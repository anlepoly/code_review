diff --git a/src/tools/qdoc/codeparser.cpp b/src/tools/qdoc/codeparser.cpp
index ea3bdc2..5fb4909 100644
--- a/src/tools/qdoc/codeparser.cpp
+++ b/src/tools/qdoc/codeparser.cpp
@@ -239,11 +239,10 @@ void CodeParser::processCommonMetaCommand(const Location& location,
     else if (command == COMMAND_DEPRECATED) {
         node->setStatus(Node::Deprecated);
     }
-    else if (command == COMMAND_INGROUP) {
-        qdb_->addToGroup(node, arg.first);
-    }
-    else if (command == COMMAND_INPUBLICGROUP) {
-        qdb_->addToPublicGroup(node, arg.first);
+    else if ((command == COMMAND_INGROUP) || (command == COMMAND_INPUBLICGROUP)) {
+        // Note: \ingroup and \inpublicgroup are now the same.
+        // Not that they were ever different.
+        DocNode* dn = qdb_->addToGroup(arg.first, node);
     }
     else if (command == COMMAND_INMODULE) {
         qdb_->addToModule(arg.first,node);
diff --git a/src/tools/qdoc/cppcodeparser.cpp b/src/tools/qdoc/cppcodeparser.cpp
index 2fc3a6c..af7d69c 100644
--- a/src/tools/qdoc/cppcodeparser.cpp
+++ b/src/tools/qdoc/cppcodeparser.cpp
@@ -478,7 +478,7 @@ Node* CppCodeParser::processTopicCommand(const Doc& doc,
         return dn;
     }
     else if (command == COMMAND_GROUP) {
-        DocNode* dn = new DocNode(qdb_->treeRoot(), arg.first, Node::Group, Node::OverviewPage);
+        DocNode* dn = qdb_->addGroup(arg.first);
         dn->setLocation(doc.startLocation());
         return dn;
     }
@@ -489,13 +489,11 @@ Node* CppCodeParser::processTopicCommand(const Doc& doc,
     }
     else if (command == COMMAND_MODULE) {
         DocNode* dn = qdb_->addModule(arg.first);
-        //DocNode* dn = new DocNode(qdb_->treeRoot(), arg.first, Node::Module, Node::OverviewPage);
         dn->setLocation(doc.startLocation());
         return dn;
     }
     else if (command == COMMAND_QMLMODULE) {
         DocNode* dn = qdb_->addQmlModule(arg.first);
-        //DocNode* dn = DocNode::lookupQmlModuleNode(qdb_->tree(), arg);
         dn->setLocation(doc.startLocation());
         return dn;
     }
diff --git a/src/tools/qdoc/ditaxmlgenerator.cpp b/src/tools/qdoc/ditaxmlgenerator.cpp
index 63adb21..b5d52bb 100644
--- a/src/tools/qdoc/ditaxmlgenerator.cpp
+++ b/src/tools/qdoc/ditaxmlgenerator.cpp
@@ -1014,9 +1014,9 @@ int DitaXmlGenerator::generateAtom(const Atom *atom,
         break;
     case Atom::AnnotatedList:
         {
-            NodeMap nodeMap;
-            qdb_->getGroup(atom->string(), nodeMap);
-            generateAnnotatedList(relative, marker, nodeMap);
+            DocNode* dn = qdb_->getGroup(atom->string());
+            if (dn)
+                generateAnnotatedList(relative, marker, dn->members());
         }
         break;
     case Atom::GeneratedList:
@@ -1042,45 +1042,6 @@ int DitaXmlGenerator::generateAtom(const Atom *atom,
                 }
             }
         }
-        else if (atom->string().contains("classesbyedition")) {
-
-            QString arg = atom->string().trimmed();
-            QString editionName = atom->string().mid(atom->string().indexOf("classesbyedition") + 16).trimmed();
-            if (editionModuleMap.contains(editionName)) {
-                QDocDatabase* qdb = QDocDatabase::qdocDB();
-                // Add all classes in the modules listed for that edition.
-                NodeMap editionClasses;
-                DocNodeMap::const_iterator i = qdb->modules().begin();
-                while (i != qdb->modules().end()) {
-                    NodeMap m;
-                    DocNode* dn = i.value();
-                    dn->getMemberClasses(m);
-                    if (!m.isEmpty())
-                        editionClasses.unite(m);
-                    m.clear();
-                    ++i;
-                }
-
-                // Add additional groups and remove groups of classes that
-                // should be excluded from the edition.
-
-                const NodeMultiMap& groups = qdb_->groups();
-                foreach (const QString &groupName, editionGroupMap[editionName]) {
-                    QList<Node *> groupClasses;
-                    if (groupName.startsWith(QLatin1Char('-'))) {
-                        groupClasses = groups.values(groupName.mid(1));
-                        foreach (const Node *node, groupClasses)
-                            editionClasses.remove(node->name());
-                    }
-                    else {
-                        groupClasses = groups.values(groupName);
-                        foreach (const Node *node, groupClasses)
-                            editionClasses.insert(node->name(), node);
-                    }
-                }
-                generateAnnotatedList(relative, marker, editionClasses);
-            }
-        }
         else if (atom->string() == "classhierarchy") {
             generateClassHierarchy(relative, qdb_->getCppClasses());
         }
@@ -1110,14 +1071,8 @@ int DitaXmlGenerator::generateAtom(const Atom *atom,
         }
         else if (atom->string() == "related") {
             const DocNode *dn = static_cast<const DocNode *>(relative);
-            if (dn && !dn->members().isEmpty()) {
-                NodeMap groupMembersMap;
-                foreach (const Node *node, dn->members()) {
-                    if (node->type() == Node::Document)
-                        groupMembersMap[node->fullName(relative)] = node;
-                }
-                generateAnnotatedList(dn, marker, groupMembersMap);
-            }
+            if (dn)
+                generateAnnotatedList(dn, marker, dn->members());
         }
         break;
     case Atom::SinceList:
@@ -2339,23 +2294,7 @@ void DitaXmlGenerator::generateDocNode(DocNode* dn, CodeMarker* marker)
             generateBody(dn, marker);
         }
         generateAlsoList(dn, marker);
-
-        if ((dn->subType() == Node::QmlModule) && !dn->members().isEmpty()) {
-            NodeMap qmlModuleMembersMap;
-            foreach (const Node* node, dn->members()) {
-                if (node->type() == Node::Document && node->subType() == Node::QmlClass)
-                    qmlModuleMembersMap[node->name()] = node;
-            }
-            generateAnnotatedList(dn, marker, qmlModuleMembersMap);
-        }
-        else if (!dn->members().isEmpty()) {
-            NodeMap groupMembersMap;
-            foreach (const Node *node, dn->members()) {
-                if (node->type() == Node::Class || node->type() == Node::Namespace)
-                    groupMembersMap[node->name()] = node;
-            }
-            generateAnnotatedList(dn, marker, groupMembersMap);
-        }
+        generateAnnotatedList(dn, marker, dn->members());
     }
     leaveSection(); // </section>
     if (!writeEndTag()) { // </body>
@@ -2706,15 +2645,15 @@ void DitaXmlGenerator::generateLowStatusMembers(const InnerNode* inner,
 /*!
   Write the XML for the class hierarchy to the current XML stream.
  */
-void DitaXmlGenerator::generateClassHierarchy(const Node* relative, const NodeMap& classMap)
+void DitaXmlGenerator::generateClassHierarchy(const Node* relative, NodeMap& classMap)
 {
     if (classMap.isEmpty())
         return;
 
     NodeMap topLevel;
-    NodeMap::ConstIterator c = classMap.constBegin();
-    while (c != classMap.constEnd()) {
-        const ClassNode* classe = static_cast<const ClassNode*>(*c);
+    NodeMap::Iterator c = classMap.begin();
+    while (c != classMap.end()) {
+        ClassNode* classe = static_cast<ClassNode*>(*c);
         if (classe->baseClasses().isEmpty())
             topLevel.insert(classe->name(), classe);
         ++c;
@@ -2732,8 +2671,7 @@ void DitaXmlGenerator::generateClassHierarchy(const Node* relative, const NodeMa
                 writeEndTag(); // </li>
         }
         else {
-            const ClassNode *child =
-                    static_cast<const ClassNode *>(*stack.top().constBegin());
+            ClassNode* child = static_cast<ClassNode*>(*stack.top().begin());
             writeStartTag(DT_li);
             generateFullName(child, relative);
             writeEndTag(); // </li>
@@ -2754,8 +2692,8 @@ void DitaXmlGenerator::generateClassHierarchy(const Node* relative, const NodeMa
 }
 
 /*!
-  Write XML for the contents of the \a nodeMap to the current
-  XML stream.
+  Output an annotated list of the nodes in \a nodeMap.
+  A two-column table is output.
  */
 void DitaXmlGenerator::generateAnnotatedList(const Node* relative,
                                              CodeMarker* marker,
@@ -2763,15 +2701,32 @@ void DitaXmlGenerator::generateAnnotatedList(const Node* relative,
 {
     if (nodeMap.isEmpty())
         return;
+    NodeList nl;
+    NodeMap::const_iterator i = nodeMap.begin();
+    while (i != nodeMap.end()) {
+        nl.append(i.value());
+        ++i;
+    }
+    generateAnnotatedList(relative, marker, nl);
+}
+
+/*!
+  Write XML for the contents of the \a nodes to the current
+  XML stream.
+ */
+void DitaXmlGenerator::generateAnnotatedList(const Node* relative,
+                                             CodeMarker* marker,
+                                             const NodeList& nodes)
+{
+    if (nodes.isEmpty())
+        return;
     writeStartTag(DT_table);
     xmlWriter().writeAttribute("outputclass","annotated");
     writeStartTag(DT_tgroup);
     xmlWriter().writeAttribute("cols","2");
     writeStartTag(DT_tbody);
 
-    foreach (const QString& name, nodeMap.keys()) {
-        const Node* node = nodeMap[name];
-
+    foreach (const Node* node, nodes) {
         if (node->status() == Node::Obsolete)
             continue;
 
@@ -2783,7 +2738,7 @@ void DitaXmlGenerator::generateAnnotatedList(const Node* relative,
         writeEndTag(); // <entry>
 
         if (!(node->type() == Node::Document)) {
-            Text brief = node->doc().trimmedBriefText(name);
+            Text brief = node->doc().trimmedBriefText(node->name());
             if (!brief.isEmpty()) {
                 writeStartTag(DT_entry);
                 writeStartTag(DT_p);
@@ -3170,7 +3125,7 @@ void DitaXmlGenerator::generateOverviewList(const Node* relative)
                 else if (!isGroupPage) {
                     // If we encounter a page that belongs to a group then
                     // we add that page to the list for that group.
-                    const DocNode* gn = qdb_->findGroupNode(QStringList(group));
+                    const DocNode* gn = qdb_->getGroup(group);
                     if (gn)
                         docNodeMap[gn].insert(sortKey, docNode);
                 }
@@ -6214,6 +6169,4 @@ void DitaXmlGenerator::generateCollisionPages()
     }
 }
 
-
-
 QT_END_NAMESPACE
diff --git a/src/tools/qdoc/ditaxmlgenerator.h b/src/tools/qdoc/ditaxmlgenerator.h
index 0c74e38..885596d 100644
--- a/src/tools/qdoc/ditaxmlgenerator.h
+++ b/src/tools/qdoc/ditaxmlgenerator.h
@@ -378,10 +378,9 @@ private:
     QString generateLowStatusMemberFile(const InnerNode* inner,
                                         CodeMarker* marker,
                                         CodeMarker::Status status);
-    void generateClassHierarchy(const Node* relative, const NodeMap& classMap);
-    void generateAnnotatedList(const Node* relative,
-                               CodeMarker* marker,
-                               const NodeMap& nodeMap);
+    void generateClassHierarchy(const Node* relative, NodeMap& classMap);
+    void generateAnnotatedList(const Node* relative, CodeMarker* marker, const NodeMap& nodeMap);
+    void generateAnnotatedList(const Node* relative, CodeMarker* marker, const NodeList& nodes);
     void generateCompactList(const Node* relative,
                              const NodeMap& classMap,
                              bool includeAlphabet,
diff --git a/src/tools/qdoc/generator.h b/src/tools/qdoc/generator.h
index a1eafa8..d0ab10a 100644
--- a/src/tools/qdoc/generator.h
+++ b/src/tools/qdoc/generator.h
@@ -56,7 +56,6 @@
 
 QT_BEGIN_NAMESPACE
 
-typedef QMap<QString, const Node*> NodeMap;
 typedef QMultiMap<QString, Node*> NodeMultiMap;
 typedef QMap<Node*, NodeMultiMap> ParentMaps;
 
diff --git a/src/tools/qdoc/htmlgenerator.cpp b/src/tools/qdoc/htmlgenerator.cpp
index 8252d8b..48b70ce 100644
--- a/src/tools/qdoc/htmlgenerator.cpp
+++ b/src/tools/qdoc/htmlgenerator.cpp
@@ -459,9 +459,9 @@ int HtmlGenerator::generateAtom(const Atom *atom, const Node *relative, CodeMark
         break;
     case Atom::AnnotatedList:
         {
-            NodeMap nodeMap;
-            qdb_->getGroup(atom->string(), nodeMap);
-            generateAnnotatedList(relative, marker, nodeMap);
+            DocNode* dn = qdb_->getGroup(atom->string());
+            if (dn)
+                generateAnnotatedList(relative, marker, dn->members());
         }
         break;
     case Atom::GeneratedList:
@@ -487,44 +487,6 @@ int HtmlGenerator::generateAtom(const Atom *atom, const Node *relative, CodeMark
                 }
             }
         }
-        else if (atom->string().contains("classesbyedition")) {
-            QString arg = atom->string().trimmed();
-            QString editionName = atom->string().mid(atom->string().indexOf("classesbyedition") + 16).trimmed();
-            if (editionModuleMap.contains(editionName)) {
-                QDocDatabase* qdb = QDocDatabase::qdocDB();
-                // Add all classes in the modules listed for that edition.
-                NodeMap editionClasses;
-                DocNodeMap::const_iterator i = qdb->modules().begin();
-                while (i != qdb->modules().end()) {
-                    NodeMap m;
-                    DocNode* dn = i.value();
-                    dn->getMemberClasses(m);
-                    if (!m.isEmpty())
-                        editionClasses.unite(m);
-                    m.clear();
-                    ++i;
-                }
-
-                // Add additional groups and remove groups of classes that
-                // should be excluded from the edition.
-
-                const NodeMultiMap& groups = qdb_->groups();
-                foreach (const QString &groupName, editionGroupMap[editionName]) {
-                    QList<Node *> groupClasses;
-                    if (groupName.startsWith(QLatin1Char('-'))) {
-                        groupClasses = groups.values(groupName.mid(1));
-                        foreach (const Node *node, groupClasses)
-                            editionClasses.remove(node->name());
-                    }
-                    else {
-                        groupClasses = groups.values(groupName);
-                        foreach (const Node *node, groupClasses)
-                            editionClasses.insert(node->name(), node);
-                    }
-                }
-                generateAnnotatedList(relative, marker, editionClasses);
-            }
-        }
         else if (atom->string() == "classhierarchy") {
             generateClassHierarchy(relative, qdb_->getCppClasses());
         }
@@ -554,14 +516,8 @@ int HtmlGenerator::generateAtom(const Atom *atom, const Node *relative, CodeMark
         }
         else if (atom->string() == "related") {
             const DocNode *dn = static_cast<const DocNode *>(relative);
-            if (dn && !dn->members().isEmpty()) {
-                NodeMap groupMembersMap;
-                foreach (const Node *node, dn->members()) {
-                    if (node->type() == Node::Document)
-                        groupMembersMap[node->fullName(relative)] = node;
-                }
-                generateAnnotatedList(dn, marker, groupMembersMap);
-            }
+            if (dn)
+                generateAnnotatedList(dn, marker, dn->members());
         }
         else if (atom->string() == "relatedinline") {
             const DocNode *dn = static_cast<const DocNode *>(relative);
@@ -1377,7 +1333,7 @@ void HtmlGenerator::generateCollisionPages()
             t += protectEnc(fullTitle);
             nm.insertMulti(t,n);
         }
-        generateAnnotatedList(ncn, marker, nm, true);
+        generateAnnotatedList(ncn, marker, nm);
 
         QList<QString> targets;
         if (!ncn->linkTargets().isEmpty()) {
@@ -1616,22 +1572,10 @@ void HtmlGenerator::generateDocNode(DocNode* dn, CodeMarker* marker)
     generateAlsoList(dn, marker);
     generateExtractionMark(dn, EndMark);
 
-    if ((dn->subType() == Node::Group) && !dn->members().isEmpty()) {
-        NodeMap groupMembersMap;
-        foreach (const Node *node, dn->members()) {
-            if (node->type() == Node::Class || node->type() == Node::Namespace)
-                groupMembersMap[node->name()] = node;
-        }
-        generateAnnotatedList(dn, marker, groupMembersMap);
-    }
-    else if ((dn->subType() == Node::QmlModule) && !dn->members().isEmpty()) {
-        NodeMap qmlModuleMembersMap;
-        foreach (const Node* node, dn->members()) {
-            if (node->type() == Node::Document && node->subType() == Node::QmlClass)
-                qmlModuleMembersMap[node->name()] = node;
-        }
-        generateAnnotatedList(dn, marker, qmlModuleMembersMap);
-    }
+    if ((dn->subType() == Node::Group))
+        generateAnnotatedList(dn, marker, dn->members());
+    else if (dn->subType() == Node::QmlModule)
+        generateAnnotatedList(dn, marker, dn->members());
 
     sections = marker->sections(dn, CodeMarker::Detailed, CodeMarker::Okay);
     s = sections.constBegin();
@@ -2202,15 +2146,15 @@ QString HtmlGenerator::generateLowStatusMemberFile(const InnerNode *inner,
     return fileName;
 }
 
-void HtmlGenerator::generateClassHierarchy(const Node *relative, const NodeMap& classMap)
+void HtmlGenerator::generateClassHierarchy(const Node *relative, NodeMap& classMap)
 {
     if (classMap.isEmpty())
         return;
 
     NodeMap topLevel;
-    NodeMap::ConstIterator c = classMap.constBegin();
-    while (c != classMap.constEnd()) {
-        const ClassNode *classe = static_cast<const ClassNode *>(*c);
+    NodeMap::Iterator c = classMap.begin();
+    while (c != classMap.end()) {
+        ClassNode *classe = static_cast<ClassNode *>(*c);
         if (classe->baseClasses().isEmpty())
             topLevel.insert(classe->name(), classe);
         ++c;
@@ -2226,8 +2170,7 @@ void HtmlGenerator::generateClassHierarchy(const Node *relative, const NodeMap&
             out() << "</ul>\n";
         }
         else {
-            const ClassNode *child =
-                    static_cast<const ClassNode *>(*stack.top().constBegin());
+            ClassNode* child = static_cast<ClassNode*>(*stack.top().begin());
             out() << "<li>";
             generateFullName(child, relative);
             out() << "</li>\n";
@@ -2246,21 +2189,36 @@ void HtmlGenerator::generateClassHierarchy(const Node *relative, const NodeMap&
     }
 }
 
+/*!
+  Output an annotated list of the nodes in \a nodeMap.
+  A two-column table is output.
+ */
+void HtmlGenerator::generateAnnotatedList(const Node* relative,
+                                          CodeMarker* marker,
+                                          const NodeMap& nodeMap)
+{
+    if (nodeMap.isEmpty())
+        return;
+    NodeList nl;
+    NodeMap::const_iterator i = nodeMap.begin();
+    while (i != nodeMap.end()) {
+        nl.append(i.value());
+        ++i;
+    }
+    generateAnnotatedList(relative, marker, nl);
+}
+
 void HtmlGenerator::generateAnnotatedList(const Node *relative,
                                           CodeMarker *marker,
-                                          const NodeMap &nodeMap,
-                                          bool allOdd)
+                                          const NodeList& nodes)
 {
     out() << "<table class=\"annotated\">\n";
-
     int row = 0;
-    foreach (const QString &name, nodeMap.keys()) {
-        const Node *node = nodeMap[name];
-
+    foreach (const Node* node, nodes) {
         if (node->status() == Node::Obsolete)
             continue;
 
-        if (allOdd || (++row % 2 == 1))
+        if (++row % 2 == 1)
             out() << "<tr class=\"odd topAlign\">";
         else
             out() << "<tr class=\"even topAlign\">";
@@ -2269,7 +2227,7 @@ void HtmlGenerator::generateAnnotatedList(const Node *relative,
         out() << "</p></td>";
 
         if (!(node->type() == Node::Document)) {
-            Text brief = node->doc().trimmedBriefText(name);
+            Text brief = node->doc().trimmedBriefText(node->name());
             if (!brief.isEmpty()) {
                 out() << "<td class=\"tblDescr\"><p>";
                 generateText(brief, node, marker);
@@ -2630,7 +2588,7 @@ void HtmlGenerator::generateOverviewList(const Node *relative)
                 else if (!isGroupPage) {
                     // If we encounter a page that belongs to a group then
                     // we add that page to the list for that group.
-                    const DocNode* gn = qdb_->findGroupNode(QStringList(group));
+                    const DocNode* gn = qdb_->getGroup(group);
                     if (gn)
                         docNodeMap[gn].insert(sortKey, docNode);
                 }
diff --git a/src/tools/qdoc/htmlgenerator.h b/src/tools/qdoc/htmlgenerator.h
index d02f50c..c24b6da 100644
--- a/src/tools/qdoc/htmlgenerator.h
+++ b/src/tools/qdoc/htmlgenerator.h
@@ -143,11 +143,9 @@ private:
     QString generateLowStatusMemberFile(const InnerNode *inner,
                                         CodeMarker *marker,
                                         CodeMarker::Status status);
-    void generateClassHierarchy(const Node *relative, const NodeMap &classMap);
-    void generateAnnotatedList(const Node *relative,
-                               CodeMarker *marker,
-                               const NodeMap &nodeMap,
-                               bool allOdd = false);
+    void generateClassHierarchy(const Node *relative, NodeMap &classMap);
+    void generateAnnotatedList(const Node* relative, CodeMarker* marker, const NodeMap& nodeMap);
+    void generateAnnotatedList(const Node* relative, CodeMarker* marker, const NodeList& nodes);
     void generateCompactList(const Node *relative,
                              const NodeMap &classMap,
                              bool includeAlphabet,
diff --git a/src/tools/qdoc/node.cpp b/src/tools/qdoc/node.cpp
index 3828709..4e891b7 100644
--- a/src/tools/qdoc/node.cpp
+++ b/src/tools/qdoc/node.cpp
@@ -170,6 +170,7 @@ Node::Node(Type type, InnerNode *parent, const QString& name)
       pageType_(NoPageType),
       status_(Commendable),
       indexNodeFlag_(false),
+      seen_(true),
       parent_(parent),
       relatesTo_(0),
       name_(name)
diff --git a/src/tools/qdoc/node.h b/src/tools/qdoc/node.h
index 05133ca..f93e777 100644
--- a/src/tools/qdoc/node.h
+++ b/src/tools/qdoc/node.h
@@ -62,7 +62,7 @@ class QmlClassNode;
 class QDocDatabase;
 
 typedef QList<Node*> NodeList;
-typedef QMap<QString, const Node*> NodeMap;
+typedef QMap<QString, Node*> NodeMap;
 typedef QMultiMap<QString, Node*> NodeMultiMap;
 typedef QMultiMap<QString, const ExampleNode*> ExampleNodeMap;
 typedef QList<QPair<QString,QString> > ImportList;
@@ -180,6 +180,8 @@ public:
     void setParent(InnerNode* n) { parent_ = n; }
     void setIndexNodeFlag() { indexNodeFlag_ = true; }
     virtual void setOutputFileName(const QString& ) { }
+    void markSeen() { seen_ = true; }
+    void markNotSeen() { seen_ = false; }
 
     virtual bool isInnerNode() const = 0;
     virtual bool isLeaf() const { return false; }
@@ -193,6 +195,8 @@ public:
     virtual bool isQmlPropertyGroup() const { return false; }
     virtual bool isCollisionNode() const { return false; }
     virtual bool isAttached() const { return false; }
+    virtual bool isGroup() const { return false; }
+    virtual void addMember(Node* ) { }
     virtual bool hasMembers() const { return false; }
     virtual bool hasNamespaces() const { return false; }
     virtual bool hasClasses() const { return false; }
@@ -203,6 +207,7 @@ public:
     virtual void getMemberClasses(NodeMap& ) { }
     bool isInternal() const;
     bool isIndexNode() const { return indexNodeFlag_; }
+    bool wasSeen() const { return seen_; }
     Type type() const { return nodeType_; }
     virtual SubType subType() const { return NoSubType; }
     InnerNode* parent() const { return parent_; }
@@ -271,6 +276,7 @@ private:
     PageType pageType_;
     Status status_;
     bool indexNodeFlag_;
+    bool seen_;
 
     InnerNode* parent_;
     InnerNode* relatesTo_;
@@ -326,7 +332,7 @@ public:
     const NodeList & childNodes() const { return children_; }
     const NodeList & relatedNodes() const { return related_; }
 
-    void addMember(Node* node) { members_.append(node); }
+    virtual void addMember(Node* node) { members_.append(node); }
     const NodeList& members() const { return members_; }
     virtual bool hasMembers() const;
     virtual bool hasNamespaces() const;
@@ -475,6 +481,7 @@ public:
     virtual QString imageFileName() const { return QString(); }
     virtual QString nameForLists() const { return title(); }
     virtual void setImageFileName(const QString& ) { }
+    virtual bool isGroup() const { return (subType() == Node::Group); }
     virtual bool isQmlPropertyGroup() const { return (nodeSubtype_ == QmlPropertyGroup); }
     virtual bool hasProperty(const QString& ) const;
 
diff --git a/src/tools/qdoc/qdocdatabase.cpp b/src/tools/qdoc/qdocdatabase.cpp
index d5dbb84..fa5b2c0 100644
--- a/src/tools/qdoc/qdocdatabase.cpp
+++ b/src/tools/qdoc/qdocdatabase.cpp
@@ -106,6 +106,12 @@ void QDocDatabase::destroyQdocDB()
 }
 
 /*!
+  \fn const DocNodeMap& QDocDatabase::groups() const
+  Returns a const reference to the collection of all
+  group nodes.
+*/
+
+/*!
   \fn const DocNodeMap& QDocDatabase::modules() const
   Returns a const reference to the collection of all
   module nodes.
@@ -118,15 +124,116 @@ void QDocDatabase::destroyQdocDB()
 */
 
 /*!
+  Find the group node named \a name and return a pointer
+  to it. If a matching node is not found, return 0.
+ */
+DocNode* QDocDatabase::getGroup(const QString& name)
+{
+    DocNodeMap::const_iterator i = groups_.find(name);
+    if (i != groups_.end())
+        return i.value();
+    return 0;
+}
+
+/*!
+  Find the group node named \a name and return a pointer
+  to it. If a matching node is not found, add a new group
+  node named \a name and return a pointer to that one.
+
+  If a new group node is added, its parent is the tree root,
+  and the new group node is marked \e{not seen}.
+ */
+DocNode* QDocDatabase::findGroup(const QString& name)
+{
+    DocNodeMap::const_iterator i = groups_.find(name);
+    if (i != groups_.end())
+        return i.value();
+    DocNode* dn = new DocNode(tree_->root(), name, Node::Group, Node::OverviewPage);
+    dn->markNotSeen();
+    groups_.insert(name,dn);
+    if (!masterMap_.contains(name,dn))
+        masterMap_.insert(name,dn);
+    return dn;
+}
+
+/*!
+  Find the module node named \a name and return a pointer
+  to it. If a matching node is not found, add a new module
+  node named \a name and return a pointer to that one.
+
+  If a new module node is added, its parent is the tree root,
+  and the new module node is marked \e{not seen}.
+ */
+DocNode* QDocDatabase::findModule(const QString& name)
+{
+    DocNodeMap::const_iterator i = modules_.find(name);
+    if (i != modules_.end())
+        return i.value();
+    DocNode* dn = new DocNode(tree_->root(), name, Node::Module, Node::OverviewPage);
+    dn->markNotSeen();
+    modules_.insert(name,dn);
+    if (!masterMap_.contains(name,dn))
+        masterMap_.insert(name,dn);
+    return dn;
+}
+
+/*!
+  Find the QML module node named \a name and return a pointer
+  to it. If a matching node is not found, add a new QML module
+  node named \a name and return a pointer to that one.
+
+  If a new QML module node is added, its parent is the tree root,
+  and the new QML module node is marked \e{not seen}.
+ */
+DocNode* QDocDatabase::findQmlModule(const QString& name)
+{
+    QStringList dotSplit;
+    QStringList blankSplit = name.split(QLatin1Char(' '));
+    QString qmid = blankSplit[0];
+    if (blankSplit.size() > 1) {
+        dotSplit = blankSplit[1].split(QLatin1Char('.'));
+        qmid += dotSplit[0];
+    }
+    DocNode* dn = 0;
+    if (qmlModules_.contains(qmid))
+        return qmlModules_.value(qmid);
+    dn = new DocNode(tree_->root(), name, Node::QmlModule, Node::OverviewPage);
+    dn->markNotSeen();
+    dn->setQmlModuleInfo(name);
+    qmlModules_.insert(qmid,dn);
+    masterMap_.insert(qmid,dn);
+    masterMap_.insert(dn->name(),dn);
+    return dn;
+}
+
+/*!
+  Looks up the group node named \a name in the collection
+  of all group nodes. If a match is found, a pointer to the
+  node is returned. Otherwise, a new group node named \a name
+  is created and inserted into the collection, and the pointer
+  to that node is returned. The group node is marked \e{seen}
+  in either case.
+ */
+DocNode* QDocDatabase::addGroup(const QString& name)
+{
+    DocNode* group = findGroup(name);
+    group->markSeen();
+    return group;
+}
+
+/*!
   Looks up the module node named \a name in the collection
   of all module nodes. If a match is found, a pointer to the
   node is returned. Otherwise, a new module node named \a name
   is created and inserted into the collection, and the pointer
-  to that node is returned.
+  to that node is returned. The module node is marked \e{seen}
+  in either case.
  */
 DocNode* QDocDatabase::addModule(const QString& name)
 {
-    return findModule(name,true);
+    DocNode* module = findModule(name);
+    module->markSeen();
+    return module;
 }
 
 /*!
@@ -134,38 +241,59 @@ DocNode* QDocDatabase::addModule(const QString& name)
   of all QML module nodes. If a match is found, a pointer to the
   node is returned. Otherwise, a new QML module node named \a name
   is created and inserted into the collection, and the pointer
-  to that node is returned.
+  to that node is returned. The QML module node is marked \e{seen}
+  in either case.
  */
 DocNode* QDocDatabase::addQmlModule(const QString& name)
 {
-    return findQmlModule(name,true);
+    DocNode* qmlModule = findQmlModule(name);
+    qmlModule->markSeen();
+    return qmlModule;
 }
 
 /*!
-  Looks up the C++ module named \a moduleName. If it isn't
-  there, create it. Then append \a node to the module's child
-  list. The parent of \a node is not changed by this function.
-  Returns the module node.
+  Looks up the group node named \a name in the collection
+  of all group nodes. If a match is not found, a new group
+  node named \a name is created and inserted into the collection.
+  Then append \a node to the group's members list, and append the
+  group node to the member list of the \a node. The parent of the
+  \a node is not changed by this function. Returns a pointer to
+  the group node.
  */
-DocNode* QDocDatabase::addToModule(const QString& moduleName, Node* node)
+DocNode* QDocDatabase::addToGroup(const QString& name, Node* node)
 {
-    DocNode* dn = findModule(moduleName,true);
+    DocNode* dn = findGroup(name);
     dn->addMember(node);
-    node->setModuleName(moduleName);
+    node->addMember(dn);
     return dn;
 }
 
 /*!
-  Looks up the QML module named \a qmlModuleName. If it isn't
-  there, create it. Then append \a node to the module's child
+  Looks up the module node named \a name in the collection
+  of all module nodes. If a match is not found, a new module
+  node named \a name is created and inserted into the collection.
+  Then append \a node to the module's members list. The parent of
+  \a node is not changed by this function. Returns the module node.
+ */
+DocNode* QDocDatabase::addToModule(const QString& name, Node* node)
+{
+    DocNode* dn = findModule(name);
+    dn->addMember(node);
+    node->setModuleName(name);
+    return dn;
+}
+
+/*!
+  Looks up the QML module named \a name. If it isn't there,
+  create it. Then append \a node to the QML module's member
   list. The parent of \a node is not changed by this function.
   Returns a pointer to the QML module node.
  */
-DocNode* QDocDatabase::addToQmlModule(const QString& qmlModuleName, Node* node)
+DocNode* QDocDatabase::addToQmlModule(const QString& name, Node* node)
 {
-    DocNode* dn = findQmlModule(qmlModuleName,true);
+    DocNode* dn = findQmlModule(name);
     dn->addMember(node);
-    node->setQmlModuleInfo(qmlModuleName);
+    node->setQmlModuleInfo(name);
     if (node->subType() == Node::QmlClass) {
         QString t = node->qmlModuleIdentifier() + "::" + node->name();
         QmlClassNode* n = static_cast<QmlClassNode*>(node);
@@ -180,64 +308,6 @@ DocNode* QDocDatabase::addToQmlModule(const QString& qmlModuleName, Node* node)
 }
 
 /*!
-  Find the module node named \a name and return a pointer
-  to it. If a matching node is not found and \a addIfNotFound
-  is true, add a new module node named \a name and return
-  a pointer to that one. Otherwise, return 0.
-
-  If a new module node is added, its parent is the tree root,
-  but the new module node is not added to the child list of the
-  tree root.
- */
-DocNode* QDocDatabase::findModule(const QString& name, bool addIfNotFound)
-{
-    DocNodeMap::const_iterator i = modules_.find(name);
-    if (i != modules_.end()) {
-        return i.value();
-    }
-    if (addIfNotFound) {
-        DocNode* dn = new DocNode(tree_->root(), name, Node::Module, Node::OverviewPage);
-        modules_.insert(name,dn);
-        if (!masterMap_.contains(name,dn))
-            masterMap_.insert(name,dn);
-        return dn;
-    }
-    return 0;
-}
-
-/*!
-  Find the QML module node named \a name and return a pointer
-  to it. If a matching node is not found and \a addIfNotFound
-  is true, add a new QML module node named \a name and return
-  a pointer to that one. Otherwise, return 0.
-
-  If a new QML module node is added, its parent is the tree root,
-  but the new QML module node is not added to the child list of
-  the tree root.
- */
-DocNode* QDocDatabase::findQmlModule(const QString& name, bool addIfNotFound)
-{
-    QStringList dotSplit;
-    QStringList blankSplit = name.split(QLatin1Char(' '));
-    QString qmid = blankSplit[0];
-    if (blankSplit.size() > 1) {
-        dotSplit = blankSplit[1].split(QLatin1Char('.'));
-        qmid += dotSplit[0];
-    }
-    DocNode* dn = 0;
-    if (qmlModules_.contains(qmid))
-        dn = qmlModules_.value(qmid);
-    else if (addIfNotFound) {
-        dn = new DocNode(tree_->root(), name, Node::QmlModule, Node::OverviewPage);
-        dn->setQmlModuleInfo(name);
-        qmlModules_.insert(qmid,dn);
-        masterMap_.insert(qmid,dn);
-        masterMap_.insert(dn->name(),dn);
-    }
-    return dn;
-}
-
-/*!
   Looks up the QML type node identified by the Qml module id
   \a qmid and QML type \a name and returns a pointer to the
   QML type node. The key is \a qmid + "::" + \a name.
@@ -553,29 +623,11 @@ const NodeMultiMap& QDocDatabase::getSinceMap(const QString& key) const
   to generating documentation.
  */
 void QDocDatabase::resolveIssues() {
-    tree_->resolveGroups();
     resolveTargets(treeRoot());
     tree_->resolveCppToQmlLinks();
 }
 
 /*!
-  Look up group \a name in the map of groups. If found, populate
-  the node map \a group with the classes in the group that are
-  not marked internal or private.
- */
-void QDocDatabase::getGroup(const QString& name, NodeMap& group) const
-{
-    group.clear();
-    NodeList values = tree_->groups().values(name);
-    for (int i=0; i<values.size(); ++i) {
-        const Node* n = values.at(i);
-        if ((n->status() != Node::Internal) && (n->access() != Node::Private)) {
-            group.insert(n->nameForLists(),n);
-        }
-    }
-}
-
-/*!
   Searches the \a database for a node named \a target and returns
   a pointer to it if found.
  */
diff --git a/src/tools/qdoc/qdocdatabase.h b/src/tools/qdoc/qdocdatabase.h
index 85f5c20..2a91693 100644
--- a/src/tools/qdoc/qdocdatabase.h
+++ b/src/tools/qdoc/qdocdatabase.h
@@ -85,14 +85,23 @@ class QDocDatabase
     static void destroyQdocDB();
     ~QDocDatabase();
 
+    const DocNodeMap& groups() const { return groups_; }
     const DocNodeMap& modules() const { return modules_; }
     const DocNodeMap& qmlModules() const { return qmlModules_; }
+
+    DocNode* getGroup(const QString& name);
+    DocNode* findGroup(const QString& name);
+    DocNode* findModule(const QString& name);
+    DocNode* findQmlModule(const QString& name);
+
+    DocNode* addGroup(const QString& name);
     DocNode* addModule(const QString& name);
     DocNode* addQmlModule(const QString& name);
+
+    DocNode* addToGroup(const QString& name, Node* node);
     DocNode* addToModule(const QString& name, Node* node);
-    DocNode* addToQmlModule(const QString& moduleName, Node* node);
-    DocNode* findModule(const QString& qmlModuleName, bool addIfNotFound = false);
-    DocNode* findQmlModule(const QString& name, bool addIfNotFound = false);
+    DocNode* addToQmlModule(const QString& name, Node* node);
+
     QmlClassNode* findQmlType(const QString& qmid, const QString& name) const;
 
     void findAllClasses(const InnerNode *node);
@@ -112,9 +121,6 @@ class QDocDatabase
     NodeMap& getQmlTypes() { return qmlClasses_; }
     NodeMapMap& getFunctionIndex() { return funcIndex_; }
     TextToNodeMap& getLegaleseTexts() { return legaleseTexts_; }
-    const NodeMultiMap& groups() const { return tree_->groups(); }
-    const NodeList getGroup(const QString& name) const { return tree_->groups().values(name); }
-    void getGroup(const QString& name, NodeMap& group) const;
     const NodeMap& getClassMap(const QString& key) const;
     const NodeMap& getQmlTypeMap(const QString& key) const;
     const NodeMultiMap& getSinceMap(const QString& key) const;
@@ -131,8 +137,6 @@ class QDocDatabase
     NamespaceNode* treeRoot() { return tree_->root(); }
     void resolveInheritance() { tree_->resolveInheritance(); }
     void resolveIssues();
-    void addToGroup(Node* node, const QString& group) { tree_->addToGroup(node, group); }
-    void addToPublicGroup(Node* node, const QString& group) { tree_->addToPublicGroup(node, group); }
     void fixInheritance() { tree_->fixInheritance(); }
     void resolveProperties() { tree_->resolveProperties(); }
 
@@ -140,7 +144,6 @@ class QDocDatabase
     ClassNode* findClassNode(const QStringList& path) { return tree_->findClassNode(path); }
     NamespaceNode* findNamespaceNode(const QStringList& path) { return tree_->findNamespaceNode(path); }
 
-    DocNode* findGroupNode(const QStringList& path) { return tree_->findGroupNode(path); }
     NameCollisionNode* findCollisionNode(const QString& name) const {
         return tree_->findCollisionNode(name);
     }
@@ -205,6 +208,7 @@ class QDocDatabase
     QString                 version_;
     QDocMultiMap            masterMap_;
     Tree*                   tree_;
+    DocNodeMap              groups_;
     DocNodeMap              modules_;
     DocNodeMap              qmlModules_;
     QmlTypeMap              qmlTypeMap_;
diff --git a/src/tools/qdoc/qdocindexfiles.cpp b/src/tools/qdoc/qdocindexfiles.cpp
index 3f79675..3a88504 100644
--- a/src/tools/qdoc/qdocindexfiles.cpp
+++ b/src/tools/qdoc/qdocindexfiles.cpp
@@ -164,11 +164,11 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
 {
     QString name = element.attribute("name");
     QString href = element.attribute("href");
-    Node* section;
+    Node* node;
     Location location;
 
     if (element.nodeName() == "namespace") {
-        section = new NamespaceNode(parent, name);
+        node = new NamespaceNode(parent, name);
 
         if (!indexUrl.isEmpty())
             location = Location(indexUrl + QLatin1Char('/') + name.toLower() + ".html");
@@ -177,8 +177,8 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
 
     }
     else if (element.nodeName() == "class") {
-        section = new ClassNode(parent, name);
-        basesList_.append(QPair<ClassNode*,QString>(static_cast<ClassNode*>(section),
+        node = new ClassNode(parent, name);
+        basesList_.append(QPair<ClassNode*,QString>(static_cast<ClassNode*>(node),
                                                    element.attribute("bases")));
 
         if (!indexUrl.isEmpty())
@@ -196,7 +196,7 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
             location = Location(indexUrl + QLatin1Char('/') + name);
         else if (!indexUrl.isNull())
             location = Location(name);
-        section = qcn;
+        node = qcn;
     }
     else if (element.nodeName() == "qmlbasictype") {
         QmlBasicTypeNode* qbtn = new QmlBasicTypeNode(parent, name);
@@ -207,7 +207,7 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
             location = Location(indexUrl + QLatin1Char('/') + name);
         else if (!indexUrl.isNull())
             location = Location(name);
-        section = qbtn;
+        node = qbtn;
     }
     else if (element.nodeName() == "page") {
         Node::SubType subtype;
@@ -266,7 +266,7 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
         else if (!indexUrl.isNull())
             location = Location(name);
 
-        section = docNode;
+        node = docNode;
 
     }
     else if (element.nodeName() == "enum") {
@@ -284,11 +284,11 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
             child = child.nextSiblingElement("value");
         }
 
-        section = enumNode;
+        node = enumNode;
 
     }
     else if (element.nodeName() == "typedef") {
-        section = new TypedefNode(parent, name);
+        node = new TypedefNode(parent, name);
 
         if (!indexUrl.isEmpty())
             location = Location(indexUrl + QLatin1Char('/') + parent->name().toLower() + ".html");
@@ -297,7 +297,7 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
 
     }
     else if (element.nodeName() == "property") {
-        section = new PropertyNode(parent, name);
+        node = new PropertyNode(parent, name);
 
         if (!indexUrl.isEmpty())
             location = Location(indexUrl + QLatin1Char('/') + parent->name().toLower() + ".html");
@@ -363,14 +363,14 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
             child = child.nextSiblingElement("parameter");
         }
 
-        section = functionNode;
+        node = functionNode;
         if (!indexUrl.isEmpty())
             location =  Location(indexUrl + QLatin1Char('/') + parent->name().toLower() + ".html");
         else if (!indexUrl.isNull())
             location = Location(parent->name().toLower() + ".html");
     }
     else if (element.nodeName() == "variable") {
-        section = new VariableNode(parent, name);
+        node = new VariableNode(parent, name);
         if (!indexUrl.isEmpty())
             location = Location(indexUrl + QLatin1Char('/') + parent->name().toLower() + ".html");
         else if (!indexUrl.isNull())
@@ -393,84 +393,96 @@ void QDocIndexFiles::readIndexSection(const QDomElement& element,
 
     QString access = element.attribute("access");
     if (access == "public")
-        section->setAccess(Node::Public);
+        node->setAccess(Node::Public);
     else if (access == "protected")
-        section->setAccess(Node::Protected);
+        node->setAccess(Node::Protected);
     else if (access == "private")
-        section->setAccess(Node::Private);
+        node->setAccess(Node::Private);
     else
-        section->setAccess(Node::Public);
+        node->setAccess(Node::Public);
 
     if ((element.nodeName() != "page") &&
             (element.nodeName() != "qmlclass") &&
             (element.nodeName() != "qmlbasictype")) {
         QString threadSafety = element.attribute("threadsafety");
         if (threadSafety == "non-reentrant")
-            section->setThreadSafeness(Node::NonReentrant);
+            node->setThreadSafeness(Node::NonReentrant);
         else if (threadSafety == "reentrant")
-            section->setThreadSafeness(Node::Reentrant);
+            node->setThreadSafeness(Node::Reentrant);
         else if (threadSafety == "thread safe")
-            section->setThreadSafeness(Node::ThreadSafe);
+            node->setThreadSafeness(Node::ThreadSafe);
         else
-            section->setThreadSafeness(Node::UnspecifiedSafeness);
+            node->setThreadSafeness(Node::UnspecifiedSafeness);
     }
     else
-        section->setThreadSafeness(Node::UnspecifiedSafeness);
+        node->setThreadSafeness(Node::UnspecifiedSafeness);
 
     QString status = element.attribute("status");
     if (status == "compat")
-        section->setStatus(Node::Compat);
+        node->setStatus(Node::Compat);
     else if (status == "obsolete")
-        section->setStatus(Node::Obsolete);
+        node->setStatus(Node::Obsolete);
     else if (status == "deprecated")
-        section->setStatus(Node::Deprecated);
+        node->setStatus(Node::Deprecated);
     else if (status == "preliminary")
-        section->setStatus(Node::Preliminary);
+        node->setStatus(Node::Preliminary);
     else if (status == "commendable")
-        section->setStatus(Node::Commendable);
+        node->setStatus(Node::Commendable);
     else if (status == "internal")
-        section->setStatus(Node::Internal);
+        node->setStatus(Node::Internal);
     else if (status == "main")
-        section->setStatus(Node::Main);
+        node->setStatus(Node::Main);
     else
-        section->setStatus(Node::Commendable);
+        node->setStatus(Node::Commendable);
 
     QString moduleName = element.attribute("module");
     if (!moduleName.isEmpty())
-        section->setModuleName(moduleName);
+        node->setModuleName(moduleName);
     if (!indexUrl.isEmpty()) {
-        section->setUrl(indexUrl + QLatin1Char('/') + href);
+        node->setUrl(indexUrl + QLatin1Char('/') + href);
     }
 
     QString since = element.attribute("since");
     if (!since.isEmpty()) {
-        section->setSince(since);
+        node->setSince(since);
+    }
+
+    QString groupsAttr = element.attribute("groups");
+    if (!groupsAttr.isEmpty()) {
+        QStringList groupNames = groupsAttr.split(" ");
+        for (int i=0; i<groupNames.size(); ++i) {
+            DocNode* dn = qdb_->findGroup(groupNames[i]);
+            if (dn)
+                dn->addMember(node);
+            else {
+                qDebug() << "NODE:" << node->name() << "GROUPS:" << groupNames;
+                qDebug() << "DID NOT FIND GROUP:" << dn->name() << "for:" << node->name();
+            }
+        }
     }
 
     // Create some content for the node.
     QSet<QString> emptySet;
     Doc doc(location, location, " ", emptySet); // placeholder
-    section->setDoc(doc);
-    section->setIndexNodeFlag();
-
-    if (section->isInnerNode()) {
-        InnerNode* inner = static_cast<InnerNode*>(section);
-        if (inner) {
-            QDomElement child = element.firstChildElement();
-            while (!child.isNull()) {
-                if (element.nodeName() == "class")
-                    readIndexSection(child, inner, indexUrl);
-                else if (element.nodeName() == "qmlclass")
-                    readIndexSection(child, inner, indexUrl);
-                else if (element.nodeName() == "page")
-                    readIndexSection(child, inner, indexUrl);
-                else if (element.nodeName() == "namespace" && !name.isEmpty())
-                    // The root node in the index is a namespace with an empty name.
-                    readIndexSection(child, inner, indexUrl);
-                else
-                    readIndexSection(child, parent, indexUrl);
-                child = child.nextSiblingElement();
-            }
+    node->setDoc(doc);
+    node->setIndexNodeFlag();
+
+    if (node->isInnerNode()) {
+        InnerNode* inner = static_cast<InnerNode*>(node);
+        QDomElement child = element.firstChildElement();
+        while (!child.isNull()) {
+            if (element.nodeName() == "class")
+                readIndexSection(child, inner, indexUrl);
+            else if (element.nodeName() == "qmlclass")
+                readIndexSection(child, inner, indexUrl);
+            else if (element.nodeName() == "page")
+                readIndexSection(child, inner, indexUrl);
+            else if (element.nodeName() == "namespace" && !name.isEmpty())
+                // The root node in the index is a namespace with an empty name.
+                readIndexSection(child, inner, indexUrl);
+            else
+                readIndexSection(child, parent, indexUrl);
+            child = child.nextSiblingElement();
         }
     }
 }
@@ -498,6 +510,38 @@ void QDocIndexFiles::resolveIndex()
 }
 
 /*!
+  Normally this is used for writing the \e groups attribute,
+  but it can be used for writing any attribute with a list
+  value that comes from some subset of the members of \a n.
+
+  \note The members of \a n are \e not the children of \a n.
+
+  The names we want to include are the names of the members
+  of \a n that have node type \a t and node subtype \a st.
+  The attribute name is \a attr. The names are joined with
+  the space character and written with \a writer.
+ */
+void QDocIndexFiles::writeMembersAttribute(QXmlStreamWriter& writer,
+                                           const InnerNode* n,
+                                           Node::Type t,
+                                           Node::SubType st,
+                                           const QString& attr)
+{
+    const NodeList& members = n->members();
+    if (!members.isEmpty()) {
+        QStringList names;
+        NodeList::ConstIterator i = members.constBegin();
+        while (i != members.constEnd()) {
+            if ((*i)->type() == t && (*i)->subType() == st)
+                names.append((*i)->name());
+            ++i;
+        }
+        if (!names.isEmpty())
+            writer.writeAttribute(attr, names.join(" "));
+    }
+}
+
+/*!
   Generate the index section with the given \a writer for the \a node
   specified, returning true if an element was written; otherwise returns
   false.
@@ -664,11 +708,16 @@ bool QDocIndexFiles::generateIndexSection(QXmlStreamWriter& writer,
             writer.writeAttribute("bases", QStringList(baseStrings.toList()).join(","));
             if (!node->moduleName().isEmpty())
                 writer.writeAttribute("module", node->moduleName());
+            writeMembersAttribute(writer, classNode, Node::Document, Node::Group, "groups");
         }
         break;
     case Node::Namespace:
-            if (!node->moduleName().isEmpty())
-                writer.writeAttribute("module", node->moduleName());
+        {
+            const NamespaceNode* namespaceNode = static_cast<const NamespaceNode*>(node);
+            if (!namespaceNode->moduleName().isEmpty())
+                writer.writeAttribute("module", namespaceNode->moduleName());
+            writeMembersAttribute(writer, namespaceNode, Node::Document, Node::Group, "groups");
+        }
         break;
     case Node::Document:
         {
@@ -691,8 +740,18 @@ bool QDocIndexFiles::generateIndexSection(QXmlStreamWriter& writer,
                 writer.writeAttribute("subtype", "file");
                 break;
             case Node::Group:
-                writer.writeAttribute("subtype", "group");
-                writeModuleName = true;
+                {
+                    writer.writeAttribute("subtype", "group");
+                    writer.writeAttribute("seen", docNode->wasSeen() ? "true" : "false");
+                    // Groups contain information about their group members.
+                    const NodeList& members = docNode->members();
+                    QStringList names;
+                    foreach (const Node* member, members) {
+                        names.append(member->name());
+                    }
+                    writer.writeAttribute("members", names.join(" "));
+                    writeModuleName = true;
+                }
                 break;
             case Node::Module:
                 writer.writeAttribute("subtype", "module");
@@ -720,6 +779,7 @@ bool QDocIndexFiles::generateIndexSection(QXmlStreamWriter& writer,
             if (!node->moduleName().isEmpty() && writeModuleName) {
                 writer.writeAttribute("module", node->moduleName());
             }
+            writeMembersAttribute(writer, docNode, Node::Document, Node::Group, "groups");
         }
         break;
     case Node::Function:
@@ -1025,7 +1085,10 @@ void QDocIndexFiles::generateIndexSections(QXmlStreamWriter& writer,
                                            Node* node,
                                            bool generateInternalNodes)
 {
-    if (generateIndexSection(writer, node, generateInternalNodes)) {
+    /*
+      Note that the groups are written after all the other nodes.
+     */
+    if (!node->isGroup() && generateIndexSection(writer, node, generateInternalNodes)) {
         if (node->isInnerNode()) {
             const InnerNode* inner = static_cast<const InnerNode*>(node);
 
@@ -1082,6 +1145,22 @@ void QDocIndexFiles::generateIndex(const QString& fileName,
 
     generateIndexSections(writer, qdb_->treeRoot(), generateInternalNodes);
 
+    /*
+      We wait until the end of the index file to output the group elements.
+      By waiting until the end, when we read each group element, its members
+      will have already been created. It is then only necessary to create
+      the group page and add each member to its member list.
+     */
+    const DocNodeMap& groups = qdb_->groups();
+    if (!groups.isEmpty()) {
+        DocNodeMap::ConstIterator g = groups.constBegin();
+        while (g != groups.constEnd()) {
+            if (generateIndexSection(writer, g.value(), generateInternalNodes))
+                writer.writeEndElement();
+            ++g;
+        }
+    }
+
     writer.writeEndElement(); // INDEX
     writer.writeEndElement(); // QDOCINDEX
     writer.writeEndDocument();
diff --git a/src/tools/qdoc/qdocindexfiles.h b/src/tools/qdoc/qdocindexfiles.h
index c53e62d..02aaf29 100644
--- a/src/tools/qdoc/qdocindexfiles.h
+++ b/src/tools/qdoc/qdocindexfiles.h
@@ -76,6 +76,11 @@ class QDocIndexFiles
     void resolveIndex();
     bool generateIndexSection(QXmlStreamWriter& writer, Node* node, bool generateInternalNodes = false);
     void generateIndexSections(QXmlStreamWriter& writer, Node* node, bool generateInternalNodes = false);
+    void writeMembersAttribute(QXmlStreamWriter& writer,
+                               const InnerNode* n,
+                               Node::Type t,
+                               Node::SubType st,
+                               const QString& attr);
 
  private:
     static QDocIndexFiles* qdocIndexFiles_;
diff --git a/src/tools/qdoc/qmlvisitor.cpp b/src/tools/qdoc/qmlvisitor.cpp
index 8181cbc..63a69ee 100644
--- a/src/tools/qdoc/qmlvisitor.cpp
+++ b/src/tools/qdoc/qmlvisitor.cpp
@@ -77,7 +77,6 @@ QT_BEGIN_NAMESPACE
 #define COMMAND_QMLDEFAULT              Doc::alias(QLatin1String("default"))
 #define COMMAND_QMLREADONLY             Doc::alias(QLatin1String("readonly"))
 #define COMMAND_QMLBASICTYPE            Doc::alias(QLatin1String("qmlbasictype"))
-#define COMMAND_QMLMODULE               Doc::alias(QLatin1String("qmlmodule"))
 
 /*!
   The constructor stores all the parameters in local data members.
@@ -345,7 +344,7 @@ void QmlDocVisitor::applyMetacommands(QQmlJS::AST::SourceLocation,
             else if ((command == COMMAND_INGROUP) && !args.isEmpty()) {
                 ArgList::ConstIterator argsIter = args.constBegin();
                 while (argsIter != args.constEnd()) {
-                    QDocDatabase::qdocDB()->addToGroup(node, argsIter->first);
+                    QDocDatabase::qdocDB()->addToGroup(argsIter->first, node);
                     ++argsIter;
                 }
             }
diff --git a/src/tools/qdoc/tree.cpp b/src/tools/qdoc/tree.cpp
index c94179b..c622fb9 100644
--- a/src/tools/qdoc/tree.cpp
+++ b/src/tools/qdoc/tree.cpp
@@ -398,41 +398,6 @@ void Tree::addPropertyFunction(PropertyNode* property,
 }
 
 /*!
-  This function adds the \a node to the \a group. The group
-  can be listed anywhere using the \e{annotated list} command.
- */
-void Tree::addToGroup(Node* node, const QString& group)
-{
-    groupMap.insert(group, node);
-}
-
-/*!
-  Returns the group map.
- */
-const NodeMultiMap& Tree::groups() const
-{
-    return groupMap;
-}
-
-/*!
-  This function adds the \a group name to the list of groups
-  for the \a node name. It also adds the \a node to the \a group.
- */
-void Tree::addToPublicGroup(Node* node, const QString& group)
-{
-    publicGroupMap.insert(node->name(), group);
-    addToGroup(node, group);
-}
-
-/*!
-  Returns the public group map.
- */
-QMultiMap<QString, QString> Tree::publicGroups() const
-{
-    return publicGroupMap;
-}
-
-/*!
  */
 void Tree::resolveInheritance(NamespaceNode* rootNode)
 {
@@ -548,23 +513,6 @@ void Tree::resolveInheritance(int pass, ClassNode* classe)
 }
 
 /*!
-  For each node in the group map, add the node to the appropriate
-  group node.
- */
-void Tree::resolveGroups()
-{
-    NodeMultiMap::const_iterator i;
-    for (i = groupMap.constBegin(); i != groupMap.constEnd(); ++i) {
-        if (i.value()->access() == Node::Private)
-            continue;
-
-        DocNode* n = findGroupNode(QStringList(i.key()));
-        if (n)
-            n->addMember(i.value());
-    }
-}
-
-/*!
   For each QML class node that points to a C++ class node,
   follow its C++ class node pointer and set the C++ class
   node's QML class node pointer back to the QML class node.
@@ -787,19 +735,6 @@ NamespaceNode* Tree::findNamespaceNode(const QStringList& path)
 }
 
 /*!
-  Find the Group node named \a path. Begin the search at the
-  \a start node. If the \a start node is 0, begin the search
-  at the root of the tree. Only a Group node named \a path is
-  acceptible. If one is not found, 0 is returned.
- */
-DocNode* Tree::findGroupNode(const QStringList& path, Node* start)
-{
-    if (!start)
-        start = const_cast<NamespaceNode*>(root());
-    return static_cast<DocNode*>(findNodeRecursive(path, 0, start, Node::Document, Node::Group));
-}
-
-/*!
   Find the Qml module node named \a path. Begin the search at the
   \a start node. If the \a start node is 0, begin the search
   at the root of the tree. Only a Qml module node named \a path is
diff --git a/src/tools/qdoc/tree.h b/src/tools/qdoc/tree.h
index 2066def..ac4f168 100644
--- a/src/tools/qdoc/tree.h
+++ b/src/tools/qdoc/tree.h
@@ -85,7 +85,6 @@ class Tree
     ClassNode* findClassNode(const QStringList& path, Node* start = 0);
     QmlClassNode* findQmlTypeNode(const QStringList& path);
     NamespaceNode* findNamespaceNode(const QStringList& path);
-    DocNode* findGroupNode(const QStringList& path, Node* start = 0);
     DocNode* findQmlModuleNode(const QStringList& path, Node* start = 0);
 
     Node* findNodeByNameAndType(const QStringList& path,
@@ -129,14 +128,9 @@ class Tree
     void addPropertyFunction(PropertyNode *property,
                              const QString &funcName,
                              PropertyNode::FunctionRole funcRole);
-    void addToGroup(Node *node, const QString &group);
-    void addToPublicGroup(Node *node, const QString &group);
     void addToQmlModule(Node* node);
-    const NodeMultiMap& groups() const;
-    QMultiMap<QString,QString> publicGroups() const;
     void resolveInheritance(NamespaceNode *rootNode = 0);
     void resolveProperties();
-    void resolveGroups();
     void resolveCppToQmlLinks();
     void fixInheritance(NamespaceNode *rootNode = 0);
     NamespaceNode *root() { return &root_; }
@@ -161,8 +155,6 @@ private:
     NamespaceNode root_;
     QMap<ClassNode* , QList<InheritanceBound> > unresolvedInheritanceMap;
     PropertyMap unresolvedPropertyMap;
-    NodeMultiMap groupMap;
-    QMultiMap<QString, QString> publicGroupMap;
 };
 
 QT_END_NAMESPACE