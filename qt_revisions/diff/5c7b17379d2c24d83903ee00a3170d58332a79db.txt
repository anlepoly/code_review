diff --git a/src/qml/debugger/debugger.pri b/src/qml/debugger/debugger.pri
index f85663c..f5abd2c 100644
--- a/src/qml/debugger/debugger.pri
+++ b/src/qml/debugger/debugger.pri
@@ -1,8 +1,6 @@
 SOURCES += \
     $$PWD/qpacketprotocol.cpp \
     $$PWD/qqmldebugservice.cpp \
-    $$PWD/qqmldebugclient.cpp \
-    $$PWD/qqmlenginedebug.cpp \
     $$PWD/qqmlprofilerservice.cpp \
     $$PWD/qqmldebugserver.cpp \
     $$PWD/qqmlinspectorservice.cpp \
@@ -15,8 +13,6 @@ HEADERS += \
     $$PWD/qpacketprotocol_p.h \
     $$PWD/qqmldebugservice_p.h \
     $$PWD/qqmldebugservice_p_p.h \
-    $$PWD/qqmldebugclient_p.h \
-    $$PWD/qqmlenginedebug_p.h \
     $$PWD/qqmlprofilerservice_p.h \
     $$PWD/qqmldebugserver_p.h \
     $$PWD/qqmldebugserverconnection_p.h \
diff --git a/src/qml/debugger/qqmldebugclient.cpp b/src/qml/debugger/qqmldebugclient.cpp
deleted file mode 100644
index fcb0861..0000000
--- a/src/qml/debugger/qqmldebugclient.cpp
+++ /dev/null
@@ -1,421 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qqmldebugclient_p.h"
-
-#include "qpacketprotocol_p.h"
-
-#include <QtCore/qdebug.h>
-#include <QtCore/qstringlist.h>
-#include <QtNetwork/qnetworkproxy.h>
-
-#include <private/qobject_p.h>
-
-QT_BEGIN_NAMESPACE
-
-const int protocolVersion = 1;
-const QString serverId = QLatin1String("QDeclarativeDebugServer");
-const QString clientId = QLatin1String("QDeclarativeDebugClient");
-
-class QQmlDebugClientPrivate : public QObjectPrivate
-{
-    Q_DECLARE_PUBLIC(QQmlDebugClient)
-public:
-    QQmlDebugClientPrivate();
-
-    QString name;
-    QQmlDebugConnection *connection;
-};
-
-class QQmlDebugConnectionPrivate : public QObject
-{
-    Q_OBJECT
-public:
-    QQmlDebugConnectionPrivate(QQmlDebugConnection *c);
-    QQmlDebugConnection *q;
-    QPacketProtocol *protocol;
-    QIODevice *device;
-
-    bool gotHello;
-    QHash <QString, float> serverPlugins;
-    QHash<QString, QQmlDebugClient *> plugins;
-
-    void advertisePlugins();
-    void connectDeviceSignals();
-
-public Q_SLOTS:
-    void connected();
-    void readyRead();
-    void deviceAboutToClose();
-};
-
-QQmlDebugConnectionPrivate::QQmlDebugConnectionPrivate(QQmlDebugConnection *c)
-    : QObject(c), q(c), protocol(0), device(0), gotHello(false)
-{
-    protocol = new QPacketProtocol(q, this);
-    QObject::connect(c, SIGNAL(connected()), this, SLOT(connected()));
-    QObject::connect(protocol, SIGNAL(readyRead()), this, SLOT(readyRead()));
-}
-
-void QQmlDebugConnectionPrivate::advertisePlugins()
-{
-    if (!q->isConnected())
-        return;
-
-    QPacket pack;
-    pack << serverId << 1 << plugins.keys();
-    protocol->send(pack);
-    q->flush();
-}
-
-void QQmlDebugConnectionPrivate::connected()
-{
-    QPacket pack;
-    pack << serverId << 0 << protocolVersion << plugins.keys();
-    protocol->send(pack);
-    q->flush();
-}
-
-void QQmlDebugConnectionPrivate::readyRead()
-{
-    if (!gotHello) {
-        QPacket pack = protocol->read();
-        QString name;
-
-        pack >> name;
-
-        bool validHello = false;
-        if (name == clientId) {
-            int op = -1;
-            pack >> op;
-            if (op == 0) {
-                int version = -1;
-                pack >> version;
-                if (version == protocolVersion) {
-                    QStringList pluginNames;
-                    QList<float> pluginVersions;
-                    pack >> pluginNames;
-                    if (!pack.isEmpty())
-                        pack >> pluginVersions;
-
-                    const int pluginNamesSize = pluginNames.size();
-                    const int pluginVersionsSize = pluginVersions.size();
-                    for (int i = 0; i < pluginNamesSize; ++i) {
-                        float pluginVersion = 1.0;
-                        if (i < pluginVersionsSize)
-                            pluginVersion = pluginVersions.at(i);
-                        serverPlugins.insert(pluginNames.at(i), pluginVersion);
-                    }
-
-                    validHello = true;
-                }
-            }
-        }
-
-        if (!validHello) {
-            qWarning("QQmlDebugConnection: Invalid hello message");
-            QObject::disconnect(protocol, SIGNAL(readyRead()), this, SLOT(readyRead()));
-            return;
-        }
-        gotHello = true;
-
-        QHash<QString, QQmlDebugClient *>::Iterator iter = plugins.begin();
-        for (; iter != plugins.end(); ++iter) {
-            QQmlDebugClient::State newState = QQmlDebugClient::Unavailable;
-            if (serverPlugins.contains(iter.key()))
-                newState = QQmlDebugClient::Enabled;
-            iter.value()->stateChanged(newState);
-        }
-    }
-
-    while (protocol->packetsAvailable()) {
-        QPacket pack = protocol->read();
-        QString name;
-        pack >> name;
-
-        if (name == clientId) {
-            int op = -1;
-            pack >> op;
-
-            if (op == 1) {
-                // Service Discovery
-                QHash<QString, float> oldServerPlugins = serverPlugins;
-                serverPlugins.clear();
-
-                QStringList pluginNames;
-                QList<float> pluginVersions;
-                pack >> pluginNames;
-                if (!pack.isEmpty())
-                    pack >> pluginVersions;
-
-                const int pluginNamesSize = pluginNames.size();
-                const int pluginVersionsSize = pluginVersions.size();
-                for (int i = 0; i < pluginNamesSize; ++i) {
-                    float pluginVersion = 1.0;
-                    if (i < pluginVersionsSize)
-                        pluginVersion = pluginVersions.at(i);
-                    serverPlugins.insert(pluginNames.at(i), pluginVersion);
-                }
-
-                QHash<QString, QQmlDebugClient *>::Iterator iter = plugins.begin();
-                for (; iter != plugins.end(); ++iter) {
-                    const QString pluginName = iter.key();
-                    QQmlDebugClient::State newSate = QQmlDebugClient::Unavailable;
-                    if (serverPlugins.contains(pluginName))
-                        newSate = QQmlDebugClient::Enabled;
-
-                    if (oldServerPlugins.contains(pluginName)
-                            != serverPlugins.contains(pluginName)) {
-                        iter.value()->stateChanged(newSate);
-                    }
-                }
-            } else {
-                qWarning() << "QQmlDebugConnection: Unknown control message id" << op;
-            }
-        } else {
-            QByteArray message;
-            pack >> message;
-
-            QHash<QString, QQmlDebugClient *>::Iterator iter =
-                    plugins.find(name);
-            if (iter == plugins.end()) {
-                qWarning() << "QQmlDebugConnection: Message received for missing plugin" << name;
-            } else {
-                (*iter)->messageReceived(message);
-            }
-        }
-    }
-}
-
-void QQmlDebugConnectionPrivate::deviceAboutToClose()
-{
-    // This is nasty syntax but we want to emit our own aboutToClose signal (by calling QIODevice::close())
-    // without calling the underlying device close fn as that would cause an infinite loop
-    q->QIODevice::close();
-}
-
-QQmlDebugConnection::QQmlDebugConnection(QObject *parent)
-    : QIODevice(parent), d(new QQmlDebugConnectionPrivate(this))
-{
-}
-
-QQmlDebugConnection::~QQmlDebugConnection()
-{
-    QHash<QString, QQmlDebugClient*>::iterator iter = d->plugins.begin();
-    for (; iter != d->plugins.end(); ++iter) {
-        iter.value()->d_func()->connection = 0;
-        iter.value()->stateChanged(QQmlDebugClient::NotConnected);
-    }
-}
-
-bool QQmlDebugConnection::isConnected() const
-{
-    return state() == QAbstractSocket::ConnectedState;
-}
-
-qint64 QQmlDebugConnection::readData(char *data, qint64 maxSize)
-{
-    return d->device->read(data, maxSize);
-}
-
-qint64 QQmlDebugConnection::writeData(const char *data, qint64 maxSize)
-{
-    return d->device->write(data, maxSize);
-}
-
-qint64 QQmlDebugConnection::bytesAvailable() const
-{
-    return d->device->bytesAvailable();
-}
-
-bool QQmlDebugConnection::isSequential() const
-{
-    return true;
-}
-
-void QQmlDebugConnection::close()
-{
-    if (isOpen()) {
-        QIODevice::close();
-        d->device->close();
-        emit stateChanged(QAbstractSocket::UnconnectedState);
-
-        QHash<QString, QQmlDebugClient*>::iterator iter = d->plugins.begin();
-        for (; iter != d->plugins.end(); ++iter) {
-            iter.value()->stateChanged(QQmlDebugClient::NotConnected);
-        }
-    }
-}
-
-bool QQmlDebugConnection::waitForConnected(int msecs)
-{
-    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
-    if (socket)
-        return socket->waitForConnected(msecs);
-    return false;
-}
-
-QAbstractSocket::SocketState QQmlDebugConnection::state() const
-{
-    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
-    if (socket)
-        return socket->state();
-
-    return QAbstractSocket::UnconnectedState;
-}
-
-void QQmlDebugConnection::flush()
-{
-    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
-    if (socket) {
-        socket->flush();
-        return;
-    }
-}
-
-void QQmlDebugConnection::connectToHost(const QString &hostName, quint16 port)
-{
-    QTcpSocket *socket = new QTcpSocket(d);
-    socket->setProxy(QNetworkProxy::NoProxy);
-    d->device = socket;
-    d->connectDeviceSignals();
-    d->gotHello = false;
-    connect(socket, SIGNAL(stateChanged(QAbstractSocket::SocketState)), this, SIGNAL(stateChanged(QAbstractSocket::SocketState)));
-    connect(socket, SIGNAL(error(QAbstractSocket::SocketError)), this, SIGNAL(error(QAbstractSocket::SocketError)));
-    connect(socket, SIGNAL(connected()), this, SIGNAL(connected()));
-    socket->connectToHost(hostName, port);
-    QIODevice::open(ReadWrite | Unbuffered);
-}
-
-void QQmlDebugConnectionPrivate::connectDeviceSignals()
-{
-    connect(device, SIGNAL(bytesWritten(qint64)), q, SIGNAL(bytesWritten(qint64)));
-    connect(device, SIGNAL(readyRead()), q, SIGNAL(readyRead()));
-    connect(device, SIGNAL(aboutToClose()), this, SLOT(deviceAboutToClose()));
-}
-
-//
-
-QQmlDebugClientPrivate::QQmlDebugClientPrivate()
-    : connection(0)
-{
-}
-
-QQmlDebugClient::QQmlDebugClient(const QString &name, 
-                                                 QQmlDebugConnection *parent)
-    : QObject(*(new QQmlDebugClientPrivate), parent)
-{
-    Q_D(QQmlDebugClient);
-    d->name = name;
-    d->connection = parent;
-
-    if (!d->connection)
-        return;
-
-    if (d->connection->d->plugins.contains(name)) {
-        qWarning() << "QQmlDebugClient: Conflicting plugin name" << name;
-        d->connection = 0;
-    } else {
-        d->connection->d->plugins.insert(name, this);
-        d->connection->d->advertisePlugins();
-    }
-}
-
-QQmlDebugClient::~QQmlDebugClient()
-{
-    Q_D(QQmlDebugClient);
-    if (d->connection && d->connection->d) {
-        d->connection->d->plugins.remove(d->name);
-        d->connection->d->advertisePlugins();
-    }
-}
-
-QString QQmlDebugClient::name() const
-{
-    Q_D(const QQmlDebugClient);
-    return d->name;
-}
-
-float QQmlDebugClient::serviceVersion() const
-{
-    Q_D(const QQmlDebugClient);
-    if (d->connection->d->serverPlugins.contains(d->name))
-        return d->connection->d->serverPlugins.value(d->name);
-    return -1;
-}
-
-QQmlDebugClient::State QQmlDebugClient::state() const
-{
-    Q_D(const QQmlDebugClient);
-    if (!d->connection
-            || !d->connection->isConnected()
-            || !d->connection->d->gotHello)
-        return NotConnected;
-
-    if (d->connection->d->serverPlugins.contains(d->name))
-        return Enabled;
-
-    return Unavailable;
-}
-
-void QQmlDebugClient::sendMessage(const QByteArray &message)
-{
-    Q_D(QQmlDebugClient);
-    if (state() != Enabled)
-        return;
-
-    QPacket pack;
-    pack << d->name << message;
-    d->connection->d->protocol->send(pack);
-    d->connection->flush();
-}
-
-void QQmlDebugClient::stateChanged(State)
-{
-}
-
-void QQmlDebugClient::messageReceived(const QByteArray &)
-{
-}
-
-QT_END_NAMESPACE
-
-#include <qqmldebugclient.moc>
diff --git a/src/qml/debugger/qqmldebugclient_p.h b/src/qml/debugger/qqmldebugclient_p.h
deleted file mode 100644
index 064e15c..0000000
--- a/src/qml/debugger/qqmldebugclient_p.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QQMLDEBUGCLIENT_H
-#define QQMLDEBUGCLIENT_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtNetwork/qtcpsocket.h>
-
-#include <private/qtqmlglobal_p.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-class QQmlDebugConnectionPrivate;
-class Q_QML_PRIVATE_EXPORT QQmlDebugConnection : public QIODevice
-{
-    Q_OBJECT
-    Q_DISABLE_COPY(QQmlDebugConnection)
-public:
-    QQmlDebugConnection(QObject * = 0);
-    ~QQmlDebugConnection();
-
-    void connectToHost(const QString &hostName, quint16 port);
-
-    qint64 bytesAvailable() const;
-    bool isConnected() const;
-    QAbstractSocket::SocketState state() const;
-    void flush();
-    bool isSequential() const;
-    void close();
-    bool waitForConnected(int msecs = 30000);
-
-signals:
-    void connected();
-    void stateChanged(QAbstractSocket::SocketState socketState);
-    void error(QAbstractSocket::SocketError socketError);
-
-protected:
-    qint64 readData(char *data, qint64 maxSize);
-    qint64 writeData(const char *data, qint64 maxSize);
-
-private:
-    QQmlDebugConnectionPrivate *d;
-    friend class QQmlDebugClient;
-    friend class QQmlDebugClientPrivate;
-};
-
-class QQmlDebugClientPrivate;
-class Q_QML_PRIVATE_EXPORT QQmlDebugClient : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QQmlDebugClient)
-    Q_DISABLE_COPY(QQmlDebugClient)
-
-public:
-    enum State { NotConnected, Unavailable, Enabled };
-
-    QQmlDebugClient(const QString &, QQmlDebugConnection *parent);
-    ~QQmlDebugClient();
-
-    QString name() const;
-    float serviceVersion() const;
-    State state() const;
-
-    virtual void sendMessage(const QByteArray &);
-
-protected:
-    virtual void stateChanged(State);
-    virtual void messageReceived(const QByteArray &);
-
-private:
-    friend class QQmlDebugConnection;
-    friend class QQmlDebugConnectionPrivate;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QQMLDEBUGCLIENT_H
diff --git a/src/qml/debugger/qqmlenginedebug.cpp b/src/qml/debugger/qqmlenginedebug.cpp
deleted file mode 100644
index 65af181..0000000
--- a/src/qml/debugger/qqmlenginedebug.cpp
+++ /dev/null
@@ -1,1072 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qqmlenginedebug_p.h"
-
-#include "qqmldebugclient_p.h"
-
-#include "qqmlenginedebugservice_p.h"
-
-#include <private/qobject_p.h>
-
-QT_BEGIN_NAMESPACE
-
-class QQmlEngineDebugClient : public QQmlDebugClient
-{
-public:
-    QQmlEngineDebugClient(QQmlDebugConnection *client, QQmlEngineDebugPrivate *p);
-
-protected:
-    virtual void stateChanged(State state);
-    virtual void messageReceived(const QByteArray &);
-
-private:
-    QQmlEngineDebugPrivate *priv;
-    friend class QQmlEngineDebugPrivate;
-};
-
-class QQmlEngineDebugPrivate : public QObjectPrivate
-{
-    Q_DECLARE_PUBLIC(QQmlEngineDebug)
-public:
-    QQmlEngineDebugPrivate(QQmlDebugConnection *);
-    ~QQmlEngineDebugPrivate();
-
-    void stateChanged(QQmlEngineDebug::State status);
-    void message(const QByteArray &);
-
-    QQmlEngineDebugClient *client;
-    int nextId;
-    int getId();
-
-    void decode(QDataStream &, QQmlDebugContextReference &);
-    void decode(QDataStream &, QQmlDebugObjectReference &, bool simple);
-
-    static void remove(QQmlEngineDebug *, QQmlDebugEnginesQuery *);
-    static void remove(QQmlEngineDebug *, QQmlDebugRootContextQuery *);
-    static void remove(QQmlEngineDebug *, QQmlDebugObjectQuery *);
-    static void remove(QQmlEngineDebug *, QQmlDebugExpressionQuery *);
-    static void remove(QQmlEngineDebug *, QQmlDebugWatch *);
-
-    QHash<int, QQmlDebugEnginesQuery *> enginesQuery;
-    QHash<int, QQmlDebugRootContextQuery *> rootContextQuery;
-    QHash<int, QQmlDebugObjectQuery *> objectQuery;
-    QHash<int, QQmlDebugExpressionQuery *> expressionQuery;
-
-    QHash<int, QQmlDebugWatch *> watched;
-};
-
-QQmlEngineDebugClient::QQmlEngineDebugClient(QQmlDebugConnection *client,
-                                                             QQmlEngineDebugPrivate *p)
-    : QQmlDebugClient(QLatin1String("QDeclarativeEngine"), client), priv(p)
-{
-}
-
-void QQmlEngineDebugClient::stateChanged(State status)
-{
-    if (priv)
-        priv->stateChanged(static_cast<QQmlEngineDebug::State>(status));
-}
-
-void QQmlEngineDebugClient::messageReceived(const QByteArray &data)
-{
-    if (priv)
-        priv->message(data);
-}
-
-QQmlEngineDebugPrivate::QQmlEngineDebugPrivate(QQmlDebugConnection *c)
-    : client(new QQmlEngineDebugClient(c, this)), nextId(0)
-{
-}
-
-QQmlEngineDebugPrivate::~QQmlEngineDebugPrivate()
-{
-    if (client)
-        client->priv = 0;
-    delete client;
-
-    QHash<int, QQmlDebugEnginesQuery*>::iterator enginesIter = enginesQuery.begin();
-    for (; enginesIter != enginesQuery.end(); ++enginesIter) {
-        enginesIter.value()->m_client = 0;
-        if (enginesIter.value()->state() == QQmlDebugQuery::Waiting)
-            enginesIter.value()->setState(QQmlDebugQuery::Error);
-    }
-
-    QHash<int, QQmlDebugRootContextQuery*>::iterator rootContextIter = rootContextQuery.begin();
-    for (; rootContextIter != rootContextQuery.end(); ++rootContextIter) {
-        rootContextIter.value()->m_client = 0;
-        if (rootContextIter.value()->state() == QQmlDebugQuery::Waiting)
-            rootContextIter.value()->setState(QQmlDebugQuery::Error);
-    }
-
-    QHash<int, QQmlDebugObjectQuery*>::iterator objectIter = objectQuery.begin();
-    for (; objectIter != objectQuery.end(); ++objectIter) {
-        objectIter.value()->m_client = 0;
-        if (objectIter.value()->state() == QQmlDebugQuery::Waiting)
-            objectIter.value()->setState(QQmlDebugQuery::Error);
-    }
-
-    QHash<int, QQmlDebugExpressionQuery*>::iterator exprIter = expressionQuery.begin();
-    for (; exprIter != expressionQuery.end(); ++exprIter) {
-        exprIter.value()->m_client = 0;
-        if (exprIter.value()->state() == QQmlDebugQuery::Waiting)
-            exprIter.value()->setState(QQmlDebugQuery::Error);
-    }
-
-    QHash<int, QQmlDebugWatch*>::iterator watchIter = watched.begin();
-    for (; watchIter != watched.end(); ++watchIter) {
-        watchIter.value()->m_client = 0;
-        watchIter.value()->setState(QQmlDebugWatch::Dead);
-    }
-}
-
-int QQmlEngineDebugPrivate::getId()
-{
-    return nextId++;
-}
-
-void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, QQmlDebugEnginesQuery *q)
-{
-    if (c && q) {
-        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
-        p->enginesQuery.remove(q->m_queryId);
-    }
-}
-
-void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, 
-                                            QQmlDebugRootContextQuery *q)
-{
-    if (c && q) {
-        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
-        p->rootContextQuery.remove(q->m_queryId);
-    }
-}
-
-void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, QQmlDebugObjectQuery *q)
-{
-    if (c && q) {
-        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
-        p->objectQuery.remove(q->m_queryId);
-    }
-}
-
-void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, QQmlDebugExpressionQuery *q)
-{
-    if (c && q) {
-        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
-        p->expressionQuery.remove(q->m_queryId);
-    }
-}
-
-void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, QQmlDebugWatch *w)
-{
-    if (c && w) {
-        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
-        p->watched.remove(w->m_queryId);
-    }
-}
-
-void QQmlEngineDebugPrivate::decode(QDataStream &ds, QQmlDebugObjectReference &o,
-                                            bool simple)
-{
-    QQmlEngineDebugService::QQmlObjectData data;
-    ds >> data;
-    o.m_debugId = data.objectId;
-    o.m_class = data.objectType;
-    o.m_idString = data.idString;
-    o.m_name = data.objectName;
-    o.m_source.m_url = data.url;
-    o.m_source.m_lineNumber = data.lineNumber;
-    o.m_source.m_columnNumber = data.columnNumber;
-    o.m_contextDebugId = data.contextId;
-
-    if (simple)
-        return;
-
-    int childCount;
-    bool recur;
-    ds >> childCount >> recur;
-
-    for (int ii = 0; ii < childCount; ++ii) {
-        o.m_children.append(QQmlDebugObjectReference());
-        decode(ds, o.m_children.last(), !recur);
-    }
-
-    int propCount;
-    ds >> propCount;
-
-    for (int ii = 0; ii < propCount; ++ii) {
-        QQmlEngineDebugService::QQmlObjectProperty data;
-        ds >> data;
-        QQmlDebugPropertyReference prop;
-        prop.m_objectDebugId = o.m_debugId;
-        prop.m_name = data.name;
-        prop.m_binding = data.binding;
-        prop.m_hasNotifySignal = data.hasNotifySignal;
-        prop.m_valueTypeName = data.valueTypeName;
-        switch (data.type) {
-        case QQmlEngineDebugService::QQmlObjectProperty::Basic:
-        case QQmlEngineDebugService::QQmlObjectProperty::List:
-        case QQmlEngineDebugService::QQmlObjectProperty::SignalProperty:
-        {
-            prop.m_value = data.value;
-            break;
-        }
-        case QQmlEngineDebugService::QQmlObjectProperty::Object:
-        {
-            QQmlDebugObjectReference obj;
-            obj.m_debugId = prop.m_value.toInt();
-            prop.m_value = QVariant::fromValue(obj);
-            break;
-        }
-        case QQmlEngineDebugService::QQmlObjectProperty::Unknown:
-            break;
-        }
-        o.m_properties << prop;
-    }
-}
-
-void QQmlEngineDebugPrivate::decode(QDataStream &ds, QQmlDebugContextReference &c)
-{
-    ds >> c.m_name >> c.m_debugId;
-
-    int contextCount;
-    ds >> contextCount;
-
-    for (int ii = 0; ii < contextCount; ++ii) {
-        c.m_contexts.append(QQmlDebugContextReference());
-        decode(ds, c.m_contexts.last());
-    }
-
-    int objectCount;
-    ds >> objectCount;
-
-    for (int ii = 0; ii < objectCount; ++ii) {
-        QQmlDebugObjectReference obj;
-        decode(ds, obj, true);
-
-        obj.m_contextDebugId = c.m_debugId;
-        c.m_objects << obj;
-    }
-}
-
-void QQmlEngineDebugPrivate::stateChanged(QQmlEngineDebug::State status)
-{
-    emit q_func()->stateChanged(status);
-}
-
-void QQmlEngineDebugPrivate::message(const QByteArray &data)
-{
-    QDataStream ds(data);
-
-    QByteArray type;
-    ds >> type;
-
-    //qDebug() << "QQmlEngineDebugPrivate::message()" << type;
-
-    if (type == "LIST_ENGINES_R") {
-        int queryId;
-        ds >> queryId;
-
-        QQmlDebugEnginesQuery *query = enginesQuery.value(queryId);
-        if (!query)
-            return;
-        enginesQuery.remove(queryId);
-
-        int count;
-        ds >> count;
-
-        for (int ii = 0; ii < count; ++ii) {
-            QQmlDebugEngineReference ref;
-            ds >> ref.m_name;
-            ds >> ref.m_debugId;
-            query->m_engines << ref;
-        }
-
-        query->m_client = 0;
-        query->setState(QQmlDebugQuery::Completed);
-    } else if (type == "LIST_OBJECTS_R") {
-        int queryId;
-        ds >> queryId;
-
-        QQmlDebugRootContextQuery *query = rootContextQuery.value(queryId);
-        if (!query)
-            return;
-        rootContextQuery.remove(queryId);
-
-        if (!ds.atEnd())
-            decode(ds, query->m_context);
-
-        query->m_client = 0;
-        query->setState(QQmlDebugQuery::Completed);
-    } else if (type == "FETCH_OBJECT_R") {
-        int queryId;
-        ds >> queryId;
-
-        QQmlDebugObjectQuery *query = objectQuery.value(queryId);
-        if (!query)
-            return;
-        objectQuery.remove(queryId);
-
-        if (!ds.atEnd())
-            decode(ds, query->m_object, false);
-
-        query->m_client = 0;
-        query->setState(QQmlDebugQuery::Completed);
-    } else if (type == "EVAL_EXPRESSION_R") {
-        int queryId;
-        QVariant result;
-        ds >> queryId >> result;
-
-        QQmlDebugExpressionQuery *query = expressionQuery.value(queryId);
-        if (!query)
-            return;
-        expressionQuery.remove(queryId);
-
-        query->m_result = result;
-        query->m_client = 0;
-        query->setState(QQmlDebugQuery::Completed);
-    } else if (type == "WATCH_PROPERTY_R") {
-        int queryId;
-        bool ok;
-        ds >> queryId >> ok;
-
-        QQmlDebugWatch *watch = watched.value(queryId);
-        if (!watch)
-            return;
-
-        watch->setState(ok ? QQmlDebugWatch::Active : QQmlDebugWatch::Inactive);
-    } else if (type == "WATCH_OBJECT_R") {
-        int queryId;
-        bool ok;
-        ds >> queryId >> ok;
-
-        QQmlDebugWatch *watch = watched.value(queryId);
-        if (!watch)
-            return;
-
-        watch->setState(ok ? QQmlDebugWatch::Active : QQmlDebugWatch::Inactive);
-    } else if (type == "WATCH_EXPR_OBJECT_R") {
-        int queryId;
-        bool ok;
-        ds >> queryId >> ok;
-
-        QQmlDebugWatch *watch = watched.value(queryId);
-        if (!watch)
-            return;
-
-        watch->setState(ok ? QQmlDebugWatch::Active : QQmlDebugWatch::Inactive);
-    } else if (type == "UPDATE_WATCH") {
-        int queryId;
-        int debugId;
-        QByteArray name;
-        QVariant value;
-        ds >> queryId >> debugId >> name >> value;
-
-        QQmlDebugWatch *watch = watched.value(queryId, 0);
-        if (!watch)
-            return;
-        emit watch->valueChanged(name, value);
-    } else if (type == "OBJECT_CREATED") {
-        emit q_func()->newObjects();
-    }
-}
-
-QQmlEngineDebug::QQmlEngineDebug(QQmlDebugConnection *client, QObject *parent)
-    : QObject(*(new QQmlEngineDebugPrivate(client)), parent)
-{
-}
-
-QQmlEngineDebug::~QQmlEngineDebug()
-{
-}
-
-QQmlEngineDebug::State QQmlEngineDebug::state() const
-{
-    Q_D(const QQmlEngineDebug);
-
-    return static_cast<QQmlEngineDebug::State>(d->client->state());
-}
-
-QQmlDebugPropertyWatch *QQmlEngineDebug::addWatch(const QQmlDebugPropertyReference &property, QObject *parent)
-{
-    Q_D(QQmlEngineDebug);
-
-    QQmlDebugPropertyWatch *watch = new QQmlDebugPropertyWatch(parent);
-    if (d->client->state() == QQmlDebugClient::Enabled) {
-        int queryId = d->getId();
-        watch->m_queryId = queryId;
-        watch->m_client = this;
-        watch->m_objectDebugId = property.objectDebugId();
-        watch->m_name = property.name();
-        d->watched.insert(queryId, watch);
-
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("WATCH_PROPERTY") << queryId << property.objectDebugId() << property.name().toUtf8();
-        d->client->sendMessage(message);
-    } else {
-        watch->m_state = QQmlDebugWatch::Dead;
-    }
-
-    return watch;
-}
-
-QQmlDebugWatch *QQmlEngineDebug::addWatch(const QQmlDebugContextReference &, const QString &, QObject *)
-{
-    qWarning("QQmlEngineDebug::addWatch(): Not implemented");
-    return 0;
-}
-
-QQmlDebugObjectExpressionWatch *QQmlEngineDebug::addWatch(const QQmlDebugObjectReference &object, const QString &expr, QObject *parent)
-{
-    Q_D(QQmlEngineDebug);
-    QQmlDebugObjectExpressionWatch *watch = new QQmlDebugObjectExpressionWatch(parent);
-    if (d->client->state() == QQmlDebugClient::Enabled) {
-        int queryId = d->getId();
-        watch->m_queryId = queryId;
-        watch->m_client = this;
-        watch->m_objectDebugId = object.debugId();
-        watch->m_expr = expr;
-        d->watched.insert(queryId, watch);
-
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("WATCH_EXPR_OBJECT") << queryId << object.debugId() << expr;
-        d->client->sendMessage(message);
-    } else {
-        watch->m_state = QQmlDebugWatch::Dead;
-    }
-    return watch;
-}
-
-QQmlDebugWatch *QQmlEngineDebug::addWatch(const QQmlDebugObjectReference &object, QObject *parent)
-{
-    Q_D(QQmlEngineDebug);
-
-    QQmlDebugWatch *watch = new QQmlDebugWatch(parent);
-    if (d->client->state() == QQmlDebugClient::Enabled) {
-        int queryId = d->getId();
-        watch->m_queryId = queryId;
-        watch->m_client = this;
-        watch->m_objectDebugId = object.debugId();
-        d->watched.insert(queryId, watch);
-
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("WATCH_OBJECT") << queryId << object.debugId();
-        d->client->sendMessage(message);
-    } else {
-        watch->m_state = QQmlDebugWatch::Dead;
-    }
-
-    return watch;
-}
-
-QQmlDebugWatch *QQmlEngineDebug::addWatch(const QQmlDebugFileReference &, QObject *)
-{
-    qWarning("QQmlEngineDebug::addWatch(): Not implemented");
-    return 0;
-}
-
-void QQmlEngineDebug::removeWatch(QQmlDebugWatch *watch)
-{
-    Q_D(QQmlEngineDebug);
-
-    if (!watch || !watch->m_client)
-        return;
-
-    watch->m_client = 0;
-    watch->setState(QQmlDebugWatch::Inactive);
-    
-    d->watched.remove(watch->queryId());
-
-    if (d->client && d->client->state() == QQmlDebugClient::Enabled) {
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("NO_WATCH") << watch->queryId();
-        d->client->sendMessage(message);
-    }
-}
-
-QQmlDebugEnginesQuery *QQmlEngineDebug::queryAvailableEngines(QObject *parent)
-{
-    Q_D(QQmlEngineDebug);
-
-    QQmlDebugEnginesQuery *query = new QQmlDebugEnginesQuery(parent);
-    if (d->client->state() == QQmlDebugClient::Enabled) {
-        query->m_client = this;
-        int queryId = d->getId();
-        query->m_queryId = queryId;
-        d->enginesQuery.insert(queryId, query);
-
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("LIST_ENGINES") << queryId;
-        d->client->sendMessage(message);
-    } else {
-        query->m_state = QQmlDebugQuery::Error;
-    }
-
-    return query;
-}
-
-QQmlDebugRootContextQuery *QQmlEngineDebug::queryRootContexts(const QQmlDebugEngineReference &engine, QObject *parent)
-{
-    Q_D(QQmlEngineDebug);
-
-    QQmlDebugRootContextQuery *query = new QQmlDebugRootContextQuery(parent);
-    if (d->client->state() == QQmlDebugClient::Enabled && engine.debugId() != -1) {
-        query->m_client = this;
-        int queryId = d->getId();
-        query->m_queryId = queryId;
-        d->rootContextQuery.insert(queryId, query);
-
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("LIST_OBJECTS") << queryId << engine.debugId();
-        d->client->sendMessage(message);
-    } else {
-        query->m_state = QQmlDebugQuery::Error;
-    }
-
-    return query;
-}
-
-QQmlDebugObjectQuery *QQmlEngineDebug::queryObject(const QQmlDebugObjectReference &object, QObject *parent)
-{
-    Q_D(QQmlEngineDebug);
-
-    QQmlDebugObjectQuery *query = new QQmlDebugObjectQuery(parent);
-    if (d->client->state() == QQmlDebugClient::Enabled && object.debugId() != -1) {
-        query->m_client = this;
-        int queryId = d->getId();
-        query->m_queryId = queryId;
-        d->objectQuery.insert(queryId, query);
-
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("FETCH_OBJECT") << queryId << object.debugId()
-           << false << true;
-        d->client->sendMessage(message);
-    } else {
-        query->m_state = QQmlDebugQuery::Error;
-    }
-
-    return query;
-}
-
-QQmlDebugObjectQuery *QQmlEngineDebug::queryObjectRecursive(const QQmlDebugObjectReference &object, QObject *parent)
-{
-    Q_D(QQmlEngineDebug);
-
-    QQmlDebugObjectQuery *query = new QQmlDebugObjectQuery(parent);
-    if (d->client->state() == QQmlDebugClient::Enabled && object.debugId() != -1) {
-        query->m_client = this;
-        int queryId = d->getId();
-        query->m_queryId = queryId;
-        d->objectQuery.insert(queryId, query);
-
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("FETCH_OBJECT") << queryId << object.debugId()
-           << true << true;
-        d->client->sendMessage(message);
-    } else {
-        query->m_state = QQmlDebugQuery::Error;
-    }
-
-    return query;
-}
-
-QQmlDebugExpressionQuery *QQmlEngineDebug::queryExpressionResult(int objectDebugId, const QString &expr, QObject *parent)
-{
-    Q_D(QQmlEngineDebug);
-
-    QQmlDebugExpressionQuery *query = new QQmlDebugExpressionQuery(parent);
-    if (d->client->state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
-        query->m_client = this;
-        query->m_expr = expr;
-        int queryId = d->getId();
-        query->m_queryId = queryId;
-        d->expressionQuery.insert(queryId, query);
-
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("EVAL_EXPRESSION") << queryId << objectDebugId << expr;
-        d->client->sendMessage(message);
-    } else {
-        query->m_state = QQmlDebugQuery::Error;
-    }
-
-    return query;
-}
-
-bool QQmlEngineDebug::setBindingForObject(int objectDebugId, const QString &propertyName,
-                                                  const QVariant &bindingExpression,
-                                                  bool isLiteralValue,
-                                                  QString source, int line)
-{
-    Q_D(QQmlEngineDebug);
-
-    if (d->client->state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("SET_BINDING") << objectDebugId << propertyName << bindingExpression << isLiteralValue << source << line;
-        d->client->sendMessage(message);
-        return true;
-    } else {
-        return false;
-    }
-}
-
-bool QQmlEngineDebug::resetBindingForObject(int objectDebugId, const QString &propertyName)
-{
-    Q_D(QQmlEngineDebug);
-
-    if (d->client->state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("RESET_BINDING") << objectDebugId << propertyName;
-        d->client->sendMessage(message);
-        return true;
-    } else {
-        return false;
-    }
-}
-
-bool QQmlEngineDebug::setMethodBody(int objectDebugId, const QString &methodName,
-                                            const QString &methodBody)
-{
-    Q_D(QQmlEngineDebug);
-
-    if (d->client->state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("SET_METHOD_BODY") << objectDebugId << methodName << methodBody;
-        d->client->sendMessage(message);
-        return true;
-    } else {
-        return false;
-    }
-}
-
-QQmlDebugWatch::QQmlDebugWatch(QObject *parent)
-    : QObject(parent), m_state(Waiting), m_queryId(-1), m_client(0), m_objectDebugId(-1)
-{
-}
-
-QQmlDebugWatch::~QQmlDebugWatch()
-{
-    if (m_client && m_queryId != -1)
-        QQmlEngineDebugPrivate::remove(m_client, this);
-}
-
-int QQmlDebugWatch::queryId() const
-{
-    return m_queryId;
-}
-
-int QQmlDebugWatch::objectDebugId() const
-{
-    return m_objectDebugId;
-}
-
-QQmlDebugWatch::State QQmlDebugWatch::state() const
-{
-    return m_state;
-}
-
-void QQmlDebugWatch::setState(State s)
-{
-    if (m_state == s)
-        return;
-    m_state = s;
-    emit stateChanged(m_state);
-}
-
-QQmlDebugPropertyWatch::QQmlDebugPropertyWatch(QObject *parent)
-    : QQmlDebugWatch(parent)
-{
-}
-
-QString QQmlDebugPropertyWatch::name() const
-{
-    return m_name;
-}
-
-
-QQmlDebugObjectExpressionWatch::QQmlDebugObjectExpressionWatch(QObject *parent)
-    : QQmlDebugWatch(parent)
-{
-}
-
-QString QQmlDebugObjectExpressionWatch::expression() const
-{
-    return m_expr;
-}
-
-
-QQmlDebugQuery::QQmlDebugQuery(QObject *parent)
-    : QObject(parent), m_state(Waiting)
-{
-}
-
-QQmlDebugQuery::State QQmlDebugQuery::state() const
-{
-    return m_state;
-}
-
-bool QQmlDebugQuery::isWaiting() const
-{
-    return m_state == Waiting;
-}
-
-void QQmlDebugQuery::setState(State s)
-{
-    if (m_state == s)
-        return;
-    m_state = s;
-    emit stateChanged(m_state);
-}
-
-QQmlDebugEnginesQuery::QQmlDebugEnginesQuery(QObject *parent)
-    : QQmlDebugQuery(parent), m_client(0), m_queryId(-1)
-{
-}
-
-QQmlDebugEnginesQuery::~QQmlDebugEnginesQuery()
-{
-    if (m_client && m_queryId != -1)
-        QQmlEngineDebugPrivate::remove(m_client, this);
-}
-
-QList<QQmlDebugEngineReference> QQmlDebugEnginesQuery::engines() const
-{
-    return m_engines;
-}
-
-QQmlDebugRootContextQuery::QQmlDebugRootContextQuery(QObject *parent)
-    : QQmlDebugQuery(parent), m_client(0), m_queryId(-1)
-{
-}
-
-QQmlDebugRootContextQuery::~QQmlDebugRootContextQuery()
-{
-    if (m_client && m_queryId != -1)
-        QQmlEngineDebugPrivate::remove(m_client, this);
-}
-
-QQmlDebugContextReference QQmlDebugRootContextQuery::rootContext() const
-{
-    return m_context;
-}
-
-QQmlDebugObjectQuery::QQmlDebugObjectQuery(QObject *parent)
-    : QQmlDebugQuery(parent), m_client(0), m_queryId(-1)
-{
-}
-
-QQmlDebugObjectQuery::~QQmlDebugObjectQuery()
-{
-    if (m_client && m_queryId != -1)
-        QQmlEngineDebugPrivate::remove(m_client, this);
-}
-
-QQmlDebugObjectReference QQmlDebugObjectQuery::object() const
-{
-    return m_object;
-}
-
-QQmlDebugExpressionQuery::QQmlDebugExpressionQuery(QObject *parent)
-    : QQmlDebugQuery(parent), m_client(0), m_queryId(-1)
-{
-}
-
-QQmlDebugExpressionQuery::~QQmlDebugExpressionQuery()
-{
-    if (m_client && m_queryId != -1)
-        QQmlEngineDebugPrivate::remove(m_client, this);
-}
-
-QVariant QQmlDebugExpressionQuery::expression() const
-{
-    return m_expr;
-}
-
-QVariant QQmlDebugExpressionQuery::result() const
-{
-    return m_result;
-}
-
-QQmlDebugEngineReference::QQmlDebugEngineReference()
-    : m_debugId(-1)
-{
-}
-
-QQmlDebugEngineReference::QQmlDebugEngineReference(int debugId)
-    : m_debugId(debugId)
-{
-}
-
-QQmlDebugEngineReference::QQmlDebugEngineReference(const QQmlDebugEngineReference &o)
-    : m_debugId(o.m_debugId), m_name(o.m_name)
-{
-}
-
-QQmlDebugEngineReference &
-QQmlDebugEngineReference::operator=(const QQmlDebugEngineReference &o)
-{
-    m_debugId = o.m_debugId; m_name = o.m_name;
-    return *this;
-}
-
-int QQmlDebugEngineReference::debugId() const
-{
-    return m_debugId;
-}
-
-QString QQmlDebugEngineReference::name() const
-{
-    return m_name;
-}
-
-QQmlDebugObjectReference::QQmlDebugObjectReference()
-    : m_debugId(-1), m_contextDebugId(-1)
-{
-}
-
-QQmlDebugObjectReference::QQmlDebugObjectReference(int debugId)
-    : m_debugId(debugId), m_contextDebugId(-1)
-{
-}
-
-QQmlDebugObjectReference::QQmlDebugObjectReference(const QQmlDebugObjectReference &o)
-    : m_debugId(o.m_debugId), m_class(o.m_class), m_idString(o.m_idString),
-      m_name(o.m_name), m_source(o.m_source), m_contextDebugId(o.m_contextDebugId),
-      m_properties(o.m_properties), m_children(o.m_children)
-{
-}
-
-QQmlDebugObjectReference &
-QQmlDebugObjectReference::operator=(const QQmlDebugObjectReference &o)
-{
-    m_debugId = o.m_debugId; m_class = o.m_class; m_idString = o.m_idString;
-    m_name = o.m_name; m_source = o.m_source; m_contextDebugId = o.m_contextDebugId;
-    m_properties = o.m_properties; m_children = o.m_children;
-    return *this;
-}
-
-int QQmlDebugObjectReference::debugId() const
-{
-    return m_debugId;
-}
-
-QString QQmlDebugObjectReference::className() const
-{
-    return m_class;
-}
-
-QString QQmlDebugObjectReference::idString() const
-{
-    return m_idString;
-}
-
-QString QQmlDebugObjectReference::name() const
-{
-    return m_name;
-}
-
-QQmlDebugFileReference QQmlDebugObjectReference::source() const
-{
-    return m_source;
-}
-
-int QQmlDebugObjectReference::contextDebugId() const
-{
-    return m_contextDebugId;
-}
-
-QList<QQmlDebugPropertyReference> QQmlDebugObjectReference::properties() const
-{
-    return m_properties;
-}
-
-QList<QQmlDebugObjectReference> QQmlDebugObjectReference::children() const
-{
-    return m_children;
-}
-
-QQmlDebugContextReference::QQmlDebugContextReference()
-    : m_debugId(-1)
-{
-}
-
-QQmlDebugContextReference::QQmlDebugContextReference(const QQmlDebugContextReference &o)
-    : m_debugId(o.m_debugId), m_name(o.m_name), m_objects(o.m_objects), m_contexts(o.m_contexts)
-{
-}
-
-QQmlDebugContextReference &QQmlDebugContextReference::operator=(const QQmlDebugContextReference &o)
-{
-    m_debugId = o.m_debugId; m_name = o.m_name; m_objects = o.m_objects;
-    m_contexts = o.m_contexts;
-    return *this;
-}
-
-int QQmlDebugContextReference::debugId() const
-{
-    return m_debugId;
-}
-
-QString QQmlDebugContextReference::name() const
-{
-    return m_name;
-}
-
-QList<QQmlDebugObjectReference> QQmlDebugContextReference::objects() const
-{
-    return m_objects;
-}
-
-QList<QQmlDebugContextReference> QQmlDebugContextReference::contexts() const
-{
-    return m_contexts;
-}
-
-QQmlDebugFileReference::QQmlDebugFileReference()
-    : m_lineNumber(-1), m_columnNumber(-1)
-{
-}
-
-QQmlDebugFileReference::QQmlDebugFileReference(const QQmlDebugFileReference &o)
-    : m_url(o.m_url), m_lineNumber(o.m_lineNumber), m_columnNumber(o.m_columnNumber)
-{
-}
-
-QQmlDebugFileReference &QQmlDebugFileReference::operator=(const QQmlDebugFileReference &o)
-{
-    m_url = o.m_url; m_lineNumber = o.m_lineNumber; m_columnNumber = o.m_columnNumber;
-    return *this;
-}
-
-QUrl QQmlDebugFileReference::url() const
-{
-    return m_url;
-}
-
-void QQmlDebugFileReference::setUrl(const QUrl &u)
-{
-    m_url = u;
-}
-
-int QQmlDebugFileReference::lineNumber() const
-{
-    return m_lineNumber;
-}
-
-void QQmlDebugFileReference::setLineNumber(int l)
-{
-    m_lineNumber = l;
-}
-
-int QQmlDebugFileReference::columnNumber() const
-{
-    return m_columnNumber;
-}
-
-void QQmlDebugFileReference::setColumnNumber(int c)
-{
-    m_columnNumber = c;
-}
-
-QQmlDebugPropertyReference::QQmlDebugPropertyReference()
-    : m_objectDebugId(-1), m_hasNotifySignal(false)
-{
-}
-
-QQmlDebugPropertyReference::QQmlDebugPropertyReference(const QQmlDebugPropertyReference &o)
-    : m_objectDebugId(o.m_objectDebugId), m_name(o.m_name), m_value(o.m_value),
-      m_valueTypeName(o.m_valueTypeName), m_binding(o.m_binding),
-      m_hasNotifySignal(o.m_hasNotifySignal)
-{
-}
-
-QQmlDebugPropertyReference &QQmlDebugPropertyReference::operator=(const QQmlDebugPropertyReference &o)
-{
-    m_objectDebugId = o.m_objectDebugId; m_name = o.m_name; m_value = o.m_value;
-    m_valueTypeName = o.m_valueTypeName; m_binding = o.m_binding;
-    m_hasNotifySignal = o.m_hasNotifySignal;
-    return *this;
-}
-
-int QQmlDebugPropertyReference::objectDebugId() const
-{
-    return m_objectDebugId;
-}
-
-QString QQmlDebugPropertyReference::name() const
-{
-    return m_name;
-}
-
-QString QQmlDebugPropertyReference::valueTypeName() const
-{
-    return m_valueTypeName;
-}
-
-QVariant QQmlDebugPropertyReference::value() const
-{
-    return m_value;
-}
-
-QString QQmlDebugPropertyReference::binding() const
-{
-    return m_binding;
-}
-
-bool QQmlDebugPropertyReference::hasNotifySignal() const
-{
-    return m_hasNotifySignal;
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/qml/debugger/qqmlenginedebug_p.h b/src/qml/debugger/qqmlenginedebug_p.h
deleted file mode 100644
index 0562d87..0000000
--- a/src/qml/debugger/qqmlenginedebug_p.h
+++ /dev/null
@@ -1,397 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QQMLENGINEDEBUG_H
-#define QQMLENGINEDEBUG_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtCore/qobject.h>
-#include <QtCore/qurl.h>
-#include <QtCore/qvariant.h>
-
-#include <private/qtqmlglobal_p.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-class QQmlDebugConnection;
-class QQmlDebugWatch;
-class QQmlDebugPropertyWatch;
-class QQmlDebugObjectExpressionWatch;
-class QQmlDebugEnginesQuery;
-class QQmlDebugRootContextQuery;
-class QQmlDebugObjectQuery;
-class QQmlDebugExpressionQuery;
-class QQmlDebugPropertyReference;
-class QQmlDebugContextReference;
-class QQmlDebugObjectReference;
-class QQmlDebugFileReference;
-class QQmlDebugEngineReference;
-class QQmlEngineDebugPrivate;
-class Q_QML_PRIVATE_EXPORT QQmlEngineDebug : public QObject
-{
-    Q_OBJECT
-public:
-    enum State { NotConnected, Unavailable, Enabled };
-
-    explicit QQmlEngineDebug(QQmlDebugConnection *, QObject * = 0);
-    ~QQmlEngineDebug();
-
-    State state() const;
-
-    QQmlDebugPropertyWatch *addWatch(const QQmlDebugPropertyReference &,
-                                             QObject *parent = 0);
-    QQmlDebugWatch *addWatch(const QQmlDebugContextReference &, const QString &,
-                                     QObject *parent = 0);
-    QQmlDebugObjectExpressionWatch *addWatch(const QQmlDebugObjectReference &, const QString &,
-                                                     QObject *parent = 0);
-    QQmlDebugWatch *addWatch(const QQmlDebugObjectReference &,
-                                     QObject *parent = 0);
-    QQmlDebugWatch *addWatch(const QQmlDebugFileReference &,
-                                     QObject *parent = 0);
-
-    void removeWatch(QQmlDebugWatch *watch);
-
-    QQmlDebugEnginesQuery *queryAvailableEngines(QObject *parent = 0);
-    QQmlDebugRootContextQuery *queryRootContexts(const QQmlDebugEngineReference &,
-                                                         QObject *parent = 0);
-    QQmlDebugObjectQuery *queryObject(const QQmlDebugObjectReference &,
-                                              QObject *parent = 0);
-    QQmlDebugObjectQuery *queryObjectRecursive(const QQmlDebugObjectReference &,
-                                                       QObject *parent = 0);
-    QQmlDebugExpressionQuery *queryExpressionResult(int objectDebugId,
-                                                            const QString &expr,
-                                                            QObject *parent = 0);
-    bool setBindingForObject(int objectDebugId, const QString &propertyName,
-                             const QVariant &bindingExpression, bool isLiteralValue,
-                             QString source = QString(), int line = -1);
-    bool resetBindingForObject(int objectDebugId, const QString &propertyName);
-    bool setMethodBody(int objectDebugId, const QString &methodName, const QString &methodBody);
-
-Q_SIGNALS:
-    void newObjects();
-    void stateChanged(State state);
-
-private:
-    Q_DECLARE_PRIVATE(QQmlEngineDebug)
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugWatch : public QObject
-{
-    Q_OBJECT
-public:
-    enum State { Waiting, Active, Inactive, Dead };
-
-    QQmlDebugWatch(QObject *);
-    ~QQmlDebugWatch();
-
-    int queryId() const;
-    int objectDebugId() const;
-    State state() const;
-
-Q_SIGNALS:
-    void stateChanged(QQmlDebugWatch::State);
-    //void objectChanged(int, const QQmlDebugObjectReference &);
-    //void valueChanged(int, const QVariant &);
-
-    // Server sends value as string if it is a user-type variant
-    void valueChanged(const QByteArray &name, const QVariant &value);
-
-private:
-    friend class QQmlEngineDebug;
-    friend class QQmlEngineDebugPrivate;
-    void setState(State);
-    State m_state;
-    int m_queryId;
-    QQmlEngineDebug *m_client;
-    int m_objectDebugId;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugPropertyWatch : public QQmlDebugWatch
-{
-    Q_OBJECT
-public:
-    QQmlDebugPropertyWatch(QObject *parent);
-
-    QString name() const;
-
-private:
-    friend class QQmlEngineDebug;
-    QString m_name;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugObjectExpressionWatch : public QQmlDebugWatch
-{
-    Q_OBJECT
-public:
-    QQmlDebugObjectExpressionWatch(QObject *parent);
-
-    QString expression() const;
-
-private:
-    friend class QQmlEngineDebug;
-    QString m_expr;
-    int m_debugId;
-};
-
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugQuery : public QObject
-{
-    Q_OBJECT
-public:
-    enum State { Waiting, Error, Completed };
-
-    State state() const;
-    bool isWaiting() const;
-
-Q_SIGNALS:
-    void stateChanged(QQmlDebugQuery::State);
-
-protected:
-    QQmlDebugQuery(QObject *);
-
-private:
-    friend class QQmlEngineDebug;
-    friend class QQmlEngineDebugPrivate;
-    void setState(State);
-    State m_state;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugFileReference 
-{
-public:
-    QQmlDebugFileReference();
-    QQmlDebugFileReference(const QQmlDebugFileReference &);
-    QQmlDebugFileReference &operator=(const QQmlDebugFileReference &);
-
-    QUrl url() const;
-    void setUrl(const QUrl &);
-    int lineNumber() const;
-    void setLineNumber(int);
-    int columnNumber() const;
-    void setColumnNumber(int);
-
-private:
-    friend class QQmlEngineDebugPrivate;
-    QUrl m_url;
-    int m_lineNumber;
-    int m_columnNumber;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugEngineReference
-{
-public:
-    QQmlDebugEngineReference();
-    QQmlDebugEngineReference(int);
-    QQmlDebugEngineReference(const QQmlDebugEngineReference &);
-    QQmlDebugEngineReference &operator=(const QQmlDebugEngineReference &);
-
-    int debugId() const;
-    QString name() const;
-
-private:
-    friend class QQmlEngineDebugPrivate;
-    int m_debugId;
-    QString m_name;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugObjectReference
-{
-public:
-    QQmlDebugObjectReference();
-    QQmlDebugObjectReference(int);
-    QQmlDebugObjectReference(const QQmlDebugObjectReference &);
-    QQmlDebugObjectReference &operator=(const QQmlDebugObjectReference &);
-
-    int debugId() const;
-    QString className() const;
-    QString idString() const;
-    QString name() const;
-
-    QQmlDebugFileReference source() const;
-    int contextDebugId() const;
-
-    QList<QQmlDebugPropertyReference> properties() const;
-    QList<QQmlDebugObjectReference> children() const;
-
-private:
-    friend class QQmlEngineDebugPrivate;
-    int m_debugId;
-    QString m_class;
-    QString m_idString;
-    QString m_name;
-    QQmlDebugFileReference m_source;
-    int m_contextDebugId;
-    QList<QQmlDebugPropertyReference> m_properties;
-    QList<QQmlDebugObjectReference> m_children;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugContextReference
-{
-public:
-    QQmlDebugContextReference();
-    QQmlDebugContextReference(const QQmlDebugContextReference &);
-    QQmlDebugContextReference &operator=(const QQmlDebugContextReference &);
-
-    int debugId() const;
-    QString name() const;
-
-    QList<QQmlDebugObjectReference> objects() const;
-    QList<QQmlDebugContextReference> contexts() const;
-
-private:
-    friend class QQmlEngineDebugPrivate;
-    int m_debugId;
-    QString m_name;
-    QList<QQmlDebugObjectReference> m_objects;
-    QList<QQmlDebugContextReference> m_contexts;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugPropertyReference
-{
-public:
-    QQmlDebugPropertyReference();
-    QQmlDebugPropertyReference(const QQmlDebugPropertyReference &);
-    QQmlDebugPropertyReference &operator=(const QQmlDebugPropertyReference &);
-
-    int objectDebugId() const;
-    QString name() const;
-    QVariant value() const;
-    QString valueTypeName() const;
-    QString binding() const;
-    bool hasNotifySignal() const;
-
-private:
-    friend class QQmlEngineDebugPrivate;
-    int m_objectDebugId;
-    QString m_name;
-    QVariant m_value;
-    QString m_valueTypeName;
-    QString m_binding;
-    bool m_hasNotifySignal;
-};
-
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugEnginesQuery : public QQmlDebugQuery
-{
-    Q_OBJECT
-public:
-    virtual ~QQmlDebugEnginesQuery();
-    QList<QQmlDebugEngineReference> engines() const;
-private:
-    friend class QQmlEngineDebug;
-    friend class QQmlEngineDebugPrivate;
-    QQmlDebugEnginesQuery(QObject *);
-    QQmlEngineDebug *m_client;
-    int m_queryId;
-    QList<QQmlDebugEngineReference> m_engines;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugRootContextQuery : public QQmlDebugQuery
-{
-    Q_OBJECT
-public:
-    virtual ~QQmlDebugRootContextQuery();
-    QQmlDebugContextReference rootContext() const;
-private:
-    friend class QQmlEngineDebug;
-    friend class QQmlEngineDebugPrivate;
-    QQmlDebugRootContextQuery(QObject *);
-    QQmlEngineDebug *m_client;
-    int m_queryId;
-    QQmlDebugContextReference m_context;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugObjectQuery : public QQmlDebugQuery
-{
-    Q_OBJECT
-public:
-    virtual ~QQmlDebugObjectQuery();
-    QQmlDebugObjectReference object() const;
-private:
-    friend class QQmlEngineDebug;
-    friend class QQmlEngineDebugPrivate;
-    QQmlDebugObjectQuery(QObject *);
-    QQmlEngineDebug *m_client;
-    int m_queryId;
-    QQmlDebugObjectReference m_object;
-
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlDebugExpressionQuery : public QQmlDebugQuery
-{
-    Q_OBJECT
-public:
-    virtual ~QQmlDebugExpressionQuery();
-    QVariant expression() const;
-    QVariant result() const;
-private:
-    friend class QQmlEngineDebug;
-    friend class QQmlEngineDebugPrivate;
-    QQmlDebugExpressionQuery(QObject *);
-    QQmlEngineDebug *m_client;
-    int m_queryId;
-    QVariant m_expr;
-    QVariant m_result;
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QQmlDebugEngineReference)
-Q_DECLARE_METATYPE(QQmlDebugObjectReference)
-Q_DECLARE_METATYPE(QQmlDebugContextReference)
-Q_DECLARE_METATYPE(QQmlDebugPropertyReference)
-
-QT_END_HEADER
-
-#endif // QQMLENGINEDEBUG_H
diff --git a/tests/auto/qml/debugger/debugger.pro b/tests/auto/qml/debugger/debugger.pro
index 4f9ebbc..7669aaa 100644
--- a/tests/auto/qml/debugger/debugger.pro
+++ b/tests/auto/qml/debugger/debugger.pro
@@ -1,7 +1,7 @@
 TEMPLATE = subdirs
 
 PRIVATETESTS += \
-    qqmlenginedebug \
+    qqmlenginedebugservice \
     qqmldebugclient \
     qqmldebugservice \
     qqmldebugjs \
diff --git a/tests/auto/qml/debugger/qdebugmessageservice/qdebugmessageservice.pro b/tests/auto/qml/debugger/qdebugmessageservice/qdebugmessageservice.pro
index d62a262..4b5bf60 100644
--- a/tests/auto/qml/debugger/qdebugmessageservice/qdebugmessageservice.pro
+++ b/tests/auto/qml/debugger/qdebugmessageservice/qdebugmessageservice.pro
@@ -3,14 +3,11 @@ TARGET = tst_qdebugmessageservice
 QT += network qml-private testlib
 macx:CONFIG -= app_bundle
 
-HEADERS += ../shared/debugutil_p.h
-
-SOURCES +=     tst_qdebugmessageservice.cpp \
-            ../shared/debugutil.cpp
+SOURCES +=     tst_qdebugmessageservice.cpp
 
 INCLUDEPATH += ../shared
-
 include(../../../shared/util.pri)
+include(../shared/debugutil.pri)
 
 TESTDATA = data/*
 
diff --git a/tests/auto/qml/debugger/qdebugmessageservice/tst_qdebugmessageservice.cpp b/tests/auto/qml/debugger/qdebugmessageservice/tst_qdebugmessageservice.cpp
index a19fd4b..8473774 100644
--- a/tests/auto/qml/debugger/qdebugmessageservice/tst_qdebugmessageservice.cpp
+++ b/tests/auto/qml/debugger/qdebugmessageservice/tst_qdebugmessageservice.cpp
@@ -39,10 +39,10 @@
 **
 ****************************************************************************/
 
-#include <QtQml/private/qqmldebugclient_p.h>
+#include "qqmldebugclient.h"
 
 //QQmlDebugTest
-#include "../shared/debugutil_p.h"
+#include "debugutil_p.h"
 #include "../../../shared/util.h"
 
 #include <QtCore/QString>
diff --git a/tests/auto/qml/debugger/qpacketprotocol/qpacketprotocol.pro b/tests/auto/qml/debugger/qpacketprotocol/qpacketprotocol.pro
index 8843919..f631929 100644
--- a/tests/auto/qml/debugger/qpacketprotocol/qpacketprotocol.pro
+++ b/tests/auto/qml/debugger/qpacketprotocol/qpacketprotocol.pro
@@ -2,9 +2,10 @@ CONFIG += testcase
 TARGET = tst_qpacketprotocol
 macx:CONFIG -= app_bundle
 
-HEADERS += ../shared/debugutil_p.h
-SOURCES += tst_qpacketprotocol.cpp \
-           ../shared/debugutil.cpp
+SOURCES += tst_qpacketprotocol.cpp
+
+INCLUDEPATH += ../shared
+include(../shared/debugutil.pri)
 
 CONFIG += parallel_test
 QT += qml-private network testlib
diff --git a/tests/auto/qml/debugger/qpacketprotocol/tst_qpacketprotocol.cpp b/tests/auto/qml/debugger/qpacketprotocol/tst_qpacketprotocol.cpp
index c02dd2d..4a6efb4 100644
--- a/tests/auto/qml/debugger/qpacketprotocol/tst_qpacketprotocol.cpp
+++ b/tests/auto/qml/debugger/qpacketprotocol/tst_qpacketprotocol.cpp
@@ -48,7 +48,7 @@
 
 #include <private/qpacketprotocol_p.h>
 
-#include "../shared/debugutil_p.h"
+#include "debugutil_p.h"
 
 class tst_QPacketProtocol : public QObject
 {
diff --git a/tests/auto/qml/debugger/qqmldebugclient/qqmldebugclient.pro b/tests/auto/qml/debugger/qqmldebugclient/qqmldebugclient.pro
index d298b5c..22a4df7 100644
--- a/tests/auto/qml/debugger/qqmldebugclient/qqmldebugclient.pro
+++ b/tests/auto/qml/debugger/qqmldebugclient/qqmldebugclient.pro
@@ -2,9 +2,10 @@ CONFIG += testcase
 TARGET = tst_qqmldebugclient
 macx:CONFIG -= app_bundle
 
-HEADERS += ../shared/debugutil_p.h
-SOURCES += tst_qqmldebugclient.cpp \
-           ../shared/debugutil.cpp
+SOURCES += tst_qqmldebugclient.cpp
+
+INCLUDEPATH += ../shared
+include(../shared/debugutil.pri)
 
 CONFIG += declarative_debug
 
diff --git a/tests/auto/qml/debugger/qqmldebugclient/tst_qqmldebugclient.cpp b/tests/auto/qml/debugger/qqmldebugclient/tst_qqmldebugclient.cpp
index b18f30f..9377ef6 100644
--- a/tests/auto/qml/debugger/qqmldebugclient/tst_qqmldebugclient.cpp
+++ b/tests/auto/qml/debugger/qqmldebugclient/tst_qqmldebugclient.cpp
@@ -47,7 +47,7 @@
 
 #include <QtQml/qqmlengine.h>
 
-#include "../shared/debugutil_p.h"
+#include "debugutil_p.h"
 
 #define PORT 13770
 #define STR_PORT "13770"
diff --git a/tests/auto/qml/debugger/qqmldebugjs/qqmldebugjs.pro b/tests/auto/qml/debugger/qqmldebugjs/qqmldebugjs.pro
index 7bb5161..7c3a2ea 100644
--- a/tests/auto/qml/debugger/qqmldebugjs/qqmldebugjs.pro
+++ b/tests/auto/qml/debugger/qqmldebugjs/qqmldebugjs.pro
@@ -3,13 +3,11 @@ TARGET = tst_qqmldebugjs
 QT += qml-private testlib
 macx:CONFIG -= app_bundle
 
-HEADERS += ../shared/debugutil_p.h
-SOURCES +=     tst_qqmldebugjs.cpp \
-            ../shared/debugutil.cpp
+SOURCES +=     tst_qqmldebugjs.cpp
 
 INCLUDEPATH += ../shared
-
-include (../../../shared/util.pri)
+include(../../../shared/util.pri)
+include(../shared/debugutil.pri)
 
 TESTDATA = data/*
 
diff --git a/tests/auto/qml/debugger/qqmldebugjs/tst_qqmldebugjs.cpp b/tests/auto/qml/debugger/qqmldebugjs/tst_qqmldebugjs.cpp
index 9a8b00b..9cd021d 100644
--- a/tests/auto/qml/debugger/qqmldebugjs/tst_qqmldebugjs.cpp
+++ b/tests/auto/qml/debugger/qqmldebugjs/tst_qqmldebugjs.cpp
@@ -46,11 +46,11 @@
 #include <QtCore/QDir>
 #include <QtCore/QMutex>
 #include <QtCore/QLibraryInfo>
-#include <QtQml/private/qqmldebugclient_p.h>
 #include <QtQml/QJSEngine>
 
 //QQmlDebugTest
-#include "../shared/debugutil_p.h"
+#include "debugutil_p.h"
+#include "qqmldebugclient.h"
 #include "../../../shared/util.h"
 
 const char *V8REQUEST = "v8request";
diff --git a/tests/auto/qml/debugger/qqmldebugservice/qqmldebugservice.pro b/tests/auto/qml/debugger/qqmldebugservice/qqmldebugservice.pro
index ecb3b2c..dc20396 100644
--- a/tests/auto/qml/debugger/qqmldebugservice/qqmldebugservice.pro
+++ b/tests/auto/qml/debugger/qqmldebugservice/qqmldebugservice.pro
@@ -2,9 +2,10 @@ CONFIG += testcase
 TARGET = tst_qqmldebugservice
 macx:CONFIG -= app_bundle
 
-HEADERS += ../shared/debugutil_p.h
-SOURCES += tst_qqmldebugservice.cpp \
-           ../shared/debugutil.cpp
+SOURCES += tst_qqmldebugservice.cpp
+INCLUDEPATH += ../shared
+include(../../../shared/util.pri)
+include(../shared/debugutil.pri)
 
 CONFIG += parallel_test declarative_debug
 
diff --git a/tests/auto/qml/debugger/qqmldebugservice/tst_qqmldebugservice.cpp b/tests/auto/qml/debugger/qqmldebugservice/tst_qqmldebugservice.cpp
index 3699530..a7fc284 100644
--- a/tests/auto/qml/debugger/qqmldebugservice/tst_qqmldebugservice.cpp
+++ b/tests/auto/qml/debugger/qqmldebugservice/tst_qqmldebugservice.cpp
@@ -47,11 +47,11 @@
 
 #include <QtQml/qqmlengine.h>
 
-#include <private/qqmldebugclient_p.h>
 #include <private/qqmldebugservice_p.h>
 
 #include "../../../shared/util.h"
-#include "../shared/debugutil_p.h"
+#include "debugutil_p.h"
+#include "qqmldebugclient.h"
 
 #define PORT 13769
 #define STR_PORT "13769"
diff --git a/tests/auto/qml/debugger/qqmlenginedebug/qqmlenginedebug.pro b/tests/auto/qml/debugger/qqmlenginedebug/qqmlenginedebug.pro
deleted file mode 100644
index 529c466..0000000
--- a/tests/auto/qml/debugger/qqmlenginedebug/qqmlenginedebug.pro
+++ /dev/null
@@ -1,11 +0,0 @@
-CONFIG += testcase
-TARGET = tst_qqmlenginedebug
-macx:CONFIG -= app_bundle
-
-HEADERS += ../shared/debugutil_p.h
-SOURCES += tst_qqmlenginedebug.cpp \
-           ../shared/debugutil.cpp
-
-CONFIG += parallel_test declarative_debug
-
-QT += core-private qml-private quick-private v8-private testlib
diff --git a/tests/auto/qml/debugger/qqmlenginedebug/tst_qqmlenginedebug.cpp b/tests/auto/qml/debugger/qqmlenginedebug/tst_qqmlenginedebug.cpp
deleted file mode 100644
index df8109a..0000000
--- a/tests/auto/qml/debugger/qqmlenginedebug/tst_qqmlenginedebug.cpp
+++ /dev/null
@@ -1,1235 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <qtest.h>
-#include <QSignalSpy>
-#include <QTimer>
-#include <QHostAddress>
-#include <QDebug>
-#include <QThread>
-
-#include <QtQml/qqmlengine.h>
-#include <QtQml/qqmlcontext.h>
-#include <QtQml/qqmlcomponent.h>
-#include <QtQml/qqmlexpression.h>
-#include <QtQml/qqmlproperty.h>
-#include <QtQuick/qquickitem.h>
-
-#include <private/qqmlbinding_p.h>
-#include <private/qqmlboundsignal_p.h>
-#include <private/qqmlenginedebug_p.h>
-#include <private/qqmldebugservice_p.h>
-#include <private/qqmlmetatype_p.h>
-#include <private/qqmlproperty_p.h>
-
-#include "../shared/debugutil_p.h"
-
-Q_DECLARE_METATYPE(QQmlDebugWatch::State)
-
-class tst_QQmlEngineDebug : public QObject
-{
-    Q_OBJECT
-
-private:
-    QQmlDebugObjectReference findRootObject(int context = 0, bool recursive = false);
-    QQmlDebugPropertyReference findProperty(const QList<QQmlDebugPropertyReference> &props, const QString &name) const;
-    void waitForQuery(QQmlDebugQuery *query);
-
-    void recursiveObjectTest(QObject *o, const QQmlDebugObjectReference &oref, bool recursive) const;
-
-    void recursiveCompareObjects(const QQmlDebugObjectReference &a, const QQmlDebugObjectReference &b) const;
-    void recursiveCompareContexts(const QQmlDebugContextReference &a, const QQmlDebugContextReference &b) const;
-    void compareProperties(const QQmlDebugPropertyReference &a, const QQmlDebugPropertyReference &b) const;
-
-    QQmlDebugConnection *m_conn;
-    QQmlEngineDebug *m_dbg;
-    QQmlEngine *m_engine;
-    QQuickItem *m_rootItem;
-
-    QObjectList m_components;
-
-private slots:
-    void initTestCase();
-    void cleanupTestCase();
-
-    void watch_property();
-    void watch_object();
-    void watch_expression();
-    void watch_expression_data();
-    void watch_context();
-    void watch_file();
-
-    void queryAvailableEngines();
-    void queryRootContexts();
-    void queryObject();
-    void queryObject_data();
-    void queryExpressionResult();
-    void queryExpressionResult_data();
-
-    void tst_QQmlDebugFileReference();
-    void tst_QQmlDebugEngineReference();
-    void tst_QQmlDebugObjectReference();
-    void tst_QQmlDebugContextReference();
-    void tst_QQmlDebugPropertyReference();
-
-    void setBindingForObject();
-    void setMethodBody();
-    void queryObjectTree();
-    void setBindingInStates();
-};
-
-class NonScriptProperty : public QObject {
-    Q_OBJECT
-    Q_PROPERTY(int nonScriptProp READ nonScriptProp WRITE setNonScriptProp NOTIFY nonScriptPropChanged SCRIPTABLE false)
-public:
-    int nonScriptProp() const { return 0; }
-    void setNonScriptProp(int) {}
-signals:
-    void nonScriptPropChanged();
-};
-QML_DECLARE_TYPE(NonScriptProperty)
-
-
-QQmlDebugObjectReference tst_QQmlEngineDebug::findRootObject(int context, bool recursive)
-{
-    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
-    waitForQuery(q_engines);
-
-    if (q_engines->engines().count() == 0)
-        return QQmlDebugObjectReference();
-    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
-    waitForQuery(q_context);
-
-    if (q_context->rootContext().objects().count() == 0)
-        return QQmlDebugObjectReference();
-    QQmlDebugObjectQuery *q_obj = recursive ?
-                m_dbg->queryObjectRecursive(q_context->rootContext().objects()[context], this) :
-                m_dbg->queryObject(q_context->rootContext().objects()[context], this);
-    waitForQuery(q_obj);
-
-    QQmlDebugObjectReference result = q_obj->object();
-
-    delete q_engines;
-    delete q_context;
-    delete q_obj;
-
-    return result;
-}
-
-QQmlDebugPropertyReference tst_QQmlEngineDebug::findProperty(const QList<QQmlDebugPropertyReference> &props, const QString &name) const
-{
-    foreach(const QQmlDebugPropertyReference &p, props) {
-        if (p.name() == name)
-            return p;
-    }
-    return QQmlDebugPropertyReference();
-}
-
-void tst_QQmlEngineDebug::waitForQuery(QQmlDebugQuery *query)
-{
-    QVERIFY(query);
-    QCOMPARE(query->parent(), qobject_cast<QObject*>(this));
-    QVERIFY(query->state() == QQmlDebugQuery::Waiting);
-    if (!QQmlDebugTest::waitForSignal(query, SIGNAL(stateChanged(QQmlDebugQuery::State))))
-        QFAIL("query timed out");
-}
-
-void tst_QQmlEngineDebug::recursiveObjectTest(QObject *o, const QQmlDebugObjectReference &oref, bool recursive) const
-{
-    const QMetaObject *meta = o->metaObject();
-
-    QQmlType *type = QQmlMetaType::qmlType(meta);
-    QString className = type ? QString(type->qmlTypeName()) : QString(meta->className());
-    className = className.mid(className.lastIndexOf(QLatin1Char('/'))+1);
-
-    QCOMPARE(oref.debugId(), QQmlDebugService::idForObject(o));
-    QCOMPARE(oref.name(), o->objectName());
-    QCOMPARE(oref.className(), className);
-    QCOMPARE(oref.contextDebugId(), QQmlDebugService::idForObject(qmlContext(o)));
-
-    const QObjectList &children = o->children();
-    for (int i=0; i<children.count(); i++) {
-        QObject *child = children[i];
-        if (!qmlContext(child))
-            continue;
-        int debugId = QQmlDebugService::idForObject(child);
-        QVERIFY(debugId >= 0);
-
-        QQmlDebugObjectReference cref;
-        foreach (const QQmlDebugObjectReference &ref, oref.children()) {
-            if (ref.debugId() == debugId) {
-                cref = ref;
-                break;
-            }
-        }
-        QVERIFY(cref.debugId() >= 0);
-
-        if (recursive)
-            recursiveObjectTest(child, cref, true);
-    }
-
-    foreach (const QQmlDebugPropertyReference &p, oref.properties()) {
-        QCOMPARE(p.objectDebugId(), QQmlDebugService::idForObject(o));
-
-        // signal properties are fake - they are generated from QQmlBoundSignal children
-        if (p.name().startsWith("on") && p.name().length() > 2 && p.name()[2].isUpper()) {
-            QList<QQmlBoundSignal*> signalHandlers = o->findChildren<QQmlBoundSignal*>();
-            QString signal = p.value().toString();
-            bool found = false;
-            for (int i = 0; i < signalHandlers.count(); ++i)
-                if (signalHandlers.at(i)->expression()->expression() == signal) {
-                    found = true;
-                    break;
-                }
-            QVERIFY(found);
-            QVERIFY(p.valueTypeName().isEmpty());
-            QVERIFY(p.binding().isEmpty());
-            QVERIFY(!p.hasNotifySignal());
-            continue;
-        }
-
-        QMetaProperty pmeta = meta->property(meta->indexOfProperty(p.name().toUtf8().constData()));
-
-        QCOMPARE(p.name(), QString::fromUtf8(pmeta.name()));
-
-        if (pmeta.type() < QVariant::UserType && pmeta.userType() != QMetaType::QVariant) // TODO test complex types
-            QCOMPARE(p.value(), pmeta.read(o));
-
-        if (p.name() == "parent")
-            QVERIFY(p.valueTypeName() == "QGraphicsObject*" || p.valueTypeName() == "QQuickItem*");
-        else
-            QCOMPARE(p.valueTypeName(), QString::fromUtf8(pmeta.typeName()));
-
-        QQmlAbstractBinding *binding = 
-            QQmlPropertyPrivate::binding(QQmlProperty(o, p.name()));
-        if (binding)
-            QCOMPARE(binding->expression(), p.binding());
-
-        QCOMPARE(p.hasNotifySignal(), pmeta.hasNotifySignal());
-
-        QVERIFY(pmeta.isValid());
-    }
-}
-
-void tst_QQmlEngineDebug::recursiveCompareObjects(const QQmlDebugObjectReference &a, const QQmlDebugObjectReference &b) const
-{
-    QCOMPARE(a.debugId(), b.debugId());
-    QCOMPARE(a.className(), b.className());
-    QCOMPARE(a.name(), b.name());
-    QCOMPARE(a.contextDebugId(), b.contextDebugId());
-
-    QCOMPARE(a.source().url(), b.source().url());
-    QCOMPARE(a.source().lineNumber(), b.source().lineNumber());
-    QCOMPARE(a.source().columnNumber(), b.source().columnNumber());
-
-    QCOMPARE(a.properties().count(), b.properties().count());
-    QCOMPARE(a.children().count(), b.children().count());
-
-    QList<QQmlDebugPropertyReference> aprops = a.properties();
-    QList<QQmlDebugPropertyReference> bprops = b.properties();
-
-    for (int i=0; i<aprops.count(); i++)
-        compareProperties(aprops[i], bprops[i]);
-
-    for (int i=0; i<a.children().count(); i++)
-        recursiveCompareObjects(a.children()[i], b.children()[i]);
-}
-
-void tst_QQmlEngineDebug::recursiveCompareContexts(const QQmlDebugContextReference &a, const QQmlDebugContextReference &b) const
-{
-    QCOMPARE(a.debugId(), b.debugId());
-    QCOMPARE(a.name(), b.name());
-    QCOMPARE(a.objects().count(), b.objects().count());
-    QCOMPARE(a.contexts().count(), b.contexts().count());
-
-    for (int i=0; i<a.objects().count(); i++)
-        recursiveCompareObjects(a.objects()[i], b.objects()[i]);
-
-    for (int i=0; i<a.contexts().count(); i++)
-        recursiveCompareContexts(a.contexts()[i], b.contexts()[i]);
-}
-
-void tst_QQmlEngineDebug::compareProperties(const QQmlDebugPropertyReference &a, const QQmlDebugPropertyReference &b) const
-{
-    QCOMPARE(a.objectDebugId(), b.objectDebugId());
-    QCOMPARE(a.name(), b.name());
-    QCOMPARE(a.value(), b.value());
-    QCOMPARE(a.valueTypeName(), b.valueTypeName());
-    QCOMPARE(a.binding(), b.binding());
-    QCOMPARE(a.hasNotifySignal(), b.hasNotifySignal());
-}
-
-void tst_QQmlEngineDebug::initTestCase()
-{
-    qRegisterMetaType<QQmlDebugWatch::State>();
-    qmlRegisterType<NonScriptProperty>("Test", 1, 0, "NonScriptPropertyElement");
-
-    QTest::ignoreMessage(QtWarningMsg, "QML Debugger: Waiting for connection on port 3768...");
-    m_engine = new QQmlEngine(this);
-
-    QList<QByteArray> qml;
-    qml << "import QtQuick 2.0\n"
-           "import Test 1.0\n"
-           "Item {"
-                "id: root\n"
-                "width: 10; height: 20; scale: blueRect.scale;"
-                "Rectangle { id: blueRect; width: 500; height: 600; color: \"blue\"; }"
-                "Text { color: blueRect.color; }"
-                "MouseArea {"
-                    "onEntered: { console.log('hello') }"
-                "}"
-                "property variant varObj\n"
-                "property variant varObjList: []\n"
-                "property variant varObjMap\n"
-                "Component.onCompleted: {\n"
-                    "varObj = blueRect;\n"
-                    "var list = varObjList;\n"
-                    "list[0] = blueRect;\n"
-                    "varObjList = list;\n"
-                    "var map = new Object;\n"
-                    "map.rect = blueRect;\n"
-                    "varObjMap = map;\n"
-                "}\n"
-                "NonScriptPropertyElement {\n"
-                "}\n"
-            "}";
-
-    // add second component to test multiple root contexts
-    qml << "import QtQuick 2.0\n"
-            "Item {}";
-
-    // and a third to test methods
-    qml << "import QtQuick 2.0\n"
-            "Item {"
-                "function myMethodNoArgs() { return 3; }\n"
-                "function myMethod(a) { return a + 9; }\n"
-                "function myMethodIndirect() { myMethod(3); }\n"
-            "}";
-
-    // and a fourth to test states
-    qml << "import QtQuick 2.0\n"
-           "Rectangle {\n"
-                "id:rootRect\n"
-                "width:100\n"
-                "states: [\n"
-                    "State {\n"
-                        "name:\"state1\"\n"
-                        "PropertyChanges {\n"
-                            "target:rootRect\n"
-                            "width:200\n"
-                        "}\n"
-                    "}\n"
-                "]\n"
-                "transitions: [\n"
-                    "Transition {\n"
-                        "from:\"*\"\n"
-                        "to:\"state1\"\n"
-                        "PropertyAnimation {\n"
-                            "target:rootRect\n"
-                            "property:\"width\"\n"
-                            "duration:100\n"
-                        "}\n"
-                    "}\n"
-                "]\n"
-           "}\n"
-           ;
-
-    for (int i=0; i<qml.count(); i++) {
-        QQmlComponent component(m_engine);
-        component.setData(qml[i], QUrl::fromLocalFile(""));
-        QVERIFY(component.isReady());  // fails if bad syntax
-        m_components << qobject_cast<QQuickItem*>(component.create());
-    }
-    m_rootItem = qobject_cast<QQuickItem*>(m_components.first());
-
-    // add an extra context to test for multiple contexts
-    QQmlContext *context = new QQmlContext(m_engine->rootContext(), this);
-    context->setObjectName("tst_QQmlDebug_childContext");
-
-    m_conn = new QQmlDebugConnection(this);
-    m_conn->connectToHost("127.0.0.1", 3768);
-
-    QTest::ignoreMessage(QtWarningMsg, "QML Debugger: Connection established.");
-    bool ok = m_conn->waitForConnected();
-    QVERIFY(ok);
-    QTRY_VERIFY(QQmlDebugService::hasDebuggingClient());
-    m_dbg = new QQmlEngineDebug(m_conn, this);
-    QTRY_VERIFY(m_dbg->state() == QQmlEngineDebug::Enabled);
-}
-
-void tst_QQmlEngineDebug::cleanupTestCase()
-{
-    delete m_dbg;
-    delete m_conn;
-    qDeleteAll(m_components);
-    delete m_engine;
-}
-
-void tst_QQmlEngineDebug::setMethodBody()
-{
-    QQmlDebugObjectReference obj = findRootObject(2);
-
-    QObject *root = m_components.at(2);
-    // Without args
-    {
-    QVariant rv;
-    QVERIFY(QMetaObject::invokeMethod(root, "myMethodNoArgs", Qt::DirectConnection,
-                                      Q_RETURN_ARG(QVariant, rv)));
-    QVERIFY(rv == QVariant(qreal(3)));
-
-
-    QVERIFY(m_dbg->setMethodBody(obj.debugId(), "myMethodNoArgs", "return 7"));
-    QTest::qWait(100);
-
-    QVERIFY(QMetaObject::invokeMethod(root, "myMethodNoArgs", Qt::DirectConnection,
-                                      Q_RETURN_ARG(QVariant, rv)));
-    QVERIFY(rv == QVariant(qreal(7)));
-    }
-
-    // With args
-    {
-    QVariant rv;
-    QVERIFY(QMetaObject::invokeMethod(root, "myMethod", Qt::DirectConnection,
-                                      Q_RETURN_ARG(QVariant, rv), Q_ARG(QVariant, QVariant(19))));
-    QVERIFY(rv == QVariant(qreal(28)));
-
-    QVERIFY(m_dbg->setMethodBody(obj.debugId(), "myMethod", "return a + 7"));
-    QTest::qWait(100);
-
-    QVERIFY(QMetaObject::invokeMethod(root, "myMethod", Qt::DirectConnection,
-                                      Q_RETURN_ARG(QVariant, rv), Q_ARG(QVariant, QVariant(19))));
-    QVERIFY(rv == QVariant(qreal(26)));
-    }
-}
-
-void tst_QQmlEngineDebug::watch_property()
-{
-    QQmlDebugObjectReference obj = findRootObject();
-    QQmlDebugPropertyReference prop = findProperty(obj.properties(), "width");
-
-    QQmlDebugPropertyWatch *watch;
-
-    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
-    watch = unconnected->addWatch(prop, this);
-    QCOMPARE(watch->state(), QQmlDebugWatch::Dead);
-    delete watch;
-    delete unconnected;
-
-    watch = m_dbg->addWatch(QQmlDebugPropertyReference(), this);
-    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
-    QCOMPARE(watch->state(), QQmlDebugWatch::Inactive);
-    delete watch;
-
-    watch = m_dbg->addWatch(prop, this);
-    QCOMPARE(watch->state(), QQmlDebugWatch::Waiting);
-    QCOMPARE(watch->objectDebugId(), obj.debugId());
-    QCOMPARE(watch->name(), prop.name());
-
-    QSignalSpy spy(watch, SIGNAL(valueChanged(QByteArray,QVariant)));
-
-    int origWidth = m_rootItem->property("width").toInt();
-    m_rootItem->setProperty("width", origWidth*2);
-
-    // stateChanged() is received before valueChanged()
-    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
-    QCOMPARE(watch->state(), QQmlDebugWatch::Active);
-    QCOMPARE(spy.count(), 1);
-
-    m_dbg->removeWatch(watch);
-    delete watch;
-
-    // restore original value and verify spy doesn't get additional signal since watch has been removed
-    m_rootItem->setProperty("width", origWidth);
-    QTest::qWait(100);
-    QCOMPARE(spy.count(), 1);
-
-    QCOMPARE(spy.at(0).at(0).value<QByteArray>(), prop.name().toUtf8());
-    QCOMPARE(spy.at(0).at(1).value<QVariant>(), qVariantFromValue(origWidth*2));
-}
-
-void tst_QQmlEngineDebug::watch_object()
-{
-    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
-    waitForQuery(q_engines);
-
-    QVERIFY(q_engines->engines().count() > 0);
-    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
-    waitForQuery(q_context);
-
-    QVERIFY(q_context->rootContext().objects().count() > 0);
-    QQmlDebugObjectQuery *q_obj = m_dbg->queryObject(q_context->rootContext().objects()[0], this);
-    waitForQuery(q_obj);
-
-    QQmlDebugObjectReference obj = q_obj->object();
-
-    delete q_engines;
-    delete q_context;
-    delete q_obj;
-
-    QQmlDebugWatch *watch;
-
-    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
-    watch = unconnected->addWatch(obj, this);
-    QCOMPARE(watch->state(), QQmlDebugWatch::Dead);
-    delete watch;
-    delete unconnected;
-
-    watch = m_dbg->addWatch(QQmlDebugObjectReference(), this);
-    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
-    QCOMPARE(watch->state(), QQmlDebugWatch::Inactive);
-    delete watch;
-
-    watch = m_dbg->addWatch(obj, this);
-    QCOMPARE(watch->state(), QQmlDebugWatch::Waiting);
-    QCOMPARE(watch->objectDebugId(), obj.debugId());
-
-    QSignalSpy spy(watch, SIGNAL(valueChanged(QByteArray,QVariant)));
-
-    int origWidth = m_rootItem->property("width").toInt();
-    int origHeight = m_rootItem->property("height").toInt();
-    m_rootItem->setProperty("width", origWidth*2);
-    m_rootItem->setProperty("height", origHeight*2);
-
-    // stateChanged() is received before any valueChanged() signals
-    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
-    QCOMPARE(watch->state(), QQmlDebugWatch::Active);
-    QVERIFY(spy.count() > 0);
-
-    int newWidth = -1;
-    int newHeight = -1;
-    for (int i=0; i<spy.count(); i++) {
-        const QVariantList &values = spy[i];
-        if (values[0].value<QByteArray>() == "width")
-            newWidth = values[1].value<QVariant>().toInt();
-        else if (values[0].value<QByteArray>() == "height")
-            newHeight = values[1].value<QVariant>().toInt();
-
-    }
-
-    m_dbg->removeWatch(watch);
-    delete watch;
-
-    // since watch has been removed, restoring the original values should not trigger a valueChanged()
-    spy.clear();
-    m_rootItem->setProperty("width", origWidth);
-    m_rootItem->setProperty("height", origHeight);
-    QTest::qWait(100);
-    QCOMPARE(spy.count(), 0);
-
-    QCOMPARE(newWidth, origWidth * 2);
-    QCOMPARE(newHeight, origHeight * 2);
-}
-
-void tst_QQmlEngineDebug::watch_expression()
-{
-    QFETCH(QString, expr);
-    QFETCH(int, increment);
-    QFETCH(int, incrementCount);
-
-    int origWidth = m_rootItem->property("width").toInt();
-
-    QQmlDebugObjectReference obj = findRootObject();
-
-    QQmlDebugObjectExpressionWatch *watch;
-
-    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
-    watch = unconnected->addWatch(obj, expr, this);
-    QCOMPARE(watch->state(), QQmlDebugWatch::Dead);
-    delete watch;
-    delete unconnected;
-
-    watch = m_dbg->addWatch(QQmlDebugObjectReference(), expr, this);
-    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
-    QCOMPARE(watch->state(), QQmlDebugWatch::Inactive);
-    delete watch;
-
-    watch = m_dbg->addWatch(obj, expr, this);
-    QCOMPARE(watch->state(), QQmlDebugWatch::Waiting);
-    QCOMPARE(watch->objectDebugId(), obj.debugId());
-    QCOMPARE(watch->expression(), expr);
-
-    QSignalSpy spyState(watch, SIGNAL(stateChanged(QQmlDebugWatch::State)));
-
-    QSignalSpy spy(watch, SIGNAL(valueChanged(QByteArray,QVariant)));
-    int expectedSpyCount = incrementCount + 1;  // should also get signal with expression's initial value
-
-    int width = origWidth;
-    for (int i=0; i<incrementCount+1; i++) {
-        if (i > 0) {
-            width += increment;
-            m_rootItem->setProperty("width", width);
-        }
-        if (!QQmlDebugTest::waitForSignal(watch, SIGNAL(valueChanged(QByteArray,QVariant))))
-            QFAIL("Did not receive valueChanged() for expression");
-    }
-
-    if (spyState.count() == 0)
-        QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
-    QCOMPARE(spyState.count(), 1);
-    QCOMPARE(watch->state(), QQmlDebugWatch::Active);
-
-    m_dbg->removeWatch(watch);
-    delete watch;
-
-    // restore original value and verify spy doesn't get a signal since watch has been removed
-    m_rootItem->setProperty("width", origWidth);
-    QTest::qWait(100);
-    QCOMPARE(spy.count(), expectedSpyCount);
-
-    width = origWidth + increment;
-    for (int i=0; i<spy.count(); i++) {
-        QCOMPARE(spy.at(i).at(1).value<QVariant>().toInt(), width);
-        width += increment;
-    }
-}
-
-void tst_QQmlEngineDebug::watch_expression_data()
-{
-    QTest::addColumn<QString>("expr");
-    QTest::addColumn<int>("increment");
-    QTest::addColumn<int>("incrementCount");
-
-    QTest::newRow("width") << "width" << 0 << 0;
-    QTest::newRow("width+10") << "width + 10" << 10 << 5;
-}
-
-void tst_QQmlEngineDebug::watch_context()
-{
-    QQmlDebugContextReference c;
-    QTest::ignoreMessage(QtWarningMsg, "QQmlEngineDebug::addWatch(): Not implemented");
-    QVERIFY(!m_dbg->addWatch(c, QString(), this));
-}
-
-void tst_QQmlEngineDebug::watch_file()
-{
-    QQmlDebugFileReference f;
-    QTest::ignoreMessage(QtWarningMsg, "QQmlEngineDebug::addWatch(): Not implemented");
-    QVERIFY(!m_dbg->addWatch(f, this));
-}
-
-void tst_QQmlEngineDebug::queryAvailableEngines()
-{
-    QQmlDebugEnginesQuery *q_engines;
-
-    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
-    q_engines = unconnected->queryAvailableEngines(0);
-    QCOMPARE(q_engines->state(), QQmlDebugQuery::Error);
-    delete q_engines;
-    delete unconnected;
-
-    q_engines = m_dbg->queryAvailableEngines(this);
-    delete q_engines;
-
-    q_engines = m_dbg->queryAvailableEngines(this);
-    QVERIFY(q_engines->engines().isEmpty());
-    waitForQuery(q_engines);
-
-    // TODO test multiple engines
-    QList<QQmlDebugEngineReference> engines = q_engines->engines();
-    QCOMPARE(engines.count(), 1);
-
-    foreach(const QQmlDebugEngineReference &e, engines) {
-        QCOMPARE(e.debugId(), QQmlDebugService::idForObject(m_engine));
-        QCOMPARE(e.name(), m_engine->objectName());
-    }
-
-    // Make query invalid by deleting client
-    q_engines = m_dbg->queryAvailableEngines(this);
-    QCOMPARE(q_engines->state(), QQmlDebugQuery::Waiting);
-    delete m_dbg;
-    QCOMPARE(q_engines->state(), QQmlDebugQuery::Error);
-    delete q_engines;
-    m_dbg = new QQmlEngineDebug(m_conn, this);
-}
-
-void tst_QQmlEngineDebug::queryRootContexts()
-{
-    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
-    waitForQuery(q_engines);
-    int engineId = q_engines->engines()[0].debugId();
-    delete q_engines;
-
-    QQmlDebugRootContextQuery *q_context;
-
-    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
-    q_context = unconnected->queryRootContexts(engineId, this);
-    QCOMPARE(q_context->state(), QQmlDebugQuery::Error);
-    delete q_context;
-    delete unconnected;
-
-    q_context = m_dbg->queryRootContexts(engineId, this);
-    delete q_context;
-
-    q_context = m_dbg->queryRootContexts(engineId, this);
-    waitForQuery(q_context);
-
-    QQmlContext *actualContext = m_engine->rootContext();
-    QQmlDebugContextReference context = q_context->rootContext();
-    QCOMPARE(context.debugId(), QQmlDebugService::idForObject(actualContext));
-    QCOMPARE(context.name(), actualContext->objectName());
-
-    QCOMPARE(context.objects().count(), 4); // 4 qml component objects created for context in main()
-
-    // root context query sends only root object data - it doesn't fill in
-    // the children or property info
-    QCOMPARE(context.objects()[0].properties().count(), 0);
-    QCOMPARE(context.objects()[0].children().count(), 0);
-
-    QCOMPARE(context.contexts().count(), 5);
-    QVERIFY(context.contexts()[0].debugId() >= 0);
-    QCOMPARE(context.contexts()[0].name(), QString("tst_QQmlDebug_childContext"));
-
-    // Make query invalid by deleting client
-    q_context = m_dbg->queryRootContexts(engineId, this);
-    QCOMPARE(q_context->state(), QQmlDebugQuery::Waiting);
-    delete m_dbg;
-    QCOMPARE(q_context->state(), QQmlDebugQuery::Error);
-    delete q_context;
-    m_dbg = new QQmlEngineDebug(m_conn, this);
-}
-
-void tst_QQmlEngineDebug::queryObject()
-{
-    QFETCH(bool, recursive);
-
-    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
-    waitForQuery(q_engines);
-
-    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
-    waitForQuery(q_context);
-    QQmlDebugObjectReference rootObject = q_context->rootContext().objects()[0];
-
-    QQmlDebugObjectQuery *q_obj = 0;
-
-    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
-    q_obj = recursive ? unconnected->queryObjectRecursive(rootObject, this) : unconnected->queryObject(rootObject, this);
-    QCOMPARE(q_obj->state(), QQmlDebugQuery::Error);
-    delete q_obj;
-    delete unconnected;
-
-    q_obj = recursive ? m_dbg->queryObjectRecursive(rootObject, this) : m_dbg->queryObject(rootObject, this);
-    delete q_obj;
-
-    q_obj = recursive ? m_dbg->queryObjectRecursive(rootObject, this) : m_dbg->queryObject(rootObject, this);
-    waitForQuery(q_obj);
-
-    QQmlDebugObjectReference obj = q_obj->object();
-
-    delete q_engines;
-    delete q_context;
-
-    // Make query invalid by deleting client
-    q_obj = recursive ? m_dbg->queryObjectRecursive(rootObject, this) : m_dbg->queryObject(rootObject, this);
-    QCOMPARE(q_obj->state(), QQmlDebugQuery::Waiting);
-    delete m_dbg;
-    QCOMPARE(q_obj->state(), QQmlDebugQuery::Error);
-    delete q_obj;
-    m_dbg = new QQmlEngineDebug(m_conn, this);
-
-    // check source as defined in main()
-    QQmlDebugFileReference source = obj.source();
-    QCOMPARE(source.url(), QUrl::fromLocalFile(""));
-    QCOMPARE(source.lineNumber(), 3);
-    QCOMPARE(source.columnNumber(), 1);
-
-    // generically test all properties, children and childrens' properties
-    recursiveObjectTest(m_rootItem, obj, recursive);
-
-    if (recursive) {
-        foreach(const QQmlDebugObjectReference &child, obj.children())
-            QVERIFY(child.properties().count() > 0);
-
-        QQmlDebugObjectReference rect;
-        QQmlDebugObjectReference text;
-        foreach (const QQmlDebugObjectReference &child, obj.children()) {
-            if (child.className() == "Rectangle")
-                rect = child;
-            else if (child.className() == "Text")
-                text = child;
-        }
-
-        // test specific property values
-        QCOMPARE(findProperty(rect.properties(), "width").value(), qVariantFromValue(500));
-        QCOMPARE(findProperty(rect.properties(), "height").value(), qVariantFromValue(600));
-        QCOMPARE(findProperty(rect.properties(), "color").value(), qVariantFromValue(QColor("blue")));
-
-        QCOMPARE(findProperty(text.properties(), "color").value(), qVariantFromValue(QColor("blue")));
-    } else {
-        foreach(const QQmlDebugObjectReference &child, obj.children())
-            QCOMPARE(child.properties().count(), 0);
-    }
-}
-
-void tst_QQmlEngineDebug::queryObject_data()
-{
-    QTest::addColumn<bool>("recursive");
-
-    QTest::newRow("non-recursive") << false;
-    QTest::newRow("recursive") << true;
-}
-
-void tst_QQmlEngineDebug::queryExpressionResult()
-{
-    QFETCH(QString, expr);
-    QFETCH(QVariant, result);
-
-    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
-    waitForQuery(q_engines);    // check immediate deletion is ok
-
-    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
-    waitForQuery(q_context);
-    int objectId = q_context->rootContext().objects()[0].debugId();
-
-    QQmlDebugExpressionQuery *q_expr;
-
-    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
-    q_expr = unconnected->queryExpressionResult(objectId, expr, this);
-    QCOMPARE(q_expr->state(), QQmlDebugQuery::Error);
-    delete q_expr;
-    delete unconnected;
-
-    q_expr = m_dbg->queryExpressionResult(objectId, expr, this);
-    delete q_expr;
-
-    q_expr = m_dbg->queryExpressionResult(objectId, expr, this);
-    QCOMPARE(q_expr->expression().toString(), expr);
-    waitForQuery(q_expr);
-
-    QCOMPARE(q_expr->result(), result);
-
-    delete q_engines;
-    delete q_context;
-
-    // Make query invalid by deleting client
-    q_expr = m_dbg->queryExpressionResult(objectId, expr, this);
-    QCOMPARE(q_expr->state(), QQmlDebugQuery::Waiting);
-    delete m_dbg;
-    QCOMPARE(q_expr->state(), QQmlDebugQuery::Error);
-    delete q_expr;
-    m_dbg = new QQmlEngineDebug(m_conn, this);
-}
-
-void tst_QQmlEngineDebug::queryExpressionResult_data()
-{
-    QTest::addColumn<QString>("expr");
-    QTest::addColumn<QVariant>("result");
-
-    QTest::newRow("width + 50") << "width + 50" << qVariantFromValue(60);
-    QTest::newRow("blueRect.width") << "blueRect.width" << qVariantFromValue(500);
-    QTest::newRow("bad expr") << "aeaef" << qVariantFromValue(QString("<undefined>"));
-    QTest::newRow("QObject*") << "varObj" << qVariantFromValue(QString("<unnamed object>"));
-    QTest::newRow("list of QObject*") << "varObjList" << qVariantFromValue(QString("<unknown value>"));
-    QVariantMap map;
-    map.insert(QLatin1String("rect"), QVariant(QLatin1String("<unnamed object>")));
-    QTest::newRow("varObjMap") << "varObjMap" << qVariantFromValue(map);
-}
-
-void tst_QQmlEngineDebug::tst_QQmlDebugFileReference()
-{
-    QQmlDebugFileReference ref;
-    QVERIFY(ref.url().isEmpty());
-    QCOMPARE(ref.lineNumber(), -1);
-    QCOMPARE(ref.columnNumber(), -1);
-
-    ref.setUrl(QUrl("http://test"));
-    QCOMPARE(ref.url(), QUrl("http://test"));
-    ref.setLineNumber(1);
-    QCOMPARE(ref.lineNumber(), 1);
-    ref.setColumnNumber(1);
-    QCOMPARE(ref.columnNumber(), 1);
-
-    QQmlDebugFileReference copy(ref);
-    QQmlDebugFileReference copyAssign;
-    copyAssign = ref;
-    foreach (const QQmlDebugFileReference &r, (QList<QQmlDebugFileReference>() << copy << copyAssign)) {
-        QCOMPARE(r.url(), ref.url());
-        QCOMPARE(r.lineNumber(), ref.lineNumber());
-        QCOMPARE(r.columnNumber(), ref.columnNumber());
-    }
-}
-
-void tst_QQmlEngineDebug::tst_QQmlDebugEngineReference()
-{
-    QQmlDebugEngineReference ref;
-    QCOMPARE(ref.debugId(), -1);
-    QVERIFY(ref.name().isEmpty());
-
-    ref = QQmlDebugEngineReference(1);
-    QCOMPARE(ref.debugId(), 1);
-    QVERIFY(ref.name().isEmpty());
-
-    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
-    waitForQuery(q_engines);
-    ref = q_engines->engines()[0];
-    delete q_engines;
-
-    QQmlDebugEngineReference copy(ref);
-    QQmlDebugEngineReference copyAssign;
-    copyAssign = ref;
-    foreach (const QQmlDebugEngineReference &r, (QList<QQmlDebugEngineReference>() << copy << copyAssign)) {
-        QCOMPARE(r.debugId(), ref.debugId());
-        QCOMPARE(r.name(), ref.name());
-    }
-}
-
-void tst_QQmlEngineDebug::tst_QQmlDebugObjectReference()
-{
-    QQmlDebugObjectReference ref;
-    QCOMPARE(ref.debugId(), -1);
-    QCOMPARE(ref.className(), QString());
-    QCOMPARE(ref.name(), QString());
-    QCOMPARE(ref.contextDebugId(), -1);
-    QVERIFY(ref.properties().isEmpty());
-    QVERIFY(ref.children().isEmpty());
-
-    QQmlDebugFileReference source = ref.source();
-    QVERIFY(source.url().isEmpty());
-    QVERIFY(source.lineNumber() < 0);
-    QVERIFY(source.columnNumber() < 0);
-
-    ref = QQmlDebugObjectReference(1);
-    QCOMPARE(ref.debugId(), 1);
-
-    QQmlDebugObjectReference rootObject = findRootObject();
-    QQmlDebugObjectQuery *query = m_dbg->queryObjectRecursive(rootObject, this);
-    waitForQuery(query);
-    ref = query->object();
-    delete query;
-
-    QVERIFY(ref.debugId() >= 0);
-
-    QQmlDebugObjectReference copy(ref);
-    QQmlDebugObjectReference copyAssign;
-    copyAssign = ref;
-    foreach (const QQmlDebugObjectReference &r, (QList<QQmlDebugObjectReference>() << copy << copyAssign))
-        recursiveCompareObjects(r, ref);
-}
-
-void tst_QQmlEngineDebug::tst_QQmlDebugContextReference()
-{
-    QQmlDebugContextReference ref;
-    QCOMPARE(ref.debugId(), -1);
-    QVERIFY(ref.name().isEmpty());
-    QVERIFY(ref.objects().isEmpty());
-    QVERIFY(ref.contexts().isEmpty());
-
-    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
-    waitForQuery(q_engines);
-    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
-    waitForQuery(q_context);
-
-    ref = q_context->rootContext();
-    delete q_engines;
-    delete q_context;
-    QVERIFY(ref.debugId() >= 0);
-
-    QQmlDebugContextReference copy(ref);
-    QQmlDebugContextReference copyAssign;
-    copyAssign = ref;
-    foreach (const QQmlDebugContextReference &r, (QList<QQmlDebugContextReference>() << copy << copyAssign))
-        recursiveCompareContexts(r, ref);
-}
-
-void tst_QQmlEngineDebug::tst_QQmlDebugPropertyReference()
-{
-    QQmlDebugObjectReference rootObject = findRootObject();
-    QQmlDebugObjectQuery *query = m_dbg->queryObject(rootObject, this);
-    waitForQuery(query);
-    QQmlDebugObjectReference obj = query->object();
-    delete query;
-
-    QQmlDebugPropertyReference ref = findProperty(obj.properties(), "scale");
-    QVERIFY(ref.objectDebugId() > 0);
-    QVERIFY(!ref.name().isEmpty());
-    QVERIFY(!ref.value().isNull());
-    QVERIFY(!ref.valueTypeName().isEmpty());
-    QVERIFY(!ref.binding().isEmpty());
-    QVERIFY(ref.hasNotifySignal());
-
-    QQmlDebugPropertyReference copy(ref);
-    QQmlDebugPropertyReference copyAssign;
-    copyAssign = ref;
-    foreach (const QQmlDebugPropertyReference &r, (QList<QQmlDebugPropertyReference>() << copy << copyAssign))
-        compareProperties(r, ref);
-}
-
-void tst_QQmlEngineDebug::setBindingForObject()
-{
-    QQmlDebugObjectReference rootObject = findRootObject();
-    QVERIFY(rootObject.debugId() != -1);
-    QQmlDebugPropertyReference widthPropertyRef = findProperty(rootObject.properties(), "width");
-
-    QCOMPARE(widthPropertyRef.value(), QVariant(10));
-    QCOMPARE(widthPropertyRef.binding(), QString());
-
-    //
-    // set literal
-    //
-    m_dbg->setBindingForObject(rootObject.debugId(), "width", "15", true);
-
-    rootObject = findRootObject();
-    widthPropertyRef =  findProperty(rootObject.properties(), "width");
-
-    QCOMPARE(widthPropertyRef.value(), QVariant(15));
-    QCOMPARE(widthPropertyRef.binding(), QString());
-
-    //
-    // set expression
-    //
-    m_dbg->setBindingForObject(rootObject.debugId(), "width", "height", false);
-
-    rootObject = findRootObject();
-    widthPropertyRef =  findProperty(rootObject.properties(), "width");
-
-    QCOMPARE(widthPropertyRef.value(), QVariant(20));
-    QCOMPARE(widthPropertyRef.binding(), QString("height"));
-
-    //
-    // reset
-    //
-    m_dbg->resetBindingForObject(rootObject.debugId(), "width");
-
-    rootObject = findRootObject();
-    widthPropertyRef =  findProperty(rootObject.properties(), "width");
-
-   // QCOMPARE(widthPropertyRef.value(), QVariant(0)); // TODO: Shouldn't this work?
-    QCOMPARE(widthPropertyRef.binding(), QString());
-
-    //
-    // set handler
-    //
-    rootObject = findRootObject();
-    QCOMPARE(rootObject.children().size(), 5); // Rectangle, Text, MouseArea, Component.onCompleted, NonScriptPropertyElement
-    QQmlDebugObjectReference mouseAreaObject = rootObject.children().at(2);
-    QQmlDebugObjectQuery *q_obj = m_dbg->queryObjectRecursive(mouseAreaObject, this);
-    waitForQuery(q_obj);
-    mouseAreaObject = q_obj->object();
-
-    QCOMPARE(mouseAreaObject.className(), QString("MouseArea"));
-
-    QQmlDebugPropertyReference onEnteredRef = findProperty(mouseAreaObject.properties(), "onEntered");
-
-    QCOMPARE(onEnteredRef.name(), QString("onEntered"));
-    QCOMPARE(onEnteredRef.value(),  QVariant("(function onEntered() { { console.log('hello') } })"));
-
-    m_dbg->setBindingForObject(mouseAreaObject.debugId(), "onEntered", "{console.log('hello, world') }", false) ;
-
-    rootObject = findRootObject();
-    mouseAreaObject = rootObject.children().at(2);
-    q_obj = m_dbg->queryObjectRecursive(mouseAreaObject, this);
-    waitForQuery(q_obj);
-    mouseAreaObject = q_obj->object();
-    onEnteredRef = findProperty(mouseAreaObject.properties(), "onEntered");
-    QCOMPARE(onEnteredRef.name(), QString("onEntered"));
-    QCOMPARE(onEnteredRef.value(),  QVariant("{console.log('hello, world') }"));
-}
-
-void tst_QQmlEngineDebug::setBindingInStates()
-{
-    // Check if changing bindings of propertychanges works
-
-    const int sourceIndex = 3;
-
-    QQmlDebugObjectReference obj = findRootObject(sourceIndex);
-
-    QVERIFY(obj.debugId() != -1);
-    QVERIFY(obj.children().count() >= 2);
-
-    // We are going to switch state a couple of times, we need to get rid of the transition before
-    QQmlDebugExpressionQuery *q_deleteTransition = m_dbg->queryExpressionResult(obj.debugId(),QString("transitions = []"),this);
-    waitForQuery(q_deleteTransition);
-    delete q_deleteTransition;
-
-
-    // check initial value of the property that is changing
-    QQmlDebugExpressionQuery *q_setState;
-    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"state1\""),this);
-    waitForQuery(q_setState);
-    delete q_setState;
-
-    obj = findRootObject(sourceIndex);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),200);
-
-
-    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"\""),this);
-    waitForQuery(q_setState);
-    delete q_setState;
-
-
-    obj = findRootObject(sourceIndex, true);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),100);
-
-
-    // change the binding
-    QQmlDebugObjectReference state = obj.children()[1];
-    QCOMPARE(state.className(), QString("State"));
-    QVERIFY(state.children().count() > 0);
-
-    QQmlDebugObjectReference propertyChange = state.children()[0];
-    QVERIFY(propertyChange.debugId() != -1);
-
-    QVERIFY( m_dbg->setBindingForObject(propertyChange.debugId(), "width",QVariant(300),true) );
-
-    // check properties changed in state
-    obj = findRootObject(sourceIndex);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),100);
-
-
-    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"state1\""),this);
-    waitForQuery(q_setState);
-    delete q_setState;
-
-    obj = findRootObject(sourceIndex);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),300);
-
-    // check changing properties of base state from within a state
-    QVERIFY(m_dbg->setBindingForObject(obj.debugId(),"width","height*2",false));
-    QVERIFY(m_dbg->setBindingForObject(obj.debugId(),"height","200",true));
-
-    obj = findRootObject(sourceIndex);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),300);
-
-    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"\""),this);
-    waitForQuery(q_setState);
-    delete q_setState;
-
-    obj = findRootObject(sourceIndex);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(), 400);
-
-    //  reset binding while in a state
-    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"state1\""),this);
-    waitForQuery(q_setState);
-    delete q_setState;
-
-    obj = findRootObject(sourceIndex);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(), 300);
-
-    m_dbg->resetBindingForObject(propertyChange.debugId(), "width");
-
-    obj = findRootObject(sourceIndex);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(), 400);
-
-    // re-add binding
-    m_dbg->setBindingForObject(propertyChange.debugId(), "width", "300", true);
-
-    obj = findRootObject(sourceIndex);
-    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(), 300);
-}
-
-void tst_QQmlEngineDebug::queryObjectTree()
-{
-    const int sourceIndex = 3;
-
-    // Check if states/transitions are initialized when fetching root item
-    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
-    waitForQuery(q_engines);
-
-    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
-    waitForQuery(q_context);
-
-    QVERIFY(q_context->rootContext().objects().count() > sourceIndex);
-    QQmlDebugObjectReference rootObject = q_context->rootContext().objects()[sourceIndex];
-
-    QQmlDebugObjectQuery *q_obj = m_dbg->queryObjectRecursive(rootObject, this);
-    waitForQuery(q_obj);
-
-    QQmlDebugObjectReference obj = q_obj->object();
-
-    delete q_engines;
-    delete q_context;
-    delete q_obj;
-
-    QVERIFY(obj.debugId() != -1);
-    QVERIFY(obj.children().count() >= 2);
-
-
-
-    // check state
-    QQmlDebugObjectReference state = obj.children()[1];
-    QCOMPARE(state.className(), QString("State"));
-    QVERIFY(state.children().count() > 0);
-
-    QQmlDebugObjectReference propertyChange = state.children()[0];
-    QVERIFY(propertyChange.debugId() != -1);
-
-    QQmlDebugPropertyReference propertyChangeTarget = findProperty(propertyChange.properties(),"target");
-    QCOMPARE(propertyChangeTarget.objectDebugId(), propertyChange.debugId());
-
-    QQmlDebugObjectReference targetReference = qvariant_cast<QQmlDebugObjectReference>(propertyChangeTarget.value());
-    QVERIFY(targetReference.debugId() != -1);
-
-
-
-    // check transition
-    QQmlDebugObjectReference transition = obj.children()[0];
-    QCOMPARE(transition.className(), QString("Transition"));
-    QCOMPARE(findProperty(transition.properties(),"from").value().toString(), QString("*"));
-    QCOMPARE(findProperty(transition.properties(),"to").value(), findProperty(state.properties(),"name").value());
-    QVERIFY(transition.children().count() > 0);
-
-    QQmlDebugObjectReference animation = transition.children()[0];
-    QVERIFY(animation.debugId() != -1);
-
-    QQmlDebugPropertyReference animationTarget = findProperty(animation.properties(),"target");
-    QCOMPARE(animationTarget.objectDebugId(), animation.debugId());
-
-    targetReference = qvariant_cast<QQmlDebugObjectReference>(animationTarget.value());
-    QVERIFY(targetReference.debugId() != -1);
-
-    QCOMPARE(findProperty(animation.properties(),"property").value().toString(), QString("width"));
-    QCOMPARE(findProperty(animation.properties(),"duration").value().toInt(), 100);
-}
-
-int main(int argc, char *argv[])
-{
-    int _argc = argc + 1;
-    char **_argv = new char*[_argc];
-    for (int i = 0; i < argc; ++i)
-        _argv[i] = argv[i];
-    char arg[] = "-qmljsdebugger=port:3768";
-    _argv[_argc - 1] = arg;
-
-    QGuiApplication app(_argc, _argv);
-    tst_QQmlEngineDebug tc;
-    return QTest::qExec(&tc, _argc, _argv);
-    delete _argv;
-}
-
-#include "tst_qqmlenginedebug.moc"
diff --git a/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugservice.pro b/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugservice.pro
new file mode 100644
index 0000000..0b92a72
--- /dev/null
+++ b/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugservice.pro
@@ -0,0 +1,12 @@
+CONFIG += testcase
+TARGET = tst_qqmlenginedebugservice
+macx:CONFIG -= app_bundle
+
+SOURCES += tst_qqmlenginedebugservice.cpp
+
+INCLUDEPATH += ../shared
+include(../shared/debugutil.pri)
+
+CONFIG += parallel_test declarative_debug
+
+QT += core-private qml-private quick-private v8-private testlib
diff --git a/tests/auto/qml/debugger/qqmlenginedebugservice/tst_qqmlenginedebugservice.cpp b/tests/auto/qml/debugger/qqmlenginedebugservice/tst_qqmlenginedebugservice.cpp
new file mode 100644
index 0000000..a35aaff
--- /dev/null
+++ b/tests/auto/qml/debugger/qqmlenginedebugservice/tst_qqmlenginedebugservice.cpp
@@ -0,0 +1,1235 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtest.h>
+#include <QSignalSpy>
+#include <QTimer>
+#include <QHostAddress>
+#include <QDebug>
+#include <QThread>
+
+#include <QtQml/qqmlengine.h>
+#include <QtQml/qqmlcontext.h>
+#include <QtQml/qqmlcomponent.h>
+#include <QtQml/qqmlexpression.h>
+#include <QtQml/qqmlproperty.h>
+#include <QtQuick/qquickitem.h>
+
+#include <private/qqmlbinding_p.h>
+#include <private/qqmlboundsignal_p.h>
+#include <private/qqmldebugservice_p.h>
+#include <private/qqmlmetatype_p.h>
+#include <private/qqmlproperty_p.h>
+
+#include "debugutil_p.h"
+#include "qqmlenginedebug_p.h"
+
+Q_DECLARE_METATYPE(QQmlDebugWatch::State)
+
+class tst_QQmlEngineDebugService : public QObject
+{
+    Q_OBJECT
+
+private:
+    QQmlDebugObjectReference findRootObject(int context = 0, bool recursive = false);
+    QQmlDebugPropertyReference findProperty(const QList<QQmlDebugPropertyReference> &props, const QString &name) const;
+    void waitForQuery(QQmlDebugQuery *query);
+
+    void recursiveObjectTest(QObject *o, const QQmlDebugObjectReference &oref, bool recursive) const;
+
+    void recursiveCompareObjects(const QQmlDebugObjectReference &a, const QQmlDebugObjectReference &b) const;
+    void recursiveCompareContexts(const QQmlDebugContextReference &a, const QQmlDebugContextReference &b) const;
+    void compareProperties(const QQmlDebugPropertyReference &a, const QQmlDebugPropertyReference &b) const;
+
+    QQmlDebugConnection *m_conn;
+    QQmlEngineDebug *m_dbg;
+    QQmlEngine *m_engine;
+    QQuickItem *m_rootItem;
+
+    QObjectList m_components;
+
+private slots:
+    void initTestCase();
+    void cleanupTestCase();
+
+    void watch_property();
+    void watch_object();
+    void watch_expression();
+    void watch_expression_data();
+    void watch_context();
+    void watch_file();
+
+    void queryAvailableEngines();
+    void queryRootContexts();
+    void queryObject();
+    void queryObject_data();
+    void queryExpressionResult();
+    void queryExpressionResult_data();
+
+    void tst_QQmlDebugFileReference();
+    void tst_QQmlDebugEngineReference();
+    void tst_QQmlDebugObjectReference();
+    void tst_QQmlDebugContextReference();
+    void tst_QQmlDebugPropertyReference();
+
+    void setBindingForObject();
+    void setMethodBody();
+    void queryObjectTree();
+    void setBindingInStates();
+};
+
+class NonScriptProperty : public QObject {
+    Q_OBJECT
+    Q_PROPERTY(int nonScriptProp READ nonScriptProp WRITE setNonScriptProp NOTIFY nonScriptPropChanged SCRIPTABLE false)
+public:
+    int nonScriptProp() const { return 0; }
+    void setNonScriptProp(int) {}
+signals:
+    void nonScriptPropChanged();
+};
+QML_DECLARE_TYPE(NonScriptProperty)
+
+
+QQmlDebugObjectReference tst_QQmlEngineDebugService::findRootObject(int context, bool recursive)
+{
+    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
+    waitForQuery(q_engines);
+
+    if (q_engines->engines().count() == 0)
+        return QQmlDebugObjectReference();
+    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
+    waitForQuery(q_context);
+
+    if (q_context->rootContext().objects().count() == 0)
+        return QQmlDebugObjectReference();
+    QQmlDebugObjectQuery *q_obj = recursive ?
+                m_dbg->queryObjectRecursive(q_context->rootContext().objects()[context], this) :
+                m_dbg->queryObject(q_context->rootContext().objects()[context], this);
+    waitForQuery(q_obj);
+
+    QQmlDebugObjectReference result = q_obj->object();
+
+    delete q_engines;
+    delete q_context;
+    delete q_obj;
+
+    return result;
+}
+
+QQmlDebugPropertyReference tst_QQmlEngineDebugService::findProperty(const QList<QQmlDebugPropertyReference> &props, const QString &name) const
+{
+    foreach(const QQmlDebugPropertyReference &p, props) {
+        if (p.name() == name)
+            return p;
+    }
+    return QQmlDebugPropertyReference();
+}
+
+void tst_QQmlEngineDebugService::waitForQuery(QQmlDebugQuery *query)
+{
+    QVERIFY(query);
+    QCOMPARE(query->parent(), qobject_cast<QObject*>(this));
+    QVERIFY(query->state() == QQmlDebugQuery::Waiting);
+    if (!QQmlDebugTest::waitForSignal(query, SIGNAL(stateChanged(QQmlDebugQuery::State))))
+        QFAIL("query timed out");
+}
+
+void tst_QQmlEngineDebugService::recursiveObjectTest(QObject *o, const QQmlDebugObjectReference &oref, bool recursive) const
+{
+    const QMetaObject *meta = o->metaObject();
+
+    QQmlType *type = QQmlMetaType::qmlType(meta);
+    QString className = type ? QString(type->qmlTypeName()) : QString(meta->className());
+    className = className.mid(className.lastIndexOf(QLatin1Char('/'))+1);
+
+    QCOMPARE(oref.debugId(), QQmlDebugService::idForObject(o));
+    QCOMPARE(oref.name(), o->objectName());
+    QCOMPARE(oref.className(), className);
+    QCOMPARE(oref.contextDebugId(), QQmlDebugService::idForObject(qmlContext(o)));
+
+    const QObjectList &children = o->children();
+    for (int i=0; i<children.count(); i++) {
+        QObject *child = children[i];
+        if (!qmlContext(child))
+            continue;
+        int debugId = QQmlDebugService::idForObject(child);
+        QVERIFY(debugId >= 0);
+
+        QQmlDebugObjectReference cref;
+        foreach (const QQmlDebugObjectReference &ref, oref.children()) {
+            if (ref.debugId() == debugId) {
+                cref = ref;
+                break;
+            }
+        }
+        QVERIFY(cref.debugId() >= 0);
+
+        if (recursive)
+            recursiveObjectTest(child, cref, true);
+    }
+
+    foreach (const QQmlDebugPropertyReference &p, oref.properties()) {
+        QCOMPARE(p.objectDebugId(), QQmlDebugService::idForObject(o));
+
+        // signal properties are fake - they are generated from QQmlBoundSignal children
+        if (p.name().startsWith("on") && p.name().length() > 2 && p.name()[2].isUpper()) {
+            QList<QQmlBoundSignal*> signalHandlers = o->findChildren<QQmlBoundSignal*>();
+            QString signal = p.value().toString();
+            bool found = false;
+            for (int i = 0; i < signalHandlers.count(); ++i)
+                if (signalHandlers.at(i)->expression()->expression() == signal) {
+                    found = true;
+                    break;
+                }
+            QVERIFY(found);
+            QVERIFY(p.valueTypeName().isEmpty());
+            QVERIFY(p.binding().isEmpty());
+            QVERIFY(!p.hasNotifySignal());
+            continue;
+        }
+
+        QMetaProperty pmeta = meta->property(meta->indexOfProperty(p.name().toUtf8().constData()));
+
+        QCOMPARE(p.name(), QString::fromUtf8(pmeta.name()));
+
+        if (pmeta.type() < QVariant::UserType && pmeta.userType() != QMetaType::QVariant) // TODO test complex types
+            QCOMPARE(p.value(), pmeta.read(o));
+
+        if (p.name() == "parent")
+            QVERIFY(p.valueTypeName() == "QGraphicsObject*" || p.valueTypeName() == "QQuickItem*");
+        else
+            QCOMPARE(p.valueTypeName(), QString::fromUtf8(pmeta.typeName()));
+
+        QQmlAbstractBinding *binding = 
+            QQmlPropertyPrivate::binding(QQmlProperty(o, p.name()));
+        if (binding)
+            QCOMPARE(binding->expression(), p.binding());
+
+        QCOMPARE(p.hasNotifySignal(), pmeta.hasNotifySignal());
+
+        QVERIFY(pmeta.isValid());
+    }
+}
+
+void tst_QQmlEngineDebugService::recursiveCompareObjects(const QQmlDebugObjectReference &a, const QQmlDebugObjectReference &b) const
+{
+    QCOMPARE(a.debugId(), b.debugId());
+    QCOMPARE(a.className(), b.className());
+    QCOMPARE(a.name(), b.name());
+    QCOMPARE(a.contextDebugId(), b.contextDebugId());
+
+    QCOMPARE(a.source().url(), b.source().url());
+    QCOMPARE(a.source().lineNumber(), b.source().lineNumber());
+    QCOMPARE(a.source().columnNumber(), b.source().columnNumber());
+
+    QCOMPARE(a.properties().count(), b.properties().count());
+    QCOMPARE(a.children().count(), b.children().count());
+
+    QList<QQmlDebugPropertyReference> aprops = a.properties();
+    QList<QQmlDebugPropertyReference> bprops = b.properties();
+
+    for (int i=0; i<aprops.count(); i++)
+        compareProperties(aprops[i], bprops[i]);
+
+    for (int i=0; i<a.children().count(); i++)
+        recursiveCompareObjects(a.children()[i], b.children()[i]);
+}
+
+void tst_QQmlEngineDebugService::recursiveCompareContexts(const QQmlDebugContextReference &a, const QQmlDebugContextReference &b) const
+{
+    QCOMPARE(a.debugId(), b.debugId());
+    QCOMPARE(a.name(), b.name());
+    QCOMPARE(a.objects().count(), b.objects().count());
+    QCOMPARE(a.contexts().count(), b.contexts().count());
+
+    for (int i=0; i<a.objects().count(); i++)
+        recursiveCompareObjects(a.objects()[i], b.objects()[i]);
+
+    for (int i=0; i<a.contexts().count(); i++)
+        recursiveCompareContexts(a.contexts()[i], b.contexts()[i]);
+}
+
+void tst_QQmlEngineDebugService::compareProperties(const QQmlDebugPropertyReference &a, const QQmlDebugPropertyReference &b) const
+{
+    QCOMPARE(a.objectDebugId(), b.objectDebugId());
+    QCOMPARE(a.name(), b.name());
+    QCOMPARE(a.value(), b.value());
+    QCOMPARE(a.valueTypeName(), b.valueTypeName());
+    QCOMPARE(a.binding(), b.binding());
+    QCOMPARE(a.hasNotifySignal(), b.hasNotifySignal());
+}
+
+void tst_QQmlEngineDebugService::initTestCase()
+{
+    qRegisterMetaType<QQmlDebugWatch::State>();
+    qmlRegisterType<NonScriptProperty>("Test", 1, 0, "NonScriptPropertyElement");
+
+    QTest::ignoreMessage(QtWarningMsg, "QML Debugger: Waiting for connection on port 3768...");
+    m_engine = new QQmlEngine(this);
+
+    QList<QByteArray> qml;
+    qml << "import QtQuick 2.0\n"
+           "import Test 1.0\n"
+           "Item {"
+                "id: root\n"
+                "width: 10; height: 20; scale: blueRect.scale;"
+                "Rectangle { id: blueRect; width: 500; height: 600; color: \"blue\"; }"
+                "Text { color: blueRect.color; }"
+                "MouseArea {"
+                    "onEntered: { console.log('hello') }"
+                "}"
+                "property variant varObj\n"
+                "property variant varObjList: []\n"
+                "property variant varObjMap\n"
+                "Component.onCompleted: {\n"
+                    "varObj = blueRect;\n"
+                    "var list = varObjList;\n"
+                    "list[0] = blueRect;\n"
+                    "varObjList = list;\n"
+                    "var map = new Object;\n"
+                    "map.rect = blueRect;\n"
+                    "varObjMap = map;\n"
+                "}\n"
+                "NonScriptPropertyElement {\n"
+                "}\n"
+            "}";
+
+    // add second component to test multiple root contexts
+    qml << "import QtQuick 2.0\n"
+            "Item {}";
+
+    // and a third to test methods
+    qml << "import QtQuick 2.0\n"
+            "Item {"
+                "function myMethodNoArgs() { return 3; }\n"
+                "function myMethod(a) { return a + 9; }\n"
+                "function myMethodIndirect() { myMethod(3); }\n"
+            "}";
+
+    // and a fourth to test states
+    qml << "import QtQuick 2.0\n"
+           "Rectangle {\n"
+                "id:rootRect\n"
+                "width:100\n"
+                "states: [\n"
+                    "State {\n"
+                        "name:\"state1\"\n"
+                        "PropertyChanges {\n"
+                            "target:rootRect\n"
+                            "width:200\n"
+                        "}\n"
+                    "}\n"
+                "]\n"
+                "transitions: [\n"
+                    "Transition {\n"
+                        "from:\"*\"\n"
+                        "to:\"state1\"\n"
+                        "PropertyAnimation {\n"
+                            "target:rootRect\n"
+                            "property:\"width\"\n"
+                            "duration:100\n"
+                        "}\n"
+                    "}\n"
+                "]\n"
+           "}\n"
+           ;
+
+    for (int i=0; i<qml.count(); i++) {
+        QQmlComponent component(m_engine);
+        component.setData(qml[i], QUrl::fromLocalFile(""));
+        QVERIFY(component.isReady());  // fails if bad syntax
+        m_components << qobject_cast<QQuickItem*>(component.create());
+    }
+    m_rootItem = qobject_cast<QQuickItem*>(m_components.first());
+
+    // add an extra context to test for multiple contexts
+    QQmlContext *context = new QQmlContext(m_engine->rootContext(), this);
+    context->setObjectName("tst_QQmlDebug_childContext");
+
+    m_conn = new QQmlDebugConnection(this);
+    m_conn->connectToHost("127.0.0.1", 3768);
+
+    QTest::ignoreMessage(QtWarningMsg, "QML Debugger: Connection established.");
+    bool ok = m_conn->waitForConnected();
+    QVERIFY(ok);
+    QTRY_VERIFY(QQmlDebugService::hasDebuggingClient());
+    m_dbg = new QQmlEngineDebug(m_conn, this);
+    QTRY_VERIFY(m_dbg->state() == QQmlEngineDebug::Enabled);
+}
+
+void tst_QQmlEngineDebugService::cleanupTestCase()
+{
+    delete m_dbg;
+    delete m_conn;
+    qDeleteAll(m_components);
+    delete m_engine;
+}
+
+void tst_QQmlEngineDebugService::setMethodBody()
+{
+    QQmlDebugObjectReference obj = findRootObject(2);
+
+    QObject *root = m_components.at(2);
+    // Without args
+    {
+    QVariant rv;
+    QVERIFY(QMetaObject::invokeMethod(root, "myMethodNoArgs", Qt::DirectConnection,
+                                      Q_RETURN_ARG(QVariant, rv)));
+    QVERIFY(rv == QVariant(qreal(3)));
+
+
+    QVERIFY(m_dbg->setMethodBody(obj.debugId(), "myMethodNoArgs", "return 7"));
+    QTest::qWait(100);
+
+    QVERIFY(QMetaObject::invokeMethod(root, "myMethodNoArgs", Qt::DirectConnection,
+                                      Q_RETURN_ARG(QVariant, rv)));
+    QVERIFY(rv == QVariant(qreal(7)));
+    }
+
+    // With args
+    {
+    QVariant rv;
+    QVERIFY(QMetaObject::invokeMethod(root, "myMethod", Qt::DirectConnection,
+                                      Q_RETURN_ARG(QVariant, rv), Q_ARG(QVariant, QVariant(19))));
+    QVERIFY(rv == QVariant(qreal(28)));
+
+    QVERIFY(m_dbg->setMethodBody(obj.debugId(), "myMethod", "return a + 7"));
+    QTest::qWait(100);
+
+    QVERIFY(QMetaObject::invokeMethod(root, "myMethod", Qt::DirectConnection,
+                                      Q_RETURN_ARG(QVariant, rv), Q_ARG(QVariant, QVariant(19))));
+    QVERIFY(rv == QVariant(qreal(26)));
+    }
+}
+
+void tst_QQmlEngineDebugService::watch_property()
+{
+    QQmlDebugObjectReference obj = findRootObject();
+    QQmlDebugPropertyReference prop = findProperty(obj.properties(), "width");
+
+    QQmlDebugPropertyWatch *watch;
+
+    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
+    watch = unconnected->addWatch(prop, this);
+    QCOMPARE(watch->state(), QQmlDebugWatch::Dead);
+    delete watch;
+    delete unconnected;
+
+    watch = m_dbg->addWatch(QQmlDebugPropertyReference(), this);
+    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
+    QCOMPARE(watch->state(), QQmlDebugWatch::Inactive);
+    delete watch;
+
+    watch = m_dbg->addWatch(prop, this);
+    QCOMPARE(watch->state(), QQmlDebugWatch::Waiting);
+    QCOMPARE(watch->objectDebugId(), obj.debugId());
+    QCOMPARE(watch->name(), prop.name());
+
+    QSignalSpy spy(watch, SIGNAL(valueChanged(QByteArray,QVariant)));
+
+    int origWidth = m_rootItem->property("width").toInt();
+    m_rootItem->setProperty("width", origWidth*2);
+
+    // stateChanged() is received before valueChanged()
+    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
+    QCOMPARE(watch->state(), QQmlDebugWatch::Active);
+    QCOMPARE(spy.count(), 1);
+
+    m_dbg->removeWatch(watch);
+    delete watch;
+
+    // restore original value and verify spy doesn't get additional signal since watch has been removed
+    m_rootItem->setProperty("width", origWidth);
+    QTest::qWait(100);
+    QCOMPARE(spy.count(), 1);
+
+    QCOMPARE(spy.at(0).at(0).value<QByteArray>(), prop.name().toUtf8());
+    QCOMPARE(spy.at(0).at(1).value<QVariant>(), qVariantFromValue(origWidth*2));
+}
+
+void tst_QQmlEngineDebugService::watch_object()
+{
+    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
+    waitForQuery(q_engines);
+
+    QVERIFY(q_engines->engines().count() > 0);
+    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
+    waitForQuery(q_context);
+
+    QVERIFY(q_context->rootContext().objects().count() > 0);
+    QQmlDebugObjectQuery *q_obj = m_dbg->queryObject(q_context->rootContext().objects()[0], this);
+    waitForQuery(q_obj);
+
+    QQmlDebugObjectReference obj = q_obj->object();
+
+    delete q_engines;
+    delete q_context;
+    delete q_obj;
+
+    QQmlDebugWatch *watch;
+
+    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
+    watch = unconnected->addWatch(obj, this);
+    QCOMPARE(watch->state(), QQmlDebugWatch::Dead);
+    delete watch;
+    delete unconnected;
+
+    watch = m_dbg->addWatch(QQmlDebugObjectReference(), this);
+    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
+    QCOMPARE(watch->state(), QQmlDebugWatch::Inactive);
+    delete watch;
+
+    watch = m_dbg->addWatch(obj, this);
+    QCOMPARE(watch->state(), QQmlDebugWatch::Waiting);
+    QCOMPARE(watch->objectDebugId(), obj.debugId());
+
+    QSignalSpy spy(watch, SIGNAL(valueChanged(QByteArray,QVariant)));
+
+    int origWidth = m_rootItem->property("width").toInt();
+    int origHeight = m_rootItem->property("height").toInt();
+    m_rootItem->setProperty("width", origWidth*2);
+    m_rootItem->setProperty("height", origHeight*2);
+
+    // stateChanged() is received before any valueChanged() signals
+    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
+    QCOMPARE(watch->state(), QQmlDebugWatch::Active);
+    QVERIFY(spy.count() > 0);
+
+    int newWidth = -1;
+    int newHeight = -1;
+    for (int i=0; i<spy.count(); i++) {
+        const QVariantList &values = spy[i];
+        if (values[0].value<QByteArray>() == "width")
+            newWidth = values[1].value<QVariant>().toInt();
+        else if (values[0].value<QByteArray>() == "height")
+            newHeight = values[1].value<QVariant>().toInt();
+
+    }
+
+    m_dbg->removeWatch(watch);
+    delete watch;
+
+    // since watch has been removed, restoring the original values should not trigger a valueChanged()
+    spy.clear();
+    m_rootItem->setProperty("width", origWidth);
+    m_rootItem->setProperty("height", origHeight);
+    QTest::qWait(100);
+    QCOMPARE(spy.count(), 0);
+
+    QCOMPARE(newWidth, origWidth * 2);
+    QCOMPARE(newHeight, origHeight * 2);
+}
+
+void tst_QQmlEngineDebugService::watch_expression()
+{
+    QFETCH(QString, expr);
+    QFETCH(int, increment);
+    QFETCH(int, incrementCount);
+
+    int origWidth = m_rootItem->property("width").toInt();
+
+    QQmlDebugObjectReference obj = findRootObject();
+
+    QQmlDebugObjectExpressionWatch *watch;
+
+    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
+    watch = unconnected->addWatch(obj, expr, this);
+    QCOMPARE(watch->state(), QQmlDebugWatch::Dead);
+    delete watch;
+    delete unconnected;
+
+    watch = m_dbg->addWatch(QQmlDebugObjectReference(), expr, this);
+    QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
+    QCOMPARE(watch->state(), QQmlDebugWatch::Inactive);
+    delete watch;
+
+    watch = m_dbg->addWatch(obj, expr, this);
+    QCOMPARE(watch->state(), QQmlDebugWatch::Waiting);
+    QCOMPARE(watch->objectDebugId(), obj.debugId());
+    QCOMPARE(watch->expression(), expr);
+
+    QSignalSpy spyState(watch, SIGNAL(stateChanged(QQmlDebugWatch::State)));
+
+    QSignalSpy spy(watch, SIGNAL(valueChanged(QByteArray,QVariant)));
+    int expectedSpyCount = incrementCount + 1;  // should also get signal with expression's initial value
+
+    int width = origWidth;
+    for (int i=0; i<incrementCount+1; i++) {
+        if (i > 0) {
+            width += increment;
+            m_rootItem->setProperty("width", width);
+        }
+        if (!QQmlDebugTest::waitForSignal(watch, SIGNAL(valueChanged(QByteArray,QVariant))))
+            QFAIL("Did not receive valueChanged() for expression");
+    }
+
+    if (spyState.count() == 0)
+        QVERIFY(QQmlDebugTest::waitForSignal(watch, SIGNAL(stateChanged(QQmlDebugWatch::State))));
+    QCOMPARE(spyState.count(), 1);
+    QCOMPARE(watch->state(), QQmlDebugWatch::Active);
+
+    m_dbg->removeWatch(watch);
+    delete watch;
+
+    // restore original value and verify spy doesn't get a signal since watch has been removed
+    m_rootItem->setProperty("width", origWidth);
+    QTest::qWait(100);
+    QCOMPARE(spy.count(), expectedSpyCount);
+
+    width = origWidth + increment;
+    for (int i=0; i<spy.count(); i++) {
+        QCOMPARE(spy.at(i).at(1).value<QVariant>().toInt(), width);
+        width += increment;
+    }
+}
+
+void tst_QQmlEngineDebugService::watch_expression_data()
+{
+    QTest::addColumn<QString>("expr");
+    QTest::addColumn<int>("increment");
+    QTest::addColumn<int>("incrementCount");
+
+    QTest::newRow("width") << "width" << 0 << 0;
+    QTest::newRow("width+10") << "width + 10" << 10 << 5;
+}
+
+void tst_QQmlEngineDebugService::watch_context()
+{
+    QQmlDebugContextReference c;
+    QTest::ignoreMessage(QtWarningMsg, "QQmlEngineDebug::addWatch(): Not implemented");
+    QVERIFY(!m_dbg->addWatch(c, QString(), this));
+}
+
+void tst_QQmlEngineDebugService::watch_file()
+{
+    QQmlDebugFileReference f;
+    QTest::ignoreMessage(QtWarningMsg, "QQmlEngineDebug::addWatch(): Not implemented");
+    QVERIFY(!m_dbg->addWatch(f, this));
+}
+
+void tst_QQmlEngineDebugService::queryAvailableEngines()
+{
+    QQmlDebugEnginesQuery *q_engines;
+
+    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
+    q_engines = unconnected->queryAvailableEngines(0);
+    QCOMPARE(q_engines->state(), QQmlDebugQuery::Error);
+    delete q_engines;
+    delete unconnected;
+
+    q_engines = m_dbg->queryAvailableEngines(this);
+    delete q_engines;
+
+    q_engines = m_dbg->queryAvailableEngines(this);
+    QVERIFY(q_engines->engines().isEmpty());
+    waitForQuery(q_engines);
+
+    // TODO test multiple engines
+    QList<QQmlDebugEngineReference> engines = q_engines->engines();
+    QCOMPARE(engines.count(), 1);
+
+    foreach(const QQmlDebugEngineReference &e, engines) {
+        QCOMPARE(e.debugId(), QQmlDebugService::idForObject(m_engine));
+        QCOMPARE(e.name(), m_engine->objectName());
+    }
+
+    // Make query invalid by deleting client
+    q_engines = m_dbg->queryAvailableEngines(this);
+    QCOMPARE(q_engines->state(), QQmlDebugQuery::Waiting);
+    delete m_dbg;
+    QCOMPARE(q_engines->state(), QQmlDebugQuery::Error);
+    delete q_engines;
+    m_dbg = new QQmlEngineDebug(m_conn, this);
+}
+
+void tst_QQmlEngineDebugService::queryRootContexts()
+{
+    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
+    waitForQuery(q_engines);
+    int engineId = q_engines->engines()[0].debugId();
+    delete q_engines;
+
+    QQmlDebugRootContextQuery *q_context;
+
+    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
+    q_context = unconnected->queryRootContexts(engineId, this);
+    QCOMPARE(q_context->state(), QQmlDebugQuery::Error);
+    delete q_context;
+    delete unconnected;
+
+    q_context = m_dbg->queryRootContexts(engineId, this);
+    delete q_context;
+
+    q_context = m_dbg->queryRootContexts(engineId, this);
+    waitForQuery(q_context);
+
+    QQmlContext *actualContext = m_engine->rootContext();
+    QQmlDebugContextReference context = q_context->rootContext();
+    QCOMPARE(context.debugId(), QQmlDebugService::idForObject(actualContext));
+    QCOMPARE(context.name(), actualContext->objectName());
+
+    QCOMPARE(context.objects().count(), 4); // 4 qml component objects created for context in main()
+
+    // root context query sends only root object data - it doesn't fill in
+    // the children or property info
+    QCOMPARE(context.objects()[0].properties().count(), 0);
+    QCOMPARE(context.objects()[0].children().count(), 0);
+
+    QCOMPARE(context.contexts().count(), 5);
+    QVERIFY(context.contexts()[0].debugId() >= 0);
+    QCOMPARE(context.contexts()[0].name(), QString("tst_QQmlDebug_childContext"));
+
+    // Make query invalid by deleting client
+    q_context = m_dbg->queryRootContexts(engineId, this);
+    QCOMPARE(q_context->state(), QQmlDebugQuery::Waiting);
+    delete m_dbg;
+    QCOMPARE(q_context->state(), QQmlDebugQuery::Error);
+    delete q_context;
+    m_dbg = new QQmlEngineDebug(m_conn, this);
+}
+
+void tst_QQmlEngineDebugService::queryObject()
+{
+    QFETCH(bool, recursive);
+
+    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
+    waitForQuery(q_engines);
+
+    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
+    waitForQuery(q_context);
+    QQmlDebugObjectReference rootObject = q_context->rootContext().objects()[0];
+
+    QQmlDebugObjectQuery *q_obj = 0;
+
+    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
+    q_obj = recursive ? unconnected->queryObjectRecursive(rootObject, this) : unconnected->queryObject(rootObject, this);
+    QCOMPARE(q_obj->state(), QQmlDebugQuery::Error);
+    delete q_obj;
+    delete unconnected;
+
+    q_obj = recursive ? m_dbg->queryObjectRecursive(rootObject, this) : m_dbg->queryObject(rootObject, this);
+    delete q_obj;
+
+    q_obj = recursive ? m_dbg->queryObjectRecursive(rootObject, this) : m_dbg->queryObject(rootObject, this);
+    waitForQuery(q_obj);
+
+    QQmlDebugObjectReference obj = q_obj->object();
+
+    delete q_engines;
+    delete q_context;
+
+    // Make query invalid by deleting client
+    q_obj = recursive ? m_dbg->queryObjectRecursive(rootObject, this) : m_dbg->queryObject(rootObject, this);
+    QCOMPARE(q_obj->state(), QQmlDebugQuery::Waiting);
+    delete m_dbg;
+    QCOMPARE(q_obj->state(), QQmlDebugQuery::Error);
+    delete q_obj;
+    m_dbg = new QQmlEngineDebug(m_conn, this);
+
+    // check source as defined in main()
+    QQmlDebugFileReference source = obj.source();
+    QCOMPARE(source.url(), QUrl::fromLocalFile(""));
+    QCOMPARE(source.lineNumber(), 3);
+    QCOMPARE(source.columnNumber(), 1);
+
+    // generically test all properties, children and childrens' properties
+    recursiveObjectTest(m_rootItem, obj, recursive);
+
+    if (recursive) {
+        foreach(const QQmlDebugObjectReference &child, obj.children())
+            QVERIFY(child.properties().count() > 0);
+
+        QQmlDebugObjectReference rect;
+        QQmlDebugObjectReference text;
+        foreach (const QQmlDebugObjectReference &child, obj.children()) {
+            if (child.className() == "Rectangle")
+                rect = child;
+            else if (child.className() == "Text")
+                text = child;
+        }
+
+        // test specific property values
+        QCOMPARE(findProperty(rect.properties(), "width").value(), qVariantFromValue(500));
+        QCOMPARE(findProperty(rect.properties(), "height").value(), qVariantFromValue(600));
+        QCOMPARE(findProperty(rect.properties(), "color").value(), qVariantFromValue(QColor("blue")));
+
+        QCOMPARE(findProperty(text.properties(), "color").value(), qVariantFromValue(QColor("blue")));
+    } else {
+        foreach(const QQmlDebugObjectReference &child, obj.children())
+            QCOMPARE(child.properties().count(), 0);
+    }
+}
+
+void tst_QQmlEngineDebugService::queryObject_data()
+{
+    QTest::addColumn<bool>("recursive");
+
+    QTest::newRow("non-recursive") << false;
+    QTest::newRow("recursive") << true;
+}
+
+void tst_QQmlEngineDebugService::queryExpressionResult()
+{
+    QFETCH(QString, expr);
+    QFETCH(QVariant, result);
+
+    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
+    waitForQuery(q_engines);    // check immediate deletion is ok
+
+    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
+    waitForQuery(q_context);
+    int objectId = q_context->rootContext().objects()[0].debugId();
+
+    QQmlDebugExpressionQuery *q_expr;
+
+    QQmlEngineDebug *unconnected = new QQmlEngineDebug(0);
+    q_expr = unconnected->queryExpressionResult(objectId, expr, this);
+    QCOMPARE(q_expr->state(), QQmlDebugQuery::Error);
+    delete q_expr;
+    delete unconnected;
+
+    q_expr = m_dbg->queryExpressionResult(objectId, expr, this);
+    delete q_expr;
+
+    q_expr = m_dbg->queryExpressionResult(objectId, expr, this);
+    QCOMPARE(q_expr->expression().toString(), expr);
+    waitForQuery(q_expr);
+
+    QCOMPARE(q_expr->result(), result);
+
+    delete q_engines;
+    delete q_context;
+
+    // Make query invalid by deleting client
+    q_expr = m_dbg->queryExpressionResult(objectId, expr, this);
+    QCOMPARE(q_expr->state(), QQmlDebugQuery::Waiting);
+    delete m_dbg;
+    QCOMPARE(q_expr->state(), QQmlDebugQuery::Error);
+    delete q_expr;
+    m_dbg = new QQmlEngineDebug(m_conn, this);
+}
+
+void tst_QQmlEngineDebugService::queryExpressionResult_data()
+{
+    QTest::addColumn<QString>("expr");
+    QTest::addColumn<QVariant>("result");
+
+    QTest::newRow("width + 50") << "width + 50" << qVariantFromValue(60);
+    QTest::newRow("blueRect.width") << "blueRect.width" << qVariantFromValue(500);
+    QTest::newRow("bad expr") << "aeaef" << qVariantFromValue(QString("<undefined>"));
+    QTest::newRow("QObject*") << "varObj" << qVariantFromValue(QString("<unnamed object>"));
+    QTest::newRow("list of QObject*") << "varObjList" << qVariantFromValue(QString("<unknown value>"));
+    QVariantMap map;
+    map.insert(QLatin1String("rect"), QVariant(QLatin1String("<unnamed object>")));
+    QTest::newRow("varObjMap") << "varObjMap" << qVariantFromValue(map);
+}
+
+void tst_QQmlEngineDebugService::tst_QQmlDebugFileReference()
+{
+    QQmlDebugFileReference ref;
+    QVERIFY(ref.url().isEmpty());
+    QCOMPARE(ref.lineNumber(), -1);
+    QCOMPARE(ref.columnNumber(), -1);
+
+    ref.setUrl(QUrl("http://test"));
+    QCOMPARE(ref.url(), QUrl("http://test"));
+    ref.setLineNumber(1);
+    QCOMPARE(ref.lineNumber(), 1);
+    ref.setColumnNumber(1);
+    QCOMPARE(ref.columnNumber(), 1);
+
+    QQmlDebugFileReference copy(ref);
+    QQmlDebugFileReference copyAssign;
+    copyAssign = ref;
+    foreach (const QQmlDebugFileReference &r, (QList<QQmlDebugFileReference>() << copy << copyAssign)) {
+        QCOMPARE(r.url(), ref.url());
+        QCOMPARE(r.lineNumber(), ref.lineNumber());
+        QCOMPARE(r.columnNumber(), ref.columnNumber());
+    }
+}
+
+void tst_QQmlEngineDebugService::tst_QQmlDebugEngineReference()
+{
+    QQmlDebugEngineReference ref;
+    QCOMPARE(ref.debugId(), -1);
+    QVERIFY(ref.name().isEmpty());
+
+    ref = QQmlDebugEngineReference(1);
+    QCOMPARE(ref.debugId(), 1);
+    QVERIFY(ref.name().isEmpty());
+
+    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
+    waitForQuery(q_engines);
+    ref = q_engines->engines()[0];
+    delete q_engines;
+
+    QQmlDebugEngineReference copy(ref);
+    QQmlDebugEngineReference copyAssign;
+    copyAssign = ref;
+    foreach (const QQmlDebugEngineReference &r, (QList<QQmlDebugEngineReference>() << copy << copyAssign)) {
+        QCOMPARE(r.debugId(), ref.debugId());
+        QCOMPARE(r.name(), ref.name());
+    }
+}
+
+void tst_QQmlEngineDebugService::tst_QQmlDebugObjectReference()
+{
+    QQmlDebugObjectReference ref;
+    QCOMPARE(ref.debugId(), -1);
+    QCOMPARE(ref.className(), QString());
+    QCOMPARE(ref.name(), QString());
+    QCOMPARE(ref.contextDebugId(), -1);
+    QVERIFY(ref.properties().isEmpty());
+    QVERIFY(ref.children().isEmpty());
+
+    QQmlDebugFileReference source = ref.source();
+    QVERIFY(source.url().isEmpty());
+    QVERIFY(source.lineNumber() < 0);
+    QVERIFY(source.columnNumber() < 0);
+
+    ref = QQmlDebugObjectReference(1);
+    QCOMPARE(ref.debugId(), 1);
+
+    QQmlDebugObjectReference rootObject = findRootObject();
+    QQmlDebugObjectQuery *query = m_dbg->queryObjectRecursive(rootObject, this);
+    waitForQuery(query);
+    ref = query->object();
+    delete query;
+
+    QVERIFY(ref.debugId() >= 0);
+
+    QQmlDebugObjectReference copy(ref);
+    QQmlDebugObjectReference copyAssign;
+    copyAssign = ref;
+    foreach (const QQmlDebugObjectReference &r, (QList<QQmlDebugObjectReference>() << copy << copyAssign))
+        recursiveCompareObjects(r, ref);
+}
+
+void tst_QQmlEngineDebugService::tst_QQmlDebugContextReference()
+{
+    QQmlDebugContextReference ref;
+    QCOMPARE(ref.debugId(), -1);
+    QVERIFY(ref.name().isEmpty());
+    QVERIFY(ref.objects().isEmpty());
+    QVERIFY(ref.contexts().isEmpty());
+
+    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
+    waitForQuery(q_engines);
+    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
+    waitForQuery(q_context);
+
+    ref = q_context->rootContext();
+    delete q_engines;
+    delete q_context;
+    QVERIFY(ref.debugId() >= 0);
+
+    QQmlDebugContextReference copy(ref);
+    QQmlDebugContextReference copyAssign;
+    copyAssign = ref;
+    foreach (const QQmlDebugContextReference &r, (QList<QQmlDebugContextReference>() << copy << copyAssign))
+        recursiveCompareContexts(r, ref);
+}
+
+void tst_QQmlEngineDebugService::tst_QQmlDebugPropertyReference()
+{
+    QQmlDebugObjectReference rootObject = findRootObject();
+    QQmlDebugObjectQuery *query = m_dbg->queryObject(rootObject, this);
+    waitForQuery(query);
+    QQmlDebugObjectReference obj = query->object();
+    delete query;
+
+    QQmlDebugPropertyReference ref = findProperty(obj.properties(), "scale");
+    QVERIFY(ref.objectDebugId() > 0);
+    QVERIFY(!ref.name().isEmpty());
+    QVERIFY(!ref.value().isNull());
+    QVERIFY(!ref.valueTypeName().isEmpty());
+    QVERIFY(!ref.binding().isEmpty());
+    QVERIFY(ref.hasNotifySignal());
+
+    QQmlDebugPropertyReference copy(ref);
+    QQmlDebugPropertyReference copyAssign;
+    copyAssign = ref;
+    foreach (const QQmlDebugPropertyReference &r, (QList<QQmlDebugPropertyReference>() << copy << copyAssign))
+        compareProperties(r, ref);
+}
+
+void tst_QQmlEngineDebugService::setBindingForObject()
+{
+    QQmlDebugObjectReference rootObject = findRootObject();
+    QVERIFY(rootObject.debugId() != -1);
+    QQmlDebugPropertyReference widthPropertyRef = findProperty(rootObject.properties(), "width");
+
+    QCOMPARE(widthPropertyRef.value(), QVariant(10));
+    QCOMPARE(widthPropertyRef.binding(), QString());
+
+    //
+    // set literal
+    //
+    m_dbg->setBindingForObject(rootObject.debugId(), "width", "15", true);
+
+    rootObject = findRootObject();
+    widthPropertyRef =  findProperty(rootObject.properties(), "width");
+
+    QCOMPARE(widthPropertyRef.value(), QVariant(15));
+    QCOMPARE(widthPropertyRef.binding(), QString());
+
+    //
+    // set expression
+    //
+    m_dbg->setBindingForObject(rootObject.debugId(), "width", "height", false);
+
+    rootObject = findRootObject();
+    widthPropertyRef =  findProperty(rootObject.properties(), "width");
+
+    QCOMPARE(widthPropertyRef.value(), QVariant(20));
+    QCOMPARE(widthPropertyRef.binding(), QString("height"));
+
+    //
+    // reset
+    //
+    m_dbg->resetBindingForObject(rootObject.debugId(), "width");
+
+    rootObject = findRootObject();
+    widthPropertyRef =  findProperty(rootObject.properties(), "width");
+
+   // QCOMPARE(widthPropertyRef.value(), QVariant(0)); // TODO: Shouldn't this work?
+    QCOMPARE(widthPropertyRef.binding(), QString());
+
+    //
+    // set handler
+    //
+    rootObject = findRootObject();
+    QCOMPARE(rootObject.children().size(), 5); // Rectangle, Text, MouseArea, Component.onCompleted, NonScriptPropertyElement
+    QQmlDebugObjectReference mouseAreaObject = rootObject.children().at(2);
+    QQmlDebugObjectQuery *q_obj = m_dbg->queryObjectRecursive(mouseAreaObject, this);
+    waitForQuery(q_obj);
+    mouseAreaObject = q_obj->object();
+
+    QCOMPARE(mouseAreaObject.className(), QString("MouseArea"));
+
+    QQmlDebugPropertyReference onEnteredRef = findProperty(mouseAreaObject.properties(), "onEntered");
+
+    QCOMPARE(onEnteredRef.name(), QString("onEntered"));
+    QCOMPARE(onEnteredRef.value(),  QVariant("(function onEntered() { { console.log('hello') } })"));
+
+    m_dbg->setBindingForObject(mouseAreaObject.debugId(), "onEntered", "{console.log('hello, world') }", false) ;
+
+    rootObject = findRootObject();
+    mouseAreaObject = rootObject.children().at(2);
+    q_obj = m_dbg->queryObjectRecursive(mouseAreaObject, this);
+    waitForQuery(q_obj);
+    mouseAreaObject = q_obj->object();
+    onEnteredRef = findProperty(mouseAreaObject.properties(), "onEntered");
+    QCOMPARE(onEnteredRef.name(), QString("onEntered"));
+    QCOMPARE(onEnteredRef.value(),  QVariant("{console.log('hello, world') }"));
+}
+
+void tst_QQmlEngineDebugService::setBindingInStates()
+{
+    // Check if changing bindings of propertychanges works
+
+    const int sourceIndex = 3;
+
+    QQmlDebugObjectReference obj = findRootObject(sourceIndex);
+
+    QVERIFY(obj.debugId() != -1);
+    QVERIFY(obj.children().count() >= 2);
+
+    // We are going to switch state a couple of times, we need to get rid of the transition before
+    QQmlDebugExpressionQuery *q_deleteTransition = m_dbg->queryExpressionResult(obj.debugId(),QString("transitions = []"),this);
+    waitForQuery(q_deleteTransition);
+    delete q_deleteTransition;
+
+
+    // check initial value of the property that is changing
+    QQmlDebugExpressionQuery *q_setState;
+    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"state1\""),this);
+    waitForQuery(q_setState);
+    delete q_setState;
+
+    obj = findRootObject(sourceIndex);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),200);
+
+
+    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"\""),this);
+    waitForQuery(q_setState);
+    delete q_setState;
+
+
+    obj = findRootObject(sourceIndex, true);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),100);
+
+
+    // change the binding
+    QQmlDebugObjectReference state = obj.children()[1];
+    QCOMPARE(state.className(), QString("State"));
+    QVERIFY(state.children().count() > 0);
+
+    QQmlDebugObjectReference propertyChange = state.children()[0];
+    QVERIFY(propertyChange.debugId() != -1);
+
+    QVERIFY( m_dbg->setBindingForObject(propertyChange.debugId(), "width",QVariant(300),true) );
+
+    // check properties changed in state
+    obj = findRootObject(sourceIndex);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),100);
+
+
+    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"state1\""),this);
+    waitForQuery(q_setState);
+    delete q_setState;
+
+    obj = findRootObject(sourceIndex);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),300);
+
+    // check changing properties of base state from within a state
+    QVERIFY(m_dbg->setBindingForObject(obj.debugId(),"width","height*2",false));
+    QVERIFY(m_dbg->setBindingForObject(obj.debugId(),"height","200",true));
+
+    obj = findRootObject(sourceIndex);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(),300);
+
+    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"\""),this);
+    waitForQuery(q_setState);
+    delete q_setState;
+
+    obj = findRootObject(sourceIndex);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(), 400);
+
+    //  reset binding while in a state
+    q_setState = m_dbg->queryExpressionResult(obj.debugId(),QString("state=\"state1\""),this);
+    waitForQuery(q_setState);
+    delete q_setState;
+
+    obj = findRootObject(sourceIndex);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(), 300);
+
+    m_dbg->resetBindingForObject(propertyChange.debugId(), "width");
+
+    obj = findRootObject(sourceIndex);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(), 400);
+
+    // re-add binding
+    m_dbg->setBindingForObject(propertyChange.debugId(), "width", "300", true);
+
+    obj = findRootObject(sourceIndex);
+    QCOMPARE(findProperty(obj.properties(),"width").value().toInt(), 300);
+}
+
+void tst_QQmlEngineDebugService::queryObjectTree()
+{
+    const int sourceIndex = 3;
+
+    // Check if states/transitions are initialized when fetching root item
+    QQmlDebugEnginesQuery *q_engines = m_dbg->queryAvailableEngines(this);
+    waitForQuery(q_engines);
+
+    QQmlDebugRootContextQuery *q_context = m_dbg->queryRootContexts(q_engines->engines()[0].debugId(), this);
+    waitForQuery(q_context);
+
+    QVERIFY(q_context->rootContext().objects().count() > sourceIndex);
+    QQmlDebugObjectReference rootObject = q_context->rootContext().objects()[sourceIndex];
+
+    QQmlDebugObjectQuery *q_obj = m_dbg->queryObjectRecursive(rootObject, this);
+    waitForQuery(q_obj);
+
+    QQmlDebugObjectReference obj = q_obj->object();
+
+    delete q_engines;
+    delete q_context;
+    delete q_obj;
+
+    QVERIFY(obj.debugId() != -1);
+    QVERIFY(obj.children().count() >= 2);
+
+
+
+    // check state
+    QQmlDebugObjectReference state = obj.children()[1];
+    QCOMPARE(state.className(), QString("State"));
+    QVERIFY(state.children().count() > 0);
+
+    QQmlDebugObjectReference propertyChange = state.children()[0];
+    QVERIFY(propertyChange.debugId() != -1);
+
+    QQmlDebugPropertyReference propertyChangeTarget = findProperty(propertyChange.properties(),"target");
+    QCOMPARE(propertyChangeTarget.objectDebugId(), propertyChange.debugId());
+
+    QQmlDebugObjectReference targetReference = qvariant_cast<QQmlDebugObjectReference>(propertyChangeTarget.value());
+    QVERIFY(targetReference.debugId() != -1);
+
+
+
+    // check transition
+    QQmlDebugObjectReference transition = obj.children()[0];
+    QCOMPARE(transition.className(), QString("Transition"));
+    QCOMPARE(findProperty(transition.properties(),"from").value().toString(), QString("*"));
+    QCOMPARE(findProperty(transition.properties(),"to").value(), findProperty(state.properties(),"name").value());
+    QVERIFY(transition.children().count() > 0);
+
+    QQmlDebugObjectReference animation = transition.children()[0];
+    QVERIFY(animation.debugId() != -1);
+
+    QQmlDebugPropertyReference animationTarget = findProperty(animation.properties(),"target");
+    QCOMPARE(animationTarget.objectDebugId(), animation.debugId());
+
+    targetReference = qvariant_cast<QQmlDebugObjectReference>(animationTarget.value());
+    QVERIFY(targetReference.debugId() != -1);
+
+    QCOMPARE(findProperty(animation.properties(),"property").value().toString(), QString("width"));
+    QCOMPARE(findProperty(animation.properties(),"duration").value().toInt(), 100);
+}
+
+int main(int argc, char *argv[])
+{
+    int _argc = argc + 1;
+    char **_argv = new char*[_argc];
+    for (int i = 0; i < argc; ++i)
+        _argv[i] = argv[i];
+    char arg[] = "-qmljsdebugger=port:3768";
+    _argv[_argc - 1] = arg;
+
+    QGuiApplication app(_argc, _argv);
+    tst_QQmlEngineDebugService tc;
+    return QTest::qExec(&tc, _argc, _argv);
+    delete _argv;
+}
+
+#include "tst_qqmlenginedebugservice.moc"
diff --git a/tests/auto/qml/debugger/qqmlinspector/tst_qqmlinspector.pro b/tests/auto/qml/debugger/qqmlinspector/tst_qqmlinspector.pro
index 010e97c..c24acca 100644
--- a/tests/auto/qml/debugger/qqmlinspector/tst_qqmlinspector.pro
+++ b/tests/auto/qml/debugger/qqmlinspector/tst_qqmlinspector.pro
@@ -2,9 +2,10 @@ CONFIG += testcase
 TARGET = tst_qqmlinspector
 macx:CONFIG -= app_bundle
 
-HEADERS += ../shared/debugutil_p.h
-SOURCES += tst_qqmlinspector.cpp \
-           ../shared/debugutil.cpp
+SOURCES += tst_qqmlinspector.cpp
+
+INCLUDEPATH += ../shared
+include(../shared/debugutil.pri)
 
 DEFINES += SRCDIR=\\\"$$PWD\\\"
 CONFIG += parallel_test declarative_debug
diff --git a/tests/auto/qml/debugger/qqmlprofilerservice/qqmlprofilerservice.pro b/tests/auto/qml/debugger/qqmlprofilerservice/qqmlprofilerservice.pro
index 81fe3d5..2bf43c9 100644
--- a/tests/auto/qml/debugger/qqmlprofilerservice/qqmlprofilerservice.pro
+++ b/tests/auto/qml/debugger/qqmlprofilerservice/qqmlprofilerservice.pro
@@ -2,13 +2,13 @@ CONFIG += testcase
 TARGET = tst_qqmlprofilerservice
 macx:CONFIG -= app_bundle
 
-HEADERS += ../shared/debugutil_p.h
+SOURCES += tst_qqmlprofilerservice.cpp
 
-SOURCES += tst_qqmlprofilerservice.cpp \
-           ../shared/debugutil.cpp
-OTHER_FILES += data/test.qml
+INCLUDEPATH += ../shared
+include(../../../shared/util.pri)
+include(../shared/debugutil.pri)
 
-include (../../../shared/util.pri)
+OTHER_FILES += data/test.qml
 
 CONFIG += parallel_test declarative_debug
 
diff --git a/tests/auto/qml/debugger/qqmlprofilerservice/tst_qqmlprofilerservice.cpp b/tests/auto/qml/debugger/qqmlprofilerservice/tst_qqmlprofilerservice.cpp
index edc120b..2b33ab3 100644
--- a/tests/auto/qml/debugger/qqmlprofilerservice/tst_qqmlprofilerservice.cpp
+++ b/tests/auto/qml/debugger/qqmlprofilerservice/tst_qqmlprofilerservice.cpp
@@ -43,7 +43,8 @@
 #include <QLibraryInfo>
 
 #include "QtQml/private/qqmlprofilerservice_p.h"
-#include "../shared/debugutil_p.h"
+#include "debugutil_p.h"
+#include "qqmldebugclient.h"
 #include "../../../shared/util.h"
 
 #define PORT 13773
diff --git a/tests/auto/qml/debugger/qv8profilerservice/qv8profilerservice.pro b/tests/auto/qml/debugger/qv8profilerservice/qv8profilerservice.pro
index e980d65..a8dd634 100644
--- a/tests/auto/qml/debugger/qv8profilerservice/qv8profilerservice.pro
+++ b/tests/auto/qml/debugger/qv8profilerservice/qv8profilerservice.pro
@@ -2,12 +2,11 @@ CONFIG += testcase
 TARGET = tst_qv8profilerservice
 macx:CONFIG -= app_bundle
 
-HEADERS += ../shared/debugutil_p.h
+SOURCES += tst_qv8profilerservice.cpp
 
-SOURCES += tst_qv8profilerservice.cpp \
-           ../shared/debugutil.cpp
-
-include (../../../shared/util.pri)
+INCLUDEPATH += ../shared
+include(../../../shared/util.pri)
+include(../shared/debugutil.pri)
 
 OTHER_FILES += data/test.qml
 
diff --git a/tests/auto/qml/debugger/qv8profilerservice/tst_qv8profilerservice.cpp b/tests/auto/qml/debugger/qv8profilerservice/tst_qv8profilerservice.cpp
index c5992a4..7b9cda9 100644
--- a/tests/auto/qml/debugger/qv8profilerservice/tst_qv8profilerservice.cpp
+++ b/tests/auto/qml/debugger/qv8profilerservice/tst_qv8profilerservice.cpp
@@ -43,7 +43,8 @@
 #include <QLibraryInfo>
 
 #include "QtQml/private/qv8profilerservice_p.h"
-#include "../shared/debugutil_p.h"
+#include "debugutil_p.h"
+#include "qqmldebugclient.h"
 #include "../../../shared/util.h"
 
 #define PORT 13774
diff --git a/tests/auto/qml/debugger/shared/debugutil.cpp b/tests/auto/qml/debugger/shared/debugutil.cpp
index a3d3dce..3d2f460 100644
--- a/tests/auto/qml/debugger/shared/debugutil.cpp
+++ b/tests/auto/qml/debugger/shared/debugutil.cpp
@@ -44,9 +44,6 @@
 #include <QEventLoop>
 #include <QTimer>
 
-#include <private/qqmldebugclient_p.h>
-#include <private/qqmldebugservice_p.h>
-
 bool QQmlDebugTest::waitForSignal(QObject *receiver, const char *member, int timeout) {
     QEventLoop loop;
     QTimer timer;
diff --git a/tests/auto/qml/debugger/shared/debugutil.pri b/tests/auto/qml/debugger/shared/debugutil.pri
new file mode 100644
index 0000000..b74f6b0
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/debugutil.pri
@@ -0,0 +1,9 @@
+QT += core-private
+
+HEADERS += $$PWD/debugutil_p.h \
+           $$PWD/qqmldebugclient.h \
+           $$PWD/qqmlenginedebug_p.h
+SOURCES += $$PWD/debugutil.cpp \
+           $$PWD/qqmldebugclient.cpp \
+           $$PWD/qqmlenginedebug.cpp
+
diff --git a/tests/auto/qml/debugger/shared/debugutil_p.h b/tests/auto/qml/debugger/shared/debugutil_p.h
index 194f8fa..177c712 100644
--- a/tests/auto/qml/debugger/shared/debugutil_p.h
+++ b/tests/auto/qml/debugger/shared/debugutil_p.h
@@ -51,7 +51,7 @@
 
 #include <QtQml/qqmlengine.h>
 
-#include <private/qqmldebugclient_p.h>
+#include "qqmldebugclient.h"
 #include <private/qqmldebugservice_p.h>
 
 class QQmlDebugTest
diff --git a/tests/auto/qml/debugger/shared/qqmldebugclient.cpp b/tests/auto/qml/debugger/shared/qqmldebugclient.cpp
new file mode 100644
index 0000000..0453f88
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmldebugclient.cpp
@@ -0,0 +1,410 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qqmldebugclient.h"
+
+#include <private/qpacketprotocol_p.h>
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qstringlist.h>
+#include <QtNetwork/qnetworkproxy.h>
+
+const int protocolVersion = 1;
+const QString serverId = QLatin1String("QDeclarativeDebugServer");
+const QString clientId = QLatin1String("QDeclarativeDebugClient");
+
+class QQmlDebugClientPrivate
+{
+public:
+    QQmlDebugClientPrivate();
+
+    QString name;
+    QQmlDebugConnection *connection;
+};
+
+class QQmlDebugConnectionPrivate : public QObject
+{
+    Q_OBJECT
+public:
+    QQmlDebugConnectionPrivate(QQmlDebugConnection *c);
+    QQmlDebugConnection *q;
+    QPacketProtocol *protocol;
+    QIODevice *device;
+
+    bool gotHello;
+    QHash <QString, float> serverPlugins;
+    QHash<QString, QQmlDebugClient *> plugins;
+
+    void advertisePlugins();
+    void connectDeviceSignals();
+
+public Q_SLOTS:
+    void connected();
+    void readyRead();
+    void deviceAboutToClose();
+};
+
+QQmlDebugConnectionPrivate::QQmlDebugConnectionPrivate(QQmlDebugConnection *c)
+    : QObject(c), q(c), protocol(0), device(0), gotHello(false)
+{
+    protocol = new QPacketProtocol(q, this);
+    QObject::connect(c, SIGNAL(connected()), this, SLOT(connected()));
+    QObject::connect(protocol, SIGNAL(readyRead()), this, SLOT(readyRead()));
+}
+
+void QQmlDebugConnectionPrivate::advertisePlugins()
+{
+    if (!q->isConnected())
+        return;
+
+    QPacket pack;
+    pack << serverId << 1 << plugins.keys();
+    protocol->send(pack);
+    q->flush();
+}
+
+void QQmlDebugConnectionPrivate::connected()
+{
+    QPacket pack;
+    pack << serverId << 0 << protocolVersion << plugins.keys();
+    protocol->send(pack);
+    q->flush();
+}
+
+void QQmlDebugConnectionPrivate::readyRead()
+{
+    if (!gotHello) {
+        QPacket pack = protocol->read();
+        QString name;
+
+        pack >> name;
+
+        bool validHello = false;
+        if (name == clientId) {
+            int op = -1;
+            pack >> op;
+            if (op == 0) {
+                int version = -1;
+                pack >> version;
+                if (version == protocolVersion) {
+                    QStringList pluginNames;
+                    QList<float> pluginVersions;
+                    pack >> pluginNames;
+                    if (!pack.isEmpty())
+                        pack >> pluginVersions;
+
+                    const int pluginNamesSize = pluginNames.size();
+                    const int pluginVersionsSize = pluginVersions.size();
+                    for (int i = 0; i < pluginNamesSize; ++i) {
+                        float pluginVersion = 1.0;
+                        if (i < pluginVersionsSize)
+                            pluginVersion = pluginVersions.at(i);
+                        serverPlugins.insert(pluginNames.at(i), pluginVersion);
+                    }
+
+                    validHello = true;
+                }
+            }
+        }
+
+        if (!validHello) {
+            qWarning("QQmlDebugConnection: Invalid hello message");
+            QObject::disconnect(protocol, SIGNAL(readyRead()), this, SLOT(readyRead()));
+            return;
+        }
+        gotHello = true;
+
+        QHash<QString, QQmlDebugClient *>::Iterator iter = plugins.begin();
+        for (; iter != plugins.end(); ++iter) {
+            QQmlDebugClient::State newState = QQmlDebugClient::Unavailable;
+            if (serverPlugins.contains(iter.key()))
+                newState = QQmlDebugClient::Enabled;
+            iter.value()->stateChanged(newState);
+        }
+    }
+
+    while (protocol->packetsAvailable()) {
+        QPacket pack = protocol->read();
+        QString name;
+        pack >> name;
+
+        if (name == clientId) {
+            int op = -1;
+            pack >> op;
+
+            if (op == 1) {
+                // Service Discovery
+                QHash<QString, float> oldServerPlugins = serverPlugins;
+                serverPlugins.clear();
+
+                QStringList pluginNames;
+                QList<float> pluginVersions;
+                pack >> pluginNames;
+                if (!pack.isEmpty())
+                    pack >> pluginVersions;
+
+                const int pluginNamesSize = pluginNames.size();
+                const int pluginVersionsSize = pluginVersions.size();
+                for (int i = 0; i < pluginNamesSize; ++i) {
+                    float pluginVersion = 1.0;
+                    if (i < pluginVersionsSize)
+                        pluginVersion = pluginVersions.at(i);
+                    serverPlugins.insert(pluginNames.at(i), pluginVersion);
+                }
+
+                QHash<QString, QQmlDebugClient *>::Iterator iter = plugins.begin();
+                for (; iter != plugins.end(); ++iter) {
+                    const QString pluginName = iter.key();
+                    QQmlDebugClient::State newSate = QQmlDebugClient::Unavailable;
+                    if (serverPlugins.contains(pluginName))
+                        newSate = QQmlDebugClient::Enabled;
+
+                    if (oldServerPlugins.contains(pluginName)
+                            != serverPlugins.contains(pluginName)) {
+                        iter.value()->stateChanged(newSate);
+                    }
+                }
+            } else {
+                qWarning() << "QQmlDebugConnection: Unknown control message id" << op;
+            }
+        } else {
+            QByteArray message;
+            pack >> message;
+
+            QHash<QString, QQmlDebugClient *>::Iterator iter =
+                    plugins.find(name);
+            if (iter == plugins.end()) {
+                qWarning() << "QQmlDebugConnection: Message received for missing plugin" << name;
+            } else {
+                (*iter)->messageReceived(message);
+            }
+        }
+    }
+}
+
+void QQmlDebugConnectionPrivate::deviceAboutToClose()
+{
+    // This is nasty syntax but we want to emit our own aboutToClose signal (by calling QIODevice::close())
+    // without calling the underlying device close fn as that would cause an infinite loop
+    q->QIODevice::close();
+}
+
+QQmlDebugConnection::QQmlDebugConnection(QObject *parent)
+    : QIODevice(parent), d(new QQmlDebugConnectionPrivate(this))
+{
+}
+
+QQmlDebugConnection::~QQmlDebugConnection()
+{
+    QHash<QString, QQmlDebugClient*>::iterator iter = d->plugins.begin();
+    for (; iter != d->plugins.end(); ++iter) {
+        iter.value()->d->connection = 0;
+        iter.value()->stateChanged(QQmlDebugClient::NotConnected);
+    }
+}
+
+bool QQmlDebugConnection::isConnected() const
+{
+    return state() == QAbstractSocket::ConnectedState;
+}
+
+qint64 QQmlDebugConnection::readData(char *data, qint64 maxSize)
+{
+    return d->device->read(data, maxSize);
+}
+
+qint64 QQmlDebugConnection::writeData(const char *data, qint64 maxSize)
+{
+    return d->device->write(data, maxSize);
+}
+
+qint64 QQmlDebugConnection::bytesAvailable() const
+{
+    return d->device->bytesAvailable();
+}
+
+bool QQmlDebugConnection::isSequential() const
+{
+    return true;
+}
+
+void QQmlDebugConnection::close()
+{
+    if (isOpen()) {
+        QIODevice::close();
+        d->device->close();
+        emit stateChanged(QAbstractSocket::UnconnectedState);
+
+        QHash<QString, QQmlDebugClient*>::iterator iter = d->plugins.begin();
+        for (; iter != d->plugins.end(); ++iter) {
+            iter.value()->stateChanged(QQmlDebugClient::NotConnected);
+        }
+    }
+}
+
+bool QQmlDebugConnection::waitForConnected(int msecs)
+{
+    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
+    if (socket)
+        return socket->waitForConnected(msecs);
+    return false;
+}
+
+QAbstractSocket::SocketState QQmlDebugConnection::state() const
+{
+    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
+    if (socket)
+        return socket->state();
+
+    return QAbstractSocket::UnconnectedState;
+}
+
+void QQmlDebugConnection::flush()
+{
+    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
+    if (socket) {
+        socket->flush();
+        return;
+    }
+}
+
+void QQmlDebugConnection::connectToHost(const QString &hostName, quint16 port)
+{
+    QTcpSocket *socket = new QTcpSocket(d);
+    socket->setProxy(QNetworkProxy::NoProxy);
+    d->device = socket;
+    d->connectDeviceSignals();
+    d->gotHello = false;
+    connect(socket, SIGNAL(stateChanged(QAbstractSocket::SocketState)), this, SIGNAL(stateChanged(QAbstractSocket::SocketState)));
+    connect(socket, SIGNAL(error(QAbstractSocket::SocketError)), this, SIGNAL(error(QAbstractSocket::SocketError)));
+    connect(socket, SIGNAL(connected()), this, SIGNAL(connected()));
+    socket->connectToHost(hostName, port);
+    QIODevice::open(ReadWrite | Unbuffered);
+}
+
+void QQmlDebugConnectionPrivate::connectDeviceSignals()
+{
+    connect(device, SIGNAL(bytesWritten(qint64)), q, SIGNAL(bytesWritten(qint64)));
+    connect(device, SIGNAL(readyRead()), q, SIGNAL(readyRead()));
+    connect(device, SIGNAL(aboutToClose()), this, SLOT(deviceAboutToClose()));
+}
+
+//
+
+QQmlDebugClientPrivate::QQmlDebugClientPrivate()
+    : connection(0)
+{
+}
+
+QQmlDebugClient::QQmlDebugClient(const QString &name, 
+                                                 QQmlDebugConnection *parent)
+    : QObject(parent),
+      d(new QQmlDebugClientPrivate)
+{
+    d->name = name;
+    d->connection = parent;
+
+    if (!d->connection)
+        return;
+
+    if (d->connection->d->plugins.contains(name)) {
+        qWarning() << "QQmlDebugClient: Conflicting plugin name" << name;
+        d->connection = 0;
+    } else {
+        d->connection->d->plugins.insert(name, this);
+        d->connection->d->advertisePlugins();
+    }
+}
+
+QQmlDebugClient::~QQmlDebugClient()
+{
+    if (d->connection && d->connection->d) {
+        d->connection->d->plugins.remove(d->name);
+        d->connection->d->advertisePlugins();
+    }
+    delete d;
+}
+
+QString QQmlDebugClient::name() const
+{
+    return d->name;
+}
+
+float QQmlDebugClient::serviceVersion() const
+{
+    if (d->connection->d->serverPlugins.contains(d->name))
+        return d->connection->d->serverPlugins.value(d->name);
+    return -1;
+}
+
+QQmlDebugClient::State QQmlDebugClient::state() const
+{
+    if (!d->connection
+            || !d->connection->isConnected()
+            || !d->connection->d->gotHello)
+        return NotConnected;
+
+    if (d->connection->d->serverPlugins.contains(d->name))
+        return Enabled;
+
+    return Unavailable;
+}
+
+void QQmlDebugClient::sendMessage(const QByteArray &message)
+{
+    if (state() != Enabled)
+        return;
+
+    QPacket pack;
+    pack << d->name << message;
+    d->connection->d->protocol->send(pack);
+    d->connection->flush();
+}
+
+void QQmlDebugClient::stateChanged(State)
+{
+}
+
+void QQmlDebugClient::messageReceived(const QByteArray &)
+{
+}
+
+#include <qqmldebugclient.moc>
diff --git a/tests/auto/qml/debugger/shared/qqmldebugclient.h b/tests/auto/qml/debugger/shared/qqmldebugclient.h
new file mode 100644
index 0000000..d3e5cd5
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmldebugclient.h
@@ -0,0 +1,112 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQMLDEBUGCLIENT_H
+#define QQMLDEBUGCLIENT_H
+
+#include <QtNetwork/qtcpsocket.h>
+
+#include <private/qtqmlglobal_p.h>
+
+class QQmlDebugConnectionPrivate;
+class Q_QML_PRIVATE_EXPORT QQmlDebugConnection : public QIODevice
+{
+    Q_OBJECT
+    Q_DISABLE_COPY(QQmlDebugConnection)
+public:
+    QQmlDebugConnection(QObject * = 0);
+    ~QQmlDebugConnection();
+
+    void connectToHost(const QString &hostName, quint16 port);
+
+    qint64 bytesAvailable() const;
+    bool isConnected() const;
+    QAbstractSocket::SocketState state() const;
+    void flush();
+    bool isSequential() const;
+    void close();
+    bool waitForConnected(int msecs = 30000);
+
+signals:
+    void connected();
+    void stateChanged(QAbstractSocket::SocketState socketState);
+    void error(QAbstractSocket::SocketError socketError);
+
+protected:
+    qint64 readData(char *data, qint64 maxSize);
+    qint64 writeData(const char *data, qint64 maxSize);
+
+private:
+    QQmlDebugConnectionPrivate *d;
+    friend class QQmlDebugClient;
+    friend class QQmlDebugClientPrivate;
+};
+
+class QQmlDebugClientPrivate;
+class Q_QML_PRIVATE_EXPORT QQmlDebugClient : public QObject
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QQmlDebugClient)
+    Q_DISABLE_COPY(QQmlDebugClient)
+
+public:
+    enum State { NotConnected, Unavailable, Enabled };
+
+    QQmlDebugClient(const QString &, QQmlDebugConnection *parent);
+    ~QQmlDebugClient();
+
+    QString name() const;
+    float serviceVersion() const;
+    State state() const;
+
+    virtual void sendMessage(const QByteArray &);
+
+protected:
+    virtual void stateChanged(State);
+    virtual void messageReceived(const QByteArray &);
+
+private:
+    QQmlDebugClientPrivate *d;
+    friend class QQmlDebugConnection;
+    friend class QQmlDebugConnectionPrivate;
+};
+
+#endif // QQMLDEBUGCLIENT_H
diff --git a/tests/auto/qml/debugger/shared/qqmlenginedebug.cpp b/tests/auto/qml/debugger/shared/qqmlenginedebug.cpp
new file mode 100644
index 0000000..8a46c76
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmlenginedebug.cpp
@@ -0,0 +1,1068 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qqmlenginedebug_p.h"
+
+#include "qqmldebugclient.h"
+
+#include <private/qqmlenginedebugservice_p.h>
+
+#include <QtCore/private/qobject_p.h>
+
+class QQmlEngineDebugClient : public QQmlDebugClient
+{
+public:
+    QQmlEngineDebugClient(QQmlDebugConnection *client, QQmlEngineDebugPrivate *p);
+
+protected:
+    virtual void stateChanged(State state);
+    virtual void messageReceived(const QByteArray &);
+
+private:
+    QQmlEngineDebugPrivate *priv;
+    friend class QQmlEngineDebugPrivate;
+};
+
+class QQmlEngineDebugPrivate : public QObjectPrivate
+{
+    Q_DECLARE_PUBLIC(QQmlEngineDebug)
+public:
+    QQmlEngineDebugPrivate(QQmlDebugConnection *);
+    ~QQmlEngineDebugPrivate();
+
+    void stateChanged(QQmlEngineDebug::State status);
+    void message(const QByteArray &);
+
+    QQmlEngineDebugClient *client;
+    int nextId;
+    int getId();
+
+    void decode(QDataStream &, QQmlDebugContextReference &);
+    void decode(QDataStream &, QQmlDebugObjectReference &, bool simple);
+
+    static void remove(QQmlEngineDebug *, QQmlDebugEnginesQuery *);
+    static void remove(QQmlEngineDebug *, QQmlDebugRootContextQuery *);
+    static void remove(QQmlEngineDebug *, QQmlDebugObjectQuery *);
+    static void remove(QQmlEngineDebug *, QQmlDebugExpressionQuery *);
+    static void remove(QQmlEngineDebug *, QQmlDebugWatch *);
+
+    QHash<int, QQmlDebugEnginesQuery *> enginesQuery;
+    QHash<int, QQmlDebugRootContextQuery *> rootContextQuery;
+    QHash<int, QQmlDebugObjectQuery *> objectQuery;
+    QHash<int, QQmlDebugExpressionQuery *> expressionQuery;
+
+    QHash<int, QQmlDebugWatch *> watched;
+};
+
+QQmlEngineDebugClient::QQmlEngineDebugClient(QQmlDebugConnection *client,
+                                                             QQmlEngineDebugPrivate *p)
+    : QQmlDebugClient(QLatin1String("QDeclarativeEngine"), client), priv(p)
+{
+}
+
+void QQmlEngineDebugClient::stateChanged(State status)
+{
+    if (priv)
+        priv->stateChanged(static_cast<QQmlEngineDebug::State>(status));
+}
+
+void QQmlEngineDebugClient::messageReceived(const QByteArray &data)
+{
+    if (priv)
+        priv->message(data);
+}
+
+QQmlEngineDebugPrivate::QQmlEngineDebugPrivate(QQmlDebugConnection *c)
+    : client(new QQmlEngineDebugClient(c, this)), nextId(0)
+{
+}
+
+QQmlEngineDebugPrivate::~QQmlEngineDebugPrivate()
+{
+    if (client)
+        client->priv = 0;
+    delete client;
+
+    QHash<int, QQmlDebugEnginesQuery*>::iterator enginesIter = enginesQuery.begin();
+    for (; enginesIter != enginesQuery.end(); ++enginesIter) {
+        enginesIter.value()->m_client = 0;
+        if (enginesIter.value()->state() == QQmlDebugQuery::Waiting)
+            enginesIter.value()->setState(QQmlDebugQuery::Error);
+    }
+
+    QHash<int, QQmlDebugRootContextQuery*>::iterator rootContextIter = rootContextQuery.begin();
+    for (; rootContextIter != rootContextQuery.end(); ++rootContextIter) {
+        rootContextIter.value()->m_client = 0;
+        if (rootContextIter.value()->state() == QQmlDebugQuery::Waiting)
+            rootContextIter.value()->setState(QQmlDebugQuery::Error);
+    }
+
+    QHash<int, QQmlDebugObjectQuery*>::iterator objectIter = objectQuery.begin();
+    for (; objectIter != objectQuery.end(); ++objectIter) {
+        objectIter.value()->m_client = 0;
+        if (objectIter.value()->state() == QQmlDebugQuery::Waiting)
+            objectIter.value()->setState(QQmlDebugQuery::Error);
+    }
+
+    QHash<int, QQmlDebugExpressionQuery*>::iterator exprIter = expressionQuery.begin();
+    for (; exprIter != expressionQuery.end(); ++exprIter) {
+        exprIter.value()->m_client = 0;
+        if (exprIter.value()->state() == QQmlDebugQuery::Waiting)
+            exprIter.value()->setState(QQmlDebugQuery::Error);
+    }
+
+    QHash<int, QQmlDebugWatch*>::iterator watchIter = watched.begin();
+    for (; watchIter != watched.end(); ++watchIter) {
+        watchIter.value()->m_client = 0;
+        watchIter.value()->setState(QQmlDebugWatch::Dead);
+    }
+}
+
+int QQmlEngineDebugPrivate::getId()
+{
+    return nextId++;
+}
+
+void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, QQmlDebugEnginesQuery *q)
+{
+    if (c && q) {
+        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
+        p->enginesQuery.remove(q->m_queryId);
+    }
+}
+
+void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, 
+                                            QQmlDebugRootContextQuery *q)
+{
+    if (c && q) {
+        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
+        p->rootContextQuery.remove(q->m_queryId);
+    }
+}
+
+void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, QQmlDebugObjectQuery *q)
+{
+    if (c && q) {
+        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
+        p->objectQuery.remove(q->m_queryId);
+    }
+}
+
+void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, QQmlDebugExpressionQuery *q)
+{
+    if (c && q) {
+        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
+        p->expressionQuery.remove(q->m_queryId);
+    }
+}
+
+void QQmlEngineDebugPrivate::remove(QQmlEngineDebug *c, QQmlDebugWatch *w)
+{
+    if (c && w) {
+        QQmlEngineDebugPrivate *p = (QQmlEngineDebugPrivate *)QObjectPrivate::get(c);
+        p->watched.remove(w->m_queryId);
+    }
+}
+
+void QQmlEngineDebugPrivate::decode(QDataStream &ds, QQmlDebugObjectReference &o,
+                                            bool simple)
+{
+    QQmlEngineDebugService::QQmlObjectData data;
+    ds >> data;
+    o.m_debugId = data.objectId;
+    o.m_class = data.objectType;
+    o.m_idString = data.idString;
+    o.m_name = data.objectName;
+    o.m_source.m_url = data.url;
+    o.m_source.m_lineNumber = data.lineNumber;
+    o.m_source.m_columnNumber = data.columnNumber;
+    o.m_contextDebugId = data.contextId;
+
+    if (simple)
+        return;
+
+    int childCount;
+    bool recur;
+    ds >> childCount >> recur;
+
+    for (int ii = 0; ii < childCount; ++ii) {
+        o.m_children.append(QQmlDebugObjectReference());
+        decode(ds, o.m_children.last(), !recur);
+    }
+
+    int propCount;
+    ds >> propCount;
+
+    for (int ii = 0; ii < propCount; ++ii) {
+        QQmlEngineDebugService::QQmlObjectProperty data;
+        ds >> data;
+        QQmlDebugPropertyReference prop;
+        prop.m_objectDebugId = o.m_debugId;
+        prop.m_name = data.name;
+        prop.m_binding = data.binding;
+        prop.m_hasNotifySignal = data.hasNotifySignal;
+        prop.m_valueTypeName = data.valueTypeName;
+        switch (data.type) {
+        case QQmlEngineDebugService::QQmlObjectProperty::Basic:
+        case QQmlEngineDebugService::QQmlObjectProperty::List:
+        case QQmlEngineDebugService::QQmlObjectProperty::SignalProperty:
+        {
+            prop.m_value = data.value;
+            break;
+        }
+        case QQmlEngineDebugService::QQmlObjectProperty::Object:
+        {
+            QQmlDebugObjectReference obj;
+            obj.m_debugId = prop.m_value.toInt();
+            prop.m_value = QVariant::fromValue(obj);
+            break;
+        }
+        case QQmlEngineDebugService::QQmlObjectProperty::Unknown:
+            break;
+        }
+        o.m_properties << prop;
+    }
+}
+
+void QQmlEngineDebugPrivate::decode(QDataStream &ds, QQmlDebugContextReference &c)
+{
+    ds >> c.m_name >> c.m_debugId;
+
+    int contextCount;
+    ds >> contextCount;
+
+    for (int ii = 0; ii < contextCount; ++ii) {
+        c.m_contexts.append(QQmlDebugContextReference());
+        decode(ds, c.m_contexts.last());
+    }
+
+    int objectCount;
+    ds >> objectCount;
+
+    for (int ii = 0; ii < objectCount; ++ii) {
+        QQmlDebugObjectReference obj;
+        decode(ds, obj, true);
+
+        obj.m_contextDebugId = c.m_debugId;
+        c.m_objects << obj;
+    }
+}
+
+void QQmlEngineDebugPrivate::stateChanged(QQmlEngineDebug::State status)
+{
+    emit q_func()->stateChanged(status);
+}
+
+void QQmlEngineDebugPrivate::message(const QByteArray &data)
+{
+    QDataStream ds(data);
+
+    QByteArray type;
+    ds >> type;
+
+    //qDebug() << "QQmlEngineDebugPrivate::message()" << type;
+
+    if (type == "LIST_ENGINES_R") {
+        int queryId;
+        ds >> queryId;
+
+        QQmlDebugEnginesQuery *query = enginesQuery.value(queryId);
+        if (!query)
+            return;
+        enginesQuery.remove(queryId);
+
+        int count;
+        ds >> count;
+
+        for (int ii = 0; ii < count; ++ii) {
+            QQmlDebugEngineReference ref;
+            ds >> ref.m_name;
+            ds >> ref.m_debugId;
+            query->m_engines << ref;
+        }
+
+        query->m_client = 0;
+        query->setState(QQmlDebugQuery::Completed);
+    } else if (type == "LIST_OBJECTS_R") {
+        int queryId;
+        ds >> queryId;
+
+        QQmlDebugRootContextQuery *query = rootContextQuery.value(queryId);
+        if (!query)
+            return;
+        rootContextQuery.remove(queryId);
+
+        if (!ds.atEnd())
+            decode(ds, query->m_context);
+
+        query->m_client = 0;
+        query->setState(QQmlDebugQuery::Completed);
+    } else if (type == "FETCH_OBJECT_R") {
+        int queryId;
+        ds >> queryId;
+
+        QQmlDebugObjectQuery *query = objectQuery.value(queryId);
+        if (!query)
+            return;
+        objectQuery.remove(queryId);
+
+        if (!ds.atEnd())
+            decode(ds, query->m_object, false);
+
+        query->m_client = 0;
+        query->setState(QQmlDebugQuery::Completed);
+    } else if (type == "EVAL_EXPRESSION_R") {
+        int queryId;
+        QVariant result;
+        ds >> queryId >> result;
+
+        QQmlDebugExpressionQuery *query = expressionQuery.value(queryId);
+        if (!query)
+            return;
+        expressionQuery.remove(queryId);
+
+        query->m_result = result;
+        query->m_client = 0;
+        query->setState(QQmlDebugQuery::Completed);
+    } else if (type == "WATCH_PROPERTY_R") {
+        int queryId;
+        bool ok;
+        ds >> queryId >> ok;
+
+        QQmlDebugWatch *watch = watched.value(queryId);
+        if (!watch)
+            return;
+
+        watch->setState(ok ? QQmlDebugWatch::Active : QQmlDebugWatch::Inactive);
+    } else if (type == "WATCH_OBJECT_R") {
+        int queryId;
+        bool ok;
+        ds >> queryId >> ok;
+
+        QQmlDebugWatch *watch = watched.value(queryId);
+        if (!watch)
+            return;
+
+        watch->setState(ok ? QQmlDebugWatch::Active : QQmlDebugWatch::Inactive);
+    } else if (type == "WATCH_EXPR_OBJECT_R") {
+        int queryId;
+        bool ok;
+        ds >> queryId >> ok;
+
+        QQmlDebugWatch *watch = watched.value(queryId);
+        if (!watch)
+            return;
+
+        watch->setState(ok ? QQmlDebugWatch::Active : QQmlDebugWatch::Inactive);
+    } else if (type == "UPDATE_WATCH") {
+        int queryId;
+        int debugId;
+        QByteArray name;
+        QVariant value;
+        ds >> queryId >> debugId >> name >> value;
+
+        QQmlDebugWatch *watch = watched.value(queryId, 0);
+        if (!watch)
+            return;
+        emit watch->valueChanged(name, value);
+    } else if (type == "OBJECT_CREATED") {
+        emit q_func()->newObjects();
+    }
+}
+
+QQmlEngineDebug::QQmlEngineDebug(QQmlDebugConnection *client, QObject *parent)
+    : QObject(*(new QQmlEngineDebugPrivate(client)), parent)
+{
+}
+
+QQmlEngineDebug::~QQmlEngineDebug()
+{
+}
+
+QQmlEngineDebug::State QQmlEngineDebug::state() const
+{
+    Q_D(const QQmlEngineDebug);
+
+    return static_cast<QQmlEngineDebug::State>(d->client->state());
+}
+
+QQmlDebugPropertyWatch *QQmlEngineDebug::addWatch(const QQmlDebugPropertyReference &property, QObject *parent)
+{
+    Q_D(QQmlEngineDebug);
+
+    QQmlDebugPropertyWatch *watch = new QQmlDebugPropertyWatch(parent);
+    if (d->client->state() == QQmlDebugClient::Enabled) {
+        int queryId = d->getId();
+        watch->m_queryId = queryId;
+        watch->m_client = this;
+        watch->m_objectDebugId = property.objectDebugId();
+        watch->m_name = property.name();
+        d->watched.insert(queryId, watch);
+
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("WATCH_PROPERTY") << queryId << property.objectDebugId() << property.name().toUtf8();
+        d->client->sendMessage(message);
+    } else {
+        watch->m_state = QQmlDebugWatch::Dead;
+    }
+
+    return watch;
+}
+
+QQmlDebugWatch *QQmlEngineDebug::addWatch(const QQmlDebugContextReference &, const QString &, QObject *)
+{
+    qWarning("QQmlEngineDebug::addWatch(): Not implemented");
+    return 0;
+}
+
+QQmlDebugObjectExpressionWatch *QQmlEngineDebug::addWatch(const QQmlDebugObjectReference &object, const QString &expr, QObject *parent)
+{
+    Q_D(QQmlEngineDebug);
+    QQmlDebugObjectExpressionWatch *watch = new QQmlDebugObjectExpressionWatch(parent);
+    if (d->client->state() == QQmlDebugClient::Enabled) {
+        int queryId = d->getId();
+        watch->m_queryId = queryId;
+        watch->m_client = this;
+        watch->m_objectDebugId = object.debugId();
+        watch->m_expr = expr;
+        d->watched.insert(queryId, watch);
+
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("WATCH_EXPR_OBJECT") << queryId << object.debugId() << expr;
+        d->client->sendMessage(message);
+    } else {
+        watch->m_state = QQmlDebugWatch::Dead;
+    }
+    return watch;
+}
+
+QQmlDebugWatch *QQmlEngineDebug::addWatch(const QQmlDebugObjectReference &object, QObject *parent)
+{
+    Q_D(QQmlEngineDebug);
+
+    QQmlDebugWatch *watch = new QQmlDebugWatch(parent);
+    if (d->client->state() == QQmlDebugClient::Enabled) {
+        int queryId = d->getId();
+        watch->m_queryId = queryId;
+        watch->m_client = this;
+        watch->m_objectDebugId = object.debugId();
+        d->watched.insert(queryId, watch);
+
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("WATCH_OBJECT") << queryId << object.debugId();
+        d->client->sendMessage(message);
+    } else {
+        watch->m_state = QQmlDebugWatch::Dead;
+    }
+
+    return watch;
+}
+
+QQmlDebugWatch *QQmlEngineDebug::addWatch(const QQmlDebugFileReference &, QObject *)
+{
+    qWarning("QQmlEngineDebug::addWatch(): Not implemented");
+    return 0;
+}
+
+void QQmlEngineDebug::removeWatch(QQmlDebugWatch *watch)
+{
+    Q_D(QQmlEngineDebug);
+
+    if (!watch || !watch->m_client)
+        return;
+
+    watch->m_client = 0;
+    watch->setState(QQmlDebugWatch::Inactive);
+    
+    d->watched.remove(watch->queryId());
+
+    if (d->client && d->client->state() == QQmlDebugClient::Enabled) {
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("NO_WATCH") << watch->queryId();
+        d->client->sendMessage(message);
+    }
+}
+
+QQmlDebugEnginesQuery *QQmlEngineDebug::queryAvailableEngines(QObject *parent)
+{
+    Q_D(QQmlEngineDebug);
+
+    QQmlDebugEnginesQuery *query = new QQmlDebugEnginesQuery(parent);
+    if (d->client->state() == QQmlDebugClient::Enabled) {
+        query->m_client = this;
+        int queryId = d->getId();
+        query->m_queryId = queryId;
+        d->enginesQuery.insert(queryId, query);
+
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("LIST_ENGINES") << queryId;
+        d->client->sendMessage(message);
+    } else {
+        query->m_state = QQmlDebugQuery::Error;
+    }
+
+    return query;
+}
+
+QQmlDebugRootContextQuery *QQmlEngineDebug::queryRootContexts(const QQmlDebugEngineReference &engine, QObject *parent)
+{
+    Q_D(QQmlEngineDebug);
+
+    QQmlDebugRootContextQuery *query = new QQmlDebugRootContextQuery(parent);
+    if (d->client->state() == QQmlDebugClient::Enabled && engine.debugId() != -1) {
+        query->m_client = this;
+        int queryId = d->getId();
+        query->m_queryId = queryId;
+        d->rootContextQuery.insert(queryId, query);
+
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("LIST_OBJECTS") << queryId << engine.debugId();
+        d->client->sendMessage(message);
+    } else {
+        query->m_state = QQmlDebugQuery::Error;
+    }
+
+    return query;
+}
+
+QQmlDebugObjectQuery *QQmlEngineDebug::queryObject(const QQmlDebugObjectReference &object, QObject *parent)
+{
+    Q_D(QQmlEngineDebug);
+
+    QQmlDebugObjectQuery *query = new QQmlDebugObjectQuery(parent);
+    if (d->client->state() == QQmlDebugClient::Enabled && object.debugId() != -1) {
+        query->m_client = this;
+        int queryId = d->getId();
+        query->m_queryId = queryId;
+        d->objectQuery.insert(queryId, query);
+
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("FETCH_OBJECT") << queryId << object.debugId()
+           << false << true;
+        d->client->sendMessage(message);
+    } else {
+        query->m_state = QQmlDebugQuery::Error;
+    }
+
+    return query;
+}
+
+QQmlDebugObjectQuery *QQmlEngineDebug::queryObjectRecursive(const QQmlDebugObjectReference &object, QObject *parent)
+{
+    Q_D(QQmlEngineDebug);
+
+    QQmlDebugObjectQuery *query = new QQmlDebugObjectQuery(parent);
+    if (d->client->state() == QQmlDebugClient::Enabled && object.debugId() != -1) {
+        query->m_client = this;
+        int queryId = d->getId();
+        query->m_queryId = queryId;
+        d->objectQuery.insert(queryId, query);
+
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("FETCH_OBJECT") << queryId << object.debugId()
+           << true << true;
+        d->client->sendMessage(message);
+    } else {
+        query->m_state = QQmlDebugQuery::Error;
+    }
+
+    return query;
+}
+
+QQmlDebugExpressionQuery *QQmlEngineDebug::queryExpressionResult(int objectDebugId, const QString &expr, QObject *parent)
+{
+    Q_D(QQmlEngineDebug);
+
+    QQmlDebugExpressionQuery *query = new QQmlDebugExpressionQuery(parent);
+    if (d->client->state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
+        query->m_client = this;
+        query->m_expr = expr;
+        int queryId = d->getId();
+        query->m_queryId = queryId;
+        d->expressionQuery.insert(queryId, query);
+
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("EVAL_EXPRESSION") << queryId << objectDebugId << expr;
+        d->client->sendMessage(message);
+    } else {
+        query->m_state = QQmlDebugQuery::Error;
+    }
+
+    return query;
+}
+
+bool QQmlEngineDebug::setBindingForObject(int objectDebugId, const QString &propertyName,
+                                                  const QVariant &bindingExpression,
+                                                  bool isLiteralValue,
+                                                  QString source, int line)
+{
+    Q_D(QQmlEngineDebug);
+
+    if (d->client->state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("SET_BINDING") << objectDebugId << propertyName << bindingExpression << isLiteralValue << source << line;
+        d->client->sendMessage(message);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+bool QQmlEngineDebug::resetBindingForObject(int objectDebugId, const QString &propertyName)
+{
+    Q_D(QQmlEngineDebug);
+
+    if (d->client->state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("RESET_BINDING") << objectDebugId << propertyName;
+        d->client->sendMessage(message);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+bool QQmlEngineDebug::setMethodBody(int objectDebugId, const QString &methodName,
+                                            const QString &methodBody)
+{
+    Q_D(QQmlEngineDebug);
+
+    if (d->client->state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("SET_METHOD_BODY") << objectDebugId << methodName << methodBody;
+        d->client->sendMessage(message);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+QQmlDebugWatch::QQmlDebugWatch(QObject *parent)
+    : QObject(parent), m_state(Waiting), m_queryId(-1), m_client(0), m_objectDebugId(-1)
+{
+}
+
+QQmlDebugWatch::~QQmlDebugWatch()
+{
+    if (m_client && m_queryId != -1)
+        QQmlEngineDebugPrivate::remove(m_client, this);
+}
+
+int QQmlDebugWatch::queryId() const
+{
+    return m_queryId;
+}
+
+int QQmlDebugWatch::objectDebugId() const
+{
+    return m_objectDebugId;
+}
+
+QQmlDebugWatch::State QQmlDebugWatch::state() const
+{
+    return m_state;
+}
+
+void QQmlDebugWatch::setState(State s)
+{
+    if (m_state == s)
+        return;
+    m_state = s;
+    emit stateChanged(m_state);
+}
+
+QQmlDebugPropertyWatch::QQmlDebugPropertyWatch(QObject *parent)
+    : QQmlDebugWatch(parent)
+{
+}
+
+QString QQmlDebugPropertyWatch::name() const
+{
+    return m_name;
+}
+
+
+QQmlDebugObjectExpressionWatch::QQmlDebugObjectExpressionWatch(QObject *parent)
+    : QQmlDebugWatch(parent)
+{
+}
+
+QString QQmlDebugObjectExpressionWatch::expression() const
+{
+    return m_expr;
+}
+
+
+QQmlDebugQuery::QQmlDebugQuery(QObject *parent)
+    : QObject(parent), m_state(Waiting)
+{
+}
+
+QQmlDebugQuery::State QQmlDebugQuery::state() const
+{
+    return m_state;
+}
+
+bool QQmlDebugQuery::isWaiting() const
+{
+    return m_state == Waiting;
+}
+
+void QQmlDebugQuery::setState(State s)
+{
+    if (m_state == s)
+        return;
+    m_state = s;
+    emit stateChanged(m_state);
+}
+
+QQmlDebugEnginesQuery::QQmlDebugEnginesQuery(QObject *parent)
+    : QQmlDebugQuery(parent), m_client(0), m_queryId(-1)
+{
+}
+
+QQmlDebugEnginesQuery::~QQmlDebugEnginesQuery()
+{
+    if (m_client && m_queryId != -1)
+        QQmlEngineDebugPrivate::remove(m_client, this);
+}
+
+QList<QQmlDebugEngineReference> QQmlDebugEnginesQuery::engines() const
+{
+    return m_engines;
+}
+
+QQmlDebugRootContextQuery::QQmlDebugRootContextQuery(QObject *parent)
+    : QQmlDebugQuery(parent), m_client(0), m_queryId(-1)
+{
+}
+
+QQmlDebugRootContextQuery::~QQmlDebugRootContextQuery()
+{
+    if (m_client && m_queryId != -1)
+        QQmlEngineDebugPrivate::remove(m_client, this);
+}
+
+QQmlDebugContextReference QQmlDebugRootContextQuery::rootContext() const
+{
+    return m_context;
+}
+
+QQmlDebugObjectQuery::QQmlDebugObjectQuery(QObject *parent)
+    : QQmlDebugQuery(parent), m_client(0), m_queryId(-1)
+{
+}
+
+QQmlDebugObjectQuery::~QQmlDebugObjectQuery()
+{
+    if (m_client && m_queryId != -1)
+        QQmlEngineDebugPrivate::remove(m_client, this);
+}
+
+QQmlDebugObjectReference QQmlDebugObjectQuery::object() const
+{
+    return m_object;
+}
+
+QQmlDebugExpressionQuery::QQmlDebugExpressionQuery(QObject *parent)
+    : QQmlDebugQuery(parent), m_client(0), m_queryId(-1)
+{
+}
+
+QQmlDebugExpressionQuery::~QQmlDebugExpressionQuery()
+{
+    if (m_client && m_queryId != -1)
+        QQmlEngineDebugPrivate::remove(m_client, this);
+}
+
+QVariant QQmlDebugExpressionQuery::expression() const
+{
+    return m_expr;
+}
+
+QVariant QQmlDebugExpressionQuery::result() const
+{
+    return m_result;
+}
+
+QQmlDebugEngineReference::QQmlDebugEngineReference()
+    : m_debugId(-1)
+{
+}
+
+QQmlDebugEngineReference::QQmlDebugEngineReference(int debugId)
+    : m_debugId(debugId)
+{
+}
+
+QQmlDebugEngineReference::QQmlDebugEngineReference(const QQmlDebugEngineReference &o)
+    : m_debugId(o.m_debugId), m_name(o.m_name)
+{
+}
+
+QQmlDebugEngineReference &
+QQmlDebugEngineReference::operator=(const QQmlDebugEngineReference &o)
+{
+    m_debugId = o.m_debugId; m_name = o.m_name;
+    return *this;
+}
+
+int QQmlDebugEngineReference::debugId() const
+{
+    return m_debugId;
+}
+
+QString QQmlDebugEngineReference::name() const
+{
+    return m_name;
+}
+
+QQmlDebugObjectReference::QQmlDebugObjectReference()
+    : m_debugId(-1), m_contextDebugId(-1)
+{
+}
+
+QQmlDebugObjectReference::QQmlDebugObjectReference(int debugId)
+    : m_debugId(debugId), m_contextDebugId(-1)
+{
+}
+
+QQmlDebugObjectReference::QQmlDebugObjectReference(const QQmlDebugObjectReference &o)
+    : m_debugId(o.m_debugId), m_class(o.m_class), m_idString(o.m_idString),
+      m_name(o.m_name), m_source(o.m_source), m_contextDebugId(o.m_contextDebugId),
+      m_properties(o.m_properties), m_children(o.m_children)
+{
+}
+
+QQmlDebugObjectReference &
+QQmlDebugObjectReference::operator=(const QQmlDebugObjectReference &o)
+{
+    m_debugId = o.m_debugId; m_class = o.m_class; m_idString = o.m_idString;
+    m_name = o.m_name; m_source = o.m_source; m_contextDebugId = o.m_contextDebugId;
+    m_properties = o.m_properties; m_children = o.m_children;
+    return *this;
+}
+
+int QQmlDebugObjectReference::debugId() const
+{
+    return m_debugId;
+}
+
+QString QQmlDebugObjectReference::className() const
+{
+    return m_class;
+}
+
+QString QQmlDebugObjectReference::idString() const
+{
+    return m_idString;
+}
+
+QString QQmlDebugObjectReference::name() const
+{
+    return m_name;
+}
+
+QQmlDebugFileReference QQmlDebugObjectReference::source() const
+{
+    return m_source;
+}
+
+int QQmlDebugObjectReference::contextDebugId() const
+{
+    return m_contextDebugId;
+}
+
+QList<QQmlDebugPropertyReference> QQmlDebugObjectReference::properties() const
+{
+    return m_properties;
+}
+
+QList<QQmlDebugObjectReference> QQmlDebugObjectReference::children() const
+{
+    return m_children;
+}
+
+QQmlDebugContextReference::QQmlDebugContextReference()
+    : m_debugId(-1)
+{
+}
+
+QQmlDebugContextReference::QQmlDebugContextReference(const QQmlDebugContextReference &o)
+    : m_debugId(o.m_debugId), m_name(o.m_name), m_objects(o.m_objects), m_contexts(o.m_contexts)
+{
+}
+
+QQmlDebugContextReference &QQmlDebugContextReference::operator=(const QQmlDebugContextReference &o)
+{
+    m_debugId = o.m_debugId; m_name = o.m_name; m_objects = o.m_objects;
+    m_contexts = o.m_contexts;
+    return *this;
+}
+
+int QQmlDebugContextReference::debugId() const
+{
+    return m_debugId;
+}
+
+QString QQmlDebugContextReference::name() const
+{
+    return m_name;
+}
+
+QList<QQmlDebugObjectReference> QQmlDebugContextReference::objects() const
+{
+    return m_objects;
+}
+
+QList<QQmlDebugContextReference> QQmlDebugContextReference::contexts() const
+{
+    return m_contexts;
+}
+
+QQmlDebugFileReference::QQmlDebugFileReference()
+    : m_lineNumber(-1), m_columnNumber(-1)
+{
+}
+
+QQmlDebugFileReference::QQmlDebugFileReference(const QQmlDebugFileReference &o)
+    : m_url(o.m_url), m_lineNumber(o.m_lineNumber), m_columnNumber(o.m_columnNumber)
+{
+}
+
+QQmlDebugFileReference &QQmlDebugFileReference::operator=(const QQmlDebugFileReference &o)
+{
+    m_url = o.m_url; m_lineNumber = o.m_lineNumber; m_columnNumber = o.m_columnNumber;
+    return *this;
+}
+
+QUrl QQmlDebugFileReference::url() const
+{
+    return m_url;
+}
+
+void QQmlDebugFileReference::setUrl(const QUrl &u)
+{
+    m_url = u;
+}
+
+int QQmlDebugFileReference::lineNumber() const
+{
+    return m_lineNumber;
+}
+
+void QQmlDebugFileReference::setLineNumber(int l)
+{
+    m_lineNumber = l;
+}
+
+int QQmlDebugFileReference::columnNumber() const
+{
+    return m_columnNumber;
+}
+
+void QQmlDebugFileReference::setColumnNumber(int c)
+{
+    m_columnNumber = c;
+}
+
+QQmlDebugPropertyReference::QQmlDebugPropertyReference()
+    : m_objectDebugId(-1), m_hasNotifySignal(false)
+{
+}
+
+QQmlDebugPropertyReference::QQmlDebugPropertyReference(const QQmlDebugPropertyReference &o)
+    : m_objectDebugId(o.m_objectDebugId), m_name(o.m_name), m_value(o.m_value),
+      m_valueTypeName(o.m_valueTypeName), m_binding(o.m_binding),
+      m_hasNotifySignal(o.m_hasNotifySignal)
+{
+}
+
+QQmlDebugPropertyReference &QQmlDebugPropertyReference::operator=(const QQmlDebugPropertyReference &o)
+{
+    m_objectDebugId = o.m_objectDebugId; m_name = o.m_name; m_value = o.m_value;
+    m_valueTypeName = o.m_valueTypeName; m_binding = o.m_binding;
+    m_hasNotifySignal = o.m_hasNotifySignal;
+    return *this;
+}
+
+int QQmlDebugPropertyReference::objectDebugId() const
+{
+    return m_objectDebugId;
+}
+
+QString QQmlDebugPropertyReference::name() const
+{
+    return m_name;
+}
+
+QString QQmlDebugPropertyReference::valueTypeName() const
+{
+    return m_valueTypeName;
+}
+
+QVariant QQmlDebugPropertyReference::value() const
+{
+    return m_value;
+}
+
+QString QQmlDebugPropertyReference::binding() const
+{
+    return m_binding;
+}
+
+bool QQmlDebugPropertyReference::hasNotifySignal() const
+{
+    return m_hasNotifySignal;
+}
+
diff --git a/tests/auto/qml/debugger/shared/qqmlenginedebug_p.h b/tests/auto/qml/debugger/shared/qqmlenginedebug_p.h
new file mode 100644
index 0000000..70f04d3
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmlenginedebug_p.h
@@ -0,0 +1,388 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQMLENGINEDEBUG_H
+#define QQMLENGINEDEBUG_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qobject.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qvariant.h>
+
+#include <private/qtqmlglobal_p.h>
+
+class QQmlDebugConnection;
+class QQmlDebugWatch;
+class QQmlDebugPropertyWatch;
+class QQmlDebugObjectExpressionWatch;
+class QQmlDebugEnginesQuery;
+class QQmlDebugRootContextQuery;
+class QQmlDebugObjectQuery;
+class QQmlDebugExpressionQuery;
+class QQmlDebugPropertyReference;
+class QQmlDebugContextReference;
+class QQmlDebugObjectReference;
+class QQmlDebugFileReference;
+class QQmlDebugEngineReference;
+class QQmlEngineDebugPrivate;
+class Q_QML_PRIVATE_EXPORT QQmlEngineDebug : public QObject
+{
+    Q_OBJECT
+public:
+    enum State { NotConnected, Unavailable, Enabled };
+
+    explicit QQmlEngineDebug(QQmlDebugConnection *, QObject * = 0);
+    ~QQmlEngineDebug();
+
+    State state() const;
+
+    QQmlDebugPropertyWatch *addWatch(const QQmlDebugPropertyReference &,
+                                             QObject *parent = 0);
+    QQmlDebugWatch *addWatch(const QQmlDebugContextReference &, const QString &,
+                                     QObject *parent = 0);
+    QQmlDebugObjectExpressionWatch *addWatch(const QQmlDebugObjectReference &, const QString &,
+                                                     QObject *parent = 0);
+    QQmlDebugWatch *addWatch(const QQmlDebugObjectReference &,
+                                     QObject *parent = 0);
+    QQmlDebugWatch *addWatch(const QQmlDebugFileReference &,
+                                     QObject *parent = 0);
+
+    void removeWatch(QQmlDebugWatch *watch);
+
+    QQmlDebugEnginesQuery *queryAvailableEngines(QObject *parent = 0);
+    QQmlDebugRootContextQuery *queryRootContexts(const QQmlDebugEngineReference &,
+                                                         QObject *parent = 0);
+    QQmlDebugObjectQuery *queryObject(const QQmlDebugObjectReference &,
+                                              QObject *parent = 0);
+    QQmlDebugObjectQuery *queryObjectRecursive(const QQmlDebugObjectReference &,
+                                                       QObject *parent = 0);
+    QQmlDebugExpressionQuery *queryExpressionResult(int objectDebugId,
+                                                            const QString &expr,
+                                                            QObject *parent = 0);
+    bool setBindingForObject(int objectDebugId, const QString &propertyName,
+                             const QVariant &bindingExpression, bool isLiteralValue,
+                             QString source = QString(), int line = -1);
+    bool resetBindingForObject(int objectDebugId, const QString &propertyName);
+    bool setMethodBody(int objectDebugId, const QString &methodName, const QString &methodBody);
+
+Q_SIGNALS:
+    void newObjects();
+    void stateChanged(State state);
+
+private:
+    Q_DECLARE_PRIVATE(QQmlEngineDebug)
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugWatch : public QObject
+{
+    Q_OBJECT
+public:
+    enum State { Waiting, Active, Inactive, Dead };
+
+    QQmlDebugWatch(QObject *);
+    ~QQmlDebugWatch();
+
+    int queryId() const;
+    int objectDebugId() const;
+    State state() const;
+
+Q_SIGNALS:
+    void stateChanged(QQmlDebugWatch::State);
+    //void objectChanged(int, const QQmlDebugObjectReference &);
+    //void valueChanged(int, const QVariant &);
+
+    // Server sends value as string if it is a user-type variant
+    void valueChanged(const QByteArray &name, const QVariant &value);
+
+private:
+    friend class QQmlEngineDebug;
+    friend class QQmlEngineDebugPrivate;
+    void setState(State);
+    State m_state;
+    int m_queryId;
+    QQmlEngineDebug *m_client;
+    int m_objectDebugId;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugPropertyWatch : public QQmlDebugWatch
+{
+    Q_OBJECT
+public:
+    QQmlDebugPropertyWatch(QObject *parent);
+
+    QString name() const;
+
+private:
+    friend class QQmlEngineDebug;
+    QString m_name;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugObjectExpressionWatch : public QQmlDebugWatch
+{
+    Q_OBJECT
+public:
+    QQmlDebugObjectExpressionWatch(QObject *parent);
+
+    QString expression() const;
+
+private:
+    friend class QQmlEngineDebug;
+    QString m_expr;
+    int m_debugId;
+};
+
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugQuery : public QObject
+{
+    Q_OBJECT
+public:
+    enum State { Waiting, Error, Completed };
+
+    State state() const;
+    bool isWaiting() const;
+
+Q_SIGNALS:
+    void stateChanged(QQmlDebugQuery::State);
+
+protected:
+    QQmlDebugQuery(QObject *);
+
+private:
+    friend class QQmlEngineDebug;
+    friend class QQmlEngineDebugPrivate;
+    void setState(State);
+    State m_state;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugFileReference 
+{
+public:
+    QQmlDebugFileReference();
+    QQmlDebugFileReference(const QQmlDebugFileReference &);
+    QQmlDebugFileReference &operator=(const QQmlDebugFileReference &);
+
+    QUrl url() const;
+    void setUrl(const QUrl &);
+    int lineNumber() const;
+    void setLineNumber(int);
+    int columnNumber() const;
+    void setColumnNumber(int);
+
+private:
+    friend class QQmlEngineDebugPrivate;
+    QUrl m_url;
+    int m_lineNumber;
+    int m_columnNumber;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugEngineReference
+{
+public:
+    QQmlDebugEngineReference();
+    QQmlDebugEngineReference(int);
+    QQmlDebugEngineReference(const QQmlDebugEngineReference &);
+    QQmlDebugEngineReference &operator=(const QQmlDebugEngineReference &);
+
+    int debugId() const;
+    QString name() const;
+
+private:
+    friend class QQmlEngineDebugPrivate;
+    int m_debugId;
+    QString m_name;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugObjectReference
+{
+public:
+    QQmlDebugObjectReference();
+    QQmlDebugObjectReference(int);
+    QQmlDebugObjectReference(const QQmlDebugObjectReference &);
+    QQmlDebugObjectReference &operator=(const QQmlDebugObjectReference &);
+
+    int debugId() const;
+    QString className() const;
+    QString idString() const;
+    QString name() const;
+
+    QQmlDebugFileReference source() const;
+    int contextDebugId() const;
+
+    QList<QQmlDebugPropertyReference> properties() const;
+    QList<QQmlDebugObjectReference> children() const;
+
+private:
+    friend class QQmlEngineDebugPrivate;
+    int m_debugId;
+    QString m_class;
+    QString m_idString;
+    QString m_name;
+    QQmlDebugFileReference m_source;
+    int m_contextDebugId;
+    QList<QQmlDebugPropertyReference> m_properties;
+    QList<QQmlDebugObjectReference> m_children;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugContextReference
+{
+public:
+    QQmlDebugContextReference();
+    QQmlDebugContextReference(const QQmlDebugContextReference &);
+    QQmlDebugContextReference &operator=(const QQmlDebugContextReference &);
+
+    int debugId() const;
+    QString name() const;
+
+    QList<QQmlDebugObjectReference> objects() const;
+    QList<QQmlDebugContextReference> contexts() const;
+
+private:
+    friend class QQmlEngineDebugPrivate;
+    int m_debugId;
+    QString m_name;
+    QList<QQmlDebugObjectReference> m_objects;
+    QList<QQmlDebugContextReference> m_contexts;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugPropertyReference
+{
+public:
+    QQmlDebugPropertyReference();
+    QQmlDebugPropertyReference(const QQmlDebugPropertyReference &);
+    QQmlDebugPropertyReference &operator=(const QQmlDebugPropertyReference &);
+
+    int objectDebugId() const;
+    QString name() const;
+    QVariant value() const;
+    QString valueTypeName() const;
+    QString binding() const;
+    bool hasNotifySignal() const;
+
+private:
+    friend class QQmlEngineDebugPrivate;
+    int m_objectDebugId;
+    QString m_name;
+    QVariant m_value;
+    QString m_valueTypeName;
+    QString m_binding;
+    bool m_hasNotifySignal;
+};
+
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugEnginesQuery : public QQmlDebugQuery
+{
+    Q_OBJECT
+public:
+    virtual ~QQmlDebugEnginesQuery();
+    QList<QQmlDebugEngineReference> engines() const;
+private:
+    friend class QQmlEngineDebug;
+    friend class QQmlEngineDebugPrivate;
+    QQmlDebugEnginesQuery(QObject *);
+    QQmlEngineDebug *m_client;
+    int m_queryId;
+    QList<QQmlDebugEngineReference> m_engines;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugRootContextQuery : public QQmlDebugQuery
+{
+    Q_OBJECT
+public:
+    virtual ~QQmlDebugRootContextQuery();
+    QQmlDebugContextReference rootContext() const;
+private:
+    friend class QQmlEngineDebug;
+    friend class QQmlEngineDebugPrivate;
+    QQmlDebugRootContextQuery(QObject *);
+    QQmlEngineDebug *m_client;
+    int m_queryId;
+    QQmlDebugContextReference m_context;
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugObjectQuery : public QQmlDebugQuery
+{
+    Q_OBJECT
+public:
+    virtual ~QQmlDebugObjectQuery();
+    QQmlDebugObjectReference object() const;
+private:
+    friend class QQmlEngineDebug;
+    friend class QQmlEngineDebugPrivate;
+    QQmlDebugObjectQuery(QObject *);
+    QQmlEngineDebug *m_client;
+    int m_queryId;
+    QQmlDebugObjectReference m_object;
+
+};
+
+class Q_QML_PRIVATE_EXPORT QQmlDebugExpressionQuery : public QQmlDebugQuery
+{
+    Q_OBJECT
+public:
+    virtual ~QQmlDebugExpressionQuery();
+    QVariant expression() const;
+    QVariant result() const;
+private:
+    friend class QQmlEngineDebug;
+    friend class QQmlEngineDebugPrivate;
+    QQmlDebugExpressionQuery(QObject *);
+    QQmlEngineDebug *m_client;
+    int m_queryId;
+    QVariant m_expr;
+    QVariant m_result;
+};
+
+Q_DECLARE_METATYPE(QQmlDebugEngineReference)
+Q_DECLARE_METATYPE(QQmlDebugObjectReference)
+Q_DECLARE_METATYPE(QQmlDebugContextReference)
+Q_DECLARE_METATYPE(QQmlDebugPropertyReference)
+
+#endif // QQMLENGINEDEBUG_H
diff --git a/tools/qmlprofiler/profileclient.h b/tools/qmlprofiler/profileclient.h
index 8aa4e67..54826a2 100644
--- a/tools/qmlprofiler/profileclient.h
+++ b/tools/qmlprofiler/profileclient.h
@@ -44,7 +44,7 @@
 
 #include "profiledata.h"
 
-#include <QtQml/private/qqmldebugclient_p.h>
+#include "qqmldebugclient.h"
 #include <QtQml/private/qqmlprofilerservice_p.h>
 
 class ProfileClientPrivate;
diff --git a/tools/qmlprofiler/qmlprofiler.pro b/tools/qmlprofiler/qmlprofiler.pro
index ec5f50e..db7e357 100644
--- a/tools/qmlprofiler/qmlprofiler.pro
+++ b/tools/qmlprofiler/qmlprofiler.pro
@@ -2,7 +2,7 @@ TEMPLATE = app
 TARGET   = qmlprofiler
 DESTDIR = $$QT.qml.bins
 
-QT += qml qml-private network
+QT += qml qml-private network core-private
 
 target.path = $$[QT_INSTALL_BINS]
 INSTALLS += target
@@ -15,11 +15,13 @@ SOURCES += main.cpp \
     qmlprofilerapplication.cpp \
     commandlistener.cpp \
     profileclient.cpp \
-    profiledata.cpp
+    profiledata.cpp \
+    qqmldebugclient.cpp
 
 HEADERS += \
     qmlprofilerapplication.h \
     commandlistener.h \
     constants.h \
     profileclient.h \
-    profiledata.h
+    profiledata.h \
+    qqmldebugclient.h
diff --git a/tools/qmlprofiler/qqmldebugclient.cpp b/tools/qmlprofiler/qqmldebugclient.cpp
new file mode 100644
index 0000000..0453f88
--- /dev/null
+++ b/tools/qmlprofiler/qqmldebugclient.cpp
@@ -0,0 +1,410 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qqmldebugclient.h"
+
+#include <private/qpacketprotocol_p.h>
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qstringlist.h>
+#include <QtNetwork/qnetworkproxy.h>
+
+const int protocolVersion = 1;
+const QString serverId = QLatin1String("QDeclarativeDebugServer");
+const QString clientId = QLatin1String("QDeclarativeDebugClient");
+
+class QQmlDebugClientPrivate
+{
+public:
+    QQmlDebugClientPrivate();
+
+    QString name;
+    QQmlDebugConnection *connection;
+};
+
+class QQmlDebugConnectionPrivate : public QObject
+{
+    Q_OBJECT
+public:
+    QQmlDebugConnectionPrivate(QQmlDebugConnection *c);
+    QQmlDebugConnection *q;
+    QPacketProtocol *protocol;
+    QIODevice *device;
+
+    bool gotHello;
+    QHash <QString, float> serverPlugins;
+    QHash<QString, QQmlDebugClient *> plugins;
+
+    void advertisePlugins();
+    void connectDeviceSignals();
+
+public Q_SLOTS:
+    void connected();
+    void readyRead();
+    void deviceAboutToClose();
+};
+
+QQmlDebugConnectionPrivate::QQmlDebugConnectionPrivate(QQmlDebugConnection *c)
+    : QObject(c), q(c), protocol(0), device(0), gotHello(false)
+{
+    protocol = new QPacketProtocol(q, this);
+    QObject::connect(c, SIGNAL(connected()), this, SLOT(connected()));
+    QObject::connect(protocol, SIGNAL(readyRead()), this, SLOT(readyRead()));
+}
+
+void QQmlDebugConnectionPrivate::advertisePlugins()
+{
+    if (!q->isConnected())
+        return;
+
+    QPacket pack;
+    pack << serverId << 1 << plugins.keys();
+    protocol->send(pack);
+    q->flush();
+}
+
+void QQmlDebugConnectionPrivate::connected()
+{
+    QPacket pack;
+    pack << serverId << 0 << protocolVersion << plugins.keys();
+    protocol->send(pack);
+    q->flush();
+}
+
+void QQmlDebugConnectionPrivate::readyRead()
+{
+    if (!gotHello) {
+        QPacket pack = protocol->read();
+        QString name;
+
+        pack >> name;
+
+        bool validHello = false;
+        if (name == clientId) {
+            int op = -1;
+            pack >> op;
+            if (op == 0) {
+                int version = -1;
+                pack >> version;
+                if (version == protocolVersion) {
+                    QStringList pluginNames;
+                    QList<float> pluginVersions;
+                    pack >> pluginNames;
+                    if (!pack.isEmpty())
+                        pack >> pluginVersions;
+
+                    const int pluginNamesSize = pluginNames.size();
+                    const int pluginVersionsSize = pluginVersions.size();
+                    for (int i = 0; i < pluginNamesSize; ++i) {
+                        float pluginVersion = 1.0;
+                        if (i < pluginVersionsSize)
+                            pluginVersion = pluginVersions.at(i);
+                        serverPlugins.insert(pluginNames.at(i), pluginVersion);
+                    }
+
+                    validHello = true;
+                }
+            }
+        }
+
+        if (!validHello) {
+            qWarning("QQmlDebugConnection: Invalid hello message");
+            QObject::disconnect(protocol, SIGNAL(readyRead()), this, SLOT(readyRead()));
+            return;
+        }
+        gotHello = true;
+
+        QHash<QString, QQmlDebugClient *>::Iterator iter = plugins.begin();
+        for (; iter != plugins.end(); ++iter) {
+            QQmlDebugClient::State newState = QQmlDebugClient::Unavailable;
+            if (serverPlugins.contains(iter.key()))
+                newState = QQmlDebugClient::Enabled;
+            iter.value()->stateChanged(newState);
+        }
+    }
+
+    while (protocol->packetsAvailable()) {
+        QPacket pack = protocol->read();
+        QString name;
+        pack >> name;
+
+        if (name == clientId) {
+            int op = -1;
+            pack >> op;
+
+            if (op == 1) {
+                // Service Discovery
+                QHash<QString, float> oldServerPlugins = serverPlugins;
+                serverPlugins.clear();
+
+                QStringList pluginNames;
+                QList<float> pluginVersions;
+                pack >> pluginNames;
+                if (!pack.isEmpty())
+                    pack >> pluginVersions;
+
+                const int pluginNamesSize = pluginNames.size();
+                const int pluginVersionsSize = pluginVersions.size();
+                for (int i = 0; i < pluginNamesSize; ++i) {
+                    float pluginVersion = 1.0;
+                    if (i < pluginVersionsSize)
+                        pluginVersion = pluginVersions.at(i);
+                    serverPlugins.insert(pluginNames.at(i), pluginVersion);
+                }
+
+                QHash<QString, QQmlDebugClient *>::Iterator iter = plugins.begin();
+                for (; iter != plugins.end(); ++iter) {
+                    const QString pluginName = iter.key();
+                    QQmlDebugClient::State newSate = QQmlDebugClient::Unavailable;
+                    if (serverPlugins.contains(pluginName))
+                        newSate = QQmlDebugClient::Enabled;
+
+                    if (oldServerPlugins.contains(pluginName)
+                            != serverPlugins.contains(pluginName)) {
+                        iter.value()->stateChanged(newSate);
+                    }
+                }
+            } else {
+                qWarning() << "QQmlDebugConnection: Unknown control message id" << op;
+            }
+        } else {
+            QByteArray message;
+            pack >> message;
+
+            QHash<QString, QQmlDebugClient *>::Iterator iter =
+                    plugins.find(name);
+            if (iter == plugins.end()) {
+                qWarning() << "QQmlDebugConnection: Message received for missing plugin" << name;
+            } else {
+                (*iter)->messageReceived(message);
+            }
+        }
+    }
+}
+
+void QQmlDebugConnectionPrivate::deviceAboutToClose()
+{
+    // This is nasty syntax but we want to emit our own aboutToClose signal (by calling QIODevice::close())
+    // without calling the underlying device close fn as that would cause an infinite loop
+    q->QIODevice::close();
+}
+
+QQmlDebugConnection::QQmlDebugConnection(QObject *parent)
+    : QIODevice(parent), d(new QQmlDebugConnectionPrivate(this))
+{
+}
+
+QQmlDebugConnection::~QQmlDebugConnection()
+{
+    QHash<QString, QQmlDebugClient*>::iterator iter = d->plugins.begin();
+    for (; iter != d->plugins.end(); ++iter) {
+        iter.value()->d->connection = 0;
+        iter.value()->stateChanged(QQmlDebugClient::NotConnected);
+    }
+}
+
+bool QQmlDebugConnection::isConnected() const
+{
+    return state() == QAbstractSocket::ConnectedState;
+}
+
+qint64 QQmlDebugConnection::readData(char *data, qint64 maxSize)
+{
+    return d->device->read(data, maxSize);
+}
+
+qint64 QQmlDebugConnection::writeData(const char *data, qint64 maxSize)
+{
+    return d->device->write(data, maxSize);
+}
+
+qint64 QQmlDebugConnection::bytesAvailable() const
+{
+    return d->device->bytesAvailable();
+}
+
+bool QQmlDebugConnection::isSequential() const
+{
+    return true;
+}
+
+void QQmlDebugConnection::close()
+{
+    if (isOpen()) {
+        QIODevice::close();
+        d->device->close();
+        emit stateChanged(QAbstractSocket::UnconnectedState);
+
+        QHash<QString, QQmlDebugClient*>::iterator iter = d->plugins.begin();
+        for (; iter != d->plugins.end(); ++iter) {
+            iter.value()->stateChanged(QQmlDebugClient::NotConnected);
+        }
+    }
+}
+
+bool QQmlDebugConnection::waitForConnected(int msecs)
+{
+    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
+    if (socket)
+        return socket->waitForConnected(msecs);
+    return false;
+}
+
+QAbstractSocket::SocketState QQmlDebugConnection::state() const
+{
+    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
+    if (socket)
+        return socket->state();
+
+    return QAbstractSocket::UnconnectedState;
+}
+
+void QQmlDebugConnection::flush()
+{
+    QAbstractSocket *socket = qobject_cast<QAbstractSocket*>(d->device);
+    if (socket) {
+        socket->flush();
+        return;
+    }
+}
+
+void QQmlDebugConnection::connectToHost(const QString &hostName, quint16 port)
+{
+    QTcpSocket *socket = new QTcpSocket(d);
+    socket->setProxy(QNetworkProxy::NoProxy);
+    d->device = socket;
+    d->connectDeviceSignals();
+    d->gotHello = false;
+    connect(socket, SIGNAL(stateChanged(QAbstractSocket::SocketState)), this, SIGNAL(stateChanged(QAbstractSocket::SocketState)));
+    connect(socket, SIGNAL(error(QAbstractSocket::SocketError)), this, SIGNAL(error(QAbstractSocket::SocketError)));
+    connect(socket, SIGNAL(connected()), this, SIGNAL(connected()));
+    socket->connectToHost(hostName, port);
+    QIODevice::open(ReadWrite | Unbuffered);
+}
+
+void QQmlDebugConnectionPrivate::connectDeviceSignals()
+{
+    connect(device, SIGNAL(bytesWritten(qint64)), q, SIGNAL(bytesWritten(qint64)));
+    connect(device, SIGNAL(readyRead()), q, SIGNAL(readyRead()));
+    connect(device, SIGNAL(aboutToClose()), this, SLOT(deviceAboutToClose()));
+}
+
+//
+
+QQmlDebugClientPrivate::QQmlDebugClientPrivate()
+    : connection(0)
+{
+}
+
+QQmlDebugClient::QQmlDebugClient(const QString &name, 
+                                                 QQmlDebugConnection *parent)
+    : QObject(parent),
+      d(new QQmlDebugClientPrivate)
+{
+    d->name = name;
+    d->connection = parent;
+
+    if (!d->connection)
+        return;
+
+    if (d->connection->d->plugins.contains(name)) {
+        qWarning() << "QQmlDebugClient: Conflicting plugin name" << name;
+        d->connection = 0;
+    } else {
+        d->connection->d->plugins.insert(name, this);
+        d->connection->d->advertisePlugins();
+    }
+}
+
+QQmlDebugClient::~QQmlDebugClient()
+{
+    if (d->connection && d->connection->d) {
+        d->connection->d->plugins.remove(d->name);
+        d->connection->d->advertisePlugins();
+    }
+    delete d;
+}
+
+QString QQmlDebugClient::name() const
+{
+    return d->name;
+}
+
+float QQmlDebugClient::serviceVersion() const
+{
+    if (d->connection->d->serverPlugins.contains(d->name))
+        return d->connection->d->serverPlugins.value(d->name);
+    return -1;
+}
+
+QQmlDebugClient::State QQmlDebugClient::state() const
+{
+    if (!d->connection
+            || !d->connection->isConnected()
+            || !d->connection->d->gotHello)
+        return NotConnected;
+
+    if (d->connection->d->serverPlugins.contains(d->name))
+        return Enabled;
+
+    return Unavailable;
+}
+
+void QQmlDebugClient::sendMessage(const QByteArray &message)
+{
+    if (state() != Enabled)
+        return;
+
+    QPacket pack;
+    pack << d->name << message;
+    d->connection->d->protocol->send(pack);
+    d->connection->flush();
+}
+
+void QQmlDebugClient::stateChanged(State)
+{
+}
+
+void QQmlDebugClient::messageReceived(const QByteArray &)
+{
+}
+
+#include <qqmldebugclient.moc>
diff --git a/tools/qmlprofiler/qqmldebugclient.h b/tools/qmlprofiler/qqmldebugclient.h
new file mode 100644
index 0000000..0f140a1
--- /dev/null
+++ b/tools/qmlprofiler/qqmldebugclient.h
@@ -0,0 +1,109 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQMLDEBUGCLIENT_H
+#define QQMLDEBUGCLIENT_H
+
+#include <QtNetwork/qtcpsocket.h>
+
+class QQmlDebugConnectionPrivate;
+class QQmlDebugConnection : public QIODevice
+{
+    Q_OBJECT
+    Q_DISABLE_COPY(QQmlDebugConnection)
+public:
+    QQmlDebugConnection(QObject * = 0);
+    ~QQmlDebugConnection();
+
+    void connectToHost(const QString &hostName, quint16 port);
+
+    qint64 bytesAvailable() const;
+    bool isConnected() const;
+    QAbstractSocket::SocketState state() const;
+    void flush();
+    bool isSequential() const;
+    void close();
+    bool waitForConnected(int msecs = 30000);
+
+signals:
+    void connected();
+    void stateChanged(QAbstractSocket::SocketState socketState);
+    void error(QAbstractSocket::SocketError socketError);
+
+protected:
+    qint64 readData(char *data, qint64 maxSize);
+    qint64 writeData(const char *data, qint64 maxSize);
+
+private:
+    QQmlDebugConnectionPrivate *d;
+    friend class QQmlDebugClient;
+    friend class QQmlDebugClientPrivate;
+};
+
+class QQmlDebugClientPrivate;
+class QQmlDebugClient : public QObject
+{
+    Q_OBJECT
+    Q_DISABLE_COPY(QQmlDebugClient)
+
+public:
+    enum State { NotConnected, Unavailable, Enabled };
+
+    QQmlDebugClient(const QString &, QQmlDebugConnection *parent);
+    ~QQmlDebugClient();
+
+    QString name() const;
+    float serviceVersion() const;
+    State state() const;
+
+    virtual void sendMessage(const QByteArray &);
+
+protected:
+    virtual void stateChanged(State);
+    virtual void messageReceived(const QByteArray &);
+
+private:
+    QQmlDebugClientPrivate *d;
+    friend class QQmlDebugConnection;
+    friend class QQmlDebugConnectionPrivate;
+};
+
+#endif // QQMLDEBUGCLIENT_H