diff --git a/bin/fixqt4headers.pl b/bin/fixqt4headers.pl
index 3516168..2c92f72 100755
--- a/bin/fixqt4headers.pl
+++ b/bin/fixqt4headers.pl
@@ -141,6 +141,7 @@ sub findQtHeaders
 die "This script requires the QTDIR environment variable pointing to Qt 5\n" unless $qtdir;
 
 findQtHeaders('QtCore', $qtdir);
+findQtHeaders('QtConcurrent', $qtdir);
 findQtHeaders('QtWidgets', $qtdir);
 findQtHeaders('QtPrintSupport', $qtdir);
 
diff --git a/examples/qtconcurrent/imagescaling/imagescaling.h b/examples/qtconcurrent/imagescaling/imagescaling.h
index 204a297..1f68a38 100644
--- a/examples/qtconcurrent/imagescaling/imagescaling.h
+++ b/examples/qtconcurrent/imagescaling/imagescaling.h
@@ -41,6 +41,7 @@
 #define IMAGESCALING_H
 
 #include <QtWidgets>
+#include <QtConcurrent>
 
 #ifndef QT_NO_CONCURRENT
 
diff --git a/examples/qtconcurrent/imagescaling/imagescaling.pro b/examples/qtconcurrent/imagescaling/imagescaling.pro
index 2ec5abd..b268aa7 100644
--- a/examples/qtconcurrent/imagescaling/imagescaling.pro
+++ b/examples/qtconcurrent/imagescaling/imagescaling.pro
@@ -1,6 +1,7 @@
 TEMPLATE = app
 DEPENDPATH += .
 INCLUDEPATH += .
+QT += concurrent
 
 # Input
 SOURCES += main.cpp imagescaling.cpp
diff --git a/examples/qtconcurrent/imagescaling/main.cpp b/examples/qtconcurrent/imagescaling/main.cpp
index f7a359c..9fef7d3 100644
--- a/examples/qtconcurrent/imagescaling/main.cpp
+++ b/examples/qtconcurrent/imagescaling/main.cpp
@@ -38,6 +38,7 @@
 **
 ****************************************************************************/
 #include <QtWidgets>
+#include <QtConcurrent>
 
 #ifndef QT_NO_CONCURRENT
 
diff --git a/examples/qtconcurrent/map/map.pro b/examples/qtconcurrent/map/map.pro
index 978eae4..72f7707 100644
--- a/examples/qtconcurrent/map/map.pro
+++ b/examples/qtconcurrent/map/map.pro
@@ -2,6 +2,7 @@ TEMPLATE = app
 TARGET = mapdemo
 DEPENDPATH += .
 INCLUDEPATH += .
+QT += concurrent widgets
 
 # Input
 SOURCES += main.cpp
@@ -13,6 +14,4 @@ sources.files = $$SOURCES $$HEADERS $$FORMS $$RESOURCES *.pro *.png
 sources.path = $$[QT_INSTALL_EXAMPLES]/qtbase/qtconcurrent/map
 INSTALLS += target sources
 
-QT += widgets
-
 simulator: warning(This example does not work on Simulator platform)
diff --git a/examples/qtconcurrent/progressdialog/main.cpp b/examples/qtconcurrent/progressdialog/main.cpp
index b26824c..87ea4f5 100644
--- a/examples/qtconcurrent/progressdialog/main.cpp
+++ b/examples/qtconcurrent/progressdialog/main.cpp
@@ -39,6 +39,7 @@
 ****************************************************************************/
 
 #include <QtWidgets>
+#include <QtConcurrent>
 
 #ifndef QT_NO_CONCURRENT
 
diff --git a/examples/qtconcurrent/progressdialog/progressdialog.pro b/examples/qtconcurrent/progressdialog/progressdialog.pro
index fbc239d..75a3aba 100644
--- a/examples/qtconcurrent/progressdialog/progressdialog.pro
+++ b/examples/qtconcurrent/progressdialog/progressdialog.pro
@@ -12,6 +12,6 @@ sources.files = $$SOURCES $$HEADERS $$FORMS $$RESOURCES *.pro *.png
 sources.path = $$[QT_INSTALL_EXAMPLES]/qtbase/qtconcurrent/progressdialog
 INSTALLS += target sources
 
-QT += widgets
+QT += concurrent widgets
 
 simulator: warning(This example does not work on Simulator platform)
diff --git a/examples/qtconcurrent/runfunction/runfunction.pro b/examples/qtconcurrent/runfunction/runfunction.pro
index d41b88e..f047577 100644
--- a/examples/qtconcurrent/runfunction/runfunction.pro
+++ b/examples/qtconcurrent/runfunction/runfunction.pro
@@ -12,6 +12,6 @@ sources.files = $$SOURCES $$HEADERS $$FORMS $$RESOURCES *.pro *.png
 sources.path = $$[QT_INSTALL_EXAMPLES]/qtbase/qtconcurrent/runfunction
 INSTALLS += target sources
 
-QT += widgets
+QT += concurrent widgets
 
 simulator: warning(This example does not work on Simulator platform)
diff --git a/examples/qtconcurrent/wordcount/wordcount.pro b/examples/qtconcurrent/wordcount/wordcount.pro
index ee4887c..3bddf1a 100644
--- a/examples/qtconcurrent/wordcount/wordcount.pro
+++ b/examples/qtconcurrent/wordcount/wordcount.pro
@@ -12,6 +12,6 @@ sources.files = $$SOURCES $$HEADERS $$FORMS $$RESOURCES *.pro *.png
 sources.path = $$[QT_INSTALL_EXAMPLES]/qtbase/qtconcurrent/wordcount
 INSTALLS += target sources
 
-QT += widgets
+QT += concurrent widgets
 
 simulator: warning(This example does not work on Simulator platform)
diff --git a/examples/tutorials/threads/helloconcurrent/helloconcurrent.cpp b/examples/tutorials/threads/helloconcurrent/helloconcurrent.cpp
index fb8f55d..02aed98 100644
--- a/examples/tutorials/threads/helloconcurrent/helloconcurrent.cpp
+++ b/examples/tutorials/threads/helloconcurrent/helloconcurrent.cpp
@@ -39,6 +39,8 @@
 ****************************************************************************/
 
 #include <QtCore>
+#include <QtConcurrent>
+
 /*
  says hello from main thread and secondary thread using QtConcurrent
 */
diff --git a/examples/tutorials/threads/helloconcurrent/helloconcurrent.pro b/examples/tutorials/threads/helloconcurrent/helloconcurrent.pro
index fb3cd0b..1941666 100644
--- a/examples/tutorials/threads/helloconcurrent/helloconcurrent.pro
+++ b/examples/tutorials/threads/helloconcurrent/helloconcurrent.pro
@@ -1,4 +1,5 @@
 QT -= gui
+QT += concurrent
 
 CONFIG += console
 CONFIG -= app_bundle
diff --git a/src/concurrent/concurrent.pro b/src/concurrent/concurrent.pro
new file mode 100644
index 0000000..a9482af
--- /dev/null
+++ b/src/concurrent/concurrent.pro
@@ -0,0 +1,59 @@
+TARGET     = QtConcurrent
+QPRO_PWD   = $$PWD
+QT         = core-private
+
+CONFIG += module
+MODULE_PRI = ../modules/qt_concurrent.pri
+
+DEFINES   += QT_BUILD_CONCURRENT_LIB QT_NO_USING_NAMESPACE
+win32-msvc*|win32-icc:QMAKE_LFLAGS += /BASE:0x66000000
+
+unix|win32-g++*:QMAKE_PKGCONFIG_REQUIRES = QtCore
+
+load(qt_module_config)
+
+HEADERS += $$QT_SOURCE_TREE/src/xml/qtconcurrentversion.h
+
+PRECOMPILED_HEADER = ../corelib/global/qt_pch.h
+
+SOURCES += \
+        qfuture.cpp \
+        qfutureinterface.cpp \
+        qfuturesynchronizer.cpp \
+        qfuturewatcher.cpp \
+        qtconcurrentfilter.cpp \
+        qtconcurrentmap.cpp \
+        qtconcurrentresultstore.cpp \
+        qtconcurrentthreadengine.cpp \
+        qtconcurrentiteratekernel.cpp \
+        qtconcurrentexception.cpp
+
+HEADERS += \
+        qfuture.h \
+        qfutureinterface.h \
+        qfuturesynchronizer.h \
+        qfuturewatcher.h \
+        qtconcurrentcompilertest.h \
+        qtconcurrentexception.h \
+        qtconcurrentfilter.h \
+        qtconcurrentfilterkernel.h \
+        qtconcurrentfunctionwrappers.h \
+        qtconcurrentiteratekernel.h \
+        qtconcurrentmap.h \
+        qtconcurrentmapkernel.h \
+        qtconcurrentmedian.h \
+        qtconcurrentreducekernel.h \
+        qtconcurrentresultstore.h \
+        qtconcurrentrun.h \
+        qtconcurrentrunbase.h \
+        qtconcurrentstoredfunctioncall.h \
+        qtconcurrentthreadengine.h
+
+# private headers
+HEADERS += \
+        qfutureinterface_p.h \
+        qfuturewatcher_p.h
+
+contains(QT_CONFIG, clock-gettime) {
+    linux-*|hpux-*|solaris-*:LIBS *= -lrt
+}
diff --git a/src/concurrent/qfuture.cpp b/src/concurrent/qfuture.cpp
new file mode 100644
index 0000000..9805454
--- /dev/null
+++ b/src/concurrent/qfuture.cpp
@@ -0,0 +1,697 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*! \class QFuture
+    \threadsafe
+    \brief The QFuture class represents the result of an asynchronous computation.
+    \since 4.4
+
+    \ingroup thread
+
+    To start a computation, use one of the APIs in the
+    \l {Concurrent Programming}{Qt Concurrent} framework.
+
+    QFuture allows threads to be synchronized against one or more results
+    which will be ready at a later point in time. The result can be of any type
+    that has a default constructor and a copy constructor. If a result is not
+    available at the time of calling the result(), resultAt(), or results()
+    functions, QFuture will wait until the result becomes available. You can
+    use the isResultReadyAt() function to determine if a result is ready or
+    not. For QFuture objects that report more than one result, the
+    resultCount() function returns the number of continuous results. This
+    means that it is always safe to iterate through the results from 0 to 
+    resultCount().
+
+    QFuture provides a \l{Java-style iterators}{Java-style iterator}
+    (QFutureIterator) and an \l{STL-style iterators}{STL-style iterator}
+    (QFuture::const_iterator). Using these iterators is  another way to access
+    results in the future.
+
+    QFuture also offers ways to interact with a runnning computation. For
+    instance, the computation can be canceled with the cancel() function. To
+    pause the computation, use the setPaused() function or one of the pause(),
+    resume(), or togglePaused() convenience functions. Be aware that not all
+    asynchronous computations can be canceled or paused. For example, the
+    future returned by QtConcurrent::run() cannot be canceled; but the
+    future returned by QtConcurrent::mappedReduced() can.
+
+    Progress information is provided by the progressValue(),
+    progressMinimum(), progressMaximum(), and progressText() functions. The
+    waitForFinished() function causes the calling thread to block and wait for
+    the computation to finish, ensuring that all results are available.
+
+    The state of the computation represented by a QFuture can be queried using
+    the isCanceled(), isStarted(), isFinished(), isRunning(), or isPaused()
+    functions.
+
+    QFuture is a lightweight reference counted class that can be passed by
+    value.
+
+    QFuture<void> is specialized to not contain any of the result fetching
+    functions. Any QFuture<T> can be assigned or copied into a QFuture<void>
+    as well. This is useful if only status or progress information is needed
+    - not the actual result data.
+
+    To interact with running tasks using signals and slots, use QFutureWatcher.
+
+    \sa QFutureWatcher, {Concurrent Programming}{Qt Concurrent}
+*/
+
+/*! \fn QFuture::QFuture()
+
+    Constructs an empty future.
+*/
+
+/*! \fn QFuture::QFuture(const QFuture &other)
+
+    Constructs a copy of \a other.
+
+    \sa operator=()
+*/
+
+/*! \fn QFuture::QFuture(QFutureInterface<T> *resultHolder)
+    \internal
+*/
+
+/*! \fn QFuture::~QFuture()
+
+    Destroys the future.
+
+    Note that this neither waits nor cancels the asynchronous computation. Use
+    waitForFinished() or QFutureSynchronizer when you need to ensure that the
+    computation is completed before the future is destroyed.
+*/
+
+/*! \fn QFuture &QFuture::operator=(const QFuture &other)
+
+     Assigns \a other to this future and returns a reference to this future.
+*/
+
+/*! \fn bool QFuture::operator==(const QFuture &other) const
+
+    Returns true if \a other is a copy of this future; otherwise returns false.
+*/
+
+/*! \fn bool QFuture::operator!=(const QFuture &other) const
+
+    Returns true if \a other is \e not a copy of this future; otherwise returns
+    false.
+*/
+
+/*! \fn void QFuture::cancel()
+
+    Cancels the asynchronous computation represented by this future. Note that
+    the cancelation is asynchronous. Use waitForFinished() after calling
+    cancel() when you need synchronous cancelation.
+
+    Results currently available may still be accessed on a canceled future,
+    but new results will \e not become available after calling this function.
+    Any QFutureWatcher object that is watching this future will not deliver
+    progress and result ready signals on a canceled future.
+
+    Be aware that not all asynchronous computations can be canceled. For
+    example, the future returned by QtConcurrent::run() cannot be canceled;
+    but the future returned by QtConcurrent::mappedReduced() can.
+*/
+
+/*! \fn bool QFuture::isCanceled() const
+
+    Returns true if the asynchronous computation has been canceled with the
+    cancel() function; otherwise returns false.
+
+    Be aware that the computation may still be running even though this
+    function returns true. See cancel() for more details.
+*/
+
+/*! \fn void QFuture::setPaused(bool paused)
+
+    If \a paused is true, this function pauses the asynchronous computation
+    represented by the future. If the computation is  already paused, this
+    function does nothing. Any QFutureWatcher object that is watching this
+    future will stop delivering progress and result ready signals while the
+    future is paused. Signal delivery will continue once the future is
+    resumed.
+
+    If \a paused is false, this function resumes the asynchronous computation.
+    If the computation was not previously paused, this function does nothing.
+
+    Be aware that not all computations can be paused. For example, the future
+    returned by QtConcurrent::run() cannot be paused; but the future returned
+    by QtConcurrent::mappedReduced() can.
+
+    \sa pause(), resume(), togglePaused()
+*/
+
+/*! \fn bool QFuture::isPaused() const
+
+    Returns true if the asynchronous computation has been paused with the
+    pause() function; otherwise returns false.
+
+    Be aware that the computation may still be running even though this
+    function returns true. See setPaused() for more details.
+
+    \sa setPaused(), togglePaused()
+*/
+
+/*! \fn void QFuture::pause()
+
+    Pauses the asynchronous computation represented by this future. This is a
+    convenience method that simply calls setPaused(true).
+
+    \sa resume()
+*/
+
+/*! \fn void QFuture::resume()
+
+    Resumes the asynchronous computation represented by this future. This is a
+    convenience method that simply calls setPaused(false).
+
+    \sa pause()
+*/
+
+/*! \fn void QFuture::togglePaused()
+
+    Toggles the paused state of the asynchronous computation. In other words,
+    if the computation is currently paused, calling this function resumes it;
+    if the computation is running, it is paused. This is a convenience method
+    for calling setPaused(!isPaused()).
+
+    \sa setPaused(), pause(), resume()
+*/
+
+/*! \fn bool QFuture::isStarted() const
+
+    Returns true if the asynchronous computation represented by this future
+    has been started; otherwise returns false.
+*/
+
+/*! \fn bool QFuture::isFinished() const
+
+    Returns true if the asynchronous computation represented by this future
+    has finished; otherwise returns false.
+*/
+
+/*! \fn bool QFuture::isRunning() const
+
+    Returns true if the asynchronous computation represented by this future is
+    currently running; otherwise returns false.
+*/
+
+/*! \fn int QFuture::resultCount() const
+
+    Returns the number of continuous results available in this future. The real
+    number of results stored might be different from this value, due to gaps
+    in the result set. It is always safe to iterate through the results from 0
+    to resultCount().
+    \sa result(), resultAt(), results()
+*/
+
+/*! \fn int QFuture::progressValue() const
+
+    Returns the current progress value, which is between the progressMinimum()
+    and progressMaximum().
+
+    \sa progressMinimum(), progressMaximum()
+*/
+
+/*! \fn int QFuture::progressMinimum() const
+
+    Returns the minimum progressValue().
+
+    \sa progressValue(), progressMaximum()
+*/
+
+/*! \fn int QFuture::progressMaximum() const
+
+    Returns the maximum progressValue().
+
+    \sa progressValue(), progressMinimum()
+*/
+
+/*! \fn QString QFuture::progressText() const
+
+    Returns the (optional) textual representation of the progress as reported
+    by the asynchronous computation.
+
+    Be aware that not all computations provide a textual representation of the
+    progress, and as such, this function may return an empty string.
+*/
+
+/*! \fn void QFuture::waitForFinished()
+
+    Waits for the asynchronous computation to finish (including cancel()ed
+    computations).
+*/
+
+/*! \fn T QFuture::result() const
+
+    Returns the first result in the future. If the result is not immediately
+    available, this function will block and wait for the result to become
+    available. This is a convenience method for calling resultAt(0).
+
+    \sa resultAt(), results()
+*/
+
+/*! \fn T QFuture::resultAt(int index) const
+
+    Returns the result at \a index in the future. If the result is not
+    immediately available, this function will block and wait for the result to
+    become available.
+
+    \sa result(), results(), resultCount()
+*/
+
+/*! \fn bool QFuture::isResultReadyAt(int index) const
+
+    Returns true if the result at \a index is immediately available; otherwise
+    returns false.
+
+    \sa resultAt(), resultCount()
+*/
+
+/*! \fn QFuture::operator T() const
+
+    Returns the first result in the future. If the result is not immediately
+    available, this function will block and wait for the result to become
+    available. This is a convenience method for calling result() or
+    resultAt(0).
+
+    \sa result(), resultAt(), results()
+*/
+
+/*! \fn QList<T> QFuture::results() const
+
+    Returns all results from the future. If the results are not immediately
+    available, this function will block and wait for them to become available.
+
+    \sa result(), resultAt(), resultCount()
+*/
+
+/*! \fn QFuture::const_iterator QFuture::begin() const
+
+    Returns a const \l{STL-style iterator} pointing to the first result in the
+    future.
+
+    \sa constBegin(), end()
+*/
+
+/*! \fn QFuture::const_iterator QFuture::end() const
+
+    Returns a const \l{STL-style iterator} pointing to the imaginary result
+    after the last result in the future.
+
+    \sa begin(), constEnd()
+*/
+
+/*! \fn QFuture::const_iterator QFuture::constBegin() const
+
+    Returns a const \l{STL-style iterator} pointing to the first result in the
+    future.
+
+    \sa begin(), constEnd()
+*/
+
+/*! \fn QFuture::const_iterator QFuture::constEnd() const
+
+    Returns a const \l{STL-style iterator} pointing to the imaginary result
+    after the last result in the future.
+
+    \sa constBegin(), end()
+*/
+
+/*! \class QFuture::const_iterator
+    \reentrant
+    \since 4.4
+
+    \brief The QFuture::const_iterator class provides an STL-style const
+    iterator for QFuture.
+
+    QFuture provides both \l{STL-style iterators} and \l{Java-style iterators}.
+    The STL-style iterators are more low-level and more cumbersome to use; on
+    the other hand, they are slightly faster and, for developers who already
+    know STL, have the advantage of familiarity.
+
+    The default QFuture::const_iterator constructor creates an uninitialized
+    iterator. You must initialize it using a QFuture function like
+    QFuture::constBegin() or QFuture::constEnd() before you start iterating.
+    Here's a typical loop that prints all the results available in a future:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuture.cpp 0
+
+    \sa QFutureIterator, QFuture
+*/
+
+/*! \typedef QFuture::const_iterator::iterator_category
+
+    Typedef for std::bidirectional_iterator_tag. Provided for STL compatibility.
+*/
+
+/*! \typedef QFuture::const_iterator::difference_type
+
+    Typedef for ptrdiff_t. Provided for STL compatibility.
+*/
+
+/*! \typedef QFuture::const_iterator::value_type
+
+    Typedef for T. Provided for STL compatibility.
+*/
+
+/*! \typedef QFuture::const_iterator::pointer
+
+    Typedef for const T *. Provided for STL compatibility.
+*/
+
+/*! \typedef QFuture::const_iterator::reference
+
+    Typedef for const T &. Provided for STL compatibility.
+*/
+
+/*! \fn QFuture::const_iterator::const_iterator()
+
+    Constructs an uninitialized iterator.
+
+    Functions like operator*() and operator++() should not be called on an
+    uninitialized iterartor. Use operator=() to assign a value to it before
+    using it.
+
+    \sa QFuture::constBegin() QFuture::constEnd()
+*/
+
+/*! \fn QFuture::const_iterator::const_iterator(QFuture const * const future, int index)
+    \internal
+*/
+
+/*! \fn QFuture::const_iterator::const_iterator(const const_iterator &other)
+
+    Constructs a copy of \a other.
+*/
+
+/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator=(const const_iterator &other)
+
+    Assigns \a other to this iterator.
+*/
+
+/*! \fn const T &QFuture::const_iterator::operator*() const
+
+    Returns the current result.
+*/
+
+/*! \fn const T *QFuture::const_iterator::operator->() const
+
+    Returns a pointer to the current result.
+*/
+
+/*! \fn bool QFuture::const_iterator::operator!=(const const_iterator &other) const
+
+    Returns true if \a other points to a different result than this iterator;
+    otherwise returns false.
+
+    \sa operator==()
+*/
+
+/*! \fn bool QFuture::const_iterator::operator==(const const_iterator &other) const
+
+    Returns true if \a other points to the same result as this iterator;
+    otherwise returns false.
+
+    \sa operator!=()
+*/
+
+/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator++()
+
+    The prefix ++ operator (\c{++it}) advances the iterator to the next result
+    in the future and returns an iterator to the new current result.
+
+    Calling this function on QFuture::constEnd() leads to undefined results.
+
+    \sa operator--()
+*/
+
+/*! \fn QFuture::const_iterator QFuture::const_iterator::operator++(int)
+
+    \overload
+
+    The postfix ++ operator (\c{it++}) advances the iterator to the next
+    result in the future and returns an iterator to the previously current
+    result.
+*/
+
+/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator--()
+
+    The prefix -- operator (\c{--it}) makes the preceding result current and
+    returns an iterator to the new current result.
+
+    Calling this function on QFuture::constBegin() leads to undefined results.
+
+    \sa operator++()
+*/
+
+/*! \fn QFuture::const_iterator QFuture::const_iterator::operator--(int)
+
+    \overload
+
+    The postfix -- operator (\c{it--}) makes the preceding result current and
+    returns an iterator to the previously current result.
+*/
+
+/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator+=(int j)
+
+    Advances the iterator by \a j results. (If \a j is negative, the iterator
+    goes backward.)
+
+    \sa operator-=(), operator+()
+*/
+
+/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator-=(int j)
+
+    Makes the iterator go back by \a j results. (If \a j is negative, the
+    iterator goes forward.)
+
+    \sa operator+=(), operator-()
+*/
+
+/*! \fn QFuture::const_iterator QFuture::const_iterator::operator+(int j) const
+
+    Returns an iterator to the results at \a j positions forward from this
+    iterator. (If \a j is negative, the iterator goes backward.)
+
+    \sa operator-(), operator+=()
+*/
+
+/*! \fn QFuture::const_iterator QFuture::const_iterator::operator-(int j) const
+
+    Returns an iterator to the result at \a j positions backward from this
+    iterator. (If \a j is negative, the iterator goes forward.)
+
+    \sa operator+(), operator-=()
+*/
+
+/*! \typedef QFuture::ConstIterator
+
+    Qt-style synonym for QFuture::const_iterator.
+*/
+
+/*!
+    \class QFutureIterator
+    \reentrant
+    \since 4.4
+    \inmodule QtCore
+
+    \brief The QFutureIterator class provides a Java-style const iterator for
+    QFuture.
+
+    QFuture has both \l{Java-style iterators} and \l{STL-style iterators}. The
+    Java-style iterators are more high-level and easier to use than the
+    STL-style iterators; on the other hand, they are slightly less efficient.
+
+    An alternative to using iterators is to use index positions. Some QFuture
+    member functions take an index as their first parameter, making it
+    possible to access results without using iterators.
+
+    QFutureIterator\<T\> allows you to iterate over a QFuture\<T\>. Note that
+    there is no mutable iterator for QFuture (unlike the other Java-style
+    iterators).
+
+    The QFutureIterator constructor takes a QFuture as its argument. After
+    construction, the iterator is located at the very beginning of the result
+    list (i.e. before the first result). Here's how to iterate over all the
+    results sequentially:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuture.cpp 1
+
+    The next() function returns the next result (waiting for it to become
+    available, if necessary) from the future and advances the iterator. Unlike
+    STL-style iterators, Java-style iterators point \e between results rather
+    than directly \e at results. The first call to next() advances the iterator
+    to the position between the first and second result, and returns the first
+    result; the second call to next() advances the iterator to the position
+    between the second and third result, and returns the second result; and
+    so on.
+
+    \img javaiterators1.png
+
+    Here's how to iterate over the elements in reverse order:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuture.cpp 2
+
+    If you want to find all occurrences of a particular value, use findNext()
+    or findPrevious() in a loop.
+
+    Multiple iterators can be used on the same future. If the future is
+    modified while a QFutureIterator is active, the QFutureIterator will
+    continue iterating over the original future, ignoring the modified copy.
+
+    \sa QFuture::const_iterator, QFuture
+*/
+
+/*!
+    \fn QFutureIterator::QFutureIterator(const QFuture<T> &future)
+
+    Constructs an iterator for traversing \a future. The iterator is set to be
+    at the front of the result list (before the first result).
+
+    \sa operator=()
+*/
+
+/*! \fn QFutureIterator &QFutureIterator::operator=(const QFuture<T> &future)
+
+    Makes the iterator operate on \a future. The iterator is set to be at the
+    front of the result list (before the first result).
+
+    \sa toFront(), toBack()
+*/
+
+/*! \fn void QFutureIterator::toFront()
+
+    Moves the iterator to the front of the result list (before the first
+    result).
+
+    \sa toBack(), next()
+*/
+
+/*! \fn void QFutureIterator::toBack()
+
+    Moves the iterator to the back of the result list (after the last result).
+
+    \sa toFront(), previous()
+*/
+
+/*! \fn bool QFutureIterator::hasNext() const
+
+    Returns true if there is at least one result ahead of the iterator, e.g.,
+    the iterator is \e not at the back of the result list; otherwise returns
+    false.
+
+    \sa hasPrevious(), next()
+*/
+
+/*! \fn const T &QFutureIterator::next()
+
+    Returns the next result and advances the iterator by one position.
+
+    Calling this function on an iterator located at the back of the result
+    list leads to undefined results.
+
+    \sa hasNext(), peekNext(), previous()
+*/
+
+/*! \fn const T &QFutureIterator::peekNext() const
+
+    Returns the next result without moving the iterator.
+
+    Calling this function on an iterator located at the back of the result
+    list leads to undefined results.
+
+    \sa hasNext(), next(), peekPrevious()
+*/
+
+/*! \fn bool QFutureIterator::hasPrevious() const
+
+    Returns true if there is at least one result ahead of the iterator, e.g.,
+    the iterator is \e not at the front of the result list; otherwise returns
+    false.
+
+    \sa hasNext(), previous()
+*/
+
+/*! \fn const T &QFutureIterator::previous()
+
+    Returns the previous result and moves the iterator back by one position.
+
+    Calling this function on an iterator located at the front of the result
+    list leads to undefined results.
+
+    \sa hasPrevious(), peekPrevious(), next()
+*/
+
+/*! \fn const T &QFutureIterator::peekPrevious() const
+
+    Returns the previous result without moving the iterator.
+
+    Calling this function on an iterator located at the front of the result
+    list leads to undefined results.
+
+    \sa hasPrevious(), previous(), peekNext()
+*/
+
+/*! \fn bool QFutureIterator::findNext(const T &value)
+
+    Searches for \a value starting from the current iterator position forward.
+    Returns true if \a value is found; otherwise returns false.
+
+    After the call, if \a value was found, the iterator is positioned just
+    after the matching result; otherwise, the iterator is positioned at the
+    back of the result list.
+
+    \sa findPrevious()
+*/
+
+/*! \fn bool QFutureIterator::findPrevious(const T &value)
+
+    Searches for \a value starting from the current iterator position
+    backward. Returns true if \a value is found; otherwise returns false.
+
+    After the call, if \a value was found, the iterator is positioned just
+    before the matching result; otherwise, the iterator is positioned at the
+    front of the result list.
+
+    \sa findNext()
+*/
diff --git a/src/concurrent/qfuture.h b/src/concurrent/qfuture.h
new file mode 100644
index 0000000..6e99a60
--- /dev/null
+++ b/src/concurrent/qfuture.h
@@ -0,0 +1,277 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFUTURE_H
+#define QFUTURE_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_QFUTURE
+
+#include <QtConcurrent/qfutureinterface.h>
+#include <QtCore/qstring.h>
+#include <QtConcurrent/qtconcurrentcompilertest.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+template <typename T>
+class QFutureWatcher;
+template <>
+class QFutureWatcher<void>;
+
+template <typename T>
+class QFuture
+{
+public:
+    QFuture()
+        : d(QFutureInterface<T>::canceledResult())
+    { }
+    explicit QFuture(QFutureInterface<T> *p) // internal
+        : d(*p)
+    { }
+    QFuture(const QFuture &other)
+        : d(other.d)
+    { }
+    ~QFuture()
+    { }
+
+    inline QFuture &operator=(const QFuture &other);
+    bool operator==(const QFuture &other) const { return (d == other.d); }
+    bool operator!=(const QFuture &other) const { return (d != other.d); }
+
+    void cancel() { d.cancel(); }
+    bool isCanceled() const { return d.isCanceled(); }
+
+    void setPaused(bool paused) { d.setPaused(paused); }
+    bool isPaused() const { return d.isPaused(); }
+    void pause() { setPaused(true); }
+    void resume() { setPaused(false); }
+    void togglePaused() { d.togglePaused(); }
+
+    bool isStarted() const { return d.isStarted(); }
+    bool isFinished() const { return d.isFinished(); }
+    bool isRunning() const { return d.isRunning(); }
+
+    int resultCount() const { return d.resultCount(); }
+    int progressValue() const { return d.progressValue(); }
+    int progressMinimum() const { return d.progressMinimum(); }
+    int progressMaximum() const { return d.progressMaximum(); }
+    QString progressText() const { return d.progressText(); }
+    void waitForFinished() { d.waitForFinished(); }
+
+    inline T result() const;
+    inline T resultAt(int index) const;
+    bool isResultReadyAt(int resultIndex) const { return d.isResultReadyAt(resultIndex); }
+
+    operator T() const { return result(); }
+    QList<T> results() const { return d.results(); }
+
+    class const_iterator
+    {
+    public:
+        typedef std::bidirectional_iterator_tag iterator_category;
+        typedef qptrdiff difference_type;
+        typedef T value_type;
+        typedef const T *pointer;
+        typedef const T &reference;
+
+        inline const_iterator() {}
+        inline const_iterator(QFuture const * const _future, int _index) : future(_future), index(_index) {}
+        inline const_iterator(const const_iterator &o) : future(o.future), index(o.index)  {}
+        inline const_iterator &operator=(const const_iterator &o)
+        { future = o.future; index = o.index; return *this; }
+        inline const T &operator*() const { return future->d.resultReference(index); }
+        inline const T *operator->() const { return future->d.resultPointer(index); }
+
+        inline bool operator!=(const const_iterator &other) const
+        {
+            if (index == -1 && other.index == -1) // comparing end != end?
+                return false;
+            if (other.index == -1)
+                return (future->isRunning() || (index < future->resultCount()));
+            return (index != other.index);
+        }
+
+        inline bool operator==(const const_iterator &o) const { return !operator!=(o); }
+        inline const_iterator &operator++() { ++index; return *this; }
+        inline const_iterator operator++(int) { const_iterator r = *this; ++index; return r; }
+        inline const_iterator &operator--() { --index; return *this; }
+        inline const_iterator operator--(int) { const_iterator r = *this; --index; return r; }
+        inline const_iterator operator+(int j) const { return const_iterator(future, index + j); }
+        inline const_iterator operator-(int j) const { return const_iterator(future, index - j); }
+        inline const_iterator &operator+=(int j) { index += j; return *this; }
+        inline const_iterator &operator-=(int j) { index -= j; return *this; }
+    private:
+        QFuture const * future;
+        int index;
+    };
+    friend class const_iterator;
+    typedef const_iterator ConstIterator;
+
+    const_iterator begin() const { return  const_iterator(this, 0); }
+    const_iterator constBegin() const { return  const_iterator(this, 0); }
+    const_iterator end() const { return const_iterator(this, -1); }
+    const_iterator constEnd() const { return const_iterator(this, -1); }
+
+private:
+    friend class QFutureWatcher<T>;
+
+public: // Warning: the d pointer is not documented and is considered private.
+    mutable QFutureInterface<T> d;
+};
+
+template <typename T>
+inline QFuture<T> &QFuture<T>::operator=(const QFuture<T> &other)
+{
+    d = other.d;
+    return *this;
+}
+
+template <typename T>
+inline T QFuture<T>::result() const
+{
+    d.waitForResult(0);
+    return d.resultReference(0);
+}
+
+template <typename T>
+inline T QFuture<T>::resultAt(int index) const
+{
+    d.waitForResult(index);
+    return d.resultReference(index);
+}
+
+template <typename T>
+inline QFuture<T> QFutureInterface<T>::future()
+{
+    return QFuture<T>(this);
+}
+
+Q_DECLARE_SEQUENTIAL_ITERATOR(Future)
+
+template <>
+class QFuture<void>
+{
+public:
+    QFuture()
+        : d(QFutureInterface<void>::canceledResult())
+    { }
+    explicit QFuture(QFutureInterfaceBase *p) // internal
+        : d(*p)
+    { }
+    QFuture(const QFuture &other)
+        : d(other.d)
+    { }
+    ~QFuture()
+    { }
+
+    QFuture &operator=(const QFuture &other);
+    bool operator==(const QFuture &other) const { return (d == other.d); }
+    bool operator!=(const QFuture &other) const { return (d != other.d); }
+
+#if !defined(Q_CC_XLC)
+    template <typename T>
+    QFuture(const QFuture<T> &other)
+        : d(other.d)
+    { }
+
+    template <typename T>
+    QFuture<void> &operator=(const QFuture<T> &other)
+    {
+        d = other.d;
+        return *this;
+    }
+#endif
+
+    void cancel() { d.cancel(); }
+    bool isCanceled() const { return d.isCanceled(); }
+
+    void setPaused(bool paused) { d.setPaused(paused); }
+    bool isPaused() const { return d.isPaused(); }
+    void pause() { setPaused(true); }
+    void resume() { setPaused(false); }
+    void togglePaused() { d.togglePaused(); }
+
+    bool isStarted() const { return d.isStarted(); }
+    bool isFinished() const { return d.isFinished(); }
+    bool isRunning() const { return d.isRunning(); }
+
+    int resultCount() const { return d.resultCount(); }
+    int progressValue() const { return d.progressValue(); }
+    int progressMinimum() const { return d.progressMinimum(); }
+    int progressMaximum() const { return d.progressMaximum(); }
+    QString progressText() const { return d.progressText(); }
+    void waitForFinished() { d.waitForFinished(); }
+
+private:
+    friend class QFutureWatcher<void>;
+
+#ifdef QFUTURE_TEST
+public:
+#endif
+    mutable QFutureInterfaceBase d;
+};
+
+inline QFuture<void> &QFuture<void>::operator=(const QFuture<void> &other)
+{
+    d = other.d;
+    return *this;
+}
+
+inline QFuture<void> QFutureInterface<void>::future()
+{
+    return QFuture<void>(this);
+}
+
+template <typename T>
+QFuture<void> qToVoidFuture(const QFuture<T> &future)
+{
+    return QFuture<void>(future.d);
+}
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif // QFUTURE_H
diff --git a/src/concurrent/qfutureinterface.cpp b/src/concurrent/qfutureinterface.cpp
new file mode 100644
index 0000000..9a273a1
--- /dev/null
+++ b/src/concurrent/qfutureinterface.cpp
@@ -0,0 +1,565 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+// qfutureinterface.h included from qfuture.h
+#include "qfuture.h"
+
+#ifndef QT_NO_QFUTURE
+
+#include <QtCore/qatomic.h>
+#include <QtCore/qthread.h>
+#include <QtCore/qthreadpool.h>
+#include <private/qthreadpool_p.h>
+
+#include "qfutureinterface_p.h"
+
+QT_BEGIN_NAMESPACE
+
+enum {
+    MaxProgressEmitsPerSecond = 25
+};
+
+QFutureInterfaceBase::QFutureInterfaceBase(State initialState)
+    : d(new QFutureInterfaceBasePrivate(initialState))
+{ }
+
+QFutureInterfaceBase::QFutureInterfaceBase(const QFutureInterfaceBase &other)
+    : d(other.d)
+{
+    d->refCount.ref();
+}
+
+QFutureInterfaceBase::~QFutureInterfaceBase()
+{
+    if (!d->refCount.deref())
+        delete d;
+}
+
+void QFutureInterfaceBase::cancel()
+{
+    QMutexLocker locker(&d->m_mutex);
+    if (d->state & Canceled)
+        return;
+
+    d->state = State((d->state & ~Paused) | Canceled);
+    d->waitCondition.wakeAll();
+    d->pausedWaitCondition.wakeAll();
+    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Canceled));
+}
+
+void QFutureInterfaceBase::setPaused(bool paused)
+{
+    QMutexLocker locker(&d->m_mutex);
+    if (paused) {
+        d->state = State(d->state | Paused);
+        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Paused));
+    } else {
+        d->state = State(d->state & ~Paused);
+        d->pausedWaitCondition.wakeAll();
+        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Resumed));
+    }
+}
+
+void QFutureInterfaceBase::togglePaused()
+{
+    QMutexLocker locker(&d->m_mutex);
+    if (d->state & Paused) {
+        d->state = State(d->state & ~Paused);
+        d->pausedWaitCondition.wakeAll();
+        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Resumed));
+    } else {
+        d->state = State(d->state | Paused);
+        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Paused));
+    }
+}
+
+void QFutureInterfaceBase::setThrottled(bool enable)
+{
+    // bail out if we are not changing the state
+    if ((enable && (d->state & Throttled)) || (!enable && !(d->state & Throttled)))
+        return;
+
+    // lock and change the state
+    QMutexLocker lock(&d->m_mutex);
+    if (enable) {
+        d->state  = State(d->state | Throttled);
+    } else {
+        d->state  = State(d->state & ~Throttled);
+        if (!(d->state & Paused))
+            d->pausedWaitCondition.wakeAll();
+    }
+}
+
+
+bool QFutureInterfaceBase::isRunning() const
+{
+    return queryState(Running);
+}
+
+bool QFutureInterfaceBase::isStarted() const
+{
+    return queryState(Started);
+}
+
+bool QFutureInterfaceBase::isCanceled() const
+{
+    return queryState(Canceled);
+}
+
+bool QFutureInterfaceBase::isFinished() const
+{
+    return queryState(Finished);
+}
+
+bool QFutureInterfaceBase::isPaused() const
+{
+    return queryState(Paused);
+}
+
+bool QFutureInterfaceBase::isThrottled() const
+{
+    return queryState(Throttled);
+}
+
+bool QFutureInterfaceBase::isResultReadyAt(int index) const
+{
+    QMutexLocker lock(&d->m_mutex);
+    return d->internal_isResultReadyAt(index);
+}
+
+bool QFutureInterfaceBase::waitForNextResult()
+{
+    QMutexLocker lock(&d->m_mutex);
+    return d->internal_waitForNextResult();
+}
+
+void QFutureInterfaceBase::waitForResume()
+{
+    // return early if possible to avoid taking the mutex lock.
+    if ((d->state & Paused) == false || (d->state & Canceled))
+        return;
+
+    QMutexLocker lock(&d->m_mutex);
+    if ((d->state & Paused) == false || (d->state & Canceled))
+        return;
+
+    // decrease active thread count since this thread will wait.
+    QThreadPool::globalInstance()->releaseThread();
+
+    d->pausedWaitCondition.wait(&d->m_mutex);
+
+    QThreadPool::globalInstance()->reserveThread();
+}
+
+int QFutureInterfaceBase::progressValue() const
+{
+    return d->m_progressValue;
+}
+
+int QFutureInterfaceBase::progressMinimum() const
+{
+    return d->m_progressMinimum;
+}
+
+int QFutureInterfaceBase::progressMaximum() const
+{
+    return d->m_progressMaximum;
+}
+
+int QFutureInterfaceBase::resultCount() const
+{
+    QMutexLocker lock(&d->m_mutex);
+    return d->internal_resultCount();
+}
+
+QString QFutureInterfaceBase::progressText() const
+{
+    QMutexLocker locker(&d->m_mutex);
+    return d->m_progressText;
+}
+
+bool QFutureInterfaceBase::isProgressUpdateNeeded() const
+{
+    QMutexLocker locker(&d->m_mutex);
+    return !d->progressTime.isValid() || (d->progressTime.elapsed() > (1000 / MaxProgressEmitsPerSecond));
+}
+
+void QFutureInterfaceBase::reportStarted()
+{
+    QMutexLocker locker(&d->m_mutex);
+    if ((d->state & Started) || (d->state & Canceled) || (d->state & Finished))
+        return;
+
+    d->setState(State(Started | Running));
+    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Started));
+}
+
+void QFutureInterfaceBase::reportCanceled()
+{
+    cancel();
+}
+
+#ifndef QT_NO_EXCEPTIONS
+void QFutureInterfaceBase::reportException(const QtConcurrent::Exception &exception)
+{
+    QMutexLocker locker(&d->m_mutex);
+    if ((d->state & Canceled) || (d->state & Finished))
+        return;
+
+    d->m_exceptionStore.setException(exception);
+    d->state = State(d->state | Canceled);
+    d->waitCondition.wakeAll();
+    d->pausedWaitCondition.wakeAll();
+    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Canceled));
+}
+#endif
+
+void QFutureInterfaceBase::reportFinished()
+{
+    QMutexLocker locker(&d->m_mutex);
+    if (!(d->state & Finished)) {
+        d->state = State((d->state & ~Running) | Finished);
+        d->waitCondition.wakeAll();
+        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Finished));
+    }
+}
+
+void QFutureInterfaceBase::setExpectedResultCount(int resultCount)
+{
+    if (d->manualProgress == false)
+        setProgressRange(0, resultCount);
+    d->m_expectedResultCount = resultCount;
+}
+
+int QFutureInterfaceBase::expectedResultCount()
+{
+    return d->m_expectedResultCount;
+}
+
+bool QFutureInterfaceBase::queryState(State state) const
+{
+    return (d->state & state);
+}
+
+void QFutureInterfaceBase::waitForResult(int resultIndex)
+{
+    d->m_exceptionStore.throwPossibleException();
+
+    if (!(d->state & Running))
+        return;
+
+    // To avoid deadlocks and reduce the number of threads used, try to 
+    // run the runnable in the current thread.
+    QThreadPool::globalInstance()->d_func()->stealRunnable(d->runnable);
+
+    QMutexLocker lock(&d->m_mutex);
+
+    if (!(d->state & Running))
+        return;
+
+    const int waitIndex = (resultIndex == -1) ? INT_MAX : resultIndex;
+    while ((d->state & Running) && d->internal_isResultReadyAt(waitIndex) == false)
+        d->waitCondition.wait(&d->m_mutex);
+
+    d->m_exceptionStore.throwPossibleException();
+}
+
+void QFutureInterfaceBase::waitForFinished()
+{
+    if (d->state & Running) {
+        QThreadPool::globalInstance()->d_func()->stealRunnable(d->runnable);
+
+        QMutexLocker lock(&d->m_mutex);
+
+        while (d->state & Running)
+            d->waitCondition.wait(&d->m_mutex);
+    }
+
+    d->m_exceptionStore.throwPossibleException();
+}
+
+void QFutureInterfaceBase::reportResultsReady(int beginIndex, int endIndex)
+{
+    if ((d->state & Canceled) || (d->state & Finished) || beginIndex == endIndex)
+        return;
+
+    d->waitCondition.wakeAll();
+
+    if (d->manualProgress == false) {
+        if (d->internal_updateProgress(d->m_progressValue + endIndex - beginIndex) == false) {
+            d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::ResultsReady,
+                                               beginIndex,
+                                               endIndex));
+            return;
+        }
+
+        d->sendCallOuts(QFutureCallOutEvent(QFutureCallOutEvent::Progress,
+                                            d->m_progressValue,
+                                            d->m_progressText),
+                        QFutureCallOutEvent(QFutureCallOutEvent::ResultsReady,
+                                            beginIndex,
+                                            endIndex));
+        return;
+    }
+    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::ResultsReady, beginIndex, endIndex));
+}
+
+void QFutureInterfaceBase::setRunnable(QRunnable *runnable)
+{
+    d->runnable = runnable;
+}
+
+void QFutureInterfaceBase::setFilterMode(bool enable)
+{
+    QMutexLocker locker(&d->m_mutex);
+    resultStoreBase().setFilterMode(enable);
+}
+
+void QFutureInterfaceBase::setProgressRange(int minimum, int maximum)
+{
+    QMutexLocker locker(&d->m_mutex);
+    d->m_progressMinimum = minimum;
+    d->m_progressMaximum = maximum;
+    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::ProgressRange, minimum, maximum));
+}
+
+void QFutureInterfaceBase::setProgressValue(int progressValue)
+{
+    setProgressValueAndText(progressValue, QString());
+}
+
+void QFutureInterfaceBase::setProgressValueAndText(int progressValue,
+                                                   const QString &progressText)
+{
+    QMutexLocker locker(&d->m_mutex);
+    if (d->manualProgress == false)
+        d->manualProgress = true;
+    if (d->m_progressValue >= progressValue)
+        return;
+
+    if ((d->state & Canceled) || (d->state & Finished))
+        return;
+
+    if (d->internal_updateProgress(progressValue, progressText)) {
+        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Progress,
+                                           d->m_progressValue,
+                                           d->m_progressText));
+    }
+}
+
+QMutex *QFutureInterfaceBase::mutex() const
+{
+    return &d->m_mutex;
+}
+
+QtConcurrent::internal::ExceptionStore &QFutureInterfaceBase::exceptionStore()
+{
+    return d->m_exceptionStore;
+}
+
+QtConcurrent::ResultStoreBase &QFutureInterfaceBase::resultStoreBase()
+{
+    return d->m_results;
+}
+
+const QtConcurrent::ResultStoreBase &QFutureInterfaceBase::resultStoreBase() const
+{
+    return d->m_results;
+}
+
+QFutureInterfaceBase &QFutureInterfaceBase::operator=(const QFutureInterfaceBase &other)
+{
+    other.d->refCount.ref();
+    if (!d->refCount.deref())
+        delete d;
+    d = other.d;
+    return *this;
+}
+
+bool QFutureInterfaceBase::referenceCountIsOne() const
+{
+    return d->refCount.load() == 1;
+}
+
+QFutureInterfaceBasePrivate::QFutureInterfaceBasePrivate(QFutureInterfaceBase::State initialState)
+    : refCount(1), m_progressValue(0), m_progressMinimum(0), m_progressMaximum(0),
+      state(initialState), pendingResults(0),
+      manualProgress(false), m_expectedResultCount(0), runnable(0)
+{
+    progressTime.invalidate();
+}
+
+int QFutureInterfaceBasePrivate::internal_resultCount() const
+{
+    return m_results.count(); // ### subtract canceled results.
+}
+
+bool QFutureInterfaceBasePrivate::internal_isResultReadyAt(int index) const
+{
+    return (m_results.contains(index));
+}
+
+bool QFutureInterfaceBasePrivate::internal_waitForNextResult()
+{
+    if (m_results.hasNextResult())
+        return true;
+
+    while ((state & QFutureInterfaceBase::Running) && m_results.hasNextResult() == false)
+        waitCondition.wait(&m_mutex);
+
+    return (!(state & QFutureInterfaceBase::Canceled) && m_results.hasNextResult());
+}
+
+bool QFutureInterfaceBasePrivate::internal_updateProgress(int progress,
+                                                          const QString &progressText)
+{
+    if (m_progressValue >= progress)
+        return false;
+
+    m_progressValue = progress;
+    m_progressText = progressText;
+
+    if (progressTime.isValid() && m_progressValue != m_progressMaximum) // make sure the first and last steps are emitted.
+        if (progressTime.elapsed() < (1000 / MaxProgressEmitsPerSecond))
+            return false;
+
+    progressTime.start();
+    return true;
+}
+
+void QFutureInterfaceBasePrivate::internal_setThrottled(bool enable)
+{
+    // bail out if we are not changing the state
+    if ((enable && (state & QFutureInterfaceBase::Throttled))
+        || (!enable && !(state & QFutureInterfaceBase::Throttled)))
+        return;
+
+    // change the state
+    if (enable) {
+        state  = QFutureInterfaceBase::State(state | QFutureInterfaceBase::Throttled);
+    } else {
+        state  = QFutureInterfaceBase::State(state & ~QFutureInterfaceBase::Throttled);
+        if (!(state & QFutureInterfaceBase::Paused))
+            pausedWaitCondition.wakeAll();
+    }
+}
+
+void QFutureInterfaceBasePrivate::sendCallOut(const QFutureCallOutEvent &callOutEvent)
+{
+    if (outputConnections.isEmpty())
+        return;
+
+    for (int i = 0; i < outputConnections.count(); ++i)
+        outputConnections.at(i)->postCallOutEvent(callOutEvent);
+}
+
+void QFutureInterfaceBasePrivate::sendCallOuts(const QFutureCallOutEvent &callOutEvent1,
+                                     const QFutureCallOutEvent &callOutEvent2)
+{
+    if (outputConnections.isEmpty())
+        return;
+
+    for (int i = 0; i < outputConnections.count(); ++i) {
+        QFutureCallOutInterface *interface = outputConnections.at(i);
+        interface->postCallOutEvent(callOutEvent1);
+        interface->postCallOutEvent(callOutEvent2);
+    }
+}
+
+// This function connects an output interface (for example a QFutureWatcher)
+// to this future. While holding the lock we check the state and ready results
+// and add the appropriate callouts to the queue. In order to avoid deadlocks,
+// the actual callouts are made at the end while not holding the lock.
+void QFutureInterfaceBasePrivate::connectOutputInterface(QFutureCallOutInterface *interface)
+{
+    QMutexLocker locker(&m_mutex);
+
+    if (state & QFutureInterfaceBase::Started) {
+        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Started));
+        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::ProgressRange,
+                                                        m_progressMinimum,
+                                                        m_progressMaximum));
+        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Progress,
+                                                        m_progressValue,
+                                                        m_progressText));
+    }
+
+    QtConcurrent::ResultIteratorBase it = m_results.begin();
+    while (it != m_results.end()) {
+        const int begin = it.resultIndex();
+        const int end = begin + it.batchSize();
+        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::ResultsReady,
+                                                        begin,
+                                                        end));
+        it.batchedAdvance();
+    }
+
+    if (state & QFutureInterfaceBase::Paused)
+        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Paused));
+
+    if (state & QFutureInterfaceBase::Canceled)
+        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Canceled));
+
+    if (state & QFutureInterfaceBase::Finished)
+        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Finished));
+
+    outputConnections.append(interface);
+}
+
+void QFutureInterfaceBasePrivate::disconnectOutputInterface(QFutureCallOutInterface *interface)
+{
+    QMutexLocker lock(&m_mutex);
+    const int index = outputConnections.indexOf(interface);
+    if (index == -1)
+        return;
+    outputConnections.removeAt(index);
+
+    interface->callOutInterfaceDisconnected();
+}
+
+void QFutureInterfaceBasePrivate::setState(QFutureInterfaceBase::State newState)
+{
+    state = newState;
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_CONCURRENT
diff --git a/src/concurrent/qfutureinterface.h b/src/concurrent/qfutureinterface.h
new file mode 100644
index 0000000..f64623a
--- /dev/null
+++ b/src/concurrent/qfutureinterface.h
@@ -0,0 +1,312 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFUTUREINTERFACE_H
+#define QFUTUREINTERFACE_H
+
+#include <QtCore/qglobal.h>
+#include <QtCore/qrunnable.h>
+
+#ifndef QT_NO_QFUTURE
+
+#include <QtCore/qmutex.h>
+#include <QtConcurrent/qtconcurrentexception.h>
+#include <QtConcurrent/qtconcurrentresultstore.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+template <typename T> class QFuture;
+class QFutureInterfaceBasePrivate;
+class QFutureWatcherBase;
+class QFutureWatcherBasePrivate;
+
+class Q_CORE_EXPORT QFutureInterfaceBase
+{
+public:
+    enum State {
+        NoState   = 0x00,
+        Running   = 0x01,
+        Started   = 0x02,
+        Finished  = 0x04,
+        Canceled  = 0x08,
+        Paused    = 0x10,
+        Throttled = 0x20
+    };
+
+    QFutureInterfaceBase(State initialState = NoState);
+    QFutureInterfaceBase(const QFutureInterfaceBase &other);
+    virtual ~QFutureInterfaceBase();
+
+    // reporting functions available to the engine author:
+    void reportStarted();
+    void reportFinished();
+    void reportCanceled();
+#ifndef QT_NO_EXCEPTIONS
+    void reportException(const QtConcurrent::Exception &e);
+#endif
+    void reportResultsReady(int beginIndex, int endIndex);
+
+    void setRunnable(QRunnable *runnable);
+    void setFilterMode(bool enable);
+    void setProgressRange(int minimum, int maximum);
+    int progressMinimum() const;
+    int progressMaximum() const;
+    bool isProgressUpdateNeeded() const;
+    void setProgressValue(int progressValue);
+    int progressValue() const;
+    void setProgressValueAndText(int progressValue, const QString &progressText);
+    QString progressText() const;
+
+    void setExpectedResultCount(int resultCount);
+    int expectedResultCount();
+    int resultCount() const;
+
+    bool queryState(State state) const;
+    bool isRunning() const;
+    bool isStarted() const;
+    bool isCanceled() const;
+    bool isFinished() const;
+    bool isPaused() const;
+    bool isThrottled() const;
+    bool isResultReadyAt(int index) const;
+
+    void cancel();
+    void setPaused(bool paused);
+    void togglePaused();
+    void setThrottled(bool enable);
+
+    void waitForFinished();
+    bool waitForNextResult();
+    void waitForResult(int resultIndex);
+    void waitForResume();
+
+    QMutex *mutex() const;
+    QtConcurrent::internal::ExceptionStore &exceptionStore();
+    QtConcurrent::ResultStoreBase &resultStoreBase();
+    const QtConcurrent::ResultStoreBase &resultStoreBase() const;
+
+    inline bool operator==(const QFutureInterfaceBase &other) const { return d == other.d; }
+    inline bool operator!=(const QFutureInterfaceBase &other) const { return d != other.d; }
+    QFutureInterfaceBase &operator=(const QFutureInterfaceBase &other);
+
+protected:
+    bool referenceCountIsOne() const;
+public:
+
+#ifndef QFUTURE_TEST
+private:
+#endif
+    QFutureInterfaceBasePrivate *d;
+
+private:
+    friend class QFutureWatcherBase;
+    friend class QFutureWatcherBasePrivate;
+};
+
+template <typename T>
+class QFutureInterface : public QFutureInterfaceBase
+{
+public:
+    QFutureInterface(State initialState = NoState)
+        : QFutureInterfaceBase(initialState)
+    { }
+    QFutureInterface(const QFutureInterface &other)
+        : QFutureInterfaceBase(other)
+    { }
+    ~QFutureInterface()
+    {
+        if (referenceCountIsOne())
+            resultStore().clear();
+    }
+
+    static QFutureInterface canceledResult()
+    { return QFutureInterface(State(Started | Finished | Canceled)); }
+
+    QFutureInterface &operator=(const QFutureInterface &other)
+    {
+        if (referenceCountIsOne())
+            resultStore().clear();
+        QFutureInterfaceBase::operator=(other);
+        return *this;
+    }
+
+    inline QFuture<T> future(); // implemented in qfuture.h
+
+    inline void reportResult(const T *result, int index = -1);
+    inline void reportResult(const T &result, int index = -1);
+    inline void reportResults(const QVector<T> &results, int beginIndex = -1, int count = -1);
+    inline void reportFinished(const T *result = 0);
+
+    inline const T &resultReference(int index) const;
+    inline const T *resultPointer(int index) const;
+    inline QList<T> results();
+private:
+    QtConcurrent::ResultStore<T> &resultStore()
+    { return static_cast<QtConcurrent::ResultStore<T> &>(resultStoreBase()); }
+    const QtConcurrent::ResultStore<T> &resultStore() const
+    { return static_cast<const QtConcurrent::ResultStore<T> &>(resultStoreBase()); }
+};
+
+template <typename T>
+inline void QFutureInterface<T>::reportResult(const T *result, int index)
+{
+    QMutexLocker locker(mutex());
+    if (this->queryState(Canceled) || this->queryState(Finished)) {
+        return;
+    }
+
+    QtConcurrent::ResultStore<T> &store = resultStore();
+
+
+    if (store.filterMode()) {
+        const int resultCountBefore = store.count();
+        store.addResult(index, result);
+        this->reportResultsReady(resultCountBefore, resultCountBefore + store.count());
+    } else {
+        const int insertIndex = store.addResult(index, result);
+        this->reportResultsReady(insertIndex, insertIndex + 1);
+    }
+}
+
+template <typename T>
+inline void QFutureInterface<T>::reportResult(const T &result, int index)
+{
+    reportResult(&result, index);
+}
+
+template <typename T>
+inline void QFutureInterface<T>::reportResults(const QVector<T> &_results, int beginIndex, int count)
+{
+    QMutexLocker locker(mutex());
+    if (this->queryState(Canceled) || this->queryState(Finished)) {
+        return;
+    }
+
+    QtConcurrent::ResultStore<T> &store = resultStore();
+
+    if (store.filterMode()) {
+        const int resultCountBefore = store.count();
+        store.addResults(beginIndex, &_results, count);
+        this->reportResultsReady(resultCountBefore, store.count());
+    } else {
+        const int insertIndex = store.addResults(beginIndex, &_results, count);
+        this->reportResultsReady(insertIndex, insertIndex + _results.count());    
+    }
+}
+
+template <typename T>
+inline void QFutureInterface<T>::reportFinished(const T *result)
+{
+    if (result)
+        reportResult(result);
+    QFutureInterfaceBase::reportFinished();
+}
+
+template <typename T>
+inline const T &QFutureInterface<T>::resultReference(int index) const
+{
+    QMutexLocker lock(mutex());
+    return resultStore().resultAt(index).value();
+}
+
+template <typename T>
+inline const T *QFutureInterface<T>::resultPointer(int index) const
+{
+    QMutexLocker lock(mutex());
+    return resultStore().resultAt(index).pointer();
+}
+
+template <typename T>
+inline QList<T> QFutureInterface<T>::results()
+{
+    if (this->isCanceled()) {
+        exceptionStore().throwPossibleException();
+        return QList<T>();
+    }
+    QFutureInterfaceBase::waitForResult(-1);
+
+    QList<T> res;
+    QMutexLocker lock(mutex());
+
+    QtConcurrent::ResultIterator<T> it = resultStore().begin();
+    while (it != resultStore().end()) {
+        res.append(it.value());
+        ++it;
+    }
+
+    return res;
+}
+
+template <>
+class QFutureInterface<void> : public QFutureInterfaceBase
+{
+public:
+    QFutureInterface<void>(State initialState = NoState)
+        : QFutureInterfaceBase(initialState)
+    { }
+    QFutureInterface<void>(const QFutureInterface<void> &other)
+        : QFutureInterfaceBase(other)
+    { }
+
+    static QFutureInterface<void> canceledResult()
+    { return QFutureInterface(State(Started | Finished | Canceled)); }
+
+    QFutureInterface<void> &operator=(const QFutureInterface<void> &other)
+    {
+        QFutureInterfaceBase::operator=(other);
+        return *this;
+    }
+
+    inline QFuture<void> future(); // implemented in qfuture.h
+
+    void reportResult(const void *, int) { }
+    void reportResults(const QVector<void> &, int) { }
+    void reportFinished(void * = 0) { QFutureInterfaceBase::reportFinished(); }
+};
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif // QFUTUREINTERFACE_H
diff --git a/src/concurrent/qfutureinterface_p.h b/src/concurrent/qfutureinterface_p.h
new file mode 100644
index 0000000..ea52621
--- /dev/null
+++ b/src/concurrent/qfutureinterface_p.h
@@ -0,0 +1,167 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFUTUREINTERFACE_P_H
+#define QFUTUREINTERFACE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qelapsedtimer.h>
+#include <QtCore/qcoreevent.h>
+#include <QtCore/qlist.h>
+#include <QtCore/qwaitcondition.h>
+#include <QtCore/qrunnable.h>
+
+QT_BEGIN_NAMESPACE
+
+class QFutureCallOutEvent : public QEvent
+{
+public:
+    enum CallOutType {
+        Started,
+        Finished,
+        Canceled,
+        Paused,
+        Resumed,
+        Progress,
+        ProgressRange,
+        ResultsReady
+    };
+
+    QFutureCallOutEvent()
+        : QEvent(QEvent::FutureCallOut), callOutType(CallOutType(0)), index1(-1), index2(-1)
+    { }
+    QFutureCallOutEvent(CallOutType callOutType, int index1 = -1)
+        : QEvent(QEvent::FutureCallOut), callOutType(callOutType), index1(index1), index2(-1)
+    { }
+    QFutureCallOutEvent(CallOutType callOutType, int index1, int index2)
+        : QEvent(QEvent::FutureCallOut), callOutType(callOutType), index1(index1), index2(index2)
+    { }
+
+    QFutureCallOutEvent(CallOutType callOutType, int index1, const QString &text)
+        : QEvent(QEvent::FutureCallOut),
+          callOutType(callOutType),
+          index1(index1),
+          index2(-1),
+          text(text)
+    { }
+
+    CallOutType callOutType;
+    int index1;
+    int index2;
+    QString text;
+
+    QFutureCallOutEvent *clone() const
+    {
+        return new QFutureCallOutEvent(callOutType, index1, index2, text);
+    }
+
+private:
+    QFutureCallOutEvent(CallOutType callOutType,
+                        int index1,
+                        int index2,
+                        const QString &text)
+        : QEvent(QEvent::FutureCallOut),
+          callOutType(callOutType),
+          index1(index1),
+          index2(index2),
+          text(text)
+    { }
+};
+
+class QFutureCallOutInterface
+{
+public:
+    virtual ~QFutureCallOutInterface() {}
+    virtual void postCallOutEvent(const QFutureCallOutEvent &) = 0;
+    virtual void callOutInterfaceDisconnected() = 0;
+};
+
+class QFutureInterfaceBasePrivate
+{
+public:
+    QFutureInterfaceBasePrivate(QFutureInterfaceBase::State initialState);
+
+    QAtomicInt refCount;
+    mutable QMutex m_mutex;
+    QWaitCondition waitCondition;
+    QList<QFutureCallOutInterface *> outputConnections;
+    int m_progressValue;
+    int m_progressMinimum;
+    int m_progressMaximum;
+    QFutureInterfaceBase::State state;
+    QElapsedTimer progressTime;
+    QWaitCondition pausedWaitCondition;
+    int pendingResults;
+    QtConcurrent::ResultStoreBase m_results;
+    bool manualProgress;
+    int m_expectedResultCount;
+    QtConcurrent::internal::ExceptionStore m_exceptionStore;
+    QString m_progressText;
+    QRunnable *runnable;
+
+    // Internal functions that does not change the mutex state.
+    // The mutex must be locked when calling these.
+    int internal_resultCount() const;
+    bool internal_isResultReadyAt(int index) const;
+    bool internal_waitForNextResult();
+    bool internal_updateProgress(int progress, const QString &progressText = QString());
+    void internal_setThrottled(bool enable);
+    void sendCallOut(const QFutureCallOutEvent &callOut);
+    void sendCallOuts(const QFutureCallOutEvent &callOut1, const QFutureCallOutEvent &callOut2);
+    void connectOutputInterface(QFutureCallOutInterface *iface);
+    void disconnectOutputInterface(QFutureCallOutInterface *iface);
+
+    void setState(QFutureInterfaceBase::State state);
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/concurrent/qfuturesynchronizer.cpp b/src/concurrent/qfuturesynchronizer.cpp
new file mode 100644
index 0000000..34b00da
--- /dev/null
+++ b/src/concurrent/qfuturesynchronizer.cpp
@@ -0,0 +1,156 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*! \class QFutureSynchronizer
+    \since 4.4
+
+    \brief The QFutureSynchronizer class is a convenience class that simplifies
+    QFuture synchronization.
+
+    \ingroup thread
+
+    QFutureSynchronizer is a template class that simplifies synchronization of
+    one or more QFuture objects. Futures are added using the addFuture() or
+    setFuture() functions. The futures() function returns a list of futures.
+    Use clearFutures() to remove all futures from the QFutureSynchronizer.
+    
+    The waitForFinished() function waits for all futures to finish.
+    The destructor of QFutureSynchronizer calls waitForFinished(), providing
+    an easy way to ensure that all futures have finished before returning from
+    a function:
+    
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuturesynchronizer.cpp 0
+    
+    The behavior of waitForFinished() can be changed using the
+    setCancelOnWait() function. Calling setCancelOnWait(true) will cause
+    waitForFinished() to cancel all futures before waiting for them to finish.
+    You can query the status of the cancel-on-wait feature using the
+    cancelOnWait() function.
+    
+    \sa QFuture, QFutureWatcher, {Concurrent Programming}{Qt Concurrent}
+*/
+
+/*!
+    \fn QFutureSynchronizer::QFutureSynchronizer()
+
+    Constructs a QFutureSynchronizer.
+*/
+
+/*!
+    \fn QFutureSynchronizer::QFutureSynchronizer(const QFuture<T> &future)
+
+    Constructs a QFutureSynchronizer and begins watching \a future by calling
+    addFuture().
+    
+    \sa addFuture()
+*/
+
+/*!
+    \fn QFutureSynchronizer::~QFutureSynchronizer()
+    
+    Calls waitForFinished() function to ensure that all futures have finished
+    before destroying this QFutureSynchronizer.
+    
+    \sa waitForFinished()
+*/
+
+/*!
+    \fn void QFutureSynchronizer::setFuture(const QFuture<T> &future)
+    
+    Sets \a future to be the only future managed by this QFutureSynchronizer.
+    This is a convenience function that calls waitForFinished(),
+    then clearFutures(), and finally passes \a future to addFuture().
+    
+    \sa addFuture(), waitForFinished(), clearFutures()
+*/
+
+/*!
+    \fn void QFutureSynchronizer::addFuture(const QFuture<T> &future)
+
+    Adds \a future to the list of managed futures.
+    
+    \sa futures()
+*/
+
+/*!
+    \fn void QFutureSynchronizer::waitForFinished()
+
+    Waits for all futures to finish. If cancelOnWait() returns true, each
+    future is canceled before waiting for them to finish.
+    
+    \sa cancelOnWait(), setCancelOnWait()
+*/
+
+/*!
+    \fn void QFutureSynchronizer::clearFutures()
+
+    Removes all managed futures from this QFutureSynchronizer.
+    
+    \sa addFuture(), setFuture()   
+*/
+
+/*!
+    \fn QList<QFuture<T> > QFutureSynchronizer::futures() const
+
+    Returns a list of all managed futures.
+    
+    \sa addFuture(), setFuture()
+*/
+
+/*!
+    \fn void QFutureSynchronizer::setCancelOnWait(bool enabled)
+    
+    Enables or disables the cancel-on-wait feature based on the \a enabled
+    argument. If \a enabled is true, the waitForFinished() function will cancel
+    all futures before waiting for them to finish.
+
+    \sa waitForFinished()
+*/
+
+/*!
+    \fn bool QFutureSynchronizer::cancelOnWait() const
+
+    Returns true if the cancel-on-wait feature is enabled; otherwise returns
+    false. If cancel-on-wait is enabled, the waitForFinished() function will
+    cancel all futures before waiting for them to finish.
+
+    \sa waitForFinished()
+*/
diff --git a/src/concurrent/qfuturesynchronizer.h b/src/concurrent/qfuturesynchronizer.h
new file mode 100644
index 0000000..8b7e710
--- /dev/null
+++ b/src/concurrent/qfuturesynchronizer.h
@@ -0,0 +1,120 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFUTRUESYNCHRONIZER_H
+#define QFUTRUESYNCHRONIZER_H
+
+#include <QtConcurrent/qfuture.h>
+
+#ifndef QT_NO_CONCURRENT
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+template <typename T>
+class QFutureSynchronizer
+{
+    Q_DISABLE_COPY(QFutureSynchronizer)
+
+public:
+    QFutureSynchronizer() : m_cancelOnWait(false) { }
+    explicit QFutureSynchronizer(const QFuture<T> &future)
+        : m_cancelOnWait(false)
+    { addFuture(future); }
+    ~QFutureSynchronizer()  { waitForFinished(); }
+
+    void setFuture(const QFuture<T> &future)
+    {
+        waitForFinished();
+        m_futures.clear();
+        addFuture(future);
+    }
+
+    void addFuture(const QFuture<T> &future)
+    {
+        m_futures.append(future);
+    }
+
+    void waitForFinished()
+    {
+        if (m_cancelOnWait) {
+            for (int i = 0; i < m_futures.count(); ++i) {
+                 m_futures[i].cancel();
+            }
+        }
+        
+        for (int i = 0; i < m_futures.count(); ++i) {
+             m_futures[i].waitForFinished();
+         }
+    }
+
+    void clearFutures()
+    {
+        m_futures.clear();
+    }
+
+    QList<QFuture<T> > futures() const
+    {
+        return m_futures;
+    }
+
+    void setCancelOnWait(bool enabled)
+    {
+        m_cancelOnWait = enabled;
+    }
+
+    bool cancelOnWait() const
+    {
+        return m_cancelOnWait;
+    }
+
+protected:
+    QList<QFuture<T> > m_futures;
+    bool m_cancelOnWait;
+};
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif // QFUTRUESYNCHRONIZER_H
diff --git a/src/concurrent/qfuturewatcher.cpp b/src/concurrent/qfuturewatcher.cpp
new file mode 100644
index 0000000..d3a1122
--- /dev/null
+++ b/src/concurrent/qfuturewatcher.cpp
@@ -0,0 +1,592 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfuturewatcher.h"
+
+#ifndef QT_NO_QFUTURE
+
+#include <QtCore/qcoreevent.h>
+#include <QtCore/qcoreapplication.h>
+#include <QtCore/qthread.h>
+
+#include "qfuturewatcher_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*! \class QFutureWatcher
+    \reentrant
+    \since 4.4
+
+    \ingroup thread
+
+    \brief The QFutureWatcher class allows monitoring a QFuture using signals
+    and slots.
+
+    QFutureWatcher provides information and notifications about a QFuture. Use
+    the setFuture() function to start watching a particular QFuture. The
+    future() function returns the future set with setFuture().
+
+    For convenience, several of QFuture's functions are also available in
+    QFutureWatcher: progressValue(), progressMinimum(), progressMaximum(),
+    progressText(), isStarted(), isFinished(), isRunning(), isCanceled(),
+    isPaused(), waitForFinished(), result(), and resultAt(). The cancel(),
+    setPaused(), pause(), resume(), and togglePaused() functions are slots in
+    QFutureWatcher.
+
+    Status changes are reported via the started(), finished(), canceled(),
+    paused(), resumed(), resultReadyAt(), and resultsReadyAt() signals.
+    Progress information is provided from the progressRangeChanged(),
+    void progressValueChanged(), and progressTextChanged() signals.
+
+    Throttling control is provided by the setPendingResultsLimit() function.
+    When the number of pending resultReadyAt() or resultsReadyAt() signals
+    exceeds the limit, the computation represented by the future will be
+    throttled automatically. The computation will resume once the number of
+    pending signals drops below the limit.
+
+    Example: Starting a computation and getting a slot callback when it's
+    finished:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuturewatcher.cpp 0
+
+    Be aware that not all asynchronous computations can be canceled or paused.
+    For example, the future returned by QtConcurrent::run() cannot be
+    canceled; but the future returned by QtConcurrent::mappedReduced() can.
+
+    QFutureWatcher<void> is specialized to not contain any of the result
+    fetching functions. Any QFuture<T> can be watched by a
+    QFutureWatcher<void> as well. This is useful if only status or progress
+    information is needed; not the actual result data.
+
+    \sa QFuture, {Concurrent Programming}{Qt Concurrent}
+*/
+
+/*! \fn QFutureWatcher::QFutureWatcher(QObject *parent)
+
+    Constructs a new QFutureWatcher with the given \a parent.
+*/
+QFutureWatcherBase::QFutureWatcherBase(QObject *parent)
+    :QObject(*new QFutureWatcherBasePrivate, parent)
+{ }
+
+/*! \fn QFutureWatcher::~QFutureWatcher()
+
+    Destroys the QFutureWatcher.
+*/
+
+/*! \fn void QFutureWatcher::cancel()
+
+    Cancels the asynchronous computation represented by the future(). Note that
+    the cancelation is asynchronous. Use waitForFinished() after calling
+    cancel() when you need synchronous cancelation.
+
+    Currently available results may still be accessed on a canceled QFuture,
+    but new results will \e not become available after calling this function.
+    Also, this QFutureWatcher will not deliver progress and result ready
+    signals once canceled. This includes the progressValueChanged(),
+    progressRangeChanged(), progressTextChanged(), resultReadyAt(), and
+    resultsReadyAt() signals.
+
+    Be aware that not all asynchronous computations can be canceled. For
+    example, the QFuture returned by QtConcurrent::run() cannot be canceled;
+    but the QFuture returned by QtConcurrent::mappedReduced() can.
+*/
+void QFutureWatcherBase::cancel()
+{
+    futureInterface().cancel();
+}
+
+/*! \fn void QFutureWatcher::setPaused(bool paused)
+
+    If \a paused is true, this function pauses the asynchronous computation
+    represented by the future(). If the computation is already paused, this
+    function does nothing. This QFutureWatcher will stop delivering progress
+    and result ready signals while the future is paused. Signal delivery will
+    continue once the computation is resumed.
+
+    If \a paused is false, this function resumes the asynchronous computation.
+    If the computation was not previously paused, this function does nothing.
+
+    Be aware that not all computations can be paused. For example, the
+    QFuture returned by QtConcurrent::run() cannot be paused; but the QFuture
+    returned by QtConcurrent::mappedReduced() can.
+
+    \sa pause(), resume(), togglePaused()
+*/
+void QFutureWatcherBase::setPaused(bool paused)
+{
+    futureInterface().setPaused(paused);
+}
+
+/*! \fn void QFutureWatcher::pause()
+
+    Pauses the asynchronous computation represented by the future(). This is a
+    convenience method that simply calls setPaused(true).
+
+    \sa resume()
+*/
+void QFutureWatcherBase::pause()
+{
+    futureInterface().setPaused(true);
+}
+
+/*! \fn void QFutureWatcher::resume()
+
+    Resumes the asynchronous computation represented by the future(). This is
+    a convenience method that simply calls setPaused(false).
+
+    \sa pause()
+*/
+void QFutureWatcherBase::resume()
+{
+    futureInterface().setPaused(false);
+}
+
+/*! \fn void QFutureWatcher::togglePaused()
+
+    Toggles the paused state of the asynchronous computation. In other words,
+    if the computation is currently paused, calling this function resumes it;
+    if the computation is running, it becomes paused. This is a convenience
+    method for calling setPaused(!isPaused()).
+
+    \sa setPaused(), pause(), resume()
+*/
+void QFutureWatcherBase::togglePaused()
+{
+    futureInterface().togglePaused();
+}
+
+/*! \fn int QFutureWatcher::progressValue() const
+
+    Returns the current progress value, which is between the progressMinimum()
+    and progressMaximum().
+
+    \sa progressMinimum(), progressMaximum()
+*/
+int QFutureWatcherBase::progressValue() const
+{
+    return futureInterface().progressValue();
+}
+
+/*! \fn int QFutureWatcher::progressMinimum() const
+
+    Returns the minimum progressValue().
+
+    \sa progressValue(), progressMaximum()
+*/
+int QFutureWatcherBase::progressMinimum() const
+{
+    return futureInterface().progressMinimum();
+}
+
+/*! \fn int QFutureWatcher::progressMaximum() const
+
+    Returns the maximum progressValue().
+
+    \sa progressValue(), progressMinimum()
+*/
+int QFutureWatcherBase::progressMaximum() const
+{
+    return futureInterface().progressMaximum();
+}
+
+/*! \fn QString QFutureWatcher::progressText() const
+
+    Returns the (optional) textual representation of the progress as reported
+    by the asynchronous computation.
+
+    Be aware that not all computations provide a textual representation of the
+    progress, and as such, this function may return an empty string.
+*/
+QString QFutureWatcherBase::progressText() const
+{
+    return futureInterface().progressText();
+}
+
+/*! \fn bool QFutureWatcher::isStarted() const
+
+    Returns true if the asynchronous computation represented by the future()
+    has been started; otherwise returns false.
+*/
+bool QFutureWatcherBase::isStarted() const
+{
+    return futureInterface().queryState(QFutureInterfaceBase::Started);
+}
+
+/*! \fn bool QFutureWatcher::isFinished() const
+
+    Returns true if the asynchronous computation represented by the future()
+    has finished; otherwise returns false.
+*/
+bool QFutureWatcherBase::isFinished() const
+{
+    Q_D(const QFutureWatcherBase);
+    return d->finished;
+}
+
+/*! \fn bool QFutureWatcher::isRunning() const
+
+    Returns true if the asynchronous computation represented by the future()
+    is currently running; otherwise returns false.
+*/
+bool QFutureWatcherBase::isRunning() const
+{
+    return futureInterface().queryState(QFutureInterfaceBase::Running);
+}
+
+/*! \fn bool QFutureWatcher::isCanceled() const
+
+    Returns true if the asynchronous computation has been canceled with the
+    cancel() function; otherwise returns false.
+
+    Be aware that the computation may still be running even though this
+    function returns true. See cancel() for more details.
+*/
+bool QFutureWatcherBase::isCanceled() const
+{
+    return futureInterface().queryState(QFutureInterfaceBase::Canceled);
+}
+
+/*! \fn bool QFutureWatcher::isPaused() const
+
+    Returns true if the asynchronous computation has been paused with the
+    pause() function; otherwise returns false.
+
+    Be aware that the computation may still be running even though this
+    function returns true. See setPaused() for more details.
+
+    \sa setPaused(), togglePaused()
+*/
+bool QFutureWatcherBase::isPaused() const
+{
+    return futureInterface().queryState(QFutureInterfaceBase::Paused);
+}
+
+/*! \fn void QFutureWatcher::waitForFinished()
+
+    Waits for the asynchronous computation to finish (including cancel()ed
+    computations).
+*/
+void QFutureWatcherBase::waitForFinished()
+{
+    futureInterface().waitForFinished();
+}
+
+/*! \fn void QFutureWatcher::setPendingResultsLimit(int limit)
+
+    The setPendingResultsLimit() provides throttling control. When the number
+    of pending resultReadyAt() or resultsReadyAt() signals exceeds the
+    \a limit, the computation represented by the future will be throttled
+    automatically. The computation will resume once the number of pending
+    signals drops below the \a limit.
+*/
+
+bool QFutureWatcherBase::event(QEvent *event)
+{
+    Q_D(QFutureWatcherBase);
+    if (event->type() == QEvent::FutureCallOut) {
+        QFutureCallOutEvent *callOutEvent = static_cast<QFutureCallOutEvent *>(event);
+
+        if (futureInterface().isPaused()) {
+            d->pendingCallOutEvents.append(callOutEvent->clone());
+            return true;
+        }
+
+        if (callOutEvent->callOutType == QFutureCallOutEvent::Resumed
+            && !d->pendingCallOutEvents.isEmpty()) {
+            // send the resume
+            d->sendCallOutEvent(callOutEvent);
+
+            // next send all pending call outs
+            for (int i = 0; i < d->pendingCallOutEvents.count(); ++i)
+                d->sendCallOutEvent(d->pendingCallOutEvents.at(i));
+            qDeleteAll(d->pendingCallOutEvents);
+            d->pendingCallOutEvents.clear();
+        } else {
+            d->sendCallOutEvent(callOutEvent);
+        }
+        return true;
+    }
+    return QObject::event(event);
+}
+
+void QFutureWatcherBase::setPendingResultsLimit(int limit)
+{
+    Q_D(QFutureWatcherBase);
+    d->maximumPendingResultsReady = limit;
+}
+
+void QFutureWatcherBase::connectNotify(const char * signal)
+{
+    Q_D(QFutureWatcherBase);
+    if (qstrcmp(signal, SIGNAL(resultReadyAt(int))) == 0)
+        d->resultAtConnected.ref();
+#ifndef QT_NO_DEBUG
+    if (qstrcmp(signal, SIGNAL(finished())) == 0) {
+        if (futureInterface().isRunning()) {
+            //connections should be established before calling stFuture to avoid race.
+            // (The future could finish before the connection is made.)
+            qWarning("QFutureWatcher::connect: connecting after calling setFuture() is likely to produce race");
+        }
+    }
+#endif
+}
+
+void QFutureWatcherBase::disconnectNotify(const char * signal)
+{
+    Q_D(QFutureWatcherBase);
+    if (qstrcmp(signal, SIGNAL(resultReadyAt(int))) == 0)
+        d->resultAtConnected.deref();
+}
+
+/*!
+    \internal
+*/
+QFutureWatcherBasePrivate::QFutureWatcherBasePrivate()
+    : maximumPendingResultsReady(QThread::idealThreadCount() * 2),
+      resultAtConnected(0)
+{ }
+
+/*!
+    \internal
+*/
+void QFutureWatcherBase::connectOutputInterface()
+{
+    futureInterface().d->connectOutputInterface(d_func());
+}
+
+/*!
+    \internal
+*/
+void QFutureWatcherBase::disconnectOutputInterface(bool pendingAssignment)
+{
+    if (pendingAssignment) {
+        Q_D(QFutureWatcherBase);
+        d->pendingResultsReady.store(0);
+        qDeleteAll(d->pendingCallOutEvents);
+        d->pendingCallOutEvents.clear();
+        d->finished = false;
+    }
+
+    futureInterface().d->disconnectOutputInterface(d_func());
+}
+
+void QFutureWatcherBasePrivate::postCallOutEvent(const QFutureCallOutEvent &callOutEvent)
+{
+    Q_Q(QFutureWatcherBase);
+
+    if (callOutEvent.callOutType == QFutureCallOutEvent::ResultsReady) {
+        if (pendingResultsReady.fetchAndAddRelaxed(1) >= maximumPendingResultsReady)
+            q->futureInterface().d->internal_setThrottled(true);
+    }
+
+    QCoreApplication::postEvent(q, callOutEvent.clone());
+}
+
+void QFutureWatcherBasePrivate::callOutInterfaceDisconnected()
+{
+    QCoreApplication::removePostedEvents(q_func(), QEvent::FutureCallOut);
+}
+
+void QFutureWatcherBasePrivate::sendCallOutEvent(QFutureCallOutEvent *event)
+{
+    Q_Q(QFutureWatcherBase);
+
+    switch (event->callOutType) {
+        case QFutureCallOutEvent::Started:
+            emit q->started();
+        break;
+        case QFutureCallOutEvent::Finished:
+            finished = true;
+            emit q->finished();
+        break;
+        case QFutureCallOutEvent::Canceled:
+            pendingResultsReady.store(0);
+            emit q->canceled();
+        break;
+        case QFutureCallOutEvent::Paused:
+            if (q->futureInterface().isCanceled())
+                break;
+            emit q->paused();
+        break;
+        case QFutureCallOutEvent::Resumed:
+            if (q->futureInterface().isCanceled())
+                break;
+            emit q->resumed();
+        break;
+        case QFutureCallOutEvent::ResultsReady: {
+            if (q->futureInterface().isCanceled())
+                break;
+
+            if (pendingResultsReady.fetchAndAddRelaxed(-1) <= maximumPendingResultsReady)
+                q->futureInterface().setThrottled(false);
+
+            const int beginIndex = event->index1;
+            const int endIndex = event->index2;
+
+            emit q->resultsReadyAt(beginIndex, endIndex);
+
+            if (resultAtConnected.load() <= 0)
+                break;
+
+            for (int i = beginIndex; i < endIndex; ++i)
+                emit q->resultReadyAt(i);
+
+        } break;
+        case QFutureCallOutEvent::Progress:
+            if (q->futureInterface().isCanceled())
+                break;
+
+            emit q->progressValueChanged(event->index1);
+            if (!event->text.isNull()) // ###
+                q->progressTextChanged(event->text);
+        break;
+        case QFutureCallOutEvent::ProgressRange:
+            emit q->progressRangeChanged(event->index1, event->index2);
+        break;
+        default: break;
+    }
+}
+
+
+/*! \fn const T &QFutureWatcher::result() const
+
+    Returns the first result in the future(). If the result is not immediately
+    available, this function will block and wait for the result to become
+    available. This is a convenience method for calling resultAt(0).
+
+    \sa resultAt()
+*/
+
+/*! \fn const T &QFutureWatcher::resultAt(int index) const
+
+    Returns the result at \a index in the future(). If the result is not
+    immediately available, this function will block and wait for the result to
+    become available.
+
+    \sa result()
+*/
+
+/*! \fn void QFutureWatcher::setFuture(const QFuture<T> &future)
+
+    Starts watching the given \a future.
+
+    One of the signals might be emitted for the current state of the
+    \a future. For example, if the future is already stopped, the
+    finished signal will be emitted.
+
+    To avoid a race condition, it is important to call this function
+    \e after doing the connections.
+*/
+
+/*! \fn QFuture<T> QFutureWatcher::future() const
+
+    Returns the watched future.
+*/
+
+/*! \fn void QFutureWatcher::started()
+
+    This signal is emitted when this QFutureWatcher starts watching the future
+    set with setFuture().
+*/
+
+/*!
+    \fn void QFutureWatcher::finished()
+    This signal is emitted when the watched future finishes.
+*/
+
+/*!
+    \fn void QFutureWatcher::canceled()
+    This signal is emitted if the watched future is canceled.
+*/
+
+/*! \fn void QFutureWatcher::paused()
+    This signal is emitted when the watched future is paused.
+*/
+
+/*! \fn void QFutureWatcher::resumed()
+    This signal is emitted when the watched future is resumed.
+*/
+
+/*!
+    \fn void QFutureWatcher::progressRangeChanged(int minimum, int maximum)
+
+    The progress range for the watched future has changed to \a minimum and
+    \a maximum
+*/
+
+/*!
+    \fn void QFutureWatcher::progressValueChanged(int progressValue)
+
+    This signal is emitted when the watched future reports progress,
+    \a progressValue gives the current progress. In order to avoid overloading
+    the GUI event loop, QFutureWatcher limits the progress signal emission
+    rate. This means that listeners connected to this slot might not get all
+    progress reports the future makes. The last progress update (where
+    \a progressValue equals the maximum value) will always be delivered.
+*/
+
+/*! \fn void QFutureWatcher::progressTextChanged(const QString &progressText)
+
+    This signal is emitted when the watched future reports textual progress
+    information, \a progressText.
+*/
+
+/*!
+    \fn void QFutureWatcher::resultReadyAt(int index)
+
+    This signal is emitted when the watched future reports a ready result at
+    \a index. If the future reports multiple results, the index will indicate
+    which one it is. Results can be reported out-of-order. To get the result,
+    call future().result(index);
+*/
+
+/*!
+    \fn void QFutureWatcher::resultsReadyAt(int beginIndex, int endIndex);
+
+    This signal is emitted when the watched future reports ready results.
+    The results are indexed from \a beginIndex to \a endIndex.
+
+*/
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_CONCURRENT
diff --git a/src/concurrent/qfuturewatcher.h b/src/concurrent/qfuturewatcher.h
new file mode 100644
index 0000000..0e94863
--- /dev/null
+++ b/src/concurrent/qfuturewatcher.h
@@ -0,0 +1,221 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFUTUREWATCHER_H
+#define QFUTUREWATCHER_H
+
+#include <QtConcurrent/qfuture.h>
+
+#ifndef QT_NO_QFUTURE
+
+#include <QtCore/qobject.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+class QEvent;
+
+class QFutureWatcherBasePrivate;
+class Q_CORE_EXPORT QFutureWatcherBase : public QObject
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QFutureWatcherBase)
+
+public:
+    QFutureWatcherBase(QObject *parent = 0);
+
+    int progressValue() const;
+    int progressMinimum() const;
+    int progressMaximum() const;
+    QString progressText() const;
+
+    bool isStarted() const;
+    bool isFinished() const;
+    bool isRunning() const;
+    bool isCanceled() const;
+    bool isPaused() const;
+
+    void waitForFinished();
+
+    void setPendingResultsLimit(int limit);
+
+    bool event(QEvent *event);
+
+Q_SIGNALS:
+    void started();
+    void finished();
+    void canceled();
+    void paused();
+    void resumed();
+    void resultReadyAt(int resultIndex);
+    void resultsReadyAt(int beginIndex, int endIndex);
+    void progressRangeChanged(int minimum, int maximum);
+    void progressValueChanged(int progressValue);
+    void progressTextChanged(const QString &progressText);
+
+public Q_SLOTS:
+    void cancel();
+    void setPaused(bool paused);
+    void pause();
+    void resume();
+    void togglePaused();
+
+protected:
+    void connectNotify (const char * signal);
+    void disconnectNotify (const char * signal);
+
+    // called from setFuture() implemented in template sub-classes
+    void connectOutputInterface();
+    void disconnectOutputInterface(bool pendingAssignment = false);
+
+private:
+    // implemented in the template sub-classes
+    virtual const QFutureInterfaceBase &futureInterface() const = 0;
+    virtual QFutureInterfaceBase &futureInterface() = 0;
+};
+
+template <typename T>
+class QFutureWatcher : public QFutureWatcherBase
+{
+public:
+    QFutureWatcher(QObject *_parent = 0)
+        : QFutureWatcherBase(_parent)
+    { }
+    ~QFutureWatcher()
+    { disconnectOutputInterface(); }
+
+    void setFuture(const QFuture<T> &future);
+    QFuture<T> future() const
+    { return m_future; }
+
+    T result() const { return m_future.result(); }
+    T resultAt(int index) const { return m_future.resultAt(index); }
+
+#ifdef qdoc
+    int progressValue() const;
+    int progressMinimum() const;
+    int progressMaximum() const;
+    QString progressText() const;
+
+    bool isStarted() const;
+    bool isFinished() const;
+    bool isRunning() const;
+    bool isCanceled() const;
+    bool isPaused() const;
+
+    void waitForFinished();
+
+    void setPendingResultsLimit(int limit);
+
+Q_SIGNALS:
+    void started();
+    void finished();
+    void canceled();
+    void paused();
+    void resumed();
+    void resultReadyAt(int resultIndex);
+    void resultsReadyAt(int beginIndex, int endIndex);
+    void progressRangeChanged(int minimum, int maximum);
+    void progressValueChanged(int progressValue);
+    void progressTextChanged(const QString &progressText);
+
+public Q_SLOTS:
+    void cancel();
+    void setPaused(bool paused);
+    void pause();
+    void resume();
+    void togglePaused();
+#endif
+
+private:
+    QFuture<T> m_future;
+    const QFutureInterfaceBase &futureInterface() const { return m_future.d; }
+    QFutureInterfaceBase &futureInterface() { return m_future.d; }
+};
+
+template <typename T>
+Q_INLINE_TEMPLATE void QFutureWatcher<T>::setFuture(const QFuture<T> &_future)
+{
+    if (_future == m_future)
+        return;
+
+    disconnectOutputInterface(true);
+    m_future = _future;
+    connectOutputInterface();
+}
+
+template <>
+class QFutureWatcher<void> : public QFutureWatcherBase
+{
+public:
+    QFutureWatcher(QObject *_parent = 0)
+        : QFutureWatcherBase(_parent)
+    { }
+    ~QFutureWatcher()
+    { disconnectOutputInterface(); }
+
+    void setFuture(const QFuture<void> &future);
+    QFuture<void> future() const
+    { return m_future; }
+
+private:
+    QFuture<void> m_future;
+    const QFutureInterfaceBase &futureInterface() const { return m_future.d; }
+    QFutureInterfaceBase &futureInterface() { return m_future.d; }
+};
+
+Q_INLINE_TEMPLATE void QFutureWatcher<void>::setFuture(const QFuture<void> &_future)
+{
+    if (_future == m_future)
+        return;
+
+    disconnectOutputInterface(true);
+    m_future = _future;
+    connectOutputInterface();
+}
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif // QFUTUREWATCHER_H
diff --git a/src/concurrent/qfuturewatcher_p.h b/src/concurrent/qfuturewatcher_p.h
new file mode 100644
index 0000000..27bc494
--- /dev/null
+++ b/src/concurrent/qfuturewatcher_p.h
@@ -0,0 +1,90 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFUTUREWATCHER_P_H
+#define QFUTUREWATCHER_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qfutureinterface_p.h"
+#include <qlist.h>
+
+#ifndef QT_NO_QFUTURE
+
+#include <private/qobject_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QFutureWatcherBase;
+class QFutureWatcherBasePrivate : public QObjectPrivate,
+                                  public QFutureCallOutInterface
+{
+    Q_DECLARE_PUBLIC(QFutureWatcherBase)
+
+public:
+    QFutureWatcherBasePrivate();
+
+    void postCallOutEvent(const QFutureCallOutEvent &callOutEvent);
+    void callOutInterfaceDisconnected();
+
+    void sendCallOutEvent(QFutureCallOutEvent *event);
+
+    QList<QFutureCallOutEvent *> pendingCallOutEvents;
+    QAtomicInt pendingResultsReady;
+    int maximumPendingResultsReady;
+
+    QAtomicInt resultAtConnected;
+    bool finished;
+};
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_QFUTURE
+#endif
diff --git a/src/concurrent/qtconcurrentcompilertest.h b/src/concurrent/qtconcurrentcompilertest.h
new file mode 100644
index 0000000..7818423
--- /dev/null
+++ b/src/concurrent/qtconcurrentcompilertest.h
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_COMPILERTEST_H
+#define QTCONCURRENT_COMPILERTEST_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#if defined (Q_CC_MSVC) && (_MSC_VER < 1300)
+#  define QT_TYPENAME
+#else
+#  define QT_TYPENAME typename
+#endif
+
+namespace QtPrivate {
+
+template<class T>
+class HasResultType {
+    typedef char Yes;
+    typedef void *No;
+    template<typename U> static Yes test(int, const typename U::result_type * = 0);
+    template<typename U> static No test(double);
+public:
+    enum { Value = (sizeof(test<T>(0)) == sizeof(Yes)) };
+};
+
+}
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentexception.cpp b/src/concurrent/qtconcurrentexception.cpp
new file mode 100644
index 0000000..caeaa8d
--- /dev/null
+++ b/src/concurrent/qtconcurrentexception.cpp
@@ -0,0 +1,211 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qtconcurrentexception.h"
+#include "QtCore/qshareddata.h"
+
+#ifndef QT_NO_QFUTURE
+#ifndef QT_NO_EXCEPTIONS
+
+QT_BEGIN_NAMESPACE
+
+/*! 
+    \class QtConcurrent::Exception
+    \brief The Exception class provides a base class for exceptions that can transferred across threads.
+    \since 4.4
+
+    Qt Concurrent supports throwing and catching exceptions across thread
+    boundaries, provided that the exception inherit from QtConcurrent::Exception
+    and implement two helper functions:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentexception.cpp 0
+
+    QtConcurrent::Exception subclasses must be thrown by value and
+    caught by reference:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentexception.cpp 1
+
+    If you throw an exception that is not a subclass of QtConcurrent::Exception,
+    the Qt Concurrent functions will throw a QtConcurrent::UnhandledException
+    in the receiver thread.
+
+    When using QFuture, transferred exceptions will be thrown when calling the following functions:
+    \list
+    \o QFuture::waitForFinished()
+    \o QFuture::result()
+    \o QFuture::resultAt()
+    \o QFuture::results()
+    \endlist
+*/
+
+/*!
+    \fn QtConcurrent::Exception::raise() const 
+    In your QtConcurrent::Exception subclass, reimplement raise() like this:
+    
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentexception.cpp 2
+*/
+
+/*!
+    \fn QtConcurrent::Exception::clone() const
+    In your QtConcurrent::Exception subclass, reimplement clone() like this:
+    
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentexception.cpp 3
+*/
+
+/*! 
+    \class QtConcurrent::UnhandledException
+
+    \brief The UnhandledException class represents an unhandled exception in a worker thread.
+    \since 4.4
+
+    If a worker thread throws an exception that is not a subclass of QtConcurrent::Exception,
+    the Qt Concurrent functions will throw a QtConcurrent::UnhandledException
+    on the receiver thread side.
+
+    Inheriting from this class is not supported.
+*/
+
+/*!
+    \fn QtConcurrent::UnhandledException::raise() const
+    \internal
+*/
+
+/*!
+    \fn QtConcurrent::UnhandledException::clone() const
+    \internal
+*/
+
+namespace QtConcurrent
+{
+
+void Exception::raise() const
+{
+    Exception e = *this;
+    throw e;
+}
+
+Exception *Exception::clone() const
+{
+    return new Exception(*this);
+}
+
+void UnhandledException::raise() const
+{
+    UnhandledException e = *this;
+    throw e;
+}
+
+Exception *UnhandledException::clone() const
+{
+    return new UnhandledException(*this);
+}
+
+#ifndef qdoc
+
+namespace internal {
+
+class Base : public QSharedData
+{
+public:
+    Base(Exception *exception)
+    : exception(exception), hasThrown(false) { }
+    ~Base() { delete exception; }
+
+    Exception *exception;
+    bool hasThrown;
+};
+
+ExceptionHolder::ExceptionHolder(Exception *exception)
+: base(new Base(exception)) {}
+
+ExceptionHolder::ExceptionHolder(const ExceptionHolder &other)
+: base(other.base)
+{}
+
+void ExceptionHolder::operator=(const ExceptionHolder &other)
+{
+    base = other.base;
+}
+
+ExceptionHolder::~ExceptionHolder()
+{}
+
+Exception *ExceptionHolder::exception() const
+{
+    return base->exception;
+}
+
+void ExceptionStore::setException(const Exception &e)
+{
+    if (hasException() == false)
+        exceptionHolder = ExceptionHolder(e.clone());
+}
+
+bool ExceptionStore::hasException() const
+{
+    return (exceptionHolder.exception() != 0);
+}
+
+ExceptionHolder ExceptionStore::exception()
+{
+    return exceptionHolder;
+}
+
+void ExceptionStore::throwPossibleException()
+{
+    if (hasException() ) {
+        exceptionHolder.base->hasThrown = true;
+        exceptionHolder.exception()->raise();
+    }
+}
+
+bool ExceptionStore::hasThrown() const { return exceptionHolder.base->hasThrown; }
+
+} // namespace internal
+
+#endif //qdoc
+
+} // namespace QtConcurrent
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_EXCEPTIONS
+#endif // QT_NO_CONCURRENT
diff --git a/src/concurrent/qtconcurrentexception.h b/src/concurrent/qtconcurrentexception.h
new file mode 100644
index 0000000..b04e1f2
--- /dev/null
+++ b/src/concurrent/qtconcurrentexception.h
@@ -0,0 +1,128 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_EXCEPTION_H
+#define QTCONCURRENT_EXCEPTION_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_QFUTURE
+
+#include <QtCore/qatomic.h>
+#include <QtCore/qshareddata.h>
+
+#ifndef QT_NO_EXCEPTIONS
+#  include <exception>
+#endif
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+namespace QtConcurrent
+{
+
+#ifndef QT_NO_EXCEPTIONS
+
+class Q_CORE_EXPORT Exception : public std::exception
+{
+public:
+    virtual void raise() const;
+    virtual Exception *clone() const;
+};
+
+class Q_CORE_EXPORT UnhandledException : public Exception
+{
+public:
+    void raise() const;
+    Exception *clone() const;
+};
+
+namespace internal {
+
+class Base;
+class ExceptionHolder
+{
+public:
+    ExceptionHolder(Exception *exception = 0);
+    ExceptionHolder(const ExceptionHolder &other);
+    void operator=(const ExceptionHolder &other);
+    ~ExceptionHolder();
+    Exception *exception() const;
+    QExplicitlySharedDataPointer<Base> base;
+};
+
+class Q_CORE_EXPORT ExceptionStore
+{
+public:
+    void setException(const Exception &e);
+    bool hasException() const;
+    ExceptionHolder exception();
+    void throwPossibleException();
+    bool hasThrown() const;
+    ExceptionHolder exceptionHolder;
+};
+
+} // namespace internal
+
+#else // QT_NO_EXCEPTIONS
+
+namespace internal {
+
+class Q_CORE_EXPORT ExceptionStore
+{
+public:
+    ExceptionStore() { }
+    inline void throwPossibleException() const {}
+};
+
+} // namespace internal
+
+#endif
+
+} // namespace QtConcurrent
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentfilter.cpp b/src/concurrent/qtconcurrentfilter.cpp
new file mode 100644
index 0000000..76ce8ca
--- /dev/null
+++ b/src/concurrent/qtconcurrentfilter.cpp
@@ -0,0 +1,330 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+    \headerfile <QtConcurrentFilter>
+    \title Concurrent Filter and Filter-Reduce
+    \ingroup thread
+
+    \brief The <QtConcurrentFilter> header provides concurrent Filter and
+    Filter-Reduce.
+
+    These functions are a part of the \l {Concurrent Programming}{Qt Concurrent} framework.
+
+    The QtConcurrent::filter(), QtConcurrent::filtered() and
+    QtConcurrent::filteredReduced() functions filter items in a sequence such
+    as a QList or a QVector in parallel. QtConcurrent::filter() modifies a
+    sequence in-place, QtConcurrent::filtered() returns a new sequence
+    containing the filtered content, and QtConcurrent::filteredReduced()
+    returns a single result.
+
+    Each of the above functions have a blocking variant that returns the final
+    result instead of a QFuture. You use them in the same way as the
+    asynchronous variants.
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 6
+
+    Note that the result types above are not QFuture objects, but real result
+    types (in this case, QStringList and QSet<QString>).
+
+    \section1 Concurrent Filter
+
+    QtConcurrent::filtered() takes an input sequence and a filter function.
+    This filter function is then called for each item in the sequence, and a
+    new sequence containing the filtered values is returned.
+
+    The filter function must be of the form:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 0
+
+    T must match the type stored in the sequence. The function returns true if
+    the item should be kept, false if it should be discarded.
+
+    This example shows how to keep strings that are all lower-case from a
+    QStringList:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 1
+
+    The results of the filter are made available through QFuture. See the
+    QFuture and QFutureWatcher documentation for more information on how to
+    use QFuture in your applications.
+
+    If you want to modify a sequence in-place, use QtConcurrent::filter():
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 2
+
+    Since the sequence is modified in place, QtConcurrent::filter() does not
+    return any results via QFuture. However, you can still use QFuture and
+    QFutureWatcher to monitor the status of the filter.
+
+    \section1 Concurrent Filter-Reduce
+
+    QtConcurrent::filteredReduced() is similar to QtConcurrent::filtered(),
+    but instead of returing a sequence with the filtered results, the results
+    are combined into a single value using a reduce function.
+
+    The reduce function must be of the form:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 3
+
+    T is the type of the final result, U is the type of items being filtered.
+    Note that the return value and return type of the reduce function are not
+    used.
+
+    Call QtConcurrent::filteredReduced() like this:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 4
+
+    The reduce function will be called once for each result kept by the filter
+    function, and should merge the \e{intermediate} into the \e{result}
+    variable. QtConcurrent::filteredReduced() guarantees that only one thread
+    will call reduce at a time, so using a mutex to lock the result variable
+    is not necessary. The QtConcurrent::ReduceOptions enum provides a way to
+    control the order in which the reduction is done.
+
+    \section1 Additional API Features
+
+    \section2 Using Iterators instead of Sequence
+
+    Each of the above functions has a variant that takes an iterator range
+    instead of a sequence. You use them in the same way as the sequence
+    variants:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 5
+
+
+    \section2 Using Member Functions
+
+    QtConcurrent::filter(), QtConcurrent::filtered(), and
+    QtConcurrent::filteredReduced() accept pointers to member functions.
+    The member function class type must match the type stored in the sequence:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 7
+
+    Note that when using QtConcurrent::filteredReduced(), you can mix the use of
+    normal and member functions freely:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 8
+
+    \section2 Using Function Objects
+
+    QtConcurrent::filter(), QtConcurrent::filtered(), and
+    QtConcurrent::filteredReduced() accept function objects, which can be used to
+    add state to a function call. The result_type typedef must define the 
+    result type of the function call operator:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 13
+
+    \section2 Using Bound Function Arguments
+
+    Note that Qt does not provide support for bound functions. This is
+    provided by 3rd party libraries like
+    \l{http://www.boost.org/libs/bind/bind.html}{Boost} or
+    \l{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf}
+    {C++ TR1 Library Extensions}.
+
+    If you want to use a filter function takes more than one argument, you can
+    use boost::bind() or std::tr1::bind() to transform it onto a function that
+    takes one argument.
+
+    As an example, we use QString::contains():
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 9
+
+    QString::contains() takes 2 arguments (including the "this" pointer) and
+    can't be used with QtConcurrent::filtered() directly, because
+    QtConcurrent::filtered() expects a function that takes one argument. To
+    use QString::contains() with QtConcurrent::filtered() we have to provide a
+    value for the \e regexp argument:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 10
+
+    The return value from boost::bind() is a function object (functor) with
+    the following signature:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 11
+
+    This matches what QtConcurrent::filtered() expects, and the complete
+    example becomes:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 12
+*/
+
+/*!
+    \fn QFuture<void> QtConcurrent::filter(Sequence &sequence, FilterFunction filterFunction)
+    \relates <QtConcurrentFilter>
+
+    Calls \a filterFunction once for each item in \a sequence. If
+    \a filterFunction returns true, the item is kept in \a sequence;
+    otherwise, the item is removed from \a sequence.
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::filtered(const Sequence &sequence, FilterFunction filterFunction)
+    \relates <QtConcurrentFilter>
+
+    Calls \a filterFunction once for each item in \a sequence and returns a
+    new Sequence of kept items. If \a filterFunction returns true, a copy of
+    the item is put in the new Sequence. Otherwise, the item will \e not
+    appear in the new Sequence.
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::filtered(ConstIterator begin, ConstIterator end, FilterFunction filterFunction)
+    \relates <QtConcurrentFilter>
+
+    Calls \a filterFunction once for each item from \a begin to \a end and
+    returns a new Sequence of kept items. If \a filterFunction returns true, a
+    copy of the item is put in the new Sequence. Otherwise, the item will
+    \e not appear in the new Sequence.
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::filteredReduced(const Sequence &sequence, FilterFunction filterFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
+    \relates <QtConcurrentFilter>
+
+    Calls \a filterFunction once for each item in \a sequence. If
+    \a filterFunction returns true for an item, that item is then passed to
+    \a reduceFunction. In other words, the return value is the result of
+    \a reduceFunction for each item where \a filterFunction returns true.
+
+    Note that while \a filterFunction is called concurrently, only one thread
+    at a time will call \a reduceFunction. The order in which \a reduceFunction
+    is called is undefined if \a reduceOptions is
+    QtConcurrent::UnorderedReduce. If \a reduceOptions is
+    QtConcurrent::OrderedReduce, \a reduceFunction is called in the order of
+    the original sequence.
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::filteredReduced(ConstIterator begin, ConstIterator end, FilterFunction filterFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
+    \relates <QtConcurrentFilter>
+
+    Calls \a filterFunction once for each item from \a begin to \a end. If
+    \a filterFunction returns true for an item, that item is then passed to
+    \a reduceFunction. In other words, the return value is the result of
+    \a reduceFunction for each item where \a filterFunction returns true.
+
+    Note that while \a filterFunction is called concurrently, only one thread
+    at a time will call \a reduceFunction. The order in which
+    \a reduceFunction is called is undefined if \a reduceOptions is
+    QtConcurrent::UnorderedReduce. If \a reduceOptions is
+    QtConcurrent::OrderedReduce, the \a reduceFunction is called in the order
+    of the original sequence.
+*/
+
+/*!
+  \fn void QtConcurrent::blockingFilter(Sequence &sequence, FilterFunction filterFunction)
+
+  Calls \a filterFunction once for each item in \a sequence. If
+  \a filterFunction returns true, the item is kept in \a sequence;
+  otherwise, the item is removed from \a sequence.
+
+  \note This function will block until all items in the sequence have been processed.
+*/
+
+/*!
+  \fn Sequence QtConcurrent::blockingFiltered(const Sequence &sequence, FilterFunction filterFunction)
+
+  Calls \a filterFunction once for each item in \a sequence and returns a
+  new Sequence of kept items. If \a filterFunction returns true, a copy of
+  the item is put in the new Sequence. Otherwise, the item will \e not
+  appear in the new Sequence.
+
+  \note This function will block until all items in the sequence have been processed.
+
+  \sa filtered()
+*/
+
+/*!
+  \fn Sequence QtConcurrent::blockingFiltered(ConstIterator begin, ConstIterator end, FilterFunction filterFunction)
+
+  Calls \a filterFunction once for each item from \a begin to \a end and
+  returns a new Sequence of kept items. If \a filterFunction returns true, a
+  copy of the item is put in the new Sequence. Otherwise, the item will
+  \e not appear in the new Sequence.
+
+  \note This function will block until the iterator reaches the end of the
+  sequence being processed.
+
+  \sa filtered()
+*/
+
+/*!
+  \fn T QtConcurrent::blockingFilteredReduced(const Sequence &sequence, FilterFunction filterFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
+
+  Calls \a filterFunction once for each item in \a sequence. If
+  \a filterFunction returns true for an item, that item is then passed to
+  \a reduceFunction. In other words, the return value is the result of
+  \a reduceFunction for each item where \a filterFunction returns true.
+
+  Note that while \a filterFunction is called concurrently, only one thread
+  at a time will call \a reduceFunction. The order in which \a reduceFunction
+  is called is undefined if \a reduceOptions is
+  QtConcurrent::UnorderedReduce. If \a reduceOptions is
+  QtConcurrent::OrderedReduce, \a reduceFunction is called in the order of
+  the original sequence.
+
+  \note This function will block until all items in the sequence have been processed.
+
+  \sa filteredReduced()
+*/
+
+/*!
+  \fn T QtConcurrent::blockingFilteredReduced(ConstIterator begin, ConstIterator end, FilterFunction filterFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
+
+  Calls \a filterFunction once for each item from \a begin to \a end. If
+  \a filterFunction returns true for an item, that item is then passed to
+  \a reduceFunction. In other words, the return value is the result of
+  \a reduceFunction for each item where \a filterFunction returns true.
+
+  Note that while \a filterFunction is called concurrently, only one thread
+  at a time will call \a reduceFunction. The order in which
+  \a reduceFunction is called is undefined if \a reduceOptions is
+  QtConcurrent::UnorderedReduce. If \a reduceOptions is
+  QtConcurrent::OrderedReduce, the \a reduceFunction is called in the order
+  of the original sequence.
+
+  \note This function will block until the iterator reaches the end of the
+  sequence being processed.
+
+  \sa filteredReduced()
+*/
diff --git a/src/concurrent/qtconcurrentfilter.h b/src/concurrent/qtconcurrentfilter.h
new file mode 100644
index 0000000..1de8d23
--- /dev/null
+++ b/src/concurrent/qtconcurrentfilter.h
@@ -0,0 +1,269 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_FILTER_H
+#define QTCONCURRENT_FILTER_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtConcurrent/qtconcurrentfilterkernel.h>
+#include <QtConcurrent/qtconcurrentfunctionwrappers.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifdef qdoc
+
+namespace QtConcurrent {
+
+    QFuture<void> filter(Sequence &sequence, FilterFunction filterFunction);
+
+    template <typename T>
+    QFuture<T> filtered(const Sequence &sequence, FilterFunction filterFunction);
+    template <typename T>
+    QFuture<T> filtered(ConstIterator begin, ConstIterator end, FilterFunction filterFunction);
+
+    template <typename T>
+    QFuture<T> filteredReduced(const Sequence &sequence,
+                               FilterFunction filterFunction,
+                               ReduceFunction reduceFunction,
+                               QtConcurrent::ReduceOptions reduceOptions = UnorderedReduce | SequentialReduce);
+    template <typename T>
+    QFuture<T> filteredReduced(ConstIterator begin,
+                               ConstIterator end,
+                               FilterFunction filterFunction,
+                               ReduceFunction reduceFunction,
+                               QtConcurrent::ReduceOptions reduceOptions = UnorderedReduce | SequentialReduce);
+
+    void blockingFilter(Sequence &sequence, FilterFunction filterFunction);
+
+    template <typename Sequence>
+    Sequence blockingFiltered(const Sequence &sequence, FilterFunction filterFunction);
+    template <typename Sequence>
+    Sequence blockingFiltered(ConstIterator begin, ConstIterator end, FilterFunction filterFunction);
+
+    template <typename T>
+    T blockingFilteredReduced(const Sequence &sequence,
+                              FilterFunction filterFunction,
+                              ReduceFunction reduceFunction,
+                              QtConcurrent::ReduceOptions reduceOptions = UnorderedReduce | SequentialReduce);
+    template <typename T>
+    T blockingFilteredReduced(ConstIterator begin,
+                              ConstIterator end,
+                              FilterFunction filterFunction,
+                              ReduceFunction reduceFunction,
+                              QtConcurrent::ReduceOptions reduceOptions = UnorderedReduce | SequentialReduce);
+
+} // namespace QtConcurrent
+
+#else
+
+namespace QtConcurrent {
+
+template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
+ThreadEngineStarter<void> filterInternal(Sequence &sequence, KeepFunctor keep, ReduceFunctor reduce)
+{
+    typedef typename Sequence::const_iterator Iterator;
+    typedef FilterKernel<Sequence, KeepFunctor, ReduceFunctor> KernelType;
+    return startThreadEngine(new KernelType(sequence, keep, reduce));
+}
+
+// filter() on sequences
+template <typename Sequence, typename KeepFunctor>
+QFuture<void> filter(Sequence &sequence, KeepFunctor keep)
+{
+    return filterInternal(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::PushBackWrapper());
+}
+
+// filteredReduced() on sequences
+template <typename ResultType, typename Sequence, typename KeepFunctor, typename ReduceFunctor>
+QFuture<ResultType> filteredReduced(const Sequence &sequence,
+                                    KeepFunctor keep,
+                                    ReduceFunctor reduce,
+                                    ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startFilteredReduced<ResultType>(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::createFunctionWrapper(reduce), options);
+}
+
+template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
+QFuture<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType> filteredReduced(const Sequence &sequence,
+                                    KeepFunctor keep,
+                                    ReduceFunctor reduce,
+                                    ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startFilteredReduced<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
+            (sequence,
+             QtPrivate::createFunctionWrapper(keep),
+             QtPrivate::createFunctionWrapper(reduce),
+             options);
+}
+
+// filteredReduced() on iterators
+template <typename ResultType, typename Iterator, typename KeepFunctor, typename ReduceFunctor>
+QFuture<ResultType> filteredReduced(Iterator begin,
+                                    Iterator end,
+                                    KeepFunctor keep,
+                                    ReduceFunctor reduce,
+                                    ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+   return startFilteredReduced<ResultType>(begin, end, QtPrivate::createFunctionWrapper(keep), QtPrivate::createFunctionWrapper(reduce), options);
+}
+
+template <typename Iterator, typename KeepFunctor, typename ReduceFunctor>
+QFuture<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType> filteredReduced(Iterator begin,
+                                    Iterator end,
+                                    KeepFunctor keep,
+                                    ReduceFunctor reduce,
+                                    ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+   return startFilteredReduced<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
+           (begin, end,
+            QtPrivate::createFunctionWrapper(keep),
+            QtPrivate::createFunctionWrapper(reduce),
+            options);
+}
+
+// filtered() on sequences
+template <typename Sequence, typename KeepFunctor>
+QFuture<typename Sequence::value_type> filtered(const Sequence &sequence, KeepFunctor keep)
+{
+    return startFiltered(sequence, QtPrivate::createFunctionWrapper(keep));
+}
+
+// filtered() on iterators
+template <typename Iterator, typename KeepFunctor>
+QFuture<typename qValueType<Iterator>::value_type> filtered(Iterator begin, Iterator end, KeepFunctor keep)
+{
+    return startFiltered(begin, end, QtPrivate::createFunctionWrapper(keep));
+}
+
+// blocking filter() on sequences
+template <typename Sequence, typename KeepFunctor>
+void blockingFilter(Sequence &sequence, KeepFunctor keep)
+{
+    filterInternal(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::PushBackWrapper()).startBlocking();
+}
+
+// blocking filteredReduced() on sequences
+template <typename ResultType, typename Sequence, typename KeepFunctor, typename ReduceFunctor>
+ResultType blockingFilteredReduced(const Sequence &sequence,
+                                   KeepFunctor keep,
+                                   ReduceFunctor reduce,
+                                   ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startFilteredReduced<ResultType>(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::createFunctionWrapper(reduce), options)
+        .startBlocking();
+}
+
+template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
+typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType blockingFilteredReduced(const Sequence &sequence,
+                                   KeepFunctor keep,
+                                   ReduceFunctor reduce,
+                                   ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return blockingFilteredReduced<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
+        (sequence,
+         QtPrivate::createFunctionWrapper(keep),
+         QtPrivate::createFunctionWrapper(reduce),
+         options);
+}
+
+// blocking filteredReduced() on iterators
+template <typename ResultType, typename Iterator, typename KeepFunctor, typename ReduceFunctor>
+ResultType blockingFilteredReduced(Iterator begin,
+                                   Iterator end,
+                                   KeepFunctor keep,
+                                   ReduceFunctor reduce,
+                                   ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startFilteredReduced<ResultType>
+        (begin, end,
+         QtPrivate::createFunctionWrapper(keep),
+         QtPrivate::createFunctionWrapper(reduce),
+         options)
+        .startBlocking();
+}
+
+template <typename Iterator, typename KeepFunctor, typename ReduceFunctor>
+typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType blockingFilteredReduced(Iterator begin,
+                                   Iterator end,
+                                   KeepFunctor keep,
+                                   ReduceFunctor reduce,
+                                   ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startFilteredReduced<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
+        (begin, end,
+         QtPrivate::createFunctionWrapper(keep),
+         QtPrivate::createFunctionWrapper(reduce),
+         options)
+        .startBlocking();
+}
+
+// blocking filtered() on sequences
+template <typename Sequence, typename KeepFunctor>
+Sequence blockingFiltered(const Sequence &sequence, KeepFunctor keep)
+{
+    return startFilteredReduced<Sequence>(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::PushBackWrapper(), OrderedReduce).startBlocking();
+}
+
+// blocking filtered() on iterators
+template <typename OutputSequence, typename Iterator, typename KeepFunctor>
+OutputSequence blockingFiltered(Iterator begin, Iterator end, KeepFunctor keep)
+{
+    return startFilteredReduced<OutputSequence>(begin, end,
+        QtPrivate::createFunctionWrapper(keep),
+        QtPrivate::PushBackWrapper(),
+        OrderedReduce).startBlocking();
+}
+
+} // namespace QtConcurrent
+
+#endif // qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentfilterkernel.h b/src/concurrent/qtconcurrentfilterkernel.h
new file mode 100644
index 0000000..71112cb
--- /dev/null
+++ b/src/concurrent/qtconcurrentfilterkernel.h
@@ -0,0 +1,350 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_FILTERKERNEL_H
+#define QTCONCURRENT_FILTERKERNEL_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtConcurrent/qtconcurrentiteratekernel.h>
+#include <QtConcurrent/qtconcurrentmapkernel.h>
+#include <QtConcurrent/qtconcurrentreducekernel.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifndef qdoc
+
+namespace QtConcurrent {
+
+template <typename T>
+struct qValueType
+{
+    typedef typename T::value_type value_type;
+};
+
+template <typename T>
+struct qValueType<const T*>
+{
+    typedef T value_type;
+};
+
+template <typename T>
+struct qValueType<T*>
+{
+    typedef T value_type;
+};
+
+// Implementation of filter
+template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
+class FilterKernel : public IterateKernel<typename Sequence::const_iterator, void>
+{
+    typedef ReduceKernel<ReduceFunctor, Sequence, typename Sequence::value_type> Reducer;
+    typedef IterateKernel<typename Sequence::const_iterator, void> IterateKernelType;
+    typedef typename ReduceFunctor::result_type T;
+
+    Sequence reducedResult;
+    Sequence &sequence;
+    KeepFunctor keep;
+    ReduceFunctor reduce;
+    Reducer reducer;
+
+public:
+    FilterKernel(Sequence &_sequence, KeepFunctor _keep, ReduceFunctor _reduce)
+        : IterateKernelType(const_cast<const Sequence &>(_sequence).begin(), const_cast<const Sequence &>(_sequence).end()), reducedResult(),
+          sequence(_sequence),
+          keep(_keep),
+          reduce(_reduce),
+          reducer(OrderedReduce)
+    { }
+
+    bool runIteration(typename Sequence::const_iterator it, int index, T *)
+    {
+        IntermediateResults<typename Sequence::value_type> results;
+        results.begin = index;
+        results.end = index + 1;
+
+            if (keep(*it))
+                results.vector.append(*it);
+
+            reducer.runReduce(reduce, reducedResult, results);
+            return false;
+    }
+
+    bool runIterations(typename Sequence::const_iterator sequenceBeginIterator, int begin, int end, T *)
+    {
+        IntermediateResults<typename Sequence::value_type> results;
+        results.begin = begin;
+        results.end = end;
+        results.vector.reserve(end - begin);
+
+
+        typename Sequence::const_iterator it = sequenceBeginIterator;
+        advance(it, begin);
+        for (int i = begin; i < end; ++i) {
+            if (keep(*it))
+                results.vector.append(*it);
+            advance(it, 1);
+        }
+
+        reducer.runReduce(reduce, reducedResult, results);
+        return false;
+    }
+
+    void finish()
+    {
+        reducer.finish(reduce, reducedResult);
+        sequence = reducedResult;
+    }
+
+    inline bool shouldThrottleThread()
+    {
+        return IterateKernelType::shouldThrottleThread() || reducer.shouldThrottle();
+    }
+
+    inline bool shouldStartThread()
+    {
+        return IterateKernelType::shouldStartThread() && reducer.shouldStartThread();
+    }
+
+    typedef void ReturnType;
+    typedef void ResultType;
+};
+
+// Implementation of filter-reduce
+template <typename ReducedResultType,
+          typename Iterator,
+          typename KeepFunctor,
+          typename ReduceFunctor,
+          typename Reducer = ReduceKernel<ReduceFunctor,
+                                          ReducedResultType,
+                                          typename qValueType<Iterator>::value_type> >
+class FilteredReducedKernel : public IterateKernel<Iterator, ReducedResultType>
+{
+    ReducedResultType reducedResult;
+    KeepFunctor keep;
+    ReduceFunctor reduce;
+    Reducer reducer;
+    typedef IterateKernel<Iterator, ReducedResultType> IterateKernelType;
+
+public:
+    FilteredReducedKernel(Iterator begin,
+                          Iterator end,
+                          KeepFunctor _keep,
+                          ReduceFunctor _reduce,
+                          ReduceOptions reduceOption)
+        : IterateKernelType(begin, end), reducedResult(), keep(_keep), reduce(_reduce), reducer(reduceOption)
+    { }
+
+#if 0
+    FilteredReducedKernel(ReducedResultType initialValue,
+                          KeepFunctor keep,
+                          ReduceFunctor reduce,
+                          ReduceOption reduceOption)
+        : reducedResult(initialValue), keep(keep), reduce(reduce), reducer(reduceOption)
+    { }
+#endif
+
+    bool runIteration(Iterator it, int index, ReducedResultType *)
+    {
+        IntermediateResults<typename qValueType<Iterator>::value_type> results;
+        results.begin = index;
+        results.end = index + 1;
+
+        if (keep(*it))
+            results.vector.append(*it);
+
+        reducer.runReduce(reduce, reducedResult, results);
+        return false;
+    }
+
+    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, ReducedResultType *)
+    {
+        IntermediateResults<typename qValueType<Iterator>::value_type> results;
+        results.begin = begin;
+        results.end = end;
+        results.vector.reserve(end - begin);
+
+        Iterator it = sequenceBeginIterator;
+        advance(it, begin);
+        for (int i = begin; i < end; ++i) {
+            if (keep(*it))
+                results.vector.append(*it);
+            advance(it, 1);
+        }
+
+        reducer.runReduce(reduce, reducedResult, results);
+        return false;
+    }
+
+    void finish()
+    {
+        reducer.finish(reduce, reducedResult);
+    }
+
+    inline bool shouldThrottleThread()
+    {
+        return IterateKernelType::shouldThrottleThread() || reducer.shouldThrottle();
+    }
+
+    inline bool shouldStartThread()
+    {
+        return IterateKernelType::shouldStartThread() && reducer.shouldStartThread();
+    }
+
+    typedef ReducedResultType ReturnType;
+    typedef ReducedResultType ResultType;
+    ReducedResultType *result()
+    {
+        return &reducedResult;
+    }
+};
+
+// Implementation of filter that reports individual results via QFutureInterface
+template <typename Iterator, typename KeepFunctor>
+class FilteredEachKernel : public IterateKernel<Iterator, typename qValueType<Iterator>::value_type>
+{
+    typedef typename qValueType<Iterator>::value_type T;
+    typedef IterateKernel<Iterator, T> IterateKernelType;
+
+    KeepFunctor keep;
+
+public:
+    typedef T ReturnType;
+    typedef T ResultType;
+
+    FilteredEachKernel(Iterator begin, Iterator end, KeepFunctor _keep)
+        : IterateKernelType(begin, end), keep(_keep)
+    { }
+
+    void start()
+    {
+        if (this->futureInterface)
+            this->futureInterface->setFilterMode(true);
+        IterateKernelType::start();
+    }
+
+    bool runIteration(Iterator it, int index, T *)
+    {
+        if (keep(*it))
+            this->reportResult(&(*it), index);
+        else
+            this->reportResult(0, index);
+        return false;
+    }
+
+    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, T *)
+    {
+        const int count = end - begin;
+        IntermediateResults<typename qValueType<Iterator>::value_type> results;
+        results.begin = begin;
+        results.end = end;
+        results.vector.reserve(count);
+
+        Iterator it = sequenceBeginIterator;
+        advance(it, begin);
+        for (int i = begin; i < end; ++i) {
+            if (keep(*it))
+                results.vector.append(*it);
+            advance(it, 1);
+        }
+
+        this->reportResults(results.vector, begin, count);
+        return false;
+    }
+};
+
+template <typename Iterator, typename KeepFunctor>
+inline
+ThreadEngineStarter<typename qValueType<Iterator>::value_type>
+startFiltered(Iterator begin, Iterator end, KeepFunctor functor)
+{
+    return startThreadEngine(new FilteredEachKernel<Iterator, KeepFunctor>(begin, end, functor));
+}
+
+template <typename Sequence, typename KeepFunctor>
+inline ThreadEngineStarter<typename Sequence::value_type>
+startFiltered(const Sequence &sequence, KeepFunctor functor)
+{
+    typedef SequenceHolder1<Sequence,
+                            FilteredEachKernel<typename Sequence::const_iterator, KeepFunctor>,
+                            KeepFunctor>
+        SequenceHolderType;
+        return startThreadEngine(new SequenceHolderType(sequence, functor));
+}
+
+template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
+inline ThreadEngineStarter<ResultType> startFilteredReduced(const Sequence & sequence,
+                                                           MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
+                                                           ReduceOptions options)
+{
+    typedef typename Sequence::const_iterator Iterator;
+    typedef ReduceKernel<ReduceFunctor, ResultType, typename qValueType<Iterator>::value_type > Reducer;
+    typedef FilteredReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> FilteredReduceType;
+    typedef SequenceHolder2<Sequence, FilteredReduceType, MapFunctor, ReduceFunctor> SequenceHolderType;
+    return startThreadEngine(new SequenceHolderType(sequence, mapFunctor, reduceFunctor, options));
+}
+
+
+template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
+inline ThreadEngineStarter<ResultType> startFilteredReduced(Iterator begin, Iterator end,
+                                                           MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
+                                                           ReduceOptions options)
+{
+    typedef ReduceKernel<ReduceFunctor, ResultType, typename qValueType<Iterator>::value_type> Reducer;
+    typedef FilteredReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> FilteredReduceType;
+    return startThreadEngine(new FilteredReduceType(begin, end, mapFunctor, reduceFunctor, options));
+}
+
+
+} // namespace QtConcurrent
+
+#endif // qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentfunctionwrappers.h b/src/concurrent/qtconcurrentfunctionwrappers.h
new file mode 100644
index 0000000..9b86b73
--- /dev/null
+++ b/src/concurrent/qtconcurrentfunctionwrappers.h
@@ -0,0 +1,303 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_FUNCTIONWRAPPERS_H
+#define QTCONCURRENT_FUNCTIONWRAPPERS_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifndef qdoc
+
+namespace QtConcurrent {
+
+template <typename T>
+class FunctionWrapper0
+{
+public:
+    typedef T (*FunctionPointerType)();
+    typedef T result_type;
+    inline FunctionWrapper0(FunctionPointerType _functionPointer)
+    :functionPointer(_functionPointer) { }
+
+    inline T operator()()
+    {
+        return functionPointer();
+    }
+private:
+    FunctionPointerType functionPointer;
+};
+
+template <typename T, typename U>
+class FunctionWrapper1
+{
+public:
+    typedef T (*FunctionPointerType)(U u);
+    typedef T result_type;
+    inline FunctionWrapper1(FunctionPointerType _functionPointer)
+    :functionPointer(_functionPointer) { }
+
+    inline T operator()(U u)
+    {
+        return functionPointer(u);
+    }
+
+private:
+    FunctionPointerType functionPointer;
+};
+
+template <typename T, typename U, typename V>
+class FunctionWrapper2
+{
+public:
+    typedef T (*FunctionPointerType)(U u, V v);
+    typedef T result_type;
+    inline FunctionWrapper2(FunctionPointerType _functionPointer)
+    :functionPointer(_functionPointer) { }
+
+    inline T operator()(U u, V v)
+    {
+        return functionPointer(u, v);
+    }
+private:
+    FunctionPointerType functionPointer;
+};
+
+template <typename T, typename C>
+class MemberFunctionWrapper
+{
+public:
+    typedef T (C::*FunctionPointerType)();
+    typedef T result_type;
+    inline MemberFunctionWrapper(FunctionPointerType _functionPointer)
+    :functionPointer(_functionPointer) { }
+
+    inline T operator()(C &c)
+    {
+        return (c.*functionPointer)();
+    }
+private:
+    FunctionPointerType functionPointer;
+};
+
+template <typename T, typename C, typename U>
+class MemberFunctionWrapper1
+{
+public:
+    typedef T (C::*FunctionPointerType)(U);
+    typedef T result_type;
+
+    inline MemberFunctionWrapper1(FunctionPointerType _functionPointer)
+        : functionPointer(_functionPointer)
+    { }
+
+    inline T operator()(C &c, U u)
+    {
+        return (c.*functionPointer)(u);
+    }
+
+private:
+    FunctionPointerType functionPointer;
+};
+
+template <typename T, typename C>
+class ConstMemberFunctionWrapper
+{
+public:
+    typedef T (C::*FunctionPointerType)() const;
+    typedef T result_type;
+    inline ConstMemberFunctionWrapper(FunctionPointerType _functionPointer)
+    :functionPointer(_functionPointer) { }
+
+    inline T operator()(const C &c) const
+    {
+        return (c.*functionPointer)();
+    }
+private:
+    FunctionPointerType functionPointer;
+};
+
+} // namespace QtConcurrent.
+
+namespace QtPrivate {
+
+template <typename T>
+const T& createFunctionWrapper(const T& t)
+{
+    return t;
+}
+
+template <typename T, typename U>
+QtConcurrent::FunctionWrapper1<T, U> createFunctionWrapper(T (*func)(U))
+{
+    return QtConcurrent::FunctionWrapper1<T, U>(func);
+}
+
+template <typename T, typename C>
+QtConcurrent::MemberFunctionWrapper<T, C> createFunctionWrapper(T (C::*func)())
+{
+    return QtConcurrent::MemberFunctionWrapper<T, C>(func);
+}
+
+template <typename T, typename C, typename U>
+QtConcurrent::MemberFunctionWrapper1<T, C, U> createFunctionWrapper(T (C::*func)(U))
+{
+    return QtConcurrent::MemberFunctionWrapper1<T, C, U>(func);
+}
+
+template <typename T, typename C>
+QtConcurrent::ConstMemberFunctionWrapper<T, C> createFunctionWrapper(T (C::*func)() const)
+{
+    return QtConcurrent::ConstMemberFunctionWrapper<T, C>(func);
+}
+
+struct PushBackWrapper
+{
+    typedef void result_type;
+
+    template <class C, class U>
+    inline void operator()(C &c, const U &u) const
+    {
+        return c.push_back(u);
+    }
+
+#ifdef Q_COMPILER_RVALUE_REFS
+    template <class C, class U>
+    inline void operator()(C &c, U &&u) const
+    {
+        return c.push_back(u);
+    }
+#endif
+};
+
+template <typename Functor, bool foo = HasResultType<Functor>::Value>
+struct LazyResultType { typedef typename Functor::result_type Type; };
+template <typename Functor>
+struct LazyResultType<Functor, false> { typedef void Type; };
+
+template <class T>
+struct ReduceResultType;
+
+template <class U, class V>
+struct ReduceResultType<void(*)(U&,V)>
+{
+    typedef U ResultType;
+};
+
+template <class T, class C, class U>
+struct ReduceResultType<T(C::*)(U)>
+{
+    typedef C ResultType;
+};
+
+template <class InputSequence, class MapFunctor>
+struct MapResultType
+{
+    typedef typename LazyResultType<MapFunctor>::Type ResultType;
+};
+
+template <class U, class V>
+struct MapResultType<void, U (*)(V)>
+{
+    typedef U ResultType;
+};
+
+template <class T, class C>
+struct MapResultType<void, T(C::*)() const>
+{
+    typedef T ResultType;
+};
+
+#ifndef QT_NO_TEMPLATE_TEMPLATE_PARAMETERS
+
+template <template <typename> class InputSequence, typename MapFunctor, typename T>
+struct MapResultType<InputSequence<T>, MapFunctor>
+{
+    typedef InputSequence<typename LazyResultType<MapFunctor>::Type> ResultType;
+};
+
+template <template <typename> class InputSequence, class T, class U, class V>
+struct MapResultType<InputSequence<T>, U (*)(V)>
+{
+    typedef InputSequence<U> ResultType;
+};
+
+template <template <typename> class InputSequence, class T, class U, class C>
+struct MapResultType<InputSequence<T>, U(C::*)() const>
+{
+    typedef InputSequence<U> ResultType;
+};
+
+#endif // QT_NO_TEMPLATE_TEMPLATE_PARAMETER
+
+template <class MapFunctor>
+struct MapResultType<QStringList, MapFunctor>
+{
+    typedef QList<typename LazyResultType<MapFunctor>::Type> ResultType;
+};
+
+template <class U, class V>
+struct MapResultType<QStringList, U (*)(V)>
+{
+    typedef QList<U> ResultType;
+};
+
+template <class U, class C>
+struct MapResultType<QStringList, U(C::*)() const>
+{
+    typedef QList<U> ResultType;
+};
+
+} // namespace QtPrivate.
+
+#endif //qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentiteratekernel.cpp b/src/concurrent/qtconcurrentiteratekernel.cpp
new file mode 100644
index 0000000..b695805
--- /dev/null
+++ b/src/concurrent/qtconcurrentiteratekernel.cpp
@@ -0,0 +1,194 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qtconcurrentiteratekernel.h"
+
+#if defined(Q_OS_MAC)
+#include <mach/mach.h>
+#include <mach/mach_time.h>
+#include <unistd.h>
+#elif defined(Q_OS_UNIX)
+#if defined(Q_OS_HURD)
+#include <sys/time.h>
+#endif
+#include <time.h>
+#include <unistd.h>
+#elif defined(Q_OS_WIN)
+#include <qt_windows.h>
+#endif
+
+#include "private/qfunctions_p.h"
+
+
+#ifndef QT_NO_CONCURRENT
+
+QT_BEGIN_NAMESPACE
+
+enum {
+    TargetRatio = 100,
+    MedianSize = 7
+};
+
+#if defined(Q_OS_MAC)
+
+static qint64 getticks()
+{
+    return mach_absolute_time();
+}
+
+#elif defined(Q_OS_UNIX)
+
+
+static qint64 getticks()
+{
+#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)
+    clockid_t clockId;
+
+#ifndef _POSIX_THREAD_CPUTIME
+    clockId = CLOCK_REALTIME;
+#elif (_POSIX_THREAD_CPUTIME-0 <= 0)
+    // if we don't have CLOCK_THREAD_CPUTIME_ID, we have to just use elapsed realtime instead
+    clockId = CLOCK_REALTIME;
+
+#  if (_POSIX_THREAD_CPUTIME-0 == 0)
+    // detect availablility of CLOCK_THREAD_CPUTIME_ID
+    static long useThreadCpuTime = -2;
+    if (useThreadCpuTime == -2) {
+        // sysconf() will return either -1 or _POSIX_VERSION (don't care about thread races here)
+        useThreadCpuTime = sysconf(_SC_THREAD_CPUTIME);
+    }
+    if (useThreadCpuTime != -1)
+        clockId = CLOCK_THREAD_CPUTIME_ID;
+#  endif
+#else
+    clockId = CLOCK_THREAD_CPUTIME_ID;
+#endif
+
+    struct timespec ts;
+    if (clock_gettime(clockId, &ts) == -1)
+        return 0;
+    return (ts.tv_sec * 1000000000) + ts.tv_nsec;
+#else
+
+    // no clock_gettime(), fall back to wall time
+    struct timeval tv;
+    gettimeofday(&tv, 0);
+    return (tv.tv_sec * 1000000) + tv.tv_usec;
+#endif
+}
+
+#elif defined(Q_OS_WIN)
+
+static qint64 getticks()
+{
+    LARGE_INTEGER x;
+    if (!QueryPerformanceCounter(&x))
+        return 0;
+    return x.QuadPart;
+}
+
+#endif
+
+static double elapsed(qint64 after, qint64 before)
+{
+    return double(after - before);
+}
+
+namespace QtConcurrent {
+
+/*! \internal
+
+*/
+BlockSizeManager::BlockSizeManager(int iterationCount)
+: maxBlockSize(iterationCount / (QThreadPool::globalInstance()->maxThreadCount() * 2)),
+  beforeUser(0), afterUser(0),
+  controlPartElapsed(MedianSize), userPartElapsed(MedianSize),
+  m_blockSize(1)
+{ }
+
+// Records the time before user code.
+void BlockSizeManager::timeBeforeUser()
+{
+    if (blockSizeMaxed())
+        return;
+
+    beforeUser = getticks();
+    controlPartElapsed.addValue(elapsed(beforeUser, afterUser));
+}
+
+ // Records the time after user code and adjust the block size if we are spending
+ // to much time in the for control code compared with the user code.
+void BlockSizeManager::timeAfterUser()
+{
+    if (blockSizeMaxed())
+        return;
+
+    afterUser = getticks();
+    userPartElapsed.addValue(elapsed(afterUser, beforeUser));
+
+    if (controlPartElapsed.isMedianValid() == false)
+        return;
+
+    if (controlPartElapsed.median() * TargetRatio < userPartElapsed.median())
+        return;
+
+    m_blockSize = qMin(m_blockSize * 2,  maxBlockSize);
+
+#ifdef QTCONCURRENT_FOR_DEBUG
+    qDebug() << QThread::currentThread() << "adjusting block size" << controlPartElapsed.median() << userPartElapsed.median() << m_blockSize;
+#endif
+
+    // Reset the medians after adjusting the block size so we get
+    // new measurements with the new block size.
+    controlPartElapsed.reset();
+    userPartElapsed.reset();
+}
+
+int BlockSizeManager::blockSize()
+{
+    return m_blockSize;
+}
+
+} // namespace QtConcurrent
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_CONCURRENT
diff --git a/src/concurrent/qtconcurrentiteratekernel.h b/src/concurrent/qtconcurrentiteratekernel.h
new file mode 100644
index 0000000..a28bc31
--- /dev/null
+++ b/src/concurrent/qtconcurrentiteratekernel.h
@@ -0,0 +1,339 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_ITERATEKERNEL_H
+#define QTCONCURRENT_ITERATEKERNEL_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtCore/qatomic.h>
+#include <QtConcurrent/qtconcurrentmedian.h>
+#include <QtConcurrent/qtconcurrentthreadengine.h>
+
+#ifndef QT_NO_STL
+#  include <iterator>
+#endif
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifndef qdoc
+
+namespace QtConcurrent {
+
+#ifndef QT_NO_STL
+    using std::advance;
+#else
+    template <typename It, typename T>
+    void advance(It &it, T value)
+    {
+        it+=value;
+    }
+#endif
+
+/*
+    The BlockSizeManager class manages how many iterations a thread should
+    reserve and process at a time. This is done by measuring the time spent
+    in the user code versus the control part code, and then increasing
+    the block size if the ratio between them is to small. The block size
+    management is done on the basis of the median of several timing measuremens,
+    and it is done induvidualy for each thread.
+*/
+class Q_CORE_EXPORT BlockSizeManager
+{
+public:
+    BlockSizeManager(int iterationCount);
+    void timeBeforeUser();
+    void timeAfterUser();
+    int blockSize();
+private:
+    inline bool blockSizeMaxed()
+    {
+        return (m_blockSize >= maxBlockSize);
+    }
+
+    const int maxBlockSize;
+    qint64 beforeUser;
+    qint64 afterUser;
+    Median<double> controlPartElapsed;
+    Median<double> userPartElapsed;
+    int m_blockSize;
+};
+
+template <typename T>
+class ResultReporter
+{
+public:
+    ResultReporter(ThreadEngine<T> *_threadEngine)
+    :threadEngine(_threadEngine)
+    {
+
+    }
+
+    void reserveSpace(int resultCount)
+    {
+        currentResultCount = resultCount;
+        vector.resize(qMax(resultCount, vector.count()));
+    }
+
+    void reportResults(int begin)
+    {
+        const int useVectorThreshold = 4; // Tunable parameter.
+        if (currentResultCount > useVectorThreshold) {
+            vector.resize(currentResultCount);
+            threadEngine->reportResults(vector, begin);
+        } else {
+            for (int i = 0; i < currentResultCount; ++i)
+                threadEngine->reportResult(&vector.at(i), begin + i);
+        }
+    }
+
+    inline T * getPointer()
+    {
+        return vector.data();
+    }
+
+    int currentResultCount;
+    ThreadEngine<T> *threadEngine;
+    QVector<T> vector;
+};
+
+template <>
+class ResultReporter<void>
+{
+public:
+    inline ResultReporter(ThreadEngine<void> *) { }
+    inline void reserveSpace(int) { }
+    inline void reportResults(int) { }
+    inline void * getPointer() { return 0; }
+};
+
+#ifndef QT_NO_STL
+inline bool selectIteration(std::bidirectional_iterator_tag)
+{
+    return false; // while
+}
+
+inline bool selectIteration(std::forward_iterator_tag)
+{
+    return false; // while
+}
+
+inline bool selectIteration(std::random_access_iterator_tag)
+{
+    return true; // for
+}
+#else
+// no stl support, always use while iteration
+template <typename T>
+inline bool selectIteration(T)
+{
+    return false; // while
+}
+#endif
+
+template <typename Iterator, typename T>
+class IterateKernel : public ThreadEngine<T>
+{
+public:
+    typedef T ResultType;
+
+    IterateKernel(Iterator _begin, Iterator _end)
+#if defined (QT_NO_STL)
+        : begin(_begin), end(_end), current(_begin), currentIndex(0),
+           forIteration(false), progressReportingEnabled(true)
+#else
+        : begin(_begin), end(_end), current(_begin), currentIndex(0),
+           forIteration(selectIteration(typename std::iterator_traits<Iterator>::iterator_category())), progressReportingEnabled(true)
+#endif
+    {
+#if defined (QT_NO_STL)
+       iterationCount = 0;
+#else
+        iterationCount =  forIteration ? std::distance(_begin, _end) : 0;
+
+#endif
+    }
+
+    virtual ~IterateKernel() { }
+
+    virtual bool runIteration(Iterator it, int index , T *result)
+        { Q_UNUSED(it); Q_UNUSED(index); Q_UNUSED(result); return false; }
+    virtual bool runIterations(Iterator _begin, int beginIndex, int endIndex, T *results)
+        { Q_UNUSED(_begin); Q_UNUSED(beginIndex); Q_UNUSED(endIndex); Q_UNUSED(results); return false; }
+
+    void start()
+    {
+        progressReportingEnabled = this->isProgressReportingEnabled();
+        if (progressReportingEnabled && iterationCount > 0)
+            this->setProgressRange(0, iterationCount);
+    }
+
+    bool shouldStartThread()
+    {
+        if (forIteration)
+            return (currentIndex.load() < iterationCount) && !this->shouldThrottleThread();
+        else // whileIteration
+            return (iteratorThreads.load() == 0);
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        if (forIteration)
+            return this->forThreadFunction();
+        else // whileIteration
+            return this->whileThreadFunction();
+    }
+
+    ThreadFunctionResult forThreadFunction()
+    {
+        BlockSizeManager blockSizeManager(iterationCount);
+        ResultReporter<T> resultReporter(this);
+
+        for(;;) {
+            if (this->isCanceled())
+                break;
+
+            const int currentBlockSize = blockSizeManager.blockSize();
+
+            if (currentIndex.load() >= iterationCount)
+                break;
+
+            // Atomically reserve a block of iterationCount for this thread.
+            const int beginIndex = currentIndex.fetchAndAddRelease(currentBlockSize);
+            const int endIndex = qMin(beginIndex + currentBlockSize, iterationCount);
+
+            if (beginIndex >= endIndex) {
+                // No more work
+                break;
+            }
+
+            this->waitForResume(); // (only waits if the qfuture is paused.)
+
+            if (shouldStartThread())
+                this->startThread();
+
+            const int finalBlockSize = endIndex - beginIndex; // block size adjusted for possible end-of-range
+            resultReporter.reserveSpace(finalBlockSize);
+
+            // Call user code with the current iteration range.
+            blockSizeManager.timeBeforeUser();
+            const bool resultsAvailable = this->runIterations(begin, beginIndex, endIndex, resultReporter.getPointer());
+            blockSizeManager.timeAfterUser();
+
+            if (resultsAvailable)
+                resultReporter.reportResults(beginIndex);
+
+            // Report progress if progress reporting enabled.
+            if (progressReportingEnabled) {
+                completed.fetchAndAddAcquire(finalBlockSize);
+                this->setProgressValue(this->completed.load());
+            }
+
+            if (this->shouldThrottleThread())
+                return ThrottleThread;
+        }
+        return ThreadFinished;
+    }
+
+    ThreadFunctionResult whileThreadFunction()
+    {
+        if (iteratorThreads.testAndSetAcquire(0, 1) == false)
+            return ThreadFinished;
+
+        ResultReporter<T> resultReporter(this);
+        resultReporter.reserveSpace(1);
+
+        while (current != end) {
+            // The following two lines breaks support for input iterators according to
+            // the sgi docs: dereferencing prev after calling ++current is not allowed
+            // on input iterators. (prev is dereferenced inside user.runIteration())
+            Iterator prev = current;
+            ++current;
+            int index = currentIndex.fetchAndAddRelaxed(1);
+            iteratorThreads.testAndSetRelease(1, 0);
+
+            this->waitForResume(); // (only waits if the qfuture is paused.)
+
+            if (shouldStartThread())
+                this->startThread();
+
+            const bool resultAavailable = this->runIteration(prev, index, resultReporter.getPointer());
+            if (resultAavailable)
+                resultReporter.reportResults(index);
+
+            if (this->shouldThrottleThread())
+                return ThrottleThread;
+
+            if (iteratorThreads.testAndSetAcquire(0, 1) == false)
+                return ThreadFinished;
+        }
+
+        return ThreadFinished;
+    }
+
+
+public:
+    const Iterator begin;
+    const Iterator end;
+    Iterator current;
+    QAtomicInt currentIndex;
+    bool forIteration;
+    QAtomicInt iteratorThreads;
+    int iterationCount;
+
+    bool progressReportingEnabled;
+    QAtomicInt completed;
+};
+
+} // namespace QtConcurrent
+
+#endif //qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentmap.cpp b/src/concurrent/qtconcurrentmap.cpp
new file mode 100644
index 0000000..1758cb9
--- /dev/null
+++ b/src/concurrent/qtconcurrentmap.cpp
@@ -0,0 +1,402 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+    \namespace QtConcurrent
+    \inmodule QtCore
+    \since 4.4
+    \brief The QtConcurrent namespace provides high-level APIs that make it
+    possible to write multi-threaded programs without using low-level
+    threading primitives.
+
+    See the \l {Concurrent Programming}{Qt Concurrent} chapter in
+    the \l{threads.html}{threading} documentation.
+
+    \inheaderfile QtCore
+    \ingroup thread
+*/
+
+/*!
+    \namespace QtConcurrent::internal
+    \internal
+
+    \brief The QtConcurrent::internal namespace contains QtConcurrent
+    implementation details.
+*/
+
+/*!
+    \enum QtConcurrent::ReduceOption
+    This enum specifies the order of which results from the map or filter 
+    function are passed to the reduce function.
+
+    \value UnorderedReduce Reduction is done in an arbitrary order.
+    \value OrderedReduce Reduction is done in the order of the
+    original sequence.
+    \value SequentialReduce Reduction is done sequentially: only one
+    thread will enter the reduce function at a time. (Parallel reduction
+    might be supported in a future version of Qt Concurrent.)
+*/
+
+/*!
+    \headerfile <QtConcurrentMap>
+    \title Concurrent Map and Map-Reduce
+    \ingroup thread
+
+    \brief The <QtConcurrentMap> header provides concurrent Map and MapReduce.
+
+    These functions are a part of the \l {Concurrent Programming}{Qt Concurrent} framework.
+
+    The QtConcurrent::map(), QtConcurrent::mapped() and
+    QtConcurrent::mappedReduced() functions run computations in parallel on
+    the items in a sequence such as a QList or a QVector. QtConcurrent::map()
+    modifies a sequence in-place, QtConcurrent::mapped() returns a new
+    sequence containing the modified content, and QtConcurrent::mappedReduced()
+    returns a single result.
+
+    Each of the above functions has a blocking variant that returns
+    the final result instead of a QFuture. You use them in the same
+    way as the asynchronous variants.
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 7
+
+    Note that the result types above are not QFuture objects, but real result
+    types (in this case, QList<QImage> and QImage).
+
+    \section1 Concurrent Map
+
+    QtConcurrent::mapped() takes an input sequence and a map function. This map
+    function is then called for each item in the sequence, and a new sequence
+    containing the return values from the map function is returned.
+
+    The map function must be of the form:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 0
+
+    T and U can be any type (and they can even be the same type), but T must
+    match the type stored in the sequence. The function returns the modified
+    or \e mapped content.
+
+    This example shows how to apply a scale function to all the items
+    in a sequence:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 1
+
+    The results of the map are made available through QFuture.  See the
+    QFuture and QFutureWatcher documentation for more information on how to
+    use QFuture in your applications.
+
+    If you want to modify a sequence in-place, use QtConcurrent::map(). The
+    map function must then be of the form:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 2
+
+    Note that the return value and return type of the map function are not
+    used.
+
+    Using QtConcurrent::map() is similar to using QtConcurrent::mapped():
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 3
+
+    Since the sequence is modified in place, QtConcurrent::map() does not
+    return any results via QFuture. However, you can still use QFuture and
+    QFutureWatcher to monitor the status of the map.
+
+    \section1 Concurrent Map-Reduce
+
+    QtConcurrent::mappedReduced() is similar to QtConcurrent::mapped(), but
+    instead of returning a sequence with the new results, the results are
+    combined into a single value using a reduce function.
+
+    The reduce function must be of the form:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 4
+
+    T is the type of the final result, U is the return type of the map
+    function. Note that the return value and return type of the reduce
+    function are not used.
+
+    Call QtConcurrent::mappedReduced() like this:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 5
+
+    The reduce function will be called once for each result returned by the map
+    function, and should merge the \e{intermediate} into the \e{result}
+    variable.  QtConcurrent::mappedReduced() guarantees that only one thread
+    will call reduce at a time, so using a mutex to lock the result variable
+    is not necessary. The QtConcurrent::ReduceOptions enum provides a way to
+    control the order in which the reduction is done. If
+    QtConcurrent::UnorderedReduce is used (the default), the order is
+    undefined, while QtConcurrent::OrderedReduce ensures that the reduction
+    is done in the order of the original sequence.
+
+    \section1 Additional API Features
+
+    \section2 Using Iterators instead of Sequence
+
+    Each of the above functions has a variant that takes an iterator range
+    instead of a sequence. You use them in the same way as the sequence
+    variants:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 6
+
+    \section2 Blocking Variants
+
+    Each of the above functions has a blocking variant that returns
+    the final result instead of a QFuture. You use them in the same
+    way as the asynchronous variants.
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 7
+
+    Note that the result types above are not QFuture objects, but real result
+    types (in this case, QList<QImage> and QImage).
+
+    \section2 Using Member Functions
+
+    QtConcurrent::map(), QtConcurrent::mapped(), and
+    QtConcurrent::mappedReduced() accept pointers to member functions.
+    The member function class type must match the type stored in the sequence:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 8
+
+    Note that when using QtConcurrent::mappedReduced(), you can mix the use of
+    normal and member functions freely:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 9
+
+    \section2 Using Function Objects
+
+    QtConcurrent::map(), QtConcurrent::mapped(), and
+    QtConcurrent::mappedReduced() accept function objects, which can be used to
+    add state to a function call. The result_type typedef must define the 
+    result type of the function call operator:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 14
+
+    \section2 Using Bound Function Arguments
+
+    Note that Qt does not provide support for bound functions. This is
+    provided by 3rd party libraries like
+    \l{http://www.boost.org/libs/bind/bind.html}{Boost} or
+    \l{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf}{C++
+    TR1 Library Extensions}.
+
+    If you want to use a map function that takes more than one argument you can
+    use boost::bind() or std::tr1::bind() to transform it onto a function that
+    takes one argument.
+
+    As an example, we'll use QImage::scaledToWidth():
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 10
+
+    scaledToWidth takes three arguments (including the "this" pointer) and
+    can't be used with QtConcurrent::mapped() directly, because
+    QtConcurrent::mapped() expects a function that takes one argument. To use
+    QImage::scaledToWidth() with QtConcurrent::mapped() we have to provide a
+    value for the \e{width} and the \e{transformation mode}:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 11
+
+    The return value from boost::bind() is a function object (functor) with
+    the following signature:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 12
+
+    This matches what QtConcurrent::mapped() expects, and the complete example
+    becomes:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 13
+*/
+
+/*!
+    \fn QFuture<void> QtConcurrent::map(Sequence &sequence, MapFunction function)
+    \relates <QtConcurrentMap>
+
+    Calls \a function once for each item in \a sequence. The \a function is
+    passed a reference to the item, so that any modifications done to the item
+    will appear in \a sequence.
+*/
+
+/*!
+    \fn QFuture<void> QtConcurrent::map(Iterator begin, Iterator end, MapFunction function)
+    \relates <QtConcurrentMap>
+
+    Calls \a function once for each item from \a begin to \a end. The
+    \a function is passed a reference to the item, so that any modifications
+    done to the item will appear in the sequence which the iterators belong to.
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::mapped(const Sequence &sequence, MapFunction function)
+    \relates <QtConcurrentMap>
+
+    Calls \a function once for each item in \a sequence and returns a future
+    with each mapped item as a result. You can use QFuture::const_iterator or
+    QFutureIterator to iterate through the results.
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::mapped(ConstIterator begin, ConstIterator end, MapFunction function)
+    \relates <QtConcurrentMap>
+
+    Calls \a function once for each item from \a begin to \a end and returns a
+    future with each mapped item as a result. You can use
+    QFuture::const_iterator or QFutureIterator to iterate through the results.
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::mappedReduced(const Sequence &sequence,
+    MapFunction mapFunction, ReduceFunction reduceFunction,
+    QtConcurrent::ReduceOptions reduceOptions)
+
+    \relates <QtConcurrentMap>
+
+    Calls \a mapFunction once for each item in \a sequence. The return value of
+    each \a mapFunction is passed to \a reduceFunction.
+
+    Note that while \a mapFunction is called concurrently, only one thread at a
+    time will call \a reduceFunction. The order in which \a reduceFunction is
+    called is determined by \a reduceOptions.
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::mappedReduced(ConstIterator begin,
+    ConstIterator end, MapFunction mapFunction, ReduceFunction reduceFunction,
+    QtConcurrent::ReduceOptions reduceOptions)
+
+    \relates <QtConcurrentMap>
+
+    Calls \a mapFunction once for each item from \a begin to \a end. The return
+    value of each \a mapFunction is passed to \a reduceFunction.
+
+    Note that while \a mapFunction is called concurrently, only one thread at a
+    time will call \a reduceFunction. By default, the order in which
+    \a reduceFunction is called is undefined.
+
+    \note QtConcurrent::OrderedReduce results in the ordered reduction.
+*/
+
+/*!
+  \fn void QtConcurrent::blockingMap(Sequence &sequence, MapFunction function)
+
+  Calls \a function once for each item in \a sequence. The \a function is
+  passed a reference to the item, so that any modifications done to the item
+  will appear in \a sequence.
+
+  \note This function will block until all items in the sequence have been processed.
+
+  \sa map()
+*/
+
+/*!
+  \fn void QtConcurrent::blockingMap(Iterator begin, Iterator end, MapFunction function)
+
+  Calls \a function once for each item from \a begin to \a end. The
+  \a function is passed a reference to the item, so that any modifications
+  done to the item will appear in the sequence which the iterators belong to.
+
+  \note This function will block until the iterator reaches the end of the
+  sequence being processed.
+
+  \sa map()
+*/
+
+/*!
+  \fn T QtConcurrent::blockingMapped(const Sequence &sequence, MapFunction function)
+
+  Calls \a function once for each item in \a sequence and returns a Sequence containing
+  the results. The type of the results will match the type returned my the MapFunction.
+
+  \note This function will block until all items in the sequence have been processed.
+
+  \sa mapped()
+*/
+
+/*!
+  \fn T QtConcurrent::blockingMapped(ConstIterator begin, ConstIterator end, MapFunction function)
+
+  Calls \a function once for each item from \a begin to \a end and returns a
+  container with the results. Specify the type of container as the a template
+  argument, like this:
+  
+  \code
+     QList<int> ints = QtConcurrent::blockingMapped<QList<int> >(beginIterator, endIterator, fn);
+  \endcode
+
+  \note This function will block until the iterator reaches the end of the
+  sequence being processed.
+
+  \sa mapped()
+*/
+
+/*!
+  \fn T QtConcurrent::blockingMappedReduced(const Sequence &sequence, MapFunction mapFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
+
+  \relates <QtConcurrentMap>
+
+  Calls \a mapFunction once for each item in \a sequence. The return value of
+  each \a mapFunction is passed to \a reduceFunction.
+
+  Note that while \a mapFunction is called concurrently, only one thread at a
+  time will call \a reduceFunction. The order in which \a reduceFunction is
+  called is determined by \a reduceOptions.
+
+  \note This function will block until all items in the sequence have been processed.
+
+  \sa mapped()
+*/
+
+/*!
+  \fn T QtConcurrent::blockingMappedReduced(ConstIterator begin, ConstIterator end, MapFunction mapFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
+
+  \relates <QtConcurrentMap>
+
+  Calls \a mapFunction once for each item from \a begin to \a end. The return
+  value of each \a mapFunction is passed to \a reduceFunction.
+
+  Note that while \a mapFunction is called concurrently, only one thread at a
+  time will call \a reduceFunction. The order in which \a reduceFunction is
+  called is undefined.
+
+  \note This function will block until the iterator reaches the end of the
+  sequence being processed.
+
+  \sa blockingMappedReduced()
+*/
diff --git a/src/concurrent/qtconcurrentmap.h b/src/concurrent/qtconcurrentmap.h
new file mode 100644
index 0000000..8a55571
--- /dev/null
+++ b/src/concurrent/qtconcurrentmap.h
@@ -0,0 +1,319 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_MAP_H
+#define QTCONCURRENT_MAP_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtConcurrent/qtconcurrentmapkernel.h>
+#include <QtConcurrent/qtconcurrentreducekernel.h>
+#include <QtConcurrent/qtconcurrentfunctionwrappers.h>
+#include <QtCore/qstringlist.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifdef qdoc
+
+namespace QtConcurrent {
+
+    QFuture<void> map(Sequence &sequence, MapFunction function);
+    QFuture<void> map(Iterator begin, Iterator end, MapFunction function);
+
+    template <typename T>
+    QFuture<T> mapped(const Sequence &sequence, MapFunction function);
+    template <typename T>
+    QFuture<T> mapped(ConstIterator begin, ConstIterator end, MapFunction function);
+
+    template <typename T>
+    QFuture<T> mappedReduced(const Sequence &sequence,
+                             MapFunction function,
+                             ReduceFunction function,
+                             QtConcurrent::ReduceOptions options = UnorderedReduce | SequentialReduce);
+    template <typename T>
+    QFuture<T> mappedReduced(ConstIterator begin,
+                             ConstIterator end,
+                             MapFunction function,
+                             ReduceFunction function,
+                             QtConcurrent::ReduceOptions options = UnorderedReduce | SequentialReduce);
+
+    void blockingMap(Sequence &sequence, MapFunction function);
+    void blockingMap(Iterator begin, Iterator end, MapFunction function);
+
+    template <typename T>
+    T blockingMapped(const Sequence &sequence, MapFunction function);
+    template <typename T>
+    T blockingMapped(ConstIterator begin, ConstIterator end, MapFunction function);
+
+    template <typename T>
+    T blockingMappedReduced(const Sequence &sequence,
+                            MapFunction function,
+                            ReduceFunction function,
+                            QtConcurrent::ReduceOptions options = UnorderedReduce | SequentialReduce);
+    template <typename T>
+    T blockingMappedReduced(ConstIterator begin,
+                            ConstIterator end,
+                            MapFunction function,
+                            ReduceFunction function,
+                            QtConcurrent::ReduceOptions options = UnorderedReduce | SequentialReduce);
+
+} // namespace QtConcurrent
+
+#else
+
+namespace QtConcurrent {
+
+// map() on sequences
+template <typename Sequence, typename MapFunctor>
+QFuture<void> map(Sequence &sequence, MapFunctor map)
+{
+    return startMap(sequence.begin(), sequence.end(), QtPrivate::createFunctionWrapper(map));
+}
+
+// map() on iterators
+template <typename Iterator, typename MapFunctor>
+QFuture<void> map(Iterator begin, Iterator end, MapFunctor map)
+{
+    return startMap(begin, end, QtPrivate::createFunctionWrapper(map));
+}
+
+// mappedReduced() for sequences.
+template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
+QFuture<ResultType> mappedReduced(const Sequence &sequence,
+                                  MapFunctor map,
+                                  ReduceFunctor reduce,
+                                  ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, ResultType>
+        (sequence,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::createFunctionWrapper(reduce),
+         options);
+}
+
+template <typename Sequence, typename MapFunctor, typename ReduceFunctor>
+QFuture<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType> mappedReduced(const Sequence &sequence,
+                                  MapFunctor map,
+                                  ReduceFunctor reduce,
+                                  ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
+        (sequence,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::createFunctionWrapper(reduce),
+         options);
+}
+
+// mappedReduced() for iterators
+template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
+QFuture<ResultType> mappedReduced(Iterator begin,
+                                  Iterator end,
+                                  MapFunctor map,
+                                  ReduceFunctor reduce,
+                                  ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, ResultType>
+        (begin, end,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::createFunctionWrapper(reduce),
+         options);
+}
+
+template <typename Iterator, typename MapFunctor, typename ReduceFunctor>
+QFuture<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType> mappedReduced(Iterator begin,
+                                  Iterator end,
+                                  MapFunctor map,
+                                  ReduceFunctor reduce,
+                                  ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
+        (begin, end,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::createFunctionWrapper(reduce),
+         options);
+}
+
+// mapped() for sequences
+template <typename Sequence, typename MapFunctor>
+QFuture<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType> mapped(const Sequence &sequence, MapFunctor map)
+{
+    return startMapped<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType>(sequence, QtPrivate::createFunctionWrapper(map));
+}
+
+// mapped() for iterator ranges.
+template <typename Iterator, typename MapFunctor>
+QFuture<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType> mapped(Iterator begin, Iterator end, MapFunctor map)
+{
+    return startMapped<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType>(begin, end, QtPrivate::createFunctionWrapper(map));
+}
+
+// blockingMap() for sequences
+template <typename Sequence, typename MapFunctor>
+void blockingMap(Sequence &sequence, MapFunctor map)
+{
+    startMap(sequence.begin(), sequence.end(), QtPrivate::createFunctionWrapper(map)).startBlocking();
+}
+
+// blockingMap() for iterator ranges
+template <typename Iterator, typename MapFunctor>
+void blockingMap(Iterator begin, Iterator end, MapFunctor map)
+{
+    startMap(begin, end, QtPrivate::createFunctionWrapper(map)).startBlocking();
+}
+
+// blockingMappedReduced() for sequences
+template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
+ResultType blockingMappedReduced(const Sequence &sequence,
+                                 MapFunctor map,
+                                 ReduceFunctor reduce,
+                                 ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return QtConcurrent::startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, ResultType>
+        (sequence,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::createFunctionWrapper(reduce),
+         options)
+        .startBlocking();
+}
+
+template <typename MapFunctor, typename ReduceFunctor, typename Sequence>
+typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType blockingMappedReduced(const Sequence &sequence,
+                                 MapFunctor map,
+                                 ReduceFunctor reduce,
+                                 ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
+{
+    return QtConcurrent::startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
+        (sequence,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::createFunctionWrapper(reduce),
+         options)
+        .startBlocking();
+}
+
+// blockingMappedReduced() for iterator ranges
+template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
+ResultType blockingMappedReduced(Iterator begin,
+                                 Iterator end,
+                                 MapFunctor map,
+                                 ReduceFunctor reduce,
+                                 QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
+{
+    return QtConcurrent::startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, ResultType>
+        (begin, end,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::createFunctionWrapper(reduce),
+         options)
+        .startBlocking();
+}
+
+template <typename Iterator, typename MapFunctor, typename ReduceFunctor>
+typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType blockingMappedReduced(Iterator begin,
+                                 Iterator end,
+                                 MapFunctor map,
+                                 ReduceFunctor reduce,
+                                 QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
+{
+    return QtConcurrent::startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
+        (begin, end,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::createFunctionWrapper(reduce),
+         options)
+        .startBlocking();
+}
+
+// mapped() for sequences with a different putput sequence type.
+template <typename OutputSequence, typename InputSequence, typename MapFunctor>
+OutputSequence blockingMapped(const InputSequence &sequence, MapFunctor map)
+{
+    return blockingMappedReduced<OutputSequence>
+        (sequence,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::PushBackWrapper(),
+         QtConcurrent::OrderedReduce);
+}
+
+template <typename MapFunctor, typename InputSequence>
+typename QtPrivate::MapResultType<InputSequence, MapFunctor>::ResultType blockingMapped(const InputSequence &sequence, MapFunctor map)
+{
+    typedef typename QtPrivate::MapResultType<InputSequence, MapFunctor>::ResultType OutputSequence;
+    return blockingMappedReduced<OutputSequence>
+        (sequence,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::PushBackWrapper(),
+         QtConcurrent::OrderedReduce);
+}
+
+// mapped()  for iterator ranges
+template <typename Sequence, typename Iterator, typename MapFunctor>
+Sequence blockingMapped(Iterator begin, Iterator end, MapFunctor map)
+{
+    return blockingMappedReduced<Sequence>
+        (begin, end,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::PushBackWrapper(),
+         QtConcurrent::OrderedReduce);
+}
+
+template <typename Iterator, typename MapFunctor>
+typename QtPrivate::MapResultType<Iterator, MapFunctor>::ResultType blockingMapped(Iterator begin, Iterator end, MapFunctor map)
+{
+    typedef typename QtPrivate::MapResultType<Iterator, MapFunctor>::ResultType OutputSequence;
+    return blockingMappedReduced<OutputSequence>
+        (begin, end,
+         QtPrivate::createFunctionWrapper(map),
+         QtPrivate::PushBackWrapper(),
+         QtConcurrent::OrderedReduce);
+}
+
+} // namespace QtConcurrent
+
+#endif // qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentmapkernel.h b/src/concurrent/qtconcurrentmapkernel.h
new file mode 100644
index 0000000..ceeaa6e
--- /dev/null
+++ b/src/concurrent/qtconcurrentmapkernel.h
@@ -0,0 +1,272 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_MAPKERNEL_H
+#define QTCONCURRENT_MAPKERNEL_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtConcurrent/qtconcurrentiteratekernel.h>
+#include <QtConcurrent/qtconcurrentreducekernel.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifndef qdoc
+namespace QtConcurrent {
+
+// map kernel, works with both parallel-for and parallel-while
+template <typename Iterator, typename MapFunctor>
+class MapKernel : public IterateKernel<Iterator, void>
+{
+    MapFunctor map;
+public:
+    typedef void ReturnType;
+    MapKernel(Iterator begin, Iterator end, MapFunctor _map)
+        : IterateKernel<Iterator, void>(begin, end), map(_map)
+    { }
+
+    bool runIteration(Iterator it, int, void *)
+    {
+        map(*it);
+        return false;
+    }
+
+    bool runIterations(Iterator sequenceBeginIterator, int beginIndex, int endIndex, void *)
+    {
+        Iterator it = sequenceBeginIterator;
+        advance(it, beginIndex);
+        for (int i = beginIndex; i < endIndex; ++i) {
+            runIteration(it, i, 0);
+            advance(it, 1);
+        }
+       
+        return false;
+    }
+};
+
+template <typename ReducedResultType,
+          typename Iterator,
+          typename MapFunctor,
+          typename ReduceFunctor,
+          typename Reducer = ReduceKernel<ReduceFunctor,
+                                          ReducedResultType,
+                                          typename MapFunctor::result_type> >
+class MappedReducedKernel : public IterateKernel<Iterator, ReducedResultType>
+{
+    ReducedResultType reducedResult;
+    MapFunctor map;
+    ReduceFunctor reduce;
+    Reducer reducer;
+public:
+    typedef ReducedResultType ReturnType;
+    MappedReducedKernel(Iterator begin, Iterator end, MapFunctor _map, ReduceFunctor _reduce, ReduceOptions reduceOptions)
+        : IterateKernel<Iterator, ReducedResultType>(begin, end), reducedResult(), map(_map), reduce(_reduce), reducer(reduceOptions)
+    { }
+
+    MappedReducedKernel(ReducedResultType initialValue,
+                     MapFunctor _map,
+                     ReduceFunctor _reduce)
+        : reducedResult(initialValue), map(_map), reduce(_reduce)
+    { }
+
+    bool runIteration(Iterator it, int index, ReducedResultType *)
+    {
+        IntermediateResults<typename MapFunctor::result_type> results;
+        results.begin = index;
+        results.end = index + 1;
+
+        results.vector.append(map(*it));
+        reducer.runReduce(reduce, reducedResult, results);
+        return false;
+    }
+
+    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, ReducedResultType *)
+    {
+        IntermediateResults<typename MapFunctor::result_type> results;
+        results.begin = begin;
+        results.end = end;
+        results.vector.reserve(end - begin);
+
+        Iterator it = sequenceBeginIterator;
+        advance(it, begin);
+        for (int i = begin; i < end; ++i) {
+            results.vector.append(map(*(it)));
+            advance(it, 1);
+        }
+
+        reducer.runReduce(reduce, reducedResult, results);
+        return false;
+    }
+
+    void finish()
+    {
+        reducer.finish(reduce, reducedResult);
+    }
+
+    bool shouldThrottleThread()
+    {
+        return IterateKernel<Iterator, ReducedResultType>::shouldThrottleThread() || reducer.shouldThrottle();
+    }
+
+    bool shouldStartThread()
+    {
+        return IterateKernel<Iterator, ReducedResultType>::shouldStartThread() && reducer.shouldStartThread();
+    }
+
+    typedef ReducedResultType ResultType;
+    ReducedResultType *result()
+    {
+        return &reducedResult;
+    }
+};
+
+template <typename Iterator, typename MapFunctor>
+class MappedEachKernel : public IterateKernel<Iterator, typename MapFunctor::result_type>
+{
+    MapFunctor map;
+    typedef typename MapFunctor::result_type T;
+public:
+    typedef T ReturnType;
+    typedef T ResultType;
+
+    MappedEachKernel(Iterator begin, Iterator end, MapFunctor _map)
+        : IterateKernel<Iterator, T>(begin, end), map(_map) { }
+
+    bool runIteration(Iterator it, int,  T *result)
+    {
+        *result = map(*it);
+        return true;
+    }
+
+    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, T *results)
+    {
+
+        Iterator it = sequenceBeginIterator;
+        advance(it, begin);
+        for (int i = begin; i < end; ++i) {
+            runIteration(it, i, results + (i - begin));
+            advance(it, 1);
+        }
+
+        return true;
+    }
+};
+
+template <typename Iterator, typename Functor>
+inline ThreadEngineStarter<void> startMap(Iterator begin, Iterator end, Functor functor)
+{
+    return startThreadEngine(new MapKernel<Iterator, Functor>(begin, end, functor));
+}
+
+template <typename T, typename Iterator, typename Functor>
+inline ThreadEngineStarter<T> startMapped(Iterator begin, Iterator end, Functor functor)
+{
+    return startThreadEngine(new MappedEachKernel<Iterator, Functor>(begin, end, functor));
+}
+
+/*
+    The SequnceHolder class is used to hold a reference to the
+    sequence we are working on.
+*/
+template <typename Sequence, typename Base, typename Functor>
+struct SequenceHolder1 : public Base
+{
+    SequenceHolder1(const Sequence &_sequence, Functor functor)
+        : Base(_sequence.begin(), _sequence.end(), functor), sequence(_sequence)
+    { }
+
+    Sequence sequence;
+
+    void finish()
+    {
+        Base::finish();
+        // Clear the sequence to make sure all temporaries are destroyed
+        // before finished is signaled.
+        sequence = Sequence();
+    }
+};
+
+template <typename T, typename Sequence, typename Functor>
+inline ThreadEngineStarter<T> startMapped(const Sequence &sequence, Functor functor)
+{
+    typedef SequenceHolder1<Sequence,
+                            MappedEachKernel<typename Sequence::const_iterator , Functor>, Functor>
+                            SequenceHolderType;
+
+    return startThreadEngine(new SequenceHolderType(sequence, functor));
+}
+
+template <typename IntermediateType, typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
+inline ThreadEngineStarter<ResultType> startMappedReduced(const Sequence & sequence,
+                                                           MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
+                                                           ReduceOptions options)
+{
+    typedef typename Sequence::const_iterator Iterator;
+    typedef ReduceKernel<ReduceFunctor, ResultType, IntermediateType> Reducer;
+    typedef MappedReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> MappedReduceType;
+    typedef SequenceHolder2<Sequence, MappedReduceType, MapFunctor, ReduceFunctor> SequenceHolderType;
+    return startThreadEngine(new SequenceHolderType(sequence, mapFunctor, reduceFunctor, options));
+}
+
+template <typename IntermediateType, typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
+inline ThreadEngineStarter<ResultType> startMappedReduced(Iterator begin, Iterator end,
+                                                           MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
+                                                           ReduceOptions options)
+{
+    typedef ReduceKernel<ReduceFunctor, ResultType, IntermediateType> Reducer;
+    typedef MappedReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> MappedReduceType;
+    return startThreadEngine(new MappedReduceType(begin, end, mapFunctor, reduceFunctor, options));
+}
+
+} // namespace QtConcurrent
+
+#endif //qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentmedian.h b/src/concurrent/qtconcurrentmedian.h
new file mode 100644
index 0000000..78fc3d9
--- /dev/null
+++ b/src/concurrent/qtconcurrentmedian.h
@@ -0,0 +1,129 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_MEDIAN_H
+#define QTCONCURRENT_MEDIAN_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtCore/qvector.h>
+#include <QtCore/qalgorithms.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifndef qdoc
+
+namespace QtConcurrent {
+
+template <typename T>
+class Median
+{
+public:
+    Median(int _bufferSize)
+        : currentMedian(), bufferSize(_bufferSize), currentIndex(0), valid(false), dirty(true)
+    {
+        values.resize(bufferSize);
+    }
+
+    void reset()
+    {
+        values.fill(0);
+        currentIndex = 0;
+        valid = false;
+        dirty = true;
+    }
+
+    void addValue(T value)
+    {
+        currentIndex = ((currentIndex + 1) % bufferSize);
+        if (valid == false && currentIndex % bufferSize == 0)
+            valid = true;
+
+        // Only update the cached median value when we have to, that
+        // is when the new value is on then other side of the median
+        // compared to the current value at the index.
+        const T currentIndexValue = values[currentIndex];
+        if ((currentIndexValue > currentMedian && currentMedian > value)
+            || (currentMedian > currentIndexValue && value > currentMedian)) {
+            dirty = true;
+        }
+
+        values[currentIndex] = value;
+    }
+
+    bool isMedianValid() const
+    {
+        return valid;
+    }
+
+    T median()
+    {
+        if (dirty) {
+            dirty = false;
+            QVector<T> sorted = values;
+            qSort(sorted);
+            currentMedian = sorted.at(bufferSize / 2 + 1);
+        }
+        return currentMedian;
+    }
+private:
+    QVector<T> values;
+    T currentMedian;
+    int bufferSize;
+    int currentIndex;
+    bool valid;
+    bool dirty;
+};
+
+} // namespace QtConcurrent
+
+#endif //qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentreducekernel.h b/src/concurrent/qtconcurrentreducekernel.h
new file mode 100644
index 0000000..ddf5629
--- /dev/null
+++ b/src/concurrent/qtconcurrentreducekernel.h
@@ -0,0 +1,254 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_REDUCEKERNEL_H
+#define QTCONCURRENT_REDUCEKERNEL_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtCore/qatomic.h>
+#include <QtCore/qlist.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qmutex.h>
+#include <QtCore/qthread.h>
+#include <QtCore/qthreadpool.h>
+#include <QtCore/qvector.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+namespace QtConcurrent {
+
+#ifndef qdoc
+
+/*
+    The ReduceQueueStartLimit and ReduceQueueThrottleLimit constants
+    limit the reduce queue size for MapReduce. When the number of
+    reduce blocks in the queue exceeds ReduceQueueStartLimit,
+    MapReduce won't start any new threads, and when it exceeds
+    ReduceQueueThrottleLimit running threads will be stopped.
+*/
+enum {
+    ReduceQueueStartLimit = 20,
+    ReduceQueueThrottleLimit = 30
+};
+
+// IntermediateResults holds a block of intermediate results from a
+// map or filter functor. The begin/end offsets indicates the origin
+// and range of the block.
+template <typename T>
+class IntermediateResults
+{
+public:
+    int begin, end;
+    QVector<T> vector;
+};
+
+#endif // qdoc
+
+enum ReduceOption {
+    UnorderedReduce = 0x1,
+    OrderedReduce = 0x2,
+    SequentialReduce = 0x4
+    // ParallelReduce = 0x8
+};
+Q_DECLARE_FLAGS(ReduceOptions, ReduceOption)
+Q_DECLARE_OPERATORS_FOR_FLAGS(ReduceOptions)
+
+#ifndef qdoc
+
+// supports both ordered and out-of-order reduction
+template <typename ReduceFunctor, typename ReduceResultType, typename T>
+class ReduceKernel
+{
+    typedef QMap<int, IntermediateResults<T> > ResultsMap;
+
+    const ReduceOptions reduceOptions;
+
+    QMutex mutex;
+    int progress, resultsMapSize, threadCount;
+    ResultsMap resultsMap;
+
+    bool canReduce(int begin) const
+    {
+        return (((reduceOptions & UnorderedReduce)
+                 && progress == 0)
+                || ((reduceOptions & OrderedReduce)
+                    && progress == begin));
+    }
+
+    void reduceResult(ReduceFunctor &reduce,
+                      ReduceResultType &r,
+                      const IntermediateResults<T> &result)
+    {
+        for (int i = 0; i < result.vector.size(); ++i) {
+            reduce(r, result.vector.at(i));
+        }
+    }
+
+    void reduceResults(ReduceFunctor &reduce,
+                       ReduceResultType &r,
+                       ResultsMap &map)
+    {
+        typename ResultsMap::iterator it = map.begin();
+        while (it != map.end()) {
+            reduceResult(reduce, r, it.value());
+            ++it;
+        }
+    }
+
+public:
+    ReduceKernel(ReduceOptions _reduceOptions)
+        : reduceOptions(_reduceOptions), progress(0), resultsMapSize(0), 
+          threadCount(QThreadPool::globalInstance()->maxThreadCount())
+    { }
+
+    void runReduce(ReduceFunctor &reduce,
+                   ReduceResultType &r,
+                   const IntermediateResults<T> &result)
+    {
+        QMutexLocker locker(&mutex);
+        if (!canReduce(result.begin)) {
+            ++resultsMapSize;
+            resultsMap.insert(result.begin, result);
+            return;
+        }
+
+        if (reduceOptions & UnorderedReduce) {
+            // UnorderedReduce
+            progress = -1;
+
+            // reduce this result
+            locker.unlock();
+            reduceResult(reduce, r, result);
+            locker.relock();
+
+            // reduce all stored results as well
+            while (!resultsMap.isEmpty()) {
+                ResultsMap resultsMapCopy = resultsMap;
+                resultsMap.clear();
+
+                locker.unlock();
+                reduceResults(reduce, r, resultsMapCopy);
+                locker.relock();
+
+                resultsMapSize -= resultsMapCopy.size();
+            }
+
+            progress = 0;
+        } else {
+            // reduce this result
+            locker.unlock();
+            reduceResult(reduce, r, result);
+            locker.relock();
+
+            // OrderedReduce
+            progress += result.end - result.begin;
+
+            // reduce as many other results as possible
+            typename ResultsMap::iterator it = resultsMap.begin();
+            while (it != resultsMap.end()) {
+                if (it.value().begin != progress)
+                    break;
+
+                locker.unlock();
+                reduceResult(reduce, r, it.value());
+                locker.relock();
+
+                --resultsMapSize;
+                progress += it.value().end - it.value().begin;
+                it = resultsMap.erase(it);
+            }
+        }
+    }
+
+    // final reduction
+    void finish(ReduceFunctor &reduce, ReduceResultType &r)
+    {
+        reduceResults(reduce, r, resultsMap);
+    }
+
+    inline bool shouldThrottle()
+    {
+        return (resultsMapSize > (ReduceQueueThrottleLimit * threadCount));
+    }
+
+    inline bool shouldStartThread()
+    {
+        return (resultsMapSize <= (ReduceQueueStartLimit * threadCount));
+    }
+};
+
+template <typename Sequence, typename Base, typename Functor1, typename Functor2>
+struct SequenceHolder2 : public Base
+{
+    SequenceHolder2(const Sequence &_sequence,
+                    Functor1 functor1,
+                    Functor2 functor2,
+                    ReduceOptions reduceOptions)
+        : Base(_sequence.begin(), _sequence.end(), functor1, functor2, reduceOptions),
+          sequence(_sequence)
+    { }
+
+    Sequence sequence;
+
+    void finish()
+    {
+        Base::finish();
+        // Clear the sequence to make sure all temporaries are destroyed
+        // before finished is signaled.
+        sequence = Sequence();
+    }
+};
+
+#endif //qdoc
+
+} // namespace QtConcurrent
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentresultstore.cpp b/src/concurrent/qtconcurrentresultstore.cpp
new file mode 100644
index 0000000..64de864
--- /dev/null
+++ b/src/concurrent/qtconcurrentresultstore.cpp
@@ -0,0 +1,256 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qtconcurrentresultstore.h"
+
+#ifndef QT_NO_QFUTURE
+
+QT_BEGIN_NAMESPACE
+
+namespace QtConcurrent {
+
+ResultIteratorBase::ResultIteratorBase()
+ : mapIterator(QMap<int, ResultItem>::const_iterator()), m_vectorIndex(0) { }
+ResultIteratorBase::ResultIteratorBase(QMap<int, ResultItem>::const_iterator _mapIterator, int _vectorIndex)
+ : mapIterator(_mapIterator), m_vectorIndex(_vectorIndex) { }
+
+int ResultIteratorBase::vectorIndex() const { return m_vectorIndex; }
+int ResultIteratorBase::resultIndex() const { return mapIterator.key() + m_vectorIndex; }
+
+ResultIteratorBase ResultIteratorBase::operator++()
+{
+    if (canIncrementVectorIndex()) {
+        ++m_vectorIndex;
+    } else {
+        ++mapIterator;
+        m_vectorIndex = 0;
+    }
+    return *this;
+}
+
+int ResultIteratorBase::batchSize() const
+{
+    return mapIterator.value().count();
+}
+
+void ResultIteratorBase::batchedAdvance()
+{
+    ++mapIterator;
+    m_vectorIndex = 0;
+}
+
+bool ResultIteratorBase::operator==(const ResultIteratorBase &other) const
+{
+    return (mapIterator == other.mapIterator && m_vectorIndex == other.m_vectorIndex);
+}
+
+bool ResultIteratorBase::operator!=(const ResultIteratorBase &other) const
+{
+    return !operator==(other);
+}
+
+bool ResultIteratorBase::isVector() const
+{
+    return mapIterator.value().isVector();
+}
+
+bool ResultIteratorBase::canIncrementVectorIndex() const
+{
+    return (m_vectorIndex + 1 < mapIterator.value().m_count);
+}
+
+ResultStoreBase::ResultStoreBase() 
+    : insertIndex(0), resultCount(0), m_filterMode(false), filteredResults(0) { }
+
+void ResultStoreBase::setFilterMode(bool enable)
+{
+    m_filterMode = enable;
+}
+
+bool ResultStoreBase::filterMode() const
+{
+    return m_filterMode;
+}
+
+void ResultStoreBase::syncResultCount()
+{
+    ResultIteratorBase it = resultAt(resultCount);
+    while (it != end()) {
+        resultCount += it.batchSize();
+        it = resultAt(resultCount);
+    }
+}
+
+void ResultStoreBase::insertResultItemIfValid(int index, ResultItem &resultItem)
+{
+    if (resultItem.isValid()) {
+        m_results[index] = resultItem;
+        syncResultCount();
+    } else {
+        filteredResults += resultItem.count();
+    }
+}
+
+int ResultStoreBase::insertResultItem(int index, ResultItem &resultItem)
+{
+    int storeIndex;
+    if (m_filterMode && index != -1 && index > insertIndex) {
+        pendingResults[index] = resultItem;
+        storeIndex = index;
+    } else {
+        storeIndex = updateInsertIndex(index, resultItem.count());
+        insertResultItemIfValid(storeIndex - filteredResults, resultItem);
+    }
+    syncPendingResults();
+    return storeIndex;
+}
+
+void ResultStoreBase::syncPendingResults()
+{
+    // check if we can insert any of the pending results:
+    QMap<int, ResultItem>::iterator it = pendingResults.begin();
+    while (it != pendingResults.end()) {
+        int index = it.key(); 
+        if (index != resultCount + filteredResults)
+            break;
+
+        ResultItem result = it.value();
+        insertResultItemIfValid(index - filteredResults, result);
+        pendingResults.erase(it);
+        it = pendingResults.begin();
+    }
+}
+
+int ResultStoreBase::addResult(int index, const void *result)
+{
+    ResultItem resultItem(result, 0); // 0 means "not a vector"
+    return insertResultItem(index, resultItem);
+}
+
+int ResultStoreBase::addResults(int index, const void *results, int vectorSize, int totalCount) 
+{
+    if (m_filterMode == false || vectorSize == totalCount) {
+        ResultItem resultItem(results, vectorSize);
+        return insertResultItem(index, resultItem);
+    } else {
+        if (vectorSize > 0) {
+            ResultItem filteredIn(results, vectorSize);
+            insertResultItem(index, filteredIn);
+        }
+        ResultItem filteredAway(0, totalCount - vectorSize);
+        return insertResultItem(index + vectorSize, filteredAway);
+    }
+}
+
+ResultIteratorBase ResultStoreBase::begin() const
+{
+    return ResultIteratorBase(m_results.begin());
+}
+
+ResultIteratorBase ResultStoreBase::end() const
+{
+    return ResultIteratorBase(m_results.end());
+}
+
+bool ResultStoreBase::hasNextResult() const
+{
+    return begin() != end();
+}
+
+ResultIteratorBase ResultStoreBase::resultAt(int index) const
+{
+    if (m_results.isEmpty())
+        return ResultIteratorBase(m_results.end());
+    QMap<int, ResultItem>::const_iterator it = m_results.lowerBound(index);
+
+    // lowerBound returns either an iterator to the result or an iterator
+    // to the nearest greater index. If the latter happens it might be
+    // that the result is stored in a vector at the previous index.
+    if (it == m_results.end()) {
+        --it;
+        if (it.value().isVector() == false) {
+            return ResultIteratorBase(m_results.end());
+        }
+    } else {
+        if (it.key() > index) {
+            if (it == m_results.begin())
+                return ResultIteratorBase(m_results.end());
+            --it;
+        }
+    }
+
+    const int vectorIndex = index - it.key();
+    
+    if (vectorIndex >= it.value().count())
+        return ResultIteratorBase(m_results.end());
+    else if (it.value().isVector() == false && vectorIndex != 0)
+        return ResultIteratorBase(m_results.end());
+    return ResultIteratorBase(it, vectorIndex);
+}
+
+bool ResultStoreBase::contains(int index) const
+{
+    return (resultAt(index) != end());
+}
+
+int ResultStoreBase::count() const
+{
+    return resultCount;
+}
+
+// returns the insert index, calling this function with
+// index equal to -1 returns the next available index.
+int ResultStoreBase::updateInsertIndex(int index, int _count)
+{
+    if (index == -1) {
+        index = insertIndex;
+        insertIndex += _count;
+    } else {
+        insertIndex = qMax(index + _count, insertIndex);
+    }
+    return index;
+}
+
+} // namespace QtConcurrent
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_CONCURRENT
diff --git a/src/concurrent/qtconcurrentresultstore.h b/src/concurrent/qtconcurrentresultstore.h
new file mode 100644
index 0000000..d39a45b
--- /dev/null
+++ b/src/concurrent/qtconcurrentresultstore.h
@@ -0,0 +1,238 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_RESULTSTORE_H
+#define QTCONCURRENT_RESULTSTORE_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_QFUTURE
+
+#include <QtCore/qmap.h>
+#include <QtCore/qdebug.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+/*
+    ResultStore stores indexed results. Results can be added and retrieved
+    either individually batched in a QVector. Retriveing results and checking
+    which indexes are in the store can be done either by iterating or by random
+    accees. In addition results kan be removed from the front of the store,
+    either individually or in batches.
+*/
+
+#ifndef qdoc
+
+namespace QtConcurrent {
+
+class ResultItem
+{
+public:
+    ResultItem(const void *_result, int _count) : m_count(_count), result(_result) { } // contruct with vector of results
+    ResultItem(const void *_result) : m_count(0), result(_result) { } // construct with result
+    ResultItem() : m_count(0), result(0) { }
+    bool isValid() const { return result != 0; }
+    bool isVector() const { return m_count != 0; }
+    int count() const { return (m_count == 0) ?  1 : m_count; }
+    int m_count;          // result is either a pointer to a result or to a vector of results,
+    const void *result; // if count is 0 it's a result, otherwise it's a vector.
+};
+
+class Q_CORE_EXPORT ResultIteratorBase
+{
+public:
+    ResultIteratorBase();
+    ResultIteratorBase(QMap<int, ResultItem>::const_iterator _mapIterator, int _vectorIndex = 0);
+    int vectorIndex() const;
+    int resultIndex() const;
+
+    ResultIteratorBase operator++();
+    int batchSize() const;
+    void batchedAdvance();
+    bool operator==(const ResultIteratorBase &other) const;
+    bool operator!=(const ResultIteratorBase &other) const;
+    bool isVector() const;
+    bool canIncrementVectorIndex() const;
+protected:
+    QMap<int, ResultItem>::const_iterator mapIterator;
+    int m_vectorIndex;
+};
+
+template <typename T>
+class  ResultIterator : public ResultIteratorBase
+{
+public:
+    ResultIterator(const ResultIteratorBase &base)
+    : ResultIteratorBase(base) { }
+
+    const T &value() const
+    {
+        return *pointer();
+    }
+
+    const T *pointer() const
+    {
+        if (mapIterator.value().isVector())
+            return &(reinterpret_cast<const QVector<T> *>(mapIterator.value().result)->at(m_vectorIndex));
+        else
+            return reinterpret_cast<const T *>(mapIterator.value().result);
+    }
+};
+
+class Q_CORE_EXPORT ResultStoreBase
+{
+public:
+    ResultStoreBase();
+    void setFilterMode(bool enable);
+    bool filterMode() const;
+    int addResult(int index, const void *result);
+    int addResults(int index, const void *results, int vectorSize, int logicalCount);
+    ResultIteratorBase begin() const;
+    ResultIteratorBase end() const;
+    bool hasNextResult() const;
+    ResultIteratorBase resultAt(int index) const;
+    bool contains(int index) const;
+    int count() const;
+    virtual ~ResultStoreBase() { }
+
+protected:
+    int insertResultItem(int index, ResultItem &resultItem);
+    void insertResultItemIfValid(int index, ResultItem &resultItem);
+    void syncPendingResults();
+    void syncResultCount();
+    int updateInsertIndex(int index, int _count);
+
+    QMap<int, ResultItem> m_results;
+    int insertIndex;     // The index where the next results(s) will be inserted.
+    int resultCount;     // The number of consecutive results stored, starting at index 0.
+
+    bool m_filterMode;
+    QMap<int, ResultItem> pendingResults;
+    int filteredResults;
+    
+};
+
+template <typename T>
+class ResultStore : public ResultStoreBase
+{
+public:
+    ResultStore() { }
+
+    ResultStore(const ResultStoreBase &base)
+    : ResultStoreBase(base) { }
+
+    int addResult(int index, const T  *result)
+    {
+        if (result == 0)
+            return ResultStoreBase::addResult(index, result);
+        else
+            return ResultStoreBase::addResult(index, new T(*result));
+    }
+
+    int addResults(int index, const QVector<T> *results)
+    {
+        return ResultStoreBase::addResults(index, new QVector<T>(*results), results->count(), results->count());
+    }
+
+    int addResults(int index, const QVector<T> *results, int totalCount)
+    {
+        return ResultStoreBase::addResults(index, new QVector<T>(*results), results->count(), totalCount);
+    }
+
+    int addCanceledResult(int index)
+    {
+        return addResult(index, 0);
+    }
+
+    int addCanceledResults(int index, int _count)
+    {
+        QVector<T> empty;
+        return addResults(index, &empty, _count);
+    }
+
+    ResultIterator<T> begin() const
+    {
+        return static_cast<ResultIterator<T> >(ResultStoreBase::begin());
+    }
+
+    ResultIterator<T> end() const
+    {
+        return static_cast<ResultIterator<T> >(ResultStoreBase::end());
+    }
+
+    ResultIterator<T> resultAt(int index) const
+    {
+        return static_cast<ResultIterator<T> >(ResultStoreBase::resultAt(index));
+    }
+
+    void clear()
+    {
+        QMap<int, ResultItem>::const_iterator mapIterator = m_results.constBegin();
+        while (mapIterator != m_results.constEnd()) {
+            if (mapIterator.value().isVector())
+                delete reinterpret_cast<const QVector<T> *>(mapIterator.value().result);
+            else
+                delete reinterpret_cast<const T *>(mapIterator.value().result);
+            ++mapIterator;
+        }
+        resultCount = 0;
+        m_results.clear();
+    }
+
+    ~ResultStore()
+    {
+        clear();
+    }
+
+};
+
+} // namespace QtConcurrent
+
+#endif //qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentrun.cpp b/src/concurrent/qtconcurrentrun.cpp
new file mode 100644
index 0000000..e51626e
--- /dev/null
+++ b/src/concurrent/qtconcurrentrun.cpp
@@ -0,0 +1,152 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+    \headerfile <QtConcurrentRun>
+    \title Asynchronous Run
+
+    \brief The <QtConcurrentRun> header provides a way to run a function in a
+    separate thread.
+
+    \ingroup thread
+    
+    This function is a part of the \l {Concurrent Programming}{Qt Concurrent} framework.
+
+    The QtConcurrent::run() function runs a function in a separate thread.
+    The return value of the function is made available through the QFuture API.
+    
+    \section1 Running a Function in a Separate Thread
+    
+    To run a function in another thread, use QtConcurrent::run():
+    
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 0
+    
+    This will run \e aFunction in a separate thread obtained from the default
+    QThreadPool. You can use the QFuture and QFutureWatcher classes to monitor
+    the status of the function.
+    
+    \section1 Passing Arguments to the Function
+
+    Passing arguments to the function is done by adding them to the
+    QtConcurrent::run() call immediately after the function name. For example:
+    
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 1
+    
+    A copy of each argument is made at the point where QtConcurrent::run() is
+    called, and these values are passed to the thread when it begins executing
+    the function. Changes made to the arguments after calling
+    QtConcurrent::run() are \e not visible to the thread.
+    
+    \section1 Returning Values from the Function
+    
+    Any return value from the function is available via QFuture:
+    
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 2
+    
+    As documented above, passing arguments is done like this:
+    
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 3
+    
+    Note that the QFuture::result() function blocks and waits for the result
+    to become available. Use QFutureWatcher to get notification when the
+    function has finished execution and the result is available.
+    
+    \section1 Additional API Features
+    
+    \section2 Using Member Functions
+    
+    QtConcurrent::run() also accepts pointers to member functions. The first
+    argument must be either a const reference or a pointer to an instance of
+    the class. Passing by const reference is useful when calling const member
+    functions; passing by pointer is useful for calling non-const member
+    functions that modify the instance.
+    
+    For example, calling QByteArray::split() (a const member function) in a
+    separate thread is done like this:
+    
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 4
+    
+    Calling a non-const member function is done like this:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 5
+
+    \section2 Using Bound Function Arguments
+
+    Note that Qt does not provide support for bound functions. This is
+    provided by 3rd party libraries like
+    \l{http://www.boost.org/libs/bind/bind.html}{Boost} or
+    \l{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf}
+    {C++ TR1 Library Extensions}.
+    
+    You can use boost::bind() or std::tr1::bind() to \e bind a number of
+    arguments to a function when called. There are number of reasons for doing
+    this:
+    
+    \list
+    \o To call a function that takes more than 5 arguments.
+    \o To simplify calling a function with constant arguments.
+    \o Changing the order of arguments.
+    \endlist
+    
+    See the documentation for the relevant functions for details on how to use
+    the bind API.
+
+    Calling a bound function is done like this:
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 6
+*/
+
+/*!
+    \fn QFuture<T> QtConcurrent::run(Function function, ...);
+    \relates <QtConcurrentRun>
+    
+    Runs \a function in a separate thread. The thread is taken from the global
+    QThreadPool. Note that the function may not run immediately; the function
+    will only be run when a thread is available.
+    
+    T is the same type as the return value of \a function. Non-void return
+    values can be accessed via the QFuture::result() function.
+    
+    Note that the QFuture returned by QtConcurrent::run() does not support
+    canceling, pausing, or progress reporting. The QFuture returned can only
+    be used to query for the running/finished status and the return value of
+    the function.
+*/
diff --git a/src/concurrent/qtconcurrentrun.h b/src/concurrent/qtconcurrentrun.h
new file mode 100644
index 0000000..d728538
--- /dev/null
+++ b/src/concurrent/qtconcurrentrun.h
@@ -0,0 +1,347 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+// Generated code, do not edit! Use generator at tools/qtconcurrent/generaterun/
+#ifndef QTCONCURRENT_RUN_H
+#define QTCONCURRENT_RUN_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtConcurrent/qtconcurrentrunbase.h>
+#include <QtConcurrent/qtconcurrentstoredfunctioncall.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifdef qdoc
+
+namespace QtConcurrent {
+
+    template <typename T>
+    QFuture<T> run(Function function, ...);
+
+} // namespace QtConcurrent
+
+#else
+
+namespace QtConcurrent {
+
+template <typename T>
+QFuture<T> run(T (*functionPointer)())
+{
+    return (new StoredFunctorCall0<T, T (*)()>(functionPointer))->start();
+}
+template <typename T, typename Param1, typename Arg1>
+QFuture<T> run(T (*functionPointer)(Param1), const Arg1 &arg1)
+{
+    return (new StoredFunctorCall1<T, T (*)(Param1), Arg1>(functionPointer, arg1))->start();
+}
+template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2>
+QFuture<T> run(T (*functionPointer)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
+{
+    return (new StoredFunctorCall2<T, T (*)(Param1, Param2), Arg1, Arg2>(functionPointer, arg1, arg2))->start();
+}
+template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+{
+    return (new StoredFunctorCall3<T, T (*)(Param1, Param2, Param3), Arg1, Arg2, Arg3>(functionPointer, arg1, arg2, arg3))->start();
+}
+template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+{
+    return (new StoredFunctorCall4<T, T (*)(Param1, Param2, Param3, Param4), Arg1, Arg2, Arg3, Arg4>(functionPointer, arg1, arg2, arg3, arg4))->start();
+}
+template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
+{
+    return (new StoredFunctorCall5<T, T (*)(Param1, Param2, Param3, Param4, Param5), Arg1, Arg2, Arg3, Arg4, Arg5>(functionPointer, arg1, arg2, arg3, arg4, arg5))->start();
+}
+
+#ifdef Q_COMPILER_DECLTYPE
+
+template <typename Functor>
+auto run(Functor functor) -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor())> >::Type
+{
+    typedef decltype(functor()) result_type;
+    return (new StoredFunctorCall0<result_type, Functor>(functor))->start();
+}
+
+template <typename Functor, typename Arg1>
+auto run(Functor functor, const Arg1 &arg1)
+    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1))> >::Type
+{
+    typedef decltype(functor(arg1)) result_type;
+    return (new StoredFunctorCall1<result_type, Functor, Arg1>(functor, arg1))->start();
+}
+
+template <typename Functor, typename Arg1, typename Arg2>
+auto run(Functor functor, const Arg1 &arg1, const Arg2 &arg2)
+    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1, arg2))> >::Type
+{
+    typedef decltype(functor(arg1, arg2)) result_type;
+    return (new StoredFunctorCall2<result_type, Functor, Arg1, Arg2>(functor, arg1, arg2))->start();
+}
+
+template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
+auto run(Functor functor, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1, arg2, arg3))> >::Type
+{
+    typedef decltype(functor(arg1, arg2, arg3)) result_type;
+    return (new StoredFunctorCall3<result_type, Functor, Arg1, Arg2, Arg3>(functor, arg1, arg2, arg3))->start();
+}
+
+template <typename Functor, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+auto run(Functor functor, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1, arg2, arg3, arg4))> >::Type
+{
+    typedef decltype(functor(arg1, arg2, arg3, arg4)) result_type;
+    return (new StoredFunctorCall4<result_type, Functor, Arg1, Arg2, Arg3, Arg4>(functor, arg1, arg2, arg3, arg4))->start();
+}
+
+template <typename Functor, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+auto run(Functor functor, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
+    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1, arg2, arg3, arg4, arg5))> >::Type
+{
+    typedef decltype(functor(arg1, arg2, arg3, arg4, arg5)) result_type;
+    return (new StoredFunctorCall5<result_type, Functor, Arg1, Arg2, Arg3, Arg4, Arg5>(functor, arg1, arg2, arg3, arg4, arg5))->start();
+}
+
+#endif
+
+template <typename FunctionObject>
+QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject)
+{
+    return (new StoredFunctorCall0<QT_TYPENAME FunctionObject::result_type, FunctionObject>(functionObject))->start();
+}
+template <typename FunctionObject, typename Arg1>
+QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1)
+{
+    return (new StoredFunctorCall1<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1>(functionObject, arg1))->start();
+}
+template <typename FunctionObject, typename Arg1, typename Arg2>
+QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2)
+{
+    return (new StoredFunctorCall2<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2>(functionObject, arg1, arg2))->start();
+}
+template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3>
+QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+{
+    return (new StoredFunctorCall3<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3>(functionObject, arg1, arg2, arg3))->start();
+}
+template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+{
+    return (new StoredFunctorCall4<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4>(functionObject, arg1, arg2, arg3, arg4))->start();
+}
+template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
+{
+    return (new StoredFunctorCall5<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4, Arg5>(functionObject, arg1, arg2, arg3, arg4, arg5))->start();
+}
+
+template <typename FunctionObject>
+QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject)
+{
+    return (new QT_TYPENAME SelectStoredFunctorPointerCall0<QT_TYPENAME FunctionObject::result_type, FunctionObject>::type(functionObject))->start();
+}
+template <typename FunctionObject, typename Arg1>
+QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1)
+{
+    return (new QT_TYPENAME SelectStoredFunctorPointerCall1<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1>::type(functionObject, arg1))->start();
+}
+template <typename FunctionObject, typename Arg1, typename Arg2>
+QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2)
+{
+    return (new QT_TYPENAME SelectStoredFunctorPointerCall2<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2>::type(functionObject, arg1, arg2))->start();
+}
+template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3>
+QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+{
+    return (new QT_TYPENAME SelectStoredFunctorPointerCall3<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3>::type(functionObject, arg1, arg2, arg3))->start();
+}
+template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+{
+    return (new QT_TYPENAME SelectStoredFunctorPointerCall4<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4>::type(functionObject, arg1, arg2, arg3, arg4))->start();
+}
+template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
+{
+    return (new QT_TYPENAME SelectStoredFunctorPointerCall5<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4, Arg5>::type(functionObject, arg1, arg2, arg3, arg4, arg5))->start();
+}
+
+template <typename T, typename Class>
+QFuture<T> run(const Class &object, T (Class::*fn)())
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionCall0<T, Class>::type(fn, object))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1), const Arg1 &arg1)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
+}
+
+template <typename T, typename Class>
+QFuture<T> run(const Class &object, T (Class::*fn)() const)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall0<T, Class>::type(fn, object))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1) const, const Arg1 &arg1)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2) const, const Arg1 &arg1, const Arg2 &arg2)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
+}
+
+template <typename T, typename Class>
+QFuture<T> run(Class *object, T (Class::*fn)())
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall0<T, Class>::type(fn, object))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1>
+QFuture<T> run(Class *object, T (Class::*fn)(Param1), const Arg1 &arg1)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
+{
+    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
+}
+
+template <typename T, typename Class>
+QFuture<T> run(const Class *object, T (Class::*fn)() const)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall0<T, Class>::type(fn, object))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1>
+QFuture<T> run(const Class *object, T (Class::*fn)(Param1) const, const Arg1 &arg1)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2) const, const Arg1 &arg1, const Arg2 &arg2)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
+}
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
+{
+    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
+}
+
+} //namespace QtConcurrent
+
+#endif // qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentrunbase.h b/src/concurrent/qtconcurrentrunbase.h
new file mode 100644
index 0000000..2105437
--- /dev/null
+++ b/src/concurrent/qtconcurrentrunbase.h
@@ -0,0 +1,154 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_RUNBASE_H
+#define QTCONCURRENT_RUNBASE_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtConcurrent/qfuture.h>
+#include <QtCore/qrunnable.h>
+#include <QtCore/qthreadpool.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifndef qdoc
+
+namespace QtConcurrent {
+
+template <typename T>
+struct SelectSpecialization
+{
+    template <class Normal, class Void>
+    struct Type { typedef Normal type; };
+};
+
+template <>
+struct SelectSpecialization<void>
+{
+    template <class Normal, class Void>
+    struct Type { typedef Void type; };
+};
+
+template <typename T>
+class RunFunctionTaskBase : public QFutureInterface<T> , public QRunnable
+{
+public:
+    QFuture<T> start()
+    {
+        this->setRunnable(this);
+        this->reportStarted();
+        QFuture<T> theFuture = this->future();
+        QThreadPool::globalInstance()->start(this, /*m_priority*/ 0);
+        return theFuture;
+    }
+
+    void run() {}
+    virtual void runFunctor() = 0;
+};
+
+template <typename T>
+class RunFunctionTask : public RunFunctionTaskBase<T>
+{
+public:
+    void run()
+    {
+        if (this->isCanceled()) {
+            this->reportFinished();
+            return;
+        }
+#ifndef QT_NO_EXCEPTIONS
+        try {
+#endif
+            this->runFunctor();
+#ifndef QT_NO_EXCEPTIONS
+        } catch (QtConcurrent::Exception &e) {
+            QFutureInterface<T>::reportException(e);
+        } catch (...) {
+            QFutureInterface<T>::reportException(QtConcurrent::UnhandledException());
+        }
+#endif
+
+        this->reportResult(result);
+        this->reportFinished();
+    }
+    T result;
+};
+
+template <>
+class RunFunctionTask<void> : public RunFunctionTaskBase<void>
+{
+public:
+    void run()
+    {
+        if (this->isCanceled()) {
+            this->reportFinished();
+            return;
+        }
+#ifndef QT_NO_EXCEPTIONS
+        try {
+#endif
+            this->runFunctor();
+#ifndef QT_NO_EXCEPTIONS
+        } catch (QtConcurrent::Exception &e) {
+            QFutureInterface<void>::reportException(e);
+        } catch (...) {
+            QFutureInterface<void>::reportException(QtConcurrent::UnhandledException());
+        }
+#endif
+        this->reportFinished();
+    }
+};
+
+} //namespace QtConcurrent
+
+#endif //qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentstoredfunctioncall.h b/src/concurrent/qtconcurrentstoredfunctioncall.h
new file mode 100644
index 0000000..c311a72
--- /dev/null
+++ b/src/concurrent/qtconcurrentstoredfunctioncall.h
@@ -0,0 +1,1312 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+// Generated code, do not edit! Use generator at tools/qtconcurrent/generaterun/
+#ifndef QTCONCURRENT_STOREDFUNCTIONCALL_H
+#define QTCONCURRENT_STOREDFUNCTIONCALL_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+#include <QtConcurrent/qtconcurrentrunbase.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifndef qdoc
+
+namespace QtConcurrent {
+template <typename T, typename FunctionPointer>
+struct StoredFunctorCall0: public RunFunctionTask<T>
+{
+    inline StoredFunctorCall0(FunctionPointer _function)
+      : function(_function) {}
+    void runFunctor() { this->result = function(); }
+    FunctionPointer function;
+
+};
+
+template <typename FunctionPointer>
+struct StoredFunctorCall0<void, FunctionPointer>: public RunFunctionTask<void>
+{
+    inline StoredFunctorCall0(FunctionPointer _function)
+      : function(_function) {}
+    void runFunctor() { function(); }
+    FunctionPointer function;
+
+};
+
+template <typename T, typename FunctionPointer>
+struct StoredFunctorPointerCall0: public RunFunctionTask<T>
+{
+    inline StoredFunctorPointerCall0(FunctionPointer * _function)
+      : function(_function) {}
+    void runFunctor() { this->result =(*function)(); }
+    FunctionPointer * function;
+
+};
+
+template <typename T, typename FunctionPointer>
+struct VoidStoredFunctorPointerCall0: public RunFunctionTask<T>
+{
+    inline VoidStoredFunctorPointerCall0(FunctionPointer * _function)
+      : function(_function) {}
+    void runFunctor() {(*function)(); }
+    FunctionPointer * function;
+
+};
+
+template <typename T, typename FunctionPointer>
+struct SelectStoredFunctorPointerCall0
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredFunctorPointerCall0    <T, FunctionPointer>,
+             VoidStoredFunctorPointerCall0<T, FunctionPointer> >::type type;
+};
+template <typename T, typename Class>
+class StoredMemberFunctionCall0 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionCall0(T (Class::*_fn)() , const Class &_object)
+    : fn(_fn), object(_object){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)();
+    }
+private:
+    T (Class::*fn)();
+    Class object;
+
+};
+template <typename T, typename Class>
+class VoidStoredMemberFunctionCall0 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionCall0(T (Class::*_fn)() , const Class &_object)
+    : fn(_fn), object(_object){ }
+
+    void runFunctor()
+    {
+        (object.*fn)();
+    }
+private:
+    T (Class::*fn)();
+    Class object;
+
+};
+template <typename T, typename Class>
+struct SelectStoredMemberFunctionCall0
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionCall0    <T, Class>,
+             VoidStoredMemberFunctionCall0<T, Class> >::type type;
+};
+template <typename T, typename Class>
+class StoredConstMemberFunctionCall0 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionCall0(T (Class::*_fn)() const, const Class &_object)
+    : fn(_fn), object(_object){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)();
+    }
+private:
+    T (Class::*fn)()const;
+    const Class object;
+
+};
+template <typename T, typename Class>
+class VoidStoredConstMemberFunctionCall0 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionCall0(T (Class::*_fn)() const, const Class &_object)
+    : fn(_fn), object(_object){ }
+
+    void runFunctor()
+    {
+        (object.*fn)();
+    }
+private:
+    T (Class::*fn)()const;
+    const Class object;
+
+};
+template <typename T, typename Class>
+struct SelectStoredConstMemberFunctionCall0
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionCall0    <T, Class>,
+             VoidStoredConstMemberFunctionCall0<T, Class> >::type type;
+};
+template <typename T, typename Class>
+class StoredMemberFunctionPointerCall0 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionPointerCall0(T (Class::*_fn)() , Class *_object)
+    : fn(_fn), object(_object){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)();
+    }
+private:
+    T (Class::*fn)();
+    Class *object;
+
+};
+template <typename T, typename Class>
+class VoidStoredMemberFunctionPointerCall0 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionPointerCall0(T (Class::*_fn)() , Class *_object)
+    : fn(_fn), object(_object){ }
+
+    void runFunctor()
+    {
+        (object->*fn)();
+    }
+private:
+    T (Class::*fn)();
+    Class *object;
+
+};
+template <typename T, typename Class>
+struct SelectStoredMemberFunctionPointerCall0
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionPointerCall0    <T, Class>,
+             VoidStoredMemberFunctionPointerCall0<T, Class> >::type type;
+};
+template <typename T, typename Class>
+class StoredConstMemberFunctionPointerCall0 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionPointerCall0(T (Class::*_fn)() const, Class const *_object)
+    : fn(_fn), object(_object){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)();
+    }
+private:
+    T (Class::*fn)()const;
+    Class const *object;
+
+};
+template <typename T, typename Class>
+class VoidStoredConstMemberFunctionPointerCall0 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionPointerCall0(T (Class::*_fn)() const, Class const *_object)
+    : fn(_fn), object(_object){ }
+
+    void runFunctor()
+    {
+        (object->*fn)();
+    }
+private:
+    T (Class::*fn)()const;
+    Class const *object;
+
+};
+template <typename T, typename Class>
+struct SelectStoredConstMemberFunctionPointerCall0
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionPointerCall0    <T, Class>,
+             VoidStoredConstMemberFunctionPointerCall0<T, Class> >::type type;
+};
+template <typename T, typename FunctionPointer, typename Arg1>
+struct StoredFunctorCall1: public RunFunctionTask<T>
+{
+    inline StoredFunctorCall1(FunctionPointer _function, const Arg1 &_arg1)
+      : function(_function), arg1(_arg1) {}
+    void runFunctor() { this->result = function(arg1); }
+    FunctionPointer function;
+    Arg1 arg1;
+};
+
+template <typename FunctionPointer, typename Arg1>
+struct StoredFunctorCall1<void, FunctionPointer, Arg1>: public RunFunctionTask<void>
+{
+    inline StoredFunctorCall1(FunctionPointer _function, const Arg1 &_arg1)
+      : function(_function), arg1(_arg1) {}
+    void runFunctor() { function(arg1); }
+    FunctionPointer function;
+    Arg1 arg1;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1>
+struct StoredFunctorPointerCall1: public RunFunctionTask<T>
+{
+    inline StoredFunctorPointerCall1(FunctionPointer * _function, const Arg1 &_arg1)
+      : function(_function), arg1(_arg1) {}
+    void runFunctor() { this->result =(*function)(arg1); }
+    FunctionPointer * function;
+    Arg1 arg1;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1>
+struct VoidStoredFunctorPointerCall1: public RunFunctionTask<T>
+{
+    inline VoidStoredFunctorPointerCall1(FunctionPointer * _function, const Arg1 &_arg1)
+      : function(_function), arg1(_arg1) {}
+    void runFunctor() {(*function)(arg1); }
+    FunctionPointer * function;
+    Arg1 arg1;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1>
+struct SelectStoredFunctorPointerCall1
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredFunctorPointerCall1    <T, FunctionPointer, Arg1>,
+             VoidStoredFunctorPointerCall1<T, FunctionPointer, Arg1> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+class StoredMemberFunctionCall1 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionCall1(T (Class::*_fn)(Param1) , const Class &_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1);
+    }
+private:
+    T (Class::*fn)(Param1);
+    Class object;
+    Arg1 arg1;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+class VoidStoredMemberFunctionCall1 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionCall1(T (Class::*_fn)(Param1) , const Class &_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1);
+    }
+private:
+    T (Class::*fn)(Param1);
+    Class object;
+    Arg1 arg1;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+struct SelectStoredMemberFunctionCall1
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionCall1    <T, Class, Param1, Arg1>,
+             VoidStoredMemberFunctionCall1<T, Class, Param1, Arg1> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+class StoredConstMemberFunctionCall1 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionCall1(T (Class::*_fn)(Param1) const, const Class &_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1);
+    }
+private:
+    T (Class::*fn)(Param1)const;
+    const Class object;
+    Arg1 arg1;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+class VoidStoredConstMemberFunctionCall1 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionCall1(T (Class::*_fn)(Param1) const, const Class &_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1);
+    }
+private:
+    T (Class::*fn)(Param1)const;
+    const Class object;
+    Arg1 arg1;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+struct SelectStoredConstMemberFunctionCall1
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionCall1    <T, Class, Param1, Arg1>,
+             VoidStoredConstMemberFunctionCall1<T, Class, Param1, Arg1> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+class StoredMemberFunctionPointerCall1 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionPointerCall1(T (Class::*_fn)(Param1) , Class *_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1);
+    }
+private:
+    T (Class::*fn)(Param1);
+    Class *object;
+    Arg1 arg1;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+class VoidStoredMemberFunctionPointerCall1 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionPointerCall1(T (Class::*_fn)(Param1) , Class *_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1);
+    }
+private:
+    T (Class::*fn)(Param1);
+    Class *object;
+    Arg1 arg1;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+struct SelectStoredMemberFunctionPointerCall1
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionPointerCall1    <T, Class, Param1, Arg1>,
+             VoidStoredMemberFunctionPointerCall1<T, Class, Param1, Arg1> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+class StoredConstMemberFunctionPointerCall1 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionPointerCall1(T (Class::*_fn)(Param1) const, Class const *_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1);
+    }
+private:
+    T (Class::*fn)(Param1)const;
+    Class const *object;
+    Arg1 arg1;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+class VoidStoredConstMemberFunctionPointerCall1 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionPointerCall1(T (Class::*_fn)(Param1) const, Class const *_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1);
+    }
+private:
+    T (Class::*fn)(Param1)const;
+    Class const *object;
+    Arg1 arg1;
+};
+template <typename T, typename Class, typename Param1, typename Arg1>
+struct SelectStoredConstMemberFunctionPointerCall1
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionPointerCall1    <T, Class, Param1, Arg1>,
+             VoidStoredConstMemberFunctionPointerCall1<T, Class, Param1, Arg1> >::type type;
+};
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
+struct StoredFunctorCall2: public RunFunctionTask<T>
+{
+    inline StoredFunctorCall2(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2)
+      : function(_function), arg1(_arg1), arg2(_arg2) {}
+    void runFunctor() { this->result = function(arg1, arg2); }
+    FunctionPointer function;
+    Arg1 arg1; Arg2 arg2;
+};
+
+template <typename FunctionPointer, typename Arg1, typename Arg2>
+struct StoredFunctorCall2<void, FunctionPointer, Arg1, Arg2>: public RunFunctionTask<void>
+{
+    inline StoredFunctorCall2(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2)
+      : function(_function), arg1(_arg1), arg2(_arg2) {}
+    void runFunctor() { function(arg1, arg2); }
+    FunctionPointer function;
+    Arg1 arg1; Arg2 arg2;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
+struct StoredFunctorPointerCall2: public RunFunctionTask<T>
+{
+    inline StoredFunctorPointerCall2(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2)
+      : function(_function), arg1(_arg1), arg2(_arg2) {}
+    void runFunctor() { this->result =(*function)(arg1, arg2); }
+    FunctionPointer * function;
+    Arg1 arg1; Arg2 arg2;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
+struct VoidStoredFunctorPointerCall2: public RunFunctionTask<T>
+{
+    inline VoidStoredFunctorPointerCall2(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2)
+    : function(_function), arg1(_arg1), arg2(_arg2) {}
+    void runFunctor() {(*function)(arg1, arg2); }
+    FunctionPointer * function;
+    Arg1 arg1; Arg2 arg2;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
+struct SelectStoredFunctorPointerCall2
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredFunctorPointerCall2    <T, FunctionPointer, Arg1, Arg2>,
+             VoidStoredFunctorPointerCall2<T, FunctionPointer, Arg1, Arg2> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class StoredMemberFunctionCall2 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1, arg2);
+    }
+private:
+    T (Class::*fn)(Param1, Param2);
+    Class object;
+    Arg1 arg1; Arg2 arg2;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class VoidStoredMemberFunctionCall2 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1, arg2);
+    }
+private:
+    T (Class::*fn)(Param1, Param2);
+    Class object;
+    Arg1 arg1; Arg2 arg2;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+struct SelectStoredMemberFunctionCall2
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionCall2    <T, Class, Param1, Arg1, Param2, Arg2>,
+             VoidStoredMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class StoredConstMemberFunctionCall2 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1, arg2);
+    }
+private:
+    T (Class::*fn)(Param1, Param2)const;
+    const Class object;
+    Arg1 arg1; Arg2 arg2;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class VoidStoredConstMemberFunctionCall2 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1, arg2);
+    }
+private:
+    T (Class::*fn)(Param1, Param2)const;
+    const Class object;
+    Arg1 arg1; Arg2 arg2;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+struct SelectStoredConstMemberFunctionCall2
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionCall2    <T, Class, Param1, Arg1, Param2, Arg2>,
+             VoidStoredConstMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class StoredMemberFunctionPointerCall2 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1, arg2);
+    }
+private:
+    T (Class::*fn)(Param1, Param2);
+    Class *object;
+    Arg1 arg1; Arg2 arg2;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class VoidStoredMemberFunctionPointerCall2 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1, arg2);
+    }
+private:
+    T (Class::*fn)(Param1, Param2);
+    Class *object;
+    Arg1 arg1; Arg2 arg2;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+struct SelectStoredMemberFunctionPointerCall2
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionPointerCall2    <T, Class, Param1, Arg1, Param2, Arg2>,
+             VoidStoredMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class StoredConstMemberFunctionPointerCall2 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1, arg2);
+    }
+private:
+    T (Class::*fn)(Param1, Param2)const;
+    Class const *object;
+    Arg1 arg1; Arg2 arg2;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class VoidStoredConstMemberFunctionPointerCall2 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1, arg2);
+    }
+private:
+    T (Class::*fn)(Param1, Param2)const;
+    Class const *object;
+    Arg1 arg1; Arg2 arg2;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+struct SelectStoredConstMemberFunctionPointerCall2
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionPointerCall2    <T, Class, Param1, Arg1, Param2, Arg2>,
+             VoidStoredConstMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
+};
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
+struct StoredFunctorCall3: public RunFunctionTask<T>
+{
+    inline StoredFunctorCall3(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
+    void runFunctor() { this->result = function(arg1, arg2, arg3); }
+    FunctionPointer function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+
+template <typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
+struct StoredFunctorCall3<void, FunctionPointer, Arg1, Arg2, Arg3>: public RunFunctionTask<void>
+{
+    inline StoredFunctorCall3(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
+    void runFunctor() { function(arg1, arg2, arg3); }
+    FunctionPointer function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
+struct StoredFunctorPointerCall3: public RunFunctionTask<T>
+{
+    inline StoredFunctorPointerCall3(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
+    void runFunctor() { this->result =(*function)(arg1, arg2, arg3); }
+    FunctionPointer * function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
+struct VoidStoredFunctorPointerCall3: public RunFunctionTask<T>
+{
+    inline VoidStoredFunctorPointerCall3(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
+    void runFunctor() {(*function)(arg1, arg2, arg3); }
+    FunctionPointer * function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
+struct SelectStoredFunctorPointerCall3
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredFunctorPointerCall3    <T, FunctionPointer, Arg1, Arg2, Arg3>,
+             VoidStoredFunctorPointerCall3<T, FunctionPointer, Arg1, Arg2, Arg3> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class StoredMemberFunctionCall3 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1, arg2, arg3);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3);
+    Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class VoidStoredMemberFunctionCall3 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1, arg2, arg3);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3);
+    Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+struct SelectStoredMemberFunctionCall3
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionCall3    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
+             VoidStoredMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class StoredConstMemberFunctionCall3 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1, arg2, arg3);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3)const;
+    const Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class VoidStoredConstMemberFunctionCall3 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1, arg2, arg3);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3)const;
+    const Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+struct SelectStoredConstMemberFunctionCall3
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionCall3    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
+             VoidStoredConstMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class StoredMemberFunctionPointerCall3 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1, arg2, arg3);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class VoidStoredMemberFunctionPointerCall3 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1, arg2, arg3);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+struct SelectStoredMemberFunctionPointerCall3
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionPointerCall3    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
+             VoidStoredMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class StoredConstMemberFunctionPointerCall3 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1, arg2, arg3);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3)const;
+    Class const *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class VoidStoredConstMemberFunctionPointerCall3 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1, arg2, arg3);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3)const;
+    Class const *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+struct SelectStoredConstMemberFunctionPointerCall3
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionPointerCall3    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
+             VoidStoredConstMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
+};
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+struct StoredFunctorCall4: public RunFunctionTask<T>
+{
+    inline StoredFunctorCall4(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
+    void runFunctor() { this->result = function(arg1, arg2, arg3, arg4); }
+    FunctionPointer function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+
+template <typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+struct StoredFunctorCall4<void, FunctionPointer, Arg1, Arg2, Arg3, Arg4>: public RunFunctionTask<void>
+{
+    inline StoredFunctorCall4(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
+    void runFunctor() { function(arg1, arg2, arg3, arg4); }
+    FunctionPointer function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+struct StoredFunctorPointerCall4: public RunFunctionTask<T>
+{
+    inline StoredFunctorPointerCall4(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
+    void runFunctor() { this->result =(*function)(arg1, arg2, arg3, arg4); }
+    FunctionPointer * function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+struct VoidStoredFunctorPointerCall4: public RunFunctionTask<T>
+{
+    inline VoidStoredFunctorPointerCall4(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
+    void runFunctor() {(*function)(arg1, arg2, arg3, arg4); }
+    FunctionPointer * function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+struct SelectStoredFunctorPointerCall4
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredFunctorPointerCall4    <T, FunctionPointer, Arg1, Arg2, Arg3, Arg4>,
+             VoidStoredFunctorPointerCall4<T, FunctionPointer, Arg1, Arg2, Arg3, Arg4> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class StoredMemberFunctionCall4 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1, arg2, arg3, arg4);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4);
+    Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class VoidStoredMemberFunctionCall4 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1, arg2, arg3, arg4);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4);
+    Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+struct SelectStoredMemberFunctionCall4
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionCall4    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
+             VoidStoredMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class StoredConstMemberFunctionCall4 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1, arg2, arg3, arg4);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4)const;
+    const Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class VoidStoredConstMemberFunctionCall4 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1, arg2, arg3, arg4);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4)const;
+    const Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+struct SelectStoredConstMemberFunctionCall4
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionCall4    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
+             VoidStoredConstMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class StoredMemberFunctionPointerCall4 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1, arg2, arg3, arg4);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class VoidStoredMemberFunctionPointerCall4 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1, arg2, arg3, arg4);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+struct SelectStoredMemberFunctionPointerCall4
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionPointerCall4    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
+             VoidStoredMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class StoredConstMemberFunctionPointerCall4 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1, arg2, arg3, arg4);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4)const;
+    Class const *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class VoidStoredConstMemberFunctionPointerCall4 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1, arg2, arg3, arg4);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4)const;
+    Class const *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+struct SelectStoredConstMemberFunctionPointerCall4
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionPointerCall4    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
+             VoidStoredConstMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
+};
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+struct StoredFunctorCall5: public RunFunctionTask<T>
+{
+    inline StoredFunctorCall5(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
+    void runFunctor() { this->result = function(arg1, arg2, arg3, arg4, arg5); }
+    FunctionPointer function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+
+template <typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+struct StoredFunctorCall5<void, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5>: public RunFunctionTask<void>
+{
+    inline StoredFunctorCall5(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
+    void runFunctor() { function(arg1, arg2, arg3, arg4, arg5); }
+    FunctionPointer function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+struct StoredFunctorPointerCall5: public RunFunctionTask<T>
+{
+    inline StoredFunctorPointerCall5(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
+    void runFunctor() { this->result =(*function)(arg1, arg2, arg3, arg4, arg5); }
+    FunctionPointer * function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+struct VoidStoredFunctorPointerCall5: public RunFunctionTask<T>
+{
+    inline VoidStoredFunctorPointerCall5(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
+    void runFunctor() {(*function)(arg1, arg2, arg3, arg4, arg5); }
+    FunctionPointer * function;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+
+template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+struct SelectStoredFunctorPointerCall5
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredFunctorPointerCall5    <T, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5>,
+             VoidStoredFunctorPointerCall5<T, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class StoredMemberFunctionCall5 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1, arg2, arg3, arg4, arg5);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
+    Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class VoidStoredMemberFunctionCall5 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1, arg2, arg3, arg4, arg5);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
+    Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+struct SelectStoredMemberFunctionCall5
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionCall5    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
+             VoidStoredMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class StoredConstMemberFunctionCall5 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor()
+    {
+        this->result = (object.*fn)(arg1, arg2, arg3, arg4, arg5);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
+    const Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class VoidStoredConstMemberFunctionCall5 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor()
+    {
+        (object.*fn)(arg1, arg2, arg3, arg4, arg5);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
+    const Class object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+struct SelectStoredConstMemberFunctionCall5
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionCall5    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
+             VoidStoredConstMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class StoredMemberFunctionPointerCall5 : public RunFunctionTask<T>
+{
+public:
+    StoredMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1, arg2, arg3, arg4, arg5);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class VoidStoredMemberFunctionPointerCall5 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1, arg2, arg3, arg4, arg5);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+struct SelectStoredMemberFunctionPointerCall5
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredMemberFunctionPointerCall5    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
+             VoidStoredMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class StoredConstMemberFunctionPointerCall5 : public RunFunctionTask<T>
+{
+public:
+    StoredConstMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor()
+    {
+        this->result = (object->*fn)(arg1, arg2, arg3, arg4, arg5);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
+    Class const *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class VoidStoredConstMemberFunctionPointerCall5 : public RunFunctionTask<T>
+{
+public:
+    VoidStoredConstMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor()
+    {
+        (object->*fn)(arg1, arg2, arg3, arg4, arg5);
+    }
+private:
+    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
+    Class const *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+struct SelectStoredConstMemberFunctionPointerCall5
+{
+    typedef typename SelectSpecialization<T>::template
+        Type<StoredConstMemberFunctionPointerCall5    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
+             VoidStoredConstMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
+};
+
+template <typename T, typename Functor>
+class StoredFunctorCall : public RunFunctionTask<T>
+{
+public:
+    StoredFunctorCall(const Functor &f) : functor(f) { }
+    void runFunctor()
+    {
+        this->result = functor();
+    }
+private:
+    Functor functor;
+};
+template <typename Functor>
+class StoredFunctorCall<void, Functor> : public RunFunctionTask<void>
+{
+public:
+    StoredFunctorCall(const Functor &f) : functor(f) { }
+    void runFunctor()
+    {
+        functor();
+    }
+private:
+    Functor functor;
+};
+
+
+} //namespace QtConcurrent
+
+#endif // qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/concurrent/qtconcurrentthreadengine.cpp b/src/concurrent/qtconcurrentthreadengine.cpp
new file mode 100644
index 0000000..7741226
--- /dev/null
+++ b/src/concurrent/qtconcurrentthreadengine.cpp
@@ -0,0 +1,299 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qtconcurrentthreadengine.h"
+
+#ifndef QT_NO_CONCURRENT
+
+QT_BEGIN_NAMESPACE
+
+namespace QtConcurrent {
+
+ThreadEngineBarrier::ThreadEngineBarrier()
+:count(0) { }
+
+void ThreadEngineBarrier::acquire()
+{
+    forever {
+        int localCount = count.load();
+        if (localCount < 0) {
+            if (count.testAndSetOrdered(localCount, localCount -1))
+                return;
+        } else {
+            if (count.testAndSetOrdered(localCount, localCount + 1))
+                return;
+        }
+    }
+}
+
+int ThreadEngineBarrier::release()
+{
+    forever {
+        int localCount = count.load();
+        if (localCount == -1) {
+            if (count.testAndSetOrdered(-1, 0)) {
+                semaphore.release();
+                return 0;
+            }
+        } else if (localCount < 0) {
+            if (count.testAndSetOrdered(localCount, localCount + 1))
+                return qAbs(localCount + 1);
+        } else {
+            if (count.testAndSetOrdered(localCount, localCount - 1))
+                return localCount - 1;
+        }
+    }
+}
+
+// Wait until all threads have been released
+void ThreadEngineBarrier::wait()
+{
+    forever {
+        int localCount = count.load();
+        if (localCount == 0)
+            return;
+
+        Q_ASSERT(localCount > 0); // multiple waiters are not allowed.
+        if (count.testAndSetOrdered(localCount, -localCount)) {
+            semaphore.acquire();
+            return;
+        }
+    }
+}
+
+int ThreadEngineBarrier::currentCount()
+{
+    return count.load();
+}
+
+// releases a thread, unless this is the last thread.
+// returns true if the thread was released.
+bool ThreadEngineBarrier::releaseUnlessLast()
+{
+    forever {
+        int localCount = count.load();
+        if (qAbs(localCount) == 1) {
+            return false;
+        } else if (localCount < 0) {
+            if (count.testAndSetOrdered(localCount, localCount + 1))
+                return true;
+        } else {
+            if (count.testAndSetOrdered(localCount, localCount - 1))
+                return true;
+        }
+    }
+}
+
+ThreadEngineBase::ThreadEngineBase()
+:futureInterface(0), threadPool(QThreadPool::globalInstance())
+{
+    setAutoDelete(false);
+}
+
+ThreadEngineBase::~ThreadEngineBase() {}
+
+void ThreadEngineBase::startSingleThreaded()
+{
+    start();
+    while (threadFunction() != ThreadFinished)
+        ;
+    finish();
+}
+
+void ThreadEngineBase::startBlocking()
+{
+    start();
+    barrier.acquire();
+    startThreads();
+
+    bool throttled = false;
+#ifndef QT_NO_EXCEPTIONS
+    try {
+#endif
+        while (threadFunction() == ThrottleThread) {
+            if (threadThrottleExit()) {
+                throttled = true;
+                break;
+            }
+        }
+#ifndef QT_NO_EXCEPTIONS
+    } catch (QtConcurrent::Exception &e) {
+        handleException(e);
+    } catch (...) {
+        handleException(QtConcurrent::UnhandledException());
+    }
+#endif
+
+    if (throttled == false) {
+        barrier.release();
+    }
+
+    barrier.wait();
+    finish();
+    exceptionStore.throwPossibleException();
+}
+
+void ThreadEngineBase::startThread()
+{
+    startThreadInternal();
+}
+
+void ThreadEngineBase::acquireBarrierSemaphore()
+{
+    barrier.acquire();
+}
+
+bool ThreadEngineBase::isCanceled()
+{
+    if (futureInterface)
+        return futureInterface->isCanceled();
+    else
+        return false;
+}
+
+void ThreadEngineBase::waitForResume()
+{
+    if (futureInterface)
+        futureInterface->waitForResume();
+}
+
+bool ThreadEngineBase::isProgressReportingEnabled()
+{
+    // If we don't have a QFuture, there is no-one to report the progress to.
+    return (futureInterface != 0);
+}
+
+void ThreadEngineBase::setProgressValue(int progress)
+{
+    if (futureInterface)
+        futureInterface->setProgressValue(progress);
+}
+
+void ThreadEngineBase::setProgressRange(int minimum, int maximum)
+{
+    if (futureInterface)
+        futureInterface->setProgressRange(minimum, maximum);
+}
+
+bool ThreadEngineBase::startThreadInternal()
+{
+    if (this->isCanceled())
+        return false;
+
+    barrier.acquire();
+    if (!threadPool->tryStart(this)) {
+        barrier.release();
+        return false;
+    }
+    return true;
+}
+
+void ThreadEngineBase::startThreads()
+{
+    while (shouldStartThread() && startThreadInternal())
+        ;
+}
+
+void ThreadEngineBase::threadExit()
+{
+    const bool asynchronous = futureInterface != 0;
+    const int lastThread = (barrier.release() == 0);
+
+    if (lastThread && asynchronous)
+        this->asynchronousFinish();
+}
+
+// Called by a worker thread that wants to be throttled. If the current number
+// of running threads is larger than one the thread is allowed to exit and
+// this function returns one.
+bool ThreadEngineBase::threadThrottleExit()
+{
+    return barrier.releaseUnlessLast();
+}
+
+void ThreadEngineBase::run() // implements QRunnable.
+{
+    if (this->isCanceled()) {
+        threadExit();
+        return;
+    }
+
+    startThreads();
+
+#ifndef QT_NO_EXCEPTIONS
+    try {
+#endif
+        while (threadFunction() == ThrottleThread) {
+            // threadFunction returning ThrottleThread means it that the user
+            // struct wants to be throttled by making a worker thread exit.
+            // Respect that request unless this is the only worker thread left
+            // running, in which case it has to keep going.
+            if (threadThrottleExit())
+                return;
+        }
+
+#ifndef QT_NO_EXCEPTIONS
+    } catch (QtConcurrent::Exception &e) {
+        handleException(e);
+    } catch (...) {
+        handleException(QtConcurrent::UnhandledException());
+    }
+#endif
+    threadExit();
+}
+
+#ifndef QT_NO_EXCEPTIONS
+
+void ThreadEngineBase::handleException(const QtConcurrent::Exception &exception)
+{
+    if (futureInterface)
+        futureInterface->reportException(exception);
+    else
+        exceptionStore.setException(exception);
+}
+#endif
+
+
+} // namepsace QtConcurrent
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_CONCURRENT
diff --git a/src/concurrent/qtconcurrentthreadengine.h b/src/concurrent/qtconcurrentthreadengine.h
new file mode 100644
index 0000000..20e86f5
--- /dev/null
+++ b/src/concurrent/qtconcurrentthreadengine.h
@@ -0,0 +1,284 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTCONCURRENT_THREADENGINE_H
+#define QTCONCURRENT_THREADENGINE_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_NO_CONCURRENT
+
+#include <QtCore/qthreadpool.h>
+#include <QtConcurrent/qfuture.h>
+#include <QtCore/qdebug.h>
+#include <QtConcurrent/qtconcurrentexception.h>
+#include <QtCore/qwaitcondition.h>
+#include <QtCore/qatomic.h>
+#include <QtCore/qsemaphore.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+#ifndef qdoc
+
+namespace QtConcurrent {
+
+// The ThreadEngineBarrier counts worker threads, and allows one
+// thread to wait for all others to finish. Tested for its use in
+// QtConcurrent, requires more testing for use as a general class.
+class ThreadEngineBarrier
+{
+private:
+    // The thread count is maintained as an integer in the count atomic
+    // variable. The count can be either positive or negative - a negative
+    // count signals that a thread is waiting on the barrier.
+
+    // BC note: inlined code from Qt < 4.6 will expect to find the QMutex 
+    // and QAtomicInt here. ### Qt 5: remove.
+    QMutex mutex;
+    QAtomicInt count;
+
+    QSemaphore semaphore;
+public:
+    ThreadEngineBarrier();
+    void acquire();
+    int release();
+    void wait();
+    int currentCount();
+    bool releaseUnlessLast();
+};
+
+enum ThreadFunctionResult { ThrottleThread, ThreadFinished };
+
+// The ThreadEngine controls the threads used in the computation.
+// Can be run in three modes: single threaded, multi-threaded blocking
+// and multi-threaded asynchronous.
+// The code for the single threaded mode is
+class Q_CORE_EXPORT ThreadEngineBase: public QRunnable
+{
+public:
+    // Public API:
+    ThreadEngineBase();
+    virtual ~ThreadEngineBase();
+    void startSingleThreaded();
+    void startBlocking();
+    void startThread();
+    bool isCanceled();
+    void waitForResume();
+    bool isProgressReportingEnabled();
+    void setProgressValue(int progress);
+    void setProgressRange(int minimum, int maximum);
+    void acquireBarrierSemaphore();
+
+protected: // The user overrides these:
+    virtual void start() {}
+    virtual void finish() {}
+    virtual ThreadFunctionResult threadFunction() { return ThreadFinished; }
+    virtual bool shouldStartThread() { return futureInterface ? !futureInterface->isPaused() : true; }
+    virtual bool shouldThrottleThread() { return futureInterface ? futureInterface->isPaused() : false; }
+private:
+    bool startThreadInternal();
+    void startThreads();
+    void threadExit();
+    bool threadThrottleExit();
+    void run();
+    virtual void asynchronousFinish() = 0;
+#ifndef QT_NO_EXCEPTIONS
+    void handleException(const QtConcurrent::Exception &exception);
+#endif
+protected:
+    QFutureInterfaceBase *futureInterface;
+    QThreadPool *threadPool;
+    ThreadEngineBarrier barrier;
+    QtConcurrent::internal::ExceptionStore exceptionStore;
+};
+
+
+template <typename T>
+class ThreadEngine : public virtual ThreadEngineBase
+{
+public:
+    typedef T ResultType;
+
+    virtual T *result() { return 0; }
+
+    QFutureInterface<T> *futureInterfaceTyped()
+    {
+        return static_cast<QFutureInterface<T> *>(futureInterface);
+    }
+
+    // Runs the user algorithm using a single thread.
+    T *startSingleThreaded()
+    {
+        ThreadEngineBase::startSingleThreaded();
+        return result();
+    }
+
+    // Runs the user algorithm using multiple threads.
+    // This function blocks until the algorithm is finished,
+    // and then returns the result.
+    T *startBlocking()
+    {
+        ThreadEngineBase::startBlocking();
+        return result();
+    }
+
+    // Runs the user algorithm using multiple threads.
+    // Does not block, returns a future.
+    QFuture<T> startAsynchronously()
+    {
+        futureInterface = new QFutureInterface<T>();
+
+        // reportStart() must be called before starting threads, otherwise the
+        // user algorithm might finish while reportStart() is running, which
+        // is very bad.
+        futureInterface->reportStarted();
+        QFuture<T> future = QFuture<T>(futureInterfaceTyped());
+        start();
+
+        acquireBarrierSemaphore();
+        threadPool->start(this);
+        return future;
+    }
+
+    void asynchronousFinish()
+    {
+        finish();
+        futureInterfaceTyped()->reportFinished(result());
+        delete futureInterfaceTyped();
+        delete this;
+    }
+
+
+    void reportResult(const T *_result, int index = -1)
+    {
+        if (futureInterface)
+            futureInterfaceTyped()->reportResult(_result, index);
+    }
+
+    void reportResults(const QVector<T> &_result, int index = -1, int count = -1)
+    {
+        if (futureInterface)
+            futureInterfaceTyped()->reportResults(_result, index, count);
+    }
+};
+
+// The ThreadEngineStarter class ecapsulates the return type
+// from the thread engine.
+// Depending on how the it is used, it will run
+// the engine in either blocking mode or asynchronous mode.
+template <typename T>
+class ThreadEngineStarterBase
+{
+public:
+    ThreadEngineStarterBase(ThreadEngine<T> *_threadEngine)
+    : threadEngine(_threadEngine) { }
+
+    inline ThreadEngineStarterBase(const ThreadEngineStarterBase &other)
+    : threadEngine(other.threadEngine) { }
+
+    QFuture<T> startAsynchronously()
+    {
+        return threadEngine->startAsynchronously();
+    }
+
+    operator QFuture<T>()
+    {
+        return startAsynchronously();
+    }
+
+protected:
+    ThreadEngine<T> *threadEngine;
+};
+
+
+// We need to factor out the code that dereferences the T pointer,
+// with a specialization where T is void. (code that dereferences a void *
+// won't compile)
+template <typename T>
+class ThreadEngineStarter : public ThreadEngineStarterBase<T>
+{
+    typedef ThreadEngineStarterBase<T> Base;
+    typedef ThreadEngine<T> TypedThreadEngine;
+public:
+    ThreadEngineStarter(TypedThreadEngine *eng)
+        : Base(eng) { }
+
+    T startBlocking()
+    {
+        T t = *this->threadEngine->startBlocking();
+        delete this->threadEngine;
+        return t;
+    }
+};
+
+// Full template specialization where T is void.
+template <>
+class ThreadEngineStarter<void> : public ThreadEngineStarterBase<void>
+{
+public:
+    ThreadEngineStarter<void>(ThreadEngine<void> *_threadEngine)
+    :ThreadEngineStarterBase<void>(_threadEngine) {}
+
+    void startBlocking()
+    {
+        this->threadEngine->startBlocking();
+        delete this->threadEngine;
+    }
+};
+
+template <typename ThreadEngine>
+inline ThreadEngineStarter<typename ThreadEngine::ResultType> startThreadEngine(ThreadEngine *threadEngine)
+{
+    return ThreadEngineStarter<typename ThreadEngine::ResultType>(threadEngine);
+}
+
+} // namespace QtConcurrent
+
+#endif //qdoc
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_CONCURRENT
+
+#endif
diff --git a/src/corelib/concurrent/concurrent.pri b/src/corelib/concurrent/concurrent.pri
deleted file mode 100644
index 9402971..0000000
--- a/src/corelib/concurrent/concurrent.pri
+++ /dev/null
@@ -1,42 +0,0 @@
-SOURCES += \
-        concurrent/qfuture.cpp \
-        concurrent/qfutureinterface.cpp \
-        concurrent/qfuturesynchronizer.cpp \
-        concurrent/qfuturewatcher.cpp \
-        concurrent/qrunnable.cpp \
-        concurrent/qtconcurrentfilter.cpp \
-        concurrent/qtconcurrentmap.cpp \
-        concurrent/qtconcurrentresultstore.cpp \
-        concurrent/qtconcurrentthreadengine.cpp \
-        concurrent/qtconcurrentiteratekernel.cpp \
-        concurrent/qtconcurrentexception.cpp \
-        concurrent/qthreadpool.cpp
-
-HEADERS += \
-        concurrent/qfuture.h \
-        concurrent/qfutureinterface.h \
-        concurrent/qfuturesynchronizer.h \
-        concurrent/qfuturewatcher.h \
-        concurrent/qrunnable.h \
-        concurrent/qtconcurrentcompilertest.h \
-        concurrent/qtconcurrentexception.h \
-        concurrent/qtconcurrentfilter.h \
-        concurrent/qtconcurrentfilterkernel.h \
-        concurrent/qtconcurrentfunctionwrappers.h \
-        concurrent/qtconcurrentiteratekernel.h \
-        concurrent/qtconcurrentmap.h \
-        concurrent/qtconcurrentmapkernel.h \
-        concurrent/qtconcurrentmedian.h \
-        concurrent/qtconcurrentreducekernel.h \
-        concurrent/qtconcurrentresultstore.h \
-        concurrent/qtconcurrentrun.h \
-        concurrent/qtconcurrentrunbase.h \
-        concurrent/qtconcurrentstoredfunctioncall.h \
-        concurrent/qtconcurrentthreadengine.h \
-        concurrent/qthreadpool.h
-
-# private headers
-HEADERS += \
-        concurrent/qfutureinterface_p.h \
-        concurrent/qfuturewatcher_p.h \
-        concurrent/qthreadpool_p.h
diff --git a/src/corelib/concurrent/qfuture.cpp b/src/corelib/concurrent/qfuture.cpp
deleted file mode 100644
index 9805454..0000000
--- a/src/corelib/concurrent/qfuture.cpp
+++ /dev/null
@@ -1,697 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*! \class QFuture
-    \threadsafe
-    \brief The QFuture class represents the result of an asynchronous computation.
-    \since 4.4
-
-    \ingroup thread
-
-    To start a computation, use one of the APIs in the
-    \l {Concurrent Programming}{Qt Concurrent} framework.
-
-    QFuture allows threads to be synchronized against one or more results
-    which will be ready at a later point in time. The result can be of any type
-    that has a default constructor and a copy constructor. If a result is not
-    available at the time of calling the result(), resultAt(), or results()
-    functions, QFuture will wait until the result becomes available. You can
-    use the isResultReadyAt() function to determine if a result is ready or
-    not. For QFuture objects that report more than one result, the
-    resultCount() function returns the number of continuous results. This
-    means that it is always safe to iterate through the results from 0 to 
-    resultCount().
-
-    QFuture provides a \l{Java-style iterators}{Java-style iterator}
-    (QFutureIterator) and an \l{STL-style iterators}{STL-style iterator}
-    (QFuture::const_iterator). Using these iterators is  another way to access
-    results in the future.
-
-    QFuture also offers ways to interact with a runnning computation. For
-    instance, the computation can be canceled with the cancel() function. To
-    pause the computation, use the setPaused() function or one of the pause(),
-    resume(), or togglePaused() convenience functions. Be aware that not all
-    asynchronous computations can be canceled or paused. For example, the
-    future returned by QtConcurrent::run() cannot be canceled; but the
-    future returned by QtConcurrent::mappedReduced() can.
-
-    Progress information is provided by the progressValue(),
-    progressMinimum(), progressMaximum(), and progressText() functions. The
-    waitForFinished() function causes the calling thread to block and wait for
-    the computation to finish, ensuring that all results are available.
-
-    The state of the computation represented by a QFuture can be queried using
-    the isCanceled(), isStarted(), isFinished(), isRunning(), or isPaused()
-    functions.
-
-    QFuture is a lightweight reference counted class that can be passed by
-    value.
-
-    QFuture<void> is specialized to not contain any of the result fetching
-    functions. Any QFuture<T> can be assigned or copied into a QFuture<void>
-    as well. This is useful if only status or progress information is needed
-    - not the actual result data.
-
-    To interact with running tasks using signals and slots, use QFutureWatcher.
-
-    \sa QFutureWatcher, {Concurrent Programming}{Qt Concurrent}
-*/
-
-/*! \fn QFuture::QFuture()
-
-    Constructs an empty future.
-*/
-
-/*! \fn QFuture::QFuture(const QFuture &other)
-
-    Constructs a copy of \a other.
-
-    \sa operator=()
-*/
-
-/*! \fn QFuture::QFuture(QFutureInterface<T> *resultHolder)
-    \internal
-*/
-
-/*! \fn QFuture::~QFuture()
-
-    Destroys the future.
-
-    Note that this neither waits nor cancels the asynchronous computation. Use
-    waitForFinished() or QFutureSynchronizer when you need to ensure that the
-    computation is completed before the future is destroyed.
-*/
-
-/*! \fn QFuture &QFuture::operator=(const QFuture &other)
-
-     Assigns \a other to this future and returns a reference to this future.
-*/
-
-/*! \fn bool QFuture::operator==(const QFuture &other) const
-
-    Returns true if \a other is a copy of this future; otherwise returns false.
-*/
-
-/*! \fn bool QFuture::operator!=(const QFuture &other) const
-
-    Returns true if \a other is \e not a copy of this future; otherwise returns
-    false.
-*/
-
-/*! \fn void QFuture::cancel()
-
-    Cancels the asynchronous computation represented by this future. Note that
-    the cancelation is asynchronous. Use waitForFinished() after calling
-    cancel() when you need synchronous cancelation.
-
-    Results currently available may still be accessed on a canceled future,
-    but new results will \e not become available after calling this function.
-    Any QFutureWatcher object that is watching this future will not deliver
-    progress and result ready signals on a canceled future.
-
-    Be aware that not all asynchronous computations can be canceled. For
-    example, the future returned by QtConcurrent::run() cannot be canceled;
-    but the future returned by QtConcurrent::mappedReduced() can.
-*/
-
-/*! \fn bool QFuture::isCanceled() const
-
-    Returns true if the asynchronous computation has been canceled with the
-    cancel() function; otherwise returns false.
-
-    Be aware that the computation may still be running even though this
-    function returns true. See cancel() for more details.
-*/
-
-/*! \fn void QFuture::setPaused(bool paused)
-
-    If \a paused is true, this function pauses the asynchronous computation
-    represented by the future. If the computation is  already paused, this
-    function does nothing. Any QFutureWatcher object that is watching this
-    future will stop delivering progress and result ready signals while the
-    future is paused. Signal delivery will continue once the future is
-    resumed.
-
-    If \a paused is false, this function resumes the asynchronous computation.
-    If the computation was not previously paused, this function does nothing.
-
-    Be aware that not all computations can be paused. For example, the future
-    returned by QtConcurrent::run() cannot be paused; but the future returned
-    by QtConcurrent::mappedReduced() can.
-
-    \sa pause(), resume(), togglePaused()
-*/
-
-/*! \fn bool QFuture::isPaused() const
-
-    Returns true if the asynchronous computation has been paused with the
-    pause() function; otherwise returns false.
-
-    Be aware that the computation may still be running even though this
-    function returns true. See setPaused() for more details.
-
-    \sa setPaused(), togglePaused()
-*/
-
-/*! \fn void QFuture::pause()
-
-    Pauses the asynchronous computation represented by this future. This is a
-    convenience method that simply calls setPaused(true).
-
-    \sa resume()
-*/
-
-/*! \fn void QFuture::resume()
-
-    Resumes the asynchronous computation represented by this future. This is a
-    convenience method that simply calls setPaused(false).
-
-    \sa pause()
-*/
-
-/*! \fn void QFuture::togglePaused()
-
-    Toggles the paused state of the asynchronous computation. In other words,
-    if the computation is currently paused, calling this function resumes it;
-    if the computation is running, it is paused. This is a convenience method
-    for calling setPaused(!isPaused()).
-
-    \sa setPaused(), pause(), resume()
-*/
-
-/*! \fn bool QFuture::isStarted() const
-
-    Returns true if the asynchronous computation represented by this future
-    has been started; otherwise returns false.
-*/
-
-/*! \fn bool QFuture::isFinished() const
-
-    Returns true if the asynchronous computation represented by this future
-    has finished; otherwise returns false.
-*/
-
-/*! \fn bool QFuture::isRunning() const
-
-    Returns true if the asynchronous computation represented by this future is
-    currently running; otherwise returns false.
-*/
-
-/*! \fn int QFuture::resultCount() const
-
-    Returns the number of continuous results available in this future. The real
-    number of results stored might be different from this value, due to gaps
-    in the result set. It is always safe to iterate through the results from 0
-    to resultCount().
-    \sa result(), resultAt(), results()
-*/
-
-/*! \fn int QFuture::progressValue() const
-
-    Returns the current progress value, which is between the progressMinimum()
-    and progressMaximum().
-
-    \sa progressMinimum(), progressMaximum()
-*/
-
-/*! \fn int QFuture::progressMinimum() const
-
-    Returns the minimum progressValue().
-
-    \sa progressValue(), progressMaximum()
-*/
-
-/*! \fn int QFuture::progressMaximum() const
-
-    Returns the maximum progressValue().
-
-    \sa progressValue(), progressMinimum()
-*/
-
-/*! \fn QString QFuture::progressText() const
-
-    Returns the (optional) textual representation of the progress as reported
-    by the asynchronous computation.
-
-    Be aware that not all computations provide a textual representation of the
-    progress, and as such, this function may return an empty string.
-*/
-
-/*! \fn void QFuture::waitForFinished()
-
-    Waits for the asynchronous computation to finish (including cancel()ed
-    computations).
-*/
-
-/*! \fn T QFuture::result() const
-
-    Returns the first result in the future. If the result is not immediately
-    available, this function will block and wait for the result to become
-    available. This is a convenience method for calling resultAt(0).
-
-    \sa resultAt(), results()
-*/
-
-/*! \fn T QFuture::resultAt(int index) const
-
-    Returns the result at \a index in the future. If the result is not
-    immediately available, this function will block and wait for the result to
-    become available.
-
-    \sa result(), results(), resultCount()
-*/
-
-/*! \fn bool QFuture::isResultReadyAt(int index) const
-
-    Returns true if the result at \a index is immediately available; otherwise
-    returns false.
-
-    \sa resultAt(), resultCount()
-*/
-
-/*! \fn QFuture::operator T() const
-
-    Returns the first result in the future. If the result is not immediately
-    available, this function will block and wait for the result to become
-    available. This is a convenience method for calling result() or
-    resultAt(0).
-
-    \sa result(), resultAt(), results()
-*/
-
-/*! \fn QList<T> QFuture::results() const
-
-    Returns all results from the future. If the results are not immediately
-    available, this function will block and wait for them to become available.
-
-    \sa result(), resultAt(), resultCount()
-*/
-
-/*! \fn QFuture::const_iterator QFuture::begin() const
-
-    Returns a const \l{STL-style iterator} pointing to the first result in the
-    future.
-
-    \sa constBegin(), end()
-*/
-
-/*! \fn QFuture::const_iterator QFuture::end() const
-
-    Returns a const \l{STL-style iterator} pointing to the imaginary result
-    after the last result in the future.
-
-    \sa begin(), constEnd()
-*/
-
-/*! \fn QFuture::const_iterator QFuture::constBegin() const
-
-    Returns a const \l{STL-style iterator} pointing to the first result in the
-    future.
-
-    \sa begin(), constEnd()
-*/
-
-/*! \fn QFuture::const_iterator QFuture::constEnd() const
-
-    Returns a const \l{STL-style iterator} pointing to the imaginary result
-    after the last result in the future.
-
-    \sa constBegin(), end()
-*/
-
-/*! \class QFuture::const_iterator
-    \reentrant
-    \since 4.4
-
-    \brief The QFuture::const_iterator class provides an STL-style const
-    iterator for QFuture.
-
-    QFuture provides both \l{STL-style iterators} and \l{Java-style iterators}.
-    The STL-style iterators are more low-level and more cumbersome to use; on
-    the other hand, they are slightly faster and, for developers who already
-    know STL, have the advantage of familiarity.
-
-    The default QFuture::const_iterator constructor creates an uninitialized
-    iterator. You must initialize it using a QFuture function like
-    QFuture::constBegin() or QFuture::constEnd() before you start iterating.
-    Here's a typical loop that prints all the results available in a future:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuture.cpp 0
-
-    \sa QFutureIterator, QFuture
-*/
-
-/*! \typedef QFuture::const_iterator::iterator_category
-
-    Typedef for std::bidirectional_iterator_tag. Provided for STL compatibility.
-*/
-
-/*! \typedef QFuture::const_iterator::difference_type
-
-    Typedef for ptrdiff_t. Provided for STL compatibility.
-*/
-
-/*! \typedef QFuture::const_iterator::value_type
-
-    Typedef for T. Provided for STL compatibility.
-*/
-
-/*! \typedef QFuture::const_iterator::pointer
-
-    Typedef for const T *. Provided for STL compatibility.
-*/
-
-/*! \typedef QFuture::const_iterator::reference
-
-    Typedef for const T &. Provided for STL compatibility.
-*/
-
-/*! \fn QFuture::const_iterator::const_iterator()
-
-    Constructs an uninitialized iterator.
-
-    Functions like operator*() and operator++() should not be called on an
-    uninitialized iterartor. Use operator=() to assign a value to it before
-    using it.
-
-    \sa QFuture::constBegin() QFuture::constEnd()
-*/
-
-/*! \fn QFuture::const_iterator::const_iterator(QFuture const * const future, int index)
-    \internal
-*/
-
-/*! \fn QFuture::const_iterator::const_iterator(const const_iterator &other)
-
-    Constructs a copy of \a other.
-*/
-
-/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator=(const const_iterator &other)
-
-    Assigns \a other to this iterator.
-*/
-
-/*! \fn const T &QFuture::const_iterator::operator*() const
-
-    Returns the current result.
-*/
-
-/*! \fn const T *QFuture::const_iterator::operator->() const
-
-    Returns a pointer to the current result.
-*/
-
-/*! \fn bool QFuture::const_iterator::operator!=(const const_iterator &other) const
-
-    Returns true if \a other points to a different result than this iterator;
-    otherwise returns false.
-
-    \sa operator==()
-*/
-
-/*! \fn bool QFuture::const_iterator::operator==(const const_iterator &other) const
-
-    Returns true if \a other points to the same result as this iterator;
-    otherwise returns false.
-
-    \sa operator!=()
-*/
-
-/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator++()
-
-    The prefix ++ operator (\c{++it}) advances the iterator to the next result
-    in the future and returns an iterator to the new current result.
-
-    Calling this function on QFuture::constEnd() leads to undefined results.
-
-    \sa operator--()
-*/
-
-/*! \fn QFuture::const_iterator QFuture::const_iterator::operator++(int)
-
-    \overload
-
-    The postfix ++ operator (\c{it++}) advances the iterator to the next
-    result in the future and returns an iterator to the previously current
-    result.
-*/
-
-/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator--()
-
-    The prefix -- operator (\c{--it}) makes the preceding result current and
-    returns an iterator to the new current result.
-
-    Calling this function on QFuture::constBegin() leads to undefined results.
-
-    \sa operator++()
-*/
-
-/*! \fn QFuture::const_iterator QFuture::const_iterator::operator--(int)
-
-    \overload
-
-    The postfix -- operator (\c{it--}) makes the preceding result current and
-    returns an iterator to the previously current result.
-*/
-
-/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator+=(int j)
-
-    Advances the iterator by \a j results. (If \a j is negative, the iterator
-    goes backward.)
-
-    \sa operator-=(), operator+()
-*/
-
-/*! \fn QFuture::const_iterator &QFuture::const_iterator::operator-=(int j)
-
-    Makes the iterator go back by \a j results. (If \a j is negative, the
-    iterator goes forward.)
-
-    \sa operator+=(), operator-()
-*/
-
-/*! \fn QFuture::const_iterator QFuture::const_iterator::operator+(int j) const
-
-    Returns an iterator to the results at \a j positions forward from this
-    iterator. (If \a j is negative, the iterator goes backward.)
-
-    \sa operator-(), operator+=()
-*/
-
-/*! \fn QFuture::const_iterator QFuture::const_iterator::operator-(int j) const
-
-    Returns an iterator to the result at \a j positions backward from this
-    iterator. (If \a j is negative, the iterator goes forward.)
-
-    \sa operator+(), operator-=()
-*/
-
-/*! \typedef QFuture::ConstIterator
-
-    Qt-style synonym for QFuture::const_iterator.
-*/
-
-/*!
-    \class QFutureIterator
-    \reentrant
-    \since 4.4
-    \inmodule QtCore
-
-    \brief The QFutureIterator class provides a Java-style const iterator for
-    QFuture.
-
-    QFuture has both \l{Java-style iterators} and \l{STL-style iterators}. The
-    Java-style iterators are more high-level and easier to use than the
-    STL-style iterators; on the other hand, they are slightly less efficient.
-
-    An alternative to using iterators is to use index positions. Some QFuture
-    member functions take an index as their first parameter, making it
-    possible to access results without using iterators.
-
-    QFutureIterator\<T\> allows you to iterate over a QFuture\<T\>. Note that
-    there is no mutable iterator for QFuture (unlike the other Java-style
-    iterators).
-
-    The QFutureIterator constructor takes a QFuture as its argument. After
-    construction, the iterator is located at the very beginning of the result
-    list (i.e. before the first result). Here's how to iterate over all the
-    results sequentially:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuture.cpp 1
-
-    The next() function returns the next result (waiting for it to become
-    available, if necessary) from the future and advances the iterator. Unlike
-    STL-style iterators, Java-style iterators point \e between results rather
-    than directly \e at results. The first call to next() advances the iterator
-    to the position between the first and second result, and returns the first
-    result; the second call to next() advances the iterator to the position
-    between the second and third result, and returns the second result; and
-    so on.
-
-    \img javaiterators1.png
-
-    Here's how to iterate over the elements in reverse order:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuture.cpp 2
-
-    If you want to find all occurrences of a particular value, use findNext()
-    or findPrevious() in a loop.
-
-    Multiple iterators can be used on the same future. If the future is
-    modified while a QFutureIterator is active, the QFutureIterator will
-    continue iterating over the original future, ignoring the modified copy.
-
-    \sa QFuture::const_iterator, QFuture
-*/
-
-/*!
-    \fn QFutureIterator::QFutureIterator(const QFuture<T> &future)
-
-    Constructs an iterator for traversing \a future. The iterator is set to be
-    at the front of the result list (before the first result).
-
-    \sa operator=()
-*/
-
-/*! \fn QFutureIterator &QFutureIterator::operator=(const QFuture<T> &future)
-
-    Makes the iterator operate on \a future. The iterator is set to be at the
-    front of the result list (before the first result).
-
-    \sa toFront(), toBack()
-*/
-
-/*! \fn void QFutureIterator::toFront()
-
-    Moves the iterator to the front of the result list (before the first
-    result).
-
-    \sa toBack(), next()
-*/
-
-/*! \fn void QFutureIterator::toBack()
-
-    Moves the iterator to the back of the result list (after the last result).
-
-    \sa toFront(), previous()
-*/
-
-/*! \fn bool QFutureIterator::hasNext() const
-
-    Returns true if there is at least one result ahead of the iterator, e.g.,
-    the iterator is \e not at the back of the result list; otherwise returns
-    false.
-
-    \sa hasPrevious(), next()
-*/
-
-/*! \fn const T &QFutureIterator::next()
-
-    Returns the next result and advances the iterator by one position.
-
-    Calling this function on an iterator located at the back of the result
-    list leads to undefined results.
-
-    \sa hasNext(), peekNext(), previous()
-*/
-
-/*! \fn const T &QFutureIterator::peekNext() const
-
-    Returns the next result without moving the iterator.
-
-    Calling this function on an iterator located at the back of the result
-    list leads to undefined results.
-
-    \sa hasNext(), next(), peekPrevious()
-*/
-
-/*! \fn bool QFutureIterator::hasPrevious() const
-
-    Returns true if there is at least one result ahead of the iterator, e.g.,
-    the iterator is \e not at the front of the result list; otherwise returns
-    false.
-
-    \sa hasNext(), previous()
-*/
-
-/*! \fn const T &QFutureIterator::previous()
-
-    Returns the previous result and moves the iterator back by one position.
-
-    Calling this function on an iterator located at the front of the result
-    list leads to undefined results.
-
-    \sa hasPrevious(), peekPrevious(), next()
-*/
-
-/*! \fn const T &QFutureIterator::peekPrevious() const
-
-    Returns the previous result without moving the iterator.
-
-    Calling this function on an iterator located at the front of the result
-    list leads to undefined results.
-
-    \sa hasPrevious(), previous(), peekNext()
-*/
-
-/*! \fn bool QFutureIterator::findNext(const T &value)
-
-    Searches for \a value starting from the current iterator position forward.
-    Returns true if \a value is found; otherwise returns false.
-
-    After the call, if \a value was found, the iterator is positioned just
-    after the matching result; otherwise, the iterator is positioned at the
-    back of the result list.
-
-    \sa findPrevious()
-*/
-
-/*! \fn bool QFutureIterator::findPrevious(const T &value)
-
-    Searches for \a value starting from the current iterator position
-    backward. Returns true if \a value is found; otherwise returns false.
-
-    After the call, if \a value was found, the iterator is positioned just
-    before the matching result; otherwise, the iterator is positioned at the
-    front of the result list.
-
-    \sa findNext()
-*/
diff --git a/src/corelib/concurrent/qfuture.h b/src/corelib/concurrent/qfuture.h
deleted file mode 100644
index a22168a..0000000
--- a/src/corelib/concurrent/qfuture.h
+++ /dev/null
@@ -1,277 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QFUTURE_H
-#define QFUTURE_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_QFUTURE
-
-#include <QtCore/qfutureinterface.h>
-#include <QtCore/qstring.h>
-#include <QtCore/qtconcurrentcompilertest.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-template <typename T>
-class QFutureWatcher;
-template <>
-class QFutureWatcher<void>;
-
-template <typename T>
-class QFuture
-{
-public:
-    QFuture()
-        : d(QFutureInterface<T>::canceledResult())
-    { }
-    explicit QFuture(QFutureInterface<T> *p) // internal
-        : d(*p)
-    { }
-    QFuture(const QFuture &other)
-        : d(other.d)
-    { }
-    ~QFuture()
-    { }
-
-    inline QFuture &operator=(const QFuture &other);
-    bool operator==(const QFuture &other) const { return (d == other.d); }
-    bool operator!=(const QFuture &other) const { return (d != other.d); }
-
-    void cancel() { d.cancel(); }
-    bool isCanceled() const { return d.isCanceled(); }
-
-    void setPaused(bool paused) { d.setPaused(paused); }
-    bool isPaused() const { return d.isPaused(); }
-    void pause() { setPaused(true); }
-    void resume() { setPaused(false); }
-    void togglePaused() { d.togglePaused(); }
-
-    bool isStarted() const { return d.isStarted(); }
-    bool isFinished() const { return d.isFinished(); }
-    bool isRunning() const { return d.isRunning(); }
-
-    int resultCount() const { return d.resultCount(); }
-    int progressValue() const { return d.progressValue(); }
-    int progressMinimum() const { return d.progressMinimum(); }
-    int progressMaximum() const { return d.progressMaximum(); }
-    QString progressText() const { return d.progressText(); }
-    void waitForFinished() { d.waitForFinished(); }
-
-    inline T result() const;
-    inline T resultAt(int index) const;
-    bool isResultReadyAt(int resultIndex) const { return d.isResultReadyAt(resultIndex); }
-
-    operator T() const { return result(); }
-    QList<T> results() const { return d.results(); }
-
-    class const_iterator
-    {
-    public:
-        typedef std::bidirectional_iterator_tag iterator_category;
-        typedef qptrdiff difference_type;
-        typedef T value_type;
-        typedef const T *pointer;
-        typedef const T &reference;
-
-        inline const_iterator() {}
-        inline const_iterator(QFuture const * const _future, int _index) : future(_future), index(_index) {}
-        inline const_iterator(const const_iterator &o) : future(o.future), index(o.index)  {}
-        inline const_iterator &operator=(const const_iterator &o)
-        { future = o.future; index = o.index; return *this; }
-        inline const T &operator*() const { return future->d.resultReference(index); }
-        inline const T *operator->() const { return future->d.resultPointer(index); }
-
-        inline bool operator!=(const const_iterator &other) const
-        {
-            if (index == -1 && other.index == -1) // comparing end != end?
-                return false;
-            if (other.index == -1)
-                return (future->isRunning() || (index < future->resultCount()));
-            return (index != other.index);
-        }
-
-        inline bool operator==(const const_iterator &o) const { return !operator!=(o); }
-        inline const_iterator &operator++() { ++index; return *this; }
-        inline const_iterator operator++(int) { const_iterator r = *this; ++index; return r; }
-        inline const_iterator &operator--() { --index; return *this; }
-        inline const_iterator operator--(int) { const_iterator r = *this; --index; return r; }
-        inline const_iterator operator+(int j) const { return const_iterator(future, index + j); }
-        inline const_iterator operator-(int j) const { return const_iterator(future, index - j); }
-        inline const_iterator &operator+=(int j) { index += j; return *this; }
-        inline const_iterator &operator-=(int j) { index -= j; return *this; }
-    private:
-        QFuture const * future;
-        int index;
-    };
-    friend class const_iterator;
-    typedef const_iterator ConstIterator;
-
-    const_iterator begin() const { return  const_iterator(this, 0); }
-    const_iterator constBegin() const { return  const_iterator(this, 0); }
-    const_iterator end() const { return const_iterator(this, -1); }
-    const_iterator constEnd() const { return const_iterator(this, -1); }
-
-private:
-    friend class QFutureWatcher<T>;
-
-public: // Warning: the d pointer is not documented and is considered private.
-    mutable QFutureInterface<T> d;
-};
-
-template <typename T>
-inline QFuture<T> &QFuture<T>::operator=(const QFuture<T> &other)
-{
-    d = other.d;
-    return *this;
-}
-
-template <typename T>
-inline T QFuture<T>::result() const
-{
-    d.waitForResult(0);
-    return d.resultReference(0);
-}
-
-template <typename T>
-inline T QFuture<T>::resultAt(int index) const
-{
-    d.waitForResult(index);
-    return d.resultReference(index);
-}
-
-template <typename T>
-inline QFuture<T> QFutureInterface<T>::future()
-{
-    return QFuture<T>(this);
-}
-
-Q_DECLARE_SEQUENTIAL_ITERATOR(Future)
-
-template <>
-class QFuture<void>
-{
-public:
-    QFuture()
-        : d(QFutureInterface<void>::canceledResult())
-    { }
-    explicit QFuture(QFutureInterfaceBase *p) // internal
-        : d(*p)
-    { }
-    QFuture(const QFuture &other)
-        : d(other.d)
-    { }
-    ~QFuture()
-    { }
-
-    QFuture &operator=(const QFuture &other);
-    bool operator==(const QFuture &other) const { return (d == other.d); }
-    bool operator!=(const QFuture &other) const { return (d != other.d); }
-
-#if !defined(Q_CC_XLC)
-    template <typename T>
-    QFuture(const QFuture<T> &other)
-        : d(other.d)
-    { }
-
-    template <typename T>
-    QFuture<void> &operator=(const QFuture<T> &other)
-    {
-        d = other.d;
-        return *this;
-    }
-#endif
-
-    void cancel() { d.cancel(); }
-    bool isCanceled() const { return d.isCanceled(); }
-
-    void setPaused(bool paused) { d.setPaused(paused); }
-    bool isPaused() const { return d.isPaused(); }
-    void pause() { setPaused(true); }
-    void resume() { setPaused(false); }
-    void togglePaused() { d.togglePaused(); }
-
-    bool isStarted() const { return d.isStarted(); }
-    bool isFinished() const { return d.isFinished(); }
-    bool isRunning() const { return d.isRunning(); }
-
-    int resultCount() const { return d.resultCount(); }
-    int progressValue() const { return d.progressValue(); }
-    int progressMinimum() const { return d.progressMinimum(); }
-    int progressMaximum() const { return d.progressMaximum(); }
-    QString progressText() const { return d.progressText(); }
-    void waitForFinished() { d.waitForFinished(); }
-
-private:
-    friend class QFutureWatcher<void>;
-
-#ifdef QFUTURE_TEST
-public:
-#endif
-    mutable QFutureInterfaceBase d;
-};
-
-inline QFuture<void> &QFuture<void>::operator=(const QFuture<void> &other)
-{
-    d = other.d;
-    return *this;
-}
-
-inline QFuture<void> QFutureInterface<void>::future()
-{
-    return QFuture<void>(this);
-}
-
-template <typename T>
-QFuture<void> qToVoidFuture(const QFuture<T> &future)
-{
-    return QFuture<void>(future.d);
-}
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif // QFUTURE_H
diff --git a/src/corelib/concurrent/qfutureinterface.cpp b/src/corelib/concurrent/qfutureinterface.cpp
deleted file mode 100644
index 9a273a1..0000000
--- a/src/corelib/concurrent/qfutureinterface.cpp
+++ /dev/null
@@ -1,565 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-// qfutureinterface.h included from qfuture.h
-#include "qfuture.h"
-
-#ifndef QT_NO_QFUTURE
-
-#include <QtCore/qatomic.h>
-#include <QtCore/qthread.h>
-#include <QtCore/qthreadpool.h>
-#include <private/qthreadpool_p.h>
-
-#include "qfutureinterface_p.h"
-
-QT_BEGIN_NAMESPACE
-
-enum {
-    MaxProgressEmitsPerSecond = 25
-};
-
-QFutureInterfaceBase::QFutureInterfaceBase(State initialState)
-    : d(new QFutureInterfaceBasePrivate(initialState))
-{ }
-
-QFutureInterfaceBase::QFutureInterfaceBase(const QFutureInterfaceBase &other)
-    : d(other.d)
-{
-    d->refCount.ref();
-}
-
-QFutureInterfaceBase::~QFutureInterfaceBase()
-{
-    if (!d->refCount.deref())
-        delete d;
-}
-
-void QFutureInterfaceBase::cancel()
-{
-    QMutexLocker locker(&d->m_mutex);
-    if (d->state & Canceled)
-        return;
-
-    d->state = State((d->state & ~Paused) | Canceled);
-    d->waitCondition.wakeAll();
-    d->pausedWaitCondition.wakeAll();
-    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Canceled));
-}
-
-void QFutureInterfaceBase::setPaused(bool paused)
-{
-    QMutexLocker locker(&d->m_mutex);
-    if (paused) {
-        d->state = State(d->state | Paused);
-        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Paused));
-    } else {
-        d->state = State(d->state & ~Paused);
-        d->pausedWaitCondition.wakeAll();
-        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Resumed));
-    }
-}
-
-void QFutureInterfaceBase::togglePaused()
-{
-    QMutexLocker locker(&d->m_mutex);
-    if (d->state & Paused) {
-        d->state = State(d->state & ~Paused);
-        d->pausedWaitCondition.wakeAll();
-        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Resumed));
-    } else {
-        d->state = State(d->state | Paused);
-        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Paused));
-    }
-}
-
-void QFutureInterfaceBase::setThrottled(bool enable)
-{
-    // bail out if we are not changing the state
-    if ((enable && (d->state & Throttled)) || (!enable && !(d->state & Throttled)))
-        return;
-
-    // lock and change the state
-    QMutexLocker lock(&d->m_mutex);
-    if (enable) {
-        d->state  = State(d->state | Throttled);
-    } else {
-        d->state  = State(d->state & ~Throttled);
-        if (!(d->state & Paused))
-            d->pausedWaitCondition.wakeAll();
-    }
-}
-
-
-bool QFutureInterfaceBase::isRunning() const
-{
-    return queryState(Running);
-}
-
-bool QFutureInterfaceBase::isStarted() const
-{
-    return queryState(Started);
-}
-
-bool QFutureInterfaceBase::isCanceled() const
-{
-    return queryState(Canceled);
-}
-
-bool QFutureInterfaceBase::isFinished() const
-{
-    return queryState(Finished);
-}
-
-bool QFutureInterfaceBase::isPaused() const
-{
-    return queryState(Paused);
-}
-
-bool QFutureInterfaceBase::isThrottled() const
-{
-    return queryState(Throttled);
-}
-
-bool QFutureInterfaceBase::isResultReadyAt(int index) const
-{
-    QMutexLocker lock(&d->m_mutex);
-    return d->internal_isResultReadyAt(index);
-}
-
-bool QFutureInterfaceBase::waitForNextResult()
-{
-    QMutexLocker lock(&d->m_mutex);
-    return d->internal_waitForNextResult();
-}
-
-void QFutureInterfaceBase::waitForResume()
-{
-    // return early if possible to avoid taking the mutex lock.
-    if ((d->state & Paused) == false || (d->state & Canceled))
-        return;
-
-    QMutexLocker lock(&d->m_mutex);
-    if ((d->state & Paused) == false || (d->state & Canceled))
-        return;
-
-    // decrease active thread count since this thread will wait.
-    QThreadPool::globalInstance()->releaseThread();
-
-    d->pausedWaitCondition.wait(&d->m_mutex);
-
-    QThreadPool::globalInstance()->reserveThread();
-}
-
-int QFutureInterfaceBase::progressValue() const
-{
-    return d->m_progressValue;
-}
-
-int QFutureInterfaceBase::progressMinimum() const
-{
-    return d->m_progressMinimum;
-}
-
-int QFutureInterfaceBase::progressMaximum() const
-{
-    return d->m_progressMaximum;
-}
-
-int QFutureInterfaceBase::resultCount() const
-{
-    QMutexLocker lock(&d->m_mutex);
-    return d->internal_resultCount();
-}
-
-QString QFutureInterfaceBase::progressText() const
-{
-    QMutexLocker locker(&d->m_mutex);
-    return d->m_progressText;
-}
-
-bool QFutureInterfaceBase::isProgressUpdateNeeded() const
-{
-    QMutexLocker locker(&d->m_mutex);
-    return !d->progressTime.isValid() || (d->progressTime.elapsed() > (1000 / MaxProgressEmitsPerSecond));
-}
-
-void QFutureInterfaceBase::reportStarted()
-{
-    QMutexLocker locker(&d->m_mutex);
-    if ((d->state & Started) || (d->state & Canceled) || (d->state & Finished))
-        return;
-
-    d->setState(State(Started | Running));
-    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Started));
-}
-
-void QFutureInterfaceBase::reportCanceled()
-{
-    cancel();
-}
-
-#ifndef QT_NO_EXCEPTIONS
-void QFutureInterfaceBase::reportException(const QtConcurrent::Exception &exception)
-{
-    QMutexLocker locker(&d->m_mutex);
-    if ((d->state & Canceled) || (d->state & Finished))
-        return;
-
-    d->m_exceptionStore.setException(exception);
-    d->state = State(d->state | Canceled);
-    d->waitCondition.wakeAll();
-    d->pausedWaitCondition.wakeAll();
-    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Canceled));
-}
-#endif
-
-void QFutureInterfaceBase::reportFinished()
-{
-    QMutexLocker locker(&d->m_mutex);
-    if (!(d->state & Finished)) {
-        d->state = State((d->state & ~Running) | Finished);
-        d->waitCondition.wakeAll();
-        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Finished));
-    }
-}
-
-void QFutureInterfaceBase::setExpectedResultCount(int resultCount)
-{
-    if (d->manualProgress == false)
-        setProgressRange(0, resultCount);
-    d->m_expectedResultCount = resultCount;
-}
-
-int QFutureInterfaceBase::expectedResultCount()
-{
-    return d->m_expectedResultCount;
-}
-
-bool QFutureInterfaceBase::queryState(State state) const
-{
-    return (d->state & state);
-}
-
-void QFutureInterfaceBase::waitForResult(int resultIndex)
-{
-    d->m_exceptionStore.throwPossibleException();
-
-    if (!(d->state & Running))
-        return;
-
-    // To avoid deadlocks and reduce the number of threads used, try to 
-    // run the runnable in the current thread.
-    QThreadPool::globalInstance()->d_func()->stealRunnable(d->runnable);
-
-    QMutexLocker lock(&d->m_mutex);
-
-    if (!(d->state & Running))
-        return;
-
-    const int waitIndex = (resultIndex == -1) ? INT_MAX : resultIndex;
-    while ((d->state & Running) && d->internal_isResultReadyAt(waitIndex) == false)
-        d->waitCondition.wait(&d->m_mutex);
-
-    d->m_exceptionStore.throwPossibleException();
-}
-
-void QFutureInterfaceBase::waitForFinished()
-{
-    if (d->state & Running) {
-        QThreadPool::globalInstance()->d_func()->stealRunnable(d->runnable);
-
-        QMutexLocker lock(&d->m_mutex);
-
-        while (d->state & Running)
-            d->waitCondition.wait(&d->m_mutex);
-    }
-
-    d->m_exceptionStore.throwPossibleException();
-}
-
-void QFutureInterfaceBase::reportResultsReady(int beginIndex, int endIndex)
-{
-    if ((d->state & Canceled) || (d->state & Finished) || beginIndex == endIndex)
-        return;
-
-    d->waitCondition.wakeAll();
-
-    if (d->manualProgress == false) {
-        if (d->internal_updateProgress(d->m_progressValue + endIndex - beginIndex) == false) {
-            d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::ResultsReady,
-                                               beginIndex,
-                                               endIndex));
-            return;
-        }
-
-        d->sendCallOuts(QFutureCallOutEvent(QFutureCallOutEvent::Progress,
-                                            d->m_progressValue,
-                                            d->m_progressText),
-                        QFutureCallOutEvent(QFutureCallOutEvent::ResultsReady,
-                                            beginIndex,
-                                            endIndex));
-        return;
-    }
-    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::ResultsReady, beginIndex, endIndex));
-}
-
-void QFutureInterfaceBase::setRunnable(QRunnable *runnable)
-{
-    d->runnable = runnable;
-}
-
-void QFutureInterfaceBase::setFilterMode(bool enable)
-{
-    QMutexLocker locker(&d->m_mutex);
-    resultStoreBase().setFilterMode(enable);
-}
-
-void QFutureInterfaceBase::setProgressRange(int minimum, int maximum)
-{
-    QMutexLocker locker(&d->m_mutex);
-    d->m_progressMinimum = minimum;
-    d->m_progressMaximum = maximum;
-    d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::ProgressRange, minimum, maximum));
-}
-
-void QFutureInterfaceBase::setProgressValue(int progressValue)
-{
-    setProgressValueAndText(progressValue, QString());
-}
-
-void QFutureInterfaceBase::setProgressValueAndText(int progressValue,
-                                                   const QString &progressText)
-{
-    QMutexLocker locker(&d->m_mutex);
-    if (d->manualProgress == false)
-        d->manualProgress = true;
-    if (d->m_progressValue >= progressValue)
-        return;
-
-    if ((d->state & Canceled) || (d->state & Finished))
-        return;
-
-    if (d->internal_updateProgress(progressValue, progressText)) {
-        d->sendCallOut(QFutureCallOutEvent(QFutureCallOutEvent::Progress,
-                                           d->m_progressValue,
-                                           d->m_progressText));
-    }
-}
-
-QMutex *QFutureInterfaceBase::mutex() const
-{
-    return &d->m_mutex;
-}
-
-QtConcurrent::internal::ExceptionStore &QFutureInterfaceBase::exceptionStore()
-{
-    return d->m_exceptionStore;
-}
-
-QtConcurrent::ResultStoreBase &QFutureInterfaceBase::resultStoreBase()
-{
-    return d->m_results;
-}
-
-const QtConcurrent::ResultStoreBase &QFutureInterfaceBase::resultStoreBase() const
-{
-    return d->m_results;
-}
-
-QFutureInterfaceBase &QFutureInterfaceBase::operator=(const QFutureInterfaceBase &other)
-{
-    other.d->refCount.ref();
-    if (!d->refCount.deref())
-        delete d;
-    d = other.d;
-    return *this;
-}
-
-bool QFutureInterfaceBase::referenceCountIsOne() const
-{
-    return d->refCount.load() == 1;
-}
-
-QFutureInterfaceBasePrivate::QFutureInterfaceBasePrivate(QFutureInterfaceBase::State initialState)
-    : refCount(1), m_progressValue(0), m_progressMinimum(0), m_progressMaximum(0),
-      state(initialState), pendingResults(0),
-      manualProgress(false), m_expectedResultCount(0), runnable(0)
-{
-    progressTime.invalidate();
-}
-
-int QFutureInterfaceBasePrivate::internal_resultCount() const
-{
-    return m_results.count(); // ### subtract canceled results.
-}
-
-bool QFutureInterfaceBasePrivate::internal_isResultReadyAt(int index) const
-{
-    return (m_results.contains(index));
-}
-
-bool QFutureInterfaceBasePrivate::internal_waitForNextResult()
-{
-    if (m_results.hasNextResult())
-        return true;
-
-    while ((state & QFutureInterfaceBase::Running) && m_results.hasNextResult() == false)
-        waitCondition.wait(&m_mutex);
-
-    return (!(state & QFutureInterfaceBase::Canceled) && m_results.hasNextResult());
-}
-
-bool QFutureInterfaceBasePrivate::internal_updateProgress(int progress,
-                                                          const QString &progressText)
-{
-    if (m_progressValue >= progress)
-        return false;
-
-    m_progressValue = progress;
-    m_progressText = progressText;
-
-    if (progressTime.isValid() && m_progressValue != m_progressMaximum) // make sure the first and last steps are emitted.
-        if (progressTime.elapsed() < (1000 / MaxProgressEmitsPerSecond))
-            return false;
-
-    progressTime.start();
-    return true;
-}
-
-void QFutureInterfaceBasePrivate::internal_setThrottled(bool enable)
-{
-    // bail out if we are not changing the state
-    if ((enable && (state & QFutureInterfaceBase::Throttled))
-        || (!enable && !(state & QFutureInterfaceBase::Throttled)))
-        return;
-
-    // change the state
-    if (enable) {
-        state  = QFutureInterfaceBase::State(state | QFutureInterfaceBase::Throttled);
-    } else {
-        state  = QFutureInterfaceBase::State(state & ~QFutureInterfaceBase::Throttled);
-        if (!(state & QFutureInterfaceBase::Paused))
-            pausedWaitCondition.wakeAll();
-    }
-}
-
-void QFutureInterfaceBasePrivate::sendCallOut(const QFutureCallOutEvent &callOutEvent)
-{
-    if (outputConnections.isEmpty())
-        return;
-
-    for (int i = 0; i < outputConnections.count(); ++i)
-        outputConnections.at(i)->postCallOutEvent(callOutEvent);
-}
-
-void QFutureInterfaceBasePrivate::sendCallOuts(const QFutureCallOutEvent &callOutEvent1,
-                                     const QFutureCallOutEvent &callOutEvent2)
-{
-    if (outputConnections.isEmpty())
-        return;
-
-    for (int i = 0; i < outputConnections.count(); ++i) {
-        QFutureCallOutInterface *interface = outputConnections.at(i);
-        interface->postCallOutEvent(callOutEvent1);
-        interface->postCallOutEvent(callOutEvent2);
-    }
-}
-
-// This function connects an output interface (for example a QFutureWatcher)
-// to this future. While holding the lock we check the state and ready results
-// and add the appropriate callouts to the queue. In order to avoid deadlocks,
-// the actual callouts are made at the end while not holding the lock.
-void QFutureInterfaceBasePrivate::connectOutputInterface(QFutureCallOutInterface *interface)
-{
-    QMutexLocker locker(&m_mutex);
-
-    if (state & QFutureInterfaceBase::Started) {
-        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Started));
-        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::ProgressRange,
-                                                        m_progressMinimum,
-                                                        m_progressMaximum));
-        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Progress,
-                                                        m_progressValue,
-                                                        m_progressText));
-    }
-
-    QtConcurrent::ResultIteratorBase it = m_results.begin();
-    while (it != m_results.end()) {
-        const int begin = it.resultIndex();
-        const int end = begin + it.batchSize();
-        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::ResultsReady,
-                                                        begin,
-                                                        end));
-        it.batchedAdvance();
-    }
-
-    if (state & QFutureInterfaceBase::Paused)
-        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Paused));
-
-    if (state & QFutureInterfaceBase::Canceled)
-        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Canceled));
-
-    if (state & QFutureInterfaceBase::Finished)
-        interface->postCallOutEvent(QFutureCallOutEvent(QFutureCallOutEvent::Finished));
-
-    outputConnections.append(interface);
-}
-
-void QFutureInterfaceBasePrivate::disconnectOutputInterface(QFutureCallOutInterface *interface)
-{
-    QMutexLocker lock(&m_mutex);
-    const int index = outputConnections.indexOf(interface);
-    if (index == -1)
-        return;
-    outputConnections.removeAt(index);
-
-    interface->callOutInterfaceDisconnected();
-}
-
-void QFutureInterfaceBasePrivate::setState(QFutureInterfaceBase::State newState)
-{
-    state = newState;
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_CONCURRENT
diff --git a/src/corelib/concurrent/qfutureinterface.h b/src/corelib/concurrent/qfutureinterface.h
deleted file mode 100644
index 85272bc5..0000000
--- a/src/corelib/concurrent/qfutureinterface.h
+++ /dev/null
@@ -1,312 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QFUTUREINTERFACE_H
-#define QFUTUREINTERFACE_H
-
-#include <QtCore/qglobal.h>
-#include <QtCore/qrunnable.h>
-
-#ifndef QT_NO_QFUTURE
-
-#include <QtCore/qmutex.h>
-#include <QtCore/qtconcurrentexception.h>
-#include <QtCore/qtconcurrentresultstore.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-template <typename T> class QFuture;
-class QFutureInterfaceBasePrivate;
-class QFutureWatcherBase;
-class QFutureWatcherBasePrivate;
-
-class Q_CORE_EXPORT QFutureInterfaceBase
-{
-public:
-    enum State {
-        NoState   = 0x00,
-        Running   = 0x01,
-        Started   = 0x02,
-        Finished  = 0x04,
-        Canceled  = 0x08,
-        Paused    = 0x10,
-        Throttled = 0x20
-    };
-
-    QFutureInterfaceBase(State initialState = NoState);
-    QFutureInterfaceBase(const QFutureInterfaceBase &other);
-    virtual ~QFutureInterfaceBase();
-
-    // reporting functions available to the engine author:
-    void reportStarted();
-    void reportFinished();
-    void reportCanceled();
-#ifndef QT_NO_EXCEPTIONS
-    void reportException(const QtConcurrent::Exception &e);
-#endif
-    void reportResultsReady(int beginIndex, int endIndex);
-
-    void setRunnable(QRunnable *runnable);
-    void setFilterMode(bool enable);
-    void setProgressRange(int minimum, int maximum);
-    int progressMinimum() const;
-    int progressMaximum() const;
-    bool isProgressUpdateNeeded() const;
-    void setProgressValue(int progressValue);
-    int progressValue() const;
-    void setProgressValueAndText(int progressValue, const QString &progressText);
-    QString progressText() const;
-
-    void setExpectedResultCount(int resultCount);
-    int expectedResultCount();
-    int resultCount() const;
-
-    bool queryState(State state) const;
-    bool isRunning() const;
-    bool isStarted() const;
-    bool isCanceled() const;
-    bool isFinished() const;
-    bool isPaused() const;
-    bool isThrottled() const;
-    bool isResultReadyAt(int index) const;
-
-    void cancel();
-    void setPaused(bool paused);
-    void togglePaused();
-    void setThrottled(bool enable);
-
-    void waitForFinished();
-    bool waitForNextResult();
-    void waitForResult(int resultIndex);
-    void waitForResume();
-
-    QMutex *mutex() const;
-    QtConcurrent::internal::ExceptionStore &exceptionStore();
-    QtConcurrent::ResultStoreBase &resultStoreBase();
-    const QtConcurrent::ResultStoreBase &resultStoreBase() const;
-
-    inline bool operator==(const QFutureInterfaceBase &other) const { return d == other.d; }
-    inline bool operator!=(const QFutureInterfaceBase &other) const { return d != other.d; }
-    QFutureInterfaceBase &operator=(const QFutureInterfaceBase &other);
-
-protected:
-    bool referenceCountIsOne() const;
-public:
-
-#ifndef QFUTURE_TEST
-private:
-#endif
-    QFutureInterfaceBasePrivate *d;
-
-private:
-    friend class QFutureWatcherBase;
-    friend class QFutureWatcherBasePrivate;
-};
-
-template <typename T>
-class QFutureInterface : public QFutureInterfaceBase
-{
-public:
-    QFutureInterface(State initialState = NoState)
-        : QFutureInterfaceBase(initialState)
-    { }
-    QFutureInterface(const QFutureInterface &other)
-        : QFutureInterfaceBase(other)
-    { }
-    ~QFutureInterface()
-    {
-        if (referenceCountIsOne())
-            resultStore().clear();
-    }
-
-    static QFutureInterface canceledResult()
-    { return QFutureInterface(State(Started | Finished | Canceled)); }
-
-    QFutureInterface &operator=(const QFutureInterface &other)
-    {
-        if (referenceCountIsOne())
-            resultStore().clear();
-        QFutureInterfaceBase::operator=(other);
-        return *this;
-    }
-
-    inline QFuture<T> future(); // implemented in qfuture.h
-
-    inline void reportResult(const T *result, int index = -1);
-    inline void reportResult(const T &result, int index = -1);
-    inline void reportResults(const QVector<T> &results, int beginIndex = -1, int count = -1);
-    inline void reportFinished(const T *result = 0);
-
-    inline const T &resultReference(int index) const;
-    inline const T *resultPointer(int index) const;
-    inline QList<T> results();
-private:
-    QtConcurrent::ResultStore<T> &resultStore()
-    { return static_cast<QtConcurrent::ResultStore<T> &>(resultStoreBase()); }
-    const QtConcurrent::ResultStore<T> &resultStore() const
-    { return static_cast<const QtConcurrent::ResultStore<T> &>(resultStoreBase()); }
-};
-
-template <typename T>
-inline void QFutureInterface<T>::reportResult(const T *result, int index)
-{
-    QMutexLocker locker(mutex());
-    if (this->queryState(Canceled) || this->queryState(Finished)) {
-        return;
-    }
-
-    QtConcurrent::ResultStore<T> &store = resultStore();
-
-
-    if (store.filterMode()) {
-        const int resultCountBefore = store.count();
-        store.addResult(index, result);
-        this->reportResultsReady(resultCountBefore, resultCountBefore + store.count());
-    } else {
-        const int insertIndex = store.addResult(index, result);
-        this->reportResultsReady(insertIndex, insertIndex + 1);
-    }
-}
-
-template <typename T>
-inline void QFutureInterface<T>::reportResult(const T &result, int index)
-{
-    reportResult(&result, index);
-}
-
-template <typename T>
-inline void QFutureInterface<T>::reportResults(const QVector<T> &_results, int beginIndex, int count)
-{
-    QMutexLocker locker(mutex());
-    if (this->queryState(Canceled) || this->queryState(Finished)) {
-        return;
-    }
-
-    QtConcurrent::ResultStore<T> &store = resultStore();
-
-    if (store.filterMode()) {
-        const int resultCountBefore = store.count();
-        store.addResults(beginIndex, &_results, count);
-        this->reportResultsReady(resultCountBefore, store.count());
-    } else {
-        const int insertIndex = store.addResults(beginIndex, &_results, count);
-        this->reportResultsReady(insertIndex, insertIndex + _results.count());    
-    }
-}
-
-template <typename T>
-inline void QFutureInterface<T>::reportFinished(const T *result)
-{
-    if (result)
-        reportResult(result);
-    QFutureInterfaceBase::reportFinished();
-}
-
-template <typename T>
-inline const T &QFutureInterface<T>::resultReference(int index) const
-{
-    QMutexLocker lock(mutex());
-    return resultStore().resultAt(index).value();
-}
-
-template <typename T>
-inline const T *QFutureInterface<T>::resultPointer(int index) const
-{
-    QMutexLocker lock(mutex());
-    return resultStore().resultAt(index).pointer();
-}
-
-template <typename T>
-inline QList<T> QFutureInterface<T>::results()
-{
-    if (this->isCanceled()) {
-        exceptionStore().throwPossibleException();
-        return QList<T>();
-    }
-    QFutureInterfaceBase::waitForResult(-1);
-
-    QList<T> res;
-    QMutexLocker lock(mutex());
-
-    QtConcurrent::ResultIterator<T> it = resultStore().begin();
-    while (it != resultStore().end()) {
-        res.append(it.value());
-        ++it;
-    }
-
-    return res;
-}
-
-template <>
-class QFutureInterface<void> : public QFutureInterfaceBase
-{
-public:
-    QFutureInterface<void>(State initialState = NoState)
-        : QFutureInterfaceBase(initialState)
-    { }
-    QFutureInterface<void>(const QFutureInterface<void> &other)
-        : QFutureInterfaceBase(other)
-    { }
-
-    static QFutureInterface<void> canceledResult()
-    { return QFutureInterface(State(Started | Finished | Canceled)); }
-
-    QFutureInterface<void> &operator=(const QFutureInterface<void> &other)
-    {
-        QFutureInterfaceBase::operator=(other);
-        return *this;
-    }
-
-    inline QFuture<void> future(); // implemented in qfuture.h
-
-    void reportResult(const void *, int) { }
-    void reportResults(const QVector<void> &, int) { }
-    void reportFinished(void * = 0) { QFutureInterfaceBase::reportFinished(); }
-};
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif // QFUTUREINTERFACE_H
diff --git a/src/corelib/concurrent/qfutureinterface_p.h b/src/corelib/concurrent/qfutureinterface_p.h
deleted file mode 100644
index ea52621..0000000
--- a/src/corelib/concurrent/qfutureinterface_p.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QFUTUREINTERFACE_P_H
-#define QFUTUREINTERFACE_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtCore/qelapsedtimer.h>
-#include <QtCore/qcoreevent.h>
-#include <QtCore/qlist.h>
-#include <QtCore/qwaitcondition.h>
-#include <QtCore/qrunnable.h>
-
-QT_BEGIN_NAMESPACE
-
-class QFutureCallOutEvent : public QEvent
-{
-public:
-    enum CallOutType {
-        Started,
-        Finished,
-        Canceled,
-        Paused,
-        Resumed,
-        Progress,
-        ProgressRange,
-        ResultsReady
-    };
-
-    QFutureCallOutEvent()
-        : QEvent(QEvent::FutureCallOut), callOutType(CallOutType(0)), index1(-1), index2(-1)
-    { }
-    QFutureCallOutEvent(CallOutType callOutType, int index1 = -1)
-        : QEvent(QEvent::FutureCallOut), callOutType(callOutType), index1(index1), index2(-1)
-    { }
-    QFutureCallOutEvent(CallOutType callOutType, int index1, int index2)
-        : QEvent(QEvent::FutureCallOut), callOutType(callOutType), index1(index1), index2(index2)
-    { }
-
-    QFutureCallOutEvent(CallOutType callOutType, int index1, const QString &text)
-        : QEvent(QEvent::FutureCallOut),
-          callOutType(callOutType),
-          index1(index1),
-          index2(-1),
-          text(text)
-    { }
-
-    CallOutType callOutType;
-    int index1;
-    int index2;
-    QString text;
-
-    QFutureCallOutEvent *clone() const
-    {
-        return new QFutureCallOutEvent(callOutType, index1, index2, text);
-    }
-
-private:
-    QFutureCallOutEvent(CallOutType callOutType,
-                        int index1,
-                        int index2,
-                        const QString &text)
-        : QEvent(QEvent::FutureCallOut),
-          callOutType(callOutType),
-          index1(index1),
-          index2(index2),
-          text(text)
-    { }
-};
-
-class QFutureCallOutInterface
-{
-public:
-    virtual ~QFutureCallOutInterface() {}
-    virtual void postCallOutEvent(const QFutureCallOutEvent &) = 0;
-    virtual void callOutInterfaceDisconnected() = 0;
-};
-
-class QFutureInterfaceBasePrivate
-{
-public:
-    QFutureInterfaceBasePrivate(QFutureInterfaceBase::State initialState);
-
-    QAtomicInt refCount;
-    mutable QMutex m_mutex;
-    QWaitCondition waitCondition;
-    QList<QFutureCallOutInterface *> outputConnections;
-    int m_progressValue;
-    int m_progressMinimum;
-    int m_progressMaximum;
-    QFutureInterfaceBase::State state;
-    QElapsedTimer progressTime;
-    QWaitCondition pausedWaitCondition;
-    int pendingResults;
-    QtConcurrent::ResultStoreBase m_results;
-    bool manualProgress;
-    int m_expectedResultCount;
-    QtConcurrent::internal::ExceptionStore m_exceptionStore;
-    QString m_progressText;
-    QRunnable *runnable;
-
-    // Internal functions that does not change the mutex state.
-    // The mutex must be locked when calling these.
-    int internal_resultCount() const;
-    bool internal_isResultReadyAt(int index) const;
-    bool internal_waitForNextResult();
-    bool internal_updateProgress(int progress, const QString &progressText = QString());
-    void internal_setThrottled(bool enable);
-    void sendCallOut(const QFutureCallOutEvent &callOut);
-    void sendCallOuts(const QFutureCallOutEvent &callOut1, const QFutureCallOutEvent &callOut2);
-    void connectOutputInterface(QFutureCallOutInterface *iface);
-    void disconnectOutputInterface(QFutureCallOutInterface *iface);
-
-    void setState(QFutureInterfaceBase::State state);
-};
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/corelib/concurrent/qfuturesynchronizer.cpp b/src/corelib/concurrent/qfuturesynchronizer.cpp
deleted file mode 100644
index 34b00da..0000000
--- a/src/corelib/concurrent/qfuturesynchronizer.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*! \class QFutureSynchronizer
-    \since 4.4
-
-    \brief The QFutureSynchronizer class is a convenience class that simplifies
-    QFuture synchronization.
-
-    \ingroup thread
-
-    QFutureSynchronizer is a template class that simplifies synchronization of
-    one or more QFuture objects. Futures are added using the addFuture() or
-    setFuture() functions. The futures() function returns a list of futures.
-    Use clearFutures() to remove all futures from the QFutureSynchronizer.
-    
-    The waitForFinished() function waits for all futures to finish.
-    The destructor of QFutureSynchronizer calls waitForFinished(), providing
-    an easy way to ensure that all futures have finished before returning from
-    a function:
-    
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuturesynchronizer.cpp 0
-    
-    The behavior of waitForFinished() can be changed using the
-    setCancelOnWait() function. Calling setCancelOnWait(true) will cause
-    waitForFinished() to cancel all futures before waiting for them to finish.
-    You can query the status of the cancel-on-wait feature using the
-    cancelOnWait() function.
-    
-    \sa QFuture, QFutureWatcher, {Concurrent Programming}{Qt Concurrent}
-*/
-
-/*!
-    \fn QFutureSynchronizer::QFutureSynchronizer()
-
-    Constructs a QFutureSynchronizer.
-*/
-
-/*!
-    \fn QFutureSynchronizer::QFutureSynchronizer(const QFuture<T> &future)
-
-    Constructs a QFutureSynchronizer and begins watching \a future by calling
-    addFuture().
-    
-    \sa addFuture()
-*/
-
-/*!
-    \fn QFutureSynchronizer::~QFutureSynchronizer()
-    
-    Calls waitForFinished() function to ensure that all futures have finished
-    before destroying this QFutureSynchronizer.
-    
-    \sa waitForFinished()
-*/
-
-/*!
-    \fn void QFutureSynchronizer::setFuture(const QFuture<T> &future)
-    
-    Sets \a future to be the only future managed by this QFutureSynchronizer.
-    This is a convenience function that calls waitForFinished(),
-    then clearFutures(), and finally passes \a future to addFuture().
-    
-    \sa addFuture(), waitForFinished(), clearFutures()
-*/
-
-/*!
-    \fn void QFutureSynchronizer::addFuture(const QFuture<T> &future)
-
-    Adds \a future to the list of managed futures.
-    
-    \sa futures()
-*/
-
-/*!
-    \fn void QFutureSynchronizer::waitForFinished()
-
-    Waits for all futures to finish. If cancelOnWait() returns true, each
-    future is canceled before waiting for them to finish.
-    
-    \sa cancelOnWait(), setCancelOnWait()
-*/
-
-/*!
-    \fn void QFutureSynchronizer::clearFutures()
-
-    Removes all managed futures from this QFutureSynchronizer.
-    
-    \sa addFuture(), setFuture()   
-*/
-
-/*!
-    \fn QList<QFuture<T> > QFutureSynchronizer::futures() const
-
-    Returns a list of all managed futures.
-    
-    \sa addFuture(), setFuture()
-*/
-
-/*!
-    \fn void QFutureSynchronizer::setCancelOnWait(bool enabled)
-    
-    Enables or disables the cancel-on-wait feature based on the \a enabled
-    argument. If \a enabled is true, the waitForFinished() function will cancel
-    all futures before waiting for them to finish.
-
-    \sa waitForFinished()
-*/
-
-/*!
-    \fn bool QFutureSynchronizer::cancelOnWait() const
-
-    Returns true if the cancel-on-wait feature is enabled; otherwise returns
-    false. If cancel-on-wait is enabled, the waitForFinished() function will
-    cancel all futures before waiting for them to finish.
-
-    \sa waitForFinished()
-*/
diff --git a/src/corelib/concurrent/qfuturesynchronizer.h b/src/corelib/concurrent/qfuturesynchronizer.h
deleted file mode 100644
index 1661cae..0000000
--- a/src/corelib/concurrent/qfuturesynchronizer.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QFUTRUESYNCHRONIZER_H
-#define QFUTRUESYNCHRONIZER_H
-
-#include <QtCore/qfuture.h>
-
-#ifndef QT_NO_CONCURRENT
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-template <typename T>
-class QFutureSynchronizer
-{
-    Q_DISABLE_COPY(QFutureSynchronizer)
-
-public:
-    QFutureSynchronizer() : m_cancelOnWait(false) { }
-    explicit QFutureSynchronizer(const QFuture<T> &future)
-        : m_cancelOnWait(false)
-    { addFuture(future); }
-    ~QFutureSynchronizer()  { waitForFinished(); }
-
-    void setFuture(const QFuture<T> &future)
-    {
-        waitForFinished();
-        m_futures.clear();
-        addFuture(future);
-    }
-
-    void addFuture(const QFuture<T> &future)
-    {
-        m_futures.append(future);
-    }
-
-    void waitForFinished()
-    {
-        if (m_cancelOnWait) {
-            for (int i = 0; i < m_futures.count(); ++i) {
-                 m_futures[i].cancel();
-            }
-        }
-        
-        for (int i = 0; i < m_futures.count(); ++i) {
-             m_futures[i].waitForFinished();
-         }
-    }
-
-    void clearFutures()
-    {
-        m_futures.clear();
-    }
-
-    QList<QFuture<T> > futures() const
-    {
-        return m_futures;
-    }
-
-    void setCancelOnWait(bool enabled)
-    {
-        m_cancelOnWait = enabled;
-    }
-
-    bool cancelOnWait() const
-    {
-        return m_cancelOnWait;
-    }
-
-protected:
-    QList<QFuture<T> > m_futures;
-    bool m_cancelOnWait;
-};
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif // QFUTRUESYNCHRONIZER_H
diff --git a/src/corelib/concurrent/qfuturewatcher.cpp b/src/corelib/concurrent/qfuturewatcher.cpp
deleted file mode 100644
index d3a1122..0000000
--- a/src/corelib/concurrent/qfuturewatcher.cpp
+++ /dev/null
@@ -1,592 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qfuturewatcher.h"
-
-#ifndef QT_NO_QFUTURE
-
-#include <QtCore/qcoreevent.h>
-#include <QtCore/qcoreapplication.h>
-#include <QtCore/qthread.h>
-
-#include "qfuturewatcher_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*! \class QFutureWatcher
-    \reentrant
-    \since 4.4
-
-    \ingroup thread
-
-    \brief The QFutureWatcher class allows monitoring a QFuture using signals
-    and slots.
-
-    QFutureWatcher provides information and notifications about a QFuture. Use
-    the setFuture() function to start watching a particular QFuture. The
-    future() function returns the future set with setFuture().
-
-    For convenience, several of QFuture's functions are also available in
-    QFutureWatcher: progressValue(), progressMinimum(), progressMaximum(),
-    progressText(), isStarted(), isFinished(), isRunning(), isCanceled(),
-    isPaused(), waitForFinished(), result(), and resultAt(). The cancel(),
-    setPaused(), pause(), resume(), and togglePaused() functions are slots in
-    QFutureWatcher.
-
-    Status changes are reported via the started(), finished(), canceled(),
-    paused(), resumed(), resultReadyAt(), and resultsReadyAt() signals.
-    Progress information is provided from the progressRangeChanged(),
-    void progressValueChanged(), and progressTextChanged() signals.
-
-    Throttling control is provided by the setPendingResultsLimit() function.
-    When the number of pending resultReadyAt() or resultsReadyAt() signals
-    exceeds the limit, the computation represented by the future will be
-    throttled automatically. The computation will resume once the number of
-    pending signals drops below the limit.
-
-    Example: Starting a computation and getting a slot callback when it's
-    finished:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qfuturewatcher.cpp 0
-
-    Be aware that not all asynchronous computations can be canceled or paused.
-    For example, the future returned by QtConcurrent::run() cannot be
-    canceled; but the future returned by QtConcurrent::mappedReduced() can.
-
-    QFutureWatcher<void> is specialized to not contain any of the result
-    fetching functions. Any QFuture<T> can be watched by a
-    QFutureWatcher<void> as well. This is useful if only status or progress
-    information is needed; not the actual result data.
-
-    \sa QFuture, {Concurrent Programming}{Qt Concurrent}
-*/
-
-/*! \fn QFutureWatcher::QFutureWatcher(QObject *parent)
-
-    Constructs a new QFutureWatcher with the given \a parent.
-*/
-QFutureWatcherBase::QFutureWatcherBase(QObject *parent)
-    :QObject(*new QFutureWatcherBasePrivate, parent)
-{ }
-
-/*! \fn QFutureWatcher::~QFutureWatcher()
-
-    Destroys the QFutureWatcher.
-*/
-
-/*! \fn void QFutureWatcher::cancel()
-
-    Cancels the asynchronous computation represented by the future(). Note that
-    the cancelation is asynchronous. Use waitForFinished() after calling
-    cancel() when you need synchronous cancelation.
-
-    Currently available results may still be accessed on a canceled QFuture,
-    but new results will \e not become available after calling this function.
-    Also, this QFutureWatcher will not deliver progress and result ready
-    signals once canceled. This includes the progressValueChanged(),
-    progressRangeChanged(), progressTextChanged(), resultReadyAt(), and
-    resultsReadyAt() signals.
-
-    Be aware that not all asynchronous computations can be canceled. For
-    example, the QFuture returned by QtConcurrent::run() cannot be canceled;
-    but the QFuture returned by QtConcurrent::mappedReduced() can.
-*/
-void QFutureWatcherBase::cancel()
-{
-    futureInterface().cancel();
-}
-
-/*! \fn void QFutureWatcher::setPaused(bool paused)
-
-    If \a paused is true, this function pauses the asynchronous computation
-    represented by the future(). If the computation is already paused, this
-    function does nothing. This QFutureWatcher will stop delivering progress
-    and result ready signals while the future is paused. Signal delivery will
-    continue once the computation is resumed.
-
-    If \a paused is false, this function resumes the asynchronous computation.
-    If the computation was not previously paused, this function does nothing.
-
-    Be aware that not all computations can be paused. For example, the
-    QFuture returned by QtConcurrent::run() cannot be paused; but the QFuture
-    returned by QtConcurrent::mappedReduced() can.
-
-    \sa pause(), resume(), togglePaused()
-*/
-void QFutureWatcherBase::setPaused(bool paused)
-{
-    futureInterface().setPaused(paused);
-}
-
-/*! \fn void QFutureWatcher::pause()
-
-    Pauses the asynchronous computation represented by the future(). This is a
-    convenience method that simply calls setPaused(true).
-
-    \sa resume()
-*/
-void QFutureWatcherBase::pause()
-{
-    futureInterface().setPaused(true);
-}
-
-/*! \fn void QFutureWatcher::resume()
-
-    Resumes the asynchronous computation represented by the future(). This is
-    a convenience method that simply calls setPaused(false).
-
-    \sa pause()
-*/
-void QFutureWatcherBase::resume()
-{
-    futureInterface().setPaused(false);
-}
-
-/*! \fn void QFutureWatcher::togglePaused()
-
-    Toggles the paused state of the asynchronous computation. In other words,
-    if the computation is currently paused, calling this function resumes it;
-    if the computation is running, it becomes paused. This is a convenience
-    method for calling setPaused(!isPaused()).
-
-    \sa setPaused(), pause(), resume()
-*/
-void QFutureWatcherBase::togglePaused()
-{
-    futureInterface().togglePaused();
-}
-
-/*! \fn int QFutureWatcher::progressValue() const
-
-    Returns the current progress value, which is between the progressMinimum()
-    and progressMaximum().
-
-    \sa progressMinimum(), progressMaximum()
-*/
-int QFutureWatcherBase::progressValue() const
-{
-    return futureInterface().progressValue();
-}
-
-/*! \fn int QFutureWatcher::progressMinimum() const
-
-    Returns the minimum progressValue().
-
-    \sa progressValue(), progressMaximum()
-*/
-int QFutureWatcherBase::progressMinimum() const
-{
-    return futureInterface().progressMinimum();
-}
-
-/*! \fn int QFutureWatcher::progressMaximum() const
-
-    Returns the maximum progressValue().
-
-    \sa progressValue(), progressMinimum()
-*/
-int QFutureWatcherBase::progressMaximum() const
-{
-    return futureInterface().progressMaximum();
-}
-
-/*! \fn QString QFutureWatcher::progressText() const
-
-    Returns the (optional) textual representation of the progress as reported
-    by the asynchronous computation.
-
-    Be aware that not all computations provide a textual representation of the
-    progress, and as such, this function may return an empty string.
-*/
-QString QFutureWatcherBase::progressText() const
-{
-    return futureInterface().progressText();
-}
-
-/*! \fn bool QFutureWatcher::isStarted() const
-
-    Returns true if the asynchronous computation represented by the future()
-    has been started; otherwise returns false.
-*/
-bool QFutureWatcherBase::isStarted() const
-{
-    return futureInterface().queryState(QFutureInterfaceBase::Started);
-}
-
-/*! \fn bool QFutureWatcher::isFinished() const
-
-    Returns true if the asynchronous computation represented by the future()
-    has finished; otherwise returns false.
-*/
-bool QFutureWatcherBase::isFinished() const
-{
-    Q_D(const QFutureWatcherBase);
-    return d->finished;
-}
-
-/*! \fn bool QFutureWatcher::isRunning() const
-
-    Returns true if the asynchronous computation represented by the future()
-    is currently running; otherwise returns false.
-*/
-bool QFutureWatcherBase::isRunning() const
-{
-    return futureInterface().queryState(QFutureInterfaceBase::Running);
-}
-
-/*! \fn bool QFutureWatcher::isCanceled() const
-
-    Returns true if the asynchronous computation has been canceled with the
-    cancel() function; otherwise returns false.
-
-    Be aware that the computation may still be running even though this
-    function returns true. See cancel() for more details.
-*/
-bool QFutureWatcherBase::isCanceled() const
-{
-    return futureInterface().queryState(QFutureInterfaceBase::Canceled);
-}
-
-/*! \fn bool QFutureWatcher::isPaused() const
-
-    Returns true if the asynchronous computation has been paused with the
-    pause() function; otherwise returns false.
-
-    Be aware that the computation may still be running even though this
-    function returns true. See setPaused() for more details.
-
-    \sa setPaused(), togglePaused()
-*/
-bool QFutureWatcherBase::isPaused() const
-{
-    return futureInterface().queryState(QFutureInterfaceBase::Paused);
-}
-
-/*! \fn void QFutureWatcher::waitForFinished()
-
-    Waits for the asynchronous computation to finish (including cancel()ed
-    computations).
-*/
-void QFutureWatcherBase::waitForFinished()
-{
-    futureInterface().waitForFinished();
-}
-
-/*! \fn void QFutureWatcher::setPendingResultsLimit(int limit)
-
-    The setPendingResultsLimit() provides throttling control. When the number
-    of pending resultReadyAt() or resultsReadyAt() signals exceeds the
-    \a limit, the computation represented by the future will be throttled
-    automatically. The computation will resume once the number of pending
-    signals drops below the \a limit.
-*/
-
-bool QFutureWatcherBase::event(QEvent *event)
-{
-    Q_D(QFutureWatcherBase);
-    if (event->type() == QEvent::FutureCallOut) {
-        QFutureCallOutEvent *callOutEvent = static_cast<QFutureCallOutEvent *>(event);
-
-        if (futureInterface().isPaused()) {
-            d->pendingCallOutEvents.append(callOutEvent->clone());
-            return true;
-        }
-
-        if (callOutEvent->callOutType == QFutureCallOutEvent::Resumed
-            && !d->pendingCallOutEvents.isEmpty()) {
-            // send the resume
-            d->sendCallOutEvent(callOutEvent);
-
-            // next send all pending call outs
-            for (int i = 0; i < d->pendingCallOutEvents.count(); ++i)
-                d->sendCallOutEvent(d->pendingCallOutEvents.at(i));
-            qDeleteAll(d->pendingCallOutEvents);
-            d->pendingCallOutEvents.clear();
-        } else {
-            d->sendCallOutEvent(callOutEvent);
-        }
-        return true;
-    }
-    return QObject::event(event);
-}
-
-void QFutureWatcherBase::setPendingResultsLimit(int limit)
-{
-    Q_D(QFutureWatcherBase);
-    d->maximumPendingResultsReady = limit;
-}
-
-void QFutureWatcherBase::connectNotify(const char * signal)
-{
-    Q_D(QFutureWatcherBase);
-    if (qstrcmp(signal, SIGNAL(resultReadyAt(int))) == 0)
-        d->resultAtConnected.ref();
-#ifndef QT_NO_DEBUG
-    if (qstrcmp(signal, SIGNAL(finished())) == 0) {
-        if (futureInterface().isRunning()) {
-            //connections should be established before calling stFuture to avoid race.
-            // (The future could finish before the connection is made.)
-            qWarning("QFutureWatcher::connect: connecting after calling setFuture() is likely to produce race");
-        }
-    }
-#endif
-}
-
-void QFutureWatcherBase::disconnectNotify(const char * signal)
-{
-    Q_D(QFutureWatcherBase);
-    if (qstrcmp(signal, SIGNAL(resultReadyAt(int))) == 0)
-        d->resultAtConnected.deref();
-}
-
-/*!
-    \internal
-*/
-QFutureWatcherBasePrivate::QFutureWatcherBasePrivate()
-    : maximumPendingResultsReady(QThread::idealThreadCount() * 2),
-      resultAtConnected(0)
-{ }
-
-/*!
-    \internal
-*/
-void QFutureWatcherBase::connectOutputInterface()
-{
-    futureInterface().d->connectOutputInterface(d_func());
-}
-
-/*!
-    \internal
-*/
-void QFutureWatcherBase::disconnectOutputInterface(bool pendingAssignment)
-{
-    if (pendingAssignment) {
-        Q_D(QFutureWatcherBase);
-        d->pendingResultsReady.store(0);
-        qDeleteAll(d->pendingCallOutEvents);
-        d->pendingCallOutEvents.clear();
-        d->finished = false;
-    }
-
-    futureInterface().d->disconnectOutputInterface(d_func());
-}
-
-void QFutureWatcherBasePrivate::postCallOutEvent(const QFutureCallOutEvent &callOutEvent)
-{
-    Q_Q(QFutureWatcherBase);
-
-    if (callOutEvent.callOutType == QFutureCallOutEvent::ResultsReady) {
-        if (pendingResultsReady.fetchAndAddRelaxed(1) >= maximumPendingResultsReady)
-            q->futureInterface().d->internal_setThrottled(true);
-    }
-
-    QCoreApplication::postEvent(q, callOutEvent.clone());
-}
-
-void QFutureWatcherBasePrivate::callOutInterfaceDisconnected()
-{
-    QCoreApplication::removePostedEvents(q_func(), QEvent::FutureCallOut);
-}
-
-void QFutureWatcherBasePrivate::sendCallOutEvent(QFutureCallOutEvent *event)
-{
-    Q_Q(QFutureWatcherBase);
-
-    switch (event->callOutType) {
-        case QFutureCallOutEvent::Started:
-            emit q->started();
-        break;
-        case QFutureCallOutEvent::Finished:
-            finished = true;
-            emit q->finished();
-        break;
-        case QFutureCallOutEvent::Canceled:
-            pendingResultsReady.store(0);
-            emit q->canceled();
-        break;
-        case QFutureCallOutEvent::Paused:
-            if (q->futureInterface().isCanceled())
-                break;
-            emit q->paused();
-        break;
-        case QFutureCallOutEvent::Resumed:
-            if (q->futureInterface().isCanceled())
-                break;
-            emit q->resumed();
-        break;
-        case QFutureCallOutEvent::ResultsReady: {
-            if (q->futureInterface().isCanceled())
-                break;
-
-            if (pendingResultsReady.fetchAndAddRelaxed(-1) <= maximumPendingResultsReady)
-                q->futureInterface().setThrottled(false);
-
-            const int beginIndex = event->index1;
-            const int endIndex = event->index2;
-
-            emit q->resultsReadyAt(beginIndex, endIndex);
-
-            if (resultAtConnected.load() <= 0)
-                break;
-
-            for (int i = beginIndex; i < endIndex; ++i)
-                emit q->resultReadyAt(i);
-
-        } break;
-        case QFutureCallOutEvent::Progress:
-            if (q->futureInterface().isCanceled())
-                break;
-
-            emit q->progressValueChanged(event->index1);
-            if (!event->text.isNull()) // ###
-                q->progressTextChanged(event->text);
-        break;
-        case QFutureCallOutEvent::ProgressRange:
-            emit q->progressRangeChanged(event->index1, event->index2);
-        break;
-        default: break;
-    }
-}
-
-
-/*! \fn const T &QFutureWatcher::result() const
-
-    Returns the first result in the future(). If the result is not immediately
-    available, this function will block and wait for the result to become
-    available. This is a convenience method for calling resultAt(0).
-
-    \sa resultAt()
-*/
-
-/*! \fn const T &QFutureWatcher::resultAt(int index) const
-
-    Returns the result at \a index in the future(). If the result is not
-    immediately available, this function will block and wait for the result to
-    become available.
-
-    \sa result()
-*/
-
-/*! \fn void QFutureWatcher::setFuture(const QFuture<T> &future)
-
-    Starts watching the given \a future.
-
-    One of the signals might be emitted for the current state of the
-    \a future. For example, if the future is already stopped, the
-    finished signal will be emitted.
-
-    To avoid a race condition, it is important to call this function
-    \e after doing the connections.
-*/
-
-/*! \fn QFuture<T> QFutureWatcher::future() const
-
-    Returns the watched future.
-*/
-
-/*! \fn void QFutureWatcher::started()
-
-    This signal is emitted when this QFutureWatcher starts watching the future
-    set with setFuture().
-*/
-
-/*!
-    \fn void QFutureWatcher::finished()
-    This signal is emitted when the watched future finishes.
-*/
-
-/*!
-    \fn void QFutureWatcher::canceled()
-    This signal is emitted if the watched future is canceled.
-*/
-
-/*! \fn void QFutureWatcher::paused()
-    This signal is emitted when the watched future is paused.
-*/
-
-/*! \fn void QFutureWatcher::resumed()
-    This signal is emitted when the watched future is resumed.
-*/
-
-/*!
-    \fn void QFutureWatcher::progressRangeChanged(int minimum, int maximum)
-
-    The progress range for the watched future has changed to \a minimum and
-    \a maximum
-*/
-
-/*!
-    \fn void QFutureWatcher::progressValueChanged(int progressValue)
-
-    This signal is emitted when the watched future reports progress,
-    \a progressValue gives the current progress. In order to avoid overloading
-    the GUI event loop, QFutureWatcher limits the progress signal emission
-    rate. This means that listeners connected to this slot might not get all
-    progress reports the future makes. The last progress update (where
-    \a progressValue equals the maximum value) will always be delivered.
-*/
-
-/*! \fn void QFutureWatcher::progressTextChanged(const QString &progressText)
-
-    This signal is emitted when the watched future reports textual progress
-    information, \a progressText.
-*/
-
-/*!
-    \fn void QFutureWatcher::resultReadyAt(int index)
-
-    This signal is emitted when the watched future reports a ready result at
-    \a index. If the future reports multiple results, the index will indicate
-    which one it is. Results can be reported out-of-order. To get the result,
-    call future().result(index);
-*/
-
-/*!
-    \fn void QFutureWatcher::resultsReadyAt(int beginIndex, int endIndex);
-
-    This signal is emitted when the watched future reports ready results.
-    The results are indexed from \a beginIndex to \a endIndex.
-
-*/
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_CONCURRENT
diff --git a/src/corelib/concurrent/qfuturewatcher.h b/src/corelib/concurrent/qfuturewatcher.h
deleted file mode 100644
index 6029331..0000000
--- a/src/corelib/concurrent/qfuturewatcher.h
+++ /dev/null
@@ -1,221 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QFUTUREWATCHER_H
-#define QFUTUREWATCHER_H
-
-#include <QtCore/qfuture.h>
-
-#ifndef QT_NO_QFUTURE
-
-#include <QtCore/qobject.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-class QEvent;
-
-class QFutureWatcherBasePrivate;
-class Q_CORE_EXPORT QFutureWatcherBase : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QFutureWatcherBase)
-
-public:
-    QFutureWatcherBase(QObject *parent = 0);
-
-    int progressValue() const;
-    int progressMinimum() const;
-    int progressMaximum() const;
-    QString progressText() const;
-
-    bool isStarted() const;
-    bool isFinished() const;
-    bool isRunning() const;
-    bool isCanceled() const;
-    bool isPaused() const;
-
-    void waitForFinished();
-
-    void setPendingResultsLimit(int limit);
-
-    bool event(QEvent *event);
-
-Q_SIGNALS:
-    void started();
-    void finished();
-    void canceled();
-    void paused();
-    void resumed();
-    void resultReadyAt(int resultIndex);
-    void resultsReadyAt(int beginIndex, int endIndex);
-    void progressRangeChanged(int minimum, int maximum);
-    void progressValueChanged(int progressValue);
-    void progressTextChanged(const QString &progressText);
-
-public Q_SLOTS:
-    void cancel();
-    void setPaused(bool paused);
-    void pause();
-    void resume();
-    void togglePaused();
-
-protected:
-    void connectNotify (const char * signal);
-    void disconnectNotify (const char * signal);
-
-    // called from setFuture() implemented in template sub-classes
-    void connectOutputInterface();
-    void disconnectOutputInterface(bool pendingAssignment = false);
-
-private:
-    // implemented in the template sub-classes
-    virtual const QFutureInterfaceBase &futureInterface() const = 0;
-    virtual QFutureInterfaceBase &futureInterface() = 0;
-};
-
-template <typename T>
-class QFutureWatcher : public QFutureWatcherBase
-{
-public:
-    QFutureWatcher(QObject *_parent = 0)
-        : QFutureWatcherBase(_parent)
-    { }
-    ~QFutureWatcher()
-    { disconnectOutputInterface(); }
-
-    void setFuture(const QFuture<T> &future);
-    QFuture<T> future() const
-    { return m_future; }
-
-    T result() const { return m_future.result(); }
-    T resultAt(int index) const { return m_future.resultAt(index); }
-
-#ifdef qdoc
-    int progressValue() const;
-    int progressMinimum() const;
-    int progressMaximum() const;
-    QString progressText() const;
-
-    bool isStarted() const;
-    bool isFinished() const;
-    bool isRunning() const;
-    bool isCanceled() const;
-    bool isPaused() const;
-
-    void waitForFinished();
-
-    void setPendingResultsLimit(int limit);
-
-Q_SIGNALS:
-    void started();
-    void finished();
-    void canceled();
-    void paused();
-    void resumed();
-    void resultReadyAt(int resultIndex);
-    void resultsReadyAt(int beginIndex, int endIndex);
-    void progressRangeChanged(int minimum, int maximum);
-    void progressValueChanged(int progressValue);
-    void progressTextChanged(const QString &progressText);
-
-public Q_SLOTS:
-    void cancel();
-    void setPaused(bool paused);
-    void pause();
-    void resume();
-    void togglePaused();
-#endif
-
-private:
-    QFuture<T> m_future;
-    const QFutureInterfaceBase &futureInterface() const { return m_future.d; }
-    QFutureInterfaceBase &futureInterface() { return m_future.d; }
-};
-
-template <typename T>
-Q_INLINE_TEMPLATE void QFutureWatcher<T>::setFuture(const QFuture<T> &_future)
-{
-    if (_future == m_future)
-        return;
-
-    disconnectOutputInterface(true);
-    m_future = _future;
-    connectOutputInterface();
-}
-
-template <>
-class QFutureWatcher<void> : public QFutureWatcherBase
-{
-public:
-    QFutureWatcher(QObject *_parent = 0)
-        : QFutureWatcherBase(_parent)
-    { }
-    ~QFutureWatcher()
-    { disconnectOutputInterface(); }
-
-    void setFuture(const QFuture<void> &future);
-    QFuture<void> future() const
-    { return m_future; }
-
-private:
-    QFuture<void> m_future;
-    const QFutureInterfaceBase &futureInterface() const { return m_future.d; }
-    QFutureInterfaceBase &futureInterface() { return m_future.d; }
-};
-
-Q_INLINE_TEMPLATE void QFutureWatcher<void>::setFuture(const QFuture<void> &_future)
-{
-    if (_future == m_future)
-        return;
-
-    disconnectOutputInterface(true);
-    m_future = _future;
-    connectOutputInterface();
-}
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif // QFUTUREWATCHER_H
diff --git a/src/corelib/concurrent/qfuturewatcher_p.h b/src/corelib/concurrent/qfuturewatcher_p.h
deleted file mode 100644
index 27bc494..0000000
--- a/src/corelib/concurrent/qfuturewatcher_p.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QFUTUREWATCHER_P_H
-#define QFUTUREWATCHER_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "qfutureinterface_p.h"
-#include <qlist.h>
-
-#ifndef QT_NO_QFUTURE
-
-#include <private/qobject_p.h>
-
-QT_BEGIN_NAMESPACE
-
-class QFutureWatcherBase;
-class QFutureWatcherBasePrivate : public QObjectPrivate,
-                                  public QFutureCallOutInterface
-{
-    Q_DECLARE_PUBLIC(QFutureWatcherBase)
-
-public:
-    QFutureWatcherBasePrivate();
-
-    void postCallOutEvent(const QFutureCallOutEvent &callOutEvent);
-    void callOutInterfaceDisconnected();
-
-    void sendCallOutEvent(QFutureCallOutEvent *event);
-
-    QList<QFutureCallOutEvent *> pendingCallOutEvents;
-    QAtomicInt pendingResultsReady;
-    int maximumPendingResultsReady;
-
-    QAtomicInt resultAtConnected;
-    bool finished;
-};
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_QFUTURE
-#endif
diff --git a/src/corelib/concurrent/qrunnable.cpp b/src/corelib/concurrent/qrunnable.cpp
deleted file mode 100644
index 933a5b9..0000000
--- a/src/corelib/concurrent/qrunnable.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-    \class QRunnable
-    \since 4.4
-    \brief The QRunnable class is the base class for all runnable objects.
-
-    \ingroup thread
-
-    The QRunnable class is an interface for representing a task or
-    piece of code that needs to be executed, represented by your
-    reimplementation of the run() function.
-
-    You can use QThreadPool to execute your code in a separate
-    thread. QThreadPool deletes the QRunnable automatically if
-    autoDelete() returns true (the default). Use setAutoDelete() to
-    change the auto-deletion flag.
-
-    QThreadPool supports executing the same QRunnable more than once
-    by calling QThreadPool::tryStart(this) from within the run() function. 
-    If autoDelete is enabled the QRunnable will be deleted when
-    the last thread exits the run function. Calling QThreadPool::start()
-    multiple times with the same QRunnable when autoDelete is enabled
-    creates a race condition and is not recommended.
-
-    \sa QThreadPool
-*/
-
-/*! \fn QRunnable::run()
-    Implement this pure virtual function in your subclass.
-*/
-
-/*! \fn QRunnable::QRunnable()
-    Constructs a QRunnable. Auto-deletion is enabled by default.
-
-    \sa autoDelete(), setAutoDelete()
-*/
-
-/*! \fn QRunnable::~QRunnable()
-    QRunnable virtual destructor.
-*/
-
-/*! \fn bool QRunnable::autoDelete() const
-
-    Returns true is auto-deletion is enabled; false otherwise.
-
-    If auto-deletion is enabled, QThreadPool will automatically delete
-    this runnable after calling run(); otherwise, ownership remains
-    with the application programmer.
-
-    \sa setAutoDelete(), QThreadPool
-*/
-
-/*! \fn bool QRunnable::setAutoDelete(bool autoDelete)
-
-    Enables auto-deletion if \a autoDelete is true; otherwise
-    auto-deletion is disabled.
-
-    If auto-deletion is enabled, QThreadPool will automatically delete
-    this runnable after calling run(); otherwise, ownership remains
-    with the application programmer.
-
-    Note that this flag must be set before calling
-    QThreadPool::start(). Calling this function after
-    QThreadPool::start() results in undefined behavior.
-
-    \sa autoDelete(), QThreadPool
-*/
diff --git a/src/corelib/concurrent/qrunnable.h b/src/corelib/concurrent/qrunnable.h
deleted file mode 100644
index 11d5c01..0000000
--- a/src/corelib/concurrent/qrunnable.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QRUNNABLE_H
-#define QRUNNABLE_H
-
-#include <QtCore/qglobal.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-class QRunnable
-{
-    int ref;
-
-    friend class QThreadPool;
-    friend class QThreadPoolPrivate;
-    friend class QThreadPoolThread;
-
-public:
-    virtual void run() = 0;
-
-    QRunnable() : ref(0) { }
-    virtual ~QRunnable() { }
-
-    bool autoDelete() const { return ref != -1; }
-    void setAutoDelete(bool _autoDelete) { ref = _autoDelete ? 0 : -1; }
-};
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentcompilertest.h b/src/corelib/concurrent/qtconcurrentcompilertest.h
deleted file mode 100644
index 7818423..0000000
--- a/src/corelib/concurrent/qtconcurrentcompilertest.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_COMPILERTEST_H
-#define QTCONCURRENT_COMPILERTEST_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#if defined (Q_CC_MSVC) && (_MSC_VER < 1300)
-#  define QT_TYPENAME
-#else
-#  define QT_TYPENAME typename
-#endif
-
-namespace QtPrivate {
-
-template<class T>
-class HasResultType {
-    typedef char Yes;
-    typedef void *No;
-    template<typename U> static Yes test(int, const typename U::result_type * = 0);
-    template<typename U> static No test(double);
-public:
-    enum { Value = (sizeof(test<T>(0)) == sizeof(Yes)) };
-};
-
-}
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentexception.cpp b/src/corelib/concurrent/qtconcurrentexception.cpp
deleted file mode 100644
index caeaa8d..0000000
--- a/src/corelib/concurrent/qtconcurrentexception.cpp
+++ /dev/null
@@ -1,211 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qtconcurrentexception.h"
-#include "QtCore/qshareddata.h"
-
-#ifndef QT_NO_QFUTURE
-#ifndef QT_NO_EXCEPTIONS
-
-QT_BEGIN_NAMESPACE
-
-/*! 
-    \class QtConcurrent::Exception
-    \brief The Exception class provides a base class for exceptions that can transferred across threads.
-    \since 4.4
-
-    Qt Concurrent supports throwing and catching exceptions across thread
-    boundaries, provided that the exception inherit from QtConcurrent::Exception
-    and implement two helper functions:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentexception.cpp 0
-
-    QtConcurrent::Exception subclasses must be thrown by value and
-    caught by reference:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentexception.cpp 1
-
-    If you throw an exception that is not a subclass of QtConcurrent::Exception,
-    the Qt Concurrent functions will throw a QtConcurrent::UnhandledException
-    in the receiver thread.
-
-    When using QFuture, transferred exceptions will be thrown when calling the following functions:
-    \list
-    \o QFuture::waitForFinished()
-    \o QFuture::result()
-    \o QFuture::resultAt()
-    \o QFuture::results()
-    \endlist
-*/
-
-/*!
-    \fn QtConcurrent::Exception::raise() const 
-    In your QtConcurrent::Exception subclass, reimplement raise() like this:
-    
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentexception.cpp 2
-*/
-
-/*!
-    \fn QtConcurrent::Exception::clone() const
-    In your QtConcurrent::Exception subclass, reimplement clone() like this:
-    
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentexception.cpp 3
-*/
-
-/*! 
-    \class QtConcurrent::UnhandledException
-
-    \brief The UnhandledException class represents an unhandled exception in a worker thread.
-    \since 4.4
-
-    If a worker thread throws an exception that is not a subclass of QtConcurrent::Exception,
-    the Qt Concurrent functions will throw a QtConcurrent::UnhandledException
-    on the receiver thread side.
-
-    Inheriting from this class is not supported.
-*/
-
-/*!
-    \fn QtConcurrent::UnhandledException::raise() const
-    \internal
-*/
-
-/*!
-    \fn QtConcurrent::UnhandledException::clone() const
-    \internal
-*/
-
-namespace QtConcurrent
-{
-
-void Exception::raise() const
-{
-    Exception e = *this;
-    throw e;
-}
-
-Exception *Exception::clone() const
-{
-    return new Exception(*this);
-}
-
-void UnhandledException::raise() const
-{
-    UnhandledException e = *this;
-    throw e;
-}
-
-Exception *UnhandledException::clone() const
-{
-    return new UnhandledException(*this);
-}
-
-#ifndef qdoc
-
-namespace internal {
-
-class Base : public QSharedData
-{
-public:
-    Base(Exception *exception)
-    : exception(exception), hasThrown(false) { }
-    ~Base() { delete exception; }
-
-    Exception *exception;
-    bool hasThrown;
-};
-
-ExceptionHolder::ExceptionHolder(Exception *exception)
-: base(new Base(exception)) {}
-
-ExceptionHolder::ExceptionHolder(const ExceptionHolder &other)
-: base(other.base)
-{}
-
-void ExceptionHolder::operator=(const ExceptionHolder &other)
-{
-    base = other.base;
-}
-
-ExceptionHolder::~ExceptionHolder()
-{}
-
-Exception *ExceptionHolder::exception() const
-{
-    return base->exception;
-}
-
-void ExceptionStore::setException(const Exception &e)
-{
-    if (hasException() == false)
-        exceptionHolder = ExceptionHolder(e.clone());
-}
-
-bool ExceptionStore::hasException() const
-{
-    return (exceptionHolder.exception() != 0);
-}
-
-ExceptionHolder ExceptionStore::exception()
-{
-    return exceptionHolder;
-}
-
-void ExceptionStore::throwPossibleException()
-{
-    if (hasException() ) {
-        exceptionHolder.base->hasThrown = true;
-        exceptionHolder.exception()->raise();
-    }
-}
-
-bool ExceptionStore::hasThrown() const { return exceptionHolder.base->hasThrown; }
-
-} // namespace internal
-
-#endif //qdoc
-
-} // namespace QtConcurrent
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_EXCEPTIONS
-#endif // QT_NO_CONCURRENT
diff --git a/src/corelib/concurrent/qtconcurrentexception.h b/src/corelib/concurrent/qtconcurrentexception.h
deleted file mode 100644
index b04e1f2..0000000
--- a/src/corelib/concurrent/qtconcurrentexception.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_EXCEPTION_H
-#define QTCONCURRENT_EXCEPTION_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_QFUTURE
-
-#include <QtCore/qatomic.h>
-#include <QtCore/qshareddata.h>
-
-#ifndef QT_NO_EXCEPTIONS
-#  include <exception>
-#endif
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-namespace QtConcurrent
-{
-
-#ifndef QT_NO_EXCEPTIONS
-
-class Q_CORE_EXPORT Exception : public std::exception
-{
-public:
-    virtual void raise() const;
-    virtual Exception *clone() const;
-};
-
-class Q_CORE_EXPORT UnhandledException : public Exception
-{
-public:
-    void raise() const;
-    Exception *clone() const;
-};
-
-namespace internal {
-
-class Base;
-class ExceptionHolder
-{
-public:
-    ExceptionHolder(Exception *exception = 0);
-    ExceptionHolder(const ExceptionHolder &other);
-    void operator=(const ExceptionHolder &other);
-    ~ExceptionHolder();
-    Exception *exception() const;
-    QExplicitlySharedDataPointer<Base> base;
-};
-
-class Q_CORE_EXPORT ExceptionStore
-{
-public:
-    void setException(const Exception &e);
-    bool hasException() const;
-    ExceptionHolder exception();
-    void throwPossibleException();
-    bool hasThrown() const;
-    ExceptionHolder exceptionHolder;
-};
-
-} // namespace internal
-
-#else // QT_NO_EXCEPTIONS
-
-namespace internal {
-
-class Q_CORE_EXPORT ExceptionStore
-{
-public:
-    ExceptionStore() { }
-    inline void throwPossibleException() const {}
-};
-
-} // namespace internal
-
-#endif
-
-} // namespace QtConcurrent
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentfilter.cpp b/src/corelib/concurrent/qtconcurrentfilter.cpp
deleted file mode 100644
index 76ce8ca..0000000
--- a/src/corelib/concurrent/qtconcurrentfilter.cpp
+++ /dev/null
@@ -1,330 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-    \headerfile <QtConcurrentFilter>
-    \title Concurrent Filter and Filter-Reduce
-    \ingroup thread
-
-    \brief The <QtConcurrentFilter> header provides concurrent Filter and
-    Filter-Reduce.
-
-    These functions are a part of the \l {Concurrent Programming}{Qt Concurrent} framework.
-
-    The QtConcurrent::filter(), QtConcurrent::filtered() and
-    QtConcurrent::filteredReduced() functions filter items in a sequence such
-    as a QList or a QVector in parallel. QtConcurrent::filter() modifies a
-    sequence in-place, QtConcurrent::filtered() returns a new sequence
-    containing the filtered content, and QtConcurrent::filteredReduced()
-    returns a single result.
-
-    Each of the above functions have a blocking variant that returns the final
-    result instead of a QFuture. You use them in the same way as the
-    asynchronous variants.
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 6
-
-    Note that the result types above are not QFuture objects, but real result
-    types (in this case, QStringList and QSet<QString>).
-
-    \section1 Concurrent Filter
-
-    QtConcurrent::filtered() takes an input sequence and a filter function.
-    This filter function is then called for each item in the sequence, and a
-    new sequence containing the filtered values is returned.
-
-    The filter function must be of the form:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 0
-
-    T must match the type stored in the sequence. The function returns true if
-    the item should be kept, false if it should be discarded.
-
-    This example shows how to keep strings that are all lower-case from a
-    QStringList:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 1
-
-    The results of the filter are made available through QFuture. See the
-    QFuture and QFutureWatcher documentation for more information on how to
-    use QFuture in your applications.
-
-    If you want to modify a sequence in-place, use QtConcurrent::filter():
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 2
-
-    Since the sequence is modified in place, QtConcurrent::filter() does not
-    return any results via QFuture. However, you can still use QFuture and
-    QFutureWatcher to monitor the status of the filter.
-
-    \section1 Concurrent Filter-Reduce
-
-    QtConcurrent::filteredReduced() is similar to QtConcurrent::filtered(),
-    but instead of returing a sequence with the filtered results, the results
-    are combined into a single value using a reduce function.
-
-    The reduce function must be of the form:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 3
-
-    T is the type of the final result, U is the type of items being filtered.
-    Note that the return value and return type of the reduce function are not
-    used.
-
-    Call QtConcurrent::filteredReduced() like this:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 4
-
-    The reduce function will be called once for each result kept by the filter
-    function, and should merge the \e{intermediate} into the \e{result}
-    variable. QtConcurrent::filteredReduced() guarantees that only one thread
-    will call reduce at a time, so using a mutex to lock the result variable
-    is not necessary. The QtConcurrent::ReduceOptions enum provides a way to
-    control the order in which the reduction is done.
-
-    \section1 Additional API Features
-
-    \section2 Using Iterators instead of Sequence
-
-    Each of the above functions has a variant that takes an iterator range
-    instead of a sequence. You use them in the same way as the sequence
-    variants:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 5
-
-
-    \section2 Using Member Functions
-
-    QtConcurrent::filter(), QtConcurrent::filtered(), and
-    QtConcurrent::filteredReduced() accept pointers to member functions.
-    The member function class type must match the type stored in the sequence:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 7
-
-    Note that when using QtConcurrent::filteredReduced(), you can mix the use of
-    normal and member functions freely:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 8
-
-    \section2 Using Function Objects
-
-    QtConcurrent::filter(), QtConcurrent::filtered(), and
-    QtConcurrent::filteredReduced() accept function objects, which can be used to
-    add state to a function call. The result_type typedef must define the 
-    result type of the function call operator:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 13
-
-    \section2 Using Bound Function Arguments
-
-    Note that Qt does not provide support for bound functions. This is
-    provided by 3rd party libraries like
-    \l{http://www.boost.org/libs/bind/bind.html}{Boost} or
-    \l{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf}
-    {C++ TR1 Library Extensions}.
-
-    If you want to use a filter function takes more than one argument, you can
-    use boost::bind() or std::tr1::bind() to transform it onto a function that
-    takes one argument.
-
-    As an example, we use QString::contains():
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 9
-
-    QString::contains() takes 2 arguments (including the "this" pointer) and
-    can't be used with QtConcurrent::filtered() directly, because
-    QtConcurrent::filtered() expects a function that takes one argument. To
-    use QString::contains() with QtConcurrent::filtered() we have to provide a
-    value for the \e regexp argument:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 10
-
-    The return value from boost::bind() is a function object (functor) with
-    the following signature:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 11
-
-    This matches what QtConcurrent::filtered() expects, and the complete
-    example becomes:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentfilter.cpp 12
-*/
-
-/*!
-    \fn QFuture<void> QtConcurrent::filter(Sequence &sequence, FilterFunction filterFunction)
-    \relates <QtConcurrentFilter>
-
-    Calls \a filterFunction once for each item in \a sequence. If
-    \a filterFunction returns true, the item is kept in \a sequence;
-    otherwise, the item is removed from \a sequence.
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::filtered(const Sequence &sequence, FilterFunction filterFunction)
-    \relates <QtConcurrentFilter>
-
-    Calls \a filterFunction once for each item in \a sequence and returns a
-    new Sequence of kept items. If \a filterFunction returns true, a copy of
-    the item is put in the new Sequence. Otherwise, the item will \e not
-    appear in the new Sequence.
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::filtered(ConstIterator begin, ConstIterator end, FilterFunction filterFunction)
-    \relates <QtConcurrentFilter>
-
-    Calls \a filterFunction once for each item from \a begin to \a end and
-    returns a new Sequence of kept items. If \a filterFunction returns true, a
-    copy of the item is put in the new Sequence. Otherwise, the item will
-    \e not appear in the new Sequence.
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::filteredReduced(const Sequence &sequence, FilterFunction filterFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
-    \relates <QtConcurrentFilter>
-
-    Calls \a filterFunction once for each item in \a sequence. If
-    \a filterFunction returns true for an item, that item is then passed to
-    \a reduceFunction. In other words, the return value is the result of
-    \a reduceFunction for each item where \a filterFunction returns true.
-
-    Note that while \a filterFunction is called concurrently, only one thread
-    at a time will call \a reduceFunction. The order in which \a reduceFunction
-    is called is undefined if \a reduceOptions is
-    QtConcurrent::UnorderedReduce. If \a reduceOptions is
-    QtConcurrent::OrderedReduce, \a reduceFunction is called in the order of
-    the original sequence.
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::filteredReduced(ConstIterator begin, ConstIterator end, FilterFunction filterFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
-    \relates <QtConcurrentFilter>
-
-    Calls \a filterFunction once for each item from \a begin to \a end. If
-    \a filterFunction returns true for an item, that item is then passed to
-    \a reduceFunction. In other words, the return value is the result of
-    \a reduceFunction for each item where \a filterFunction returns true.
-
-    Note that while \a filterFunction is called concurrently, only one thread
-    at a time will call \a reduceFunction. The order in which
-    \a reduceFunction is called is undefined if \a reduceOptions is
-    QtConcurrent::UnorderedReduce. If \a reduceOptions is
-    QtConcurrent::OrderedReduce, the \a reduceFunction is called in the order
-    of the original sequence.
-*/
-
-/*!
-  \fn void QtConcurrent::blockingFilter(Sequence &sequence, FilterFunction filterFunction)
-
-  Calls \a filterFunction once for each item in \a sequence. If
-  \a filterFunction returns true, the item is kept in \a sequence;
-  otherwise, the item is removed from \a sequence.
-
-  \note This function will block until all items in the sequence have been processed.
-*/
-
-/*!
-  \fn Sequence QtConcurrent::blockingFiltered(const Sequence &sequence, FilterFunction filterFunction)
-
-  Calls \a filterFunction once for each item in \a sequence and returns a
-  new Sequence of kept items. If \a filterFunction returns true, a copy of
-  the item is put in the new Sequence. Otherwise, the item will \e not
-  appear in the new Sequence.
-
-  \note This function will block until all items in the sequence have been processed.
-
-  \sa filtered()
-*/
-
-/*!
-  \fn Sequence QtConcurrent::blockingFiltered(ConstIterator begin, ConstIterator end, FilterFunction filterFunction)
-
-  Calls \a filterFunction once for each item from \a begin to \a end and
-  returns a new Sequence of kept items. If \a filterFunction returns true, a
-  copy of the item is put in the new Sequence. Otherwise, the item will
-  \e not appear in the new Sequence.
-
-  \note This function will block until the iterator reaches the end of the
-  sequence being processed.
-
-  \sa filtered()
-*/
-
-/*!
-  \fn T QtConcurrent::blockingFilteredReduced(const Sequence &sequence, FilterFunction filterFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
-
-  Calls \a filterFunction once for each item in \a sequence. If
-  \a filterFunction returns true for an item, that item is then passed to
-  \a reduceFunction. In other words, the return value is the result of
-  \a reduceFunction for each item where \a filterFunction returns true.
-
-  Note that while \a filterFunction is called concurrently, only one thread
-  at a time will call \a reduceFunction. The order in which \a reduceFunction
-  is called is undefined if \a reduceOptions is
-  QtConcurrent::UnorderedReduce. If \a reduceOptions is
-  QtConcurrent::OrderedReduce, \a reduceFunction is called in the order of
-  the original sequence.
-
-  \note This function will block until all items in the sequence have been processed.
-
-  \sa filteredReduced()
-*/
-
-/*!
-  \fn T QtConcurrent::blockingFilteredReduced(ConstIterator begin, ConstIterator end, FilterFunction filterFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
-
-  Calls \a filterFunction once for each item from \a begin to \a end. If
-  \a filterFunction returns true for an item, that item is then passed to
-  \a reduceFunction. In other words, the return value is the result of
-  \a reduceFunction for each item where \a filterFunction returns true.
-
-  Note that while \a filterFunction is called concurrently, only one thread
-  at a time will call \a reduceFunction. The order in which
-  \a reduceFunction is called is undefined if \a reduceOptions is
-  QtConcurrent::UnorderedReduce. If \a reduceOptions is
-  QtConcurrent::OrderedReduce, the \a reduceFunction is called in the order
-  of the original sequence.
-
-  \note This function will block until the iterator reaches the end of the
-  sequence being processed.
-
-  \sa filteredReduced()
-*/
diff --git a/src/corelib/concurrent/qtconcurrentfilter.h b/src/corelib/concurrent/qtconcurrentfilter.h
deleted file mode 100644
index f5c3865..0000000
--- a/src/corelib/concurrent/qtconcurrentfilter.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_FILTER_H
-#define QTCONCURRENT_FILTER_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qtconcurrentfilterkernel.h>
-#include <QtCore/qtconcurrentfunctionwrappers.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifdef qdoc
-
-namespace QtConcurrent {
-
-    QFuture<void> filter(Sequence &sequence, FilterFunction filterFunction);
-
-    template <typename T>
-    QFuture<T> filtered(const Sequence &sequence, FilterFunction filterFunction);
-    template <typename T>
-    QFuture<T> filtered(ConstIterator begin, ConstIterator end, FilterFunction filterFunction);
-
-    template <typename T>
-    QFuture<T> filteredReduced(const Sequence &sequence,
-                               FilterFunction filterFunction,
-                               ReduceFunction reduceFunction,
-                               QtConcurrent::ReduceOptions reduceOptions = UnorderedReduce | SequentialReduce);
-    template <typename T>
-    QFuture<T> filteredReduced(ConstIterator begin,
-                               ConstIterator end,
-                               FilterFunction filterFunction,
-                               ReduceFunction reduceFunction,
-                               QtConcurrent::ReduceOptions reduceOptions = UnorderedReduce | SequentialReduce);
-
-    void blockingFilter(Sequence &sequence, FilterFunction filterFunction);
-
-    template <typename Sequence>
-    Sequence blockingFiltered(const Sequence &sequence, FilterFunction filterFunction);
-    template <typename Sequence>
-    Sequence blockingFiltered(ConstIterator begin, ConstIterator end, FilterFunction filterFunction);
-
-    template <typename T>
-    T blockingFilteredReduced(const Sequence &sequence,
-                              FilterFunction filterFunction,
-                              ReduceFunction reduceFunction,
-                              QtConcurrent::ReduceOptions reduceOptions = UnorderedReduce | SequentialReduce);
-    template <typename T>
-    T blockingFilteredReduced(ConstIterator begin,
-                              ConstIterator end,
-                              FilterFunction filterFunction,
-                              ReduceFunction reduceFunction,
-                              QtConcurrent::ReduceOptions reduceOptions = UnorderedReduce | SequentialReduce);
-
-} // namespace QtConcurrent
-
-#else
-
-namespace QtConcurrent {
-
-template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
-ThreadEngineStarter<void> filterInternal(Sequence &sequence, KeepFunctor keep, ReduceFunctor reduce)
-{
-    typedef typename Sequence::const_iterator Iterator;
-    typedef FilterKernel<Sequence, KeepFunctor, ReduceFunctor> KernelType;
-    return startThreadEngine(new KernelType(sequence, keep, reduce));
-}
-
-// filter() on sequences
-template <typename Sequence, typename KeepFunctor>
-QFuture<void> filter(Sequence &sequence, KeepFunctor keep)
-{
-    return filterInternal(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::PushBackWrapper());
-}
-
-// filteredReduced() on sequences
-template <typename ResultType, typename Sequence, typename KeepFunctor, typename ReduceFunctor>
-QFuture<ResultType> filteredReduced(const Sequence &sequence,
-                                    KeepFunctor keep,
-                                    ReduceFunctor reduce,
-                                    ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startFilteredReduced<ResultType>(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::createFunctionWrapper(reduce), options);
-}
-
-template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
-QFuture<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType> filteredReduced(const Sequence &sequence,
-                                    KeepFunctor keep,
-                                    ReduceFunctor reduce,
-                                    ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startFilteredReduced<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
-            (sequence,
-             QtPrivate::createFunctionWrapper(keep),
-             QtPrivate::createFunctionWrapper(reduce),
-             options);
-}
-
-// filteredReduced() on iterators
-template <typename ResultType, typename Iterator, typename KeepFunctor, typename ReduceFunctor>
-QFuture<ResultType> filteredReduced(Iterator begin,
-                                    Iterator end,
-                                    KeepFunctor keep,
-                                    ReduceFunctor reduce,
-                                    ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-   return startFilteredReduced<ResultType>(begin, end, QtPrivate::createFunctionWrapper(keep), QtPrivate::createFunctionWrapper(reduce), options);
-}
-
-template <typename Iterator, typename KeepFunctor, typename ReduceFunctor>
-QFuture<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType> filteredReduced(Iterator begin,
-                                    Iterator end,
-                                    KeepFunctor keep,
-                                    ReduceFunctor reduce,
-                                    ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-   return startFilteredReduced<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
-           (begin, end,
-            QtPrivate::createFunctionWrapper(keep),
-            QtPrivate::createFunctionWrapper(reduce),
-            options);
-}
-
-// filtered() on sequences
-template <typename Sequence, typename KeepFunctor>
-QFuture<typename Sequence::value_type> filtered(const Sequence &sequence, KeepFunctor keep)
-{
-    return startFiltered(sequence, QtPrivate::createFunctionWrapper(keep));
-}
-
-// filtered() on iterators
-template <typename Iterator, typename KeepFunctor>
-QFuture<typename qValueType<Iterator>::value_type> filtered(Iterator begin, Iterator end, KeepFunctor keep)
-{
-    return startFiltered(begin, end, QtPrivate::createFunctionWrapper(keep));
-}
-
-// blocking filter() on sequences
-template <typename Sequence, typename KeepFunctor>
-void blockingFilter(Sequence &sequence, KeepFunctor keep)
-{
-    filterInternal(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::PushBackWrapper()).startBlocking();
-}
-
-// blocking filteredReduced() on sequences
-template <typename ResultType, typename Sequence, typename KeepFunctor, typename ReduceFunctor>
-ResultType blockingFilteredReduced(const Sequence &sequence,
-                                   KeepFunctor keep,
-                                   ReduceFunctor reduce,
-                                   ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startFilteredReduced<ResultType>(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::createFunctionWrapper(reduce), options)
-        .startBlocking();
-}
-
-template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
-typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType blockingFilteredReduced(const Sequence &sequence,
-                                   KeepFunctor keep,
-                                   ReduceFunctor reduce,
-                                   ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return blockingFilteredReduced<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
-        (sequence,
-         QtPrivate::createFunctionWrapper(keep),
-         QtPrivate::createFunctionWrapper(reduce),
-         options);
-}
-
-// blocking filteredReduced() on iterators
-template <typename ResultType, typename Iterator, typename KeepFunctor, typename ReduceFunctor>
-ResultType blockingFilteredReduced(Iterator begin,
-                                   Iterator end,
-                                   KeepFunctor keep,
-                                   ReduceFunctor reduce,
-                                   ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startFilteredReduced<ResultType>
-        (begin, end,
-         QtPrivate::createFunctionWrapper(keep),
-         QtPrivate::createFunctionWrapper(reduce),
-         options)
-        .startBlocking();
-}
-
-template <typename Iterator, typename KeepFunctor, typename ReduceFunctor>
-typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType blockingFilteredReduced(Iterator begin,
-                                   Iterator end,
-                                   KeepFunctor keep,
-                                   ReduceFunctor reduce,
-                                   ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startFilteredReduced<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
-        (begin, end,
-         QtPrivate::createFunctionWrapper(keep),
-         QtPrivate::createFunctionWrapper(reduce),
-         options)
-        .startBlocking();
-}
-
-// blocking filtered() on sequences
-template <typename Sequence, typename KeepFunctor>
-Sequence blockingFiltered(const Sequence &sequence, KeepFunctor keep)
-{
-    return startFilteredReduced<Sequence>(sequence, QtPrivate::createFunctionWrapper(keep), QtPrivate::PushBackWrapper(), OrderedReduce).startBlocking();
-}
-
-// blocking filtered() on iterators
-template <typename OutputSequence, typename Iterator, typename KeepFunctor>
-OutputSequence blockingFiltered(Iterator begin, Iterator end, KeepFunctor keep)
-{
-    return startFilteredReduced<OutputSequence>(begin, end,
-        QtPrivate::createFunctionWrapper(keep),
-        QtPrivate::PushBackWrapper(),
-        OrderedReduce).startBlocking();
-}
-
-} // namespace QtConcurrent
-
-#endif // qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentfilterkernel.h b/src/corelib/concurrent/qtconcurrentfilterkernel.h
deleted file mode 100644
index ea0e5fc..0000000
--- a/src/corelib/concurrent/qtconcurrentfilterkernel.h
+++ /dev/null
@@ -1,350 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_FILTERKERNEL_H
-#define QTCONCURRENT_FILTERKERNEL_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qtconcurrentiteratekernel.h>
-#include <QtCore/qtconcurrentmapkernel.h>
-#include <QtCore/qtconcurrentreducekernel.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifndef qdoc
-
-namespace QtConcurrent {
-
-template <typename T>
-struct qValueType
-{
-    typedef typename T::value_type value_type;
-};
-
-template <typename T>
-struct qValueType<const T*>
-{
-    typedef T value_type;
-};
-
-template <typename T>
-struct qValueType<T*>
-{
-    typedef T value_type;
-};
-
-// Implementation of filter
-template <typename Sequence, typename KeepFunctor, typename ReduceFunctor>
-class FilterKernel : public IterateKernel<typename Sequence::const_iterator, void>
-{
-    typedef ReduceKernel<ReduceFunctor, Sequence, typename Sequence::value_type> Reducer;
-    typedef IterateKernel<typename Sequence::const_iterator, void> IterateKernelType;
-    typedef typename ReduceFunctor::result_type T;
-
-    Sequence reducedResult;
-    Sequence &sequence;
-    KeepFunctor keep;
-    ReduceFunctor reduce;
-    Reducer reducer;
-
-public:
-    FilterKernel(Sequence &_sequence, KeepFunctor _keep, ReduceFunctor _reduce)
-        : IterateKernelType(const_cast<const Sequence &>(_sequence).begin(), const_cast<const Sequence &>(_sequence).end()), reducedResult(),
-          sequence(_sequence),
-          keep(_keep),
-          reduce(_reduce),
-          reducer(OrderedReduce)
-    { }
-
-    bool runIteration(typename Sequence::const_iterator it, int index, T *)
-    {
-        IntermediateResults<typename Sequence::value_type> results;
-        results.begin = index;
-        results.end = index + 1;
-
-            if (keep(*it))
-                results.vector.append(*it);
-
-            reducer.runReduce(reduce, reducedResult, results);
-            return false;
-    }
-
-    bool runIterations(typename Sequence::const_iterator sequenceBeginIterator, int begin, int end, T *)
-    {
-        IntermediateResults<typename Sequence::value_type> results;
-        results.begin = begin;
-        results.end = end;
-        results.vector.reserve(end - begin);
-
-
-        typename Sequence::const_iterator it = sequenceBeginIterator;
-        advance(it, begin);
-        for (int i = begin; i < end; ++i) {
-            if (keep(*it))
-                results.vector.append(*it);
-            advance(it, 1);
-        }
-
-        reducer.runReduce(reduce, reducedResult, results);
-        return false;
-    }
-
-    void finish()
-    {
-        reducer.finish(reduce, reducedResult);
-        sequence = reducedResult;
-    }
-
-    inline bool shouldThrottleThread()
-    {
-        return IterateKernelType::shouldThrottleThread() || reducer.shouldThrottle();
-    }
-
-    inline bool shouldStartThread()
-    {
-        return IterateKernelType::shouldStartThread() && reducer.shouldStartThread();
-    }
-
-    typedef void ReturnType;
-    typedef void ResultType;
-};
-
-// Implementation of filter-reduce
-template <typename ReducedResultType,
-          typename Iterator,
-          typename KeepFunctor,
-          typename ReduceFunctor,
-          typename Reducer = ReduceKernel<ReduceFunctor,
-                                          ReducedResultType,
-                                          typename qValueType<Iterator>::value_type> >
-class FilteredReducedKernel : public IterateKernel<Iterator, ReducedResultType>
-{
-    ReducedResultType reducedResult;
-    KeepFunctor keep;
-    ReduceFunctor reduce;
-    Reducer reducer;
-    typedef IterateKernel<Iterator, ReducedResultType> IterateKernelType;
-
-public:
-    FilteredReducedKernel(Iterator begin,
-                          Iterator end,
-                          KeepFunctor _keep,
-                          ReduceFunctor _reduce,
-                          ReduceOptions reduceOption)
-        : IterateKernelType(begin, end), reducedResult(), keep(_keep), reduce(_reduce), reducer(reduceOption)
-    { }
-
-#if 0
-    FilteredReducedKernel(ReducedResultType initialValue,
-                          KeepFunctor keep,
-                          ReduceFunctor reduce,
-                          ReduceOption reduceOption)
-        : reducedResult(initialValue), keep(keep), reduce(reduce), reducer(reduceOption)
-    { }
-#endif
-
-    bool runIteration(Iterator it, int index, ReducedResultType *)
-    {
-        IntermediateResults<typename qValueType<Iterator>::value_type> results;
-        results.begin = index;
-        results.end = index + 1;
-
-        if (keep(*it))
-            results.vector.append(*it);
-
-        reducer.runReduce(reduce, reducedResult, results);
-        return false;
-    }
-
-    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, ReducedResultType *)
-    {
-        IntermediateResults<typename qValueType<Iterator>::value_type> results;
-        results.begin = begin;
-        results.end = end;
-        results.vector.reserve(end - begin);
-
-        Iterator it = sequenceBeginIterator;
-        advance(it, begin);
-        for (int i = begin; i < end; ++i) {
-            if (keep(*it))
-                results.vector.append(*it);
-            advance(it, 1);
-        }
-
-        reducer.runReduce(reduce, reducedResult, results);
-        return false;
-    }
-
-    void finish()
-    {
-        reducer.finish(reduce, reducedResult);
-    }
-
-    inline bool shouldThrottleThread()
-    {
-        return IterateKernelType::shouldThrottleThread() || reducer.shouldThrottle();
-    }
-
-    inline bool shouldStartThread()
-    {
-        return IterateKernelType::shouldStartThread() && reducer.shouldStartThread();
-    }
-
-    typedef ReducedResultType ReturnType;
-    typedef ReducedResultType ResultType;
-    ReducedResultType *result()
-    {
-        return &reducedResult;
-    }
-};
-
-// Implementation of filter that reports individual results via QFutureInterface
-template <typename Iterator, typename KeepFunctor>
-class FilteredEachKernel : public IterateKernel<Iterator, typename qValueType<Iterator>::value_type>
-{
-    typedef typename qValueType<Iterator>::value_type T;
-    typedef IterateKernel<Iterator, T> IterateKernelType;
-
-    KeepFunctor keep;
-
-public:
-    typedef T ReturnType;
-    typedef T ResultType;
-
-    FilteredEachKernel(Iterator begin, Iterator end, KeepFunctor _keep)
-        : IterateKernelType(begin, end), keep(_keep)
-    { }
-
-    void start()
-    {
-        if (this->futureInterface)
-            this->futureInterface->setFilterMode(true);
-        IterateKernelType::start();
-    }
-
-    bool runIteration(Iterator it, int index, T *)
-    {
-        if (keep(*it))
-            this->reportResult(&(*it), index);
-        else
-            this->reportResult(0, index);
-        return false;
-    }
-
-    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, T *)
-    {
-        const int count = end - begin;
-        IntermediateResults<typename qValueType<Iterator>::value_type> results;
-        results.begin = begin;
-        results.end = end;
-        results.vector.reserve(count);
-
-        Iterator it = sequenceBeginIterator;
-        advance(it, begin);
-        for (int i = begin; i < end; ++i) {
-            if (keep(*it))
-                results.vector.append(*it);
-            advance(it, 1);
-        }
-
-        this->reportResults(results.vector, begin, count);
-        return false;
-    }
-};
-
-template <typename Iterator, typename KeepFunctor>
-inline
-ThreadEngineStarter<typename qValueType<Iterator>::value_type>
-startFiltered(Iterator begin, Iterator end, KeepFunctor functor)
-{
-    return startThreadEngine(new FilteredEachKernel<Iterator, KeepFunctor>(begin, end, functor));
-}
-
-template <typename Sequence, typename KeepFunctor>
-inline ThreadEngineStarter<typename Sequence::value_type>
-startFiltered(const Sequence &sequence, KeepFunctor functor)
-{
-    typedef SequenceHolder1<Sequence,
-                            FilteredEachKernel<typename Sequence::const_iterator, KeepFunctor>,
-                            KeepFunctor>
-        SequenceHolderType;
-        return startThreadEngine(new SequenceHolderType(sequence, functor));
-}
-
-template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
-inline ThreadEngineStarter<ResultType> startFilteredReduced(const Sequence & sequence,
-                                                           MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
-                                                           ReduceOptions options)
-{
-    typedef typename Sequence::const_iterator Iterator;
-    typedef ReduceKernel<ReduceFunctor, ResultType, typename qValueType<Iterator>::value_type > Reducer;
-    typedef FilteredReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> FilteredReduceType;
-    typedef SequenceHolder2<Sequence, FilteredReduceType, MapFunctor, ReduceFunctor> SequenceHolderType;
-    return startThreadEngine(new SequenceHolderType(sequence, mapFunctor, reduceFunctor, options));
-}
-
-
-template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
-inline ThreadEngineStarter<ResultType> startFilteredReduced(Iterator begin, Iterator end,
-                                                           MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
-                                                           ReduceOptions options)
-{
-    typedef ReduceKernel<ReduceFunctor, ResultType, typename qValueType<Iterator>::value_type> Reducer;
-    typedef FilteredReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> FilteredReduceType;
-    return startThreadEngine(new FilteredReduceType(begin, end, mapFunctor, reduceFunctor, options));
-}
-
-
-} // namespace QtConcurrent
-
-#endif // qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentfunctionwrappers.h b/src/corelib/concurrent/qtconcurrentfunctionwrappers.h
deleted file mode 100644
index 9b86b73..0000000
--- a/src/corelib/concurrent/qtconcurrentfunctionwrappers.h
+++ /dev/null
@@ -1,303 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_FUNCTIONWRAPPERS_H
-#define QTCONCURRENT_FUNCTIONWRAPPERS_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifndef qdoc
-
-namespace QtConcurrent {
-
-template <typename T>
-class FunctionWrapper0
-{
-public:
-    typedef T (*FunctionPointerType)();
-    typedef T result_type;
-    inline FunctionWrapper0(FunctionPointerType _functionPointer)
-    :functionPointer(_functionPointer) { }
-
-    inline T operator()()
-    {
-        return functionPointer();
-    }
-private:
-    FunctionPointerType functionPointer;
-};
-
-template <typename T, typename U>
-class FunctionWrapper1
-{
-public:
-    typedef T (*FunctionPointerType)(U u);
-    typedef T result_type;
-    inline FunctionWrapper1(FunctionPointerType _functionPointer)
-    :functionPointer(_functionPointer) { }
-
-    inline T operator()(U u)
-    {
-        return functionPointer(u);
-    }
-
-private:
-    FunctionPointerType functionPointer;
-};
-
-template <typename T, typename U, typename V>
-class FunctionWrapper2
-{
-public:
-    typedef T (*FunctionPointerType)(U u, V v);
-    typedef T result_type;
-    inline FunctionWrapper2(FunctionPointerType _functionPointer)
-    :functionPointer(_functionPointer) { }
-
-    inline T operator()(U u, V v)
-    {
-        return functionPointer(u, v);
-    }
-private:
-    FunctionPointerType functionPointer;
-};
-
-template <typename T, typename C>
-class MemberFunctionWrapper
-{
-public:
-    typedef T (C::*FunctionPointerType)();
-    typedef T result_type;
-    inline MemberFunctionWrapper(FunctionPointerType _functionPointer)
-    :functionPointer(_functionPointer) { }
-
-    inline T operator()(C &c)
-    {
-        return (c.*functionPointer)();
-    }
-private:
-    FunctionPointerType functionPointer;
-};
-
-template <typename T, typename C, typename U>
-class MemberFunctionWrapper1
-{
-public:
-    typedef T (C::*FunctionPointerType)(U);
-    typedef T result_type;
-
-    inline MemberFunctionWrapper1(FunctionPointerType _functionPointer)
-        : functionPointer(_functionPointer)
-    { }
-
-    inline T operator()(C &c, U u)
-    {
-        return (c.*functionPointer)(u);
-    }
-
-private:
-    FunctionPointerType functionPointer;
-};
-
-template <typename T, typename C>
-class ConstMemberFunctionWrapper
-{
-public:
-    typedef T (C::*FunctionPointerType)() const;
-    typedef T result_type;
-    inline ConstMemberFunctionWrapper(FunctionPointerType _functionPointer)
-    :functionPointer(_functionPointer) { }
-
-    inline T operator()(const C &c) const
-    {
-        return (c.*functionPointer)();
-    }
-private:
-    FunctionPointerType functionPointer;
-};
-
-} // namespace QtConcurrent.
-
-namespace QtPrivate {
-
-template <typename T>
-const T& createFunctionWrapper(const T& t)
-{
-    return t;
-}
-
-template <typename T, typename U>
-QtConcurrent::FunctionWrapper1<T, U> createFunctionWrapper(T (*func)(U))
-{
-    return QtConcurrent::FunctionWrapper1<T, U>(func);
-}
-
-template <typename T, typename C>
-QtConcurrent::MemberFunctionWrapper<T, C> createFunctionWrapper(T (C::*func)())
-{
-    return QtConcurrent::MemberFunctionWrapper<T, C>(func);
-}
-
-template <typename T, typename C, typename U>
-QtConcurrent::MemberFunctionWrapper1<T, C, U> createFunctionWrapper(T (C::*func)(U))
-{
-    return QtConcurrent::MemberFunctionWrapper1<T, C, U>(func);
-}
-
-template <typename T, typename C>
-QtConcurrent::ConstMemberFunctionWrapper<T, C> createFunctionWrapper(T (C::*func)() const)
-{
-    return QtConcurrent::ConstMemberFunctionWrapper<T, C>(func);
-}
-
-struct PushBackWrapper
-{
-    typedef void result_type;
-
-    template <class C, class U>
-    inline void operator()(C &c, const U &u) const
-    {
-        return c.push_back(u);
-    }
-
-#ifdef Q_COMPILER_RVALUE_REFS
-    template <class C, class U>
-    inline void operator()(C &c, U &&u) const
-    {
-        return c.push_back(u);
-    }
-#endif
-};
-
-template <typename Functor, bool foo = HasResultType<Functor>::Value>
-struct LazyResultType { typedef typename Functor::result_type Type; };
-template <typename Functor>
-struct LazyResultType<Functor, false> { typedef void Type; };
-
-template <class T>
-struct ReduceResultType;
-
-template <class U, class V>
-struct ReduceResultType<void(*)(U&,V)>
-{
-    typedef U ResultType;
-};
-
-template <class T, class C, class U>
-struct ReduceResultType<T(C::*)(U)>
-{
-    typedef C ResultType;
-};
-
-template <class InputSequence, class MapFunctor>
-struct MapResultType
-{
-    typedef typename LazyResultType<MapFunctor>::Type ResultType;
-};
-
-template <class U, class V>
-struct MapResultType<void, U (*)(V)>
-{
-    typedef U ResultType;
-};
-
-template <class T, class C>
-struct MapResultType<void, T(C::*)() const>
-{
-    typedef T ResultType;
-};
-
-#ifndef QT_NO_TEMPLATE_TEMPLATE_PARAMETERS
-
-template <template <typename> class InputSequence, typename MapFunctor, typename T>
-struct MapResultType<InputSequence<T>, MapFunctor>
-{
-    typedef InputSequence<typename LazyResultType<MapFunctor>::Type> ResultType;
-};
-
-template <template <typename> class InputSequence, class T, class U, class V>
-struct MapResultType<InputSequence<T>, U (*)(V)>
-{
-    typedef InputSequence<U> ResultType;
-};
-
-template <template <typename> class InputSequence, class T, class U, class C>
-struct MapResultType<InputSequence<T>, U(C::*)() const>
-{
-    typedef InputSequence<U> ResultType;
-};
-
-#endif // QT_NO_TEMPLATE_TEMPLATE_PARAMETER
-
-template <class MapFunctor>
-struct MapResultType<QStringList, MapFunctor>
-{
-    typedef QList<typename LazyResultType<MapFunctor>::Type> ResultType;
-};
-
-template <class U, class V>
-struct MapResultType<QStringList, U (*)(V)>
-{
-    typedef QList<U> ResultType;
-};
-
-template <class U, class C>
-struct MapResultType<QStringList, U(C::*)() const>
-{
-    typedef QList<U> ResultType;
-};
-
-} // namespace QtPrivate.
-
-#endif //qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentiteratekernel.cpp b/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
deleted file mode 100644
index b695805..0000000
--- a/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
+++ /dev/null
@@ -1,194 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qtconcurrentiteratekernel.h"
-
-#if defined(Q_OS_MAC)
-#include <mach/mach.h>
-#include <mach/mach_time.h>
-#include <unistd.h>
-#elif defined(Q_OS_UNIX)
-#if defined(Q_OS_HURD)
-#include <sys/time.h>
-#endif
-#include <time.h>
-#include <unistd.h>
-#elif defined(Q_OS_WIN)
-#include <qt_windows.h>
-#endif
-
-#include "private/qfunctions_p.h"
-
-
-#ifndef QT_NO_CONCURRENT
-
-QT_BEGIN_NAMESPACE
-
-enum {
-    TargetRatio = 100,
-    MedianSize = 7
-};
-
-#if defined(Q_OS_MAC)
-
-static qint64 getticks()
-{
-    return mach_absolute_time();
-}
-
-#elif defined(Q_OS_UNIX)
-
-
-static qint64 getticks()
-{
-#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)
-    clockid_t clockId;
-
-#ifndef _POSIX_THREAD_CPUTIME
-    clockId = CLOCK_REALTIME;
-#elif (_POSIX_THREAD_CPUTIME-0 <= 0)
-    // if we don't have CLOCK_THREAD_CPUTIME_ID, we have to just use elapsed realtime instead
-    clockId = CLOCK_REALTIME;
-
-#  if (_POSIX_THREAD_CPUTIME-0 == 0)
-    // detect availablility of CLOCK_THREAD_CPUTIME_ID
-    static long useThreadCpuTime = -2;
-    if (useThreadCpuTime == -2) {
-        // sysconf() will return either -1 or _POSIX_VERSION (don't care about thread races here)
-        useThreadCpuTime = sysconf(_SC_THREAD_CPUTIME);
-    }
-    if (useThreadCpuTime != -1)
-        clockId = CLOCK_THREAD_CPUTIME_ID;
-#  endif
-#else
-    clockId = CLOCK_THREAD_CPUTIME_ID;
-#endif
-
-    struct timespec ts;
-    if (clock_gettime(clockId, &ts) == -1)
-        return 0;
-    return (ts.tv_sec * 1000000000) + ts.tv_nsec;
-#else
-
-    // no clock_gettime(), fall back to wall time
-    struct timeval tv;
-    gettimeofday(&tv, 0);
-    return (tv.tv_sec * 1000000) + tv.tv_usec;
-#endif
-}
-
-#elif defined(Q_OS_WIN)
-
-static qint64 getticks()
-{
-    LARGE_INTEGER x;
-    if (!QueryPerformanceCounter(&x))
-        return 0;
-    return x.QuadPart;
-}
-
-#endif
-
-static double elapsed(qint64 after, qint64 before)
-{
-    return double(after - before);
-}
-
-namespace QtConcurrent {
-
-/*! \internal
-
-*/
-BlockSizeManager::BlockSizeManager(int iterationCount)
-: maxBlockSize(iterationCount / (QThreadPool::globalInstance()->maxThreadCount() * 2)),
-  beforeUser(0), afterUser(0),
-  controlPartElapsed(MedianSize), userPartElapsed(MedianSize),
-  m_blockSize(1)
-{ }
-
-// Records the time before user code.
-void BlockSizeManager::timeBeforeUser()
-{
-    if (blockSizeMaxed())
-        return;
-
-    beforeUser = getticks();
-    controlPartElapsed.addValue(elapsed(beforeUser, afterUser));
-}
-
- // Records the time after user code and adjust the block size if we are spending
- // to much time in the for control code compared with the user code.
-void BlockSizeManager::timeAfterUser()
-{
-    if (blockSizeMaxed())
-        return;
-
-    afterUser = getticks();
-    userPartElapsed.addValue(elapsed(afterUser, beforeUser));
-
-    if (controlPartElapsed.isMedianValid() == false)
-        return;
-
-    if (controlPartElapsed.median() * TargetRatio < userPartElapsed.median())
-        return;
-
-    m_blockSize = qMin(m_blockSize * 2,  maxBlockSize);
-
-#ifdef QTCONCURRENT_FOR_DEBUG
-    qDebug() << QThread::currentThread() << "adjusting block size" << controlPartElapsed.median() << userPartElapsed.median() << m_blockSize;
-#endif
-
-    // Reset the medians after adjusting the block size so we get
-    // new measurements with the new block size.
-    controlPartElapsed.reset();
-    userPartElapsed.reset();
-}
-
-int BlockSizeManager::blockSize()
-{
-    return m_blockSize;
-}
-
-} // namespace QtConcurrent
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_CONCURRENT
diff --git a/src/corelib/concurrent/qtconcurrentiteratekernel.h b/src/corelib/concurrent/qtconcurrentiteratekernel.h
deleted file mode 100644
index 527bd85..0000000
--- a/src/corelib/concurrent/qtconcurrentiteratekernel.h
+++ /dev/null
@@ -1,339 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_ITERATEKERNEL_H
-#define QTCONCURRENT_ITERATEKERNEL_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qatomic.h>
-#include <QtCore/qtconcurrentmedian.h>
-#include <QtCore/qtconcurrentthreadengine.h>
-
-#ifndef QT_NO_STL
-#  include <iterator>
-#endif
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifndef qdoc
-
-namespace QtConcurrent {
-
-#ifndef QT_NO_STL
-    using std::advance;
-#else
-    template <typename It, typename T>
-    void advance(It &it, T value)
-    {
-        it+=value;
-    }
-#endif
-
-/*
-    The BlockSizeManager class manages how many iterations a thread should
-    reserve and process at a time. This is done by measuring the time spent
-    in the user code versus the control part code, and then increasing
-    the block size if the ratio between them is to small. The block size
-    management is done on the basis of the median of several timing measuremens,
-    and it is done induvidualy for each thread.
-*/
-class Q_CORE_EXPORT BlockSizeManager
-{
-public:
-    BlockSizeManager(int iterationCount);
-    void timeBeforeUser();
-    void timeAfterUser();
-    int blockSize();
-private:
-    inline bool blockSizeMaxed()
-    {
-        return (m_blockSize >= maxBlockSize);
-    }
-
-    const int maxBlockSize;
-    qint64 beforeUser;
-    qint64 afterUser;
-    Median<double> controlPartElapsed;
-    Median<double> userPartElapsed;
-    int m_blockSize;
-};
-
-template <typename T>
-class ResultReporter
-{
-public:
-    ResultReporter(ThreadEngine<T> *_threadEngine)
-    :threadEngine(_threadEngine)
-    {
-
-    }
-
-    void reserveSpace(int resultCount)
-    {
-        currentResultCount = resultCount;
-        vector.resize(qMax(resultCount, vector.count()));
-    }
-
-    void reportResults(int begin)
-    {
-        const int useVectorThreshold = 4; // Tunable parameter.
-        if (currentResultCount > useVectorThreshold) {
-            vector.resize(currentResultCount);
-            threadEngine->reportResults(vector, begin);
-        } else {
-            for (int i = 0; i < currentResultCount; ++i)
-                threadEngine->reportResult(&vector.at(i), begin + i);
-        }
-    }
-
-    inline T * getPointer()
-    {
-        return vector.data();
-    }
-
-    int currentResultCount;
-    ThreadEngine<T> *threadEngine;
-    QVector<T> vector;
-};
-
-template <>
-class ResultReporter<void>
-{
-public:
-    inline ResultReporter(ThreadEngine<void> *) { }
-    inline void reserveSpace(int) { }
-    inline void reportResults(int) { }
-    inline void * getPointer() { return 0; }
-};
-
-#ifndef QT_NO_STL
-inline bool selectIteration(std::bidirectional_iterator_tag)
-{
-    return false; // while
-}
-
-inline bool selectIteration(std::forward_iterator_tag)
-{
-    return false; // while
-}
-
-inline bool selectIteration(std::random_access_iterator_tag)
-{
-    return true; // for
-}
-#else
-// no stl support, always use while iteration
-template <typename T>
-inline bool selectIteration(T)
-{
-    return false; // while
-}
-#endif
-
-template <typename Iterator, typename T>
-class IterateKernel : public ThreadEngine<T>
-{
-public:
-    typedef T ResultType;
-
-    IterateKernel(Iterator _begin, Iterator _end)
-#if defined (QT_NO_STL)
-        : begin(_begin), end(_end), current(_begin), currentIndex(0),
-           forIteration(false), progressReportingEnabled(true)
-#else
-        : begin(_begin), end(_end), current(_begin), currentIndex(0),
-           forIteration(selectIteration(typename std::iterator_traits<Iterator>::iterator_category())), progressReportingEnabled(true)
-#endif
-    {
-#if defined (QT_NO_STL)
-       iterationCount = 0;
-#else
-        iterationCount =  forIteration ? std::distance(_begin, _end) : 0;
-
-#endif
-    }
-
-    virtual ~IterateKernel() { }
-
-    virtual bool runIteration(Iterator it, int index , T *result)
-        { Q_UNUSED(it); Q_UNUSED(index); Q_UNUSED(result); return false; }
-    virtual bool runIterations(Iterator _begin, int beginIndex, int endIndex, T *results)
-        { Q_UNUSED(_begin); Q_UNUSED(beginIndex); Q_UNUSED(endIndex); Q_UNUSED(results); return false; }
-
-    void start()
-    {
-        progressReportingEnabled = this->isProgressReportingEnabled();
-        if (progressReportingEnabled && iterationCount > 0)
-            this->setProgressRange(0, iterationCount);
-    }
-
-    bool shouldStartThread()
-    {
-        if (forIteration)
-            return (currentIndex.load() < iterationCount) && !this->shouldThrottleThread();
-        else // whileIteration
-            return (iteratorThreads.load() == 0);
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        if (forIteration)
-            return this->forThreadFunction();
-        else // whileIteration
-            return this->whileThreadFunction();
-    }
-
-    ThreadFunctionResult forThreadFunction()
-    {
-        BlockSizeManager blockSizeManager(iterationCount);
-        ResultReporter<T> resultReporter(this);
-
-        for(;;) {
-            if (this->isCanceled())
-                break;
-
-            const int currentBlockSize = blockSizeManager.blockSize();
-
-            if (currentIndex.load() >= iterationCount)
-                break;
-
-            // Atomically reserve a block of iterationCount for this thread.
-            const int beginIndex = currentIndex.fetchAndAddRelease(currentBlockSize);
-            const int endIndex = qMin(beginIndex + currentBlockSize, iterationCount);
-
-            if (beginIndex >= endIndex) {
-                // No more work
-                break;
-            }
-
-            this->waitForResume(); // (only waits if the qfuture is paused.)
-
-            if (shouldStartThread())
-                this->startThread();
-
-            const int finalBlockSize = endIndex - beginIndex; // block size adjusted for possible end-of-range
-            resultReporter.reserveSpace(finalBlockSize);
-
-            // Call user code with the current iteration range.
-            blockSizeManager.timeBeforeUser();
-            const bool resultsAvailable = this->runIterations(begin, beginIndex, endIndex, resultReporter.getPointer());
-            blockSizeManager.timeAfterUser();
-
-            if (resultsAvailable)
-                resultReporter.reportResults(beginIndex);
-
-            // Report progress if progress reporting enabled.
-            if (progressReportingEnabled) {
-                completed.fetchAndAddAcquire(finalBlockSize);
-                this->setProgressValue(this->completed.load());
-            }
-
-            if (this->shouldThrottleThread())
-                return ThrottleThread;
-        }
-        return ThreadFinished;
-    }
-
-    ThreadFunctionResult whileThreadFunction()
-    {
-        if (iteratorThreads.testAndSetAcquire(0, 1) == false)
-            return ThreadFinished;
-
-        ResultReporter<T> resultReporter(this);
-        resultReporter.reserveSpace(1);
-
-        while (current != end) {
-            // The following two lines breaks support for input iterators according to
-            // the sgi docs: dereferencing prev after calling ++current is not allowed
-            // on input iterators. (prev is dereferenced inside user.runIteration())
-            Iterator prev = current;
-            ++current;
-            int index = currentIndex.fetchAndAddRelaxed(1);
-            iteratorThreads.testAndSetRelease(1, 0);
-
-            this->waitForResume(); // (only waits if the qfuture is paused.)
-
-            if (shouldStartThread())
-                this->startThread();
-
-            const bool resultAavailable = this->runIteration(prev, index, resultReporter.getPointer());
-            if (resultAavailable)
-                resultReporter.reportResults(index);
-
-            if (this->shouldThrottleThread())
-                return ThrottleThread;
-
-            if (iteratorThreads.testAndSetAcquire(0, 1) == false)
-                return ThreadFinished;
-        }
-
-        return ThreadFinished;
-    }
-
-
-public:
-    const Iterator begin;
-    const Iterator end;
-    Iterator current;
-    QAtomicInt currentIndex;
-    bool forIteration;
-    QAtomicInt iteratorThreads;
-    int iterationCount;
-
-    bool progressReportingEnabled;
-    QAtomicInt completed;
-};
-
-} // namespace QtConcurrent
-
-#endif //qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentmap.cpp b/src/corelib/concurrent/qtconcurrentmap.cpp
deleted file mode 100644
index 1758cb9..0000000
--- a/src/corelib/concurrent/qtconcurrentmap.cpp
+++ /dev/null
@@ -1,402 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-    \namespace QtConcurrent
-    \inmodule QtCore
-    \since 4.4
-    \brief The QtConcurrent namespace provides high-level APIs that make it
-    possible to write multi-threaded programs without using low-level
-    threading primitives.
-
-    See the \l {Concurrent Programming}{Qt Concurrent} chapter in
-    the \l{threads.html}{threading} documentation.
-
-    \inheaderfile QtCore
-    \ingroup thread
-*/
-
-/*!
-    \namespace QtConcurrent::internal
-    \internal
-
-    \brief The QtConcurrent::internal namespace contains QtConcurrent
-    implementation details.
-*/
-
-/*!
-    \enum QtConcurrent::ReduceOption
-    This enum specifies the order of which results from the map or filter 
-    function are passed to the reduce function.
-
-    \value UnorderedReduce Reduction is done in an arbitrary order.
-    \value OrderedReduce Reduction is done in the order of the
-    original sequence.
-    \value SequentialReduce Reduction is done sequentially: only one
-    thread will enter the reduce function at a time. (Parallel reduction
-    might be supported in a future version of Qt Concurrent.)
-*/
-
-/*!
-    \headerfile <QtConcurrentMap>
-    \title Concurrent Map and Map-Reduce
-    \ingroup thread
-
-    \brief The <QtConcurrentMap> header provides concurrent Map and MapReduce.
-
-    These functions are a part of the \l {Concurrent Programming}{Qt Concurrent} framework.
-
-    The QtConcurrent::map(), QtConcurrent::mapped() and
-    QtConcurrent::mappedReduced() functions run computations in parallel on
-    the items in a sequence such as a QList or a QVector. QtConcurrent::map()
-    modifies a sequence in-place, QtConcurrent::mapped() returns a new
-    sequence containing the modified content, and QtConcurrent::mappedReduced()
-    returns a single result.
-
-    Each of the above functions has a blocking variant that returns
-    the final result instead of a QFuture. You use them in the same
-    way as the asynchronous variants.
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 7
-
-    Note that the result types above are not QFuture objects, but real result
-    types (in this case, QList<QImage> and QImage).
-
-    \section1 Concurrent Map
-
-    QtConcurrent::mapped() takes an input sequence and a map function. This map
-    function is then called for each item in the sequence, and a new sequence
-    containing the return values from the map function is returned.
-
-    The map function must be of the form:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 0
-
-    T and U can be any type (and they can even be the same type), but T must
-    match the type stored in the sequence. The function returns the modified
-    or \e mapped content.
-
-    This example shows how to apply a scale function to all the items
-    in a sequence:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 1
-
-    The results of the map are made available through QFuture.  See the
-    QFuture and QFutureWatcher documentation for more information on how to
-    use QFuture in your applications.
-
-    If you want to modify a sequence in-place, use QtConcurrent::map(). The
-    map function must then be of the form:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 2
-
-    Note that the return value and return type of the map function are not
-    used.
-
-    Using QtConcurrent::map() is similar to using QtConcurrent::mapped():
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 3
-
-    Since the sequence is modified in place, QtConcurrent::map() does not
-    return any results via QFuture. However, you can still use QFuture and
-    QFutureWatcher to monitor the status of the map.
-
-    \section1 Concurrent Map-Reduce
-
-    QtConcurrent::mappedReduced() is similar to QtConcurrent::mapped(), but
-    instead of returning a sequence with the new results, the results are
-    combined into a single value using a reduce function.
-
-    The reduce function must be of the form:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 4
-
-    T is the type of the final result, U is the return type of the map
-    function. Note that the return value and return type of the reduce
-    function are not used.
-
-    Call QtConcurrent::mappedReduced() like this:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 5
-
-    The reduce function will be called once for each result returned by the map
-    function, and should merge the \e{intermediate} into the \e{result}
-    variable.  QtConcurrent::mappedReduced() guarantees that only one thread
-    will call reduce at a time, so using a mutex to lock the result variable
-    is not necessary. The QtConcurrent::ReduceOptions enum provides a way to
-    control the order in which the reduction is done. If
-    QtConcurrent::UnorderedReduce is used (the default), the order is
-    undefined, while QtConcurrent::OrderedReduce ensures that the reduction
-    is done in the order of the original sequence.
-
-    \section1 Additional API Features
-
-    \section2 Using Iterators instead of Sequence
-
-    Each of the above functions has a variant that takes an iterator range
-    instead of a sequence. You use them in the same way as the sequence
-    variants:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 6
-
-    \section2 Blocking Variants
-
-    Each of the above functions has a blocking variant that returns
-    the final result instead of a QFuture. You use them in the same
-    way as the asynchronous variants.
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 7
-
-    Note that the result types above are not QFuture objects, but real result
-    types (in this case, QList<QImage> and QImage).
-
-    \section2 Using Member Functions
-
-    QtConcurrent::map(), QtConcurrent::mapped(), and
-    QtConcurrent::mappedReduced() accept pointers to member functions.
-    The member function class type must match the type stored in the sequence:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 8
-
-    Note that when using QtConcurrent::mappedReduced(), you can mix the use of
-    normal and member functions freely:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 9
-
-    \section2 Using Function Objects
-
-    QtConcurrent::map(), QtConcurrent::mapped(), and
-    QtConcurrent::mappedReduced() accept function objects, which can be used to
-    add state to a function call. The result_type typedef must define the 
-    result type of the function call operator:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 14
-
-    \section2 Using Bound Function Arguments
-
-    Note that Qt does not provide support for bound functions. This is
-    provided by 3rd party libraries like
-    \l{http://www.boost.org/libs/bind/bind.html}{Boost} or
-    \l{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf}{C++
-    TR1 Library Extensions}.
-
-    If you want to use a map function that takes more than one argument you can
-    use boost::bind() or std::tr1::bind() to transform it onto a function that
-    takes one argument.
-
-    As an example, we'll use QImage::scaledToWidth():
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 10
-
-    scaledToWidth takes three arguments (including the "this" pointer) and
-    can't be used with QtConcurrent::mapped() directly, because
-    QtConcurrent::mapped() expects a function that takes one argument. To use
-    QImage::scaledToWidth() with QtConcurrent::mapped() we have to provide a
-    value for the \e{width} and the \e{transformation mode}:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 11
-
-    The return value from boost::bind() is a function object (functor) with
-    the following signature:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 12
-
-    This matches what QtConcurrent::mapped() expects, and the complete example
-    becomes:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentmap.cpp 13
-*/
-
-/*!
-    \fn QFuture<void> QtConcurrent::map(Sequence &sequence, MapFunction function)
-    \relates <QtConcurrentMap>
-
-    Calls \a function once for each item in \a sequence. The \a function is
-    passed a reference to the item, so that any modifications done to the item
-    will appear in \a sequence.
-*/
-
-/*!
-    \fn QFuture<void> QtConcurrent::map(Iterator begin, Iterator end, MapFunction function)
-    \relates <QtConcurrentMap>
-
-    Calls \a function once for each item from \a begin to \a end. The
-    \a function is passed a reference to the item, so that any modifications
-    done to the item will appear in the sequence which the iterators belong to.
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::mapped(const Sequence &sequence, MapFunction function)
-    \relates <QtConcurrentMap>
-
-    Calls \a function once for each item in \a sequence and returns a future
-    with each mapped item as a result. You can use QFuture::const_iterator or
-    QFutureIterator to iterate through the results.
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::mapped(ConstIterator begin, ConstIterator end, MapFunction function)
-    \relates <QtConcurrentMap>
-
-    Calls \a function once for each item from \a begin to \a end and returns a
-    future with each mapped item as a result. You can use
-    QFuture::const_iterator or QFutureIterator to iterate through the results.
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::mappedReduced(const Sequence &sequence,
-    MapFunction mapFunction, ReduceFunction reduceFunction,
-    QtConcurrent::ReduceOptions reduceOptions)
-
-    \relates <QtConcurrentMap>
-
-    Calls \a mapFunction once for each item in \a sequence. The return value of
-    each \a mapFunction is passed to \a reduceFunction.
-
-    Note that while \a mapFunction is called concurrently, only one thread at a
-    time will call \a reduceFunction. The order in which \a reduceFunction is
-    called is determined by \a reduceOptions.
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::mappedReduced(ConstIterator begin,
-    ConstIterator end, MapFunction mapFunction, ReduceFunction reduceFunction,
-    QtConcurrent::ReduceOptions reduceOptions)
-
-    \relates <QtConcurrentMap>
-
-    Calls \a mapFunction once for each item from \a begin to \a end. The return
-    value of each \a mapFunction is passed to \a reduceFunction.
-
-    Note that while \a mapFunction is called concurrently, only one thread at a
-    time will call \a reduceFunction. By default, the order in which
-    \a reduceFunction is called is undefined.
-
-    \note QtConcurrent::OrderedReduce results in the ordered reduction.
-*/
-
-/*!
-  \fn void QtConcurrent::blockingMap(Sequence &sequence, MapFunction function)
-
-  Calls \a function once for each item in \a sequence. The \a function is
-  passed a reference to the item, so that any modifications done to the item
-  will appear in \a sequence.
-
-  \note This function will block until all items in the sequence have been processed.
-
-  \sa map()
-*/
-
-/*!
-  \fn void QtConcurrent::blockingMap(Iterator begin, Iterator end, MapFunction function)
-
-  Calls \a function once for each item from \a begin to \a end. The
-  \a function is passed a reference to the item, so that any modifications
-  done to the item will appear in the sequence which the iterators belong to.
-
-  \note This function will block until the iterator reaches the end of the
-  sequence being processed.
-
-  \sa map()
-*/
-
-/*!
-  \fn T QtConcurrent::blockingMapped(const Sequence &sequence, MapFunction function)
-
-  Calls \a function once for each item in \a sequence and returns a Sequence containing
-  the results. The type of the results will match the type returned my the MapFunction.
-
-  \note This function will block until all items in the sequence have been processed.
-
-  \sa mapped()
-*/
-
-/*!
-  \fn T QtConcurrent::blockingMapped(ConstIterator begin, ConstIterator end, MapFunction function)
-
-  Calls \a function once for each item from \a begin to \a end and returns a
-  container with the results. Specify the type of container as the a template
-  argument, like this:
-  
-  \code
-     QList<int> ints = QtConcurrent::blockingMapped<QList<int> >(beginIterator, endIterator, fn);
-  \endcode
-
-  \note This function will block until the iterator reaches the end of the
-  sequence being processed.
-
-  \sa mapped()
-*/
-
-/*!
-  \fn T QtConcurrent::blockingMappedReduced(const Sequence &sequence, MapFunction mapFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
-
-  \relates <QtConcurrentMap>
-
-  Calls \a mapFunction once for each item in \a sequence. The return value of
-  each \a mapFunction is passed to \a reduceFunction.
-
-  Note that while \a mapFunction is called concurrently, only one thread at a
-  time will call \a reduceFunction. The order in which \a reduceFunction is
-  called is determined by \a reduceOptions.
-
-  \note This function will block until all items in the sequence have been processed.
-
-  \sa mapped()
-*/
-
-/*!
-  \fn T QtConcurrent::blockingMappedReduced(ConstIterator begin, ConstIterator end, MapFunction mapFunction, ReduceFunction reduceFunction, QtConcurrent::ReduceOptions reduceOptions)
-
-  \relates <QtConcurrentMap>
-
-  Calls \a mapFunction once for each item from \a begin to \a end. The return
-  value of each \a mapFunction is passed to \a reduceFunction.
-
-  Note that while \a mapFunction is called concurrently, only one thread at a
-  time will call \a reduceFunction. The order in which \a reduceFunction is
-  called is undefined.
-
-  \note This function will block until the iterator reaches the end of the
-  sequence being processed.
-
-  \sa blockingMappedReduced()
-*/
diff --git a/src/corelib/concurrent/qtconcurrentmap.h b/src/corelib/concurrent/qtconcurrentmap.h
deleted file mode 100644
index ef66cc1..0000000
--- a/src/corelib/concurrent/qtconcurrentmap.h
+++ /dev/null
@@ -1,319 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_MAP_H
-#define QTCONCURRENT_MAP_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qtconcurrentmapkernel.h>
-#include <QtCore/qtconcurrentreducekernel.h>
-#include <QtCore/qtconcurrentfunctionwrappers.h>
-#include <QtCore/qstringlist.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifdef qdoc
-
-namespace QtConcurrent {
-
-    QFuture<void> map(Sequence &sequence, MapFunction function);
-    QFuture<void> map(Iterator begin, Iterator end, MapFunction function);
-
-    template <typename T>
-    QFuture<T> mapped(const Sequence &sequence, MapFunction function);
-    template <typename T>
-    QFuture<T> mapped(ConstIterator begin, ConstIterator end, MapFunction function);
-
-    template <typename T>
-    QFuture<T> mappedReduced(const Sequence &sequence,
-                             MapFunction function,
-                             ReduceFunction function,
-                             QtConcurrent::ReduceOptions options = UnorderedReduce | SequentialReduce);
-    template <typename T>
-    QFuture<T> mappedReduced(ConstIterator begin,
-                             ConstIterator end,
-                             MapFunction function,
-                             ReduceFunction function,
-                             QtConcurrent::ReduceOptions options = UnorderedReduce | SequentialReduce);
-
-    void blockingMap(Sequence &sequence, MapFunction function);
-    void blockingMap(Iterator begin, Iterator end, MapFunction function);
-
-    template <typename T>
-    T blockingMapped(const Sequence &sequence, MapFunction function);
-    template <typename T>
-    T blockingMapped(ConstIterator begin, ConstIterator end, MapFunction function);
-
-    template <typename T>
-    T blockingMappedReduced(const Sequence &sequence,
-                            MapFunction function,
-                            ReduceFunction function,
-                            QtConcurrent::ReduceOptions options = UnorderedReduce | SequentialReduce);
-    template <typename T>
-    T blockingMappedReduced(ConstIterator begin,
-                            ConstIterator end,
-                            MapFunction function,
-                            ReduceFunction function,
-                            QtConcurrent::ReduceOptions options = UnorderedReduce | SequentialReduce);
-
-} // namespace QtConcurrent
-
-#else
-
-namespace QtConcurrent {
-
-// map() on sequences
-template <typename Sequence, typename MapFunctor>
-QFuture<void> map(Sequence &sequence, MapFunctor map)
-{
-    return startMap(sequence.begin(), sequence.end(), QtPrivate::createFunctionWrapper(map));
-}
-
-// map() on iterators
-template <typename Iterator, typename MapFunctor>
-QFuture<void> map(Iterator begin, Iterator end, MapFunctor map)
-{
-    return startMap(begin, end, QtPrivate::createFunctionWrapper(map));
-}
-
-// mappedReduced() for sequences.
-template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
-QFuture<ResultType> mappedReduced(const Sequence &sequence,
-                                  MapFunctor map,
-                                  ReduceFunctor reduce,
-                                  ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, ResultType>
-        (sequence,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::createFunctionWrapper(reduce),
-         options);
-}
-
-template <typename Sequence, typename MapFunctor, typename ReduceFunctor>
-QFuture<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType> mappedReduced(const Sequence &sequence,
-                                  MapFunctor map,
-                                  ReduceFunctor reduce,
-                                  ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
-        (sequence,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::createFunctionWrapper(reduce),
-         options);
-}
-
-// mappedReduced() for iterators
-template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
-QFuture<ResultType> mappedReduced(Iterator begin,
-                                  Iterator end,
-                                  MapFunctor map,
-                                  ReduceFunctor reduce,
-                                  ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, ResultType>
-        (begin, end,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::createFunctionWrapper(reduce),
-         options);
-}
-
-template <typename Iterator, typename MapFunctor, typename ReduceFunctor>
-QFuture<typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType> mappedReduced(Iterator begin,
-                                  Iterator end,
-                                  MapFunctor map,
-                                  ReduceFunctor reduce,
-                                  ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
-        (begin, end,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::createFunctionWrapper(reduce),
-         options);
-}
-
-// mapped() for sequences
-template <typename Sequence, typename MapFunctor>
-QFuture<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType> mapped(const Sequence &sequence, MapFunctor map)
-{
-    return startMapped<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType>(sequence, QtPrivate::createFunctionWrapper(map));
-}
-
-// mapped() for iterator ranges.
-template <typename Iterator, typename MapFunctor>
-QFuture<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType> mapped(Iterator begin, Iterator end, MapFunctor map)
-{
-    return startMapped<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType>(begin, end, QtPrivate::createFunctionWrapper(map));
-}
-
-// blockingMap() for sequences
-template <typename Sequence, typename MapFunctor>
-void blockingMap(Sequence &sequence, MapFunctor map)
-{
-    startMap(sequence.begin(), sequence.end(), QtPrivate::createFunctionWrapper(map)).startBlocking();
-}
-
-// blockingMap() for iterator ranges
-template <typename Iterator, typename MapFunctor>
-void blockingMap(Iterator begin, Iterator end, MapFunctor map)
-{
-    startMap(begin, end, QtPrivate::createFunctionWrapper(map)).startBlocking();
-}
-
-// blockingMappedReduced() for sequences
-template <typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
-ResultType blockingMappedReduced(const Sequence &sequence,
-                                 MapFunctor map,
-                                 ReduceFunctor reduce,
-                                 ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return QtConcurrent::startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, ResultType>
-        (sequence,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::createFunctionWrapper(reduce),
-         options)
-        .startBlocking();
-}
-
-template <typename MapFunctor, typename ReduceFunctor, typename Sequence>
-typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType blockingMappedReduced(const Sequence &sequence,
-                                 MapFunctor map,
-                                 ReduceFunctor reduce,
-                                 ReduceOptions options = ReduceOptions(UnorderedReduce | SequentialReduce))
-{
-    return QtConcurrent::startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
-        (sequence,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::createFunctionWrapper(reduce),
-         options)
-        .startBlocking();
-}
-
-// blockingMappedReduced() for iterator ranges
-template <typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
-ResultType blockingMappedReduced(Iterator begin,
-                                 Iterator end,
-                                 MapFunctor map,
-                                 ReduceFunctor reduce,
-                                 QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
-{
-    return QtConcurrent::startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, ResultType>
-        (begin, end,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::createFunctionWrapper(reduce),
-         options)
-        .startBlocking();
-}
-
-template <typename Iterator, typename MapFunctor, typename ReduceFunctor>
-typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType blockingMappedReduced(Iterator begin,
-                                 Iterator end,
-                                 MapFunctor map,
-                                 ReduceFunctor reduce,
-                                 QtConcurrent::ReduceOptions options = QtConcurrent::ReduceOptions(QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce))
-{
-    return QtConcurrent::startMappedReduced<typename QtPrivate::MapResultType<void, MapFunctor>::ResultType, typename QtPrivate::ReduceResultType<ReduceFunctor>::ResultType>
-        (begin, end,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::createFunctionWrapper(reduce),
-         options)
-        .startBlocking();
-}
-
-// mapped() for sequences with a different putput sequence type.
-template <typename OutputSequence, typename InputSequence, typename MapFunctor>
-OutputSequence blockingMapped(const InputSequence &sequence, MapFunctor map)
-{
-    return blockingMappedReduced<OutputSequence>
-        (sequence,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::PushBackWrapper(),
-         QtConcurrent::OrderedReduce);
-}
-
-template <typename MapFunctor, typename InputSequence>
-typename QtPrivate::MapResultType<InputSequence, MapFunctor>::ResultType blockingMapped(const InputSequence &sequence, MapFunctor map)
-{
-    typedef typename QtPrivate::MapResultType<InputSequence, MapFunctor>::ResultType OutputSequence;
-    return blockingMappedReduced<OutputSequence>
-        (sequence,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::PushBackWrapper(),
-         QtConcurrent::OrderedReduce);
-}
-
-// mapped()  for iterator ranges
-template <typename Sequence, typename Iterator, typename MapFunctor>
-Sequence blockingMapped(Iterator begin, Iterator end, MapFunctor map)
-{
-    return blockingMappedReduced<Sequence>
-        (begin, end,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::PushBackWrapper(),
-         QtConcurrent::OrderedReduce);
-}
-
-template <typename Iterator, typename MapFunctor>
-typename QtPrivate::MapResultType<Iterator, MapFunctor>::ResultType blockingMapped(Iterator begin, Iterator end, MapFunctor map)
-{
-    typedef typename QtPrivate::MapResultType<Iterator, MapFunctor>::ResultType OutputSequence;
-    return blockingMappedReduced<OutputSequence>
-        (begin, end,
-         QtPrivate::createFunctionWrapper(map),
-         QtPrivate::PushBackWrapper(),
-         QtConcurrent::OrderedReduce);
-}
-
-} // namespace QtConcurrent
-
-#endif // qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentmapkernel.h b/src/corelib/concurrent/qtconcurrentmapkernel.h
deleted file mode 100644
index 47cf143..0000000
--- a/src/corelib/concurrent/qtconcurrentmapkernel.h
+++ /dev/null
@@ -1,272 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_MAPKERNEL_H
-#define QTCONCURRENT_MAPKERNEL_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qtconcurrentiteratekernel.h>
-#include <QtCore/qtconcurrentreducekernel.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifndef qdoc
-namespace QtConcurrent {
-
-// map kernel, works with both parallel-for and parallel-while
-template <typename Iterator, typename MapFunctor>
-class MapKernel : public IterateKernel<Iterator, void>
-{
-    MapFunctor map;
-public:
-    typedef void ReturnType;
-    MapKernel(Iterator begin, Iterator end, MapFunctor _map)
-        : IterateKernel<Iterator, void>(begin, end), map(_map)
-    { }
-
-    bool runIteration(Iterator it, int, void *)
-    {
-        map(*it);
-        return false;
-    }
-
-    bool runIterations(Iterator sequenceBeginIterator, int beginIndex, int endIndex, void *)
-    {
-        Iterator it = sequenceBeginIterator;
-        advance(it, beginIndex);
-        for (int i = beginIndex; i < endIndex; ++i) {
-            runIteration(it, i, 0);
-            advance(it, 1);
-        }
-       
-        return false;
-    }
-};
-
-template <typename ReducedResultType,
-          typename Iterator,
-          typename MapFunctor,
-          typename ReduceFunctor,
-          typename Reducer = ReduceKernel<ReduceFunctor,
-                                          ReducedResultType,
-                                          typename MapFunctor::result_type> >
-class MappedReducedKernel : public IterateKernel<Iterator, ReducedResultType>
-{
-    ReducedResultType reducedResult;
-    MapFunctor map;
-    ReduceFunctor reduce;
-    Reducer reducer;
-public:
-    typedef ReducedResultType ReturnType;
-    MappedReducedKernel(Iterator begin, Iterator end, MapFunctor _map, ReduceFunctor _reduce, ReduceOptions reduceOptions)
-        : IterateKernel<Iterator, ReducedResultType>(begin, end), reducedResult(), map(_map), reduce(_reduce), reducer(reduceOptions)
-    { }
-
-    MappedReducedKernel(ReducedResultType initialValue,
-                     MapFunctor _map,
-                     ReduceFunctor _reduce)
-        : reducedResult(initialValue), map(_map), reduce(_reduce)
-    { }
-
-    bool runIteration(Iterator it, int index, ReducedResultType *)
-    {
-        IntermediateResults<typename MapFunctor::result_type> results;
-        results.begin = index;
-        results.end = index + 1;
-
-        results.vector.append(map(*it));
-        reducer.runReduce(reduce, reducedResult, results);
-        return false;
-    }
-
-    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, ReducedResultType *)
-    {
-        IntermediateResults<typename MapFunctor::result_type> results;
-        results.begin = begin;
-        results.end = end;
-        results.vector.reserve(end - begin);
-
-        Iterator it = sequenceBeginIterator;
-        advance(it, begin);
-        for (int i = begin; i < end; ++i) {
-            results.vector.append(map(*(it)));
-            advance(it, 1);
-        }
-
-        reducer.runReduce(reduce, reducedResult, results);
-        return false;
-    }
-
-    void finish()
-    {
-        reducer.finish(reduce, reducedResult);
-    }
-
-    bool shouldThrottleThread()
-    {
-        return IterateKernel<Iterator, ReducedResultType>::shouldThrottleThread() || reducer.shouldThrottle();
-    }
-
-    bool shouldStartThread()
-    {
-        return IterateKernel<Iterator, ReducedResultType>::shouldStartThread() && reducer.shouldStartThread();
-    }
-
-    typedef ReducedResultType ResultType;
-    ReducedResultType *result()
-    {
-        return &reducedResult;
-    }
-};
-
-template <typename Iterator, typename MapFunctor>
-class MappedEachKernel : public IterateKernel<Iterator, typename MapFunctor::result_type>
-{
-    MapFunctor map;
-    typedef typename MapFunctor::result_type T;
-public:
-    typedef T ReturnType;
-    typedef T ResultType;
-
-    MappedEachKernel(Iterator begin, Iterator end, MapFunctor _map)
-        : IterateKernel<Iterator, T>(begin, end), map(_map) { }
-
-    bool runIteration(Iterator it, int,  T *result)
-    {
-        *result = map(*it);
-        return true;
-    }
-
-    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, T *results)
-    {
-
-        Iterator it = sequenceBeginIterator;
-        advance(it, begin);
-        for (int i = begin; i < end; ++i) {
-            runIteration(it, i, results + (i - begin));
-            advance(it, 1);
-        }
-
-        return true;
-    }
-};
-
-template <typename Iterator, typename Functor>
-inline ThreadEngineStarter<void> startMap(Iterator begin, Iterator end, Functor functor)
-{
-    return startThreadEngine(new MapKernel<Iterator, Functor>(begin, end, functor));
-}
-
-template <typename T, typename Iterator, typename Functor>
-inline ThreadEngineStarter<T> startMapped(Iterator begin, Iterator end, Functor functor)
-{
-    return startThreadEngine(new MappedEachKernel<Iterator, Functor>(begin, end, functor));
-}
-
-/*
-    The SequnceHolder class is used to hold a reference to the
-    sequence we are working on.
-*/
-template <typename Sequence, typename Base, typename Functor>
-struct SequenceHolder1 : public Base
-{
-    SequenceHolder1(const Sequence &_sequence, Functor functor)
-        : Base(_sequence.begin(), _sequence.end(), functor), sequence(_sequence)
-    { }
-
-    Sequence sequence;
-
-    void finish()
-    {
-        Base::finish();
-        // Clear the sequence to make sure all temporaries are destroyed
-        // before finished is signaled.
-        sequence = Sequence();
-    }
-};
-
-template <typename T, typename Sequence, typename Functor>
-inline ThreadEngineStarter<T> startMapped(const Sequence &sequence, Functor functor)
-{
-    typedef SequenceHolder1<Sequence,
-                            MappedEachKernel<typename Sequence::const_iterator , Functor>, Functor>
-                            SequenceHolderType;
-
-    return startThreadEngine(new SequenceHolderType(sequence, functor));
-}
-
-template <typename IntermediateType, typename ResultType, typename Sequence, typename MapFunctor, typename ReduceFunctor>
-inline ThreadEngineStarter<ResultType> startMappedReduced(const Sequence & sequence,
-                                                           MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
-                                                           ReduceOptions options)
-{
-    typedef typename Sequence::const_iterator Iterator;
-    typedef ReduceKernel<ReduceFunctor, ResultType, IntermediateType> Reducer;
-    typedef MappedReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> MappedReduceType;
-    typedef SequenceHolder2<Sequence, MappedReduceType, MapFunctor, ReduceFunctor> SequenceHolderType;
-    return startThreadEngine(new SequenceHolderType(sequence, mapFunctor, reduceFunctor, options));
-}
-
-template <typename IntermediateType, typename ResultType, typename Iterator, typename MapFunctor, typename ReduceFunctor>
-inline ThreadEngineStarter<ResultType> startMappedReduced(Iterator begin, Iterator end,
-                                                           MapFunctor mapFunctor, ReduceFunctor reduceFunctor,
-                                                           ReduceOptions options)
-{
-    typedef ReduceKernel<ReduceFunctor, ResultType, IntermediateType> Reducer;
-    typedef MappedReducedKernel<ResultType, Iterator, MapFunctor, ReduceFunctor, Reducer> MappedReduceType;
-    return startThreadEngine(new MappedReduceType(begin, end, mapFunctor, reduceFunctor, options));
-}
-
-} // namespace QtConcurrent
-
-#endif //qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentmedian.h b/src/corelib/concurrent/qtconcurrentmedian.h
deleted file mode 100644
index 78fc3d9..0000000
--- a/src/corelib/concurrent/qtconcurrentmedian.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_MEDIAN_H
-#define QTCONCURRENT_MEDIAN_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qvector.h>
-#include <QtCore/qalgorithms.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifndef qdoc
-
-namespace QtConcurrent {
-
-template <typename T>
-class Median
-{
-public:
-    Median(int _bufferSize)
-        : currentMedian(), bufferSize(_bufferSize), currentIndex(0), valid(false), dirty(true)
-    {
-        values.resize(bufferSize);
-    }
-
-    void reset()
-    {
-        values.fill(0);
-        currentIndex = 0;
-        valid = false;
-        dirty = true;
-    }
-
-    void addValue(T value)
-    {
-        currentIndex = ((currentIndex + 1) % bufferSize);
-        if (valid == false && currentIndex % bufferSize == 0)
-            valid = true;
-
-        // Only update the cached median value when we have to, that
-        // is when the new value is on then other side of the median
-        // compared to the current value at the index.
-        const T currentIndexValue = values[currentIndex];
-        if ((currentIndexValue > currentMedian && currentMedian > value)
-            || (currentMedian > currentIndexValue && value > currentMedian)) {
-            dirty = true;
-        }
-
-        values[currentIndex] = value;
-    }
-
-    bool isMedianValid() const
-    {
-        return valid;
-    }
-
-    T median()
-    {
-        if (dirty) {
-            dirty = false;
-            QVector<T> sorted = values;
-            qSort(sorted);
-            currentMedian = sorted.at(bufferSize / 2 + 1);
-        }
-        return currentMedian;
-    }
-private:
-    QVector<T> values;
-    T currentMedian;
-    int bufferSize;
-    int currentIndex;
-    bool valid;
-    bool dirty;
-};
-
-} // namespace QtConcurrent
-
-#endif //qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentreducekernel.h b/src/corelib/concurrent/qtconcurrentreducekernel.h
deleted file mode 100644
index ddf5629..0000000
--- a/src/corelib/concurrent/qtconcurrentreducekernel.h
+++ /dev/null
@@ -1,254 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_REDUCEKERNEL_H
-#define QTCONCURRENT_REDUCEKERNEL_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qatomic.h>
-#include <QtCore/qlist.h>
-#include <QtCore/qmap.h>
-#include <QtCore/qmutex.h>
-#include <QtCore/qthread.h>
-#include <QtCore/qthreadpool.h>
-#include <QtCore/qvector.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-namespace QtConcurrent {
-
-#ifndef qdoc
-
-/*
-    The ReduceQueueStartLimit and ReduceQueueThrottleLimit constants
-    limit the reduce queue size for MapReduce. When the number of
-    reduce blocks in the queue exceeds ReduceQueueStartLimit,
-    MapReduce won't start any new threads, and when it exceeds
-    ReduceQueueThrottleLimit running threads will be stopped.
-*/
-enum {
-    ReduceQueueStartLimit = 20,
-    ReduceQueueThrottleLimit = 30
-};
-
-// IntermediateResults holds a block of intermediate results from a
-// map or filter functor. The begin/end offsets indicates the origin
-// and range of the block.
-template <typename T>
-class IntermediateResults
-{
-public:
-    int begin, end;
-    QVector<T> vector;
-};
-
-#endif // qdoc
-
-enum ReduceOption {
-    UnorderedReduce = 0x1,
-    OrderedReduce = 0x2,
-    SequentialReduce = 0x4
-    // ParallelReduce = 0x8
-};
-Q_DECLARE_FLAGS(ReduceOptions, ReduceOption)
-Q_DECLARE_OPERATORS_FOR_FLAGS(ReduceOptions)
-
-#ifndef qdoc
-
-// supports both ordered and out-of-order reduction
-template <typename ReduceFunctor, typename ReduceResultType, typename T>
-class ReduceKernel
-{
-    typedef QMap<int, IntermediateResults<T> > ResultsMap;
-
-    const ReduceOptions reduceOptions;
-
-    QMutex mutex;
-    int progress, resultsMapSize, threadCount;
-    ResultsMap resultsMap;
-
-    bool canReduce(int begin) const
-    {
-        return (((reduceOptions & UnorderedReduce)
-                 && progress == 0)
-                || ((reduceOptions & OrderedReduce)
-                    && progress == begin));
-    }
-
-    void reduceResult(ReduceFunctor &reduce,
-                      ReduceResultType &r,
-                      const IntermediateResults<T> &result)
-    {
-        for (int i = 0; i < result.vector.size(); ++i) {
-            reduce(r, result.vector.at(i));
-        }
-    }
-
-    void reduceResults(ReduceFunctor &reduce,
-                       ReduceResultType &r,
-                       ResultsMap &map)
-    {
-        typename ResultsMap::iterator it = map.begin();
-        while (it != map.end()) {
-            reduceResult(reduce, r, it.value());
-            ++it;
-        }
-    }
-
-public:
-    ReduceKernel(ReduceOptions _reduceOptions)
-        : reduceOptions(_reduceOptions), progress(0), resultsMapSize(0), 
-          threadCount(QThreadPool::globalInstance()->maxThreadCount())
-    { }
-
-    void runReduce(ReduceFunctor &reduce,
-                   ReduceResultType &r,
-                   const IntermediateResults<T> &result)
-    {
-        QMutexLocker locker(&mutex);
-        if (!canReduce(result.begin)) {
-            ++resultsMapSize;
-            resultsMap.insert(result.begin, result);
-            return;
-        }
-
-        if (reduceOptions & UnorderedReduce) {
-            // UnorderedReduce
-            progress = -1;
-
-            // reduce this result
-            locker.unlock();
-            reduceResult(reduce, r, result);
-            locker.relock();
-
-            // reduce all stored results as well
-            while (!resultsMap.isEmpty()) {
-                ResultsMap resultsMapCopy = resultsMap;
-                resultsMap.clear();
-
-                locker.unlock();
-                reduceResults(reduce, r, resultsMapCopy);
-                locker.relock();
-
-                resultsMapSize -= resultsMapCopy.size();
-            }
-
-            progress = 0;
-        } else {
-            // reduce this result
-            locker.unlock();
-            reduceResult(reduce, r, result);
-            locker.relock();
-
-            // OrderedReduce
-            progress += result.end - result.begin;
-
-            // reduce as many other results as possible
-            typename ResultsMap::iterator it = resultsMap.begin();
-            while (it != resultsMap.end()) {
-                if (it.value().begin != progress)
-                    break;
-
-                locker.unlock();
-                reduceResult(reduce, r, it.value());
-                locker.relock();
-
-                --resultsMapSize;
-                progress += it.value().end - it.value().begin;
-                it = resultsMap.erase(it);
-            }
-        }
-    }
-
-    // final reduction
-    void finish(ReduceFunctor &reduce, ReduceResultType &r)
-    {
-        reduceResults(reduce, r, resultsMap);
-    }
-
-    inline bool shouldThrottle()
-    {
-        return (resultsMapSize > (ReduceQueueThrottleLimit * threadCount));
-    }
-
-    inline bool shouldStartThread()
-    {
-        return (resultsMapSize <= (ReduceQueueStartLimit * threadCount));
-    }
-};
-
-template <typename Sequence, typename Base, typename Functor1, typename Functor2>
-struct SequenceHolder2 : public Base
-{
-    SequenceHolder2(const Sequence &_sequence,
-                    Functor1 functor1,
-                    Functor2 functor2,
-                    ReduceOptions reduceOptions)
-        : Base(_sequence.begin(), _sequence.end(), functor1, functor2, reduceOptions),
-          sequence(_sequence)
-    { }
-
-    Sequence sequence;
-
-    void finish()
-    {
-        Base::finish();
-        // Clear the sequence to make sure all temporaries are destroyed
-        // before finished is signaled.
-        sequence = Sequence();
-    }
-};
-
-#endif //qdoc
-
-} // namespace QtConcurrent
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentresultstore.cpp b/src/corelib/concurrent/qtconcurrentresultstore.cpp
deleted file mode 100644
index 64de864..0000000
--- a/src/corelib/concurrent/qtconcurrentresultstore.cpp
+++ /dev/null
@@ -1,256 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qtconcurrentresultstore.h"
-
-#ifndef QT_NO_QFUTURE
-
-QT_BEGIN_NAMESPACE
-
-namespace QtConcurrent {
-
-ResultIteratorBase::ResultIteratorBase()
- : mapIterator(QMap<int, ResultItem>::const_iterator()), m_vectorIndex(0) { }
-ResultIteratorBase::ResultIteratorBase(QMap<int, ResultItem>::const_iterator _mapIterator, int _vectorIndex)
- : mapIterator(_mapIterator), m_vectorIndex(_vectorIndex) { }
-
-int ResultIteratorBase::vectorIndex() const { return m_vectorIndex; }
-int ResultIteratorBase::resultIndex() const { return mapIterator.key() + m_vectorIndex; }
-
-ResultIteratorBase ResultIteratorBase::operator++()
-{
-    if (canIncrementVectorIndex()) {
-        ++m_vectorIndex;
-    } else {
-        ++mapIterator;
-        m_vectorIndex = 0;
-    }
-    return *this;
-}
-
-int ResultIteratorBase::batchSize() const
-{
-    return mapIterator.value().count();
-}
-
-void ResultIteratorBase::batchedAdvance()
-{
-    ++mapIterator;
-    m_vectorIndex = 0;
-}
-
-bool ResultIteratorBase::operator==(const ResultIteratorBase &other) const
-{
-    return (mapIterator == other.mapIterator && m_vectorIndex == other.m_vectorIndex);
-}
-
-bool ResultIteratorBase::operator!=(const ResultIteratorBase &other) const
-{
-    return !operator==(other);
-}
-
-bool ResultIteratorBase::isVector() const
-{
-    return mapIterator.value().isVector();
-}
-
-bool ResultIteratorBase::canIncrementVectorIndex() const
-{
-    return (m_vectorIndex + 1 < mapIterator.value().m_count);
-}
-
-ResultStoreBase::ResultStoreBase() 
-    : insertIndex(0), resultCount(0), m_filterMode(false), filteredResults(0) { }
-
-void ResultStoreBase::setFilterMode(bool enable)
-{
-    m_filterMode = enable;
-}
-
-bool ResultStoreBase::filterMode() const
-{
-    return m_filterMode;
-}
-
-void ResultStoreBase::syncResultCount()
-{
-    ResultIteratorBase it = resultAt(resultCount);
-    while (it != end()) {
-        resultCount += it.batchSize();
-        it = resultAt(resultCount);
-    }
-}
-
-void ResultStoreBase::insertResultItemIfValid(int index, ResultItem &resultItem)
-{
-    if (resultItem.isValid()) {
-        m_results[index] = resultItem;
-        syncResultCount();
-    } else {
-        filteredResults += resultItem.count();
-    }
-}
-
-int ResultStoreBase::insertResultItem(int index, ResultItem &resultItem)
-{
-    int storeIndex;
-    if (m_filterMode && index != -1 && index > insertIndex) {
-        pendingResults[index] = resultItem;
-        storeIndex = index;
-    } else {
-        storeIndex = updateInsertIndex(index, resultItem.count());
-        insertResultItemIfValid(storeIndex - filteredResults, resultItem);
-    }
-    syncPendingResults();
-    return storeIndex;
-}
-
-void ResultStoreBase::syncPendingResults()
-{
-    // check if we can insert any of the pending results:
-    QMap<int, ResultItem>::iterator it = pendingResults.begin();
-    while (it != pendingResults.end()) {
-        int index = it.key(); 
-        if (index != resultCount + filteredResults)
-            break;
-
-        ResultItem result = it.value();
-        insertResultItemIfValid(index - filteredResults, result);
-        pendingResults.erase(it);
-        it = pendingResults.begin();
-    }
-}
-
-int ResultStoreBase::addResult(int index, const void *result)
-{
-    ResultItem resultItem(result, 0); // 0 means "not a vector"
-    return insertResultItem(index, resultItem);
-}
-
-int ResultStoreBase::addResults(int index, const void *results, int vectorSize, int totalCount) 
-{
-    if (m_filterMode == false || vectorSize == totalCount) {
-        ResultItem resultItem(results, vectorSize);
-        return insertResultItem(index, resultItem);
-    } else {
-        if (vectorSize > 0) {
-            ResultItem filteredIn(results, vectorSize);
-            insertResultItem(index, filteredIn);
-        }
-        ResultItem filteredAway(0, totalCount - vectorSize);
-        return insertResultItem(index + vectorSize, filteredAway);
-    }
-}
-
-ResultIteratorBase ResultStoreBase::begin() const
-{
-    return ResultIteratorBase(m_results.begin());
-}
-
-ResultIteratorBase ResultStoreBase::end() const
-{
-    return ResultIteratorBase(m_results.end());
-}
-
-bool ResultStoreBase::hasNextResult() const
-{
-    return begin() != end();
-}
-
-ResultIteratorBase ResultStoreBase::resultAt(int index) const
-{
-    if (m_results.isEmpty())
-        return ResultIteratorBase(m_results.end());
-    QMap<int, ResultItem>::const_iterator it = m_results.lowerBound(index);
-
-    // lowerBound returns either an iterator to the result or an iterator
-    // to the nearest greater index. If the latter happens it might be
-    // that the result is stored in a vector at the previous index.
-    if (it == m_results.end()) {
-        --it;
-        if (it.value().isVector() == false) {
-            return ResultIteratorBase(m_results.end());
-        }
-    } else {
-        if (it.key() > index) {
-            if (it == m_results.begin())
-                return ResultIteratorBase(m_results.end());
-            --it;
-        }
-    }
-
-    const int vectorIndex = index - it.key();
-    
-    if (vectorIndex >= it.value().count())
-        return ResultIteratorBase(m_results.end());
-    else if (it.value().isVector() == false && vectorIndex != 0)
-        return ResultIteratorBase(m_results.end());
-    return ResultIteratorBase(it, vectorIndex);
-}
-
-bool ResultStoreBase::contains(int index) const
-{
-    return (resultAt(index) != end());
-}
-
-int ResultStoreBase::count() const
-{
-    return resultCount;
-}
-
-// returns the insert index, calling this function with
-// index equal to -1 returns the next available index.
-int ResultStoreBase::updateInsertIndex(int index, int _count)
-{
-    if (index == -1) {
-        index = insertIndex;
-        insertIndex += _count;
-    } else {
-        insertIndex = qMax(index + _count, insertIndex);
-    }
-    return index;
-}
-
-} // namespace QtConcurrent
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_CONCURRENT
diff --git a/src/corelib/concurrent/qtconcurrentresultstore.h b/src/corelib/concurrent/qtconcurrentresultstore.h
deleted file mode 100644
index d39a45b..0000000
--- a/src/corelib/concurrent/qtconcurrentresultstore.h
+++ /dev/null
@@ -1,238 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_RESULTSTORE_H
-#define QTCONCURRENT_RESULTSTORE_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_QFUTURE
-
-#include <QtCore/qmap.h>
-#include <QtCore/qdebug.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-/*
-    ResultStore stores indexed results. Results can be added and retrieved
-    either individually batched in a QVector. Retriveing results and checking
-    which indexes are in the store can be done either by iterating or by random
-    accees. In addition results kan be removed from the front of the store,
-    either individually or in batches.
-*/
-
-#ifndef qdoc
-
-namespace QtConcurrent {
-
-class ResultItem
-{
-public:
-    ResultItem(const void *_result, int _count) : m_count(_count), result(_result) { } // contruct with vector of results
-    ResultItem(const void *_result) : m_count(0), result(_result) { } // construct with result
-    ResultItem() : m_count(0), result(0) { }
-    bool isValid() const { return result != 0; }
-    bool isVector() const { return m_count != 0; }
-    int count() const { return (m_count == 0) ?  1 : m_count; }
-    int m_count;          // result is either a pointer to a result or to a vector of results,
-    const void *result; // if count is 0 it's a result, otherwise it's a vector.
-};
-
-class Q_CORE_EXPORT ResultIteratorBase
-{
-public:
-    ResultIteratorBase();
-    ResultIteratorBase(QMap<int, ResultItem>::const_iterator _mapIterator, int _vectorIndex = 0);
-    int vectorIndex() const;
-    int resultIndex() const;
-
-    ResultIteratorBase operator++();
-    int batchSize() const;
-    void batchedAdvance();
-    bool operator==(const ResultIteratorBase &other) const;
-    bool operator!=(const ResultIteratorBase &other) const;
-    bool isVector() const;
-    bool canIncrementVectorIndex() const;
-protected:
-    QMap<int, ResultItem>::const_iterator mapIterator;
-    int m_vectorIndex;
-};
-
-template <typename T>
-class  ResultIterator : public ResultIteratorBase
-{
-public:
-    ResultIterator(const ResultIteratorBase &base)
-    : ResultIteratorBase(base) { }
-
-    const T &value() const
-    {
-        return *pointer();
-    }
-
-    const T *pointer() const
-    {
-        if (mapIterator.value().isVector())
-            return &(reinterpret_cast<const QVector<T> *>(mapIterator.value().result)->at(m_vectorIndex));
-        else
-            return reinterpret_cast<const T *>(mapIterator.value().result);
-    }
-};
-
-class Q_CORE_EXPORT ResultStoreBase
-{
-public:
-    ResultStoreBase();
-    void setFilterMode(bool enable);
-    bool filterMode() const;
-    int addResult(int index, const void *result);
-    int addResults(int index, const void *results, int vectorSize, int logicalCount);
-    ResultIteratorBase begin() const;
-    ResultIteratorBase end() const;
-    bool hasNextResult() const;
-    ResultIteratorBase resultAt(int index) const;
-    bool contains(int index) const;
-    int count() const;
-    virtual ~ResultStoreBase() { }
-
-protected:
-    int insertResultItem(int index, ResultItem &resultItem);
-    void insertResultItemIfValid(int index, ResultItem &resultItem);
-    void syncPendingResults();
-    void syncResultCount();
-    int updateInsertIndex(int index, int _count);
-
-    QMap<int, ResultItem> m_results;
-    int insertIndex;     // The index where the next results(s) will be inserted.
-    int resultCount;     // The number of consecutive results stored, starting at index 0.
-
-    bool m_filterMode;
-    QMap<int, ResultItem> pendingResults;
-    int filteredResults;
-    
-};
-
-template <typename T>
-class ResultStore : public ResultStoreBase
-{
-public:
-    ResultStore() { }
-
-    ResultStore(const ResultStoreBase &base)
-    : ResultStoreBase(base) { }
-
-    int addResult(int index, const T  *result)
-    {
-        if (result == 0)
-            return ResultStoreBase::addResult(index, result);
-        else
-            return ResultStoreBase::addResult(index, new T(*result));
-    }
-
-    int addResults(int index, const QVector<T> *results)
-    {
-        return ResultStoreBase::addResults(index, new QVector<T>(*results), results->count(), results->count());
-    }
-
-    int addResults(int index, const QVector<T> *results, int totalCount)
-    {
-        return ResultStoreBase::addResults(index, new QVector<T>(*results), results->count(), totalCount);
-    }
-
-    int addCanceledResult(int index)
-    {
-        return addResult(index, 0);
-    }
-
-    int addCanceledResults(int index, int _count)
-    {
-        QVector<T> empty;
-        return addResults(index, &empty, _count);
-    }
-
-    ResultIterator<T> begin() const
-    {
-        return static_cast<ResultIterator<T> >(ResultStoreBase::begin());
-    }
-
-    ResultIterator<T> end() const
-    {
-        return static_cast<ResultIterator<T> >(ResultStoreBase::end());
-    }
-
-    ResultIterator<T> resultAt(int index) const
-    {
-        return static_cast<ResultIterator<T> >(ResultStoreBase::resultAt(index));
-    }
-
-    void clear()
-    {
-        QMap<int, ResultItem>::const_iterator mapIterator = m_results.constBegin();
-        while (mapIterator != m_results.constEnd()) {
-            if (mapIterator.value().isVector())
-                delete reinterpret_cast<const QVector<T> *>(mapIterator.value().result);
-            else
-                delete reinterpret_cast<const T *>(mapIterator.value().result);
-            ++mapIterator;
-        }
-        resultCount = 0;
-        m_results.clear();
-    }
-
-    ~ResultStore()
-    {
-        clear();
-    }
-
-};
-
-} // namespace QtConcurrent
-
-#endif //qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentrun.cpp b/src/corelib/concurrent/qtconcurrentrun.cpp
deleted file mode 100644
index e51626e..0000000
--- a/src/corelib/concurrent/qtconcurrentrun.cpp
+++ /dev/null
@@ -1,152 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-    \headerfile <QtConcurrentRun>
-    \title Asynchronous Run
-
-    \brief The <QtConcurrentRun> header provides a way to run a function in a
-    separate thread.
-
-    \ingroup thread
-    
-    This function is a part of the \l {Concurrent Programming}{Qt Concurrent} framework.
-
-    The QtConcurrent::run() function runs a function in a separate thread.
-    The return value of the function is made available through the QFuture API.
-    
-    \section1 Running a Function in a Separate Thread
-    
-    To run a function in another thread, use QtConcurrent::run():
-    
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 0
-    
-    This will run \e aFunction in a separate thread obtained from the default
-    QThreadPool. You can use the QFuture and QFutureWatcher classes to monitor
-    the status of the function.
-    
-    \section1 Passing Arguments to the Function
-
-    Passing arguments to the function is done by adding them to the
-    QtConcurrent::run() call immediately after the function name. For example:
-    
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 1
-    
-    A copy of each argument is made at the point where QtConcurrent::run() is
-    called, and these values are passed to the thread when it begins executing
-    the function. Changes made to the arguments after calling
-    QtConcurrent::run() are \e not visible to the thread.
-    
-    \section1 Returning Values from the Function
-    
-    Any return value from the function is available via QFuture:
-    
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 2
-    
-    As documented above, passing arguments is done like this:
-    
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 3
-    
-    Note that the QFuture::result() function blocks and waits for the result
-    to become available. Use QFutureWatcher to get notification when the
-    function has finished execution and the result is available.
-    
-    \section1 Additional API Features
-    
-    \section2 Using Member Functions
-    
-    QtConcurrent::run() also accepts pointers to member functions. The first
-    argument must be either a const reference or a pointer to an instance of
-    the class. Passing by const reference is useful when calling const member
-    functions; passing by pointer is useful for calling non-const member
-    functions that modify the instance.
-    
-    For example, calling QByteArray::split() (a const member function) in a
-    separate thread is done like this:
-    
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 4
-    
-    Calling a non-const member function is done like this:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 5
-
-    \section2 Using Bound Function Arguments
-
-    Note that Qt does not provide support for bound functions. This is
-    provided by 3rd party libraries like
-    \l{http://www.boost.org/libs/bind/bind.html}{Boost} or
-    \l{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf}
-    {C++ TR1 Library Extensions}.
-    
-    You can use boost::bind() or std::tr1::bind() to \e bind a number of
-    arguments to a function when called. There are number of reasons for doing
-    this:
-    
-    \list
-    \o To call a function that takes more than 5 arguments.
-    \o To simplify calling a function with constant arguments.
-    \o Changing the order of arguments.
-    \endlist
-    
-    See the documentation for the relevant functions for details on how to use
-    the bind API.
-
-    Calling a bound function is done like this:
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qtconcurrentrun.cpp 6
-*/
-
-/*!
-    \fn QFuture<T> QtConcurrent::run(Function function, ...);
-    \relates <QtConcurrentRun>
-    
-    Runs \a function in a separate thread. The thread is taken from the global
-    QThreadPool. Note that the function may not run immediately; the function
-    will only be run when a thread is available.
-    
-    T is the same type as the return value of \a function. Non-void return
-    values can be accessed via the QFuture::result() function.
-    
-    Note that the QFuture returned by QtConcurrent::run() does not support
-    canceling, pausing, or progress reporting. The QFuture returned can only
-    be used to query for the running/finished status and the return value of
-    the function.
-*/
diff --git a/src/corelib/concurrent/qtconcurrentrun.h b/src/corelib/concurrent/qtconcurrentrun.h
deleted file mode 100644
index fc4bd01..0000000
--- a/src/corelib/concurrent/qtconcurrentrun.h
+++ /dev/null
@@ -1,347 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-// Generated code, do not edit! Use generator at tools/qtconcurrent/generaterun/
-#ifndef QTCONCURRENT_RUN_H
-#define QTCONCURRENT_RUN_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qtconcurrentrunbase.h>
-#include <QtCore/qtconcurrentstoredfunctioncall.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifdef qdoc
-
-namespace QtConcurrent {
-
-    template <typename T>
-    QFuture<T> run(Function function, ...);
-
-} // namespace QtConcurrent
-
-#else
-
-namespace QtConcurrent {
-
-template <typename T>
-QFuture<T> run(T (*functionPointer)())
-{
-    return (new StoredFunctorCall0<T, T (*)()>(functionPointer))->start();
-}
-template <typename T, typename Param1, typename Arg1>
-QFuture<T> run(T (*functionPointer)(Param1), const Arg1 &arg1)
-{
-    return (new StoredFunctorCall1<T, T (*)(Param1), Arg1>(functionPointer, arg1))->start();
-}
-template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2>
-QFuture<T> run(T (*functionPointer)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
-{
-    return (new StoredFunctorCall2<T, T (*)(Param1, Param2), Arg1, Arg2>(functionPointer, arg1, arg2))->start();
-}
-template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
-{
-    return (new StoredFunctorCall3<T, T (*)(Param1, Param2, Param3), Arg1, Arg2, Arg3>(functionPointer, arg1, arg2, arg3))->start();
-}
-template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
-{
-    return (new StoredFunctorCall4<T, T (*)(Param1, Param2, Param3, Param4), Arg1, Arg2, Arg3, Arg4>(functionPointer, arg1, arg2, arg3, arg4))->start();
-}
-template <typename T, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-QFuture<T> run(T (*functionPointer)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
-{
-    return (new StoredFunctorCall5<T, T (*)(Param1, Param2, Param3, Param4, Param5), Arg1, Arg2, Arg3, Arg4, Arg5>(functionPointer, arg1, arg2, arg3, arg4, arg5))->start();
-}
-
-#ifdef Q_COMPILER_DECLTYPE
-
-template <typename Functor>
-auto run(Functor functor) -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor())> >::Type
-{
-    typedef decltype(functor()) result_type;
-    return (new StoredFunctorCall0<result_type, Functor>(functor))->start();
-}
-
-template <typename Functor, typename Arg1>
-auto run(Functor functor, const Arg1 &arg1)
-    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1))> >::Type
-{
-    typedef decltype(functor(arg1)) result_type;
-    return (new StoredFunctorCall1<result_type, Functor, Arg1>(functor, arg1))->start();
-}
-
-template <typename Functor, typename Arg1, typename Arg2>
-auto run(Functor functor, const Arg1 &arg1, const Arg2 &arg2)
-    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1, arg2))> >::Type
-{
-    typedef decltype(functor(arg1, arg2)) result_type;
-    return (new StoredFunctorCall2<result_type, Functor, Arg1, Arg2>(functor, arg1, arg2))->start();
-}
-
-template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
-auto run(Functor functor, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
-    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1, arg2, arg3))> >::Type
-{
-    typedef decltype(functor(arg1, arg2, arg3)) result_type;
-    return (new StoredFunctorCall3<result_type, Functor, Arg1, Arg2, Arg3>(functor, arg1, arg2, arg3))->start();
-}
-
-template <typename Functor, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-auto run(Functor functor, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
-    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1, arg2, arg3, arg4))> >::Type
-{
-    typedef decltype(functor(arg1, arg2, arg3, arg4)) result_type;
-    return (new StoredFunctorCall4<result_type, Functor, Arg1, Arg2, Arg3, Arg4>(functor, arg1, arg2, arg3, arg4))->start();
-}
-
-template <typename Functor, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
-auto run(Functor functor, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
-    -> typename QtPrivate::QEnableIf<!QtPrivate::HasResultType<Functor>::Value, QFuture<decltype(functor(arg1, arg2, arg3, arg4, arg5))> >::Type
-{
-    typedef decltype(functor(arg1, arg2, arg3, arg4, arg5)) result_type;
-    return (new StoredFunctorCall5<result_type, Functor, Arg1, Arg2, Arg3, Arg4, Arg5>(functor, arg1, arg2, arg3, arg4, arg5))->start();
-}
-
-#endif
-
-template <typename FunctionObject>
-QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject)
-{
-    return (new StoredFunctorCall0<QT_TYPENAME FunctionObject::result_type, FunctionObject>(functionObject))->start();
-}
-template <typename FunctionObject, typename Arg1>
-QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1)
-{
-    return (new StoredFunctorCall1<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1>(functionObject, arg1))->start();
-}
-template <typename FunctionObject, typename Arg1, typename Arg2>
-QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2)
-{
-    return (new StoredFunctorCall2<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2>(functionObject, arg1, arg2))->start();
-}
-template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3>
-QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
-{
-    return (new StoredFunctorCall3<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3>(functionObject, arg1, arg2, arg3))->start();
-}
-template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
-{
-    return (new StoredFunctorCall4<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4>(functionObject, arg1, arg2, arg3, arg4))->start();
-}
-template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
-QFuture<typename FunctionObject::result_type> run(FunctionObject functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
-{
-    return (new StoredFunctorCall5<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4, Arg5>(functionObject, arg1, arg2, arg3, arg4, arg5))->start();
-}
-
-template <typename FunctionObject>
-QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject)
-{
-    return (new QT_TYPENAME SelectStoredFunctorPointerCall0<QT_TYPENAME FunctionObject::result_type, FunctionObject>::type(functionObject))->start();
-}
-template <typename FunctionObject, typename Arg1>
-QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1)
-{
-    return (new QT_TYPENAME SelectStoredFunctorPointerCall1<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1>::type(functionObject, arg1))->start();
-}
-template <typename FunctionObject, typename Arg1, typename Arg2>
-QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2)
-{
-    return (new QT_TYPENAME SelectStoredFunctorPointerCall2<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2>::type(functionObject, arg1, arg2))->start();
-}
-template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3>
-QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
-{
-    return (new QT_TYPENAME SelectStoredFunctorPointerCall3<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3>::type(functionObject, arg1, arg2, arg3))->start();
-}
-template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
-{
-    return (new QT_TYPENAME SelectStoredFunctorPointerCall4<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4>::type(functionObject, arg1, arg2, arg3, arg4))->start();
-}
-template <typename FunctionObject, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
-QFuture<typename FunctionObject::result_type> run(FunctionObject *functionObject, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
-{
-    return (new QT_TYPENAME SelectStoredFunctorPointerCall5<QT_TYPENAME FunctionObject::result_type, FunctionObject, Arg1, Arg2, Arg3, Arg4, Arg5>::type(functionObject, arg1, arg2, arg3, arg4, arg5))->start();
-}
-
-template <typename T, typename Class>
-QFuture<T> run(const Class &object, T (Class::*fn)())
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionCall0<T, Class>::type(fn, object))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1), const Arg1 &arg1)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
-}
-
-template <typename T, typename Class>
-QFuture<T> run(const Class &object, T (Class::*fn)() const)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall0<T, Class>::type(fn, object))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1) const, const Arg1 &arg1)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2) const, const Arg1 &arg1, const Arg2 &arg2)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-QFuture<T> run(const Class &object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
-}
-
-template <typename T, typename Class>
-QFuture<T> run(Class *object, T (Class::*fn)())
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall0<T, Class>::type(fn, object))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1>
-QFuture<T> run(Class *object, T (Class::*fn)(Param1), const Arg1 &arg1)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-QFuture<T> run(Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
-{
-    return (new QT_TYPENAME SelectStoredMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
-}
-
-template <typename T, typename Class>
-QFuture<T> run(const Class *object, T (Class::*fn)() const)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall0<T, Class>::type(fn, object))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1>
-QFuture<T> run(const Class *object, T (Class::*fn)(Param1) const, const Arg1 &arg1)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall1<T, Class, Param1, Arg1>::type(fn, object, arg1))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2) const, const Arg1 &arg1, const Arg2 &arg2)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2>::type(fn, object, arg1, arg2))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>::type(fn, object, arg1, arg2, arg3))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>::type(fn, object, arg1, arg2, arg3, arg4))->start();
-}
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-QFuture<T> run(const Class *object, T (Class::*fn)(Param1, Param2, Param3, Param4, Param5) const, const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg5 &arg5)
-{
-    return (new QT_TYPENAME SelectStoredConstMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>::type(fn, object, arg1, arg2, arg3, arg4, arg5))->start();
-}
-
-} //namespace QtConcurrent
-
-#endif // qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentrunbase.h b/src/corelib/concurrent/qtconcurrentrunbase.h
deleted file mode 100644
index 99ca0a9..0000000
--- a/src/corelib/concurrent/qtconcurrentrunbase.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_RUNBASE_H
-#define QTCONCURRENT_RUNBASE_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qfuture.h>
-#include <QtCore/qrunnable.h>
-#include <QtCore/qthreadpool.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifndef qdoc
-
-namespace QtConcurrent {
-
-template <typename T>
-struct SelectSpecialization
-{
-    template <class Normal, class Void>
-    struct Type { typedef Normal type; };
-};
-
-template <>
-struct SelectSpecialization<void>
-{
-    template <class Normal, class Void>
-    struct Type { typedef Void type; };
-};
-
-template <typename T>
-class RunFunctionTaskBase : public QFutureInterface<T> , public QRunnable
-{
-public:
-    QFuture<T> start()
-    {
-        this->setRunnable(this);
-        this->reportStarted();
-        QFuture<T> theFuture = this->future();
-        QThreadPool::globalInstance()->start(this, /*m_priority*/ 0);
-        return theFuture;
-    }
-
-    void run() {}
-    virtual void runFunctor() = 0;
-};
-
-template <typename T>
-class RunFunctionTask : public RunFunctionTaskBase<T>
-{
-public:
-    void run()
-    {
-        if (this->isCanceled()) {
-            this->reportFinished();
-            return;
-        }
-#ifndef QT_NO_EXCEPTIONS
-        try {
-#endif
-            this->runFunctor();
-#ifndef QT_NO_EXCEPTIONS
-        } catch (QtConcurrent::Exception &e) {
-            QFutureInterface<T>::reportException(e);
-        } catch (...) {
-            QFutureInterface<T>::reportException(QtConcurrent::UnhandledException());
-        }
-#endif
-
-        this->reportResult(result);
-        this->reportFinished();
-    }
-    T result;
-};
-
-template <>
-class RunFunctionTask<void> : public RunFunctionTaskBase<void>
-{
-public:
-    void run()
-    {
-        if (this->isCanceled()) {
-            this->reportFinished();
-            return;
-        }
-#ifndef QT_NO_EXCEPTIONS
-        try {
-#endif
-            this->runFunctor();
-#ifndef QT_NO_EXCEPTIONS
-        } catch (QtConcurrent::Exception &e) {
-            QFutureInterface<void>::reportException(e);
-        } catch (...) {
-            QFutureInterface<void>::reportException(QtConcurrent::UnhandledException());
-        }
-#endif
-        this->reportFinished();
-    }
-};
-
-} //namespace QtConcurrent
-
-#endif //qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentstoredfunctioncall.h b/src/corelib/concurrent/qtconcurrentstoredfunctioncall.h
deleted file mode 100644
index cf426a4..0000000
--- a/src/corelib/concurrent/qtconcurrentstoredfunctioncall.h
+++ /dev/null
@@ -1,1312 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-// Generated code, do not edit! Use generator at tools/qtconcurrent/generaterun/
-#ifndef QTCONCURRENT_STOREDFUNCTIONCALL_H
-#define QTCONCURRENT_STOREDFUNCTIONCALL_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-#include <QtCore/qtconcurrentrunbase.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifndef qdoc
-
-namespace QtConcurrent {
-template <typename T, typename FunctionPointer>
-struct StoredFunctorCall0: public RunFunctionTask<T>
-{
-    inline StoredFunctorCall0(FunctionPointer _function)
-      : function(_function) {}
-    void runFunctor() { this->result = function(); }
-    FunctionPointer function;
-
-};
-
-template <typename FunctionPointer>
-struct StoredFunctorCall0<void, FunctionPointer>: public RunFunctionTask<void>
-{
-    inline StoredFunctorCall0(FunctionPointer _function)
-      : function(_function) {}
-    void runFunctor() { function(); }
-    FunctionPointer function;
-
-};
-
-template <typename T, typename FunctionPointer>
-struct StoredFunctorPointerCall0: public RunFunctionTask<T>
-{
-    inline StoredFunctorPointerCall0(FunctionPointer * _function)
-      : function(_function) {}
-    void runFunctor() { this->result =(*function)(); }
-    FunctionPointer * function;
-
-};
-
-template <typename T, typename FunctionPointer>
-struct VoidStoredFunctorPointerCall0: public RunFunctionTask<T>
-{
-    inline VoidStoredFunctorPointerCall0(FunctionPointer * _function)
-      : function(_function) {}
-    void runFunctor() {(*function)(); }
-    FunctionPointer * function;
-
-};
-
-template <typename T, typename FunctionPointer>
-struct SelectStoredFunctorPointerCall0
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredFunctorPointerCall0    <T, FunctionPointer>,
-             VoidStoredFunctorPointerCall0<T, FunctionPointer> >::type type;
-};
-template <typename T, typename Class>
-class StoredMemberFunctionCall0 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionCall0(T (Class::*_fn)() , const Class &_object)
-    : fn(_fn), object(_object){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)();
-    }
-private:
-    T (Class::*fn)();
-    Class object;
-
-};
-template <typename T, typename Class>
-class VoidStoredMemberFunctionCall0 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionCall0(T (Class::*_fn)() , const Class &_object)
-    : fn(_fn), object(_object){ }
-
-    void runFunctor()
-    {
-        (object.*fn)();
-    }
-private:
-    T (Class::*fn)();
-    Class object;
-
-};
-template <typename T, typename Class>
-struct SelectStoredMemberFunctionCall0
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionCall0    <T, Class>,
-             VoidStoredMemberFunctionCall0<T, Class> >::type type;
-};
-template <typename T, typename Class>
-class StoredConstMemberFunctionCall0 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionCall0(T (Class::*_fn)() const, const Class &_object)
-    : fn(_fn), object(_object){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)();
-    }
-private:
-    T (Class::*fn)()const;
-    const Class object;
-
-};
-template <typename T, typename Class>
-class VoidStoredConstMemberFunctionCall0 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionCall0(T (Class::*_fn)() const, const Class &_object)
-    : fn(_fn), object(_object){ }
-
-    void runFunctor()
-    {
-        (object.*fn)();
-    }
-private:
-    T (Class::*fn)()const;
-    const Class object;
-
-};
-template <typename T, typename Class>
-struct SelectStoredConstMemberFunctionCall0
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionCall0    <T, Class>,
-             VoidStoredConstMemberFunctionCall0<T, Class> >::type type;
-};
-template <typename T, typename Class>
-class StoredMemberFunctionPointerCall0 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionPointerCall0(T (Class::*_fn)() , Class *_object)
-    : fn(_fn), object(_object){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)();
-    }
-private:
-    T (Class::*fn)();
-    Class *object;
-
-};
-template <typename T, typename Class>
-class VoidStoredMemberFunctionPointerCall0 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionPointerCall0(T (Class::*_fn)() , Class *_object)
-    : fn(_fn), object(_object){ }
-
-    void runFunctor()
-    {
-        (object->*fn)();
-    }
-private:
-    T (Class::*fn)();
-    Class *object;
-
-};
-template <typename T, typename Class>
-struct SelectStoredMemberFunctionPointerCall0
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionPointerCall0    <T, Class>,
-             VoidStoredMemberFunctionPointerCall0<T, Class> >::type type;
-};
-template <typename T, typename Class>
-class StoredConstMemberFunctionPointerCall0 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionPointerCall0(T (Class::*_fn)() const, Class const *_object)
-    : fn(_fn), object(_object){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)();
-    }
-private:
-    T (Class::*fn)()const;
-    Class const *object;
-
-};
-template <typename T, typename Class>
-class VoidStoredConstMemberFunctionPointerCall0 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionPointerCall0(T (Class::*_fn)() const, Class const *_object)
-    : fn(_fn), object(_object){ }
-
-    void runFunctor()
-    {
-        (object->*fn)();
-    }
-private:
-    T (Class::*fn)()const;
-    Class const *object;
-
-};
-template <typename T, typename Class>
-struct SelectStoredConstMemberFunctionPointerCall0
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionPointerCall0    <T, Class>,
-             VoidStoredConstMemberFunctionPointerCall0<T, Class> >::type type;
-};
-template <typename T, typename FunctionPointer, typename Arg1>
-struct StoredFunctorCall1: public RunFunctionTask<T>
-{
-    inline StoredFunctorCall1(FunctionPointer _function, const Arg1 &_arg1)
-      : function(_function), arg1(_arg1) {}
-    void runFunctor() { this->result = function(arg1); }
-    FunctionPointer function;
-    Arg1 arg1;
-};
-
-template <typename FunctionPointer, typename Arg1>
-struct StoredFunctorCall1<void, FunctionPointer, Arg1>: public RunFunctionTask<void>
-{
-    inline StoredFunctorCall1(FunctionPointer _function, const Arg1 &_arg1)
-      : function(_function), arg1(_arg1) {}
-    void runFunctor() { function(arg1); }
-    FunctionPointer function;
-    Arg1 arg1;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1>
-struct StoredFunctorPointerCall1: public RunFunctionTask<T>
-{
-    inline StoredFunctorPointerCall1(FunctionPointer * _function, const Arg1 &_arg1)
-      : function(_function), arg1(_arg1) {}
-    void runFunctor() { this->result =(*function)(arg1); }
-    FunctionPointer * function;
-    Arg1 arg1;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1>
-struct VoidStoredFunctorPointerCall1: public RunFunctionTask<T>
-{
-    inline VoidStoredFunctorPointerCall1(FunctionPointer * _function, const Arg1 &_arg1)
-      : function(_function), arg1(_arg1) {}
-    void runFunctor() {(*function)(arg1); }
-    FunctionPointer * function;
-    Arg1 arg1;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1>
-struct SelectStoredFunctorPointerCall1
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredFunctorPointerCall1    <T, FunctionPointer, Arg1>,
-             VoidStoredFunctorPointerCall1<T, FunctionPointer, Arg1> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-class StoredMemberFunctionCall1 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionCall1(T (Class::*_fn)(Param1) , const Class &_object, const Arg1 &_arg1)
-    : fn(_fn), object(_object), arg1(_arg1){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1);
-    }
-private:
-    T (Class::*fn)(Param1);
-    Class object;
-    Arg1 arg1;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-class VoidStoredMemberFunctionCall1 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionCall1(T (Class::*_fn)(Param1) , const Class &_object, const Arg1 &_arg1)
-    : fn(_fn), object(_object), arg1(_arg1){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1);
-    }
-private:
-    T (Class::*fn)(Param1);
-    Class object;
-    Arg1 arg1;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-struct SelectStoredMemberFunctionCall1
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionCall1    <T, Class, Param1, Arg1>,
-             VoidStoredMemberFunctionCall1<T, Class, Param1, Arg1> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-class StoredConstMemberFunctionCall1 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionCall1(T (Class::*_fn)(Param1) const, const Class &_object, const Arg1 &_arg1)
-    : fn(_fn), object(_object), arg1(_arg1){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1);
-    }
-private:
-    T (Class::*fn)(Param1)const;
-    const Class object;
-    Arg1 arg1;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-class VoidStoredConstMemberFunctionCall1 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionCall1(T (Class::*_fn)(Param1) const, const Class &_object, const Arg1 &_arg1)
-    : fn(_fn), object(_object), arg1(_arg1){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1);
-    }
-private:
-    T (Class::*fn)(Param1)const;
-    const Class object;
-    Arg1 arg1;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-struct SelectStoredConstMemberFunctionCall1
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionCall1    <T, Class, Param1, Arg1>,
-             VoidStoredConstMemberFunctionCall1<T, Class, Param1, Arg1> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-class StoredMemberFunctionPointerCall1 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionPointerCall1(T (Class::*_fn)(Param1) , Class *_object, const Arg1 &_arg1)
-    : fn(_fn), object(_object), arg1(_arg1){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1);
-    }
-private:
-    T (Class::*fn)(Param1);
-    Class *object;
-    Arg1 arg1;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-class VoidStoredMemberFunctionPointerCall1 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionPointerCall1(T (Class::*_fn)(Param1) , Class *_object, const Arg1 &_arg1)
-    : fn(_fn), object(_object), arg1(_arg1){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1);
-    }
-private:
-    T (Class::*fn)(Param1);
-    Class *object;
-    Arg1 arg1;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-struct SelectStoredMemberFunctionPointerCall1
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionPointerCall1    <T, Class, Param1, Arg1>,
-             VoidStoredMemberFunctionPointerCall1<T, Class, Param1, Arg1> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-class StoredConstMemberFunctionPointerCall1 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionPointerCall1(T (Class::*_fn)(Param1) const, Class const *_object, const Arg1 &_arg1)
-    : fn(_fn), object(_object), arg1(_arg1){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1);
-    }
-private:
-    T (Class::*fn)(Param1)const;
-    Class const *object;
-    Arg1 arg1;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-class VoidStoredConstMemberFunctionPointerCall1 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionPointerCall1(T (Class::*_fn)(Param1) const, Class const *_object, const Arg1 &_arg1)
-    : fn(_fn), object(_object), arg1(_arg1){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1);
-    }
-private:
-    T (Class::*fn)(Param1)const;
-    Class const *object;
-    Arg1 arg1;
-};
-template <typename T, typename Class, typename Param1, typename Arg1>
-struct SelectStoredConstMemberFunctionPointerCall1
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionPointerCall1    <T, Class, Param1, Arg1>,
-             VoidStoredConstMemberFunctionPointerCall1<T, Class, Param1, Arg1> >::type type;
-};
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
-struct StoredFunctorCall2: public RunFunctionTask<T>
-{
-    inline StoredFunctorCall2(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2)
-      : function(_function), arg1(_arg1), arg2(_arg2) {}
-    void runFunctor() { this->result = function(arg1, arg2); }
-    FunctionPointer function;
-    Arg1 arg1; Arg2 arg2;
-};
-
-template <typename FunctionPointer, typename Arg1, typename Arg2>
-struct StoredFunctorCall2<void, FunctionPointer, Arg1, Arg2>: public RunFunctionTask<void>
-{
-    inline StoredFunctorCall2(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2)
-      : function(_function), arg1(_arg1), arg2(_arg2) {}
-    void runFunctor() { function(arg1, arg2); }
-    FunctionPointer function;
-    Arg1 arg1; Arg2 arg2;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
-struct StoredFunctorPointerCall2: public RunFunctionTask<T>
-{
-    inline StoredFunctorPointerCall2(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2)
-      : function(_function), arg1(_arg1), arg2(_arg2) {}
-    void runFunctor() { this->result =(*function)(arg1, arg2); }
-    FunctionPointer * function;
-    Arg1 arg1; Arg2 arg2;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
-struct VoidStoredFunctorPointerCall2: public RunFunctionTask<T>
-{
-    inline VoidStoredFunctorPointerCall2(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2)
-    : function(_function), arg1(_arg1), arg2(_arg2) {}
-    void runFunctor() {(*function)(arg1, arg2); }
-    FunctionPointer * function;
-    Arg1 arg1; Arg2 arg2;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2>
-struct SelectStoredFunctorPointerCall2
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredFunctorPointerCall2    <T, FunctionPointer, Arg1, Arg2>,
-             VoidStoredFunctorPointerCall2<T, FunctionPointer, Arg1, Arg2> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-class StoredMemberFunctionCall2 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1, arg2);
-    }
-private:
-    T (Class::*fn)(Param1, Param2);
-    Class object;
-    Arg1 arg1; Arg2 arg2;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-class VoidStoredMemberFunctionCall2 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1, arg2);
-    }
-private:
-    T (Class::*fn)(Param1, Param2);
-    Class object;
-    Arg1 arg1; Arg2 arg2;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-struct SelectStoredMemberFunctionCall2
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionCall2    <T, Class, Param1, Arg1, Param2, Arg2>,
-             VoidStoredMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-class StoredConstMemberFunctionCall2 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1, arg2);
-    }
-private:
-    T (Class::*fn)(Param1, Param2)const;
-    const Class object;
-    Arg1 arg1; Arg2 arg2;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-class VoidStoredConstMemberFunctionCall2 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionCall2(T (Class::*_fn)(Param1, Param2) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1, arg2);
-    }
-private:
-    T (Class::*fn)(Param1, Param2)const;
-    const Class object;
-    Arg1 arg1; Arg2 arg2;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-struct SelectStoredConstMemberFunctionCall2
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionCall2    <T, Class, Param1, Arg1, Param2, Arg2>,
-             VoidStoredConstMemberFunctionCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-class StoredMemberFunctionPointerCall2 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1, arg2);
-    }
-private:
-    T (Class::*fn)(Param1, Param2);
-    Class *object;
-    Arg1 arg1; Arg2 arg2;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-class VoidStoredMemberFunctionPointerCall2 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1, arg2);
-    }
-private:
-    T (Class::*fn)(Param1, Param2);
-    Class *object;
-    Arg1 arg1; Arg2 arg2;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-struct SelectStoredMemberFunctionPointerCall2
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionPointerCall2    <T, Class, Param1, Arg1, Param2, Arg2>,
-             VoidStoredMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-class StoredConstMemberFunctionPointerCall2 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1, arg2);
-    }
-private:
-    T (Class::*fn)(Param1, Param2)const;
-    Class const *object;
-    Arg1 arg1; Arg2 arg2;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-class VoidStoredConstMemberFunctionPointerCall2 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionPointerCall2(T (Class::*_fn)(Param1, Param2) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1, arg2);
-    }
-private:
-    T (Class::*fn)(Param1, Param2)const;
-    Class const *object;
-    Arg1 arg1; Arg2 arg2;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
-struct SelectStoredConstMemberFunctionPointerCall2
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionPointerCall2    <T, Class, Param1, Arg1, Param2, Arg2>,
-             VoidStoredConstMemberFunctionPointerCall2<T, Class, Param1, Arg1, Param2, Arg2> >::type type;
-};
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
-struct StoredFunctorCall3: public RunFunctionTask<T>
-{
-    inline StoredFunctorCall3(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
-    void runFunctor() { this->result = function(arg1, arg2, arg3); }
-    FunctionPointer function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-
-template <typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
-struct StoredFunctorCall3<void, FunctionPointer, Arg1, Arg2, Arg3>: public RunFunctionTask<void>
-{
-    inline StoredFunctorCall3(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
-    void runFunctor() { function(arg1, arg2, arg3); }
-    FunctionPointer function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
-struct StoredFunctorPointerCall3: public RunFunctionTask<T>
-{
-    inline StoredFunctorPointerCall3(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
-    void runFunctor() { this->result =(*function)(arg1, arg2, arg3); }
-    FunctionPointer * function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
-struct VoidStoredFunctorPointerCall3: public RunFunctionTask<T>
-{
-    inline VoidStoredFunctorPointerCall3(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3) {}
-    void runFunctor() {(*function)(arg1, arg2, arg3); }
-    FunctionPointer * function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3>
-struct SelectStoredFunctorPointerCall3
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredFunctorPointerCall3    <T, FunctionPointer, Arg1, Arg2, Arg3>,
-             VoidStoredFunctorPointerCall3<T, FunctionPointer, Arg1, Arg2, Arg3> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-class StoredMemberFunctionCall3 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1, arg2, arg3);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3);
-    Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-class VoidStoredMemberFunctionCall3 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1, arg2, arg3);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3);
-    Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-struct SelectStoredMemberFunctionCall3
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionCall3    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
-             VoidStoredMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-class StoredConstMemberFunctionCall3 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1, arg2, arg3);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3)const;
-    const Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-class VoidStoredConstMemberFunctionCall3 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionCall3(T (Class::*_fn)(Param1, Param2, Param3) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1, arg2, arg3);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3)const;
-    const Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-struct SelectStoredConstMemberFunctionCall3
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionCall3    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
-             VoidStoredConstMemberFunctionCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-class StoredMemberFunctionPointerCall3 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1, arg2, arg3);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3);
-    Class *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-class VoidStoredMemberFunctionPointerCall3 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1, arg2, arg3);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3);
-    Class *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-struct SelectStoredMemberFunctionPointerCall3
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionPointerCall3    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
-             VoidStoredMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-class StoredConstMemberFunctionPointerCall3 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1, arg2, arg3);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3)const;
-    Class const *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-class VoidStoredConstMemberFunctionPointerCall3 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionPointerCall3(T (Class::*_fn)(Param1, Param2, Param3) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1, arg2, arg3);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3)const;
-    Class const *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
-struct SelectStoredConstMemberFunctionPointerCall3
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionPointerCall3    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>,
-             VoidStoredConstMemberFunctionPointerCall3<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3> >::type type;
-};
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-struct StoredFunctorCall4: public RunFunctionTask<T>
-{
-    inline StoredFunctorCall4(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
-    void runFunctor() { this->result = function(arg1, arg2, arg3, arg4); }
-    FunctionPointer function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-
-template <typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-struct StoredFunctorCall4<void, FunctionPointer, Arg1, Arg2, Arg3, Arg4>: public RunFunctionTask<void>
-{
-    inline StoredFunctorCall4(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
-    void runFunctor() { function(arg1, arg2, arg3, arg4); }
-    FunctionPointer function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-struct StoredFunctorPointerCall4: public RunFunctionTask<T>
-{
-    inline StoredFunctorPointerCall4(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
-    void runFunctor() { this->result =(*function)(arg1, arg2, arg3, arg4); }
-    FunctionPointer * function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-struct VoidStoredFunctorPointerCall4: public RunFunctionTask<T>
-{
-    inline VoidStoredFunctorPointerCall4(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4) {}
-    void runFunctor() {(*function)(arg1, arg2, arg3, arg4); }
-    FunctionPointer * function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-struct SelectStoredFunctorPointerCall4
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredFunctorPointerCall4    <T, FunctionPointer, Arg1, Arg2, Arg3, Arg4>,
-             VoidStoredFunctorPointerCall4<T, FunctionPointer, Arg1, Arg2, Arg3, Arg4> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-class StoredMemberFunctionCall4 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1, arg2, arg3, arg4);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4);
-    Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-class VoidStoredMemberFunctionCall4 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1, arg2, arg3, arg4);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4);
-    Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-struct SelectStoredMemberFunctionCall4
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionCall4    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
-             VoidStoredMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-class StoredConstMemberFunctionCall4 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1, arg2, arg3, arg4);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4)const;
-    const Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-class VoidStoredConstMemberFunctionCall4 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1, arg2, arg3, arg4);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4)const;
-    const Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-struct SelectStoredConstMemberFunctionCall4
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionCall4    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
-             VoidStoredConstMemberFunctionCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-class StoredMemberFunctionPointerCall4 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1, arg2, arg3, arg4);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4);
-    Class *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-class VoidStoredMemberFunctionPointerCall4 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1, arg2, arg3, arg4);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4);
-    Class *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-struct SelectStoredMemberFunctionPointerCall4
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionPointerCall4    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
-             VoidStoredMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-class StoredConstMemberFunctionPointerCall4 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1, arg2, arg3, arg4);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4)const;
-    Class const *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-class VoidStoredConstMemberFunctionPointerCall4 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionPointerCall4(T (Class::*_fn)(Param1, Param2, Param3, Param4) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1, arg2, arg3, arg4);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4)const;
-    Class const *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
-struct SelectStoredConstMemberFunctionPointerCall4
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionPointerCall4    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>,
-             VoidStoredConstMemberFunctionPointerCall4<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4> >::type type;
-};
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
-struct StoredFunctorCall5: public RunFunctionTask<T>
-{
-    inline StoredFunctorCall5(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
-    void runFunctor() { this->result = function(arg1, arg2, arg3, arg4, arg5); }
-    FunctionPointer function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-
-template <typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
-struct StoredFunctorCall5<void, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5>: public RunFunctionTask<void>
-{
-    inline StoredFunctorCall5(FunctionPointer _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
-    void runFunctor() { function(arg1, arg2, arg3, arg4, arg5); }
-    FunctionPointer function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
-struct StoredFunctorPointerCall5: public RunFunctionTask<T>
-{
-    inline StoredFunctorPointerCall5(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
-    void runFunctor() { this->result =(*function)(arg1, arg2, arg3, arg4, arg5); }
-    FunctionPointer * function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
-struct VoidStoredFunctorPointerCall5: public RunFunctionTask<T>
-{
-    inline VoidStoredFunctorPointerCall5(FunctionPointer * _function, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-      : function(_function), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5) {}
-    void runFunctor() {(*function)(arg1, arg2, arg3, arg4, arg5); }
-    FunctionPointer * function;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-
-template <typename T, typename FunctionPointer, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
-struct SelectStoredFunctorPointerCall5
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredFunctorPointerCall5    <T, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5>,
-             VoidStoredFunctorPointerCall5<T, FunctionPointer, Arg1, Arg2, Arg3, Arg4, Arg5> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-class StoredMemberFunctionCall5 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1, arg2, arg3, arg4, arg5);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
-    Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-class VoidStoredMemberFunctionCall5 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1, arg2, arg3, arg4, arg5);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
-    Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-struct SelectStoredMemberFunctionCall5
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionCall5    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
-             VoidStoredMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-class StoredConstMemberFunctionCall5 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
-
-    void runFunctor()
-    {
-        this->result = (object.*fn)(arg1, arg2, arg3, arg4, arg5);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
-    const Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-class VoidStoredConstMemberFunctionCall5 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, const Class &_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
-
-    void runFunctor()
-    {
-        (object.*fn)(arg1, arg2, arg3, arg4, arg5);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
-    const Class object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-struct SelectStoredConstMemberFunctionCall5
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionCall5    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
-             VoidStoredConstMemberFunctionCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-class StoredMemberFunctionPointerCall5 : public RunFunctionTask<T>
-{
-public:
-    StoredMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1, arg2, arg3, arg4, arg5);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
-    Class *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-class VoidStoredMemberFunctionPointerCall5 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1, arg2, arg3, arg4, arg5);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
-    Class *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-struct SelectStoredMemberFunctionPointerCall5
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredMemberFunctionPointerCall5    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
-             VoidStoredMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-class StoredConstMemberFunctionPointerCall5 : public RunFunctionTask<T>
-{
-public:
-    StoredConstMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
-
-    void runFunctor()
-    {
-        this->result = (object->*fn)(arg1, arg2, arg3, arg4, arg5);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
-    Class const *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-class VoidStoredConstMemberFunctionPointerCall5 : public RunFunctionTask<T>
-{
-public:
-    VoidStoredConstMemberFunctionPointerCall5(T (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) const, Class const *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
-    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
-
-    void runFunctor()
-    {
-        (object->*fn)(arg1, arg2, arg3, arg4, arg5);
-    }
-private:
-    T (Class::*fn)(Param1, Param2, Param3, Param4, Param5)const;
-    Class const *object;
-    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
-};
-template <typename T, typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
-struct SelectStoredConstMemberFunctionPointerCall5
-{
-    typedef typename SelectSpecialization<T>::template
-        Type<StoredConstMemberFunctionPointerCall5    <T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>,
-             VoidStoredConstMemberFunctionPointerCall5<T, Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5> >::type type;
-};
-
-template <typename T, typename Functor>
-class StoredFunctorCall : public RunFunctionTask<T>
-{
-public:
-    StoredFunctorCall(const Functor &f) : functor(f) { }
-    void runFunctor()
-    {
-        this->result = functor();
-    }
-private:
-    Functor functor;
-};
-template <typename Functor>
-class StoredFunctorCall<void, Functor> : public RunFunctionTask<void>
-{
-public:
-    StoredFunctorCall(const Functor &f) : functor(f) { }
-    void runFunctor()
-    {
-        functor();
-    }
-private:
-    Functor functor;
-};
-
-
-} //namespace QtConcurrent
-
-#endif // qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qtconcurrentthreadengine.cpp b/src/corelib/concurrent/qtconcurrentthreadengine.cpp
deleted file mode 100644
index 7741226..0000000
--- a/src/corelib/concurrent/qtconcurrentthreadengine.cpp
+++ /dev/null
@@ -1,299 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qtconcurrentthreadengine.h"
-
-#ifndef QT_NO_CONCURRENT
-
-QT_BEGIN_NAMESPACE
-
-namespace QtConcurrent {
-
-ThreadEngineBarrier::ThreadEngineBarrier()
-:count(0) { }
-
-void ThreadEngineBarrier::acquire()
-{
-    forever {
-        int localCount = count.load();
-        if (localCount < 0) {
-            if (count.testAndSetOrdered(localCount, localCount -1))
-                return;
-        } else {
-            if (count.testAndSetOrdered(localCount, localCount + 1))
-                return;
-        }
-    }
-}
-
-int ThreadEngineBarrier::release()
-{
-    forever {
-        int localCount = count.load();
-        if (localCount == -1) {
-            if (count.testAndSetOrdered(-1, 0)) {
-                semaphore.release();
-                return 0;
-            }
-        } else if (localCount < 0) {
-            if (count.testAndSetOrdered(localCount, localCount + 1))
-                return qAbs(localCount + 1);
-        } else {
-            if (count.testAndSetOrdered(localCount, localCount - 1))
-                return localCount - 1;
-        }
-    }
-}
-
-// Wait until all threads have been released
-void ThreadEngineBarrier::wait()
-{
-    forever {
-        int localCount = count.load();
-        if (localCount == 0)
-            return;
-
-        Q_ASSERT(localCount > 0); // multiple waiters are not allowed.
-        if (count.testAndSetOrdered(localCount, -localCount)) {
-            semaphore.acquire();
-            return;
-        }
-    }
-}
-
-int ThreadEngineBarrier::currentCount()
-{
-    return count.load();
-}
-
-// releases a thread, unless this is the last thread.
-// returns true if the thread was released.
-bool ThreadEngineBarrier::releaseUnlessLast()
-{
-    forever {
-        int localCount = count.load();
-        if (qAbs(localCount) == 1) {
-            return false;
-        } else if (localCount < 0) {
-            if (count.testAndSetOrdered(localCount, localCount + 1))
-                return true;
-        } else {
-            if (count.testAndSetOrdered(localCount, localCount - 1))
-                return true;
-        }
-    }
-}
-
-ThreadEngineBase::ThreadEngineBase()
-:futureInterface(0), threadPool(QThreadPool::globalInstance())
-{
-    setAutoDelete(false);
-}
-
-ThreadEngineBase::~ThreadEngineBase() {}
-
-void ThreadEngineBase::startSingleThreaded()
-{
-    start();
-    while (threadFunction() != ThreadFinished)
-        ;
-    finish();
-}
-
-void ThreadEngineBase::startBlocking()
-{
-    start();
-    barrier.acquire();
-    startThreads();
-
-    bool throttled = false;
-#ifndef QT_NO_EXCEPTIONS
-    try {
-#endif
-        while (threadFunction() == ThrottleThread) {
-            if (threadThrottleExit()) {
-                throttled = true;
-                break;
-            }
-        }
-#ifndef QT_NO_EXCEPTIONS
-    } catch (QtConcurrent::Exception &e) {
-        handleException(e);
-    } catch (...) {
-        handleException(QtConcurrent::UnhandledException());
-    }
-#endif
-
-    if (throttled == false) {
-        barrier.release();
-    }
-
-    barrier.wait();
-    finish();
-    exceptionStore.throwPossibleException();
-}
-
-void ThreadEngineBase::startThread()
-{
-    startThreadInternal();
-}
-
-void ThreadEngineBase::acquireBarrierSemaphore()
-{
-    barrier.acquire();
-}
-
-bool ThreadEngineBase::isCanceled()
-{
-    if (futureInterface)
-        return futureInterface->isCanceled();
-    else
-        return false;
-}
-
-void ThreadEngineBase::waitForResume()
-{
-    if (futureInterface)
-        futureInterface->waitForResume();
-}
-
-bool ThreadEngineBase::isProgressReportingEnabled()
-{
-    // If we don't have a QFuture, there is no-one to report the progress to.
-    return (futureInterface != 0);
-}
-
-void ThreadEngineBase::setProgressValue(int progress)
-{
-    if (futureInterface)
-        futureInterface->setProgressValue(progress);
-}
-
-void ThreadEngineBase::setProgressRange(int minimum, int maximum)
-{
-    if (futureInterface)
-        futureInterface->setProgressRange(minimum, maximum);
-}
-
-bool ThreadEngineBase::startThreadInternal()
-{
-    if (this->isCanceled())
-        return false;
-
-    barrier.acquire();
-    if (!threadPool->tryStart(this)) {
-        barrier.release();
-        return false;
-    }
-    return true;
-}
-
-void ThreadEngineBase::startThreads()
-{
-    while (shouldStartThread() && startThreadInternal())
-        ;
-}
-
-void ThreadEngineBase::threadExit()
-{
-    const bool asynchronous = futureInterface != 0;
-    const int lastThread = (barrier.release() == 0);
-
-    if (lastThread && asynchronous)
-        this->asynchronousFinish();
-}
-
-// Called by a worker thread that wants to be throttled. If the current number
-// of running threads is larger than one the thread is allowed to exit and
-// this function returns one.
-bool ThreadEngineBase::threadThrottleExit()
-{
-    return barrier.releaseUnlessLast();
-}
-
-void ThreadEngineBase::run() // implements QRunnable.
-{
-    if (this->isCanceled()) {
-        threadExit();
-        return;
-    }
-
-    startThreads();
-
-#ifndef QT_NO_EXCEPTIONS
-    try {
-#endif
-        while (threadFunction() == ThrottleThread) {
-            // threadFunction returning ThrottleThread means it that the user
-            // struct wants to be throttled by making a worker thread exit.
-            // Respect that request unless this is the only worker thread left
-            // running, in which case it has to keep going.
-            if (threadThrottleExit())
-                return;
-        }
-
-#ifndef QT_NO_EXCEPTIONS
-    } catch (QtConcurrent::Exception &e) {
-        handleException(e);
-    } catch (...) {
-        handleException(QtConcurrent::UnhandledException());
-    }
-#endif
-    threadExit();
-}
-
-#ifndef QT_NO_EXCEPTIONS
-
-void ThreadEngineBase::handleException(const QtConcurrent::Exception &exception)
-{
-    if (futureInterface)
-        futureInterface->reportException(exception);
-    else
-        exceptionStore.setException(exception);
-}
-#endif
-
-
-} // namepsace QtConcurrent
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_CONCURRENT
diff --git a/src/corelib/concurrent/qtconcurrentthreadengine.h b/src/corelib/concurrent/qtconcurrentthreadengine.h
deleted file mode 100644
index e9c144a..0000000
--- a/src/corelib/concurrent/qtconcurrentthreadengine.h
+++ /dev/null
@@ -1,284 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTCONCURRENT_THREADENGINE_H
-#define QTCONCURRENT_THREADENGINE_H
-
-#include <QtCore/qglobal.h>
-
-#ifndef QT_NO_CONCURRENT
-
-#include <QtCore/qthreadpool.h>
-#include <QtCore/qfuture.h>
-#include <QtCore/qdebug.h>
-#include <QtCore/qtconcurrentexception.h>
-#include <QtCore/qwaitcondition.h>
-#include <QtCore/qatomic.h>
-#include <QtCore/qsemaphore.h>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-#ifndef qdoc
-
-namespace QtConcurrent {
-
-// The ThreadEngineBarrier counts worker threads, and allows one
-// thread to wait for all others to finish. Tested for its use in
-// QtConcurrent, requires more testing for use as a general class.
-class ThreadEngineBarrier
-{
-private:
-    // The thread count is maintained as an integer in the count atomic
-    // variable. The count can be either positive or negative - a negative
-    // count signals that a thread is waiting on the barrier.
-
-    // BC note: inlined code from Qt < 4.6 will expect to find the QMutex 
-    // and QAtomicInt here. ### Qt 5: remove.
-    QMutex mutex;
-    QAtomicInt count;
-
-    QSemaphore semaphore;
-public:
-    ThreadEngineBarrier();
-    void acquire();
-    int release();
-    void wait();
-    int currentCount();
-    bool releaseUnlessLast();
-};
-
-enum ThreadFunctionResult { ThrottleThread, ThreadFinished };
-
-// The ThreadEngine controls the threads used in the computation.
-// Can be run in three modes: single threaded, multi-threaded blocking
-// and multi-threaded asynchronous.
-// The code for the single threaded mode is
-class Q_CORE_EXPORT ThreadEngineBase: public QRunnable
-{
-public:
-    // Public API:
-    ThreadEngineBase();
-    virtual ~ThreadEngineBase();
-    void startSingleThreaded();
-    void startBlocking();
-    void startThread();
-    bool isCanceled();
-    void waitForResume();
-    bool isProgressReportingEnabled();
-    void setProgressValue(int progress);
-    void setProgressRange(int minimum, int maximum);
-    void acquireBarrierSemaphore();
-
-protected: // The user overrides these:
-    virtual void start() {}
-    virtual void finish() {}
-    virtual ThreadFunctionResult threadFunction() { return ThreadFinished; }
-    virtual bool shouldStartThread() { return futureInterface ? !futureInterface->isPaused() : true; }
-    virtual bool shouldThrottleThread() { return futureInterface ? futureInterface->isPaused() : false; }
-private:
-    bool startThreadInternal();
-    void startThreads();
-    void threadExit();
-    bool threadThrottleExit();
-    void run();
-    virtual void asynchronousFinish() = 0;
-#ifndef QT_NO_EXCEPTIONS
-    void handleException(const QtConcurrent::Exception &exception);
-#endif
-protected:
-    QFutureInterfaceBase *futureInterface;
-    QThreadPool *threadPool;
-    ThreadEngineBarrier barrier;
-    QtConcurrent::internal::ExceptionStore exceptionStore;
-};
-
-
-template <typename T>
-class ThreadEngine : public virtual ThreadEngineBase
-{
-public:
-    typedef T ResultType;
-
-    virtual T *result() { return 0; }
-
-    QFutureInterface<T> *futureInterfaceTyped()
-    {
-        return static_cast<QFutureInterface<T> *>(futureInterface);
-    }
-
-    // Runs the user algorithm using a single thread.
-    T *startSingleThreaded()
-    {
-        ThreadEngineBase::startSingleThreaded();
-        return result();
-    }
-
-    // Runs the user algorithm using multiple threads.
-    // This function blocks until the algorithm is finished,
-    // and then returns the result.
-    T *startBlocking()
-    {
-        ThreadEngineBase::startBlocking();
-        return result();
-    }
-
-    // Runs the user algorithm using multiple threads.
-    // Does not block, returns a future.
-    QFuture<T> startAsynchronously()
-    {
-        futureInterface = new QFutureInterface<T>();
-
-        // reportStart() must be called before starting threads, otherwise the
-        // user algorithm might finish while reportStart() is running, which
-        // is very bad.
-        futureInterface->reportStarted();
-        QFuture<T> future = QFuture<T>(futureInterfaceTyped());
-        start();
-
-        acquireBarrierSemaphore();
-        threadPool->start(this);
-        return future;
-    }
-
-    void asynchronousFinish()
-    {
-        finish();
-        futureInterfaceTyped()->reportFinished(result());
-        delete futureInterfaceTyped();
-        delete this;
-    }
-
-
-    void reportResult(const T *_result, int index = -1)
-    {
-        if (futureInterface)
-            futureInterfaceTyped()->reportResult(_result, index);
-    }
-
-    void reportResults(const QVector<T> &_result, int index = -1, int count = -1)
-    {
-        if (futureInterface)
-            futureInterfaceTyped()->reportResults(_result, index, count);
-    }
-};
-
-// The ThreadEngineStarter class ecapsulates the return type
-// from the thread engine.
-// Depending on how the it is used, it will run
-// the engine in either blocking mode or asynchronous mode.
-template <typename T>
-class ThreadEngineStarterBase
-{
-public:
-    ThreadEngineStarterBase(ThreadEngine<T> *_threadEngine)
-    : threadEngine(_threadEngine) { }
-
-    inline ThreadEngineStarterBase(const ThreadEngineStarterBase &other)
-    : threadEngine(other.threadEngine) { }
-
-    QFuture<T> startAsynchronously()
-    {
-        return threadEngine->startAsynchronously();
-    }
-
-    operator QFuture<T>()
-    {
-        return startAsynchronously();
-    }
-
-protected:
-    ThreadEngine<T> *threadEngine;
-};
-
-
-// We need to factor out the code that dereferences the T pointer,
-// with a specialization where T is void. (code that dereferences a void *
-// won't compile)
-template <typename T>
-class ThreadEngineStarter : public ThreadEngineStarterBase<T>
-{
-    typedef ThreadEngineStarterBase<T> Base;
-    typedef ThreadEngine<T> TypedThreadEngine;
-public:
-    ThreadEngineStarter(TypedThreadEngine *eng)
-        : Base(eng) { }
-
-    T startBlocking()
-    {
-        T t = *this->threadEngine->startBlocking();
-        delete this->threadEngine;
-        return t;
-    }
-};
-
-// Full template specialization where T is void.
-template <>
-class ThreadEngineStarter<void> : public ThreadEngineStarterBase<void>
-{
-public:
-    ThreadEngineStarter<void>(ThreadEngine<void> *_threadEngine)
-    :ThreadEngineStarterBase<void>(_threadEngine) {}
-
-    void startBlocking()
-    {
-        this->threadEngine->startBlocking();
-        delete this->threadEngine;
-    }
-};
-
-template <typename ThreadEngine>
-inline ThreadEngineStarter<typename ThreadEngine::ResultType> startThreadEngine(ThreadEngine *threadEngine)
-{
-    return ThreadEngineStarter<typename ThreadEngine::ResultType>(threadEngine);
-}
-
-} // namespace QtConcurrent
-
-#endif //qdoc
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_CONCURRENT
-
-#endif
diff --git a/src/corelib/concurrent/qthreadpool.cpp b/src/corelib/concurrent/qthreadpool.cpp
deleted file mode 100644
index af8c991..0000000
--- a/src/corelib/concurrent/qthreadpool.cpp
+++ /dev/null
@@ -1,651 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qthreadpool.h"
-#include "qthreadpool_p.h"
-#include "qelapsedtimer.h"
-
-#ifndef QT_NO_THREAD
-
-QT_BEGIN_NAMESPACE
-
-inline bool operator<(int priority, const QPair<QRunnable *, int> &p)
-{
-    return p.second < priority;
-}
-inline bool operator<(const QPair<QRunnable *, int> &p, int priority)
-{
-    return priority < p.second;
-}
-
-Q_GLOBAL_STATIC(QThreadPool, theInstance)
-
-/*
-    QThread wrapper, provides synchronizitaion against a ThreadPool
-*/
-class QThreadPoolThread : public QThread
-{
-public:
-    QThreadPoolThread(QThreadPoolPrivate *manager);
-    void run();
-    void registerTheadInactive();
-
-    QThreadPoolPrivate *manager;
-    QRunnable *runnable;
-};
-
-/*
-    QThreadPool private class.
-*/
-
-
-/*!\internal
-
-*/
-QThreadPoolThread::QThreadPoolThread(QThreadPoolPrivate *manager)
-    :manager(manager), runnable(0)
-{ }
-
-/* \internal
-
-*/
-void QThreadPoolThread::run()
-{
-    QMutexLocker locker(&manager->mutex);
-    for(;;) {
-        QRunnable *r = runnable;
-        runnable = 0;
-
-        do {
-            if (r) {
-                const bool autoDelete = r->autoDelete();
-
-
-                // run the task
-                locker.unlock();
-#ifndef QT_NO_EXCEPTIONS
-                try {
-#endif
-                    r->run();
-#ifndef QT_NO_EXCEPTIONS
-                } catch (...) {
-                    qWarning("Qt Concurrent has caught an exception thrown from a worker thread.\n"
-                             "This is not supported, exceptions thrown in worker threads must be\n"
-                             "caught before control returns to Qt Concurrent.");
-                    registerTheadInactive();
-                    throw;
-                }
-#endif
-                locker.relock();
-
-                if (autoDelete && !--r->ref)
-                    delete r;
-            }
-
-            // if too many threads are active, expire this thread
-            if (manager->tooManyThreadsActive())
-                break;
-
-            r = !manager->queue.isEmpty() ? manager->queue.takeFirst().first : 0;
-        } while (r != 0);
-
-        if (manager->isExiting) {
-            registerTheadInactive();
-            break;
-        }
-
-        // if too many threads are active, expire this thread
-        bool expired = manager->tooManyThreadsActive();
-        if (!expired) {
-            ++manager->waitingThreads;
-            registerTheadInactive();
-            // wait for work, exiting after the expiry timeout is reached
-            expired = !manager->runnableReady.wait(locker.mutex(), manager->expiryTimeout);
-            ++manager->activeThreads;
-    
-            if (expired)
-                --manager->waitingThreads;
-        }
-        if (expired) {
-            manager->expiredThreads.enqueue(this);
-            registerTheadInactive();
-            break;
-        }
-    }
-}
-
-void QThreadPoolThread::registerTheadInactive()
-{
-    if (--manager->activeThreads == 0)
-        manager->noActiveThreads.wakeAll();
-}
-
-
-/* \internal
-
-*/
-QThreadPoolPrivate:: QThreadPoolPrivate()
-    : isExiting(false),
-      expiryTimeout(30000),
-      maxThreadCount(qAbs(QThread::idealThreadCount())),
-      reservedThreads(0),
-      waitingThreads(0),
-      activeThreads(0)
-{ }
-
-bool QThreadPoolPrivate::tryStart(QRunnable *task)
-{
-    if (allThreads.isEmpty()) {
-        // always create at least one thread
-        startThread(task);
-        return true;
-    }
-
-    // can't do anything if we're over the limit
-    if (activeThreadCount() >= maxThreadCount)
-        return false;
-
-    if (waitingThreads > 0) {
-        // recycle an available thread
-        --waitingThreads;
-        enqueueTask(task);
-        return true;
-    }
-
-    if (!expiredThreads.isEmpty()) {
-        // restart an expired thread
-        QThreadPoolThread *thread = expiredThreads.dequeue();
-        Q_ASSERT(thread->runnable == 0);
-
-        ++activeThreads;
-
-        if (task->autoDelete())
-            ++task->ref;
-        thread->runnable = task;
-        thread->start();
-        return true;
-    }
-
-    // start a new thread
-    startThread(task);
-    return true;
-}
-
-void QThreadPoolPrivate::enqueueTask(QRunnable *runnable, int priority)
-{
-    if (runnable->autoDelete())
-        ++runnable->ref;
-
-    // put it on the queue
-    QList<QPair<QRunnable *, int> >::iterator at =
-        qUpperBound(queue.begin(), queue.end(), priority);
-    queue.insert(at, qMakePair(runnable, priority));
-    runnableReady.wakeOne();
-}
-
-int QThreadPoolPrivate::activeThreadCount() const
-{
-    // To improve scalability this function is called without holding 
-    // the mutex lock -- keep it thread-safe.
-    return (allThreads.count()
-            - expiredThreads.count()
-            - waitingThreads
-            + reservedThreads);
-}
-
-void QThreadPoolPrivate::tryToStartMoreThreads()
-{
-    // try to push tasks on the queue to any available threads
-    while (!queue.isEmpty() && tryStart(queue.first().first))
-        queue.removeFirst();
-}
-
-bool QThreadPoolPrivate::tooManyThreadsActive() const
-{
-    const int activeThreadCount = this->activeThreadCount();
-    return activeThreadCount > maxThreadCount && (activeThreadCount - reservedThreads) > 1;
-}
-
-/*! \internal
-
-*/
-void QThreadPoolPrivate::startThread(QRunnable *runnable)
-{
-    QScopedPointer <QThreadPoolThread> thread(new QThreadPoolThread(this));
-    thread->setObjectName(QLatin1String("Thread (pooled)"));
-    allThreads.insert(thread.data());
-    ++activeThreads;
-
-    if (runnable->autoDelete())
-        ++runnable->ref;
-    thread->runnable = runnable;
-    thread.take()->start();
-}
-
-/*! \internal
-    Makes all threads exit, waits for each tread to exit and deletes it.
-*/
-void QThreadPoolPrivate::reset()
-{
-    QMutexLocker locker(&mutex);
-    isExiting = true;
-    runnableReady.wakeAll();
-
-    do {
-        // make a copy of the set so that we can iterate without the lock
-        QSet<QThreadPoolThread *> allThreadsCopy = allThreads;
-        allThreads.clear();
-        locker.unlock();
-
-        foreach (QThreadPoolThread *thread, allThreadsCopy) {
-            thread->wait();
-            delete thread;
-        }
-
-        locker.relock();
-        // repeat until all newly arrived threads have also completed
-    } while (!allThreads.isEmpty());
-
-    waitingThreads = 0;
-    expiredThreads.clear();
-
-    isExiting = false;
-}
-
-bool QThreadPoolPrivate::waitForDone(int msecs)
-{
-    QMutexLocker locker(&mutex);
-    if (msecs < 0) {
-        while (!(queue.isEmpty() && activeThreads == 0))
-            noActiveThreads.wait(locker.mutex());
-    } else {
-        QElapsedTimer timer;
-        timer.start();
-        int t;
-        while (!(queue.isEmpty() && activeThreads == 0) && 
-               ((t = msecs - timer.elapsed()) > 0))
-            noActiveThreads.wait(locker.mutex(), t);
-    }
-    return queue.isEmpty() && activeThreads == 0;
-}
-
-/*! \internal
-    Pulls a runnable from the front queue and runs it in the current thread. Blocks
-    until the runnable has completed. Returns true if a runnable was found.
-*/
-bool QThreadPoolPrivate::startFrontRunnable()
-{
-    QMutexLocker locker(&mutex);
-    if (queue.isEmpty())
-        return false;
-
-    QRunnable *runnable = queue.takeFirst().first;
-    const bool autoDelete = runnable->autoDelete();
-    bool del = autoDelete && !--runnable->ref;
-
-    locker.unlock();
-    runnable->run();
-    locker.relock();
-
-    if (del) {
-        delete runnable;
-    }
-
-    return true;
-}
-
-/*! \internal
-    Seaches for \a runnable in the queue, removes it from the queue and
-    runs it if found. This functon does not return until the runnable
-    has completed.
-*/
-void QThreadPoolPrivate::stealRunnable(QRunnable *runnable)
-{
-    if (runnable == 0 || queue.isEmpty())
-        return;
-    bool found = false;
-    {
-        QMutexLocker locker(&mutex);
-        QList<QPair<QRunnable *, int> >::iterator it = queue.begin();
-        QList<QPair<QRunnable *, int> >::iterator end = queue.end();
-
-        while (it != end) {
-            if (it->first == runnable) {
-                found = true;
-                queue.erase(it);
-                break;
-            }
-            ++it;
-        }
-    }
-
-    if (!found)
-        return;
-
-    const bool autoDelete = runnable->autoDelete();
-    bool del = autoDelete && !--runnable->ref;
-
-    runnable->run();
-
-    if (del) {
-        delete runnable;
-    }
-}
-
-/*!
-    \class QThreadPool
-    \brief The QThreadPool class manages a collection of QThreads.
-    \since 4.4
-    \threadsafe
-
-    \ingroup thread
-
-    QThreadPool manages and recyles individual QThread objects to help reduce
-    thread creation costs in programs that use threads. Each Qt application
-    has one global QThreadPool object, which can be accessed by calling
-    globalInstance().
-
-    To use one of the QThreadPool threads, subclass QRunnable and implement
-    the run() virtual function. Then create an object of that class and pass
-    it to QThreadPool::start().
-
-    \snippet doc/src/snippets/code/src_corelib_concurrent_qthreadpool.cpp 0
-
-    QThreadPool deletes the QRunnable automatically by default. Use 
-    QRunnable::setAutoDelete() to change the auto-deletion flag.
-
-    QThreadPool supports executing the same QRunnable more than once
-    by calling tryStart(this) from within QRunnable::run(). 
-    If autoDelete is enabled the QRunnable will be deleted when
-    the last thread exits the run function. Calling start()
-    multiple times with the same QRunnable when autoDelete is enabled
-    creates a race condition and is not recommended.
-
-    Threads that are unused for a certain amount of time will expire. The
-    default expiry timeout is 30000 milliseconds (30 seconds). This can be
-    changed using setExpiryTimeout(). Setting a negative expiry timeout
-    disables the expiry mechanism.
-
-    Call maxThreadCount() to query the maximum number of threads to be used.
-    If needed, you can change the limit with setMaxThreadCount(). The default
-    maxThreadCount() is QThread::idealThreadCount(). The activeThreadCount()
-    function returns the number of threads currently doing work.
-
-    The reserveThread() function reserves a thread for external
-    use. Use releaseThread() when your are done with the thread, so
-    that it may be reused.  Essentially, these functions temporarily
-    increase or reduce the active thread count and are useful when
-    implementing time-consuming operations that are not visible to the
-    QThreadPool.
-
-    Note that QThreadPool is a low-level class for managing threads, see
-    QtConcurrent::run() or the other
-    \l {Concurrent Programming}{Qt Concurrent} APIs for higher
-    level alternatives.
-
-    \sa QRunnable
-*/
-
-/*!
-    Constructs a thread pool with the given \a parent.
-*/
-QThreadPool::QThreadPool(QObject *parent)
-    : QObject(*new QThreadPoolPrivate, parent)
-{ }
-
-/*!
-    Destroys the QThreadPool.
-    This function will block until all runnables have been completed.
-*/
-QThreadPool::~QThreadPool()
-{
-    d_func()->waitForDone();
-    d_func()->reset();
-}
-
-/*!
-    Returns the global QThreadPool instance.
-*/
-QThreadPool *QThreadPool::globalInstance()
-{
-    return theInstance();
-}
-
-/*!
-    Reserves a thread and uses it to run \a runnable, unless this thread will
-    make the current thread count exceed maxThreadCount().  In that case,
-    \a runnable is added to a run queue instead. The \a priority argument can
-    be used to control the run queue's order of execution.
-
-    Note that the thread pool takes ownership of the \a runnable if
-    \l{QRunnable::autoDelete()}{runnable->autoDelete()} returns true,
-    and the \a runnable will be deleted automatically by the thread
-    pool after the \l{QRunnable::run()}{runnable->run()} returns. If
-    \l{QRunnable::autoDelete()}{runnable->autoDelete()} returns false,
-    ownership of \a runnable remains with the caller. Note that
-    changing the auto-deletion on \a runnable after calling this
-    functions results in undefined behavior.
-*/
-void QThreadPool::start(QRunnable *runnable, int priority)
-{
-    if (!runnable)
-        return;
-
-    Q_D(QThreadPool);
-    QMutexLocker locker(&d->mutex);
-    if (!d->tryStart(runnable))
-        d->enqueueTask(runnable, priority);
-}
-
-/*!
-    Attempts to reserve a thread to run \a runnable.
-
-    If no threads are available at the time of calling, then this function
-    does nothing and returns false.  Otherwise, \a runnable is run immediately
-    using one available thread and this function returns true.
-
-    Note that the thread pool takes ownership of the \a runnable if
-    \l{QRunnable::autoDelete()}{runnable->autoDelete()} returns true,
-    and the \a runnable will be deleted automatically by the thread
-    pool after the \l{QRunnable::run()}{runnable->run()} returns. If
-    \l{QRunnable::autoDelete()}{runnable->autoDelete()} returns false,
-    ownership of \a runnable remains with the caller. Note that
-    changing the auto-deletion on \a runnable after calling this
-    function results in undefined behavior.
-*/
-bool QThreadPool::tryStart(QRunnable *runnable)
-{
-    if (!runnable)
-        return false;
-
-    Q_D(QThreadPool);
-
-    // To improve scalability perform a check on the thread count
-    // before locking the mutex.
-    if (d->allThreads.isEmpty() == false && d->activeThreadCount() >= d->maxThreadCount)
-        return false;
-
-    QMutexLocker locker(&d->mutex);
-    return d->tryStart(runnable);
-}
-
-/*! \property QThreadPool::expiryTimeout
-
-    Threads that are unused for \a expiryTimeout milliseconds are considered
-    to have expired and will exit. Such threads will be restarted as needed.
-    The default \a expiryTimeout is 30000 milliseconds (30 seconds). If
-    \a expiryTimeout is negative, newly created threads will not expire, e.g.,
-    they will not exit until the thread pool is destroyed.
-
-    Note that setting \a expiryTimeout has no effect on already running
-    threads. Only newly created threads will use the new \a expiryTimeout.
-    We recommend setting the \a expiryTimeout immediately after creating the
-    thread pool, but before calling start().
-*/
-
-int QThreadPool::expiryTimeout() const
-{
-    Q_D(const QThreadPool);
-    return d->expiryTimeout;
-}
-
-void QThreadPool::setExpiryTimeout(int expiryTimeout)
-{
-    Q_D(QThreadPool);
-    if (d->expiryTimeout == expiryTimeout)
-        return;
-    d->expiryTimeout = expiryTimeout;
-}
-
-/*! \property QThreadPool::maxThreadCount
-
-    This property represents the maximum number of threads used by the thread
-    pool.
-
-    \note The thread pool will always use at least 1 thread, even if
-    \a maxThreadCount limit is zero or negative.
-
-    The default \a maxThreadCount is QThread::idealThreadCount().
-*/
-
-int QThreadPool::maxThreadCount() const
-{
-    Q_D(const QThreadPool);
-    return d->maxThreadCount;
-}
-
-void QThreadPool::setMaxThreadCount(int maxThreadCount)
-{
-    Q_D(QThreadPool);
-    QMutexLocker locker(&d->mutex);
-
-    if (maxThreadCount == d->maxThreadCount)
-        return;
-
-    d->maxThreadCount = maxThreadCount;
-    d->tryToStartMoreThreads();
-}
-
-/*! \property QThreadPool::activeThreadCount
-
-    This property represents the number of active threads in the thread pool.
-
-    \note It is possible for this function to return a value that is greater
-    than maxThreadCount(). See reserveThread() for more details.
-
-    \sa reserveThread(), releaseThread()
-*/
-
-int QThreadPool::activeThreadCount() const
-{
-    Q_D(const QThreadPool);
-    return d->activeThreadCount();
-}
-
-/*!
-    Reserves one thread, disregarding activeThreadCount() and maxThreadCount().
-
-    Once you are done with the thread, call releaseThread() to allow it to be
-    reused.
-
-    \note This function will always increase the number of active threads.
-    This means that by using this function, it is possible for
-    activeThreadCount() to return a value greater than maxThreadCount() .
-
-    \sa releaseThread()
- */
-void QThreadPool::reserveThread()
-{
-    Q_D(QThreadPool);
-    QMutexLocker locker(&d->mutex);
-    ++d->reservedThreads;
-}
-
-/*!
-    Releases a thread previously reserved by a call to reserveThread().
-
-    \note Calling this function without previously reserving a thread
-    temporarily increases maxThreadCount(). This is useful when a
-    thread goes to sleep waiting for more work, allowing other threads
-    to continue. Be sure to call reserveThread() when done waiting, so
-    that the thread pool can correctly maintain the
-    activeThreadCount().
-
-    \sa reserveThread()
-*/
-void QThreadPool::releaseThread()
-{
-    Q_D(QThreadPool);
-    QMutexLocker locker(&d->mutex);
-    --d->reservedThreads;
-    d->tryToStartMoreThreads();
-}
-
-/*!
-    Waits for each thread to exit and removes all threads from the thread pool.
-*/
-void QThreadPool::waitForDone()
-{
-    Q_D(QThreadPool);
-    d->waitForDone();
-    d->reset();
-}
-
-/*!
-    \overload waitForDone()
-    \since 4.8
-
-    Waits up to \a msecs milliseconds for all threads to exit and removes all 
-    threads from the thread pool. Returns true if all threads were removed; 
-    otherwise it returns false.
-*/
-bool QThreadPool::waitForDone(int msecs)
-{
-    Q_D(QThreadPool);
-    bool rc = d->waitForDone(msecs);
-    if (rc)
-      d->reset();
-    return rc;
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/corelib/concurrent/qthreadpool.h b/src/corelib/concurrent/qthreadpool.h
deleted file mode 100644
index 9fc023c..0000000
--- a/src/corelib/concurrent/qthreadpool.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTHREADPOOL_H
-#define QTHREADPOOL_H
-
-#include <QtCore/qglobal.h>
-
-#include <QtCore/qthread.h>
-#include <QtCore/qrunnable.h>
-
-#ifndef QT_NO_THREAD
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-
-class QThreadPoolPrivate;
-class Q_CORE_EXPORT QThreadPool : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QThreadPool)
-    Q_PROPERTY(int expiryTimeout READ expiryTimeout WRITE setExpiryTimeout)
-    Q_PROPERTY(int maxThreadCount READ maxThreadCount WRITE setMaxThreadCount)
-    Q_PROPERTY(int activeThreadCount READ activeThreadCount)
-    friend class QFutureInterfaceBase;
-
-public:
-    QThreadPool(QObject *parent = 0);
-    ~QThreadPool();
-
-    static QThreadPool *globalInstance();
-
-    void start(QRunnable *runnable, int priority = 0);
-    bool tryStart(QRunnable *runnable);
-
-    int expiryTimeout() const;
-    void setExpiryTimeout(int expiryTimeout);
-
-    int maxThreadCount() const;
-    void setMaxThreadCount(int maxThreadCount);
-
-    int activeThreadCount() const;
-
-    void reserveThread();
-    void releaseThread();
-
-    void waitForDone();
-    bool waitForDone(int msecs);
-};
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QT_NO_THREAD
-
-#endif
diff --git a/src/corelib/concurrent/qthreadpool_p.h b/src/corelib/concurrent/qthreadpool_p.h
deleted file mode 100644
index f4c67b8..0000000
--- a/src/corelib/concurrent/qthreadpool_p.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTHREADPOOL_P_H
-#define QTHREADPOOL_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-//
-
-#include "QtCore/qmutex.h"
-#include "QtCore/qwaitcondition.h"
-#include "QtCore/qset.h"
-#include "QtCore/qqueue.h"
-#include "private/qobject_p.h"
-
-#ifndef QT_NO_THREAD
-
-QT_BEGIN_NAMESPACE
-
-class QThreadPoolThread;
-class QThreadPoolPrivate : public QObjectPrivate
-{
-    Q_DECLARE_PUBLIC(QThreadPool)
-    friend class QThreadPoolThread;
-
-public:
-    QThreadPoolPrivate();
-
-    bool tryStart(QRunnable *task);
-    void enqueueTask(QRunnable *task, int priority = 0);
-    int activeThreadCount() const;
-
-    void tryToStartMoreThreads();
-    bool tooManyThreadsActive() const;
-
-    void startThread(QRunnable *runnable = 0);
-    void reset();
-    bool waitForDone(int msecs = -1);
-    bool startFrontRunnable();
-    void stealRunnable(QRunnable *);
-
-    mutable QMutex mutex;
-    QWaitCondition runnableReady;
-    QSet<QThreadPoolThread *> allThreads;
-    QQueue<QThreadPoolThread *> expiredThreads;
-    QList<QPair<QRunnable *, int> > queue;
-    QWaitCondition noActiveThreads;
-
-    bool isExiting;
-    int expiryTimeout;
-    int maxThreadCount;
-    int reservedThreads;
-    int waitingThreads;
-    int activeThreads;
-};
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_THREAD
-#endif
diff --git a/src/corelib/corelib.pro b/src/corelib/corelib.pro
index de2b100..c8c9b9b 100644
--- a/src/corelib/corelib.pro
+++ b/src/corelib/corelib.pro
@@ -18,7 +18,6 @@ HEADERS += $$QT_SOURCE_TREE/src/corelib/qtcoreversion.h
 
 include(animation/animation.pri)
 include(arch/arch.pri)
-include(concurrent/concurrent.pri)
 include(global/global.pri)
 include(thread/thread.pri)
 include(tools/tools.pri)
diff --git a/src/corelib/global/qglobal.h b/src/corelib/global/qglobal.h
index 681cd55..c92336f 100644
--- a/src/corelib/global/qglobal.h
+++ b/src/corelib/global/qglobal.h
@@ -1326,6 +1326,11 @@ class QDataStream;
 #      define Q_DBUS_EXPORT Q_DECL_IMPORT
 #    endif
 #    define Q_TEMPLATEDLL
+#    if defined(QT_BUILD_CONCURRENT_LIB)
+#      define Q_CONCURRENT_EXPORT Q_DECL_EXPORT
+#    else
+#      define Q_CONCURRENT_EXPORT Q_DECL_IMPORT
+#    endif
 #  elif defined(QT_DLL) /* use a Qt DLL library */
 #    define Q_CORE_EXPORT Q_DECL_IMPORT
 #    define Q_GUI_EXPORT Q_DECL_IMPORT
@@ -1347,6 +1352,7 @@ class QDataStream;
 #    define Q_SCRIPTTOOLS_EXPORT Q_DECL_IMPORT
 #    define Q_COMPAT_EXPORT Q_DECL_IMPORT
 #    define Q_DBUS_EXPORT Q_DECL_IMPORT
+#    define Q_CONCURRENT_EXPORT Q_DECL_IMPORT
 #    define Q_TEMPLATEDLL
 #  endif
 #  define Q_NO_DECLARED_NOT_DEFINED
@@ -1380,6 +1386,7 @@ class QDataStream;
 #    define Q_SCRIPTTOOLS_EXPORT Q_DECL_EXPORT
 #    define Q_COMPAT_EXPORT Q_DECL_EXPORT
 #    define Q_DBUS_EXPORT Q_DECL_EXPORT
+#    define Q_CONCURRENT_EXPORT Q_DECL_EXPORT
 #  else
 #    define Q_CORE_EXPORT
 #    define Q_GUI_EXPORT
@@ -1400,6 +1407,7 @@ class QDataStream;
 #    define Q_SCRIPTTOOLS_EXPORT
 #    define Q_COMPAT_EXPORT
 #    define Q_DBUS_EXPORT
+#    define Q_CONCURRENT_EXPORT
 #  endif
 #endif
 
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index a248e18..cf3ae1b 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -593,7 +593,6 @@ QCoreApplication::~QCoreApplication()
     QCoreApplicationPrivate::is_app_running = false;
 
 #if !defined(QT_NO_THREAD)
-#if !defined(QT_NO_CONCURRENT)
     // Synchronize and stop the global thread pool threads.
     QThreadPool *globalThreadPool = 0;
     QT_TRY {
@@ -603,7 +602,6 @@ QCoreApplication::~QCoreApplication()
     }
     if (globalThreadPool)
         globalThreadPool->waitForDone();
-#endif
     QThread::cleanup();
 #endif
 
diff --git a/src/corelib/thread/qrunnable.cpp b/src/corelib/thread/qrunnable.cpp
new file mode 100644
index 0000000..933a5b9
--- /dev/null
+++ b/src/corelib/thread/qrunnable.cpp
@@ -0,0 +1,107 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+    \class QRunnable
+    \since 4.4
+    \brief The QRunnable class is the base class for all runnable objects.
+
+    \ingroup thread
+
+    The QRunnable class is an interface for representing a task or
+    piece of code that needs to be executed, represented by your
+    reimplementation of the run() function.
+
+    You can use QThreadPool to execute your code in a separate
+    thread. QThreadPool deletes the QRunnable automatically if
+    autoDelete() returns true (the default). Use setAutoDelete() to
+    change the auto-deletion flag.
+
+    QThreadPool supports executing the same QRunnable more than once
+    by calling QThreadPool::tryStart(this) from within the run() function. 
+    If autoDelete is enabled the QRunnable will be deleted when
+    the last thread exits the run function. Calling QThreadPool::start()
+    multiple times with the same QRunnable when autoDelete is enabled
+    creates a race condition and is not recommended.
+
+    \sa QThreadPool
+*/
+
+/*! \fn QRunnable::run()
+    Implement this pure virtual function in your subclass.
+*/
+
+/*! \fn QRunnable::QRunnable()
+    Constructs a QRunnable. Auto-deletion is enabled by default.
+
+    \sa autoDelete(), setAutoDelete()
+*/
+
+/*! \fn QRunnable::~QRunnable()
+    QRunnable virtual destructor.
+*/
+
+/*! \fn bool QRunnable::autoDelete() const
+
+    Returns true is auto-deletion is enabled; false otherwise.
+
+    If auto-deletion is enabled, QThreadPool will automatically delete
+    this runnable after calling run(); otherwise, ownership remains
+    with the application programmer.
+
+    \sa setAutoDelete(), QThreadPool
+*/
+
+/*! \fn bool QRunnable::setAutoDelete(bool autoDelete)
+
+    Enables auto-deletion if \a autoDelete is true; otherwise
+    auto-deletion is disabled.
+
+    If auto-deletion is enabled, QThreadPool will automatically delete
+    this runnable after calling run(); otherwise, ownership remains
+    with the application programmer.
+
+    Note that this flag must be set before calling
+    QThreadPool::start(). Calling this function after
+    QThreadPool::start() results in undefined behavior.
+
+    \sa autoDelete(), QThreadPool
+*/
diff --git a/src/corelib/thread/qrunnable.h b/src/corelib/thread/qrunnable.h
new file mode 100644
index 0000000..11d5c01
--- /dev/null
+++ b/src/corelib/thread/qrunnable.h
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QRUNNABLE_H
+#define QRUNNABLE_H
+
+#include <QtCore/qglobal.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+class QRunnable
+{
+    int ref;
+
+    friend class QThreadPool;
+    friend class QThreadPoolPrivate;
+    friend class QThreadPoolThread;
+
+public:
+    virtual void run() = 0;
+
+    QRunnable() : ref(0) { }
+    virtual ~QRunnable() { }
+
+    bool autoDelete() const { return ref != -1; }
+    void setAutoDelete(bool _autoDelete) { ref = _autoDelete ? 0 : -1; }
+};
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif
diff --git a/src/corelib/thread/qthreadpool.cpp b/src/corelib/thread/qthreadpool.cpp
new file mode 100644
index 0000000..af8c991
--- /dev/null
+++ b/src/corelib/thread/qthreadpool.cpp
@@ -0,0 +1,651 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qthreadpool.h"
+#include "qthreadpool_p.h"
+#include "qelapsedtimer.h"
+
+#ifndef QT_NO_THREAD
+
+QT_BEGIN_NAMESPACE
+
+inline bool operator<(int priority, const QPair<QRunnable *, int> &p)
+{
+    return p.second < priority;
+}
+inline bool operator<(const QPair<QRunnable *, int> &p, int priority)
+{
+    return priority < p.second;
+}
+
+Q_GLOBAL_STATIC(QThreadPool, theInstance)
+
+/*
+    QThread wrapper, provides synchronizitaion against a ThreadPool
+*/
+class QThreadPoolThread : public QThread
+{
+public:
+    QThreadPoolThread(QThreadPoolPrivate *manager);
+    void run();
+    void registerTheadInactive();
+
+    QThreadPoolPrivate *manager;
+    QRunnable *runnable;
+};
+
+/*
+    QThreadPool private class.
+*/
+
+
+/*!\internal
+
+*/
+QThreadPoolThread::QThreadPoolThread(QThreadPoolPrivate *manager)
+    :manager(manager), runnable(0)
+{ }
+
+/* \internal
+
+*/
+void QThreadPoolThread::run()
+{
+    QMutexLocker locker(&manager->mutex);
+    for(;;) {
+        QRunnable *r = runnable;
+        runnable = 0;
+
+        do {
+            if (r) {
+                const bool autoDelete = r->autoDelete();
+
+
+                // run the task
+                locker.unlock();
+#ifndef QT_NO_EXCEPTIONS
+                try {
+#endif
+                    r->run();
+#ifndef QT_NO_EXCEPTIONS
+                } catch (...) {
+                    qWarning("Qt Concurrent has caught an exception thrown from a worker thread.\n"
+                             "This is not supported, exceptions thrown in worker threads must be\n"
+                             "caught before control returns to Qt Concurrent.");
+                    registerTheadInactive();
+                    throw;
+                }
+#endif
+                locker.relock();
+
+                if (autoDelete && !--r->ref)
+                    delete r;
+            }
+
+            // if too many threads are active, expire this thread
+            if (manager->tooManyThreadsActive())
+                break;
+
+            r = !manager->queue.isEmpty() ? manager->queue.takeFirst().first : 0;
+        } while (r != 0);
+
+        if (manager->isExiting) {
+            registerTheadInactive();
+            break;
+        }
+
+        // if too many threads are active, expire this thread
+        bool expired = manager->tooManyThreadsActive();
+        if (!expired) {
+            ++manager->waitingThreads;
+            registerTheadInactive();
+            // wait for work, exiting after the expiry timeout is reached
+            expired = !manager->runnableReady.wait(locker.mutex(), manager->expiryTimeout);
+            ++manager->activeThreads;
+    
+            if (expired)
+                --manager->waitingThreads;
+        }
+        if (expired) {
+            manager->expiredThreads.enqueue(this);
+            registerTheadInactive();
+            break;
+        }
+    }
+}
+
+void QThreadPoolThread::registerTheadInactive()
+{
+    if (--manager->activeThreads == 0)
+        manager->noActiveThreads.wakeAll();
+}
+
+
+/* \internal
+
+*/
+QThreadPoolPrivate:: QThreadPoolPrivate()
+    : isExiting(false),
+      expiryTimeout(30000),
+      maxThreadCount(qAbs(QThread::idealThreadCount())),
+      reservedThreads(0),
+      waitingThreads(0),
+      activeThreads(0)
+{ }
+
+bool QThreadPoolPrivate::tryStart(QRunnable *task)
+{
+    if (allThreads.isEmpty()) {
+        // always create at least one thread
+        startThread(task);
+        return true;
+    }
+
+    // can't do anything if we're over the limit
+    if (activeThreadCount() >= maxThreadCount)
+        return false;
+
+    if (waitingThreads > 0) {
+        // recycle an available thread
+        --waitingThreads;
+        enqueueTask(task);
+        return true;
+    }
+
+    if (!expiredThreads.isEmpty()) {
+        // restart an expired thread
+        QThreadPoolThread *thread = expiredThreads.dequeue();
+        Q_ASSERT(thread->runnable == 0);
+
+        ++activeThreads;
+
+        if (task->autoDelete())
+            ++task->ref;
+        thread->runnable = task;
+        thread->start();
+        return true;
+    }
+
+    // start a new thread
+    startThread(task);
+    return true;
+}
+
+void QThreadPoolPrivate::enqueueTask(QRunnable *runnable, int priority)
+{
+    if (runnable->autoDelete())
+        ++runnable->ref;
+
+    // put it on the queue
+    QList<QPair<QRunnable *, int> >::iterator at =
+        qUpperBound(queue.begin(), queue.end(), priority);
+    queue.insert(at, qMakePair(runnable, priority));
+    runnableReady.wakeOne();
+}
+
+int QThreadPoolPrivate::activeThreadCount() const
+{
+    // To improve scalability this function is called without holding 
+    // the mutex lock -- keep it thread-safe.
+    return (allThreads.count()
+            - expiredThreads.count()
+            - waitingThreads
+            + reservedThreads);
+}
+
+void QThreadPoolPrivate::tryToStartMoreThreads()
+{
+    // try to push tasks on the queue to any available threads
+    while (!queue.isEmpty() && tryStart(queue.first().first))
+        queue.removeFirst();
+}
+
+bool QThreadPoolPrivate::tooManyThreadsActive() const
+{
+    const int activeThreadCount = this->activeThreadCount();
+    return activeThreadCount > maxThreadCount && (activeThreadCount - reservedThreads) > 1;
+}
+
+/*! \internal
+
+*/
+void QThreadPoolPrivate::startThread(QRunnable *runnable)
+{
+    QScopedPointer <QThreadPoolThread> thread(new QThreadPoolThread(this));
+    thread->setObjectName(QLatin1String("Thread (pooled)"));
+    allThreads.insert(thread.data());
+    ++activeThreads;
+
+    if (runnable->autoDelete())
+        ++runnable->ref;
+    thread->runnable = runnable;
+    thread.take()->start();
+}
+
+/*! \internal
+    Makes all threads exit, waits for each tread to exit and deletes it.
+*/
+void QThreadPoolPrivate::reset()
+{
+    QMutexLocker locker(&mutex);
+    isExiting = true;
+    runnableReady.wakeAll();
+
+    do {
+        // make a copy of the set so that we can iterate without the lock
+        QSet<QThreadPoolThread *> allThreadsCopy = allThreads;
+        allThreads.clear();
+        locker.unlock();
+
+        foreach (QThreadPoolThread *thread, allThreadsCopy) {
+            thread->wait();
+            delete thread;
+        }
+
+        locker.relock();
+        // repeat until all newly arrived threads have also completed
+    } while (!allThreads.isEmpty());
+
+    waitingThreads = 0;
+    expiredThreads.clear();
+
+    isExiting = false;
+}
+
+bool QThreadPoolPrivate::waitForDone(int msecs)
+{
+    QMutexLocker locker(&mutex);
+    if (msecs < 0) {
+        while (!(queue.isEmpty() && activeThreads == 0))
+            noActiveThreads.wait(locker.mutex());
+    } else {
+        QElapsedTimer timer;
+        timer.start();
+        int t;
+        while (!(queue.isEmpty() && activeThreads == 0) && 
+               ((t = msecs - timer.elapsed()) > 0))
+            noActiveThreads.wait(locker.mutex(), t);
+    }
+    return queue.isEmpty() && activeThreads == 0;
+}
+
+/*! \internal
+    Pulls a runnable from the front queue and runs it in the current thread. Blocks
+    until the runnable has completed. Returns true if a runnable was found.
+*/
+bool QThreadPoolPrivate::startFrontRunnable()
+{
+    QMutexLocker locker(&mutex);
+    if (queue.isEmpty())
+        return false;
+
+    QRunnable *runnable = queue.takeFirst().first;
+    const bool autoDelete = runnable->autoDelete();
+    bool del = autoDelete && !--runnable->ref;
+
+    locker.unlock();
+    runnable->run();
+    locker.relock();
+
+    if (del) {
+        delete runnable;
+    }
+
+    return true;
+}
+
+/*! \internal
+    Seaches for \a runnable in the queue, removes it from the queue and
+    runs it if found. This functon does not return until the runnable
+    has completed.
+*/
+void QThreadPoolPrivate::stealRunnable(QRunnable *runnable)
+{
+    if (runnable == 0 || queue.isEmpty())
+        return;
+    bool found = false;
+    {
+        QMutexLocker locker(&mutex);
+        QList<QPair<QRunnable *, int> >::iterator it = queue.begin();
+        QList<QPair<QRunnable *, int> >::iterator end = queue.end();
+
+        while (it != end) {
+            if (it->first == runnable) {
+                found = true;
+                queue.erase(it);
+                break;
+            }
+            ++it;
+        }
+    }
+
+    if (!found)
+        return;
+
+    const bool autoDelete = runnable->autoDelete();
+    bool del = autoDelete && !--runnable->ref;
+
+    runnable->run();
+
+    if (del) {
+        delete runnable;
+    }
+}
+
+/*!
+    \class QThreadPool
+    \brief The QThreadPool class manages a collection of QThreads.
+    \since 4.4
+    \threadsafe
+
+    \ingroup thread
+
+    QThreadPool manages and recyles individual QThread objects to help reduce
+    thread creation costs in programs that use threads. Each Qt application
+    has one global QThreadPool object, which can be accessed by calling
+    globalInstance().
+
+    To use one of the QThreadPool threads, subclass QRunnable and implement
+    the run() virtual function. Then create an object of that class and pass
+    it to QThreadPool::start().
+
+    \snippet doc/src/snippets/code/src_corelib_concurrent_qthreadpool.cpp 0
+
+    QThreadPool deletes the QRunnable automatically by default. Use 
+    QRunnable::setAutoDelete() to change the auto-deletion flag.
+
+    QThreadPool supports executing the same QRunnable more than once
+    by calling tryStart(this) from within QRunnable::run(). 
+    If autoDelete is enabled the QRunnable will be deleted when
+    the last thread exits the run function. Calling start()
+    multiple times with the same QRunnable when autoDelete is enabled
+    creates a race condition and is not recommended.
+
+    Threads that are unused for a certain amount of time will expire. The
+    default expiry timeout is 30000 milliseconds (30 seconds). This can be
+    changed using setExpiryTimeout(). Setting a negative expiry timeout
+    disables the expiry mechanism.
+
+    Call maxThreadCount() to query the maximum number of threads to be used.
+    If needed, you can change the limit with setMaxThreadCount(). The default
+    maxThreadCount() is QThread::idealThreadCount(). The activeThreadCount()
+    function returns the number of threads currently doing work.
+
+    The reserveThread() function reserves a thread for external
+    use. Use releaseThread() when your are done with the thread, so
+    that it may be reused.  Essentially, these functions temporarily
+    increase or reduce the active thread count and are useful when
+    implementing time-consuming operations that are not visible to the
+    QThreadPool.
+
+    Note that QThreadPool is a low-level class for managing threads, see
+    QtConcurrent::run() or the other
+    \l {Concurrent Programming}{Qt Concurrent} APIs for higher
+    level alternatives.
+
+    \sa QRunnable
+*/
+
+/*!
+    Constructs a thread pool with the given \a parent.
+*/
+QThreadPool::QThreadPool(QObject *parent)
+    : QObject(*new QThreadPoolPrivate, parent)
+{ }
+
+/*!
+    Destroys the QThreadPool.
+    This function will block until all runnables have been completed.
+*/
+QThreadPool::~QThreadPool()
+{
+    d_func()->waitForDone();
+    d_func()->reset();
+}
+
+/*!
+    Returns the global QThreadPool instance.
+*/
+QThreadPool *QThreadPool::globalInstance()
+{
+    return theInstance();
+}
+
+/*!
+    Reserves a thread and uses it to run \a runnable, unless this thread will
+    make the current thread count exceed maxThreadCount().  In that case,
+    \a runnable is added to a run queue instead. The \a priority argument can
+    be used to control the run queue's order of execution.
+
+    Note that the thread pool takes ownership of the \a runnable if
+    \l{QRunnable::autoDelete()}{runnable->autoDelete()} returns true,
+    and the \a runnable will be deleted automatically by the thread
+    pool after the \l{QRunnable::run()}{runnable->run()} returns. If
+    \l{QRunnable::autoDelete()}{runnable->autoDelete()} returns false,
+    ownership of \a runnable remains with the caller. Note that
+    changing the auto-deletion on \a runnable after calling this
+    functions results in undefined behavior.
+*/
+void QThreadPool::start(QRunnable *runnable, int priority)
+{
+    if (!runnable)
+        return;
+
+    Q_D(QThreadPool);
+    QMutexLocker locker(&d->mutex);
+    if (!d->tryStart(runnable))
+        d->enqueueTask(runnable, priority);
+}
+
+/*!
+    Attempts to reserve a thread to run \a runnable.
+
+    If no threads are available at the time of calling, then this function
+    does nothing and returns false.  Otherwise, \a runnable is run immediately
+    using one available thread and this function returns true.
+
+    Note that the thread pool takes ownership of the \a runnable if
+    \l{QRunnable::autoDelete()}{runnable->autoDelete()} returns true,
+    and the \a runnable will be deleted automatically by the thread
+    pool after the \l{QRunnable::run()}{runnable->run()} returns. If
+    \l{QRunnable::autoDelete()}{runnable->autoDelete()} returns false,
+    ownership of \a runnable remains with the caller. Note that
+    changing the auto-deletion on \a runnable after calling this
+    function results in undefined behavior.
+*/
+bool QThreadPool::tryStart(QRunnable *runnable)
+{
+    if (!runnable)
+        return false;
+
+    Q_D(QThreadPool);
+
+    // To improve scalability perform a check on the thread count
+    // before locking the mutex.
+    if (d->allThreads.isEmpty() == false && d->activeThreadCount() >= d->maxThreadCount)
+        return false;
+
+    QMutexLocker locker(&d->mutex);
+    return d->tryStart(runnable);
+}
+
+/*! \property QThreadPool::expiryTimeout
+
+    Threads that are unused for \a expiryTimeout milliseconds are considered
+    to have expired and will exit. Such threads will be restarted as needed.
+    The default \a expiryTimeout is 30000 milliseconds (30 seconds). If
+    \a expiryTimeout is negative, newly created threads will not expire, e.g.,
+    they will not exit until the thread pool is destroyed.
+
+    Note that setting \a expiryTimeout has no effect on already running
+    threads. Only newly created threads will use the new \a expiryTimeout.
+    We recommend setting the \a expiryTimeout immediately after creating the
+    thread pool, but before calling start().
+*/
+
+int QThreadPool::expiryTimeout() const
+{
+    Q_D(const QThreadPool);
+    return d->expiryTimeout;
+}
+
+void QThreadPool::setExpiryTimeout(int expiryTimeout)
+{
+    Q_D(QThreadPool);
+    if (d->expiryTimeout == expiryTimeout)
+        return;
+    d->expiryTimeout = expiryTimeout;
+}
+
+/*! \property QThreadPool::maxThreadCount
+
+    This property represents the maximum number of threads used by the thread
+    pool.
+
+    \note The thread pool will always use at least 1 thread, even if
+    \a maxThreadCount limit is zero or negative.
+
+    The default \a maxThreadCount is QThread::idealThreadCount().
+*/
+
+int QThreadPool::maxThreadCount() const
+{
+    Q_D(const QThreadPool);
+    return d->maxThreadCount;
+}
+
+void QThreadPool::setMaxThreadCount(int maxThreadCount)
+{
+    Q_D(QThreadPool);
+    QMutexLocker locker(&d->mutex);
+
+    if (maxThreadCount == d->maxThreadCount)
+        return;
+
+    d->maxThreadCount = maxThreadCount;
+    d->tryToStartMoreThreads();
+}
+
+/*! \property QThreadPool::activeThreadCount
+
+    This property represents the number of active threads in the thread pool.
+
+    \note It is possible for this function to return a value that is greater
+    than maxThreadCount(). See reserveThread() for more details.
+
+    \sa reserveThread(), releaseThread()
+*/
+
+int QThreadPool::activeThreadCount() const
+{
+    Q_D(const QThreadPool);
+    return d->activeThreadCount();
+}
+
+/*!
+    Reserves one thread, disregarding activeThreadCount() and maxThreadCount().
+
+    Once you are done with the thread, call releaseThread() to allow it to be
+    reused.
+
+    \note This function will always increase the number of active threads.
+    This means that by using this function, it is possible for
+    activeThreadCount() to return a value greater than maxThreadCount() .
+
+    \sa releaseThread()
+ */
+void QThreadPool::reserveThread()
+{
+    Q_D(QThreadPool);
+    QMutexLocker locker(&d->mutex);
+    ++d->reservedThreads;
+}
+
+/*!
+    Releases a thread previously reserved by a call to reserveThread().
+
+    \note Calling this function without previously reserving a thread
+    temporarily increases maxThreadCount(). This is useful when a
+    thread goes to sleep waiting for more work, allowing other threads
+    to continue. Be sure to call reserveThread() when done waiting, so
+    that the thread pool can correctly maintain the
+    activeThreadCount().
+
+    \sa reserveThread()
+*/
+void QThreadPool::releaseThread()
+{
+    Q_D(QThreadPool);
+    QMutexLocker locker(&d->mutex);
+    --d->reservedThreads;
+    d->tryToStartMoreThreads();
+}
+
+/*!
+    Waits for each thread to exit and removes all threads from the thread pool.
+*/
+void QThreadPool::waitForDone()
+{
+    Q_D(QThreadPool);
+    d->waitForDone();
+    d->reset();
+}
+
+/*!
+    \overload waitForDone()
+    \since 4.8
+
+    Waits up to \a msecs milliseconds for all threads to exit and removes all 
+    threads from the thread pool. Returns true if all threads were removed; 
+    otherwise it returns false.
+*/
+bool QThreadPool::waitForDone(int msecs)
+{
+    Q_D(QThreadPool);
+    bool rc = d->waitForDone(msecs);
+    if (rc)
+      d->reset();
+    return rc;
+}
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/corelib/thread/qthreadpool.h b/src/corelib/thread/qthreadpool.h
new file mode 100644
index 0000000..9fc023c
--- /dev/null
+++ b/src/corelib/thread/qthreadpool.h
@@ -0,0 +1,95 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTHREADPOOL_H
+#define QTHREADPOOL_H
+
+#include <QtCore/qglobal.h>
+
+#include <QtCore/qthread.h>
+#include <QtCore/qrunnable.h>
+
+#ifndef QT_NO_THREAD
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+
+class QThreadPoolPrivate;
+class Q_CORE_EXPORT QThreadPool : public QObject
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QThreadPool)
+    Q_PROPERTY(int expiryTimeout READ expiryTimeout WRITE setExpiryTimeout)
+    Q_PROPERTY(int maxThreadCount READ maxThreadCount WRITE setMaxThreadCount)
+    Q_PROPERTY(int activeThreadCount READ activeThreadCount)
+    friend class QFutureInterfaceBase;
+
+public:
+    QThreadPool(QObject *parent = 0);
+    ~QThreadPool();
+
+    static QThreadPool *globalInstance();
+
+    void start(QRunnable *runnable, int priority = 0);
+    bool tryStart(QRunnable *runnable);
+
+    int expiryTimeout() const;
+    void setExpiryTimeout(int expiryTimeout);
+
+    int maxThreadCount() const;
+    void setMaxThreadCount(int maxThreadCount);
+
+    int activeThreadCount() const;
+
+    void reserveThread();
+    void releaseThread();
+
+    void waitForDone();
+    bool waitForDone(int msecs);
+};
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QT_NO_THREAD
+
+#endif
diff --git a/src/corelib/thread/qthreadpool_p.h b/src/corelib/thread/qthreadpool_p.h
new file mode 100644
index 0000000..9a7c096
--- /dev/null
+++ b/src/corelib/thread/qthreadpool_p.h
@@ -0,0 +1,107 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QTHREADPOOL_P_H
+#define QTHREADPOOL_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+//
+
+#include "QtCore/qmutex.h"
+#include "QtCore/qwaitcondition.h"
+#include "QtCore/qset.h"
+#include "QtCore/qqueue.h"
+#include "private/qobject_p.h"
+
+#ifndef QT_NO_THREAD
+
+QT_BEGIN_NAMESPACE
+
+class QThreadPoolThread;
+class Q_CORE_EXPORT QThreadPoolPrivate : public QObjectPrivate
+{
+    Q_DECLARE_PUBLIC(QThreadPool)
+    friend class QThreadPoolThread;
+
+public:
+    QThreadPoolPrivate();
+
+    bool tryStart(QRunnable *task);
+    void enqueueTask(QRunnable *task, int priority = 0);
+    int activeThreadCount() const;
+
+    void tryToStartMoreThreads();
+    bool tooManyThreadsActive() const;
+
+    void startThread(QRunnable *runnable = 0);
+    void reset();
+    bool waitForDone(int msecs = -1);
+    bool startFrontRunnable();
+    void stealRunnable(QRunnable *);
+
+    mutable QMutex mutex;
+    QWaitCondition runnableReady;
+    QSet<QThreadPoolThread *> allThreads;
+    QQueue<QThreadPoolThread *> expiredThreads;
+    QList<QPair<QRunnable *, int> > queue;
+    QWaitCondition noActiveThreads;
+
+    bool isExiting;
+    int expiryTimeout;
+    int maxThreadCount;
+    int reservedThreads;
+    int waitingThreads;
+    int activeThreads;
+};
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_THREAD
+#endif
diff --git a/src/corelib/thread/thread.pri b/src/corelib/thread/thread.pri
index ea6f0eb..1eefa60 100644
--- a/src/corelib/thread/thread.pri
+++ b/src/corelib/thread/thread.pri
@@ -2,9 +2,11 @@
 
 # public headers
 HEADERS += thread/qmutex.h \
+           thread/qrunnable.h \
            thread/qreadwritelock.h \
            thread/qsemaphore.h \
            thread/qthread.h \
+           thread/qthreadpool.h \
            thread/qthreadstorage.h \
            thread/qwaitcondition.h \
            thread/qatomic.h \
@@ -17,14 +19,17 @@ HEADERS += thread/qmutex_p.h \
            thread/qmutexpool_p.h \
            thread/qorderedmutexlocker_p.h \
            thread/qreadwritelock_p.h \
-           thread/qthread_p.h
+           thread/qthread_p.h \
+           thread/qthreadpool_p.h
 
 SOURCES += thread/qatomic.cpp \
            thread/qmutex.cpp \
            thread/qreadwritelock.cpp \
+           thread/qrunnable.cpp \
            thread/qmutexpool.cpp \
            thread/qsemaphore.cpp \
            thread/qthread.cpp \
+           thread/qthreadpool.cpp \
            thread/qthreadstorage.cpp
 
 unix:SOURCES += thread/qthread_unix.cpp \
diff --git a/src/modules/qt_concurrent.pri b/src/modules/qt_concurrent.pri
new file mode 100644
index 0000000..eccec12
--- /dev/null
+++ b/src/modules/qt_concurrent.pri
@@ -0,0 +1,15 @@
+QT.concurrent.VERSION = 5.0.0
+QT.concurrent.MAJOR_VERSION = 5
+QT.concurrent.MINOR_VERSION = 0
+QT.concurrent.PATCH_VERSION = 0
+
+QT.concurrent.name = QtConcurrent
+QT.concurrent.bins = $$QT_MODULE_BIN_BASE
+QT.concurrent.includes = $$QT_MODULE_INCLUDE_BASE/QtConcurrent
+QT.concurrent.private_includes = $$QT_MODULE_INCLUDE_BASE/QtConcurrent/$$QT.concurrent.VERSION
+QT.concurrent.sources = $$QT_MODULE_BASE/src/concurrent
+QT.concurrent.libs = $$QT_MODULE_LIB_BASE
+QT.concurrent.plugins = $$QT_MODULE_PLUGIN_BASE
+QT.concurrent.imports = $$QT_MODULE_IMPORT_BASE
+QT.concurrent.depends = core
+QT.concurrent.DEFINES = QT_CONCURRENT_LIB
diff --git a/src/src.pro b/src/src.pro
index 8d750ba..9ef8bf4 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -8,6 +8,7 @@ SRC_SUBDIRS += src_corelib
 SRC_SUBDIRS += src_network src_sql src_gui src_xml src_widgets src_printsupport src_testlib src_platformsupport
 nacl: SRC_SUBDIRS -= src_network src_testlib
 contains(QT_CONFIG, dbus):SRC_SUBDIRS += src_dbus
+contains(QT_CONFIG, concurrent):SRC_SUBDIRS += src_concurrent
 
 contains(QT_CONFIG, no-gui): SRC_SUBDIRS -= src_gui
 
@@ -40,6 +41,8 @@ src_testlib.subdir = $$QT_SOURCE_TREE/src/testlib
 src_testlib.target = sub-testlib
 src_platformsupport.subdir = $$QT_SOURCE_TREE/src/platformsupport
 src_platformsupport.target = sub-platformsupport
+src_concurrent.subdir = $$QT_SOURCE_TREE/src/concurrent
+src_concurrent.target = sub-concurrent
 
 
 #CONFIG += ordered
@@ -50,6 +53,7 @@ src_platformsupport.target = sub-platformsupport
    src_platformsupport.depends = src_corelib src_gui src_network
    src_widgets.depends = src_corelib src_gui src_tools_uic
    src_xml.depends = src_corelib
+   src_concurrent.depends = src_corelib
    src_dbus.depends = src_corelib
    src_network.depends = src_corelib
    src_opengl.depends = src_gui src_widgets
diff --git a/sync.profile b/sync.profile
index cabc8a3..446f8f4 100644
--- a/sync.profile
+++ b/sync.profile
@@ -9,6 +9,7 @@
     "QtNetwork" => "$basedir/src/network",
     "QtTest" => "$basedir/src/testlib",
     "QtDBus" => "$basedir/src/dbus",
+    "QtConcurrent" => "$basedir/src/concurrent",
     "QtPlatformSupport" => "$basedir/src/platformsupport",
 );
 %moduleheaders = ( # restrict the module headers to those found in relative path
@@ -40,6 +41,7 @@
     "qtxmlversion.h" => "QtXmlVersion",
     "qtwidgetsversion.h" => "QtWidgetsVersion",
     "qtprintsupportversion.h" => "QtPrintSupportVersion",
+    "qtconcurrentversion.h" => "QtConcurrentVersion",
     "qtplatformsupportversion.h" => "QtPlatformSupportVersion",
 );
 %mastercontent = (
@@ -50,6 +52,7 @@
     "network" => "#include <QtNetwork/QtNetwork>\n",
     "opengl" => "#include <QtOpenGL/QtOpenGL>\n",
     "xml" => "#include <QtXml/QtXml>\n",
+    "concurrent" => "#include <QtConcurrent/QtConcurrent>\n",
 );
 %modulepris = (
     "QtCore" => "$basedir/src/modules/qt_core.pri",
@@ -62,6 +65,7 @@
     "QtSql" => "$basedir/src/modules/qt_sql.pri",
     "QtTest" => "$basedir/src/modules/qt_testlib.pri",
     "QtXml" => "$basedir/src/modules/qt_xml.pri",
+    "QtConcurrent" => "$basedir/src/modules/qt_concurrent.pri",
     "QtPlatformSupport" => "$basedir/src/modules/qt_platformsupport.pri",
 );
 %explicitheaders = (
diff --git a/tests/auto/auto.pro b/tests/auto/auto.pro
index 4f81c43..1796fa2 100644
--- a/tests/auto/auto.pro
+++ b/tests/auto/auto.pro
@@ -10,6 +10,7 @@ SUBDIRS += \
     testlib \
     tools \
     xml \
+    concurrent \
     other \
     widgets \
 
@@ -21,3 +22,6 @@ cross_compile:                              SUBDIRS -= tools
 mac {
     network.CONFIG += no_check_target
 }
+
+!contains(QT_CONFIG, concurrent): SUBDIRS -= concurrent
+
diff --git a/tests/auto/concurrent/concurrent.pro b/tests/auto/concurrent/concurrent.pro
new file mode 100644
index 0000000..15368ae
--- /dev/null
+++ b/tests/auto/concurrent/concurrent.pro
@@ -0,0 +1,12 @@
+TEMPLATE=subdirs
+SUBDIRS=\
+   qfuture \
+   qfuturesynchronizer \
+   qfuturewatcher \
+   qtconcurrentfilter \
+   qtconcurrentiteratekernel \
+   qtconcurrentmap \
+   qtconcurrentresultstore \
+   qtconcurrentrun \
+   qtconcurrentthreadengine
+
diff --git a/tests/auto/concurrent/qfuture/.gitignore b/tests/auto/concurrent/qfuture/.gitignore
new file mode 100644
index 0000000..77c055c
--- /dev/null
+++ b/tests/auto/concurrent/qfuture/.gitignore
@@ -0,0 +1 @@
+tst_qfuture
diff --git a/tests/auto/concurrent/qfuture/qfuture.pro b/tests/auto/concurrent/qfuture/qfuture.pro
new file mode 100644
index 0000000..a4c7061
--- /dev/null
+++ b/tests/auto/concurrent/qfuture/qfuture.pro
@@ -0,0 +1,5 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qfuture
+QT = concurrent-private testlib concurrent
+SOURCES = tst_qfuture.cpp
+DEFINES += QT_STRICT_ITERATORS
diff --git a/tests/auto/concurrent/qfuture/tst_qfuture.cpp b/tests/auto/concurrent/qfuture/tst_qfuture.cpp
new file mode 100644
index 0000000..3610f8f
--- /dev/null
+++ b/tests/auto/concurrent/qfuture/tst_qfuture.cpp
@@ -0,0 +1,1438 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QCoreApplication>
+#include <QDebug>
+
+#define QFUTURE_TEST
+
+#include <QtTest/QtTest>
+#include <qfuture.h>
+#include <qfuturewatcher.h>
+#include <qtconcurrentresultstore.h>
+#include <qtconcurrentexception.h>
+#include <private/qfutureinterface_p.h>
+
+using namespace QtConcurrent;
+
+// COM interface macro.
+#if defined(Q_OS_WIN) && defined(interface)
+#  undef interface
+#endif
+
+class tst_QFuture: public QObject
+{
+    Q_OBJECT
+private slots:
+    void resultStore();
+    void future();
+    void futureInterface();
+    void refcounting();
+    void cancel();
+    void statePropagation();
+    void multipleResults();
+    void indexedResults();
+    void progress();
+    void progressText();
+    void resultsAfterFinished();
+    void resultsAsList();
+    void implicitConversions();
+    void iterators();
+    void pause();
+    void throttling();
+    void voidConversions();
+#ifndef QT_NO_EXCEPTIONS
+    void exceptions();
+    void nestedExceptions();
+#endif
+};
+
+void tst_QFuture::resultStore()
+{
+    int int0 = 0;
+    int int1 = 1;
+    int int2 = 2;
+
+    {
+        ResultStore<int> store;
+        QVERIFY(store.begin() == store.end());
+        QVERIFY(store.resultAt(0) == store.end());
+        QVERIFY(store.resultAt(1) == store.end());
+    }
+
+
+    {
+        ResultStoreBase store;
+        store.addResult(-1, &int0); // note to self: adding a pointer to the stack here is ok since
+        store.addResult(1, &int1);  // ResultStoreBase does not take ownership, only ResultStore<> does.
+        ResultIteratorBase it = store.begin();
+        QCOMPARE(it.resultIndex(), 0);
+        QVERIFY(it == store.begin());
+        QVERIFY(it != store.end());
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 1);
+        QVERIFY(it != store.begin());
+        QVERIFY(it != store.end());
+
+        ++it;
+        QVERIFY(it != store.begin());
+        QVERIFY(it == store.end());
+    }
+
+    QVector<int> vec0 = QVector<int>() << 2 << 3;
+    QVector<int> vec1 = QVector<int>() << 4 << 5;
+
+    {
+        ResultStoreBase store;
+        store.addResults(-1, &vec0, 2, 2);
+        store.addResults(-1, &vec1, 2, 2);
+        ResultIteratorBase it = store.begin();
+        QCOMPARE(it.resultIndex(), 0);
+        QVERIFY(it == store.begin());
+        QVERIFY(it != store.end());
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 1);
+        QVERIFY(it != store.begin());
+        QVERIFY(it != store.end());
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 2);
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 3);
+
+        ++it;
+        QVERIFY(it == store.end());
+    }
+    {
+        ResultStoreBase store;
+        store.addResult(-1, &int0);
+        store.addResults(-1, &vec1, 2, 2);
+        store.addResult(-1, &int1);
+
+        ResultIteratorBase it = store.begin();
+        QCOMPARE(it.resultIndex(), 0);
+        QVERIFY(it == store.begin());
+        QVERIFY(it != store.end());
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 1);
+        QVERIFY(it != store.begin());
+        QVERIFY(it != store.end());
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 2);
+        QVERIFY(it != store.end());
+        ++it;
+        QCOMPARE(it.resultIndex(), 3);
+        QVERIFY(it != store.end());
+        ++it;
+        QVERIFY(it == store.end());
+
+        QCOMPARE(store.resultAt(0).resultIndex(), 0);
+        QCOMPARE(store.resultAt(1).resultIndex(), 1);
+        QCOMPARE(store.resultAt(2).resultIndex(), 2);
+        QCOMPARE(store.resultAt(3).resultIndex(), 3);
+        QCOMPARE(store.resultAt(4), store.end());
+    }
+    {
+        ResultStore<int> store;
+        store.addResult(-1, &int0);
+        store.addResults(-1, &vec0);
+        store.addResult(-1, &int1);
+
+        ResultIteratorBase it = store.begin();
+        QCOMPARE(it.resultIndex(), 0);
+        QVERIFY(it == store.begin());
+        QVERIFY(it != store.end());
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 1);
+        QVERIFY(it != store.begin());
+        QVERIFY(it != store.end());
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 2);
+        QVERIFY(it != store.end());
+        ++it;
+        QCOMPARE(it.resultIndex(), 3);
+        QVERIFY(it != store.end());
+        ++it;
+        QVERIFY(it == store.end());
+
+        QCOMPARE(store.resultAt(0).value(), int0);
+        QCOMPARE(store.resultAt(1).value(), vec0[0]);
+        QCOMPARE(store.resultAt(2).value(), vec0[1]);
+        QCOMPARE(store.resultAt(3).value(), int1);
+    }
+    {
+        ResultStore<int> store;
+        store.addResult(-1, &int0);
+        store.addResults(-1, &vec0);
+        store.addResult(200, &int1);
+
+        QCOMPARE(store.resultAt(0).value(), int0);
+        QCOMPARE(store.resultAt(1).value(), vec0[0]);
+        QCOMPARE(store.resultAt(2).value(), vec0[1]);
+        QCOMPARE(store.resultAt(200).value(), int1);
+    }
+
+    {
+        ResultStore<int> store;
+        store.addResult(1, &int1);
+        store.addResult(0, &int0);
+        store.addResult(-1, &int2);
+
+        QCOMPARE(store.resultAt(0).value(), int0);
+        QCOMPARE(store.resultAt(1).value(), int1);
+        QCOMPARE(store.resultAt(2).value(), int2);
+    }
+
+    {
+        ResultStore<int> store;
+        QCOMPARE(store.contains(0), false);
+        QCOMPARE(store.contains(1), false);
+        QCOMPARE(store.contains(INT_MAX), false);
+    }
+
+    {
+        // Test filter mode, where "gaps" in the result array aren't allowed.
+        ResultStore<int> store;
+        store.setFilterMode(true);
+
+        store.addResult(0, &int0);
+        QCOMPARE(store.contains(0), true);
+
+        store.addResult(2, &int2); // add result at index 2
+        QCOMPARE(store.contains(2), false); // but 1 is missing, so this 2 won't be reported yet.
+
+        store.addResult(1, &int1); 
+        QCOMPARE(store.contains(1), true);
+        QCOMPARE(store.contains(2), true); // 2 should be visible now.
+
+        store.addResult(4, &int0); 
+        store.addResult(5, &int0); 
+        store.addResult(7, &int0); 
+        QCOMPARE(store.contains(4), false);
+        QCOMPARE(store.contains(5), false);
+        QCOMPARE(store.contains(7), false);
+
+        store.addResult(3, &int0);  // adding 3 makes 4 and 5 visible
+        QCOMPARE(store.contains(4), true);
+        QCOMPARE(store.contains(5), true);
+        QCOMPARE(store.contains(7), false);
+
+        store.addResult(6, &int0);  // adding 6 makes 7 visible
+
+        QCOMPARE(store.contains(6), true);
+        QCOMPARE(store.contains(7), true);
+        QCOMPARE(store.contains(8), false);
+    }
+
+    {
+        // test canceled results
+        ResultStore<int> store;
+        store.setFilterMode(true);
+
+        store.addResult(0, &int0);
+        QCOMPARE(store.contains(0), true);
+        
+        store.addResult(2, &int0);
+        QCOMPARE(store.contains(2), false);       
+
+        store.addCanceledResult(1); // report no result at 1
+
+        QCOMPARE(store.contains(0), true);
+        QCOMPARE(store.contains(1), true); // 2 gets renamed to 1
+        QCOMPARE(store.contains(2), false);
+
+        store.addResult(3, &int0);
+        QCOMPARE(store.contains(2), true); //3 gets renamed to 2
+
+        store.addResult(6, &int0);
+        store.addResult(7, &int0);
+        QCOMPARE(store.contains(3), false);
+ 
+        store.addCanceledResult(4);
+        store.addCanceledResult(5);
+
+        QCOMPARE(store.contains(3), true); //6 gets renamed to 3
+        QCOMPARE(store.contains(4), true); //7 gets renamed to 4
+
+        store.addResult(8, &int0);
+        QCOMPARE(store.contains(5), true); //8 gets renamed to 4
+
+        QCOMPARE(store.contains(6), false);
+        QCOMPARE(store.contains(7), false);
+    }
+
+    {
+        // test addResult return value
+        ResultStore<int> store;
+        store.setFilterMode(true);
+
+        store.addResult(0, &int0);
+        QCOMPARE(store.count(), 1); // result 0 becomes available
+        QCOMPARE(store.contains(0), true);
+        
+        store.addResult(2, &int0);
+        QCOMPARE(store.count(), 1);
+        QCOMPARE(store.contains(2), false);       
+
+        store.addCanceledResult(1);
+        QCOMPARE(store.count(), 2); // result 2 is renamed to 1 and becomes available
+
+        QCOMPARE(store.contains(0), true);
+        QCOMPARE(store.contains(1), true);
+        QCOMPARE(store.contains(2), false);
+
+        store.addResult(3, &int0);
+        QCOMPARE(store.count(), 3);
+        QCOMPARE(store.contains(2), true);
+
+        store.addResult(6, &int0);
+        QCOMPARE(store.count(), 3);
+        store.addResult(7, &int0);
+        QCOMPARE(store.count(), 3);
+        QCOMPARE(store.contains(3), false);
+ 
+        store.addCanceledResult(4);
+        store.addCanceledResult(5);
+        QCOMPARE(store.count(), 5); // 6 and 7 is renamed to 3 and 4 and becomes available
+
+        QCOMPARE(store.contains(3), true);
+        QCOMPARE(store.contains(4), true);
+
+        store.addResult(8, &int0);
+        QCOMPARE(store.contains(5), true);
+        QCOMPARE(store.count(), 6);
+
+        QCOMPARE(store.contains(6), false);
+        QCOMPARE(store.contains(7), false);
+    }
+    
+    {
+        // test resultCount in non-filtered mode. It should always be possible
+        // to iterate through the results 0 to resultCount.
+        ResultStore<int> store;
+        store.addResult(0, &int0);
+        
+        QCOMPARE(store.count(), 1);
+
+        store.addResult(2, &int0);
+
+        QCOMPARE(store.count(), 1);
+
+        store.addResult(1, &int0);
+        QCOMPARE(store.count(), 3);
+    }
+
+    {
+        ResultStore<int> store;
+        store.addResult(2, &int0);
+        QCOMPARE(store.count(), 0);
+
+        store.addResult(1, &int0);
+        QCOMPARE(store.count(), 0);
+
+        store.addResult(0, &int0);
+        QCOMPARE(store.count(), 3);
+    }
+
+    {
+        ResultStore<int> store;
+        store.addResults(2, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addResult(1, &int0);
+        QCOMPARE(store.count(), 0);
+
+        store.addResult(0, &int0);
+        QCOMPARE(store.count(), 4);
+    }
+
+    {
+        ResultStore<int> store;
+        store.addResults(2, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addResults(0, &vec0);
+        QCOMPARE(store.count(), 4);
+    }
+    {
+        ResultStore<int> store;
+        store.addResults(3, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addResults(0, &vec0);
+        QCOMPARE(store.count(), 2);
+
+        store.addResult(2, &int0);
+        QCOMPARE(store.count(), 5);
+    }
+
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addResults(3, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addResults(0, &vec0);
+        QCOMPARE(store.count(), 2);
+
+        store.addCanceledResult(2);
+        QCOMPARE(store.count(), 4);
+    }
+
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addResults(3, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addCanceledResults(0, 3);
+        QCOMPARE(store.count(), 2);
+    }
+
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addResults(3, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addCanceledResults(0, 3);
+        QCOMPARE(store.count(), 2);  // results at 3 and 4 become available at index 0, 1
+
+        store.addResult(5, &int0); 
+        QCOMPARE(store.count(), 3);// result 5 becomes available at index 2
+    }
+
+    {
+        ResultStore<int> store;
+        store.addResult(1, &int0);
+        store.addResult(3, &int0);
+        store.addResults(6, &vec0);
+        QCOMPARE(store.contains(0), false);
+        QCOMPARE(store.contains(1), true);
+        QCOMPARE(store.contains(2), false);
+        QCOMPARE(store.contains(3), true);
+        QCOMPARE(store.contains(4), false);
+        QCOMPARE(store.contains(5), false);
+        QCOMPARE(store.contains(6), true);
+        QCOMPARE(store.contains(7), true);
+    }
+
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addResult(1, &int0);
+        store.addResult(3, &int0);
+        store.addResults(6, &vec0);
+        QCOMPARE(store.contains(0), false);
+        QCOMPARE(store.contains(1), false);
+        QCOMPARE(store.contains(2), false);
+        QCOMPARE(store.contains(3), false);
+        QCOMPARE(store.contains(4), false);
+        QCOMPARE(store.contains(5), false);
+        QCOMPARE(store.contains(6), false);
+        QCOMPARE(store.contains(7), false);
+
+        store.addCanceledResult(0);
+        store.addCanceledResult(2);
+        store.addCanceledResults(4, 2);
+
+        QCOMPARE(store.contains(0), true);
+        QCOMPARE(store.contains(1), true);
+        QCOMPARE(store.contains(2), true);
+        QCOMPARE(store.contains(3), true);
+        QCOMPARE(store.contains(4), false);
+        QCOMPARE(store.contains(5), false);
+        QCOMPARE(store.contains(6), false);
+        QCOMPARE(store.contains(7), false);
+    }
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addCanceledResult(0);
+        QCOMPARE(store.contains(0), false);
+
+        store.addResult(1, &int0);
+        QCOMPARE(store.contains(0), true);
+        QCOMPARE(store.contains(1), false);
+    }
+}
+
+void tst_QFuture::future()
+{
+    // default constructors
+    QFuture<int> intFuture;
+    intFuture.waitForFinished();
+    QFuture<QString> stringFuture;
+    stringFuture.waitForFinished();
+    QFuture<void> voidFuture;
+    voidFuture.waitForFinished();
+    QFuture<void> defaultVoidFuture;
+    defaultVoidFuture.waitForFinished();
+
+    // copy constructor
+    QFuture<int> intFuture2(intFuture);
+    QFuture<void> voidFuture2(defaultVoidFuture);
+
+    // assigmnent operator
+    intFuture2 = QFuture<int>();
+    voidFuture2 = QFuture<void>();
+
+    // state
+    QCOMPARE(intFuture2.isStarted(), true);
+    QCOMPARE(intFuture2.isFinished(), true);
+}
+
+class IntResult : public QFutureInterface<int>
+{
+public:
+    QFuture<int> run()
+    {
+        this->reportStarted();
+        QFuture<int> future = QFuture<int>(this);
+
+        int res = 10;
+        reportFinished(&res);
+        return future;
+    }
+};
+
+int value = 10;
+
+class VoidResult : public QFutureInterfaceBase
+{
+public:
+    QFuture<void> run()
+    {
+        this->reportStarted();
+        QFuture<void> future = QFuture<void>(this);
+        reportFinished();
+        return future;
+    }
+};
+
+void tst_QFuture::futureInterface()
+{
+    {
+        QFuture<void> future;
+        {
+            QFutureInterface<void> i;
+            i.reportStarted();
+            future = i.future();
+            i.reportFinished();
+        }
+    }
+    {
+        QFuture<int> future;
+        {
+            QFutureInterface<int> i;
+            i.reportStarted();
+            i.reportResult(10);
+            future = i.future();
+            i.reportFinished();
+        }
+        QCOMPARE(future.resultAt(0), 10);
+    }
+
+    {
+        QFuture<int> intFuture;
+
+        QCOMPARE(intFuture.isStarted(), true);
+        QCOMPARE(intFuture.isFinished(), true);
+
+        IntResult result;
+
+        result.reportStarted();
+        intFuture = result.future();
+
+        QCOMPARE(intFuture.isStarted(), true);
+        QCOMPARE(intFuture.isFinished(), false);
+
+        result.reportFinished(&value);
+
+        QCOMPARE(intFuture.isStarted(), true);
+        QCOMPARE(intFuture.isFinished(), true);
+
+        int e = intFuture.result();
+
+        QCOMPARE(intFuture.isStarted(), true);
+        QCOMPARE(intFuture.isFinished(), true);
+        QCOMPARE(intFuture.isCanceled(), false);
+
+        QCOMPARE(e, value);
+        intFuture.waitForFinished();
+
+        IntResult intAlgo;
+        intFuture = intAlgo.run();
+        QFuture<int> intFuture2(intFuture);
+        QCOMPARE(intFuture.result(), value);
+        QCOMPARE(intFuture2.result(), value);
+        intFuture.waitForFinished();
+
+        VoidResult a;
+        a.run().waitForFinished();
+    }
+}
+
+template <typename T>
+void testRefCounting()
+{
+    QFutureInterface<T> interface;
+    QCOMPARE(interface.d->refCount.load(), 1);
+
+    {
+        interface.reportStarted();
+
+        QFuture<T> f = interface.future();
+        QCOMPARE(interface.d->refCount.load(), 2);
+
+        QFuture<T> f2(f);
+        QCOMPARE(interface.d->refCount.load(), 3);
+
+        QFuture<T> f3;
+        f3 = f2;
+        QCOMPARE(interface.d->refCount.load(), 4);
+
+        interface.reportFinished(0);
+        QCOMPARE(interface.d->refCount.load(), 4);
+    }
+
+    QCOMPARE(interface.d->refCount.load(), 1);
+}
+
+void tst_QFuture::refcounting()
+{
+    testRefCounting<int>();
+}
+
+void tst_QFuture::cancel()
+{
+    {
+        QFuture<void> f;
+        QFutureInterface<void> result;
+
+        result.reportStarted();
+        f = result.future();
+        QVERIFY(f.isCanceled() == false);
+        result.reportCanceled();
+        QVERIFY(f.isCanceled());
+        result.reportFinished();
+        QVERIFY(f.isCanceled());
+        f.waitForFinished();
+        QVERIFY(f.isCanceled());
+    }
+
+    // Cancel from the QFuture side and test if the result
+    // interface detects it.
+    {
+        QFutureInterface<void> result;
+
+        QFuture<void> f;
+        QVERIFY(f.isStarted() == true);
+
+        result.reportStarted();
+        f = result.future();
+
+        QVERIFY(f.isStarted() == true);
+
+        QVERIFY(result.isCanceled() == false);
+        f.cancel();
+
+        QVERIFY(result.isCanceled());
+
+        result.reportFinished();
+    }
+
+    // Test that finished futures can be canceled.
+    {
+        QFutureInterface<void> result;
+
+        QFuture<void> f;
+        QVERIFY(f.isStarted() == true);
+
+        result.reportStarted();
+        f = result.future();
+
+        QVERIFY(f.isStarted() == true);
+
+        result.reportFinished();
+
+        f.cancel();
+
+        QVERIFY(result.isCanceled());
+        QVERIFY(f.isCanceled());
+    }
+
+    // Results reported after canceled is called should not be propagated.
+    {
+
+        QFutureInterface<int> futureInterface;
+        futureInterface.reportStarted();
+        QFuture<int> f = futureInterface.future();
+
+        int result = 0;
+        futureInterface.reportResult(&result);
+        result = 1;
+        futureInterface.reportResult(&result);
+        f.cancel();
+        result = 2;
+        futureInterface.reportResult(&result);
+        result = 3;
+        futureInterface.reportResult(&result);
+        futureInterface.reportFinished();
+        QCOMPARE(f.results(), QList<int>());
+    }
+}
+
+void tst_QFuture::statePropagation()
+{
+    QFuture<void> f1;
+    QFuture<void> f2;
+
+    QCOMPARE(f1.isStarted(), true);
+
+    QFutureInterface<void> result;
+    result.reportStarted();
+    f1 = result.future();
+
+    f2 = f1;
+
+    QCOMPARE(f2.isStarted(), true);
+
+    result.reportCanceled();
+
+    QCOMPARE(f2.isStarted(), true);
+    QCOMPARE(f2.isCanceled(), true);
+
+    QFuture<void> f3 = f2;
+
+    QCOMPARE(f3.isStarted(), true);
+    QCOMPARE(f3.isCanceled(), true);
+
+    result.reportFinished();
+
+    QCOMPARE(f2.isStarted(), true);
+    QCOMPARE(f2.isCanceled(), true);
+
+    QCOMPARE(f3.isStarted(), true);
+    QCOMPARE(f3.isCanceled(), true);
+}
+
+/*
+    Tests that a QFuture can return multiple results.
+*/
+void tst_QFuture::multipleResults()
+{
+    IntResult a;
+    a.reportStarted();
+    QFuture<int> f = a.future();
+
+    QFuture<int> copy = f;
+    int result;
+
+    result = 1;
+    a.reportResult(&result);
+    QCOMPARE(f.resultAt(0), 1);
+
+    result = 2;
+    a.reportResult(&result);
+    QCOMPARE(f.resultAt(1), 2);
+
+    result = 3;
+    a.reportResult(&result);
+
+    result = 4;
+    a.reportFinished(&result);
+
+    QCOMPARE(f.results(), QList<int>() << 1 << 2 << 3 << 4);
+
+    // test foreach
+    QList<int> fasit = QList<int>() << 1 << 2 << 3 << 4;
+    {
+        QList<int> results;
+        foreach(int result, f)
+            results.append(result);
+        QCOMPARE(results, fasit);
+    }
+    {
+        QList<int> results;
+        foreach(int result, copy)
+            results.append(result);
+        QCOMPARE(results, fasit);
+    }
+}
+
+/*
+    Test out-of-order result reporting using indexes
+*/
+void tst_QFuture::indexedResults()
+{
+    {
+        QFutureInterface<QChar> Interface;
+        QFuture<QChar> f;
+        QVERIFY(f.isStarted() == true);
+
+        Interface.reportStarted();
+        f = Interface.future();
+
+        QVERIFY(f.isStarted() == true);
+
+        QChar result;
+
+        result = 'B';
+        Interface.reportResult(&result, 1);
+
+        QCOMPARE(f.resultAt(1), result);
+
+        result = 'A';
+        Interface.reportResult(&result, 0);
+        QCOMPARE(f.resultAt(0), result);
+
+        result = 'C';
+        Interface.reportResult(&result); // no index
+        QCOMPARE(f.resultAt(2), result);
+
+        Interface.reportFinished();
+
+        QCOMPARE(f.results(), QList<QChar>() << 'A' << 'B' << 'C');
+    }
+
+    {
+        // Test result reporting with a missing result in the middle
+        QFutureInterface<int> Interface;
+        Interface.reportStarted();
+        QFuture<int> f = Interface.future();
+        int result;
+
+        result = 0;
+        Interface.reportResult(&result, 0);
+        QVERIFY(f.isResultReadyAt(0));
+        QCOMPARE(f.resultAt(0), 0);
+
+        result = 3;
+        Interface.reportResult(&result, 3);
+        QVERIFY(f.isResultReadyAt(3));
+        QCOMPARE(f.resultAt(3), 3);
+
+        result = 2;
+        Interface.reportResult(&result, 2);
+        QVERIFY(f.isResultReadyAt(2));
+        QCOMPARE(f.resultAt(2), 2);
+
+        result = 4;
+        Interface.reportResult(&result); // no index
+        QVERIFY(f.isResultReadyAt(4));
+        QCOMPARE(f.resultAt(4), 4);
+
+        Interface.reportFinished();
+
+        QCOMPARE(f.results(), QList<int>() << 0 << 2 << 3 << 4);
+    }
+}
+
+void tst_QFuture::progress()
+{
+    QFutureInterface<QChar> result;
+    QFuture<QChar> f;
+
+    QCOMPARE (f.progressValue(), 0);
+
+    result.reportStarted();
+    f = result.future();
+
+    QCOMPARE (f.progressValue(), 0);
+
+    result.setProgressValue(50);
+
+    QCOMPARE (f.progressValue(), 50);
+
+    result.reportFinished();
+
+    QCOMPARE (f.progressValue(), 50);
+}
+
+void tst_QFuture::progressText()
+{
+    QFutureInterface<void> i;
+    i.reportStarted();
+    QFuture<void> f = i.future();
+
+    QCOMPARE(f.progressText(), QLatin1String(""));
+    i.setProgressValueAndText(1, QLatin1String("foo"));
+    QCOMPARE(f.progressText(), QLatin1String("foo"));
+    i.reportFinished();
+}
+
+/*
+    Test that results reported after finished are ignored.
+*/
+void tst_QFuture::resultsAfterFinished()
+{
+    {
+        IntResult a;
+        a.reportStarted();
+        QFuture<int> f =  a.future();
+        int result;
+
+        QCOMPARE(f.resultCount(), 0);
+
+        result = 1;
+        a.reportResult(&result);
+        QCOMPARE(f.resultAt(0), 1);
+
+        a.reportFinished();
+
+        QCOMPARE(f.resultAt(0), 1);
+        QCOMPARE(f.resultCount(), 1);
+        result = 2;
+        a.reportResult(&result);
+        QCOMPARE(f.resultCount(), 1);
+    }
+    // cancel it
+    {
+        IntResult a;
+        a.reportStarted();
+        QFuture<int> f =  a.future();
+        int result;
+
+        QCOMPARE(f.resultCount(), 0);
+
+        result = 1;
+        a.reportResult(&result);
+        QCOMPARE(f.resultAt(0), 1);
+        QCOMPARE(f.resultCount(), 1);
+
+        a.reportCanceled();
+
+        QCOMPARE(f.resultAt(0), 1);
+        QCOMPARE(f.resultCount(), 1);
+
+        result = 2;
+        a.reportResult(&result);
+        a.reportFinished();
+    }
+}
+
+void tst_QFuture::resultsAsList()
+{
+    IntResult a;
+    a.reportStarted();
+    QFuture<int> f = a.future();
+
+    int result;
+    result = 1;
+    a.reportResult(&result);
+    result = 2;
+    a.reportResult(&result);
+
+    a.reportFinished();
+
+    QList<int> results = f.results();
+    QCOMPARE(results, QList<int>() << 1 << 2);
+}
+
+/*
+    Test that QFuture<T> can be implicitly converted to T
+*/
+void tst_QFuture::implicitConversions()
+{
+    QFutureInterface<QString> iface;
+    iface.reportStarted();
+
+    QFuture<QString> f(&iface);
+
+    const QString input("FooBar 2000");
+    iface.reportFinished(&input);
+
+    const QString result = f;
+    QCOMPARE(result, input);
+    QCOMPARE(QString(f), input);
+    QCOMPARE(static_cast<QString>(f), input);
+}
+
+void tst_QFuture::iterators()
+{
+    {
+        QFutureInterface<int> e;
+        e.reportStarted();
+        QFuture<int> f = e.future();
+
+        int result;
+        result = 1;
+        e.reportResult(&result);
+        result = 2;
+        e.reportResult(&result);
+        result = 3;
+        e.reportResult(&result);
+        e.reportFinished();
+
+        QList<int> results;
+        QFutureIterator<int> i(f);
+        while (i.hasNext()) {
+            results.append(i.next());
+        }
+
+        QCOMPARE(results, f.results());
+
+        QFuture<int>::const_iterator i1 = f.begin(), i2 = i1 + 1;
+        QFuture<int>::const_iterator c1 = i1, c2 = c1 + 1;
+
+        QVERIFY(i1 == i1);
+        QVERIFY(i1 == c1);
+        QVERIFY(c1 == i1);
+        QVERIFY(c1 == c1);
+        QVERIFY(i2 == i2);
+        QVERIFY(i2 == c2);
+        QVERIFY(c2 == i2);
+        QVERIFY(c2 == c2);
+
+        QVERIFY(i1 != i2);
+        QVERIFY(i1 != c2);
+        QVERIFY(c1 != i2);
+        QVERIFY(c1 != c2);
+        QVERIFY(i2 != i1);
+        QVERIFY(i2 != c1);
+        QVERIFY(c2 != i1);
+        QVERIFY(c2 != c1);
+
+        int x1 = *i1;
+        Q_UNUSED(x1);
+        int x2 = *i2;
+        Q_UNUSED(x2);
+        int y1 = *c1;
+        Q_UNUSED(y1);
+        int y2 = *c2;
+        Q_UNUSED(y2);
+    }
+
+    {
+        QFutureInterface<QString> e;
+        e.reportStarted();
+        QFuture<QString> f =  e.future();
+
+        e.reportResult(QString("one"));
+        e.reportResult(QString("two"));
+        e.reportResult(QString("three"));
+        e.reportFinished();
+
+        QList<QString> results;
+        QFutureIterator<QString> i(f);
+        while (i.hasNext()) {
+            results.append(i.next());
+        }
+
+        QCOMPARE(results, f.results());
+
+        QFuture<QString>::const_iterator i1 = f.begin(), i2 = i1 + 1;
+        QFuture<QString>::const_iterator c1 = i1, c2 = c1 + 1;
+
+        QVERIFY(i1 == i1);
+        QVERIFY(i1 == c1);
+        QVERIFY(c1 == i1);
+        QVERIFY(c1 == c1);
+        QVERIFY(i2 == i2);
+        QVERIFY(i2 == c2);
+        QVERIFY(c2 == i2);
+        QVERIFY(c2 == c2);
+
+        QVERIFY(i1 != i2);
+        QVERIFY(i1 != c2);
+        QVERIFY(c1 != i2);
+        QVERIFY(c1 != c2);
+        QVERIFY(i2 != i1);
+        QVERIFY(i2 != c1);
+        QVERIFY(c2 != i1);
+        QVERIFY(c2 != c1);
+
+        QString x1 = *i1;
+        QString x2 = *i2;
+        QString y1 = *c1;
+        QString y2 = *c2;
+
+        QCOMPARE(x1, y1);
+        QCOMPARE(x2, y2);
+
+        int i1Size = i1->size();
+        int i2Size = i2->size();
+        int c1Size = c1->size();
+        int c2Size = c2->size();
+
+        QCOMPARE(i1Size, c1Size);
+        QCOMPARE(i2Size, c2Size);
+    }
+
+    {
+        const int resultCount = 20;
+
+        QFutureInterface<int> e;
+        e.reportStarted();
+        QFuture<int> f =  e.future();
+
+        for (int i = 0; i < resultCount; ++i) {
+            e.reportResult(i);
+        }
+    
+        e.reportFinished();
+    
+        {
+            QFutureIterator<int> it(f);
+            QFutureIterator<int> it2(it);
+        }
+
+        {
+            QFutureIterator<int> it(f);
+    
+            for (int i = 0; i < resultCount - 1; ++i) {
+                QVERIFY(it.hasNext());
+                QCOMPARE(it.peekNext(), i);
+                QCOMPARE(it.next(), i);
+            }
+
+            QVERIFY(it.hasNext());
+            QCOMPARE(it.peekNext(), resultCount - 1);
+            QCOMPARE(it.next(), resultCount - 1);
+            QVERIFY(it.hasNext() == false);
+        }
+
+        {
+            QFutureIterator<int> it(f);
+            QVERIFY(it.hasNext());
+            it.toBack();
+            QVERIFY(it.hasNext() == false);
+            it.toFront();
+            QVERIFY(it.hasNext());
+        }
+    }
+}
+
+class SignalSlotObject : public QObject
+{
+Q_OBJECT
+public:
+    SignalSlotObject()
+    : finishedCalled(false),
+      canceledCalled(false),
+      rangeBegin(0),
+      rangeEnd(0) { }
+
+public slots:
+    void finished()
+    {
+        finishedCalled = true;
+    }
+
+    void canceled()
+    {
+        canceledCalled = true;
+    }
+
+    void resultReady(int index)
+    {
+        results.insert(index);
+    }
+
+    void progressRange(int begin, int end)
+    {
+        rangeBegin = begin;
+        rangeEnd = end;
+    }
+
+    void progress(int progress)
+    {
+        reportedProgress.insert(progress);
+    }
+public:
+    bool finishedCalled;
+    bool canceledCalled;
+    QSet<int> results;
+    int rangeBegin;
+    int rangeEnd;
+    QSet<int> reportedProgress;
+};
+
+void tst_QFuture::pause()
+{
+    QFutureInterface<void> Interface;
+
+    Interface.reportStarted();
+    QFuture<void> f = Interface.future();
+
+    QVERIFY(Interface.isPaused() == false);
+    f.pause();
+    QVERIFY(Interface.isPaused() == true);
+    f.resume();
+    QVERIFY(Interface.isPaused() == false);
+    f.togglePaused();
+    QVERIFY(Interface.isPaused() == true);
+    f.togglePaused();
+    QVERIFY(Interface.isPaused() == false);
+
+    Interface.reportFinished();
+}
+
+const int resultCount = 1000;
+
+class ResultObject : public QObject
+{
+Q_OBJECT
+public slots:
+    void resultReady(int)
+    {
+
+    }
+public:
+};
+
+// Test that that the isPaused() on future result interface returns true
+// if we report a lot of results that are not handled.
+void tst_QFuture::throttling()
+{
+    {
+        QFutureInterface<void> i;
+
+        i.reportStarted();
+        QFuture<void> f = i.future();
+
+        QVERIFY(i.isThrottled() == false);
+
+        i.setThrottled(true);
+        QVERIFY(i.isThrottled());
+
+        i.setThrottled(false);
+        QVERIFY(i.isThrottled() == false);
+
+        i.setThrottled(true);
+        QVERIFY(i.isThrottled());
+
+        i.reportFinished();
+    }
+}
+
+void tst_QFuture::voidConversions()
+{
+    QFutureInterface<int> iface;
+    iface.reportStarted();
+
+    QFuture<int> intFuture(&iface);
+
+    int value = 10;
+    iface.reportFinished(&value);
+
+    QFuture<void> voidFuture(intFuture);
+    voidFuture = intFuture;
+
+    QVERIFY(voidFuture == intFuture);
+}
+
+
+#ifndef QT_NO_EXCEPTIONS
+
+QFuture<void> createExceptionFuture()
+{
+    QFutureInterface<void> i;
+    i.reportStarted();
+    QFuture<void> f = i.future();
+
+    Exception e;
+    i.reportException(e);
+    i.reportFinished();
+    return f;
+}
+
+QFuture<int> createExceptionResultFuture()
+{
+    QFutureInterface<int> i;
+    i.reportStarted();
+    QFuture<int> f = i.future();
+    int r = 0;
+    i.reportResult(r);
+
+    Exception e;
+    i.reportException(e);
+    i.reportFinished();
+    return f;
+}
+
+class DerivedException : public Exception
+{
+public:
+    void raise() const { throw *this; }
+    Exception *clone() const { return new DerivedException(*this); }
+};
+
+QFuture<void> createDerivedExceptionFuture()
+{
+    QFutureInterface<void> i;
+    i.reportStarted();
+    QFuture<void> f = i.future();
+
+    DerivedException e;
+    i.reportException(e);
+    i.reportFinished();
+    return f;
+}
+
+void tst_QFuture::exceptions()
+{
+    // test throwing from waitForFinished
+    {
+        QFuture<void> f = createExceptionFuture();
+        bool caught = false;
+        try {
+            f.waitForFinished();
+        } catch (Exception &) {
+            caught = true;
+        }
+        QVERIFY(caught);
+    }
+
+    // test result()
+    {
+        QFuture<int> f = createExceptionResultFuture();
+        bool caught = false;
+        try {
+            f.result();
+        } catch (Exception &) {
+            caught = true;
+        }
+        QVERIFY(caught);
+    }
+
+    // test result() and destroy
+    {
+        bool caught = false;
+        try {
+            createExceptionResultFuture().result();
+        } catch (Exception &) {
+            caught = true;
+        }
+        QVERIFY(caught);
+    }
+
+    // test results()
+    {
+        QFuture<int> f = createExceptionResultFuture();
+        bool caught = false;
+        try {
+            f.results();
+        } catch (Exception &) {
+            caught = true;
+        }
+        QVERIFY(caught);
+    }
+
+    // test foreach
+    {
+        QFuture<int> f = createExceptionResultFuture();
+        bool caught = false;
+        try {
+            foreach (int e, f.results()) {
+                Q_UNUSED(e);
+                QFAIL("did not get exception");
+            }
+        } catch (Exception &) {
+            caught = true;
+        }
+        QVERIFY(caught);
+    }
+
+    // catch derived exceptions
+    {
+        bool caught = false;
+        try {
+            createDerivedExceptionFuture().waitForFinished();
+        } catch (Exception &) {
+            caught = true;
+        }
+        QVERIFY(caught);
+    }
+
+    {
+        bool caught = false;
+        try {
+            createDerivedExceptionFuture().waitForFinished();
+        } catch (DerivedException &) {
+            caught = true;
+        }
+        QVERIFY(caught);
+    }
+}
+
+class MyClass
+{
+public:
+    ~MyClass()
+    {
+        QFuture<void> f = createExceptionFuture();
+        try {
+            f.waitForFinished();
+        } catch (Exception &) {
+            caught = true;
+        }
+    }
+    static bool caught;
+};
+
+bool MyClass::caught = false;
+
+// This is a regression test for QTBUG-18149. where QFuture did not throw
+// exceptions if called from destructors when the stack was already unwinding
+// due to an exception having been thrown.
+void tst_QFuture::nestedExceptions()
+{
+    try {
+        MyClass m;
+        Q_UNUSED(m);
+        throw 0;
+    } catch (int) {}
+
+    QVERIFY(MyClass::caught);
+}
+
+#endif // QT_NO_EXCEPTIONS
+
+QTEST_MAIN(tst_QFuture)
+#include "tst_qfuture.moc"
diff --git a/tests/auto/concurrent/qfuturesynchronizer/qfuturesynchronizer.pro b/tests/auto/concurrent/qfuturesynchronizer/qfuturesynchronizer.pro
new file mode 100644
index 0000000..331a8e3
--- /dev/null
+++ b/tests/auto/concurrent/qfuturesynchronizer/qfuturesynchronizer.pro
@@ -0,0 +1,4 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qfuturesynchronizer
+QT = core testlib concurrent
+SOURCES = tst_qfuturesynchronizer.cpp
diff --git a/tests/auto/concurrent/qfuturesynchronizer/tst_qfuturesynchronizer.cpp b/tests/auto/concurrent/qfuturesynchronizer/tst_qfuturesynchronizer.cpp
new file mode 100644
index 0000000..012c90d
--- /dev/null
+++ b/tests/auto/concurrent/qfuturesynchronizer/tst_qfuturesynchronizer.cpp
@@ -0,0 +1,158 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtTest>
+
+#include <QtConcurrent/qfuturesynchronizer.h>
+#include <QtConcurrent/qfuture.h>
+
+class tst_QFutureSynchronizer : public QObject
+{
+    Q_OBJECT
+
+
+private Q_SLOTS:
+    void construction();
+    void addFuture();
+    void cancelOnWait();
+    void clearFutures();
+    void futures();
+    void setFuture();
+    void waitForFinished();
+};
+
+
+void tst_QFutureSynchronizer::construction()
+{
+
+    QFuture<void> future;
+    QFutureSynchronizer<void> synchronizer;
+    QFutureSynchronizer<void> synchronizerWithFuture(future);
+
+    QCOMPARE(synchronizer.futures().size(), 0);
+    QCOMPARE(synchronizerWithFuture.futures().size(), 1);
+}
+
+void tst_QFutureSynchronizer::addFuture()
+{
+    QFutureSynchronizer<void> synchronizer;
+
+    synchronizer.addFuture(QFuture<void>());
+    QFuture<void> future;
+    synchronizer.addFuture(future);
+    synchronizer.addFuture(future);
+
+    QCOMPARE(synchronizer.futures().size(), 3);
+}
+
+void tst_QFutureSynchronizer::cancelOnWait()
+{
+    QFutureSynchronizer<void> synchronizer;
+    QVERIFY(!synchronizer.cancelOnWait());
+    synchronizer.setCancelOnWait(true);
+    QVERIFY(synchronizer.cancelOnWait());
+    synchronizer.setCancelOnWait(false);
+    QVERIFY(!synchronizer.cancelOnWait());
+    synchronizer.setCancelOnWait(true);
+    QVERIFY(synchronizer.cancelOnWait());
+}
+
+void tst_QFutureSynchronizer::clearFutures()
+{
+    QFutureSynchronizer<void> synchronizer;
+    synchronizer.clearFutures();
+    QVERIFY(synchronizer.futures().isEmpty());
+
+    synchronizer.addFuture(QFuture<void>());
+    QFuture<void> future;
+    synchronizer.addFuture(future);
+    synchronizer.addFuture(future);
+    synchronizer.clearFutures();
+    QVERIFY(synchronizer.futures().isEmpty());
+}
+
+void tst_QFutureSynchronizer::futures()
+{
+    QFutureSynchronizer<void> synchronizer;
+
+    QList<QFuture<void> > futures;
+    for (int i=0; i<100; i++) {
+        QFuture<void> future;
+        futures.append(future);
+        synchronizer.addFuture(future);
+    }
+
+    QCOMPARE(futures, synchronizer.futures());
+}
+
+void tst_QFutureSynchronizer::setFuture()
+{
+    QFutureSynchronizer<void> synchronizer;
+
+    for (int i=0; i<100; i++) {
+        synchronizer.addFuture(QFuture<void>());
+    }
+    QCOMPARE(synchronizer.futures().size(), 100);
+
+    QFuture<void> future;
+    synchronizer.setFuture(future);
+    QCOMPARE(synchronizer.futures().size(), 1);
+    QCOMPARE(synchronizer.futures().first(), future);
+}
+
+void tst_QFutureSynchronizer::waitForFinished()
+{
+    QFutureSynchronizer<void> synchronizer;
+
+    for (int i=0; i<100; i++) {
+        synchronizer.addFuture(QFuture<void>());
+    }
+    synchronizer.waitForFinished();
+    const QList<QFuture<void> > futures = synchronizer.futures();
+
+    for (int i=0; i<100; i++) {
+        QVERIFY(futures.at(i).isFinished());
+    }
+}
+
+QTEST_MAIN(tst_QFutureSynchronizer)
+
+#include "tst_qfuturesynchronizer.moc"
diff --git a/tests/auto/concurrent/qfuturewatcher/.gitignore b/tests/auto/concurrent/qfuturewatcher/.gitignore
new file mode 100644
index 0000000..1d77843
--- /dev/null
+++ b/tests/auto/concurrent/qfuturewatcher/.gitignore
@@ -0,0 +1 @@
+tst_qfuturewatcher
diff --git a/tests/auto/concurrent/qfuturewatcher/qfuturewatcher.pro b/tests/auto/concurrent/qfuturewatcher/qfuturewatcher.pro
new file mode 100644
index 0000000..3b8ebda
--- /dev/null
+++ b/tests/auto/concurrent/qfuturewatcher/qfuturewatcher.pro
@@ -0,0 +1,4 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qfuturewatcher
+QT = concurrent-private testlib concurrent
+SOURCES = tst_qfuturewatcher.cpp
diff --git a/tests/auto/concurrent/qfuturewatcher/tst_qfuturewatcher.cpp b/tests/auto/concurrent/qfuturewatcher/tst_qfuturewatcher.cpp
new file mode 100644
index 0000000..fe3eb37
--- /dev/null
+++ b/tests/auto/concurrent/qfuturewatcher/tst_qfuturewatcher.cpp
@@ -0,0 +1,942 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QCoreApplication>
+#include <QDebug>
+#include <QtTest/QtTest>
+
+#include <QtConcurrent>
+#include <private/qfutureinterface_p.h>
+
+using namespace QtConcurrent;
+
+#include <QtTest/QtTest>
+
+//#define PRINT
+
+class tst_QFutureWatcher: public QObject
+{
+    Q_OBJECT
+private slots:
+    void startFinish();
+    void progressValueChanged();
+    void canceled();
+    void resultAt();
+    void resultReadyAt();
+    void futureSignals();
+    void watchFinishedFuture();
+    void watchCanceledFuture();
+    void disconnectRunningFuture();
+    void tooMuchProgress();
+    void progressText();
+    void sharedFutureInterface();
+    void changeFuture();
+    void cancelEvents();
+    void pauseEvents();
+    void finishedState();
+    void throttling();
+    void incrementalMapResults();
+    void incrementalFilterResults();
+    void qfutureSynchronizer();
+    void warnRace();
+};
+
+void sleeper()
+{
+    QTest::qSleep(100);
+}
+
+void tst_QFutureWatcher::startFinish()
+{
+    QFutureWatcher<void> futureWatcher;
+
+    QSignalSpy startedSpy(&futureWatcher, SIGNAL(started()));
+    QSignalSpy finishedSpy(&futureWatcher, SIGNAL(finished()));
+
+    QVERIFY(startedSpy.isValid());
+    QVERIFY(finishedSpy.isValid());
+
+    futureWatcher.setFuture(QtConcurrent::run(sleeper));
+    QTest::qWait(10); // spin the event loop to deliver queued signals.
+    QCOMPARE(startedSpy.count(), 1);
+    QCOMPARE(finishedSpy.count(), 0);
+    futureWatcher.future().waitForFinished();
+    QTest::qWait(10);
+    QCOMPARE(startedSpy.count(), 1);
+    QCOMPARE(finishedSpy.count(), 1);
+}
+
+void mapSleeper(int &)
+{
+    QTest::qSleep(100);
+}
+
+QSet<int> progressValues;
+QSet<QString> progressTexts;
+QMutex mutex;
+class ProgressObject : public QObject
+{
+Q_OBJECT
+public slots:
+    void printProgress(int);
+    void printText(const QString &text);
+    void registerProgress(int);
+    void registerText(const QString &text);
+};
+
+void ProgressObject::printProgress(int progress)
+{
+    qDebug() << "thread" << QThread::currentThread() << "reports progress" << progress;
+}
+
+void ProgressObject::printText(const QString &text)
+{
+    qDebug() << "thread" << QThread::currentThread() << "reports progress text" << text;
+}
+
+void ProgressObject::registerProgress(int progress)
+{
+    QTest::qSleep(1);
+    progressValues.insert(progress);
+}
+
+void ProgressObject::registerText(const QString &text)
+{
+    QTest::qSleep(1);
+    progressTexts.insert(text);
+}
+
+
+QList<int> createList(int listSize)
+{
+    QList<int> list;
+    for (int i = 0; i < listSize; ++i) {
+        list.append(i);
+    }
+    return list;
+}
+
+void tst_QFutureWatcher::progressValueChanged()
+{
+#ifdef PRINT
+    qDebug() << "main thread" << QThread::currentThread();
+#endif
+
+    progressValues.clear();
+    const int listSize = 20;
+    QList<int> list = createList(listSize);
+
+    QFutureWatcher<void> futureWatcher;
+    ProgressObject progressObject;
+    QObject::connect(&futureWatcher, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
+#ifdef PRINT
+    QObject::connect(&futureWatcher, SIGNAL(progressValueChanged(int)), &progressObject, SLOT(printProgress(int)), Qt::DirectConnection );
+#endif
+    QObject::connect(&futureWatcher, SIGNAL(progressValueChanged(int)), &progressObject, SLOT(registerProgress(int)));
+
+    futureWatcher.setFuture(QtConcurrent::map(list, mapSleeper));
+
+    QTestEventLoop::instance().enterLoop(5);
+    QVERIFY(!QTestEventLoop::instance().timeout());
+    futureWatcher.disconnect();
+    QVERIFY(progressValues.contains(0));
+    QVERIFY(progressValues.contains(listSize));
+}
+
+class CancelObject : public QObject
+{
+Q_OBJECT
+public:
+    bool wasCanceled;
+    CancelObject() : wasCanceled(false) {};
+public slots:
+    void cancel();
+};
+
+void CancelObject::cancel()
+{
+#ifdef PRINT
+    qDebug() << "thread" << QThread::currentThread() << "reports canceled";
+#endif
+    wasCanceled = true;
+}
+
+void tst_QFutureWatcher::canceled()
+{
+    const int listSize = 20;
+    QList<int> list = createList(listSize);
+
+    QFutureWatcher<void> futureWatcher;
+    QFuture<void> future;
+    CancelObject cancelObject;
+
+    QObject::connect(&futureWatcher, SIGNAL(canceled()), &cancelObject, SLOT(cancel()));
+    QObject::connect(&futureWatcher, SIGNAL(canceled()),
+        &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
+
+    future = QtConcurrent::map(list, mapSleeper);
+    futureWatcher.setFuture(future);
+    futureWatcher.cancel();
+    QTestEventLoop::instance().enterLoop(5);
+    QVERIFY(!QTestEventLoop::instance().timeout());
+
+    QVERIFY(future.isCanceled());
+    QVERIFY(cancelObject.wasCanceled);
+    futureWatcher.disconnect();
+    future.waitForFinished();
+}
+
+class IntTask : public RunFunctionTask<int>
+{
+public:
+    void runFunctor()
+    {
+        result = 10;
+    }
+};
+
+void tst_QFutureWatcher::resultAt()
+{
+    QFutureWatcher<int> futureWatcher;
+    futureWatcher.setFuture((new IntTask())->start());
+    futureWatcher.waitForFinished();
+    QCOMPARE(futureWatcher.result(), 10);
+    QCOMPARE(futureWatcher.resultAt(0), 10);
+}
+
+void tst_QFutureWatcher::resultReadyAt()
+{
+    QFutureWatcher<int> futureWatcher;
+    QObject::connect(&futureWatcher, SIGNAL(resultReadyAt(int)), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
+
+    QFuture<int> future = (new IntTask())->start();
+    futureWatcher.setFuture(future);
+
+    QTestEventLoop::instance().enterLoop(1);
+    QVERIFY(!QTestEventLoop::instance().timeout());
+
+    // Setting the future again should give us another signal.
+    // (this is to prevent the race where the task associated
+    // with the future finishes before setFuture is called.)
+    futureWatcher.setFuture(QFuture<int>());
+    futureWatcher.setFuture(future);
+
+    QTestEventLoop::instance().enterLoop(1);
+    QVERIFY(!QTestEventLoop::instance().timeout());
+}
+
+class SignalSlotObject : public QObject
+{
+Q_OBJECT
+
+signals:
+    void cancel();
+
+public slots:
+    void started()
+    {
+        qDebug() << "started called";
+    }
+
+    void finished()
+    {
+        qDebug() << "finished called";
+    }
+
+    void canceled()
+    {
+        qDebug() << "canceled called";
+    }
+
+#ifdef PRINT
+    void resultReadyAt(int index)
+    {
+        qDebug() << "result" << index << "ready";
+    }
+#else
+    void resultReadyAt(int) { }
+#endif
+    void progressValueChanged(int progress)
+    {
+        qDebug() << "progress" << progress;
+    }
+
+    void progressRangeChanged(int min, int max)
+    {
+        qDebug() << "progress range" << min << max;
+    }
+
+};
+
+void tst_QFutureWatcher::futureSignals()
+{
+    {
+        QFutureInterface<int> a;
+        QFutureWatcher<int> f;
+
+        SignalSlotObject object;
+#ifdef PRINT
+        connect(&f, SIGNAL(finished()), &object, SLOT(finished()));
+        connect(&f, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
+#endif
+        // must connect to resultReadyAt so that the watcher can detect the connection
+        // (QSignalSpy does not trigger it.)
+        connect(&f, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+        a.reportStarted();
+        f.setFuture(a.future());
+
+        QSignalSpy progressSpy(&f, SIGNAL(progressValueChanged(int)));
+        QVERIFY(progressSpy.isValid());
+        const int progress = 1;
+        a.setProgressValue(progress);
+        QTest::qWait(10);
+        QCOMPARE(progressSpy.count(), 2);
+        QCOMPARE(progressSpy.takeFirst().at(0).toInt(), 0);
+        QCOMPARE(progressSpy.takeFirst().at(0).toInt(), 1);
+
+        QSignalSpy finishedSpy(&f, SIGNAL(finished()));
+        QSignalSpy resultReadySpy(&f, SIGNAL(resultReadyAt(int)));
+
+        QVERIFY(finishedSpy.isValid());
+        QVERIFY(resultReadySpy.isValid());
+
+        const int result = 10;
+        a.reportResult(&result);
+        QTest::qWait(10);
+        QCOMPARE(resultReadySpy.count(), 1);
+        a.reportFinished(&result);
+        QTest::qWait(10);
+
+        QCOMPARE(resultReadySpy.count(), 2);
+        QCOMPARE(resultReadySpy.takeFirst().at(0).toInt(), 0); // check the index
+        QCOMPARE(resultReadySpy.takeFirst().at(0).toInt(), 1);
+
+        QCOMPARE(finishedSpy.count(), 1);
+    }
+}
+
+void tst_QFutureWatcher::watchFinishedFuture()
+{
+    QFutureInterface<int> iface;
+    iface.reportStarted();
+
+    QFuture<int> f = iface.future();
+
+    int value = 100;
+    iface.reportFinished(&value);
+
+    QFutureWatcher<int> watcher;
+
+    SignalSlotObject object;
+#ifdef PRINT
+    connect(&watcher, SIGNAL(started()), &object, SLOT(started()));
+    connect(&watcher, SIGNAL(canceled()), &object, SLOT(canceled()));
+    connect(&watcher, SIGNAL(finished()), &object, SLOT(finished()));
+    connect(&watcher, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
+    connect(&watcher, SIGNAL(progressRangeChanged(int, int)), &object, SLOT(progressRangeChanged(int, int)));
+#endif
+    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+
+    QSignalSpy startedSpy(&watcher, SIGNAL(started()));
+    QSignalSpy finishedSpy(&watcher, SIGNAL(finished()));
+    QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
+    QSignalSpy canceledSpy(&watcher, SIGNAL(canceled()));
+
+    QVERIFY(startedSpy.isValid());
+    QVERIFY(finishedSpy.isValid());
+    QVERIFY(resultReadySpy.isValid());
+    QVERIFY(canceledSpy.isValid());
+
+    watcher.setFuture(f);
+    QTest::qWait(10);
+
+    QCOMPARE(startedSpy.count(), 1);
+    QCOMPARE(finishedSpy.count(), 1);
+    QCOMPARE(resultReadySpy.count(), 1);
+    QCOMPARE(canceledSpy.count(), 0);
+}
+
+void tst_QFutureWatcher::watchCanceledFuture()
+{
+    QFuture<int> f;
+    QFutureWatcher<int> watcher;
+
+    SignalSlotObject object;
+#ifdef PRINT
+    connect(&watcher, SIGNAL(started()), &object, SLOT(started()));
+    connect(&watcher, SIGNAL(canceled()), &object, SLOT(canceled()));
+    connect(&watcher, SIGNAL(finished()), &object, SLOT(finished()));
+    connect(&watcher, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
+    connect(&watcher, SIGNAL(progressRangeChanged(int, int)), &object, SLOT(progressRangeChanged(int, int)));
+#endif
+    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+
+    QSignalSpy startedSpy(&watcher, SIGNAL(started()));
+    QSignalSpy finishedSpy(&watcher, SIGNAL(finished()));
+    QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
+    QSignalSpy canceledSpy(&watcher, SIGNAL(canceled()));
+
+    QVERIFY(startedSpy.isValid());
+    QVERIFY(finishedSpy.isValid());
+    QVERIFY(resultReadySpy.isValid());
+    QVERIFY(canceledSpy.isValid());
+
+    watcher.setFuture(f);
+    QTest::qWait(10);
+
+    QCOMPARE(startedSpy.count(), 1);
+    QCOMPARE(finishedSpy.count(), 1);
+    QCOMPARE(resultReadySpy.count(), 0);
+    QCOMPARE(canceledSpy.count(), 1);
+}
+
+void tst_QFutureWatcher::disconnectRunningFuture()
+{
+    QFutureInterface<int> a;
+    a.reportStarted();
+
+    QFuture<int> f = a.future();
+    QFutureWatcher<int> *watcher = new QFutureWatcher<int>();
+    watcher->setFuture(f);
+
+    SignalSlotObject object;
+    connect(watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+
+    QSignalSpy finishedSpy(watcher, SIGNAL(finished()));
+    QSignalSpy resultReadySpy(watcher, SIGNAL(resultReadyAt(int)));
+
+    QVERIFY(finishedSpy.isValid());
+    QVERIFY(resultReadySpy.isValid());
+
+    const int result = 10;
+    a.reportResult(&result);
+    QTest::qWait(10);
+    QCOMPARE(resultReadySpy.count(), 1);
+
+    delete watcher;
+
+    a.reportResult(&result);
+    QTest::qWait(10);
+    QCOMPARE(resultReadySpy.count(), 1);
+
+    a.reportFinished(&result);
+    QTest::qWait(10);
+    QCOMPARE(finishedSpy.count(), 0);
+}
+
+const int maxProgress = 100000;
+class ProgressEmitterTask : public RunFunctionTask<void>
+{
+public:
+    void runFunctor()
+    {
+        setProgressRange(0, maxProgress);
+        for (int p = 0; p <= maxProgress; ++p)
+            setProgressValue(p);
+    }
+};
+
+void tst_QFutureWatcher::tooMuchProgress()
+{
+    progressValues.clear();
+    ProgressObject o;
+
+    QFutureWatcher<void> f;
+    QObject::connect(&f, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
+#ifdef PRINT
+    QObject::connect(&f, SIGNAL(progressValueChanged(int)), &o, SLOT(printProgress(int)));
+#endif
+    QObject::connect(&f, SIGNAL(progressValueChanged(int)), &o, SLOT(registerProgress(int)));
+    f.setFuture((new ProgressEmitterTask())->start());
+
+    QTestEventLoop::instance().enterLoop(5);
+    QVERIFY(!QTestEventLoop::instance().timeout());
+    QVERIFY(progressValues.contains(maxProgress));
+}
+
+template <typename T>
+class ProgressTextTask : public RunFunctionTask<T>
+{
+public:
+    void runFunctor()
+    {
+        this->setProgressValueAndText(1, QLatin1String("Foo 1"));
+
+        while (this->isProgressUpdateNeeded() == false)
+            QTest::qSleep(1);
+        this->setProgressValueAndText(2, QLatin1String("Foo 2"));
+
+        while (this->isProgressUpdateNeeded() == false)
+            QTest::qSleep(1);
+        this->setProgressValueAndText(3, QLatin1String("Foo 3"));
+
+        while (this->isProgressUpdateNeeded() == false)
+            QTest::qSleep(1);
+        this->setProgressValueAndText(4, QLatin1String("Foo 4"));
+    }
+};
+
+void tst_QFutureWatcher::progressText()
+{
+    {   // instantiate API for T=int and T=void.
+        ProgressTextTask<int> a;
+        ProgressTextTask<void> b;
+    }
+    {
+        progressValues.clear();
+        progressTexts.clear();
+        QFuture<int> f = ((new ProgressTextTask<int>())->start());
+        QFutureWatcher<int> watcher;
+        ProgressObject o;
+        QObject::connect(&watcher, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
+#ifdef PRINT
+        QObject::connect(&watcher, SIGNAL(progressValueChanged(int)), &o, SLOT(printProgress(int)));
+        QObject::connect(&watcher, SIGNAL(progressTextChanged(const QString &)), &o, SLOT(printText(const QString &)));
+#endif
+        QObject::connect(&watcher, SIGNAL(progressValueChanged(int)), &o, SLOT(registerProgress(int)));
+        QObject::connect(&watcher, SIGNAL(progressTextChanged(const QString &)), &o, SLOT(registerText(const QString &)));
+
+        watcher.setFuture(f);
+        QTestEventLoop::instance().enterLoop(5);
+        QVERIFY(!QTestEventLoop::instance().timeout());
+
+        QCOMPARE(f.progressText(), QLatin1String("Foo 4"));
+        QCOMPARE(f.progressValue(), 4);
+        QVERIFY(progressValues.contains(1));
+        QVERIFY(progressValues.contains(2));
+        QVERIFY(progressValues.contains(3));
+        QVERIFY(progressValues.contains(4));
+        QVERIFY(progressTexts.contains(QLatin1String("Foo 1")));
+        QVERIFY(progressTexts.contains(QLatin1String("Foo 2")));
+        QVERIFY(progressTexts.contains(QLatin1String("Foo 3")));
+        QVERIFY(progressTexts.contains(QLatin1String("Foo 4")));
+    }
+}
+
+template <typename T>
+void callInterface(T &obj)
+{
+    obj.progressValue();
+    obj.progressMinimum();
+    obj.progressMaximum();
+    obj.progressText();
+
+    obj.isStarted();
+    obj.isFinished();
+    obj.isRunning();
+    obj.isCanceled();
+    obj.isPaused();
+
+    obj.cancel();
+    obj.pause();
+    obj.resume();
+    obj.togglePaused();
+    obj.waitForFinished();
+
+    const T& objConst = obj;
+    objConst.progressValue();
+    objConst.progressMinimum();
+    objConst.progressMaximum();
+    objConst.progressText();
+
+    objConst.isStarted();
+    objConst.isFinished();
+    objConst.isRunning();
+    objConst.isCanceled();
+    objConst.isPaused();
+}
+
+template <typename T>
+void callInterface(const T &obj)
+{
+    obj.result();
+    obj.resultAt(0);
+}
+
+
+// QFutureWatcher and QFuture has a similar interface. Test
+// that the functions we want ot have in both are actually
+// there.
+void tst_QFutureWatcher::sharedFutureInterface()
+{
+    QFutureInterface<int> iface;
+    iface.reportStarted();
+
+    QFuture<int> intFuture = iface.future();
+
+    int value = 0;
+    iface.reportFinished(&value);
+
+    QFuture<void> voidFuture;
+    QFutureWatcher<int> intWatcher;
+    intWatcher.setFuture(intFuture);
+    QFutureWatcher<void> voidWatcher;
+
+    callInterface(intFuture);
+    callInterface(voidFuture);
+    callInterface(intWatcher);
+    callInterface(voidWatcher);
+
+    callInterface(intFuture);
+    callInterface(intWatcher);
+}
+
+void tst_QFutureWatcher::changeFuture()
+{
+    QFutureInterface<int> iface;
+    iface.reportStarted();
+
+    QFuture<int> a = iface.future();
+
+    int value = 0;
+    iface.reportFinished(&value);
+
+    QFuture<int> b;
+
+    QFutureWatcher<int> watcher;
+
+    SignalSlotObject object;
+    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+    QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
+    QVERIFY(resultReadySpy.isValid());
+
+    watcher.setFuture(a); // Watch 'a' which will genere a resultReady event.
+    watcher.setFuture(b); // But oh no! we're switching to another future
+    QTest::qWait(10);     // before the event gets delivered.
+
+    QCOMPARE(resultReadySpy.count(), 0);
+
+    watcher.setFuture(a);
+    watcher.setFuture(b);
+    watcher.setFuture(a); // setting it back gets us one event, not two.
+    QTest::qWait(10);
+
+    QCOMPARE(resultReadySpy.count(), 1);
+}
+
+// Test that events aren't delivered from canceled futures
+void tst_QFutureWatcher::cancelEvents()
+{
+    QFutureInterface<int> iface;
+    iface.reportStarted();
+
+    QFuture<int> a = iface.future();
+
+    int value = 0;
+    iface.reportFinished(&value);
+
+    QFutureWatcher<int> watcher;
+
+    SignalSlotObject object;
+    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+    QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
+    QVERIFY(resultReadySpy.isValid());
+
+    watcher.setFuture(a);
+    watcher.cancel();
+
+    QTest::qWait(10);
+
+    QCOMPARE(resultReadySpy.count(), 0);
+}
+
+// Tests that events from paused futures are saved and
+// delivered on resume.
+void tst_QFutureWatcher::pauseEvents()
+{
+    {
+        QFutureInterface<int> iface;
+        iface.reportStarted();
+
+        QFuture<int> a = iface.future();
+
+        int value = 0;
+        iface.reportFinished(&value);
+
+        QFutureWatcher<int> watcher;
+
+        SignalSlotObject object;
+        connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+        QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
+        QVERIFY(resultReadySpy.isValid());
+
+        watcher.setFuture(a);
+        watcher.pause();
+
+        QTest::qWait(10);
+        QCOMPARE(resultReadySpy.count(), 0);
+
+        watcher.resume();
+        QTest::qWait(10);
+        QCOMPARE(resultReadySpy.count(), 1);
+    }
+    {
+        QFutureInterface<int> iface;
+        iface.reportStarted();
+
+        QFuture<int> a = iface.future();
+
+        int value = 0;
+        iface.reportFinished(&value);
+
+        QFutureWatcher<int> watcher;
+
+        SignalSlotObject object;
+        connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+        QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
+        QVERIFY(resultReadySpy.isValid());
+
+        watcher.setFuture(a);
+        a.pause();
+
+        QFuture<int> b;
+        watcher.setFuture(b); // If we watch b instead, resuming a
+        a.resume();           // should give us no results.
+
+        QTest::qWait(10);
+        QCOMPARE(resultReadySpy.count(), 0);
+    }
+}
+
+// Test that the finished state for the watcher gets
+// set when the finished event is delivered.
+// This means it will lag the finished state for the future,
+// but makes it more useful.
+void tst_QFutureWatcher::finishedState()
+{
+    QFutureInterface<int> iface;
+    iface.reportStarted();
+    QFuture<int> future = iface.future();
+    QFutureWatcher<int> watcher;
+
+    watcher.setFuture(future);
+    QTest::qWait(10);
+
+    iface.reportFinished();
+    QVERIFY(future.isFinished());
+    QVERIFY(watcher.isFinished() == false);
+
+    QTest::qWait(10);
+    QVERIFY(watcher.isFinished());
+}
+
+/*
+    Verify that throttling kicks in if you report a lot of results,
+    and that it clears when the result events are processed.
+*/
+void tst_QFutureWatcher::throttling()
+{
+    QFutureInterface<int> iface;
+    iface.reportStarted();
+    QFuture<int> future = iface.future();
+    QFutureWatcher<int> watcher;
+    watcher.setFuture(future);
+
+    QVERIFY(iface.isThrottled() == false);
+
+    for (int i = 0; i < 1000; ++i) {
+        int result = 0;
+        iface.reportResult(result);
+    }
+
+    QVERIFY(iface.isThrottled() == true);
+
+    QTest::qWait(100); // process events.
+
+    QVERIFY(iface.isThrottled() == false);
+
+    iface.reportFinished();
+}
+
+int mapper(const int &i)
+{
+    return i;
+}
+
+class ResultReadyTester : public QObject
+{
+Q_OBJECT
+public:
+    ResultReadyTester(QFutureWatcher<int> *watcher)
+    :m_watcher(watcher), filter(false), ok(true), count(0)
+    {
+        
+    }
+public slots:
+    void resultReadyAt(int index)
+    {
+        ++count;
+        if (m_watcher->future().isResultReadyAt(index) == false)
+            ok = false;
+        if (!filter && m_watcher->future().resultAt(index) != index)
+            ok = false;
+        if (filter && m_watcher->future().resultAt(index) != index * 2 + 1)
+            ok = false;
+    }
+public:
+    QFutureWatcher<int> *m_watcher;
+    bool filter;
+    bool ok;
+    int count;
+};
+
+void tst_QFutureWatcher::incrementalMapResults()
+{
+    QFutureWatcher<int> watcher;
+
+    SignalSlotObject object;
+#ifdef PRINT
+    connect(&watcher, SIGNAL(finished()), &object, SLOT(finished()));
+    connect(&watcher, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
+    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+#endif
+
+    QObject::connect(&watcher, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
+
+    ResultReadyTester resultReadyTester(&watcher);
+    connect(&watcher, SIGNAL(resultReadyAt(int)), &resultReadyTester, SLOT(resultReadyAt(int)));
+
+    const int count = 10000;
+    QList<int> ints; 
+    for (int i = 0; i < count; ++i)
+        ints << i;
+
+    QFuture<int> future = QtConcurrent::mapped(ints, mapper);
+    watcher.setFuture(future);
+
+    QTestEventLoop::instance().enterLoop(10);
+    QVERIFY(!QTestEventLoop::instance().timeout());
+    QCOMPARE(resultReadyTester.count, count);
+    QVERIFY(resultReadyTester.ok);
+    QVERIFY(watcher.isFinished());
+    future.waitForFinished(); 
+}
+
+bool filterer(int i)
+{
+    return (i % 2);
+}
+
+void tst_QFutureWatcher::incrementalFilterResults()
+{
+    QFutureWatcher<int> watcher;
+
+    SignalSlotObject object;
+#ifdef PRINT
+    connect(&watcher, SIGNAL(finished()), &object, SLOT(finished()));
+    connect(&watcher, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
+    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
+#endif
+
+    QObject::connect(&watcher, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
+
+
+    ResultReadyTester resultReadyTester(&watcher);
+    resultReadyTester.filter = true;
+    connect(&watcher, SIGNAL(resultReadyAt(int)), &resultReadyTester, SLOT(resultReadyAt(int)));
+
+    const int count = 10000;
+    QList<int> ints; 
+    for (int i = 0; i < count; ++i)
+        ints << i;
+
+    QFuture<int> future = QtConcurrent::filtered(ints, filterer);
+    watcher.setFuture(future);
+
+    QTestEventLoop::instance().enterLoop(10);
+    QVERIFY(!QTestEventLoop::instance().timeout());
+    QCOMPARE(resultReadyTester.count, count / 2);
+    QVERIFY(resultReadyTester.ok);
+    QVERIFY(watcher.isFinished());
+    future.waitForFinished(); 
+}
+
+void tst_QFutureWatcher::qfutureSynchronizer()
+{
+    int taskCount = 1000; 
+    QTime t;
+    t.start();
+
+    {
+        QFutureSynchronizer<void> sync;
+
+        sync.setCancelOnWait(true);
+        for (int i = 0; i < taskCount; ++i) {
+            sync.addFuture(run(sleeper));
+        }
+    }
+
+    // Test that we're not running each task.
+    QVERIFY(t.elapsed() < taskCount * 10);
+}
+
+class DummyObject : public QObject {
+    Q_OBJECT
+public slots:
+    void dummySlot() {}
+public:
+    static void function(QMutex *m)
+    {
+        QMutexLocker lock(m);
+    }
+};
+
+void tst_QFutureWatcher::warnRace()
+{
+#ifndef Q_OS_MAC //I don't know why it is not working on mac
+#ifndef QT_NO_DEBUG
+    QTest::ignoreMessage(QtWarningMsg, "QFutureWatcher::connect: connecting after calling setFuture() is likely to produce race");
+#endif
+#endif
+    QFutureWatcher<void> watcher;
+    DummyObject object;
+    QMutex mutex;
+    mutex.lock();
+
+    QFuture<void> future = QtConcurrent::run(DummyObject::function, &mutex);
+    watcher.setFuture(future);
+    QTRY_VERIFY(future.isStarted());
+    connect(&watcher, SIGNAL(finished()), &object, SLOT(dummySlot()));
+    mutex.unlock();
+    future.waitForFinished();
+}
+
+QTEST_MAIN(tst_QFutureWatcher)
+#include "tst_qfuturewatcher.moc"
diff --git a/tests/auto/concurrent/qtconcurrentfilter/.gitignore b/tests/auto/concurrent/qtconcurrentfilter/.gitignore
new file mode 100644
index 0000000..f93d27e
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentfilter/.gitignore
@@ -0,0 +1 @@
+tst_qtconcurrentfilter
diff --git a/tests/auto/concurrent/qtconcurrentfilter/qtconcurrentfilter.pro b/tests/auto/concurrent/qtconcurrentfilter/qtconcurrentfilter.pro
new file mode 100644
index 0000000..eb0c054
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentfilter/qtconcurrentfilter.pro
@@ -0,0 +1,7 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qtconcurrentfilter
+QT = core testlib concurrent
+SOURCES = tst_qtconcurrentfilter.cpp
+DEFINES += QT_STRICT_ITERATORS
+
+CONFIG += insignificant_test # See QTBUG-20688
diff --git a/tests/auto/concurrent/qtconcurrentfilter/tst_qtconcurrentfilter.cpp b/tests/auto/concurrent/qtconcurrentfilter/tst_qtconcurrentfilter.cpp
new file mode 100644
index 0000000..971a699
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentfilter/tst_qtconcurrentfilter.cpp
@@ -0,0 +1,1543 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtconcurrentfilter.h>
+#include <QCoreApplication>
+#include <QList>
+#include <QLinkedList>
+#include <QtTest/QtTest>
+
+#include "../qtconcurrentmap/functions.h"
+
+class tst_QtConcurrentFilter : public QObject
+{
+    Q_OBJECT
+
+private slots:
+#ifdef QT_NO_CONCURRENT_FILTER
+    void initTestCase();
+#else
+    void filter();
+    void filtered();
+    void filteredReduced();
+    void resultAt();
+    void incrementalResults();
+    void noDetach();
+#ifndef QT_NO_STL
+    void stlContainers();
+#endif
+#endif
+};
+
+#ifdef QT_NO_CONCURRENT_FILTER
+void tst_QtConcurrentFilter::initTestCase()
+{
+    QSKIP("This test is skipped for gcc 3.x");
+}
+
+#else
+
+void tst_QtConcurrentFilter::filter()
+{
+    // functor
+    {
+        QList<int> list;
+        list << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(list, KeepEvenIntegers()).waitForFinished();
+        QCOMPARE(list, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list;
+        list << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(list, KeepEvenIntegers());
+        QCOMPARE(list, QList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(linkedList, KeepEvenIntegers()).waitForFinished();
+        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(linkedList, KeepEvenIntegers());
+        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QVector<int> vector;
+        vector << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(vector, KeepEvenIntegers()).waitForFinished();
+        QCOMPARE(vector, QVector<int>() << 2 << 4);
+    }
+    {
+        QVector<int> vector;
+        vector << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(vector, KeepEvenIntegers());
+        QCOMPARE(vector, QVector<int>() << 2 << 4);
+    }
+
+
+    // function
+    {
+        QList<int> list;
+        list << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(list, keepEvenIntegers).waitForFinished();
+        QCOMPARE(list, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list;
+        list << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(list, keepEvenIntegers);
+        QCOMPARE(list, QList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(linkedList, keepEvenIntegers).waitForFinished();
+        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(linkedList, keepEvenIntegers);
+        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
+    }
+
+    // bound function
+    {
+        QList<int> list;
+        list << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(list, keepEvenIntegers).waitForFinished();
+        QCOMPARE(list, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list;
+        list << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(list, keepEvenIntegers);
+        QCOMPARE(list, QList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(linkedList, keepEvenIntegers).waitForFinished();
+        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(linkedList, keepEvenIntegers);
+        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
+    }
+
+    // member
+    {
+        QList<Number> list;
+        list << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(list, &Number::isEven).waitForFinished();
+        QCOMPARE(list, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> list;
+        list << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(list, &Number::isEven);
+        QCOMPARE(list, QList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QtConcurrent::filter(linkedList, &Number::isEven).waitForFinished();
+        QCOMPARE(linkedList, QLinkedList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QtConcurrent::blockingFilter(linkedList, &Number::isEven);
+        QCOMPARE(linkedList, QLinkedList<Number>() << 2 << 4);
+    }
+}
+
+void tst_QtConcurrentFilter::filtered()
+{
+    QList<int> list;
+    list << 1 << 2 << 3 << 4;
+
+    // functor
+    {
+        QFuture<int> f = QtConcurrent::filtered(list, KeepEvenIntegers());
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(list.begin(), list.end(), KeepEvenIntegers());
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(list.constBegin(),
+                                                list.constEnd(),
+                                                KeepEvenIntegers());
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered(list, KeepEvenIntegers());
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.begin(),
+                                                                       list.end(),
+                                                                       KeepEvenIntegers());
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.constBegin(),
+                                                                       list.constEnd(),
+                                                                       KeepEvenIntegers());
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+
+    {
+        QVector<int> vector;
+        vector << 1 << 2 << 3 << 4;
+        QVector<int> vector2 = QtConcurrent::blockingFiltered(vector, KeepEvenIntegers());
+        QCOMPARE(vector2, QVector<int>() << 2 << 4);
+    }
+    {
+        QVector<int> vector;
+        vector << 1 << 2 << 3 << 4;
+        QFuture<int> f = QtConcurrent::filtered(vector, KeepEvenIntegers());
+        QCOMPARE(f.results(), QList<int>() << 2 << 4);
+    }
+
+    {
+        QLinkedList<int> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered(linkedList, KeepEvenIntegers());
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList;
+        linkedList << 1 << 2 << 3 << 4;
+        QFuture<int> f = QtConcurrent::filtered(linkedList, KeepEvenIntegers());
+        QCOMPARE(f.results(), QList<int>() << 2 << 4);
+    }
+
+    // function
+    {
+        QFuture<int> f = QtConcurrent::filtered(list, keepEvenIntegers);
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(list.begin(), list.end(), keepEvenIntegers);
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(list.constBegin(),
+                                                list.constEnd(),
+                                                keepEvenIntegers);
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered(list, keepEvenIntegers);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.begin(),
+                                                                       list.end(),
+                                                                       keepEvenIntegers);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.constBegin(),
+                                                                       list.constEnd(),
+                                                                       keepEvenIntegers);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+
+    // bound function
+    {
+        QFuture<int> f = QtConcurrent::filtered(list, keepEvenIntegers);
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(list.begin(), list.end(), keepEvenIntegers);
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(list.constBegin(),
+                                                list.constEnd(),
+                                                keepEvenIntegers);
+        QList<int> list2 = f.results();
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered(list, keepEvenIntegers);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.begin(),
+                                                                       list.end(),
+                                                                       keepEvenIntegers);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.constBegin(),
+                                                                       list.constEnd(),
+                                                                       keepEvenIntegers);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+
+    // const member function
+    {
+        QList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QFuture<Number> f = QtConcurrent::filtered(integers, &Number::isEven);
+        QList<Number> list2 = f.results();
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QFuture<Number> f = QtConcurrent::filtered(integers.begin(),
+                                                   integers.end(),
+                                                   &Number::isEven);
+        QList<Number> list2 = f.results();
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QFuture<Number> f = QtConcurrent::filtered(integers.constBegin(),
+                                                   integers.constEnd(),
+                                                   &Number::isEven);
+        QList<Number> list2 = f.results();
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QList<Number> list2 = QtConcurrent::blockingFiltered(integers, &Number::isEven);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QList<Number> list2 = QtConcurrent::blockingFiltered<QList<Number> >(integers.begin(),
+                                                                             integers.end(),
+                                                                             &Number::isEven);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QList<Number> list2 =
+            QtConcurrent::blockingFiltered<QList<Number> >(integers.constBegin(),
+                                                           integers.constEnd(),
+                                                           &Number::isEven);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+
+    // same thing on linked lists
+
+    QLinkedList<int> linkedList;
+    linkedList << 1 << 2 << 3 << 4;
+
+    // functor
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList, KeepEvenIntegers());
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList.begin(),
+                                                linkedList.end(),
+                                                KeepEvenIntegers());
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList.constBegin(),
+                                                linkedList.constEnd(),
+                                                KeepEvenIntegers());
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered(linkedList, KeepEvenIntegers());
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.begin(),
+                                                                                         linkedList.end(),
+                                                                                         KeepEvenIntegers());
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.constBegin(),
+                                                                                         linkedList.constEnd(),
+                                                                                         KeepEvenIntegers());
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+
+    // function
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList, keepEvenIntegers);
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList.begin(),
+                                                linkedList.end(),
+                                                keepEvenIntegers);
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList.constBegin(),
+                                                linkedList.constEnd(),
+                                                keepEvenIntegers);
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered(linkedList, keepEvenIntegers);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.begin(),
+                                                                                         linkedList.end(),
+                                                                                         keepEvenIntegers);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.constBegin(),
+                                                                                         linkedList.constEnd(),
+                                                                                         keepEvenIntegers);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+
+    // bound function
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList, keepEvenIntegers);
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList.begin(),
+                                                linkedList.end(),
+                                                keepEvenIntegers);
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QFuture<int> f = QtConcurrent::filtered(linkedList.constBegin(),
+                                                linkedList.constEnd(),
+                                                keepEvenIntegers);
+        QList<int> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered(linkedList, keepEvenIntegers);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.begin(),
+                                                                                         linkedList.end(),
+                                                                                         keepEvenIntegers);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.constBegin(),
+                                                                                         linkedList.constEnd(),
+                                                                                         keepEvenIntegers);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+
+    // const member function
+    {
+        QLinkedList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QFuture<Number> f = QtConcurrent::filtered(integers, &Number::isEven);
+        QList<Number> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QFuture<Number> f = QtConcurrent::filtered(integers.begin(),
+                                                   integers.end(),
+                                                   &Number::isEven);
+        QList<Number> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QFuture<Number> f = QtConcurrent::filtered(integers.constBegin(),
+                                                   integers.constEnd(),
+                                                   &Number::isEven);
+        QList<Number> linkedList2 = f.results();
+        QCOMPARE(linkedList2, QList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFiltered(integers, &Number::isEven);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<Number> >(integers.begin(),
+                                                                                               integers.end(),
+                                                                                               &Number::isEven);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> integers;
+        integers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 =
+            QtConcurrent::blockingFiltered<QLinkedList<Number> >(integers.constBegin(),
+                                                                 integers.constEnd(),
+                                                                 &Number::isEven);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+}
+
+void tst_QtConcurrentFilter::filteredReduced()
+{
+    QList<int> list;
+    list << 1 << 2 << 3 << 4;
+    QList<Number> numberList;
+    numberList << 1 << 2 << 3 << 4;
+
+    // functor-functor
+    {
+        int sum = QtConcurrent::filteredReduced<int>(list, KeepEvenIntegers(), IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced<int>(list, keepEvenIntegers, intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        QVector<int> vector;
+        vector << 1 << 2 << 3 << 4;
+        int sum = QtConcurrent::filteredReduced<int>(vector, KeepEvenIntegers(), IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+
+    {
+        int sum = QtConcurrent::filteredReduced<int>(list.begin(),
+                                                     list.end(),
+                                                     KeepEvenIntegers(),
+                                                     IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced<int>(list.begin(),
+                                                      list.end(),
+                                                      keepEvenIntegers,
+                                                      intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(list.constBegin(),
+                                                     list.constEnd(),
+                                                     KeepEvenIntegers(),
+                                                     IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced<int>(list.constBegin(),
+                                                      list.constEnd(),
+                                                      keepEvenIntegers,
+                                                      intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(list, KeepEvenIntegers(), IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced<int>(list, keepEvenIntegers, intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(list.begin(),
+                                                             list.end(),
+                                                             KeepEvenIntegers(),
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced<int>(list.begin(),
+                                                              list.end(),
+                                                              keepEvenIntegers,
+                                                              intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(list.constBegin(),
+                                                             list.constEnd(),
+                                                             KeepEvenIntegers(),
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced<int>(list.constBegin(),
+                                                              list.constEnd(),
+                                                              keepEvenIntegers,
+                                                              intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+
+    // function-functor
+    {
+        int sum = QtConcurrent::filteredReduced<int>(list, keepEvenIntegers, IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(list.begin(),
+                                                     list.end(),
+                                                     keepEvenIntegers,
+                                                     IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(list.constBegin(),
+                                                     list.constEnd(),
+                                                     keepEvenIntegers,
+                                                     IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(list, keepEvenIntegers, IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(list.begin(),
+                                                             list.end(),
+                                                             keepEvenIntegers,
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(list.constBegin(),
+                                                             list.constEnd(),
+                                                             keepEvenIntegers,
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+
+    // functor-function
+    {
+        int sum = QtConcurrent::filteredReduced(list, KeepEvenIntegers(), intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(list.begin(),
+                                                list.end(),
+                                                KeepEvenIntegers(),
+                                                intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(list.constBegin(),
+                                                list.constEnd(),
+                                                KeepEvenIntegers(),
+                                                intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(list, KeepEvenIntegers(), intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(list.begin(),
+                                                        list.end(),
+                                                        KeepEvenIntegers(),
+                                                        intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(list.constBegin(),
+                                                        list.constEnd(),
+                                                        KeepEvenIntegers(),
+                                                        intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+
+    // function-function
+    {
+        int sum = QtConcurrent::filteredReduced(list, keepEvenIntegers, intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(list.begin(),
+                                                list.end(),
+                                                keepEvenIntegers,
+                                                intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(list.constBegin(),
+                                                list.constEnd(),
+                                                keepEvenIntegers,
+                                                intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(list, keepEvenIntegers, intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(list.begin(),
+                                                        list.end(),
+                                                        keepEvenIntegers,
+                                                        intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(list.constBegin(),
+                                                        list.constEnd(),
+                                                        keepEvenIntegers,
+                                                        intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+
+    // functor-member
+    {
+        QList<int> list2 = QtConcurrent::filteredReduced(list, KeepEvenIntegers(), &QList<int>::push_back, QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::filteredReduced(list.begin(),
+                                                         list.end(),
+                                                         KeepEvenIntegers(),
+                                                         &QList<int>::push_back,
+                                                         QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::filteredReduced(list.constBegin(),
+                                                         list.constEnd(),
+                                                         KeepEvenIntegers(),
+                                                         &QList<int>::push_back,
+                                                         QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list, KeepEvenIntegers(), &QList<int>::push_back, QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list.begin(),
+                                                                 list.end(),
+                                                                 KeepEvenIntegers(),
+                                                                 &QList<int>::push_back,
+                                                                 QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list.constBegin(),
+                                                                 list.constEnd(),
+                                                                 KeepEvenIntegers(),
+                                                                 &QList<int>::push_back,
+                                                                 QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+
+    // member-functor
+    {
+        int sum = QtConcurrent::filteredReduced<int>(numberList, &Number::isEven, NumberSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced<int>(QList<Number>(numberList),
+                                                      &Number::isEven,
+                                                      NumberSumReduce());
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(numberList.begin(),
+                                                     numberList.end(),
+                                                     &Number::isEven,
+                                                     NumberSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(numberList.constBegin(),
+                                                     numberList.constEnd(),
+                                                     &Number::isEven,
+                                                     NumberSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(numberList, &Number::isEven, NumberSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced<int>(QList<Number>(numberList),
+                                                              &Number::isEven,
+                                                              NumberSumReduce());
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(numberList.begin(),
+                                                             numberList.end(),
+                                                             &Number::isEven,
+                                                             NumberSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(numberList.constBegin(),
+                                                             numberList.constEnd(),
+                                                             &Number::isEven,
+                                                             NumberSumReduce());
+        QCOMPARE(sum, 6);
+    }
+
+    // member-member
+    {
+        QList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QList<Number> list2 = QtConcurrent::filteredReduced(numbers,
+                                                            &Number::isEven,
+                                                            &QList<Number>::push_back, QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QList<Number> list2 = QtConcurrent::filteredReduced(numbers.begin(),
+                                                            numbers.end(),
+                                                            &Number::isEven,
+                                                            &QList<Number>::push_back,
+                                                            QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QList<Number> list2 = QtConcurrent::filteredReduced(numbers.constBegin(),
+                                                            numbers.constEnd(),
+                                                            &Number::isEven,
+                                                            &QList<Number>::push_back,
+                                                            QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QList<Number> list2 = QtConcurrent::blockingFilteredReduced(numbers,
+                                                                    &Number::isEven,
+                                                                    &QList<Number>::push_back, QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QList<Number> list2 = QtConcurrent::blockingFilteredReduced(numbers.begin(),
+                                                                    numbers.end(),
+                                                                    &Number::isEven,
+                                                                    &QList<Number>::push_back,
+                                                                    QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+    {
+        QList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QList<Number> list2 = QtConcurrent::blockingFilteredReduced(numbers.constBegin(),
+                                                                    numbers.constEnd(),
+                                                                    &Number::isEven,
+                                                                    &QList<Number>::push_back,
+                                                                    QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<Number>() << 2 << 4);
+    }
+
+    // function-member
+    {
+        QList<int> list2 = QtConcurrent::filteredReduced(list, keepEvenIntegers, &QList<int>::push_back, QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::filteredReduced(list.begin(),
+                                                         list.end(),
+                                                         keepEvenIntegers,
+                                                         &QList<int>::push_back,
+                                                         QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::filteredReduced(list.constBegin(),
+                                                         list.constEnd(),
+                                                         keepEvenIntegers,
+                                                         &QList<int>::push_back,
+                                                         QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list, keepEvenIntegers, &QList<int>::push_back, QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list.begin(),
+                                                                 list.end(),
+                                                                 keepEvenIntegers,
+                                                                 &QList<int>::push_back,
+                                                                 QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+    {
+        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list.constBegin(),
+                                                                 list.constEnd(),
+                                                                 keepEvenIntegers,
+                                                                 &QList<int>::push_back,
+                                                                 QtConcurrent::OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 2 << 4);
+    }
+
+    // member-function
+    {
+        int sum = QtConcurrent::filteredReduced(numberList, &Number::isEven, numberSumReduce);
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced(QList<Number>(numberList),
+                                                 &Number::isEven,
+                                                 numberSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(numberList.begin(),
+                                                numberList.end(),
+                                                &Number::isEven,
+                                                numberSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(numberList.constBegin(),
+                                                numberList.constEnd(),
+                                                &Number::isEven,
+                                                numberSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(numberList, &Number::isEven, numberSumReduce);
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced(QList<Number>(numberList),
+                                                         &Number::isEven,
+                                                         numberSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(numberList.begin(),
+                                                        numberList.end(),
+                                                        &Number::isEven,
+                                                        numberSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(numberList.constBegin(),
+                                                        numberList.constEnd(),
+                                                        &Number::isEven,
+                                                        numberSumReduce);
+        QCOMPARE(sum, 6);
+    }
+
+    // same as above on linked lists
+    QLinkedList<int> linkedList;
+    linkedList << 1 << 2 << 3 << 4;
+    QLinkedList<Number> numberLinkedList;
+    numberLinkedList << 1 << 2 << 3 << 4;
+
+    // functor-functor
+    {
+        int sum = QtConcurrent::filteredReduced<int>(linkedList, KeepEvenIntegers(), IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced<int>(linkedList, keepEvenIntegers, intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(linkedList.begin(),
+                                                     linkedList.end(),
+                                                     KeepEvenIntegers(),
+                                                     IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced<int>(linkedList.begin(),
+                                                      linkedList.end(),
+                                                      keepEvenIntegers,
+                                                      intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(linkedList.constBegin(),
+                                                     linkedList.constEnd(),
+                                                     KeepEvenIntegers(),
+                                                     IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced<int>(linkedList.constBegin(),
+                                                      linkedList.constEnd(),
+                                                      keepEvenIntegers,
+                                                      intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList, KeepEvenIntegers(), IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced<int>(linkedList, keepEvenIntegers, intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList.begin(),
+                                                             linkedList.end(),
+                                                             KeepEvenIntegers(),
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced<int>(linkedList.begin(),
+                                                              linkedList.end(),
+                                                              keepEvenIntegers,
+                                                              intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList.constBegin(),
+                                                             linkedList.constEnd(),
+                                                             KeepEvenIntegers(),
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced<int>(linkedList.constBegin(),
+                                                              linkedList.constEnd(),
+                                                              keepEvenIntegers,
+                                                              intSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+
+    // function-functor
+    {
+        int sum = QtConcurrent::filteredReduced<int>(linkedList, keepEvenIntegers, IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(linkedList.begin(),
+                                                     linkedList.end(),
+                                                     keepEvenIntegers,
+                                                     IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(linkedList.constBegin(),
+                                                     linkedList.constEnd(),
+                                                     keepEvenIntegers,
+                                                     IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList, keepEvenIntegers, IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList.begin(),
+                                                             linkedList.end(),
+                                                             keepEvenIntegers,
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList.constBegin(),
+                                                             linkedList.constEnd(),
+                                                             keepEvenIntegers,
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+    }
+
+    // functor-function
+    {
+        int sum = QtConcurrent::filteredReduced(linkedList, KeepEvenIntegers(), intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(linkedList.begin(),
+                                                linkedList.end(),
+                                                KeepEvenIntegers(),
+                                                intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(linkedList.constBegin(),
+                                                linkedList.constEnd(),
+                                                KeepEvenIntegers(),
+                                                intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(linkedList, KeepEvenIntegers(), intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(linkedList.begin(),
+                                                        linkedList.end(),
+                                                        KeepEvenIntegers(),
+                                                        intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(linkedList.constBegin(),
+                                                        linkedList.constEnd(),
+                                                        KeepEvenIntegers(),
+                                                        intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+
+    // function-function
+    {
+        int sum = QtConcurrent::filteredReduced(linkedList, keepEvenIntegers, intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(linkedList.begin(),
+                                                linkedList.end(),
+                                                keepEvenIntegers,
+                                                intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(linkedList.constBegin(),
+                                                linkedList.constEnd(),
+                                                keepEvenIntegers,
+                                                intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(linkedList, keepEvenIntegers, intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(linkedList.begin(),
+                                                        linkedList.end(),
+                                                        keepEvenIntegers,
+                                                        intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(linkedList.constBegin(),
+                                                        linkedList.constEnd(),
+                                                        keepEvenIntegers,
+                                                        intSumReduce);
+        QCOMPARE(sum, 6);
+    }
+
+    // functor-member
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList, KeepEvenIntegers(), &QLinkedList<int>::append, QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList.begin(),
+                                                                     linkedList.end(),
+                                                                     KeepEvenIntegers(),
+                                                                     &QLinkedList<int>::append,
+                                                                     QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList.constBegin(),
+                                                                     linkedList.constEnd(),
+                                                                     KeepEvenIntegers(),
+                                                                     &QLinkedList<int>::append,
+                                                                     QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList, KeepEvenIntegers(), &QLinkedList<int>::append, QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList.begin(),
+                                                                             linkedList.end(),
+                                                                             KeepEvenIntegers(),
+                                                                             &QLinkedList<int>::append,
+                                                                             QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList.constBegin(),
+                                                                             linkedList.constEnd(),
+                                                                             KeepEvenIntegers(),
+                                                                             &QLinkedList<int>::append,
+                                                                             QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+
+    // member-functor
+    {
+        int sum = QtConcurrent::filteredReduced<int>(numberLinkedList, &Number::isEven, NumberSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced<int>(QLinkedList<Number>(numberLinkedList),
+                                                      &Number::isEven,
+                                                      NumberSumReduce());
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(numberLinkedList.begin(),
+                                                     numberLinkedList.end(),
+                                                     &Number::isEven,
+                                                     NumberSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced<int>(numberLinkedList.constBegin(),
+                                                     numberLinkedList.constEnd(),
+                                                     &Number::isEven,
+                                                     NumberSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(numberLinkedList, &Number::isEven, NumberSumReduce());
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced<int>(QLinkedList<Number>(numberLinkedList),
+                                                              &Number::isEven,
+                                                              NumberSumReduce());
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(numberLinkedList.begin(),
+                                                             numberLinkedList.end(),
+                                                             &Number::isEven,
+                                                             NumberSumReduce());
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced<int>(numberLinkedList.constBegin(),
+                                                             numberLinkedList.constEnd(),
+                                                             &Number::isEven,
+                                                             NumberSumReduce());
+        QCOMPARE(sum, 6);
+    }
+
+    // member-member
+    {
+        QLinkedList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 = QtConcurrent::filteredReduced(numbers,
+                                                                        &Number::isEven,
+                                                                        &QLinkedList<Number>::append, QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 = QtConcurrent::filteredReduced(numbers.begin(),
+                                                                        numbers.end(),
+                                                                        &Number::isEven,
+                                                                        &QLinkedList<Number>::append,
+                                                                        QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 = QtConcurrent::filteredReduced(numbers.constBegin(),
+                                                                        numbers.constEnd(),
+                                                                        &Number::isEven,
+                                                                        &QLinkedList<Number>::append,
+                                                                        QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFilteredReduced(numbers,
+                                                                                &Number::isEven,
+                                                                                &QLinkedList<Number>::append, QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFilteredReduced(numbers.begin(),
+                                                                                numbers.end(),
+                                                                                &Number::isEven,
+                                                                                &QLinkedList<Number>::append,
+                                                                                QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+    {
+        QLinkedList<Number> numbers;
+        numbers << 1 << 2 << 3 << 4;
+        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFilteredReduced(numbers.constBegin(),
+                                                                                numbers.constEnd(),
+                                                                                &Number::isEven,
+                                                                                &QLinkedList<Number>::append,
+                                                                                QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
+    }
+
+    // function-member
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList, keepEvenIntegers, &QLinkedList<int>::append, QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList.begin(),
+                                                                     linkedList.end(),
+                                                                     keepEvenIntegers,
+                                                                     &QLinkedList<int>::append,
+                                                                     QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList.constBegin(),
+                                                                     linkedList.constEnd(),
+                                                                     keepEvenIntegers,
+                                                                     &QLinkedList<int>::append,
+                                                                     QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList, keepEvenIntegers, &QLinkedList<int>::append, QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList.begin(),
+                                                                             linkedList.end(),
+                                                                             keepEvenIntegers,
+                                                                             &QLinkedList<int>::append,
+                                                                             QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList.constBegin(),
+                                                                             linkedList.constEnd(),
+                                                                             keepEvenIntegers,
+                                                                             &QLinkedList<int>::append,
+                                                                             QtConcurrent::OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
+    }
+
+    // member-function
+    {
+        int sum = QtConcurrent::filteredReduced(numberLinkedList, &Number::isEven, numberSumReduce);
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::filteredReduced(QLinkedList<Number>(numberLinkedList),
+                                                 &Number::isEven,
+                                                 numberSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(numberLinkedList.begin(),
+                                                numberLinkedList.end(),
+                                                &Number::isEven,
+                                                numberSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::filteredReduced(numberLinkedList.constBegin(),
+                                                numberLinkedList.constEnd(),
+                                                &Number::isEven,
+                                                numberSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(numberLinkedList, &Number::isEven, numberSumReduce);
+        QCOMPARE(sum, 6);
+
+        int sum2 = QtConcurrent::blockingFilteredReduced(QLinkedList<Number>(numberLinkedList),
+                                                         &Number::isEven,
+                                                         numberSumReduce);
+        QCOMPARE(sum2, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(numberLinkedList.begin(),
+                                                        numberLinkedList.end(),
+                                                        &Number::isEven,
+                                                        numberSumReduce);
+        QCOMPARE(sum, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingFilteredReduced(numberLinkedList.constBegin(),
+                                                        numberLinkedList.constEnd(),
+                                                        &Number::isEven,
+                                                        numberSumReduce);
+        QCOMPARE(sum, 6);
+    }
+
+    // ### the same as above, with an initial result value
+}
+
+bool filterfn(int i)  
+{ 
+    return (i % 2);
+} 
+
+void tst_QtConcurrentFilter::resultAt()
+{
+
+    QList<int> ints; 
+    for (int i=0; i < 1000; ++i)
+        ints << i;
+
+    QFuture<int> future = QtConcurrent::filtered(ints, filterfn);
+    future.waitForFinished(); 
+
+    
+    for (int i = 0; i < future.resultCount(); ++i) {
+        QCOMPARE(future.resultAt(i), ints.at(i * 2 + 1));
+    }
+
+}
+
+bool waitFilterfn(const int &i)  
+{ 
+    QTest::qWait(1);
+    return (i % 2);
+} 
+
+void tst_QtConcurrentFilter::incrementalResults()
+{
+    const int count = 200;
+    QList<int> ints; 
+    for (int i=0; i < count; ++i)
+        ints << i;
+
+    QFuture<int> future = QtConcurrent::filtered(ints, waitFilterfn);
+    
+    QList<int> results;
+
+    while (future.isFinished() == false) {
+        for (int i = 0; i < future.resultCount(); ++i) {
+            results += future.resultAt(i);
+        }
+        QTest::qWait(1);
+    }
+
+    QCOMPARE(future.isFinished(), true);
+    QCOMPARE(future.resultCount(), count / 2);
+    QCOMPARE(future.results().count(), count / 2);
+}
+
+void tst_QtConcurrentFilter::noDetach()
+{
+    {
+        QList<int> l = QList<int>() << 1;
+        QVERIFY(l.isDetached());
+
+        QList<int> ll = l;
+        QVERIFY(l.isDetached() == false);
+
+        QtConcurrent::filtered(l, waitFilterfn).waitForFinished();
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+
+        QtConcurrent::blockingFiltered(l, waitFilterfn);
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+
+        QtConcurrent::filteredReduced(l, waitFilterfn, intSumReduce).waitForFinished();
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+
+        QtConcurrent::filter(l, waitFilterfn).waitForFinished();
+        QVERIFY(l.isDetached() == true);
+        QVERIFY(ll.isDetached() == true);
+    }
+    {
+        const QList<int> l = QList<int>() << 1;
+        QVERIFY(l.isDetached());
+
+        const QList<int> ll = l;
+        QVERIFY(l.isDetached() == false);
+
+        QtConcurrent::filtered(l, waitFilterfn).waitForFinished();
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+
+        QtConcurrent::filteredReduced(l, waitFilterfn, intSumReduce).waitForFinished();
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+    }
+}
+
+#ifndef QT_NO_STL
+void tst_QtConcurrentFilter::stlContainers()
+{
+    std::vector<int> vector;
+    vector.push_back(1);
+    vector.push_back(2);
+
+    std::vector<int> vector2 =  QtConcurrent::blockingFiltered(vector, waitFilterfn);
+    QCOMPARE(vector2.size(), (std::vector<int>::size_type)(1));
+    QCOMPARE(vector2[0], 1);
+
+    std::list<int> list;
+    list.push_back(1);
+    list.push_back(2);
+
+    std::list<int> list2 =  QtConcurrent::blockingFiltered(list, waitFilterfn);
+    QCOMPARE(list2.size(), (std::list<int>::size_type)(1));
+    QCOMPARE(*list2.begin(), 1);
+
+    QtConcurrent::filtered(list, waitFilterfn).waitForFinished();
+    QtConcurrent::filtered(vector, waitFilterfn).waitForFinished();
+    QtConcurrent::filtered(vector.begin(), vector.end(), waitFilterfn).waitForFinished();
+
+    QtConcurrent::blockingFilter(list, waitFilterfn);
+    QCOMPARE(list2.size(), (std::list<int>::size_type)(1));
+    QCOMPARE(*list2.begin(), 1);
+}
+#endif
+
+#endif
+
+QTEST_MAIN(tst_QtConcurrentFilter)
+#include "tst_qtconcurrentfilter.moc"
diff --git a/tests/auto/concurrent/qtconcurrentiteratekernel/.gitignore b/tests/auto/concurrent/qtconcurrentiteratekernel/.gitignore
new file mode 100644
index 0000000..ac5dec4
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentiteratekernel/.gitignore
@@ -0,0 +1 @@
+tst_qtconcurrentiteratekernel
diff --git a/tests/auto/concurrent/qtconcurrentiteratekernel/qtconcurrentiteratekernel.pro b/tests/auto/concurrent/qtconcurrentiteratekernel/qtconcurrentiteratekernel.pro
new file mode 100644
index 0000000..4cfebc0
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentiteratekernel/qtconcurrentiteratekernel.pro
@@ -0,0 +1,4 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qtconcurrentiteratekernel
+QT = core testlib concurrent
+SOURCES = tst_qtconcurrentiteratekernel.cpp
diff --git a/tests/auto/concurrent/qtconcurrentiteratekernel/tst_qtconcurrentiteratekernel.cpp b/tests/auto/concurrent/qtconcurrentiteratekernel/tst_qtconcurrentiteratekernel.cpp
new file mode 100644
index 0000000..46562b5
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentiteratekernel/tst_qtconcurrentiteratekernel.cpp
@@ -0,0 +1,310 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QThread>
+
+struct TestIterator
+{
+    TestIterator(int i)
+    :i(i) { }
+
+    int operator-(const TestIterator &other)
+    {
+        return i - other.i;
+    }
+
+    TestIterator& operator++()
+    {
+        ++i;
+        return *this;
+    }
+
+    bool operator!=(const TestIterator &other) const
+    {
+        return i != other.i;
+    }
+
+    int i;
+};
+
+#include <qiterator.h>
+#ifndef QT_NO_STL
+namespace std {
+template <>
+struct iterator_traits<TestIterator>
+{
+    typedef random_access_iterator_tag iterator_category;
+};
+
+int distance(TestIterator &a, TestIterator &b)
+{
+    return b - a;
+}
+
+}
+#endif
+
+#include <qtconcurrentiteratekernel.h>
+#include <QtTest/QtTest>
+
+using namespace QtConcurrent;
+
+class tst_QtConcurrentIterateKernel: public QObject
+{
+    Q_OBJECT
+private slots:
+    // "for" iteration tests:
+    void instantiate();
+    void cancel();
+    void stresstest();
+    void noIterations();
+    void throttling();
+#ifndef QT_NO_STL
+    void blockSize();
+    void multipleResults();
+#endif
+};
+
+QAtomicInt iterations;
+class PrintFor : public IterateKernel<TestIterator, void>
+{
+public:
+    PrintFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { iterations.store(0); }
+    bool runIterations(TestIterator/*beginIterator*/, int begin, int end, void *)
+    {
+        iterations.fetchAndAddRelaxed(end - begin);
+#ifdef PRINT
+        qDebug() << QThread::currentThread() << "iteration" << begin <<  "to" << end << "(exclusive)";
+#endif
+        return false;
+    }
+    bool runIteration(TestIterator it, int index , void *result)
+    { 
+        return runIterations(it, index, index + 1, result);
+    }
+
+};
+
+class SleepPrintFor : public IterateKernel<TestIterator, void>
+{
+public:
+    SleepPrintFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { iterations.store(0); }
+    inline bool runIterations(TestIterator/*beginIterator*/, int begin, int end, void *)
+    {
+        QTest::qSleep(200);
+        iterations.fetchAndAddRelaxed(end - begin);
+#ifdef PRINT
+        qDebug() << QThread::currentThread() << "iteration" << begin <<  "to" << end << "(exclusive)";
+#endif
+        return false;
+    }
+    bool runIteration(TestIterator it, int index , void *result)
+    { 
+        return runIterations(it, index, index + 1, result);
+    }
+};
+
+
+void tst_QtConcurrentIterateKernel::instantiate()
+{
+    startThreadEngine(new PrintFor(0, 40)).startBlocking();
+    QCOMPARE(iterations.load(), 40);
+}
+
+void tst_QtConcurrentIterateKernel::cancel()
+{
+    {
+        QFuture<void> f = startThreadEngine(new SleepPrintFor(0, 40)).startAsynchronously();
+        f.cancel();
+        f.waitForFinished();
+        QVERIFY(f.isCanceled());
+        QVERIFY(iterations.load() <= QThread::idealThreadCount()); // the threads might run one iteration each before they are canceled.
+    }
+}
+
+QAtomicInt counter;
+class CountFor : public IterateKernel<TestIterator, void>
+{
+public:
+    CountFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { iterations.store(0); }
+    inline bool runIterations(TestIterator/*beginIterator*/, int begin, int end, void *)
+    {
+        counter.fetchAndAddRelaxed(end - begin);
+        return false;
+    }
+    bool runIteration(TestIterator it, int index , void *result)
+    { 
+        return runIterations(it, index, index + 1, result);
+    }
+};
+
+void tst_QtConcurrentIterateKernel::stresstest()
+{
+    const int iterations = 1000;
+    const int times = 50;
+    for (int i = 0; i < times; ++i) {
+        counter.store(0);
+        CountFor f(0, iterations);
+        f.startBlocking();
+        QCOMPARE(counter.load(), iterations);
+    }
+}
+
+void tst_QtConcurrentIterateKernel::noIterations()
+{
+    const int times = 20000;
+    for (int i = 0; i < times; ++i)
+        startThreadEngine(new IterateKernel<TestIterator, void>(0, 0)).startBlocking();
+}
+
+QMutex threadsMutex;
+QSet<QThread *> threads;
+class ThrottleFor : public IterateKernel<TestIterator, void>
+{
+public:
+    // this class throttles between iterations 100 and 200,
+    // and then records how many threads that run between
+    // iterations 140 and 160.
+    ThrottleFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { iterations.store(0); throttling = false; }
+    inline bool runIterations(TestIterator/*beginIterator*/, int begin, int end, void *)
+    {
+        if (200 >= begin && 200 < end) {
+            throttling = false;
+        }
+
+        iterations.fetchAndAddRelaxed(end - begin);
+
+        QThread *thread = QThread::currentThread();
+
+        if (begin > 140 && end < 160) {
+            QMutexLocker locker(&threadsMutex);
+            threads.insert(thread);
+        }
+
+        if (100 >= begin && 100 < end) {
+            throttling = true;
+        }
+        
+        QTest::qWait(1);
+
+        return false;
+    }
+    bool runIteration(TestIterator it, int index , void *result)
+    { 
+        return runIterations(it, index, index + 1, result);
+    }
+
+    bool shouldThrottleThread()
+    {
+       const int load = iterations.load();
+       return (load > 100 && load < 200);
+    }
+    bool throttling;
+};
+
+void tst_QtConcurrentIterateKernel::throttling()
+{
+    const int totalIterations = 400;
+    iterations.store(0);
+
+    threads.clear();
+
+    ThrottleFor f(0, totalIterations);
+    f.startBlocking();
+
+    QCOMPARE(iterations.load(), totalIterations);
+
+
+    QCOMPARE(threads.count(), 1);
+}
+
+
+int peakBlockSize = 0;
+class BlockSizeRecorder : public IterateKernel<TestIterator, void>
+{
+public:
+    BlockSizeRecorder(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { }
+    inline bool runIterations(TestIterator, int begin, int end, void *)
+    {
+        peakBlockSize = qMax(peakBlockSize, end - begin);
+        return false;
+    }
+};
+
+// Missing stl iterators prevent correct block size calculation.
+#ifndef QT_NO_STL
+void tst_QtConcurrentIterateKernel::blockSize()
+{
+    const int expectedMinimumBlockSize = 1024 / QThread::idealThreadCount();
+    BlockSizeRecorder(0, 10000).startBlocking();
+    if (peakBlockSize < expectedMinimumBlockSize)
+        qDebug() << "block size" << peakBlockSize;
+    QVERIFY(peakBlockSize >= expectedMinimumBlockSize);
+}
+#endif
+
+class MultipleResultsFor : public IterateKernel<TestIterator, int>
+{
+public:
+    MultipleResultsFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, int>(begin, end) { }
+    inline bool runIterations(TestIterator, int begin, int end, int *results)
+    {
+        for (int i = begin; i < end; ++i)
+            results[i - begin] = i;
+        return true;
+    }
+};
+
+// Missing stl iterators prevent correct summation.
+#ifndef QT_NO_STL
+void tst_QtConcurrentIterateKernel::multipleResults()
+{
+    QFuture<int> f = startThreadEngine(new MultipleResultsFor(0, 10)).startAsynchronously();
+    QCOMPARE(f.results().count() , 10);
+    QCOMPARE(f.resultAt(0), 0);
+    QCOMPARE(f.resultAt(5), 5);
+    QCOMPARE(f.resultAt(9), 9);
+    f.waitForFinished();
+}
+#endif
+
+QTEST_MAIN(tst_QtConcurrentIterateKernel)
+
+#include "tst_qtconcurrentiteratekernel.moc"
diff --git a/tests/auto/concurrent/qtconcurrentmap/.gitignore b/tests/auto/concurrent/qtconcurrentmap/.gitignore
new file mode 100644
index 0000000..f1c563e
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentmap/.gitignore
@@ -0,0 +1 @@
+tst_qtconcurrentmap
diff --git a/tests/auto/concurrent/qtconcurrentmap/functions.h b/tests/auto/concurrent/qtconcurrentmap/functions.h
new file mode 100644
index 0000000..f5963db
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentmap/functions.h
@@ -0,0 +1,130 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef FUNCTIONS_H
+#define FUNCTIONS_H
+
+bool keepEvenIntegers(const int &x)
+{
+    return (x & 1) == 0;
+}
+
+class KeepEvenIntegers
+{
+public:
+    bool operator()(const int &x)
+    {
+        return (x & 1) == 0;
+    }
+};
+
+class Number
+{
+    int n;
+
+public:
+    Number()
+        : n(0)
+    { }
+
+    Number(int n)
+        : n(n)
+    { }
+
+    void multiplyBy2()
+    {
+        n *= 2;
+    }
+
+    Number multipliedBy2() const
+    {
+        return n * 2;
+    }
+
+    bool isEven() const
+    {
+        return (n & 1) == 0;
+    }
+
+    int toInt() const
+    {
+        return n;
+    }
+
+    QString toString() const
+    {
+        return QString::number(n);
+    }
+
+    bool operator==(const Number &other) const
+    {
+        return n == other.n;
+    }
+};
+
+void intSumReduce(int &sum, int x)
+{
+    sum += x;
+}
+
+class IntSumReduce
+{
+public:
+    void operator()(int &sum, int x)
+    {
+        sum += x;
+    }
+};
+
+void numberSumReduce(int &sum, const Number &x)
+{
+    sum += x.toInt();
+}
+
+class NumberSumReduce
+{
+public:
+    void operator()(int &sum, const Number &x)
+    {
+        sum += x.toInt();
+    }
+};
+
+#endif
diff --git a/tests/auto/concurrent/qtconcurrentmap/qtconcurrentmap.pro b/tests/auto/concurrent/qtconcurrentmap/qtconcurrentmap.pro
new file mode 100644
index 0000000..199e5ad
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentmap/qtconcurrentmap.pro
@@ -0,0 +1,5 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qtconcurrentmap
+QT = core testlib concurrent
+SOURCES = tst_qtconcurrentmap.cpp
+DEFINES += QT_STRICT_ITERATORS
diff --git a/tests/auto/concurrent/qtconcurrentmap/tst_qtconcurrentmap.cpp b/tests/auto/concurrent/qtconcurrentmap/tst_qtconcurrentmap.cpp
new file mode 100644
index 0000000..960511d
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentmap/tst_qtconcurrentmap.cpp
@@ -0,0 +1,2426 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtconcurrentmap.h>
+#include <qtconcurrentexception.h>
+
+#include <qdebug.h>
+#include <QThread>
+
+#include <QtTest/QtTest>
+
+#include "functions.h"
+
+Q_DECLARE_METATYPE(QVector<int>);
+Q_DECLARE_METATYPE(QVector<double>);
+Q_DECLARE_METATYPE(QVector<QString>);
+Q_DECLARE_METATYPE(QList<int>);
+Q_DECLARE_METATYPE(QList<double>);
+Q_DECLARE_METATYPE(QList<QString>);
+
+class tst_QtConcurrentMap: public QObject
+{
+    Q_OBJECT
+private slots:
+#ifdef QT_NO_CONCURRENT_MAP
+    void initTestCase()
+#else
+    void map();
+    void blocking_map();
+    void mapped();
+    void blocking_mapped();
+    void mappedReduced();
+    void blocking_mappedReduced();
+    void assignResult();
+    void functionOverloads();
+#ifndef QT_NO_EXCEPTIONS
+    void exceptions();
+#endif
+    void incrementalResults();
+    void noDetach();
+#ifndef QT_NO_STL
+    void stlContainers();
+#endif
+    void qFutureAssignmentLeak();
+    void stressTest();
+public slots:
+    void throttling();
+#endif
+};
+
+#ifdef QT_NO_CONCURRENT_FILTER
+void tst_QtConcurrentFilter::initTestCase()
+{
+    QSKIP("This test is skipped for gcc 3.x");
+}
+
+#else
+
+using namespace QtConcurrent;
+
+void multiplyBy2Immutable(int x)
+{
+    x *= 2;
+}
+
+class MultiplyBy2Immutable
+{
+public:
+    void operator()(int x)
+    {
+        x *= 2;
+    }
+};
+
+void multiplyBy2InPlace(int &x)
+{
+    x *= 2;
+}
+
+class MultiplyBy2InPlace
+{
+public:
+    void operator()(int &x)
+    {
+        x *= 2;
+    }
+};
+
+Q_DECLARE_METATYPE(QList<Number>);
+
+void tst_QtConcurrentMap::map()
+{
+    // functors take arguments by reference, modifying the sequence in place
+    {
+        QList<int> list;
+        list << 1 << 2 << 3;
+
+        // functor
+        QtConcurrent::map(list, MultiplyBy2InPlace()).waitForFinished();
+        QCOMPARE(list, QList<int>() << 2 << 4 << 6);
+        QtConcurrent::map(list.begin(), list.end(), MultiplyBy2InPlace()).waitForFinished();
+        QCOMPARE(list, QList<int>() << 4 << 8 << 12);
+
+        // function
+        QtConcurrent::map(list, multiplyBy2InPlace).waitForFinished();
+        QCOMPARE(list, QList<int>() << 8 << 16 << 24);
+        QtConcurrent::map(list.begin(), list.end(), multiplyBy2InPlace).waitForFinished();
+        QCOMPARE(list, QList<int>() << 16 << 32 << 48);
+
+        // bound function
+        QtConcurrent::map(list, multiplyBy2InPlace).waitForFinished();
+        QCOMPARE(list, QList<int>() << 32 << 64 << 96);
+        QtConcurrent::map(list.begin(), list.end(), multiplyBy2InPlace).waitForFinished();
+        QCOMPARE(list, QList<int>() << 64 << 128 << 192);
+
+        // member function
+        QList<Number> numberList;
+        numberList << 1 << 2 << 3;
+        QtConcurrent::map(numberList, &Number::multiplyBy2).waitForFinished();
+        QCOMPARE(numberList, QList<Number>() << 2 << 4 << 6);
+        QtConcurrent::map(numberList.begin(), numberList.end(), &Number::multiplyBy2).waitForFinished();
+        QCOMPARE(numberList, QList<Number>() << 4 << 8 << 12);
+
+#ifdef Q_COMPILER_LAMBDA
+        // lambda
+        QtConcurrent::map(list, [](int &x){x *= 2;}).waitForFinished();
+        QCOMPARE(list, QList<int>() << 128 << 256 << 384);
+        QtConcurrent::map(list.begin(), list.end(), [](int &x){x *= 2;}).waitForFinished();
+        QCOMPARE(list, QList<int>() << 256 << 512 << 768);
+#endif
+
+    }
+
+    // functors don't take arguments by reference, making these no-ops
+    {
+        QList<int> list;
+        list << 1 << 2 << 3;
+
+        // functor
+        QtConcurrent::map(list, MultiplyBy2Immutable()).waitForFinished();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QtConcurrent::map(list.begin(), list.end(), MultiplyBy2Immutable()).waitForFinished();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        // function
+        QtConcurrent::map(list, multiplyBy2Immutable).waitForFinished();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QtConcurrent::map(list.begin(), list.end(), multiplyBy2Immutable).waitForFinished();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        // bound function
+        QtConcurrent::map(list, multiplyBy2Immutable).waitForFinished();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QtConcurrent::map(list.begin(), list.end(), multiplyBy2Immutable).waitForFinished();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+#ifdef Q_COMPILER_LAMBDA
+        // lambda
+        QtConcurrent::map(list, [](int x){x *= 2;}).waitForFinished();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QtConcurrent::map(list.begin(), list.end(), [](int x){x *= 2;}).waitForFinished();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+#endif
+    }
+
+    // Linked lists and forward iterators
+    {
+        QLinkedList<int> list;
+        list << 1 << 2 << 3;
+
+        // functor
+        QtConcurrent::map(list, MultiplyBy2InPlace()).waitForFinished();
+        QCOMPARE(list, QLinkedList<int>() << 2 << 4 << 6);
+        QtConcurrent::map(list.begin(), list.end(), MultiplyBy2InPlace()).waitForFinished();
+        QCOMPARE(list, QLinkedList<int>() << 4 << 8 << 12);
+
+        // function
+        QtConcurrent::map(list, multiplyBy2InPlace).waitForFinished();
+        QCOMPARE(list, QLinkedList<int>() << 8 << 16 << 24);
+        QtConcurrent::map(list.begin(), list.end(), multiplyBy2InPlace).waitForFinished();
+        QCOMPARE(list, QLinkedList<int>() << 16 << 32 << 48);
+
+        // bound function
+        QtConcurrent::map(list, multiplyBy2InPlace).waitForFinished();
+        QCOMPARE(list, QLinkedList<int>() << 32 << 64 << 96);
+        QtConcurrent::map(list.begin(), list.end(), multiplyBy2InPlace).waitForFinished();
+        QCOMPARE(list, QLinkedList<int>() << 64 << 128 << 192);
+
+        // member function
+        QLinkedList<Number> numberList;
+        numberList << 1 << 2 << 3;
+        QtConcurrent::map(numberList, &Number::multiplyBy2).waitForFinished();
+        QCOMPARE(numberList, QLinkedList<Number>() << 2 << 4 << 6);
+        QtConcurrent::map(numberList.begin(), numberList.end(), &Number::multiplyBy2).waitForFinished();
+        QCOMPARE(numberList, QLinkedList<Number>() << 4 << 8 << 12);
+    }
+
+#if 0
+    // not allowed: map() with immutable sequences makes no sense
+    {
+        const QList<int> list = QList<int>() << 1 << 2 << 3;
+
+        QtConcurrent::map(list, MultiplyBy2Immutable());
+        QtConcurrent::map(list, multiplyBy2Immutable);
+        QtConcurrent::map(list, multiplyBy2Immutable);
+    }
+#endif
+
+#if 0
+    // not allowed: in place modification of a temp copy (since temp copy goes out of scope)
+    {
+        QList<int> list;
+        list << 1 << 2 << 3;
+
+        QtConcurrent::map(QList<int>(list), MultiplyBy2InPlace());
+        QtConcurrent::map(QList<int>(list), multiplyBy2);
+        QtConcurrent::map(QList<int>(list), multiplyBy2InPlace);
+
+        QList<Number> numberList;
+        numberList << 1 << 2 << 3;
+        QtConcurrent::map(QList<Number>(numberList), &Number::multiplyBy2);
+    }
+#endif
+
+#if 0
+    // not allowed: map() on a const list, where functors try to modify the items in the list
+    {
+        const QList<int> list = QList<int>() << 1 << 2 << 3;;
+
+        QtConcurrent::map(list, MultiplyBy2InPlace());
+        QtConcurrent::map(list, multiplyBy2InPlace);
+        QtConcurrent::map(list, multiplyBy2InPlace);
+
+        const QList<Number> numberList = QList<Number>() << 1 << 2 << 3;
+        QtConcurrent::map(numberList, &Number::multiplyBy2);
+    }
+#endif
+}
+
+void tst_QtConcurrentMap::blocking_map()
+{
+    // functors take arguments by reference, modifying the sequence in place
+    {
+        QList<int> list;
+        list << 1 << 2 << 3;
+
+        // functor
+        QtConcurrent::blockingMap(list, MultiplyBy2InPlace());
+        QCOMPARE(list, QList<int>() << 2 << 4 << 6);
+        QtConcurrent::blockingMap(list.begin(), list.end(), MultiplyBy2InPlace());
+        QCOMPARE(list, QList<int>() << 4 << 8 << 12);
+
+        // function
+        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
+        QCOMPARE(list, QList<int>() << 8 << 16 << 24);
+        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2InPlace);
+        QCOMPARE(list, QList<int>() << 16 << 32 << 48);
+
+        // bound function
+        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
+        QCOMPARE(list, QList<int>() << 32 << 64 << 96);
+        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2InPlace);
+        QCOMPARE(list, QList<int>() << 64 << 128 << 192);
+
+        // member function
+        QList<Number> numberList;
+        numberList << 1 << 2 << 3;
+        QtConcurrent::blockingMap(numberList, &Number::multiplyBy2);
+        QCOMPARE(numberList, QList<Number>() << 2 << 4 << 6);
+        QtConcurrent::blockingMap(numberList.begin(), numberList.end(), &Number::multiplyBy2);
+        QCOMPARE(numberList, QList<Number>() << 4 << 8 << 12);
+    }
+
+    // functors don't take arguments by reference, making these no-ops
+    {
+        QList<int> list;
+        list << 1 << 2 << 3;
+
+        // functor
+        QtConcurrent::blockingMap(list, MultiplyBy2Immutable());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QtConcurrent::blockingMap(list.begin(), list.end(), MultiplyBy2Immutable());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        // function
+        QtConcurrent::blockingMap(list, multiplyBy2Immutable);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2Immutable);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        // bound function
+        QtConcurrent::blockingMap(list, multiplyBy2Immutable);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2Immutable);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+    }
+
+    // Linked lists and forward iterators
+    {
+        QLinkedList<int> list;
+        list << 1 << 2 << 3;
+
+        // functor
+        QtConcurrent::blockingMap(list, MultiplyBy2InPlace());
+        QCOMPARE(list, QLinkedList<int>() << 2 << 4 << 6);
+        QtConcurrent::blockingMap(list.begin(), list.end(), MultiplyBy2InPlace());
+        QCOMPARE(list, QLinkedList<int>() << 4 << 8 << 12);
+
+        // function
+        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
+        QCOMPARE(list, QLinkedList<int>() << 8 << 16 << 24);
+        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2InPlace);
+        QCOMPARE(list, QLinkedList<int>() << 16 << 32 << 48);
+
+        // bound function
+        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
+        QCOMPARE(list, QLinkedList<int>() << 32 << 64 << 96);
+        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2InPlace);
+        QCOMPARE(list, QLinkedList<int>() << 64 << 128 << 192);
+
+        // member function
+        QLinkedList<Number> numberList;
+        numberList << 1 << 2 << 3;
+        QtConcurrent::blockingMap(numberList, &Number::multiplyBy2);
+        QCOMPARE(numberList, QLinkedList<Number>() << 2 << 4 << 6);
+        QtConcurrent::blockingMap(numberList.begin(), numberList.end(), &Number::multiplyBy2);
+        QCOMPARE(numberList, QLinkedList<Number>() << 4 << 8 << 12);
+    }
+
+#if 0
+    // not allowed: map() with immutable sequences makes no sense
+    {
+        const QList<int> list = QList<int>() << 1 << 2 << 3;
+
+        QtConcurrent::blockingMap(list, MultiplyBy2Immutable());
+        QtConcurrent::blockkng::map(list, multiplyBy2Immutable);
+        QtConcurrent::blockingMap(list, multiplyBy2Immutable);
+    }
+#endif
+
+#if 0
+    // not allowed: in place modification of a temp copy (since temp copy goes out of scope)
+    {
+        QList<int> list;
+        list << 1 << 2 << 3;
+
+        QtConcurrent::blockingMap(QList<int>(list), MultiplyBy2InPlace());
+        QtConcurrent::blockingMap(QList<int>(list), multiplyBy2);
+        QtConcurrent::blockingMap(QList<int>(list), multiplyBy2InPlace);
+
+        QList<Number> numberList;
+        numberList << 1 << 2 << 3;
+        QtConcurrent::blockingMap(QList<Number>(numberList), &Number::multiplyBy2);
+    }
+#endif
+
+#if 0
+    // not allowed: map() on a const list, where functors try to modify the items in the list
+    {
+        const QList<int> list = QList<int>() << 1 << 2 << 3;;
+
+        QtConcurrent::blockingMap(list, MultiplyBy2InPlace());
+        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
+        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
+
+        const QList<Number> numberList = QList<Number>() << 1 << 2 << 3;
+        QtConcurrent::blockingMap(numberList, &Number::multiplyBy2);
+    }
+#endif
+}
+
+int multiplyBy2(int x)
+{
+    int y = x * 2;
+    return y;
+}
+
+class MultiplyBy2
+{
+public:
+    typedef int result_type;
+
+    int operator()(int x) const
+    {
+        int y = x * 2;
+        return y;
+    }
+};
+
+double intToDouble(int x)
+{
+    return double(x);
+}
+
+class IntToDouble
+{
+public:
+    typedef double result_type;
+
+    double operator()(int x) const
+    {
+        return double(x);
+    }
+};
+
+int stringToInt(const QString &string)
+{
+    return string.toInt();
+}
+
+class StringToInt
+{
+public:
+    typedef int result_type;
+
+    int operator()(const QString &string) const
+    {
+        return string.toInt();
+    }
+};
+
+void tst_QtConcurrentMap::mapped()
+{
+    QList<int> list;
+    list << 1 << 2 << 3;
+    QLinkedList<int> linkedList;
+    linkedList << 1 << 2 << 3;
+    QList<Number> numberList;
+    numberList << 1 << 2 << 3;
+    QLinkedList<Number> numberLinkedList;
+    numberLinkedList << 1 << 2 << 3;
+
+    // functor
+    {
+        QList<int> list2 = QtConcurrent::mapped(list, MultiplyBy2()).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::mapped(list.constBegin(),
+                                                list.constEnd(),
+                                                MultiplyBy2()).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 = QtConcurrent::mapped(QList<int>(list), MultiplyBy2()).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+    {
+        QList<int> list2 = QtConcurrent::mapped(linkedList, MultiplyBy2()).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::mapped(linkedList.constBegin(),
+                                                linkedList.constEnd(),
+                                                MultiplyBy2()).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 =
+            QtConcurrent::mapped(QLinkedList<int>(linkedList), MultiplyBy2()).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+
+    // function
+    {
+        QList<int> list2 = QtConcurrent::mapped(list, multiplyBy2).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::mapped(list.constBegin(),
+                                                list.constEnd(),
+                                                multiplyBy2).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 = QtConcurrent::mapped(QList<int>(list), multiplyBy2).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+    {
+        QList<int> list2 = QtConcurrent::mapped(linkedList, multiplyBy2).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::mapped(linkedList.constBegin(),
+                                                linkedList.constEnd(),
+                                                multiplyBy2).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 =
+            QtConcurrent::mapped(QLinkedList<int>(linkedList), multiplyBy2).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+
+    // bound function
+    {
+        QList<int> list2 = QtConcurrent::mapped(list, multiplyBy2).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::mapped(list.constBegin(),
+                                                list.constEnd(),
+                                                multiplyBy2).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 = QtConcurrent::mapped(QList<int>(list), multiplyBy2).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+    {
+        QList<int> list2 = QtConcurrent::mapped(linkedList, multiplyBy2).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::mapped(linkedList.constBegin(),
+                                                linkedList.constEnd(),
+                                                multiplyBy2)
+                           .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 = QtConcurrent::mapped(QLinkedList<int>(linkedList), multiplyBy2)
+                           .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+
+    // const member function
+    {
+        QList<Number> numberList2 = QtConcurrent::mapped(numberList, &Number::multipliedBy2)
+                                    .results();
+        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList2, QList<Number>() << 2 << 4 << 6);
+
+        QList<Number> numberList3 = QtConcurrent::mapped(numberList.constBegin(),
+                                                         numberList.constEnd(),
+                                                         &Number::multipliedBy2)
+                                    .results();
+        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList3, QList<Number>() << 2 << 4 << 6);
+
+        QList<Number> numberList4 = QtConcurrent::mapped(QList<Number>(numberList),
+                                                         &Number::multipliedBy2)
+                                    .results();
+        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList4, QList<Number>() << 2 << 4 << 6);
+    }
+    {
+        QList<Number> numberList2 = QtConcurrent::mapped(numberLinkedList, &Number::multipliedBy2)
+                                    .results();
+        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList2, QList<Number>() << 2 << 4 << 6);
+
+        QList<Number> numberList3 = QtConcurrent::mapped(numberLinkedList.constBegin(),
+                                                         numberLinkedList.constEnd(),
+                                                         &Number::multipliedBy2)
+                                    .results();
+        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList3, QList<Number>() << 2 << 4 << 6);
+
+        QList<Number> numberList4 = QtConcurrent::mapped(QLinkedList<Number>(numberLinkedList),
+                                                         &Number::multipliedBy2)
+                                    .results();
+        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList4, QList<Number>() << 2 << 4 << 6);
+    }
+
+    // change the value_type, same container
+
+    // functor
+    {
+        QList<double> list2 = QtConcurrent::mapped(list, IntToDouble()).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::mapped(list.constBegin(),
+                                                   list.constEnd(),
+                                                   IntToDouble())
+                              .results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list4 = QtConcurrent::mapped(QList<int>(list),
+                                                   IntToDouble())
+                              .results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+    {
+        QList<double> list2 = QtConcurrent::mapped(linkedList, IntToDouble()).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::mapped(linkedList.constBegin(),
+                                                   linkedList.constEnd(),
+                                                   IntToDouble())
+                              .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list4 = QtConcurrent::mapped(QLinkedList<int>(linkedList),
+                                                   IntToDouble())
+                              .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+
+    // function
+    {
+        QList<double> list2 = QtConcurrent::mapped(list, intToDouble).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::mapped(list.constBegin(),
+                                                   list.constEnd(),
+                                                   intToDouble)
+                              .results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list4 = QtConcurrent::mapped(QList<int>(list), intToDouble).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+    {
+        QList<double> list2 = QtConcurrent::mapped(linkedList, intToDouble).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::mapped(linkedList.constBegin(),
+                                                   linkedList.constEnd(),
+                                                   intToDouble)
+                              .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list4 = QtConcurrent::mapped(QLinkedList<int>(linkedList), intToDouble)
+                              .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+
+    // bound function
+    {
+        QList<double> list2 = QtConcurrent::mapped(list, intToDouble).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::mapped(list.constBegin(),
+                                                   list.constEnd(),
+                                                   intToDouble)
+                              .results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+
+        QList<double> list4 = QtConcurrent::mapped(QList<int>(list),
+                                                   intToDouble)
+                              .results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+    {
+        QList<double> list2 = QtConcurrent::mapped(linkedList, intToDouble).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::mapped(linkedList.constBegin(),
+                                                   linkedList.constEnd(),
+                                                   intToDouble)
+                              .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+
+        QList<double> list4 = QtConcurrent::mapped(QLinkedList<int>(linkedList),
+                                                   intToDouble)
+                              .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+
+    // const member function
+    {
+        QList<QString> list2 = QtConcurrent::mapped(numberList, &Number::toString).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<QString>() << "1" << "2" << "3");
+
+        QList<QString> list3 = QtConcurrent::mapped(numberList.constBegin(),
+                                                    numberList.constEnd(),
+                                                    &Number::toString)
+                               .results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<QString>() << "1" << "2" << "3");
+
+        QList<QString> list4 = QtConcurrent::mapped(QList<Number>(numberList), &Number::toString)
+                               .results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<QString>() << "1" << "2" << "3");
+    }
+    {
+        QList<QString> list2 = QtConcurrent::mapped(numberLinkedList, &Number::toString).results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<QString>() << "1" << "2" << "3");
+
+        QList<QString> list3 = QtConcurrent::mapped(numberLinkedList.constBegin(),
+                                                    numberLinkedList.constEnd(),
+                                                    &Number::toString)
+                               .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<QString>() << "1" << "2" << "3");
+
+        QList<QString> list4 = QtConcurrent::mapped(QLinkedList<Number>(numberLinkedList),
+                                                    &Number::toString)
+                               .results();
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<QString>() << "1" << "2" << "3");
+    }
+
+    // change the value_type
+    {
+        QList<QString> strings = QStringList() << "1" << "2" << "3";
+        QList<int> list = QtConcurrent::mapped(strings, StringToInt()).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list2 = QtConcurrent::mapped(strings.constBegin(),
+                                                strings.constEnd(),
+                                                StringToInt())
+                           .results();
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+    }
+    {
+        QList<QString> strings = QStringList() << "1" << "2" << "3";
+        QList<int> list = QtConcurrent::mapped(strings, stringToInt).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list2 = QtConcurrent::mapped(strings.constBegin(),
+                                                strings.constEnd(),
+                                                stringToInt).results();
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+    }
+
+    {
+        QList<int> numberList2 = QtConcurrent::mapped(numberList, &Number::toInt).results();
+        QCOMPARE(numberList2, QList<int>() << 1 << 2 << 3);
+
+        QList<int> numberList3 = QtConcurrent::mapped(numberList.constBegin(),
+                                                      numberList.constEnd(),
+                                                      &Number::toInt)
+                                 .results();
+        QCOMPARE(numberList3, QList<int>() << 1 << 2 << 3);
+    }
+
+    // change the value_type from QStringList
+    {
+        QStringList strings = QStringList() << "1" << "2" << "3";
+        QList<int> list = QtConcurrent::mapped(strings, StringToInt()).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list2 = QtConcurrent::mapped(strings.constBegin(),
+                                                strings.constEnd(),
+                                                StringToInt())
+                           .results();
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+    }
+    {
+        QStringList strings = QStringList() << "1" << "2" << "3";
+        QList<int> list = QtConcurrent::mapped(strings, stringToInt).results();
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list2 = QtConcurrent::mapped(strings.constBegin(),
+                                                strings.constEnd(),
+                                                stringToInt)
+                           .results();
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+    }
+}
+
+void tst_QtConcurrentMap::blocking_mapped()
+{
+    QList<int> list;
+    list << 1 << 2 << 3;
+    QLinkedList<int> linkedList;
+    linkedList << 1 << 2 << 3;
+    QList<Number> numberList;
+    numberList << 1 << 2 << 3;
+    QLinkedList<Number> numberLinkedList;
+    numberLinkedList << 1 << 2 << 3;
+
+    // functor
+    {
+        QList<int> list2 = QtConcurrent::blockingMapped(list, MultiplyBy2());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::blockingMapped<QList<int> >(list.constBegin(),
+                                                                       list.constEnd(),
+                                                                       MultiplyBy2());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 = QtConcurrent::blockingMapped(QList<int>(list), MultiplyBy2());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingMapped(linkedList, MultiplyBy2());
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4 << 6);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<int> >(linkedList.constBegin(),
+                                                                       linkedList.constEnd(),
+                                                                       MultiplyBy2());
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 2 << 4 << 6);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::blockingMapped(QLinkedList<int>(linkedList), MultiplyBy2());
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 2 << 4 << 6);
+    }
+
+    // function
+    {
+        QList<int> list2 = QtConcurrent::blockingMapped(list, multiplyBy2);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::blockingMapped<QList<int> >(list.constBegin(),
+                                                             list.constEnd(),
+                                                             multiplyBy2);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 = QtConcurrent::blockingMapped(QList<int>(list), multiplyBy2);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingMapped(linkedList, multiplyBy2);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4 << 6);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<int> >(linkedList.constBegin(),
+                                                             linkedList.constEnd(),
+                                                             multiplyBy2);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 2 << 4 << 6);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::blockingMapped(QLinkedList<int>(linkedList), multiplyBy2);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 2 << 4 << 6);
+    }
+
+    // bound function
+    {
+        QList<int> list2 = QtConcurrent::blockingMapped(list, multiplyBy2);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list3 = QtConcurrent::blockingMapped<QList<int> >(list.constBegin(),
+                                                             list.constEnd(),
+                                                             multiplyBy2);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
+
+        QList<int> list4 = QtConcurrent::blockingMapped(QList<int>(list), multiplyBy2);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingMapped(linkedList, multiplyBy2);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4 << 6);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<int> >(linkedList.constBegin(),
+                                                             linkedList.constEnd(),
+                                                             multiplyBy2);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 2 << 4 << 6);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::blockingMapped(QLinkedList<int>(linkedList), multiplyBy2);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 2 << 4 << 6);
+    }
+
+    // const member function
+    {
+        QList<Number> numberList2 = QtConcurrent::blockingMapped(numberList, &Number::multipliedBy2);
+        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList2, QList<Number>() << 2 << 4 << 6);
+
+        QList<Number> numberList3 = QtConcurrent::blockingMapped<QList<Number> >(numberList.constBegin(),
+                                                                         numberList.constEnd(),
+                                                                         &Number::multipliedBy2);
+        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList3, QList<Number>() << 2 << 4 << 6);
+
+        QList<Number> numberList4 = QtConcurrent::blockingMapped(QList<Number>(numberList),
+                                                         &Number::multipliedBy2);
+        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberList4, QList<Number>() << 2 << 4 << 6);
+    }
+    {
+        QLinkedList<Number> numberLinkedList2 = QtConcurrent::blockingMapped(numberLinkedList, &Number::multipliedBy2);
+        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberLinkedList2, QLinkedList<Number>() << 2 << 4 << 6);
+
+        QLinkedList<Number> numberLinkedList3 = QtConcurrent::blockingMapped<QLinkedList<Number> >(numberLinkedList.constBegin(),
+                                                                         numberLinkedList.constEnd(),
+                                                                         &Number::multipliedBy2);
+        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberLinkedList3, QLinkedList<Number>() << 2 << 4 << 6);
+
+        QLinkedList<Number> numberLinkedList4 = QtConcurrent::blockingMapped(QLinkedList<Number>(numberLinkedList),
+                                                         &Number::multipliedBy2);
+        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
+        QCOMPARE(numberLinkedList4, QLinkedList<Number>() << 2 << 4 << 6);
+    }
+
+    // change the value_type, same container
+
+    // functor
+    {
+        QList<double> list2 = QtConcurrent::blockingMapped<QList<double> >(list, IntToDouble());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::blockingMapped<QList<double> >(list.constBegin(),
+                                                                   list.constEnd(),
+                                                                   IntToDouble());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list4 = QtConcurrent::blockingMapped<QList<double> >(QList<int>(list),
+                                                                   IntToDouble());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+    {
+        QLinkedList<double> linkedList2 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList, IntToDouble());
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+
+        QLinkedList<double> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList.constBegin(),
+                                                                   linkedList.constEnd(),
+                                                                   IntToDouble());
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+
+        QLinkedList<double> linkedList4 = QtConcurrent::blockingMapped<QLinkedList<double> >(QLinkedList<int>(linkedList),
+                                                                   IntToDouble());
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+    }
+
+    // function
+    {
+        QList<double> list2 = QtConcurrent::blockingMapped<QList<double> >(list, intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::blockingMapped<QList<double> >(list.constBegin(),
+                                                                   list.constEnd(),
+                                                                   intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list4 = QtConcurrent::blockingMapped<QList<double> >(QList<int>(list), intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+    {
+        QLinkedList<double> linkedList2 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList, intToDouble);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+
+        QLinkedList<double> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList.constBegin(),
+                                                                   linkedList.constEnd(),
+                                                                   intToDouble);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+
+        QLinkedList<double> linkedList4 = QtConcurrent::blockingMapped<QLinkedList<double> >(QLinkedList<int>(linkedList), intToDouble);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+    }
+
+    // bound function
+    {
+        QList<double> list2 = QtConcurrent::blockingMapped<QList<double> >(list, intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
+
+        QList<double> list3 = QtConcurrent::blockingMapped<QList<double> >(list.constBegin(),
+                                                                   list.constEnd(),
+                                                                   intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
+
+
+        QList<double> list4 = QtConcurrent::blockingMapped<QList<double> >(QList<int>(list),
+                                                                   intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
+    }
+    {
+        QLinkedList<double> linkedList2 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList, intToDouble);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+
+        QLinkedList<double> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList.constBegin(),
+                                                                   linkedList.constEnd(),
+                                                                   intToDouble);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+
+
+        QLinkedList<double> linkedList4 = QtConcurrent::blockingMapped<QLinkedList<double> >(QLinkedList<int>(linkedList),
+                                                                   intToDouble);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
+    }
+
+    // const member function
+    {
+        QList<QString> list2 =
+            QtConcurrent::blockingMapped<QList<QString> >(numberList, &Number::toString);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<QString>() << "1" << "2" << "3");
+
+        QList<QString> list3 = QtConcurrent::blockingMapped<QList<QString> >(numberList.constBegin(),
+                                                                     numberList.constEnd()
+                                                                     , &Number::toString);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<QString>() << "1" << "2" << "3");
+
+        QList<QString> list4 =
+            QtConcurrent::blockingMapped<QList<QString> >(QList<Number>(numberList), &Number::toString);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<QString>() << "1" << "2" << "3");
+    }
+    {
+        QLinkedList<QString> linkedList2 =
+            QtConcurrent::blockingMapped<QLinkedList<QString> >(numberLinkedList, &Number::toString);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<QString>() << "1" << "2" << "3");
+
+        QLinkedList<QString> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<QString> >(numberLinkedList.constBegin(),
+                                                                     numberLinkedList.constEnd()
+                                                                     , &Number::toString);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<QString>() << "1" << "2" << "3");
+
+        QLinkedList<QString> linkedList4 =
+            QtConcurrent::blockingMapped<QLinkedList<QString> >(QLinkedList<Number>(numberLinkedList), &Number::toString);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<QString>() << "1" << "2" << "3");
+    }
+
+    // change the value_type
+    {
+        QList<QString> strings = QStringList() << "1" << "2" << "3";
+        QList<int> list = QtConcurrent::blockingMapped(strings, StringToInt());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list2 = QtConcurrent::blockingMapped<QList<int> >(strings.constBegin(),
+                                                             strings.constEnd(),
+                                                             StringToInt());
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+    }
+    {
+        QList<QString> strings = QStringList() << "1" << "2" << "3";
+        QList<int> list = QtConcurrent::blockingMapped(strings, stringToInt);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list2 = QtConcurrent::blockingMapped<QList<int> >(strings.constBegin(),
+                                                             strings.constEnd(),
+                                                             stringToInt);
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+    }
+
+    {
+        QList<int> numberList2 = QtConcurrent::blockingMapped(numberList, &Number::toInt);
+        QCOMPARE(numberList2, QList<int>() << 1 << 2 << 3);
+
+        QList<int> numberList3 = QtConcurrent::blockingMapped<QList<int> >(numberList.constBegin(),
+                                                                   numberList.constEnd(),
+                                                                   &Number::toInt);
+        QCOMPARE(numberList3, QList<int>() << 1 << 2 << 3);
+    }
+
+    // change the value_type from QStringList
+    {
+        QStringList strings = QStringList() << "1" << "2" << "3";
+        QList<int> list = QtConcurrent::blockingMapped(strings, StringToInt());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list2 = QtConcurrent::blockingMapped<QList<int> >(strings.constBegin(),
+                                                             strings.constEnd(),
+                                                             StringToInt());
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+    }
+    {
+        QStringList strings = QStringList() << "1" << "2" << "3";
+        QList<int> list = QtConcurrent::blockingMapped(strings, stringToInt);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list2 = QtConcurrent::blockingMapped<QList<int> >(strings.constBegin(),
+                                                             strings.constEnd(),
+                                                             stringToInt);
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+    }
+
+    // functor
+    {
+        QVector<double> list2 = QtConcurrent::blockingMapped<QVector<double> >(list, IntToDouble());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QVector<double>() << 1.0 << 2.0 << 3.0);
+
+        QVector<double> list3 = QtConcurrent::blockingMapped<QVector<double> >(list.constBegin(),
+                                                                       list.constEnd(),
+                                                                       IntToDouble());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QVector<double>() << 1.0 << 2.0 << 3.0);
+
+        QVector<double> list4 = QtConcurrent::blockingMapped<QVector<double> >(QList<int>(list),
+                                                                       IntToDouble());
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QVector<double>() << 1.0 << 2.0 << 3.0);
+
+        QStringList strings = QStringList() << "1" << "2" << "3";
+        QVector<int> list5 = QtConcurrent::blockingMapped<QVector<int> >(strings, StringToInt());
+        QCOMPARE(list5, QVector<int>() << 1 << 2 << 3);
+
+        QVector<int> list6 = QtConcurrent::blockingMapped<QVector<int> >(strings.constBegin(),
+                                                                 strings.constEnd(),
+                                                                 StringToInt());
+        QCOMPARE(list6, QVector<int>() << 1 << 2 << 3);
+
+        QVector<int> list7 = QtConcurrent::blockingMapped<QVector<int> >(QStringList(strings),
+                                                                 StringToInt());
+        QCOMPARE(list7, QVector<int>() << 1 << 2 << 3);
+    }
+
+    // function
+    {
+        QVector<double> list2 = QtConcurrent::blockingMapped<QVector<double> >(list, intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QVector<double>() << 1.0 << 2.0 << 3.0);
+
+        QVector<double> list3 = QtConcurrent::blockingMapped<QVector<double> >(list.constBegin(),
+                                                                       list.constEnd(),
+                                                                       intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QVector<double>() << 1.0 << 2.0 << 3.0);
+
+        QVector<double> list4 = QtConcurrent::blockingMapped<QVector<double> >(QList<int>(list),
+                                                                       intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QVector<double>() << 1.0 << 2.0 << 3.0);
+
+        QStringList strings = QStringList() << "1" << "2" << "3";
+        QVector<int> list5 = QtConcurrent::blockingMapped<QVector<int> >(strings, stringToInt);
+        QCOMPARE(list5, QVector<int>() << 1 << 2 << 3);
+
+        QVector<int> list6 = QtConcurrent::blockingMapped<QVector<int> >(strings.constBegin(),
+                                                                 strings.constEnd(),
+                                                                 stringToInt);
+        QCOMPARE(list6, QVector<int>() << 1 << 2 << 3);
+
+        QVector<int> list7 = QtConcurrent::blockingMapped<QVector<int> >(QStringList(strings),
+                                                                 stringToInt);
+        QCOMPARE(list7, QVector<int>() << 1 << 2 << 3);
+    }
+
+    // bound function
+    {
+        QVector<double> list2 = QtConcurrent::blockingMapped<QVector<double> >(list, intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QVector<double>() << 1.0 << 2.0 << 3.0);
+
+        QVector<double> list3 = QtConcurrent::blockingMapped<QVector<double> >(QList<int>(list), intToDouble);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QVector<double>() << 1.0 << 2.0 << 3.0);
+
+        QStringList strings = QStringList() << "1" << "2" << "3";
+        QVector<int> list4 = QtConcurrent::blockingMapped<QVector<int> >(strings, stringToInt);
+        QCOMPARE(list4, QVector<int>() << 1 << 2 << 3);
+
+        QVector<int> list5 = QtConcurrent::blockingMapped<QVector<int> >(QStringList(strings), stringToInt);
+        QCOMPARE(list5, QVector<int>() << 1 << 2 << 3);
+    }
+
+    // const member function
+    {
+        QVector<QString> list2 = QtConcurrent::blockingMapped<QVector<QString> >(numberList, &Number::toString);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QVector<QString>() << "1" << "2" << "3");
+
+        QVector<QString> list3 =
+            QtConcurrent::blockingMapped<QVector<QString> >(QList<Number>(numberList), &Number::toString);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QVector<QString>() << "1" << "2" << "3");
+
+        // not allowed: const member function where all arguments have default values
+#if 0
+        QStringList strings = QStringList() << "1" << "2" << "3";
+        QVector<int> list4 = QtConcurrent::blockingMapped<QVector<int> >(strings, &QString::toInt);
+        QCOMPARE(list4, QVector<int>() << 1 << 2 << 3);
+
+        QVector<int> list5 = QtConcurrent::blockingMapped<QVector<int> >(QStringList(strings), &QString::toInt);
+        QCOMPARE(list5, QVector<int>() << 1 << 2 << 3);
+#endif
+    }
+}
+
+int intSquare(int x)
+{
+    return x * x;
+}
+
+class IntSquare
+{
+public:
+    typedef int result_type;
+
+    int operator()(int x)
+    {
+        return x * x;
+    }
+};
+
+void tst_QtConcurrentMap::mappedReduced()
+{
+    QList<int> list;
+    list << 1 << 2 << 3;
+    QLinkedList<int> linkedList;
+    linkedList << 1 << 2 << 3;
+    QList<Number> numberList;
+    numberList << 1 << 2 << 3;
+    QLinkedList<Number> numberLinkedList;
+    numberLinkedList << 1 << 2 << 3;
+
+    // test Q_DECLARE_OPERATORS_FOR_FLAGS
+    QtConcurrent::ReduceOptions opt = (QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce);
+    QVERIFY(opt);
+
+    // functor-functor
+    {
+        int sum = QtConcurrent::mappedReduced<int>(list, IntSquare(), IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    IntSquare(),
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced<int>(QList<int>(list), IntSquare(), IntSumReduce());
+        QCOMPARE(sum3, 14);
+
+        int sum4 = QtConcurrent::mappedReduced<int>(list, intSquare, intSumReduce);
+        QCOMPARE(sum4, 14);
+        int sum5 = QtConcurrent::mappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum5, 14);
+
+        int sum6 = QtConcurrent::mappedReduced<int>(QList<int>(list),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum6, 14);
+    }
+    {
+        int sum = QtConcurrent::mappedReduced<int>(linkedList, IntSquare(), IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced<int>(linkedList.constBegin(),
+                                                    linkedList.constEnd(),
+                                                    IntSquare(),
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(linkedList), IntSquare(), IntSumReduce());
+        QCOMPARE(sum3, 14);
+
+        int sum4 = QtConcurrent::mappedReduced<int>(linkedList, intSquare, intSumReduce);
+        QCOMPARE(sum4, 14);
+        int sum5 = QtConcurrent::mappedReduced<int>(linkedList.constBegin(),
+                                                    linkedList.constEnd(),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum5, 14);
+
+        int sum6 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(linkedList),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum6, 14);
+    }
+
+    // function-functor
+    {
+        int sum = QtConcurrent::mappedReduced<int>(list, intSquare, IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    intSquare,
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced<int>(QList<int>(list), intSquare, IntSumReduce());
+        QCOMPARE(sum3, 14);
+    }
+    {
+        int sum = QtConcurrent::mappedReduced<int>(linkedList, intSquare, IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced<int>(linkedList.constBegin(),
+                                                    linkedList.constEnd(),
+                                                    intSquare,
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(linkedList), intSquare, IntSumReduce());
+        QCOMPARE(sum3, 14);
+    }
+
+    // functor-function
+    {
+        int sum = QtConcurrent::mappedReduced(list, IntSquare(), intSumReduce);
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced(list.constBegin(),
+                                               list.constEnd(),
+                                               IntSquare(),
+                                               intSumReduce);
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced(QList<int>(list), IntSquare(), intSumReduce);
+        QCOMPARE(sum3, 14);
+    }
+    {
+        int sum = QtConcurrent::mappedReduced(linkedList, IntSquare(), intSumReduce);
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced(linkedList.constBegin(),
+                                               linkedList.constEnd(),
+                                               IntSquare(),
+                                               intSumReduce);
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced(QLinkedList<int>(linkedList), IntSquare(), intSumReduce);
+        QCOMPARE(sum3, 14);
+    }
+
+    // function-function
+    {
+        int sum = QtConcurrent::mappedReduced(list, intSquare, intSumReduce);
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced(list.constBegin(),
+                                               list.constEnd(),
+                                               intSquare,
+                                               intSumReduce);
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced(QList<int>(list), intSquare, intSumReduce);
+        QCOMPARE(sum3, 14);
+    }
+    {
+        int sum = QtConcurrent::mappedReduced(linkedList, intSquare, intSumReduce);
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced(linkedList.constBegin(),
+                                               linkedList.constEnd(),
+                                               intSquare,
+                                               intSumReduce);
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced(QLinkedList<int>(linkedList), intSquare, intSumReduce);
+        QCOMPARE(sum3, 14);
+    }
+
+    // functor-member
+    {
+        QList<int> list2 = QtConcurrent::mappedReduced(list,
+                                                       IntSquare(),
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 1 << 4 << 9);
+
+        QList<int> list3 = QtConcurrent::mappedReduced(list.constBegin(),
+                                                       list.constEnd(),
+                                                       IntSquare(),
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 1 << 4 << 9);
+
+        QList<int> list4 = QtConcurrent::mappedReduced(QList<int>(list),
+                                                       IntSquare(),
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 1 << 4 << 9);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::mappedReduced(linkedList,
+                                                       IntSquare(),
+                                                       &QLinkedList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 4 << 9);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::mappedReduced(linkedList.constBegin(),
+                                                       linkedList.constEnd(),
+                                                       IntSquare(),
+                                                       &QLinkedList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 4 << 9);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::mappedReduced(QLinkedList<int>(linkedList),
+                                                       IntSquare(),
+                                                       &QLinkedList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 4 << 9);
+    }
+
+    // member-functor
+    {
+        int sum = QtConcurrent::mappedReduced<int>(numberList, &Number::toInt, IntSumReduce());
+        QCOMPARE(sum, 6);
+        int sum2 = QtConcurrent::mappedReduced<int>(numberList.constBegin(),
+                                                    numberList.constEnd(),
+                                                    &Number::toInt,
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 6);
+
+        int sum3 = QtConcurrent::mappedReduced<int>(QList<Number>(numberList),
+                                                    &Number::toInt,
+                                                    IntSumReduce());
+        QCOMPARE(sum3, 6);
+    }
+    {
+        int sum = QtConcurrent::mappedReduced<int>(numberLinkedList, &Number::toInt, IntSumReduce());
+        QCOMPARE(sum, 6);
+        int sum2 = QtConcurrent::mappedReduced<int>(numberLinkedList.constBegin(),
+                                                    numberLinkedList.constEnd(),
+                                                    &Number::toInt,
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 6);
+
+        int sum3 = QtConcurrent::mappedReduced<int>(QLinkedList<Number>(numberLinkedList),
+                                                    &Number::toInt,
+                                                    IntSumReduce());
+        QCOMPARE(sum3, 6);
+    }
+
+    // member-member
+    {
+        QList<int> list2 = QtConcurrent::mappedReduced(numberList,
+                                                       &Number::toInt,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list3 = QtConcurrent::mappedReduced(numberList.constBegin(),
+                                                       numberList.constEnd(),
+                                                       &Number::toInt,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list3, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list4 = QtConcurrent::mappedReduced(QList<Number>(numberList),
+                                                       &Number::toInt,
+                                                       &QList<int>::push_back, OrderedReduce);
+        QCOMPARE(list4, QList<int>() << 1 << 2 << 3);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::mappedReduced(numberLinkedList,
+                                                       &Number::toInt,
+                                                       &QLinkedList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 2 << 3);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::mappedReduced(numberLinkedList.constBegin(),
+                                                       numberLinkedList.constEnd(),
+                                                       &Number::toInt,
+                                                       &QLinkedList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 2 << 3);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::mappedReduced(QLinkedList<Number>(numberLinkedList),
+                                                       &Number::toInt,
+                                                       &QLinkedList<int>::push_back, OrderedReduce);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 2 << 3);
+    }
+
+    // function-member
+    {
+        QList<int> list2 = QtConcurrent::mappedReduced(list,
+                                                       intSquare,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 1 << 4 << 9);
+
+        QList<int> list3 = QtConcurrent::mappedReduced(list.constBegin(),
+                                                       list.constEnd(),
+                                                       intSquare,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 1 << 4 << 9);
+
+        QList<int> list4 = QtConcurrent::mappedReduced(QList<int>(list),
+                                                       intSquare,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 1 << 4 << 9);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::mappedReduced(linkedList,
+                                                       intSquare,
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 4 << 9);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::mappedReduced(linkedList.constBegin(),
+                                                       linkedList.constEnd(),
+                                                       intSquare,
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 4 << 9);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::mappedReduced(QLinkedList<int>(linkedList),
+                                                       intSquare,
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 4 << 9);
+    }
+
+    // member-function
+    {
+        int sum = QtConcurrent::mappedReduced(numberList,
+                                              &Number::toInt,
+                                              intSumReduce);
+        QCOMPARE(sum, 6);
+        int sum2 = QtConcurrent::mappedReduced(numberList.constBegin(),
+                                               numberList.constEnd(),
+                                              &Number::toInt,
+                                              intSumReduce);
+        QCOMPARE(sum2, 6);
+
+        int sum3 = QtConcurrent::mappedReduced(QList<Number>(numberList),
+                                               &Number::toInt,
+                                               intSumReduce);
+        QCOMPARE(sum3, 6);
+    }
+    {
+        int sum = QtConcurrent::mappedReduced(numberLinkedList,
+                                              &Number::toInt,
+                                              intSumReduce);
+        QCOMPARE(sum, 6);
+        int sum2 = QtConcurrent::mappedReduced(numberLinkedList.constBegin(),
+                                               numberLinkedList.constEnd(),
+                                              &Number::toInt,
+                                              intSumReduce);
+        QCOMPARE(sum2, 6);
+
+        int sum3 = QtConcurrent::mappedReduced(QLinkedList<Number>(numberLinkedList),
+                                               &Number::toInt,
+                                               intSumReduce);
+        QCOMPARE(sum3, 6);
+    }
+
+    // linked lists
+    {
+
+        QLinkedList<int> list;
+        list << 1 << 2 << 3;
+
+        QLinkedList<Number> numberList;
+        numberList << 1 << 2 << 3;
+
+        int sum = QtConcurrent::mappedReduced<int>(list, IntSquare(), IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::mappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    IntSquare(),
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(list), IntSquare(), IntSumReduce());
+        QCOMPARE(sum3, 14);
+
+        int sum4 = QtConcurrent::mappedReduced<int>(list, intSquare, intSumReduce);
+        QCOMPARE(sum4, 14);
+        int sum5 = QtConcurrent::mappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum5, 14);
+
+        int sum6 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(list),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum6, 14);
+    }
+
+    // ### the same as above, with an initial result value
+}
+
+void tst_QtConcurrentMap::blocking_mappedReduced()
+{
+    QList<int> list;
+    list << 1 << 2 << 3;
+    QLinkedList<int> linkedList;
+    linkedList << 1 << 2 << 3;
+    QList<Number> numberList;
+    numberList << 1 << 2 << 3;
+    QLinkedList<Number> numberLinkedList;
+    numberLinkedList << 1 << 2 << 3;
+
+    // functor-functor
+    {
+        int sum = QtConcurrent::blockingMappedReduced<int>(list, IntSquare(), IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    IntSquare(),
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced<int>(QList<int>(list), IntSquare(), IntSumReduce());
+        QCOMPARE(sum3, 14);
+
+        int sum4 = QtConcurrent::blockingMappedReduced<int>(list, intSquare, intSumReduce);
+        QCOMPARE(sum4, 14);
+        int sum5 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum5, 14);
+
+        int sum6 = QtConcurrent::blockingMappedReduced<int>(QList<int>(list),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum6, 14);
+    }
+    {
+        int sum = QtConcurrent::blockingMappedReduced<int>(linkedList, IntSquare(), IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced<int>(linkedList.constBegin(),
+                                                    linkedList.constEnd(),
+                                                    IntSquare(),
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(linkedList), IntSquare(), IntSumReduce());
+        QCOMPARE(sum3, 14);
+
+        int sum4 = QtConcurrent::blockingMappedReduced<int>(linkedList, intSquare, intSumReduce);
+        QCOMPARE(sum4, 14);
+        int sum5 = QtConcurrent::blockingMappedReduced<int>(linkedList.constBegin(),
+                                                    linkedList.constEnd(),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum5, 14);
+
+        int sum6 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(linkedList),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum6, 14);
+    }
+
+    // function-functor
+    {
+        int sum = QtConcurrent::blockingMappedReduced<int>(list, intSquare, IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    intSquare,
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced<int>(QList<int>(list), intSquare, IntSumReduce());
+        QCOMPARE(sum3, 14);
+    }
+    {
+        int sum = QtConcurrent::blockingMappedReduced<int>(linkedList, intSquare, IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced<int>(linkedList.constBegin(),
+                                                    linkedList.constEnd(),
+                                                    intSquare,
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(linkedList), intSquare, IntSumReduce());
+        QCOMPARE(sum3, 14);
+    }
+
+    // functor-function
+    {
+        int sum = QtConcurrent::blockingMappedReduced(list, IntSquare(), intSumReduce);
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced(list.constBegin(),
+                                               list.constEnd(),
+                                               IntSquare(),
+                                               intSumReduce);
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced(QList<int>(list), IntSquare(), intSumReduce);
+        QCOMPARE(sum3, 14);
+    }
+    {
+        int sum = QtConcurrent::blockingMappedReduced(linkedList, IntSquare(), intSumReduce);
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced(linkedList.constBegin(),
+                                               linkedList.constEnd(),
+                                               IntSquare(),
+                                               intSumReduce);
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced(QLinkedList<int>(linkedList), IntSquare(), intSumReduce);
+        QCOMPARE(sum3, 14);
+    }
+
+    // function-function
+    {
+        int sum = QtConcurrent::blockingMappedReduced(list, intSquare, intSumReduce);
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced(list.constBegin(),
+                                                         list.constEnd(),
+                                                         intSquare,
+                                                         intSumReduce);
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced(QList<int>(list), intSquare, intSumReduce);
+        QCOMPARE(sum3, 14);
+    }
+    {
+        int sum = QtConcurrent::blockingMappedReduced(linkedList, intSquare, intSumReduce);
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced(linkedList.constBegin(),
+                                               linkedList.constEnd(),
+                                               intSquare,
+                                               intSumReduce);
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced(QLinkedList<int>(linkedList), intSquare, intSumReduce);
+        QCOMPARE(sum3, 14);
+    }
+
+    // functor-member
+    {
+        QList<int> list2 = QtConcurrent::blockingMappedReduced(list,
+                                                       IntSquare(),
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 1 << 4 << 9);
+
+        QList<int> list3 = QtConcurrent::blockingMappedReduced(list.constBegin(),
+                                                       list.constEnd(),
+                                                       IntSquare(),
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 1 << 4 << 9);
+
+        QList<int> list4 = QtConcurrent::blockingMappedReduced(QList<int>(list),
+                                                       IntSquare(),
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 1 << 4 << 9);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingMappedReduced(linkedList,
+                                                       IntSquare(),
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 4 << 9);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::blockingMappedReduced(linkedList.constBegin(),
+                                                       linkedList.constEnd(),
+                                                       IntSquare(),
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 4 << 9);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::blockingMappedReduced(QLinkedList<int>(linkedList),
+                                                       IntSquare(),
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 4 << 9);
+    }
+
+    // member-functor
+    {
+        int sum = QtConcurrent::blockingMappedReduced<int>(numberList, &Number::toInt,
+                                                             IntSumReduce());
+        QCOMPARE(sum, 6);
+        int sum2 = QtConcurrent::blockingMappedReduced<int>(numberList.constBegin(),
+                                                              numberList.constEnd(),
+                                                              &Number::toInt,
+                                                              IntSumReduce());
+        QCOMPARE(sum2, 6);
+
+        int sum3 = QtConcurrent::blockingMappedReduced<int>(QList<Number>(numberList),
+                                                              &Number::toInt,
+                                                              IntSumReduce());
+        QCOMPARE(sum3, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingMappedReduced<int>(numberLinkedList, &Number::toInt, IntSumReduce());
+        QCOMPARE(sum, 6);
+        int sum2 = QtConcurrent::blockingMappedReduced<int>(numberLinkedList.constBegin(),
+                                                    numberLinkedList.constEnd(),
+                                                    &Number::toInt,
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 6);
+
+        int sum3 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<Number>(numberLinkedList),
+                                                    &Number::toInt,
+                                                    IntSumReduce());
+        QCOMPARE(sum3, 6);
+    }
+
+    // member-member
+    {
+        QList<int> list2 = QtConcurrent::blockingMappedReduced(numberList,
+                                                       &Number::toInt,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list3 = QtConcurrent::blockingMappedReduced(numberList.constBegin(),
+                                                       numberList.constEnd(),
+                                                       &Number::toInt,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list3, QList<int>() << 1 << 2 << 3);
+
+        QList<int> list4 = QtConcurrent::blockingMappedReduced(QList<Number>(numberList),
+                                                       &Number::toInt,
+                                                       &QList<int>::push_back, OrderedReduce);
+        QCOMPARE(list4, QList<int>() << 1 << 2 << 3);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingMappedReduced(numberLinkedList,
+                                                       &Number::toInt,
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 2 << 3);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::blockingMappedReduced(numberLinkedList.constBegin(),
+                                                       numberLinkedList.constEnd(),
+                                                       &Number::toInt,
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 2 << 3);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::blockingMappedReduced(QLinkedList<Number>(numberLinkedList),
+                                                       &Number::toInt,
+                                                       &QLinkedList<int>::append, OrderedReduce);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 2 << 3);
+    }
+
+    // function-member
+    {
+        QList<int> list2 = QtConcurrent::blockingMappedReduced(list,
+                                                       intSquare,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list2, QList<int>() << 1 << 4 << 9);
+
+        QList<int> list3 = QtConcurrent::blockingMappedReduced(list.constBegin(),
+                                                       list.constEnd(),
+                                                       intSquare,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list3, QList<int>() << 1 << 4 << 9);
+
+        QList<int> list4 = QtConcurrent::blockingMappedReduced(QList<int>(list),
+                                                       intSquare,
+                                                       &QList<int>::push_back,
+                                                       OrderedReduce);
+        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
+        QCOMPARE(list4, QList<int>() << 1 << 4 << 9);
+    }
+    {
+        QLinkedList<int> linkedList2 = QtConcurrent::blockingMappedReduced(linkedList,
+                                                       intSquare,
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 4 << 9);
+
+        QLinkedList<int> linkedList3 = QtConcurrent::blockingMappedReduced(linkedList.constBegin(),
+                                                       linkedList.constEnd(),
+                                                       intSquare,
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 4 << 9);
+
+        QLinkedList<int> linkedList4 = QtConcurrent::blockingMappedReduced(QLinkedList<int>(linkedList),
+                                                       intSquare,
+                                                       &QLinkedList<int>::append,
+                                                       OrderedReduce);
+        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
+        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 4 << 9);
+    }
+
+    // member-function
+    {
+        int sum = QtConcurrent::blockingMappedReduced(numberList,
+                                              &Number::toInt,
+                                              intSumReduce);
+        QCOMPARE(sum, 6);
+        int sum2 = QtConcurrent::blockingMappedReduced(numberList.constBegin(),
+                                               numberList.constEnd(),
+                                              &Number::toInt,
+                                              intSumReduce);
+        QCOMPARE(sum2, 6);
+
+        int sum3 = QtConcurrent::blockingMappedReduced(QList<Number>(numberList),
+                                               &Number::toInt,
+                                               intSumReduce);
+        QCOMPARE(sum3, 6);
+    }
+    {
+        int sum = QtConcurrent::blockingMappedReduced(numberLinkedList,
+                                              &Number::toInt,
+                                              intSumReduce);
+        QCOMPARE(sum, 6);
+        int sum2 = QtConcurrent::blockingMappedReduced(numberLinkedList.constBegin(),
+                                               numberLinkedList.constEnd(),
+                                              &Number::toInt,
+                                              intSumReduce);
+        QCOMPARE(sum2, 6);
+
+        int sum3 = QtConcurrent::blockingMappedReduced(QLinkedList<Number>(numberLinkedList),
+                                               &Number::toInt,
+                                               intSumReduce);
+        QCOMPARE(sum3, 6);
+    }
+
+    // linked lists
+    {
+
+        QLinkedList<int> list;
+        list << 1 << 2 << 3;
+
+        QLinkedList<Number> numberList;
+        numberList << 1 << 2 << 3;
+
+        int sum = QtConcurrent::blockingMappedReduced<int>(list, IntSquare(), IntSumReduce());
+        QCOMPARE(sum, 14);
+        int sum2 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    IntSquare(),
+                                                    IntSumReduce());
+        QCOMPARE(sum2, 14);
+
+        int sum3 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(list), IntSquare(), IntSumReduce());
+        QCOMPARE(sum3, 14);
+
+        int sum4 = QtConcurrent::blockingMappedReduced<int>(list, intSquare, intSumReduce);
+        QCOMPARE(sum4, 14);
+        int sum5 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
+                                                    list.constEnd(),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum5, 14);
+
+        int sum6 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(list),
+                                                    intSquare,
+                                                    intSumReduce);
+        QCOMPARE(sum6, 14);
+    }
+
+    // ### the same as above, with an initial result value
+}
+
+int sleeper(int val)
+{
+    QTest::qSleep(100);
+    return val;
+}
+
+void tst_QtConcurrentMap::assignResult()
+{
+    const QList<int> startList = QList<int>() << 0 << 1 << 2;
+    QList<int> list = QtConcurrent::blockingMapped(startList, sleeper);
+    QCOMPARE(list.at(0), 0);
+    QCOMPARE(list.at(1), 1);
+}
+
+int fnConst(const int &i)
+{
+    return i;
+}
+
+int fn(int &i)
+{
+    return i;
+}
+
+QString changeTypeConst(const int &)
+{
+    return QString();
+}
+
+QString changeType(int &)
+{
+    return QString();
+}
+
+int changeTypeQStringListConst(const QStringList &)
+{
+    return 0;
+}
+
+int changeTypeQStringList(QStringList &)
+{
+    return 0;
+}
+
+class MemFnTester
+{
+public:
+    MemFnTester() {}
+
+    MemFnTester fn()
+    {
+        return MemFnTester();
+    }
+
+    MemFnTester fnConst() const
+    {
+        return MemFnTester();
+    }
+
+    QString changeType()
+    {
+        return QString();
+    }
+
+    QString changeTypeConst() const
+    {
+        return QString();
+    }
+};
+
+Q_DECLARE_METATYPE(QVector<MemFnTester>);
+Q_DECLARE_METATYPE(QList<MemFnTester>);
+
+void tst_QtConcurrentMap::functionOverloads()
+{
+    QList<int> intList;
+    const QList<int> constIntList;
+    QList<MemFnTester> classList;
+    const QList<MemFnTester> constMemFnTesterList;
+
+    QtConcurrent::mapped(intList, fnConst);
+    QtConcurrent::mapped(constIntList, fnConst);
+    QtConcurrent::mapped(classList, &MemFnTester::fnConst);
+    QtConcurrent::mapped(constMemFnTesterList, &MemFnTester::fnConst);
+
+    QtConcurrent::blockingMapped<QVector<int> >(intList, fnConst);
+    QtConcurrent::blockingMapped<QVector<int> >(constIntList, fnConst);
+    QtConcurrent::blockingMapped<QVector<MemFnTester> >(classList, &MemFnTester::fnConst);
+    QtConcurrent::blockingMapped<QVector<MemFnTester> >(constMemFnTesterList, &MemFnTester::fnConst);
+
+    QtConcurrent::blockingMapped<QList<QString> >(intList, changeTypeConst);
+    QtConcurrent::blockingMapped<QList<QString> >(constIntList, changeTypeConst);
+    QtConcurrent::blockingMapped<QList<QString> >(classList, &MemFnTester::changeTypeConst);
+    QtConcurrent::blockingMapped<QList<QString> >(constMemFnTesterList, &MemFnTester::changeTypeConst);
+
+    QStringList stringList;
+    const QStringList constStringList;
+    // QtConcurrent::map(stringList, changeTypeQStringListConst);
+    // QtConcurrent::map(intList, changeTypeNonConst);
+    // QList<QString>(QtConcurrent::map(constStringList, changeTypeQStringList));
+    // QtConcurrent::map(classList, &MemFnTester::changeType);
+    // QtConcurrent::map(classList, &MemFnTester::changeTypeConst);
+    // QtConcurrent::map(constMemFnTesterList, &MemFnTester::changeTypeConst);
+}
+
+QAtomicInt currentInstanceCount;
+QAtomicInt peakInstanceCount;
+class InstanceCounter
+{
+public:
+    inline InstanceCounter()
+    { currentInstanceCount.fetchAndAddRelaxed(1); updatePeak(); }
+    inline ~InstanceCounter()
+    { currentInstanceCount.fetchAndAddRelaxed(-1);}
+    inline InstanceCounter(const InstanceCounter &)
+    { currentInstanceCount.fetchAndAddRelaxed(1); updatePeak(); }
+
+    void updatePeak()
+    {
+        forever {
+            const int localPeak = peakInstanceCount.load();
+            const int localCurrent = currentInstanceCount.load();
+            if (localCurrent <= localPeak)
+                break;
+            if (peakInstanceCount.testAndSetOrdered(localPeak, localCurrent))
+                break;
+        }
+    }
+};
+
+InstanceCounter slowMap(const InstanceCounter &in)
+{
+    QTest::qSleep(2);
+    return in;
+}
+
+InstanceCounter fastMap(const InstanceCounter &in)
+{
+    QTest::qSleep(rand() % 2 + 1);
+    return in;
+}
+
+void slowReduce(int &result, const InstanceCounter&)
+{
+    QTest::qSleep(rand() % 4 + 1);
+    ++result;
+}
+
+void fastReduce(int &result, const InstanceCounter&)
+{
+    ++result;
+}
+
+void tst_QtConcurrentMap::throttling()
+{
+    const int itemcount = 100;
+    const int allowedTemporaries = QThread::idealThreadCount() * 40;
+
+    {
+        currentInstanceCount.store(0);
+        peakInstanceCount.store(0);
+
+        QList<InstanceCounter> instances;
+        for (int i = 0; i < itemcount; ++i)
+            instances.append(InstanceCounter());
+
+        QCOMPARE(currentInstanceCount.load(), itemcount);
+
+        int results = QtConcurrent::blockingMappedReduced(instances, slowMap, fastReduce);
+        QCOMPARE(results, itemcount);
+        QCOMPARE(currentInstanceCount.load(), itemcount);
+        QVERIFY(peakInstanceCount.load() < itemcount + allowedTemporaries);
+    }
+
+    {
+        QCOMPARE(currentInstanceCount.load(), 0);
+        peakInstanceCount.store(0);
+
+        QList<InstanceCounter> instances;
+        for (int i = 0; i < itemcount; ++i)
+            instances.append(InstanceCounter());
+
+        QCOMPARE(currentInstanceCount.load(), itemcount);
+        int results = QtConcurrent::blockingMappedReduced(instances, fastMap, slowReduce);
+
+        QCOMPARE(results, itemcount);
+        QCOMPARE(currentInstanceCount.load(), itemcount);
+        QVERIFY(peakInstanceCount.load() < itemcount + allowedTemporaries);
+    }
+}
+
+#ifndef QT_NO_EXCEPTIONS
+void throwMapper(int &e)
+{
+    Q_UNUSED(e);
+    throw QtConcurrent::Exception();
+}
+
+void tst_QtConcurrentMap::exceptions()
+{
+    bool caught = false;
+    try  {
+        QList<int> list = QList<int>() << 1 << 2 << 3;
+        QtConcurrent::map(list, throwMapper).waitForFinished();
+    } catch (const Exception &) {
+        caught = true;
+    }
+    if (!caught)
+        QFAIL("did not get exception");
+}
+#endif
+
+int mapper(const int &i)
+{
+    QTest::qWait(1);
+    return i;
+}
+
+void tst_QtConcurrentMap::incrementalResults()
+{
+    const int count = 200;
+    QList<int> ints; 
+    for (int i=0; i < count; ++i)
+        ints << i;
+
+    QFuture<int> future = QtConcurrent::mapped(ints, mapper);
+    
+    QList<int> results;
+
+    while (future.isFinished() == false) {
+        for (int i = 0; i < future.resultCount(); ++i) {
+            results += future.resultAt(i);
+        }
+
+        QTest::qWait(1);
+    }
+
+    QCOMPARE(future.isFinished(), true);
+    QCOMPARE(future.resultCount(), count);
+    QCOMPARE(future.results().count(), count);
+}
+
+/*
+    Test that mapped does not cause deep copies when holding
+    references to Qt containers.
+*/
+void tst_QtConcurrentMap::noDetach()
+{
+    {
+        QList<int> l = QList<int>() << 1;
+        QVERIFY(l.isDetached());
+
+        QList<int> ll = l;
+        QVERIFY(l.isDetached() == false);
+
+        QtConcurrent::mapped(l, mapper).waitForFinished();
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+
+        QtConcurrent::mappedReduced(l, mapper, intSumReduce).waitForFinished();
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+
+        QtConcurrent::map(l, multiplyBy2Immutable).waitForFinished();
+        QVERIFY(l.isDetached() == true);
+        QVERIFY(ll.isDetached() == true);
+    }
+    {
+        const QList<int> l = QList<int>() << 1;
+        QVERIFY(l.isDetached());
+
+        const QList<int> ll = l;
+        QVERIFY(l.isDetached() == false);
+
+        QtConcurrent::mapped(l, mapper).waitForFinished();
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+
+        QtConcurrent::mappedReduced(l, mapper, intSumReduce).waitForFinished();
+
+        QVERIFY(l.isDetached() == false);
+        QVERIFY(ll.isDetached() == false);
+    }
+
+}
+
+#ifndef QT_NO_STL
+void tst_QtConcurrentMap::stlContainers()
+{
+    std::vector<int> vector;
+    vector.push_back(1);
+    vector.push_back(2);
+
+    std::vector<int> vector2 =  QtConcurrent::blockingMapped<std::vector<int> >(vector, mapper);
+    QCOMPARE(vector2.size(), (std::vector<int>::size_type)(2));
+
+    std::list<int> list;
+    list.push_back(1);
+    list.push_back(2);
+
+    std::list<int> list2 =  QtConcurrent::blockingMapped<std::list<int> >(list, mapper);
+    QCOMPARE(list2.size(), (std::vector<int>::size_type)(2));
+
+    QtConcurrent::mapped(list, mapper).waitForFinished();
+    
+    QtConcurrent::blockingMap(list, multiplyBy2Immutable);
+}
+#endif
+
+InstanceCounter ic_fn(const InstanceCounter & ic)
+{
+    return InstanceCounter(ic);
+};
+
+// Verify that held results are deleted when a future is
+// assigned over with operator ==
+void tst_QtConcurrentMap::qFutureAssignmentLeak()
+{
+    currentInstanceCount.store(0);
+    peakInstanceCount.store(0);
+    QFuture<InstanceCounter> future;
+    {
+        QList<InstanceCounter> list;
+        for (int i=0;i<1000;++i)
+            list += InstanceCounter();
+        future = QtConcurrent::mapped(list, ic_fn);
+        future.waitForFinished();
+
+        future = QtConcurrent::mapped(list, ic_fn);
+        future.waitForFinished();
+
+        future = QtConcurrent::mapped(list, ic_fn);
+        future.waitForFinished();
+    }
+
+    QCOMPARE(currentInstanceCount.load(), 1000);
+    future = QFuture<InstanceCounter>();
+    QCOMPARE(currentInstanceCount.load(), 0);
+}
+
+inline void increment(int &num)
+{
+    ++num;
+}
+
+inline int echo(const int &num)
+{
+    return num;
+}
+
+void add(int &result, const int &sum)
+{
+    result += sum;
+}
+
+void tst_QtConcurrentMap::stressTest()
+{
+    const int listSize = 1000;
+    const int sum = (listSize - 1) * (listSize / 2);
+    QList<int> list;
+
+
+    for (int i = 0; i < listSize; ++i) {
+        list.append(i);
+    }
+
+    for (int i =0 ; i < 100; ++i) {
+        QList<int> result = QtConcurrent::blockingMapped(list, echo);
+        for (int j = 0; j < listSize; ++j)
+            QCOMPARE(result.at(j), j);
+    }
+
+    for (int i = 0 ; i < 100; ++i) {
+        int result = QtConcurrent::blockingMappedReduced(list, echo, add);
+        QCOMPARE(result, sum);
+    }
+
+    for (int i = 0 ; i < 100; ++i) {
+        QtConcurrent::map(list, increment).waitForFinished();
+        for (int j = 0; j < listSize; ++j)
+            QCOMPARE(list.at(j), i + j + 1);
+    }
+}
+
+#endif
+
+QTEST_MAIN(tst_QtConcurrentMap)
+#include "tst_qtconcurrentmap.moc"
diff --git a/tests/auto/concurrent/qtconcurrentresultstore/qtconcurrentresultstore.pro b/tests/auto/concurrent/qtconcurrentresultstore/qtconcurrentresultstore.pro
new file mode 100644
index 0000000..2c04f75
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentresultstore/qtconcurrentresultstore.pro
@@ -0,0 +1,5 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qtconcurrentresultstore
+QT = core-private testlib concurrent
+SOURCES = tst_qtconcurrentresultstore.cpp
+DEFINES += QT_STRICT_ITERATORS
diff --git a/tests/auto/concurrent/qtconcurrentresultstore/tst_qtconcurrentresultstore.cpp b/tests/auto/concurrent/qtconcurrentresultstore/tst_qtconcurrentresultstore.cpp
new file mode 100644
index 0000000..236d0b6
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentresultstore/tst_qtconcurrentresultstore.cpp
@@ -0,0 +1,490 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtTest/QtTest>
+
+#include <qtconcurrentresultstore.h>
+
+using namespace QtConcurrent;
+
+class tst_QtConcurrentResultStore : public QObject
+{
+    Q_OBJECT
+public slots:
+    void init();
+private slots:
+    void construction();
+    void iterators();
+    void addResult();
+    void addResults();
+    void resultIndex();
+    void resultAt();
+    void contains();
+    void filterMode();
+    void addCanceledResult();
+    void count();
+private:
+    int int0;
+    int int1;
+    int int2;
+    QVector<int> vec0;
+    QVector<int> vec1;
+};
+
+void tst_QtConcurrentResultStore::init()
+{
+    int0 = 0;
+    int1 = 1;
+    int2 = 2;
+    vec0 = QVector<int>() << 2 << 3;
+    vec1 = QVector<int>() << 4 << 5;
+}
+
+void tst_QtConcurrentResultStore::construction()
+{
+    ResultStore<int> store;
+    QCOMPARE(store.count(), 0);
+}
+
+void tst_QtConcurrentResultStore::iterators()
+{
+    {
+        ResultStore<int> store;
+        QVERIFY(store.begin() == store.end());
+        QVERIFY(store.resultAt(0) == store.end());
+        QVERIFY(store.resultAt(1) == store.end());
+    }
+    {
+        ResultStoreBase storebase;
+        storebase.addResult(-1, &int0); // note to self: adding a pointer to the stack here is ok since
+        storebase.addResult(1, &int1);  // ResultStoreBase does not take ownership, only ResultStore<> does.
+        ResultIteratorBase it = storebase.begin();
+        QCOMPARE(it.resultIndex(), 0);
+        QVERIFY(it == storebase.begin());
+        QVERIFY(it != storebase.end());
+
+        ++it;
+        QCOMPARE(it.resultIndex(), 1);
+        QVERIFY(it != storebase.begin());
+        QVERIFY(it != storebase.end());
+
+        ++it;
+        QVERIFY(it != storebase.begin());
+        QVERIFY(it == storebase.end());
+    }
+}
+
+void tst_QtConcurrentResultStore::addResult()
+{
+    {
+        // test addResult return value
+        ResultStore<int> store;
+        store.setFilterMode(true);
+
+        QCOMPARE(store.addResult(0, &int0), 0);
+        QCOMPARE(store.count(), 1); // result 0 becomes available
+        QCOMPARE(store.contains(0), true);
+
+        QCOMPARE(store.addResult(2, &int0), 2);
+        QCOMPARE(store.count(), 1);
+        QCOMPARE(store.contains(2), false);
+
+        QCOMPARE(store.addCanceledResult(1), 1);
+        QCOMPARE(store.count(), 2); // result 2 is renamed to 1 and becomes available
+
+        QCOMPARE(store.contains(0), true);
+        QCOMPARE(store.contains(1), true);
+        QCOMPARE(store.contains(2), false);
+
+        QCOMPARE(store.addResult(3, &int0), 3);
+        QCOMPARE(store.count(), 3);
+        QCOMPARE(store.contains(2), true);
+
+        QCOMPARE(store.addResult(6, &int0), 6);
+        QCOMPARE(store.count(), 3);
+        QCOMPARE(store.addResult(7, &int0), 7);
+        QCOMPARE(store.count(), 3);
+        QCOMPARE(store.contains(3), false);
+
+        QCOMPARE(store.addCanceledResult(4), 4);
+        QCOMPARE(store.addCanceledResult(5), 5);
+        QCOMPARE(store.count(), 5); // 6 and 7 is renamed to 3 and 4 and becomes available
+
+        QCOMPARE(store.contains(3), true);
+        QCOMPARE(store.contains(4), true);
+
+        QCOMPARE(store.addResult(8, &int0), 8);
+        QCOMPARE(store.contains(5), true);
+        QCOMPARE(store.count(), 6);
+
+        QCOMPARE(store.contains(6), false);
+        QCOMPARE(store.contains(7), false);
+    }
+}
+
+void tst_QtConcurrentResultStore::addResults()
+{
+
+    ResultStoreBase store;
+    store.addResults(-1, &vec0, 2, 2);
+    store.addResults(-1, &vec1, 2, 2);
+    ResultIteratorBase it = store.begin();
+    QCOMPARE(it.resultIndex(), 0);
+    QVERIFY(it == store.begin());
+    QVERIFY(it != store.end());
+
+    ++it;
+    QCOMPARE(it.resultIndex(), 1);
+    QVERIFY(it != store.begin());
+    QVERIFY(it != store.end());
+
+    ++it;
+    QCOMPARE(it.resultIndex(), 2);
+
+    ++it;
+    QCOMPARE(it.resultIndex(), 3);
+
+    ++it;
+    QVERIFY(it == store.end());
+}
+
+void tst_QtConcurrentResultStore::resultIndex()
+{
+    ResultStore<int> store;
+    store.addResult(-1, &int0);
+    store.addResults(-1, &vec0);
+    store.addResult(-1, &int1);
+
+    ResultIteratorBase it = store.begin();
+    QCOMPARE(it.resultIndex(), 0);
+    QVERIFY(it == store.begin());
+    QVERIFY(it != store.end());
+
+    ++it;
+    QCOMPARE(it.resultIndex(), 1);
+    QVERIFY(it != store.begin());
+    QVERIFY(it != store.end());
+
+    ++it;
+    QCOMPARE(it.resultIndex(), 2);
+    QVERIFY(it != store.end());
+    ++it;
+    QCOMPARE(it.resultIndex(), 3);
+    QVERIFY(it != store.end());
+    ++it;
+    QVERIFY(it == store.end());
+
+    QCOMPARE(store.resultAt(0).value(), int0);
+    QCOMPARE(store.resultAt(1).value(), vec0[0]);
+    QCOMPARE(store.resultAt(2).value(), vec0[1]);
+    QCOMPARE(store.resultAt(3).value(), int1);
+}
+
+void tst_QtConcurrentResultStore::resultAt()
+{
+    {
+        ResultStore<int> store;
+        store.addResult(-1, &int0);
+        store.addResults(-1, &vec0);
+        store.addResult(200, &int1);
+
+        QCOMPARE(store.resultAt(0).value(), int0);
+        QCOMPARE(store.resultAt(1).value(), vec0[0]);
+        QCOMPARE(store.resultAt(2).value(), vec0[1]);
+        QCOMPARE(store.resultAt(200).value(), int1);
+    }
+    {
+        ResultStore<int> store;
+        store.addResult(1, &int1);
+        store.addResult(0, &int0);
+        store.addResult(-1, &int2);
+
+        QCOMPARE(store.resultAt(0).value(), int0);
+        QCOMPARE(store.resultAt(1).value(), int1);
+        QCOMPARE(store.resultAt(2).value(), int2);
+    }
+}
+
+void tst_QtConcurrentResultStore::contains()
+{
+    {
+        ResultStore<int> store;
+        QCOMPARE(store.contains(0), false);
+        QCOMPARE(store.contains(1), false);
+        QCOMPARE(store.contains(INT_MAX), false);
+        store.addResult(1, &int1);
+        QVERIFY(store.contains(int1));
+        store.addResult(0, &int0);
+        QVERIFY(store.contains(int0));
+        store.addResult(-1, &int2);
+        QVERIFY(store.contains(int2));
+    }
+    {
+        ResultStore<int> store;
+        store.addResult(1, &int0);
+        store.addResult(3, &int0);
+        store.addResults(6, &vec0);
+        QCOMPARE(store.contains(0), false);
+        QCOMPARE(store.contains(1), true);
+        QCOMPARE(store.contains(2), false);
+        QCOMPARE(store.contains(3), true);
+        QCOMPARE(store.contains(4), false);
+        QCOMPARE(store.contains(5), false);
+        QCOMPARE(store.contains(6), true);
+        QCOMPARE(store.contains(7), true);
+    }
+
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addResult(1, &int0);
+        store.addResult(3, &int0);
+        store.addResults(6, &vec0);
+        QCOMPARE(store.contains(0), false);
+        QCOMPARE(store.contains(1), false);
+        QCOMPARE(store.contains(2), false);
+        QCOMPARE(store.contains(3), false);
+        QCOMPARE(store.contains(4), false);
+        QCOMPARE(store.contains(5), false);
+        QCOMPARE(store.contains(6), false);
+        QCOMPARE(store.contains(7), false);
+
+        store.addCanceledResult(0);
+        store.addCanceledResult(2);
+        store.addCanceledResults(4, 2);
+
+        QCOMPARE(store.contains(0), true);
+        QCOMPARE(store.contains(1), true);
+        QCOMPARE(store.contains(2), true);
+        QCOMPARE(store.contains(3), true);
+        QCOMPARE(store.contains(4), false);
+        QCOMPARE(store.contains(5), false);
+        QCOMPARE(store.contains(6), false);
+        QCOMPARE(store.contains(7), false);
+    }
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addCanceledResult(0);
+        QCOMPARE(store.contains(0), false);
+
+        store.addResult(1, &int0);
+        QCOMPARE(store.contains(0), true);
+        QCOMPARE(store.contains(1), false);
+    }
+}
+
+void tst_QtConcurrentResultStore::filterMode()
+{
+    // Test filter mode, where "gaps" in the result array aren't allowed.
+    ResultStore<int> store;
+    QCOMPARE(store.filterMode(), false);
+    store.setFilterMode(true);
+    QVERIFY(store.filterMode());
+
+    store.addResult(0, &int0);
+    QCOMPARE(store.contains(0), true);
+
+    store.addResult(2, &int2); // add result at index 2
+    QCOMPARE(store.contains(2), false); // but 1 is missing, so this 2 won't be reported yet.
+
+    store.addResult(1, &int1);
+    QCOMPARE(store.contains(1), true);
+    QCOMPARE(store.contains(2), true); // 2 should be visible now.
+
+    store.addResult(4, &int0);
+    store.addResult(5, &int0);
+    store.addResult(7, &int0);
+    QCOMPARE(store.contains(4), false);
+    QCOMPARE(store.contains(5), false);
+    QCOMPARE(store.contains(7), false);
+
+    store.addResult(3, &int0);  // adding 3 makes 4 and 5 visible
+    QCOMPARE(store.contains(4), true);
+    QCOMPARE(store.contains(5), true);
+    QCOMPARE(store.contains(7), false);
+
+    store.addResult(6, &int0);  // adding 6 makes 7 visible
+
+    QCOMPARE(store.contains(6), true);
+    QCOMPARE(store.contains(7), true);
+    QCOMPARE(store.contains(8), false);
+}
+
+void tst_QtConcurrentResultStore::addCanceledResult()
+{
+    // test canceled results
+    ResultStore<int> store;
+    store.setFilterMode(true);
+
+    store.addResult(0, &int0);
+    QCOMPARE(store.contains(0), true);
+
+    store.addResult(2, &int0);
+    QCOMPARE(store.contains(2), false);
+
+    store.addCanceledResult(1); // report no result at 1
+
+    QCOMPARE(store.contains(0), true);
+    QCOMPARE(store.contains(1), true); // 2 gets renamed to 1
+    QCOMPARE(store.contains(2), false);
+
+    store.addResult(3, &int0);
+    QCOMPARE(store.contains(2), true); //3 gets renamed to 2
+
+    store.addResult(6, &int0);
+    store.addResult(7, &int0);
+    QCOMPARE(store.contains(3), false);
+
+    store.addCanceledResult(4);
+    store.addCanceledResult(5);
+
+    QCOMPARE(store.contains(3), true); //6 gets renamed to 3
+    QCOMPARE(store.contains(4), true); //7 gets renamed to 4
+
+    store.addResult(8, &int0);
+    QCOMPARE(store.contains(5), true); //8 gets renamed to 4
+
+    QCOMPARE(store.contains(6), false);
+    QCOMPARE(store.contains(7), false);
+}
+
+void tst_QtConcurrentResultStore::count()
+{
+    {
+        // test resultCount in non-filtered mode. It should always be possible
+        // to iterate through the results 0 to resultCount.
+        ResultStore<int> store;
+        store.addResult(0, &int0);
+
+        QCOMPARE(store.count(), 1);
+
+        store.addResult(2, &int0);
+
+        QCOMPARE(store.count(), 1);
+
+        store.addResult(1, &int0);
+        QCOMPARE(store.count(), 3);
+    }
+
+    {
+        ResultStore<int> store;
+        store.addResult(2, &int0);
+        QCOMPARE(store.count(), 0);
+
+        store.addResult(1, &int0);
+        QCOMPARE(store.count(), 0);
+
+        store.addResult(0, &int0);
+        QCOMPARE(store.count(), 3);
+    }
+
+    {
+        ResultStore<int> store;
+        store.addResults(2, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addResult(1, &int0);
+        QCOMPARE(store.count(), 0);
+
+        store.addResult(0, &int0);
+        QCOMPARE(store.count(), 4);
+    }
+
+    {
+        ResultStore<int> store;
+        store.addResults(2, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addResults(0, &vec0);
+        QCOMPARE(store.count(), 4);
+    }
+    {
+        ResultStore<int> store;
+        store.addResults(3, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addResults(0, &vec0);
+        QCOMPARE(store.count(), 2);
+
+        store.addResult(2, &int0);
+        QCOMPARE(store.count(), 5);
+    }
+
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addResults(3, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addResults(0, &vec0);
+        QCOMPARE(store.count(), 2);
+
+        store.addCanceledResult(2);
+        QCOMPARE(store.count(), 4);
+    }
+
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addResults(3, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addCanceledResults(0, 3);
+        QCOMPARE(store.count(), 2);
+    }
+
+    {
+        ResultStore<int> store;
+        store.setFilterMode(true);
+        store.addResults(3, &vec1);
+        QCOMPARE(store.count(), 0);
+
+        store.addCanceledResults(0, 3);
+        QCOMPARE(store.count(), 2);  // results at 3 and 4 become available at index 0, 1
+
+        store.addResult(5, &int0);
+        QCOMPARE(store.count(), 3);// result 5 becomes available at index 2
+    }
+}
+
+QTEST_MAIN(tst_QtConcurrentResultStore)
+#include "tst_qtconcurrentresultstore.moc"
diff --git a/tests/auto/concurrent/qtconcurrentrun/.gitignore b/tests/auto/concurrent/qtconcurrentrun/.gitignore
new file mode 100644
index 0000000..d7a8334
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentrun/.gitignore
@@ -0,0 +1 @@
+tst_qtconcurrentrun
diff --git a/tests/auto/concurrent/qtconcurrentrun/qtconcurrentrun.pro b/tests/auto/concurrent/qtconcurrentrun/qtconcurrentrun.pro
new file mode 100644
index 0000000..03d77b3
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentrun/qtconcurrentrun.pro
@@ -0,0 +1,4 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qtconcurrentrun
+QT = core testlib concurrent
+SOURCES = tst_qtconcurrentrun.cpp
diff --git a/tests/auto/concurrent/qtconcurrentrun/tst_qtconcurrentrun.cpp b/tests/auto/concurrent/qtconcurrentrun/tst_qtconcurrentrun.cpp
new file mode 100644
index 0000000..86e3433
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentrun/tst_qtconcurrentrun.cpp
@@ -0,0 +1,463 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtconcurrentrun.h>
+#include <qfuture.h>
+#include <QString>
+#include <QtTest/QtTest>
+
+using namespace QtConcurrent;
+
+class tst_QtConcurrentRun: public QObject
+{
+    Q_OBJECT
+private slots:
+    void runLightFunction();
+    void runHeavyFunction();
+    void returnValue();
+    void functionObject();
+    void memberFunctions();
+    void implicitConvertibleTypes();
+    void runWaitLoop();
+    void recursive();
+#ifndef QT_NO_EXCEPTIONS
+    void exceptions();
+#endif
+    void functor();
+    void lambda();
+};
+
+void light()
+{
+    qDebug("in function");
+    qDebug("done function");
+}
+
+void heavy()
+{
+    qDebug("in function");
+    QString str;
+    for (int i = 0; i < 1000000; ++i)
+        str.append("a");
+    qDebug("done function");
+}
+
+
+void tst_QtConcurrentRun::runLightFunction()
+{
+    qDebug("starting function");
+    QFuture<void> future = run(light);
+    qDebug("waiting");
+    future.waitForFinished();
+    qDebug("done");
+}
+
+void tst_QtConcurrentRun::runHeavyFunction()
+{
+    qDebug("starting function");
+    QFuture<void> future = run(heavy);
+    qDebug("waiting");
+    future.waitForFinished();
+    qDebug("done");
+}
+
+int returnInt0()
+{
+    return 10;
+}
+
+int returnInt1(int i)
+{
+    return i;
+}
+
+class A
+{
+public:
+    int member0() { return 10; }
+    int member1(int in) { return in; }
+
+    typedef int result_type;
+    int operator()() { return 10; }
+    int operator()(int in) { return in; }
+};
+
+class AConst
+{
+public:
+    int member0() const { return 10; }
+    int member1(int in) const { return in; }
+
+    typedef int result_type;
+    int operator()() const { return 10; }
+    int operator()(int in) const { return in; }
+};
+
+void tst_QtConcurrentRun::returnValue()
+{
+    QFuture<int> f;
+    
+    f = run(returnInt0);
+    QCOMPARE(f.result(), 10);
+    
+    A a;
+    f = run(&a, &A::member0);
+    QCOMPARE(f.result(), 10);
+
+    f = run(&a, &A::member1, 20);
+    QCOMPARE(f.result(), 20);
+
+    f = run(a, &A::member0);
+    QCOMPARE(f.result(), 10);
+
+    f = run(a, &A::member1, 20);
+    QCOMPARE(f.result(), 20);
+
+    f = run(a);
+    QCOMPARE(f.result(), 10);
+
+    f = run(&a);
+    QCOMPARE(f.result(), 10);
+
+    f = run(a, 20);
+    QCOMPARE(f.result(), 20);
+
+    f = run(&a, 20);
+    QCOMPARE(f.result(), 20);
+
+    const AConst aConst = AConst();
+    f = run(&aConst, &AConst::member0);
+    QCOMPARE(f.result(), 10);
+
+    f = run(&aConst, &AConst::member1, 20);
+    QCOMPARE(f.result(), 20);
+
+    f = run(aConst, &AConst::member0);
+    QCOMPARE(f.result(), 10);
+
+    f = run(aConst, &AConst::member1, 20);
+    QCOMPARE(f.result(), 20);
+
+    f = run(aConst);
+    QCOMPARE(f.result(), 10);
+
+    f = run(&aConst);
+    QCOMPARE(f.result(), 10);
+
+    f = run(aConst, 20);
+    QCOMPARE(f.result(), 20);
+
+    f = run(&aConst, 20);
+    QCOMPARE(f.result(), 20);
+}
+
+struct TestClass
+{
+    void foo() { }
+    typedef void result_type;
+    void operator()() { }
+    void operator()(int) { }
+    void fooInt(int){ };
+};
+
+struct TestConstClass
+{
+    void foo() const { }
+    typedef void result_type;
+    void operator()() const { }
+    void operator()(int) const { }
+    void fooInt(int) const { };
+};
+
+void tst_QtConcurrentRun::functionObject()
+{
+    QFuture<void> f;
+    TestClass c;
+    
+    f = run(c);
+    f = run(&c);
+    f = run(c, 10);
+    f = run(&c, 10);
+
+    const TestConstClass cc = TestConstClass();
+    f = run(cc);
+    f = run(&cc);
+    f = run(cc, 10);
+    f = run(&cc, 10);
+}
+
+
+void tst_QtConcurrentRun::memberFunctions()
+{
+    TestClass c;
+
+    run(c, &TestClass::foo).waitForFinished();
+    run(&c, &TestClass::foo).waitForFinished();
+    run(c, &TestClass::fooInt, 10).waitForFinished();
+    run(&c, &TestClass::fooInt, 10).waitForFinished();
+
+    const TestConstClass cc = TestConstClass();
+    run(cc, &TestConstClass::foo).waitForFinished();
+    run(&cc, &TestConstClass::foo).waitForFinished();
+    run(cc, &TestConstClass::fooInt, 10).waitForFinished();
+    run(&cc, &TestConstClass::fooInt, 10).waitForFinished();
+}
+
+
+void doubleFunction(double)
+{
+
+}
+
+void stringConstRefFunction(const QString &)
+{
+
+}
+
+void stringRefFunction(QString &)
+{
+
+}
+
+void stringFunction(QString)
+{
+
+}
+
+void stringIntFunction(QString)
+{
+
+}
+
+
+void tst_QtConcurrentRun::implicitConvertibleTypes()
+{
+    double d;
+    run(doubleFunction, d).waitForFinished();
+    int i;
+    run(doubleFunction, d).waitForFinished();
+    run(doubleFunction, i).waitForFinished();
+    run(doubleFunction, 10).waitForFinished();
+    run(stringFunction, QLatin1String("Foo")).waitForFinished();
+    run(stringConstRefFunction, QLatin1String("Foo")).waitForFinished();
+    QString string;
+    run(stringRefFunction, string).waitForFinished();
+}
+
+void fn() { }
+
+void tst_QtConcurrentRun::runWaitLoop()
+{
+    for (int i = 0; i < 1000; ++i)
+        run(fn).waitForFinished();
+}
+
+QAtomicInt count;
+
+void recursiveRun(int level)
+{
+    count.ref();
+    if (--level > 0) {
+        QFuture<void> f1 = run(recursiveRun, level);
+        QFuture<void> f2 = run(recursiveRun, level);
+        f1.waitForFinished();
+        f2.waitForFinished();
+    }
+}
+
+int recursiveResult(int level)
+{
+    count.ref();
+    if (--level > 0) {
+        QFuture<int> f1 = run(recursiveResult, level);
+        QFuture<int> f2 = run(recursiveResult, level);
+        return f1.result() + f2.result();
+    }
+    return 1;
+}
+
+void tst_QtConcurrentRun::recursive()
+{
+    int levels = 15;
+
+    for (int i = 0; i < QThread::idealThreadCount(); ++i) {
+        count.store(0);
+        QThreadPool::globalInstance()->setMaxThreadCount(i);
+        recursiveRun(levels);
+        QCOMPARE(count.load(), (int)pow(2.0, levels) - 1);
+    }
+
+    for (int i = 0; i < QThread::idealThreadCount(); ++i) {
+        count.store(0);
+        QThreadPool::globalInstance()->setMaxThreadCount(i);
+        recursiveResult(levels);
+        QCOMPARE(count.load(), (int)pow(2.0, levels) - 1);
+    }
+}
+
+int e;
+void vfn0()
+{
+    ++e;
+}
+
+int fn0()
+{
+    return 1;
+}
+
+void vfn1(double)
+{
+    ++e;
+}
+
+int fn1(int)
+{
+    return 1;
+}
+
+void vfn2(double, int *)
+{
+    ++e;
+}
+
+int fn2(double, int *)
+{
+    return 1;
+}
+
+
+#ifndef QT_NO_EXCEPTIONS
+void throwFunction()
+{
+    throw QtConcurrent::Exception();
+}
+
+int throwFunctionReturn()
+{
+    throw QtConcurrent::Exception();
+    return 0;
+}
+
+void tst_QtConcurrentRun::exceptions()
+{
+    bool caught = false;
+    try  {
+        QtConcurrent::run(throwFunction).waitForFinished();
+    } catch (Exception &e) {
+        caught = true;
+    }
+    if (!caught)
+        QFAIL("did not get exception");
+
+    caught = false;
+    try  {
+        QtConcurrent::run(throwFunctionReturn).waitForFinished();
+    } catch (Exception &e) {
+        caught = true;
+    }
+    if (!caught)
+        QFAIL("did not get exception");
+}
+#endif
+
+struct Functor {
+    int operator()() { return 42; }
+    double operator()(double a, double b) { return a/b; }
+    int operator()(int a, int b) { return a/b; }
+    void operator()(int) { }
+    void operator()(int, int, int) { }
+    void operator()(int, int, int, int) { }
+    void operator()(int, int, int, int, int) { }
+    void operator()(int, int, int, int, int, int) { }
+};
+
+// This tests functor without result_type; decltype need to be supported by the compiler.
+void tst_QtConcurrentRun::functor()
+{
+#ifndef Q_COMPILER_DECLTYPE
+    QSKIP("Compiler does not support decltype");
+#else
+    Functor f;
+    {
+        QFuture<int> fut = QtConcurrent::run(f);
+        QCOMPARE(fut.result(), 42);
+    }
+    {
+        QFuture<double> fut = QtConcurrent::run(f, 8.5, 1.8);
+        QCOMPARE(fut.result(), (8.5/1.8));
+    }
+    {
+        QFuture<int> fut = QtConcurrent::run(f, 19, 3);
+        QCOMPARE(fut.result(), int(19/3));
+    }
+    {
+        QtConcurrent::run(f, 1).waitForFinished();
+        QtConcurrent::run(f, 1,2).waitForFinished();
+        QtConcurrent::run(f, 1,2,3).waitForFinished();
+        QtConcurrent::run(f, 1,2,3,4).waitForFinished();
+        QtConcurrent::run(f, 1,2,3,4,5).waitForFinished();
+    }
+#endif
+}
+
+void tst_QtConcurrentRun::lambda()
+{
+#ifndef Q_COMPILER_LAMBDA
+    QSKIP("Compiler does not support lambda");
+#else
+    QCOMPARE(QtConcurrent::run([](){ return 45; }).result(), 45);
+    QCOMPARE(QtConcurrent::run([](int a){ return a+15; }, 12).result(), 12+15);
+    QCOMPARE(QtConcurrent::run([](int a, double b){ return a + b; }, 12, 15).result(), double(12+15));
+    QCOMPARE(QtConcurrent::run([](int a , int, int, int, int b){ return a + b; }, 1, 2, 3, 4, 5).result(), 1 + 5);
+
+#ifdef Q_COMPILER_INITIALIZER_LISTS
+    {
+        QString str { "Hello World Foo" };
+        QFuture<QStringList> f1 = QtConcurrent::run([&](){ return str.split(' '); });
+        auto r = f1.result();
+        QCOMPARE(r, QStringList({"Hello", "World", "Foo"}));
+    }
+#endif
+#endif
+}
+
+QTEST_MAIN(tst_QtConcurrentRun)
+#include "tst_qtconcurrentrun.moc"
diff --git a/tests/auto/concurrent/qtconcurrentthreadengine/.gitignore b/tests/auto/concurrent/qtconcurrentthreadengine/.gitignore
new file mode 100644
index 0000000..a2e2896
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentthreadengine/.gitignore
@@ -0,0 +1 @@
+tst_qtconcurrentthreadengine
diff --git a/tests/auto/concurrent/qtconcurrentthreadengine/qtconcurrentthreadengine.pro b/tests/auto/concurrent/qtconcurrentthreadengine/qtconcurrentthreadengine.pro
new file mode 100644
index 0000000..f6ddd33
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentthreadengine/qtconcurrentthreadengine.pro
@@ -0,0 +1,4 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qtconcurrentthreadengine
+QT = core testlib concurrent
+SOURCES = tst_qtconcurrentthreadengine.cpp
diff --git a/tests/auto/concurrent/qtconcurrentthreadengine/tst_qtconcurrentthreadengine.cpp b/tests/auto/concurrent/qtconcurrentthreadengine/tst_qtconcurrentthreadengine.cpp
new file mode 100644
index 0000000..9722887
--- /dev/null
+++ b/tests/auto/concurrent/qtconcurrentthreadengine/tst_qtconcurrentthreadengine.cpp
@@ -0,0 +1,520 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtconcurrentthreadengine.h>
+#include <qtconcurrentexception.h>
+#include <QThread>
+#include <QtTest/QtTest>
+
+using namespace QtConcurrent;
+
+class tst_QtConcurrentThreadEngine: public QObject
+{
+    Q_OBJECT
+private slots:
+    void runDirectly();
+    void result();
+    void runThroughStarter();
+    void cancel();
+    void throttle();
+    void threadCount();
+    void multipleResults();
+    void stresstest();
+    void cancelQueuedSlowUser();
+#ifndef QT_NO_EXCEPTIONS
+    void exceptions();
+#endif
+};
+
+
+class PrintUser : public ThreadEngine<void>
+{
+public:
+    ThreadFunctionResult threadFunction()
+    {
+        QTest::qSleep(50);
+        QTest::qSleep(100);
+        return ThreadFinished;
+    }
+};
+
+void tst_QtConcurrentThreadEngine::runDirectly()
+{
+    {
+        PrintUser engine;
+        engine.startSingleThreaded();
+        engine.startBlocking();
+    }
+    {
+        PrintUser *engine = new PrintUser();
+        QFuture<void> f = engine->startAsynchronously();
+        f.waitForFinished();
+    }
+}
+
+class StringResultUser : public ThreadEngine<QString>
+{
+public:
+    typedef QString ResultType;
+    StringResultUser()
+    : done(false) { }
+
+    bool shouldStartThread()
+    {
+        return !done;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        done = true;
+        return ThreadFinished;
+    }
+
+    QString *result()
+    {
+        foo = "Foo";
+        return &foo;
+    }
+    QString foo;
+    bool done;
+};
+
+void tst_QtConcurrentThreadEngine::result()
+{
+    StringResultUser engine;
+    QCOMPARE(*engine.startBlocking(), QString("Foo"));
+}
+
+class VoidResultUser : public ThreadEngine<void>
+{
+public:
+    bool shouldStartThread()
+    {
+        return !done;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        done = true;
+        return ThreadFinished;
+    }
+
+    void *result()
+    {
+        return 0;
+    }
+    bool done;
+};
+
+void tst_QtConcurrentThreadEngine::runThroughStarter()
+{
+    {
+        ThreadEngineStarter<QString> starter = startThreadEngine(new StringResultUser());
+        QFuture<QString>  f = starter.startAsynchronously();
+        QCOMPARE(f.result(), QString("Foo"));
+    }
+
+    {
+        ThreadEngineStarter<QString> starter = startThreadEngine(new StringResultUser());
+        QString str = starter.startBlocking();
+        QCOMPARE(str, QString("Foo"));
+    }
+}
+
+class CancelUser : public ThreadEngine<void>
+{
+public:
+    void *result()
+    {
+        return 0;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        while (this->isCanceled() == false)
+        {
+            QTest::qSleep(10);
+        }
+        return ThreadFinished;
+    }
+};
+
+void tst_QtConcurrentThreadEngine::cancel()
+{
+    {
+        CancelUser *engine = new CancelUser();
+        QFuture<void> f = engine->startAsynchronously();
+        f.cancel();
+        f.waitForFinished();
+    }
+    {
+        CancelUser *engine = new CancelUser();
+        QFuture<void> f = engine->startAsynchronously();
+        QTest::qSleep(10);
+        f.cancel();
+        f.waitForFinished();
+    }
+}
+
+QAtomicInt count;
+class ThrottleAlwaysUser : public ThreadEngine<void>
+{
+public:
+    ThrottleAlwaysUser()
+    {
+        count.store(initialCount = 100);
+        finishing = false;
+    }
+
+    bool shouldStartThread()
+    {
+        return !finishing;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        forever {
+            const int local = count.load();
+            if (local == 0) {
+                finishing = true;
+                return ThreadFinished;
+            }
+
+            if (count.testAndSetOrdered(local, local - 1))
+                break;
+        }
+        return ThrottleThread;
+    }
+
+    bool finishing;
+    int initialCount;
+};
+
+// Test that a user task with a thread function that always
+// want to be throttled still completes. The thread engine
+// should make keep one thread running at all times.
+void tst_QtConcurrentThreadEngine::throttle()
+{
+    const int repeats = 10;
+    for (int i = 0; i < repeats; ++i) {
+        QFuture<void> f = (new ThrottleAlwaysUser())->startAsynchronously();
+        f.waitForFinished();
+        QCOMPARE(count.load(), 0);
+    }
+
+    for (int i = 0; i < repeats; ++i) {
+        ThrottleAlwaysUser t;
+        t.startBlocking();
+        QCOMPARE(count.load(), 0);
+    }
+}
+
+QSet<QThread *> threads;
+QMutex mutex;
+class ThreadCountUser : public ThreadEngine<void>
+{
+public:
+    ThreadCountUser(bool finishImmediately = false)
+    {
+        threads.clear();
+        finishing = finishImmediately;
+    }
+
+    bool shouldStartThread()
+    {
+        return !finishing;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        {
+            QMutexLocker lock(&mutex);
+            threads.insert(QThread::currentThread());
+        }
+        QTest::qSleep(10);
+        finishing = true;
+        return ThreadFinished;
+    }
+
+    bool finishing;
+};
+
+void tst_QtConcurrentThreadEngine::threadCount()
+{
+    QSKIP("QTBUG-23333: This test is unstable");
+
+    const int repeats = 10;
+    for (int i = 0; i < repeats; ++i) {
+        ThreadCountUser t;
+        t.startBlocking();
+        QCOMPARE(threads.count(), QThreadPool::globalInstance()->maxThreadCount() + 1); // +1 for the main thread.
+
+        (new ThreadCountUser())->startAsynchronously().waitForFinished();
+        QCOMPARE(threads.count(), QThreadPool::globalInstance()->maxThreadCount());
+    }
+
+    // Set the finish flag immediately, this should give us one thread only.
+    for (int i = 0; i < repeats; ++i) {
+        ThreadCountUser t(true /*finishImmediately*/);
+        t.startBlocking();
+        QCOMPARE(threads.count(), 1);
+
+        (new ThreadCountUser(true /*finishImmediately*/))->startAsynchronously().waitForFinished();
+        QCOMPARE(threads.count(), 1);
+    }
+}
+
+class MultipleResultsUser : public ThreadEngine<int>
+{
+public:
+    bool shouldStartThread()
+    {
+        return false;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        for (int i = 0; i < 10; ++i)
+            this->reportResult(&i);
+        return ThreadFinished;
+    }
+};
+
+
+void tst_QtConcurrentThreadEngine::multipleResults()
+{
+    MultipleResultsUser *engine =  new MultipleResultsUser();
+    QFuture<int> f = engine->startAsynchronously();
+    QCOMPARE(f.results().count() , 10);
+    QCOMPARE(f.resultAt(0), 0);
+    QCOMPARE(f.resultAt(5), 5);
+    QCOMPARE(f.resultAt(9), 9);
+    f.waitForFinished();
+}
+
+
+class NoThreadsUser : public ThreadEngine<void>
+{
+public:
+    bool shouldStartThread()
+    {
+        return false;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        return ThreadFinished;
+    }
+
+    void *result()
+    {
+        return 0;
+    }
+};
+
+void tst_QtConcurrentThreadEngine::stresstest()
+{
+    const int times = 20000;
+
+    for (int i = 0; i < times; ++i) {
+        VoidResultUser *engine = new VoidResultUser();
+        engine->startAsynchronously().waitForFinished();
+    }
+
+    for (int i = 0; i < times; ++i) {
+        VoidResultUser *engine = new VoidResultUser();
+        engine->startAsynchronously();
+    }
+
+    for (int i = 0; i < times; ++i) {
+        VoidResultUser *engine = new VoidResultUser();
+        engine->startAsynchronously().waitForFinished();
+    }
+}
+
+const int sleepTime = 20;
+class SlowUser : public ThreadEngine<void>
+{
+public:
+    bool shouldStartThread() { return false; }
+    ThreadFunctionResult threadFunction() { QTest::qSleep(sleepTime); return ThreadFinished; }
+};
+
+void tst_QtConcurrentThreadEngine::cancelQueuedSlowUser()
+{
+    const int times = 100;
+
+    QTime t;
+    t.start();
+
+    {
+        QList<QFuture<void> > futures;
+        for (int i = 0; i < times; ++i) {
+            SlowUser *engine = new SlowUser();
+            futures.append(engine->startAsynchronously());
+        }
+
+        foreach(QFuture<void> future, futures)
+            future.cancel();
+    }
+
+    QVERIFY(t.elapsed() < (sleepTime * times) / 2);
+}
+
+#ifndef QT_NO_EXCEPTIONS
+
+class QtConcurrentExceptionThrower : public ThreadEngine<void>
+{
+public:
+    QtConcurrentExceptionThrower(QThread *blockThread = 0)
+    {
+        this->blockThread = blockThread;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        QTest::qSleep(50);
+        throw QtConcurrent::Exception();
+        return ThreadFinished;
+    }
+    QThread *blockThread;
+};
+
+class UnrelatedExceptionThrower : public ThreadEngine<void>
+{
+public:
+    UnrelatedExceptionThrower(QThread *blockThread = 0)
+    {
+        this->blockThread = blockThread;
+    }
+
+    ThreadFunctionResult threadFunction()
+    {
+        QTest::qSleep(50);
+        throw int();
+        return ThreadFinished;
+    }
+    QThread *blockThread;
+};
+
+void tst_QtConcurrentThreadEngine::exceptions()
+{
+    // Asynchronous mode:
+    {
+        bool caught = false;
+        try  {
+            QtConcurrentExceptionThrower *e = new QtConcurrentExceptionThrower();
+            QFuture<void> f = e->startAsynchronously();
+            f.waitForFinished();
+        } catch (const Exception &) {
+            caught = true;
+        }
+        QVERIFY2(caught, "did not get exception");
+    }
+
+    // Blocking mode:
+    // test throwing the exception from a worker thread.
+    {
+        bool caught = false;
+        try  {
+            QtConcurrentExceptionThrower e(QThread::currentThread());
+            e.startBlocking();
+        } catch (const Exception &) {
+            caught = true;
+        }
+        QVERIFY2(caught, "did not get exception");
+    }
+
+    // test throwing the exception from the main thread (different code path)
+    {
+        bool caught = false;
+        try  {
+            QtConcurrentExceptionThrower e(0);
+            e.startBlocking();
+        } catch (const Exception &) {
+            caught = true;
+        }
+        QVERIFY2(caught, "did not get exception");
+    }
+
+    // Asynchronous mode:
+    {
+        bool caught = false;
+        try  {
+            UnrelatedExceptionThrower *e = new UnrelatedExceptionThrower();
+            QFuture<void> f = e->startAsynchronously();
+            f.waitForFinished();
+        } catch (const QtConcurrent::UnhandledException &) {
+            caught = true;
+        }
+        QVERIFY2(caught, "did not get exception");
+    }
+
+    // Blocking mode:
+    // test throwing the exception from a worker thread.
+    {
+        bool caught = false;
+        try  {
+            UnrelatedExceptionThrower e(QThread::currentThread());
+            e.startBlocking();
+        } catch (const QtConcurrent::UnhandledException &) {
+            caught = true;
+        }
+        QVERIFY2(caught, "did not get exception");
+    }
+
+    // test throwing the exception from the main thread (different code path)
+    {
+        bool caught = false;
+        try  {
+            UnrelatedExceptionThrower e(0);
+            e.startBlocking();
+        } catch (const QtConcurrent::UnhandledException &) {
+            caught = true;
+        }
+        QVERIFY2(caught, "did not get exception");
+    }
+}
+
+#endif
+
+QTEST_MAIN(tst_QtConcurrentThreadEngine)
+
+#include "tst_qtconcurrentthreadengine.moc"
diff --git a/tests/auto/corelib/codecs/qtextcodec/tst_qtextcodec.cpp b/tests/auto/corelib/codecs/qtextcodec/tst_qtextcodec.cpp
index ade1786..7daed39 100644
--- a/tests/auto/corelib/codecs/qtextcodec/tst_qtextcodec.cpp
+++ b/tests/auto/corelib/codecs/qtextcodec/tst_qtextcodec.cpp
@@ -47,7 +47,6 @@
 #include <qtextdocument.h>
 #include <time.h>
 #include <qprocess.h>
-#include <QtConcurrentMap>
 #include <QThreadPool>
 
 class tst_QTextCodec : public QObject
@@ -55,9 +54,7 @@ class tst_QTextCodec : public QObject
     Q_OBJECT
 
 private slots:
-#ifndef QT_NO_CONCURRENT
     void threadSafety();
-#endif
 
     void toUnicode_data();
     void toUnicode();
@@ -1939,48 +1936,75 @@ void tst_QTextCodec::toLocal8Bit()
 }
 #endif
 
-static QByteArray loadAndConvert(const QByteArray &codecName)
+class LoadAndConvert: public QRunnable
 {
-    QTextCodec *c = QTextCodec::codecForName(codecName);
-    if (!c) {
-        qWarning() << "WARNING" << codecName << "not found?";
-        return QByteArray();
+public:
+    LoadAndConvert(const QByteArray &source, QByteArray *destination)
+        : codecName(source), target(destination)
+    {}
+    QByteArray codecName;
+    QByteArray *target;
+    void run()
+    {
+        QTextCodec *c = QTextCodec::codecForName(codecName);
+        if (!c) {
+            qWarning() << "WARNING" << codecName << "not found?";
+            return;
+        }
+        QString str = QString::fromLatin1(codecName);
+        QByteArray b = c->fromUnicode(str);
+        c->toUnicode(b);
+        *target = codecName;
     }
-    QString str = QString::fromLatin1(codecName);
-    QByteArray b = c->fromUnicode(str);
-    c->toUnicode(b);
-    return codecName;
-}
+};
 
-static int loadAndConvertMIB(int mib)
+class LoadAndConvertMIB: public QRunnable
 {
-    QTextCodec *c = QTextCodec::codecForMib(mib);
-    if (!c) {
-        qWarning() << "WARNING" << mib << "not found?";
-        return 0;
+public:
+    LoadAndConvertMIB(int mib, int *target)
+        : mib(mib), target(target)
+    {}
+    int mib;
+    int *target;
+    void run()
+    {
+        QTextCodec *c = QTextCodec::codecForMib(mib);
+        if (!c) {
+            qWarning() << "WARNING" << mib << "not found?";
+            return;
+        }
+        QString str = QString::number(mib);
+        QByteArray b = c->fromUnicode(str);
+        c->toUnicode(b);
+        *target = mib;
     }
-    QString str = QString::number(mib);
-    QByteArray b = c->fromUnicode(str);
-    c->toUnicode(b);
-    return mib;
-}
+};
 
 
-#ifndef QT_NO_CONCURRENT
 void tst_QTextCodec::threadSafety()
 {
     QList<QByteArray> codecList = QTextCodec::availableCodecs();
     QList<int> mibList = QTextCodec::availableMibs();
     QThreadPool::globalInstance()->setMaxThreadCount(12);
 
-    QFuture<QByteArray> res = QtConcurrent::mapped(codecList, loadAndConvert);
+    QVector<QByteArray> res;
+    res.resize(codecList.size());
+    for (int i = 0; i < codecList.size(); ++i) {
+        QThreadPool::globalInstance()->start(new LoadAndConvert(codecList.at(i), &res[i]));
+    }
 
-    QFuture<int> res2 = QtConcurrent::mapped(mibList, loadAndConvertMIB);
+    QVector<int> res2;
+    res2.resize(mibList.size());
+    for (int i = 0; i < mibList.size(); ++i) {
+        QThreadPool::globalInstance()->start(new LoadAndConvertMIB(mibList.at(i), &res2[i]));
+    }
+
+    // wait for all threads to finish working
+    QThreadPool::globalInstance()->waitForDone();
 
-    QCOMPARE(res.results(), codecList);
-    QCOMPARE(res2.results(), mibList);
+    QCOMPARE(res.toList(), codecList);
+    QCOMPARE(res2.toList(), mibList);
 }
-#endif
 
 void tst_QTextCodec::invalidNames()
 {
diff --git a/tests/auto/corelib/concurrent/concurrent.pro b/tests/auto/corelib/concurrent/concurrent.pro
deleted file mode 100644
index 6541b0c..0000000
--- a/tests/auto/corelib/concurrent/concurrent.pro
+++ /dev/null
@@ -1,13 +0,0 @@
-TEMPLATE=subdirs
-SUBDIRS=\
-   qfuture \
-   qfuturesynchronizer \
-   qfuturewatcher \
-   qtconcurrentfilter \
-   qtconcurrentiteratekernel \
-   qtconcurrentmap \
-   qtconcurrentresultstore \
-   qtconcurrentrun \
-   qtconcurrentthreadengine \
-   qthreadpool
-
diff --git a/tests/auto/corelib/concurrent/qfuture/.gitignore b/tests/auto/corelib/concurrent/qfuture/.gitignore
deleted file mode 100644
index 77c055c..0000000
--- a/tests/auto/corelib/concurrent/qfuture/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qfuture
diff --git a/tests/auto/corelib/concurrent/qfuture/qfuture.pro b/tests/auto/corelib/concurrent/qfuture/qfuture.pro
deleted file mode 100644
index 517871a..0000000
--- a/tests/auto/corelib/concurrent/qfuture/qfuture.pro
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qfuture
-QT = core-private testlib
-SOURCES = tst_qfuture.cpp
-DEFINES += QT_STRICT_ITERATORS
diff --git a/tests/auto/corelib/concurrent/qfuture/tst_qfuture.cpp b/tests/auto/corelib/concurrent/qfuture/tst_qfuture.cpp
deleted file mode 100644
index 3610f8f..0000000
--- a/tests/auto/corelib/concurrent/qfuture/tst_qfuture.cpp
+++ /dev/null
@@ -1,1438 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <QCoreApplication>
-#include <QDebug>
-
-#define QFUTURE_TEST
-
-#include <QtTest/QtTest>
-#include <qfuture.h>
-#include <qfuturewatcher.h>
-#include <qtconcurrentresultstore.h>
-#include <qtconcurrentexception.h>
-#include <private/qfutureinterface_p.h>
-
-using namespace QtConcurrent;
-
-// COM interface macro.
-#if defined(Q_OS_WIN) && defined(interface)
-#  undef interface
-#endif
-
-class tst_QFuture: public QObject
-{
-    Q_OBJECT
-private slots:
-    void resultStore();
-    void future();
-    void futureInterface();
-    void refcounting();
-    void cancel();
-    void statePropagation();
-    void multipleResults();
-    void indexedResults();
-    void progress();
-    void progressText();
-    void resultsAfterFinished();
-    void resultsAsList();
-    void implicitConversions();
-    void iterators();
-    void pause();
-    void throttling();
-    void voidConversions();
-#ifndef QT_NO_EXCEPTIONS
-    void exceptions();
-    void nestedExceptions();
-#endif
-};
-
-void tst_QFuture::resultStore()
-{
-    int int0 = 0;
-    int int1 = 1;
-    int int2 = 2;
-
-    {
-        ResultStore<int> store;
-        QVERIFY(store.begin() == store.end());
-        QVERIFY(store.resultAt(0) == store.end());
-        QVERIFY(store.resultAt(1) == store.end());
-    }
-
-
-    {
-        ResultStoreBase store;
-        store.addResult(-1, &int0); // note to self: adding a pointer to the stack here is ok since
-        store.addResult(1, &int1);  // ResultStoreBase does not take ownership, only ResultStore<> does.
-        ResultIteratorBase it = store.begin();
-        QCOMPARE(it.resultIndex(), 0);
-        QVERIFY(it == store.begin());
-        QVERIFY(it != store.end());
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 1);
-        QVERIFY(it != store.begin());
-        QVERIFY(it != store.end());
-
-        ++it;
-        QVERIFY(it != store.begin());
-        QVERIFY(it == store.end());
-    }
-
-    QVector<int> vec0 = QVector<int>() << 2 << 3;
-    QVector<int> vec1 = QVector<int>() << 4 << 5;
-
-    {
-        ResultStoreBase store;
-        store.addResults(-1, &vec0, 2, 2);
-        store.addResults(-1, &vec1, 2, 2);
-        ResultIteratorBase it = store.begin();
-        QCOMPARE(it.resultIndex(), 0);
-        QVERIFY(it == store.begin());
-        QVERIFY(it != store.end());
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 1);
-        QVERIFY(it != store.begin());
-        QVERIFY(it != store.end());
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 2);
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 3);
-
-        ++it;
-        QVERIFY(it == store.end());
-    }
-    {
-        ResultStoreBase store;
-        store.addResult(-1, &int0);
-        store.addResults(-1, &vec1, 2, 2);
-        store.addResult(-1, &int1);
-
-        ResultIteratorBase it = store.begin();
-        QCOMPARE(it.resultIndex(), 0);
-        QVERIFY(it == store.begin());
-        QVERIFY(it != store.end());
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 1);
-        QVERIFY(it != store.begin());
-        QVERIFY(it != store.end());
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 2);
-        QVERIFY(it != store.end());
-        ++it;
-        QCOMPARE(it.resultIndex(), 3);
-        QVERIFY(it != store.end());
-        ++it;
-        QVERIFY(it == store.end());
-
-        QCOMPARE(store.resultAt(0).resultIndex(), 0);
-        QCOMPARE(store.resultAt(1).resultIndex(), 1);
-        QCOMPARE(store.resultAt(2).resultIndex(), 2);
-        QCOMPARE(store.resultAt(3).resultIndex(), 3);
-        QCOMPARE(store.resultAt(4), store.end());
-    }
-    {
-        ResultStore<int> store;
-        store.addResult(-1, &int0);
-        store.addResults(-1, &vec0);
-        store.addResult(-1, &int1);
-
-        ResultIteratorBase it = store.begin();
-        QCOMPARE(it.resultIndex(), 0);
-        QVERIFY(it == store.begin());
-        QVERIFY(it != store.end());
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 1);
-        QVERIFY(it != store.begin());
-        QVERIFY(it != store.end());
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 2);
-        QVERIFY(it != store.end());
-        ++it;
-        QCOMPARE(it.resultIndex(), 3);
-        QVERIFY(it != store.end());
-        ++it;
-        QVERIFY(it == store.end());
-
-        QCOMPARE(store.resultAt(0).value(), int0);
-        QCOMPARE(store.resultAt(1).value(), vec0[0]);
-        QCOMPARE(store.resultAt(2).value(), vec0[1]);
-        QCOMPARE(store.resultAt(3).value(), int1);
-    }
-    {
-        ResultStore<int> store;
-        store.addResult(-1, &int0);
-        store.addResults(-1, &vec0);
-        store.addResult(200, &int1);
-
-        QCOMPARE(store.resultAt(0).value(), int0);
-        QCOMPARE(store.resultAt(1).value(), vec0[0]);
-        QCOMPARE(store.resultAt(2).value(), vec0[1]);
-        QCOMPARE(store.resultAt(200).value(), int1);
-    }
-
-    {
-        ResultStore<int> store;
-        store.addResult(1, &int1);
-        store.addResult(0, &int0);
-        store.addResult(-1, &int2);
-
-        QCOMPARE(store.resultAt(0).value(), int0);
-        QCOMPARE(store.resultAt(1).value(), int1);
-        QCOMPARE(store.resultAt(2).value(), int2);
-    }
-
-    {
-        ResultStore<int> store;
-        QCOMPARE(store.contains(0), false);
-        QCOMPARE(store.contains(1), false);
-        QCOMPARE(store.contains(INT_MAX), false);
-    }
-
-    {
-        // Test filter mode, where "gaps" in the result array aren't allowed.
-        ResultStore<int> store;
-        store.setFilterMode(true);
-
-        store.addResult(0, &int0);
-        QCOMPARE(store.contains(0), true);
-
-        store.addResult(2, &int2); // add result at index 2
-        QCOMPARE(store.contains(2), false); // but 1 is missing, so this 2 won't be reported yet.
-
-        store.addResult(1, &int1); 
-        QCOMPARE(store.contains(1), true);
-        QCOMPARE(store.contains(2), true); // 2 should be visible now.
-
-        store.addResult(4, &int0); 
-        store.addResult(5, &int0); 
-        store.addResult(7, &int0); 
-        QCOMPARE(store.contains(4), false);
-        QCOMPARE(store.contains(5), false);
-        QCOMPARE(store.contains(7), false);
-
-        store.addResult(3, &int0);  // adding 3 makes 4 and 5 visible
-        QCOMPARE(store.contains(4), true);
-        QCOMPARE(store.contains(5), true);
-        QCOMPARE(store.contains(7), false);
-
-        store.addResult(6, &int0);  // adding 6 makes 7 visible
-
-        QCOMPARE(store.contains(6), true);
-        QCOMPARE(store.contains(7), true);
-        QCOMPARE(store.contains(8), false);
-    }
-
-    {
-        // test canceled results
-        ResultStore<int> store;
-        store.setFilterMode(true);
-
-        store.addResult(0, &int0);
-        QCOMPARE(store.contains(0), true);
-        
-        store.addResult(2, &int0);
-        QCOMPARE(store.contains(2), false);       
-
-        store.addCanceledResult(1); // report no result at 1
-
-        QCOMPARE(store.contains(0), true);
-        QCOMPARE(store.contains(1), true); // 2 gets renamed to 1
-        QCOMPARE(store.contains(2), false);
-
-        store.addResult(3, &int0);
-        QCOMPARE(store.contains(2), true); //3 gets renamed to 2
-
-        store.addResult(6, &int0);
-        store.addResult(7, &int0);
-        QCOMPARE(store.contains(3), false);
- 
-        store.addCanceledResult(4);
-        store.addCanceledResult(5);
-
-        QCOMPARE(store.contains(3), true); //6 gets renamed to 3
-        QCOMPARE(store.contains(4), true); //7 gets renamed to 4
-
-        store.addResult(8, &int0);
-        QCOMPARE(store.contains(5), true); //8 gets renamed to 4
-
-        QCOMPARE(store.contains(6), false);
-        QCOMPARE(store.contains(7), false);
-    }
-
-    {
-        // test addResult return value
-        ResultStore<int> store;
-        store.setFilterMode(true);
-
-        store.addResult(0, &int0);
-        QCOMPARE(store.count(), 1); // result 0 becomes available
-        QCOMPARE(store.contains(0), true);
-        
-        store.addResult(2, &int0);
-        QCOMPARE(store.count(), 1);
-        QCOMPARE(store.contains(2), false);       
-
-        store.addCanceledResult(1);
-        QCOMPARE(store.count(), 2); // result 2 is renamed to 1 and becomes available
-
-        QCOMPARE(store.contains(0), true);
-        QCOMPARE(store.contains(1), true);
-        QCOMPARE(store.contains(2), false);
-
-        store.addResult(3, &int0);
-        QCOMPARE(store.count(), 3);
-        QCOMPARE(store.contains(2), true);
-
-        store.addResult(6, &int0);
-        QCOMPARE(store.count(), 3);
-        store.addResult(7, &int0);
-        QCOMPARE(store.count(), 3);
-        QCOMPARE(store.contains(3), false);
- 
-        store.addCanceledResult(4);
-        store.addCanceledResult(5);
-        QCOMPARE(store.count(), 5); // 6 and 7 is renamed to 3 and 4 and becomes available
-
-        QCOMPARE(store.contains(3), true);
-        QCOMPARE(store.contains(4), true);
-
-        store.addResult(8, &int0);
-        QCOMPARE(store.contains(5), true);
-        QCOMPARE(store.count(), 6);
-
-        QCOMPARE(store.contains(6), false);
-        QCOMPARE(store.contains(7), false);
-    }
-    
-    {
-        // test resultCount in non-filtered mode. It should always be possible
-        // to iterate through the results 0 to resultCount.
-        ResultStore<int> store;
-        store.addResult(0, &int0);
-        
-        QCOMPARE(store.count(), 1);
-
-        store.addResult(2, &int0);
-
-        QCOMPARE(store.count(), 1);
-
-        store.addResult(1, &int0);
-        QCOMPARE(store.count(), 3);
-    }
-
-    {
-        ResultStore<int> store;
-        store.addResult(2, &int0);
-        QCOMPARE(store.count(), 0);
-
-        store.addResult(1, &int0);
-        QCOMPARE(store.count(), 0);
-
-        store.addResult(0, &int0);
-        QCOMPARE(store.count(), 3);
-    }
-
-    {
-        ResultStore<int> store;
-        store.addResults(2, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addResult(1, &int0);
-        QCOMPARE(store.count(), 0);
-
-        store.addResult(0, &int0);
-        QCOMPARE(store.count(), 4);
-    }
-
-    {
-        ResultStore<int> store;
-        store.addResults(2, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addResults(0, &vec0);
-        QCOMPARE(store.count(), 4);
-    }
-    {
-        ResultStore<int> store;
-        store.addResults(3, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addResults(0, &vec0);
-        QCOMPARE(store.count(), 2);
-
-        store.addResult(2, &int0);
-        QCOMPARE(store.count(), 5);
-    }
-
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addResults(3, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addResults(0, &vec0);
-        QCOMPARE(store.count(), 2);
-
-        store.addCanceledResult(2);
-        QCOMPARE(store.count(), 4);
-    }
-
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addResults(3, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addCanceledResults(0, 3);
-        QCOMPARE(store.count(), 2);
-    }
-
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addResults(3, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addCanceledResults(0, 3);
-        QCOMPARE(store.count(), 2);  // results at 3 and 4 become available at index 0, 1
-
-        store.addResult(5, &int0); 
-        QCOMPARE(store.count(), 3);// result 5 becomes available at index 2
-    }
-
-    {
-        ResultStore<int> store;
-        store.addResult(1, &int0);
-        store.addResult(3, &int0);
-        store.addResults(6, &vec0);
-        QCOMPARE(store.contains(0), false);
-        QCOMPARE(store.contains(1), true);
-        QCOMPARE(store.contains(2), false);
-        QCOMPARE(store.contains(3), true);
-        QCOMPARE(store.contains(4), false);
-        QCOMPARE(store.contains(5), false);
-        QCOMPARE(store.contains(6), true);
-        QCOMPARE(store.contains(7), true);
-    }
-
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addResult(1, &int0);
-        store.addResult(3, &int0);
-        store.addResults(6, &vec0);
-        QCOMPARE(store.contains(0), false);
-        QCOMPARE(store.contains(1), false);
-        QCOMPARE(store.contains(2), false);
-        QCOMPARE(store.contains(3), false);
-        QCOMPARE(store.contains(4), false);
-        QCOMPARE(store.contains(5), false);
-        QCOMPARE(store.contains(6), false);
-        QCOMPARE(store.contains(7), false);
-
-        store.addCanceledResult(0);
-        store.addCanceledResult(2);
-        store.addCanceledResults(4, 2);
-
-        QCOMPARE(store.contains(0), true);
-        QCOMPARE(store.contains(1), true);
-        QCOMPARE(store.contains(2), true);
-        QCOMPARE(store.contains(3), true);
-        QCOMPARE(store.contains(4), false);
-        QCOMPARE(store.contains(5), false);
-        QCOMPARE(store.contains(6), false);
-        QCOMPARE(store.contains(7), false);
-    }
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addCanceledResult(0);
-        QCOMPARE(store.contains(0), false);
-
-        store.addResult(1, &int0);
-        QCOMPARE(store.contains(0), true);
-        QCOMPARE(store.contains(1), false);
-    }
-}
-
-void tst_QFuture::future()
-{
-    // default constructors
-    QFuture<int> intFuture;
-    intFuture.waitForFinished();
-    QFuture<QString> stringFuture;
-    stringFuture.waitForFinished();
-    QFuture<void> voidFuture;
-    voidFuture.waitForFinished();
-    QFuture<void> defaultVoidFuture;
-    defaultVoidFuture.waitForFinished();
-
-    // copy constructor
-    QFuture<int> intFuture2(intFuture);
-    QFuture<void> voidFuture2(defaultVoidFuture);
-
-    // assigmnent operator
-    intFuture2 = QFuture<int>();
-    voidFuture2 = QFuture<void>();
-
-    // state
-    QCOMPARE(intFuture2.isStarted(), true);
-    QCOMPARE(intFuture2.isFinished(), true);
-}
-
-class IntResult : public QFutureInterface<int>
-{
-public:
-    QFuture<int> run()
-    {
-        this->reportStarted();
-        QFuture<int> future = QFuture<int>(this);
-
-        int res = 10;
-        reportFinished(&res);
-        return future;
-    }
-};
-
-int value = 10;
-
-class VoidResult : public QFutureInterfaceBase
-{
-public:
-    QFuture<void> run()
-    {
-        this->reportStarted();
-        QFuture<void> future = QFuture<void>(this);
-        reportFinished();
-        return future;
-    }
-};
-
-void tst_QFuture::futureInterface()
-{
-    {
-        QFuture<void> future;
-        {
-            QFutureInterface<void> i;
-            i.reportStarted();
-            future = i.future();
-            i.reportFinished();
-        }
-    }
-    {
-        QFuture<int> future;
-        {
-            QFutureInterface<int> i;
-            i.reportStarted();
-            i.reportResult(10);
-            future = i.future();
-            i.reportFinished();
-        }
-        QCOMPARE(future.resultAt(0), 10);
-    }
-
-    {
-        QFuture<int> intFuture;
-
-        QCOMPARE(intFuture.isStarted(), true);
-        QCOMPARE(intFuture.isFinished(), true);
-
-        IntResult result;
-
-        result.reportStarted();
-        intFuture = result.future();
-
-        QCOMPARE(intFuture.isStarted(), true);
-        QCOMPARE(intFuture.isFinished(), false);
-
-        result.reportFinished(&value);
-
-        QCOMPARE(intFuture.isStarted(), true);
-        QCOMPARE(intFuture.isFinished(), true);
-
-        int e = intFuture.result();
-
-        QCOMPARE(intFuture.isStarted(), true);
-        QCOMPARE(intFuture.isFinished(), true);
-        QCOMPARE(intFuture.isCanceled(), false);
-
-        QCOMPARE(e, value);
-        intFuture.waitForFinished();
-
-        IntResult intAlgo;
-        intFuture = intAlgo.run();
-        QFuture<int> intFuture2(intFuture);
-        QCOMPARE(intFuture.result(), value);
-        QCOMPARE(intFuture2.result(), value);
-        intFuture.waitForFinished();
-
-        VoidResult a;
-        a.run().waitForFinished();
-    }
-}
-
-template <typename T>
-void testRefCounting()
-{
-    QFutureInterface<T> interface;
-    QCOMPARE(interface.d->refCount.load(), 1);
-
-    {
-        interface.reportStarted();
-
-        QFuture<T> f = interface.future();
-        QCOMPARE(interface.d->refCount.load(), 2);
-
-        QFuture<T> f2(f);
-        QCOMPARE(interface.d->refCount.load(), 3);
-
-        QFuture<T> f3;
-        f3 = f2;
-        QCOMPARE(interface.d->refCount.load(), 4);
-
-        interface.reportFinished(0);
-        QCOMPARE(interface.d->refCount.load(), 4);
-    }
-
-    QCOMPARE(interface.d->refCount.load(), 1);
-}
-
-void tst_QFuture::refcounting()
-{
-    testRefCounting<int>();
-}
-
-void tst_QFuture::cancel()
-{
-    {
-        QFuture<void> f;
-        QFutureInterface<void> result;
-
-        result.reportStarted();
-        f = result.future();
-        QVERIFY(f.isCanceled() == false);
-        result.reportCanceled();
-        QVERIFY(f.isCanceled());
-        result.reportFinished();
-        QVERIFY(f.isCanceled());
-        f.waitForFinished();
-        QVERIFY(f.isCanceled());
-    }
-
-    // Cancel from the QFuture side and test if the result
-    // interface detects it.
-    {
-        QFutureInterface<void> result;
-
-        QFuture<void> f;
-        QVERIFY(f.isStarted() == true);
-
-        result.reportStarted();
-        f = result.future();
-
-        QVERIFY(f.isStarted() == true);
-
-        QVERIFY(result.isCanceled() == false);
-        f.cancel();
-
-        QVERIFY(result.isCanceled());
-
-        result.reportFinished();
-    }
-
-    // Test that finished futures can be canceled.
-    {
-        QFutureInterface<void> result;
-
-        QFuture<void> f;
-        QVERIFY(f.isStarted() == true);
-
-        result.reportStarted();
-        f = result.future();
-
-        QVERIFY(f.isStarted() == true);
-
-        result.reportFinished();
-
-        f.cancel();
-
-        QVERIFY(result.isCanceled());
-        QVERIFY(f.isCanceled());
-    }
-
-    // Results reported after canceled is called should not be propagated.
-    {
-
-        QFutureInterface<int> futureInterface;
-        futureInterface.reportStarted();
-        QFuture<int> f = futureInterface.future();
-
-        int result = 0;
-        futureInterface.reportResult(&result);
-        result = 1;
-        futureInterface.reportResult(&result);
-        f.cancel();
-        result = 2;
-        futureInterface.reportResult(&result);
-        result = 3;
-        futureInterface.reportResult(&result);
-        futureInterface.reportFinished();
-        QCOMPARE(f.results(), QList<int>());
-    }
-}
-
-void tst_QFuture::statePropagation()
-{
-    QFuture<void> f1;
-    QFuture<void> f2;
-
-    QCOMPARE(f1.isStarted(), true);
-
-    QFutureInterface<void> result;
-    result.reportStarted();
-    f1 = result.future();
-
-    f2 = f1;
-
-    QCOMPARE(f2.isStarted(), true);
-
-    result.reportCanceled();
-
-    QCOMPARE(f2.isStarted(), true);
-    QCOMPARE(f2.isCanceled(), true);
-
-    QFuture<void> f3 = f2;
-
-    QCOMPARE(f3.isStarted(), true);
-    QCOMPARE(f3.isCanceled(), true);
-
-    result.reportFinished();
-
-    QCOMPARE(f2.isStarted(), true);
-    QCOMPARE(f2.isCanceled(), true);
-
-    QCOMPARE(f3.isStarted(), true);
-    QCOMPARE(f3.isCanceled(), true);
-}
-
-/*
-    Tests that a QFuture can return multiple results.
-*/
-void tst_QFuture::multipleResults()
-{
-    IntResult a;
-    a.reportStarted();
-    QFuture<int> f = a.future();
-
-    QFuture<int> copy = f;
-    int result;
-
-    result = 1;
-    a.reportResult(&result);
-    QCOMPARE(f.resultAt(0), 1);
-
-    result = 2;
-    a.reportResult(&result);
-    QCOMPARE(f.resultAt(1), 2);
-
-    result = 3;
-    a.reportResult(&result);
-
-    result = 4;
-    a.reportFinished(&result);
-
-    QCOMPARE(f.results(), QList<int>() << 1 << 2 << 3 << 4);
-
-    // test foreach
-    QList<int> fasit = QList<int>() << 1 << 2 << 3 << 4;
-    {
-        QList<int> results;
-        foreach(int result, f)
-            results.append(result);
-        QCOMPARE(results, fasit);
-    }
-    {
-        QList<int> results;
-        foreach(int result, copy)
-            results.append(result);
-        QCOMPARE(results, fasit);
-    }
-}
-
-/*
-    Test out-of-order result reporting using indexes
-*/
-void tst_QFuture::indexedResults()
-{
-    {
-        QFutureInterface<QChar> Interface;
-        QFuture<QChar> f;
-        QVERIFY(f.isStarted() == true);
-
-        Interface.reportStarted();
-        f = Interface.future();
-
-        QVERIFY(f.isStarted() == true);
-
-        QChar result;
-
-        result = 'B';
-        Interface.reportResult(&result, 1);
-
-        QCOMPARE(f.resultAt(1), result);
-
-        result = 'A';
-        Interface.reportResult(&result, 0);
-        QCOMPARE(f.resultAt(0), result);
-
-        result = 'C';
-        Interface.reportResult(&result); // no index
-        QCOMPARE(f.resultAt(2), result);
-
-        Interface.reportFinished();
-
-        QCOMPARE(f.results(), QList<QChar>() << 'A' << 'B' << 'C');
-    }
-
-    {
-        // Test result reporting with a missing result in the middle
-        QFutureInterface<int> Interface;
-        Interface.reportStarted();
-        QFuture<int> f = Interface.future();
-        int result;
-
-        result = 0;
-        Interface.reportResult(&result, 0);
-        QVERIFY(f.isResultReadyAt(0));
-        QCOMPARE(f.resultAt(0), 0);
-
-        result = 3;
-        Interface.reportResult(&result, 3);
-        QVERIFY(f.isResultReadyAt(3));
-        QCOMPARE(f.resultAt(3), 3);
-
-        result = 2;
-        Interface.reportResult(&result, 2);
-        QVERIFY(f.isResultReadyAt(2));
-        QCOMPARE(f.resultAt(2), 2);
-
-        result = 4;
-        Interface.reportResult(&result); // no index
-        QVERIFY(f.isResultReadyAt(4));
-        QCOMPARE(f.resultAt(4), 4);
-
-        Interface.reportFinished();
-
-        QCOMPARE(f.results(), QList<int>() << 0 << 2 << 3 << 4);
-    }
-}
-
-void tst_QFuture::progress()
-{
-    QFutureInterface<QChar> result;
-    QFuture<QChar> f;
-
-    QCOMPARE (f.progressValue(), 0);
-
-    result.reportStarted();
-    f = result.future();
-
-    QCOMPARE (f.progressValue(), 0);
-
-    result.setProgressValue(50);
-
-    QCOMPARE (f.progressValue(), 50);
-
-    result.reportFinished();
-
-    QCOMPARE (f.progressValue(), 50);
-}
-
-void tst_QFuture::progressText()
-{
-    QFutureInterface<void> i;
-    i.reportStarted();
-    QFuture<void> f = i.future();
-
-    QCOMPARE(f.progressText(), QLatin1String(""));
-    i.setProgressValueAndText(1, QLatin1String("foo"));
-    QCOMPARE(f.progressText(), QLatin1String("foo"));
-    i.reportFinished();
-}
-
-/*
-    Test that results reported after finished are ignored.
-*/
-void tst_QFuture::resultsAfterFinished()
-{
-    {
-        IntResult a;
-        a.reportStarted();
-        QFuture<int> f =  a.future();
-        int result;
-
-        QCOMPARE(f.resultCount(), 0);
-
-        result = 1;
-        a.reportResult(&result);
-        QCOMPARE(f.resultAt(0), 1);
-
-        a.reportFinished();
-
-        QCOMPARE(f.resultAt(0), 1);
-        QCOMPARE(f.resultCount(), 1);
-        result = 2;
-        a.reportResult(&result);
-        QCOMPARE(f.resultCount(), 1);
-    }
-    // cancel it
-    {
-        IntResult a;
-        a.reportStarted();
-        QFuture<int> f =  a.future();
-        int result;
-
-        QCOMPARE(f.resultCount(), 0);
-
-        result = 1;
-        a.reportResult(&result);
-        QCOMPARE(f.resultAt(0), 1);
-        QCOMPARE(f.resultCount(), 1);
-
-        a.reportCanceled();
-
-        QCOMPARE(f.resultAt(0), 1);
-        QCOMPARE(f.resultCount(), 1);
-
-        result = 2;
-        a.reportResult(&result);
-        a.reportFinished();
-    }
-}
-
-void tst_QFuture::resultsAsList()
-{
-    IntResult a;
-    a.reportStarted();
-    QFuture<int> f = a.future();
-
-    int result;
-    result = 1;
-    a.reportResult(&result);
-    result = 2;
-    a.reportResult(&result);
-
-    a.reportFinished();
-
-    QList<int> results = f.results();
-    QCOMPARE(results, QList<int>() << 1 << 2);
-}
-
-/*
-    Test that QFuture<T> can be implicitly converted to T
-*/
-void tst_QFuture::implicitConversions()
-{
-    QFutureInterface<QString> iface;
-    iface.reportStarted();
-
-    QFuture<QString> f(&iface);
-
-    const QString input("FooBar 2000");
-    iface.reportFinished(&input);
-
-    const QString result = f;
-    QCOMPARE(result, input);
-    QCOMPARE(QString(f), input);
-    QCOMPARE(static_cast<QString>(f), input);
-}
-
-void tst_QFuture::iterators()
-{
-    {
-        QFutureInterface<int> e;
-        e.reportStarted();
-        QFuture<int> f = e.future();
-
-        int result;
-        result = 1;
-        e.reportResult(&result);
-        result = 2;
-        e.reportResult(&result);
-        result = 3;
-        e.reportResult(&result);
-        e.reportFinished();
-
-        QList<int> results;
-        QFutureIterator<int> i(f);
-        while (i.hasNext()) {
-            results.append(i.next());
-        }
-
-        QCOMPARE(results, f.results());
-
-        QFuture<int>::const_iterator i1 = f.begin(), i2 = i1 + 1;
-        QFuture<int>::const_iterator c1 = i1, c2 = c1 + 1;
-
-        QVERIFY(i1 == i1);
-        QVERIFY(i1 == c1);
-        QVERIFY(c1 == i1);
-        QVERIFY(c1 == c1);
-        QVERIFY(i2 == i2);
-        QVERIFY(i2 == c2);
-        QVERIFY(c2 == i2);
-        QVERIFY(c2 == c2);
-
-        QVERIFY(i1 != i2);
-        QVERIFY(i1 != c2);
-        QVERIFY(c1 != i2);
-        QVERIFY(c1 != c2);
-        QVERIFY(i2 != i1);
-        QVERIFY(i2 != c1);
-        QVERIFY(c2 != i1);
-        QVERIFY(c2 != c1);
-
-        int x1 = *i1;
-        Q_UNUSED(x1);
-        int x2 = *i2;
-        Q_UNUSED(x2);
-        int y1 = *c1;
-        Q_UNUSED(y1);
-        int y2 = *c2;
-        Q_UNUSED(y2);
-    }
-
-    {
-        QFutureInterface<QString> e;
-        e.reportStarted();
-        QFuture<QString> f =  e.future();
-
-        e.reportResult(QString("one"));
-        e.reportResult(QString("two"));
-        e.reportResult(QString("three"));
-        e.reportFinished();
-
-        QList<QString> results;
-        QFutureIterator<QString> i(f);
-        while (i.hasNext()) {
-            results.append(i.next());
-        }
-
-        QCOMPARE(results, f.results());
-
-        QFuture<QString>::const_iterator i1 = f.begin(), i2 = i1 + 1;
-        QFuture<QString>::const_iterator c1 = i1, c2 = c1 + 1;
-
-        QVERIFY(i1 == i1);
-        QVERIFY(i1 == c1);
-        QVERIFY(c1 == i1);
-        QVERIFY(c1 == c1);
-        QVERIFY(i2 == i2);
-        QVERIFY(i2 == c2);
-        QVERIFY(c2 == i2);
-        QVERIFY(c2 == c2);
-
-        QVERIFY(i1 != i2);
-        QVERIFY(i1 != c2);
-        QVERIFY(c1 != i2);
-        QVERIFY(c1 != c2);
-        QVERIFY(i2 != i1);
-        QVERIFY(i2 != c1);
-        QVERIFY(c2 != i1);
-        QVERIFY(c2 != c1);
-
-        QString x1 = *i1;
-        QString x2 = *i2;
-        QString y1 = *c1;
-        QString y2 = *c2;
-
-        QCOMPARE(x1, y1);
-        QCOMPARE(x2, y2);
-
-        int i1Size = i1->size();
-        int i2Size = i2->size();
-        int c1Size = c1->size();
-        int c2Size = c2->size();
-
-        QCOMPARE(i1Size, c1Size);
-        QCOMPARE(i2Size, c2Size);
-    }
-
-    {
-        const int resultCount = 20;
-
-        QFutureInterface<int> e;
-        e.reportStarted();
-        QFuture<int> f =  e.future();
-
-        for (int i = 0; i < resultCount; ++i) {
-            e.reportResult(i);
-        }
-    
-        e.reportFinished();
-    
-        {
-            QFutureIterator<int> it(f);
-            QFutureIterator<int> it2(it);
-        }
-
-        {
-            QFutureIterator<int> it(f);
-    
-            for (int i = 0; i < resultCount - 1; ++i) {
-                QVERIFY(it.hasNext());
-                QCOMPARE(it.peekNext(), i);
-                QCOMPARE(it.next(), i);
-            }
-
-            QVERIFY(it.hasNext());
-            QCOMPARE(it.peekNext(), resultCount - 1);
-            QCOMPARE(it.next(), resultCount - 1);
-            QVERIFY(it.hasNext() == false);
-        }
-
-        {
-            QFutureIterator<int> it(f);
-            QVERIFY(it.hasNext());
-            it.toBack();
-            QVERIFY(it.hasNext() == false);
-            it.toFront();
-            QVERIFY(it.hasNext());
-        }
-    }
-}
-
-class SignalSlotObject : public QObject
-{
-Q_OBJECT
-public:
-    SignalSlotObject()
-    : finishedCalled(false),
-      canceledCalled(false),
-      rangeBegin(0),
-      rangeEnd(0) { }
-
-public slots:
-    void finished()
-    {
-        finishedCalled = true;
-    }
-
-    void canceled()
-    {
-        canceledCalled = true;
-    }
-
-    void resultReady(int index)
-    {
-        results.insert(index);
-    }
-
-    void progressRange(int begin, int end)
-    {
-        rangeBegin = begin;
-        rangeEnd = end;
-    }
-
-    void progress(int progress)
-    {
-        reportedProgress.insert(progress);
-    }
-public:
-    bool finishedCalled;
-    bool canceledCalled;
-    QSet<int> results;
-    int rangeBegin;
-    int rangeEnd;
-    QSet<int> reportedProgress;
-};
-
-void tst_QFuture::pause()
-{
-    QFutureInterface<void> Interface;
-
-    Interface.reportStarted();
-    QFuture<void> f = Interface.future();
-
-    QVERIFY(Interface.isPaused() == false);
-    f.pause();
-    QVERIFY(Interface.isPaused() == true);
-    f.resume();
-    QVERIFY(Interface.isPaused() == false);
-    f.togglePaused();
-    QVERIFY(Interface.isPaused() == true);
-    f.togglePaused();
-    QVERIFY(Interface.isPaused() == false);
-
-    Interface.reportFinished();
-}
-
-const int resultCount = 1000;
-
-class ResultObject : public QObject
-{
-Q_OBJECT
-public slots:
-    void resultReady(int)
-    {
-
-    }
-public:
-};
-
-// Test that that the isPaused() on future result interface returns true
-// if we report a lot of results that are not handled.
-void tst_QFuture::throttling()
-{
-    {
-        QFutureInterface<void> i;
-
-        i.reportStarted();
-        QFuture<void> f = i.future();
-
-        QVERIFY(i.isThrottled() == false);
-
-        i.setThrottled(true);
-        QVERIFY(i.isThrottled());
-
-        i.setThrottled(false);
-        QVERIFY(i.isThrottled() == false);
-
-        i.setThrottled(true);
-        QVERIFY(i.isThrottled());
-
-        i.reportFinished();
-    }
-}
-
-void tst_QFuture::voidConversions()
-{
-    QFutureInterface<int> iface;
-    iface.reportStarted();
-
-    QFuture<int> intFuture(&iface);
-
-    int value = 10;
-    iface.reportFinished(&value);
-
-    QFuture<void> voidFuture(intFuture);
-    voidFuture = intFuture;
-
-    QVERIFY(voidFuture == intFuture);
-}
-
-
-#ifndef QT_NO_EXCEPTIONS
-
-QFuture<void> createExceptionFuture()
-{
-    QFutureInterface<void> i;
-    i.reportStarted();
-    QFuture<void> f = i.future();
-
-    Exception e;
-    i.reportException(e);
-    i.reportFinished();
-    return f;
-}
-
-QFuture<int> createExceptionResultFuture()
-{
-    QFutureInterface<int> i;
-    i.reportStarted();
-    QFuture<int> f = i.future();
-    int r = 0;
-    i.reportResult(r);
-
-    Exception e;
-    i.reportException(e);
-    i.reportFinished();
-    return f;
-}
-
-class DerivedException : public Exception
-{
-public:
-    void raise() const { throw *this; }
-    Exception *clone() const { return new DerivedException(*this); }
-};
-
-QFuture<void> createDerivedExceptionFuture()
-{
-    QFutureInterface<void> i;
-    i.reportStarted();
-    QFuture<void> f = i.future();
-
-    DerivedException e;
-    i.reportException(e);
-    i.reportFinished();
-    return f;
-}
-
-void tst_QFuture::exceptions()
-{
-    // test throwing from waitForFinished
-    {
-        QFuture<void> f = createExceptionFuture();
-        bool caught = false;
-        try {
-            f.waitForFinished();
-        } catch (Exception &) {
-            caught = true;
-        }
-        QVERIFY(caught);
-    }
-
-    // test result()
-    {
-        QFuture<int> f = createExceptionResultFuture();
-        bool caught = false;
-        try {
-            f.result();
-        } catch (Exception &) {
-            caught = true;
-        }
-        QVERIFY(caught);
-    }
-
-    // test result() and destroy
-    {
-        bool caught = false;
-        try {
-            createExceptionResultFuture().result();
-        } catch (Exception &) {
-            caught = true;
-        }
-        QVERIFY(caught);
-    }
-
-    // test results()
-    {
-        QFuture<int> f = createExceptionResultFuture();
-        bool caught = false;
-        try {
-            f.results();
-        } catch (Exception &) {
-            caught = true;
-        }
-        QVERIFY(caught);
-    }
-
-    // test foreach
-    {
-        QFuture<int> f = createExceptionResultFuture();
-        bool caught = false;
-        try {
-            foreach (int e, f.results()) {
-                Q_UNUSED(e);
-                QFAIL("did not get exception");
-            }
-        } catch (Exception &) {
-            caught = true;
-        }
-        QVERIFY(caught);
-    }
-
-    // catch derived exceptions
-    {
-        bool caught = false;
-        try {
-            createDerivedExceptionFuture().waitForFinished();
-        } catch (Exception &) {
-            caught = true;
-        }
-        QVERIFY(caught);
-    }
-
-    {
-        bool caught = false;
-        try {
-            createDerivedExceptionFuture().waitForFinished();
-        } catch (DerivedException &) {
-            caught = true;
-        }
-        QVERIFY(caught);
-    }
-}
-
-class MyClass
-{
-public:
-    ~MyClass()
-    {
-        QFuture<void> f = createExceptionFuture();
-        try {
-            f.waitForFinished();
-        } catch (Exception &) {
-            caught = true;
-        }
-    }
-    static bool caught;
-};
-
-bool MyClass::caught = false;
-
-// This is a regression test for QTBUG-18149. where QFuture did not throw
-// exceptions if called from destructors when the stack was already unwinding
-// due to an exception having been thrown.
-void tst_QFuture::nestedExceptions()
-{
-    try {
-        MyClass m;
-        Q_UNUSED(m);
-        throw 0;
-    } catch (int) {}
-
-    QVERIFY(MyClass::caught);
-}
-
-#endif // QT_NO_EXCEPTIONS
-
-QTEST_MAIN(tst_QFuture)
-#include "tst_qfuture.moc"
diff --git a/tests/auto/corelib/concurrent/qfuturesynchronizer/qfuturesynchronizer.pro b/tests/auto/corelib/concurrent/qfuturesynchronizer/qfuturesynchronizer.pro
deleted file mode 100644
index b36560b..0000000
--- a/tests/auto/corelib/concurrent/qfuturesynchronizer/qfuturesynchronizer.pro
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qfuturesynchronizer
-QT = core testlib
-SOURCES = tst_qfuturesynchronizer.cpp
diff --git a/tests/auto/corelib/concurrent/qfuturesynchronizer/tst_qfuturesynchronizer.cpp b/tests/auto/corelib/concurrent/qfuturesynchronizer/tst_qfuturesynchronizer.cpp
deleted file mode 100644
index 5bf6d1d..0000000
--- a/tests/auto/corelib/concurrent/qfuturesynchronizer/tst_qfuturesynchronizer.cpp
+++ /dev/null
@@ -1,158 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QtTest>
-
-#include <QtCore/qfuturesynchronizer.h>
-#include <QtCore/qfuture.h>
-
-class tst_QFutureSynchronizer : public QObject
-{
-    Q_OBJECT
-
-
-private Q_SLOTS:
-    void construction();
-    void addFuture();
-    void cancelOnWait();
-    void clearFutures();
-    void futures();
-    void setFuture();
-    void waitForFinished();
-};
-
-
-void tst_QFutureSynchronizer::construction()
-{
-
-    QFuture<void> future;
-    QFutureSynchronizer<void> synchronizer;
-    QFutureSynchronizer<void> synchronizerWithFuture(future);
-
-    QCOMPARE(synchronizer.futures().size(), 0);
-    QCOMPARE(synchronizerWithFuture.futures().size(), 1);
-}
-
-void tst_QFutureSynchronizer::addFuture()
-{
-    QFutureSynchronizer<void> synchronizer;
-
-    synchronizer.addFuture(QFuture<void>());
-    QFuture<void> future;
-    synchronizer.addFuture(future);
-    synchronizer.addFuture(future);
-
-    QCOMPARE(synchronizer.futures().size(), 3);
-}
-
-void tst_QFutureSynchronizer::cancelOnWait()
-{
-    QFutureSynchronizer<void> synchronizer;
-    QVERIFY(!synchronizer.cancelOnWait());
-    synchronizer.setCancelOnWait(true);
-    QVERIFY(synchronizer.cancelOnWait());
-    synchronizer.setCancelOnWait(false);
-    QVERIFY(!synchronizer.cancelOnWait());
-    synchronizer.setCancelOnWait(true);
-    QVERIFY(synchronizer.cancelOnWait());
-}
-
-void tst_QFutureSynchronizer::clearFutures()
-{
-    QFutureSynchronizer<void> synchronizer;
-    synchronizer.clearFutures();
-    QVERIFY(synchronizer.futures().isEmpty());
-
-    synchronizer.addFuture(QFuture<void>());
-    QFuture<void> future;
-    synchronizer.addFuture(future);
-    synchronizer.addFuture(future);
-    synchronizer.clearFutures();
-    QVERIFY(synchronizer.futures().isEmpty());
-}
-
-void tst_QFutureSynchronizer::futures()
-{
-    QFutureSynchronizer<void> synchronizer;
-
-    QList<QFuture<void> > futures;
-    for (int i=0; i<100; i++) {
-        QFuture<void> future;
-        futures.append(future);
-        synchronizer.addFuture(future);
-    }
-
-    QCOMPARE(futures, synchronizer.futures());
-}
-
-void tst_QFutureSynchronizer::setFuture()
-{
-    QFutureSynchronizer<void> synchronizer;
-
-    for (int i=0; i<100; i++) {
-        synchronizer.addFuture(QFuture<void>());
-    }
-    QCOMPARE(synchronizer.futures().size(), 100);
-
-    QFuture<void> future;
-    synchronizer.setFuture(future);
-    QCOMPARE(synchronizer.futures().size(), 1);
-    QCOMPARE(synchronizer.futures().first(), future);
-}
-
-void tst_QFutureSynchronizer::waitForFinished()
-{
-    QFutureSynchronizer<void> synchronizer;
-
-    for (int i=0; i<100; i++) {
-        synchronizer.addFuture(QFuture<void>());
-    }
-    synchronizer.waitForFinished();
-    const QList<QFuture<void> > futures = synchronizer.futures();
-
-    for (int i=0; i<100; i++) {
-        QVERIFY(futures.at(i).isFinished());
-    }
-}
-
-QTEST_MAIN(tst_QFutureSynchronizer)
-
-#include "tst_qfuturesynchronizer.moc"
diff --git a/tests/auto/corelib/concurrent/qfuturewatcher/.gitignore b/tests/auto/corelib/concurrent/qfuturewatcher/.gitignore
deleted file mode 100644
index 1d77843..0000000
--- a/tests/auto/corelib/concurrent/qfuturewatcher/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qfuturewatcher
diff --git a/tests/auto/corelib/concurrent/qfuturewatcher/qfuturewatcher.pro b/tests/auto/corelib/concurrent/qfuturewatcher/qfuturewatcher.pro
deleted file mode 100644
index ae98fed..0000000
--- a/tests/auto/corelib/concurrent/qfuturewatcher/qfuturewatcher.pro
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qfuturewatcher
-QT = core-private testlib
-SOURCES = tst_qfuturewatcher.cpp
diff --git a/tests/auto/corelib/concurrent/qfuturewatcher/tst_qfuturewatcher.cpp b/tests/auto/corelib/concurrent/qfuturewatcher/tst_qfuturewatcher.cpp
deleted file mode 100644
index 5a86d97..0000000
--- a/tests/auto/corelib/concurrent/qfuturewatcher/tst_qfuturewatcher.cpp
+++ /dev/null
@@ -1,945 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <QCoreApplication>
-#include <QDebug>
-#include <QtTest/QtTest>
-
-#include <qfuture.h>
-#include <qfuturewatcher.h>
-#include <qtconcurrentrun.h>
-#include <qtconcurrentmap.h>
-#include <private/qfutureinterface_p.h>
-
-using namespace QtConcurrent;
-
-#include <QtTest/QtTest>
-
-//#define PRINT
-
-class tst_QFutureWatcher: public QObject
-{
-    Q_OBJECT
-private slots:
-    void startFinish();
-    void progressValueChanged();
-    void canceled();
-    void resultAt();
-    void resultReadyAt();
-    void futureSignals();
-    void watchFinishedFuture();
-    void watchCanceledFuture();
-    void disconnectRunningFuture();
-    void tooMuchProgress();
-    void progressText();
-    void sharedFutureInterface();
-    void changeFuture();
-    void cancelEvents();
-    void pauseEvents();
-    void finishedState();
-    void throttling();
-    void incrementalMapResults();
-    void incrementalFilterResults();
-    void qfutureSynchronizer();
-    void warnRace();
-};
-
-void sleeper()
-{
-    QTest::qSleep(100);
-}
-
-void tst_QFutureWatcher::startFinish()
-{
-    QFutureWatcher<void> futureWatcher;
-
-    QSignalSpy startedSpy(&futureWatcher, SIGNAL(started()));
-    QSignalSpy finishedSpy(&futureWatcher, SIGNAL(finished()));
-
-    QVERIFY(startedSpy.isValid());
-    QVERIFY(finishedSpy.isValid());
-
-    futureWatcher.setFuture(QtConcurrent::run(sleeper));
-    QTest::qWait(10); // spin the event loop to deliver queued signals.
-    QCOMPARE(startedSpy.count(), 1);
-    QCOMPARE(finishedSpy.count(), 0);
-    futureWatcher.future().waitForFinished();
-    QTest::qWait(10);
-    QCOMPARE(startedSpy.count(), 1);
-    QCOMPARE(finishedSpy.count(), 1);
-}
-
-void mapSleeper(int &)
-{
-    QTest::qSleep(100);
-}
-
-QSet<int> progressValues;
-QSet<QString> progressTexts;
-QMutex mutex;
-class ProgressObject : public QObject
-{
-Q_OBJECT
-public slots:
-    void printProgress(int);
-    void printText(const QString &text);
-    void registerProgress(int);
-    void registerText(const QString &text);
-};
-
-void ProgressObject::printProgress(int progress)
-{
-    qDebug() << "thread" << QThread::currentThread() << "reports progress" << progress;
-}
-
-void ProgressObject::printText(const QString &text)
-{
-    qDebug() << "thread" << QThread::currentThread() << "reports progress text" << text;
-}
-
-void ProgressObject::registerProgress(int progress)
-{
-    QTest::qSleep(1);
-    progressValues.insert(progress);
-}
-
-void ProgressObject::registerText(const QString &text)
-{
-    QTest::qSleep(1);
-    progressTexts.insert(text);
-}
-
-
-QList<int> createList(int listSize)
-{
-    QList<int> list;
-    for (int i = 0; i < listSize; ++i) {
-        list.append(i);
-    }
-    return list;
-}
-
-void tst_QFutureWatcher::progressValueChanged()
-{
-#ifdef PRINT
-    qDebug() << "main thread" << QThread::currentThread();
-#endif
-
-    progressValues.clear();
-    const int listSize = 20;
-    QList<int> list = createList(listSize);
-
-    QFutureWatcher<void> futureWatcher;
-    ProgressObject progressObject;
-    QObject::connect(&futureWatcher, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
-#ifdef PRINT
-    QObject::connect(&futureWatcher, SIGNAL(progressValueChanged(int)), &progressObject, SLOT(printProgress(int)), Qt::DirectConnection );
-#endif
-    QObject::connect(&futureWatcher, SIGNAL(progressValueChanged(int)), &progressObject, SLOT(registerProgress(int)));
-
-    futureWatcher.setFuture(QtConcurrent::map(list, mapSleeper));
-
-    QTestEventLoop::instance().enterLoop(5);
-    QVERIFY(!QTestEventLoop::instance().timeout());
-    futureWatcher.disconnect();
-    QVERIFY(progressValues.contains(0));
-    QVERIFY(progressValues.contains(listSize));
-}
-
-class CancelObject : public QObject
-{
-Q_OBJECT
-public:
-    bool wasCanceled;
-    CancelObject() : wasCanceled(false) {};
-public slots:
-    void cancel();
-};
-
-void CancelObject::cancel()
-{
-#ifdef PRINT
-    qDebug() << "thread" << QThread::currentThread() << "reports canceled";
-#endif
-    wasCanceled = true;
-}
-
-void tst_QFutureWatcher::canceled()
-{
-    const int listSize = 20;
-    QList<int> list = createList(listSize);
-
-    QFutureWatcher<void> futureWatcher;
-    QFuture<void> future;
-    CancelObject cancelObject;
-
-    QObject::connect(&futureWatcher, SIGNAL(canceled()), &cancelObject, SLOT(cancel()));
-    QObject::connect(&futureWatcher, SIGNAL(canceled()),
-        &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
-
-    future = QtConcurrent::map(list, mapSleeper);
-    futureWatcher.setFuture(future);
-    futureWatcher.cancel();
-    QTestEventLoop::instance().enterLoop(5);
-    QVERIFY(!QTestEventLoop::instance().timeout());
-
-    QVERIFY(future.isCanceled());
-    QVERIFY(cancelObject.wasCanceled);
-    futureWatcher.disconnect();
-    future.waitForFinished();
-}
-
-class IntTask : public RunFunctionTask<int>
-{
-public:
-    void runFunctor()
-    {
-        result = 10;
-    }
-};
-
-void tst_QFutureWatcher::resultAt()
-{
-    QFutureWatcher<int> futureWatcher;
-    futureWatcher.setFuture((new IntTask())->start());
-    futureWatcher.waitForFinished();
-    QCOMPARE(futureWatcher.result(), 10);
-    QCOMPARE(futureWatcher.resultAt(0), 10);
-}
-
-void tst_QFutureWatcher::resultReadyAt()
-{
-    QFutureWatcher<int> futureWatcher;
-    QObject::connect(&futureWatcher, SIGNAL(resultReadyAt(int)), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
-
-    QFuture<int> future = (new IntTask())->start();
-    futureWatcher.setFuture(future);
-
-    QTestEventLoop::instance().enterLoop(1);
-    QVERIFY(!QTestEventLoop::instance().timeout());
-
-    // Setting the future again should give us another signal.
-    // (this is to prevent the race where the task associated
-    // with the future finishes before setFuture is called.)
-    futureWatcher.setFuture(QFuture<int>());
-    futureWatcher.setFuture(future);
-
-    QTestEventLoop::instance().enterLoop(1);
-    QVERIFY(!QTestEventLoop::instance().timeout());
-}
-
-class SignalSlotObject : public QObject
-{
-Q_OBJECT
-
-signals:
-    void cancel();
-
-public slots:
-    void started()
-    {
-        qDebug() << "started called";
-    }
-
-    void finished()
-    {
-        qDebug() << "finished called";
-    }
-
-    void canceled()
-    {
-        qDebug() << "canceled called";
-    }
-
-#ifdef PRINT
-    void resultReadyAt(int index)
-    {
-        qDebug() << "result" << index << "ready";
-    }
-#else
-    void resultReadyAt(int) { }
-#endif
-    void progressValueChanged(int progress)
-    {
-        qDebug() << "progress" << progress;
-    }
-
-    void progressRangeChanged(int min, int max)
-    {
-        qDebug() << "progress range" << min << max;
-    }
-
-};
-
-void tst_QFutureWatcher::futureSignals()
-{
-    {
-        QFutureInterface<int> a;
-        QFutureWatcher<int> f;
-
-        SignalSlotObject object;
-#ifdef PRINT
-        connect(&f, SIGNAL(finished()), &object, SLOT(finished()));
-        connect(&f, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
-#endif
-        // must connect to resultReadyAt so that the watcher can detect the connection
-        // (QSignalSpy does not trigger it.)
-        connect(&f, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-        a.reportStarted();
-        f.setFuture(a.future());
-
-        QSignalSpy progressSpy(&f, SIGNAL(progressValueChanged(int)));
-        QVERIFY(progressSpy.isValid());
-        const int progress = 1;
-        a.setProgressValue(progress);
-        QTest::qWait(10);
-        QCOMPARE(progressSpy.count(), 2);
-        QCOMPARE(progressSpy.takeFirst().at(0).toInt(), 0);
-        QCOMPARE(progressSpy.takeFirst().at(0).toInt(), 1);
-
-        QSignalSpy finishedSpy(&f, SIGNAL(finished()));
-        QSignalSpy resultReadySpy(&f, SIGNAL(resultReadyAt(int)));
-
-        QVERIFY(finishedSpy.isValid());
-        QVERIFY(resultReadySpy.isValid());
-
-        const int result = 10;
-        a.reportResult(&result);
-        QTest::qWait(10);
-        QCOMPARE(resultReadySpy.count(), 1);
-        a.reportFinished(&result);
-        QTest::qWait(10);
-
-        QCOMPARE(resultReadySpy.count(), 2);
-        QCOMPARE(resultReadySpy.takeFirst().at(0).toInt(), 0); // check the index
-        QCOMPARE(resultReadySpy.takeFirst().at(0).toInt(), 1);
-
-        QCOMPARE(finishedSpy.count(), 1);
-    }
-}
-
-void tst_QFutureWatcher::watchFinishedFuture()
-{
-    QFutureInterface<int> iface;
-    iface.reportStarted();
-
-    QFuture<int> f = iface.future();
-
-    int value = 100;
-    iface.reportFinished(&value);
-
-    QFutureWatcher<int> watcher;
-
-    SignalSlotObject object;
-#ifdef PRINT
-    connect(&watcher, SIGNAL(started()), &object, SLOT(started()));
-    connect(&watcher, SIGNAL(canceled()), &object, SLOT(canceled()));
-    connect(&watcher, SIGNAL(finished()), &object, SLOT(finished()));
-    connect(&watcher, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
-    connect(&watcher, SIGNAL(progressRangeChanged(int, int)), &object, SLOT(progressRangeChanged(int, int)));
-#endif
-    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-
-    QSignalSpy startedSpy(&watcher, SIGNAL(started()));
-    QSignalSpy finishedSpy(&watcher, SIGNAL(finished()));
-    QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
-    QSignalSpy canceledSpy(&watcher, SIGNAL(canceled()));
-
-    QVERIFY(startedSpy.isValid());
-    QVERIFY(finishedSpy.isValid());
-    QVERIFY(resultReadySpy.isValid());
-    QVERIFY(canceledSpy.isValid());
-
-    watcher.setFuture(f);
-    QTest::qWait(10);
-
-    QCOMPARE(startedSpy.count(), 1);
-    QCOMPARE(finishedSpy.count(), 1);
-    QCOMPARE(resultReadySpy.count(), 1);
-    QCOMPARE(canceledSpy.count(), 0);
-}
-
-void tst_QFutureWatcher::watchCanceledFuture()
-{
-    QFuture<int> f;
-    QFutureWatcher<int> watcher;
-
-    SignalSlotObject object;
-#ifdef PRINT
-    connect(&watcher, SIGNAL(started()), &object, SLOT(started()));
-    connect(&watcher, SIGNAL(canceled()), &object, SLOT(canceled()));
-    connect(&watcher, SIGNAL(finished()), &object, SLOT(finished()));
-    connect(&watcher, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
-    connect(&watcher, SIGNAL(progressRangeChanged(int, int)), &object, SLOT(progressRangeChanged(int, int)));
-#endif
-    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-
-    QSignalSpy startedSpy(&watcher, SIGNAL(started()));
-    QSignalSpy finishedSpy(&watcher, SIGNAL(finished()));
-    QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
-    QSignalSpy canceledSpy(&watcher, SIGNAL(canceled()));
-
-    QVERIFY(startedSpy.isValid());
-    QVERIFY(finishedSpy.isValid());
-    QVERIFY(resultReadySpy.isValid());
-    QVERIFY(canceledSpy.isValid());
-
-    watcher.setFuture(f);
-    QTest::qWait(10);
-
-    QCOMPARE(startedSpy.count(), 1);
-    QCOMPARE(finishedSpy.count(), 1);
-    QCOMPARE(resultReadySpy.count(), 0);
-    QCOMPARE(canceledSpy.count(), 1);
-}
-
-void tst_QFutureWatcher::disconnectRunningFuture()
-{
-    QFutureInterface<int> a;
-    a.reportStarted();
-
-    QFuture<int> f = a.future();
-    QFutureWatcher<int> *watcher = new QFutureWatcher<int>();
-    watcher->setFuture(f);
-
-    SignalSlotObject object;
-    connect(watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-
-    QSignalSpy finishedSpy(watcher, SIGNAL(finished()));
-    QSignalSpy resultReadySpy(watcher, SIGNAL(resultReadyAt(int)));
-
-    QVERIFY(finishedSpy.isValid());
-    QVERIFY(resultReadySpy.isValid());
-
-    const int result = 10;
-    a.reportResult(&result);
-    QTest::qWait(10);
-    QCOMPARE(resultReadySpy.count(), 1);
-
-    delete watcher;
-
-    a.reportResult(&result);
-    QTest::qWait(10);
-    QCOMPARE(resultReadySpy.count(), 1);
-
-    a.reportFinished(&result);
-    QTest::qWait(10);
-    QCOMPARE(finishedSpy.count(), 0);
-}
-
-const int maxProgress = 100000;
-class ProgressEmitterTask : public RunFunctionTask<void>
-{
-public:
-    void runFunctor()
-    {
-        setProgressRange(0, maxProgress);
-        for (int p = 0; p <= maxProgress; ++p)
-            setProgressValue(p);
-    }
-};
-
-void tst_QFutureWatcher::tooMuchProgress()
-{
-    progressValues.clear();
-    ProgressObject o;
-
-    QFutureWatcher<void> f;
-    QObject::connect(&f, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
-#ifdef PRINT
-    QObject::connect(&f, SIGNAL(progressValueChanged(int)), &o, SLOT(printProgress(int)));
-#endif
-    QObject::connect(&f, SIGNAL(progressValueChanged(int)), &o, SLOT(registerProgress(int)));
-    f.setFuture((new ProgressEmitterTask())->start());
-
-    QTestEventLoop::instance().enterLoop(5);
-    QVERIFY(!QTestEventLoop::instance().timeout());
-    QVERIFY(progressValues.contains(maxProgress));
-}
-
-template <typename T>
-class ProgressTextTask : public RunFunctionTask<T>
-{
-public:
-    void runFunctor()
-    {
-        this->setProgressValueAndText(1, QLatin1String("Foo 1"));
-
-        while (this->isProgressUpdateNeeded() == false)
-            QTest::qSleep(1);
-        this->setProgressValueAndText(2, QLatin1String("Foo 2"));
-
-        while (this->isProgressUpdateNeeded() == false)
-            QTest::qSleep(1);
-        this->setProgressValueAndText(3, QLatin1String("Foo 3"));
-
-        while (this->isProgressUpdateNeeded() == false)
-            QTest::qSleep(1);
-        this->setProgressValueAndText(4, QLatin1String("Foo 4"));
-    }
-};
-
-void tst_QFutureWatcher::progressText()
-{
-    {   // instantiate API for T=int and T=void.
-        ProgressTextTask<int> a;
-        ProgressTextTask<void> b;
-    }
-    {
-        progressValues.clear();
-        progressTexts.clear();
-        QFuture<int> f = ((new ProgressTextTask<int>())->start());
-        QFutureWatcher<int> watcher;
-        ProgressObject o;
-        QObject::connect(&watcher, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
-#ifdef PRINT
-        QObject::connect(&watcher, SIGNAL(progressValueChanged(int)), &o, SLOT(printProgress(int)));
-        QObject::connect(&watcher, SIGNAL(progressTextChanged(const QString &)), &o, SLOT(printText(const QString &)));
-#endif
-        QObject::connect(&watcher, SIGNAL(progressValueChanged(int)), &o, SLOT(registerProgress(int)));
-        QObject::connect(&watcher, SIGNAL(progressTextChanged(const QString &)), &o, SLOT(registerText(const QString &)));
-
-        watcher.setFuture(f);
-        QTestEventLoop::instance().enterLoop(5);
-        QVERIFY(!QTestEventLoop::instance().timeout());
-
-        QCOMPARE(f.progressText(), QLatin1String("Foo 4"));
-        QCOMPARE(f.progressValue(), 4);
-        QVERIFY(progressValues.contains(1));
-        QVERIFY(progressValues.contains(2));
-        QVERIFY(progressValues.contains(3));
-        QVERIFY(progressValues.contains(4));
-        QVERIFY(progressTexts.contains(QLatin1String("Foo 1")));
-        QVERIFY(progressTexts.contains(QLatin1String("Foo 2")));
-        QVERIFY(progressTexts.contains(QLatin1String("Foo 3")));
-        QVERIFY(progressTexts.contains(QLatin1String("Foo 4")));
-    }
-}
-
-template <typename T>
-void callInterface(T &obj)
-{
-    obj.progressValue();
-    obj.progressMinimum();
-    obj.progressMaximum();
-    obj.progressText();
-
-    obj.isStarted();
-    obj.isFinished();
-    obj.isRunning();
-    obj.isCanceled();
-    obj.isPaused();
-
-    obj.cancel();
-    obj.pause();
-    obj.resume();
-    obj.togglePaused();
-    obj.waitForFinished();
-
-    const T& objConst = obj;
-    objConst.progressValue();
-    objConst.progressMinimum();
-    objConst.progressMaximum();
-    objConst.progressText();
-
-    objConst.isStarted();
-    objConst.isFinished();
-    objConst.isRunning();
-    objConst.isCanceled();
-    objConst.isPaused();
-}
-
-template <typename T>
-void callInterface(const T &obj)
-{
-    obj.result();
-    obj.resultAt(0);
-}
-
-
-// QFutureWatcher and QFuture has a similar interface. Test
-// that the functions we want ot have in both are actually
-// there.
-void tst_QFutureWatcher::sharedFutureInterface()
-{
-    QFutureInterface<int> iface;
-    iface.reportStarted();
-
-    QFuture<int> intFuture = iface.future();
-
-    int value = 0;
-    iface.reportFinished(&value);
-
-    QFuture<void> voidFuture;
-    QFutureWatcher<int> intWatcher;
-    intWatcher.setFuture(intFuture);
-    QFutureWatcher<void> voidWatcher;
-
-    callInterface(intFuture);
-    callInterface(voidFuture);
-    callInterface(intWatcher);
-    callInterface(voidWatcher);
-
-    callInterface(intFuture);
-    callInterface(intWatcher);
-}
-
-void tst_QFutureWatcher::changeFuture()
-{
-    QFutureInterface<int> iface;
-    iface.reportStarted();
-
-    QFuture<int> a = iface.future();
-
-    int value = 0;
-    iface.reportFinished(&value);
-
-    QFuture<int> b;
-
-    QFutureWatcher<int> watcher;
-
-    SignalSlotObject object;
-    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-    QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
-    QVERIFY(resultReadySpy.isValid());
-
-    watcher.setFuture(a); // Watch 'a' which will genere a resultReady event.
-    watcher.setFuture(b); // But oh no! we're switching to another future
-    QTest::qWait(10);     // before the event gets delivered.
-
-    QCOMPARE(resultReadySpy.count(), 0);
-
-    watcher.setFuture(a);
-    watcher.setFuture(b);
-    watcher.setFuture(a); // setting it back gets us one event, not two.
-    QTest::qWait(10);
-
-    QCOMPARE(resultReadySpy.count(), 1);
-}
-
-// Test that events aren't delivered from canceled futures
-void tst_QFutureWatcher::cancelEvents()
-{
-    QFutureInterface<int> iface;
-    iface.reportStarted();
-
-    QFuture<int> a = iface.future();
-
-    int value = 0;
-    iface.reportFinished(&value);
-
-    QFutureWatcher<int> watcher;
-
-    SignalSlotObject object;
-    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-    QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
-    QVERIFY(resultReadySpy.isValid());
-
-    watcher.setFuture(a);
-    watcher.cancel();
-
-    QTest::qWait(10);
-
-    QCOMPARE(resultReadySpy.count(), 0);
-}
-
-// Tests that events from paused futures are saved and
-// delivered on resume.
-void tst_QFutureWatcher::pauseEvents()
-{
-    {
-        QFutureInterface<int> iface;
-        iface.reportStarted();
-
-        QFuture<int> a = iface.future();
-
-        int value = 0;
-        iface.reportFinished(&value);
-
-        QFutureWatcher<int> watcher;
-
-        SignalSlotObject object;
-        connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-        QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
-        QVERIFY(resultReadySpy.isValid());
-
-        watcher.setFuture(a);
-        watcher.pause();
-
-        QTest::qWait(10);
-        QCOMPARE(resultReadySpy.count(), 0);
-
-        watcher.resume();
-        QTest::qWait(10);
-        QCOMPARE(resultReadySpy.count(), 1);
-    }
-    {
-        QFutureInterface<int> iface;
-        iface.reportStarted();
-
-        QFuture<int> a = iface.future();
-
-        int value = 0;
-        iface.reportFinished(&value);
-
-        QFutureWatcher<int> watcher;
-
-        SignalSlotObject object;
-        connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-        QSignalSpy resultReadySpy(&watcher, SIGNAL(resultReadyAt(int)));
-        QVERIFY(resultReadySpy.isValid());
-
-        watcher.setFuture(a);
-        a.pause();
-
-        QFuture<int> b;
-        watcher.setFuture(b); // If we watch b instead, resuming a
-        a.resume();           // should give us no results.
-
-        QTest::qWait(10);
-        QCOMPARE(resultReadySpy.count(), 0);
-    }
-}
-
-// Test that the finished state for the watcher gets
-// set when the finished event is delivered.
-// This means it will lag the finished state for the future,
-// but makes it more useful.
-void tst_QFutureWatcher::finishedState()
-{
-    QFutureInterface<int> iface;
-    iface.reportStarted();
-    QFuture<int> future = iface.future();
-    QFutureWatcher<int> watcher;
-
-    watcher.setFuture(future);
-    QTest::qWait(10);
-
-    iface.reportFinished();
-    QVERIFY(future.isFinished());
-    QVERIFY(watcher.isFinished() == false);
-
-    QTest::qWait(10);
-    QVERIFY(watcher.isFinished());
-}
-
-/*
-    Verify that throttling kicks in if you report a lot of results,
-    and that it clears when the result events are processed.
-*/
-void tst_QFutureWatcher::throttling()
-{
-    QFutureInterface<int> iface;
-    iface.reportStarted();
-    QFuture<int> future = iface.future();
-    QFutureWatcher<int> watcher;
-    watcher.setFuture(future);
-
-    QVERIFY(iface.isThrottled() == false);
-
-    for (int i = 0; i < 1000; ++i) {
-        int result = 0;
-        iface.reportResult(result);
-    }
-
-    QVERIFY(iface.isThrottled() == true);
-
-    QTest::qWait(100); // process events.
-
-    QVERIFY(iface.isThrottled() == false);
-
-    iface.reportFinished();
-}
-
-int mapper(const int &i)
-{
-    return i;
-}
-
-class ResultReadyTester : public QObject
-{
-Q_OBJECT
-public:
-    ResultReadyTester(QFutureWatcher<int> *watcher)
-    :m_watcher(watcher), filter(false), ok(true), count(0)
-    {
-        
-    }
-public slots:
-    void resultReadyAt(int index)
-    {
-        ++count;
-        if (m_watcher->future().isResultReadyAt(index) == false)
-            ok = false;
-        if (!filter && m_watcher->future().resultAt(index) != index)
-            ok = false;
-        if (filter && m_watcher->future().resultAt(index) != index * 2 + 1)
-            ok = false;
-    }
-public:
-    QFutureWatcher<int> *m_watcher;
-    bool filter;
-    bool ok;
-    int count;
-};
-
-void tst_QFutureWatcher::incrementalMapResults()
-{
-    QFutureWatcher<int> watcher;
-
-    SignalSlotObject object;
-#ifdef PRINT
-    connect(&watcher, SIGNAL(finished()), &object, SLOT(finished()));
-    connect(&watcher, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
-    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-#endif
-
-    QObject::connect(&watcher, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
-
-    ResultReadyTester resultReadyTester(&watcher);
-    connect(&watcher, SIGNAL(resultReadyAt(int)), &resultReadyTester, SLOT(resultReadyAt(int)));
-
-    const int count = 10000;
-    QList<int> ints; 
-    for (int i = 0; i < count; ++i)
-        ints << i;
-
-    QFuture<int> future = QtConcurrent::mapped(ints, mapper);
-    watcher.setFuture(future);
-
-    QTestEventLoop::instance().enterLoop(10);
-    QVERIFY(!QTestEventLoop::instance().timeout());
-    QCOMPARE(resultReadyTester.count, count);
-    QVERIFY(resultReadyTester.ok);
-    QVERIFY(watcher.isFinished());
-    future.waitForFinished(); 
-}
-
-bool filterer(int i)
-{
-    return (i % 2);
-}
-
-void tst_QFutureWatcher::incrementalFilterResults()
-{
-    QFutureWatcher<int> watcher;
-
-    SignalSlotObject object;
-#ifdef PRINT
-    connect(&watcher, SIGNAL(finished()), &object, SLOT(finished()));
-    connect(&watcher, SIGNAL(progressValueChanged(int)), &object, SLOT(progressValueChanged(int)));
-    connect(&watcher, SIGNAL(resultReadyAt(int)), &object, SLOT(resultReadyAt(int)));
-#endif
-
-    QObject::connect(&watcher, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
-
-
-    ResultReadyTester resultReadyTester(&watcher);
-    resultReadyTester.filter = true;
-    connect(&watcher, SIGNAL(resultReadyAt(int)), &resultReadyTester, SLOT(resultReadyAt(int)));
-
-    const int count = 10000;
-    QList<int> ints; 
-    for (int i = 0; i < count; ++i)
-        ints << i;
-
-    QFuture<int> future = QtConcurrent::filtered(ints, filterer);
-    watcher.setFuture(future);
-
-    QTestEventLoop::instance().enterLoop(10);
-    QVERIFY(!QTestEventLoop::instance().timeout());
-    QCOMPARE(resultReadyTester.count, count / 2);
-    QVERIFY(resultReadyTester.ok);
-    QVERIFY(watcher.isFinished());
-    future.waitForFinished(); 
-}
-
-void tst_QFutureWatcher::qfutureSynchronizer()
-{
-    int taskCount = 1000; 
-    QTime t;
-    t.start();
-
-    {
-        QFutureSynchronizer<void> sync;
-
-        sync.setCancelOnWait(true);
-        for (int i = 0; i < taskCount; ++i) {
-            sync.addFuture(run(sleeper));
-        }
-    }
-
-    // Test that we're not running each task.
-    QVERIFY(t.elapsed() < taskCount * 10);
-}
-
-class DummyObject : public QObject {
-    Q_OBJECT
-public slots:
-    void dummySlot() {}
-public:
-    static void function(QMutex *m)
-    {
-        QMutexLocker lock(m);
-    }
-};
-
-void tst_QFutureWatcher::warnRace()
-{
-#ifndef Q_OS_MAC //I don't know why it is not working on mac
-#ifndef QT_NO_DEBUG
-    QTest::ignoreMessage(QtWarningMsg, "QFutureWatcher::connect: connecting after calling setFuture() is likely to produce race");
-#endif
-#endif
-    QFutureWatcher<void> watcher;
-    DummyObject object;
-    QMutex mutex;
-    mutex.lock();
-
-    QFuture<void> future = QtConcurrent::run(DummyObject::function, &mutex);
-    watcher.setFuture(future);
-    QTRY_VERIFY(future.isStarted());
-    connect(&watcher, SIGNAL(finished()), &object, SLOT(dummySlot()));
-    mutex.unlock();
-    future.waitForFinished();
-}
-
-QTEST_MAIN(tst_QFutureWatcher)
-#include "tst_qfuturewatcher.moc"
diff --git a/tests/auto/corelib/concurrent/qtconcurrentfilter/.gitignore b/tests/auto/corelib/concurrent/qtconcurrentfilter/.gitignore
deleted file mode 100644
index f93d27e..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentfilter/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qtconcurrentfilter
diff --git a/tests/auto/corelib/concurrent/qtconcurrentfilter/qtconcurrentfilter.pro b/tests/auto/corelib/concurrent/qtconcurrentfilter/qtconcurrentfilter.pro
deleted file mode 100644
index f783455..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentfilter/qtconcurrentfilter.pro
+++ /dev/null
@@ -1,7 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qtconcurrentfilter
-QT = core testlib
-SOURCES = tst_qtconcurrentfilter.cpp
-DEFINES += QT_STRICT_ITERATORS
-
-CONFIG += insignificant_test # See QTBUG-20688
diff --git a/tests/auto/corelib/concurrent/qtconcurrentfilter/tst_qtconcurrentfilter.cpp b/tests/auto/corelib/concurrent/qtconcurrentfilter/tst_qtconcurrentfilter.cpp
deleted file mode 100644
index 971a699..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentfilter/tst_qtconcurrentfilter.cpp
+++ /dev/null
@@ -1,1543 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <qtconcurrentfilter.h>
-#include <QCoreApplication>
-#include <QList>
-#include <QLinkedList>
-#include <QtTest/QtTest>
-
-#include "../qtconcurrentmap/functions.h"
-
-class tst_QtConcurrentFilter : public QObject
-{
-    Q_OBJECT
-
-private slots:
-#ifdef QT_NO_CONCURRENT_FILTER
-    void initTestCase();
-#else
-    void filter();
-    void filtered();
-    void filteredReduced();
-    void resultAt();
-    void incrementalResults();
-    void noDetach();
-#ifndef QT_NO_STL
-    void stlContainers();
-#endif
-#endif
-};
-
-#ifdef QT_NO_CONCURRENT_FILTER
-void tst_QtConcurrentFilter::initTestCase()
-{
-    QSKIP("This test is skipped for gcc 3.x");
-}
-
-#else
-
-void tst_QtConcurrentFilter::filter()
-{
-    // functor
-    {
-        QList<int> list;
-        list << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(list, KeepEvenIntegers()).waitForFinished();
-        QCOMPARE(list, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list;
-        list << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(list, KeepEvenIntegers());
-        QCOMPARE(list, QList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(linkedList, KeepEvenIntegers()).waitForFinished();
-        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(linkedList, KeepEvenIntegers());
-        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QVector<int> vector;
-        vector << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(vector, KeepEvenIntegers()).waitForFinished();
-        QCOMPARE(vector, QVector<int>() << 2 << 4);
-    }
-    {
-        QVector<int> vector;
-        vector << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(vector, KeepEvenIntegers());
-        QCOMPARE(vector, QVector<int>() << 2 << 4);
-    }
-
-
-    // function
-    {
-        QList<int> list;
-        list << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(list, keepEvenIntegers).waitForFinished();
-        QCOMPARE(list, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list;
-        list << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(list, keepEvenIntegers);
-        QCOMPARE(list, QList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(linkedList, keepEvenIntegers).waitForFinished();
-        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(linkedList, keepEvenIntegers);
-        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
-    }
-
-    // bound function
-    {
-        QList<int> list;
-        list << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(list, keepEvenIntegers).waitForFinished();
-        QCOMPARE(list, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list;
-        list << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(list, keepEvenIntegers);
-        QCOMPARE(list, QList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(linkedList, keepEvenIntegers).waitForFinished();
-        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(linkedList, keepEvenIntegers);
-        QCOMPARE(linkedList, QLinkedList<int>() << 2 << 4);
-    }
-
-    // member
-    {
-        QList<Number> list;
-        list << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(list, &Number::isEven).waitForFinished();
-        QCOMPARE(list, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> list;
-        list << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(list, &Number::isEven);
-        QCOMPARE(list, QList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QtConcurrent::filter(linkedList, &Number::isEven).waitForFinished();
-        QCOMPARE(linkedList, QLinkedList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QtConcurrent::blockingFilter(linkedList, &Number::isEven);
-        QCOMPARE(linkedList, QLinkedList<Number>() << 2 << 4);
-    }
-}
-
-void tst_QtConcurrentFilter::filtered()
-{
-    QList<int> list;
-    list << 1 << 2 << 3 << 4;
-
-    // functor
-    {
-        QFuture<int> f = QtConcurrent::filtered(list, KeepEvenIntegers());
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(list.begin(), list.end(), KeepEvenIntegers());
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(list.constBegin(),
-                                                list.constEnd(),
-                                                KeepEvenIntegers());
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered(list, KeepEvenIntegers());
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.begin(),
-                                                                       list.end(),
-                                                                       KeepEvenIntegers());
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.constBegin(),
-                                                                       list.constEnd(),
-                                                                       KeepEvenIntegers());
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-
-    {
-        QVector<int> vector;
-        vector << 1 << 2 << 3 << 4;
-        QVector<int> vector2 = QtConcurrent::blockingFiltered(vector, KeepEvenIntegers());
-        QCOMPARE(vector2, QVector<int>() << 2 << 4);
-    }
-    {
-        QVector<int> vector;
-        vector << 1 << 2 << 3 << 4;
-        QFuture<int> f = QtConcurrent::filtered(vector, KeepEvenIntegers());
-        QCOMPARE(f.results(), QList<int>() << 2 << 4);
-    }
-
-    {
-        QLinkedList<int> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered(linkedList, KeepEvenIntegers());
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList;
-        linkedList << 1 << 2 << 3 << 4;
-        QFuture<int> f = QtConcurrent::filtered(linkedList, KeepEvenIntegers());
-        QCOMPARE(f.results(), QList<int>() << 2 << 4);
-    }
-
-    // function
-    {
-        QFuture<int> f = QtConcurrent::filtered(list, keepEvenIntegers);
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(list.begin(), list.end(), keepEvenIntegers);
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(list.constBegin(),
-                                                list.constEnd(),
-                                                keepEvenIntegers);
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered(list, keepEvenIntegers);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.begin(),
-                                                                       list.end(),
-                                                                       keepEvenIntegers);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.constBegin(),
-                                                                       list.constEnd(),
-                                                                       keepEvenIntegers);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-
-    // bound function
-    {
-        QFuture<int> f = QtConcurrent::filtered(list, keepEvenIntegers);
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(list.begin(), list.end(), keepEvenIntegers);
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(list.constBegin(),
-                                                list.constEnd(),
-                                                keepEvenIntegers);
-        QList<int> list2 = f.results();
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered(list, keepEvenIntegers);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.begin(),
-                                                                       list.end(),
-                                                                       keepEvenIntegers);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFiltered<QList<int> >(list.constBegin(),
-                                                                       list.constEnd(),
-                                                                       keepEvenIntegers);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-
-    // const member function
-    {
-        QList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QFuture<Number> f = QtConcurrent::filtered(integers, &Number::isEven);
-        QList<Number> list2 = f.results();
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QFuture<Number> f = QtConcurrent::filtered(integers.begin(),
-                                                   integers.end(),
-                                                   &Number::isEven);
-        QList<Number> list2 = f.results();
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QFuture<Number> f = QtConcurrent::filtered(integers.constBegin(),
-                                                   integers.constEnd(),
-                                                   &Number::isEven);
-        QList<Number> list2 = f.results();
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QList<Number> list2 = QtConcurrent::blockingFiltered(integers, &Number::isEven);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QList<Number> list2 = QtConcurrent::blockingFiltered<QList<Number> >(integers.begin(),
-                                                                             integers.end(),
-                                                                             &Number::isEven);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QList<Number> list2 =
-            QtConcurrent::blockingFiltered<QList<Number> >(integers.constBegin(),
-                                                           integers.constEnd(),
-                                                           &Number::isEven);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-
-    // same thing on linked lists
-
-    QLinkedList<int> linkedList;
-    linkedList << 1 << 2 << 3 << 4;
-
-    // functor
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList, KeepEvenIntegers());
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList.begin(),
-                                                linkedList.end(),
-                                                KeepEvenIntegers());
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList.constBegin(),
-                                                linkedList.constEnd(),
-                                                KeepEvenIntegers());
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered(linkedList, KeepEvenIntegers());
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.begin(),
-                                                                                         linkedList.end(),
-                                                                                         KeepEvenIntegers());
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.constBegin(),
-                                                                                         linkedList.constEnd(),
-                                                                                         KeepEvenIntegers());
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-
-    // function
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList, keepEvenIntegers);
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList.begin(),
-                                                linkedList.end(),
-                                                keepEvenIntegers);
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList.constBegin(),
-                                                linkedList.constEnd(),
-                                                keepEvenIntegers);
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered(linkedList, keepEvenIntegers);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.begin(),
-                                                                                         linkedList.end(),
-                                                                                         keepEvenIntegers);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.constBegin(),
-                                                                                         linkedList.constEnd(),
-                                                                                         keepEvenIntegers);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-
-    // bound function
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList, keepEvenIntegers);
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList.begin(),
-                                                linkedList.end(),
-                                                keepEvenIntegers);
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QFuture<int> f = QtConcurrent::filtered(linkedList.constBegin(),
-                                                linkedList.constEnd(),
-                                                keepEvenIntegers);
-        QList<int> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered(linkedList, keepEvenIntegers);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.begin(),
-                                                                                         linkedList.end(),
-                                                                                         keepEvenIntegers);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<int> >(linkedList.constBegin(),
-                                                                                         linkedList.constEnd(),
-                                                                                         keepEvenIntegers);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-
-    // const member function
-    {
-        QLinkedList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QFuture<Number> f = QtConcurrent::filtered(integers, &Number::isEven);
-        QList<Number> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QFuture<Number> f = QtConcurrent::filtered(integers.begin(),
-                                                   integers.end(),
-                                                   &Number::isEven);
-        QList<Number> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QFuture<Number> f = QtConcurrent::filtered(integers.constBegin(),
-                                                   integers.constEnd(),
-                                                   &Number::isEven);
-        QList<Number> linkedList2 = f.results();
-        QCOMPARE(linkedList2, QList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFiltered(integers, &Number::isEven);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFiltered<QLinkedList<Number> >(integers.begin(),
-                                                                                               integers.end(),
-                                                                                               &Number::isEven);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> integers;
-        integers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 =
-            QtConcurrent::blockingFiltered<QLinkedList<Number> >(integers.constBegin(),
-                                                                 integers.constEnd(),
-                                                                 &Number::isEven);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-}
-
-void tst_QtConcurrentFilter::filteredReduced()
-{
-    QList<int> list;
-    list << 1 << 2 << 3 << 4;
-    QList<Number> numberList;
-    numberList << 1 << 2 << 3 << 4;
-
-    // functor-functor
-    {
-        int sum = QtConcurrent::filteredReduced<int>(list, KeepEvenIntegers(), IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced<int>(list, keepEvenIntegers, intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        QVector<int> vector;
-        vector << 1 << 2 << 3 << 4;
-        int sum = QtConcurrent::filteredReduced<int>(vector, KeepEvenIntegers(), IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-
-    {
-        int sum = QtConcurrent::filteredReduced<int>(list.begin(),
-                                                     list.end(),
-                                                     KeepEvenIntegers(),
-                                                     IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced<int>(list.begin(),
-                                                      list.end(),
-                                                      keepEvenIntegers,
-                                                      intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(list.constBegin(),
-                                                     list.constEnd(),
-                                                     KeepEvenIntegers(),
-                                                     IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced<int>(list.constBegin(),
-                                                      list.constEnd(),
-                                                      keepEvenIntegers,
-                                                      intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(list, KeepEvenIntegers(), IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced<int>(list, keepEvenIntegers, intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(list.begin(),
-                                                             list.end(),
-                                                             KeepEvenIntegers(),
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced<int>(list.begin(),
-                                                              list.end(),
-                                                              keepEvenIntegers,
-                                                              intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(list.constBegin(),
-                                                             list.constEnd(),
-                                                             KeepEvenIntegers(),
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced<int>(list.constBegin(),
-                                                              list.constEnd(),
-                                                              keepEvenIntegers,
-                                                              intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-
-    // function-functor
-    {
-        int sum = QtConcurrent::filteredReduced<int>(list, keepEvenIntegers, IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(list.begin(),
-                                                     list.end(),
-                                                     keepEvenIntegers,
-                                                     IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(list.constBegin(),
-                                                     list.constEnd(),
-                                                     keepEvenIntegers,
-                                                     IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(list, keepEvenIntegers, IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(list.begin(),
-                                                             list.end(),
-                                                             keepEvenIntegers,
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(list.constBegin(),
-                                                             list.constEnd(),
-                                                             keepEvenIntegers,
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-
-    // functor-function
-    {
-        int sum = QtConcurrent::filteredReduced(list, KeepEvenIntegers(), intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(list.begin(),
-                                                list.end(),
-                                                KeepEvenIntegers(),
-                                                intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(list.constBegin(),
-                                                list.constEnd(),
-                                                KeepEvenIntegers(),
-                                                intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(list, KeepEvenIntegers(), intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(list.begin(),
-                                                        list.end(),
-                                                        KeepEvenIntegers(),
-                                                        intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(list.constBegin(),
-                                                        list.constEnd(),
-                                                        KeepEvenIntegers(),
-                                                        intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-
-    // function-function
-    {
-        int sum = QtConcurrent::filteredReduced(list, keepEvenIntegers, intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(list.begin(),
-                                                list.end(),
-                                                keepEvenIntegers,
-                                                intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(list.constBegin(),
-                                                list.constEnd(),
-                                                keepEvenIntegers,
-                                                intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(list, keepEvenIntegers, intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(list.begin(),
-                                                        list.end(),
-                                                        keepEvenIntegers,
-                                                        intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(list.constBegin(),
-                                                        list.constEnd(),
-                                                        keepEvenIntegers,
-                                                        intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-
-    // functor-member
-    {
-        QList<int> list2 = QtConcurrent::filteredReduced(list, KeepEvenIntegers(), &QList<int>::push_back, QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::filteredReduced(list.begin(),
-                                                         list.end(),
-                                                         KeepEvenIntegers(),
-                                                         &QList<int>::push_back,
-                                                         QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::filteredReduced(list.constBegin(),
-                                                         list.constEnd(),
-                                                         KeepEvenIntegers(),
-                                                         &QList<int>::push_back,
-                                                         QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list, KeepEvenIntegers(), &QList<int>::push_back, QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list.begin(),
-                                                                 list.end(),
-                                                                 KeepEvenIntegers(),
-                                                                 &QList<int>::push_back,
-                                                                 QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list.constBegin(),
-                                                                 list.constEnd(),
-                                                                 KeepEvenIntegers(),
-                                                                 &QList<int>::push_back,
-                                                                 QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-
-    // member-functor
-    {
-        int sum = QtConcurrent::filteredReduced<int>(numberList, &Number::isEven, NumberSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced<int>(QList<Number>(numberList),
-                                                      &Number::isEven,
-                                                      NumberSumReduce());
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(numberList.begin(),
-                                                     numberList.end(),
-                                                     &Number::isEven,
-                                                     NumberSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(numberList.constBegin(),
-                                                     numberList.constEnd(),
-                                                     &Number::isEven,
-                                                     NumberSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(numberList, &Number::isEven, NumberSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced<int>(QList<Number>(numberList),
-                                                              &Number::isEven,
-                                                              NumberSumReduce());
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(numberList.begin(),
-                                                             numberList.end(),
-                                                             &Number::isEven,
-                                                             NumberSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(numberList.constBegin(),
-                                                             numberList.constEnd(),
-                                                             &Number::isEven,
-                                                             NumberSumReduce());
-        QCOMPARE(sum, 6);
-    }
-
-    // member-member
-    {
-        QList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QList<Number> list2 = QtConcurrent::filteredReduced(numbers,
-                                                            &Number::isEven,
-                                                            &QList<Number>::push_back, QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QList<Number> list2 = QtConcurrent::filteredReduced(numbers.begin(),
-                                                            numbers.end(),
-                                                            &Number::isEven,
-                                                            &QList<Number>::push_back,
-                                                            QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QList<Number> list2 = QtConcurrent::filteredReduced(numbers.constBegin(),
-                                                            numbers.constEnd(),
-                                                            &Number::isEven,
-                                                            &QList<Number>::push_back,
-                                                            QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QList<Number> list2 = QtConcurrent::blockingFilteredReduced(numbers,
-                                                                    &Number::isEven,
-                                                                    &QList<Number>::push_back, QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QList<Number> list2 = QtConcurrent::blockingFilteredReduced(numbers.begin(),
-                                                                    numbers.end(),
-                                                                    &Number::isEven,
-                                                                    &QList<Number>::push_back,
-                                                                    QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-    {
-        QList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QList<Number> list2 = QtConcurrent::blockingFilteredReduced(numbers.constBegin(),
-                                                                    numbers.constEnd(),
-                                                                    &Number::isEven,
-                                                                    &QList<Number>::push_back,
-                                                                    QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<Number>() << 2 << 4);
-    }
-
-    // function-member
-    {
-        QList<int> list2 = QtConcurrent::filteredReduced(list, keepEvenIntegers, &QList<int>::push_back, QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::filteredReduced(list.begin(),
-                                                         list.end(),
-                                                         keepEvenIntegers,
-                                                         &QList<int>::push_back,
-                                                         QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::filteredReduced(list.constBegin(),
-                                                         list.constEnd(),
-                                                         keepEvenIntegers,
-                                                         &QList<int>::push_back,
-                                                         QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list, keepEvenIntegers, &QList<int>::push_back, QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list.begin(),
-                                                                 list.end(),
-                                                                 keepEvenIntegers,
-                                                                 &QList<int>::push_back,
-                                                                 QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-    {
-        QList<int> list2 = QtConcurrent::blockingFilteredReduced(list.constBegin(),
-                                                                 list.constEnd(),
-                                                                 keepEvenIntegers,
-                                                                 &QList<int>::push_back,
-                                                                 QtConcurrent::OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 2 << 4);
-    }
-
-    // member-function
-    {
-        int sum = QtConcurrent::filteredReduced(numberList, &Number::isEven, numberSumReduce);
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced(QList<Number>(numberList),
-                                                 &Number::isEven,
-                                                 numberSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(numberList.begin(),
-                                                numberList.end(),
-                                                &Number::isEven,
-                                                numberSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(numberList.constBegin(),
-                                                numberList.constEnd(),
-                                                &Number::isEven,
-                                                numberSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(numberList, &Number::isEven, numberSumReduce);
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced(QList<Number>(numberList),
-                                                         &Number::isEven,
-                                                         numberSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(numberList.begin(),
-                                                        numberList.end(),
-                                                        &Number::isEven,
-                                                        numberSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(numberList.constBegin(),
-                                                        numberList.constEnd(),
-                                                        &Number::isEven,
-                                                        numberSumReduce);
-        QCOMPARE(sum, 6);
-    }
-
-    // same as above on linked lists
-    QLinkedList<int> linkedList;
-    linkedList << 1 << 2 << 3 << 4;
-    QLinkedList<Number> numberLinkedList;
-    numberLinkedList << 1 << 2 << 3 << 4;
-
-    // functor-functor
-    {
-        int sum = QtConcurrent::filteredReduced<int>(linkedList, KeepEvenIntegers(), IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced<int>(linkedList, keepEvenIntegers, intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(linkedList.begin(),
-                                                     linkedList.end(),
-                                                     KeepEvenIntegers(),
-                                                     IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced<int>(linkedList.begin(),
-                                                      linkedList.end(),
-                                                      keepEvenIntegers,
-                                                      intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(linkedList.constBegin(),
-                                                     linkedList.constEnd(),
-                                                     KeepEvenIntegers(),
-                                                     IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced<int>(linkedList.constBegin(),
-                                                      linkedList.constEnd(),
-                                                      keepEvenIntegers,
-                                                      intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList, KeepEvenIntegers(), IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced<int>(linkedList, keepEvenIntegers, intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList.begin(),
-                                                             linkedList.end(),
-                                                             KeepEvenIntegers(),
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced<int>(linkedList.begin(),
-                                                              linkedList.end(),
-                                                              keepEvenIntegers,
-                                                              intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList.constBegin(),
-                                                             linkedList.constEnd(),
-                                                             KeepEvenIntegers(),
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced<int>(linkedList.constBegin(),
-                                                              linkedList.constEnd(),
-                                                              keepEvenIntegers,
-                                                              intSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-
-    // function-functor
-    {
-        int sum = QtConcurrent::filteredReduced<int>(linkedList, keepEvenIntegers, IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(linkedList.begin(),
-                                                     linkedList.end(),
-                                                     keepEvenIntegers,
-                                                     IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(linkedList.constBegin(),
-                                                     linkedList.constEnd(),
-                                                     keepEvenIntegers,
-                                                     IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList, keepEvenIntegers, IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList.begin(),
-                                                             linkedList.end(),
-                                                             keepEvenIntegers,
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(linkedList.constBegin(),
-                                                             linkedList.constEnd(),
-                                                             keepEvenIntegers,
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-    }
-
-    // functor-function
-    {
-        int sum = QtConcurrent::filteredReduced(linkedList, KeepEvenIntegers(), intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(linkedList.begin(),
-                                                linkedList.end(),
-                                                KeepEvenIntegers(),
-                                                intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(linkedList.constBegin(),
-                                                linkedList.constEnd(),
-                                                KeepEvenIntegers(),
-                                                intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(linkedList, KeepEvenIntegers(), intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(linkedList.begin(),
-                                                        linkedList.end(),
-                                                        KeepEvenIntegers(),
-                                                        intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(linkedList.constBegin(),
-                                                        linkedList.constEnd(),
-                                                        KeepEvenIntegers(),
-                                                        intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-
-    // function-function
-    {
-        int sum = QtConcurrent::filteredReduced(linkedList, keepEvenIntegers, intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(linkedList.begin(),
-                                                linkedList.end(),
-                                                keepEvenIntegers,
-                                                intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(linkedList.constBegin(),
-                                                linkedList.constEnd(),
-                                                keepEvenIntegers,
-                                                intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(linkedList, keepEvenIntegers, intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(linkedList.begin(),
-                                                        linkedList.end(),
-                                                        keepEvenIntegers,
-                                                        intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(linkedList.constBegin(),
-                                                        linkedList.constEnd(),
-                                                        keepEvenIntegers,
-                                                        intSumReduce);
-        QCOMPARE(sum, 6);
-    }
-
-    // functor-member
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList, KeepEvenIntegers(), &QLinkedList<int>::append, QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList.begin(),
-                                                                     linkedList.end(),
-                                                                     KeepEvenIntegers(),
-                                                                     &QLinkedList<int>::append,
-                                                                     QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList.constBegin(),
-                                                                     linkedList.constEnd(),
-                                                                     KeepEvenIntegers(),
-                                                                     &QLinkedList<int>::append,
-                                                                     QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList, KeepEvenIntegers(), &QLinkedList<int>::append, QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList.begin(),
-                                                                             linkedList.end(),
-                                                                             KeepEvenIntegers(),
-                                                                             &QLinkedList<int>::append,
-                                                                             QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList.constBegin(),
-                                                                             linkedList.constEnd(),
-                                                                             KeepEvenIntegers(),
-                                                                             &QLinkedList<int>::append,
-                                                                             QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-
-    // member-functor
-    {
-        int sum = QtConcurrent::filteredReduced<int>(numberLinkedList, &Number::isEven, NumberSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced<int>(QLinkedList<Number>(numberLinkedList),
-                                                      &Number::isEven,
-                                                      NumberSumReduce());
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(numberLinkedList.begin(),
-                                                     numberLinkedList.end(),
-                                                     &Number::isEven,
-                                                     NumberSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced<int>(numberLinkedList.constBegin(),
-                                                     numberLinkedList.constEnd(),
-                                                     &Number::isEven,
-                                                     NumberSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(numberLinkedList, &Number::isEven, NumberSumReduce());
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced<int>(QLinkedList<Number>(numberLinkedList),
-                                                              &Number::isEven,
-                                                              NumberSumReduce());
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(numberLinkedList.begin(),
-                                                             numberLinkedList.end(),
-                                                             &Number::isEven,
-                                                             NumberSumReduce());
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced<int>(numberLinkedList.constBegin(),
-                                                             numberLinkedList.constEnd(),
-                                                             &Number::isEven,
-                                                             NumberSumReduce());
-        QCOMPARE(sum, 6);
-    }
-
-    // member-member
-    {
-        QLinkedList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 = QtConcurrent::filteredReduced(numbers,
-                                                                        &Number::isEven,
-                                                                        &QLinkedList<Number>::append, QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 = QtConcurrent::filteredReduced(numbers.begin(),
-                                                                        numbers.end(),
-                                                                        &Number::isEven,
-                                                                        &QLinkedList<Number>::append,
-                                                                        QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 = QtConcurrent::filteredReduced(numbers.constBegin(),
-                                                                        numbers.constEnd(),
-                                                                        &Number::isEven,
-                                                                        &QLinkedList<Number>::append,
-                                                                        QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFilteredReduced(numbers,
-                                                                                &Number::isEven,
-                                                                                &QLinkedList<Number>::append, QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFilteredReduced(numbers.begin(),
-                                                                                numbers.end(),
-                                                                                &Number::isEven,
-                                                                                &QLinkedList<Number>::append,
-                                                                                QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-    {
-        QLinkedList<Number> numbers;
-        numbers << 1 << 2 << 3 << 4;
-        QLinkedList<Number> linkedList2 = QtConcurrent::blockingFilteredReduced(numbers.constBegin(),
-                                                                                numbers.constEnd(),
-                                                                                &Number::isEven,
-                                                                                &QLinkedList<Number>::append,
-                                                                                QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<Number>() << 2 << 4);
-    }
-
-    // function-member
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList, keepEvenIntegers, &QLinkedList<int>::append, QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList.begin(),
-                                                                     linkedList.end(),
-                                                                     keepEvenIntegers,
-                                                                     &QLinkedList<int>::append,
-                                                                     QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::filteredReduced(linkedList.constBegin(),
-                                                                     linkedList.constEnd(),
-                                                                     keepEvenIntegers,
-                                                                     &QLinkedList<int>::append,
-                                                                     QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList, keepEvenIntegers, &QLinkedList<int>::append, QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList.begin(),
-                                                                             linkedList.end(),
-                                                                             keepEvenIntegers,
-                                                                             &QLinkedList<int>::append,
-                                                                             QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingFilteredReduced(linkedList.constBegin(),
-                                                                             linkedList.constEnd(),
-                                                                             keepEvenIntegers,
-                                                                             &QLinkedList<int>::append,
-                                                                             QtConcurrent::OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4);
-    }
-
-    // member-function
-    {
-        int sum = QtConcurrent::filteredReduced(numberLinkedList, &Number::isEven, numberSumReduce);
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::filteredReduced(QLinkedList<Number>(numberLinkedList),
-                                                 &Number::isEven,
-                                                 numberSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(numberLinkedList.begin(),
-                                                numberLinkedList.end(),
-                                                &Number::isEven,
-                                                numberSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::filteredReduced(numberLinkedList.constBegin(),
-                                                numberLinkedList.constEnd(),
-                                                &Number::isEven,
-                                                numberSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(numberLinkedList, &Number::isEven, numberSumReduce);
-        QCOMPARE(sum, 6);
-
-        int sum2 = QtConcurrent::blockingFilteredReduced(QLinkedList<Number>(numberLinkedList),
-                                                         &Number::isEven,
-                                                         numberSumReduce);
-        QCOMPARE(sum2, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(numberLinkedList.begin(),
-                                                        numberLinkedList.end(),
-                                                        &Number::isEven,
-                                                        numberSumReduce);
-        QCOMPARE(sum, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingFilteredReduced(numberLinkedList.constBegin(),
-                                                        numberLinkedList.constEnd(),
-                                                        &Number::isEven,
-                                                        numberSumReduce);
-        QCOMPARE(sum, 6);
-    }
-
-    // ### the same as above, with an initial result value
-}
-
-bool filterfn(int i)  
-{ 
-    return (i % 2);
-} 
-
-void tst_QtConcurrentFilter::resultAt()
-{
-
-    QList<int> ints; 
-    for (int i=0; i < 1000; ++i)
-        ints << i;
-
-    QFuture<int> future = QtConcurrent::filtered(ints, filterfn);
-    future.waitForFinished(); 
-
-    
-    for (int i = 0; i < future.resultCount(); ++i) {
-        QCOMPARE(future.resultAt(i), ints.at(i * 2 + 1));
-    }
-
-}
-
-bool waitFilterfn(const int &i)  
-{ 
-    QTest::qWait(1);
-    return (i % 2);
-} 
-
-void tst_QtConcurrentFilter::incrementalResults()
-{
-    const int count = 200;
-    QList<int> ints; 
-    for (int i=0; i < count; ++i)
-        ints << i;
-
-    QFuture<int> future = QtConcurrent::filtered(ints, waitFilterfn);
-    
-    QList<int> results;
-
-    while (future.isFinished() == false) {
-        for (int i = 0; i < future.resultCount(); ++i) {
-            results += future.resultAt(i);
-        }
-        QTest::qWait(1);
-    }
-
-    QCOMPARE(future.isFinished(), true);
-    QCOMPARE(future.resultCount(), count / 2);
-    QCOMPARE(future.results().count(), count / 2);
-}
-
-void tst_QtConcurrentFilter::noDetach()
-{
-    {
-        QList<int> l = QList<int>() << 1;
-        QVERIFY(l.isDetached());
-
-        QList<int> ll = l;
-        QVERIFY(l.isDetached() == false);
-
-        QtConcurrent::filtered(l, waitFilterfn).waitForFinished();
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-
-        QtConcurrent::blockingFiltered(l, waitFilterfn);
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-
-        QtConcurrent::filteredReduced(l, waitFilterfn, intSumReduce).waitForFinished();
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-
-        QtConcurrent::filter(l, waitFilterfn).waitForFinished();
-        QVERIFY(l.isDetached() == true);
-        QVERIFY(ll.isDetached() == true);
-    }
-    {
-        const QList<int> l = QList<int>() << 1;
-        QVERIFY(l.isDetached());
-
-        const QList<int> ll = l;
-        QVERIFY(l.isDetached() == false);
-
-        QtConcurrent::filtered(l, waitFilterfn).waitForFinished();
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-
-        QtConcurrent::filteredReduced(l, waitFilterfn, intSumReduce).waitForFinished();
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-    }
-}
-
-#ifndef QT_NO_STL
-void tst_QtConcurrentFilter::stlContainers()
-{
-    std::vector<int> vector;
-    vector.push_back(1);
-    vector.push_back(2);
-
-    std::vector<int> vector2 =  QtConcurrent::blockingFiltered(vector, waitFilterfn);
-    QCOMPARE(vector2.size(), (std::vector<int>::size_type)(1));
-    QCOMPARE(vector2[0], 1);
-
-    std::list<int> list;
-    list.push_back(1);
-    list.push_back(2);
-
-    std::list<int> list2 =  QtConcurrent::blockingFiltered(list, waitFilterfn);
-    QCOMPARE(list2.size(), (std::list<int>::size_type)(1));
-    QCOMPARE(*list2.begin(), 1);
-
-    QtConcurrent::filtered(list, waitFilterfn).waitForFinished();
-    QtConcurrent::filtered(vector, waitFilterfn).waitForFinished();
-    QtConcurrent::filtered(vector.begin(), vector.end(), waitFilterfn).waitForFinished();
-
-    QtConcurrent::blockingFilter(list, waitFilterfn);
-    QCOMPARE(list2.size(), (std::list<int>::size_type)(1));
-    QCOMPARE(*list2.begin(), 1);
-}
-#endif
-
-#endif
-
-QTEST_MAIN(tst_QtConcurrentFilter)
-#include "tst_qtconcurrentfilter.moc"
diff --git a/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/.gitignore b/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/.gitignore
deleted file mode 100644
index ac5dec4..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qtconcurrentiteratekernel
diff --git a/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/qtconcurrentiteratekernel.pro b/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/qtconcurrentiteratekernel.pro
deleted file mode 100644
index e876c86..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/qtconcurrentiteratekernel.pro
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qtconcurrentiteratekernel
-QT = core testlib
-SOURCES = tst_qtconcurrentiteratekernel.cpp
diff --git a/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/tst_qtconcurrentiteratekernel.cpp b/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/tst_qtconcurrentiteratekernel.cpp
deleted file mode 100644
index 46562b5..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentiteratekernel/tst_qtconcurrentiteratekernel.cpp
+++ /dev/null
@@ -1,310 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <QThread>
-
-struct TestIterator
-{
-    TestIterator(int i)
-    :i(i) { }
-
-    int operator-(const TestIterator &other)
-    {
-        return i - other.i;
-    }
-
-    TestIterator& operator++()
-    {
-        ++i;
-        return *this;
-    }
-
-    bool operator!=(const TestIterator &other) const
-    {
-        return i != other.i;
-    }
-
-    int i;
-};
-
-#include <qiterator.h>
-#ifndef QT_NO_STL
-namespace std {
-template <>
-struct iterator_traits<TestIterator>
-{
-    typedef random_access_iterator_tag iterator_category;
-};
-
-int distance(TestIterator &a, TestIterator &b)
-{
-    return b - a;
-}
-
-}
-#endif
-
-#include <qtconcurrentiteratekernel.h>
-#include <QtTest/QtTest>
-
-using namespace QtConcurrent;
-
-class tst_QtConcurrentIterateKernel: public QObject
-{
-    Q_OBJECT
-private slots:
-    // "for" iteration tests:
-    void instantiate();
-    void cancel();
-    void stresstest();
-    void noIterations();
-    void throttling();
-#ifndef QT_NO_STL
-    void blockSize();
-    void multipleResults();
-#endif
-};
-
-QAtomicInt iterations;
-class PrintFor : public IterateKernel<TestIterator, void>
-{
-public:
-    PrintFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { iterations.store(0); }
-    bool runIterations(TestIterator/*beginIterator*/, int begin, int end, void *)
-    {
-        iterations.fetchAndAddRelaxed(end - begin);
-#ifdef PRINT
-        qDebug() << QThread::currentThread() << "iteration" << begin <<  "to" << end << "(exclusive)";
-#endif
-        return false;
-    }
-    bool runIteration(TestIterator it, int index , void *result)
-    { 
-        return runIterations(it, index, index + 1, result);
-    }
-
-};
-
-class SleepPrintFor : public IterateKernel<TestIterator, void>
-{
-public:
-    SleepPrintFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { iterations.store(0); }
-    inline bool runIterations(TestIterator/*beginIterator*/, int begin, int end, void *)
-    {
-        QTest::qSleep(200);
-        iterations.fetchAndAddRelaxed(end - begin);
-#ifdef PRINT
-        qDebug() << QThread::currentThread() << "iteration" << begin <<  "to" << end << "(exclusive)";
-#endif
-        return false;
-    }
-    bool runIteration(TestIterator it, int index , void *result)
-    { 
-        return runIterations(it, index, index + 1, result);
-    }
-};
-
-
-void tst_QtConcurrentIterateKernel::instantiate()
-{
-    startThreadEngine(new PrintFor(0, 40)).startBlocking();
-    QCOMPARE(iterations.load(), 40);
-}
-
-void tst_QtConcurrentIterateKernel::cancel()
-{
-    {
-        QFuture<void> f = startThreadEngine(new SleepPrintFor(0, 40)).startAsynchronously();
-        f.cancel();
-        f.waitForFinished();
-        QVERIFY(f.isCanceled());
-        QVERIFY(iterations.load() <= QThread::idealThreadCount()); // the threads might run one iteration each before they are canceled.
-    }
-}
-
-QAtomicInt counter;
-class CountFor : public IterateKernel<TestIterator, void>
-{
-public:
-    CountFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { iterations.store(0); }
-    inline bool runIterations(TestIterator/*beginIterator*/, int begin, int end, void *)
-    {
-        counter.fetchAndAddRelaxed(end - begin);
-        return false;
-    }
-    bool runIteration(TestIterator it, int index , void *result)
-    { 
-        return runIterations(it, index, index + 1, result);
-    }
-};
-
-void tst_QtConcurrentIterateKernel::stresstest()
-{
-    const int iterations = 1000;
-    const int times = 50;
-    for (int i = 0; i < times; ++i) {
-        counter.store(0);
-        CountFor f(0, iterations);
-        f.startBlocking();
-        QCOMPARE(counter.load(), iterations);
-    }
-}
-
-void tst_QtConcurrentIterateKernel::noIterations()
-{
-    const int times = 20000;
-    for (int i = 0; i < times; ++i)
-        startThreadEngine(new IterateKernel<TestIterator, void>(0, 0)).startBlocking();
-}
-
-QMutex threadsMutex;
-QSet<QThread *> threads;
-class ThrottleFor : public IterateKernel<TestIterator, void>
-{
-public:
-    // this class throttles between iterations 100 and 200,
-    // and then records how many threads that run between
-    // iterations 140 and 160.
-    ThrottleFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { iterations.store(0); throttling = false; }
-    inline bool runIterations(TestIterator/*beginIterator*/, int begin, int end, void *)
-    {
-        if (200 >= begin && 200 < end) {
-            throttling = false;
-        }
-
-        iterations.fetchAndAddRelaxed(end - begin);
-
-        QThread *thread = QThread::currentThread();
-
-        if (begin > 140 && end < 160) {
-            QMutexLocker locker(&threadsMutex);
-            threads.insert(thread);
-        }
-
-        if (100 >= begin && 100 < end) {
-            throttling = true;
-        }
-        
-        QTest::qWait(1);
-
-        return false;
-    }
-    bool runIteration(TestIterator it, int index , void *result)
-    { 
-        return runIterations(it, index, index + 1, result);
-    }
-
-    bool shouldThrottleThread()
-    {
-       const int load = iterations.load();
-       return (load > 100 && load < 200);
-    }
-    bool throttling;
-};
-
-void tst_QtConcurrentIterateKernel::throttling()
-{
-    const int totalIterations = 400;
-    iterations.store(0);
-
-    threads.clear();
-
-    ThrottleFor f(0, totalIterations);
-    f.startBlocking();
-
-    QCOMPARE(iterations.load(), totalIterations);
-
-
-    QCOMPARE(threads.count(), 1);
-}
-
-
-int peakBlockSize = 0;
-class BlockSizeRecorder : public IterateKernel<TestIterator, void>
-{
-public:
-    BlockSizeRecorder(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, void>(begin, end) { }
-    inline bool runIterations(TestIterator, int begin, int end, void *)
-    {
-        peakBlockSize = qMax(peakBlockSize, end - begin);
-        return false;
-    }
-};
-
-// Missing stl iterators prevent correct block size calculation.
-#ifndef QT_NO_STL
-void tst_QtConcurrentIterateKernel::blockSize()
-{
-    const int expectedMinimumBlockSize = 1024 / QThread::idealThreadCount();
-    BlockSizeRecorder(0, 10000).startBlocking();
-    if (peakBlockSize < expectedMinimumBlockSize)
-        qDebug() << "block size" << peakBlockSize;
-    QVERIFY(peakBlockSize >= expectedMinimumBlockSize);
-}
-#endif
-
-class MultipleResultsFor : public IterateKernel<TestIterator, int>
-{
-public:
-    MultipleResultsFor(TestIterator begin, TestIterator end) : IterateKernel<TestIterator, int>(begin, end) { }
-    inline bool runIterations(TestIterator, int begin, int end, int *results)
-    {
-        for (int i = begin; i < end; ++i)
-            results[i - begin] = i;
-        return true;
-    }
-};
-
-// Missing stl iterators prevent correct summation.
-#ifndef QT_NO_STL
-void tst_QtConcurrentIterateKernel::multipleResults()
-{
-    QFuture<int> f = startThreadEngine(new MultipleResultsFor(0, 10)).startAsynchronously();
-    QCOMPARE(f.results().count() , 10);
-    QCOMPARE(f.resultAt(0), 0);
-    QCOMPARE(f.resultAt(5), 5);
-    QCOMPARE(f.resultAt(9), 9);
-    f.waitForFinished();
-}
-#endif
-
-QTEST_MAIN(tst_QtConcurrentIterateKernel)
-
-#include "tst_qtconcurrentiteratekernel.moc"
diff --git a/tests/auto/corelib/concurrent/qtconcurrentmap/.gitignore b/tests/auto/corelib/concurrent/qtconcurrentmap/.gitignore
deleted file mode 100644
index f1c563e..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentmap/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qtconcurrentmap
diff --git a/tests/auto/corelib/concurrent/qtconcurrentmap/functions.h b/tests/auto/corelib/concurrent/qtconcurrentmap/functions.h
deleted file mode 100644
index f5963db..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentmap/functions.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#ifndef FUNCTIONS_H
-#define FUNCTIONS_H
-
-bool keepEvenIntegers(const int &x)
-{
-    return (x & 1) == 0;
-}
-
-class KeepEvenIntegers
-{
-public:
-    bool operator()(const int &x)
-    {
-        return (x & 1) == 0;
-    }
-};
-
-class Number
-{
-    int n;
-
-public:
-    Number()
-        : n(0)
-    { }
-
-    Number(int n)
-        : n(n)
-    { }
-
-    void multiplyBy2()
-    {
-        n *= 2;
-    }
-
-    Number multipliedBy2() const
-    {
-        return n * 2;
-    }
-
-    bool isEven() const
-    {
-        return (n & 1) == 0;
-    }
-
-    int toInt() const
-    {
-        return n;
-    }
-
-    QString toString() const
-    {
-        return QString::number(n);
-    }
-
-    bool operator==(const Number &other) const
-    {
-        return n == other.n;
-    }
-};
-
-void intSumReduce(int &sum, int x)
-{
-    sum += x;
-}
-
-class IntSumReduce
-{
-public:
-    void operator()(int &sum, int x)
-    {
-        sum += x;
-    }
-};
-
-void numberSumReduce(int &sum, const Number &x)
-{
-    sum += x.toInt();
-}
-
-class NumberSumReduce
-{
-public:
-    void operator()(int &sum, const Number &x)
-    {
-        sum += x.toInt();
-    }
-};
-
-#endif
diff --git a/tests/auto/corelib/concurrent/qtconcurrentmap/qtconcurrentmap.pro b/tests/auto/corelib/concurrent/qtconcurrentmap/qtconcurrentmap.pro
deleted file mode 100644
index b4f5cbc..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentmap/qtconcurrentmap.pro
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qtconcurrentmap
-QT = core testlib
-SOURCES = tst_qtconcurrentmap.cpp
-DEFINES += QT_STRICT_ITERATORS
diff --git a/tests/auto/corelib/concurrent/qtconcurrentmap/tst_qtconcurrentmap.cpp b/tests/auto/corelib/concurrent/qtconcurrentmap/tst_qtconcurrentmap.cpp
deleted file mode 100644
index 960511d..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentmap/tst_qtconcurrentmap.cpp
+++ /dev/null
@@ -1,2426 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <qtconcurrentmap.h>
-#include <qtconcurrentexception.h>
-
-#include <qdebug.h>
-#include <QThread>
-
-#include <QtTest/QtTest>
-
-#include "functions.h"
-
-Q_DECLARE_METATYPE(QVector<int>);
-Q_DECLARE_METATYPE(QVector<double>);
-Q_DECLARE_METATYPE(QVector<QString>);
-Q_DECLARE_METATYPE(QList<int>);
-Q_DECLARE_METATYPE(QList<double>);
-Q_DECLARE_METATYPE(QList<QString>);
-
-class tst_QtConcurrentMap: public QObject
-{
-    Q_OBJECT
-private slots:
-#ifdef QT_NO_CONCURRENT_MAP
-    void initTestCase()
-#else
-    void map();
-    void blocking_map();
-    void mapped();
-    void blocking_mapped();
-    void mappedReduced();
-    void blocking_mappedReduced();
-    void assignResult();
-    void functionOverloads();
-#ifndef QT_NO_EXCEPTIONS
-    void exceptions();
-#endif
-    void incrementalResults();
-    void noDetach();
-#ifndef QT_NO_STL
-    void stlContainers();
-#endif
-    void qFutureAssignmentLeak();
-    void stressTest();
-public slots:
-    void throttling();
-#endif
-};
-
-#ifdef QT_NO_CONCURRENT_FILTER
-void tst_QtConcurrentFilter::initTestCase()
-{
-    QSKIP("This test is skipped for gcc 3.x");
-}
-
-#else
-
-using namespace QtConcurrent;
-
-void multiplyBy2Immutable(int x)
-{
-    x *= 2;
-}
-
-class MultiplyBy2Immutable
-{
-public:
-    void operator()(int x)
-    {
-        x *= 2;
-    }
-};
-
-void multiplyBy2InPlace(int &x)
-{
-    x *= 2;
-}
-
-class MultiplyBy2InPlace
-{
-public:
-    void operator()(int &x)
-    {
-        x *= 2;
-    }
-};
-
-Q_DECLARE_METATYPE(QList<Number>);
-
-void tst_QtConcurrentMap::map()
-{
-    // functors take arguments by reference, modifying the sequence in place
-    {
-        QList<int> list;
-        list << 1 << 2 << 3;
-
-        // functor
-        QtConcurrent::map(list, MultiplyBy2InPlace()).waitForFinished();
-        QCOMPARE(list, QList<int>() << 2 << 4 << 6);
-        QtConcurrent::map(list.begin(), list.end(), MultiplyBy2InPlace()).waitForFinished();
-        QCOMPARE(list, QList<int>() << 4 << 8 << 12);
-
-        // function
-        QtConcurrent::map(list, multiplyBy2InPlace).waitForFinished();
-        QCOMPARE(list, QList<int>() << 8 << 16 << 24);
-        QtConcurrent::map(list.begin(), list.end(), multiplyBy2InPlace).waitForFinished();
-        QCOMPARE(list, QList<int>() << 16 << 32 << 48);
-
-        // bound function
-        QtConcurrent::map(list, multiplyBy2InPlace).waitForFinished();
-        QCOMPARE(list, QList<int>() << 32 << 64 << 96);
-        QtConcurrent::map(list.begin(), list.end(), multiplyBy2InPlace).waitForFinished();
-        QCOMPARE(list, QList<int>() << 64 << 128 << 192);
-
-        // member function
-        QList<Number> numberList;
-        numberList << 1 << 2 << 3;
-        QtConcurrent::map(numberList, &Number::multiplyBy2).waitForFinished();
-        QCOMPARE(numberList, QList<Number>() << 2 << 4 << 6);
-        QtConcurrent::map(numberList.begin(), numberList.end(), &Number::multiplyBy2).waitForFinished();
-        QCOMPARE(numberList, QList<Number>() << 4 << 8 << 12);
-
-#ifdef Q_COMPILER_LAMBDA
-        // lambda
-        QtConcurrent::map(list, [](int &x){x *= 2;}).waitForFinished();
-        QCOMPARE(list, QList<int>() << 128 << 256 << 384);
-        QtConcurrent::map(list.begin(), list.end(), [](int &x){x *= 2;}).waitForFinished();
-        QCOMPARE(list, QList<int>() << 256 << 512 << 768);
-#endif
-
-    }
-
-    // functors don't take arguments by reference, making these no-ops
-    {
-        QList<int> list;
-        list << 1 << 2 << 3;
-
-        // functor
-        QtConcurrent::map(list, MultiplyBy2Immutable()).waitForFinished();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QtConcurrent::map(list.begin(), list.end(), MultiplyBy2Immutable()).waitForFinished();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        // function
-        QtConcurrent::map(list, multiplyBy2Immutable).waitForFinished();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QtConcurrent::map(list.begin(), list.end(), multiplyBy2Immutable).waitForFinished();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        // bound function
-        QtConcurrent::map(list, multiplyBy2Immutable).waitForFinished();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QtConcurrent::map(list.begin(), list.end(), multiplyBy2Immutable).waitForFinished();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-#ifdef Q_COMPILER_LAMBDA
-        // lambda
-        QtConcurrent::map(list, [](int x){x *= 2;}).waitForFinished();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QtConcurrent::map(list.begin(), list.end(), [](int x){x *= 2;}).waitForFinished();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-#endif
-    }
-
-    // Linked lists and forward iterators
-    {
-        QLinkedList<int> list;
-        list << 1 << 2 << 3;
-
-        // functor
-        QtConcurrent::map(list, MultiplyBy2InPlace()).waitForFinished();
-        QCOMPARE(list, QLinkedList<int>() << 2 << 4 << 6);
-        QtConcurrent::map(list.begin(), list.end(), MultiplyBy2InPlace()).waitForFinished();
-        QCOMPARE(list, QLinkedList<int>() << 4 << 8 << 12);
-
-        // function
-        QtConcurrent::map(list, multiplyBy2InPlace).waitForFinished();
-        QCOMPARE(list, QLinkedList<int>() << 8 << 16 << 24);
-        QtConcurrent::map(list.begin(), list.end(), multiplyBy2InPlace).waitForFinished();
-        QCOMPARE(list, QLinkedList<int>() << 16 << 32 << 48);
-
-        // bound function
-        QtConcurrent::map(list, multiplyBy2InPlace).waitForFinished();
-        QCOMPARE(list, QLinkedList<int>() << 32 << 64 << 96);
-        QtConcurrent::map(list.begin(), list.end(), multiplyBy2InPlace).waitForFinished();
-        QCOMPARE(list, QLinkedList<int>() << 64 << 128 << 192);
-
-        // member function
-        QLinkedList<Number> numberList;
-        numberList << 1 << 2 << 3;
-        QtConcurrent::map(numberList, &Number::multiplyBy2).waitForFinished();
-        QCOMPARE(numberList, QLinkedList<Number>() << 2 << 4 << 6);
-        QtConcurrent::map(numberList.begin(), numberList.end(), &Number::multiplyBy2).waitForFinished();
-        QCOMPARE(numberList, QLinkedList<Number>() << 4 << 8 << 12);
-    }
-
-#if 0
-    // not allowed: map() with immutable sequences makes no sense
-    {
-        const QList<int> list = QList<int>() << 1 << 2 << 3;
-
-        QtConcurrent::map(list, MultiplyBy2Immutable());
-        QtConcurrent::map(list, multiplyBy2Immutable);
-        QtConcurrent::map(list, multiplyBy2Immutable);
-    }
-#endif
-
-#if 0
-    // not allowed: in place modification of a temp copy (since temp copy goes out of scope)
-    {
-        QList<int> list;
-        list << 1 << 2 << 3;
-
-        QtConcurrent::map(QList<int>(list), MultiplyBy2InPlace());
-        QtConcurrent::map(QList<int>(list), multiplyBy2);
-        QtConcurrent::map(QList<int>(list), multiplyBy2InPlace);
-
-        QList<Number> numberList;
-        numberList << 1 << 2 << 3;
-        QtConcurrent::map(QList<Number>(numberList), &Number::multiplyBy2);
-    }
-#endif
-
-#if 0
-    // not allowed: map() on a const list, where functors try to modify the items in the list
-    {
-        const QList<int> list = QList<int>() << 1 << 2 << 3;;
-
-        QtConcurrent::map(list, MultiplyBy2InPlace());
-        QtConcurrent::map(list, multiplyBy2InPlace);
-        QtConcurrent::map(list, multiplyBy2InPlace);
-
-        const QList<Number> numberList = QList<Number>() << 1 << 2 << 3;
-        QtConcurrent::map(numberList, &Number::multiplyBy2);
-    }
-#endif
-}
-
-void tst_QtConcurrentMap::blocking_map()
-{
-    // functors take arguments by reference, modifying the sequence in place
-    {
-        QList<int> list;
-        list << 1 << 2 << 3;
-
-        // functor
-        QtConcurrent::blockingMap(list, MultiplyBy2InPlace());
-        QCOMPARE(list, QList<int>() << 2 << 4 << 6);
-        QtConcurrent::blockingMap(list.begin(), list.end(), MultiplyBy2InPlace());
-        QCOMPARE(list, QList<int>() << 4 << 8 << 12);
-
-        // function
-        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
-        QCOMPARE(list, QList<int>() << 8 << 16 << 24);
-        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2InPlace);
-        QCOMPARE(list, QList<int>() << 16 << 32 << 48);
-
-        // bound function
-        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
-        QCOMPARE(list, QList<int>() << 32 << 64 << 96);
-        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2InPlace);
-        QCOMPARE(list, QList<int>() << 64 << 128 << 192);
-
-        // member function
-        QList<Number> numberList;
-        numberList << 1 << 2 << 3;
-        QtConcurrent::blockingMap(numberList, &Number::multiplyBy2);
-        QCOMPARE(numberList, QList<Number>() << 2 << 4 << 6);
-        QtConcurrent::blockingMap(numberList.begin(), numberList.end(), &Number::multiplyBy2);
-        QCOMPARE(numberList, QList<Number>() << 4 << 8 << 12);
-    }
-
-    // functors don't take arguments by reference, making these no-ops
-    {
-        QList<int> list;
-        list << 1 << 2 << 3;
-
-        // functor
-        QtConcurrent::blockingMap(list, MultiplyBy2Immutable());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QtConcurrent::blockingMap(list.begin(), list.end(), MultiplyBy2Immutable());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        // function
-        QtConcurrent::blockingMap(list, multiplyBy2Immutable);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2Immutable);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        // bound function
-        QtConcurrent::blockingMap(list, multiplyBy2Immutable);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2Immutable);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-    }
-
-    // Linked lists and forward iterators
-    {
-        QLinkedList<int> list;
-        list << 1 << 2 << 3;
-
-        // functor
-        QtConcurrent::blockingMap(list, MultiplyBy2InPlace());
-        QCOMPARE(list, QLinkedList<int>() << 2 << 4 << 6);
-        QtConcurrent::blockingMap(list.begin(), list.end(), MultiplyBy2InPlace());
-        QCOMPARE(list, QLinkedList<int>() << 4 << 8 << 12);
-
-        // function
-        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
-        QCOMPARE(list, QLinkedList<int>() << 8 << 16 << 24);
-        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2InPlace);
-        QCOMPARE(list, QLinkedList<int>() << 16 << 32 << 48);
-
-        // bound function
-        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
-        QCOMPARE(list, QLinkedList<int>() << 32 << 64 << 96);
-        QtConcurrent::blockingMap(list.begin(), list.end(), multiplyBy2InPlace);
-        QCOMPARE(list, QLinkedList<int>() << 64 << 128 << 192);
-
-        // member function
-        QLinkedList<Number> numberList;
-        numberList << 1 << 2 << 3;
-        QtConcurrent::blockingMap(numberList, &Number::multiplyBy2);
-        QCOMPARE(numberList, QLinkedList<Number>() << 2 << 4 << 6);
-        QtConcurrent::blockingMap(numberList.begin(), numberList.end(), &Number::multiplyBy2);
-        QCOMPARE(numberList, QLinkedList<Number>() << 4 << 8 << 12);
-    }
-
-#if 0
-    // not allowed: map() with immutable sequences makes no sense
-    {
-        const QList<int> list = QList<int>() << 1 << 2 << 3;
-
-        QtConcurrent::blockingMap(list, MultiplyBy2Immutable());
-        QtConcurrent::blockkng::map(list, multiplyBy2Immutable);
-        QtConcurrent::blockingMap(list, multiplyBy2Immutable);
-    }
-#endif
-
-#if 0
-    // not allowed: in place modification of a temp copy (since temp copy goes out of scope)
-    {
-        QList<int> list;
-        list << 1 << 2 << 3;
-
-        QtConcurrent::blockingMap(QList<int>(list), MultiplyBy2InPlace());
-        QtConcurrent::blockingMap(QList<int>(list), multiplyBy2);
-        QtConcurrent::blockingMap(QList<int>(list), multiplyBy2InPlace);
-
-        QList<Number> numberList;
-        numberList << 1 << 2 << 3;
-        QtConcurrent::blockingMap(QList<Number>(numberList), &Number::multiplyBy2);
-    }
-#endif
-
-#if 0
-    // not allowed: map() on a const list, where functors try to modify the items in the list
-    {
-        const QList<int> list = QList<int>() << 1 << 2 << 3;;
-
-        QtConcurrent::blockingMap(list, MultiplyBy2InPlace());
-        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
-        QtConcurrent::blockingMap(list, multiplyBy2InPlace);
-
-        const QList<Number> numberList = QList<Number>() << 1 << 2 << 3;
-        QtConcurrent::blockingMap(numberList, &Number::multiplyBy2);
-    }
-#endif
-}
-
-int multiplyBy2(int x)
-{
-    int y = x * 2;
-    return y;
-}
-
-class MultiplyBy2
-{
-public:
-    typedef int result_type;
-
-    int operator()(int x) const
-    {
-        int y = x * 2;
-        return y;
-    }
-};
-
-double intToDouble(int x)
-{
-    return double(x);
-}
-
-class IntToDouble
-{
-public:
-    typedef double result_type;
-
-    double operator()(int x) const
-    {
-        return double(x);
-    }
-};
-
-int stringToInt(const QString &string)
-{
-    return string.toInt();
-}
-
-class StringToInt
-{
-public:
-    typedef int result_type;
-
-    int operator()(const QString &string) const
-    {
-        return string.toInt();
-    }
-};
-
-void tst_QtConcurrentMap::mapped()
-{
-    QList<int> list;
-    list << 1 << 2 << 3;
-    QLinkedList<int> linkedList;
-    linkedList << 1 << 2 << 3;
-    QList<Number> numberList;
-    numberList << 1 << 2 << 3;
-    QLinkedList<Number> numberLinkedList;
-    numberLinkedList << 1 << 2 << 3;
-
-    // functor
-    {
-        QList<int> list2 = QtConcurrent::mapped(list, MultiplyBy2()).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::mapped(list.constBegin(),
-                                                list.constEnd(),
-                                                MultiplyBy2()).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 = QtConcurrent::mapped(QList<int>(list), MultiplyBy2()).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-    {
-        QList<int> list2 = QtConcurrent::mapped(linkedList, MultiplyBy2()).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::mapped(linkedList.constBegin(),
-                                                linkedList.constEnd(),
-                                                MultiplyBy2()).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 =
-            QtConcurrent::mapped(QLinkedList<int>(linkedList), MultiplyBy2()).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-
-    // function
-    {
-        QList<int> list2 = QtConcurrent::mapped(list, multiplyBy2).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::mapped(list.constBegin(),
-                                                list.constEnd(),
-                                                multiplyBy2).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 = QtConcurrent::mapped(QList<int>(list), multiplyBy2).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-    {
-        QList<int> list2 = QtConcurrent::mapped(linkedList, multiplyBy2).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::mapped(linkedList.constBegin(),
-                                                linkedList.constEnd(),
-                                                multiplyBy2).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 =
-            QtConcurrent::mapped(QLinkedList<int>(linkedList), multiplyBy2).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-
-    // bound function
-    {
-        QList<int> list2 = QtConcurrent::mapped(list, multiplyBy2).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::mapped(list.constBegin(),
-                                                list.constEnd(),
-                                                multiplyBy2).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 = QtConcurrent::mapped(QList<int>(list), multiplyBy2).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-    {
-        QList<int> list2 = QtConcurrent::mapped(linkedList, multiplyBy2).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::mapped(linkedList.constBegin(),
-                                                linkedList.constEnd(),
-                                                multiplyBy2)
-                           .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 = QtConcurrent::mapped(QLinkedList<int>(linkedList), multiplyBy2)
-                           .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-
-    // const member function
-    {
-        QList<Number> numberList2 = QtConcurrent::mapped(numberList, &Number::multipliedBy2)
-                                    .results();
-        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList2, QList<Number>() << 2 << 4 << 6);
-
-        QList<Number> numberList3 = QtConcurrent::mapped(numberList.constBegin(),
-                                                         numberList.constEnd(),
-                                                         &Number::multipliedBy2)
-                                    .results();
-        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList3, QList<Number>() << 2 << 4 << 6);
-
-        QList<Number> numberList4 = QtConcurrent::mapped(QList<Number>(numberList),
-                                                         &Number::multipliedBy2)
-                                    .results();
-        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList4, QList<Number>() << 2 << 4 << 6);
-    }
-    {
-        QList<Number> numberList2 = QtConcurrent::mapped(numberLinkedList, &Number::multipliedBy2)
-                                    .results();
-        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList2, QList<Number>() << 2 << 4 << 6);
-
-        QList<Number> numberList3 = QtConcurrent::mapped(numberLinkedList.constBegin(),
-                                                         numberLinkedList.constEnd(),
-                                                         &Number::multipliedBy2)
-                                    .results();
-        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList3, QList<Number>() << 2 << 4 << 6);
-
-        QList<Number> numberList4 = QtConcurrent::mapped(QLinkedList<Number>(numberLinkedList),
-                                                         &Number::multipliedBy2)
-                                    .results();
-        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList4, QList<Number>() << 2 << 4 << 6);
-    }
-
-    // change the value_type, same container
-
-    // functor
-    {
-        QList<double> list2 = QtConcurrent::mapped(list, IntToDouble()).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::mapped(list.constBegin(),
-                                                   list.constEnd(),
-                                                   IntToDouble())
-                              .results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list4 = QtConcurrent::mapped(QList<int>(list),
-                                                   IntToDouble())
-                              .results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-    {
-        QList<double> list2 = QtConcurrent::mapped(linkedList, IntToDouble()).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::mapped(linkedList.constBegin(),
-                                                   linkedList.constEnd(),
-                                                   IntToDouble())
-                              .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list4 = QtConcurrent::mapped(QLinkedList<int>(linkedList),
-                                                   IntToDouble())
-                              .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-
-    // function
-    {
-        QList<double> list2 = QtConcurrent::mapped(list, intToDouble).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::mapped(list.constBegin(),
-                                                   list.constEnd(),
-                                                   intToDouble)
-                              .results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list4 = QtConcurrent::mapped(QList<int>(list), intToDouble).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-    {
-        QList<double> list2 = QtConcurrent::mapped(linkedList, intToDouble).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::mapped(linkedList.constBegin(),
-                                                   linkedList.constEnd(),
-                                                   intToDouble)
-                              .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list4 = QtConcurrent::mapped(QLinkedList<int>(linkedList), intToDouble)
-                              .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-
-    // bound function
-    {
-        QList<double> list2 = QtConcurrent::mapped(list, intToDouble).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::mapped(list.constBegin(),
-                                                   list.constEnd(),
-                                                   intToDouble)
-                              .results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-
-        QList<double> list4 = QtConcurrent::mapped(QList<int>(list),
-                                                   intToDouble)
-                              .results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-    {
-        QList<double> list2 = QtConcurrent::mapped(linkedList, intToDouble).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::mapped(linkedList.constBegin(),
-                                                   linkedList.constEnd(),
-                                                   intToDouble)
-                              .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-
-        QList<double> list4 = QtConcurrent::mapped(QLinkedList<int>(linkedList),
-                                                   intToDouble)
-                              .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-
-    // const member function
-    {
-        QList<QString> list2 = QtConcurrent::mapped(numberList, &Number::toString).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<QString>() << "1" << "2" << "3");
-
-        QList<QString> list3 = QtConcurrent::mapped(numberList.constBegin(),
-                                                    numberList.constEnd(),
-                                                    &Number::toString)
-                               .results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<QString>() << "1" << "2" << "3");
-
-        QList<QString> list4 = QtConcurrent::mapped(QList<Number>(numberList), &Number::toString)
-                               .results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<QString>() << "1" << "2" << "3");
-    }
-    {
-        QList<QString> list2 = QtConcurrent::mapped(numberLinkedList, &Number::toString).results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<QString>() << "1" << "2" << "3");
-
-        QList<QString> list3 = QtConcurrent::mapped(numberLinkedList.constBegin(),
-                                                    numberLinkedList.constEnd(),
-                                                    &Number::toString)
-                               .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<QString>() << "1" << "2" << "3");
-
-        QList<QString> list4 = QtConcurrent::mapped(QLinkedList<Number>(numberLinkedList),
-                                                    &Number::toString)
-                               .results();
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<QString>() << "1" << "2" << "3");
-    }
-
-    // change the value_type
-    {
-        QList<QString> strings = QStringList() << "1" << "2" << "3";
-        QList<int> list = QtConcurrent::mapped(strings, StringToInt()).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list2 = QtConcurrent::mapped(strings.constBegin(),
-                                                strings.constEnd(),
-                                                StringToInt())
-                           .results();
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-    }
-    {
-        QList<QString> strings = QStringList() << "1" << "2" << "3";
-        QList<int> list = QtConcurrent::mapped(strings, stringToInt).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list2 = QtConcurrent::mapped(strings.constBegin(),
-                                                strings.constEnd(),
-                                                stringToInt).results();
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-    }
-
-    {
-        QList<int> numberList2 = QtConcurrent::mapped(numberList, &Number::toInt).results();
-        QCOMPARE(numberList2, QList<int>() << 1 << 2 << 3);
-
-        QList<int> numberList3 = QtConcurrent::mapped(numberList.constBegin(),
-                                                      numberList.constEnd(),
-                                                      &Number::toInt)
-                                 .results();
-        QCOMPARE(numberList3, QList<int>() << 1 << 2 << 3);
-    }
-
-    // change the value_type from QStringList
-    {
-        QStringList strings = QStringList() << "1" << "2" << "3";
-        QList<int> list = QtConcurrent::mapped(strings, StringToInt()).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list2 = QtConcurrent::mapped(strings.constBegin(),
-                                                strings.constEnd(),
-                                                StringToInt())
-                           .results();
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-    }
-    {
-        QStringList strings = QStringList() << "1" << "2" << "3";
-        QList<int> list = QtConcurrent::mapped(strings, stringToInt).results();
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list2 = QtConcurrent::mapped(strings.constBegin(),
-                                                strings.constEnd(),
-                                                stringToInt)
-                           .results();
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-    }
-}
-
-void tst_QtConcurrentMap::blocking_mapped()
-{
-    QList<int> list;
-    list << 1 << 2 << 3;
-    QLinkedList<int> linkedList;
-    linkedList << 1 << 2 << 3;
-    QList<Number> numberList;
-    numberList << 1 << 2 << 3;
-    QLinkedList<Number> numberLinkedList;
-    numberLinkedList << 1 << 2 << 3;
-
-    // functor
-    {
-        QList<int> list2 = QtConcurrent::blockingMapped(list, MultiplyBy2());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::blockingMapped<QList<int> >(list.constBegin(),
-                                                                       list.constEnd(),
-                                                                       MultiplyBy2());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 = QtConcurrent::blockingMapped(QList<int>(list), MultiplyBy2());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingMapped(linkedList, MultiplyBy2());
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4 << 6);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<int> >(linkedList.constBegin(),
-                                                                       linkedList.constEnd(),
-                                                                       MultiplyBy2());
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 2 << 4 << 6);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::blockingMapped(QLinkedList<int>(linkedList), MultiplyBy2());
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 2 << 4 << 6);
-    }
-
-    // function
-    {
-        QList<int> list2 = QtConcurrent::blockingMapped(list, multiplyBy2);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::blockingMapped<QList<int> >(list.constBegin(),
-                                                             list.constEnd(),
-                                                             multiplyBy2);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 = QtConcurrent::blockingMapped(QList<int>(list), multiplyBy2);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingMapped(linkedList, multiplyBy2);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4 << 6);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<int> >(linkedList.constBegin(),
-                                                             linkedList.constEnd(),
-                                                             multiplyBy2);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 2 << 4 << 6);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::blockingMapped(QLinkedList<int>(linkedList), multiplyBy2);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 2 << 4 << 6);
-    }
-
-    // bound function
-    {
-        QList<int> list2 = QtConcurrent::blockingMapped(list, multiplyBy2);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list3 = QtConcurrent::blockingMapped<QList<int> >(list.constBegin(),
-                                                             list.constEnd(),
-                                                             multiplyBy2);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 2 << 4 << 6);
-
-        QList<int> list4 = QtConcurrent::blockingMapped(QList<int>(list), multiplyBy2);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 2 << 4 << 6);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingMapped(linkedList, multiplyBy2);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 2 << 4 << 6);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<int> >(linkedList.constBegin(),
-                                                             linkedList.constEnd(),
-                                                             multiplyBy2);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 2 << 4 << 6);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::blockingMapped(QLinkedList<int>(linkedList), multiplyBy2);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 2 << 4 << 6);
-    }
-
-    // const member function
-    {
-        QList<Number> numberList2 = QtConcurrent::blockingMapped(numberList, &Number::multipliedBy2);
-        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList2, QList<Number>() << 2 << 4 << 6);
-
-        QList<Number> numberList3 = QtConcurrent::blockingMapped<QList<Number> >(numberList.constBegin(),
-                                                                         numberList.constEnd(),
-                                                                         &Number::multipliedBy2);
-        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList3, QList<Number>() << 2 << 4 << 6);
-
-        QList<Number> numberList4 = QtConcurrent::blockingMapped(QList<Number>(numberList),
-                                                         &Number::multipliedBy2);
-        QCOMPARE(numberList, QList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberList4, QList<Number>() << 2 << 4 << 6);
-    }
-    {
-        QLinkedList<Number> numberLinkedList2 = QtConcurrent::blockingMapped(numberLinkedList, &Number::multipliedBy2);
-        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberLinkedList2, QLinkedList<Number>() << 2 << 4 << 6);
-
-        QLinkedList<Number> numberLinkedList3 = QtConcurrent::blockingMapped<QLinkedList<Number> >(numberLinkedList.constBegin(),
-                                                                         numberLinkedList.constEnd(),
-                                                                         &Number::multipliedBy2);
-        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberLinkedList3, QLinkedList<Number>() << 2 << 4 << 6);
-
-        QLinkedList<Number> numberLinkedList4 = QtConcurrent::blockingMapped(QLinkedList<Number>(numberLinkedList),
-                                                         &Number::multipliedBy2);
-        QCOMPARE(numberLinkedList, QLinkedList<Number>() << 1 << 2 << 3);
-        QCOMPARE(numberLinkedList4, QLinkedList<Number>() << 2 << 4 << 6);
-    }
-
-    // change the value_type, same container
-
-    // functor
-    {
-        QList<double> list2 = QtConcurrent::blockingMapped<QList<double> >(list, IntToDouble());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::blockingMapped<QList<double> >(list.constBegin(),
-                                                                   list.constEnd(),
-                                                                   IntToDouble());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list4 = QtConcurrent::blockingMapped<QList<double> >(QList<int>(list),
-                                                                   IntToDouble());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-    {
-        QLinkedList<double> linkedList2 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList, IntToDouble());
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-
-        QLinkedList<double> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList.constBegin(),
-                                                                   linkedList.constEnd(),
-                                                                   IntToDouble());
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-
-        QLinkedList<double> linkedList4 = QtConcurrent::blockingMapped<QLinkedList<double> >(QLinkedList<int>(linkedList),
-                                                                   IntToDouble());
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-    }
-
-    // function
-    {
-        QList<double> list2 = QtConcurrent::blockingMapped<QList<double> >(list, intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::blockingMapped<QList<double> >(list.constBegin(),
-                                                                   list.constEnd(),
-                                                                   intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list4 = QtConcurrent::blockingMapped<QList<double> >(QList<int>(list), intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-    {
-        QLinkedList<double> linkedList2 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList, intToDouble);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-
-        QLinkedList<double> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList.constBegin(),
-                                                                   linkedList.constEnd(),
-                                                                   intToDouble);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-
-        QLinkedList<double> linkedList4 = QtConcurrent::blockingMapped<QLinkedList<double> >(QLinkedList<int>(linkedList), intToDouble);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-    }
-
-    // bound function
-    {
-        QList<double> list2 = QtConcurrent::blockingMapped<QList<double> >(list, intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<double>() << 1.0 << 2.0 << 3.0);
-
-        QList<double> list3 = QtConcurrent::blockingMapped<QList<double> >(list.constBegin(),
-                                                                   list.constEnd(),
-                                                                   intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<double>() << 1.0 << 2.0 << 3.0);
-
-
-        QList<double> list4 = QtConcurrent::blockingMapped<QList<double> >(QList<int>(list),
-                                                                   intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<double>() << 1.0 << 2.0 << 3.0);
-    }
-    {
-        QLinkedList<double> linkedList2 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList, intToDouble);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-
-        QLinkedList<double> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<double> >(linkedList.constBegin(),
-                                                                   linkedList.constEnd(),
-                                                                   intToDouble);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-
-
-        QLinkedList<double> linkedList4 = QtConcurrent::blockingMapped<QLinkedList<double> >(QLinkedList<int>(linkedList),
-                                                                   intToDouble);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<double>() << 1.0 << 2.0 << 3.0);
-    }
-
-    // const member function
-    {
-        QList<QString> list2 =
-            QtConcurrent::blockingMapped<QList<QString> >(numberList, &Number::toString);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<QString>() << "1" << "2" << "3");
-
-        QList<QString> list3 = QtConcurrent::blockingMapped<QList<QString> >(numberList.constBegin(),
-                                                                     numberList.constEnd()
-                                                                     , &Number::toString);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<QString>() << "1" << "2" << "3");
-
-        QList<QString> list4 =
-            QtConcurrent::blockingMapped<QList<QString> >(QList<Number>(numberList), &Number::toString);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<QString>() << "1" << "2" << "3");
-    }
-    {
-        QLinkedList<QString> linkedList2 =
-            QtConcurrent::blockingMapped<QLinkedList<QString> >(numberLinkedList, &Number::toString);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<QString>() << "1" << "2" << "3");
-
-        QLinkedList<QString> linkedList3 = QtConcurrent::blockingMapped<QLinkedList<QString> >(numberLinkedList.constBegin(),
-                                                                     numberLinkedList.constEnd()
-                                                                     , &Number::toString);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<QString>() << "1" << "2" << "3");
-
-        QLinkedList<QString> linkedList4 =
-            QtConcurrent::blockingMapped<QLinkedList<QString> >(QLinkedList<Number>(numberLinkedList), &Number::toString);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<QString>() << "1" << "2" << "3");
-    }
-
-    // change the value_type
-    {
-        QList<QString> strings = QStringList() << "1" << "2" << "3";
-        QList<int> list = QtConcurrent::blockingMapped(strings, StringToInt());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list2 = QtConcurrent::blockingMapped<QList<int> >(strings.constBegin(),
-                                                             strings.constEnd(),
-                                                             StringToInt());
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-    }
-    {
-        QList<QString> strings = QStringList() << "1" << "2" << "3";
-        QList<int> list = QtConcurrent::blockingMapped(strings, stringToInt);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list2 = QtConcurrent::blockingMapped<QList<int> >(strings.constBegin(),
-                                                             strings.constEnd(),
-                                                             stringToInt);
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-    }
-
-    {
-        QList<int> numberList2 = QtConcurrent::blockingMapped(numberList, &Number::toInt);
-        QCOMPARE(numberList2, QList<int>() << 1 << 2 << 3);
-
-        QList<int> numberList3 = QtConcurrent::blockingMapped<QList<int> >(numberList.constBegin(),
-                                                                   numberList.constEnd(),
-                                                                   &Number::toInt);
-        QCOMPARE(numberList3, QList<int>() << 1 << 2 << 3);
-    }
-
-    // change the value_type from QStringList
-    {
-        QStringList strings = QStringList() << "1" << "2" << "3";
-        QList<int> list = QtConcurrent::blockingMapped(strings, StringToInt());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list2 = QtConcurrent::blockingMapped<QList<int> >(strings.constBegin(),
-                                                             strings.constEnd(),
-                                                             StringToInt());
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-    }
-    {
-        QStringList strings = QStringList() << "1" << "2" << "3";
-        QList<int> list = QtConcurrent::blockingMapped(strings, stringToInt);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list2 = QtConcurrent::blockingMapped<QList<int> >(strings.constBegin(),
-                                                             strings.constEnd(),
-                                                             stringToInt);
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-    }
-
-    // functor
-    {
-        QVector<double> list2 = QtConcurrent::blockingMapped<QVector<double> >(list, IntToDouble());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QVector<double>() << 1.0 << 2.0 << 3.0);
-
-        QVector<double> list3 = QtConcurrent::blockingMapped<QVector<double> >(list.constBegin(),
-                                                                       list.constEnd(),
-                                                                       IntToDouble());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QVector<double>() << 1.0 << 2.0 << 3.0);
-
-        QVector<double> list4 = QtConcurrent::blockingMapped<QVector<double> >(QList<int>(list),
-                                                                       IntToDouble());
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QVector<double>() << 1.0 << 2.0 << 3.0);
-
-        QStringList strings = QStringList() << "1" << "2" << "3";
-        QVector<int> list5 = QtConcurrent::blockingMapped<QVector<int> >(strings, StringToInt());
-        QCOMPARE(list5, QVector<int>() << 1 << 2 << 3);
-
-        QVector<int> list6 = QtConcurrent::blockingMapped<QVector<int> >(strings.constBegin(),
-                                                                 strings.constEnd(),
-                                                                 StringToInt());
-        QCOMPARE(list6, QVector<int>() << 1 << 2 << 3);
-
-        QVector<int> list7 = QtConcurrent::blockingMapped<QVector<int> >(QStringList(strings),
-                                                                 StringToInt());
-        QCOMPARE(list7, QVector<int>() << 1 << 2 << 3);
-    }
-
-    // function
-    {
-        QVector<double> list2 = QtConcurrent::blockingMapped<QVector<double> >(list, intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QVector<double>() << 1.0 << 2.0 << 3.0);
-
-        QVector<double> list3 = QtConcurrent::blockingMapped<QVector<double> >(list.constBegin(),
-                                                                       list.constEnd(),
-                                                                       intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QVector<double>() << 1.0 << 2.0 << 3.0);
-
-        QVector<double> list4 = QtConcurrent::blockingMapped<QVector<double> >(QList<int>(list),
-                                                                       intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QVector<double>() << 1.0 << 2.0 << 3.0);
-
-        QStringList strings = QStringList() << "1" << "2" << "3";
-        QVector<int> list5 = QtConcurrent::blockingMapped<QVector<int> >(strings, stringToInt);
-        QCOMPARE(list5, QVector<int>() << 1 << 2 << 3);
-
-        QVector<int> list6 = QtConcurrent::blockingMapped<QVector<int> >(strings.constBegin(),
-                                                                 strings.constEnd(),
-                                                                 stringToInt);
-        QCOMPARE(list6, QVector<int>() << 1 << 2 << 3);
-
-        QVector<int> list7 = QtConcurrent::blockingMapped<QVector<int> >(QStringList(strings),
-                                                                 stringToInt);
-        QCOMPARE(list7, QVector<int>() << 1 << 2 << 3);
-    }
-
-    // bound function
-    {
-        QVector<double> list2 = QtConcurrent::blockingMapped<QVector<double> >(list, intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QVector<double>() << 1.0 << 2.0 << 3.0);
-
-        QVector<double> list3 = QtConcurrent::blockingMapped<QVector<double> >(QList<int>(list), intToDouble);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QVector<double>() << 1.0 << 2.0 << 3.0);
-
-        QStringList strings = QStringList() << "1" << "2" << "3";
-        QVector<int> list4 = QtConcurrent::blockingMapped<QVector<int> >(strings, stringToInt);
-        QCOMPARE(list4, QVector<int>() << 1 << 2 << 3);
-
-        QVector<int> list5 = QtConcurrent::blockingMapped<QVector<int> >(QStringList(strings), stringToInt);
-        QCOMPARE(list5, QVector<int>() << 1 << 2 << 3);
-    }
-
-    // const member function
-    {
-        QVector<QString> list2 = QtConcurrent::blockingMapped<QVector<QString> >(numberList, &Number::toString);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QVector<QString>() << "1" << "2" << "3");
-
-        QVector<QString> list3 =
-            QtConcurrent::blockingMapped<QVector<QString> >(QList<Number>(numberList), &Number::toString);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QVector<QString>() << "1" << "2" << "3");
-
-        // not allowed: const member function where all arguments have default values
-#if 0
-        QStringList strings = QStringList() << "1" << "2" << "3";
-        QVector<int> list4 = QtConcurrent::blockingMapped<QVector<int> >(strings, &QString::toInt);
-        QCOMPARE(list4, QVector<int>() << 1 << 2 << 3);
-
-        QVector<int> list5 = QtConcurrent::blockingMapped<QVector<int> >(QStringList(strings), &QString::toInt);
-        QCOMPARE(list5, QVector<int>() << 1 << 2 << 3);
-#endif
-    }
-}
-
-int intSquare(int x)
-{
-    return x * x;
-}
-
-class IntSquare
-{
-public:
-    typedef int result_type;
-
-    int operator()(int x)
-    {
-        return x * x;
-    }
-};
-
-void tst_QtConcurrentMap::mappedReduced()
-{
-    QList<int> list;
-    list << 1 << 2 << 3;
-    QLinkedList<int> linkedList;
-    linkedList << 1 << 2 << 3;
-    QList<Number> numberList;
-    numberList << 1 << 2 << 3;
-    QLinkedList<Number> numberLinkedList;
-    numberLinkedList << 1 << 2 << 3;
-
-    // test Q_DECLARE_OPERATORS_FOR_FLAGS
-    QtConcurrent::ReduceOptions opt = (QtConcurrent::UnorderedReduce | QtConcurrent::SequentialReduce);
-    QVERIFY(opt);
-
-    // functor-functor
-    {
-        int sum = QtConcurrent::mappedReduced<int>(list, IntSquare(), IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    IntSquare(),
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced<int>(QList<int>(list), IntSquare(), IntSumReduce());
-        QCOMPARE(sum3, 14);
-
-        int sum4 = QtConcurrent::mappedReduced<int>(list, intSquare, intSumReduce);
-        QCOMPARE(sum4, 14);
-        int sum5 = QtConcurrent::mappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum5, 14);
-
-        int sum6 = QtConcurrent::mappedReduced<int>(QList<int>(list),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum6, 14);
-    }
-    {
-        int sum = QtConcurrent::mappedReduced<int>(linkedList, IntSquare(), IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced<int>(linkedList.constBegin(),
-                                                    linkedList.constEnd(),
-                                                    IntSquare(),
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(linkedList), IntSquare(), IntSumReduce());
-        QCOMPARE(sum3, 14);
-
-        int sum4 = QtConcurrent::mappedReduced<int>(linkedList, intSquare, intSumReduce);
-        QCOMPARE(sum4, 14);
-        int sum5 = QtConcurrent::mappedReduced<int>(linkedList.constBegin(),
-                                                    linkedList.constEnd(),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum5, 14);
-
-        int sum6 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(linkedList),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum6, 14);
-    }
-
-    // function-functor
-    {
-        int sum = QtConcurrent::mappedReduced<int>(list, intSquare, IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    intSquare,
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced<int>(QList<int>(list), intSquare, IntSumReduce());
-        QCOMPARE(sum3, 14);
-    }
-    {
-        int sum = QtConcurrent::mappedReduced<int>(linkedList, intSquare, IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced<int>(linkedList.constBegin(),
-                                                    linkedList.constEnd(),
-                                                    intSquare,
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(linkedList), intSquare, IntSumReduce());
-        QCOMPARE(sum3, 14);
-    }
-
-    // functor-function
-    {
-        int sum = QtConcurrent::mappedReduced(list, IntSquare(), intSumReduce);
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced(list.constBegin(),
-                                               list.constEnd(),
-                                               IntSquare(),
-                                               intSumReduce);
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced(QList<int>(list), IntSquare(), intSumReduce);
-        QCOMPARE(sum3, 14);
-    }
-    {
-        int sum = QtConcurrent::mappedReduced(linkedList, IntSquare(), intSumReduce);
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced(linkedList.constBegin(),
-                                               linkedList.constEnd(),
-                                               IntSquare(),
-                                               intSumReduce);
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced(QLinkedList<int>(linkedList), IntSquare(), intSumReduce);
-        QCOMPARE(sum3, 14);
-    }
-
-    // function-function
-    {
-        int sum = QtConcurrent::mappedReduced(list, intSquare, intSumReduce);
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced(list.constBegin(),
-                                               list.constEnd(),
-                                               intSquare,
-                                               intSumReduce);
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced(QList<int>(list), intSquare, intSumReduce);
-        QCOMPARE(sum3, 14);
-    }
-    {
-        int sum = QtConcurrent::mappedReduced(linkedList, intSquare, intSumReduce);
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced(linkedList.constBegin(),
-                                               linkedList.constEnd(),
-                                               intSquare,
-                                               intSumReduce);
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced(QLinkedList<int>(linkedList), intSquare, intSumReduce);
-        QCOMPARE(sum3, 14);
-    }
-
-    // functor-member
-    {
-        QList<int> list2 = QtConcurrent::mappedReduced(list,
-                                                       IntSquare(),
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 1 << 4 << 9);
-
-        QList<int> list3 = QtConcurrent::mappedReduced(list.constBegin(),
-                                                       list.constEnd(),
-                                                       IntSquare(),
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 1 << 4 << 9);
-
-        QList<int> list4 = QtConcurrent::mappedReduced(QList<int>(list),
-                                                       IntSquare(),
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 1 << 4 << 9);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::mappedReduced(linkedList,
-                                                       IntSquare(),
-                                                       &QLinkedList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 4 << 9);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::mappedReduced(linkedList.constBegin(),
-                                                       linkedList.constEnd(),
-                                                       IntSquare(),
-                                                       &QLinkedList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 4 << 9);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::mappedReduced(QLinkedList<int>(linkedList),
-                                                       IntSquare(),
-                                                       &QLinkedList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 4 << 9);
-    }
-
-    // member-functor
-    {
-        int sum = QtConcurrent::mappedReduced<int>(numberList, &Number::toInt, IntSumReduce());
-        QCOMPARE(sum, 6);
-        int sum2 = QtConcurrent::mappedReduced<int>(numberList.constBegin(),
-                                                    numberList.constEnd(),
-                                                    &Number::toInt,
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 6);
-
-        int sum3 = QtConcurrent::mappedReduced<int>(QList<Number>(numberList),
-                                                    &Number::toInt,
-                                                    IntSumReduce());
-        QCOMPARE(sum3, 6);
-    }
-    {
-        int sum = QtConcurrent::mappedReduced<int>(numberLinkedList, &Number::toInt, IntSumReduce());
-        QCOMPARE(sum, 6);
-        int sum2 = QtConcurrent::mappedReduced<int>(numberLinkedList.constBegin(),
-                                                    numberLinkedList.constEnd(),
-                                                    &Number::toInt,
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 6);
-
-        int sum3 = QtConcurrent::mappedReduced<int>(QLinkedList<Number>(numberLinkedList),
-                                                    &Number::toInt,
-                                                    IntSumReduce());
-        QCOMPARE(sum3, 6);
-    }
-
-    // member-member
-    {
-        QList<int> list2 = QtConcurrent::mappedReduced(numberList,
-                                                       &Number::toInt,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list3 = QtConcurrent::mappedReduced(numberList.constBegin(),
-                                                       numberList.constEnd(),
-                                                       &Number::toInt,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list3, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list4 = QtConcurrent::mappedReduced(QList<Number>(numberList),
-                                                       &Number::toInt,
-                                                       &QList<int>::push_back, OrderedReduce);
-        QCOMPARE(list4, QList<int>() << 1 << 2 << 3);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::mappedReduced(numberLinkedList,
-                                                       &Number::toInt,
-                                                       &QLinkedList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 2 << 3);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::mappedReduced(numberLinkedList.constBegin(),
-                                                       numberLinkedList.constEnd(),
-                                                       &Number::toInt,
-                                                       &QLinkedList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 2 << 3);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::mappedReduced(QLinkedList<Number>(numberLinkedList),
-                                                       &Number::toInt,
-                                                       &QLinkedList<int>::push_back, OrderedReduce);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 2 << 3);
-    }
-
-    // function-member
-    {
-        QList<int> list2 = QtConcurrent::mappedReduced(list,
-                                                       intSquare,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 1 << 4 << 9);
-
-        QList<int> list3 = QtConcurrent::mappedReduced(list.constBegin(),
-                                                       list.constEnd(),
-                                                       intSquare,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 1 << 4 << 9);
-
-        QList<int> list4 = QtConcurrent::mappedReduced(QList<int>(list),
-                                                       intSquare,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 1 << 4 << 9);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::mappedReduced(linkedList,
-                                                       intSquare,
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 4 << 9);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::mappedReduced(linkedList.constBegin(),
-                                                       linkedList.constEnd(),
-                                                       intSquare,
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 4 << 9);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::mappedReduced(QLinkedList<int>(linkedList),
-                                                       intSquare,
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 4 << 9);
-    }
-
-    // member-function
-    {
-        int sum = QtConcurrent::mappedReduced(numberList,
-                                              &Number::toInt,
-                                              intSumReduce);
-        QCOMPARE(sum, 6);
-        int sum2 = QtConcurrent::mappedReduced(numberList.constBegin(),
-                                               numberList.constEnd(),
-                                              &Number::toInt,
-                                              intSumReduce);
-        QCOMPARE(sum2, 6);
-
-        int sum3 = QtConcurrent::mappedReduced(QList<Number>(numberList),
-                                               &Number::toInt,
-                                               intSumReduce);
-        QCOMPARE(sum3, 6);
-    }
-    {
-        int sum = QtConcurrent::mappedReduced(numberLinkedList,
-                                              &Number::toInt,
-                                              intSumReduce);
-        QCOMPARE(sum, 6);
-        int sum2 = QtConcurrent::mappedReduced(numberLinkedList.constBegin(),
-                                               numberLinkedList.constEnd(),
-                                              &Number::toInt,
-                                              intSumReduce);
-        QCOMPARE(sum2, 6);
-
-        int sum3 = QtConcurrent::mappedReduced(QLinkedList<Number>(numberLinkedList),
-                                               &Number::toInt,
-                                               intSumReduce);
-        QCOMPARE(sum3, 6);
-    }
-
-    // linked lists
-    {
-
-        QLinkedList<int> list;
-        list << 1 << 2 << 3;
-
-        QLinkedList<Number> numberList;
-        numberList << 1 << 2 << 3;
-
-        int sum = QtConcurrent::mappedReduced<int>(list, IntSquare(), IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::mappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    IntSquare(),
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(list), IntSquare(), IntSumReduce());
-        QCOMPARE(sum3, 14);
-
-        int sum4 = QtConcurrent::mappedReduced<int>(list, intSquare, intSumReduce);
-        QCOMPARE(sum4, 14);
-        int sum5 = QtConcurrent::mappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum5, 14);
-
-        int sum6 = QtConcurrent::mappedReduced<int>(QLinkedList<int>(list),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum6, 14);
-    }
-
-    // ### the same as above, with an initial result value
-}
-
-void tst_QtConcurrentMap::blocking_mappedReduced()
-{
-    QList<int> list;
-    list << 1 << 2 << 3;
-    QLinkedList<int> linkedList;
-    linkedList << 1 << 2 << 3;
-    QList<Number> numberList;
-    numberList << 1 << 2 << 3;
-    QLinkedList<Number> numberLinkedList;
-    numberLinkedList << 1 << 2 << 3;
-
-    // functor-functor
-    {
-        int sum = QtConcurrent::blockingMappedReduced<int>(list, IntSquare(), IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    IntSquare(),
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced<int>(QList<int>(list), IntSquare(), IntSumReduce());
-        QCOMPARE(sum3, 14);
-
-        int sum4 = QtConcurrent::blockingMappedReduced<int>(list, intSquare, intSumReduce);
-        QCOMPARE(sum4, 14);
-        int sum5 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum5, 14);
-
-        int sum6 = QtConcurrent::blockingMappedReduced<int>(QList<int>(list),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum6, 14);
-    }
-    {
-        int sum = QtConcurrent::blockingMappedReduced<int>(linkedList, IntSquare(), IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced<int>(linkedList.constBegin(),
-                                                    linkedList.constEnd(),
-                                                    IntSquare(),
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(linkedList), IntSquare(), IntSumReduce());
-        QCOMPARE(sum3, 14);
-
-        int sum4 = QtConcurrent::blockingMappedReduced<int>(linkedList, intSquare, intSumReduce);
-        QCOMPARE(sum4, 14);
-        int sum5 = QtConcurrent::blockingMappedReduced<int>(linkedList.constBegin(),
-                                                    linkedList.constEnd(),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum5, 14);
-
-        int sum6 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(linkedList),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum6, 14);
-    }
-
-    // function-functor
-    {
-        int sum = QtConcurrent::blockingMappedReduced<int>(list, intSquare, IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    intSquare,
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced<int>(QList<int>(list), intSquare, IntSumReduce());
-        QCOMPARE(sum3, 14);
-    }
-    {
-        int sum = QtConcurrent::blockingMappedReduced<int>(linkedList, intSquare, IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced<int>(linkedList.constBegin(),
-                                                    linkedList.constEnd(),
-                                                    intSquare,
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(linkedList), intSquare, IntSumReduce());
-        QCOMPARE(sum3, 14);
-    }
-
-    // functor-function
-    {
-        int sum = QtConcurrent::blockingMappedReduced(list, IntSquare(), intSumReduce);
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced(list.constBegin(),
-                                               list.constEnd(),
-                                               IntSquare(),
-                                               intSumReduce);
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced(QList<int>(list), IntSquare(), intSumReduce);
-        QCOMPARE(sum3, 14);
-    }
-    {
-        int sum = QtConcurrent::blockingMappedReduced(linkedList, IntSquare(), intSumReduce);
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced(linkedList.constBegin(),
-                                               linkedList.constEnd(),
-                                               IntSquare(),
-                                               intSumReduce);
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced(QLinkedList<int>(linkedList), IntSquare(), intSumReduce);
-        QCOMPARE(sum3, 14);
-    }
-
-    // function-function
-    {
-        int sum = QtConcurrent::blockingMappedReduced(list, intSquare, intSumReduce);
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced(list.constBegin(),
-                                                         list.constEnd(),
-                                                         intSquare,
-                                                         intSumReduce);
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced(QList<int>(list), intSquare, intSumReduce);
-        QCOMPARE(sum3, 14);
-    }
-    {
-        int sum = QtConcurrent::blockingMappedReduced(linkedList, intSquare, intSumReduce);
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced(linkedList.constBegin(),
-                                               linkedList.constEnd(),
-                                               intSquare,
-                                               intSumReduce);
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced(QLinkedList<int>(linkedList), intSquare, intSumReduce);
-        QCOMPARE(sum3, 14);
-    }
-
-    // functor-member
-    {
-        QList<int> list2 = QtConcurrent::blockingMappedReduced(list,
-                                                       IntSquare(),
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 1 << 4 << 9);
-
-        QList<int> list3 = QtConcurrent::blockingMappedReduced(list.constBegin(),
-                                                       list.constEnd(),
-                                                       IntSquare(),
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 1 << 4 << 9);
-
-        QList<int> list4 = QtConcurrent::blockingMappedReduced(QList<int>(list),
-                                                       IntSquare(),
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 1 << 4 << 9);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingMappedReduced(linkedList,
-                                                       IntSquare(),
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 4 << 9);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::blockingMappedReduced(linkedList.constBegin(),
-                                                       linkedList.constEnd(),
-                                                       IntSquare(),
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 4 << 9);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::blockingMappedReduced(QLinkedList<int>(linkedList),
-                                                       IntSquare(),
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 4 << 9);
-    }
-
-    // member-functor
-    {
-        int sum = QtConcurrent::blockingMappedReduced<int>(numberList, &Number::toInt,
-                                                             IntSumReduce());
-        QCOMPARE(sum, 6);
-        int sum2 = QtConcurrent::blockingMappedReduced<int>(numberList.constBegin(),
-                                                              numberList.constEnd(),
-                                                              &Number::toInt,
-                                                              IntSumReduce());
-        QCOMPARE(sum2, 6);
-
-        int sum3 = QtConcurrent::blockingMappedReduced<int>(QList<Number>(numberList),
-                                                              &Number::toInt,
-                                                              IntSumReduce());
-        QCOMPARE(sum3, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingMappedReduced<int>(numberLinkedList, &Number::toInt, IntSumReduce());
-        QCOMPARE(sum, 6);
-        int sum2 = QtConcurrent::blockingMappedReduced<int>(numberLinkedList.constBegin(),
-                                                    numberLinkedList.constEnd(),
-                                                    &Number::toInt,
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 6);
-
-        int sum3 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<Number>(numberLinkedList),
-                                                    &Number::toInt,
-                                                    IntSumReduce());
-        QCOMPARE(sum3, 6);
-    }
-
-    // member-member
-    {
-        QList<int> list2 = QtConcurrent::blockingMappedReduced(numberList,
-                                                       &Number::toInt,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list2, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list3 = QtConcurrent::blockingMappedReduced(numberList.constBegin(),
-                                                       numberList.constEnd(),
-                                                       &Number::toInt,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list3, QList<int>() << 1 << 2 << 3);
-
-        QList<int> list4 = QtConcurrent::blockingMappedReduced(QList<Number>(numberList),
-                                                       &Number::toInt,
-                                                       &QList<int>::push_back, OrderedReduce);
-        QCOMPARE(list4, QList<int>() << 1 << 2 << 3);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingMappedReduced(numberLinkedList,
-                                                       &Number::toInt,
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 2 << 3);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::blockingMappedReduced(numberLinkedList.constBegin(),
-                                                       numberLinkedList.constEnd(),
-                                                       &Number::toInt,
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 2 << 3);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::blockingMappedReduced(QLinkedList<Number>(numberLinkedList),
-                                                       &Number::toInt,
-                                                       &QLinkedList<int>::append, OrderedReduce);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 2 << 3);
-    }
-
-    // function-member
-    {
-        QList<int> list2 = QtConcurrent::blockingMappedReduced(list,
-                                                       intSquare,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list2, QList<int>() << 1 << 4 << 9);
-
-        QList<int> list3 = QtConcurrent::blockingMappedReduced(list.constBegin(),
-                                                       list.constEnd(),
-                                                       intSquare,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list3, QList<int>() << 1 << 4 << 9);
-
-        QList<int> list4 = QtConcurrent::blockingMappedReduced(QList<int>(list),
-                                                       intSquare,
-                                                       &QList<int>::push_back,
-                                                       OrderedReduce);
-        QCOMPARE(list, QList<int>() << 1 << 2 << 3);
-        QCOMPARE(list4, QList<int>() << 1 << 4 << 9);
-    }
-    {
-        QLinkedList<int> linkedList2 = QtConcurrent::blockingMappedReduced(linkedList,
-                                                       intSquare,
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList2, QLinkedList<int>() << 1 << 4 << 9);
-
-        QLinkedList<int> linkedList3 = QtConcurrent::blockingMappedReduced(linkedList.constBegin(),
-                                                       linkedList.constEnd(),
-                                                       intSquare,
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList3, QLinkedList<int>() << 1 << 4 << 9);
-
-        QLinkedList<int> linkedList4 = QtConcurrent::blockingMappedReduced(QLinkedList<int>(linkedList),
-                                                       intSquare,
-                                                       &QLinkedList<int>::append,
-                                                       OrderedReduce);
-        QCOMPARE(linkedList, QLinkedList<int>() << 1 << 2 << 3);
-        QCOMPARE(linkedList4, QLinkedList<int>() << 1 << 4 << 9);
-    }
-
-    // member-function
-    {
-        int sum = QtConcurrent::blockingMappedReduced(numberList,
-                                              &Number::toInt,
-                                              intSumReduce);
-        QCOMPARE(sum, 6);
-        int sum2 = QtConcurrent::blockingMappedReduced(numberList.constBegin(),
-                                               numberList.constEnd(),
-                                              &Number::toInt,
-                                              intSumReduce);
-        QCOMPARE(sum2, 6);
-
-        int sum3 = QtConcurrent::blockingMappedReduced(QList<Number>(numberList),
-                                               &Number::toInt,
-                                               intSumReduce);
-        QCOMPARE(sum3, 6);
-    }
-    {
-        int sum = QtConcurrent::blockingMappedReduced(numberLinkedList,
-                                              &Number::toInt,
-                                              intSumReduce);
-        QCOMPARE(sum, 6);
-        int sum2 = QtConcurrent::blockingMappedReduced(numberLinkedList.constBegin(),
-                                               numberLinkedList.constEnd(),
-                                              &Number::toInt,
-                                              intSumReduce);
-        QCOMPARE(sum2, 6);
-
-        int sum3 = QtConcurrent::blockingMappedReduced(QLinkedList<Number>(numberLinkedList),
-                                               &Number::toInt,
-                                               intSumReduce);
-        QCOMPARE(sum3, 6);
-    }
-
-    // linked lists
-    {
-
-        QLinkedList<int> list;
-        list << 1 << 2 << 3;
-
-        QLinkedList<Number> numberList;
-        numberList << 1 << 2 << 3;
-
-        int sum = QtConcurrent::blockingMappedReduced<int>(list, IntSquare(), IntSumReduce());
-        QCOMPARE(sum, 14);
-        int sum2 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    IntSquare(),
-                                                    IntSumReduce());
-        QCOMPARE(sum2, 14);
-
-        int sum3 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(list), IntSquare(), IntSumReduce());
-        QCOMPARE(sum3, 14);
-
-        int sum4 = QtConcurrent::blockingMappedReduced<int>(list, intSquare, intSumReduce);
-        QCOMPARE(sum4, 14);
-        int sum5 = QtConcurrent::blockingMappedReduced<int>(list.constBegin(),
-                                                    list.constEnd(),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum5, 14);
-
-        int sum6 = QtConcurrent::blockingMappedReduced<int>(QLinkedList<int>(list),
-                                                    intSquare,
-                                                    intSumReduce);
-        QCOMPARE(sum6, 14);
-    }
-
-    // ### the same as above, with an initial result value
-}
-
-int sleeper(int val)
-{
-    QTest::qSleep(100);
-    return val;
-}
-
-void tst_QtConcurrentMap::assignResult()
-{
-    const QList<int> startList = QList<int>() << 0 << 1 << 2;
-    QList<int> list = QtConcurrent::blockingMapped(startList, sleeper);
-    QCOMPARE(list.at(0), 0);
-    QCOMPARE(list.at(1), 1);
-}
-
-int fnConst(const int &i)
-{
-    return i;
-}
-
-int fn(int &i)
-{
-    return i;
-}
-
-QString changeTypeConst(const int &)
-{
-    return QString();
-}
-
-QString changeType(int &)
-{
-    return QString();
-}
-
-int changeTypeQStringListConst(const QStringList &)
-{
-    return 0;
-}
-
-int changeTypeQStringList(QStringList &)
-{
-    return 0;
-}
-
-class MemFnTester
-{
-public:
-    MemFnTester() {}
-
-    MemFnTester fn()
-    {
-        return MemFnTester();
-    }
-
-    MemFnTester fnConst() const
-    {
-        return MemFnTester();
-    }
-
-    QString changeType()
-    {
-        return QString();
-    }
-
-    QString changeTypeConst() const
-    {
-        return QString();
-    }
-};
-
-Q_DECLARE_METATYPE(QVector<MemFnTester>);
-Q_DECLARE_METATYPE(QList<MemFnTester>);
-
-void tst_QtConcurrentMap::functionOverloads()
-{
-    QList<int> intList;
-    const QList<int> constIntList;
-    QList<MemFnTester> classList;
-    const QList<MemFnTester> constMemFnTesterList;
-
-    QtConcurrent::mapped(intList, fnConst);
-    QtConcurrent::mapped(constIntList, fnConst);
-    QtConcurrent::mapped(classList, &MemFnTester::fnConst);
-    QtConcurrent::mapped(constMemFnTesterList, &MemFnTester::fnConst);
-
-    QtConcurrent::blockingMapped<QVector<int> >(intList, fnConst);
-    QtConcurrent::blockingMapped<QVector<int> >(constIntList, fnConst);
-    QtConcurrent::blockingMapped<QVector<MemFnTester> >(classList, &MemFnTester::fnConst);
-    QtConcurrent::blockingMapped<QVector<MemFnTester> >(constMemFnTesterList, &MemFnTester::fnConst);
-
-    QtConcurrent::blockingMapped<QList<QString> >(intList, changeTypeConst);
-    QtConcurrent::blockingMapped<QList<QString> >(constIntList, changeTypeConst);
-    QtConcurrent::blockingMapped<QList<QString> >(classList, &MemFnTester::changeTypeConst);
-    QtConcurrent::blockingMapped<QList<QString> >(constMemFnTesterList, &MemFnTester::changeTypeConst);
-
-    QStringList stringList;
-    const QStringList constStringList;
-    // QtConcurrent::map(stringList, changeTypeQStringListConst);
-    // QtConcurrent::map(intList, changeTypeNonConst);
-    // QList<QString>(QtConcurrent::map(constStringList, changeTypeQStringList));
-    // QtConcurrent::map(classList, &MemFnTester::changeType);
-    // QtConcurrent::map(classList, &MemFnTester::changeTypeConst);
-    // QtConcurrent::map(constMemFnTesterList, &MemFnTester::changeTypeConst);
-}
-
-QAtomicInt currentInstanceCount;
-QAtomicInt peakInstanceCount;
-class InstanceCounter
-{
-public:
-    inline InstanceCounter()
-    { currentInstanceCount.fetchAndAddRelaxed(1); updatePeak(); }
-    inline ~InstanceCounter()
-    { currentInstanceCount.fetchAndAddRelaxed(-1);}
-    inline InstanceCounter(const InstanceCounter &)
-    { currentInstanceCount.fetchAndAddRelaxed(1); updatePeak(); }
-
-    void updatePeak()
-    {
-        forever {
-            const int localPeak = peakInstanceCount.load();
-            const int localCurrent = currentInstanceCount.load();
-            if (localCurrent <= localPeak)
-                break;
-            if (peakInstanceCount.testAndSetOrdered(localPeak, localCurrent))
-                break;
-        }
-    }
-};
-
-InstanceCounter slowMap(const InstanceCounter &in)
-{
-    QTest::qSleep(2);
-    return in;
-}
-
-InstanceCounter fastMap(const InstanceCounter &in)
-{
-    QTest::qSleep(rand() % 2 + 1);
-    return in;
-}
-
-void slowReduce(int &result, const InstanceCounter&)
-{
-    QTest::qSleep(rand() % 4 + 1);
-    ++result;
-}
-
-void fastReduce(int &result, const InstanceCounter&)
-{
-    ++result;
-}
-
-void tst_QtConcurrentMap::throttling()
-{
-    const int itemcount = 100;
-    const int allowedTemporaries = QThread::idealThreadCount() * 40;
-
-    {
-        currentInstanceCount.store(0);
-        peakInstanceCount.store(0);
-
-        QList<InstanceCounter> instances;
-        for (int i = 0; i < itemcount; ++i)
-            instances.append(InstanceCounter());
-
-        QCOMPARE(currentInstanceCount.load(), itemcount);
-
-        int results = QtConcurrent::blockingMappedReduced(instances, slowMap, fastReduce);
-        QCOMPARE(results, itemcount);
-        QCOMPARE(currentInstanceCount.load(), itemcount);
-        QVERIFY(peakInstanceCount.load() < itemcount + allowedTemporaries);
-    }
-
-    {
-        QCOMPARE(currentInstanceCount.load(), 0);
-        peakInstanceCount.store(0);
-
-        QList<InstanceCounter> instances;
-        for (int i = 0; i < itemcount; ++i)
-            instances.append(InstanceCounter());
-
-        QCOMPARE(currentInstanceCount.load(), itemcount);
-        int results = QtConcurrent::blockingMappedReduced(instances, fastMap, slowReduce);
-
-        QCOMPARE(results, itemcount);
-        QCOMPARE(currentInstanceCount.load(), itemcount);
-        QVERIFY(peakInstanceCount.load() < itemcount + allowedTemporaries);
-    }
-}
-
-#ifndef QT_NO_EXCEPTIONS
-void throwMapper(int &e)
-{
-    Q_UNUSED(e);
-    throw QtConcurrent::Exception();
-}
-
-void tst_QtConcurrentMap::exceptions()
-{
-    bool caught = false;
-    try  {
-        QList<int> list = QList<int>() << 1 << 2 << 3;
-        QtConcurrent::map(list, throwMapper).waitForFinished();
-    } catch (const Exception &) {
-        caught = true;
-    }
-    if (!caught)
-        QFAIL("did not get exception");
-}
-#endif
-
-int mapper(const int &i)
-{
-    QTest::qWait(1);
-    return i;
-}
-
-void tst_QtConcurrentMap::incrementalResults()
-{
-    const int count = 200;
-    QList<int> ints; 
-    for (int i=0; i < count; ++i)
-        ints << i;
-
-    QFuture<int> future = QtConcurrent::mapped(ints, mapper);
-    
-    QList<int> results;
-
-    while (future.isFinished() == false) {
-        for (int i = 0; i < future.resultCount(); ++i) {
-            results += future.resultAt(i);
-        }
-
-        QTest::qWait(1);
-    }
-
-    QCOMPARE(future.isFinished(), true);
-    QCOMPARE(future.resultCount(), count);
-    QCOMPARE(future.results().count(), count);
-}
-
-/*
-    Test that mapped does not cause deep copies when holding
-    references to Qt containers.
-*/
-void tst_QtConcurrentMap::noDetach()
-{
-    {
-        QList<int> l = QList<int>() << 1;
-        QVERIFY(l.isDetached());
-
-        QList<int> ll = l;
-        QVERIFY(l.isDetached() == false);
-
-        QtConcurrent::mapped(l, mapper).waitForFinished();
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-
-        QtConcurrent::mappedReduced(l, mapper, intSumReduce).waitForFinished();
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-
-        QtConcurrent::map(l, multiplyBy2Immutable).waitForFinished();
-        QVERIFY(l.isDetached() == true);
-        QVERIFY(ll.isDetached() == true);
-    }
-    {
-        const QList<int> l = QList<int>() << 1;
-        QVERIFY(l.isDetached());
-
-        const QList<int> ll = l;
-        QVERIFY(l.isDetached() == false);
-
-        QtConcurrent::mapped(l, mapper).waitForFinished();
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-
-        QtConcurrent::mappedReduced(l, mapper, intSumReduce).waitForFinished();
-
-        QVERIFY(l.isDetached() == false);
-        QVERIFY(ll.isDetached() == false);
-    }
-
-}
-
-#ifndef QT_NO_STL
-void tst_QtConcurrentMap::stlContainers()
-{
-    std::vector<int> vector;
-    vector.push_back(1);
-    vector.push_back(2);
-
-    std::vector<int> vector2 =  QtConcurrent::blockingMapped<std::vector<int> >(vector, mapper);
-    QCOMPARE(vector2.size(), (std::vector<int>::size_type)(2));
-
-    std::list<int> list;
-    list.push_back(1);
-    list.push_back(2);
-
-    std::list<int> list2 =  QtConcurrent::blockingMapped<std::list<int> >(list, mapper);
-    QCOMPARE(list2.size(), (std::vector<int>::size_type)(2));
-
-    QtConcurrent::mapped(list, mapper).waitForFinished();
-    
-    QtConcurrent::blockingMap(list, multiplyBy2Immutable);
-}
-#endif
-
-InstanceCounter ic_fn(const InstanceCounter & ic)
-{
-    return InstanceCounter(ic);
-};
-
-// Verify that held results are deleted when a future is
-// assigned over with operator ==
-void tst_QtConcurrentMap::qFutureAssignmentLeak()
-{
-    currentInstanceCount.store(0);
-    peakInstanceCount.store(0);
-    QFuture<InstanceCounter> future;
-    {
-        QList<InstanceCounter> list;
-        for (int i=0;i<1000;++i)
-            list += InstanceCounter();
-        future = QtConcurrent::mapped(list, ic_fn);
-        future.waitForFinished();
-
-        future = QtConcurrent::mapped(list, ic_fn);
-        future.waitForFinished();
-
-        future = QtConcurrent::mapped(list, ic_fn);
-        future.waitForFinished();
-    }
-
-    QCOMPARE(currentInstanceCount.load(), 1000);
-    future = QFuture<InstanceCounter>();
-    QCOMPARE(currentInstanceCount.load(), 0);
-}
-
-inline void increment(int &num)
-{
-    ++num;
-}
-
-inline int echo(const int &num)
-{
-    return num;
-}
-
-void add(int &result, const int &sum)
-{
-    result += sum;
-}
-
-void tst_QtConcurrentMap::stressTest()
-{
-    const int listSize = 1000;
-    const int sum = (listSize - 1) * (listSize / 2);
-    QList<int> list;
-
-
-    for (int i = 0; i < listSize; ++i) {
-        list.append(i);
-    }
-
-    for (int i =0 ; i < 100; ++i) {
-        QList<int> result = QtConcurrent::blockingMapped(list, echo);
-        for (int j = 0; j < listSize; ++j)
-            QCOMPARE(result.at(j), j);
-    }
-
-    for (int i = 0 ; i < 100; ++i) {
-        int result = QtConcurrent::blockingMappedReduced(list, echo, add);
-        QCOMPARE(result, sum);
-    }
-
-    for (int i = 0 ; i < 100; ++i) {
-        QtConcurrent::map(list, increment).waitForFinished();
-        for (int j = 0; j < listSize; ++j)
-            QCOMPARE(list.at(j), i + j + 1);
-    }
-}
-
-#endif
-
-QTEST_MAIN(tst_QtConcurrentMap)
-#include "tst_qtconcurrentmap.moc"
diff --git a/tests/auto/corelib/concurrent/qtconcurrentresultstore/qtconcurrentresultstore.pro b/tests/auto/corelib/concurrent/qtconcurrentresultstore/qtconcurrentresultstore.pro
deleted file mode 100644
index e93fc58..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentresultstore/qtconcurrentresultstore.pro
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qtconcurrentresultstore
-QT = core-private testlib
-SOURCES = tst_qtconcurrentresultstore.cpp
-DEFINES += QT_STRICT_ITERATORS
diff --git a/tests/auto/corelib/concurrent/qtconcurrentresultstore/tst_qtconcurrentresultstore.cpp b/tests/auto/corelib/concurrent/qtconcurrentresultstore/tst_qtconcurrentresultstore.cpp
deleted file mode 100644
index 236d0b6..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentresultstore/tst_qtconcurrentresultstore.cpp
+++ /dev/null
@@ -1,490 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QtTest/QtTest>
-
-#include <qtconcurrentresultstore.h>
-
-using namespace QtConcurrent;
-
-class tst_QtConcurrentResultStore : public QObject
-{
-    Q_OBJECT
-public slots:
-    void init();
-private slots:
-    void construction();
-    void iterators();
-    void addResult();
-    void addResults();
-    void resultIndex();
-    void resultAt();
-    void contains();
-    void filterMode();
-    void addCanceledResult();
-    void count();
-private:
-    int int0;
-    int int1;
-    int int2;
-    QVector<int> vec0;
-    QVector<int> vec1;
-};
-
-void tst_QtConcurrentResultStore::init()
-{
-    int0 = 0;
-    int1 = 1;
-    int2 = 2;
-    vec0 = QVector<int>() << 2 << 3;
-    vec1 = QVector<int>() << 4 << 5;
-}
-
-void tst_QtConcurrentResultStore::construction()
-{
-    ResultStore<int> store;
-    QCOMPARE(store.count(), 0);
-}
-
-void tst_QtConcurrentResultStore::iterators()
-{
-    {
-        ResultStore<int> store;
-        QVERIFY(store.begin() == store.end());
-        QVERIFY(store.resultAt(0) == store.end());
-        QVERIFY(store.resultAt(1) == store.end());
-    }
-    {
-        ResultStoreBase storebase;
-        storebase.addResult(-1, &int0); // note to self: adding a pointer to the stack here is ok since
-        storebase.addResult(1, &int1);  // ResultStoreBase does not take ownership, only ResultStore<> does.
-        ResultIteratorBase it = storebase.begin();
-        QCOMPARE(it.resultIndex(), 0);
-        QVERIFY(it == storebase.begin());
-        QVERIFY(it != storebase.end());
-
-        ++it;
-        QCOMPARE(it.resultIndex(), 1);
-        QVERIFY(it != storebase.begin());
-        QVERIFY(it != storebase.end());
-
-        ++it;
-        QVERIFY(it != storebase.begin());
-        QVERIFY(it == storebase.end());
-    }
-}
-
-void tst_QtConcurrentResultStore::addResult()
-{
-    {
-        // test addResult return value
-        ResultStore<int> store;
-        store.setFilterMode(true);
-
-        QCOMPARE(store.addResult(0, &int0), 0);
-        QCOMPARE(store.count(), 1); // result 0 becomes available
-        QCOMPARE(store.contains(0), true);
-
-        QCOMPARE(store.addResult(2, &int0), 2);
-        QCOMPARE(store.count(), 1);
-        QCOMPARE(store.contains(2), false);
-
-        QCOMPARE(store.addCanceledResult(1), 1);
-        QCOMPARE(store.count(), 2); // result 2 is renamed to 1 and becomes available
-
-        QCOMPARE(store.contains(0), true);
-        QCOMPARE(store.contains(1), true);
-        QCOMPARE(store.contains(2), false);
-
-        QCOMPARE(store.addResult(3, &int0), 3);
-        QCOMPARE(store.count(), 3);
-        QCOMPARE(store.contains(2), true);
-
-        QCOMPARE(store.addResult(6, &int0), 6);
-        QCOMPARE(store.count(), 3);
-        QCOMPARE(store.addResult(7, &int0), 7);
-        QCOMPARE(store.count(), 3);
-        QCOMPARE(store.contains(3), false);
-
-        QCOMPARE(store.addCanceledResult(4), 4);
-        QCOMPARE(store.addCanceledResult(5), 5);
-        QCOMPARE(store.count(), 5); // 6 and 7 is renamed to 3 and 4 and becomes available
-
-        QCOMPARE(store.contains(3), true);
-        QCOMPARE(store.contains(4), true);
-
-        QCOMPARE(store.addResult(8, &int0), 8);
-        QCOMPARE(store.contains(5), true);
-        QCOMPARE(store.count(), 6);
-
-        QCOMPARE(store.contains(6), false);
-        QCOMPARE(store.contains(7), false);
-    }
-}
-
-void tst_QtConcurrentResultStore::addResults()
-{
-
-    ResultStoreBase store;
-    store.addResults(-1, &vec0, 2, 2);
-    store.addResults(-1, &vec1, 2, 2);
-    ResultIteratorBase it = store.begin();
-    QCOMPARE(it.resultIndex(), 0);
-    QVERIFY(it == store.begin());
-    QVERIFY(it != store.end());
-
-    ++it;
-    QCOMPARE(it.resultIndex(), 1);
-    QVERIFY(it != store.begin());
-    QVERIFY(it != store.end());
-
-    ++it;
-    QCOMPARE(it.resultIndex(), 2);
-
-    ++it;
-    QCOMPARE(it.resultIndex(), 3);
-
-    ++it;
-    QVERIFY(it == store.end());
-}
-
-void tst_QtConcurrentResultStore::resultIndex()
-{
-    ResultStore<int> store;
-    store.addResult(-1, &int0);
-    store.addResults(-1, &vec0);
-    store.addResult(-1, &int1);
-
-    ResultIteratorBase it = store.begin();
-    QCOMPARE(it.resultIndex(), 0);
-    QVERIFY(it == store.begin());
-    QVERIFY(it != store.end());
-
-    ++it;
-    QCOMPARE(it.resultIndex(), 1);
-    QVERIFY(it != store.begin());
-    QVERIFY(it != store.end());
-
-    ++it;
-    QCOMPARE(it.resultIndex(), 2);
-    QVERIFY(it != store.end());
-    ++it;
-    QCOMPARE(it.resultIndex(), 3);
-    QVERIFY(it != store.end());
-    ++it;
-    QVERIFY(it == store.end());
-
-    QCOMPARE(store.resultAt(0).value(), int0);
-    QCOMPARE(store.resultAt(1).value(), vec0[0]);
-    QCOMPARE(store.resultAt(2).value(), vec0[1]);
-    QCOMPARE(store.resultAt(3).value(), int1);
-}
-
-void tst_QtConcurrentResultStore::resultAt()
-{
-    {
-        ResultStore<int> store;
-        store.addResult(-1, &int0);
-        store.addResults(-1, &vec0);
-        store.addResult(200, &int1);
-
-        QCOMPARE(store.resultAt(0).value(), int0);
-        QCOMPARE(store.resultAt(1).value(), vec0[0]);
-        QCOMPARE(store.resultAt(2).value(), vec0[1]);
-        QCOMPARE(store.resultAt(200).value(), int1);
-    }
-    {
-        ResultStore<int> store;
-        store.addResult(1, &int1);
-        store.addResult(0, &int0);
-        store.addResult(-1, &int2);
-
-        QCOMPARE(store.resultAt(0).value(), int0);
-        QCOMPARE(store.resultAt(1).value(), int1);
-        QCOMPARE(store.resultAt(2).value(), int2);
-    }
-}
-
-void tst_QtConcurrentResultStore::contains()
-{
-    {
-        ResultStore<int> store;
-        QCOMPARE(store.contains(0), false);
-        QCOMPARE(store.contains(1), false);
-        QCOMPARE(store.contains(INT_MAX), false);
-        store.addResult(1, &int1);
-        QVERIFY(store.contains(int1));
-        store.addResult(0, &int0);
-        QVERIFY(store.contains(int0));
-        store.addResult(-1, &int2);
-        QVERIFY(store.contains(int2));
-    }
-    {
-        ResultStore<int> store;
-        store.addResult(1, &int0);
-        store.addResult(3, &int0);
-        store.addResults(6, &vec0);
-        QCOMPARE(store.contains(0), false);
-        QCOMPARE(store.contains(1), true);
-        QCOMPARE(store.contains(2), false);
-        QCOMPARE(store.contains(3), true);
-        QCOMPARE(store.contains(4), false);
-        QCOMPARE(store.contains(5), false);
-        QCOMPARE(store.contains(6), true);
-        QCOMPARE(store.contains(7), true);
-    }
-
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addResult(1, &int0);
-        store.addResult(3, &int0);
-        store.addResults(6, &vec0);
-        QCOMPARE(store.contains(0), false);
-        QCOMPARE(store.contains(1), false);
-        QCOMPARE(store.contains(2), false);
-        QCOMPARE(store.contains(3), false);
-        QCOMPARE(store.contains(4), false);
-        QCOMPARE(store.contains(5), false);
-        QCOMPARE(store.contains(6), false);
-        QCOMPARE(store.contains(7), false);
-
-        store.addCanceledResult(0);
-        store.addCanceledResult(2);
-        store.addCanceledResults(4, 2);
-
-        QCOMPARE(store.contains(0), true);
-        QCOMPARE(store.contains(1), true);
-        QCOMPARE(store.contains(2), true);
-        QCOMPARE(store.contains(3), true);
-        QCOMPARE(store.contains(4), false);
-        QCOMPARE(store.contains(5), false);
-        QCOMPARE(store.contains(6), false);
-        QCOMPARE(store.contains(7), false);
-    }
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addCanceledResult(0);
-        QCOMPARE(store.contains(0), false);
-
-        store.addResult(1, &int0);
-        QCOMPARE(store.contains(0), true);
-        QCOMPARE(store.contains(1), false);
-    }
-}
-
-void tst_QtConcurrentResultStore::filterMode()
-{
-    // Test filter mode, where "gaps" in the result array aren't allowed.
-    ResultStore<int> store;
-    QCOMPARE(store.filterMode(), false);
-    store.setFilterMode(true);
-    QVERIFY(store.filterMode());
-
-    store.addResult(0, &int0);
-    QCOMPARE(store.contains(0), true);
-
-    store.addResult(2, &int2); // add result at index 2
-    QCOMPARE(store.contains(2), false); // but 1 is missing, so this 2 won't be reported yet.
-
-    store.addResult(1, &int1);
-    QCOMPARE(store.contains(1), true);
-    QCOMPARE(store.contains(2), true); // 2 should be visible now.
-
-    store.addResult(4, &int0);
-    store.addResult(5, &int0);
-    store.addResult(7, &int0);
-    QCOMPARE(store.contains(4), false);
-    QCOMPARE(store.contains(5), false);
-    QCOMPARE(store.contains(7), false);
-
-    store.addResult(3, &int0);  // adding 3 makes 4 and 5 visible
-    QCOMPARE(store.contains(4), true);
-    QCOMPARE(store.contains(5), true);
-    QCOMPARE(store.contains(7), false);
-
-    store.addResult(6, &int0);  // adding 6 makes 7 visible
-
-    QCOMPARE(store.contains(6), true);
-    QCOMPARE(store.contains(7), true);
-    QCOMPARE(store.contains(8), false);
-}
-
-void tst_QtConcurrentResultStore::addCanceledResult()
-{
-    // test canceled results
-    ResultStore<int> store;
-    store.setFilterMode(true);
-
-    store.addResult(0, &int0);
-    QCOMPARE(store.contains(0), true);
-
-    store.addResult(2, &int0);
-    QCOMPARE(store.contains(2), false);
-
-    store.addCanceledResult(1); // report no result at 1
-
-    QCOMPARE(store.contains(0), true);
-    QCOMPARE(store.contains(1), true); // 2 gets renamed to 1
-    QCOMPARE(store.contains(2), false);
-
-    store.addResult(3, &int0);
-    QCOMPARE(store.contains(2), true); //3 gets renamed to 2
-
-    store.addResult(6, &int0);
-    store.addResult(7, &int0);
-    QCOMPARE(store.contains(3), false);
-
-    store.addCanceledResult(4);
-    store.addCanceledResult(5);
-
-    QCOMPARE(store.contains(3), true); //6 gets renamed to 3
-    QCOMPARE(store.contains(4), true); //7 gets renamed to 4
-
-    store.addResult(8, &int0);
-    QCOMPARE(store.contains(5), true); //8 gets renamed to 4
-
-    QCOMPARE(store.contains(6), false);
-    QCOMPARE(store.contains(7), false);
-}
-
-void tst_QtConcurrentResultStore::count()
-{
-    {
-        // test resultCount in non-filtered mode. It should always be possible
-        // to iterate through the results 0 to resultCount.
-        ResultStore<int> store;
-        store.addResult(0, &int0);
-
-        QCOMPARE(store.count(), 1);
-
-        store.addResult(2, &int0);
-
-        QCOMPARE(store.count(), 1);
-
-        store.addResult(1, &int0);
-        QCOMPARE(store.count(), 3);
-    }
-
-    {
-        ResultStore<int> store;
-        store.addResult(2, &int0);
-        QCOMPARE(store.count(), 0);
-
-        store.addResult(1, &int0);
-        QCOMPARE(store.count(), 0);
-
-        store.addResult(0, &int0);
-        QCOMPARE(store.count(), 3);
-    }
-
-    {
-        ResultStore<int> store;
-        store.addResults(2, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addResult(1, &int0);
-        QCOMPARE(store.count(), 0);
-
-        store.addResult(0, &int0);
-        QCOMPARE(store.count(), 4);
-    }
-
-    {
-        ResultStore<int> store;
-        store.addResults(2, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addResults(0, &vec0);
-        QCOMPARE(store.count(), 4);
-    }
-    {
-        ResultStore<int> store;
-        store.addResults(3, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addResults(0, &vec0);
-        QCOMPARE(store.count(), 2);
-
-        store.addResult(2, &int0);
-        QCOMPARE(store.count(), 5);
-    }
-
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addResults(3, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addResults(0, &vec0);
-        QCOMPARE(store.count(), 2);
-
-        store.addCanceledResult(2);
-        QCOMPARE(store.count(), 4);
-    }
-
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addResults(3, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addCanceledResults(0, 3);
-        QCOMPARE(store.count(), 2);
-    }
-
-    {
-        ResultStore<int> store;
-        store.setFilterMode(true);
-        store.addResults(3, &vec1);
-        QCOMPARE(store.count(), 0);
-
-        store.addCanceledResults(0, 3);
-        QCOMPARE(store.count(), 2);  // results at 3 and 4 become available at index 0, 1
-
-        store.addResult(5, &int0);
-        QCOMPARE(store.count(), 3);// result 5 becomes available at index 2
-    }
-}
-
-QTEST_MAIN(tst_QtConcurrentResultStore)
-#include "tst_qtconcurrentresultstore.moc"
diff --git a/tests/auto/corelib/concurrent/qtconcurrentrun/.gitignore b/tests/auto/corelib/concurrent/qtconcurrentrun/.gitignore
deleted file mode 100644
index d7a8334..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentrun/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qtconcurrentrun
diff --git a/tests/auto/corelib/concurrent/qtconcurrentrun/qtconcurrentrun.pro b/tests/auto/corelib/concurrent/qtconcurrentrun/qtconcurrentrun.pro
deleted file mode 100644
index d4f130f..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentrun/qtconcurrentrun.pro
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qtconcurrentrun
-QT = core testlib
-SOURCES = tst_qtconcurrentrun.cpp
diff --git a/tests/auto/corelib/concurrent/qtconcurrentrun/tst_qtconcurrentrun.cpp b/tests/auto/corelib/concurrent/qtconcurrentrun/tst_qtconcurrentrun.cpp
deleted file mode 100644
index 86e3433..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentrun/tst_qtconcurrentrun.cpp
+++ /dev/null
@@ -1,463 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <qtconcurrentrun.h>
-#include <qfuture.h>
-#include <QString>
-#include <QtTest/QtTest>
-
-using namespace QtConcurrent;
-
-class tst_QtConcurrentRun: public QObject
-{
-    Q_OBJECT
-private slots:
-    void runLightFunction();
-    void runHeavyFunction();
-    void returnValue();
-    void functionObject();
-    void memberFunctions();
-    void implicitConvertibleTypes();
-    void runWaitLoop();
-    void recursive();
-#ifndef QT_NO_EXCEPTIONS
-    void exceptions();
-#endif
-    void functor();
-    void lambda();
-};
-
-void light()
-{
-    qDebug("in function");
-    qDebug("done function");
-}
-
-void heavy()
-{
-    qDebug("in function");
-    QString str;
-    for (int i = 0; i < 1000000; ++i)
-        str.append("a");
-    qDebug("done function");
-}
-
-
-void tst_QtConcurrentRun::runLightFunction()
-{
-    qDebug("starting function");
-    QFuture<void> future = run(light);
-    qDebug("waiting");
-    future.waitForFinished();
-    qDebug("done");
-}
-
-void tst_QtConcurrentRun::runHeavyFunction()
-{
-    qDebug("starting function");
-    QFuture<void> future = run(heavy);
-    qDebug("waiting");
-    future.waitForFinished();
-    qDebug("done");
-}
-
-int returnInt0()
-{
-    return 10;
-}
-
-int returnInt1(int i)
-{
-    return i;
-}
-
-class A
-{
-public:
-    int member0() { return 10; }
-    int member1(int in) { return in; }
-
-    typedef int result_type;
-    int operator()() { return 10; }
-    int operator()(int in) { return in; }
-};
-
-class AConst
-{
-public:
-    int member0() const { return 10; }
-    int member1(int in) const { return in; }
-
-    typedef int result_type;
-    int operator()() const { return 10; }
-    int operator()(int in) const { return in; }
-};
-
-void tst_QtConcurrentRun::returnValue()
-{
-    QFuture<int> f;
-    
-    f = run(returnInt0);
-    QCOMPARE(f.result(), 10);
-    
-    A a;
-    f = run(&a, &A::member0);
-    QCOMPARE(f.result(), 10);
-
-    f = run(&a, &A::member1, 20);
-    QCOMPARE(f.result(), 20);
-
-    f = run(a, &A::member0);
-    QCOMPARE(f.result(), 10);
-
-    f = run(a, &A::member1, 20);
-    QCOMPARE(f.result(), 20);
-
-    f = run(a);
-    QCOMPARE(f.result(), 10);
-
-    f = run(&a);
-    QCOMPARE(f.result(), 10);
-
-    f = run(a, 20);
-    QCOMPARE(f.result(), 20);
-
-    f = run(&a, 20);
-    QCOMPARE(f.result(), 20);
-
-    const AConst aConst = AConst();
-    f = run(&aConst, &AConst::member0);
-    QCOMPARE(f.result(), 10);
-
-    f = run(&aConst, &AConst::member1, 20);
-    QCOMPARE(f.result(), 20);
-
-    f = run(aConst, &AConst::member0);
-    QCOMPARE(f.result(), 10);
-
-    f = run(aConst, &AConst::member1, 20);
-    QCOMPARE(f.result(), 20);
-
-    f = run(aConst);
-    QCOMPARE(f.result(), 10);
-
-    f = run(&aConst);
-    QCOMPARE(f.result(), 10);
-
-    f = run(aConst, 20);
-    QCOMPARE(f.result(), 20);
-
-    f = run(&aConst, 20);
-    QCOMPARE(f.result(), 20);
-}
-
-struct TestClass
-{
-    void foo() { }
-    typedef void result_type;
-    void operator()() { }
-    void operator()(int) { }
-    void fooInt(int){ };
-};
-
-struct TestConstClass
-{
-    void foo() const { }
-    typedef void result_type;
-    void operator()() const { }
-    void operator()(int) const { }
-    void fooInt(int) const { };
-};
-
-void tst_QtConcurrentRun::functionObject()
-{
-    QFuture<void> f;
-    TestClass c;
-    
-    f = run(c);
-    f = run(&c);
-    f = run(c, 10);
-    f = run(&c, 10);
-
-    const TestConstClass cc = TestConstClass();
-    f = run(cc);
-    f = run(&cc);
-    f = run(cc, 10);
-    f = run(&cc, 10);
-}
-
-
-void tst_QtConcurrentRun::memberFunctions()
-{
-    TestClass c;
-
-    run(c, &TestClass::foo).waitForFinished();
-    run(&c, &TestClass::foo).waitForFinished();
-    run(c, &TestClass::fooInt, 10).waitForFinished();
-    run(&c, &TestClass::fooInt, 10).waitForFinished();
-
-    const TestConstClass cc = TestConstClass();
-    run(cc, &TestConstClass::foo).waitForFinished();
-    run(&cc, &TestConstClass::foo).waitForFinished();
-    run(cc, &TestConstClass::fooInt, 10).waitForFinished();
-    run(&cc, &TestConstClass::fooInt, 10).waitForFinished();
-}
-
-
-void doubleFunction(double)
-{
-
-}
-
-void stringConstRefFunction(const QString &)
-{
-
-}
-
-void stringRefFunction(QString &)
-{
-
-}
-
-void stringFunction(QString)
-{
-
-}
-
-void stringIntFunction(QString)
-{
-
-}
-
-
-void tst_QtConcurrentRun::implicitConvertibleTypes()
-{
-    double d;
-    run(doubleFunction, d).waitForFinished();
-    int i;
-    run(doubleFunction, d).waitForFinished();
-    run(doubleFunction, i).waitForFinished();
-    run(doubleFunction, 10).waitForFinished();
-    run(stringFunction, QLatin1String("Foo")).waitForFinished();
-    run(stringConstRefFunction, QLatin1String("Foo")).waitForFinished();
-    QString string;
-    run(stringRefFunction, string).waitForFinished();
-}
-
-void fn() { }
-
-void tst_QtConcurrentRun::runWaitLoop()
-{
-    for (int i = 0; i < 1000; ++i)
-        run(fn).waitForFinished();
-}
-
-QAtomicInt count;
-
-void recursiveRun(int level)
-{
-    count.ref();
-    if (--level > 0) {
-        QFuture<void> f1 = run(recursiveRun, level);
-        QFuture<void> f2 = run(recursiveRun, level);
-        f1.waitForFinished();
-        f2.waitForFinished();
-    }
-}
-
-int recursiveResult(int level)
-{
-    count.ref();
-    if (--level > 0) {
-        QFuture<int> f1 = run(recursiveResult, level);
-        QFuture<int> f2 = run(recursiveResult, level);
-        return f1.result() + f2.result();
-    }
-    return 1;
-}
-
-void tst_QtConcurrentRun::recursive()
-{
-    int levels = 15;
-
-    for (int i = 0; i < QThread::idealThreadCount(); ++i) {
-        count.store(0);
-        QThreadPool::globalInstance()->setMaxThreadCount(i);
-        recursiveRun(levels);
-        QCOMPARE(count.load(), (int)pow(2.0, levels) - 1);
-    }
-
-    for (int i = 0; i < QThread::idealThreadCount(); ++i) {
-        count.store(0);
-        QThreadPool::globalInstance()->setMaxThreadCount(i);
-        recursiveResult(levels);
-        QCOMPARE(count.load(), (int)pow(2.0, levels) - 1);
-    }
-}
-
-int e;
-void vfn0()
-{
-    ++e;
-}
-
-int fn0()
-{
-    return 1;
-}
-
-void vfn1(double)
-{
-    ++e;
-}
-
-int fn1(int)
-{
-    return 1;
-}
-
-void vfn2(double, int *)
-{
-    ++e;
-}
-
-int fn2(double, int *)
-{
-    return 1;
-}
-
-
-#ifndef QT_NO_EXCEPTIONS
-void throwFunction()
-{
-    throw QtConcurrent::Exception();
-}
-
-int throwFunctionReturn()
-{
-    throw QtConcurrent::Exception();
-    return 0;
-}
-
-void tst_QtConcurrentRun::exceptions()
-{
-    bool caught = false;
-    try  {
-        QtConcurrent::run(throwFunction).waitForFinished();
-    } catch (Exception &e) {
-        caught = true;
-    }
-    if (!caught)
-        QFAIL("did not get exception");
-
-    caught = false;
-    try  {
-        QtConcurrent::run(throwFunctionReturn).waitForFinished();
-    } catch (Exception &e) {
-        caught = true;
-    }
-    if (!caught)
-        QFAIL("did not get exception");
-}
-#endif
-
-struct Functor {
-    int operator()() { return 42; }
-    double operator()(double a, double b) { return a/b; }
-    int operator()(int a, int b) { return a/b; }
-    void operator()(int) { }
-    void operator()(int, int, int) { }
-    void operator()(int, int, int, int) { }
-    void operator()(int, int, int, int, int) { }
-    void operator()(int, int, int, int, int, int) { }
-};
-
-// This tests functor without result_type; decltype need to be supported by the compiler.
-void tst_QtConcurrentRun::functor()
-{
-#ifndef Q_COMPILER_DECLTYPE
-    QSKIP("Compiler does not support decltype");
-#else
-    Functor f;
-    {
-        QFuture<int> fut = QtConcurrent::run(f);
-        QCOMPARE(fut.result(), 42);
-    }
-    {
-        QFuture<double> fut = QtConcurrent::run(f, 8.5, 1.8);
-        QCOMPARE(fut.result(), (8.5/1.8));
-    }
-    {
-        QFuture<int> fut = QtConcurrent::run(f, 19, 3);
-        QCOMPARE(fut.result(), int(19/3));
-    }
-    {
-        QtConcurrent::run(f, 1).waitForFinished();
-        QtConcurrent::run(f, 1,2).waitForFinished();
-        QtConcurrent::run(f, 1,2,3).waitForFinished();
-        QtConcurrent::run(f, 1,2,3,4).waitForFinished();
-        QtConcurrent::run(f, 1,2,3,4,5).waitForFinished();
-    }
-#endif
-}
-
-void tst_QtConcurrentRun::lambda()
-{
-#ifndef Q_COMPILER_LAMBDA
-    QSKIP("Compiler does not support lambda");
-#else
-    QCOMPARE(QtConcurrent::run([](){ return 45; }).result(), 45);
-    QCOMPARE(QtConcurrent::run([](int a){ return a+15; }, 12).result(), 12+15);
-    QCOMPARE(QtConcurrent::run([](int a, double b){ return a + b; }, 12, 15).result(), double(12+15));
-    QCOMPARE(QtConcurrent::run([](int a , int, int, int, int b){ return a + b; }, 1, 2, 3, 4, 5).result(), 1 + 5);
-
-#ifdef Q_COMPILER_INITIALIZER_LISTS
-    {
-        QString str { "Hello World Foo" };
-        QFuture<QStringList> f1 = QtConcurrent::run([&](){ return str.split(' '); });
-        auto r = f1.result();
-        QCOMPARE(r, QStringList({"Hello", "World", "Foo"}));
-    }
-#endif
-#endif
-}
-
-QTEST_MAIN(tst_QtConcurrentRun)
-#include "tst_qtconcurrentrun.moc"
diff --git a/tests/auto/corelib/concurrent/qtconcurrentthreadengine/.gitignore b/tests/auto/corelib/concurrent/qtconcurrentthreadengine/.gitignore
deleted file mode 100644
index a2e2896..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentthreadengine/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qtconcurrentthreadengine
diff --git a/tests/auto/corelib/concurrent/qtconcurrentthreadengine/qtconcurrentthreadengine.pro b/tests/auto/corelib/concurrent/qtconcurrentthreadengine/qtconcurrentthreadengine.pro
deleted file mode 100644
index 536ccc3..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentthreadengine/qtconcurrentthreadengine.pro
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qtconcurrentthreadengine
-QT = core testlib
-SOURCES = tst_qtconcurrentthreadengine.cpp
diff --git a/tests/auto/corelib/concurrent/qtconcurrentthreadengine/tst_qtconcurrentthreadengine.cpp b/tests/auto/corelib/concurrent/qtconcurrentthreadengine/tst_qtconcurrentthreadengine.cpp
deleted file mode 100644
index 9722887..0000000
--- a/tests/auto/corelib/concurrent/qtconcurrentthreadengine/tst_qtconcurrentthreadengine.cpp
+++ /dev/null
@@ -1,520 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <qtconcurrentthreadengine.h>
-#include <qtconcurrentexception.h>
-#include <QThread>
-#include <QtTest/QtTest>
-
-using namespace QtConcurrent;
-
-class tst_QtConcurrentThreadEngine: public QObject
-{
-    Q_OBJECT
-private slots:
-    void runDirectly();
-    void result();
-    void runThroughStarter();
-    void cancel();
-    void throttle();
-    void threadCount();
-    void multipleResults();
-    void stresstest();
-    void cancelQueuedSlowUser();
-#ifndef QT_NO_EXCEPTIONS
-    void exceptions();
-#endif
-};
-
-
-class PrintUser : public ThreadEngine<void>
-{
-public:
-    ThreadFunctionResult threadFunction()
-    {
-        QTest::qSleep(50);
-        QTest::qSleep(100);
-        return ThreadFinished;
-    }
-};
-
-void tst_QtConcurrentThreadEngine::runDirectly()
-{
-    {
-        PrintUser engine;
-        engine.startSingleThreaded();
-        engine.startBlocking();
-    }
-    {
-        PrintUser *engine = new PrintUser();
-        QFuture<void> f = engine->startAsynchronously();
-        f.waitForFinished();
-    }
-}
-
-class StringResultUser : public ThreadEngine<QString>
-{
-public:
-    typedef QString ResultType;
-    StringResultUser()
-    : done(false) { }
-
-    bool shouldStartThread()
-    {
-        return !done;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        done = true;
-        return ThreadFinished;
-    }
-
-    QString *result()
-    {
-        foo = "Foo";
-        return &foo;
-    }
-    QString foo;
-    bool done;
-};
-
-void tst_QtConcurrentThreadEngine::result()
-{
-    StringResultUser engine;
-    QCOMPARE(*engine.startBlocking(), QString("Foo"));
-}
-
-class VoidResultUser : public ThreadEngine<void>
-{
-public:
-    bool shouldStartThread()
-    {
-        return !done;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        done = true;
-        return ThreadFinished;
-    }
-
-    void *result()
-    {
-        return 0;
-    }
-    bool done;
-};
-
-void tst_QtConcurrentThreadEngine::runThroughStarter()
-{
-    {
-        ThreadEngineStarter<QString> starter = startThreadEngine(new StringResultUser());
-        QFuture<QString>  f = starter.startAsynchronously();
-        QCOMPARE(f.result(), QString("Foo"));
-    }
-
-    {
-        ThreadEngineStarter<QString> starter = startThreadEngine(new StringResultUser());
-        QString str = starter.startBlocking();
-        QCOMPARE(str, QString("Foo"));
-    }
-}
-
-class CancelUser : public ThreadEngine<void>
-{
-public:
-    void *result()
-    {
-        return 0;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        while (this->isCanceled() == false)
-        {
-            QTest::qSleep(10);
-        }
-        return ThreadFinished;
-    }
-};
-
-void tst_QtConcurrentThreadEngine::cancel()
-{
-    {
-        CancelUser *engine = new CancelUser();
-        QFuture<void> f = engine->startAsynchronously();
-        f.cancel();
-        f.waitForFinished();
-    }
-    {
-        CancelUser *engine = new CancelUser();
-        QFuture<void> f = engine->startAsynchronously();
-        QTest::qSleep(10);
-        f.cancel();
-        f.waitForFinished();
-    }
-}
-
-QAtomicInt count;
-class ThrottleAlwaysUser : public ThreadEngine<void>
-{
-public:
-    ThrottleAlwaysUser()
-    {
-        count.store(initialCount = 100);
-        finishing = false;
-    }
-
-    bool shouldStartThread()
-    {
-        return !finishing;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        forever {
-            const int local = count.load();
-            if (local == 0) {
-                finishing = true;
-                return ThreadFinished;
-            }
-
-            if (count.testAndSetOrdered(local, local - 1))
-                break;
-        }
-        return ThrottleThread;
-    }
-
-    bool finishing;
-    int initialCount;
-};
-
-// Test that a user task with a thread function that always
-// want to be throttled still completes. The thread engine
-// should make keep one thread running at all times.
-void tst_QtConcurrentThreadEngine::throttle()
-{
-    const int repeats = 10;
-    for (int i = 0; i < repeats; ++i) {
-        QFuture<void> f = (new ThrottleAlwaysUser())->startAsynchronously();
-        f.waitForFinished();
-        QCOMPARE(count.load(), 0);
-    }
-
-    for (int i = 0; i < repeats; ++i) {
-        ThrottleAlwaysUser t;
-        t.startBlocking();
-        QCOMPARE(count.load(), 0);
-    }
-}
-
-QSet<QThread *> threads;
-QMutex mutex;
-class ThreadCountUser : public ThreadEngine<void>
-{
-public:
-    ThreadCountUser(bool finishImmediately = false)
-    {
-        threads.clear();
-        finishing = finishImmediately;
-    }
-
-    bool shouldStartThread()
-    {
-        return !finishing;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        {
-            QMutexLocker lock(&mutex);
-            threads.insert(QThread::currentThread());
-        }
-        QTest::qSleep(10);
-        finishing = true;
-        return ThreadFinished;
-    }
-
-    bool finishing;
-};
-
-void tst_QtConcurrentThreadEngine::threadCount()
-{
-    QSKIP("QTBUG-23333: This test is unstable");
-
-    const int repeats = 10;
-    for (int i = 0; i < repeats; ++i) {
-        ThreadCountUser t;
-        t.startBlocking();
-        QCOMPARE(threads.count(), QThreadPool::globalInstance()->maxThreadCount() + 1); // +1 for the main thread.
-
-        (new ThreadCountUser())->startAsynchronously().waitForFinished();
-        QCOMPARE(threads.count(), QThreadPool::globalInstance()->maxThreadCount());
-    }
-
-    // Set the finish flag immediately, this should give us one thread only.
-    for (int i = 0; i < repeats; ++i) {
-        ThreadCountUser t(true /*finishImmediately*/);
-        t.startBlocking();
-        QCOMPARE(threads.count(), 1);
-
-        (new ThreadCountUser(true /*finishImmediately*/))->startAsynchronously().waitForFinished();
-        QCOMPARE(threads.count(), 1);
-    }
-}
-
-class MultipleResultsUser : public ThreadEngine<int>
-{
-public:
-    bool shouldStartThread()
-    {
-        return false;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        for (int i = 0; i < 10; ++i)
-            this->reportResult(&i);
-        return ThreadFinished;
-    }
-};
-
-
-void tst_QtConcurrentThreadEngine::multipleResults()
-{
-    MultipleResultsUser *engine =  new MultipleResultsUser();
-    QFuture<int> f = engine->startAsynchronously();
-    QCOMPARE(f.results().count() , 10);
-    QCOMPARE(f.resultAt(0), 0);
-    QCOMPARE(f.resultAt(5), 5);
-    QCOMPARE(f.resultAt(9), 9);
-    f.waitForFinished();
-}
-
-
-class NoThreadsUser : public ThreadEngine<void>
-{
-public:
-    bool shouldStartThread()
-    {
-        return false;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        return ThreadFinished;
-    }
-
-    void *result()
-    {
-        return 0;
-    }
-};
-
-void tst_QtConcurrentThreadEngine::stresstest()
-{
-    const int times = 20000;
-
-    for (int i = 0; i < times; ++i) {
-        VoidResultUser *engine = new VoidResultUser();
-        engine->startAsynchronously().waitForFinished();
-    }
-
-    for (int i = 0; i < times; ++i) {
-        VoidResultUser *engine = new VoidResultUser();
-        engine->startAsynchronously();
-    }
-
-    for (int i = 0; i < times; ++i) {
-        VoidResultUser *engine = new VoidResultUser();
-        engine->startAsynchronously().waitForFinished();
-    }
-}
-
-const int sleepTime = 20;
-class SlowUser : public ThreadEngine<void>
-{
-public:
-    bool shouldStartThread() { return false; }
-    ThreadFunctionResult threadFunction() { QTest::qSleep(sleepTime); return ThreadFinished; }
-};
-
-void tst_QtConcurrentThreadEngine::cancelQueuedSlowUser()
-{
-    const int times = 100;
-
-    QTime t;
-    t.start();
-
-    {
-        QList<QFuture<void> > futures;
-        for (int i = 0; i < times; ++i) {
-            SlowUser *engine = new SlowUser();
-            futures.append(engine->startAsynchronously());
-        }
-
-        foreach(QFuture<void> future, futures)
-            future.cancel();
-    }
-
-    QVERIFY(t.elapsed() < (sleepTime * times) / 2);
-}
-
-#ifndef QT_NO_EXCEPTIONS
-
-class QtConcurrentExceptionThrower : public ThreadEngine<void>
-{
-public:
-    QtConcurrentExceptionThrower(QThread *blockThread = 0)
-    {
-        this->blockThread = blockThread;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        QTest::qSleep(50);
-        throw QtConcurrent::Exception();
-        return ThreadFinished;
-    }
-    QThread *blockThread;
-};
-
-class UnrelatedExceptionThrower : public ThreadEngine<void>
-{
-public:
-    UnrelatedExceptionThrower(QThread *blockThread = 0)
-    {
-        this->blockThread = blockThread;
-    }
-
-    ThreadFunctionResult threadFunction()
-    {
-        QTest::qSleep(50);
-        throw int();
-        return ThreadFinished;
-    }
-    QThread *blockThread;
-};
-
-void tst_QtConcurrentThreadEngine::exceptions()
-{
-    // Asynchronous mode:
-    {
-        bool caught = false;
-        try  {
-            QtConcurrentExceptionThrower *e = new QtConcurrentExceptionThrower();
-            QFuture<void> f = e->startAsynchronously();
-            f.waitForFinished();
-        } catch (const Exception &) {
-            caught = true;
-        }
-        QVERIFY2(caught, "did not get exception");
-    }
-
-    // Blocking mode:
-    // test throwing the exception from a worker thread.
-    {
-        bool caught = false;
-        try  {
-            QtConcurrentExceptionThrower e(QThread::currentThread());
-            e.startBlocking();
-        } catch (const Exception &) {
-            caught = true;
-        }
-        QVERIFY2(caught, "did not get exception");
-    }
-
-    // test throwing the exception from the main thread (different code path)
-    {
-        bool caught = false;
-        try  {
-            QtConcurrentExceptionThrower e(0);
-            e.startBlocking();
-        } catch (const Exception &) {
-            caught = true;
-        }
-        QVERIFY2(caught, "did not get exception");
-    }
-
-    // Asynchronous mode:
-    {
-        bool caught = false;
-        try  {
-            UnrelatedExceptionThrower *e = new UnrelatedExceptionThrower();
-            QFuture<void> f = e->startAsynchronously();
-            f.waitForFinished();
-        } catch (const QtConcurrent::UnhandledException &) {
-            caught = true;
-        }
-        QVERIFY2(caught, "did not get exception");
-    }
-
-    // Blocking mode:
-    // test throwing the exception from a worker thread.
-    {
-        bool caught = false;
-        try  {
-            UnrelatedExceptionThrower e(QThread::currentThread());
-            e.startBlocking();
-        } catch (const QtConcurrent::UnhandledException &) {
-            caught = true;
-        }
-        QVERIFY2(caught, "did not get exception");
-    }
-
-    // test throwing the exception from the main thread (different code path)
-    {
-        bool caught = false;
-        try  {
-            UnrelatedExceptionThrower e(0);
-            e.startBlocking();
-        } catch (const QtConcurrent::UnhandledException &) {
-            caught = true;
-        }
-        QVERIFY2(caught, "did not get exception");
-    }
-}
-
-#endif
-
-QTEST_MAIN(tst_QtConcurrentThreadEngine)
-
-#include "tst_qtconcurrentthreadengine.moc"
diff --git a/tests/auto/corelib/concurrent/qthreadpool/.gitignore b/tests/auto/corelib/concurrent/qthreadpool/.gitignore
deleted file mode 100644
index 1610582..0000000
--- a/tests/auto/corelib/concurrent/qthreadpool/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qthreadpool
diff --git a/tests/auto/corelib/concurrent/qthreadpool/qthreadpool.pro b/tests/auto/corelib/concurrent/qthreadpool/qthreadpool.pro
deleted file mode 100644
index 4d81218..0000000
--- a/tests/auto/corelib/concurrent/qthreadpool/qthreadpool.pro
+++ /dev/null
@@ -1,4 +0,0 @@
-CONFIG += testcase parallel_test
-TARGET = tst_qthreadpool
-QT = core testlib
-SOURCES = tst_qthreadpool.cpp
diff --git a/tests/auto/corelib/concurrent/qthreadpool/tst_qthreadpool.cpp b/tests/auto/corelib/concurrent/qthreadpool/tst_qthreadpool.cpp
deleted file mode 100644
index 1dd0410..0000000
--- a/tests/auto/corelib/concurrent/qthreadpool/tst_qthreadpool.cpp
+++ /dev/null
@@ -1,849 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <QtTest/QtTest>
-#include <qdatetime.h>
-#include <qthreadpool.h>
-#include <qstring.h>
-#include <qmutex.h>
-
-typedef void (*FunctionPointer)();
-
-class FunctionPointerTask : public QRunnable
-{
-public:
-    FunctionPointerTask(FunctionPointer function)
-    :function(function) {}
-    void run() { function(); }
-private:
-    FunctionPointer function;
-};
-
-QRunnable *createTask(FunctionPointer pointer)
-{
-    return new FunctionPointerTask(pointer);
-}
-
-class tst_QThreadPool : public QObject
-{
-    Q_OBJECT
-private slots:
-    void runFunction();
-    void createThreadRunFunction();
-    void runMultiple();
-    void waitcomplete();
-    void runTask();
-    void singleton();
-    void destruction();
-    void threadRecycling();
-    void expiryTimeout();
-#ifndef QT_NO_EXCEPTIONS
-    void exceptions();
-#endif
-    void setMaxThreadCount_data();
-    void setMaxThreadCount();
-    void setMaxThreadCountStartsAndStopsThreads();
-    void reserveThread_data();
-    void reserveThread();
-    void releaseThread_data();
-    void releaseThread();
-    void start();
-    void tryStart();
-    void tryStartPeakThreadCount();
-    void tryStartCount();
-    void waitForDone();
-    void waitForDoneTimeout();
-    void destroyingWaitsForTasksToFinish();
-    void stressTest();
-};
-
-int testFunctionCount;
-
-void sleepTestFunction()
-{
-    QTest::qSleep(1000);
-    ++testFunctionCount;
-}
-
-void emptyFunct()
-{
-
-}
-
-void noSleepTestFunction()
-{
-    ++testFunctionCount;
-}
-
-void sleepTestFunctionMutex()
-{
-    static QMutex testMutex;
-    QTest::qSleep(1000);
-    testMutex.lock();
-    ++testFunctionCount;
-    testMutex.unlock();
-}
-
-void noSleepTestFunctionMutex()
-{
-    static QMutex testMutex;
-    testMutex.lock();
-    ++testFunctionCount;
-    testMutex.unlock();
-}
-
-void tst_QThreadPool::runFunction()
-{
-    {
-        QThreadPool manager;
-        testFunctionCount = 0;
-        manager.start(createTask(noSleepTestFunction));
-    }
-    QCOMPARE(testFunctionCount, 1);
-}
-
-void tst_QThreadPool::createThreadRunFunction()
-{
-    {
-        QThreadPool manager;
-        testFunctionCount = 0;
-        manager.start(createTask(noSleepTestFunction));
-    }
-
-    QCOMPARE(testFunctionCount, 1);
-}
-
-void tst_QThreadPool::runMultiple()
-{
-    const int runs = 10;
-
-    {
-        QThreadPool manager;
-        testFunctionCount = 0;
-        for (int i = 0; i < runs; ++i) {
-            manager.start(createTask(sleepTestFunctionMutex));
-        }
-    }
-    QCOMPARE(testFunctionCount, runs);
-
-    {
-        QThreadPool manager;
-        testFunctionCount = 0;
-        for (int i = 0; i < runs; ++i) {
-            manager.start(createTask(noSleepTestFunctionMutex));
-        }
-    }
-    QCOMPARE(testFunctionCount, runs);
-
-    {
-        QThreadPool manager;
-        for (int i = 0; i < 500; ++i)
-            manager.start(createTask(emptyFunct));
-    }
-}
-
-void tst_QThreadPool::waitcomplete()
-{
-    testFunctionCount = 0;
-    const int runs = 500;
-    for (int i = 0; i < 500; ++i) {
-        QThreadPool pool;
-        pool.start(createTask(noSleepTestFunction));
-    }
-    QCOMPARE(testFunctionCount, runs);
-}
-
-volatile bool ran;
-class TestTask : public QRunnable
-{
-public:
-    void run()
-    {
-        ran = true;
-    }
-};
-
-void tst_QThreadPool::runTask()
-{
-    QThreadPool manager;
-    ran = false;
-    manager.start(new TestTask());
-    QTRY_VERIFY(ran);
-}
-
-/*
-    Test running via QThreadPool::globalInstance()
-*/
-void tst_QThreadPool::singleton()
-{
-    ran = false;
-    QThreadPool::globalInstance()->start(new TestTask());
-    QTRY_VERIFY(ran);
-}
-
-int *value = 0;
-class IntAccessor : public QRunnable
-{
-public:
-    void run()
-    {
-        for (int i = 0; i < 100; ++i) {
-            ++(*value);
-            QTest::qSleep(1);
-        }
-    }
-};
-
-/*
-    Test that the ThreadManager destructor waits until
-    all threads have completed.
-*/
-void tst_QThreadPool::destruction()
-{
-    value = new int;
-    QThreadPool *threadManager = new QThreadPool();
-    threadManager->start(new IntAccessor());
-    threadManager->start(new IntAccessor());
-    delete threadManager;
-    delete value;
-    value = 0;
-}
-
-QSemaphore threadRecyclingSemaphore;
-QThread *recycledThread = 0;
-
-class ThreadRecorderTask : public QRunnable
-{
-public:
-    void run()
-    {
-        recycledThread = QThread::currentThread();
-        threadRecyclingSemaphore.release();
-    }
-};
-
-/*
-    Test that the thread pool really reuses threads.
-*/
-void tst_QThreadPool::threadRecycling()
-{
-    QThreadPool threadPool;
-
-    threadPool.start(new ThreadRecorderTask());
-    threadRecyclingSemaphore.acquire();
-    QThread *thread1 = recycledThread;
-
-    QTest::qSleep(100);
-
-    threadPool.start(new ThreadRecorderTask());
-    threadRecyclingSemaphore.acquire();
-    QThread *thread2 = recycledThread;
-    QCOMPARE(thread1, thread2);
-
-    QTest::qSleep(100);
-
-    threadPool.start(new ThreadRecorderTask());
-    threadRecyclingSemaphore.acquire();
-    QThread *thread3 = recycledThread;
-    QCOMPARE(thread2, thread3);
-}
-
-class ExpiryTimeoutTask : public QRunnable
-{
-public:
-    QThread *thread;
-    int runCount;
-    QSemaphore semaphore;
-
-    ExpiryTimeoutTask()
-        : thread(0), runCount(0)
-    {
-        setAutoDelete(false);
-    }
-
-    void run()
-    {
-        thread = QThread::currentThread();
-        ++runCount;
-        semaphore.release();
-    }
-};
-
-void tst_QThreadPool::expiryTimeout()
-{
-    ExpiryTimeoutTask task;
-
-    QThreadPool threadPool;
-    threadPool.setMaxThreadCount(1);
-
-    int expiryTimeout = threadPool.expiryTimeout();
-    threadPool.setExpiryTimeout(1000);
-    QCOMPARE(threadPool.expiryTimeout(), 1000);
-
-    // run the task
-    threadPool.start(&task);
-    QVERIFY(task.semaphore.tryAcquire(1, 10000));
-    QCOMPARE(task.runCount, 1);
-    QVERIFY(!task.thread->wait(100));
-    // thread should expire
-    QThread *firstThread = task.thread;
-    QVERIFY(task.thread->wait(10000));
-
-    // run task again, thread should be restarted
-    threadPool.start(&task);
-    QVERIFY(task.semaphore.tryAcquire(1, 10000));
-    QCOMPARE(task.runCount, 2);
-    QVERIFY(!task.thread->wait(100));
-    // thread should expire again
-    QVERIFY(task.thread->wait(10000));
-
-    // thread pool should have reused the expired thread (instead of
-    // starting a new one)
-    QCOMPARE(firstThread, task.thread);
-
-    threadPool.setExpiryTimeout(expiryTimeout);
-    QCOMPARE(threadPool.expiryTimeout(), expiryTimeout);
-}
-
-#ifndef QT_NO_EXCEPTIONS
-class ExceptionTask : public QRunnable
-{
-public:
-    void run()
-    {
-        throw new int;
-    }
-};
-
-void tst_QThreadPool::exceptions()
-{
-    ExceptionTask task;
-    {
-        QThreadPool threadPool;
-//  Uncomment this for a nice crash.
-//        threadPool.start(&task);
-    }
-}
-#endif
-
-void tst_QThreadPool::setMaxThreadCount_data()
-{
-    QTest::addColumn<int>("limit");
-
-    QTest::newRow("") << 1;
-    QTest::newRow("") << -1;
-    QTest::newRow("") << 2;
-    QTest::newRow("") << -2;
-    QTest::newRow("") << 4;
-    QTest::newRow("") << -4;
-    QTest::newRow("") << 0;
-    QTest::newRow("") << 12345;
-    QTest::newRow("") << -6789;
-    QTest::newRow("") << 42;
-    QTest::newRow("") << -666;
-}
-
-void tst_QThreadPool::setMaxThreadCount()
-{
-    QFETCH(int, limit);
-    QThreadPool *threadPool = QThreadPool::globalInstance();
-    int savedLimit = threadPool->maxThreadCount();
-
-    // maxThreadCount() should always return the previous argument to
-    // setMaxThreadCount(), regardless of input
-    threadPool->setMaxThreadCount(limit);
-    QCOMPARE(threadPool->maxThreadCount(), limit);
-
-    // the value returned from maxThreadCount() should always be valid input for setMaxThreadCount()
-    threadPool->setMaxThreadCount(savedLimit);
-    QCOMPARE(threadPool->maxThreadCount(), savedLimit);
-
-    // setting the limit on children should have no effect on the parent
-    {
-        QThreadPool threadPool2(threadPool);
-        savedLimit = threadPool2.maxThreadCount();
-
-        // maxThreadCount() should always return the previous argument to
-        // setMaxThreadCount(), regardless of input
-        threadPool2.setMaxThreadCount(limit);
-        QCOMPARE(threadPool2.maxThreadCount(), limit);
-
-        // the value returned from maxThreadCount() should always be valid input for setMaxThreadCount()
-        threadPool2.setMaxThreadCount(savedLimit);
-        QCOMPARE(threadPool2.maxThreadCount(), savedLimit);
-    }
-}
-
-void tst_QThreadPool::setMaxThreadCountStartsAndStopsThreads()
-{
-    class WaitingTask : public QRunnable
-    {
-    public:
-        QSemaphore waitForStarted, waitToFinish;
-
-        WaitingTask() { setAutoDelete(false); }
-
-        void run()
-        {
-            waitForStarted.release();
-            waitToFinish.acquire();
-        }
-    };
-
-    QThreadPool threadPool;
-    threadPool.setMaxThreadCount(1);
-
-    WaitingTask *task = new WaitingTask;
-    threadPool.start(task);
-    QVERIFY(task->waitForStarted.tryAcquire(1, 1000));
-
-    // thread limit is 1, cannot start more tasks
-    threadPool.start(task);
-    QVERIFY(!task->waitForStarted.tryAcquire(1, 1000));
-
-    // increasing the limit by 1 should start the task immediately
-    threadPool.setMaxThreadCount(2);
-    QVERIFY(task->waitForStarted.tryAcquire(1, 1000));
-
-    // ... but we still cannot start more tasks
-    threadPool.start(task);
-    QVERIFY(!task->waitForStarted.tryAcquire(1, 1000));
-
-    // increasing the limit should be able to start more than one at a time
-    threadPool.start(task);
-    threadPool.setMaxThreadCount(4);
-    QVERIFY(task->waitForStarted.tryAcquire(2, 1000));
-
-    // ... but we still cannot start more tasks
-    threadPool.start(task);
-    threadPool.start(task);
-    QVERIFY(!task->waitForStarted.tryAcquire(2, 1000));
-
-    // decreasing the thread limit should cause the active thread count to go down
-    threadPool.setMaxThreadCount(2);
-    QCOMPARE(threadPool.activeThreadCount(), 4);
-    task->waitToFinish.release(2);
-    QTest::qWait(1000);
-    QCOMPARE(threadPool.activeThreadCount(), 2);
-
-    // ... and we still cannot start more tasks
-    threadPool.start(task);
-    threadPool.start(task);
-    QVERIFY(!task->waitForStarted.tryAcquire(2, 1000));
-
-    // start all remaining tasks
-    threadPool.start(task);
-    threadPool.start(task);
-    threadPool.start(task);
-    threadPool.start(task);
-    threadPool.setMaxThreadCount(8);
-    QVERIFY(task->waitForStarted.tryAcquire(6, 1000));
-
-    task->waitToFinish.release(10);
-//    delete task;
-}
-
-void tst_QThreadPool::reserveThread_data()
-{
-    setMaxThreadCount_data();
-}
-
-void tst_QThreadPool::reserveThread()
-{
-    QFETCH(int, limit);
-    QThreadPool *threadpool = QThreadPool::globalInstance();
-    int savedLimit = threadpool->maxThreadCount();
-    threadpool->setMaxThreadCount(limit);
-
-    // reserve up to the limit
-    for (int i = 0; i < limit; ++i)
-        threadpool->reserveThread();
-
-    // reserveThread() should always reserve a thread, regardless of
-    // how many have been previously reserved
-    threadpool->reserveThread();
-    QCOMPARE(threadpool->activeThreadCount(), (limit > 0 ? limit : 0) + 1);
-    threadpool->reserveThread();
-    QCOMPARE(threadpool->activeThreadCount(), (limit > 0 ? limit : 0) + 2);
-
-    // cleanup
-    threadpool->releaseThread();
-    threadpool->releaseThread();
-    for (int i = 0; i < limit; ++i)
-        threadpool->releaseThread();
-
-    // reserving threads in children should not effect the parent
-    {
-        QThreadPool threadpool2(threadpool);
-        threadpool2.setMaxThreadCount(limit);
-
-        // reserve up to the limit
-        for (int i = 0; i < limit; ++i)
-            threadpool2.reserveThread();
-
-        // reserveThread() should always reserve a thread, regardless
-        // of how many have been previously reserved
-        threadpool2.reserveThread();
-        QCOMPARE(threadpool2.activeThreadCount(), (limit > 0 ? limit : 0) + 1);
-        threadpool2.reserveThread();
-        QCOMPARE(threadpool2.activeThreadCount(), (limit > 0 ? limit : 0) + 2);
-
-        threadpool->reserveThread();
-        QCOMPARE(threadpool->activeThreadCount(), 1);
-        threadpool->reserveThread();
-        QCOMPARE(threadpool->activeThreadCount(), 2);
-
-        // cleanup
-        threadpool2.releaseThread();
-        threadpool2.releaseThread();
-        threadpool->releaseThread();
-        threadpool->releaseThread();
-        while (threadpool2.activeThreadCount() > 0)
-            threadpool2.releaseThread();
-    }
-
-    // reset limit on global QThreadPool
-    threadpool->setMaxThreadCount(savedLimit);
-}
-
-void tst_QThreadPool::releaseThread_data()
-{
-    setMaxThreadCount_data();
-}
-
-void tst_QThreadPool::releaseThread()
-{
-    QFETCH(int, limit);
-    QThreadPool *threadpool = QThreadPool::globalInstance();
-    int savedLimit = threadpool->maxThreadCount();
-    threadpool->setMaxThreadCount(limit);
-
-    // reserve up to the limit
-    for (int i = 0; i < limit; ++i)
-        threadpool->reserveThread();
-
-    // release should decrease the number of reserved threads
-    int reserved = threadpool->activeThreadCount();
-    while (reserved-- > 0) {
-        threadpool->releaseThread();
-        QCOMPARE(threadpool->activeThreadCount(), reserved);
-    }
-    QCOMPARE(threadpool->activeThreadCount(), 0);
-
-    // releaseThread() can release more than have been reserved
-    threadpool->releaseThread();
-    QCOMPARE(threadpool->activeThreadCount(), -1);
-    threadpool->reserveThread();
-    QCOMPARE(threadpool->activeThreadCount(), 0);
-
-    // releasing threads in children should not effect the parent
-    {
-        QThreadPool threadpool2(threadpool);
-        threadpool2.setMaxThreadCount(limit);
-
-        // reserve up to the limit
-        for (int i = 0; i < limit; ++i)
-            threadpool2.reserveThread();
-
-        // release should decrease the number of reserved threads
-        int reserved = threadpool2.activeThreadCount();
-        while (reserved-- > 0) {
-            threadpool2.releaseThread();
-            QCOMPARE(threadpool2.activeThreadCount(), reserved);
-            QCOMPARE(threadpool->activeThreadCount(), 0);
-        }
-        QCOMPARE(threadpool2.activeThreadCount(), 0);
-        QCOMPARE(threadpool->activeThreadCount(), 0);
-
-        // releaseThread() can release more than have been reserved
-        threadpool2.releaseThread();
-        QCOMPARE(threadpool2.activeThreadCount(), -1);
-        QCOMPARE(threadpool->activeThreadCount(), 0);
-        threadpool2.reserveThread();
-        QCOMPARE(threadpool2.activeThreadCount(), 0);
-        QCOMPARE(threadpool->activeThreadCount(), 0);
-    }
-
-    // reset limit on global QThreadPool
-    threadpool->setMaxThreadCount(savedLimit);
-}
-
-QAtomicInt count;
-class CountingRunnable : public QRunnable
-{
-    public: void run()
-    {
-        count.ref();
-    }
-};
-
-void tst_QThreadPool::start()
-{
-    const int runs = 1000;
-    count.store(0);
-    {
-        QThreadPool threadPool;
-        for (int i = 0; i< runs; ++i) {
-            threadPool.start(new CountingRunnable());
-        }
-    }
-    QCOMPARE(count.load(), runs);
-}
-
-void tst_QThreadPool::tryStart()
-{
-    class WaitingTask : public QRunnable
-    {
-    public:
-        QSemaphore semaphore;
-
-        WaitingTask() { setAutoDelete(false); }
-
-        void run()
-        {
-            semaphore.acquire();
-            count.ref();
-        }
-    };
-
-    count.store(0);
-
-    WaitingTask task;
-    QThreadPool threadPool;
-    for (int i = 0; i < threadPool.maxThreadCount(); ++i) {
-        threadPool.start(&task);
-    }
-    QVERIFY(!threadPool.tryStart(&task));
-    task.semaphore.release(threadPool.maxThreadCount());
-    threadPool.waitForDone();
-    QCOMPARE(count.load(), threadPool.maxThreadCount());
-}
-
-QMutex mutex;
-int activeThreads = 0;
-int peakActiveThreads = 0;
-void tst_QThreadPool::tryStartPeakThreadCount()
-{
-    class CounterTask : public QRunnable
-    {
-    public:
-        CounterTask() { setAutoDelete(false); }
-
-        void run()
-        {
-            {
-                QMutexLocker lock(&mutex);
-                ++activeThreads;
-                peakActiveThreads = qMax(peakActiveThreads, activeThreads);
-            }
-
-            QTest::qWait(100);
-            {
-                QMutexLocker lock(&mutex);
-                --activeThreads;
-            }
-        }
-    };
-
-    CounterTask task;
-    QThreadPool threadPool;
-
-    for (int i = 0; i < 20; ++i) {
-        if (threadPool.tryStart(&task) == false)
-            QTest::qWait(10);
-    }
-    QCOMPARE(peakActiveThreads, QThread::idealThreadCount());
-
-    for (int i = 0; i < 20; ++i) {
-        if (threadPool.tryStart(&task) == false)
-            QTest::qWait(10);
-    }
-    QCOMPARE(peakActiveThreads, QThread::idealThreadCount());
-}
-
-void tst_QThreadPool::tryStartCount()
-{
-    class SleeperTask : public QRunnable
-    {
-    public:
-        SleeperTask() { setAutoDelete(false); }
-
-        void run()
-        {
-            QTest::qWait(50);
-        }
-    };
-
-    SleeperTask task;
-    QThreadPool threadPool;
-    const int runs = 5;
-
-    for (int i = 0; i < runs; ++i) {
-        int count = 0;
-        while (threadPool.tryStart(&task))
-            ++count;
-        QCOMPARE(count, QThread::idealThreadCount());
-
-        QTest::qWait(100);
-    }
-}
-
-void tst_QThreadPool::waitForDone()
-{
-    QTime total, pass;
-    total.start();
-
-    QThreadPool threadPool;
-    while (total.elapsed() < 10000) {
-        int runs;
-        count.store(runs = 0);
-        pass.restart();
-        while (pass.elapsed() < 100) {
-            threadPool.start(new CountingRunnable());
-            ++runs;
-        }
-        threadPool.waitForDone();
-        QCOMPARE(count.load(), runs);
-
-        count.store(runs = 0);
-        pass.restart();
-        while (pass.elapsed() < 100) {
-            threadPool.start(new CountingRunnable());
-            threadPool.start(new CountingRunnable());
-            runs += 2;
-        }
-        threadPool.waitForDone();
-        QCOMPARE(count.load(), runs);
-    }
-}
-
-void tst_QThreadPool::waitForDoneTimeout()
-{
-    class BlockedTask : public QRunnable
-    {
-    public:
-      QMutex mutex;
-      BlockedTask() { setAutoDelete(false); }
-      
-      void run()
-        {
-          mutex.lock();
-          mutex.unlock();
-          QTest::qSleep(50);
-        }
-    };
-
-    QThreadPool threadPool;
-
-    BlockedTask *task = new BlockedTask;
-    task->mutex.lock();
-    threadPool.start(task);
-    QVERIFY(!threadPool.waitForDone(100));
-    task->mutex.unlock();
-    QVERIFY(threadPool.waitForDone(400));
-}
-
-void tst_QThreadPool::destroyingWaitsForTasksToFinish()
-{
-    QTime total, pass;
-    total.start();
-
-    while (total.elapsed() < 10000) {
-        int runs;
-        count.store(runs = 0);
-        {
-            QThreadPool threadPool;
-            pass.restart();
-            while (pass.elapsed() < 100) {
-                threadPool.start(new CountingRunnable());
-                ++runs;
-            }
-        }
-        QCOMPARE(count.load(), runs);
-
-        count.store(runs = 0);
-        {
-            QThreadPool threadPool;
-            pass.restart();
-            while (pass.elapsed() < 100) {
-                threadPool.start(new CountingRunnable());
-                threadPool.start(new CountingRunnable());
-                runs += 2;
-            }
-        }
-        QCOMPARE(count.load(), runs);
-    }
-}
-
-void tst_QThreadPool::stressTest()
-{
-    class Task : public QRunnable
-    {
-        QSemaphore semaphore;
-    public:
-        Task() { setAutoDelete(false); }
-
-        void start()
-        {
-            QThreadPool::globalInstance()->start(this);
-        }
-
-        void wait()
-        {
-            semaphore.acquire();
-        }
-
-        void run()
-        {
-            semaphore.release();
-        }
-    };
-
-    QTime total;
-    total.start();
-    while (total.elapsed() < 30000) {
-        Task t;
-        t.start();
-        t.wait();
-    }
-}
-
-QTEST_MAIN(tst_QThreadPool);
-#include "tst_qthreadpool.moc"
diff --git a/tests/auto/corelib/corelib.pro b/tests/auto/corelib/corelib.pro
index be12fda..4f284ac 100644
--- a/tests/auto/corelib/corelib.pro
+++ b/tests/auto/corelib/corelib.pro
@@ -2,7 +2,6 @@ TEMPLATE=subdirs
 SUBDIRS=\
    animation \
    codecs \
-   concurrent \
    global \
    io \
    itemmodels \
@@ -14,4 +13,3 @@ SUBDIRS=\
    tools \
    xml
 
-!contains(QT_CONFIG, concurrent): SUBDIRS -= concurrent
diff --git a/tests/auto/corelib/thread/qthreadpool/.gitignore b/tests/auto/corelib/thread/qthreadpool/.gitignore
new file mode 100644
index 0000000..1610582
--- /dev/null
+++ b/tests/auto/corelib/thread/qthreadpool/.gitignore
@@ -0,0 +1 @@
+tst_qthreadpool
diff --git a/tests/auto/corelib/thread/qthreadpool/qthreadpool.pro b/tests/auto/corelib/thread/qthreadpool/qthreadpool.pro
new file mode 100644
index 0000000..4d81218
--- /dev/null
+++ b/tests/auto/corelib/thread/qthreadpool/qthreadpool.pro
@@ -0,0 +1,4 @@
+CONFIG += testcase parallel_test
+TARGET = tst_qthreadpool
+QT = core testlib
+SOURCES = tst_qthreadpool.cpp
diff --git a/tests/auto/corelib/thread/qthreadpool/tst_qthreadpool.cpp b/tests/auto/corelib/thread/qthreadpool/tst_qthreadpool.cpp
new file mode 100644
index 0000000..1dd0410
--- /dev/null
+++ b/tests/auto/corelib/thread/qthreadpool/tst_qthreadpool.cpp
@@ -0,0 +1,849 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QtTest/QtTest>
+#include <qdatetime.h>
+#include <qthreadpool.h>
+#include <qstring.h>
+#include <qmutex.h>
+
+typedef void (*FunctionPointer)();
+
+class FunctionPointerTask : public QRunnable
+{
+public:
+    FunctionPointerTask(FunctionPointer function)
+    :function(function) {}
+    void run() { function(); }
+private:
+    FunctionPointer function;
+};
+
+QRunnable *createTask(FunctionPointer pointer)
+{
+    return new FunctionPointerTask(pointer);
+}
+
+class tst_QThreadPool : public QObject
+{
+    Q_OBJECT
+private slots:
+    void runFunction();
+    void createThreadRunFunction();
+    void runMultiple();
+    void waitcomplete();
+    void runTask();
+    void singleton();
+    void destruction();
+    void threadRecycling();
+    void expiryTimeout();
+#ifndef QT_NO_EXCEPTIONS
+    void exceptions();
+#endif
+    void setMaxThreadCount_data();
+    void setMaxThreadCount();
+    void setMaxThreadCountStartsAndStopsThreads();
+    void reserveThread_data();
+    void reserveThread();
+    void releaseThread_data();
+    void releaseThread();
+    void start();
+    void tryStart();
+    void tryStartPeakThreadCount();
+    void tryStartCount();
+    void waitForDone();
+    void waitForDoneTimeout();
+    void destroyingWaitsForTasksToFinish();
+    void stressTest();
+};
+
+int testFunctionCount;
+
+void sleepTestFunction()
+{
+    QTest::qSleep(1000);
+    ++testFunctionCount;
+}
+
+void emptyFunct()
+{
+
+}
+
+void noSleepTestFunction()
+{
+    ++testFunctionCount;
+}
+
+void sleepTestFunctionMutex()
+{
+    static QMutex testMutex;
+    QTest::qSleep(1000);
+    testMutex.lock();
+    ++testFunctionCount;
+    testMutex.unlock();
+}
+
+void noSleepTestFunctionMutex()
+{
+    static QMutex testMutex;
+    testMutex.lock();
+    ++testFunctionCount;
+    testMutex.unlock();
+}
+
+void tst_QThreadPool::runFunction()
+{
+    {
+        QThreadPool manager;
+        testFunctionCount = 0;
+        manager.start(createTask(noSleepTestFunction));
+    }
+    QCOMPARE(testFunctionCount, 1);
+}
+
+void tst_QThreadPool::createThreadRunFunction()
+{
+    {
+        QThreadPool manager;
+        testFunctionCount = 0;
+        manager.start(createTask(noSleepTestFunction));
+    }
+
+    QCOMPARE(testFunctionCount, 1);
+}
+
+void tst_QThreadPool::runMultiple()
+{
+    const int runs = 10;
+
+    {
+        QThreadPool manager;
+        testFunctionCount = 0;
+        for (int i = 0; i < runs; ++i) {
+            manager.start(createTask(sleepTestFunctionMutex));
+        }
+    }
+    QCOMPARE(testFunctionCount, runs);
+
+    {
+        QThreadPool manager;
+        testFunctionCount = 0;
+        for (int i = 0; i < runs; ++i) {
+            manager.start(createTask(noSleepTestFunctionMutex));
+        }
+    }
+    QCOMPARE(testFunctionCount, runs);
+
+    {
+        QThreadPool manager;
+        for (int i = 0; i < 500; ++i)
+            manager.start(createTask(emptyFunct));
+    }
+}
+
+void tst_QThreadPool::waitcomplete()
+{
+    testFunctionCount = 0;
+    const int runs = 500;
+    for (int i = 0; i < 500; ++i) {
+        QThreadPool pool;
+        pool.start(createTask(noSleepTestFunction));
+    }
+    QCOMPARE(testFunctionCount, runs);
+}
+
+volatile bool ran;
+class TestTask : public QRunnable
+{
+public:
+    void run()
+    {
+        ran = true;
+    }
+};
+
+void tst_QThreadPool::runTask()
+{
+    QThreadPool manager;
+    ran = false;
+    manager.start(new TestTask());
+    QTRY_VERIFY(ran);
+}
+
+/*
+    Test running via QThreadPool::globalInstance()
+*/
+void tst_QThreadPool::singleton()
+{
+    ran = false;
+    QThreadPool::globalInstance()->start(new TestTask());
+    QTRY_VERIFY(ran);
+}
+
+int *value = 0;
+class IntAccessor : public QRunnable
+{
+public:
+    void run()
+    {
+        for (int i = 0; i < 100; ++i) {
+            ++(*value);
+            QTest::qSleep(1);
+        }
+    }
+};
+
+/*
+    Test that the ThreadManager destructor waits until
+    all threads have completed.
+*/
+void tst_QThreadPool::destruction()
+{
+    value = new int;
+    QThreadPool *threadManager = new QThreadPool();
+    threadManager->start(new IntAccessor());
+    threadManager->start(new IntAccessor());
+    delete threadManager;
+    delete value;
+    value = 0;
+}
+
+QSemaphore threadRecyclingSemaphore;
+QThread *recycledThread = 0;
+
+class ThreadRecorderTask : public QRunnable
+{
+public:
+    void run()
+    {
+        recycledThread = QThread::currentThread();
+        threadRecyclingSemaphore.release();
+    }
+};
+
+/*
+    Test that the thread pool really reuses threads.
+*/
+void tst_QThreadPool::threadRecycling()
+{
+    QThreadPool threadPool;
+
+    threadPool.start(new ThreadRecorderTask());
+    threadRecyclingSemaphore.acquire();
+    QThread *thread1 = recycledThread;
+
+    QTest::qSleep(100);
+
+    threadPool.start(new ThreadRecorderTask());
+    threadRecyclingSemaphore.acquire();
+    QThread *thread2 = recycledThread;
+    QCOMPARE(thread1, thread2);
+
+    QTest::qSleep(100);
+
+    threadPool.start(new ThreadRecorderTask());
+    threadRecyclingSemaphore.acquire();
+    QThread *thread3 = recycledThread;
+    QCOMPARE(thread2, thread3);
+}
+
+class ExpiryTimeoutTask : public QRunnable
+{
+public:
+    QThread *thread;
+    int runCount;
+    QSemaphore semaphore;
+
+    ExpiryTimeoutTask()
+        : thread(0), runCount(0)
+    {
+        setAutoDelete(false);
+    }
+
+    void run()
+    {
+        thread = QThread::currentThread();
+        ++runCount;
+        semaphore.release();
+    }
+};
+
+void tst_QThreadPool::expiryTimeout()
+{
+    ExpiryTimeoutTask task;
+
+    QThreadPool threadPool;
+    threadPool.setMaxThreadCount(1);
+
+    int expiryTimeout = threadPool.expiryTimeout();
+    threadPool.setExpiryTimeout(1000);
+    QCOMPARE(threadPool.expiryTimeout(), 1000);
+
+    // run the task
+    threadPool.start(&task);
+    QVERIFY(task.semaphore.tryAcquire(1, 10000));
+    QCOMPARE(task.runCount, 1);
+    QVERIFY(!task.thread->wait(100));
+    // thread should expire
+    QThread *firstThread = task.thread;
+    QVERIFY(task.thread->wait(10000));
+
+    // run task again, thread should be restarted
+    threadPool.start(&task);
+    QVERIFY(task.semaphore.tryAcquire(1, 10000));
+    QCOMPARE(task.runCount, 2);
+    QVERIFY(!task.thread->wait(100));
+    // thread should expire again
+    QVERIFY(task.thread->wait(10000));
+
+    // thread pool should have reused the expired thread (instead of
+    // starting a new one)
+    QCOMPARE(firstThread, task.thread);
+
+    threadPool.setExpiryTimeout(expiryTimeout);
+    QCOMPARE(threadPool.expiryTimeout(), expiryTimeout);
+}
+
+#ifndef QT_NO_EXCEPTIONS
+class ExceptionTask : public QRunnable
+{
+public:
+    void run()
+    {
+        throw new int;
+    }
+};
+
+void tst_QThreadPool::exceptions()
+{
+    ExceptionTask task;
+    {
+        QThreadPool threadPool;
+//  Uncomment this for a nice crash.
+//        threadPool.start(&task);
+    }
+}
+#endif
+
+void tst_QThreadPool::setMaxThreadCount_data()
+{
+    QTest::addColumn<int>("limit");
+
+    QTest::newRow("") << 1;
+    QTest::newRow("") << -1;
+    QTest::newRow("") << 2;
+    QTest::newRow("") << -2;
+    QTest::newRow("") << 4;
+    QTest::newRow("") << -4;
+    QTest::newRow("") << 0;
+    QTest::newRow("") << 12345;
+    QTest::newRow("") << -6789;
+    QTest::newRow("") << 42;
+    QTest::newRow("") << -666;
+}
+
+void tst_QThreadPool::setMaxThreadCount()
+{
+    QFETCH(int, limit);
+    QThreadPool *threadPool = QThreadPool::globalInstance();
+    int savedLimit = threadPool->maxThreadCount();
+
+    // maxThreadCount() should always return the previous argument to
+    // setMaxThreadCount(), regardless of input
+    threadPool->setMaxThreadCount(limit);
+    QCOMPARE(threadPool->maxThreadCount(), limit);
+
+    // the value returned from maxThreadCount() should always be valid input for setMaxThreadCount()
+    threadPool->setMaxThreadCount(savedLimit);
+    QCOMPARE(threadPool->maxThreadCount(), savedLimit);
+
+    // setting the limit on children should have no effect on the parent
+    {
+        QThreadPool threadPool2(threadPool);
+        savedLimit = threadPool2.maxThreadCount();
+
+        // maxThreadCount() should always return the previous argument to
+        // setMaxThreadCount(), regardless of input
+        threadPool2.setMaxThreadCount(limit);
+        QCOMPARE(threadPool2.maxThreadCount(), limit);
+
+        // the value returned from maxThreadCount() should always be valid input for setMaxThreadCount()
+        threadPool2.setMaxThreadCount(savedLimit);
+        QCOMPARE(threadPool2.maxThreadCount(), savedLimit);
+    }
+}
+
+void tst_QThreadPool::setMaxThreadCountStartsAndStopsThreads()
+{
+    class WaitingTask : public QRunnable
+    {
+    public:
+        QSemaphore waitForStarted, waitToFinish;
+
+        WaitingTask() { setAutoDelete(false); }
+
+        void run()
+        {
+            waitForStarted.release();
+            waitToFinish.acquire();
+        }
+    };
+
+    QThreadPool threadPool;
+    threadPool.setMaxThreadCount(1);
+
+    WaitingTask *task = new WaitingTask;
+    threadPool.start(task);
+    QVERIFY(task->waitForStarted.tryAcquire(1, 1000));
+
+    // thread limit is 1, cannot start more tasks
+    threadPool.start(task);
+    QVERIFY(!task->waitForStarted.tryAcquire(1, 1000));
+
+    // increasing the limit by 1 should start the task immediately
+    threadPool.setMaxThreadCount(2);
+    QVERIFY(task->waitForStarted.tryAcquire(1, 1000));
+
+    // ... but we still cannot start more tasks
+    threadPool.start(task);
+    QVERIFY(!task->waitForStarted.tryAcquire(1, 1000));
+
+    // increasing the limit should be able to start more than one at a time
+    threadPool.start(task);
+    threadPool.setMaxThreadCount(4);
+    QVERIFY(task->waitForStarted.tryAcquire(2, 1000));
+
+    // ... but we still cannot start more tasks
+    threadPool.start(task);
+    threadPool.start(task);
+    QVERIFY(!task->waitForStarted.tryAcquire(2, 1000));
+
+    // decreasing the thread limit should cause the active thread count to go down
+    threadPool.setMaxThreadCount(2);
+    QCOMPARE(threadPool.activeThreadCount(), 4);
+    task->waitToFinish.release(2);
+    QTest::qWait(1000);
+    QCOMPARE(threadPool.activeThreadCount(), 2);
+
+    // ... and we still cannot start more tasks
+    threadPool.start(task);
+    threadPool.start(task);
+    QVERIFY(!task->waitForStarted.tryAcquire(2, 1000));
+
+    // start all remaining tasks
+    threadPool.start(task);
+    threadPool.start(task);
+    threadPool.start(task);
+    threadPool.start(task);
+    threadPool.setMaxThreadCount(8);
+    QVERIFY(task->waitForStarted.tryAcquire(6, 1000));
+
+    task->waitToFinish.release(10);
+//    delete task;
+}
+
+void tst_QThreadPool::reserveThread_data()
+{
+    setMaxThreadCount_data();
+}
+
+void tst_QThreadPool::reserveThread()
+{
+    QFETCH(int, limit);
+    QThreadPool *threadpool = QThreadPool::globalInstance();
+    int savedLimit = threadpool->maxThreadCount();
+    threadpool->setMaxThreadCount(limit);
+
+    // reserve up to the limit
+    for (int i = 0; i < limit; ++i)
+        threadpool->reserveThread();
+
+    // reserveThread() should always reserve a thread, regardless of
+    // how many have been previously reserved
+    threadpool->reserveThread();
+    QCOMPARE(threadpool->activeThreadCount(), (limit > 0 ? limit : 0) + 1);
+    threadpool->reserveThread();
+    QCOMPARE(threadpool->activeThreadCount(), (limit > 0 ? limit : 0) + 2);
+
+    // cleanup
+    threadpool->releaseThread();
+    threadpool->releaseThread();
+    for (int i = 0; i < limit; ++i)
+        threadpool->releaseThread();
+
+    // reserving threads in children should not effect the parent
+    {
+        QThreadPool threadpool2(threadpool);
+        threadpool2.setMaxThreadCount(limit);
+
+        // reserve up to the limit
+        for (int i = 0; i < limit; ++i)
+            threadpool2.reserveThread();
+
+        // reserveThread() should always reserve a thread, regardless
+        // of how many have been previously reserved
+        threadpool2.reserveThread();
+        QCOMPARE(threadpool2.activeThreadCount(), (limit > 0 ? limit : 0) + 1);
+        threadpool2.reserveThread();
+        QCOMPARE(threadpool2.activeThreadCount(), (limit > 0 ? limit : 0) + 2);
+
+        threadpool->reserveThread();
+        QCOMPARE(threadpool->activeThreadCount(), 1);
+        threadpool->reserveThread();
+        QCOMPARE(threadpool->activeThreadCount(), 2);
+
+        // cleanup
+        threadpool2.releaseThread();
+        threadpool2.releaseThread();
+        threadpool->releaseThread();
+        threadpool->releaseThread();
+        while (threadpool2.activeThreadCount() > 0)
+            threadpool2.releaseThread();
+    }
+
+    // reset limit on global QThreadPool
+    threadpool->setMaxThreadCount(savedLimit);
+}
+
+void tst_QThreadPool::releaseThread_data()
+{
+    setMaxThreadCount_data();
+}
+
+void tst_QThreadPool::releaseThread()
+{
+    QFETCH(int, limit);
+    QThreadPool *threadpool = QThreadPool::globalInstance();
+    int savedLimit = threadpool->maxThreadCount();
+    threadpool->setMaxThreadCount(limit);
+
+    // reserve up to the limit
+    for (int i = 0; i < limit; ++i)
+        threadpool->reserveThread();
+
+    // release should decrease the number of reserved threads
+    int reserved = threadpool->activeThreadCount();
+    while (reserved-- > 0) {
+        threadpool->releaseThread();
+        QCOMPARE(threadpool->activeThreadCount(), reserved);
+    }
+    QCOMPARE(threadpool->activeThreadCount(), 0);
+
+    // releaseThread() can release more than have been reserved
+    threadpool->releaseThread();
+    QCOMPARE(threadpool->activeThreadCount(), -1);
+    threadpool->reserveThread();
+    QCOMPARE(threadpool->activeThreadCount(), 0);
+
+    // releasing threads in children should not effect the parent
+    {
+        QThreadPool threadpool2(threadpool);
+        threadpool2.setMaxThreadCount(limit);
+
+        // reserve up to the limit
+        for (int i = 0; i < limit; ++i)
+            threadpool2.reserveThread();
+
+        // release should decrease the number of reserved threads
+        int reserved = threadpool2.activeThreadCount();
+        while (reserved-- > 0) {
+            threadpool2.releaseThread();
+            QCOMPARE(threadpool2.activeThreadCount(), reserved);
+            QCOMPARE(threadpool->activeThreadCount(), 0);
+        }
+        QCOMPARE(threadpool2.activeThreadCount(), 0);
+        QCOMPARE(threadpool->activeThreadCount(), 0);
+
+        // releaseThread() can release more than have been reserved
+        threadpool2.releaseThread();
+        QCOMPARE(threadpool2.activeThreadCount(), -1);
+        QCOMPARE(threadpool->activeThreadCount(), 0);
+        threadpool2.reserveThread();
+        QCOMPARE(threadpool2.activeThreadCount(), 0);
+        QCOMPARE(threadpool->activeThreadCount(), 0);
+    }
+
+    // reset limit on global QThreadPool
+    threadpool->setMaxThreadCount(savedLimit);
+}
+
+QAtomicInt count;
+class CountingRunnable : public QRunnable
+{
+    public: void run()
+    {
+        count.ref();
+    }
+};
+
+void tst_QThreadPool::start()
+{
+    const int runs = 1000;
+    count.store(0);
+    {
+        QThreadPool threadPool;
+        for (int i = 0; i< runs; ++i) {
+            threadPool.start(new CountingRunnable());
+        }
+    }
+    QCOMPARE(count.load(), runs);
+}
+
+void tst_QThreadPool::tryStart()
+{
+    class WaitingTask : public QRunnable
+    {
+    public:
+        QSemaphore semaphore;
+
+        WaitingTask() { setAutoDelete(false); }
+
+        void run()
+        {
+            semaphore.acquire();
+            count.ref();
+        }
+    };
+
+    count.store(0);
+
+    WaitingTask task;
+    QThreadPool threadPool;
+    for (int i = 0; i < threadPool.maxThreadCount(); ++i) {
+        threadPool.start(&task);
+    }
+    QVERIFY(!threadPool.tryStart(&task));
+    task.semaphore.release(threadPool.maxThreadCount());
+    threadPool.waitForDone();
+    QCOMPARE(count.load(), threadPool.maxThreadCount());
+}
+
+QMutex mutex;
+int activeThreads = 0;
+int peakActiveThreads = 0;
+void tst_QThreadPool::tryStartPeakThreadCount()
+{
+    class CounterTask : public QRunnable
+    {
+    public:
+        CounterTask() { setAutoDelete(false); }
+
+        void run()
+        {
+            {
+                QMutexLocker lock(&mutex);
+                ++activeThreads;
+                peakActiveThreads = qMax(peakActiveThreads, activeThreads);
+            }
+
+            QTest::qWait(100);
+            {
+                QMutexLocker lock(&mutex);
+                --activeThreads;
+            }
+        }
+    };
+
+    CounterTask task;
+    QThreadPool threadPool;
+
+    for (int i = 0; i < 20; ++i) {
+        if (threadPool.tryStart(&task) == false)
+            QTest::qWait(10);
+    }
+    QCOMPARE(peakActiveThreads, QThread::idealThreadCount());
+
+    for (int i = 0; i < 20; ++i) {
+        if (threadPool.tryStart(&task) == false)
+            QTest::qWait(10);
+    }
+    QCOMPARE(peakActiveThreads, QThread::idealThreadCount());
+}
+
+void tst_QThreadPool::tryStartCount()
+{
+    class SleeperTask : public QRunnable
+    {
+    public:
+        SleeperTask() { setAutoDelete(false); }
+
+        void run()
+        {
+            QTest::qWait(50);
+        }
+    };
+
+    SleeperTask task;
+    QThreadPool threadPool;
+    const int runs = 5;
+
+    for (int i = 0; i < runs; ++i) {
+        int count = 0;
+        while (threadPool.tryStart(&task))
+            ++count;
+        QCOMPARE(count, QThread::idealThreadCount());
+
+        QTest::qWait(100);
+    }
+}
+
+void tst_QThreadPool::waitForDone()
+{
+    QTime total, pass;
+    total.start();
+
+    QThreadPool threadPool;
+    while (total.elapsed() < 10000) {
+        int runs;
+        count.store(runs = 0);
+        pass.restart();
+        while (pass.elapsed() < 100) {
+            threadPool.start(new CountingRunnable());
+            ++runs;
+        }
+        threadPool.waitForDone();
+        QCOMPARE(count.load(), runs);
+
+        count.store(runs = 0);
+        pass.restart();
+        while (pass.elapsed() < 100) {
+            threadPool.start(new CountingRunnable());
+            threadPool.start(new CountingRunnable());
+            runs += 2;
+        }
+        threadPool.waitForDone();
+        QCOMPARE(count.load(), runs);
+    }
+}
+
+void tst_QThreadPool::waitForDoneTimeout()
+{
+    class BlockedTask : public QRunnable
+    {
+    public:
+      QMutex mutex;
+      BlockedTask() { setAutoDelete(false); }
+      
+      void run()
+        {
+          mutex.lock();
+          mutex.unlock();
+          QTest::qSleep(50);
+        }
+    };
+
+    QThreadPool threadPool;
+
+    BlockedTask *task = new BlockedTask;
+    task->mutex.lock();
+    threadPool.start(task);
+    QVERIFY(!threadPool.waitForDone(100));
+    task->mutex.unlock();
+    QVERIFY(threadPool.waitForDone(400));
+}
+
+void tst_QThreadPool::destroyingWaitsForTasksToFinish()
+{
+    QTime total, pass;
+    total.start();
+
+    while (total.elapsed() < 10000) {
+        int runs;
+        count.store(runs = 0);
+        {
+            QThreadPool threadPool;
+            pass.restart();
+            while (pass.elapsed() < 100) {
+                threadPool.start(new CountingRunnable());
+                ++runs;
+            }
+        }
+        QCOMPARE(count.load(), runs);
+
+        count.store(runs = 0);
+        {
+            QThreadPool threadPool;
+            pass.restart();
+            while (pass.elapsed() < 100) {
+                threadPool.start(new CountingRunnable());
+                threadPool.start(new CountingRunnable());
+                runs += 2;
+            }
+        }
+        QCOMPARE(count.load(), runs);
+    }
+}
+
+void tst_QThreadPool::stressTest()
+{
+    class Task : public QRunnable
+    {
+        QSemaphore semaphore;
+    public:
+        Task() { setAutoDelete(false); }
+
+        void start()
+        {
+            QThreadPool::globalInstance()->start(this);
+        }
+
+        void wait()
+        {
+            semaphore.acquire();
+        }
+
+        void run()
+        {
+            semaphore.release();
+        }
+    };
+
+    QTime total;
+    total.start();
+    while (total.elapsed() < 30000) {
+        Task t;
+        t.start();
+        t.wait();
+    }
+}
+
+QTEST_MAIN(tst_QThreadPool);
+#include "tst_qthreadpool.moc"
diff --git a/tests/auto/corelib/thread/thread.pro b/tests/auto/corelib/thread/thread.pro
index a137748..12a284c 100644
--- a/tests/auto/corelib/thread/thread.pro
+++ b/tests/auto/corelib/thread/thread.pro
@@ -9,6 +9,7 @@ SUBDIRS=\
     qsemaphore \
     qthread \
     qthreadonce \
+    qthreadpool \
     qthreadstorage \
     qwaitcondition \
     qwritelocker