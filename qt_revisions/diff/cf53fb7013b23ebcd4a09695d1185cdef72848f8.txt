diff --git a/src/serialport.cpp b/src/serialport.cpp
index 5a8130a..82dd6e7 100755
--- a/src/serialport.cpp
+++ b/src/serialport.cpp
@@ -175,8 +175,9 @@ bool SerialPortPrivate::setRate(qint32 rate, SerialPort::Directions dir)
 qint32 SerialPortPrivate::rate(SerialPort::Directions dir) const
 {
     if (dir == SerialPort::AllDirections)
-        return (options.inputRate == options.outputRate) ? (options.inputRate) : SerialPort::UnknownRate;
-    return (dir & SerialPort::Input) ? (options.inputRate) : (options.outputRate);
+        return options.inputRate == options.outputRate ?
+                    options.inputRate : SerialPort::UnknownRate;
+    return dir & SerialPort::Input ? options.inputRate : options.outputRate;
 }
 
 /*! \internal
@@ -415,7 +416,7 @@ bool SerialPortPrivate::setBreak(bool set)
 */
 bool SerialPortPrivate::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
 {
-    const bool ret = (options.policy == policy) || engine->setDataErrorPolicy(policy);
+    const bool ret = options.policy == policy || engine->setDataErrorPolicy(policy);
     if (ret)
         options.policy = policy;
     return ret;
@@ -547,14 +548,11 @@ void SerialPortPrivate::clearBuffers()
 */
 bool SerialPortPrivate::readFromPort()
 {
-    qint64 bytesToRead = (options.policy == SerialPort::IgnorePolicy) ?
-                (SERIALPORT_READ_CHUNKSIZE) : 1;
-
-    if (readBufferMaxSize
-            && (bytesToRead > (readBufferMaxSize - readBuffer.size()))) {
+    qint64 bytesToRead = options.policy == SerialPort::IgnorePolicy ?
+                SERIALPORT_READ_CHUNKSIZE : 1;
 
+    if (readBufferMaxSize && bytesToRead > (readBufferMaxSize - readBuffer.size()))
         bytesToRead = readBufferMaxSize - readBuffer.size();
-    }
 
     char *ptr = readBuffer.reserve(bytesToRead);
     const qint64 readBytes = read(ptr, bytesToRead);
@@ -566,7 +564,7 @@ bool SerialPortPrivate::readFromPort()
         return true;
     }
 
-    readBuffer.chop(int(bytesToRead - ((readBytes < 0) ? 0 : readBytes)));
+    readBuffer.chop(int(bytesToRead - (readBytes < 0 ? 0 : readBytes)));
 
     if (readBytes < 0) {
         setError(SerialPort::IoError);
@@ -606,9 +604,7 @@ bool SerialPortPrivate::canReadNotification()
     qint64 newBytes = 0;
     if (isBuffered) {
         // Return if there is no space in the buffer.
-        if (readBufferMaxSize
-                && (readBuffer.size() >= readBufferMaxSize)) {
-
+        if (readBufferMaxSize && readBuffer.size() >= readBufferMaxSize) {
             readSerialNotifierCalled = false;
             return false;
         }
@@ -622,31 +618,28 @@ bool SerialPortPrivate::canReadNotification()
         newBytes = readBuffer.size() - newBytes;
 
         // If read buffer is full, disable the read serial notifier.
-        if (readBufferMaxSize
-                && (readBuffer.size() == readBufferMaxSize)) {
-
+        if (readBufferMaxSize && readBuffer.size() == readBufferMaxSize) {
             engine->setReadNotificationEnabled(false);
         }
     }
 
     // Only emit readyRead() when not recursing,
     // and only if there is data available.
-    const bool hasData = (isBuffered) ? (newBytes > 0) : true;
+    const bool hasData = isBuffered ? (newBytes > 0) : true;
 
-    if ((!emittedReadyRead) && hasData) {
+    if (!emittedReadyRead && hasData) {
         emittedReadyRead = true;
         emit q->readyRead();
         emittedReadyRead = false;
     }
 
-    if ((!hasData) && engine->isReadNotificationEnabled())
+    if (!hasData && engine->isReadNotificationEnabled())
         engine->setReadNotificationEnabled(true);
 
     // Reset the read serial notifier state if we reentered inside the
     // readyRead() connected slot.
-    if (readSerialNotifierStateSet &&
-            (readSerialNotifierState != engine->isReadNotificationEnabled())) {
-
+    if (readSerialNotifierStateSet
+            && readSerialNotifierState != engine->isReadNotificationEnabled()) {
         engine->setReadNotificationEnabled(readSerialNotifierState);
         readSerialNotifierStateSet = false;
     }
@@ -681,7 +674,7 @@ bool SerialPortPrivate::canWriteNotification()
     if (writeBuffer.isEmpty())
         engine->setWriteNotificationEnabled(false);
 #endif
-    return (writeBuffer.size() < tmp);
+    return writeBuffer.size() < tmp;
 }
 
 /*! \internal
@@ -1124,8 +1117,8 @@ bool SerialPort::open(OpenMode mode)
     }
 
     // Define while not supported modes.
-    static const OpenMode unsupportedModes = (Append | Truncate | Text);
-    if ((mode & unsupportedModes) || (mode == NotOpen)) {
+    static const OpenMode unsupportedModes = Append | Truncate | Text;
+    if ((mode & unsupportedModes) || mode == NotOpen) {
         d->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
@@ -1142,7 +1135,7 @@ bool SerialPort::open(OpenMode mode)
 
         d->engine->setErrorNotificationEnabled(true);
 
-        d->isBuffered = !(mode & Unbuffered);
+        d->isBuffered = (mode & Unbuffered) == 0;
         return true;
     }
     return false;
@@ -1574,16 +1567,17 @@ bool SerialPort::canReadLine() const
 {
     Q_D(const SerialPort);
     const bool hasLine = d->readBuffer.canReadLine();
-    return (hasLine || QIODevice::canReadLine());
+    return hasLine || QIODevice::canReadLine();
 }
 
 // Returns the difference between msecs and elapsed. If msecs is -1,
 // however, -1 is returned.
 static int qt_timeout_value(int msecs, int elapsed)
 {
-    if (msecs == -1) { return msecs; }
+    if (msecs == -1)
+        return msecs;
     msecs -= elapsed;
-    return (msecs < 0) ? 0 : msecs;
+    return msecs < 0 ? 0 : msecs;
 }
 
 /*! \reimp
@@ -1601,7 +1595,7 @@ bool SerialPort::waitForReadyRead(int msecs)
 {
     Q_D(SerialPort);
 
-    if (d->isBuffered && (!d->readBuffer.isEmpty()))
+    if (d->isBuffered && !d->readBuffer.isEmpty())
         return true;
 
     if (d->engine->isReadNotificationEnabled())
@@ -1619,7 +1613,7 @@ bool SerialPort::waitForReadyRead(int msecs)
         bool readyToRead = false;
         bool readyToWrite = false;
         if (!d->waitForReadOrWrite(qt_timeout_value(msecs, stopWatch.elapsed()),
-                                   true, (!d->writeBuffer.isEmpty()),
+                                   true, !d->writeBuffer.isEmpty(),
                                    &readyToRead, &readyToWrite)) {
             return false;
         }
@@ -1654,7 +1648,7 @@ bool SerialPort::waitForBytesWritten(int msecs)
         bool readyToRead = false;
         bool readyToWrite = false;
         if (!d->waitForReadOrWrite(qt_timeout_value(msecs, stopWatch.elapsed()),
-                                   true, (!d->writeBuffer.isEmpty()),
+                                   true, !d->writeBuffer.isEmpty(),
                                    &readyToRead, &readyToWrite)) {
             return false;
         }
@@ -1663,9 +1657,8 @@ bool SerialPort::waitForBytesWritten(int msecs)
                 return false;
         }
         if (readyToWrite) {
-            if (d->canWriteNotification()) {
+            if (d->canWriteNotification())
                 return true;
-            }
         }
     }
     return false;
@@ -1770,7 +1763,7 @@ qint64 SerialPort::readData(char *data, qint64 maxSize)
             if (readBytes == -2)
                 d->readBuffer.chop(bytesToRead); // No bytes currently available for reading.
             else
-                d->readBuffer.chop(int(bytesToRead - ((readBytes < 0) ? 0 : readBytes)));
+                d->readBuffer.chop(int(bytesToRead - (readBytes < 0 ? 0 : readBytes)));
         }
     }
 
diff --git a/src/serialportengine_symbian.cpp b/src/serialportengine_symbian.cpp
index 599e7a0..a2b86a2 100755
--- a/src/serialportengine_symbian.cpp
+++ b/src/serialportengine_symbian.cpp
@@ -103,16 +103,16 @@ static bool loadDevices()
 #endif
 
     r = User::LoadPhysicalDevice(KPddName);
-    if ((r != KErrNone) && (r != KErrAlreadyExists))
+    if (r != KErrNone && r != KErrAlreadyExists)
         return false; //User::Leave(r);
 
     r = User::LoadLogicalDevice(KLddName);
-    if ((r != KErrNone) && (r != KErrAlreadyExists))
+    if (r != KErrNone && r != KErrAlreadyExists)
         return false; //User::Leave(r);
 
 #if !defined (__WINS__)
     r = StartC32();
-    if ((r != KErrNone) && (r != KErrAlreadyExists))
+    if (r != KErrNone && r != KErrAlreadyExists)
         return false; //User::Leave(r);
 #endif
 
@@ -196,12 +196,15 @@ bool SymbianSerialPortEngine::open(const QString &location, QIODevice::OpenMode
     if (r != KErrNone) {
         switch (r) {
         case KErrPermissionDenied:
-            dptr->setError(SerialPort::NoSuchDeviceError); break;
+            dptr->setError(SerialPort::NoSuchDeviceError);
+            break;
         case KErrLocked:
         case KErrAccessDenied:
-            dptr->setError(SerialPort::PermissionDeniedError); break;
+            dptr->setError(SerialPort::PermissionDeniedError);
+            break;
         default:
             dptr->setError(SerialPort::UnknownPortError);
+            break;
         }
         return false;
     }
@@ -225,9 +228,8 @@ void SymbianSerialPortEngine::close(const QString &location)
 {
     Q_UNUSED(location);
 
-    if (dptr->options.restoreSettingsOnClose) {
+    if (dptr->options.restoreSettingsOnClose)
         m_descriptor.SetConfig(m_restoredSettings);
-    }
 
     m_descriptor.Close();
 }
@@ -277,7 +279,7 @@ bool SymbianSerialPortEngine::setDtr(bool set)
     else
         r = m_descriptor.SetSignalsToSpace(KSignalDTR);
 
-    return (r == KErrNone);
+    return r == KErrNone;
 }
 
 /*!
@@ -293,7 +295,7 @@ bool SymbianSerialPortEngine::setRts(bool set)
     else
         r = m_descriptor.SetSignalsToSpace(KSignalRTS);
 
-    return (r == KErrNone);
+    return r == KErrNone;
 }
 
 /*!
@@ -312,7 +314,7 @@ bool SymbianSerialPortEngine::flush()
 bool SymbianSerialPortEngine::reset()
 {
     TInt r = m_descriptor.ResetBuffers(KCommResetRx | KCommResetTx);
-    return (r == KErrNone);
+    return r == KErrNone;
 }
 
 /*!
@@ -823,7 +825,7 @@ qint32 SymbianSerialPortEngine::rateFromSetting(EBps setting)
 {
     const RatePair rp = {0, setting};
     const RatePair *ret = qFind(standardRatesTable, standardRatesTable_end, rp);
-    return (ret != standardRatesTable_end) ? ret->rate : 0;
+    return ret != standardRatesTable_end ? ret->rate : 0;
 }
 
 /*!
@@ -834,7 +836,7 @@ EBps SymbianSerialPortEngine::settingFromRate(qint32 rate)
 {
     const RatePair rp = {rate, 0};
     const RatePair *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rp);
-    return (ret != standardRatesTable_end) ? ret->setting : 0;
+    return ret != standardRatesTable_end ? ret->setting : 0;
 }
 
 /*!
@@ -880,6 +882,7 @@ void SymbianSerialPortEngine::detectDefaultSettings()
         break;
     default:
         dptr->options.dataBits = SerialPort::UnknownDataBits;
+        break;
     }
 
     // Detect parity.
@@ -901,6 +904,7 @@ void SymbianSerialPortEngine::detectDefaultSettings()
         break;
     default:
         dptr->options.parity = SerialPort::UnknownParity;
+        break;
     }
 
     // Detect stopbits.
@@ -913,6 +917,7 @@ void SymbianSerialPortEngine::detectDefaultSettings()
         break;
     default:
         dptr->options.stopBits = SerialPort::UnknownStopBits;
+        break;
     }
 
     // Detect flow control.
diff --git a/src/serialportengine_unix.cpp b/src/serialportengine_unix.cpp
index d7c042b..eb06bcc 100755
--- a/src/serialportengine_unix.cpp
+++ b/src/serialportengine_unix.cpp
@@ -187,6 +187,7 @@ bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mod
             break;
         default:
             dptr->setError(SerialPort::UnknownPortError);
+            break;
         }
         return false;
     }
@@ -212,7 +213,7 @@ bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mod
 
     // Set other options.
     ::cfmakeraw(&m_currentTermios);
-    m_currentTermios.c_cflag |= (CREAD | CLOCAL);
+    m_currentTermios.c_cflag |= CREAD | CLOCAL;
     m_currentTermios.c_cc[VTIME] = 0;
 
     // Apply new init settings.
@@ -321,7 +322,7 @@ SerialPort::Lines UnixSerialPortEngine::lines() const
 static bool trigger_out_line(int fd, int bit, bool set)
 {
     int arg = 0;
-    bool ret = (::ioctl(fd, TIOCMGET, &arg) != -1);
+    bool ret = ::ioctl(fd, TIOCMGET, &arg) != -1;
 
     if (ret) {
         int tmp = arg & bit;
@@ -333,9 +334,9 @@ static bool trigger_out_line(int fd, int bit, bool set)
         if (set)
             arg |= bit;
         else
-            arg &= (~bit);
+            arg &= ~bit;
 
-        ret = (::ioctl(fd, TIOCMSET, &arg) != -1);
+        ret = ::ioctl(fd, TIOCMSET, &arg) != -1;
     }
     return ret;
 }
@@ -368,7 +369,7 @@ bool UnixSerialPortEngine::setRts(bool set)
 */
 bool UnixSerialPortEngine::flush()
 {
-    return (::tcdrain(m_descriptor) != -1);
+    return ::tcdrain(m_descriptor) != -1;
 }
 
 /*!
@@ -379,7 +380,7 @@ bool UnixSerialPortEngine::flush()
 */
 bool UnixSerialPortEngine::reset()
 {
-    return (::tcflush(m_descriptor, TCIOFLUSH) != -1);
+    return ::tcflush(m_descriptor, TCIOFLUSH) != -1;
 }
 
 /*!
@@ -389,7 +390,7 @@ bool UnixSerialPortEngine::reset()
 */
 bool UnixSerialPortEngine::sendBreak(int duration)
 {
-    return (::tcsendbreak(m_descriptor, duration) != -1);
+    return ::tcsendbreak(m_descriptor, duration) != -1;
 }
 
 /*!
@@ -400,7 +401,7 @@ bool UnixSerialPortEngine::sendBreak(int duration)
 */
 bool UnixSerialPortEngine::setBreak(bool set)
 {
-    return (::ioctl(m_descriptor, set ? TIOCSBRK : TIOCCBRK) != -1);
+    return ::ioctl(m_descriptor, set ? TIOCSBRK : TIOCCBRK) != -1;
 }
 
 /*!
@@ -446,15 +447,16 @@ qint64 UnixSerialPortEngine::read(char *data, qint64 len)
 {
     qint64 bytesRead = 0;
 #if defined (CMSPAR)
-    if ((dptr->options.parity == SerialPort::NoParity)
-            || (dptr->options.policy != SerialPort::StopReceivingPolicy))
+    if (dptr->options.parity == SerialPort::NoParity
+            || dptr->options.policy != SerialPort::StopReceivingPolicy) {
 #else
-    if ((dptr->options.parity != SerialPort::MarkParity)
-            && (dptr->options.parity != SerialPort::SpaceParity))
+    if (dptr->options.parity != SerialPort::MarkParity
+            && dptr->options.parity != SerialPort::SpaceParity) {
 #endif
         bytesRead = ::read(m_descriptor, data, len);
-    else // Perform parity emulation.
+    } else {// Perform parity emulation.
         bytesRead = readPerChar(data, len);
+    }
 
     // FIXME: Here 'errno' codes for sockets.
     // You need to replace the codes for the serial port.
@@ -501,10 +503,12 @@ qint64 UnixSerialPortEngine::write(const char *data, qint64 len)
 #if defined (CMSPAR)
     bytesWritten = ::write(m_descriptor, data, len);
 #else
-    if ((dptr->options.parity != SerialPort::MarkParity) && (dptr->options.parity != SerialPort::SpaceParity))
+    if (dptr->options.parity != SerialPort::MarkParity
+            && dptr->options.parity != SerialPort::SpaceParity) {
         bytesWritten = ::write(m_descriptor, data, len);
-    else // Perform parity emulation.
+    } else {// Perform parity emulation.
         bytesWritten = writePerChar(data, len);
+    }
 #endif
 
     // FIXME: Here 'errno' codes for sockets.
@@ -557,10 +561,10 @@ bool UnixSerialPortEngine::select(int timeout,
         FD_SET(m_descriptor, &fdwrite);
 
     struct timeval tv;
-    tv.tv_sec = (timeout / 1000);
+    tv.tv_sec = timeout / 1000;
     tv.tv_usec = (timeout % 1000) * 1000;
 
-    if (::select(m_descriptor + 1, &fdread, &fdwrite, 0, (timeout < 0) ? 0 : &tv) <= 0) {
+    if (::select(m_descriptor + 1, &fdread, &fdwrite, 0, timeout < 0 ? 0 : &tv) <= 0) {
         Q_ASSERT(selectForRead);
         *selectForRead = false;
         Q_ASSERT(selectForWrite);
@@ -631,7 +635,7 @@ QString UnixSerialPortEngine::fromSystemLocation(const QString &location) const
 */
 bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 {
-    bool ret = (rate > 0);
+    bool ret = rate > 0;
 
     // prepare section
 
@@ -648,8 +652,8 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
             }
 #endif
             // prepare to set standard rate
-            ret = !(((dir & SerialPort::Input) && (::cfsetispeed(&m_currentTermios, unixRate) < 0))
-                    || ((dir & SerialPort::Output) && (::cfsetospeed(&m_currentTermios, unixRate) < 0)));
+            ret = !(((dir & SerialPort::Input) && ::cfsetispeed(&m_currentTermios, unixRate) < 0)
+                    || ((dir & SerialPort::Output) && ::cfsetospeed(&m_currentTermios, unixRate) < 0));
         } else {
             // try prepate to set custom baud rate
 #if defined (Q_OS_LINUX)
@@ -672,7 +676,7 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
             // other than those specified by POSIX. The driver for the underlying serial hardware
             // ultimately determines which baud rates can be used. This ioctl sets both the input
             // and output speed.
-            ret = (::ioctl(m_descriptor, IOSSIOSPEED, &rate) != -1);
+            ret = ::ioctl(m_descriptor, IOSSIOSPEED, &rate) != -1;
 #  else
             // others MacOSX version, can't prepare to set custom rate
             ret = false;
@@ -688,16 +692,12 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
     // finally section
 
 #if defined (Q_OS_LINUX)
-    if (ret && m_isCustomRateSupported) {
-        // finally, set or reset the custom mode
-        ret = (::ioctl(m_descriptor, TIOCSSERIAL, &m_currentSerialInfo) != -1);
-    }
+    if (ret && m_isCustomRateSupported) // finally, set or reset the custom mode
+        ret = ::ioctl(m_descriptor, TIOCSSERIAL, &m_currentSerialInfo) != -1;
 #endif
 
-    if (ret) {
-        // finally, set rate
+    if (ret) // finally, set rate
         ret = updateTermios();
-    }
 
     if (!ret)
         dptr->setError(SerialPort::UnsupportedPortOperationError);
@@ -713,7 +713,7 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 */
 bool UnixSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 {
-    m_currentTermios.c_cflag &= (~CSIZE);
+    m_currentTermios.c_cflag &= ~CSIZE;
     switch (dataBits) {
     case SerialPort::Data5:
         m_currentTermios.c_cflag |= CS5;
@@ -753,26 +753,26 @@ bool UnixSerialPortEngine::setParity(SerialPort::Parity parity)
 #if defined (CMSPAR)
     // Here Installation parity only for GNU/Linux where the macro CMSPAR.
     case SerialPort::SpaceParity:
-        m_currentTermios.c_cflag &= (~PARODD);
-        m_currentTermios.c_cflag |= (PARENB | CMSPAR);
+        m_currentTermios.c_cflag &= ~PARODD;
+        m_currentTermios.c_cflag |= PARENB | CMSPAR;
         break;
     case SerialPort::MarkParity:
-        m_currentTermios.c_cflag |= (PARENB | CMSPAR | PARODD);
+        m_currentTermios.c_cflag |= PARENB | CMSPAR | PARODD;
         break;
 #endif
     case SerialPort::NoParity:
-        m_currentTermios.c_cflag &= (~PARENB);
+        m_currentTermios.c_cflag &= ~PARENB;
         break;
     case SerialPort::EvenParity:
-        m_currentTermios.c_cflag &= (~PARODD);
+        m_currentTermios.c_cflag &= ~PARODD;
         m_currentTermios.c_cflag |= PARENB;
         break;
     case SerialPort::OddParity:
-        m_currentTermios.c_cflag |= (PARENB | PARODD);
+        m_currentTermios.c_cflag |= PARENB | PARODD;
         break;
     default:
         m_currentTermios.c_cflag |= PARENB;
-        m_currentTermios.c_iflag |= (PARMRK | INPCK);
+        m_currentTermios.c_iflag |= PARMRK | INPCK;
         m_currentTermios.c_iflag &= ~IGNPAR;
         break;
     }
@@ -791,7 +791,7 @@ bool UnixSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
 {
     switch (stopBits) {
     case SerialPort::OneStop:
-        m_currentTermios.c_cflag &= (~CSTOPB);
+        m_currentTermios.c_cflag &= ~CSTOPB;
         break;
     case SerialPort::TwoStop:
         m_currentTermios.c_cflag |= CSTOPB;
@@ -815,16 +815,16 @@ bool UnixSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
 {
     switch (flow) {
     case SerialPort::NoFlowControl:
-        m_currentTermios.c_cflag &= (~CRTSCTS);
-        m_currentTermios.c_iflag &= (~(IXON | IXOFF | IXANY));
+        m_currentTermios.c_cflag &= ~CRTSCTS;
+        m_currentTermios.c_iflag &= ~(IXON | IXOFF | IXANY);
         break;
     case SerialPort::HardwareControl:
         m_currentTermios.c_cflag |= CRTSCTS;
-        m_currentTermios.c_iflag &= (~(IXON | IXOFF | IXANY));
+        m_currentTermios.c_iflag &= ~(IXON | IXOFF | IXANY);
         break;
     case SerialPort::SoftwareControl:
-        m_currentTermios.c_cflag &= (~CRTSCTS);
-        m_currentTermios.c_iflag |= (IXON | IXOFF | IXANY);
+        m_currentTermios.c_cflag &= ~CRTSCTS;
+        m_currentTermios.c_iflag |= IXON | IXOFF | IXANY;
         break;
     default:
         dptr->setError(SerialPort::UnsupportedPortOperationError);
@@ -842,8 +842,10 @@ bool UnixSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy
     tcflag_t parmrkMask = PARMRK;
 #ifndef CMSPAR
     //in space/mark parity emulation also used PARMRK flag
-    if (dptr->options.parity == SerialPort::SpaceParity || dptr->options.parity == SerialPort::MarkParity)
+    if (dptr->options.parity == SerialPort::SpaceParity
+            || dptr->options.parity == SerialPort::MarkParity) {
         parmrkMask = 0;
+    }
 #endif //CMSPAR
     switch (policy) {
     case SerialPort::SkipPolicy:
@@ -859,7 +861,7 @@ bool UnixSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy
         break;
     case SerialPort::StopReceivingPolicy:
         m_currentTermios.c_iflag &= ~IGNPAR;
-        m_currentTermios.c_iflag |= (parmrkMask | INPCK);
+        m_currentTermios.c_iflag |= parmrkMask | INPCK;
         break;
     default:
         dptr->setError(SerialPort::UnsupportedPortOperationError);
@@ -873,7 +875,7 @@ bool UnixSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy
 */
 bool UnixSerialPortEngine::isReadNotificationEnabled() const
 {
-    return (m_readNotifier && m_readNotifier->isEnabled());
+    return m_readNotifier && m_readNotifier->isEnabled();
 }
 
 /*!
@@ -902,7 +904,7 @@ void UnixSerialPortEngine::setReadNotificationEnabled(bool enable)
 */
 bool UnixSerialPortEngine::isWriteNotificationEnabled() const
 {
-    return (m_writeNotifier && m_writeNotifier->isEnabled());
+    return m_writeNotifier && m_writeNotifier->isEnabled();
 }
 
 /*!
@@ -930,7 +932,7 @@ void UnixSerialPortEngine::setWriteNotificationEnabled(bool enable)
 */
 bool UnixSerialPortEngine::isErrorNotificationEnabled() const
 {
-    return (m_exceptionNotifier && m_exceptionNotifier->isEnabled());
+    return m_exceptionNotifier && m_exceptionNotifier->isEnabled();
 }
 
 /*!
@@ -1081,7 +1083,7 @@ qint32 UnixSerialPortEngine::rateFromSetting(qint32 setting)
 {
     const RatePair rp = { 0, setting };
     const RatePair *ret = qFind(standardRatesTable, standardRatesTable_end, rp);
-    return (ret != standardRatesTable_end) ? ret->rate : 0;
+    return ret != standardRatesTable_end ? ret->rate : 0;
 }
 
 /*!
@@ -1092,7 +1094,7 @@ qint32 UnixSerialPortEngine::settingFromRate(qint32 rate)
 {
     const RatePair rp = { rate, 0 };
     const RatePair *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rp);
-    return (ret != standardRatesTable_end) ? ret->setting : 0;
+    return ret != standardRatesTable_end ? ret->setting : 0;
 }
 
 /*!
@@ -1121,20 +1123,19 @@ void UnixSerialPortEngine::detectDefaultSettings()
 
 #if defined (Q_OS_LINUX)
     // try detect the ability to support custom rate
-    m_isCustomRateSupported = (::ioctl(m_descriptor, TIOCGSERIAL, &m_currentSerialInfo) != -1)
-            && (::ioctl(m_descriptor, TIOCSSERIAL, &m_currentSerialInfo) != -1);
+    m_isCustomRateSupported = ::ioctl(m_descriptor, TIOCGSERIAL, &m_currentSerialInfo) != -1
+            && ::ioctl(m_descriptor, TIOCSSERIAL, &m_currentSerialInfo) != -1;
 
     if (m_isCustomRateSupported) {
 
         ::memcpy(&m_restoredSerialInfo, &m_currentSerialInfo, sizeof(struct serial_struct));
 
         // assume that the baud rate is a custom
-        isCustomRateCurrentSet = (inputUnixRate == B38400)
-                && (outputUnixRate == B38400);
+        isCustomRateCurrentSet = inputUnixRate == B38400 && outputUnixRate == B38400;
 
         if (isCustomRateCurrentSet) {
             if ((m_currentSerialInfo.flags & ASYNC_SPD_CUST)
-                    && (m_currentSerialInfo.custom_divisor > 0)) {
+                    && m_currentSerialInfo.custom_divisor > 0) {
 
                 // yes, speed is really custom
                 dptr->options.inputRate = m_currentSerialInfo.baud_base / m_currentSerialInfo.custom_divisor;
@@ -1169,26 +1170,28 @@ void UnixSerialPortEngine::detectDefaultSettings()
         break;
     default:
         dptr->options.dataBits = SerialPort::UnknownDataBits;
+        break;
     }
 
     // Detect parity.
 #if defined (CMSPAR)
     if (m_currentTermios.c_cflag & CMSPAR) {
-        dptr->options.parity = (m_currentTermios.c_cflag & PARODD) ?
+        dptr->options.parity = m_currentTermios.c_cflag & PARODD ?
                     SerialPort::MarkParity : SerialPort::SpaceParity;
     } else {
 #endif
         if (m_currentTermios.c_cflag & PARENB) {
-            dptr->options.parity = (m_currentTermios.c_cflag & PARODD) ?
+            dptr->options.parity = m_currentTermios.c_cflag & PARODD ?
                         SerialPort::OddParity : SerialPort::EvenParity;
-        } else
+        } else {
             dptr->options.parity = SerialPort::NoParity;
+        }
 #if defined (CMSPAR)
     }
 #endif
 
     // Detect stopbits.
-    dptr->options.stopBits = (m_currentTermios.c_cflag & CSTOPB) ?
+    dptr->options.stopBits = m_currentTermios.c_cflag & CSTOPB ?
                 SerialPort::TwoStop : SerialPort::OneStop;
 
     // Detect flow control.
@@ -1281,7 +1284,7 @@ qint64 UnixSerialPortEngine::writePerChar(const char *data, qint64 maxSize)
 
         bool par = evenParity(*data & charMask);
         // False if need EVEN, true if need ODD.
-        par ^= (dptr->options.parity == SerialPort::MarkParity);
+        par ^= dptr->options.parity == SerialPort::MarkParity;
         if (par ^ bool(m_currentTermios.c_cflag & PARODD)) { // Need switch parity mode?
             m_currentTermios.c_cflag ^= PARODD;
             flush(); //force sending already buffered data, because updateTermios() cleares buffers
@@ -1358,7 +1361,8 @@ qint64 UnixSerialPortEngine::readPerChar(char *data, qint64 maxSize)
                 if (dptr->options.parity != SerialPort::NoParity)
                     dptr->portError = SerialPort::ParityError;
                 else
-                    dptr->portError = (*data == '\0') ? SerialPort::BreakConditionError : SerialPort::FramingError;
+                    dptr->portError = *data == '\0' ?
+                                SerialPort::BreakConditionError : SerialPort::FramingError;
                 return ++ret;   //abort receiving
                 break;
             case SerialPort::UnknownPolicy:
diff --git a/src/serialportengine_win.cpp b/src/serialportengine_win.cpp
index 37f695b..e9fecc3 100755
--- a/src/serialportengine_win.cpp
+++ b/src/serialportengine_win.cpp
@@ -225,6 +225,7 @@ bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode
             break;
         default:
             dptr->setError(SerialPort::UnknownPortError);
+            break;
         }
         return false;
     }
@@ -313,10 +314,8 @@ SerialPort::Lines WinSerialPortEngine::lines() const
     DWORD modemStat = 0;
     SerialPort::Lines ret = 0;
 
-    if (::GetCommModemStatus(m_descriptor, &modemStat) == 0) {
-        // Print error?
+    if (::GetCommModemStatus(m_descriptor, &modemStat) == 0)
         return ret;
-    }
 
     if (modemStat & MS_CTS_ON)
         ret |= SerialPort::Cts;
@@ -348,7 +347,7 @@ SerialPort::Lines WinSerialPortEngine::lines() const
 */
 bool WinSerialPortEngine::setDtr(bool set)
 {
-    return ::EscapeCommFunction(m_descriptor, (set) ? SETDTR : CLRDTR);
+    return ::EscapeCommFunction(m_descriptor, set ? SETDTR : CLRDTR);
 }
 
 /*!
@@ -358,7 +357,7 @@ bool WinSerialPortEngine::setDtr(bool set)
 */
 bool WinSerialPortEngine::setRts(bool set)
 {
-    return ::EscapeCommFunction(m_descriptor, (set) ? SETRTS : CLRRTS);
+    return ::EscapeCommFunction(m_descriptor, set ? SETRTS : CLRRTS);
 }
 
 /*!
@@ -380,7 +379,7 @@ bool WinSerialPortEngine::flush()
 */
 bool WinSerialPortEngine::reset()
 {
-    const DWORD flags = (PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR);
+    const DWORD flags = PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR;
     return ::PurgeComm(m_descriptor, flags);
 }
 
@@ -410,8 +409,9 @@ bool WinSerialPortEngine::sendBreak(int duration)
 */
 bool WinSerialPortEngine::setBreak(bool set)
 {
-    return (set) ?
-                (::SetCommBreak(m_descriptor)) : (::ClearCommBreak(m_descriptor));
+    if (set)
+        return ::SetCommBreak(m_descriptor);
+    return ::ClearCommBreak(m_descriptor);
 }
 
 enum CommStatQue { CS_IN_QUE, CS_OUT_QUE };
@@ -421,7 +421,7 @@ static qint64 get_commstat_que(HANDLE m_descriptor, enum CommStatQue que)
     ::memset(&cs, 0, sizeof(COMSTAT));
     if (::ClearCommError(m_descriptor, 0, &cs) == 0)
         return -1;
-    return (que == CS_IN_QUE) ? cs.cbInQue : cs.cbOutQue;
+    return que == CS_IN_QUE ? cs.cbInQue : cs.cbOutQue;
 }
 
 /*!
@@ -495,13 +495,12 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
 #if defined (Q_OS_WINCE)
     sucessResult = ::ReadFile(m_descriptor, data, len, &readBytes, 0);
 #else
-    if (::ReadFile(m_descriptor, data, len, &readBytes, &m_readOverlapped))
+    if (::ReadFile(m_descriptor, data, len, &readBytes, &m_readOverlapped)) {
         sucessResult = true;
-    else if ((::GetLastError() == ERROR_IO_PENDING)
+    } else if (::GetLastError() == ERROR_IO_PENDING
              // Here have to wait for completion of pending transactions
              // to get the number of actually readed bytes.
              && ::GetOverlappedResult(m_descriptor, &m_readOverlapped, &readBytes, true)) {
-
         sucessResult = true;
     }
 #endif
@@ -521,7 +520,8 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
             break;
         case SerialPort::StopReceivingPolicy:
             break;
-        default:;
+        default:
+            break;
         }
     }
     return readBytes;
@@ -544,9 +544,9 @@ qint64 WinSerialPortEngine::write(const char *data, qint64 len)
 #if defined (Q_OS_WINCE)
     sucessResult = ::WriteFile(m_descriptor, data, len, &writeBytes, 0);
 #else
-    if (::WriteFile(m_descriptor, data, len, &writeBytes, &m_writeOverlapped))
+    if (::WriteFile(m_descriptor, data, len, &writeBytes, &m_writeOverlapped)) {
         sucessResult = true;
-    else if (::GetLastError() == ERROR_IO_PENDING) {
+    } else if (::GetLastError() == ERROR_IO_PENDING) {
         // This is not an error. In this case, the number of bytes actually
         // transmitted can be received only after the completion of pending
         // transactions, but it will freeze the event loop. The solution is
@@ -611,32 +611,27 @@ bool WinSerialPortEngine::select(int timeout,
         currEventMask |= EV_TXEMPTY;
 
     // Save old mask.
-    if (::GetCommMask(m_descriptor, &oldEventMask) == 0) {
-        //Print error?
+    if (::GetCommMask(m_descriptor, &oldEventMask) == 0)
         return false;
-    }
 
     // Checking the old mask bits as in the current mask.
     // And if these bits are not exists, then add them and set the reting mask.
     if (currEventMask != (oldEventMask & currEventMask)) {
         currEventMask |= oldEventMask;
-        if (::SetCommMask(m_descriptor, currEventMask) == 0) {
-            //Print error?
+        if (::SetCommMask(m_descriptor, currEventMask) == 0)
             return false;
-        }
     }
 
     currEventMask = 0;
     bool sucessResult = false;
 
 #if !defined (Q_OS_WINCE)
-    if (::WaitCommEvent(m_descriptor, &currEventMask, &m_selectOverlapped))
+    if (::WaitCommEvent(m_descriptor, &currEventMask, &m_selectOverlapped)) {
         sucessResult = true;
-    else if (::GetLastError() == ERROR_IO_PENDING) {
+    } else if (::GetLastError() == ERROR_IO_PENDING) {
         DWORD bytesTransferred = 0;
-        if ((::WaitForSingleObject(m_selectOverlapped.hEvent, (timeout < 0) ? 0 : timeout) == WAIT_OBJECT_0)
+        if (::WaitForSingleObject(m_selectOverlapped.hEvent, timeout < 0 ? 0 : timeout) == WAIT_OBJECT_0
                 && ::GetOverlappedResult(m_descriptor, &m_selectOverlapped, &bytesTransferred, false)) {
-
             sucessResult = true;
         } else {
             // Here there was a timeout or other error.
@@ -646,7 +641,7 @@ bool WinSerialPortEngine::select(int timeout,
     // FIXME: Here the situation is not properly handled with zero timeout:
     // breaker can work out before you call a method WaitCommEvent()
     // and so it will loop forever!
-    WinCeWaitCommEventBreaker breaker(m_descriptor, (timeout < 0) ? 0 : timeout);
+    WinCeWaitCommEventBreaker breaker(m_descriptor, timeout < 0 ? 0 : timeout);
     ::WaitCommEvent(m_descriptor, &currEventMask, 0);
     breaker.stop();
     sucessResult = !breaker.isWorked();
@@ -660,11 +655,11 @@ bool WinSerialPortEngine::select(int timeout,
         // adding (in the code above) extra bits in the mask currEventMask.
         if (checkRead) {
             Q_ASSERT(selectForRead);
-            *selectForRead = (currEventMask & EV_RXCHAR) && (bytesAvailable() > 0);
+            *selectForRead = (currEventMask & EV_RXCHAR) && bytesAvailable() > 0;
         }
         if (checkWrite) {
             Q_ASSERT(selectForWrite);
-            *selectForWrite =  (currEventMask & EV_TXEMPTY);
+            *selectForWrite =  currEventMask & EV_TXEMPTY;
         }
     }
 
@@ -922,7 +917,7 @@ void WinSerialPortEngine::setErrorNotificationEnabled(bool enable)
 bool WinSerialPortEngine::processIOErrors()
 {
     DWORD err = 0;
-    const bool ret = (::ClearCommError(m_descriptor, &err, 0) != 0);
+    const bool ret = ::ClearCommError(m_descriptor, &err, 0) != 0;
     if (ret && err) {
         if (err & CE_FRAME)
             dptr->setError(SerialPort::FramingError);
@@ -953,6 +948,8 @@ void WinSerialPortEngine::lockNotification(NotificationLockerType type, bool use
     case CanErrorLocker:
         mutex = &m_errorNotificationMutex;
         break;
+    default:
+        break;
     }
 
     if (uselocker)
@@ -973,6 +970,8 @@ void WinSerialPortEngine::unlockNotification(NotificationLockerType type)
     case CanErrorLocker:
         m_errorNotificationMutex.unlock();
         break;
+    default:
+        break;
     }
 }
 
@@ -1075,6 +1074,7 @@ void WinSerialPortEngine::detectDefaultSettings()
         break;
     default:
         dptr->options.dataBits = SerialPort::UnknownDataBits;
+        break;
     }
 
     // Detect parity.
@@ -1104,6 +1104,7 @@ void WinSerialPortEngine::detectDefaultSettings()
         break;
     default:
         dptr->options.stopBits = SerialPort::UnknownStopBits;
+        break;
     }
 
     // Detect flow control.
@@ -1184,9 +1185,9 @@ bool WinSerialPortEngine::event(QEvent *e)
             dptr->canWriteNotification();
             ret = true;
         }
-    }
-    else
+    } else {
         ret = QWinEventNotifier::event(e);
+    }
 
     ::WaitCommEvent(m_descriptor, &m_currentMask, &m_notifyOverlapped);
     return ret;
@@ -1259,7 +1260,7 @@ bool WinSerialPortEngine::isNotificationEnabled(DWORD mask) const
 #else
     enabled = isEnabled();
 #endif
-    return (enabled && (m_desiredMask & mask));
+    return enabled && (m_desiredMask & mask);
 }
 
 /*!
diff --git a/src/serialportinfo_mac.cpp b/src/serialportinfo_mac.cpp
index 90f146b..fc557ea 100644
--- a/src/serialportinfo_mac.cpp
+++ b/src/serialportinfo_mac.cpp
@@ -204,10 +204,8 @@ QList<SerialPortInfo> SerialPortInfo::availablePorts()
                                          buffer.data(),
                                          buffer.size(),
                                          kCFStringEncodingUTF8)) {
-
                     info.d_ptr->device = QString(buffer);
                 }
-
                 ::CFRelease(device);
             }
 
@@ -216,10 +214,8 @@ QList<SerialPortInfo> SerialPortInfo::availablePorts()
                                          buffer.data(),
                                          buffer.size(),
                                          kCFStringEncodingUTF8)) {
-
                     info.d_ptr->portName = QString(buffer);
                 }
-
                 ::CFRelease(portName);
             }
 
@@ -243,7 +239,6 @@ QList<SerialPortInfo> SerialPortInfo::availablePorts()
                 ::CFRelease(manufacturer);
             }
 
-
             int value = 0;
 
             if (vendorIdentifier) {
diff --git a/src/serialportinfo_symbian.cpp b/src/serialportinfo_symbian.cpp
index a0759bf..e49845c 100644
--- a/src/serialportinfo_symbian.cpp
+++ b/src/serialportinfo_symbian.cpp
@@ -82,16 +82,16 @@ static bool loadDevices()
 #endif
 
     r = User::LoadPhysicalDevice(KPddName);
-    if ((r != KErrNone) && (r != KErrAlreadyExists))
+    if (r != KErrNone && r != KErrAlreadyExists)
         return false; //User::Leave(r);
 
     r = User::LoadLogicalDevice(KLddName);
-    if ((r != KErrNone) && (r != KErrAlreadyExists))
+    if (r != KErrNone && r != KErrAlreadyExists)
         return false; //User::Leave(r);
 
 #if !defined (__WINS__)
     r = StartC32();
-    if ((r != KErrNone) && (r != KErrAlreadyExists))
+    if (r != KErrNone && r != KErrAlreadyExists)
         return false; //User::Leave(r);
 #endif
 
@@ -232,7 +232,7 @@ bool SerialPortInfo::isBusy() const
     r = port.Open(server, portName, ECommExclusive);
     if (r == KErrNone)
         port.Close();
-    return (r == KErrLocked);
+    return r == KErrLocked;
 }
 
 bool SerialPortInfo::isValid() const
@@ -250,7 +250,7 @@ bool SerialPortInfo::isValid() const
     r = port.Open(server, portName, ECommExclusive);
     if (r == KErrNone)
         port.Close();
-    return (r == KErrNone ) || (r == KErrLocked);
+    return r == KErrNone || r == KErrLocked;
 }
 
 QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialportinfo_win.cpp b/src/serialportinfo_win.cpp
index 433263f..7496b8c 100644
--- a/src/serialportinfo_win.cpp
+++ b/src/serialportinfo_win.cpp
@@ -99,9 +99,8 @@ static QVariant getDeviceRegistryProperty(HDEVINFO deviceInfoSet,
         case REG_EXPAND_SZ:
         case REG_SZ: {
             QString s;
-            if (dataSize) {
+            if (dataSize)
                 s = QString::fromWCharArray(((const wchar_t *)data.constData()));
-            }
             v = QVariant(s);
             break;
         }
@@ -126,9 +125,8 @@ static QVariant getDeviceRegistryProperty(HDEVINFO deviceInfoSet,
         case REG_NONE:
         case REG_BINARY: {
             QString s;
-            if (dataSize) {
+            if (dataSize)
                 s = QString::fromWCharArray((const wchar_t *)data.constData(), data.size() / 2);
-            }
             v = QVariant(s);
             break;
         }
@@ -144,6 +142,7 @@ static QVariant getDeviceRegistryProperty(HDEVINFO deviceInfoSet,
 
         default:
             v = QVariant();
+            break;
         }
 
     }
@@ -188,9 +187,9 @@ static QString getNativeName(HDEVINFO deviceInfoSet,
                     break;
                 }
             }
-        }
-        else
+        } else {
             break;
+        }
     }
 
     ::RegCloseKey(key);
@@ -244,7 +243,8 @@ static QString findDescription(HKEY parentKeyHandle, const QString &subKey)
                     if (dataSize)
                         result = QString::fromWCharArray(((const wchar_t *)data.constData()));
                     break;
-                default:;
+                default:
+                    break;
                 }
             }
         } else {
@@ -365,9 +365,9 @@ bool SerialPortInfo::isBusy() const
     if (descriptor == INVALID_HANDLE_VALUE) {
         if (::GetLastError() == ERROR_ACCESS_DENIED)
             return true;
-    }
-    else
+    } else {
         ::CloseHandle(descriptor);
+    }
     return false;
 }
 
@@ -382,9 +382,9 @@ bool SerialPortInfo::isValid() const
     if (descriptor == INVALID_HANDLE_VALUE) {
         if (::GetLastError() != ERROR_ACCESS_DENIED)
             return false;
-    }
-    else
+    } else {
         ::CloseHandle(descriptor);
+    }
     return true;
 }