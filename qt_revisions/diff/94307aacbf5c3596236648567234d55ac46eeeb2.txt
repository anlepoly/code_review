diff --git a/components/Button.qml b/components/Button.qml
index ccdbaa9..b27ee69 100644
--- a/components/Button.qml
+++ b/components/Button.qml
@@ -39,10 +39,10 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
+import "private"
 import QtDesktop 0.2
 
-Components.Button {
+BasicButton {
     id: button
 
     implicitWidth: Math.max(72, backgroundItem.implicitWidth)
@@ -51,6 +51,12 @@ Components.Button {
     property alias containsMouse: tooltip.containsMouse
     property bool defaultbutton: false
     property string styleHint
+    property string text
+    property url iconSource
+
+    Accessible.name: text
+
+    Keys.onSpacePressed:animateClick()
 
     TooltipArea {
         // Note this will eat hover events
@@ -74,28 +80,28 @@ Components.Button {
         activeControl: defaultbutton ? "default" : "f"
     }
 
-    label: Item {
-        // Used as a fallback since I can't pass the imageURL
-        // directly to the style object
-        visible: button.iconSource === ""
-        Row {
-            id: row
-            anchors.centerIn: parent
-            spacing: 4
-            Image {
-                source: iconSource
-                anchors.verticalCenter: parent.verticalCenter
-                fillMode: Image.Stretch //mm Image should shrink if button is too small, depends on QTBUG-14957
-            }
-            Text {
-                id:text
-                color: textColor
-                anchors.verticalCenter: parent.verticalCenter
-                text: button.text
-                horizontalAlignment: Text.Center
-            }
-        }
-    }
-    Keys.onSpacePressed:animateClick()
+// ## TODO: move to style implementation
+//    label: Item {
+//        // Used as a fallback since I can't pass the imageURL
+//        // directly to the style object
+//        visible: button.iconSource === ""
+//        Row {
+//            id: row
+//            anchors.centerIn: parent
+//            spacing: 4
+//            Image {
+//                source: iconSource
+//                anchors.verticalCenter: parent.verticalCenter
+//                fillMode: Image.Stretch //mm Image should shrink if button is too small, depends on QTBUG-14957
+//            }
+//            Text {
+//                id:text
+//                color: textColor
+//                anchors.verticalCenter: parent.verticalCenter
+//                text: button.text
+//                horizontalAlignment: Text.Center
+//            }
+//        }
+//    }
 }
 
diff --git a/components/ButtonColumn.qml b/components/ButtonColumn.qml
index f624e72..8b5f685 100644
--- a/components/ButtonColumn.qml
+++ b/components/ButtonColumn.qml
@@ -39,7 +39,52 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
+import "private/ButtonGroup.js" as Behavior
+
+/*
+   Class: ButtonColumn
+   A ButtonColumn allows you to group Buttons in a column. It provides a selection-behavior as well.
+
+   Note: This component don't support the enabled property.
+   If you need to disable it you should disable all the buttons inside it.
+
+   <code>
+       ButtonColumn {
+           Button { text: "Top" }
+           Button { text: "Bottom" }
+       }
+   </code>
+*/
+Column {
+    id: root
+
+    /*
+     * Property: exclusive
+     * [bool=true] Specifies the grouping behavior. If enabled, the checked property on buttons contained
+     * in the group will be exclusive.
+     *
+     * Note that a button in an exclusive group will allways be checkable
+     */
+    property bool exclusive: true
+
+    /*
+     * Property: styleHint
+     * [string] Used to indicate special OS specific button types
+     */
+    property string styleHint
+
+    /*
+     * Property: checkedButton
+     * [string] Contains the last checked Button.
+     */
+    property Item checkedButton;
+
+    Component.onCompleted: {
+        Behavior.create(root, {direction: Qt.Vertical});
+    }
+
+    Component.onDestruction: {
+        Behavior.destroy();
+    }
 
-Components.ButtonColumn {
 }
diff --git a/components/ButtonRow.qml b/components/ButtonRow.qml
index 49c0b34..be4f1b7 100644
--- a/components/ButtonRow.qml
+++ b/components/ButtonRow.qml
@@ -39,7 +39,50 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
+import "private/ButtonGroup.js" as Behavior
 
-Components.ButtonRow {
+/*
+   Class: ButtonRow
+   A ButtonRow allows you to group Buttons in a row. It provides a selection-behavior as well.
+
+   Note: This component don't support the enabled property.
+   If you need to disable it you should disable all the buttons inside it.
+
+   <code>
+       ButtonRow {
+           Button { text: "Left" }
+           Button { text: "Right" }
+       }
+   </code>
+*/
+Row {
+    id: root
+
+    /*
+     * Property: exclusive
+     * [bool=false] Specifies the grouping behavior. If enabled, the checked property on buttons contained
+     * in the group will be exclusive.
+     *
+     * Note that a button in an exclusive group will allways be checkable
+     */
+    property bool exclusive: false
+
+    /*
+     * Property: styleHint
+     * [string] Used to indicate special OS specific button types
+     */
+    property string styleHint
+    /*
+     * Property: checkedButton
+     * [string] Contains the last checked Button.
+     */
+    property Item checkedButton;
+
+    Component.onCompleted: {
+        Behavior.create(root, {direction: Qt.Horizontal});
+    }
+
+    Component.onDestruction: {
+        Behavior.destroy();
+    }
 }
diff --git a/components/CheckBox.qml b/components/CheckBox.qml
index 5345058..d2e2308 100644
--- a/components/CheckBox.qml
+++ b/components/CheckBox.qml
@@ -39,41 +39,69 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
+import "private"
 
-// jb : Size should not depend on background, we should make it consistent
+FocusScope {
+    id: checkBox
+
+    signal clicked
+
+    property alias pressed: behavior.pressed
+    property alias checked: behavior.checked
+    property alias containsMouse: behavior.containsMouse
 
-Components.CheckBox {
-    id: checkbox
     property string text
     property string styleHint
 
+    property Item backgroundItem: backgroundLoader.item
+
+    // implementation
+    Accessible.role: Accessible.CheckBox
+    Accessible.name: text
+
     implicitWidth: Math.max(120, backgroundItem.implicitWidth)
     implicitHeight: backgroundItem.implicitHeight
 
-    Accessible.name: text
+    property Component background: StyleItem {
+                elementType: "checkbox"
+                sunken: pressed
+                on: checked || pressed
+                hover: containsMouse
+                enabled: control.enabled
+                hasFocus: control.activeFocus
+                hint: control.styleHint
+                contentHeight: textitem.implicitHeight
+                contentWidth: textitem.implicitWidth + indicatorWidth
+                property int indicatorWidth: pixelMetric("indicatorwidth") + 2
+                Text {
+                    id: textitem
+                    text: control.text
+                    anchors.left: parent.left
+                    anchors.leftMargin: parent.indicatorWidth
+                    anchors.verticalCenter: parent.verticalCenter
+                    anchors.right: parent.right
+                    elide: Text.ElideRight
+                }
+            }
+
+    Loader {
+        id: backgroundLoader
+        anchors.fill: parent
+        property alias control: checkBox
+        sourceComponent: background
+    }
 
-    background: StyleItem {
-        elementType: "checkbox"
-        sunken: pressed
-        on: checked || pressed
-        hover: containsMouse
-        enabled: checkbox.enabled
-        hasFocus: checkbox.activeFocus
-        hint: checkbox.styleHint
-        contentHeight: textitem.implicitHeight
-        contentWidth: textitem.implicitWidth + indicatorWidth
-        property int indicatorWidth: pixelMetric("indicatorwidth") + 2
-        Text {
-            id: textitem
-            text: checkbox.text
-            anchors.left: parent.left
-            anchors.leftMargin: parent.indicatorWidth
-            anchors.verticalCenter: parent.verticalCenter
-            anchors.right: parent.right
-            elide: Text.ElideRight
+    ButtonBehavior {
+        id: behavior
+        focus: true
+        anchors.fill: parent
+        checkable: true
+        onClicked: {
+            if (checkBox.activeFocusOnPress)
+                checkBox.forceActiveFocus();
+            checkBox.clicked();
         }
     }
+    Keys.onSpacePressed: {clicked(); checked = !checked; }
 }
-
diff --git a/components/ComboBox.qml b/components/ComboBox.qml
index 3a913f2..0e7245b 100644
--- a/components/ComboBox.qml
+++ b/components/ComboBox.qml
@@ -39,7 +39,7 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Custom
+import "private" as Private
 import QtDesktop 0.2
 
 /*
@@ -92,7 +92,7 @@ import QtDesktop 0.2
 *
 */
 
-Custom.BasicButton {
+Private.BasicButton {
     id: comboBox
 
     default property alias menuItems: popup.menuItems
diff --git a/components/Dial.qml b/components/Dial.qml
index 59b2850..e8b9765 100644
--- a/components/Dial.qml
+++ b/components/Dial.qml
@@ -39,8 +39,6 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-
-import "custom" as Components
 import QtDesktop 0.2
 
 // jens: ContainsMouse breaks drag functionality
diff --git a/components/Frame.qml b/components/Frame.qml
index 0a6596a..7b82378 100644
--- a/components/Frame.qml
+++ b/components/Frame.qml
@@ -39,7 +39,6 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
 Item {
diff --git a/components/GroupBox.qml b/components/GroupBox.qml
index b3f04f4..c87ade5 100644
--- a/components/GroupBox.qml
+++ b/components/GroupBox.qml
@@ -39,15 +39,30 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
-Components.GroupBox {
+Item {
     id: groupbox
-    implicitWidth: Math.max(200, contentWidth + backgroundItem.implicitWidth)
-    implicitHeight: contentHeight + backgroundItem.implicitHeight + 4
+    implicitWidth: Math.max(200, contentWidth + loader.item.implicitWidth)
+    implicitHeight: contentHeight + loader.item.implicitHeight + 4
+
+    default property alias data: content.data
+
+    property string title
     property bool flat: false
-    background : StyleItem {
+    property bool checkable: false
+    property int contentWidth: content.childrenRect.width
+    property int contentHeight: content.childrenRect.height
+
+    property Item checkbox: check
+    property alias checked: check.checked
+    property bool adjustToContentSize: false // Resizes groupbox to fit contents.
+                                             // Note when using this, you cannot anchor children
+
+    Accessible.role: Accessible.Grouping
+    Accessible.name: title
+
+    property Component background: StyleItem {
         id: styleitem
         elementType: "groupbox"
         anchors.fill: parent
@@ -60,6 +75,36 @@ Components.GroupBox {
         contentHeight:  (title.length > 0 || checkable) ? 24 : 4
     }
 
-    Accessible.role: Accessible.Grouping
-    Accessible.name: title
+    Loader {
+        id: loader
+        anchors.fill: parent
+        property int topMargin: title.length > 0 || checkable ? 22 : 4
+        property int bottomMargin: 4
+        property int leftMargin: 4
+        property int rightMargin: 4
+        property alias styledItem: groupbox
+        sourceComponent: background
+    }
+
+    CheckBox {
+        id: check
+        checked: true
+        visible: checkable
+        anchors.top: parent.top
+        anchors.left: parent.left
+        anchors.right: parent.right
+        height: loader.topMargin
+    }
+
+    Item {
+        id:content
+        z: 1
+        focus: true
+        anchors.topMargin: loader.topMargin
+        anchors.leftMargin: 8
+        anchors.rightMargin: 8
+        anchors.bottomMargin: 8
+        anchors.fill: parent
+        enabled: (!checkable || checkbox.checked)
+    }
 }
diff --git a/components/ProgressBar.qml b/components/ProgressBar.qml
index ed54b71..d07aa9d 100644
--- a/components/ProgressBar.qml
+++ b/components/ProgressBar.qml
@@ -39,22 +39,30 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
-Components.ProgressBar {
+Item {
     id:progressbar
 
+    property real value: 0
+    property real minimumValue: 0
+    property real maximumValue: 1
+    property bool indeterminate: false
+    property bool containsMouse: mouseArea.containsMouse
+
+    property int minimumWidth: 0
+    property int minimumHeight: 0
+
     property int orientation: Qt.Horizontal
     property string styleHint
 
-    implicitWidth: orientation === Qt.Horizontal ? 200 : backgroundItem.implicitHeight
-    implicitHeight: orientation === Qt.Horizontal ? backgroundItem.implicitHeight : 200
-
+    Accessible.role: Accessible.ProgressBar
+    Accessible.name: value
 
-    SystemPalette {id: syspal}
+    implicitWidth: orientation === Qt.Horizontal ? 200 : loader.item.implicitHeight
+    implicitHeight: orientation === Qt.Horizontal ? loader.item.implicitHeight : 200
 
-    background: StyleItem {
+    property Component background: StyleItem {
         anchors.fill: parent
         elementType: "progressbar"
         // XXX: since desktop uses int instead of real, the progressbar
@@ -69,5 +77,22 @@ Components.ProgressBar {
         contentWidth: 23
         contentHeight: 23
     }
+
+    Loader {
+        id: loader
+        property alias indeterminate: progressbar.indeterminate
+        property alias value:progressbar.value
+        property alias maximumValue:progressbar.maximumValue
+        property alias minimumValue:progressbar.minimumValue
+
+        sourceComponent: background
+        anchors.fill: parent
+    }
+
+    MouseArea {
+        id: mouseArea
+        anchors.fill: parent
+        hoverEnabled: true
+    }
 }
 
diff --git a/components/RadioButton.qml b/components/RadioButton.qml
index 59517d7..9037666 100644
--- a/components/RadioButton.qml
+++ b/components/RadioButton.qml
@@ -39,15 +39,12 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
 // jb : Size should not depend on background, we should make it consistent
 
-Components.CheckBox {
+CheckBox {
     id: radiobutton
-    property string text
-    property string styleHint
 
     implicitWidth: Math.max(120, backgroundItem.implicitWidth)
     implicitHeight: backgroundItem.implicitHeight
diff --git a/components/ScrollArea.qml b/components/ScrollArea.qml
index 67bc292..5c0ec0e 100644
--- a/components/ScrollArea.qml
+++ b/components/ScrollArea.qml
@@ -39,9 +39,8 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
-import "private" as Private
 import QtDesktop 0.2
+import "private" as Private
 
 FocusScope {
     id: root
diff --git a/components/ScrollBar.qml b/components/ScrollBar.qml
index c8379d7..071dee4 100644
--- a/components/ScrollBar.qml
+++ b/components/ScrollBar.qml
@@ -39,7 +39,6 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
 Item {
@@ -186,8 +185,8 @@ Item {
             enabled: parent.enabled
         }
 
-        property variant handleRect: Qt.rect(0,0,0,0)
-        property variant grooveRect: Qt.rect(0,0,0,0)
+        property rect handleRect: Qt.rect(0,0,0,0)
+        property rect grooveRect: Qt.rect(0,0,0,0)
         function updateHandle() {
             internal.handleRect = styleitem.subControlRect("handle")
             grooveRect = styleitem.subControlRect("groove");
@@ -203,5 +202,4 @@ Item {
             positionAtMaximum: internal.grooveSize
         }
     }
-
 }
diff --git a/components/Slider.qml b/components/Slider.qml
index 374b839..de58112 100644
--- a/components/Slider.qml
+++ b/components/Slider.qml
@@ -39,17 +39,39 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
 // jens: ContainsMouse breaks drag functionality
 
-Components.Slider{
+Item {
     id: slider
 
+    // Common API
+    property int orientation: Qt.Horizontal
+    property alias minimumValue: range.minimumValue
+    property alias maximumValue: range.maximumValue
+    property alias inverted: range.inverted
+    property bool updateValueWhileDragging: true
+    property alias pressed: mouseArea.pressed
+    property alias stepSize: range.stepSize
+    property alias hoverEnabled: mouseArea.hoverEnabled
+    property alias value: range.value
+
+    // Destop API
+    property bool containsMouse: mouseArea.containsMouse
+    property bool activeFocusOnPress: false
     property bool tickmarksEnabled: false
     property string tickPosition: "Below" // "Above", "Below", "BothSides"
 
+    Accessible.role: Accessible.Slider
+    Accessible.name: value
+
+    // Reimplement this function to control how the value is shown in the
+    // indicator.
+    function formatValue(v) {
+        return Math.round(v);
+    }
+
     StyleItem {
         id:buttonitem
         elementType: "slider"
@@ -57,14 +79,12 @@ Components.Slider{
         contentHeight:23
     }
 
-    property int orientation: Qt.Horizontal
-
     implicitWidth: orientation === Qt.Horizontal ? 200 : buttonitem.implicitHeight
     implicitHeight: orientation === Qt.Horizontal ? buttonitem.implicitHeight : 200
 
     property string styleHint;
 
-    groove: StyleItem {
+    property Component groove: StyleItem {
         anchors.fill:parent
         elementType: "slider"
         sunken: pressed
@@ -79,12 +99,132 @@ Components.Slider{
         activeControl: tickmarksEnabled ? tickPosition.toLowerCase() : ""
     }
 
-    handle: null
-    valueIndicator: null
-
     Keys.onRightPressed: value += (maximumValue - minimumValue)/10.0
     Keys.onLeftPressed: value -= (maximumValue - minimumValue)/10.0
 
+    Item {
+        id: contents
+
+        width: orientation == Qt.Vertical ? slider.height : slider.width
+        height: orientation == Qt.Vertical ? slider.width : slider.height
+        rotation: orientation == Qt.Vertical ? -90 : 0
+
+        anchors.centerIn: slider
+
+        RangeModel {
+            id: range
+            minimumValue: 0.0
+            maximumValue: 1.0
+            value: 0
+            stepSize: 0.0
+            inverted: false
+
+            positionAtMinimum: grooveLoader.leftMargin
+            positionAtMaximum: contents.width - grooveLoader.rightMargin
+        }
+
+        Loader {
+            id: grooveLoader
+            anchors.fill: parent
+            sourceComponent: groove
+
+            property real handlePosition : handleLoader.x
+            function positionForValue(value) {
+                return range.positionForValue(value) - leftMargin;
+            }
+            property int leftMargin: 0
+            property int rightMargin: 0
+        }
+
+        Loader {
+            id: handleLoader
+            transform: Translate { x: - handleLoader.width / 2 }
+
+            anchors.verticalCenter: grooveLoader.verticalCenter
+
+            sourceComponent: null
+
+            x: fakeHandle.x
+            Behavior on x {
+                id: behavior
+                enabled: !mouseArea.drag.active
+
+                PropertyAnimation {
+                    duration: behavior.enabled ? 150 : 0
+                    easing.type: Easing.OutSine
+                }
+            }
+        }
+
+        Item {
+            id: fakeHandle
+            width: handleLoader.width
+            height: handleLoader.height
+            transform: Translate { x: - handleLoader.width / 2 }
+        }
+
+        MouseArea {
+            id: mouseArea
+            hoverEnabled: true
+            anchors.centerIn: parent
+            anchors.horizontalCenterOffset: (grooveLoader.leftMargin - grooveLoader.rightMargin) / 2
+
+            width: parent.width + handleLoader.width - grooveLoader.rightMargin - grooveLoader.leftMargin
+            height: parent.height
+
+            drag.target: fakeHandle
+            drag.axis: Drag.XAxis
+            drag.minimumX: range.positionAtMinimum
+            drag.maximumX: range.positionAtMaximum
+
+            onPressed: {
+
+                if (activeFocusOnPress)
+                    slider.focus = true;
+
+                // Clamp the value
+                var newX = Math.max(mouse.x, drag.minimumX);
+                newX = Math.min(newX, drag.maximumX);
+
+                // Debounce the press: a press event inside the handler will not
+                // change its position, the user needs to drag it.
+
+                // Note this really messes up things for scrollbar
+                // if (Math.abs(newX - fakeHandle.x) > handleLoader.width / 2)
+                range.position = newX;
+            }
+
+            onReleased: {
+                // If we don't update while dragging, this is the only
+                // moment that the range is updated.
+                if (!slider.updateValueWhileDragging)
+                    range.position = fakeHandle.x;
+            }
+        }
+
+
+    }
+    // Range position normally follow fakeHandle, except when
+    // 'updateValueWhileDragging' is false. In this case it will only follow
+    // if the user is not pressing the handle.
+    Binding {
+        when: updateValueWhileDragging || !mouseArea.pressed
+        target: range
+        property: "position"
+        value: fakeHandle.x
+    }
+
+    // During the drag, we simply ignore position set from the range, this
+    // means that setting a value while dragging will not "interrupt" the
+    // dragging activity.
+    Binding {
+        when: !mouseArea.drag.active
+        target: fakeHandle
+        property: "x"
+        value: range.position
+    }
+
+
     WheelArea {
         id: wheelarea
         anchors.fill: parent
@@ -102,5 +242,4 @@ Components.Slider{
             value += horizontalDelta/4*step
         }
     }
-
 }
diff --git a/components/SpinBox.qml b/components/SpinBox.qml
index 60641cb..cffa68b 100644
--- a/components/SpinBox.qml
+++ b/components/SpinBox.qml
@@ -39,47 +39,53 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
-Components.SpinBox {
-    id:spinbox
+FocusScope {
+    id: spinbox
 
-    property variant __upRect;
-    property variant __downRect;
-    property int __margin: (height -16)/2
-    property string styleHint
+    property int minimumWidth: 0
+    property int minimumHeight: 0
 
-    // Align height with button
-    topMargin: __margin
-    bottomMargin: __margin
+    property real value: 0.0
+    property real maximumValue: 99
+    property real minimumValue: 0
+    property real singleStep: 1
+    property string postfix
 
-    leftMargin:6
-    rightMargin:6
+    property bool upEnabled: value != maximumValue;
+    property bool downEnabled: value != minimumValue;
+    property alias upPressed: mouseUp.pressed
+    property alias downPressed: mouseDown.pressed
+    property alias upHovered: mouseUp.containsMouse
+    property alias downHovered: mouseDown.containsMouse
+    property alias containsMouse: mouseArea.containsMouse
+    property alias font: input.font
+    property string styleHint
 
-    StyleItem {
-        id:edititem
-        elementType: "edit"
-        visible: false
-        contentWidth: 70
-        contentHeight: 20
-    }
+    Accessible.name: input.text
+    Accessible.role: Accessible.SpinBox
 
-    implicitWidth: edititem.implicitWidth
-    implicitHeight: edititem.implicitHeight
+    SystemPalette {
+        id: syspal
+        colorGroup: enabled ? SystemPalette.Active : SystemPalette.Disabled
+    }
 
-    clip:false
+    property Component background: Item {
 
-    background: Item {
-        anchors.fill: parent
-        property variant __editRect
+        property rect upRect
+        property rect downRect
+        property rect inputRect
+        implicitHeight: styleitem.implicitHeight
+        implicitWidth: styleitem.implicitWidth
 
         Rectangle {
             id: editBackground
-            x: __editRect.x - 1
-            y: __editRect.y
-            width: __editRect.width + 1
-            height: __editRect.height
+            x: inputRect.x - 1
+            y: inputRect.y
+            width: inputRect.width + 1
+            height: inputRect.height
+            color: "white"
         }
 
         Item {
@@ -98,11 +104,9 @@ Components.SpinBox {
         }
 
         function updateRect() {
-            __upRect = styleitem.subControlRect("up");
-            __downRect = styleitem.subControlRect("down");
-            __editRect = styleitem.subControlRect("edit");
-            spinbox.leftMargin = __editRect.x + 2
-            spinbox.rightMargin = spinbox.width -__editRect.width - __editRect.x
+            upRect = styleitem.subControlRect("up");
+            downRect = styleitem.subControlRect("down");
+            inputRect = styleitem.subControlRect("edit");
         }
 
         Component.onCompleted: updateRect()
@@ -113,6 +117,8 @@ Components.SpinBox {
             id: styleitem
             anchors.fill: parent
             elementType: "spinbox"
+            contentWidth: 200
+            contentHeight: 26
             sunken: (downEnabled && downPressed) | (upEnabled && upPressed)
             hover: containsMouse
             hasFocus: spinbox.focus
@@ -125,17 +131,132 @@ Components.SpinBox {
         }
     }
 
-    up: Item {
-        x: __upRect.x
-        y: __upRect.y
-        width: __upRect.width
-        height: __upRect.height
+    width: implicitWidth
+    height: implicitHeight
+
+    implicitWidth: loader.item ? loader.item.implicitWidth : 0
+    implicitHeight: loader.item ? loader.item.implicitHeight : 0
+
+    function increment() {
+        setValue(input.text)
+        value += singleStep
+        if (value > maximumValue)
+            value = maximumValue
+        input.text = value
+    }
+
+    function decrement() {
+        setValue(input.text)
+        value -= singleStep
+        if (value < minimumValue)
+            value = minimumValue
+        input.text = value
+    }
+
+    function setValue(v) {
+        var newval = parseFloat(v)
+        if (newval > maximumValue)
+            newval = maximumValue
+        else if (v < minimumValue)
+            newval = minimumValue
+        value = newval
+        input.text = value
+    }
+
+    Component.onCompleted: setValue(value)
+
+    onValueChanged: {
+        input.valueUpdate = true
+        input.text = value
+        input.valueUpdate = false
+    }
+
+    Loader {
+        id: loader
+        property rect upRect: item ? item.upRect : Qt.rect(0, 0, 0, 0)
+        property rect downRect: item ? item.downRect : Qt.rect(0, 0, 0, 0)
+        property rect inputRect: item ? item.inputRect : Qt.rect(0, 0, 0, 0)
+        sourceComponent: background
+        anchors.fill: parent
+    }
+
+    MouseArea {
+        id: mouseArea
+        anchors.fill: parent
+        hoverEnabled: true
+    }
+
+    // Spinbox input field
+
+    TextInput {
+        id: input
+
+        property bool valueUpdate: false
+
+        clip: true
+
+        x: loader.inputRect.x
+        y: loader.inputRect.y
+        width: loader.inputRect.width
+        height: loader.inputRect.height
+        selectByMouse: true
+
+        // validator: DoubleValidator { bottom: minimumValue; top: maximumValue; }
+        onAccepted: {setValue(input.text)}
+        onActiveFocusChanged: setValue(input.text)
+        color: syspal.text
+        opacity: parent.enabled ? 1 : 0.5
+        Text {
+            text: postfix
+            anchors.rightMargin: 4
+            anchors.right: parent.right
+            anchors.verticalCenter: parent.verticalCenter
+        }
+    }
+
+    // Spinbox increment button
+
+    MouseArea {
+        id: mouseUp
+
+        anchors.left: parent.left
+        anchors.top: parent.top
+
+        anchors.leftMargin: loader.upRect.x
+        anchors.topMargin: loader.upRect.y
+
+        width: loader.upRect.width
+        height: loader.upRect.height
+
+        onClicked: increment()
+
+        property bool autoincrement: false;
+        onReleased: autoincrement = false
+        Timer { running: mouseUp.pressed; interval: 350 ; onTriggered: mouseUp.autoincrement = true }
+        Timer { running: mouseUp.autoincrement; interval: 60 ; repeat: true ; onTriggered: increment() }
     }
 
-    down: Item {
-        x: __downRect.x
-        y: __downRect.y
-        width: __downRect.width
-        height: __downRect.height
+    // Spinbox decrement button
+
+    MouseArea {
+        id: mouseDown
+        onClicked: decrement()
+
+        anchors.left: parent.left
+        anchors.top: parent.top
+
+        anchors.leftMargin: loader.downRect.x
+        anchors.topMargin: loader.downRect.y
+
+        width: loader.downRect.width
+        height: loader.downRect.height
+
+        property bool autoincrement: false;
+        onReleased: autoincrement = false
+        Timer { running: mouseDown.pressed; interval: 350 ; onTriggered: mouseDown.autoincrement = true }
+        Timer { running: mouseDown.autoincrement; interval: 60 ; repeat: true ; onTriggered: decrement() }
     }
+
+    Keys.onUpPressed: increment()
+    Keys.onDownPressed: decrement()
 }
diff --git a/components/SplitterColumn.qml b/components/SplitterColumn.qml
index feb12de..86d9b8f 100644
--- a/components/SplitterColumn.qml
+++ b/components/SplitterColumn.qml
@@ -39,7 +39,7 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
+import "private" as Private
 import QtDesktop 0.2
 
 /*
@@ -138,7 +138,7 @@ import QtDesktop 0.2
 *    }
 */
 
-Components.Splitter {
+Private.Splitter {
     orientation: Qt.Vertical
     handleBackground: StyleItem {
         id: styleitem
diff --git a/components/SplitterRow.qml b/components/SplitterRow.qml
index 4385614..5c566d6 100644
--- a/components/SplitterRow.qml
+++ b/components/SplitterRow.qml
@@ -39,7 +39,7 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
+import "private" as Private
 import QtDesktop 0.2
 
 /*
@@ -139,7 +139,7 @@ import QtDesktop 0.2
 */
 
 
-Components.Splitter {
+Private.Splitter {
     orientation: Qt.Horizontal
     handleBackground: StyleItem {
         id: styleitem
diff --git a/components/StatusBar.qml b/components/StatusBar.qml
index cd6777d..1645de7 100644
--- a/components/StatusBar.qml
+++ b/components/StatusBar.qml
@@ -39,8 +39,6 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "."
-import "custom" as Components
 
 Item {
     width: parent ? parent.width : 200
diff --git a/components/TabBar.qml b/components/TabBar.qml
index 8ebc6ff..0263511 100644
--- a/components/TabBar.qml
+++ b/components/TabBar.qml
@@ -39,10 +39,8 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
-
 Item {
     id: tabbar
     property int tabHeight: tabrow.height
diff --git a/components/TabFrame.qml b/components/TabFrame.qml
index 3b0e151..f15067b 100644
--- a/components/TabFrame.qml
+++ b/components/TabFrame.qml
@@ -39,7 +39,6 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
 Item {
diff --git a/components/TextArea.qml b/components/TextArea.qml
index 6441aa9..05a2b77 100644
--- a/components/TextArea.qml
+++ b/components/TextArea.qml
@@ -39,7 +39,6 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
 ScrollArea {
diff --git a/components/TextField.qml b/components/TextField.qml
index 918be4d..4cf7e3f 100644
--- a/components/TextField.qml
+++ b/components/TextField.qml
@@ -39,31 +39,34 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
 
-Components.TextField {
+FocusScope {
     id: textfield
-    minimumWidth: 200
+    property alias text: textInput.text
+    property alias font: textInput.font
 
-    placeholderText: ""
-    topMargin: 2
-    bottomMargin: 2
-    leftMargin: 6
-    rightMargin: 6
+    property int minimumWidth: 0
+    property int minimumHeight: 0
 
-    implicitWidth: backgroundItem.implicitWidth
-    implicitHeight: backgroundItem.implicitHeight
+    property int inputHint // values tbd
+    property bool acceptableInput: textInput.acceptableInput // read only
+    property alias readOnly: textInput.readOnly // read only
+    property alias placeholderText: placeholderTextComponent.text
+    property bool  passwordMode: false
+    property alias selectedText: textInput.selectedText
+    property alias selectionEnd: textInput.selectionEnd
+    property alias selectionStart: textInput.selectionStart
+    property alias validator: textInput.validator
+    property alias inputMask: textInput.inputMask
+    property alias horizontalalignment: textInput.horizontalAlignment
+    property alias echoMode: textInput.echoMode
+    property alias cursorPosition: textInput.cursorPosition
+    property alias inputMethodHints: textInput.inputMethodHints
+    property alias activeFocusOnPress: textInput.activeFocusOnPress
+    property alias containsMouse: mouseArea.containsMouse
 
-    clip: false
-
-    Accessible.name: text
-    Accessible.role: Accessible.EditableText
-    Accessible.description: placeholderText
-
-    property string styleHint
-
-    background: StyleItem {
+    property Component background: StyleItem {
         anchors.fill: parent
         elementType: "edit"
         sunken: true
@@ -72,22 +75,123 @@ Components.TextField {
         hint: textfield.styleHint
         contentWidth: 200
         contentHeight: 25
-    }
 
-    Item{
-        id: focusFrame
-        anchors.fill: textfield
-        parent: textfield
-        visible: framestyle.styleHint("focuswidget")
-        StyleItem {
-            id: framestyle
-            anchors.margins: -2
-            anchors.rightMargin:-4
-            anchors.bottomMargin:-4
+        Item {
+            id: focusFrame
             anchors.fill: parent
-            visible: textfield.activeFocus
-            hint: textfield.styleHint
-            elementType: "focusframe"
+            parent: textfield
+            visible: framestyle.styleHint("focuswidget")
+            StyleItem {
+                id: framestyle
+                anchors.margins: -2
+                anchors.rightMargin:-4
+                anchors.bottomMargin:-4
+                anchors.fill: parent
+                visible: textfield.activeFocus
+                hint: textfield.styleHint
+                elementType: "focusframe"
+            }
         }
+
+    }
+
+    implicitWidth: backgroundLoader.item.implicitWidth
+    implicitHeight: backgroundLoader.item.implicitHeight
+
+    Accessible.name: text
+    Accessible.role: Accessible.EditableText
+    Accessible.description: placeholderText
+
+    property string styleHint
+
+
+    function copy() {
+        textInput.copy()
+    }
+
+    function paste() {
+        textInput.paste()
+    }
+
+    function cut() {
+        textInput.cut()
+    }
+
+    function select(start, end) {
+        textInput.select(start, end)
+    }
+
+    function selectAll() {
+        textInput.selectAll()
+    }
+
+    function selectWord() {
+        textInput.selectWord()
+    }
+
+    function positionAt(x) {
+        var p = mapToItem(textInput, x, 0);
+        return textInput.positionAt(p.x);
+    }
+
+    function positionToRectangle(pos) {
+        var p = mapToItem(textInput, pos.x, pos.y);
+        return textInput.positionToRectangle(p);
+    }
+
+    // Implementation
+
+    SystemPalette {
+        id: syspal
+        colorGroup: enabled ? SystemPalette.Active : SystemPalette.Disabled
+    }
+
+    Loader {
+        id: backgroundLoader;
+        sourceComponent: background;
+        anchors.fill:parent
+    }
+
+    MouseArea {
+        id: mouseArea
+        anchors.fill: parent
+        hoverEnabled: true
+        onClicked: textfield.forceActiveFocus()
+    }
+
+    onFocusChanged: {
+        if (textField.activeFocus)
+            textInput.forceActiveFocus();
+    }
+
+    TextInput { // see QTBUG-14936
+        id: textInput
+        selectByMouse:true
+
+        // Todo move these margins to StyleItem
+        anchors.leftMargin: 4
+        anchors.topMargin: 4
+        anchors.rightMargin: 4
+        anchors.bottomMargin: 4
+
+        anchors.left: parent.left
+        anchors.right: parent.right
+        anchors.verticalCenter: parent.verticalCenter
+
+        color: syspal.text
+        echoMode: passwordMode ? TextInput.Password : TextInput.Normal
+        clip: true
+    }
+
+    Text {
+        id: placeholderTextComponent
+        anchors.fill: textInput
+        font: textInput.font
+        opacity: !textInput.text.length && !textInput.activeFocus ? 1 : 0
+        color: "darkgray"
+        text: "Enter text"
+        clip: true
+        elide: Text.ElideRight
+        Behavior on opacity { NumberAnimation { duration: 90 } }
     }
 }
diff --git a/components/ToolBar.qml b/components/ToolBar.qml
index 6edd7ff..6892b8e 100644
--- a/components/ToolBar.qml
+++ b/components/ToolBar.qml
@@ -39,8 +39,6 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "."
-import "custom" as Components
 import QtDesktop 0.2
 
 StyleItem {
diff --git a/components/ToolButton.qml b/components/ToolButton.qml
index 6bf2c9d..7f41fe6 100644
--- a/components/ToolButton.qml
+++ b/components/ToolButton.qml
@@ -39,16 +39,18 @@
 ****************************************************************************/
 
 import QtQuick 2.0
-import "custom" as Components
 import QtDesktop 0.2
+import "private" as Private
 
-Components.Button {
+Private.BasicButton {
     id:button
 
     property alias containsMouse: tooltip.containsMouse
     property string iconName
     property string styleHint
     property int iconSize: (backgroundItem && backgroundItem.style === "mac" && button.styleHint.indexOf("segmented") !== -1) ? 16 : 24
+    property url iconSource
+    property string text
 
     implicitWidth: backgroundItem.implicitWidth
     implicitHeight: backgroundItem.implicitHeight
@@ -96,4 +98,5 @@ Components.Button {
             source: visible ? button.iconSource : ""
         }
     }
+    Accessible.name: text
 }
diff --git a/components/custom/BasicButton.qml b/components/custom/BasicButton.qml
deleted file mode 100644
index 972ac19..0000000
--- a/components/custom/BasicButton.qml
+++ /dev/null
@@ -1,106 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-import "./behaviors"    // ButtonBehavior
-
-Item {
-    id: button
-
-    signal clicked
-    property alias pressed: behavior.pressed
-    property alias containsMouse: behavior.containsMouse
-    property alias checkable: behavior.checkable  // button toggles between checked and !checked
-    property alias checked: behavior.checked
-    property bool activeFocusOnPress: false
-
-    property Component background: null
-    property Item backgroundItem: backgroundLoader.item
-
-    property color textColor: syspal.text;
-    property string tooltip
-
-    Accessible.role: Accessible.Button
-    Accessible.description: tooltip
-
-    signal toolTipTriggered
-
-    // implementation
-
-    property string __position: "only"
-    implicitWidth: backgroundLoader.item.width
-    implicitHeight: backgroundLoader.item.height
-
-    function animateClick() {
-        behavior.pressed = true
-        behavior.clicked()
-        animateClickTimer.start()
-    }
-
-    Timer {
-        id: animateClickTimer
-        interval: 250
-        onTriggered: behavior.pressed = false
-    }
-
-    Loader {
-        id: backgroundLoader
-        anchors.fill: parent
-        sourceComponent: background
-        property alias styledItem: button
-        property alias position: button.__position
-    }
-
-    ButtonBehavior {
-        id: behavior
-        anchors.fill: parent
-        onClicked: button.clicked()
-        onPressedChanged: if (activeFocusOnPress) button.focus = true
-        onMouseMoved: {tiptimer.restart()}
-        Timer{
-            id: tiptimer
-            interval:1000
-            running:containsMouse && tooltip.length
-            onTriggered: button.toolTipTriggered()
-        }
-    }
-
-    SystemPalette { id: syspal }
-}
diff --git a/components/custom/Button.qml b/components/custom/Button.qml
deleted file mode 100644
index d54e09f..0000000
--- a/components/custom/Button.qml
+++ /dev/null
@@ -1,62 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-
-BasicButton {
-    id: button
-
-    property string text
-    property url iconSource
-    property Component label: null
-
-    // implementation
-    Accessible.name: text
-
-    background: defaultStyle.background
-    property Item labelItem: labelLoader.item
-
-    Loader {
-        id: labelLoader
-        anchors.fill: parent
-        property alias styledItem: button
-        sourceComponent: label
-    }
-}
diff --git a/components/custom/ButtonColumn.qml b/components/custom/ButtonColumn.qml
deleted file mode 100644
index ec0d625..0000000
--- a/components/custom/ButtonColumn.qml
+++ /dev/null
@@ -1,90 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-import "ButtonGroup.js" as Behavior
-
-/*
-   Class: ButtonColumn
-   A ButtonColumn allows you to group Buttons in a column. It provides a selection-behavior as well.
-
-   Note: This component don't support the enabled property.
-   If you need to disable it you should disable all the buttons inside it.
-
-   <code>
-       ButtonColumn {
-           Button { text: "Top" }
-           Button { text: "Bottom" }
-       }
-   </code>
-*/
-Column {
-    id: root
-
-    /*
-     * Property: exclusive
-     * [bool=true] Specifies the grouping behavior. If enabled, the checked property on buttons contained
-     * in the group will be exclusive.
-     *
-     * Note that a button in an exclusive group will allways be checkable
-     */
-    property bool exclusive: true
-
-    /*
-     * Property: styleHint
-     * [string] Used to indicate special OS specific button types
-     */
-    property string styleHint
-
-    /*
-     * Property: checkedButton
-     * [string] Contains the last checked Button.
-     */
-    property Item checkedButton;
-
-    Component.onCompleted: {
-        Behavior.create(root, {direction: Qt.Vertical});
-    }
-
-    Component.onDestruction: {
-        Behavior.destroy();
-    }
-
-}
diff --git a/components/custom/ButtonGroup.js b/components/custom/ButtonGroup.js
deleted file mode 100644
index 5b0d9ad..0000000
--- a/components/custom/ButtonGroup.js
+++ /dev/null
@@ -1,141 +0,0 @@
-var self;
-var checkHandlers = [];
-var visibleButtons = [];
-var nonVisibleButtons = [];
-var direction;
-
-function create(that, options) {
-    self = that;
-    direction = options.direction || Qt.Horizontal;
-    self.childrenChanged.connect(rebuild);
-//    self.widthChanged.connect(resizeChildren);
-    build();
-}
-
-function isButton(item) {
-    if (item && item.hasOwnProperty("__position"))
-        return true;
-    return false;
-}
-
-function hasChecked(item) {
-    return (item && item.hasOwnProperty("checked"));
-}
-
-function destroy() {
-    self.childrenChanged.disconnect(rebuild);
-//    self.widthChanged.disconnect(resizeChildren);
-    cleanup();
-}
-
-function build() {
-    visibleButtons = [];
-    nonVisibleButtons = [];
-
-    for (var i = 0, item; (item = self.children[i]); i++) {
-
-        if (item.hasOwnProperty("styleHint"))
-            item.styleHint = styleHint;
-
-        if (!hasChecked(item))
-            continue;
-
-        item.visibleChanged.connect(rebuild); // Not optimal, but hardly a bottleneck in your app
-        if (!item.visible) {
-            nonVisibleButtons.push(item);
-            continue;
-        }
-        visibleButtons.push(item);
-
-        if (self.exclusive && item.hasOwnProperty("checkable"))
-            item.checkable = true;
-
-        if (self.exclusive) {
-            item.checked = false;
-            checkHandlers.push(checkExclusive(item));
-            item.checkedChanged.connect(checkHandlers[checkHandlers.length - 1]);
-        }
-    }
-
-    var nrButtons = visibleButtons.length;
-    if (nrButtons == 0)
-        return;
-
-    if (self.checkedButton)
-        self.checkedButton.checked = true;
-    else if (self.exclusive) {
-        self.checkedButton = visibleButtons[0];
-        self.checkedButton.checked = true;
-    }
-
-    if (nrButtons == 1) {
-        finishButton(visibleButtons[0], "only");
-    } else {
-        finishButton(visibleButtons[0], direction == Qt.Horizontal ? "leftmost" : "top");
-        for (var i = 1; i < nrButtons - 1; i++)
-            finishButton(visibleButtons[i], direction == Qt.Horizontal ? "h_middle": "v_middle");
-        finishButton(visibleButtons[nrButtons - 1], direction == Qt.Horizontal ? "rightmost" : "bottom");
-    }
-}
-
-function finishButton(button, position) {
-    if (isButton(button)) {
-        button.__position = position;
-        if (direction == Qt.Vertical) {
-            button.anchors.left = self.left     //mm How to make this not cause binding loops? see QTBUG-17162
-            button.anchors.right = self.right
-        }
-    }
-}
-
-function cleanup() {
-    visibleButtons.forEach(function(item, i) {
-        if (checkHandlers[i])
-            item.checkedChanged.disconnect(checkHandlers[i]);
-        item.visibleChanged.disconnect(rebuild);
-    });
-    checkHandlers = [];
-
-    nonVisibleButtons.forEach(function(item, i) {
-        item.visibleChanged.disconnect(rebuild);
-    });
-}
-
-function rebuild() {
-    if (self == undefined)
-        return;
-
-    cleanup();
-    build();
-}
-
-function resizeChildren() {
-    if (direction != Qt.Horizontal)
-        return;
-
-    var extraPixels = self.width % visibleButtons;
-    var buttonSize = (self.width - extraPixels) / visibleButtons;
-    visibleButtons.forEach(function(item, i) {
-        if (!item || !item.visible)
-            return;
-        item.width = buttonSize + (extraPixels > 0 ? 1 : 0);
-        if (extraPixels > 0)
-            extraPixels--;
-    });
-}
-
-function checkExclusive(item) {
-    var button = item;
-    return function() {
-        for (var i = 0, ref; (ref = visibleButtons[i]); i++) {
-            if (ref.checked == (button === ref))
-                continue;
-
-            // Disconnect the signal to avoid recursive calls
-            ref.checkedChanged.disconnect(checkHandlers[i]);
-            ref.checked = !ref.checked;
-            ref.checkedChanged.connect(checkHandlers[i]);
-        }
-        self.checkedButton = button;
-    }
-}
diff --git a/components/custom/ButtonRow.qml b/components/custom/ButtonRow.qml
deleted file mode 100644
index ac1b0e7..0000000
--- a/components/custom/ButtonRow.qml
+++ /dev/null
@@ -1,88 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-import "ButtonGroup.js" as Behavior
-
-/*
-   Class: ButtonRow
-   A ButtonRow allows you to group Buttons in a row. It provides a selection-behavior as well.
-
-   Note: This component don't support the enabled property.
-   If you need to disable it you should disable all the buttons inside it.
-
-   <code>
-       ButtonRow {
-           Button { text: "Left" }
-           Button { text: "Right" }
-       }
-   </code>
-*/
-Row {
-    id: root
-
-    /*
-     * Property: exclusive
-     * [bool=false] Specifies the grouping behavior. If enabled, the checked property on buttons contained
-     * in the group will be exclusive.
-     *
-     * Note that a button in an exclusive group will allways be checkable
-     */
-    property bool exclusive: false
-
-    /*
-     * Property: styleHint
-     * [string] Used to indicate special OS specific button types
-     */
-    property string styleHint
-    /*
-     * Property: checkedButton
-     * [string] Contains the last checked Button.
-     */
-    property Item checkedButton;
-
-    Component.onCompleted: {
-        Behavior.create(root, {direction: Qt.Horizontal});
-    }
-
-    Component.onDestruction: {
-        Behavior.destroy();
-    }
-}
diff --git a/components/custom/CheckBox.qml b/components/custom/CheckBox.qml
deleted file mode 100644
index 1b55c37..0000000
--- a/components/custom/CheckBox.qml
+++ /dev/null
@@ -1,77 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-import "./behaviors"
-
-FocusScope {
-    id: checkBox
-
-    signal clicked
-    property alias pressed: behavior.pressed
-    property alias checked: behavior.checked
-    property alias containsMouse: behavior.containsMouse
-
-    property Component background: null
-    property Item backgroundItem: backgroundLoader.item
-
-    // implementation
-    Accessible.role: Accessible.CheckBox
-
-    Loader {
-        id: backgroundLoader
-        anchors.fill: parent
-        property alias styledItem: checkBox
-        sourceComponent: background
-    }
-
-    ButtonBehavior {
-        id: behavior
-        focus: true
-        anchors.fill: parent
-        checkable: true
-        onClicked: {
-            if (checkBox.activeFocusOnPress)
-                checkBox.forceActiveFocus();
-            checkBox.clicked();
-        }
-    }
-    Keys.onSpacePressed: {clicked(); checked = !checked; }
-}
diff --git a/components/custom/GroupBox.qml b/components/custom/GroupBox.qml
deleted file mode 100644
index 9cf46e1..0000000
--- a/components/custom/GroupBox.qml
+++ /dev/null
@@ -1,94 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-
-Item {
-    id: groupbox
-
-    implicitWidth: adjustToContentSize ? Math.max(200, contentWidth + loader.leftMargin + loader.rightMargin) : 100
-    implicitHeight: adjustToContentSize ? contentHeight + loader.topMargin + loader.bottomMargin : 100
-
-    default property alias data: content.data
-
-    property string title
-    property bool checkable: false
-    property int contentWidth: content.childrenRect.width
-    property int contentHeight: content.childrenRect.height
-    property double contentOpacity: 1
-
-    property Component background: null
-    property Item backgroundItem: loader.item
-
-    property Item checkbox: check
-    property alias checked: check.checked
-    property bool adjustToContentSize: false // Resizes groupbox to fit contents.
-                                             // Note when using this, you cannot anchor children
-    Loader {
-        id: loader
-        anchors.fill: parent
-        property int topMargin: title.length > 0 || checkable ? 22 : 4
-        property int bottomMargin: 4
-        property int leftMargin: 4
-        property int rightMargin: 4
-        property alias styledItem: groupbox
-        sourceComponent: background
-    }
-    CheckBox {
-        id: check
-        checked: true
-        anchors.top: parent.top
-        anchors.left: parent.left
-        anchors.right: parent.right
-        height: loader.topMargin
-    }
-    Item {
-        id:content
-        z: 1
-        focus: true
-        opacity: contentOpacity
-        anchors.topMargin: loader.topMargin
-        anchors.leftMargin: 8
-        anchors.rightMargin: 8
-        anchors.bottomMargin: 8
-        anchors.fill: parent
-        enabled: (!checkable || checkbox.checked)
-    }
-}
diff --git a/components/custom/ProgressBar.qml b/components/custom/ProgressBar.qml
deleted file mode 100644
index 51290b3..0000000
--- a/components/custom/ProgressBar.qml
+++ /dev/null
@@ -1,93 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-
-Item {
-    id: progressBar
-
-    property real value: 0
-    property real minimumValue: 0
-    property real maximumValue: 1
-    property bool indeterminate: false
-    property bool containsMouse: mouseArea.containsMouse
-
-    property int leftMargin: 0
-    property int topMargin: 0
-    property int rightMargin: 0
-    property int bottomMargin: 0
-
-    property int minimumWidth: 0
-    property int minimumHeight: 0
-
-    property Component background: null
-    property Item backgroundItem: groove.item
-
-    property color backgroundColor: syspal.base
-    property color progressColor: syspal.highlight
-
-    Accessible.role: Accessible.ProgressBar
-    Accessible.name: value
-
-    Loader {
-        id: groove
-        property alias indeterminate:progressBar.indeterminate
-        property alias value:progressBar.value
-        property alias maximumValue:progressBar.maximumValue
-        property alias minimumValue:progressBar.minimumValue
-
-        sourceComponent: background
-        anchors.fill: parent
-    }
-
-    Item {
-        anchors.fill: parent
-        anchors.leftMargin: leftMargin
-        anchors.rightMargin: rightMargin
-        anchors.topMargin: topMargin
-        anchors.bottomMargin: bottomMargin
-    }
-
-    MouseArea {
-        id: mouseArea
-        anchors.fill: parent
-        hoverEnabled: true
-    }
-}
diff --git a/components/custom/Slider.qml b/components/custom/Slider.qml
deleted file mode 100644
index ea71eee..0000000
--- a/components/custom/Slider.qml
+++ /dev/null
@@ -1,304 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-import QtDesktop 0.2
-//import "../"
-
-Item {
-    id: slider
-
-    // COMMON API
-    property int orientation: Qt.Horizontal
-    property alias minimumValue: range.minimumValue
-    property alias maximumValue: range.maximumValue
-    property alias inverted: range.inverted
-    property bool updateValueWhileDragging: true
-    property alias pressed: mouseArea.pressed
-    property alias stepSize: range.stepSize
-    property alias hoverEnabled: mouseArea.hoverEnabled
-
-    // NOTE: this property is in/out, the user can set it, create bindings to it, and
-    // at the same time the slider wants to update. There's no way in QML to do this kind
-    // of updates AND allow the user bind it (without a Binding object). That's the
-    // reason this is an alias to a C++ property in range model.
-    property alias value: range.value
-    property bool containsMouse: mouseArea.containsMouse
-
-    // CONVENIENCE TO BE USED BY STYLES
-
-    property int leftMargin: 0
-    property int rightMargin: 0
-
-    // EXTENSIONS
-    // Indicate that we want animations in the Slider, people customizing should
-    // look at it to decide whether or not active animations.
-    property bool animated: true
-    property bool activeFocusOnPress: false
-
-    // Value indicator displays the current value near the slider
-    property bool valueIndicatorVisible: true
-    property int valueIndicatorMargin: 10
-    property string valueIndicatorPosition: _isVertical ? "Left" : "Top"
-
-    // Reimplement this function to control how the value is shown in the
-    // indicator.
-    function formatValue(v) {
-        return Math.round(v);
-    }
-
-    // Hooks for customizing the pieces of the slider
-    property Component groove: null
-    property Component handle: null
-    property Component valueIndicator: null
-
-    Accessible.role: Accessible.Slider
-    Accessible.name: value
-
-    // PRIVATE/CONVENIENCE
-    property bool _isVertical: orientation == Qt.Vertical
-
-    // This is a template slider, so every piece can be modified by passing a
-    // different Component. The main elements in the implementation are
-    //
-    // - the 'range' does the calculations to map position to/from value,
-    //   it also serves as a data storage for both properties;
-    //
-    // - the 'fakeHandle' is what the mouse area drags on the screen, it feeds
-    //   the 'range' position and also reads it when convenient;
-    //
-    // - the real 'handle' it is the visual representation of the handle, that
-    //   just follows the 'fakeHandle' position.
-    //
-    // When the 'updateValueWhileDragging' is false and we are dragging, we stop
-    // feeding the range with position information, delaying until the next
-    // mouse release.
-    //
-    // Everything is encapsulated in a contents Item, so for the
-    // vertical slider, we just swap the height/width, make it
-    // horizontal, and then use rotation to make it vertical again.
-
-    Item {
-        id: contents
-
-        width: _isVertical ? slider.height : slider.width
-        height: _isVertical ? slider.width : slider.height
-        rotation: _isVertical ? -90 : 0
-
-        anchors.centerIn: slider
-
-        RangeModel {
-            id: range
-            minimumValue: 0.0
-            maximumValue: 1.0
-            value: 0
-            stepSize: 0.0
-            inverted: false
-
-            positionAtMinimum: leftMargin
-            positionAtMaximum: contents.width - rightMargin
-        }
-
-        Loader {
-            id: grooveLoader
-            anchors.fill: parent
-            sourceComponent: groove
-
-            property real handlePosition : handleLoader.x
-            function positionForValue(value) {
-                return range.positionForValue(value) - leftMargin;
-            }
-        }
-
-        Loader {
-            id: handleLoader
-            transform: Translate { x: - handleLoader.width / 2 }
-
-            anchors.verticalCenter: grooveLoader.verticalCenter
-
-            sourceComponent: handle
-
-            x: fakeHandle.x
-            Behavior on x {
-                id: behavior
-                enabled: !mouseArea.drag.active && slider.animated
-
-                PropertyAnimation {
-                    duration: behavior.enabled ? 150 : 0
-                    easing.type: Easing.OutSine
-                }
-            }
-        }
-
-        Item {
-            id: fakeHandle
-            width: handleLoader.width
-            height: handleLoader.height
-            transform: Translate { x: - handleLoader.width / 2 }
-        }
-
-        MouseArea {
-            id: mouseArea
-            hoverEnabled: true
-            anchors.centerIn: parent
-            anchors.horizontalCenterOffset: (slider.leftMargin - slider.rightMargin) / 2
-
-            width: parent.width + handleLoader.width - slider.rightMargin - slider.leftMargin
-            height: parent.height
-
-            drag.target: fakeHandle
-            drag.axis: Drag.XAxis
-            drag.minimumX: range.positionAtMinimum
-            drag.maximumX: range.positionAtMaximum
-
-            onPressed: {
-
-                if (activeFocusOnPress)
-                    slider.focus = true;
-
-                // Clamp the value
-                var newX = Math.max(mouse.x, drag.minimumX);
-                newX = Math.min(newX, drag.maximumX);
-
-                // Debounce the press: a press event inside the handler will not
-                // change its position, the user needs to drag it.
-
-                // Note this really messes up things for scrollbar
-                // if (Math.abs(newX - fakeHandle.x) > handleLoader.width / 2)
-                    range.position = newX;
-            }
-
-            onReleased: {
-                // If we don't update while dragging, this is the only
-                // moment that the range is updated.
-                if (!slider.updateValueWhileDragging)
-                    range.position = fakeHandle.x;
-            }
-        }
-
-        Loader {
-            id: valueIndicatorLoader
-
-            transform: Translate { x: - handleLoader.width / 2 }
-            rotation: _isVertical ? 90 : 0
-            visible: valueIndicatorVisible
-
-            // Properties available for the delegate component. Note that the indicatorText
-            // shows the value for the position the handle is, which is not necessarily the
-            // available as the current slider.value, since updateValueWhileDragging can
-            // be set to 'false'.
-            property string indicatorText: slider.formatValue(range.valueForPosition(handleLoader.x))
-            property bool dragging: mouseArea.drag.active
-
-            sourceComponent: valueIndicator
-
-            state: {
-                if (!_isVertical)
-                    return slider.valueIndicatorPosition;
-
-                if (valueIndicatorPosition == "Right")
-                    return "Bottom";
-                if (valueIndicatorPosition == "Top")
-                    return "Right";
-                if (valueIndicatorPosition == "Bottom")
-                    return "Left";
-
-                return "Top";
-            }
-
-            anchors.margins: valueIndicatorMargin
-
-            states: [
-                State {
-                    name: "Top"
-                    AnchorChanges {
-                        target: valueIndicatorLoader
-                        anchors.bottom: handleLoader.top
-                        anchors.horizontalCenter: handleLoader.horizontalCenter
-                    }
-                },
-                State {
-                    name: "Bottom"
-                    AnchorChanges {
-                        target: valueIndicatorLoader
-                        anchors.top: handleLoader.bottom
-                        anchors.horizontalCenter: handleLoader.horizontalCenter
-                    }
-                },
-                State {
-                    name: "Right"
-                    AnchorChanges {
-                        target: valueIndicatorLoader
-                        anchors.left: handleLoader.right
-                        anchors.verticalCenter: handleLoader.verticalCenter
-                    }
-                },
-                State {
-                    name: "Left"
-                    AnchorChanges {
-                        target: valueIndicatorLoader
-                        anchors.right: handleLoader.left
-                        anchors.verticalCenter: handleLoader.verticalCenter
-                    }
-                }
-            ]
-        }
-    }
-
-    // Range position normally follow fakeHandle, except when
-    // 'updateValueWhileDragging' is false. In this case it will only follow
-    // if the user is not pressing the handle.
-    Binding {
-        when: updateValueWhileDragging || !mouseArea.pressed
-        target: range
-        property: "position"
-        value: fakeHandle.x
-    }
-
-    // During the drag, we simply ignore position set from the range, this
-    // means that setting a value while dragging will not "interrupt" the
-    // dragging activity.
-    Binding {
-        when: !mouseArea.drag.active
-        target: fakeHandle
-        property: "x"
-        value: range.position
-    }
-}
diff --git a/components/custom/SpinBox.qml b/components/custom/SpinBox.qml
deleted file mode 100644
index ceb7578..0000000
--- a/components/custom/SpinBox.qml
+++ /dev/null
@@ -1,204 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-
-FocusScope {
-    id: spinbox
-
-    SystemPalette {
-        id: syspal
-        colorGroup: enabled ? SystemPalette.Active : SystemPalette.Disabled
-    }
-
-    property int minimumWidth: 0
-    property int minimumHeight: 0
-
-    property int leftMargin: 0
-    property int topMargin: 0
-    property int rightMargin: 0
-    property int bottomMargin: 0
-
-    property real value: 0.0
-    property real maximumValue: 99
-    property real minimumValue: 0
-    property real singleStep: 1
-    property string postfix
-
-    property bool upEnabled: value != maximumValue;
-    property bool downEnabled: value != minimumValue;
-    property alias upPressed: mouseUp.pressed
-    property alias downPressed: mouseDown.pressed
-    property alias upHovered: mouseUp.containsMouse
-    property alias downHovered: mouseDown.containsMouse
-    property alias containsMouse: mouseArea.containsMouse
-    property alias textColor: syspal.text
-    property alias font: input.font
-
-    property Component background: null
-    property Item backgroundItem: backgroundComponent.item
-    property Component up: null
-    property Component down: null
-
-    Accessible.name: input.text
-    Accessible.role: Accessible.SpinBox
-
-    QtObject {
-        id: componentPrivate
-        property bool valueUpdate: false
-    }
-
-    function increment() {
-        setValue(input.text)
-        value += singleStep
-        if (value > maximumValue)
-            value = maximumValue
-        input.text = value
-    }
-
-    function decrement() {
-        setValue(input.text)
-        value -= singleStep
-        if (value < minimumValue)
-            value = minimumValue
-        input.text = value
-    }
-
-    function setValue(v) {
-        var newval = parseFloat(v)
-        if (newval > maximumValue)
-            newval = maximumValue
-        else if (v < minimumValue)
-            newval = minimumValue
-        value = newval
-        input.text = value
-    }
-
-    Component.onCompleted: setValue(value)
-
-    onValueChanged: {
-        componentPrivate.valueUpdate = true
-        input.text = value
-        componentPrivate.valueUpdate = false
-    }
-
-    // background
-    Loader {
-        id: backgroundComponent
-        anchors.fill: parent
-        sourceComponent: background
-    }
-
-    MouseArea {
-        id: mouseArea
-        anchors.fill: parent
-        hoverEnabled: true
-    }
-
-    TextInput {
-        id: input
-
-        anchors.margins: 5
-        anchors.leftMargin: leftMargin
-        anchors.topMargin: topMargin
-        anchors.rightMargin: rightMargin
-        anchors.bottomMargin: bottomMargin
-        anchors.fill: parent
-        selectByMouse: true
-
-        // validator: DoubleValidator { bottom: minimumValue; top: maximumValue; }
-        onAccepted: {setValue(input.text)}
-        onActiveFocusChanged: setValue(input.text)
-        color: textColor
-        opacity: parent.enabled ? 1 : 0.5
-        Text {
-            text: postfix
-            anchors.rightMargin: 4
-            anchors.right: parent.right
-            anchors.verticalCenter: parent.verticalCenter
-        }
-    }
-
-    Loader {
-        id: upButton
-        property alias pressed : spinbox.upPressed
-        property alias hover : spinbox.upHovered
-        property alias enabled : spinbox.upEnabled
-        sourceComponent: up
-        MouseArea {
-            id: mouseUp
-            anchors.fill: upButton.item
-            onClicked: increment()
-
-            property bool autoincrement: false;
-            onReleased: autoincrement = false
-            Timer { running: mouseUp.pressed; interval: 350 ; onTriggered: mouseUp.autoincrement = true }
-            Timer { running: mouseUp.autoincrement; interval: 60 ; repeat: true ; onTriggered: increment() }
-        }
-        onLoaded: {
-            item.parent = spinbox
-            mouseUp.parent = item
-        }
-    }
-
-    Loader {
-        id: downButton
-        property alias pressed : spinbox.downPressed
-        property alias hover : spinbox.downHovered
-        property alias enabled : spinbox.downEnabled
-        sourceComponent: down
-        MouseArea {
-            id: mouseDown
-            anchors.fill: downButton.item
-            onClicked: decrement()
-
-            property bool autoincrement: false;
-            onReleased: autoincrement = false
-            Timer { running: mouseDown.pressed; interval: 350 ; onTriggered: mouseDown.autoincrement = true }
-            Timer { running: mouseDown.autoincrement; interval: 60 ; repeat: true ; onTriggered: decrement() }
-        }
-        onLoaded: {
-            item.parent = spinbox
-            mouseDown.parent = item
-        }
-    }
-    Keys.onUpPressed: increment()
-    Keys.onDownPressed: decrement()
-}
diff --git a/components/custom/Splitter.qml b/components/custom/Splitter.qml
deleted file mode 100644
index 61c2d9f..0000000
--- a/components/custom/Splitter.qml
+++ /dev/null
@@ -1,445 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-import QtDesktop 0.2
-
-Splitter {
-    id: root
-    default property alias items: splitterItems.children
-    property alias handles: splitterHandles.children
-    property Component handleBackground: Rectangle { width:3; color: "black" }
-    property int handleWidth: -1
-    property real preferredSize: 0
-    property int orientation: Qt.Horizontal
-
-    clip: true
-    Component.onCompleted: d.init();
-    onWidthChanged: d.updateLayout();
-    onHeightChanged: d.updateLayout();
-
-    QtObject {
-        id: d
-
-        property bool horizontal: orientation == Qt.Horizontal
-        property string size: horizontal ? "width" : "height"
-        property string minimum: horizontal ? "minimumWidth" : "minimumHeight"
-        property string maximum: horizontal ? "maximumWidth" : "maximumHeight"
-
-        property string offset: horizontal ? "x" : "y"
-        property int expandingIndex: -1
-        property bool updateLayoutGuard: true
-        property bool itemWidthGuard: false
-        property bool itemExpandingGuard: true
-
-        function init()
-        {
-            for (var i=0; i<items.length; ++i) {
-                var item = items[i];
-
-                item.Splitter.itemIndex = i
-                // Assign one, and only one, item to be expanding:
-                if (item.Splitter.expanding === true) {
-                    if (d.expandingIndex === -1 && item.visible === true)
-                        d.expandingIndex = i
-                    else
-                        item.Splitter.expanding = false
-                }
-
-                // Anchor each item to fill out all space vertically:
-                if (d.horizontal) {
-                    item.anchors.top = splitterItems.top
-                    item.anchors.bottom = splitterItems.bottom
-                } else  {
-                    item.anchors.left = splitterItems.left
-                    item.anchors.right = splitterItems.right
-
-                }
-
-                // Listen for changes to width and expanding:
-                propertyChangeListener.createObject(item, {"itemIndex":i});
-                if (i < items.length-1) {
-                    // Create a handle for the item, unless its the last:
-                    var handle = handleBackgroundLoader.createObject(splitterHandles, {"handleIndex":i});
-
-                    if (d.horizontal) {
-                        handle.anchors.top = splitterHandles.top
-                        handle.anchors.bottom = splitterHandles.bottom
-                    } else {
-                        handle.anchors.left = splitterHandles.left
-                        handle.anchors.right = splitterHandles.right
-                    }
-                }
-            }
-
-            if (d.expandingIndex === -1) {
-                // INVARIANT: No item was set as expanding.
-                // We then choose the last visible item instead:
-                d.expandingIndex = items.length - 1
-                for (i=items.length-1; i>=0; --i) {
-                    var item = items[i]
-                    if (item.visible === true) {
-                        d.expandingIndex = i
-                        item = items[i]
-                        break
-                    }
-                }
-                item.Splitter.expanding = true
-            }
-
-            d.itemExpandingGuard = false
-            d.updateLayoutGuard = false
-            d.updateLayout()
-        }
-
-        function accumulatedSize(firstIndex, lastIndex, includeExpandingMinimum)
-        {
-            // Go through items and handles, and
-            // calculate their acummulated width.
-            var w = 0
-            for (var i=firstIndex; i<lastIndex; ++i) {
-                var item = items[i]
-                if (item.visible) {
-                    if (i !== d.expandingIndex)
-                        w += item[d.size];
-                    else if (includeExpandingMinimum && item.Splitter[minimum] != -1)
-                        w += item[minimum]
-                }
-
-                var handle = handles[i]
-                if (handle && items[i + ((d.expandingIndex > i) ? 0 : 1)].visible)
-                    w += handle[d.size]
-            }
-            return w
-        }
-
-        function updateLayout()
-        {
-            // This function will reposition both handles and
-            // items according to the _width of the each item_
-            if (items.length === 0)
-                return;
-            if (d.updateLayoutGuard === true)
-                return
-            d.updateLayoutGuard = true
-
-            // Use a temporary variable to store values to avoid breaking
-            // property bindings when the value does not actually change:
-            var newValue
-
-            // Ensure all items within min/max:
-            for (var i=0; i<items.length; ++i) {
-                if (i !== d.expandingIndex) {
-                    item = items[i];
-                    // If the item is using percentage width, convert
-                    // that number to real width now:
-                    if (item.Splitter.percentageSize !== -1) {
-                        newValue = item.Splitter.percentageSize * (root[d.size] / 100)
-                        if (newValue !== item[d.size])
-                            item[d.size] = newValue
-                    }
-                    // Ensure item width is not more than maximumSize:
-                    if (item.Splitter[maximum] !== -1) {
-                        newValue = Math.min(item[d.size], item.Splitter[maximum])
-                        if (newValue !== item[d.size])
-                            item[d.size] = newValue
-                    }
-                    // Ensure item width is not more less minimumWidth:
-                    if (item.Splitter[minimum] !== -1) {
-                        newValue = Math.max(item[d.size], item.Splitter[minimum])
-                        if (newValue !== item[d.size])
-                            item[d.size] = newValue
-                    }
-                }
-            }
-
-            // Special case: set width of expanding item to available space:
-            newValue = root[d.size] - d.accumulatedSize(0, items.length, false);
-            var expandingItem = items[d.expandingIndex]
-            var expandingMinimum = 0
-            if (expandingItem.Splitter[minimum] !== -1)
-                expandingMinimum = expandingItem.Splitter[minimum]
-            newValue = Math.max(newValue, expandingMinimum)
-            if (expandingItem[d.size] !== 0 && expandingItem.Splitter.percentageSize !== -1)
-                expandingItem.Splitter.percentageSize = newValue * (100 / root[d.size])
-            if (expandingItem[d.size] !== newValue)
-                expandingItem[d.size] = newValue
-
-            // Then, position items and handles according to their width:
-            var item, lastVisibleItem
-            var handle, lastVisibleHandle
-            var newpreferredSize = expandingMinimum - expandingItem[d.size]
-
-            for (i=0; i<items.length; ++i) {
-                // Position item to the right of the previous visible handle:
-                item = items[i];
-                if (item.visible) {
-                    if (lastVisibleHandle) {
-                        newValue = lastVisibleHandle[d.offset] + lastVisibleHandle[d.size]
-                        if (newValue !== item[d.offset])
-                            item[d.offset] = newValue
-                    } else {
-                        newValue = 0
-                        if (newValue !== item[d.offset])
-                            item[d.offset] = newValue
-                    }
-                    newpreferredSize += item[d.size]
-                    lastVisibleItem = item
-                }
-
-                // Position handle to the right of the previous visible item. We use an alterative way of
-                // checking handle visibility because that property might not have updated correctly yet:
-                handle = handles[i]
-                if (handle && items[i + ((d.expandingIndex > i) ? 0 : 1)].visible) {
-                    newValue = lastVisibleItem[d.offset] + Math.max(0, lastVisibleItem[d.size])
-                    if (newValue !== handle[d.offset])
-                        handle[d.offset] = newValue
-                    newpreferredSize += handle[d.size]
-                    lastVisibleHandle = handle
-                }
-            }
-
-            root.preferredSize = newpreferredSize
-            d.updateLayoutGuard = false
-        }
-    }
-
-    Component {
-        id: handleBackgroundLoader
-        Loader {
-            id: myHandle
-            property int handleIndex: 0
-            property Item handle: myHandle
-            property Item splitterItem: items[handleIndex + ((d.expandingIndex > handleIndex) ? 0 : 1)]
-
-             // 'splitterRow' should be an alias, but that fails to resolve runtime:
-            property Item splitterRow: root
-            property Item background: item
-
-            visible: splitterItem.visible
-            sourceComponent: handleBackground
-            onWidthChanged: d.updateLayout()
-
-            onXChanged: {
-                // Moving the handle means resizing an item. Which one,
-                // left or right, depends on where the expanding item is.
-                // 'updateLayout' will override in case new width violates max/min.
-                // And 'updateLayout will be triggered when an item changes width.
-                if (d.updateLayoutGuard)
-                    return
-
-                var leftHandle, leftItem, rightItem, rightHandle
-                var leftEdge, rightEdge, newWidth, leftStopX, rightStopX
-                var i
-
-                if (d.expandingIndex > handleIndex) {
-                    // Resize item to the left.
-                    // Ensure that the handle is not crossing other handles. So
-                    // find the first visible handle to the left to determine the left edge:
-                    leftEdge = 0
-                    for (i=handleIndex-1; i>=0; --i) {
-                        leftHandle = handles[i]
-                        if (leftHandle.visible) {
-                            leftEdge = leftHandle[d.offset] + leftHandle[d.size]
-                            break;
-                        }
-                    }
-
-                    // Ensure: leftStopX >= myHandle[d.offset] >= rightStopX
-                    var min = d.accumulatedSize(handleIndex+1, items.length, true)
-                    rightStopX = root[d.size] - min - myHandle[d.size]
-                    leftStopX = Math.max(leftEdge, myHandle[d.offset])
-                    myHandle[d.offset] = Math.min(rightStopX, Math.max(leftStopX, myHandle[d.offset]))
-
-                    newWidth = myHandle[d.offset] - leftEdge
-                    leftItem = items[handleIndex]
-                    if (root[d.size] != 0 && leftItem.Splitter.percentageSize !== -1)
-                        leftItem.Splitter.percentageSize = newWidth * (100 / root[d.size])
-                    // The next line will trigger 'updateLayout' inside 'propertyChangeListener':
-                    leftItem[d.size] = newWidth
-                } else {
-                    // Resize item to the right.
-                    // Ensure that the handle is not crossing other handles. So
-                    // find the first visible handle to the right to determine the right edge:
-                    rightEdge = root[d.size]
-                    for (i=handleIndex+1; i<handles.length; ++i) {
-                        rightHandle = handles[i]
-                        if (rightHandle.visible) {
-                            rightEdge = rightHandle[d.offset]
-                            break;
-                        }
-                    }
-
-                    // Ensure: leftStopX <= myHandle[d.offset] <= rightStopX
-                    var min = d.accumulatedSize(0, handleIndex+1, true)
-                    leftStopX = min - myHandle[d.size]
-                    rightStopX = Math.min((rightEdge - myHandle[d.size]), myHandle[d.offset])
-                    myHandle[d.offset] = Math.max(leftStopX, Math.min(myHandle[d.offset], rightStopX))
-
-                    newWidth = rightEdge - (myHandle[d.offset] + myHandle[d.size])
-                    rightItem = items[handleIndex+1]
-                    if (root[d.size] !== 0 && rightItem[d.percentageSize] !== -1)
-                        rightItem.Splitter.percentageSize = newWidth * (100 / root[d.size])
-                    // The next line will trigger 'updateLayout' inside 'propertyChangeListener':
-                    rightItem[d.size] = newWidth
-                }
-            }
-        }
-    }
-
-    Item {
-        id: splitterItems
-        anchors.fill: parent
-    }
-    Item {
-        id: splitterHandles
-        anchors.fill: parent
-    }
-
-    Component {
-        // This dummy item becomes a child of all
-        // items it the splitter, just to provide a way
-        // to listen for changes to their width, expanding etc.
-        id: propertyChangeListener
-        Item {
-            id: target
-            width: parent[d.size]
-            property bool expanding: parent.Splitter.expanding
-            property real percentageSize: parent.Splitter.percentageSize
-            property real minimumWidth: parent.Splitter[d.minimum]
-            property real maximumSize: parent.Splitter[d.maximum]
-            property int itemIndex: parent.Splitter.itemIndex
-
-            onPercentageSizeChanged: d.updateLayout();
-            onMinimumWidthChanged: d.updateLayout();
-            onMaximumSizeChanged: d.updateLayout();
-            onExpandingChanged: updateExpandingIndex()
-
-            function updateExpandingIndex()
-            {
-                // The following code is needed to avoid a binding
-                // loop, since we might change 'expanding' again to a different item:
-                if (d.itemExpandingGuard === true)
-                    return
-                d.itemExpandingGuard = true
-                // break binding:
-                expanding = false
-
-                // 'expanding' follows radio button behavior:
-                // First, find the new expanding item:
-                var newIndex = items.length-1
-                for (var i=0; i<items.length; ++i) {
-                    var item = items[i]
-                    if (i !== d.expandingIndex && item.Splitter.expanding === true && item.visible === true) {
-                        newIndex = i
-                        break
-                    }
-                }
-                item = items[newIndex]
-                if (item.visible === false) {
-                    // So now we ended up with the last item in the splitter to be
-                    // expanding, but it turns out to not be visible. So we need to
-                    // traverse backwards again to find one that is visible...
-                    for (i=items.length-2; i>=0; --i) {
-                        var item = items[i]
-                        if (item.visible === true) {
-                            newIndex = i
-                            item = items[newIndex]
-                           break
-                        }
-                    }
-                }
-
-                // Tell the found item that it is expanding:
-                if (item.Splitter.expanding !== true)
-                    item.Splitter.expanding = true
-                // ...and the old one that it is not:
-                if (newIndex !== d.expandingIndex) {
-                    item = items[d.expandingIndex]
-                    if (item.Splitter.expanding !== false)
-                        item.Splitter.expanding = false
-                }
-                // update index:
-                d.expandingIndex = newIndex
-                d.updateLayout();
-                // recreate binding:
-                expanding = function() { return parent.Splitter.expanding }
-                d.itemExpandingGuard = false
-            }
-
-            function handleSizeChanged() {
-                // We need to update the layout.
-                // The following code is needed to avoid a binding
-                // loop, since we might change 'width' again to a different value:
-                if (d.itemWidthGuard === true)
-                    return
-                d.itemWidthGuard = true
-                // Break binding:
-                this[d.size] = 0
-
-                d.updateLayout()
-
-                // Restablish binding:
-                width = Qt.binding(function() { return parent[d.size]; })
-                d.itemWidthGuard = false
-            }
-
-            onWidthChanged:  handleSizeChanged()
-            onHeightChanged: handleSizeChanged()
-            onVisibleChanged: {
-                // Hiding the expanding item forces us to
-                // select a new one (and therefore not recommended):
-                if (d.expandingIndex === itemIndex) {
-                    updateExpandingIndex()
-                } else {
-                    if (visible) {
-                        // Try to keep all items within the SplitterRow. When an item
-                        // has been hidden, the expanding item might no longer be large enough
-                        // to give away space to the new items width. So we need to resize:
-                        var overflow = d.accumulatedSize(0, items.length, true) - root[d.size];
-                        if (overflow > 0)
-                            parent[d.size] -= overflow
-                    }
-                    d.updateLayout()
-                }
-            }
-        }
-    }
-}
diff --git a/components/custom/TextField.qml b/components/custom/TextField.qml
deleted file mode 100644
index c18be1f..0000000
--- a/components/custom/TextField.qml
+++ /dev/null
@@ -1,170 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-import "./behaviors"    // TextEditMouseBehavior
-
-// KNOWN ISSUES
-// 1) TextField does not loose focus when !enabled if it is a FocusScope (see QTBUG-16161)
-
-FocusScope {
-    id: textField
-
-    property alias text: textInput.text
-    property alias font: textInput.font
-
-    property int inputHint // values tbd
-    property bool acceptableInput: textInput.acceptableInput // read only
-    property alias readOnly: textInput.readOnly // read only
-    property alias placeholderText: placeholderTextComponent.text
-    property bool  passwordMode: false
-    property alias selectedText: textInput.selectedText
-    property alias selectionEnd: textInput.selectionEnd
-    property alias selectionStart: textInput.selectionStart
-    property alias validator: textInput.validator
-    property alias inputMask: textInput.inputMask
-    property alias horizontalalignment: textInput.horizontalAlignment
-    property alias echoMode: textInput.echoMode
-    property alias cursorPosition: textInput.cursorPosition
-    property alias inputMethodHints: textInput.inputMethodHints
-    property alias activeFocusOnPress: textInput.activeFocusOnPress
-
-    property color textColor: syspal.text
-    property color backgroundColor: syspal.base
-    property alias containsMouse: mouseArea.containsMouse
-
-    property Component background: null
-    property Component hints: null
-    property Item backgroundItem: backgroundLoader.item
-
-    property int minimumWidth: 0
-    property int minimumHeight: 0
-
-    property int leftMargin: 0
-    property int topMargin: 0
-    property int rightMargin: 0
-    property int bottomMargin: 0
-
-    function copy() {
-        textInput.copy()
-    }
-
-    function paste() {
-        textInput.paste()
-    }
-
-    function cut() {
-        textInput.cut()
-    }
-
-    function select(start, end) {
-        textInput.select(start, end)
-    }
-
-    function selectAll() {
-        textInput.selectAll()
-    }
-
-    function selectWord() {
-        textInput.selectWord()
-    }
-
-    function positionAt(x) {
-        var p = mapToItem(textInput, x, 0);
-        return textInput.positionAt(p.x);
-    }
-
-    function positionToRectangle(pos) {
-        var p = mapToItem(textInput, pos.x, pos.y);
-        return textInput.positionToRectangle(p);
-    }
-
-    // Implementation
-    clip: true
-
-    SystemPalette {
-        id: syspal
-        colorGroup: enabled ? SystemPalette.Active : SystemPalette.Disabled
-    }
-    Loader { id: hintsLoader; sourceComponent: hints }
-    Loader { id: backgroundLoader; sourceComponent: background; anchors.fill:parent}
-
-    MouseArea {
-        id: mouseArea
-        anchors.fill: parent
-        hoverEnabled: true
-        onClicked: textfield.forceActiveFocus()
-    }
-
-    onFocusChanged: {
-        if (textField.activeFocus)
-            textInput.forceActiveFocus();
-    }
-
-    TextInput { // see QTBUG-14936
-        id: textInput
-        selectByMouse:true
-
-        anchors.leftMargin: leftMargin
-        anchors.topMargin: topMargin
-        anchors.rightMargin: rightMargin
-        anchors.bottomMargin: bottomMargin
-
-        anchors.left: parent.left
-        anchors.right: parent.right
-        anchors.verticalCenter: parent.verticalCenter
-
-        color: syspal.text
-        echoMode: passwordMode ? TextInput.Password : TextInput.Normal
-        clip: true
-    }
-
-    Text {
-        id: placeholderTextComponent
-        anchors.fill: textInput
-        font: textInput.font
-        opacity: !textInput.text.length && !textInput.activeFocus ? 1 : 0
-        color: "darkgray"
-        text: "Enter text"
-        clip: true
-        elide: Text.ElideRight
-        Behavior on opacity { NumberAnimation { duration: 90 } }
-    }
-}
diff --git a/components/custom/behaviors/ButtonBehavior.qml b/components/custom/behaviors/ButtonBehavior.qml
deleted file mode 100644
index 4942d62..0000000
--- a/components/custom/behaviors/ButtonBehavior.qml
+++ /dev/null
@@ -1,73 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-
-Item {
-    id: behavior
-
-    signal clicked
-    property bool pressed: false    // Can't be alias of mouseArea.pressed because the latter is read-only
-    property alias containsMouse: mouseArea.containsMouse
-    property bool checkable: false
-    property bool checked: false
-    property bool triState: false
-    signal mouseMoved
-
-    onCheckableChanged: { if(!checkable) checked = false }
-    MouseArea {
-        id: mouseArea
-        anchors.fill: parent
-        hoverEnabled: true
-        onPositionChanged: behavior.mouseMoved()
-        onPressed: behavior.pressed = true  // needed when hover is enabled
-        onEntered: if(pressed && enabled) behavior.pressed = true
-        onExited: behavior.pressed = false
-        onCanceled: behavior.pressed = false    // mouse stolen e.g. by Flickable
-        onReleased: {
-            if(behavior.pressed && behavior.enabled) { // No click if release outside area
-                behavior.pressed = false
-                if(behavior.checkable)
-                    behavior.checked = !behavior.checked;
-                behavior.clicked()
-            }
-        }
-    }
-}
diff --git a/components/custom/behaviors/ModalPopupBehavior.qml b/components/custom/behaviors/ModalPopupBehavior.qml
deleted file mode 100644
index bd70052..0000000
--- a/components/custom/behaviors/ModalPopupBehavior.qml
+++ /dev/null
@@ -1,130 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Components project.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
-**     the names of its contributors may be used to endorse or promote
-**     products derived from this software without specific prior written
-**     permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-import QtQuick 2.0
-
-// KNOWN ISSUES
-// none
-
-Item {
-    id: popupBehavior
-
-    property bool showing: false
-    property bool whenAlso: true            // modifier to the "showing" property
-    property bool consumeCancelClick: true
-    property int delay: 0                   // delay before popout becomes visible
-    property int deallocationDelay: 3000    // 3 seconds
-
-    property Component popupComponent
-
-    property alias popup: popupLoader.item  // read-only
-    property alias window: popupBehavior.root // read-only
-
-    signal prepareToShow
-    signal prepareToHide
-    signal cancelledByClick
-
-    // implementation
-
-    anchors.fill: parent
-
-    onShowingChanged: notifyChange()
-    onWhenAlsoChanged: notifyChange()
-    function notifyChange() {
-        if(showing && whenAlso) {
-            if(popupLoader.sourceComponent == undefined) {
-                popupLoader.sourceComponent = popupComponent;
-            }
-        } else {
-            mouseArea.enabled = false; // disable before opacity is changed in case it has fading behavior
-            if(Qt.isQtObject(popupLoader.item)) {
-                popupBehavior.prepareToHide();
-                popupLoader.item.opacity = 0;
-            }
-        }
-    }
-
-    property Item root: findRoot()
-    function findRoot() {
-        var p = parent;
-        while(p.parent != undefined)
-            p = p.parent;
-
-        return p;
-    }
-
-    MouseArea {
-        id: mouseArea
-        anchors.fill: parent
-        enabled: false  // enabled only when popout is showing
-        onPressed: {
-            popupBehavior.showing = false;
-            mouse.accepted = consumeCancelClick;
-            cancelledByClick();
-        }
-    }
-
-    Loader {
-        id: popupLoader
-    }
-
-    Timer { // visibility timer
-        running: Qt.isQtObject(popupLoader.item) && showing && whenAlso
-        interval: delay
-        onTriggered: {
-            popupBehavior.prepareToShow();
-            mouseArea.enabled = true;
-            popup.opacity = 1;
-        }
-    }
-
-    Timer { // deallocation timer
-        running: Qt.isQtObject(popupLoader.item) && popupLoader.item.opacity == 0
-        interval: deallocationDelay
-        onTriggered: popupLoader.sourceComponent = undefined
-    }
-
-    states: State {
-        name: "active"
-        when: Qt.isQtObject(popupLoader.item) && popupLoader.item.opacity > 0
-        ParentChange { target: popupBehavior; parent: root }
-    }
- }
-
diff --git a/components/custom/components.pro b/components/custom/components.pro
deleted file mode 100644
index 5ab59ce..0000000
--- a/components/custom/components.pro
+++ /dev/null
@@ -1,39 +0,0 @@
-TEMPLATE = subdirs # XXX: Avoid call the linker
-TARGETPATH = Qt/labs/components/custom
-
-QML_FILES = \
-        qmldir \
-        BasicButton.qml \
-        BusyIndicator.qml \
-        ButtonBlock.qml \
-        ButtonColumn.qml \
-        ButtonRow.qml \
-        ButtonGroup.js \
-        Button.qml \
-        CheckBox.qml \
-        Splitter.qml \
-        ProgressBar.qml \
-        RadioButton.qml \
-        ScrollDecorator.qml \
-        ScrollIndicator.qml \
-        Slider.qml \
-        SpinBox.qml \
-        Switch.qml \
-        TextArea.qml \
-        TextField.qml
-
-QML_DIRS = \
-        behaviors \
-        private \
-        styles \
-        visuals
-
-qmlfiles.files = $$QML_FILES
-qmlfiles.sources = $$QML_FILES
-qmlfiles.path = $$[QT_INSTALL_IMPORTS]/$$TARGETPATH
-
-qmldirs.files = $$QML_DIRS
-qmldirs.sources = $$QML_DIRS
-qmldirs.path = $$[QT_INSTALL_IMPORTS]/$$TARGETPATH
-
-INSTALLS += qmlfiles qmldirs
diff --git a/components/custom/qmldir b/components/custom/qmldir
deleted file mode 100644
index 716e44f..0000000
--- a/components/custom/qmldir
+++ /dev/null
@@ -1,14 +0,0 @@
-RangeModel 1.0 RangeModel.qml
-BasicButton 1.0 BasicButton.qml
-BusyIndicator 1.0 BusyIndicator.qml
-ButtonBlock 1.0 ButtonBlock.qml
-Button 1.0 Button.qml
-ButtonColumn 1.0 ButtonColumn.qml
-ButtonRow 1.0 ButtonRow.qml
-CheckBox 1.0 CheckBox.qml
-ProgressBar 1.0 ProgressBar.qml
-Slider 1.0 Slider.qml
-SpinBox 1.0 SpinBox.qml
-TextField 1.0 TextField.qml
-GroupBox 1.0 GroupBox.qml
-Splitter 1.0 Splitter.qml
diff --git a/components/private/ButtonBehavior.qml b/components/private/ButtonBehavior.qml
new file mode 100644
index 0000000..4942d62
--- /dev/null
+++ b/components/private/ButtonBehavior.qml
@@ -0,0 +1,73 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Components project.
+**
+** $QT_BEGIN_LICENSE:BSD$
+** You may use this file under the terms of the BSD license as follows:
+**
+** "Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above copyright
+**     notice, this list of conditions and the following disclaimer in
+**     the documentation and/or other materials provided with the
+**     distribution.
+**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
+**     the names of its contributors may be used to endorse or promote
+**     products derived from this software without specific prior written
+**     permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+import QtQuick 2.0
+
+Item {
+    id: behavior
+
+    signal clicked
+    property bool pressed: false    // Can't be alias of mouseArea.pressed because the latter is read-only
+    property alias containsMouse: mouseArea.containsMouse
+    property bool checkable: false
+    property bool checked: false
+    property bool triState: false
+    signal mouseMoved
+
+    onCheckableChanged: { if(!checkable) checked = false }
+    MouseArea {
+        id: mouseArea
+        anchors.fill: parent
+        hoverEnabled: true
+        onPositionChanged: behavior.mouseMoved()
+        onPressed: behavior.pressed = true  // needed when hover is enabled
+        onEntered: if(pressed && enabled) behavior.pressed = true
+        onExited: behavior.pressed = false
+        onCanceled: behavior.pressed = false    // mouse stolen e.g. by Flickable
+        onReleased: {
+            if(behavior.pressed && behavior.enabled) { // No click if release outside area
+                behavior.pressed = false
+                if(behavior.checkable)
+                    behavior.checked = !behavior.checked;
+                behavior.clicked()
+            }
+        }
+    }
+}
diff --git a/components/private/ButtonGroup.js b/components/private/ButtonGroup.js
new file mode 100644
index 0000000..5b0d9ad
--- /dev/null
+++ b/components/private/ButtonGroup.js
@@ -0,0 +1,141 @@
+var self;
+var checkHandlers = [];
+var visibleButtons = [];
+var nonVisibleButtons = [];
+var direction;
+
+function create(that, options) {
+    self = that;
+    direction = options.direction || Qt.Horizontal;
+    self.childrenChanged.connect(rebuild);
+//    self.widthChanged.connect(resizeChildren);
+    build();
+}
+
+function isButton(item) {
+    if (item && item.hasOwnProperty("__position"))
+        return true;
+    return false;
+}
+
+function hasChecked(item) {
+    return (item && item.hasOwnProperty("checked"));
+}
+
+function destroy() {
+    self.childrenChanged.disconnect(rebuild);
+//    self.widthChanged.disconnect(resizeChildren);
+    cleanup();
+}
+
+function build() {
+    visibleButtons = [];
+    nonVisibleButtons = [];
+
+    for (var i = 0, item; (item = self.children[i]); i++) {
+
+        if (item.hasOwnProperty("styleHint"))
+            item.styleHint = styleHint;
+
+        if (!hasChecked(item))
+            continue;
+
+        item.visibleChanged.connect(rebuild); // Not optimal, but hardly a bottleneck in your app
+        if (!item.visible) {
+            nonVisibleButtons.push(item);
+            continue;
+        }
+        visibleButtons.push(item);
+
+        if (self.exclusive && item.hasOwnProperty("checkable"))
+            item.checkable = true;
+
+        if (self.exclusive) {
+            item.checked = false;
+            checkHandlers.push(checkExclusive(item));
+            item.checkedChanged.connect(checkHandlers[checkHandlers.length - 1]);
+        }
+    }
+
+    var nrButtons = visibleButtons.length;
+    if (nrButtons == 0)
+        return;
+
+    if (self.checkedButton)
+        self.checkedButton.checked = true;
+    else if (self.exclusive) {
+        self.checkedButton = visibleButtons[0];
+        self.checkedButton.checked = true;
+    }
+
+    if (nrButtons == 1) {
+        finishButton(visibleButtons[0], "only");
+    } else {
+        finishButton(visibleButtons[0], direction == Qt.Horizontal ? "leftmost" : "top");
+        for (var i = 1; i < nrButtons - 1; i++)
+            finishButton(visibleButtons[i], direction == Qt.Horizontal ? "h_middle": "v_middle");
+        finishButton(visibleButtons[nrButtons - 1], direction == Qt.Horizontal ? "rightmost" : "bottom");
+    }
+}
+
+function finishButton(button, position) {
+    if (isButton(button)) {
+        button.__position = position;
+        if (direction == Qt.Vertical) {
+            button.anchors.left = self.left     //mm How to make this not cause binding loops? see QTBUG-17162
+            button.anchors.right = self.right
+        }
+    }
+}
+
+function cleanup() {
+    visibleButtons.forEach(function(item, i) {
+        if (checkHandlers[i])
+            item.checkedChanged.disconnect(checkHandlers[i]);
+        item.visibleChanged.disconnect(rebuild);
+    });
+    checkHandlers = [];
+
+    nonVisibleButtons.forEach(function(item, i) {
+        item.visibleChanged.disconnect(rebuild);
+    });
+}
+
+function rebuild() {
+    if (self == undefined)
+        return;
+
+    cleanup();
+    build();
+}
+
+function resizeChildren() {
+    if (direction != Qt.Horizontal)
+        return;
+
+    var extraPixels = self.width % visibleButtons;
+    var buttonSize = (self.width - extraPixels) / visibleButtons;
+    visibleButtons.forEach(function(item, i) {
+        if (!item || !item.visible)
+            return;
+        item.width = buttonSize + (extraPixels > 0 ? 1 : 0);
+        if (extraPixels > 0)
+            extraPixels--;
+    });
+}
+
+function checkExclusive(item) {
+    var button = item;
+    return function() {
+        for (var i = 0, ref; (ref = visibleButtons[i]); i++) {
+            if (ref.checked == (button === ref))
+                continue;
+
+            // Disconnect the signal to avoid recursive calls
+            ref.checkedChanged.disconnect(checkHandlers[i]);
+            ref.checked = !ref.checked;
+            ref.checkedChanged.connect(checkHandlers[i]);
+        }
+        self.checkedButton = button;
+    }
+}
diff --git a/components/private/ModalPopupBehavior.qml b/components/private/ModalPopupBehavior.qml
new file mode 100644
index 0000000..bd70052
--- /dev/null
+++ b/components/private/ModalPopupBehavior.qml
@@ -0,0 +1,130 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Components project.
+**
+** $QT_BEGIN_LICENSE:BSD$
+** You may use this file under the terms of the BSD license as follows:
+**
+** "Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above copyright
+**     notice, this list of conditions and the following disclaimer in
+**     the documentation and/or other materials provided with the
+**     distribution.
+**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
+**     the names of its contributors may be used to endorse or promote
+**     products derived from this software without specific prior written
+**     permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+import QtQuick 2.0
+
+// KNOWN ISSUES
+// none
+
+Item {
+    id: popupBehavior
+
+    property bool showing: false
+    property bool whenAlso: true            // modifier to the "showing" property
+    property bool consumeCancelClick: true
+    property int delay: 0                   // delay before popout becomes visible
+    property int deallocationDelay: 3000    // 3 seconds
+
+    property Component popupComponent
+
+    property alias popup: popupLoader.item  // read-only
+    property alias window: popupBehavior.root // read-only
+
+    signal prepareToShow
+    signal prepareToHide
+    signal cancelledByClick
+
+    // implementation
+
+    anchors.fill: parent
+
+    onShowingChanged: notifyChange()
+    onWhenAlsoChanged: notifyChange()
+    function notifyChange() {
+        if(showing && whenAlso) {
+            if(popupLoader.sourceComponent == undefined) {
+                popupLoader.sourceComponent = popupComponent;
+            }
+        } else {
+            mouseArea.enabled = false; // disable before opacity is changed in case it has fading behavior
+            if(Qt.isQtObject(popupLoader.item)) {
+                popupBehavior.prepareToHide();
+                popupLoader.item.opacity = 0;
+            }
+        }
+    }
+
+    property Item root: findRoot()
+    function findRoot() {
+        var p = parent;
+        while(p.parent != undefined)
+            p = p.parent;
+
+        return p;
+    }
+
+    MouseArea {
+        id: mouseArea
+        anchors.fill: parent
+        enabled: false  // enabled only when popout is showing
+        onPressed: {
+            popupBehavior.showing = false;
+            mouse.accepted = consumeCancelClick;
+            cancelledByClick();
+        }
+    }
+
+    Loader {
+        id: popupLoader
+    }
+
+    Timer { // visibility timer
+        running: Qt.isQtObject(popupLoader.item) && showing && whenAlso
+        interval: delay
+        onTriggered: {
+            popupBehavior.prepareToShow();
+            mouseArea.enabled = true;
+            popup.opacity = 1;
+        }
+    }
+
+    Timer { // deallocation timer
+        running: Qt.isQtObject(popupLoader.item) && popupLoader.item.opacity == 0
+        interval: deallocationDelay
+        onTriggered: popupLoader.sourceComponent = undefined
+    }
+
+    states: State {
+        name: "active"
+        when: Qt.isQtObject(popupLoader.item) && popupLoader.item.opacity > 0
+        ParentChange { target: popupBehavior; parent: root }
+    }
+ }
+
diff --git a/components/private/Splitter.qml b/components/private/Splitter.qml
new file mode 100644
index 0000000..61c2d9f
--- /dev/null
+++ b/components/private/Splitter.qml
@@ -0,0 +1,445 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Components project.
+**
+** $QT_BEGIN_LICENSE:BSD$
+** You may use this file under the terms of the BSD license as follows:
+**
+** "Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above copyright
+**     notice, this list of conditions and the following disclaimer in
+**     the documentation and/or other materials provided with the
+**     distribution.
+**   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
+**     the names of its contributors may be used to endorse or promote
+**     products derived from this software without specific prior written
+**     permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+import QtQuick 2.0
+import QtDesktop 0.2
+
+Splitter {
+    id: root
+    default property alias items: splitterItems.children
+    property alias handles: splitterHandles.children
+    property Component handleBackground: Rectangle { width:3; color: "black" }
+    property int handleWidth: -1
+    property real preferredSize: 0
+    property int orientation: Qt.Horizontal
+
+    clip: true
+    Component.onCompleted: d.init();
+    onWidthChanged: d.updateLayout();
+    onHeightChanged: d.updateLayout();
+
+    QtObject {
+        id: d
+
+        property bool horizontal: orientation == Qt.Horizontal
+        property string size: horizontal ? "width" : "height"
+        property string minimum: horizontal ? "minimumWidth" : "minimumHeight"
+        property string maximum: horizontal ? "maximumWidth" : "maximumHeight"
+
+        property string offset: horizontal ? "x" : "y"
+        property int expandingIndex: -1
+        property bool updateLayoutGuard: true
+        property bool itemWidthGuard: false
+        property bool itemExpandingGuard: true
+
+        function init()
+        {
+            for (var i=0; i<items.length; ++i) {
+                var item = items[i];
+
+                item.Splitter.itemIndex = i
+                // Assign one, and only one, item to be expanding:
+                if (item.Splitter.expanding === true) {
+                    if (d.expandingIndex === -1 && item.visible === true)
+                        d.expandingIndex = i
+                    else
+                        item.Splitter.expanding = false
+                }
+
+                // Anchor each item to fill out all space vertically:
+                if (d.horizontal) {
+                    item.anchors.top = splitterItems.top
+                    item.anchors.bottom = splitterItems.bottom
+                } else  {
+                    item.anchors.left = splitterItems.left
+                    item.anchors.right = splitterItems.right
+
+                }
+
+                // Listen for changes to width and expanding:
+                propertyChangeListener.createObject(item, {"itemIndex":i});
+                if (i < items.length-1) {
+                    // Create a handle for the item, unless its the last:
+                    var handle = handleBackgroundLoader.createObject(splitterHandles, {"handleIndex":i});
+
+                    if (d.horizontal) {
+                        handle.anchors.top = splitterHandles.top
+                        handle.anchors.bottom = splitterHandles.bottom
+                    } else {
+                        handle.anchors.left = splitterHandles.left
+                        handle.anchors.right = splitterHandles.right
+                    }
+                }
+            }
+
+            if (d.expandingIndex === -1) {
+                // INVARIANT: No item was set as expanding.
+                // We then choose the last visible item instead:
+                d.expandingIndex = items.length - 1
+                for (i=items.length-1; i>=0; --i) {
+                    var item = items[i]
+                    if (item.visible === true) {
+                        d.expandingIndex = i
+                        item = items[i]
+                        break
+                    }
+                }
+                item.Splitter.expanding = true
+            }
+
+            d.itemExpandingGuard = false
+            d.updateLayoutGuard = false
+            d.updateLayout()
+        }
+
+        function accumulatedSize(firstIndex, lastIndex, includeExpandingMinimum)
+        {
+            // Go through items and handles, and
+            // calculate their acummulated width.
+            var w = 0
+            for (var i=firstIndex; i<lastIndex; ++i) {
+                var item = items[i]
+                if (item.visible) {
+                    if (i !== d.expandingIndex)
+                        w += item[d.size];
+                    else if (includeExpandingMinimum && item.Splitter[minimum] != -1)
+                        w += item[minimum]
+                }
+
+                var handle = handles[i]
+                if (handle && items[i + ((d.expandingIndex > i) ? 0 : 1)].visible)
+                    w += handle[d.size]
+            }
+            return w
+        }
+
+        function updateLayout()
+        {
+            // This function will reposition both handles and
+            // items according to the _width of the each item_
+            if (items.length === 0)
+                return;
+            if (d.updateLayoutGuard === true)
+                return
+            d.updateLayoutGuard = true
+
+            // Use a temporary variable to store values to avoid breaking
+            // property bindings when the value does not actually change:
+            var newValue
+
+            // Ensure all items within min/max:
+            for (var i=0; i<items.length; ++i) {
+                if (i !== d.expandingIndex) {
+                    item = items[i];
+                    // If the item is using percentage width, convert
+                    // that number to real width now:
+                    if (item.Splitter.percentageSize !== -1) {
+                        newValue = item.Splitter.percentageSize * (root[d.size] / 100)
+                        if (newValue !== item[d.size])
+                            item[d.size] = newValue
+                    }
+                    // Ensure item width is not more than maximumSize:
+                    if (item.Splitter[maximum] !== -1) {
+                        newValue = Math.min(item[d.size], item.Splitter[maximum])
+                        if (newValue !== item[d.size])
+                            item[d.size] = newValue
+                    }
+                    // Ensure item width is not more less minimumWidth:
+                    if (item.Splitter[minimum] !== -1) {
+                        newValue = Math.max(item[d.size], item.Splitter[minimum])
+                        if (newValue !== item[d.size])
+                            item[d.size] = newValue
+                    }
+                }
+            }
+
+            // Special case: set width of expanding item to available space:
+            newValue = root[d.size] - d.accumulatedSize(0, items.length, false);
+            var expandingItem = items[d.expandingIndex]
+            var expandingMinimum = 0
+            if (expandingItem.Splitter[minimum] !== -1)
+                expandingMinimum = expandingItem.Splitter[minimum]
+            newValue = Math.max(newValue, expandingMinimum)
+            if (expandingItem[d.size] !== 0 && expandingItem.Splitter.percentageSize !== -1)
+                expandingItem.Splitter.percentageSize = newValue * (100 / root[d.size])
+            if (expandingItem[d.size] !== newValue)
+                expandingItem[d.size] = newValue
+
+            // Then, position items and handles according to their width:
+            var item, lastVisibleItem
+            var handle, lastVisibleHandle
+            var newpreferredSize = expandingMinimum - expandingItem[d.size]
+
+            for (i=0; i<items.length; ++i) {
+                // Position item to the right of the previous visible handle:
+                item = items[i];
+                if (item.visible) {
+                    if (lastVisibleHandle) {
+                        newValue = lastVisibleHandle[d.offset] + lastVisibleHandle[d.size]
+                        if (newValue !== item[d.offset])
+                            item[d.offset] = newValue
+                    } else {
+                        newValue = 0
+                        if (newValue !== item[d.offset])
+                            item[d.offset] = newValue
+                    }
+                    newpreferredSize += item[d.size]
+                    lastVisibleItem = item
+                }
+
+                // Position handle to the right of the previous visible item. We use an alterative way of
+                // checking handle visibility because that property might not have updated correctly yet:
+                handle = handles[i]
+                if (handle && items[i + ((d.expandingIndex > i) ? 0 : 1)].visible) {
+                    newValue = lastVisibleItem[d.offset] + Math.max(0, lastVisibleItem[d.size])
+                    if (newValue !== handle[d.offset])
+                        handle[d.offset] = newValue
+                    newpreferredSize += handle[d.size]
+                    lastVisibleHandle = handle
+                }
+            }
+
+            root.preferredSize = newpreferredSize
+            d.updateLayoutGuard = false
+        }
+    }
+
+    Component {
+        id: handleBackgroundLoader
+        Loader {
+            id: myHandle
+            property int handleIndex: 0
+            property Item handle: myHandle
+            property Item splitterItem: items[handleIndex + ((d.expandingIndex > handleIndex) ? 0 : 1)]
+
+             // 'splitterRow' should be an alias, but that fails to resolve runtime:
+            property Item splitterRow: root
+            property Item background: item
+
+            visible: splitterItem.visible
+            sourceComponent: handleBackground
+            onWidthChanged: d.updateLayout()
+
+            onXChanged: {
+                // Moving the handle means resizing an item. Which one,
+                // left or right, depends on where the expanding item is.
+                // 'updateLayout' will override in case new width violates max/min.
+                // And 'updateLayout will be triggered when an item changes width.
+                if (d.updateLayoutGuard)
+                    return
+
+                var leftHandle, leftItem, rightItem, rightHandle
+                var leftEdge, rightEdge, newWidth, leftStopX, rightStopX
+                var i
+
+                if (d.expandingIndex > handleIndex) {
+                    // Resize item to the left.
+                    // Ensure that the handle is not crossing other handles. So
+                    // find the first visible handle to the left to determine the left edge:
+                    leftEdge = 0
+                    for (i=handleIndex-1; i>=0; --i) {
+                        leftHandle = handles[i]
+                        if (leftHandle.visible) {
+                            leftEdge = leftHandle[d.offset] + leftHandle[d.size]
+                            break;
+                        }
+                    }
+
+                    // Ensure: leftStopX >= myHandle[d.offset] >= rightStopX
+                    var min = d.accumulatedSize(handleIndex+1, items.length, true)
+                    rightStopX = root[d.size] - min - myHandle[d.size]
+                    leftStopX = Math.max(leftEdge, myHandle[d.offset])
+                    myHandle[d.offset] = Math.min(rightStopX, Math.max(leftStopX, myHandle[d.offset]))
+
+                    newWidth = myHandle[d.offset] - leftEdge
+                    leftItem = items[handleIndex]
+                    if (root[d.size] != 0 && leftItem.Splitter.percentageSize !== -1)
+                        leftItem.Splitter.percentageSize = newWidth * (100 / root[d.size])
+                    // The next line will trigger 'updateLayout' inside 'propertyChangeListener':
+                    leftItem[d.size] = newWidth
+                } else {
+                    // Resize item to the right.
+                    // Ensure that the handle is not crossing other handles. So
+                    // find the first visible handle to the right to determine the right edge:
+                    rightEdge = root[d.size]
+                    for (i=handleIndex+1; i<handles.length; ++i) {
+                        rightHandle = handles[i]
+                        if (rightHandle.visible) {
+                            rightEdge = rightHandle[d.offset]
+                            break;
+                        }
+                    }
+
+                    // Ensure: leftStopX <= myHandle[d.offset] <= rightStopX
+                    var min = d.accumulatedSize(0, handleIndex+1, true)
+                    leftStopX = min - myHandle[d.size]
+                    rightStopX = Math.min((rightEdge - myHandle[d.size]), myHandle[d.offset])
+                    myHandle[d.offset] = Math.max(leftStopX, Math.min(myHandle[d.offset], rightStopX))
+
+                    newWidth = rightEdge - (myHandle[d.offset] + myHandle[d.size])
+                    rightItem = items[handleIndex+1]
+                    if (root[d.size] !== 0 && rightItem[d.percentageSize] !== -1)
+                        rightItem.Splitter.percentageSize = newWidth * (100 / root[d.size])
+                    // The next line will trigger 'updateLayout' inside 'propertyChangeListener':
+                    rightItem[d.size] = newWidth
+                }
+            }
+        }
+    }
+
+    Item {
+        id: splitterItems
+        anchors.fill: parent
+    }
+    Item {
+        id: splitterHandles
+        anchors.fill: parent
+    }
+
+    Component {
+        // This dummy item becomes a child of all
+        // items it the splitter, just to provide a way
+        // to listen for changes to their width, expanding etc.
+        id: propertyChangeListener
+        Item {
+            id: target
+            width: parent[d.size]
+            property bool expanding: parent.Splitter.expanding
+            property real percentageSize: parent.Splitter.percentageSize
+            property real minimumWidth: parent.Splitter[d.minimum]
+            property real maximumSize: parent.Splitter[d.maximum]
+            property int itemIndex: parent.Splitter.itemIndex
+
+            onPercentageSizeChanged: d.updateLayout();
+            onMinimumWidthChanged: d.updateLayout();
+            onMaximumSizeChanged: d.updateLayout();
+            onExpandingChanged: updateExpandingIndex()
+
+            function updateExpandingIndex()
+            {
+                // The following code is needed to avoid a binding
+                // loop, since we might change 'expanding' again to a different item:
+                if (d.itemExpandingGuard === true)
+                    return
+                d.itemExpandingGuard = true
+                // break binding:
+                expanding = false
+
+                // 'expanding' follows radio button behavior:
+                // First, find the new expanding item:
+                var newIndex = items.length-1
+                for (var i=0; i<items.length; ++i) {
+                    var item = items[i]
+                    if (i !== d.expandingIndex && item.Splitter.expanding === true && item.visible === true) {
+                        newIndex = i
+                        break
+                    }
+                }
+                item = items[newIndex]
+                if (item.visible === false) {
+                    // So now we ended up with the last item in the splitter to be
+                    // expanding, but it turns out to not be visible. So we need to
+                    // traverse backwards again to find one that is visible...
+                    for (i=items.length-2; i>=0; --i) {
+                        var item = items[i]
+                        if (item.visible === true) {
+                            newIndex = i
+                            item = items[newIndex]
+                           break
+                        }
+                    }
+                }
+
+                // Tell the found item that it is expanding:
+                if (item.Splitter.expanding !== true)
+                    item.Splitter.expanding = true
+                // ...and the old one that it is not:
+                if (newIndex !== d.expandingIndex) {
+                    item = items[d.expandingIndex]
+                    if (item.Splitter.expanding !== false)
+                        item.Splitter.expanding = false
+                }
+                // update index:
+                d.expandingIndex = newIndex
+                d.updateLayout();
+                // recreate binding:
+                expanding = function() { return parent.Splitter.expanding }
+                d.itemExpandingGuard = false
+            }
+
+            function handleSizeChanged() {
+                // We need to update the layout.
+                // The following code is needed to avoid a binding
+                // loop, since we might change 'width' again to a different value:
+                if (d.itemWidthGuard === true)
+                    return
+                d.itemWidthGuard = true
+                // Break binding:
+                this[d.size] = 0
+
+                d.updateLayout()
+
+                // Restablish binding:
+                width = Qt.binding(function() { return parent[d.size]; })
+                d.itemWidthGuard = false
+            }
+
+            onWidthChanged:  handleSizeChanged()
+            onHeightChanged: handleSizeChanged()
+            onVisibleChanged: {
+                // Hiding the expanding item forces us to
+                // select a new one (and therefore not recommended):
+                if (d.expandingIndex === itemIndex) {
+                    updateExpandingIndex()
+                } else {
+                    if (visible) {
+                        // Try to keep all items within the SplitterRow. When an item
+                        // has been hidden, the expanding item might no longer be large enough
+                        // to give away space to the new items width. So we need to resize:
+                        var overflow = d.accumulatedSize(0, items.length, true) - root[d.size];
+                        if (overflow > 0)
+                            parent[d.size] -= overflow
+                    }
+                    d.updateLayout()
+                }
+            }
+        }
+    }
+}
diff --git a/src/qstyleitem.cpp b/src/qstyleitem.cpp
index 15d5f41..397ff3c 100644
--- a/src/qstyleitem.cpp
+++ b/src/qstyleitem.cpp
@@ -929,7 +929,7 @@ void QStyleItem::showToolTip(const QString &str)
 }
 #endif
 
-QRect QStyleItem::subControlRect(const QString &subcontrolString)
+QRectF QStyleItem::subControlRect(const QString &subcontrolString)
 {
     QStyle::SubControl subcontrol = QStyle::SC_None;
     initStyleOption();
@@ -984,7 +984,7 @@ QRect QStyleItem::subControlRect(const QString &subcontrolString)
     default:
         break;
     }
-    return QRect();
+    return QRectF();
 }
 
 void QStyleItem::paint(QPainter *painter)
diff --git a/src/qstyleitem.h b/src/qstyleitem.h
index 1f7f42d..49d67de 100644
--- a/src/qstyleitem.h
+++ b/src/qstyleitem.h
@@ -189,7 +189,7 @@ public Q_SLOTS:
     void updateSizeHint();
     void updateItem(){initStyleOption(); update();}
     QString hitTest(int x, int y);
-    QRect subControlRect(const QString &subcontrolString);
+    QRectF subControlRect(const QString &subcontrolString);
     QString elidedText(const QString &text, int elideMode, int width);
     int textWidth(const QString &);
     bool hasThemeIcon(const QString &) const;