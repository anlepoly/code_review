diff --git a/src/tools/qdoc/codemarker.cpp b/src/tools/qdoc/codemarker.cpp
index e82a4a0..d40db41 100644
--- a/src/tools/qdoc/codemarker.cpp
+++ b/src/tools/qdoc/codemarker.cpp
@@ -273,7 +273,7 @@ QString CodeMarker::taggedNode(const Node* node)
     case Node::Property:
         tag = QLatin1String("@property");
         break;
-    case Node::Fake:
+    case Node::Document:
         /*
           Remove the "QML:" prefix, if present.
           There shouldn't be any of these "QML:"
@@ -464,7 +464,7 @@ void CodeMarker::insert(FastSection& fastSection,
 
     bool inheritedMember = false;
     InnerNode* parent = node->parent();
-    if (parent && (parent->type() == Node::Fake) &&
+    if (parent && (parent->type() == Node::Document) &&
             (parent->subType() == Node::QmlPropertyGroup)) {
         parent = parent->parent();
     }
@@ -476,7 +476,7 @@ void CodeMarker::insert(FastSection& fastSection,
             fastSection.memberMap.insert(key, node);
     }
     else {
-        if ((parent->type() == Node::Fake) && (parent->subType() == Node::QmlClass)) {
+        if ((parent->type() == Node::Document) && (parent->subType() == Node::QmlClass)) {
             if (fastSection.inherited.isEmpty()
                     || fastSection.inherited.last().first != parent) {
                 QPair<InnerNode*, int> p(parent, 0);
@@ -605,7 +605,7 @@ QStringList CodeMarker::macRefsForNode(Node *node)
         return stringList;
     }
     case Node::Namespace:
-    case Node::Fake:
+    case Node::Document:
     default:
         return QStringList();
     }
diff --git a/src/tools/qdoc/codeparser.cpp b/src/tools/qdoc/codeparser.cpp
index e811120..dbbb20c 100644
--- a/src/tools/qdoc/codeparser.cpp
+++ b/src/tools/qdoc/codeparser.cpp
@@ -251,7 +251,7 @@ void CodeParser::processCommonMetaCommand(const Location& location,
     }
     else if (command == COMMAND_INQMLMODULE) {
         node->setQmlModule(arg);
-        FakeNode* fn = FakeNode::lookupQmlModuleNode(tree, arg);
+        DocNode* fn = DocNode::lookupQmlModuleNode(tree, arg);
         fn->addQmlModuleMember(node);
         QString qmid = node->qmlModuleIdentifier();
         QmlClassNode* qcn = static_cast<QmlClassNode*>(node);
@@ -297,9 +297,9 @@ void CodeParser::processCommonMetaCommand(const Location& location,
         node->addPageKeywords(arg.first);
     }
     else if (command == COMMAND_SUBTITLE) {
-        if (node->type() == Node::Fake) {
-            FakeNode *fake = static_cast<FakeNode *>(node);
-            fake->setSubTitle(arg.first);
+        if (node->type() == Node::Document) {
+            DocNode *dn = static_cast<DocNode *>(node);
+            dn->setSubTitle(arg.first);
         }
         else
             location.warning(tr("Ignored '\\%1'").arg(COMMAND_SUBTITLE));
@@ -308,13 +308,13 @@ void CodeParser::processCommonMetaCommand(const Location& location,
         node->setThreadSafeness(Node::ThreadSafe);
     }
     else if (command == COMMAND_TITLE) {
-        if (node->type() == Node::Fake) {
-            FakeNode *fake = static_cast<FakeNode *>(node);
-            fake->setTitle(arg.first);
-            if (fake->subType() == Node::Example) {
-                ExampleNode::exampleNodeMap.insert(fake->title(),static_cast<ExampleNode*>(fake));
+        if (node->type() == Node::Document) {
+            DocNode *dn = static_cast<DocNode *>(node);
+            dn->setTitle(arg.first);
+            if (dn->subType() == Node::Example) {
+                ExampleNode::exampleNodeMap.insert(dn->title(),static_cast<ExampleNode*>(dn));
             }
-            nameToTitle.insert(fake->name(),arg.first);
+            nameToTitle.insert(dn->name(),arg.first);
         }
         else
             location.warning(tr("Ignored '\\%1'").arg(COMMAND_TITLE));
diff --git a/src/tools/qdoc/cppcodemarker.cpp b/src/tools/qdoc/cppcodemarker.cpp
index e910665..80fb75a 100644
--- a/src/tools/qdoc/cppcodemarker.cpp
+++ b/src/tools/qdoc/cppcodemarker.cpp
@@ -1353,13 +1353,12 @@ QList<Section> CppCodeMarker::qmlSections(const QmlClassNode* qmlClassNode, Syno
                     }
                     ++c;
                 }
-                const FakeNode* fn = current->qmlBase();
-                if (fn) {
-                    if (fn->subType() == Node::QmlClass)
-                        current = static_cast<const QmlClassNode*>(fn);
+                const DocNode* dn = current->qmlBase();
+                if (dn) {
+                    if (dn->subType() == Node::QmlClass)
+                        current = static_cast<const QmlClassNode*>(dn);
                     else {
-                        fn->doc().location().warning(tr("Base class of QML class '%1' is ambgiguous")
-                                                     .arg(current->name()));
+                        dn->doc().location().warning(tr("Base class of QML class '%1' is ambgiguous").arg(current->name()));
                         current = 0;
                     }
                 }
diff --git a/src/tools/qdoc/cppcodeparser.cpp b/src/tools/qdoc/cppcodeparser.cpp
index c072243..b88fde1 100644
--- a/src/tools/qdoc/cppcodeparser.cpp
+++ b/src/tools/qdoc/cppcodeparser.cpp
@@ -518,9 +518,10 @@ Node* CppCodeParser::processTopicCommand(const Doc& doc,
                 if (parentPath.isEmpty() && !lastPath.isEmpty())
                     func = tree_->findFunctionNode(lastPath, clone);
                 if (func == 0) {
-                    doc.location().warning(tr("Cannot find '%1' in '\\%2'")
+                    doc.location().warning(tr("Cannot find '%1' in '\\%2' %3")
                                            .arg(clone->name() + "(...)")
-                                           .arg(COMMAND_FN),
+                                           .arg(COMMAND_FN)
+                                           .arg(arg.first),
                                            tr("I cannot find any function of that name with the "
                                               "specified signature. Make sure that the signature "
                                               "is identical to the declaration, including 'const' "
@@ -590,7 +591,7 @@ Node* CppCodeParser::processTopicCommand(const Doc& doc,
          */
         Node::Type type =  nodeTypeMap[command];
         Node::SubType subtype = Node::NoSubType;
-        if (type == Node::Fake)
+        if (type == Node::Document)
             subtype = Node::QmlClass;
 
         QStringList paths = arg.first.split(QLatin1Char(' '));
@@ -648,34 +649,34 @@ Node* CppCodeParser::processTopicCommand(const Doc& doc,
         }
     }
     else if (command == COMMAND_EXTERNALPAGE) {
-        FakeNode* fn = new FakeNode(tree_->root(), arg.first, Node::ExternalPage, Node::ArticlePage);
-        fn->setLocation(doc.startLocation());
-        return fn;
+        DocNode* dn = new DocNode(tree_->root(), arg.first, Node::ExternalPage, Node::ArticlePage);
+        dn->setLocation(doc.startLocation());
+        return dn;
     }
     else if (command == COMMAND_FILE) {
-        FakeNode* fn = new FakeNode(tree_->root(), arg.first, Node::File, Node::NoPageType);
-        fn->setLocation(doc.startLocation());
-        return fn;
+        DocNode* dn = new DocNode(tree_->root(), arg.first, Node::File, Node::NoPageType);
+        dn->setLocation(doc.startLocation());
+        return dn;
     }
     else if (command == COMMAND_GROUP) {
-        FakeNode* fn = new FakeNode(tree_->root(), arg.first, Node::Group, Node::OverviewPage);
-        fn->setLocation(doc.startLocation());
-        return fn;
+        DocNode* dn = new DocNode(tree_->root(), arg.first, Node::Group, Node::OverviewPage);
+        dn->setLocation(doc.startLocation());
+        return dn;
     }
     else if (command == COMMAND_HEADERFILE) {
-        FakeNode* fn = new FakeNode(tree_->root(), arg.first, Node::HeaderFile, Node::ApiPage);
-        fn->setLocation(doc.startLocation());
-        return fn;
+        DocNode* dn = new DocNode(tree_->root(), arg.first, Node::HeaderFile, Node::ApiPage);
+        dn->setLocation(doc.startLocation());
+        return dn;
     }
     else if (command == COMMAND_MODULE) {
-        FakeNode* fn = new FakeNode(tree_->root(), arg.first, Node::Module, Node::OverviewPage);
-        fn->setLocation(doc.startLocation());
-        return fn;
+        DocNode* dn = new DocNode(tree_->root(), arg.first, Node::Module, Node::OverviewPage);
+        dn->setLocation(doc.startLocation());
+        return dn;
     }
     else if (command == COMMAND_QMLMODULE) {
-        FakeNode* fn = FakeNode::lookupQmlModuleNode(tree_, arg);
-        fn->setLocation(doc.startLocation());
-        return fn;
+        DocNode* dn = DocNode::lookupQmlModuleNode(tree_, arg);
+        dn->setLocation(doc.startLocation());
+        return dn;
     }
     else if (command == COMMAND_PAGE) {
         Node::PageType ptype = Node::ArticlePage;
@@ -710,21 +711,21 @@ Node* CppCodeParser::processTopicCommand(const Doc& doc,
           node and return that one.
         */
         NameCollisionNode* ncn = tree_->checkForCollision(args[0]);
-        FakeNode* fn = 0;
+        DocNode* dn = 0;
         if (ptype == Node::DitaMapPage)
-            fn = new DitaMapNode(tree_->root(), args[0]);
+            dn = new DitaMapNode(tree_->root(), args[0]);
         else
-            fn = new FakeNode(tree_->root(), args[0], Node::Page, ptype);
-        fn->setLocation(doc.startLocation());
+            dn = new DocNode(tree_->root(), args[0], Node::Page, ptype);
+        dn->setLocation(doc.startLocation());
         if (ncn) {
-            ncn->addCollision(fn);
+            ncn->addCollision(dn);
         }
-        return fn;
+        return dn;
     }
     else if (command == COMMAND_DITAMAP) {
-        FakeNode* fn = new DitaMapNode(tree_->root(), arg.first);
-        fn->setLocation(doc.startLocation());
-        return fn;
+        DocNode* dn = new DitaMapNode(tree_->root(), arg.first);
+        dn->setLocation(doc.startLocation());
+        return dn;
     }
     else if ((command == COMMAND_QMLCLASS) || (command == COMMAND_QMLTYPE)) {
         if (command == COMMAND_QMLCLASS)
@@ -1084,7 +1085,7 @@ void CppCodeParser::processOtherMetaCommand(const Doc& doc,
             /*
               It should be a header file, I think.
             */
-            n = tree_->findNodeByNameAndType(QStringList(arg), Node::Fake, Node::NoSubType, 0);
+            n = tree_->findNodeByNameAndType(QStringList(arg), Node::Document, Node::NoSubType, 0);
         }
         else {
             /*
@@ -1135,7 +1136,7 @@ void CppCodeParser::processOtherMetaCommand(const Doc& doc,
         }
     }
     else if (command == COMMAND_QMLINSTANTIATES) {
-        if ((node->type() == Node::Fake) && (node->subType() == Node::QmlClass)) {
+        if ((node->type() == Node::Document) && (node->subType() == Node::QmlClass)) {
             ClassNode* classNode = tree_->findClassNode(arg.split("::"));
             if (classNode)
                 node->setClassNode(classNode);
@@ -1150,7 +1151,7 @@ void CppCodeParser::processOtherMetaCommand(const Doc& doc,
             QmlPropertyNode* qpn = static_cast<QmlPropertyNode*>(node);
             qpn->setDefault();
         }
-        else if (node->type() == Node::Fake && node->subType() == Node::QmlPropertyGroup) {
+        else if (node->type() == Node::Document && node->subType() == Node::QmlPropertyGroup) {
             QmlPropGroupNode* qpgn = static_cast<QmlPropGroupNode*>(node);
             NodeList::ConstIterator p = qpgn->childNodes().constBegin();
             while (p != qpgn->childNodes().constEnd()) {
@@ -1167,7 +1168,7 @@ void CppCodeParser::processOtherMetaCommand(const Doc& doc,
             QmlPropertyNode* qpn = static_cast<QmlPropertyNode*>(node);
             qpn->setReadOnly(1);
         }
-        else if (node->type() == Node::Fake && node->subType() == Node::QmlPropertyGroup) {
+        else if (node->type() == Node::Document && node->subType() == Node::QmlPropertyGroup) {
             QmlPropGroupNode* qpgn = static_cast<QmlPropGroupNode*>(node);
             NodeList::ConstIterator p = qpgn->childNodes().constBegin();
             while (p != qpgn->childNodes().constEnd()) {
@@ -1180,7 +1181,7 @@ void CppCodeParser::processOtherMetaCommand(const Doc& doc,
         }
     }
     else if (command == COMMAND_QMLABSTRACT) {
-        if ((node->type() == Node::Fake) && (node->subType() == Node::QmlClass)) {
+        if ((node->type() == Node::Document) && (node->subType() == Node::QmlClass)) {
             node->setAbstract(true);
         }
     }
@@ -1834,7 +1835,6 @@ bool CppCodeParser::matchNamespaceDecl(InnerNode *parent)
 
     readToken(); // skip '{'
     bool matched = matchDeclList(ns);
-
     return matched && match(Tok_RightBrace);
 }
 
@@ -2268,8 +2268,9 @@ bool CppCodeParser::matchDocsAndStuff()
                     foreach (const QString& usedNamespace_, activeNamespaces_) {
                         QStringList newPath = usedNamespace_.split("::") + parentPath;
                         func = tree_->findFunctionNode(newPath, clone);
-                        if (func)
+                        if (func) {
                             break;
+                        }
                     }
                     if (func == 0)
                         func = tree_->findFunctionNode(parentPath, clone);
@@ -2483,13 +2484,13 @@ void CppCodeParser::instantiateIteratorMacro(const QString &container,
     matchDeclList(tree_->root());
 }
 
-void CppCodeParser::createExampleFileNodes(FakeNode *fake)
+void CppCodeParser::createExampleFileNodes(DocNode *dn)
 {
-    QString examplePath = fake->name();
+    QString examplePath = dn->name();
     QString proFileName = examplePath + QLatin1Char('/') + examplePath.split(QLatin1Char('/')).last() + ".pro";
     QString userFriendlyFilePath;
 
-    QString fullPath = Config::findFile(fake->doc().location(),
+    QString fullPath = Config::findFile(dn->doc().location(),
                                         exampleFiles,
                                         exampleDirs,
                                         proFileName,
@@ -2499,7 +2500,7 @@ void CppCodeParser::createExampleFileNodes(FakeNode *fake)
         QString tmp = proFileName;
         proFileName = examplePath + QLatin1Char('/') + "qbuild.pro";
         userFriendlyFilePath.clear();
-        fullPath = Config::findFile(fake->doc().location(),
+        fullPath = Config::findFile(dn->doc().location(),
                                     exampleFiles,
                                     exampleDirs,
                                     proFileName,
@@ -2507,14 +2508,14 @@ void CppCodeParser::createExampleFileNodes(FakeNode *fake)
         if (fullPath.isEmpty()) {
             proFileName = examplePath + QLatin1Char('/') + examplePath.split(QLatin1Char('/')).last() + ".qmlproject";
             userFriendlyFilePath.clear();
-            fullPath = Config::findFile(fake->doc().location(),
+            fullPath = Config::findFile(dn->doc().location(),
                                         exampleFiles,
                                         exampleDirs,
                                         proFileName,
                                         userFriendlyFilePath);
             if (fullPath.isEmpty()) {
-                fake->location().warning(tr("Cannot find file '%1' or '%2'").arg(tmp).arg(proFileName));
-                fake->location().warning(tr("  EXAMPLE PATH DOES NOT EXIST: %1").arg(examplePath));
+                dn->location().warning(tr("Cannot find file '%1' or '%2'").arg(tmp).arg(proFileName));
+                dn->location().warning(tr("  EXAMPLE PATH DOES NOT EXIST: %1").arg(examplePath));
                 return;
             }
         }
@@ -2551,16 +2552,16 @@ void CppCodeParser::createExampleFileNodes(FakeNode *fake)
     }
 
     foreach (const QString &exampleFile, exampleFiles) {
-        new FakeNode(fake,
-                     exampleFile.mid(sizeOfBoringPartOfName),
-                     Node::File,
-                     Node::NoPageType);
+        new DocNode(dn,
+                    exampleFile.mid(sizeOfBoringPartOfName),
+                    Node::File,
+                    Node::NoPageType);
     }
     foreach (const QString &imageFile, imageFiles) {
-        new FakeNode(fake,
-                     imageFile.mid(sizeOfBoringPartOfName),
-                     Node::Image,
-                     Node::NoPageType);
+        new DocNode(dn,
+                    imageFile.mid(sizeOfBoringPartOfName),
+                    Node::Image,
+                    Node::NoPageType);
     }
 }
 
diff --git a/src/tools/qdoc/cppcodeparser.h b/src/tools/qdoc/cppcodeparser.h
index b6a7dbc..e67abb7 100644
--- a/src/tools/qdoc/cppcodeparser.h
+++ b/src/tools/qdoc/cppcodeparser.h
@@ -159,7 +159,7 @@ protected:
                                   const QString &includeFile,
                                   const QString &macroDef,
                                   Tree *tree);
-    void createExampleFileNodes(FakeNode *fake);
+    void createExampleFileNodes(DocNode *dn);
 
  protected:
     QMap<QString, Node::Type> nodeTypeMap;
diff --git a/src/tools/qdoc/ditaxmlgenerator.cpp b/src/tools/qdoc/ditaxmlgenerator.cpp
index 0d99177..db713fc 100644
--- a/src/tools/qdoc/ditaxmlgenerator.cpp
+++ b/src/tools/qdoc/ditaxmlgenerator.cpp
@@ -841,7 +841,7 @@ int DitaXmlGenerator::generateAtom(const Atom *atom,
         }
         break;
     case Atom::BriefRight:
-        //        if (relative->type() != Node::Fake)
+        //        if (relative->type() != Node::Document)
         writeEndTag(); // </shortdesc> or </p>
         if (in_para)
             in_para = false;
@@ -1125,14 +1125,14 @@ int DitaXmlGenerator::generateAtom(const Atom *atom,
             generateAnnotatedList(relative, marker, namespaceIndex);
         }
         else if (atom->string() == "related") {
-            const FakeNode *fake = static_cast<const FakeNode *>(relative);
-            if (fake && !fake->groupMembers().isEmpty()) {
+            const DocNode *dn = static_cast<const DocNode *>(relative);
+            if (dn && !dn->groupMembers().isEmpty()) {
                 NodeMap groupMembersMap;
-                foreach (const Node *node, fake->groupMembers()) {
-                    if (node->type() == Node::Fake)
+                foreach (const Node *node, dn->groupMembers()) {
+                    if (node->type() == Node::Document)
                         groupMembersMap[fullName(node, relative, marker)] = node;
                 }
-                generateAnnotatedList(fake, marker, groupMembersMap);
+                generateAnnotatedList(dn, marker, groupMembersMap);
             }
         }
         break;
@@ -1154,7 +1154,7 @@ int DitaXmlGenerator::generateAtom(const Atom *atom,
             while (n != nsmap.value().constEnd()) {
                 const Node* node = n.value();
                 switch (node->type()) {
-                case Node::Fake:
+                case Node::Document:
                     if (node->subType() == Node::QmlClass) {
                         sections[QmlClass].appendMember((Node*)node);
                     }
@@ -1309,7 +1309,7 @@ int DitaXmlGenerator::generateAtom(const Atom *atom,
                 images.append(QLatin1Char('/'));
             fileName = images + atom->string();
         }
-        if (relative && (relative->type() == Node::Fake) &&
+        if (relative && (relative->type() == Node::Document) &&
                 (relative->subType() == Node::Example)) {
             const ExampleNode* cen = static_cast<const ExampleNode*>(relative);
             if (cen->imageFileName().isEmpty()) {
@@ -2103,8 +2103,8 @@ DitaXmlGenerator::generateClassLikeNode(InnerNode* inner, CodeMarker* marker)
         generateLowStatusMembers(inner,marker,CodeMarker::Compat);
         writeEndTag(); // </cxxClass>
     }
-    else if ((inner->type() == Node::Fake) && (inner->subType() == Node::HeaderFile)) {
-        const FakeNode* fn = const_cast<FakeNode*>(static_cast<const FakeNode*>(inner));
+    else if ((inner->type() == Node::Document) && (inner->subType() == Node::HeaderFile)) {
+        const DocNode* dn = const_cast<DocNode*>(static_cast<const DocNode*>(inner));
         rawTitle = marker->plainName(inner);
         fullTitle = marker->plainFullName(inner);
         title = rawTitle;
@@ -2121,13 +2121,13 @@ DitaXmlGenerator::generateClassLikeNode(InnerNode* inner, CodeMarker* marker)
 
         writeStartTag(DT_cxxClassDetail);
         enterDesc(DT_apiDesc,QString(),title);
-        generateStatus(fn, marker);
-        generateThreadSafeness(fn, marker);
-        generateSince(fn, marker);
-        generateSince(fn, marker);
+        generateStatus(dn, marker);
+        generateThreadSafeness(dn, marker);
+        generateSince(dn, marker);
+        generateSince(dn, marker);
         enterSection(QString(), QString());
-        generateBody(fn, marker);
-        generateAlsoList(fn, marker);
+        generateBody(dn, marker);
+        generateAlsoList(dn, marker);
         leaveSection();
         leaveSection(); // </apiDesc>
 
@@ -2192,7 +2192,7 @@ DitaXmlGenerator::generateClassLikeNode(InnerNode* inner, CodeMarker* marker)
         s = detailSections.constBegin();
         while (s != detailSections.constEnd()) {
             if ((*s).name == "Classes") {
-                writeNestedClasses((*s),fn);
+                writeNestedClasses((*s),dn);
                 break;
             }
             ++s;
@@ -2201,7 +2201,7 @@ DitaXmlGenerator::generateClassLikeNode(InnerNode* inner, CodeMarker* marker)
         s = detailSections.constBegin();
         while (s != detailSections.constEnd()) {
             if ((*s).name == "Function Documentation") {
-                writeFunctions((*s),fn,marker);
+                writeFunctions((*s),dn,marker);
             }
             else if ((*s).name == "Type Documentation") {
                 writeEnumerations((*s),marker);
@@ -2219,7 +2219,7 @@ DitaXmlGenerator::generateClassLikeNode(InnerNode* inner, CodeMarker* marker)
         generateLowStatusMembers(inner,marker,CodeMarker::Compat);
         writeEndTag(); // </cxxClass>
     }
-    else if ((inner->type() == Node::Fake) && (inner->subType() == Node::QmlClass)) {
+    else if ((inner->type() == Node::Document) && (inner->subType() == Node::QmlClass)) {
         QmlClassNode* qcn = const_cast<QmlClassNode*>(static_cast<const QmlClassNode*>(inner));
         ClassNode* cn = qcn->classNode();
         rawTitle = marker->plainName(inner);
@@ -2285,100 +2285,100 @@ void DitaXmlGenerator::writeXrefListItem(const QString& link, const QString& tex
   Generate the DITA page for a qdoc file that doesn't map
   to an underlying c++ file.
  */
-void DitaXmlGenerator::generateFakeNode(FakeNode* fake, CodeMarker* marker)
+void DitaXmlGenerator::generateDocNode(DocNode* dn, CodeMarker* marker)
 {
     /*
-      If the fake node is a page node, and if the page type
+      If the dn node is a page node, and if the page type
       is DITA map page, write the node's contents as a dita
       map and return without doing anything else.
      */
-    if (fake->subType() == Node::Page && fake->pageType() == Node::DitaMapPage) {
-        const DitaMapNode* dmn = static_cast<const DitaMapNode*>(fake);
+    if (dn->subType() == Node::Page && dn->pageType() == Node::DitaMapPage) {
+        const DitaMapNode* dmn = static_cast<const DitaMapNode*>(dn);
         writeDitaMap(dmn);
         return;
     }
 
     QList<Section> sections;
     QList<Section>::const_iterator s;
-    QString fullTitle = fake->fullTitle();
+    QString fullTitle = dn->fullTitle();
 
-    if (fake->subType() == Node::QmlBasicType) {
+    if (dn->subType() == Node::QmlBasicType) {
         fullTitle = "QML Basic Type: " + fullTitle;
     }
-    else if (fake->subType() == Node::Collision) {
+    else if (dn->subType() == Node::Collision) {
         fullTitle = "Name Collision: " + fullTitle;
     }
 
-    generateHeader(fake, fullTitle);
-    generateBrief(fake, marker); // <shortdesc>
-    writeProlog(fake);
+    generateHeader(dn, fullTitle);
+    generateBrief(dn, marker); // <shortdesc>
+    writeProlog(dn);
 
     writeStartTag(DT_body);
     enterSection(QString(), QString());
-    if (fake->subType() == Node::Module) {
-        generateStatus(fake, marker);
-        if (moduleNamespaceMap.contains(fake->name())) {
+    if (dn->subType() == Node::Module) {
+        generateStatus(dn, marker);
+        if (moduleNamespaceMap.contains(dn->name())) {
             enterSection("h2","Namespaces");
-            generateAnnotatedList(fake, marker, moduleNamespaceMap[fake->name()]);
+            generateAnnotatedList(dn, marker, moduleNamespaceMap[dn->name()]);
             leaveSection();
         }
-        if (moduleClassMap.contains(fake->name())) {
+        if (moduleClassMap.contains(dn->name())) {
             enterSection("h2","Classes");
-            generateAnnotatedList(fake, marker, moduleClassMap[fake->name()]);
+            generateAnnotatedList(dn, marker, moduleClassMap[dn->name()]);
             leaveSection();
         }
     }
 
-    if (fake->doc().isEmpty()) {
-        if (fake->subType() == Node::File) {
+    if (dn->doc().isEmpty()) {
+        if (dn->subType() == Node::File) {
             Text text;
             Quoter quoter;
             writeStartTag(DT_p);
             xmlWriter().writeAttribute("outputclass", "small-subtitle");
-            text << fake->subTitle();
-            generateText(text, fake, marker);
+            text << dn->subTitle();
+            generateText(text, dn, marker);
             writeEndTag(); // </p>
-            Doc::quoteFromFile(fake->doc().location(), quoter, fake->name());
-            QString code = quoter.quoteTo(fake->location(), "", "");
+            Doc::quoteFromFile(dn->doc().location(), quoter, dn->name());
+            QString code = quoter.quoteTo(dn->location(), "", "");
             text.clear();
             text << Atom(Atom::Code, code);
-            generateText(text, fake, marker);
+            generateText(text, dn, marker);
         }
     }
     else {
-        if (fake->subType() == Node::Module) {
+        if (dn->subType() == Node::Module) {
             enterSection(QString(), QString());
-            generateBody(fake, marker);
+            generateBody(dn, marker);
             leaveSection();
         }
         else {
-            generateBody(fake, marker);
+            generateBody(dn, marker);
         }
-        generateAlsoList(fake, marker);
+        generateAlsoList(dn, marker);
 
-        if ((fake->subType() == Node::QmlModule) && !fake->qmlModuleMembers().isEmpty()) {
+        if ((dn->subType() == Node::QmlModule) && !dn->qmlModuleMembers().isEmpty()) {
             NodeMap qmlModuleMembersMap;
-            foreach (const Node* node, fake->qmlModuleMembers()) {
-                if (node->type() == Node::Fake && node->subType() == Node::QmlClass)
+            foreach (const Node* node, dn->qmlModuleMembers()) {
+                if (node->type() == Node::Document && node->subType() == Node::QmlClass)
                     qmlModuleMembersMap[node->name()] = node;
             }
-            generateAnnotatedList(fake, marker, qmlModuleMembersMap);
+            generateAnnotatedList(dn, marker, qmlModuleMembersMap);
         }
-        else if (!fake->groupMembers().isEmpty()) {
+        else if (!dn->groupMembers().isEmpty()) {
             NodeMap groupMembersMap;
-            foreach (const Node *node, fake->groupMembers()) {
+            foreach (const Node *node, dn->groupMembers()) {
                 if (node->type() == Node::Class || node->type() == Node::Namespace)
                     groupMembersMap[node->name()] = node;
             }
-            generateAnnotatedList(fake, marker, groupMembersMap);
+            generateAnnotatedList(dn, marker, groupMembersMap);
         }
     }
     leaveSection(); // </section>
     if (!writeEndTag()) { // </body>
-        fake->doc().location().warning(tr("Pop of empty XML tag stack; generating DITA for '%1'").arg(fake->name()));
+        dn->doc().location().warning(tr("Pop of empty XML tag stack; generating DITA for '%1'").arg(dn->name()));
         return;
     }
-    writeRelatedLinks(fake, marker);
+    writeRelatedLinks(dn, marker);
     writeEndTag(); // </topic>
 }
 
@@ -2413,7 +2413,7 @@ void DitaXmlGenerator::writeLink(const Node* node,
   value of the \e role attribute is \c{parent} for the
   \c{start} link.
  */
-void DitaXmlGenerator::writeRelatedLinks(const FakeNode* node, CodeMarker* marker)
+void DitaXmlGenerator::writeRelatedLinks(const DocNode* node, CodeMarker* marker)
 {
     const Node* linkNode = 0;
     QPair<QString,QString> linkPair;
@@ -2422,27 +2422,27 @@ void DitaXmlGenerator::writeRelatedLinks(const FakeNode* node, CodeMarker* marke
         if (node->links().contains(Node::PreviousLink)) {
             linkPair = node->links()[Node::PreviousLink];
             linkNode = findNodeForTarget(linkPair.first, node, marker);
-            if (linkNode && linkNode->type() == Node::Fake) {
-                const FakeNode *fakeNode = static_cast<const FakeNode*>(linkNode);
-                linkPair.second = fakeNode->title();
+            if (linkNode && linkNode->type() == Node::Document) {
+                const DocNode *docNode = static_cast<const DocNode*>(linkNode);
+                linkPair.second = docNode->title();
             }
             writeLink(linkNode, linkPair.second, "previous");
         }
         if (node->links().contains(Node::NextLink)) {
             linkPair = node->links()[Node::NextLink];
             linkNode = findNodeForTarget(linkPair.first, node, marker);
-            if (linkNode && linkNode->type() == Node::Fake) {
-                const FakeNode *fakeNode = static_cast<const FakeNode*>(linkNode);
-                linkPair.second = fakeNode->title();
+            if (linkNode && linkNode->type() == Node::Document) {
+                const DocNode *docNode = static_cast<const DocNode*>(linkNode);
+                linkPair.second = docNode->title();
             }
             writeLink(linkNode, linkPair.second, "next");
         }
         if (node->links().contains(Node::StartLink)) {
             linkPair = node->links()[Node::StartLink];
             linkNode = findNodeForTarget(linkPair.first, node, marker);
-            if (linkNode && linkNode->type() == Node::Fake) {
-                const FakeNode *fakeNode = static_cast<const FakeNode*>(linkNode);
-                linkPair.second = fakeNode->title();
+            if (linkNode && linkNode->type() == Node::Document) {
+                const DocNode *docNode = static_cast<const DocNode*>(linkNode);
+                linkPair.second = docNode->title();
             }
             writeLink(linkNode, linkPair.second, "parent");
         }
@@ -2499,7 +2499,7 @@ void DitaXmlGenerator::generateHeader(const Node* node,
                 version + "//EN\" \"" + dtd + "\">";
         outputclass = "namespace";
     }
-    else if (node->type() == Node::Fake || subpage) {
+    else if (node->type() == Node::Document || subpage) {
         if (node->subType() == Node::HeaderFile) {
             mainTag = DT_cxxClass;
             nameTag = DT_apiName;
@@ -2910,7 +2910,7 @@ void DitaXmlGenerator::generateAnnotatedList(const Node* relative,
         writeEndTag(); // </p>
         writeEndTag(); // <entry>
 
-        if (!(node->type() == Node::Fake)) {
+        if (!(node->type() == Node::Document)) {
             Text brief = node->doc().trimmedBriefText(name);
             if (!brief.isEmpty()) {
                 writeStartTag(DT_entry);
@@ -3242,38 +3242,38 @@ void DitaXmlGenerator::generateQmlItem(const Node* node,
  */
 void DitaXmlGenerator::generateOverviewList(const Node* relative, CodeMarker* /* marker */)
 {
-    QMap<const FakeNode*, QMap<QString, FakeNode*> > fakeNodeMap;
-    QMap<QString, const FakeNode*> groupTitlesMap;
-    QMap<QString, FakeNode*> uncategorizedNodeMap;
+    QMap<const DocNode*, QMap<QString, DocNode*> > docNodeMap;
+    QMap<QString, const DocNode*> groupTitlesMap;
+    QMap<QString, DocNode*> uncategorizedNodeMap;
     QRegExp singleDigit("\\b([0-9])\\b");
 
     const NodeList children = tree_->root()->childNodes();
     foreach (Node* child, children) {
-        if (child->type() == Node::Fake && child != relative) {
-            FakeNode* fakeNode = static_cast<FakeNode*>(child);
+        if (child->type() == Node::Document && child != relative) {
+            DocNode* docNode = static_cast<DocNode*>(child);
 
             // Check whether the page is part of a group or is the group
             // definition page.
             QString group;
             bool isGroupPage = false;
-            if (fakeNode->doc().metaCommandsUsed().contains("group")) {
-                group = fakeNode->doc().metaCommandArgs("group")[0].first;
+            if (docNode->doc().metaCommandsUsed().contains("group")) {
+                group = docNode->doc().metaCommandArgs("group")[0].first;
                 isGroupPage = true;
             }
 
             // there are too many examples; they would clutter the list
-            if (fakeNode->subType() == Node::Example)
+            if (docNode->subType() == Node::Example)
                 continue;
 
             // not interested either in individual (Qt Designer etc.) manual chapters
-            if (fakeNode->links().contains(Node::ContentsLink))
+            if (docNode->links().contains(Node::ContentsLink))
                 continue;
 
             // Discard external nodes.
-            if (fakeNode->subType() == Node::ExternalPage)
+            if (docNode->subType() == Node::ExternalPage)
                 continue;
 
-            QString sortKey = fakeNode->fullTitle().toLower();
+            QString sortKey = docNode->fullTitle().toLower();
             if (sortKey.startsWith("the "))
                 sortKey.remove(0, 4);
             sortKey.replace(singleDigit, "0\\1");
@@ -3282,26 +3282,26 @@ void DitaXmlGenerator::generateOverviewList(const Node* relative, CodeMarker* /*
                 if (isGroupPage) {
                     // If we encounter a group definition page, we add all
                     // the pages in that group to the list for that group.
-                    foreach (Node* member, fakeNode->groupMembers()) {
-                        if (member->type() != Node::Fake)
+                    foreach (Node* member, docNode->groupMembers()) {
+                        if (member->type() != Node::Document)
                             continue;
-                        FakeNode* page = static_cast<FakeNode*>(member);
+                        DocNode* page = static_cast<DocNode*>(member);
                         if (page) {
                             QString sortKey = page->fullTitle().toLower();
                             if (sortKey.startsWith("the "))
                                 sortKey.remove(0, 4);
                             sortKey.replace(singleDigit, "0\\1");
-                            fakeNodeMap[const_cast<const FakeNode*>(fakeNode)].insert(sortKey, page);
-                            groupTitlesMap[fakeNode->fullTitle()] = const_cast<const FakeNode*>(fakeNode);
+                            docNodeMap[const_cast<const DocNode*>(docNode)].insert(sortKey, page);
+                            groupTitlesMap[docNode->fullTitle()] = const_cast<const DocNode*>(docNode);
                         }
                     }
                 }
                 else if (!isGroupPage) {
                     // If we encounter a page that belongs to a group then
                     // we add that page to the list for that group.
-                    const FakeNode* gn = tree_->findGroupNode(QStringList(group));
+                    const DocNode* gn = tree_->findGroupNode(QStringList(group));
                     if (gn)
-                        fakeNodeMap[gn].insert(sortKey, fakeNode);
+                        docNodeMap[gn].insert(sortKey, docNode);
                 }
             }
         }
@@ -3313,9 +3313,9 @@ void DitaXmlGenerator::generateOverviewList(const Node* relative, CodeMarker* /*
     // incomplete. However, if the group definition page was listed, all the
     // pages in that group are listed for completeness.
 
-    if (!fakeNodeMap.isEmpty()) {
+    if (!docNodeMap.isEmpty()) {
         foreach (const QString& groupTitle, groupTitlesMap.keys()) {
-            const FakeNode* groupNode = groupTitlesMap[groupTitle];
+            const DocNode* groupNode = groupTitlesMap[groupTitle];
             writeStartTag(DT_p);
             xmlWriter().writeAttribute("outputclass","h3");
             writeStartTag(DT_xref);
@@ -3324,18 +3324,18 @@ void DitaXmlGenerator::generateOverviewList(const Node* relative, CodeMarker* /*
             writeCharacters(protectEnc(groupNode->fullTitle()));
             writeEndTag(); // </xref>
             writeEndTag(); // </p>
-            if (fakeNodeMap[groupNode].count() == 0)
+            if (docNodeMap[groupNode].count() == 0)
                 continue;
 
             writeStartTag(DT_ul);
-            foreach (const FakeNode* fakeNode, fakeNodeMap[groupNode]) {
-                QString title = fakeNode->fullTitle();
+            foreach (const DocNode* docNode, docNodeMap[groupNode]) {
+                QString title = docNode->fullTitle();
                 if (title.startsWith("The "))
                     title.remove(0, 4);
                 writeStartTag(DT_li);
                 writeStartTag(DT_xref);
                 // formathtml
-                xmlWriter().writeAttribute("href",linkForNode(fakeNode, relative));
+                xmlWriter().writeAttribute("href",linkForNode(docNode, relative));
                 writeCharacters(protectEnc(title));
                 writeEndTag(); // </xref>
                 writeEndTag(); // </li>
@@ -3350,14 +3350,14 @@ void DitaXmlGenerator::generateOverviewList(const Node* relative, CodeMarker* /*
         xmlWriter().writeCharacters("Miscellaneous");
         writeEndTag(); // </p>
         writeStartTag(DT_ul);
-        foreach (const FakeNode *fakeNode, uncategorizedNodeMap) {
-            QString title = fakeNode->fullTitle();
+        foreach (const DocNode *docNode, uncategorizedNodeMap) {
+            QString title = docNode->fullTitle();
             if (title.startsWith("The "))
                 title.remove(0, 4);
             writeStartTag(DT_li);
             writeStartTag(DT_xref);
             // formathtml
-            xmlWriter().writeAttribute("href",linkForNode(fakeNode, relative));
+            xmlWriter().writeAttribute("href",linkForNode(docNode, relative));
             writeCharacters(protectEnc(title));
             writeEndTag(); // </xref>
             writeEndTag(); // </li>
@@ -3821,7 +3821,7 @@ QString DitaXmlGenerator::guidForNode(const Node* node)
         }
         return fn->guid();
     }
-    case Node::Fake:
+    case Node::Document:
         if (node->subType() != Node::QmlPropertyGroup)
             break;
     case Node::QmlProperty:
@@ -3847,12 +3847,12 @@ QString DitaXmlGenerator::guidForNode(const Node* node)
  */
 QString DitaXmlGenerator::fileName(const Node* node)
 {
-    if (node->type() == Node::Fake) {
-        if (static_cast<const FakeNode*>(node)->pageType() == Node::DitaMapPage)
+    if (node->type() == Node::Document) {
+        if (static_cast<const DocNode*>(node)->pageType() == Node::DitaMapPage)
             return node->name();
-        if (static_cast<const FakeNode*>(node)->subType() == Node::ExternalPage)
+        if (static_cast<const DocNode*>(node)->subType() == Node::ExternalPage)
             return node->name();
-        if (static_cast<const FakeNode*>(node)->subType() == Node::Image)
+        if (static_cast<const DocNode*>(node)->subType() == Node::Image)
             return node->name();
     }
     return Generator::fileName(node);
@@ -3972,7 +3972,7 @@ void DitaXmlGenerator::findAllClasses(const InnerNode* node)
                 if (!serviceName.isEmpty())
                     serviceClasses.insert(serviceName, *c);
             }
-            else if ((*c)->type() == Node::Fake &&
+            else if ((*c)->type() == Node::Document &&
                      (*c)->subType() == Node::QmlClass &&
                      !(*c)->doc().isEmpty()) {
                 QString qmlClassName = (*c)->name();
@@ -4061,7 +4061,7 @@ int DitaXmlGenerator::hOffset(const Node* node)
     case Node::Namespace:
     case Node::Class:
         return 2;
-    case Node::Fake:
+    case Node::Document:
         return 1;
     case Node::Enum:
     case Node::Typedef:
@@ -4093,12 +4093,12 @@ const Node* DitaXmlGenerator::findNodeForTarget(const QString& target,
         node = relative;
     }
     else if (target.endsWith(".html")) {
-        node = tree_->root()->findChildNodeByNameAndType(target, Node::Fake);
+        node = tree_->root()->findChildNodeByNameAndType(target, Node::Document);
     }
     else if (marker) {
         node = marker->resolveTarget(target, tree_, relative);
         if (!node)
-            node = tree_->findFakeNodeByTitle(target, relative);
+            node = tree_->findDocNodeByTitle(target, relative);
         if (!node && atom) {
             node = tree_->findUnambiguousTarget(target, *const_cast<Atom**>(&atom), relative);
         }
@@ -4114,9 +4114,9 @@ const QPair<QString,QString> DitaXmlGenerator::anchorForNode(const Node* node)
 {
     QPair<QString,QString> anchorPair;
     anchorPair.first = Generator::fileName(node);
-    if (node->type() == Node::Fake) {
-        const FakeNode *fakeNode = static_cast<const FakeNode*>(node);
-        anchorPair.second = fakeNode->title();
+    if (node->type() == Node::Document) {
+        const DocNode *docNode = static_cast<const DocNode*>(node);
+        anchorPair.second = docNode->title();
     }
 
     return anchorPair;
@@ -4154,12 +4154,12 @@ QString DitaXmlGenerator::getLink(const Atom* atom,
             *node = relative;
         }
         else if (first.endsWith(".html")) {
-            *node = tree_->root()->findChildNodeByNameAndType(first, Node::Fake);
+            *node = tree_->root()->findChildNodeByNameAndType(first, Node::Document);
         }
         else {
             *node = marker->resolveTarget(first, tree_, relative);
             if (!*node)
-                *node = tree_->findFakeNodeByTitle(first, relative);
+                *node = tree_->findDocNodeByTitle(first, relative);
             if (!*node)
                 *node = tree_->findUnambiguousTarget(first, targetAtom, relative);
         }
@@ -4177,8 +4177,8 @@ QString DitaXmlGenerator::getLink(const Atom* atom,
             if (relative && (relative->parent() != *node) &&
                     (relative->status() != Node::Obsolete)) {
                 bool porting = false;
-                if (relative->type() == Node::Fake) {
-                    const FakeNode* fake = static_cast<const FakeNode*>(relative);
+                if (relative->type() == Node::Document) {
+                    const DocNode* fake = static_cast<const DocNode*>(relative);
                     if (fake->title().startsWith("Porting"))
                         porting = true;
                 }
@@ -4267,17 +4267,17 @@ void DitaXmlGenerator::generateStatus(const Node* node, CodeMarker* marker)
                  << "We strongly advise against "
                  << "using it in new code. See ";
 
-            const FakeNode *fakeNode = tree_->findFakeNodeByTitle("Porting To Qt 4");
+            const DocNode *docNode = tree_->findDocNodeByTitle("Porting To Qt 4");
             Atom *targetAtom = 0;
-            if (fakeNode && node->type() == Node::Class) {
+            if (docNode && node->type() == Node::Class) {
                 QString oldName(node->name());
                 oldName.remove(QLatin1Char('3'));
-                targetAtom = tree_->findTarget(oldName,fakeNode);
+                targetAtom = tree_->findTarget(oldName,docNode);
             }
 
             if (targetAtom) {
-                QString fn = fileName(fakeNode);
-                QString guid = lookupGuid(fn,refForAtom(targetAtom,fakeNode));
+                QString fn = fileName(docNode);
+                QString guid = lookupGuid(fn,refForAtom(targetAtom,docNode));
                 text << Atom(Atom::GuidLink, fn + QLatin1Char('#') + guid);
             }
             else
@@ -4551,7 +4551,7 @@ void DitaXmlGenerator::generateQmlInherits(const QmlClassNode* qcn, CodeMarker*
 {
     if (!qcn)
         return;
-    const FakeNode* base = qcn->qmlBase();
+    const DocNode* base = qcn->qmlBase();
     if (base) {
         writeStartTag(DT_qmlInherits);
         //writeStartTag(DT_qmlTypeDef);
@@ -5647,17 +5647,17 @@ DitaXmlGenerator::generateInnerNode(InnerNode* node)
     if (!node->url().isNull())
         return;
 
-    if (node->type() == Node::Fake) {
-        FakeNode* fakeNode = static_cast<FakeNode*>(node);
-        if (fakeNode->subType() == Node::ExternalPage)
+    if (node->type() == Node::Document) {
+        DocNode* docNode = static_cast<DocNode*>(node);
+        if (docNode->subType() == Node::ExternalPage)
             return;
-        if (fakeNode->subType() == Node::Image)
+        if (docNode->subType() == Node::Image)
             return;
-        if (fakeNode->subType() == Node::QmlPropertyGroup)
+        if (docNode->subType() == Node::QmlPropertyGroup)
             return;
-        if (fakeNode->subType() == Node::Page) {
+        if (docNode->subType() == Node::Page) {
             if (node->count() > 0)
-                qDebug("PAGE %s HAS CHILDREN", qPrintable(fakeNode->title()));
+                qDebug("PAGE %s HAS CHILDREN", qPrintable(docNode->title()));
         }
     }
 
@@ -5671,7 +5671,7 @@ DitaXmlGenerator::generateInnerNode(InnerNode* node)
           later in generateCollisionPages(). Each one is
           appended to a list for later.
          */
-        if ((node->type() == Node::Fake) && (node->subType() == Node::Collision)) {
+        if ((node->type() == Node::Document) && (node->subType() == Node::Collision)) {
             NameCollisionNode* ncn = static_cast<NameCollisionNode*>(node);
             collisionNodes.append(const_cast<NameCollisionNode*>(ncn));
         }
@@ -5681,13 +5681,13 @@ DitaXmlGenerator::generateInnerNode(InnerNode* node)
             if (node->type() == Node::Namespace || node->type() == Node::Class) {
                 generateClassLikeNode(node, marker);
             }
-            else if (node->type() == Node::Fake) {
+            else if (node->type() == Node::Document) {
                 if (node->subType() == Node::HeaderFile)
                     generateClassLikeNode(node, marker);
                 else if (node->subType() == Node::QmlClass)
                     generateClassLikeNode(node, marker);
                 else
-                    generateFakeNode(static_cast<FakeNode*>(node), marker);
+                    generateDocNode(static_cast<DocNode*>(node), marker);
             }
             if (!node->name().endsWith(".ditamap"))
                 endSubPage();
@@ -5757,8 +5757,8 @@ Node* DitaXmlGenerator::collectNodesByTypeAndSubtype(const InnerNode* parent)
     QString message;
     for (int i=0; i<children.size(); ++i) {
         Node* child = children[i];
-        if ((child->type() == Node::Fake) && (child->subType() == Node::Collision)) {
-            const FakeNode* fake = static_cast<const FakeNode*>(child);
+        if ((child->type() == Node::Document) && (child->subType() == Node::Collision)) {
+            const DocNode* fake = static_cast<const DocNode*>(child);
             Node* n = collectNodesByTypeAndSubtype(fake);
             if (n)
                 rootPageNode = n;
@@ -5780,7 +5780,7 @@ Node* DitaXmlGenerator::collectNodesByTypeAndSubtype(const InnerNode* parent)
             if (!isDuplicate(nodeTypeMaps[Node::Class],child->name(),child))
                 nodeTypeMaps[Node::Class]->insert(child->name(),child);
             break;
-        case Node::Fake:
+        case Node::Document:
             switch (child->subType()) {
             case Node::Example:
                 if (!isDuplicate(nodeSubtypeMaps[Node::Example],child->title(),child))
@@ -5987,9 +5987,9 @@ void DitaXmlGenerator::writeDitaRefs(const DitaRefList& ditarefs)
             writeStartTag(DT_topicref);
         xmlWriter().writeAttribute("navtitle",t->navtitle());
         if (t->href().isEmpty()) {
-            const FakeNode* fn = tree_->findFakeNodeByTitle(t->navtitle());
-            if (fn)
-                xmlWriter().writeAttribute("href",fileName(fn));
+            const DocNode* dn = tree_->findDocNodeByTitle(t->navtitle());
+            if (dn)
+                xmlWriter().writeAttribute("href",fileName(dn));
         }
         else
             xmlWriter().writeAttribute("href",t->href());
@@ -6286,7 +6286,7 @@ DitaXmlGenerator::writeProlog(const InnerNode* inner)
             category = "Class reference";
         else if (inner->type() == Node::Namespace)
             category = "Namespace";
-        else if (inner->type() == Node::Fake) {
+        else if (inner->type() == Node::Document) {
             if (inner->subType() == Node::QmlClass)
                 category = "QML Reference";
             else if (inner->subType() == Node::QmlBasicType)
@@ -6348,7 +6348,7 @@ DitaXmlGenerator::writeProlog(const InnerNode* inner)
         writeEndTag(); // </othermeta>
     }
     if ((tagStack.first() == DT_cxxClass && !inner->includes().isEmpty()) ||
-        (inner->type() == Node::Fake && inner->subType() == Node::HeaderFile)) {
+        (inner->type() == Node::Document && inner->subType() == Node::HeaderFile)) {
         writeStartTag(DT_othermeta);
         xmlWriter().writeAttribute("name","includeFile");
         QString text;
diff --git a/src/tools/qdoc/ditaxmlgenerator.h b/src/tools/qdoc/ditaxmlgenerator.h
index 96691a4..f8a16b4 100644
--- a/src/tools/qdoc/ditaxmlgenerator.h
+++ b/src/tools/qdoc/ditaxmlgenerator.h
@@ -315,7 +315,7 @@ protected:
                              const Node* relative,
                              CodeMarker* marker);
     virtual void generateClassLikeNode(InnerNode* inner, CodeMarker* marker);
-    virtual void generateFakeNode(FakeNode* fake, CodeMarker* marker);
+    virtual void generateDocNode(DocNode* dn, CodeMarker* marker);
     virtual QString fileExtension() const;
     virtual QString guidForNode(const Node* node);
     virtual QString linkForNode(const Node* node, const Node* relative);
@@ -353,7 +353,7 @@ protected:
                      CodeMarker* marker,
                      const QString& attribute = QString());
     void writePropertyParameter(const QString& tag, const NodeList& nlist);
-    void writeRelatedLinks(const FakeNode* fake, CodeMarker* marker);
+    void writeRelatedLinks(const DocNode* dn, CodeMarker* marker);
     void writeLink(const Node* node, const QString& tex, const QString& role);
     void writeProlog(const InnerNode* inner);
     bool writeMetadataElement(const InnerNode* inner,
diff --git a/src/tools/qdoc/doc.h b/src/tools/qdoc/doc.h
index 9d65ead..dc781f4 100644
--- a/src/tools/qdoc/doc.h
+++ b/src/tools/qdoc/doc.h
@@ -60,7 +60,6 @@ class Config;
 class DocPrivate;
 class Quoter;
 class Text;
-class FakeNode;
 class DitaRef;
 
 typedef QPair<QString, Location> ArgLocPair;
diff --git a/src/tools/qdoc/generator.cpp b/src/tools/qdoc/generator.cpp
index b158bb7..323737f 100644
--- a/src/tools/qdoc/generator.cpp
+++ b/src/tools/qdoc/generator.cpp
@@ -300,12 +300,12 @@ QString Generator::fileBase(const Node *node) const
                 (p->subType() == Node::QmlBasicType)) {
             base.prepend(outputPrefix(QLatin1String("QML")));
         }
-        if (!pp || pp->name().isEmpty() || pp->type() == Node::Fake)
+        if (!pp || pp->name().isEmpty() || pp->type() == Node::Document)
             break;
         base.prepend(QLatin1Char('-'));
         p = pp;
     }
-    if (node->type() == Node::Fake) {
+    if (node->type() == Node::Document) {
         if (node->subType() == Node::Collision) {
             const NameCollisionNode* ncn = static_cast<const NameCollisionNode*>(node);
             if (ncn->currentChild())
@@ -502,7 +502,7 @@ QString Generator::fullDocumentLocation(const Node *node, bool subdir)
         else
             return QString();
     }
-    else if (node->type() == Node::Fake) {
+    else if (node->type() == Node::Document) {
         if ((node->subType() == Node::QmlClass) ||
                 (node->subType() == Node::QmlBasicType)) {
             QString fb = fileBase(node);
@@ -598,12 +598,8 @@ QString Generator::fullDocumentLocation(const Node *node, bool subdir)
     case Node::Variable:
         anchorRef = QLatin1Char('#') + node->name() + "-var";
         break;
-    case Node::Fake:
+    case Node::Document:
     {
-        /*
-              Use fileBase(node) for fake nodes because they are represented
-              by pages whose file names are lower-case.
-            */
         parentName = fileBase(node);
         parentName.replace(QLatin1Char('/'), QLatin1Char('-')).replace(QLatin1Char('.'), QLatin1Char('-'));
         parentName += QLatin1Char('.') + currentGenerator()->fileExtension();
@@ -636,8 +632,8 @@ QString Generator::fullName(const Node *node,
                             const Node *relative,
                             CodeMarker *marker) const
 {
-    if (node->type() == Node::Fake) {
-        const FakeNode* fn = static_cast<const FakeNode *>(node);
+    if (node->type() == Node::Document) {
+        const DocNode* fn = static_cast<const DocNode *>(node);
 
         // Only print modulename::type on collision pages.
         if (!fn->qmlModuleIdentifier().isEmpty() && relative != 0 && relative->isCollisionNode())
@@ -743,9 +739,9 @@ void Generator::generateBody(const Node *node, CodeMarker *marker)
 {
     bool quiet = false;
 
-    if (node->type() == Node::Fake) {
-        const FakeNode *fake = static_cast<const FakeNode *>(node);
-        if ((fake->subType() == Node::File) || (fake->subType() == Node::Image)) {
+    if (node->type() == Node::Document) {
+        const DocNode *dn = static_cast<const DocNode *>(node);
+        if ((dn->subType() == Node::File) || (dn->subType() == Node::Image)) {
             quiet = true;
         }
     }
@@ -871,19 +867,19 @@ void Generator::generateBody(const Node *node, CodeMarker *marker)
         }
     }
 
-    if (node->type() == Node::Fake) {
-        const FakeNode *fake = static_cast<const FakeNode *>(node);
-        if (fake->subType() == Node::Example) {
-            generateExampleFiles(fake, marker);
+    if (node->type() == Node::Document) {
+        const DocNode *dn = static_cast<const DocNode *>(node);
+        if (dn->subType() == Node::Example) {
+            generateExampleFiles(dn, marker);
         }
-        else if (fake->subType() == Node::File) {
+        else if (dn->subType() == Node::File) {
             Text text;
             Quoter quoter;
-            Doc::quoteFromFile(fake->doc().location(), quoter, fake->name());
-            QString code = quoter.quoteTo(fake->location(), QString(), QString());
-            CodeMarker *codeMarker = CodeMarker::markerForFileName(fake->name());
+            Doc::quoteFromFile(dn->doc().location(), quoter, dn->name());
+            QString code = quoter.quoteTo(dn->location(), QString(), QString());
+            CodeMarker *codeMarker = CodeMarker::markerForFileName(dn->name());
             text << Atom(codeMarker->atomType(), code);
-            generateText(text, fake, codeMarker);
+            generateText(text, dn, codeMarker);
         }
     }
 }
@@ -892,15 +888,15 @@ void Generator::generateClassLikeNode(InnerNode* /* classe */, CodeMarker* /* ma
 {
 }
 
-void Generator::generateExampleFiles(const FakeNode *fake, CodeMarker *marker)
+void Generator::generateExampleFiles(const DocNode *dn, CodeMarker *marker)
 {
-    if (fake->childNodes().isEmpty())
+    if (dn->childNodes().isEmpty())
         return;
-    generateFileList(fake, marker, Node::File, QString("Files:"));
-    generateFileList(fake, marker, Node::Image, QString("Images:"));
+    generateFileList(dn, marker, Node::File, QString("Files:"));
+    generateFileList(dn, marker, Node::Image, QString("Images:"));
 }
 
-void Generator::generateFakeNode(FakeNode* /* fake */, CodeMarker* /* marker */)
+void Generator::generateDocNode(DocNode* /* dn */, CodeMarker* /* marker */)
 {
 }
 
@@ -911,7 +907,7 @@ void Generator::generateFakeNode(FakeNode* /* fake */, CodeMarker* /* marker */)
   by the example. The images are copied into a subtree of
   \c{...doc/html/images/used-in-examples/...}
  */
-void Generator::generateFileList(const FakeNode* fake,
+void Generator::generateFileList(const DocNode* dn,
                                  CodeMarker* marker,
                                  Node::SubType subtype,
                                  const QString& tag)
@@ -923,7 +919,7 @@ void Generator::generateFileList(const FakeNode* fake,
     text << Atom::ParaLeft << tag << Atom::ParaRight
          << Atom(Atom::ListLeft, openedList.styleString());
 
-    foreach (const Node* child, fake->childNodes()) {
+    foreach (const Node* child, dn->childNodes()) {
         if (child->subType() == subtype) {
             ++count;
             QString file = child->name();
@@ -931,7 +927,7 @@ void Generator::generateFileList(const FakeNode* fake,
                 if (!file.isEmpty()) {
                     QDir dirInfo;
                     QString userFriendlyFilePath;
-                    QString srcPath = Config::findFile(fake->location(),
+                    QString srcPath = Config::findFile(dn->location(),
                                                        QStringList(),
                                                        exampleDirs,
                                                        file,
@@ -941,10 +937,10 @@ void Generator::generateFileList(const FakeNode* fake,
 
                     QString imgOutDir = outDir_ + "/images/used-in-examples/" + userFriendlyFilePath;
                     if (!dirInfo.mkpath(imgOutDir))
-                        fake->location().fatal(tr("Cannot create output directory '%1'")
+                        dn->location().fatal(tr("Cannot create output directory '%1'")
                                                .arg(imgOutDir));
 
-                    QString imgOutName = Config::copyFile(fake->location(),
+                    QString imgOutName = Config::copyFile(dn->location(),
                                                           srcPath,
                                                           file,
                                                           imgOutDir);
@@ -966,7 +962,7 @@ void Generator::generateFileList(const FakeNode* fake,
     }
     text << Atom(Atom::ListRight, openedList.styleString());
     if (count > 0)
-        generateText(text, fake, marker);
+        generateText(text, dn, marker);
 }
 
 void Generator::generateInheritedBy(const ClassNode *classe, CodeMarker *marker)
@@ -1030,17 +1026,17 @@ void Generator::generateInnerNode(InnerNode* node)
     if (!node->url().isNull())
         return;
 
-    if (node->type() == Node::Fake) {
-        FakeNode* fakeNode = static_cast<FakeNode*>(node);
-        if (fakeNode->subType() == Node::ExternalPage)
+    if (node->type() == Node::Document) {
+        DocNode* docNode = static_cast<DocNode*>(node);
+        if (docNode->subType() == Node::ExternalPage)
             return;
-        if (fakeNode->subType() == Node::Image)
+        if (docNode->subType() == Node::Image)
             return;
-        if (fakeNode->subType() == Node::QmlPropertyGroup)
+        if (docNode->subType() == Node::QmlPropertyGroup)
             return;
-        if (fakeNode->subType() == Node::Page) {
+        if (docNode->subType() == Node::Page) {
             if (node->count() > 0)
-                qDebug("PAGE %s HAS CHILDREN", qPrintable(fakeNode->title()));
+                qDebug("PAGE %s HAS CHILDREN", qPrintable(docNode->title()));
         }
     }
 
@@ -1055,7 +1051,7 @@ void Generator::generateInnerNode(InnerNode* node)
           later in generateCollisionPages(). Each one is
           appended to a list for later.
          */
-        if ((node->type() == Node::Fake) && (node->subType() == Node::Collision)) {
+        if ((node->type() == Node::Document) && (node->subType() == Node::Collision)) {
             NameCollisionNode* ncn = static_cast<NameCollisionNode*>(node);
             collisionNodes.append(const_cast<NameCollisionNode*>(ncn));
         }
@@ -1064,8 +1060,8 @@ void Generator::generateInnerNode(InnerNode* node)
             if (node->type() == Node::Namespace || node->type() == Node::Class) {
                 generateClassLikeNode(node, marker);
             }
-            else if (node->type() == Node::Fake) {
-                generateFakeNode(static_cast<FakeNode*>(node), marker);
+            else if (node->type() == Node::Document) {
+                generateDocNode(static_cast<DocNode*>(node), marker);
             }
             endSubPage();
         }
@@ -2013,7 +2009,7 @@ QString Generator::typeString(const Node *node)
         return "namespace";
     case Node::Class:
         return "class";
-    case Node::Fake:
+    case Node::Document:
     {
         switch (node->subType()) {
         case Node::QmlClass:
diff --git a/src/tools/qdoc/generator.h b/src/tools/qdoc/generator.h
index e736270..3694c9c 100644
--- a/src/tools/qdoc/generator.h
+++ b/src/tools/qdoc/generator.h
@@ -69,7 +69,7 @@ typedef QMap<Node*, NodeMultiMap> ParentMaps;
 class ClassNode;
 class Config;
 class CodeMarker;
-class FakeNode;
+class DocNode;
 class FunctionNode;
 class InnerNode;
 class Location;
@@ -114,7 +114,7 @@ protected:
                              CodeMarker *marker);
     virtual void generateBody(const Node *node, CodeMarker *marker);
     virtual void generateClassLikeNode(InnerNode* inner, CodeMarker* marker);
-    virtual void generateFakeNode(FakeNode* fake, CodeMarker* marker);
+    virtual void generateDocNode(DocNode* dn, CodeMarker* marker);
     virtual void generateInheritedBy(const ClassNode *classe,
                                      CodeMarker *marker);
     virtual void generateInherits(const ClassNode *classe,
@@ -151,8 +151,8 @@ protected:
                                  CodeMarker *marker,
                                  bool generate,
                                  int& numGeneratedAtoms);
-    void generateExampleFiles(const FakeNode *fake, CodeMarker *marker);
-    void generateFileList(const FakeNode* fake,
+    void generateExampleFiles(const DocNode *dn, CodeMarker *marker);
+    void generateFileList(const DocNode* dn,
                           CodeMarker* marker,
                           Node::SubType subtype,
                           const QString& tag);
diff --git a/src/tools/qdoc/helpprojectwriter.cpp b/src/tools/qdoc/helpprojectwriter.cpp
index 5e8c6d8..e71ce59 100644
--- a/src/tools/qdoc/helpprojectwriter.cpp
+++ b/src/tools/qdoc/helpprojectwriter.cpp
@@ -115,7 +115,7 @@ void HelpProjectWriter::readSelectors(SubProject &subproject, const QStringList
     QHash<QString, Node::Type> typeHash;
     typeHash["namespace"] = Node::Namespace;
     typeHash["class"] = Node::Class;
-    typeHash["fake"] = Node::Fake;
+    typeHash["fake"] = Node::Document;
     typeHash["enum"] = Node::Enum;
     typeHash["typedef"] = Node::Typedef;
     typeHash["function"] = Node::Function;
@@ -200,8 +200,8 @@ QStringList HelpProjectWriter::keywordDetails(const Node *node) const
         // "id"
         details << node->parent()->name()+"::"+node->name();
     }
-    else if (node->type() == Node::Fake) {
-        const FakeNode *fake = static_cast<const FakeNode *>(node);
+    else if (node->type() == Node::Document) {
+        const DocNode *fake = static_cast<const DocNode *>(node);
         if (fake->subType() == Node::QmlClass) {
             details << (QmlClassNode::qmlOnly ? fake->name() : fake->fullTitle());
             details << "QML." + fake->name();
@@ -237,8 +237,8 @@ bool HelpProjectWriter::generateSection(HelpProject &project,
         return false;
 
     QString objName;
-    if (node->type() == Node::Fake) {
-        const FakeNode *fake = static_cast<const FakeNode *>(node);
+    if (node->type() == Node::Document) {
+        const DocNode *fake = static_cast<const DocNode *>(node);
         objName = fake->fullTitle();
     }
     else
@@ -255,15 +255,15 @@ bool HelpProjectWriter::generateSection(HelpProject &project,
         }
         else if (subproject.selectors.contains(node->type())) {
             // Accept only the node types in the selectors hash.
-            if (node->type() != Node::Fake)
+            if (node->type() != Node::Document)
                 project.subprojects[name].nodes[objName] = node;
             else {
                 // Accept only fake nodes with subtypes contained in the selector's
                 // mask.
-                const FakeNode *fakeNode = static_cast<const FakeNode *>(node);
-                if (subproject.selectors[node->type()].contains(fakeNode->subType()) &&
-                        fakeNode->subType() != Node::ExternalPage &&
-                        !fakeNode->fullTitle().isEmpty()) {
+                const DocNode *docNode = static_cast<const DocNode *>(node);
+                if (subproject.selectors[node->type()].contains(docNode->subType()) &&
+                        docNode->subType() != Node::ExternalPage &&
+                        !docNode->fullTitle().isEmpty()) {
 
                     project.subprojects[name].nodes[objName] = node;
                 }
@@ -360,16 +360,16 @@ bool HelpProjectWriter::generateSection(HelpProject &project,
     }
         break;
 
-        // Fake nodes (such as manual pages) contain subtypes, titles and other
+        // Document nodes (such as manual pages) contain subtypes, titles and other
         // attributes.
-    case Node::Fake: {
-        const FakeNode *fakeNode = static_cast<const FakeNode*>(node);
-        if (fakeNode->subType() != Node::ExternalPage &&
-                !fakeNode->fullTitle().isEmpty()) {
-
-            if (fakeNode->subType() != Node::File) {
-                if (fakeNode->doc().hasKeywords()) {
-                    foreach (const Atom *keyword, fakeNode->doc().keywords()) {
+    case Node::Document: {
+        const DocNode *docNode = static_cast<const DocNode*>(node);
+        if (docNode->subType() != Node::ExternalPage &&
+                !docNode->fullTitle().isEmpty()) {
+
+            if (docNode->subType() != Node::File) {
+                if (docNode->doc().hasKeywords()) {
+                    foreach (const Atom *keyword, docNode->doc().keywords()) {
                         if (!keyword->string().isEmpty()) {
                             QStringList details;
                             details << keyword->string()
@@ -378,7 +378,7 @@ bool HelpProjectWriter::generateSection(HelpProject &project,
                                        QLatin1Char('#') + Doc::canonicalTitle(keyword->string());
                             project.keywords.append(details);
                         } else
-                            fakeNode->doc().location().warning(
+                            docNode->doc().location().warning(
                                         tr("Bad keyword in %1").arg(gen_->fullDocumentLocation(node,true))
                                         );
                     }
@@ -422,7 +422,7 @@ void HelpProjectWriter::generateSections(HelpProject &project,
         foreach (const Node *node, inner->childNodes()) {
             if (node->access() == Node::Private)
                 continue;
-            if (node->type() == Node::Fake) {
+            if (node->type() == Node::Document) {
                 /*
                   Don't visit QML property group nodes,
                   but visit their children, which are all
@@ -437,7 +437,7 @@ void HelpProjectWriter::generateSections(HelpProject &project,
                     }
                 }
                 else
-                    childMap[static_cast<const FakeNode *>(node)->fullTitle()] = node;
+                    childMap[static_cast<const DocNode *>(node)->fullTitle()] = node;
             }
             else {
                 if (node->type() == Node::Function) {
@@ -514,22 +514,22 @@ void HelpProjectWriter::writeNode(HelpProject &project, QXmlStreamWriter &writer
         writer.writeEndElement(); // section
         break;
 
-    case Node::Fake: {
-        // Fake nodes (such as manual pages) contain subtypes, titles and other
+    case Node::Document: {
+        // Document nodes (such as manual pages) contain subtypes, titles and other
         // attributes.
-        const FakeNode *fakeNode = static_cast<const FakeNode*>(node);
+        const DocNode *docNode = static_cast<const DocNode*>(node);
 
         writer.writeStartElement("section");
         writer.writeAttribute("ref", href);
-        if (fakeNode->subType() == Node::QmlClass)
-            writer.writeAttribute("title", tr("%1 Type Reference").arg(fakeNode->fullTitle()));
+        if (docNode->subType() == Node::QmlClass)
+            writer.writeAttribute("title", tr("%1 Type Reference").arg(docNode->fullTitle()));
         else
-            writer.writeAttribute("title", fakeNode->fullTitle());
+            writer.writeAttribute("title", docNode->fullTitle());
 
-        if ((fakeNode->subType() == Node::HeaderFile) || (fakeNode->subType() == Node::QmlClass)) {
+        if ((docNode->subType() == Node::HeaderFile) || (docNode->subType() == Node::QmlClass)) {
             // Write subsections for all members, obsolete members and Qt 3
             // members.
-            if (!project.memberStatus[node].isEmpty() || (fakeNode->subType() == Node::QmlClass)) {
+            if (!project.memberStatus[node].isEmpty() || (docNode->subType() == Node::QmlClass)) {
                 QString membersPath = href.left(href.size()-5) + "-members.html";
                 writer.writeStartElement("section");
                 writer.writeAttribute("ref", membersPath);
@@ -567,7 +567,7 @@ void HelpProjectWriter::generateProject(HelpProject &project)
 {
     const Node *rootNode;
     if (!project.indexRoot.isEmpty())
-        rootNode = tree->findFakeNodeByTitle(project.indexRoot);
+        rootNode = tree->findDocNodeByTitle(project.indexRoot);
     else
         rootNode = tree->root();
 
@@ -610,7 +610,7 @@ void HelpProjectWriter::generateProject(HelpProject &project)
 
     writer.writeStartElement("toc");
     writer.writeStartElement("section");
-    const Node* node = tree->findFakeNodeByTitle(project.indexTitle);
+    const Node* node = tree->findDocNodeByTitle(project.indexTitle);
     if (node == 0)
         node = tree->findNode(QStringList("index.html"));
     QString indexPath;
@@ -629,7 +629,7 @@ void HelpProjectWriter::generateProject(HelpProject &project)
 
         if (subproject.type == QLatin1String("manual")) {
 
-            const FakeNode *indexPage = tree->findFakeNodeByTitle(subproject.indexTitle);
+            const DocNode *indexPage = tree->findDocNodeByTitle(subproject.indexTitle);
             if (indexPage) {
                 Text indexBody = indexPage->doc().body();
                 const Atom *atom = indexBody.firstAtom();
@@ -656,7 +656,7 @@ void HelpProjectWriter::generateProject(HelpProject &project)
                             if (sectionStack.top() > 0)
                                 writer.writeEndElement(); // section
 
-                            const FakeNode *page = tree->findFakeNodeByTitle(atom->string());
+                            const DocNode *page = tree->findDocNodeByTitle(atom->string());
                             writer.writeStartElement("section");
                             QString indexPath = gen_->fullDocumentLocation(page,true);
                             writer.writeAttribute("ref", indexPath);
@@ -683,7 +683,7 @@ void HelpProjectWriter::generateProject(HelpProject &project)
 
             if (!name.isEmpty()) {
                 writer.writeStartElement("section");
-                QString indexPath = gen_->fullDocumentLocation(tree->findFakeNodeByTitle(subproject.indexTitle),true);
+                QString indexPath = gen_->fullDocumentLocation(tree->findDocNodeByTitle(subproject.indexTitle),true);
                 writer.writeAttribute("ref", indexPath);
                 writer.writeAttribute("title", subproject.title);
                 project.files.insert(indexPath);
@@ -703,7 +703,7 @@ void HelpProjectWriter::generateProject(HelpProject &project)
                     if (!nextTitle.isEmpty() &&
                             node->links().value(Node::ContentsLink).first.isEmpty()) {
 
-                        FakeNode *nextPage = const_cast<FakeNode *>(tree->findFakeNodeByTitle(nextTitle));
+                        DocNode *nextPage = const_cast<DocNode *>(tree->findDocNodeByTitle(nextTitle));
 
                         // Write the contents node.
                         writeNode(project, writer, node);
@@ -713,7 +713,7 @@ void HelpProjectWriter::generateProject(HelpProject &project)
                             nextTitle = nextPage->links().value(Node::NextLink).first;
                             if (nextTitle.isEmpty() || visited.contains(nextTitle))
                                 break;
-                            nextPage = const_cast<FakeNode *>(tree->findFakeNodeByTitle(nextTitle));
+                            nextPage = const_cast<DocNode *>(tree->findDocNodeByTitle(nextTitle));
                             visited.insert(nextTitle);
                         }
                         break;
diff --git a/src/tools/qdoc/helpprojectwriter.h b/src/tools/qdoc/helpprojectwriter.h
index d9be950..ac81352 100644
--- a/src/tools/qdoc/helpprojectwriter.h
+++ b/src/tools/qdoc/helpprojectwriter.h
@@ -59,7 +59,7 @@ struct SubProject
 {
     QString title;
     QString indexTitle;
-    QHash<Node::Type, QSet<FakeNode::SubType> > selectors;
+    QHash<Node::Type, QSet<DocNode::SubType> > selectors;
     bool sortPages;
     QString type;
     QHash<QString, const Node *> nodes;
diff --git a/src/tools/qdoc/htmlgenerator.cpp b/src/tools/qdoc/htmlgenerator.cpp
index 5e412f4..0d3cbcd 100644
--- a/src/tools/qdoc/htmlgenerator.cpp
+++ b/src/tools/qdoc/htmlgenerator.cpp
@@ -337,7 +337,7 @@ int HtmlGenerator::generateAtom(const Atom *atom,
     case Atom::BaseName:
         break;
     case Atom::BriefLeft:
-        if (relative->type() == Node::Fake) {
+        if (relative->type() == Node::Document) {
             if (relative->subType() != Node::Example) {
                 skipAhead = skipAtoms(atom, Atom::BriefRight);
                 break;
@@ -375,7 +375,7 @@ int HtmlGenerator::generateAtom(const Atom *atom,
         }
         break;
     case Atom::BriefRight:
-        if (relative->type() != Node::Fake)
+        if (relative->type() != Node::Document)
             out() << "</p>\n";
         break;
     case Atom::C:
@@ -581,24 +581,24 @@ int HtmlGenerator::generateAtom(const Atom *atom,
             generateAnnotatedList(relative, marker, namespaceIndex);
         }
         else if (atom->string() == "related") {
-            const FakeNode *fake = static_cast<const FakeNode *>(relative);
-            if (fake && !fake->groupMembers().isEmpty()) {
+            const DocNode *dn = static_cast<const DocNode *>(relative);
+            if (dn && !dn->groupMembers().isEmpty()) {
                 NodeMap groupMembersMap;
-                foreach (const Node *node, fake->groupMembers()) {
-                    if (node->type() == Node::Fake)
+                foreach (const Node *node, dn->groupMembers()) {
+                    if (node->type() == Node::Document)
                         groupMembersMap[fullName(node, relative, marker)] = node;
                 }
-                generateAnnotatedList(fake, marker, groupMembersMap);
+                generateAnnotatedList(dn, marker, groupMembersMap);
             }
         }
         else if (atom->string() == "relatedinline") {
-            const FakeNode *fake = static_cast<const FakeNode *>(relative);
-            if (fake && !fake->groupMembers().isEmpty()) {
+            const DocNode *dn = static_cast<const DocNode *>(relative);
+            if (dn && !dn->groupMembers().isEmpty()) {
                 // Reverse the list into the original scan order.
                 // Should be sorted.  But on what?  It may not be a
                 // regular class or page definition.
                 QList<const Node *> list;
-                foreach (const Node *node, fake->groupMembers())
+                foreach (const Node *node, dn->groupMembers())
                     list.prepend(node);
                 foreach (const Node *node, list)
                     generateBody(node, marker);
@@ -627,7 +627,7 @@ int HtmlGenerator::generateAtom(const Atom *atom,
 
                 const Node* node = n.value();
                 switch (node->type()) {
-                case Node::Fake:
+                case Node::Document:
                     if (node->subType() == Node::QmlClass) {
                         sections[QmlClass].appendMember((Node*)node);
                     }
@@ -791,7 +791,7 @@ int HtmlGenerator::generateAtom(const Atom *atom,
                 out() << " alt=\"\"";
             out() << " />";
             helpProjectWriter->addExtraFile(fileName);
-            if ((relative->type() == Node::Fake) &&
+            if ((relative->type() == Node::Document) &&
                     (relative->subType() == Node::Example)) {
                 const ExampleNode* cen = static_cast<const ExampleNode*>(relative);
                 if (cen->imageFileName().isEmpty()) {
@@ -1472,15 +1472,15 @@ void HtmlGenerator::generateCollisionPages()
   Generate the HTML page for an entity that doesn't map
   to any underlying parsable C++ class or QML component.
  */
-void HtmlGenerator::generateFakeNode(FakeNode* fake, CodeMarker* marker)
+void HtmlGenerator::generateDocNode(DocNode* dn, CodeMarker* marker)
 {
     /*
-      If the fake node is a page node, and if the page type
+      If the document node is a page node, and if the page type
       is DITA map page, write the node's contents as a dita
       map and return without doing anything else.
      */
-    if (fake->subType() == Node::Page && fake->pageType() == Node::DitaMapPage) {
-        const DitaMapNode* dmn = static_cast<const DitaMapNode*>(fake);
+    if (dn->subType() == Node::Page && dn->pageType() == Node::DitaMapPage) {
+        const DitaMapNode* dmn = static_cast<const DitaMapNode*>(dn);
         writeDitaMap(dmn);
         return;
     }
@@ -1488,14 +1488,14 @@ void HtmlGenerator::generateFakeNode(FakeNode* fake, CodeMarker* marker)
     SubTitleSize subTitleSize = LargeSubTitle;
     QList<Section> sections;
     QList<Section>::const_iterator s;
-    QString fullTitle = fake->fullTitle();
+    QString fullTitle = dn->fullTitle();
     QString htmlTitle = fullTitle;
 
-    if (fake->subType() == Node::File && !fake->subTitle().isEmpty()) {
+    if (dn->subType() == Node::File && !dn->subTitle().isEmpty()) {
         subTitleSize = SmallSubTitle;
-        htmlTitle += " (" + fake->subTitle() + QLatin1Char(')');
+        htmlTitle += " (" + dn->subTitle() + QLatin1Char(')');
     }
-    else if (fake->subType() == Node::QmlBasicType) {
+    else if (dn->subType() == Node::QmlBasicType) {
         fullTitle = "QML Basic Type: " + fullTitle;
         htmlTitle = fullTitle;
 
@@ -1503,67 +1503,67 @@ void HtmlGenerator::generateFakeNode(FakeNode* fake, CodeMarker* marker)
         marker = CodeMarker::markerForLanguage(QLatin1String("QML"));
     }
 
-    generateHeader(htmlTitle, fake, marker);
+    generateHeader(htmlTitle, dn, marker);
     /*
       Generate the TOC for the new doc format.
       Don't generate a TOC for the home page.
     */
     QmlClassNode* qml_cn = 0;
-    if (fake->subType() == Node::QmlClass) {
-        qml_cn = static_cast<QmlClassNode*>(fake);
+    if (dn->subType() == Node::QmlClass) {
+        qml_cn = static_cast<QmlClassNode*>(dn);
         sections = marker->qmlSections(qml_cn,CodeMarker::Summary);
-        generateTableOfContents(fake,marker,&sections);
+        generateTableOfContents(dn,marker,&sections);
 
         // Replace the marker with a QML code marker.
         marker = CodeMarker::markerForLanguage(QLatin1String("QML"));
     }
-    else if (fake->subType() != Node::Collision && fake->name() != QString("index.html"))
-        generateTableOfContents(fake,marker,0);
+    else if (dn->subType() != Node::Collision && dn->name() != QString("index.html"))
+        generateTableOfContents(dn,marker,0);
 
     generateTitle(fullTitle,
-                  Text() << fake->subTitle(),
+                  Text() << dn->subTitle(),
                   subTitleSize,
-                  fake,
+                  dn,
                   marker);
 
-    if (fake->subType() == Node::Module) {
+    if (dn->subType() == Node::Module) {
         // Generate brief text and status for modules.
-        generateBrief(fake, marker);
-        generateStatus(fake, marker);
-        generateSince(fake, marker);
+        generateBrief(dn, marker);
+        generateStatus(dn, marker);
+        generateSince(dn, marker);
 
-        if (moduleNamespaceMap.contains(fake->name())) {
+        if (moduleNamespaceMap.contains(dn->name())) {
             out() << "<a name=\"" << registerRef("namespaces") << "\"></a>" << divNavTop << '\n';
             out() << "<h2>Namespaces</h2>\n";
-            generateAnnotatedList(fake, marker, moduleNamespaceMap[fake->name()]);
+            generateAnnotatedList(dn, marker, moduleNamespaceMap[dn->name()]);
         }
-        if (moduleClassMap.contains(fake->name())) {
+        if (moduleClassMap.contains(dn->name())) {
             out() << "<a name=\"" << registerRef("classes") << "\"></a>" << divNavTop << '\n';
             out() << "<h2>Classes</h2>\n";
-            generateAnnotatedList(fake, marker, moduleClassMap[fake->name()]);
+            generateAnnotatedList(dn, marker, moduleClassMap[dn->name()]);
         }
     }
-    else if (fake->subType() == Node::HeaderFile) {
+    else if (dn->subType() == Node::HeaderFile) {
         // Generate brief text and status for modules.
-        generateBrief(fake, marker);
-        generateStatus(fake, marker);
-        generateSince(fake, marker);
+        generateBrief(dn, marker);
+        generateStatus(dn, marker);
+        generateSince(dn, marker);
 
         out() << "<ul>\n";
 
-        QString membersLink = generateListOfAllMemberFile(fake, marker);
+        QString membersLink = generateListOfAllMemberFile(dn, marker);
         if (!membersLink.isEmpty())
             out() << "<li><a href=\"" << membersLink << "\">"
                   << "List of all members, including inherited members</a></li>\n";
 
-        QString obsoleteLink = generateLowStatusMemberFile(fake,
+        QString obsoleteLink = generateLowStatusMemberFile(dn,
                                                            marker,
                                                            CodeMarker::Obsolete);
         if (!obsoleteLink.isEmpty())
             out() << "<li><a href=\"" << obsoleteLink << "\">"
                   << "Obsolete members</a></li>\n";
 
-        QString compatLink = generateLowStatusMemberFile(fake,
+        QString compatLink = generateLowStatusMemberFile(dn,
                                                          marker,
                                                          CodeMarker::Compat);
         if (!compatLink.isEmpty())
@@ -1572,8 +1572,8 @@ void HtmlGenerator::generateFakeNode(FakeNode* fake, CodeMarker* marker)
 
         out() << "</ul>\n";
     }
-    else if (fake->subType() == Node::QmlClass) {
-        const_cast<FakeNode*>(fake)->setCurrentChild();
+    else if (dn->subType() == Node::QmlClass) {
+        const_cast<DocNode*>(dn)->setCurrentChild();
         ClassNode* cn = qml_cn->classNode();
         generateBrief(qml_cn, marker);
         generateQmlInherits(qml_cn, marker);
@@ -1594,18 +1594,18 @@ void HtmlGenerator::generateFakeNode(FakeNode* fake, CodeMarker* marker)
             out() << "<a name=\"" << registerRef((*s).name.toLower())
                   << "\"></a>" << divNavTop << '\n';
             out() << "<h2>" << protectEnc((*s).name) << "</h2>\n";
-            generateQmlSummary(*s,fake,marker);
+            generateQmlSummary(*s,dn,marker);
             ++s;
         }
 
-        generateExtractionMark(fake, DetailedDescriptionMark);
+        generateExtractionMark(dn, DetailedDescriptionMark);
         out() << "<a name=\"" << registerRef("details") << "\"></a>" << divNavTop << '\n';
         out() << "<h2>" << "Detailed Description" << "</h2>\n";
-        generateBody(fake, marker);
+        generateBody(dn, marker);
         if (cn)
-            generateQmlText(cn->doc().body(), cn, marker, fake->name());
-        generateAlsoList(fake, marker);
-        generateExtractionMark(fake, EndMark);
+            generateQmlText(cn->doc().body(), cn, marker, dn->name());
+        generateAlsoList(dn, marker);
+        generateExtractionMark(dn, EndMark);
         //out() << "<hr />\n";
 
         sections = marker->qmlSections(qml_cn,CodeMarker::Detailed);
@@ -1614,61 +1614,61 @@ void HtmlGenerator::generateFakeNode(FakeNode* fake, CodeMarker* marker)
             out() << "<h2>" << protectEnc((*s).name) << "</h2>\n";
             NodeList::ConstIterator m = (*s).members.constBegin();
             while (m != (*s).members.constEnd()) {
-                generateDetailedQmlMember(*m, fake, marker);
+                generateDetailedQmlMember(*m, dn, marker);
                 out() << "<br/>\n";
                 ++m;
             }
             ++s;
         }
-        generateFooter(fake);
-        const_cast<FakeNode*>(fake)->clearCurrentChild();
+        generateFooter(dn);
+        const_cast<DocNode*>(dn)->clearCurrentChild();
         return;
     }
 
-    sections = marker->sections(fake, CodeMarker::Summary, CodeMarker::Okay);
+    sections = marker->sections(dn, CodeMarker::Summary, CodeMarker::Okay);
     s = sections.constBegin();
     while (s != sections.constEnd()) {
         out() << "<a name=\"" << registerRef((*s).name) << "\"></a>" << divNavTop << '\n';
         out() << "<h2>" << protectEnc((*s).name) << "</h2>\n";
-        generateSectionList(*s, fake, marker, CodeMarker::Summary);
+        generateSectionList(*s, dn, marker, CodeMarker::Summary);
         ++s;
     }
 
-    Text brief = fake->doc().briefText();
-    if (fake->subType() == Node::Module && !brief.isEmpty()) {
-        generateExtractionMark(fake, DetailedDescriptionMark);
+    Text brief = dn->doc().briefText();
+    if (dn->subType() == Node::Module && !brief.isEmpty()) {
+        generateExtractionMark(dn, DetailedDescriptionMark);
         out() << "<a name=\"" << registerRef("details") << "\"></a>" << divNavTop << '\n';
         out() << "<div class=\"descr\">\n"; // QTBUG-9504
         out() << "<h2>" << "Detailed Description" << "</h2>\n";
     }
     else {
-        generateExtractionMark(fake, DetailedDescriptionMark);
+        generateExtractionMark(dn, DetailedDescriptionMark);
         out() << "<div class=\"descr\"> <a name=\"" << registerRef("details") << "\"></a>\n"; // QTBUG-9504
     }
 
-    generateBody(fake, marker);
+    generateBody(dn, marker);
     out() << "</div>\n"; // QTBUG-9504
-    generateAlsoList(fake, marker);
-    generateExtractionMark(fake, EndMark);
+    generateAlsoList(dn, marker);
+    generateExtractionMark(dn, EndMark);
 
-    if ((fake->subType() == Node::Group) && !fake->groupMembers().isEmpty()) {
+    if ((dn->subType() == Node::Group) && !dn->groupMembers().isEmpty()) {
         NodeMap groupMembersMap;
-        foreach (const Node *node, fake->groupMembers()) {
+        foreach (const Node *node, dn->groupMembers()) {
             if (node->type() == Node::Class || node->type() == Node::Namespace)
                 groupMembersMap[node->name()] = node;
         }
-        generateAnnotatedList(fake, marker, groupMembersMap);
+        generateAnnotatedList(dn, marker, groupMembersMap);
     }
-    else if ((fake->subType() == Node::QmlModule) && !fake->qmlModuleMembers().isEmpty()) {
+    else if ((dn->subType() == Node::QmlModule) && !dn->qmlModuleMembers().isEmpty()) {
         NodeMap qmlModuleMembersMap;
-        foreach (const Node* node, fake->qmlModuleMembers()) {
-            if (node->type() == Node::Fake && node->subType() == Node::QmlClass)
+        foreach (const Node* node, dn->qmlModuleMembers()) {
+            if (node->type() == Node::Document && node->subType() == Node::QmlClass)
                 qmlModuleMembersMap[node->name()] = node;
         }
-        generateAnnotatedList(fake, marker, qmlModuleMembersMap);
+        generateAnnotatedList(dn, marker, qmlModuleMembersMap);
     }
 
-    sections = marker->sections(fake, CodeMarker::Detailed, CodeMarker::Okay);
+    sections = marker->sections(dn, CodeMarker::Detailed, CodeMarker::Okay);
     s = sections.constBegin();
     while (s != sections.constEnd()) {
         //out() << "<hr />\n";
@@ -1676,12 +1676,12 @@ void HtmlGenerator::generateFakeNode(FakeNode* fake, CodeMarker* marker)
 
         NodeList::ConstIterator m = (*s).members.constBegin();
         while (m != (*s).members.constEnd()) {
-            generateDetailedMember(*m, fake, marker);
+            generateDetailedMember(*m, dn, marker);
             ++m;
         }
         ++s;
     }
-    generateFooter(fake);
+    generateFooter(dn);
 }
 
 /*!
@@ -1721,8 +1721,8 @@ void HtmlGenerator::generateBreadCrumbs(const QString &title,
                         << Atom(Atom::String, protectEnc(cn->name()))
                         << Atom(Atom::ListItemRight);
     }
-    else if (node->type() == Node::Fake) {
-        const FakeNode* fn = static_cast<const FakeNode*>(node);
+    else if (node->type() == Node::Document) {
+        const DocNode* fn = static_cast<const DocNode*>(node);
         if (node->subType() == Node::Module) {
             breadcrumbs << Atom(Atom::ListItemLeft)
                         << Atom(Atom::Link, QLatin1String("All Modules"))
@@ -2299,7 +2299,7 @@ void HtmlGenerator::generateAnnotatedList(const Node *relative,
         generateFullName(node, relative, marker);
         out() << "</p></td>";
 
-        if (!(node->type() == Node::Fake)) {
+        if (!(node->type() == Node::Document)) {
             Text brief = node->doc().trimmedBriefText(name);
             if (!brief.isEmpty()) {
                 out() << "<td class=\"tblDescr\"><p>";
@@ -2605,38 +2605,38 @@ void HtmlGenerator::generateQmlItem(const Node *node,
 
 void HtmlGenerator::generateOverviewList(const Node *relative, CodeMarker * /* marker */)
 {
-    QMap<const FakeNode *, QMap<QString, FakeNode *> > fakeNodeMap;
-    QMap<QString, const FakeNode *> groupTitlesMap;
-    QMap<QString, FakeNode *> uncategorizedNodeMap;
+    QMap<const DocNode *, QMap<QString, DocNode *> > docNodeMap;
+    QMap<QString, const DocNode *> groupTitlesMap;
+    QMap<QString, DocNode *> uncategorizedNodeMap;
     QRegExp singleDigit("\\b([0-9])\\b");
 
     const NodeList children = tree_->root()->childNodes();
     foreach (Node *child, children) {
-        if (child->type() == Node::Fake && child != relative) {
-            FakeNode *fakeNode = static_cast<FakeNode *>(child);
+        if (child->type() == Node::Document && child != relative) {
+            DocNode *docNode = static_cast<DocNode *>(child);
 
             // Check whether the page is part of a group or is the group
             // definition page.
             QString group;
             bool isGroupPage = false;
-            if (fakeNode->doc().metaCommandsUsed().contains("group")) {
-                group = fakeNode->doc().metaCommandArgs("group")[0].first;
+            if (docNode->doc().metaCommandsUsed().contains("group")) {
+                group = docNode->doc().metaCommandArgs("group")[0].first;
                 isGroupPage = true;
             }
 
             // there are too many examples; they would clutter the list
-            if (fakeNode->subType() == Node::Example)
+            if (docNode->subType() == Node::Example)
                 continue;
 
             // not interested either in individual (Qt Designer etc.) manual chapters
-            if (fakeNode->links().contains(Node::ContentsLink))
+            if (docNode->links().contains(Node::ContentsLink))
                 continue;
 
             // Discard external nodes.
-            if (fakeNode->subType() == Node::ExternalPage)
+            if (docNode->subType() == Node::ExternalPage)
                 continue;
 
-            QString sortKey = fakeNode->fullTitle().toLower();
+            QString sortKey = docNode->fullTitle().toLower();
             if (sortKey.startsWith("the "))
                 sortKey.remove(0, 4);
             sortKey.replace(singleDigit, "0\\1");
@@ -2645,26 +2645,26 @@ void HtmlGenerator::generateOverviewList(const Node *relative, CodeMarker * /* m
                 if (isGroupPage) {
                     // If we encounter a group definition page, we add all
                     // the pages in that group to the list for that group.
-                    foreach (Node *member, fakeNode->groupMembers()) {
-                        if (member->type() != Node::Fake)
+                    foreach (Node *member, docNode->groupMembers()) {
+                        if (member->type() != Node::Document)
                             continue;
-                        FakeNode *page = static_cast<FakeNode *>(member);
+                        DocNode *page = static_cast<DocNode *>(member);
                         if (page) {
                             QString sortKey = page->fullTitle().toLower();
                             if (sortKey.startsWith("the "))
                                 sortKey.remove(0, 4);
                             sortKey.replace(singleDigit, "0\\1");
-                            fakeNodeMap[const_cast<const FakeNode *>(fakeNode)].insert(sortKey, page);
-                            groupTitlesMap[fakeNode->fullTitle()] = const_cast<const FakeNode *>(fakeNode);
+                            docNodeMap[const_cast<const DocNode *>(docNode)].insert(sortKey, page);
+                            groupTitlesMap[docNode->fullTitle()] = const_cast<const DocNode *>(docNode);
                         }
                     }
                 }
                 else if (!isGroupPage) {
                     // If we encounter a page that belongs to a group then
                     // we add that page to the list for that group.
-                    const FakeNode* gn = tree_->findGroupNode(QStringList(group));
+                    const DocNode* gn = tree_->findGroupNode(QStringList(group));
                     if (gn)
-                        fakeNodeMap[gn].insert(sortKey, fakeNode);
+                        docNodeMap[gn].insert(sortKey, docNode);
                 }
             }
         }
@@ -2676,23 +2676,23 @@ void HtmlGenerator::generateOverviewList(const Node *relative, CodeMarker * /* m
     // incomplete. However, if the group definition page was listed, all the
     // pages in that group are listed for completeness.
 
-    if (!fakeNodeMap.isEmpty()) {
+    if (!docNodeMap.isEmpty()) {
         foreach (const QString &groupTitle, groupTitlesMap.keys()) {
-            const FakeNode *groupNode = groupTitlesMap[groupTitle];
+            const DocNode *groupNode = groupTitlesMap[groupTitle];
             out() << QString("<h3><a href=\"%1\">%2</a></h3>\n").arg(
                          linkForNode(groupNode, relative)).arg(
                          protectEnc(groupNode->fullTitle()));
 
-            if (fakeNodeMap[groupNode].count() == 0)
+            if (docNodeMap[groupNode].count() == 0)
                 continue;
 
             out() << "<ul>\n";
 
-            foreach (const FakeNode *fakeNode, fakeNodeMap[groupNode]) {
-                QString title = fakeNode->fullTitle();
+            foreach (const DocNode *docNode, docNodeMap[groupNode]) {
+                QString title = docNode->fullTitle();
                 if (title.startsWith("The "))
                     title.remove(0, 4);
-                out() << "<li><a href=\"" << linkForNode(fakeNode, relative) << "\">"
+                out() << "<li><a href=\"" << linkForNode(docNode, relative) << "\">"
                       << protectEnc(title) << "</a></li>\n";
             }
             out() << "</ul>\n";
@@ -2702,11 +2702,11 @@ void HtmlGenerator::generateOverviewList(const Node *relative, CodeMarker * /* m
     if (!uncategorizedNodeMap.isEmpty()) {
         out() << QString("<h3>Miscellaneous</h3>\n");
         out() << "<ul>\n";
-        foreach (const FakeNode *fakeNode, uncategorizedNodeMap) {
-            QString title = fakeNode->fullTitle();
+        foreach (const DocNode *docNode, uncategorizedNodeMap) {
+            QString title = docNode->fullTitle();
             if (title.startsWith("The "))
                 title.remove(0, 4);
-            out() << "<li><a href=\"" << linkForNode(fakeNode, relative) << "\">"
+            out() << "<li><a href=\"" << linkForNode(docNode, relative) << "\">"
                   << protectEnc(title) << "</a></li>\n";
         }
         out() << "</ul>\n";
@@ -3263,10 +3263,10 @@ QString HtmlGenerator::fileBase(const Node *node) const
 
 QString HtmlGenerator::fileName(const Node *node)
 {
-    if (node->type() == Node::Fake) {
-        if (static_cast<const FakeNode *>(node)->subType() == Node::ExternalPage)
+    if (node->type() == Node::Document) {
+        if (static_cast<const DocNode *>(node)->subType() == Node::ExternalPage)
             return node->name();
-        if (static_cast<const FakeNode *>(node)->subType() == Node::Image)
+        if (static_cast<const DocNode *>(node)->subType() == Node::Image)
             return node->name();
     }
     return Generator::fileName(node);
@@ -3306,7 +3306,7 @@ QString HtmlGenerator::refForNode(const Node *node)
                 ref += QLatin1Char('-') + QString::number(func->overloadNumber());
         }
         break;
-    case Node::Fake:
+    case Node::Document:
         if (node->subType() != Node::QmlPropertyGroup)
             break;
     case Node::QmlProperty:
@@ -3544,7 +3544,7 @@ void HtmlGenerator::findAllClasses(const InnerNode *node)
                 if (!serviceName.isEmpty())
                     serviceClasses.insert(serviceName, *c);
             }
-            else if ((*c)->type() == Node::Fake &&
+            else if ((*c)->type() == Node::Document &&
                      (*c)->subType() == Node::QmlClass &&
                      !(*c)->doc().isEmpty()) {
                 QString qmlClassName = (*c)->name();
@@ -3635,7 +3635,7 @@ int HtmlGenerator::hOffset(const Node *node)
     case Node::Namespace:
     case Node::Class:
         return 2;
-    case Node::Fake:
+    case Node::Document:
         return 1;
     case Node::Enum:
     case Node::Typedef:
@@ -3667,12 +3667,12 @@ const Node *HtmlGenerator::findNodeForTarget(const QString &target,
         node = relative;
     }
     else if (target.endsWith(".html")) {
-        node = tree_->root()->findChildNodeByNameAndType(target, Node::Fake);
+        node = tree_->root()->findChildNodeByNameAndType(target, Node::Document);
     }
     else if (marker) {
         node = marker->resolveTarget(target, tree_, relative);
         if (!node) {
-            node = tree_->findFakeNodeByTitle(target, relative);
+            node = tree_->findDocNodeByTitle(target, relative);
         }
         if (!node && atom) {
             node = tree_->findUnambiguousTarget(target, *const_cast<Atom**>(&atom), relative);
@@ -3689,9 +3689,9 @@ const QPair<QString,QString> HtmlGenerator::anchorForNode(const Node *node)
     QPair<QString,QString> anchorPair;
 
     anchorPair.first = Generator::fileName(node);
-    if (node->type() == Node::Fake) {
-        const FakeNode *fakeNode = static_cast<const FakeNode*>(node);
-        anchorPair.second = fakeNode->title();
+    if (node->type() == Node::Document) {
+        const DocNode *docNode = static_cast<const DocNode*>(node);
+        anchorPair.second = docNode->title();
     }
 
     return anchorPair;
@@ -3736,12 +3736,12 @@ QString HtmlGenerator::getLink(const Atom *atom,
               node, which must be a direct child of the tree
               root.
             */
-            *node = tree_->root()->findChildNodeByNameAndType(first, Node::Fake);
+            *node = tree_->root()->findChildNodeByNameAndType(first, Node::Document);
         }
         else {
             *node = marker->resolveTarget(first, tree_, relative);
             if (!*node) {
-                *node = tree_->findFakeNodeByTitle(first, relative);
+                *node = tree_->findDocNodeByTitle(first, relative);
             }
             if (!*node) {
                 *node = tree_->findUnambiguousTarget(first, targetAtom, relative);
@@ -3765,9 +3765,9 @@ QString HtmlGenerator::getLink(const Atom *atom,
                     if (relative->parent() != *node) {
                         if (relative->status() != Node::Obsolete) {
                             bool porting = false;
-                            if (relative->type() == Node::Fake) {
-                                const FakeNode* fake = static_cast<const FakeNode*>(relative);
-                                if (fake->title().startsWith("Porting"))
+                            if (relative->type() == Node::Document) {
+                                const DocNode* dn = static_cast<const DocNode*>(relative);
+                                if (dn->title().startsWith("Porting"))
                                     porting = true;
                             }
                             QString name = marker->plainFullName(relative);
@@ -3865,18 +3865,18 @@ void HtmlGenerator::generateStatus(const Node *node, CodeMarker *marker)
                  << "We strongly advise against "
                  << "using it in new code. See ";
 
-            const FakeNode *fakeNode = tree_->findFakeNodeByTitle("Porting To Qt 4");
+            const DocNode *docNode = tree_->findDocNodeByTitle("Porting To Qt 4");
             Atom *targetAtom = 0;
-            if (fakeNode && node->type() == Node::Class) {
+            if (docNode && node->type() == Node::Class) {
                 QString oldName(node->name());
                 oldName.remove(QLatin1Char('3'));
                 targetAtom = tree_->findTarget(oldName,
-                                                fakeNode);
+                                                docNode);
             }
 
             if (targetAtom) {
-                text << Atom(Atom::Link, linkForNode(fakeNode, node) + QLatin1Char('#') +
-                             refForAtom(targetAtom, fakeNode));
+                text << Atom(Atom::Link, linkForNode(docNode, node) + QLatin1Char('#') +
+                             refForAtom(targetAtom, docNode));
             }
             else
                 text << Atom(Atom::Link, "Porting to Qt 4");
@@ -4139,7 +4139,7 @@ void HtmlGenerator::generateQmlInherits(const QmlClassNode* qcn, CodeMarker* mar
 {
     if (!qcn)
         return;
-    const FakeNode* base = qcn->qmlBase();
+    const DocNode* base = qcn->qmlBase();
     if (base) {
         Text text;
         text << Atom::ParaLeft << "Inherits ";
@@ -4475,7 +4475,7 @@ void HtmlGenerator::reportOrphans(const InnerNode* parent)
             break;
         case Node::Class:
             break;
-        case Node::Fake:
+        case Node::Document:
             switch (child->subType()) {
             case Node::Example:
                 break;
@@ -4638,7 +4638,7 @@ void HtmlGenerator::writeDitaRefs(const DitaRefList& ditarefs)
             xmlWriter().writeStartElement("topicref");
         xmlWriter().writeAttribute("navtitle",t->navtitle());
         if (t->href().isEmpty()) {
-            const FakeNode* fn = tree_->findFakeNodeByTitle(t->navtitle());
+            const DocNode* fn = tree_->findDocNodeByTitle(t->navtitle());
             if (fn)
                 xmlWriter().writeAttribute("href",fileName(fn));
         }
diff --git a/src/tools/qdoc/htmlgenerator.h b/src/tools/qdoc/htmlgenerator.h
index a4e6c2f..02c9137 100644
--- a/src/tools/qdoc/htmlgenerator.h
+++ b/src/tools/qdoc/htmlgenerator.h
@@ -101,7 +101,7 @@ protected:
                              const Node *relative,
                              CodeMarker *marker);
     virtual void generateClassLikeNode(InnerNode* inner, CodeMarker* marker);
-    virtual void generateFakeNode(FakeNode* fake, CodeMarker* marker);
+    virtual void generateDocNode(DocNode* dn, CodeMarker* marker);
     virtual QString fileExtension() const;
     virtual QString refForNode(const Node *node);
     virtual QString linkForNode(const Node *node, const Node *relative);
diff --git a/src/tools/qdoc/node.cpp b/src/tools/qdoc/node.cpp
index c222cb7..1b2ac78 100644
--- a/src/tools/qdoc/node.cpp
+++ b/src/tools/qdoc/node.cpp
@@ -238,8 +238,8 @@ QString Node::nodeTypeString(unsigned t)
         return "namespace";
     case Class:
         return "class";
-    case Fake:
-        return "fake";
+    case Document:
+        return "document";
     case Enum:
         return "enum";
     case Typedef:
@@ -267,7 +267,7 @@ QString Node::nodeTypeString(unsigned t)
 /*!
   Returns this node's subtype as a string for use as an
   attribute value in XML or HTML. This is only useful
-  in the case where the node type is Fake.
+  in the case where the node type is Document.
  */
 QString Node::nodeSubtypeString() const
 {
@@ -277,7 +277,7 @@ QString Node::nodeSubtypeString() const
 /*!
   Returns the node subtype \a t as a string for use as an
   attribute value in XML or HTML. This is only useful
-  in the case where the node type is Fake.
+  in the case where the node type is Document.
  */
 QString Node::nodeSubtypeString(unsigned t)
 {
@@ -605,7 +605,7 @@ Node *InnerNode::findChildNodeByName(const QString& name)
     Node *node = childMap.value(name);
     if (node && node->subType() != QmlPropertyGroup)
         return node;
-    if ((type() == Fake) && (subType() == QmlClass)) {
+    if ((type() == Document) && (subType() == QmlClass)) {
         for (int i=0; i<children.size(); ++i) {
             Node* n = children.at(i);
             if (n->subType() == QmlPropertyGroup) {
@@ -629,7 +629,7 @@ void InnerNode::findNodes(const QString& name, QList<Node*>& n)
       found, append it to the output list and return immediately.
      */
     if (nodes.isEmpty()) {
-        if ((type() == Fake) && (subType() == QmlClass)) {
+        if ((type() == Document) && (subType() == QmlClass)) {
             for (int i=0; i<children.size(); ++i) {
                 node = children.at(i);
                 if (node->subType() == QmlPropertyGroup) {
@@ -694,7 +694,7 @@ Node* InnerNode::findChildNodeByName(const QString& name, bool qml)
                 return node;
         }
     }
-    if (qml && (type() == Fake) && (subType() == QmlClass)) {
+    if (qml && (type() == Document) && (subType() == QmlClass)) {
         for (int i=0; i<children.size(); ++i) {
             Node* node = children.at(i);
             if (node->subType() == QmlPropertyGroup) {
@@ -1423,19 +1423,19 @@ QmlClassNode* ClassNode::findQmlBaseNode()
     return result;
 }
 
-QMap<QString, FakeNode*> FakeNode::qmlModuleMap_;
+QMap<QString, DocNode*> DocNode::qmlModuleMap_;
 
 /*!
-  \class FakeNode
+  \class DocNode
  */
 
 /*!
-  The type of a FakeNode is Fake, and it has a \a subtype,
-  which specifies the type of FakeNode. The page type for
+  The type of a DocNode is Document, and it has a \a subtype,
+  which specifies the type of DocNode. The page type for
   the page index is set here.
  */
-FakeNode::FakeNode(InnerNode* parent, const QString& name, SubType subtype, Node::PageType ptype)
-    : InnerNode(Fake, parent, name), nodeSubtype_(subtype)
+DocNode::DocNode(InnerNode* parent, const QString& name, SubType subtype, Node::PageType ptype)
+    : InnerNode(Document, parent, name), nodeSubtype_(subtype)
 {
     switch (subtype) {
     case Page:
@@ -1467,19 +1467,19 @@ FakeNode::FakeNode(InnerNode* parent, const QString& name, SubType subtype, Node
 }
 
 /*!
-  Returns the fake node's title. This is used for the page title.
+  Returns the document node's title. This is used for the page title.
 */
-QString FakeNode::title() const
+QString DocNode::title() const
 {
     return title_;
 }
 
 /*!
-  Returns the fake node's full title, which is usually
+  Returns the document node's full title, which is usually
   just title(), but for some SubType values is different
   from title()
  */
-QString FakeNode::fullTitle() const
+QString DocNode::fullTitle() const
 {
     if (nodeSubtype_ == File) {
         if (title().isEmpty())
@@ -1510,7 +1510,7 @@ QString FakeNode::fullTitle() const
 /*!
   Returns the subtitle.
  */
-QString FakeNode::subTitle() const
+QString DocNode::subTitle() const
 {
     if (!subtitle_.isEmpty())
         return subtitle_;
@@ -1531,20 +1531,20 @@ QString FakeNode::subTitle() const
   If the QML module map does not contain the module identifier
   \a qmid, insert the QML module node \a fn mapped to \a qmid.
  */
-void FakeNode::insertQmlModuleNode(const QString& qmid, FakeNode* fn)
+void DocNode::insertQmlModuleNode(const QString& qmid, DocNode* fn)
 {
     if (!qmlModuleMap_.contains(qmid))
         qmlModuleMap_.insert(qmid,fn);
 }
 
 /*!
-  Returns a pointer to the QML module node (FakeNode) that is
+  Returns a pointer to the QML module node (DocNode) that is
   mapped to the QML module identifier constructed from \a arg.
   If that QML module node does not yet exist, it is constructed
   and inserted into the QML module map mapped to the QML module
   identifier constructed from \a arg.
  */
-FakeNode* FakeNode::lookupQmlModuleNode(Tree* tree, const ArgLocPair& arg)
+DocNode* DocNode::lookupQmlModuleNode(Tree* tree, const ArgLocPair& arg)
 {
     QStringList dotSplit;
     QStringList blankSplit = arg.first.split(QLatin1Char(' '));
@@ -1553,11 +1553,11 @@ FakeNode* FakeNode::lookupQmlModuleNode(Tree* tree, const ArgLocPair& arg)
         dotSplit = blankSplit[1].split(QLatin1Char('.'));
         qmid += dotSplit[0];
     }
-    FakeNode* fn = 0;
+    DocNode* fn = 0;
     if (qmlModuleMap_.contains(qmid))
         fn = qmlModuleMap_.value(qmid);
     if (!fn) {
-        fn = new FakeNode(tree->root(), arg.first, Node::QmlModule, Node::OverviewPage);
+        fn = new DocNode(tree->root(), arg.first, Node::QmlModule, Node::OverviewPage);
         fn->setQmlModule(arg);
         insertQmlModuleNode(qmid,fn);
     }
@@ -1568,10 +1568,10 @@ FakeNode* FakeNode::lookupQmlModuleNode(Tree* tree, const ArgLocPair& arg)
   Returns true if this QML type or property group contains a
   property named \a name.
  */
-bool FakeNode::hasProperty(const QString& name) const
+bool DocNode::hasProperty(const QString& name) const
 {
     foreach (Node* child, childNodes()) {
-        if (child->type() == Node::Fake && child->subType() == Node::QmlPropertyGroup) {
+        if (child->type() == Node::Document && child->subType() == Node::QmlPropertyGroup) {
             if (child->hasProperty(name))
                 return true;
         }
@@ -1584,11 +1584,11 @@ bool FakeNode::hasProperty(const QString& name) const
 }
 
 /*!
-  The constructor calls the FakeNode constructor with
+  The constructor calls the DocNode constructor with
   \a parent, \a name, and Node::Example.
  */
 ExampleNode::ExampleNode(InnerNode* parent, const QString& name)
-    : FakeNode(parent, name, Node::Example, Node::ExamplePage)
+    : DocNode(parent, name, Node::Example, Node::ExamplePage)
 {
     // nothing
 }
@@ -2004,12 +2004,12 @@ QMultiMap<QString,Node*> QmlClassNode::inheritedBy;
 QMap<QString, QmlClassNode*> QmlClassNode::qmlModuleMemberMap_;
 
 /*!
-  Constructs a Qml class node (i.e. a Fake node with the
+  Constructs a Qml class node (i.e. a Document node with the
   subtype QmlClass. The new node has the given \a parent
   and \a name.
  */
 QmlClassNode::QmlClassNode(InnerNode *parent, const QString& name)
-    : FakeNode(parent, name, QmlClass, Node::ApiPage),
+    : DocNode(parent, name, QmlClass, Node::ApiPage),
       abstract_(false),
       cnodeRequired_(false),
       cnode_(0),
@@ -2178,7 +2178,7 @@ void QmlClassNode::resolveInheritance(Tree* tree)
         QStringList strList = linkPair.first.split("::");
         Node* n = tree->findQmlClassNode(strList);
         if (n) {
-            base_ = static_cast<FakeNode*>(n);
+            base_ = static_cast<DocNode*>(n);
             if (base_ && base_->subType() == Node::QmlClass) {
                 return;
             }
@@ -2190,7 +2190,7 @@ void QmlClassNode::resolveInheritance(Tree* tree)
                 QString qmid = importList_.at(i).first + importList_.at(i).second;
                 for (int j=0; j<children.size(); ++j) {
                     if (qmid == children.at(j)->qmlModuleIdentifier()) {
-                        base_ = static_cast<FakeNode*>(children.at(j));
+                        base_ = static_cast<DocNode*>(children.at(j));
                         return;
                     }
                 }
@@ -2215,13 +2215,13 @@ void QmlClassNode::resolveInheritance(Tree* tree)
 }
 
 /*!
-  Constructs a Qml basic type node (i.e. a Fake node with
+  Constructs a Qml basic type node (i.e. a Document node with
   the subtype QmlBasicType. The new node has the given
   \a parent and \a name.
  */
 QmlBasicTypeNode::QmlBasicTypeNode(InnerNode *parent,
                                    const QString& name)
-    : FakeNode(parent, name, QmlBasicType, Node::ApiPage)
+    : DocNode(parent, name, QmlBasicType, Node::ApiPage)
 {
     setTitle(name);
 }
@@ -2231,7 +2231,7 @@ QmlBasicTypeNode::QmlBasicTypeNode(InnerNode *parent,
   always a QmlClassNode.
  */
 QmlPropGroupNode::QmlPropGroupNode(QmlClassNode* parent, const QString& name)
-    : FakeNode(parent, name, QmlPropertyGroup, Node::ApiPage)
+    : DocNode(parent, name, QmlPropertyGroup, Node::ApiPage)
 {
     idNumber_ = -1;
 }
@@ -2437,7 +2437,7 @@ bool QmlPropertyNode::hasProperty(const QString& n) const
   this node's parent.
  */
 NameCollisionNode::NameCollisionNode(InnerNode* child)
-    : FakeNode(child->parent(), child->name(), Collision, Node::NoPageType)
+    : DocNode(child->parent(), child->name(), Collision, Node::NoPageType)
 {
     setTitle("Name Collision: " + child->name());
     addCollision(child);
@@ -2524,7 +2524,7 @@ const Node* NameCollisionNode::applyModuleIdentifier(const Node* origin) const
         const NodeList& cn = childNodes();
         NodeList::ConstIterator i = cn.constBegin();
         while (i != cn.constEnd()) {
-            if ((*i)->type() == Node::Fake && (*i)->subType() == Node::QmlClass) {
+            if ((*i)->type() == Node::Document && (*i)->subType() == Node::QmlClass) {
                 if (origin->qmlModuleIdentifier() == (*i)->qmlModuleIdentifier())
                     return (*i);
             }
@@ -2544,10 +2544,10 @@ QString Node::fullDocumentName() const
 
     do {
         if (!n->name().isEmpty() &&
-                ((n->type() != Node::Fake) || (n->subType() != Node::QmlPropertyGroup)))
+                ((n->type() != Node::Document) || (n->subType() != Node::QmlPropertyGroup)))
             pieces.insert(0, n->name());
 
-        if ((n->type() == Node::Fake) && (n->subType() != Node::QmlPropertyGroup)) {
+        if ((n->type() == Node::Document) && (n->subType() != Node::QmlPropertyGroup)) {
             if ((n->subType() == Node::QmlClass) && !n->qmlModuleName().isEmpty())
                 pieces.insert(0, n->qmlModuleIdentifier());
             break;
@@ -2562,7 +2562,7 @@ QString Node::fullDocumentName() const
 
     // Create a name based on the type of the ancestor node.
     QString concatenator = "::";
-    if ((n->type() == Node::Fake) && (n->subType() != Node::QmlClass))
+    if ((n->type() == Node::Document) && (n->subType() != Node::QmlClass))
         concatenator = QLatin1Char('#');
 
     return pieces.join(concatenator);
@@ -2741,7 +2741,7 @@ QString Node::idForNode() const
                     str = "class-member-" + func->name();
                 else if (parent_->type() == Namespace)
                     str = "namespace-member-" + func->name();
-                else if (parent_->type() == Fake) {
+                else if (parent_->type() == Document) {
                     if (parent_->subType() == QmlClass)
                         str = "qml-method-" + parent_->name().toLower() + "-" + func->name();
                     else
@@ -2757,7 +2757,7 @@ QString Node::idForNode() const
                 str += QLatin1Char('-') + QString::number(func->overloadNumber());
         }
         break;
-    case Node::Fake:
+    case Node::Document:
         {
             switch (subType()) {
             case Node::QmlClass:
diff --git a/src/tools/qdoc/node.h b/src/tools/qdoc/node.h
index fbb6c6f..29e2932 100644
--- a/src/tools/qdoc/node.h
+++ b/src/tools/qdoc/node.h
@@ -77,7 +77,7 @@ public:
     enum Type {
         Namespace,
         Class,
-        Fake,
+        Document,
         Enum,
         Typedef,
         Function,
@@ -441,15 +441,15 @@ private:
     QmlClassNode* qmlelement;
 };
 
-class FakeNode : public InnerNode
+class DocNode : public InnerNode
 {
 public:
 
-    FakeNode(InnerNode* parent,
+    DocNode(InnerNode* parent,
              const QString& name,
              SubType subType,
              PageType ptype);
-    virtual ~FakeNode() { }
+    virtual ~DocNode() { }
 
     void setTitle(const QString &title) { title_ = title; }
     void setSubTitle(const QString &subTitle) { subtitle_ = subTitle; }
@@ -468,8 +468,8 @@ public:
     virtual bool isQmlPropertyGroup() const { return (nodeSubtype_ == QmlPropertyGroup); }
     virtual bool hasProperty(const QString& ) const;
 
-    static void insertQmlModuleNode(const QString& qmid, FakeNode* fn);
-    static FakeNode* lookupQmlModuleNode(Tree* tree, const ArgLocPair& arg);
+    static void insertQmlModuleNode(const QString& qmid, DocNode* fn);
+    static DocNode* lookupQmlModuleNode(Tree* tree, const ArgLocPair& arg);
 
 protected:
     SubType nodeSubtype_;
@@ -477,10 +477,10 @@ protected:
     QString subtitle_;
     NodeList nodeList; // used for groups and QML modules.
 
-    static QMap<QString, FakeNode*> qmlModuleMap_;
+    static QMap<QString, DocNode*> qmlModuleMap_;
 };
 
-class NameCollisionNode : public FakeNode
+class NameCollisionNode : public DocNode
 {
 public:
     NameCollisionNode(InnerNode* child);
@@ -501,7 +501,7 @@ private:
     QMap<QString,QString> targets;
 };
 
-class ExampleNode : public FakeNode
+class ExampleNode : public DocNode
 {
 public:
     ExampleNode(InnerNode* parent, const QString& name);
@@ -518,7 +518,7 @@ private:
     QString imageFileName_;
 };
 
-class QmlClassNode : public FakeNode
+class QmlClassNode : public DocNode
 {
 public:
     QmlClassNode(InnerNode* parent, const QString& name);
@@ -533,7 +533,7 @@ public:
     virtual void setImportList(const ImportList& il) { importList_ = il; }
     virtual bool isAbstract() const { return abstract_; }
     virtual void setAbstract(bool b) { abstract_ = b; }
-    const FakeNode* qmlBase() const { return base_; }
+    const DocNode* qmlBase() const { return base_; }
     void resolveInheritance(Tree* tree);
     void requireCppClass() { cnodeRequired_ = true; }
     bool cppClassRequired() const { return cnodeRequired_; }
@@ -553,11 +553,11 @@ private:
     bool abstract_;
     bool cnodeRequired_;
     ClassNode*    cnode_;
-    FakeNode*     base_;
+    DocNode*     base_;
     ImportList          importList_;
 };
 
-class QmlBasicTypeNode : public FakeNode
+class QmlBasicTypeNode : public DocNode
 {
 public:
     QmlBasicTypeNode(InnerNode* parent,
@@ -566,7 +566,7 @@ public:
     virtual bool isQmlNode() const { return true; }
 };
 
-class QmlPropGroupNode : public FakeNode
+class QmlPropGroupNode : public DocNode
 {
 public:
     QmlPropGroupNode(QmlClassNode* parent, const QString& name);
@@ -950,11 +950,11 @@ inline VariableNode::VariableNode(InnerNode* parent, const QString &name)
     // nothing.
 }
 
-class DitaMapNode : public FakeNode
+class DitaMapNode : public DocNode
 {
 public:
     DitaMapNode(InnerNode* parent, const QString& name)
-        : FakeNode(parent, name, Node::Page, Node::DitaMapPage) { }
+        : DocNode(parent, name, Node::Page, Node::DitaMapPage) { }
     virtual ~DitaMapNode() { }
 
     const DitaRefList& map() const { return doc().ditamap(); }
diff --git a/src/tools/qdoc/qmlvisitor.cpp b/src/tools/qdoc/qmlvisitor.cpp
index 76b6308..318ce14 100644
--- a/src/tools/qdoc/qmlvisitor.cpp
+++ b/src/tools/qdoc/qmlvisitor.cpp
@@ -309,7 +309,7 @@ void QmlDocVisitor::applyMetacommands(QQmlJS::AST::SourceLocation,
             QString command = *i;
             args = doc.metaCommandArgs(command);
             if (command == COMMAND_QMLABSTRACT) {
-                if ((node->type() == Node::Fake) && (node->subType() == Node::QmlClass)) {
+                if ((node->type() == Node::Document) && (node->subType() == Node::QmlClass)) {
                     node->setAbstract(true);
                 }
             }
@@ -318,8 +318,8 @@ void QmlDocVisitor::applyMetacommands(QQmlJS::AST::SourceLocation,
             }
             else if (command == COMMAND_INQMLMODULE) {
                 node->setQmlModule(args[0]);
-                FakeNode* fn = FakeNode::lookupQmlModuleNode(tree, args[0]);
-                fn->addQmlModuleMember(node);
+                DocNode* dn = DocNode::lookupQmlModuleNode(tree, args[0]);
+                dn->addQmlModuleMember(node);
                 QString qmid = node->qmlModuleIdentifier();
                 QmlClassNode* qcn = static_cast<QmlClassNode*>(node);
                 QmlClassNode::insertQmlModuleMember(qmid, qcn);
@@ -462,7 +462,7 @@ bool QmlDocVisitor::visit(QQmlJS::AST::UiPublicMember *member)
     switch (member->type) {
     case QQmlJS::AST::UiPublicMember::Signal:
     {
-        if (current->type() == Node::Fake) {
+        if (current->type() == Node::Document) {
             QmlClassNode *qmlClass = static_cast<QmlClassNode *>(current);
             if (qmlClass) {
 
@@ -485,7 +485,7 @@ bool QmlDocVisitor::visit(QQmlJS::AST::UiPublicMember *member)
     {
         QString type = member->memberType.toString();
         QString name = member->name.toString();
-        if (current->type() == Node::Fake) {
+        if (current->type() == Node::Document) {
             QmlClassNode *qmlClass = static_cast<QmlClassNode *>(current);
             if (qmlClass) {
                 QString name = member->name.toString();
@@ -526,7 +526,7 @@ bool QmlDocVisitor::visit(QQmlJS::AST::FunctionDeclaration* fd)
 {
     if (nestingLevel > 1)
         return true;
-    if (current->type() == Node::Fake) {
+    if (current->type() == Node::Document) {
         QmlClassNode* qmlClass = static_cast<QmlClassNode*>(current);
         if (qmlClass) {
             QString name = fd->name.toString();
@@ -572,7 +572,7 @@ bool QmlDocVisitor::visit(QQmlJS::AST::UiScriptBinding* sb)
 {
     if (nestingLevel > 1)
         return true;
-    if (current->type() == Node::Fake) {
+    if (current->type() == Node::Document) {
         QString handler = sb->qualifiedId->name.toString();
         if (handler.length() > 2 && handler.startsWith("on") && handler.at(2).isUpper()) {
             QmlClassNode* qmlClass = static_cast<QmlClassNode*>(current);
diff --git a/src/tools/qdoc/tree.cpp b/src/tools/qdoc/tree.cpp
index 4d0e126..9f7eb70 100644
--- a/src/tools/qdoc/tree.cpp
+++ b/src/tools/qdoc/tree.cpp
@@ -83,7 +83,7 @@ struct Target
 
 typedef QMap<PropertyNode::FunctionRole, QString> RoleMap;
 typedef QMap<PropertyNode*, RoleMap> PropertyMap;
-typedef QMultiHash<QString, FakeNode*> FakeNodeHash;
+typedef QMultiHash<QString, DocNode*> DocNodeHash;
 typedef QMultiHash<QString, Target> TargetHash;
 
 class TreePrivate
@@ -93,7 +93,7 @@ public:
     PropertyMap unresolvedPropertyMap;
     NodeMultiMap groupMap;
     QMultiMap<QString, QString> publicGroupMap;
-    FakeNodeHash fakeNodesByTitle;
+    DocNodeHash docNodesByTitle;
     TargetHash targetHash;
     QList<QPair<ClassNode*,QString> > basesList;
     QList<QPair<FunctionNode*,QString> > relatedList;
@@ -195,7 +195,6 @@ const Node* Tree::findNode(const QStringList& path,
                 break;
 
             const Node* next = static_cast<const InnerNode*>(node)->findChildNodeByName(path.at(i), qml);
-
             if (!next && (findFlags & SearchEnumValues) && i == path.size()-1)
                 next = static_cast<const InnerNode*>(node)->findEnumNodeForValue(path.at(i));
 
@@ -230,8 +229,8 @@ const Node* Tree::findNode(const QStringList& path,
 /*!
   Find the QML class node for the specified \a module and \a name
   identifiers. The \a module identifier may be empty. If the module
-  identifier is empty, then begin by finding the FakeNode that has
-  the specified \a name. If that FakeNode is a QML class, return it.
+  identifier is empty, then begin by finding the DocNode that has
+  the specified \a name. If that DocNode is a QML class, return it.
   If it is a collision node, return its current child, if the current
   child is a QML class. If the collision node does not have a child
   that is a QML class node, return 0.
@@ -246,7 +245,7 @@ QmlClassNode* Tree::findQmlClassNode(const QString& module, const QString& name)
             else if (n->subType() == Node::Collision) {
                 NameCollisionNode* ncn;
                 ncn = static_cast<NameCollisionNode*>(n);
-                return static_cast<QmlClassNode*>(ncn->findAny(Node::Fake,Node::QmlClass));
+                return static_cast<QmlClassNode*>(ncn->findAny(Node::Document,Node::QmlClass));
             }
         }
         return 0;
@@ -433,15 +432,15 @@ static const char*  const suffixes[NumSuffixes] = { "", "s", "es" };
   If \a relative node is provided, it is used to disambiguate if
   it has a QML module identifier.
  */
-const FakeNode* Tree::findFakeNodeByTitle(const QString& title, const Node* relative ) const
+const DocNode* Tree::findDocNodeByTitle(const QString& title, const Node* relative ) const
 {
     for (int pass = 0; pass < NumSuffixes; ++pass) {
-        FakeNodeHash::const_iterator i = priv->fakeNodesByTitle.constFind(Doc::canonicalTitle(title + suffixes[pass]));
-        if (i != priv->fakeNodesByTitle.constEnd()) {
+        DocNodeHash::const_iterator i = priv->docNodesByTitle.constFind(Doc::canonicalTitle(title + suffixes[pass]));
+        if (i != priv->docNodesByTitle.constEnd()) {
             if (relative && !relative->qmlModuleIdentifier().isEmpty()) {
-                const FakeNode* fn = i.value();
-                InnerNode* parent = fn->parent();
-                if (parent && parent->type() == Node::Fake && parent->subType() == Node::Collision) {
+                const DocNode* dn = i.value();
+                InnerNode* parent = dn->parent();
+                if (parent && parent->type() == Node::Document && parent->subType() == Node::Collision) {
                     const NodeList& nl = parent->childNodes();
                     NodeList::ConstIterator it = nl.constBegin();
                     while (it != nl.constEnd()) {
@@ -452,8 +451,8 @@ const FakeNode* Tree::findFakeNodeByTitle(const QString& title, const Node* rela
                               because of the QML module identifier being used as a
                               namespace qualifier.
                              */
-                            fn = static_cast<const FakeNode*>(*it);
-                            return fn;
+                            dn = static_cast<const DocNode*>(*it);
+                            return dn;
                         }
                         ++it;
                     }
@@ -464,11 +463,11 @@ const FakeNode* Tree::findFakeNodeByTitle(const QString& title, const Node* rela
               overkill. We should report the duplicate file and let
               that suffice.
              */
-            FakeNodeHash::const_iterator j = i;
+            DocNodeHash::const_iterator j = i;
             ++j;
-            if (j != priv->fakeNodesByTitle.constEnd() && j.key() == i.key()) {
+            if (j != priv->docNodesByTitle.constEnd() && j.key() == i.key()) {
                 QList<Location> internalLocations;
-                while (j != priv->fakeNodesByTitle.constEnd()) {
+                while (j != priv->docNodesByTitle.constEnd()) {
                     if (j.key() == i.key() && j.value()->url().isEmpty())
                         internalLocations.append(j.value()->location());
                     ++j;
@@ -759,10 +758,10 @@ void Tree::resolveTargets(InnerNode* root)
     // need recursion
 
     foreach (Node* child, root->childNodes()) {
-        if (child->type() == Node::Fake) {
-            FakeNode* node = static_cast<FakeNode*>(child);
+        if (child->type() == Node::Document) {
+            DocNode* node = static_cast<DocNode*>(child);
             if (!node->title().isEmpty())
-                priv->fakeNodesByTitle.insert(Doc::canonicalTitle(node->title()), node);
+                priv->docNodesByTitle.insert(Doc::canonicalTitle(node->title()), node);
             if (node->subType() == Node::Collision) {
                 resolveTargets(node);
             }
@@ -815,7 +814,7 @@ void Tree::resolveCppToQmlLinks()
 {
 
     foreach (Node* child, roo.childNodes()) {
-        if (child->type() == Node::Fake && child->subType() == Node::QmlClass) {
+        if (child->type() == Node::Document && child->subType() == Node::QmlClass) {
             QmlClassNode* qcn = static_cast<QmlClassNode*>(child);
             ClassNode* cn = const_cast<ClassNode*>(qcn->classNode());
             if (cn)
@@ -833,7 +832,7 @@ void Tree::resolveQmlInheritance()
 {
 
     foreach (Node* child, roo.childNodes()) {
-        if (child->type() == Node::Fake) {
+        if (child->type() == Node::Document) {
             if (child->subType() == Node::QmlClass) {
                 QmlClassNode* qcn = static_cast<QmlClassNode*>(child);
                 qcn->resolveInheritance(this);
@@ -841,7 +840,7 @@ void Tree::resolveQmlInheritance()
             else if (child->subType() == Node::Collision) {
                 NameCollisionNode* ncn = static_cast<NameCollisionNode*>(child);
                 foreach (Node* child, ncn->childNodes()) {
-                    if (child->type() == Node::Fake) {
+                    if (child->type() == Node::Document) {
                         if (child->subType() == Node::QmlClass) {
                             QmlClassNode* qcn = static_cast<QmlClassNode*>(child);
                             qcn->resolveInheritance(this);
@@ -1076,8 +1075,8 @@ void Tree::readIndexSection(const QDomElement& element,
         else
             return;
 
-        FakeNode* fakeNode = new FakeNode(parent, name, subtype, ptype);
-        fakeNode->setTitle(element.attribute("title"));
+        DocNode* docNode = new DocNode(parent, name, subtype, ptype);
+        docNode->setTitle(element.attribute("title"));
 
         if (element.hasAttribute("location"))
             name = element.attribute("location", "");
@@ -1087,7 +1086,7 @@ void Tree::readIndexSection(const QDomElement& element,
         else if (!indexUrl.isNull())
             location = Location(name);
 
-        section = fakeNode;
+        section = docNode;
 
     }
     else if (element.nodeName() == "enum") {
@@ -1371,7 +1370,7 @@ bool Tree::generateIndexSection(QXmlStreamWriter& writer,
     case Node::Class:
         nodeName = "class";
         break;
-    case Node::Fake:
+    case Node::Document:
         nodeName = "page";
         if (node->subType() == Node::QmlClass)
             nodeName = "qmlclass";
@@ -1442,7 +1441,7 @@ bool Tree::generateIndexSection(QXmlStreamWriter& writer,
     QXmlStreamAttributes attributes;
     writer.writeAttribute("access", access);
 
-    if (node->type() != Node::Fake) {
+    if (node->type() != Node::Document) {
         QString threadSafety;
         switch (node->threadSafeness()) {
         case Node::NonReentrant:
@@ -1498,7 +1497,7 @@ bool Tree::generateIndexSection(QXmlStreamWriter& writer,
         href.append(QLatin1Char('/'));
     href.append(gen_->fullDocumentLocation(node));
     writer.writeAttribute("href", href);
-    if ((node->type() != Node::Fake) && (!node->isQmlNode()))
+    if ((node->type() != Node::Document) && (!node->isQmlNode()))
         writer.writeAttribute("location", node->location().fileName());
 
     switch (node->type()) {
@@ -1523,15 +1522,15 @@ bool Tree::generateIndexSection(QXmlStreamWriter& writer,
         writer.writeAttribute("module", node->moduleName());
         break;
 
-    case Node::Fake:
+    case Node::Document:
     {
         /*
-              Fake nodes (such as manual pages) contain subtypes,
+              Document nodes (such as manual pages) contain subtypes,
               titles and other attributes.
             */
 
-        const FakeNode* fakeNode = static_cast<const FakeNode*>(node);
-        switch (fakeNode->subType()) {
+        const DocNode* docNode = static_cast<const DocNode*>(node);
+        switch (docNode->subType()) {
         case Node::Example:
             writer.writeAttribute("subtype", "example");
             break;
@@ -1562,10 +1561,10 @@ bool Tree::generateIndexSection(QXmlStreamWriter& writer,
         default:
             break;
         }
-        writer.writeAttribute("title", fakeNode->title());
-        writer.writeAttribute("fulltitle", fakeNode->fullTitle());
-        writer.writeAttribute("subtitle", fakeNode->subTitle());
-        writer.writeAttribute("location", fakeNode->doc().location().fileName());
+        writer.writeAttribute("title", docNode->title());
+        writer.writeAttribute("fulltitle", docNode->fullTitle());
+        writer.writeAttribute("subtitle", docNode->subTitle());
+        writer.writeAttribute("location", docNode->doc().location().fileName());
     }
         break;
 
@@ -1709,9 +1708,9 @@ bool Tree::generateIndexSection(QXmlStreamWriter& writer,
 
         if (inner->doc().hasTargets()) {
             bool external = false;
-            if (inner->type() == Node::Fake) {
-                const FakeNode* fakeNode = static_cast<const FakeNode*>(inner);
-                if (fakeNode->subType() == Node::ExternalPage)
+            if (inner->type() == Node::Document) {
+                const DocNode* docNode = static_cast<const DocNode*>(inner);
+                if (docNode->subType() == Node::ExternalPage)
                     external = true;
             }
 
@@ -1867,9 +1866,9 @@ bool compareNodes(const Node* n1, const Node* n2)
             return false;
     }
 
-    if (n1->type() == Node::Fake && n2->type() == Node::Fake) {
-        const FakeNode* f1 = static_cast<const FakeNode*>(n1);
-        const FakeNode* f2 = static_cast<const FakeNode*>(n2);
+    if (n1->type() == Node::Document && n2->type() == Node::Document) {
+        const DocNode* f1 = static_cast<const DocNode*>(n1);
+        const DocNode* f2 = static_cast<const DocNode*>(n2);
         if (f1->fullTitle() < f2->fullTitle())
             return true;
         else if (f1->fullTitle() > f2->fullTitle())
@@ -2264,14 +2263,14 @@ void Tree::generateTagFile(const QString& fileName)
  */
 void Tree::addExternalLink(const QString& url, const Node* relative)
 {
-    FakeNode* fakeNode = new FakeNode(root(), url, Node::ExternalPage, Node::ArticlePage);
-    fakeNode->setAccess(Node::Public);
+    DocNode* docNode = new DocNode(root(), url, Node::ExternalPage, Node::ArticlePage);
+    docNode->setAccess(Node::Public);
 
     // Create some content for the node.
     QSet<QString> emptySet;
     Location location(relative->doc().location());
     Doc doc(location, location, " ", emptySet); // placeholder
-    fakeNode->setDoc(doc);
+    docNode->setDoc(doc);
 }
 
 /*!
@@ -2279,7 +2278,7 @@ void Tree::addExternalLink(const QString& url, const Node* relative)
   the specified \a type and \a subtype. Begin the search at
   the \a start node. If the \a start node is 0, begin the
   search at the tree root. \a subtype is not used unless
-  \a type is \c{Fake}.
+  \a type is \c{Document}.
  */
 Node* Tree::findNodeByNameAndType(const QStringList& path,
                                   Node::Type type,
@@ -2304,7 +2303,7 @@ Node* Tree::findNodeByNameAndType(const QStringList& path,
   If the end of the path is reached (i.e. if a matching
   node is found for each name in the \a path), the \a type
   must match the type of the last matching node, and if the
-  type is \e{Fake}, the \a subtype must match as well.
+  type is \e{Document}, the \a subtype must match as well.
 
   If the algorithm is successful, the pointer to the final
   node is returned. Otherwise 0 is returned.
@@ -2343,7 +2342,7 @@ Node* Tree::findNodeRecursive(const QStringList& path,
         else if (n->name() == name) {
             if (pathIndex+1 >= path.size()) {
                 if (n->type() == type) {
-                    if (type == Node::Fake) {
+                    if (type == Node::Document) {
                         if (n->subType() == subtype)
                             return n;
                         else if (n->subType() == Node::Collision && acceptCollision)
@@ -2423,7 +2422,7 @@ QmlClassNode* Tree::findQmlClassNode(const QStringList& path, Node* start)
 
     if (!start)
         start = const_cast<NamespaceNode*>(root());
-    return static_cast<QmlClassNode*>(findNodeRecursive(path, 0, start, Node::Fake, Node::QmlClass));
+    return static_cast<QmlClassNode*>(findNodeRecursive(path, 0, start, Node::Document, Node::QmlClass));
 }
 
 /*!
@@ -2445,11 +2444,11 @@ NamespaceNode* Tree::findNamespaceNode(const QStringList& path, Node* start)
   at the root of the tree. Only a Group node named \a path is
   acceptible. If one is not found, 0 is returned.
  */
-FakeNode* Tree::findGroupNode(const QStringList& path, Node* start)
+DocNode* Tree::findGroupNode(const QStringList& path, Node* start)
 {
     if (!start)
         start = const_cast<NamespaceNode*>(root());
-    return static_cast<FakeNode*>(findNodeRecursive(path, 0, start, Node::Fake, Node::Group));
+    return static_cast<DocNode*>(findNodeRecursive(path, 0, start, Node::Document, Node::Group));
 }
 
 /*!
@@ -2458,11 +2457,11 @@ FakeNode* Tree::findGroupNode(const QStringList& path, Node* start)
   at the root of the tree. Only a Qml module node named \a path is
   acceptible. If one is not found, 0 is returned.
  */
-FakeNode* Tree::findQmlModuleNode(const QStringList& path, Node* start)
+DocNode* Tree::findQmlModuleNode(const QStringList& path, Node* start)
 {
     if (!start)
         start = const_cast<NamespaceNode*>(root());
-    return static_cast<FakeNode*>(findNodeRecursive(path, 0, start, Node::Fake, Node::QmlModule));
+    return static_cast<DocNode*>(findNodeRecursive(path, 0, start, Node::Document, Node::QmlModule));
 }
 
 QT_END_NAMESPACE
diff --git a/src/tools/qdoc/tree.h b/src/tools/qdoc/tree.h
index 0e6090f..0684364 100644
--- a/src/tools/qdoc/tree.h
+++ b/src/tools/qdoc/tree.h
@@ -70,8 +70,8 @@ public:
     ClassNode* findClassNode(const QStringList& path, Node* start = 0);
     QmlClassNode* findQmlClassNode(const QStringList& path, Node* start = 0);
     NamespaceNode* findNamespaceNode(const QStringList& path, Node* start = 0);
-    FakeNode* findGroupNode(const QStringList& path, Node* start = 0);
-    FakeNode* findQmlModuleNode(const QStringList& path, Node* start = 0);
+    DocNode* findGroupNode(const QStringList& path, Node* start = 0);
+    DocNode* findQmlModuleNode(const QStringList& path, Node* start = 0);
 
     Node* findNodeByNameAndType(const QStringList& path,
                                 Node::Type type,
@@ -139,7 +139,7 @@ public:
                                          const FunctionNode *clone,
                                          const Node *relative = 0,
                                          int findFlags = 0) const;
-    const FakeNode *findFakeNodeByTitle(const QString &title, const Node* relative = 0) const;
+    const DocNode *findDocNodeByTitle(const QString &title, const Node* relative = 0) const;
     const Node *findUnambiguousTarget(const QString &target, Atom *&atom, const Node* relative) const;
     Atom *findTarget(const QString &target, const Node *node) const;
     const NamespaceNode *root() const { return &roo; }