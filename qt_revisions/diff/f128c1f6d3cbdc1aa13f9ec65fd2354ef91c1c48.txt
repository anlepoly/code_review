diff --git a/src/gui/accessible/accessible.pri b/src/gui/accessible/accessible.pri
index abffa2a..7c8e818 100644
--- a/src/gui/accessible/accessible.pri
+++ b/src/gui/accessible/accessible.pri
@@ -12,7 +12,7 @@ contains(QT_CONFIG, accessibility) {
         accessible/qaccessible2.cpp \
         accessible/qaccessibleobject.cpp \
         accessible/qaccessibleplugin.cpp \
-        accessible/qplatformaccessibility_qpa.cpp
+        accessible/qplatformaccessibility.cpp
 
     HEADERS += accessible/qaccessiblebridge.h
     SOURCES += accessible/qaccessiblebridge.cpp
diff --git a/src/gui/accessible/qplatformaccessibility.cpp b/src/gui/accessible/qplatformaccessibility.cpp
new file mode 100644
index 0000000..dba5475
--- /dev/null
+++ b/src/gui/accessible/qplatformaccessibility.cpp
@@ -0,0 +1,143 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "qplatformaccessibility.h"
+#include <private/qfactoryloader_p.h>
+#include "qaccessibleplugin.h"
+#include "qaccessibleobject.h"
+#include "qaccessiblebridge.h"
+#include <QtGui/QGuiApplication>
+
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_ACCESSIBILITY
+
+/* accessiblebridge plugin discovery stuff */
+#ifndef QT_NO_LIBRARY
+Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, bridgeloader,
+    (QAccessibleBridgeFactoryInterface_iid, QLatin1String("/accessiblebridge")))
+#endif
+
+Q_GLOBAL_STATIC(QVector<QAccessibleBridge *>, bridges)
+
+/*!
+    \class QPlatformAccessibility
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+    \ingroup accessibility
+
+    \brief The QPlatformAccessibility class is the base class for
+    integrating accessibility backends
+
+    \sa QAccessible
+*/
+QPlatformAccessibility::QPlatformAccessibility()
+{
+}
+
+QPlatformAccessibility::~QPlatformAccessibility()
+{
+}
+
+void QPlatformAccessibility::notifyAccessibilityUpdate(QAccessibleEvent *event)
+{
+    initialize();
+
+    if (!bridges() || bridges()->isEmpty())
+        return;
+
+    for (int i = 0; i < bridges()->count(); ++i)
+        bridges()->at(i)->notifyAccessibilityUpdate(event);
+}
+
+void QPlatformAccessibility::setRootObject(QObject *o)
+{
+    initialize();
+    if (bridges()->isEmpty())
+        return;
+
+    if (!o)
+        return;
+
+    for (int i = 0; i < bridges()->count(); ++i) {
+        QAccessibleInterface *iface = QAccessible::queryAccessibleInterface(o);
+        bridges()->at(i)->setRootObject(iface);
+    }
+}
+
+void QPlatformAccessibility::initialize()
+{
+    static bool isInit = false;
+    if (isInit)
+        return;
+    isInit = true;      // ### not atomic
+
+#ifndef QT_NO_LIBRARY
+    typedef QMultiMap<int, QString> PluginKeyMap;
+    typedef PluginKeyMap::const_iterator PluginKeyMapConstIterator;
+
+    const PluginKeyMap keyMap = bridgeloader()->keyMap();
+    QAccessibleBridgePlugin *factory = 0;
+    int i = -1;
+    const PluginKeyMapConstIterator cend = keyMap.constEnd();
+    for (PluginKeyMapConstIterator it = keyMap.constBegin(); it != cend; ++it) {
+        if (it.key() != i) {
+            i = it.key();
+            factory = qobject_cast<QAccessibleBridgePlugin*>(bridgeloader()->instance(i));
+        }
+        if (factory)
+            if (QAccessibleBridge *bridge = factory->create(it.value()))
+                bridges()->append(bridge);
+    }
+#endif
+}
+
+void QPlatformAccessibility::cleanup()
+{
+    qDeleteAll(*bridges());
+}
+
+#endif // QT_NO_ACCESSIBILITY
+
+QT_END_NAMESPACE
diff --git a/src/gui/accessible/qplatformaccessibility_qpa.cpp b/src/gui/accessible/qplatformaccessibility_qpa.cpp
deleted file mode 100644
index dba5475..0000000
--- a/src/gui/accessible/qplatformaccessibility_qpa.cpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include "qplatformaccessibility.h"
-#include <private/qfactoryloader_p.h>
-#include "qaccessibleplugin.h"
-#include "qaccessibleobject.h"
-#include "qaccessiblebridge.h"
-#include <QtGui/QGuiApplication>
-
-#include <QDebug>
-
-QT_BEGIN_NAMESPACE
-
-#ifndef QT_NO_ACCESSIBILITY
-
-/* accessiblebridge plugin discovery stuff */
-#ifndef QT_NO_LIBRARY
-Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, bridgeloader,
-    (QAccessibleBridgeFactoryInterface_iid, QLatin1String("/accessiblebridge")))
-#endif
-
-Q_GLOBAL_STATIC(QVector<QAccessibleBridge *>, bridges)
-
-/*!
-    \class QPlatformAccessibility
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-    \ingroup accessibility
-
-    \brief The QPlatformAccessibility class is the base class for
-    integrating accessibility backends
-
-    \sa QAccessible
-*/
-QPlatformAccessibility::QPlatformAccessibility()
-{
-}
-
-QPlatformAccessibility::~QPlatformAccessibility()
-{
-}
-
-void QPlatformAccessibility::notifyAccessibilityUpdate(QAccessibleEvent *event)
-{
-    initialize();
-
-    if (!bridges() || bridges()->isEmpty())
-        return;
-
-    for (int i = 0; i < bridges()->count(); ++i)
-        bridges()->at(i)->notifyAccessibilityUpdate(event);
-}
-
-void QPlatformAccessibility::setRootObject(QObject *o)
-{
-    initialize();
-    if (bridges()->isEmpty())
-        return;
-
-    if (!o)
-        return;
-
-    for (int i = 0; i < bridges()->count(); ++i) {
-        QAccessibleInterface *iface = QAccessible::queryAccessibleInterface(o);
-        bridges()->at(i)->setRootObject(iface);
-    }
-}
-
-void QPlatformAccessibility::initialize()
-{
-    static bool isInit = false;
-    if (isInit)
-        return;
-    isInit = true;      // ### not atomic
-
-#ifndef QT_NO_LIBRARY
-    typedef QMultiMap<int, QString> PluginKeyMap;
-    typedef PluginKeyMap::const_iterator PluginKeyMapConstIterator;
-
-    const PluginKeyMap keyMap = bridgeloader()->keyMap();
-    QAccessibleBridgePlugin *factory = 0;
-    int i = -1;
-    const PluginKeyMapConstIterator cend = keyMap.constEnd();
-    for (PluginKeyMapConstIterator it = keyMap.constBegin(); it != cend; ++it) {
-        if (it.key() != i) {
-            i = it.key();
-            factory = qobject_cast<QAccessibleBridgePlugin*>(bridgeloader()->instance(i));
-        }
-        if (factory)
-            if (QAccessibleBridge *bridge = factory->create(it.value()))
-                bridges()->append(bridge);
-    }
-#endif
-}
-
-void QPlatformAccessibility::cleanup()
-{
-    qDeleteAll(*bridges());
-}
-
-#endif // QT_NO_ACCESSIBILITY
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/kernel.pri b/src/gui/kernel/kernel.pri
index efa79b5..bf79837 100644
--- a/src/gui/kernel/kernel.pri
+++ b/src/gui/kernel/kernel.pri
@@ -66,29 +66,29 @@ HEADERS += \
 SOURCES += \
         kernel/qclipboard_qpa.cpp \
         kernel/qcursor_qpa.cpp \
-        kernel/qgenericpluginfactory_qpa.cpp \
-        kernel/qgenericplugin_qpa.cpp \
-        kernel/qwindowsysteminterface_qpa.cpp \
-        kernel/qplatforminputcontextfactory_qpa.cpp \
-        kernel/qplatforminputcontextplugin_qpa.cpp \
-        kernel/qplatforminputcontext_qpa.cpp \
-        kernel/qplatformintegration_qpa.cpp \
-        kernel/qplatformdrag_qpa.cpp \
-        kernel/qplatformscreen_qpa.cpp \
-        kernel/qplatformintegrationfactory_qpa.cpp \
-        kernel/qplatformintegrationplugin_qpa.cpp \
-        kernel/qplatformtheme_qpa.cpp \
-        kernel/qplatformthemefactory_qpa.cpp \
-        kernel/qplatformthemeplugin_qpa.cpp \
-        kernel/qplatformwindow_qpa.cpp \
-        kernel/qplatformcursor_qpa.cpp \
-        kernel/qplatformclipboard_qpa.cpp \
-        kernel/qplatformnativeinterface_qpa.cpp \
-        kernel/qsessionmanager_qpa.cpp \
+        kernel/qgenericpluginfactory.cpp \
+        kernel/qgenericplugin.cpp \
+        kernel/qwindowsysteminterface.cpp \
+        kernel/qplatforminputcontextfactory.cpp \
+        kernel/qplatforminputcontextplugin.cpp \
+        kernel/qplatforminputcontext.cpp \
+        kernel/qplatformintegration.cpp \
+        kernel/qplatformdrag.cpp \
+        kernel/qplatformscreen.cpp \
+        kernel/qplatformintegrationfactory.cpp \
+        kernel/qplatformintegrationplugin.cpp \
+        kernel/qplatformtheme.cpp \
+        kernel/qplatformthemefactory.cpp \
+        kernel/qplatformthemeplugin.cpp \
+        kernel/qplatformwindow.cpp \
+        kernel/qplatformcursor.cpp \
+        kernel/qplatformclipboard.cpp \
+        kernel/qplatformnativeinterface.cpp \
+        kernel/qsessionmanager.cpp \
         kernel/qsurfaceformat.cpp \
         kernel/qguiapplication.cpp \
         kernel/qwindow.cpp \
-        kernel/qplatformsurface_qpa.cpp \
+        kernel/qplatformsurface.cpp \
         kernel/qsurface.cpp \
         kernel/qclipboard.cpp \
         kernel/qcursor.cpp \
@@ -105,10 +105,10 @@ SOURCES += \
         kernel/qshortcutmap.cpp \
         kernel/qstylehints.cpp \
         kernel/qtouchdevice.cpp \
-        kernel/qplatformsharedgraphicscache_qpa.cpp \
-        kernel/qplatformdialoghelper_qpa.cpp \
-        kernel/qplatformservices_qpa.cpp \
-        kernel/qplatformscreenpageflipper_qpa.cpp
+        kernel/qplatformsharedgraphicscache.cpp \
+        kernel/qplatformdialoghelper.cpp \
+        kernel/qplatformservices.cpp \
+        kernel/qplatformscreenpageflipper.cpp
 
 contains(QT_CONFIG, opengl)|contains(QT_CONFIG, opengles2) {
     HEADERS += \
@@ -117,7 +117,7 @@ contains(QT_CONFIG, opengl)|contains(QT_CONFIG, opengles2) {
             kernel/qopenglcontext_p.h
 
     SOURCES += \
-            kernel/qplatformopenglcontext_qpa.cpp \
+            kernel/qplatformopenglcontext.cpp \
             kernel/qopenglcontext.cpp
 }
 
diff --git a/src/gui/kernel/qgenericplugin.cpp b/src/gui/kernel/qgenericplugin.cpp
new file mode 100644
index 0000000..4cd12d0
--- /dev/null
+++ b/src/gui/kernel/qgenericplugin.cpp
@@ -0,0 +1,106 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qgenericplugin_qpa.h"
+
+#ifndef QT_NO_LIBRARY
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QGenericPlugin
+    \ingroup plugins
+    \ingroup qpa
+
+    \brief The QGenericPlugin class is an abstract base class for
+    window-system related plugins in Qt QPA.
+
+    Note that this class is only available in Qt QPA.
+
+    A mouse plugin can be created by subclassing
+    QGenericPlugin and reimplementing the pure virtual create()
+    function. By exporting the derived class using the
+    Q_PLUGIN_METADATA() macro, The default implementation of the
+    QGenericPluginFactory class will automatically detect the plugin and
+    load the driver into the server application at run-time. See \l
+    {How to Create Qt Plugins} for details.
+
+    The json metadata file should contain a list of keys supported by this
+    plugin.
+
+    \sa QGenericPluginFactory
+*/
+
+/*!
+    Constructs a plugin with the given \a parent.
+
+    Note that this constructor is invoked automatically by the
+    moc generated code that exports the plugin, so there is no need for calling it
+    explicitly.
+*/
+QGenericPlugin::QGenericPlugin(QObject *parent)
+    : QObject(parent)
+{
+}
+
+/*!
+    Destroys the plugin.
+
+    Note that Qt destroys a plugin automatically when it is no longer
+    used, so there is no need for calling the destructor explicitly.
+*/
+QGenericPlugin::~QGenericPlugin()
+{
+}
+
+/*!
+    \fn QObject* QGenericPlugin::create(const QString &key, const QString& specification)
+
+    Implement this function to create a driver matching the type
+    specified by the given \a key and \a specification parameters. Note that
+    keys are case-insensitive.
+
+    \sa keys()
+*/
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_LIBRARY
diff --git a/src/gui/kernel/qgenericplugin_qpa.cpp b/src/gui/kernel/qgenericplugin_qpa.cpp
deleted file mode 100644
index 4cd12d0..0000000
--- a/src/gui/kernel/qgenericplugin_qpa.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qgenericplugin_qpa.h"
-
-#ifndef QT_NO_LIBRARY
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QGenericPlugin
-    \ingroup plugins
-    \ingroup qpa
-
-    \brief The QGenericPlugin class is an abstract base class for
-    window-system related plugins in Qt QPA.
-
-    Note that this class is only available in Qt QPA.
-
-    A mouse plugin can be created by subclassing
-    QGenericPlugin and reimplementing the pure virtual create()
-    function. By exporting the derived class using the
-    Q_PLUGIN_METADATA() macro, The default implementation of the
-    QGenericPluginFactory class will automatically detect the plugin and
-    load the driver into the server application at run-time. See \l
-    {How to Create Qt Plugins} for details.
-
-    The json metadata file should contain a list of keys supported by this
-    plugin.
-
-    \sa QGenericPluginFactory
-*/
-
-/*!
-    Constructs a plugin with the given \a parent.
-
-    Note that this constructor is invoked automatically by the
-    moc generated code that exports the plugin, so there is no need for calling it
-    explicitly.
-*/
-QGenericPlugin::QGenericPlugin(QObject *parent)
-    : QObject(parent)
-{
-}
-
-/*!
-    Destroys the plugin.
-
-    Note that Qt destroys a plugin automatically when it is no longer
-    used, so there is no need for calling the destructor explicitly.
-*/
-QGenericPlugin::~QGenericPlugin()
-{
-}
-
-/*!
-    \fn QObject* QGenericPlugin::create(const QString &key, const QString& specification)
-
-    Implement this function to create a driver matching the type
-    specified by the given \a key and \a specification parameters. Note that
-    keys are case-insensitive.
-
-    \sa keys()
-*/
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_LIBRARY
diff --git a/src/gui/kernel/qgenericpluginfactory.cpp b/src/gui/kernel/qgenericpluginfactory.cpp
new file mode 100644
index 0000000..663b88e
--- /dev/null
+++ b/src/gui/kernel/qgenericpluginfactory.cpp
@@ -0,0 +1,117 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qgenericpluginfactory_qpa.h"
+
+#include "qguiapplication.h"
+#include "private/qfactoryloader_p.h"
+#include "qgenericplugin_qpa.h"
+#include "qdebug.h"
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)
+#ifndef QT_NO_LIBRARY
+
+Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
+    (QGenericPluginFactoryInterface_iid,
+     QLatin1String("/generic"), Qt::CaseInsensitive))
+
+#endif //QT_NO_LIBRARY
+#endif //QT_MAKEDLL
+
+/*!
+    \class QGenericPluginFactory
+    \ingroup qpa
+
+    \brief The QGenericPluginFactory class creates window-system
+    related plugin drivers in Qt QPA.
+
+    Note that this class is only available in Qt QPA.
+
+    \sa QGenericPlugin
+*/
+
+/*!
+    Creates the driver specified by \a key, using the given \a specification.
+
+    Note that the keys are case-insensitive.
+
+    \sa keys()
+*/
+QObject *QGenericPluginFactory::create(const QString& key, const QString &specification)
+{
+    const QString driver = key.toLower();
+
+#if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)
+#ifndef QT_NO_LIBRARY
+    if (QObject *object = qLoadPlugin1<QObject, QGenericPlugin>(loader(), driver, specification))
+        return object;
+#endif
+#endif
+    return 0;
+}
+
+/*!
+    Returns the list of valid keys, i.e. the available mouse drivers.
+
+    \sa create()
+*/
+QStringList QGenericPluginFactory::keys()
+{
+    QStringList list;
+
+#if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)
+#ifndef QT_NO_LIBRARY
+    typedef QMultiMap<int, QString> PluginKeyMap;
+    typedef PluginKeyMap::const_iterator PluginKeyMapConstIterator;
+
+    const PluginKeyMap keyMap = loader()->keyMap();
+    const PluginKeyMapConstIterator cend = keyMap.constEnd();
+    for (PluginKeyMapConstIterator it = keyMap.constBegin(); it != cend; ++it)
+        if (!list.contains(it.value()))
+            list += it.value();
+#endif //QT_NO_LIBRARY
+#endif //QT_MAKEDLL
+    return list;
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qgenericpluginfactory_qpa.cpp b/src/gui/kernel/qgenericpluginfactory_qpa.cpp
deleted file mode 100644
index 663b88e..0000000
--- a/src/gui/kernel/qgenericpluginfactory_qpa.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qgenericpluginfactory_qpa.h"
-
-#include "qguiapplication.h"
-#include "private/qfactoryloader_p.h"
-#include "qgenericplugin_qpa.h"
-#include "qdebug.h"
-
-QT_BEGIN_NAMESPACE
-
-#if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)
-#ifndef QT_NO_LIBRARY
-
-Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
-    (QGenericPluginFactoryInterface_iid,
-     QLatin1String("/generic"), Qt::CaseInsensitive))
-
-#endif //QT_NO_LIBRARY
-#endif //QT_MAKEDLL
-
-/*!
-    \class QGenericPluginFactory
-    \ingroup qpa
-
-    \brief The QGenericPluginFactory class creates window-system
-    related plugin drivers in Qt QPA.
-
-    Note that this class is only available in Qt QPA.
-
-    \sa QGenericPlugin
-*/
-
-/*!
-    Creates the driver specified by \a key, using the given \a specification.
-
-    Note that the keys are case-insensitive.
-
-    \sa keys()
-*/
-QObject *QGenericPluginFactory::create(const QString& key, const QString &specification)
-{
-    const QString driver = key.toLower();
-
-#if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)
-#ifndef QT_NO_LIBRARY
-    if (QObject *object = qLoadPlugin1<QObject, QGenericPlugin>(loader(), driver, specification))
-        return object;
-#endif
-#endif
-    return 0;
-}
-
-/*!
-    Returns the list of valid keys, i.e. the available mouse drivers.
-
-    \sa create()
-*/
-QStringList QGenericPluginFactory::keys()
-{
-    QStringList list;
-
-#if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)
-#ifndef QT_NO_LIBRARY
-    typedef QMultiMap<int, QString> PluginKeyMap;
-    typedef PluginKeyMap::const_iterator PluginKeyMapConstIterator;
-
-    const PluginKeyMap keyMap = loader()->keyMap();
-    const PluginKeyMapConstIterator cend = keyMap.constEnd();
-    for (PluginKeyMapConstIterator it = keyMap.constBegin(); it != cend; ++it)
-        if (!list.contains(it.value()))
-            list += it.value();
-#endif //QT_NO_LIBRARY
-#endif //QT_MAKEDLL
-    return list;
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformclipboard.cpp b/src/gui/kernel/qplatformclipboard.cpp
new file mode 100644
index 0000000..5a29606
--- /dev/null
+++ b/src/gui/kernel/qplatformclipboard.cpp
@@ -0,0 +1,131 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "qplatformclipboard.h"
+
+#ifndef QT_NO_CLIPBOARD
+
+#include <QtGui/private/qguiapplication_p.h>
+#include <QtCore/qmimedata.h>
+
+QT_BEGIN_NAMESPACE
+
+class QClipboardData
+{
+public:
+    QClipboardData();
+   ~QClipboardData();
+
+    void setSource(QMimeData* s)
+    {
+        if (s == src)
+            return;
+        delete src;
+        src = s;
+    }
+    QMimeData* source()
+        { return src; }
+
+private:
+    QMimeData* src;
+};
+
+QClipboardData::QClipboardData()
+{
+    src = 0;
+}
+
+QClipboardData::~QClipboardData()
+{
+    delete src;
+}
+
+Q_GLOBAL_STATIC(QClipboardData,q_clipboardData);
+
+/*!
+    \class QPlatformClipboard
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformClipboard class provides an abstraction for the system clipboard.
+ */
+
+QPlatformClipboard::~QPlatformClipboard()
+{
+
+}
+
+QMimeData *QPlatformClipboard::mimeData(QClipboard::Mode mode)
+{
+    //we know its clipboard
+    Q_UNUSED(mode);
+    return q_clipboardData()->source();
+}
+
+void QPlatformClipboard::setMimeData(QMimeData *data, QClipboard::Mode mode)
+{
+    //we know its clipboard
+    Q_UNUSED(mode);
+    q_clipboardData()->setSource(data);
+
+    emitChanged(mode);
+}
+
+bool QPlatformClipboard::supportsMode(QClipboard::Mode mode) const
+{
+    return mode == QClipboard::Clipboard;
+}
+
+bool QPlatformClipboard::ownsMode(QClipboard::Mode mode) const
+{
+    Q_UNUSED(mode);
+    return false;
+}
+
+void QPlatformClipboard::emitChanged(QClipboard::Mode mode)
+{
+    QGuiApplication::clipboard()->emitChanged(mode);
+}
+
+QT_END_NAMESPACE
+
+#endif //QT_NO_CLIPBOARD
diff --git a/src/gui/kernel/qplatformclipboard_qpa.cpp b/src/gui/kernel/qplatformclipboard_qpa.cpp
deleted file mode 100644
index 5a29606..0000000
--- a/src/gui/kernel/qplatformclipboard_qpa.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include "qplatformclipboard.h"
-
-#ifndef QT_NO_CLIPBOARD
-
-#include <QtGui/private/qguiapplication_p.h>
-#include <QtCore/qmimedata.h>
-
-QT_BEGIN_NAMESPACE
-
-class QClipboardData
-{
-public:
-    QClipboardData();
-   ~QClipboardData();
-
-    void setSource(QMimeData* s)
-    {
-        if (s == src)
-            return;
-        delete src;
-        src = s;
-    }
-    QMimeData* source()
-        { return src; }
-
-private:
-    QMimeData* src;
-};
-
-QClipboardData::QClipboardData()
-{
-    src = 0;
-}
-
-QClipboardData::~QClipboardData()
-{
-    delete src;
-}
-
-Q_GLOBAL_STATIC(QClipboardData,q_clipboardData);
-
-/*!
-    \class QPlatformClipboard
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformClipboard class provides an abstraction for the system clipboard.
- */
-
-QPlatformClipboard::~QPlatformClipboard()
-{
-
-}
-
-QMimeData *QPlatformClipboard::mimeData(QClipboard::Mode mode)
-{
-    //we know its clipboard
-    Q_UNUSED(mode);
-    return q_clipboardData()->source();
-}
-
-void QPlatformClipboard::setMimeData(QMimeData *data, QClipboard::Mode mode)
-{
-    //we know its clipboard
-    Q_UNUSED(mode);
-    q_clipboardData()->setSource(data);
-
-    emitChanged(mode);
-}
-
-bool QPlatformClipboard::supportsMode(QClipboard::Mode mode) const
-{
-    return mode == QClipboard::Clipboard;
-}
-
-bool QPlatformClipboard::ownsMode(QClipboard::Mode mode) const
-{
-    Q_UNUSED(mode);
-    return false;
-}
-
-void QPlatformClipboard::emitChanged(QClipboard::Mode mode)
-{
-    QGuiApplication::clipboard()->emitChanged(mode);
-}
-
-QT_END_NAMESPACE
-
-#endif //QT_NO_CLIPBOARD
diff --git a/src/gui/kernel/qplatformcursor.cpp b/src/gui/kernel/qplatformcursor.cpp
new file mode 100644
index 0000000..40b7967
--- /dev/null
+++ b/src/gui/kernel/qplatformcursor.cpp
@@ -0,0 +1,664 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtOpenVG module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "qplatformcursor.h"
+
+#include <QPainter>
+#include <QBitmap>
+#include <QGuiApplication>
+#include <QScreen>
+#include <qpa/qplatformscreen.h>
+#include <private/qguiapplication_p.h>
+
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+QList<QPlatformCursor *> QPlatformCursorPrivate::getInstances()
+{
+    QList<QPlatformCursor *> result;
+    foreach (const QScreen *screen, QGuiApplicationPrivate::screen_list)
+        if (QPlatformCursor *cursor = screen->handle()->cursor())
+            result.push_back(cursor);
+    return result;
+}
+
+/*!
+    \class QPlatformCursor
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformCursor class provides information about
+    pointer device events (movement, buttons), and requests to change
+    the currently displayed cursor.
+
+    Note that QPlatformCursor does not include any graphics for
+    display. An application that sets a QCursor may provide its own
+    graphics.
+
+    \sa QPlatformCursorImage
+*/
+
+/*!
+    \fn virtual void QPlatformCursor::pointerEvent(const QMouseEvent & event)
+
+    This method is called by Qt whenever a QMouseEvent is generated by the
+    underlying pointer input. \a event is a reference to the QMouseEvent in
+    question. A default do-nothing implementation is provided.
+*/
+
+/*!
+    \fn virtual void QPlatformCursor::changeCursor(QCursor * windowCursor, QWindow * window)
+
+    \brief This method is called by Qt whenever the cursor graphic should be changed.
+
+    Implementation of this method is mandatory for a subclass of QPlatformCursor.
+
+    \a windowCursor is a pointer to the QCursor that should be displayed.
+
+    \a window is a pointer to the window currently displayed at QCursor::pos(). Note
+    that this may be 0 if the current position is not occupied by a displayed widget.
+
+    \sa QCursor::pos()
+*/
+
+/*!
+    \fn QPlatformCursor::QPlatformCursor(QPlatformScreen *screen)
+
+    Constructs a QPlatformCursor for the given \a screen.
+*/
+QPlatformCursor::QPlatformCursor()
+{
+}
+
+QPoint QPlatformCursor::pos() const
+{
+    // As a fallback return the last mouse position seen by QGuiApplication.
+    return QGuiApplicationPrivate::lastCursorPosition.toPoint();
+}
+
+void QPlatformCursor::setPos(const QPoint &pos)
+{
+    Q_UNUSED(pos);
+    qWarning("This plugin does not support QCursor::setPos()");
+}
+
+// End of display and pointer event handling code
+// Beginning of built-in cursor graphics
+// from src/gui/embedded/QGraphicsSystemCursorImage_qws.cpp
+
+/*!
+    \class QPlatformCursorImage
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformCursorImage class provides a set of graphics
+    intended to be used as cursors.
+
+    \sa QPlatformCursor
+*/
+
+static QPlatformCursorImage *systemCursorTable[Qt::LastCursor+1];
+static bool systemCursorTableInit = false;
+
+// 16 x 16
+static const uchar cur_arrow_bits[] = {
+   0x07, 0x00, 0x39, 0x00, 0xc1, 0x01, 0x02, 0x0e, 0x02, 0x10, 0x02, 0x08,
+   0x04, 0x04, 0x04, 0x02, 0x04, 0x04, 0x88, 0x08, 0x48, 0x11, 0x28, 0x22,
+   0x10, 0x44, 0x00, 0x28, 0x00, 0x10, 0x00, 0x00 };
+static const uchar mcur_arrow_bits[] = {
+   0x07, 0x00, 0x3f, 0x00, 0xff, 0x01, 0xfe, 0x0f, 0xfe, 0x1f, 0xfe, 0x0f,
+   0xfc, 0x07, 0xfc, 0x03, 0xfc, 0x07, 0xf8, 0x0f, 0x78, 0x1f, 0x38, 0x3e,
+   0x10, 0x7c, 0x00, 0x38, 0x00, 0x10, 0x00, 0x00 };
+
+static const unsigned char cur_up_arrow_bits[] = {
+   0x80, 0x00, 0x40, 0x01, 0x40, 0x01, 0x20, 0x02, 0x20, 0x02, 0x10, 0x04,
+   0x10, 0x04, 0x08, 0x08, 0x78, 0x0f, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01,
+   0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0xc0, 0x01};
+static const unsigned char mcur_up_arrow_bits[] = {
+   0x80, 0x00, 0xc0, 0x01, 0xc0, 0x01, 0xe0, 0x03, 0xe0, 0x03, 0xf0, 0x07,
+   0xf0, 0x07, 0xf8, 0x0f, 0xf8, 0x0f, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
+   0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01};
+
+static const unsigned char cur_cross_bits[] = {
+   0xc0, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01,
+   0x7f, 0x7f, 0x01, 0x40, 0x7f, 0x7f, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01,
+   0x40, 0x01, 0x40, 0x01, 0xc0, 0x01, 0x00, 0x00};
+static const unsigned char mcur_cross_bits[] = {
+   0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
+   0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
+   0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0x00, 0x00};
+
+static const uchar cur_ibeam_bits[] = {
+   0x00, 0x00, 0xe0, 0x03, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00,
+   0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00,
+   0x80, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00 };
+static const uchar mcur_ibeam_bits[] = {
+   0xf0, 0x07, 0xf0, 0x07, 0xf0, 0x07, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
+   0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
+   0xf0, 0x07, 0xf0, 0x07, 0xf0, 0x07, 0x00, 0x00 };
+
+static const uchar cur_ver_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0xc0, 0x03, 0xe0, 0x07, 0xf0, 0x0f,
+    0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0xf0, 0x0f,
+    0xe0, 0x07, 0xc0, 0x03, 0x80, 0x01, 0x00, 0x00 };
+static const uchar mcur_ver_bits[] = {
+    0x00, 0x00, 0x80, 0x03, 0xc0, 0x07, 0xe0, 0x0f, 0xf0, 0x1f, 0xf8, 0x3f,
+    0xfc, 0x7f, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0xfc, 0x7f, 0xf8, 0x3f,
+    0xf0, 0x1f, 0xe0, 0x0f, 0xc0, 0x07, 0x80, 0x03 };
+
+static const uchar cur_hor_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x08, 0x30, 0x18,
+    0x38, 0x38, 0xfc, 0x7f, 0xfc, 0x7f, 0x38, 0x38, 0x30, 0x18, 0x20, 0x08,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const uchar mcur_hor_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x60, 0x0c, 0x70, 0x1c, 0x78, 0x3c,
+    0xfc, 0x7f, 0xfe, 0xff, 0xfe, 0xff, 0xfe, 0xff, 0xfc, 0x7f, 0x78, 0x3c,
+    0x70, 0x1c, 0x60, 0x0c, 0x40, 0x04, 0x00, 0x00 };
+static const uchar cur_bdiag_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x3e, 0x00, 0x3c, 0x00, 0x3e,
+    0x00, 0x37, 0x88, 0x23, 0xd8, 0x01, 0xf8, 0x00, 0x78, 0x00, 0xf8, 0x00,
+    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const uchar mcur_bdiag_bits[] = {
+    0x00, 0x00, 0xc0, 0x7f, 0x80, 0x7f, 0x00, 0x7f, 0x00, 0x7e, 0x04, 0x7f,
+    0x8c, 0x7f, 0xdc, 0x77, 0xfc, 0x63, 0xfc, 0x41, 0xfc, 0x00, 0xfc, 0x01,
+    0xfc, 0x03, 0xfc, 0x07, 0x00, 0x00, 0x00, 0x00 };
+static const uchar cur_fdiag_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x01, 0xf8, 0x00, 0x78, 0x00,
+    0xf8, 0x00, 0xd8, 0x01, 0x88, 0x23, 0x00, 0x37, 0x00, 0x3e, 0x00, 0x3c,
+    0x00, 0x3e, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00 };
+static const uchar mcur_fdiag_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0xfc, 0x07, 0xfc, 0x03, 0xfc, 0x01, 0xfc, 0x00,
+    0xfc, 0x41, 0xfc, 0x63, 0xdc, 0x77, 0x8c, 0x7f, 0x04, 0x7f, 0x00, 0x7e,
+    0x00, 0x7f, 0x80, 0x7f, 0xc0, 0x7f, 0x00, 0x00 };
+
+// 20 x 20
+static const uchar forbidden_bits[] = {
+    0x00,0x00,0x00,0x80,0x1f,0x00,0xe0,0x7f,0x00,0xf0,0xf0,0x00,0x38,0xc0,0x01,
+    0x7c,0x80,0x03,0xec,0x00,0x03,0xce,0x01,0x07,0x86,0x03,0x06,0x06,0x07,0x06,
+    0x06,0x0e,0x06,0x06,0x1c,0x06,0x0e,0x38,0x07,0x0c,0x70,0x03,0x1c,0xe0,0x03,
+    0x38,0xc0,0x01,0xf0,0xe0,0x00,0xe0,0x7f,0x00,0x80,0x1f,0x00,0x00,0x00,0x00 };
+
+static const uchar forbiddenm_bits[] = {
+    0x80,0x1f,0x00,0xe0,0x7f,0x00,0xf0,0xff,0x00,0xf8,0xff,0x01,0xfc,0xf0,0x03,
+    0xfe,0xc0,0x07,0xfe,0x81,0x07,0xff,0x83,0x0f,0xcf,0x07,0x0f,0x8f,0x0f,0x0f,
+    0x0f,0x1f,0x0f,0x0f,0x3e,0x0f,0x1f,0xfc,0x0f,0x1e,0xf8,0x07,0x3e,0xf0,0x07,
+    0xfc,0xe0,0x03,0xf8,0xff,0x01,0xf0,0xff,0x00,0xe0,0x7f,0x00,0x80,0x1f,0x00};
+
+// 32 x 32
+static const uchar wait_data_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x7f, 0x00,
+   0x00, 0x04, 0x40, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0x08, 0x20, 0x00,
+   0x00, 0x08, 0x20, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x08, 0x20, 0x00,
+   0x00, 0x50, 0x15, 0x00, 0x00, 0xa0, 0x0a, 0x00, 0x00, 0x40, 0x05, 0x00,
+   0x00, 0x80, 0x02, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x20, 0x08, 0x00,
+   0x00, 0x10, 0x10, 0x00, 0x00, 0x08, 0x21, 0x00, 0x00, 0x88, 0x22, 0x00,
+   0x00, 0x48, 0x25, 0x00, 0x00, 0xa8, 0x2a, 0x00, 0x00, 0xfc, 0x7f, 0x00,
+   0x00, 0x04, 0x40, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const uchar wait_mask_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x7f, 0x00,
+   0x00, 0xfc, 0x7f, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0xf8, 0x3f, 0x00,
+   0x00, 0xf8, 0x3f, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0xf8, 0x3f, 0x00,
+   0x00, 0xf0, 0x1f, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0xc0, 0x07, 0x00,
+   0x00, 0x80, 0x03, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0xe0, 0x0f, 0x00,
+   0x00, 0xf0, 0x1f, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0xf8, 0x3f, 0x00,
+   0x00, 0xf8, 0x3f, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0xfc, 0x7f, 0x00,
+   0x00, 0xfc, 0x7f, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static const uchar hsplit_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00,
+    0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00,
+    0x00, 0x41, 0x82, 0x00, 0x80, 0x41, 0x82, 0x01, 0xc0, 0x7f, 0xfe, 0x03,
+    0x80, 0x41, 0x82, 0x01, 0x00, 0x41, 0x82, 0x00, 0x00, 0x40, 0x02, 0x00,
+    0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00,
+    0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const uchar hsplitm_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
+    0x00, 0xe0, 0x07, 0x00, 0x00, 0xe2, 0x47, 0x00, 0x00, 0xe3, 0xc7, 0x00,
+    0x80, 0xe3, 0xc7, 0x01, 0xc0, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0x07,
+    0xc0, 0xff, 0xff, 0x03, 0x80, 0xe3, 0xc7, 0x01, 0x00, 0xe3, 0xc7, 0x00,
+    0x00, 0xe2, 0x47, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
+    0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const uchar vsplit_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x80, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00,
+    0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
+    0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00,
+    0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
+    0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00,
+    0x00, 0xc0, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const uchar vsplitm_bits[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
+    0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf0, 0x07, 0x00,
+    0x00, 0xf8, 0x0f, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00,
+    0x00, 0xc0, 0x01, 0x00, 0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00,
+    0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00,
+    0x80, 0xff, 0xff, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00,
+    0x00, 0xc0, 0x01, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x07, 0x00,
+    0x00, 0xe0, 0x03, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const uchar phand_bits[] = {
+    0x00, 0x00, 0x00, 0x00,        0xfe, 0x01, 0x00, 0x00,        0x01, 0x02, 0x00, 0x00,
+    0x7e, 0x04, 0x00, 0x00,        0x08, 0x08, 0x00, 0x00,        0x70, 0x08, 0x00, 0x00,
+    0x08, 0x08, 0x00, 0x00,        0x70, 0x14, 0x00, 0x00,        0x08, 0x22, 0x00, 0x00,
+    0x30, 0x41, 0x00, 0x00,        0xc0, 0x20, 0x00, 0x00,        0x40, 0x12, 0x00, 0x00,
+    0x80, 0x08, 0x00, 0x00,        0x00, 0x05, 0x00, 0x00,        0x00, 0x02, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00 };
+static const uchar phandm_bits[] = {
+    0xfe, 0x01, 0x00, 0x00,        0xff, 0x03, 0x00, 0x00,        0xff, 0x07, 0x00, 0x00,
+    0xff, 0x0f, 0x00, 0x00,        0xfe, 0x1f, 0x00, 0x00,        0xf8, 0x1f, 0x00, 0x00,
+    0xfc, 0x1f, 0x00, 0x00,        0xf8, 0x3f, 0x00, 0x00,        0xfc, 0x7f, 0x00, 0x00,
+    0xf8, 0xff, 0x00, 0x00,        0xf0, 0x7f, 0x00, 0x00,        0xe0, 0x3f, 0x00, 0x00,
+    0xc0, 0x1f, 0x00, 0x00,        0x80, 0x0f, 0x00, 0x00,        0x00, 0x07, 0x00, 0x00,
+    0x00, 0x02, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00 };
+
+static const uchar size_all_data_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x80, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00,
+   0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
+   0x00, 0x80, 0x00, 0x00, 0x00, 0x81, 0x40, 0x00, 0x80, 0x81, 0xc0, 0x00,
+   0xc0, 0xff, 0xff, 0x01, 0x80, 0x81, 0xc0, 0x00, 0x00, 0x81, 0x40, 0x00,
+   0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
+   0x00, 0x80, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xc0, 0x01, 0x00,
+   0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const uchar size_all_mask_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
+   0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf0, 0x07, 0x00,
+   0x00, 0xf8, 0x0f, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc2, 0x21, 0x00,
+   0x00, 0xc3, 0x61, 0x00, 0x80, 0xc3, 0xe1, 0x00, 0xc0, 0xff, 0xff, 0x01,
+   0xe0, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff, 0x01, 0x80, 0xc3, 0xe1, 0x00,
+   0x00, 0xc3, 0x61, 0x00, 0x00, 0xc2, 0x21, 0x00, 0x00, 0xc0, 0x01, 0x00,
+   0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0xe0, 0x03, 0x00,
+   0x00, 0xc0, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static const uchar whatsthis_bits[] = {
+   0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0xf0, 0x07, 0x00,
+   0x09, 0x18, 0x0e, 0x00, 0x11, 0x1c, 0x0e, 0x00, 0x21, 0x1c, 0x0e, 0x00,
+   0x41, 0x1c, 0x0e, 0x00, 0x81, 0x1c, 0x0e, 0x00, 0x01, 0x01, 0x07, 0x00,
+   0x01, 0x82, 0x03, 0x00, 0xc1, 0xc7, 0x01, 0x00, 0x49, 0xc0, 0x01, 0x00,
+   0x95, 0xc0, 0x01, 0x00, 0x93, 0xc0, 0x01, 0x00, 0x21, 0x01, 0x00, 0x00,
+   0x20, 0xc1, 0x01, 0x00, 0x40, 0xc2, 0x01, 0x00, 0x40, 0x02, 0x00, 0x00,
+   0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
+static const uchar whatsthism_bits[] = {
+   0x01, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x07, 0x00, 0x07, 0xf8, 0x0f, 0x00,
+   0x0f, 0xfc, 0x1f, 0x00, 0x1f, 0x3e, 0x1f, 0x00, 0x3f, 0x3e, 0x1f, 0x00,
+   0x7f, 0x3e, 0x1f, 0x00, 0xff, 0x3e, 0x1f, 0x00, 0xff, 0x9d, 0x0f, 0x00,
+   0xff, 0xc3, 0x07, 0x00, 0xff, 0xe7, 0x03, 0x00, 0x7f, 0xe0, 0x03, 0x00,
+   0xf7, 0xe0, 0x03, 0x00, 0xf3, 0xe0, 0x03, 0x00, 0xe1, 0xe1, 0x03, 0x00,
+   0xe0, 0xe1, 0x03, 0x00, 0xc0, 0xe3, 0x03, 0x00, 0xc0, 0xe3, 0x03, 0x00,
+   0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
+
+static const uchar busy_bits[] = {
+    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
+    0x09, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
+    0x41, 0xe0, 0xff, 0x00, 0x81, 0x20, 0x80, 0x00, 0x01, 0xe1, 0xff, 0x00,
+    0x01, 0x42, 0x40, 0x00, 0xc1, 0x47, 0x40, 0x00, 0x49, 0x40, 0x55, 0x00,
+    0x95, 0x80, 0x2a, 0x00, 0x93, 0x00, 0x15, 0x00, 0x21, 0x01, 0x0a, 0x00,
+    0x20, 0x01, 0x11, 0x00, 0x40, 0x82, 0x20, 0x00, 0x40, 0x42, 0x44, 0x00,
+    0x80, 0x41, 0x4a, 0x00, 0x00, 0x40, 0x55, 0x00, 0x00, 0xe0, 0xff, 0x00,
+    0x00, 0x20, 0x80, 0x00, 0x00, 0xe0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+static const uchar busym_bits[] = {
+    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
+    0x0f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00,
+    0x7f, 0xe0, 0xff, 0x00, 0xff, 0xe0, 0xff, 0x00, 0xff, 0xe1, 0xff, 0x00,
+    0xff, 0xc3, 0x7f, 0x00, 0xff, 0xc7, 0x7f, 0x00, 0x7f, 0xc0, 0x7f, 0x00,
+    0xf7, 0x80, 0x3f, 0x00, 0xf3, 0x00, 0x1f, 0x00, 0xe1, 0x01, 0x0e, 0x00,
+    0xe0, 0x01, 0x1f, 0x00, 0xc0, 0x83, 0x3f, 0x00, 0xc0, 0xc3, 0x7f, 0x00,
+    0x80, 0xc1, 0x7f, 0x00, 0x00, 0xc0, 0x7f, 0x00, 0x00, 0xe0, 0xff, 0x00,
+    0x00, 0xe0, 0xff, 0x00, 0x00, 0xe0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+// 16 x 16
+static const uchar openhand_bits[] = {
+    0x80,0x01,0x58,0x0e,0x64,0x12,0x64,0x52,0x48,0xb2,0x48,0x92,
+    0x16,0x90,0x19,0x80,0x11,0x40,0x02,0x40,0x04,0x40,0x04,0x20,
+    0x08,0x20,0x10,0x10,0x20,0x10,0x00,0x00};
+static const uchar openhandm_bits[] = {
+    0x80,0x01,0xd8,0x0f,0xfc,0x1f,0xfc,0x5f,0xf8,0xff,0xf8,0xff,
+    0xfe,0xff,0xff,0xff,0xff,0x7f,0xfe,0x7f,0xfc,0x7f,0xfc,0x3f,
+    0xf8,0x3f,0xf0,0x1f,0xe0,0x1f,0x00,0x00};
+static const uchar closedhand_bits[] = {
+    0x00,0x00,0x00,0x00,0x00,0x00,0xb0,0x0d,0x48,0x32,0x08,0x50,
+    0x10,0x40,0x18,0x40,0x04,0x40,0x04,0x20,0x08,0x20,0x10,0x10,
+    0x20,0x10,0x20,0x10,0x00,0x00,0x00,0x00};
+static const uchar closedhandm_bits[] = {
+    0x00,0x00,0x00,0x00,0x00,0x00,0xb0,0x0d,0xf8,0x3f,0xf8,0x7f,
+    0xf0,0x7f,0xf8,0x7f,0xfc,0x7f,0xfc,0x3f,0xf8,0x3f,0xf0,0x1f,
+    0xe0,0x1f,0xe0,0x1f,0x00,0x00,0x00,0x00};
+
+void QPlatformCursorImage::createSystemCursor(int id)
+{
+    if (!systemCursorTableInit) {
+        for (int i = 0; i <= Qt::LastCursor; i++)
+            systemCursorTable[i] = 0;
+        systemCursorTableInit = true;
+    }
+    switch (id) {
+        // 16x16 cursors
+        case Qt::ArrowCursor:
+            systemCursorTable[Qt::ArrowCursor] =
+                new QPlatformCursorImage(cur_arrow_bits, mcur_arrow_bits, 16, 16, 0, 0);
+            break;
+
+        case Qt::UpArrowCursor:
+            systemCursorTable[Qt::UpArrowCursor] =
+                new QPlatformCursorImage(cur_up_arrow_bits, mcur_up_arrow_bits, 16, 16, 7, 0);
+            break;
+
+        case Qt::CrossCursor:
+            systemCursorTable[Qt::CrossCursor] =
+                new QPlatformCursorImage(cur_cross_bits, mcur_cross_bits, 16, 16, 7, 7);
+            break;
+
+        case Qt::IBeamCursor:
+            systemCursorTable[Qt::IBeamCursor] =
+                new QPlatformCursorImage(cur_ibeam_bits, mcur_ibeam_bits, 16, 16, 7, 7);
+            break;
+
+        case Qt::SizeVerCursor:
+            systemCursorTable[Qt::SizeVerCursor] =
+                new QPlatformCursorImage(cur_ver_bits, mcur_ver_bits, 16, 16, 7, 7);
+            break;
+
+        case Qt::SizeHorCursor:
+            systemCursorTable[Qt::SizeHorCursor] =
+                new QPlatformCursorImage(cur_hor_bits, mcur_hor_bits, 16, 16, 7, 7);
+            break;
+
+        case Qt::SizeBDiagCursor:
+            systemCursorTable[Qt::SizeBDiagCursor] =
+                new QPlatformCursorImage(cur_bdiag_bits, mcur_bdiag_bits, 16, 16, 7, 7);
+            break;
+
+        case Qt::SizeFDiagCursor:
+            systemCursorTable[Qt::SizeFDiagCursor] =
+                new QPlatformCursorImage(cur_fdiag_bits, mcur_fdiag_bits, 16, 16, 7, 7);
+            break;
+
+        case Qt::BlankCursor:
+            systemCursorTable[Qt::BlankCursor] =
+                new QPlatformCursorImage(0, 0, 0, 0, 0, 0);
+            break;
+
+        // 20x20 cursors
+        case Qt::ForbiddenCursor:
+            systemCursorTable[Qt::ForbiddenCursor] =
+                new QPlatformCursorImage(forbidden_bits, forbiddenm_bits, 20, 20, 10, 10);
+            break;
+
+        // 32x32 cursors
+        case Qt::WaitCursor:
+            systemCursorTable[Qt::WaitCursor] =
+                new QPlatformCursorImage(wait_data_bits, wait_mask_bits, 32, 32, 15, 15);
+            break;
+
+        case Qt::SplitVCursor:
+            systemCursorTable[Qt::SplitVCursor] =
+                new QPlatformCursorImage(vsplit_bits, vsplitm_bits, 32, 32, 15, 15);
+            break;
+
+        case Qt::SplitHCursor:
+            systemCursorTable[Qt::SplitHCursor] =
+                new QPlatformCursorImage(hsplit_bits, hsplitm_bits, 32, 32, 15, 15);
+            break;
+
+        case Qt::SizeAllCursor:
+            systemCursorTable[Qt::SizeAllCursor] =
+                new QPlatformCursorImage(size_all_data_bits, size_all_mask_bits, 32, 32, 15, 15);
+            break;
+
+        case Qt::PointingHandCursor:
+            systemCursorTable[Qt::PointingHandCursor] =
+                new QPlatformCursorImage(phand_bits, phandm_bits, 32, 32, 0, 0);
+            break;
+
+        case Qt::WhatsThisCursor:
+            systemCursorTable[Qt::WhatsThisCursor] =
+                new QPlatformCursorImage(whatsthis_bits, whatsthism_bits, 32, 32, 0, 0);
+            break;
+        case Qt::BusyCursor:
+            systemCursorTable[Qt::BusyCursor] =
+                new QPlatformCursorImage(busy_bits, busym_bits, 32, 32, 0, 0);
+            break;
+
+        case Qt::OpenHandCursor:
+            systemCursorTable[Qt::OpenHandCursor] =
+                new QPlatformCursorImage(openhand_bits, openhandm_bits, 16, 16, 8, 8);
+            break;
+        case Qt::ClosedHandCursor:
+            systemCursorTable[Qt::ClosedHandCursor] =
+                new QPlatformCursorImage(closedhand_bits, closedhandm_bits, 16, 16, 8, 8);
+            break;
+        default:
+            qWarning("Unknown system cursor %d", id);
+    }
+}
+
+/*!
+    \fn void QPlatformCursorImage::set(Qt::CursorShape id)
+
+    \brief Calling this method sets the cursor image to the specified shape
+
+    \a id is one of the defined Qt::CursorShape values.
+
+    If id is invalid, Qt::BitmapCursor, or unknown by the implementation,
+    Qt::ArrowCursor is used instead.
+*/
+
+void QPlatformCursorImage::set(Qt::CursorShape id)
+{
+    QPlatformCursorImage *cursor = 0;
+    if (id >= 0 && id <= Qt::LastCursor) {
+        if (!systemCursorTable[id])
+            createSystemCursor(id);
+        cursor = systemCursorTable[id];
+    }
+
+    if (cursor == 0) {
+        if (!systemCursorTable[Qt::ArrowCursor])
+            createSystemCursor(Qt::ArrowCursor);
+        cursor = systemCursorTable[Qt::ArrowCursor];
+    }
+    cursorImage = cursor->cursorImage;
+    hot = cursor->hot;
+}
+
+/*!
+    Sets the cursor image to the given \a image, with the hotspot at the
+    point specified by (\a hx, \a hy).
+*/
+
+void QPlatformCursorImage::set(const QImage &image, int hx, int hy)
+{
+    hot.setX(hx);
+    hot.setY(hy);
+    cursorImage = image;
+}
+
+/*!
+    \fn void QPlatformCursorImage::set(const uchar *data, const uchar *mask, int width, int height, int hx, int hy)
+
+    Sets the cursor image to the graphic represented by the combination of
+    \a data and \a mask, with dimensions given by \a width and \a height and a
+    hotspot at the point specified by (\a hx, \a hy).
+
+    The image data specified by \a data must be supplied in the format
+    described by QImage::Format_Indexed8.
+
+    The corresponding mask data specified by \a mask must be supplied in a
+    character array containing packed 1 bit per pixel format data, with any
+    padding bits at the end of the array. Bits of value 0 represent transparent
+    pixels in the image data.
+*/
+void QPlatformCursorImage::set(const uchar *data, const uchar *mask,
+                    int width, int height, int hx, int hy)
+{
+    hot.setX(hx);
+    hot.setY(hy);
+
+    cursorImage = QImage(width,height, QImage::Format_Indexed8);
+
+    if (!width || !height || !data || !mask || cursorImage.isNull())
+        return;
+
+    cursorImage.setColorCount(3);
+    cursorImage.setColor(0, 0xff000000);
+    cursorImage.setColor(1, 0xffffffff);
+    cursorImage.setColor(2, 0x00000000);
+
+    int bytesPerLine = (width + 7) / 8;
+    int p = 0;
+    int d, m;
+
+    int x = -1, w = 0;
+
+    uchar *cursor_data = cursorImage.bits();
+    int bpl = cursorImage.bytesPerLine();
+    for (int i = 0; i < height; i++)
+    {
+        for (int j = 0; j < bytesPerLine; j++, data++, mask++)
+        {
+            for (int b = 0; b < 8 && j*8+b < width; b++)
+            {
+                d = *data & (1 << b);
+                m = *mask & (1 << b);
+                if (d && m) p = 0;
+                else if (!d && m) p = 1;
+                else p = 2;
+                cursor_data[j*8+b] = p;
+
+                // calc region
+                if (x < 0 && m)
+                    x = j*8+b;
+                else if (x >= 0 && !m) {
+                    x = -1;
+                    w = 0;
+                }
+                if (m)
+                    w++;
+            }
+        }
+        if (x >= 0) {
+            x = -1;
+            w = 0;
+        }
+        cursor_data += bpl;
+    }
+
+}
+
+/*!
+    \fn QPlatformCursorImage::QPlatformCursorImage(const uchar *data, const uchar *mask, int width, int height, int hotX, int hotY)
+
+    Sets the cursor image to the graphic represented by the combination of
+    \a data and \a mask, with dimensions given by \a width and \a height and a
+    hotspot at the point specified by (\a hotX, \a hotY).
+
+    \sa set()
+*/
+
+/*!
+  \fn QImage *QPlatformCursorImage::image()
+
+  \brief Return the cursor graphic as a pointer to a QImage
+*/
+
+/*!
+    \fn QPoint QPlatformCursorImage::hotspot()
+
+    \brief Return the cursor's hotspot
+*/
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformcursor_qpa.cpp b/src/gui/kernel/qplatformcursor_qpa.cpp
deleted file mode 100644
index 40b7967..0000000
--- a/src/gui/kernel/qplatformcursor_qpa.cpp
+++ /dev/null
@@ -1,664 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtOpenVG module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include "qplatformcursor.h"
-
-#include <QPainter>
-#include <QBitmap>
-#include <QGuiApplication>
-#include <QScreen>
-#include <qpa/qplatformscreen.h>
-#include <private/qguiapplication_p.h>
-
-#include <QDebug>
-
-QT_BEGIN_NAMESPACE
-
-QList<QPlatformCursor *> QPlatformCursorPrivate::getInstances()
-{
-    QList<QPlatformCursor *> result;
-    foreach (const QScreen *screen, QGuiApplicationPrivate::screen_list)
-        if (QPlatformCursor *cursor = screen->handle()->cursor())
-            result.push_back(cursor);
-    return result;
-}
-
-/*!
-    \class QPlatformCursor
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformCursor class provides information about
-    pointer device events (movement, buttons), and requests to change
-    the currently displayed cursor.
-
-    Note that QPlatformCursor does not include any graphics for
-    display. An application that sets a QCursor may provide its own
-    graphics.
-
-    \sa QPlatformCursorImage
-*/
-
-/*!
-    \fn virtual void QPlatformCursor::pointerEvent(const QMouseEvent & event)
-
-    This method is called by Qt whenever a QMouseEvent is generated by the
-    underlying pointer input. \a event is a reference to the QMouseEvent in
-    question. A default do-nothing implementation is provided.
-*/
-
-/*!
-    \fn virtual void QPlatformCursor::changeCursor(QCursor * windowCursor, QWindow * window)
-
-    \brief This method is called by Qt whenever the cursor graphic should be changed.
-
-    Implementation of this method is mandatory for a subclass of QPlatformCursor.
-
-    \a windowCursor is a pointer to the QCursor that should be displayed.
-
-    \a window is a pointer to the window currently displayed at QCursor::pos(). Note
-    that this may be 0 if the current position is not occupied by a displayed widget.
-
-    \sa QCursor::pos()
-*/
-
-/*!
-    \fn QPlatformCursor::QPlatformCursor(QPlatformScreen *screen)
-
-    Constructs a QPlatformCursor for the given \a screen.
-*/
-QPlatformCursor::QPlatformCursor()
-{
-}
-
-QPoint QPlatformCursor::pos() const
-{
-    // As a fallback return the last mouse position seen by QGuiApplication.
-    return QGuiApplicationPrivate::lastCursorPosition.toPoint();
-}
-
-void QPlatformCursor::setPos(const QPoint &pos)
-{
-    Q_UNUSED(pos);
-    qWarning("This plugin does not support QCursor::setPos()");
-}
-
-// End of display and pointer event handling code
-// Beginning of built-in cursor graphics
-// from src/gui/embedded/QGraphicsSystemCursorImage_qws.cpp
-
-/*!
-    \class QPlatformCursorImage
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformCursorImage class provides a set of graphics
-    intended to be used as cursors.
-
-    \sa QPlatformCursor
-*/
-
-static QPlatformCursorImage *systemCursorTable[Qt::LastCursor+1];
-static bool systemCursorTableInit = false;
-
-// 16 x 16
-static const uchar cur_arrow_bits[] = {
-   0x07, 0x00, 0x39, 0x00, 0xc1, 0x01, 0x02, 0x0e, 0x02, 0x10, 0x02, 0x08,
-   0x04, 0x04, 0x04, 0x02, 0x04, 0x04, 0x88, 0x08, 0x48, 0x11, 0x28, 0x22,
-   0x10, 0x44, 0x00, 0x28, 0x00, 0x10, 0x00, 0x00 };
-static const uchar mcur_arrow_bits[] = {
-   0x07, 0x00, 0x3f, 0x00, 0xff, 0x01, 0xfe, 0x0f, 0xfe, 0x1f, 0xfe, 0x0f,
-   0xfc, 0x07, 0xfc, 0x03, 0xfc, 0x07, 0xf8, 0x0f, 0x78, 0x1f, 0x38, 0x3e,
-   0x10, 0x7c, 0x00, 0x38, 0x00, 0x10, 0x00, 0x00 };
-
-static const unsigned char cur_up_arrow_bits[] = {
-   0x80, 0x00, 0x40, 0x01, 0x40, 0x01, 0x20, 0x02, 0x20, 0x02, 0x10, 0x04,
-   0x10, 0x04, 0x08, 0x08, 0x78, 0x0f, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01,
-   0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0xc0, 0x01};
-static const unsigned char mcur_up_arrow_bits[] = {
-   0x80, 0x00, 0xc0, 0x01, 0xc0, 0x01, 0xe0, 0x03, 0xe0, 0x03, 0xf0, 0x07,
-   0xf0, 0x07, 0xf8, 0x0f, 0xf8, 0x0f, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
-   0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01};
-
-static const unsigned char cur_cross_bits[] = {
-   0xc0, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01,
-   0x7f, 0x7f, 0x01, 0x40, 0x7f, 0x7f, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01,
-   0x40, 0x01, 0x40, 0x01, 0xc0, 0x01, 0x00, 0x00};
-static const unsigned char mcur_cross_bits[] = {
-   0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
-   0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
-   0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0x00, 0x00};
-
-static const uchar cur_ibeam_bits[] = {
-   0x00, 0x00, 0xe0, 0x03, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00,
-   0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00,
-   0x80, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00 };
-static const uchar mcur_ibeam_bits[] = {
-   0xf0, 0x07, 0xf0, 0x07, 0xf0, 0x07, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
-   0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01,
-   0xf0, 0x07, 0xf0, 0x07, 0xf0, 0x07, 0x00, 0x00 };
-
-static const uchar cur_ver_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0xc0, 0x03, 0xe0, 0x07, 0xf0, 0x0f,
-    0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0xf0, 0x0f,
-    0xe0, 0x07, 0xc0, 0x03, 0x80, 0x01, 0x00, 0x00 };
-static const uchar mcur_ver_bits[] = {
-    0x00, 0x00, 0x80, 0x03, 0xc0, 0x07, 0xe0, 0x0f, 0xf0, 0x1f, 0xf8, 0x3f,
-    0xfc, 0x7f, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0xfc, 0x7f, 0xf8, 0x3f,
-    0xf0, 0x1f, 0xe0, 0x0f, 0xc0, 0x07, 0x80, 0x03 };
-
-static const uchar cur_hor_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x08, 0x30, 0x18,
-    0x38, 0x38, 0xfc, 0x7f, 0xfc, 0x7f, 0x38, 0x38, 0x30, 0x18, 0x20, 0x08,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static const uchar mcur_hor_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x60, 0x0c, 0x70, 0x1c, 0x78, 0x3c,
-    0xfc, 0x7f, 0xfe, 0xff, 0xfe, 0xff, 0xfe, 0xff, 0xfc, 0x7f, 0x78, 0x3c,
-    0x70, 0x1c, 0x60, 0x0c, 0x40, 0x04, 0x00, 0x00 };
-static const uchar cur_bdiag_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x3e, 0x00, 0x3c, 0x00, 0x3e,
-    0x00, 0x37, 0x88, 0x23, 0xd8, 0x01, 0xf8, 0x00, 0x78, 0x00, 0xf8, 0x00,
-    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static const uchar mcur_bdiag_bits[] = {
-    0x00, 0x00, 0xc0, 0x7f, 0x80, 0x7f, 0x00, 0x7f, 0x00, 0x7e, 0x04, 0x7f,
-    0x8c, 0x7f, 0xdc, 0x77, 0xfc, 0x63, 0xfc, 0x41, 0xfc, 0x00, 0xfc, 0x01,
-    0xfc, 0x03, 0xfc, 0x07, 0x00, 0x00, 0x00, 0x00 };
-static const uchar cur_fdiag_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x01, 0xf8, 0x00, 0x78, 0x00,
-    0xf8, 0x00, 0xd8, 0x01, 0x88, 0x23, 0x00, 0x37, 0x00, 0x3e, 0x00, 0x3c,
-    0x00, 0x3e, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00 };
-static const uchar mcur_fdiag_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0xfc, 0x07, 0xfc, 0x03, 0xfc, 0x01, 0xfc, 0x00,
-    0xfc, 0x41, 0xfc, 0x63, 0xdc, 0x77, 0x8c, 0x7f, 0x04, 0x7f, 0x00, 0x7e,
-    0x00, 0x7f, 0x80, 0x7f, 0xc0, 0x7f, 0x00, 0x00 };
-
-// 20 x 20
-static const uchar forbidden_bits[] = {
-    0x00,0x00,0x00,0x80,0x1f,0x00,0xe0,0x7f,0x00,0xf0,0xf0,0x00,0x38,0xc0,0x01,
-    0x7c,0x80,0x03,0xec,0x00,0x03,0xce,0x01,0x07,0x86,0x03,0x06,0x06,0x07,0x06,
-    0x06,0x0e,0x06,0x06,0x1c,0x06,0x0e,0x38,0x07,0x0c,0x70,0x03,0x1c,0xe0,0x03,
-    0x38,0xc0,0x01,0xf0,0xe0,0x00,0xe0,0x7f,0x00,0x80,0x1f,0x00,0x00,0x00,0x00 };
-
-static const uchar forbiddenm_bits[] = {
-    0x80,0x1f,0x00,0xe0,0x7f,0x00,0xf0,0xff,0x00,0xf8,0xff,0x01,0xfc,0xf0,0x03,
-    0xfe,0xc0,0x07,0xfe,0x81,0x07,0xff,0x83,0x0f,0xcf,0x07,0x0f,0x8f,0x0f,0x0f,
-    0x0f,0x1f,0x0f,0x0f,0x3e,0x0f,0x1f,0xfc,0x0f,0x1e,0xf8,0x07,0x3e,0xf0,0x07,
-    0xfc,0xe0,0x03,0xf8,0xff,0x01,0xf0,0xff,0x00,0xe0,0x7f,0x00,0x80,0x1f,0x00};
-
-// 32 x 32
-static const uchar wait_data_bits[] = {
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x7f, 0x00,
-   0x00, 0x04, 0x40, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0x08, 0x20, 0x00,
-   0x00, 0x08, 0x20, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x08, 0x20, 0x00,
-   0x00, 0x50, 0x15, 0x00, 0x00, 0xa0, 0x0a, 0x00, 0x00, 0x40, 0x05, 0x00,
-   0x00, 0x80, 0x02, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x20, 0x08, 0x00,
-   0x00, 0x10, 0x10, 0x00, 0x00, 0x08, 0x21, 0x00, 0x00, 0x88, 0x22, 0x00,
-   0x00, 0x48, 0x25, 0x00, 0x00, 0xa8, 0x2a, 0x00, 0x00, 0xfc, 0x7f, 0x00,
-   0x00, 0x04, 0x40, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static const uchar wait_mask_bits[] = {
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x7f, 0x00,
-   0x00, 0xfc, 0x7f, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0xf8, 0x3f, 0x00,
-   0x00, 0xf8, 0x3f, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0xf8, 0x3f, 0x00,
-   0x00, 0xf0, 0x1f, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0xc0, 0x07, 0x00,
-   0x00, 0x80, 0x03, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0xe0, 0x0f, 0x00,
-   0x00, 0xf0, 0x1f, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0xf8, 0x3f, 0x00,
-   0x00, 0xf8, 0x3f, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0xfc, 0x7f, 0x00,
-   0x00, 0xfc, 0x7f, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-
-static const uchar hsplit_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00,
-    0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00,
-    0x00, 0x41, 0x82, 0x00, 0x80, 0x41, 0x82, 0x01, 0xc0, 0x7f, 0xfe, 0x03,
-    0x80, 0x41, 0x82, 0x01, 0x00, 0x41, 0x82, 0x00, 0x00, 0x40, 0x02, 0x00,
-    0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00,
-    0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static const uchar hsplitm_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
-    0x00, 0xe0, 0x07, 0x00, 0x00, 0xe2, 0x47, 0x00, 0x00, 0xe3, 0xc7, 0x00,
-    0x80, 0xe3, 0xc7, 0x01, 0xc0, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0x07,
-    0xc0, 0xff, 0xff, 0x03, 0x80, 0xe3, 0xc7, 0x01, 0x00, 0xe3, 0xc7, 0x00,
-    0x00, 0xe2, 0x47, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
-    0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static const uchar vsplit_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x80, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00,
-    0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-    0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00,
-    0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-    0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00,
-    0x00, 0xc0, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static const uchar vsplitm_bits[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-    0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf0, 0x07, 0x00,
-    0x00, 0xf8, 0x0f, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00,
-    0x00, 0xc0, 0x01, 0x00, 0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00,
-    0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00,
-    0x80, 0xff, 0xff, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00,
-    0x00, 0xc0, 0x01, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x07, 0x00,
-    0x00, 0xe0, 0x03, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static const uchar phand_bits[] = {
-    0x00, 0x00, 0x00, 0x00,        0xfe, 0x01, 0x00, 0x00,        0x01, 0x02, 0x00, 0x00,
-    0x7e, 0x04, 0x00, 0x00,        0x08, 0x08, 0x00, 0x00,        0x70, 0x08, 0x00, 0x00,
-    0x08, 0x08, 0x00, 0x00,        0x70, 0x14, 0x00, 0x00,        0x08, 0x22, 0x00, 0x00,
-    0x30, 0x41, 0x00, 0x00,        0xc0, 0x20, 0x00, 0x00,        0x40, 0x12, 0x00, 0x00,
-    0x80, 0x08, 0x00, 0x00,        0x00, 0x05, 0x00, 0x00,        0x00, 0x02, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00 };
-static const uchar phandm_bits[] = {
-    0xfe, 0x01, 0x00, 0x00,        0xff, 0x03, 0x00, 0x00,        0xff, 0x07, 0x00, 0x00,
-    0xff, 0x0f, 0x00, 0x00,        0xfe, 0x1f, 0x00, 0x00,        0xf8, 0x1f, 0x00, 0x00,
-    0xfc, 0x1f, 0x00, 0x00,        0xf8, 0x3f, 0x00, 0x00,        0xfc, 0x7f, 0x00, 0x00,
-    0xf8, 0xff, 0x00, 0x00,        0xf0, 0x7f, 0x00, 0x00,        0xe0, 0x3f, 0x00, 0x00,
-    0xc0, 0x1f, 0x00, 0x00,        0x80, 0x0f, 0x00, 0x00,        0x00, 0x07, 0x00, 0x00,
-    0x00, 0x02, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00 };
-
-static const uchar size_all_data_bits[] = {
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x80, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00,
-   0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-   0x00, 0x80, 0x00, 0x00, 0x00, 0x81, 0x40, 0x00, 0x80, 0x81, 0xc0, 0x00,
-   0xc0, 0xff, 0xff, 0x01, 0x80, 0x81, 0xc0, 0x00, 0x00, 0x81, 0x40, 0x00,
-   0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-   0x00, 0x80, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xc0, 0x01, 0x00,
-   0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static const uchar size_all_mask_bits[] = {
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
-   0x00, 0xc0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf0, 0x07, 0x00,
-   0x00, 0xf8, 0x0f, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xc2, 0x21, 0x00,
-   0x00, 0xc3, 0x61, 0x00, 0x80, 0xc3, 0xe1, 0x00, 0xc0, 0xff, 0xff, 0x01,
-   0xe0, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff, 0x01, 0x80, 0xc3, 0xe1, 0x00,
-   0x00, 0xc3, 0x61, 0x00, 0x00, 0xc2, 0x21, 0x00, 0x00, 0xc0, 0x01, 0x00,
-   0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0xe0, 0x03, 0x00,
-   0x00, 0xc0, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-
-static const uchar whatsthis_bits[] = {
-   0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0xf0, 0x07, 0x00,
-   0x09, 0x18, 0x0e, 0x00, 0x11, 0x1c, 0x0e, 0x00, 0x21, 0x1c, 0x0e, 0x00,
-   0x41, 0x1c, 0x0e, 0x00, 0x81, 0x1c, 0x0e, 0x00, 0x01, 0x01, 0x07, 0x00,
-   0x01, 0x82, 0x03, 0x00, 0xc1, 0xc7, 0x01, 0x00, 0x49, 0xc0, 0x01, 0x00,
-   0x95, 0xc0, 0x01, 0x00, 0x93, 0xc0, 0x01, 0x00, 0x21, 0x01, 0x00, 0x00,
-   0x20, 0xc1, 0x01, 0x00, 0x40, 0xc2, 0x01, 0x00, 0x40, 0x02, 0x00, 0x00,
-   0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
-static const uchar whatsthism_bits[] = {
-   0x01, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x07, 0x00, 0x07, 0xf8, 0x0f, 0x00,
-   0x0f, 0xfc, 0x1f, 0x00, 0x1f, 0x3e, 0x1f, 0x00, 0x3f, 0x3e, 0x1f, 0x00,
-   0x7f, 0x3e, 0x1f, 0x00, 0xff, 0x3e, 0x1f, 0x00, 0xff, 0x9d, 0x0f, 0x00,
-   0xff, 0xc3, 0x07, 0x00, 0xff, 0xe7, 0x03, 0x00, 0x7f, 0xe0, 0x03, 0x00,
-   0xf7, 0xe0, 0x03, 0x00, 0xf3, 0xe0, 0x03, 0x00, 0xe1, 0xe1, 0x03, 0x00,
-   0xe0, 0xe1, 0x03, 0x00, 0xc0, 0xe3, 0x03, 0x00, 0xc0, 0xe3, 0x03, 0x00,
-   0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
-
-static const uchar busy_bits[] = {
-    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
-    0x09, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
-    0x41, 0xe0, 0xff, 0x00, 0x81, 0x20, 0x80, 0x00, 0x01, 0xe1, 0xff, 0x00,
-    0x01, 0x42, 0x40, 0x00, 0xc1, 0x47, 0x40, 0x00, 0x49, 0x40, 0x55, 0x00,
-    0x95, 0x80, 0x2a, 0x00, 0x93, 0x00, 0x15, 0x00, 0x21, 0x01, 0x0a, 0x00,
-    0x20, 0x01, 0x11, 0x00, 0x40, 0x82, 0x20, 0x00, 0x40, 0x42, 0x44, 0x00,
-    0x80, 0x41, 0x4a, 0x00, 0x00, 0x40, 0x55, 0x00, 0x00, 0xe0, 0xff, 0x00,
-    0x00, 0x20, 0x80, 0x00, 0x00, 0xe0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-static const uchar busym_bits[] = {
-    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
-    0x0f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00,
-    0x7f, 0xe0, 0xff, 0x00, 0xff, 0xe0, 0xff, 0x00, 0xff, 0xe1, 0xff, 0x00,
-    0xff, 0xc3, 0x7f, 0x00, 0xff, 0xc7, 0x7f, 0x00, 0x7f, 0xc0, 0x7f, 0x00,
-    0xf7, 0x80, 0x3f, 0x00, 0xf3, 0x00, 0x1f, 0x00, 0xe1, 0x01, 0x0e, 0x00,
-    0xe0, 0x01, 0x1f, 0x00, 0xc0, 0x83, 0x3f, 0x00, 0xc0, 0xc3, 0x7f, 0x00,
-    0x80, 0xc1, 0x7f, 0x00, 0x00, 0xc0, 0x7f, 0x00, 0x00, 0xe0, 0xff, 0x00,
-    0x00, 0xe0, 0xff, 0x00, 0x00, 0xe0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-// 16 x 16
-static const uchar openhand_bits[] = {
-    0x80,0x01,0x58,0x0e,0x64,0x12,0x64,0x52,0x48,0xb2,0x48,0x92,
-    0x16,0x90,0x19,0x80,0x11,0x40,0x02,0x40,0x04,0x40,0x04,0x20,
-    0x08,0x20,0x10,0x10,0x20,0x10,0x00,0x00};
-static const uchar openhandm_bits[] = {
-    0x80,0x01,0xd8,0x0f,0xfc,0x1f,0xfc,0x5f,0xf8,0xff,0xf8,0xff,
-    0xfe,0xff,0xff,0xff,0xff,0x7f,0xfe,0x7f,0xfc,0x7f,0xfc,0x3f,
-    0xf8,0x3f,0xf0,0x1f,0xe0,0x1f,0x00,0x00};
-static const uchar closedhand_bits[] = {
-    0x00,0x00,0x00,0x00,0x00,0x00,0xb0,0x0d,0x48,0x32,0x08,0x50,
-    0x10,0x40,0x18,0x40,0x04,0x40,0x04,0x20,0x08,0x20,0x10,0x10,
-    0x20,0x10,0x20,0x10,0x00,0x00,0x00,0x00};
-static const uchar closedhandm_bits[] = {
-    0x00,0x00,0x00,0x00,0x00,0x00,0xb0,0x0d,0xf8,0x3f,0xf8,0x7f,
-    0xf0,0x7f,0xf8,0x7f,0xfc,0x7f,0xfc,0x3f,0xf8,0x3f,0xf0,0x1f,
-    0xe0,0x1f,0xe0,0x1f,0x00,0x00,0x00,0x00};
-
-void QPlatformCursorImage::createSystemCursor(int id)
-{
-    if (!systemCursorTableInit) {
-        for (int i = 0; i <= Qt::LastCursor; i++)
-            systemCursorTable[i] = 0;
-        systemCursorTableInit = true;
-    }
-    switch (id) {
-        // 16x16 cursors
-        case Qt::ArrowCursor:
-            systemCursorTable[Qt::ArrowCursor] =
-                new QPlatformCursorImage(cur_arrow_bits, mcur_arrow_bits, 16, 16, 0, 0);
-            break;
-
-        case Qt::UpArrowCursor:
-            systemCursorTable[Qt::UpArrowCursor] =
-                new QPlatformCursorImage(cur_up_arrow_bits, mcur_up_arrow_bits, 16, 16, 7, 0);
-            break;
-
-        case Qt::CrossCursor:
-            systemCursorTable[Qt::CrossCursor] =
-                new QPlatformCursorImage(cur_cross_bits, mcur_cross_bits, 16, 16, 7, 7);
-            break;
-
-        case Qt::IBeamCursor:
-            systemCursorTable[Qt::IBeamCursor] =
-                new QPlatformCursorImage(cur_ibeam_bits, mcur_ibeam_bits, 16, 16, 7, 7);
-            break;
-
-        case Qt::SizeVerCursor:
-            systemCursorTable[Qt::SizeVerCursor] =
-                new QPlatformCursorImage(cur_ver_bits, mcur_ver_bits, 16, 16, 7, 7);
-            break;
-
-        case Qt::SizeHorCursor:
-            systemCursorTable[Qt::SizeHorCursor] =
-                new QPlatformCursorImage(cur_hor_bits, mcur_hor_bits, 16, 16, 7, 7);
-            break;
-
-        case Qt::SizeBDiagCursor:
-            systemCursorTable[Qt::SizeBDiagCursor] =
-                new QPlatformCursorImage(cur_bdiag_bits, mcur_bdiag_bits, 16, 16, 7, 7);
-            break;
-
-        case Qt::SizeFDiagCursor:
-            systemCursorTable[Qt::SizeFDiagCursor] =
-                new QPlatformCursorImage(cur_fdiag_bits, mcur_fdiag_bits, 16, 16, 7, 7);
-            break;
-
-        case Qt::BlankCursor:
-            systemCursorTable[Qt::BlankCursor] =
-                new QPlatformCursorImage(0, 0, 0, 0, 0, 0);
-            break;
-
-        // 20x20 cursors
-        case Qt::ForbiddenCursor:
-            systemCursorTable[Qt::ForbiddenCursor] =
-                new QPlatformCursorImage(forbidden_bits, forbiddenm_bits, 20, 20, 10, 10);
-            break;
-
-        // 32x32 cursors
-        case Qt::WaitCursor:
-            systemCursorTable[Qt::WaitCursor] =
-                new QPlatformCursorImage(wait_data_bits, wait_mask_bits, 32, 32, 15, 15);
-            break;
-
-        case Qt::SplitVCursor:
-            systemCursorTable[Qt::SplitVCursor] =
-                new QPlatformCursorImage(vsplit_bits, vsplitm_bits, 32, 32, 15, 15);
-            break;
-
-        case Qt::SplitHCursor:
-            systemCursorTable[Qt::SplitHCursor] =
-                new QPlatformCursorImage(hsplit_bits, hsplitm_bits, 32, 32, 15, 15);
-            break;
-
-        case Qt::SizeAllCursor:
-            systemCursorTable[Qt::SizeAllCursor] =
-                new QPlatformCursorImage(size_all_data_bits, size_all_mask_bits, 32, 32, 15, 15);
-            break;
-
-        case Qt::PointingHandCursor:
-            systemCursorTable[Qt::PointingHandCursor] =
-                new QPlatformCursorImage(phand_bits, phandm_bits, 32, 32, 0, 0);
-            break;
-
-        case Qt::WhatsThisCursor:
-            systemCursorTable[Qt::WhatsThisCursor] =
-                new QPlatformCursorImage(whatsthis_bits, whatsthism_bits, 32, 32, 0, 0);
-            break;
-        case Qt::BusyCursor:
-            systemCursorTable[Qt::BusyCursor] =
-                new QPlatformCursorImage(busy_bits, busym_bits, 32, 32, 0, 0);
-            break;
-
-        case Qt::OpenHandCursor:
-            systemCursorTable[Qt::OpenHandCursor] =
-                new QPlatformCursorImage(openhand_bits, openhandm_bits, 16, 16, 8, 8);
-            break;
-        case Qt::ClosedHandCursor:
-            systemCursorTable[Qt::ClosedHandCursor] =
-                new QPlatformCursorImage(closedhand_bits, closedhandm_bits, 16, 16, 8, 8);
-            break;
-        default:
-            qWarning("Unknown system cursor %d", id);
-    }
-}
-
-/*!
-    \fn void QPlatformCursorImage::set(Qt::CursorShape id)
-
-    \brief Calling this method sets the cursor image to the specified shape
-
-    \a id is one of the defined Qt::CursorShape values.
-
-    If id is invalid, Qt::BitmapCursor, or unknown by the implementation,
-    Qt::ArrowCursor is used instead.
-*/
-
-void QPlatformCursorImage::set(Qt::CursorShape id)
-{
-    QPlatformCursorImage *cursor = 0;
-    if (id >= 0 && id <= Qt::LastCursor) {
-        if (!systemCursorTable[id])
-            createSystemCursor(id);
-        cursor = systemCursorTable[id];
-    }
-
-    if (cursor == 0) {
-        if (!systemCursorTable[Qt::ArrowCursor])
-            createSystemCursor(Qt::ArrowCursor);
-        cursor = systemCursorTable[Qt::ArrowCursor];
-    }
-    cursorImage = cursor->cursorImage;
-    hot = cursor->hot;
-}
-
-/*!
-    Sets the cursor image to the given \a image, with the hotspot at the
-    point specified by (\a hx, \a hy).
-*/
-
-void QPlatformCursorImage::set(const QImage &image, int hx, int hy)
-{
-    hot.setX(hx);
-    hot.setY(hy);
-    cursorImage = image;
-}
-
-/*!
-    \fn void QPlatformCursorImage::set(const uchar *data, const uchar *mask, int width, int height, int hx, int hy)
-
-    Sets the cursor image to the graphic represented by the combination of
-    \a data and \a mask, with dimensions given by \a width and \a height and a
-    hotspot at the point specified by (\a hx, \a hy).
-
-    The image data specified by \a data must be supplied in the format
-    described by QImage::Format_Indexed8.
-
-    The corresponding mask data specified by \a mask must be supplied in a
-    character array containing packed 1 bit per pixel format data, with any
-    padding bits at the end of the array. Bits of value 0 represent transparent
-    pixels in the image data.
-*/
-void QPlatformCursorImage::set(const uchar *data, const uchar *mask,
-                    int width, int height, int hx, int hy)
-{
-    hot.setX(hx);
-    hot.setY(hy);
-
-    cursorImage = QImage(width,height, QImage::Format_Indexed8);
-
-    if (!width || !height || !data || !mask || cursorImage.isNull())
-        return;
-
-    cursorImage.setColorCount(3);
-    cursorImage.setColor(0, 0xff000000);
-    cursorImage.setColor(1, 0xffffffff);
-    cursorImage.setColor(2, 0x00000000);
-
-    int bytesPerLine = (width + 7) / 8;
-    int p = 0;
-    int d, m;
-
-    int x = -1, w = 0;
-
-    uchar *cursor_data = cursorImage.bits();
-    int bpl = cursorImage.bytesPerLine();
-    for (int i = 0; i < height; i++)
-    {
-        for (int j = 0; j < bytesPerLine; j++, data++, mask++)
-        {
-            for (int b = 0; b < 8 && j*8+b < width; b++)
-            {
-                d = *data & (1 << b);
-                m = *mask & (1 << b);
-                if (d && m) p = 0;
-                else if (!d && m) p = 1;
-                else p = 2;
-                cursor_data[j*8+b] = p;
-
-                // calc region
-                if (x < 0 && m)
-                    x = j*8+b;
-                else if (x >= 0 && !m) {
-                    x = -1;
-                    w = 0;
-                }
-                if (m)
-                    w++;
-            }
-        }
-        if (x >= 0) {
-            x = -1;
-            w = 0;
-        }
-        cursor_data += bpl;
-    }
-
-}
-
-/*!
-    \fn QPlatformCursorImage::QPlatformCursorImage(const uchar *data, const uchar *mask, int width, int height, int hotX, int hotY)
-
-    Sets the cursor image to the graphic represented by the combination of
-    \a data and \a mask, with dimensions given by \a width and \a height and a
-    hotspot at the point specified by (\a hotX, \a hotY).
-
-    \sa set()
-*/
-
-/*!
-  \fn QImage *QPlatformCursorImage::image()
-
-  \brief Return the cursor graphic as a pointer to a QImage
-*/
-
-/*!
-    \fn QPoint QPlatformCursorImage::hotspot()
-
-    \brief Return the cursor's hotspot
-*/
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformdialoghelper.cpp b/src/gui/kernel/qplatformdialoghelper.cpp
new file mode 100644
index 0000000..f71c5e5
--- /dev/null
+++ b/src/gui/kernel/qplatformdialoghelper.cpp
@@ -0,0 +1,594 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformdialoghelper.h"
+
+#include <QtCore/QVariant>
+#include <QtCore/QSharedData>
+#include <QtCore/QSettings>
+#include <QtCore/QHash>
+#include <QtCore/QUrl>
+#include <QtGui/QColor>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformDialogHelper
+    \since 5.0
+    \internal
+    \ingroup qpa
+
+    \brief The QPlatformDialogHelper class allows for platform-specific customization of dialogs.
+
+*/
+
+/*!
+    \enum QPlatformDialogHelper::StyleHint
+
+    This enum type specifies platform-specific style hints.
+
+    \value SnapToDefaultButton Snap the mouse to the center of the default
+                               button. There is corresponding system
+                               setting on Windows.
+
+    \sa styleHint()
+*/
+
+QPlatformDialogHelper::QPlatformDialogHelper()
+{
+}
+
+QPlatformDialogHelper::~QPlatformDialogHelper()
+{
+}
+
+QVariant QPlatformDialogHelper::styleHint(StyleHint hint) const
+{
+    return QPlatformDialogHelper::defaultStyleHint(hint);
+}
+
+QVariant  QPlatformDialogHelper::defaultStyleHint(QPlatformDialogHelper::StyleHint hint)
+{
+    switch (hint) {
+    case QPlatformDialogHelper::SnapToDefaultButton:
+        return QVariant(false);
+    }
+    return QVariant();
+}
+
+// Font dialog
+
+class QFontDialogOptionsPrivate : public QSharedData
+{
+public:
+    QFontDialogOptionsPrivate() : options(0) {}
+
+    QFontDialogOptions::FontDialogOptions options;
+    QString windowTitle;
+};
+
+QFontDialogOptions::QFontDialogOptions() : d(new QFontDialogOptionsPrivate)
+{
+}
+
+QFontDialogOptions::QFontDialogOptions(const QFontDialogOptions &rhs) : d(rhs.d)
+{
+}
+
+QFontDialogOptions &QFontDialogOptions::operator=(const QFontDialogOptions &rhs)
+{
+    if (this != &rhs)
+        d = rhs.d;
+    return *this;
+}
+
+QFontDialogOptions::~QFontDialogOptions()
+{
+}
+
+QString QFontDialogOptions::windowTitle() const
+{
+    return d->windowTitle;
+}
+
+void QFontDialogOptions::setWindowTitle(const QString &title)
+{
+    d->windowTitle = title;
+}
+
+void QFontDialogOptions::setOption(QFontDialogOptions::FontDialogOption option, bool on)
+{
+    if (!(d->options & option) != !on)
+        setOptions(d->options ^ option);
+}
+
+bool QFontDialogOptions::testOption(QFontDialogOptions::FontDialogOption option) const
+{
+    return d->options & option;
+}
+
+void QFontDialogOptions::setOptions(FontDialogOptions options)
+{
+    if (options != d->options)
+        d->options = options;
+}
+
+QFontDialogOptions::FontDialogOptions QFontDialogOptions::options() const
+{
+    return d->options;
+}
+
+/*!
+    \class QPlatformFontDialogHelper
+    \since 5.0
+    \internal
+    \ingroup qpa
+
+    \brief The QPlatformFontDialogHelper class allows for platform-specific customization of font dialogs.
+
+*/
+const QSharedPointer<QFontDialogOptions> &QPlatformFontDialogHelper::options() const
+{
+    return m_options;
+}
+
+void QPlatformFontDialogHelper::setOptions(const QSharedPointer<QFontDialogOptions> &options)
+{
+    m_options = options;
+}
+
+// Color dialog
+
+class QColorDialogStaticData
+{
+public:
+    enum { CustomColorCount = 16, StandardColorCount = 6 * 8 };
+
+    QColorDialogStaticData();
+    inline void readSettings();
+    inline void writeSettings() const;
+
+    QRgb customRgb[CustomColorCount];
+    QRgb standardRgb[StandardColorCount];
+    bool customSet;
+};
+
+QColorDialogStaticData::QColorDialogStaticData() : customSet(false)
+{
+    int i = 0;
+    for (int g = 0; g < 4; ++g)
+        for (int r = 0;  r < 4; ++r)
+            for (int b = 0; b < 3; ++b)
+                standardRgb[i++] = qRgb(r * 255 / 3, g * 255 / 3, b * 255 / 2);
+    qFill(customRgb, customRgb + CustomColorCount, 0xffffffff);
+    readSettings();
+}
+
+void QColorDialogStaticData::readSettings()
+{
+#ifndef QT_NO_SETTINGS
+    const QSettings settings(QSettings::UserScope, QStringLiteral("Trolltech"));
+    for (int i = 0; i < int(CustomColorCount); ++i) {
+        const QVariant v = settings.value(QStringLiteral("Qt/customColors/") + QString::number(i));
+        if (v.isValid())
+            customRgb[i] = v.toUInt();
+    }
+#endif
+}
+
+void QColorDialogStaticData::writeSettings() const
+{
+#ifndef QT_NO_SETTINGS
+    if (!customSet) {
+        QSettings settings(QSettings::UserScope, QStringLiteral("Trolltech"));
+        for (int i = 0; i < int(CustomColorCount); ++i)
+            settings.setValue(QStringLiteral("Qt/customColors/") + QString::number(i), customRgb[i]);
+    }
+#endif
+}
+
+Q_GLOBAL_STATIC(QColorDialogStaticData, qColorDialogStaticData)
+
+class QColorDialogOptionsPrivate : public QSharedData
+{
+public:
+    QColorDialogOptionsPrivate() : options(0) {}
+    // Write out settings around destruction of dialogs
+    ~QColorDialogOptionsPrivate() { qColorDialogStaticData()->writeSettings(); }
+
+    QColorDialogOptions::ColorDialogOptions options;
+    QString windowTitle;
+};
+
+QColorDialogOptions::QColorDialogOptions() : d(new QColorDialogOptionsPrivate)
+{
+}
+
+QColorDialogOptions::QColorDialogOptions(const QColorDialogOptions &rhs) : d(rhs.d)
+{
+}
+
+QColorDialogOptions &QColorDialogOptions::operator=(const QColorDialogOptions &rhs)
+{
+    if (this != &rhs)
+        d = rhs.d;
+    return *this;
+}
+
+QColorDialogOptions::~QColorDialogOptions()
+{
+}
+
+QString QColorDialogOptions::windowTitle() const
+{
+    return d->windowTitle;
+}
+
+void QColorDialogOptions::setWindowTitle(const QString &title)
+{
+    d->windowTitle = title;
+}
+
+void QColorDialogOptions::setOption(QColorDialogOptions::ColorDialogOption option, bool on)
+{
+    if (!(d->options & option) != !on)
+        setOptions(d->options ^ option);
+}
+
+bool QColorDialogOptions::testOption(QColorDialogOptions::ColorDialogOption option) const
+{
+    return d->options & option;
+}
+
+void QColorDialogOptions::setOptions(ColorDialogOptions options)
+{
+    if (options != d->options)
+        d->options = options;
+}
+
+QColorDialogOptions::ColorDialogOptions QColorDialogOptions::options() const
+{
+    return d->options;
+}
+
+int QColorDialogOptions::customColorCount()
+{
+    return QColorDialogStaticData::CustomColorCount;
+}
+
+QRgb QColorDialogOptions::customColor(int index)
+{
+    if (uint(index) >= uint(QColorDialogStaticData::CustomColorCount))
+        return qRgb(255, 255, 255);
+    return qColorDialogStaticData()->customRgb[index];
+}
+
+QRgb *QColorDialogOptions::customColors()
+{
+    return qColorDialogStaticData()->customRgb;
+}
+
+void QColorDialogOptions::setCustomColor(int index, QRgb color)
+{
+    if (uint(index) >= uint(QColorDialogStaticData::CustomColorCount))
+        return;
+    qColorDialogStaticData()->customSet;
+    qColorDialogStaticData()->customRgb[index] = color;
+}
+
+QRgb *QColorDialogOptions::standardColors()
+{
+    return qColorDialogStaticData()->standardRgb;
+}
+
+QRgb QColorDialogOptions::standardColor(int index)
+{
+    if (uint(index) >= uint(QColorDialogStaticData::StandardColorCount))
+        return qRgb(255, 255, 255);
+    return qColorDialogStaticData()->standardRgb[index];
+}
+
+void QColorDialogOptions::setStandardColor(int index, QRgb color)
+{
+    if (uint(index) >= uint(QColorDialogStaticData::StandardColorCount))
+        return;
+    qColorDialogStaticData()->standardRgb[index] = color;
+}
+
+/*!
+    \class QPlatformColorDialogHelper
+    \since 5.0
+    \internal
+    \ingroup qpa
+
+    \brief The QPlatformColorDialogHelper class allows for platform-specific customization of color dialogs.
+
+*/
+const QSharedPointer<QColorDialogOptions> &QPlatformColorDialogHelper::options() const
+{
+    return m_options;
+}
+
+void QPlatformColorDialogHelper::setOptions(const QSharedPointer<QColorDialogOptions> &options)
+{
+    m_options = options;
+}
+
+// File dialog
+
+class QFileDialogOptionsPrivate : public QSharedData
+{
+public:
+    QFileDialogOptionsPrivate() : options(0),
+        viewMode(QFileDialogOptions::Detail),
+        fileMode(QFileDialogOptions::AnyFile),
+        acceptMode(QFileDialogOptions::AcceptOpen),
+        filters(QDir::AllEntries | QDir::NoDotAndDotDot | QDir::AllDirs)
+    {}
+
+    QFileDialogOptions::FileDialogOptions options;
+    QString windowTitle;
+
+    QFileDialogOptions::ViewMode viewMode;
+    QFileDialogOptions::FileMode fileMode;
+    QFileDialogOptions::AcceptMode acceptMode;
+    QString labels[QFileDialogOptions::DialogLabelCount];
+    QDir::Filters filters;
+    QList<QUrl> sidebarUrls;
+    QStringList nameFilters;
+    QString defaultSuffix;
+    QStringList history;
+    QString initialDirectory;
+    QString initiallySelectedNameFilter;
+    QStringList initiallySelectedFiles;
+};
+
+QFileDialogOptions::QFileDialogOptions() : d(new QFileDialogOptionsPrivate)
+{
+}
+
+QFileDialogOptions::QFileDialogOptions(const QFileDialogOptions &rhs) : d(rhs.d)
+{
+}
+
+QFileDialogOptions &QFileDialogOptions::operator=(const QFileDialogOptions &rhs)
+{
+    if (this != &rhs)
+        d = rhs.d;
+    return *this;
+}
+
+QFileDialogOptions::~QFileDialogOptions()
+{
+}
+
+QString QFileDialogOptions::windowTitle() const
+{
+    return d->windowTitle;
+}
+
+void QFileDialogOptions::setWindowTitle(const QString &title)
+{
+    d->windowTitle = title;
+}
+
+void QFileDialogOptions::setOption(QFileDialogOptions::FileDialogOption option, bool on)
+{
+    if (!(d->options & option) != !on)
+        setOptions(d->options ^ option);
+}
+
+bool QFileDialogOptions::testOption(QFileDialogOptions::FileDialogOption option) const
+{
+    return d->options & option;
+}
+
+void QFileDialogOptions::setOptions(FileDialogOptions options)
+{
+    if (options != d->options)
+        d->options = options;
+}
+
+QFileDialogOptions::FileDialogOptions QFileDialogOptions::options() const
+{
+    return d->options;
+}
+
+QDir::Filters QFileDialogOptions::filter() const
+{
+    return d->filters;
+}
+
+void QFileDialogOptions::setFilter(QDir::Filters filters)
+{
+    d->filters  = filters;
+}
+
+void QFileDialogOptions::setViewMode(QFileDialogOptions::ViewMode mode)
+{
+    d->viewMode = mode;
+}
+
+QFileDialogOptions::ViewMode QFileDialogOptions::viewMode() const
+{
+    return d->viewMode;
+}
+
+void QFileDialogOptions::setFileMode(QFileDialogOptions::FileMode mode)
+{
+    d->fileMode = mode;
+}
+
+QFileDialogOptions::FileMode QFileDialogOptions::fileMode() const
+{
+    return d->fileMode;
+}
+
+void QFileDialogOptions::setAcceptMode(QFileDialogOptions::AcceptMode mode)
+{
+    d->acceptMode = mode;
+}
+
+QFileDialogOptions::AcceptMode QFileDialogOptions::acceptMode() const
+{
+    return d->acceptMode;
+}
+
+void QFileDialogOptions::setSidebarUrls(const QList<QUrl> &urls)
+{
+    d->sidebarUrls = urls;
+}
+
+QList<QUrl> QFileDialogOptions::sidebarUrls() const
+{
+    return d->sidebarUrls;
+}
+
+void QFileDialogOptions::setNameFilters(const QStringList &filters)
+{
+    d->nameFilters = filters;
+}
+
+QStringList QFileDialogOptions::nameFilters() const
+{
+    return d->nameFilters;
+}
+
+void QFileDialogOptions::setDefaultSuffix(const QString &suffix)
+{
+    d->defaultSuffix = suffix;
+}
+
+QString QFileDialogOptions::defaultSuffix() const
+{
+    return d->defaultSuffix;
+}
+
+void QFileDialogOptions::setHistory(const QStringList &paths)
+{
+    d->history = paths;
+}
+
+QStringList QFileDialogOptions::history() const
+{
+    return d->history;
+}
+
+void QFileDialogOptions::setLabelText(QFileDialogOptions::DialogLabel label, const QString &text)
+{
+    if (label >= 0 && label < DialogLabelCount)
+        d->labels[label] = text;
+}
+
+QString QFileDialogOptions::labelText(QFileDialogOptions::DialogLabel label) const
+{
+    return (label >= 0 && label < DialogLabelCount) ? d->labels[label] : QString();
+}
+
+bool QFileDialogOptions::isLabelExplicitlySet(DialogLabel label)
+{
+    return label >= 0 && label < DialogLabelCount && !d->labels[label].isEmpty();
+}
+
+QString QFileDialogOptions::initialDirectory() const
+{
+    return d->initialDirectory;
+}
+
+void QFileDialogOptions::setInitialDirectory(const QString &directory)
+{
+    d->initialDirectory = directory;
+}
+
+QString QFileDialogOptions::initiallySelectedNameFilter() const
+{
+    return d->initiallySelectedNameFilter;
+}
+
+void QFileDialogOptions::setInitiallySelectedNameFilter(const QString &filter)
+{
+    d->initiallySelectedNameFilter = filter;
+}
+
+QStringList QFileDialogOptions::initiallySelectedFiles() const
+{
+    return d->initiallySelectedFiles;
+}
+
+void QFileDialogOptions::setInitiallySelectedFiles(const QStringList &files)
+{
+    d->initiallySelectedFiles = files;
+}
+
+/*!
+    \class QPlatformFileDialogHelper
+    \since 5.0
+    \internal
+    \ingroup qpa
+
+    \brief The QPlatformFileDialogHelper class allows for platform-specific customization of file dialogs.
+
+*/
+const QSharedPointer<QFileDialogOptions> &QPlatformFileDialogHelper::options() const
+{
+    return m_options;
+}
+
+void QPlatformFileDialogHelper::setOptions(const QSharedPointer<QFileDialogOptions> &options)
+{
+    m_options = options;
+}
+
+const char *QPlatformFileDialogHelper::filterRegExp =
+"^(.*)\\(([a-zA-Z0-9_.*? +;#\\-\\[\\]@\\{\\}/!<>\\$%&=^~:\\|]*)\\)$";
+
+// Makes a list of filters from a normal filter string "Image Files (*.png *.jpg)"
+QStringList QPlatformFileDialogHelper::cleanFilterList(const QString &filter)
+{
+    QRegExp regexp(QString::fromLatin1(filterRegExp));
+    QString f = filter;
+    int i = regexp.indexIn(f);
+    if (i >= 0)
+        f = regexp.cap(2);
+    return f.split(QLatin1Char(' '), QString::SkipEmptyParts);
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformdialoghelper_qpa.cpp b/src/gui/kernel/qplatformdialoghelper_qpa.cpp
deleted file mode 100644
index f71c5e5..0000000
--- a/src/gui/kernel/qplatformdialoghelper_qpa.cpp
+++ /dev/null
@@ -1,594 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformdialoghelper.h"
-
-#include <QtCore/QVariant>
-#include <QtCore/QSharedData>
-#include <QtCore/QSettings>
-#include <QtCore/QHash>
-#include <QtCore/QUrl>
-#include <QtGui/QColor>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformDialogHelper
-    \since 5.0
-    \internal
-    \ingroup qpa
-
-    \brief The QPlatformDialogHelper class allows for platform-specific customization of dialogs.
-
-*/
-
-/*!
-    \enum QPlatformDialogHelper::StyleHint
-
-    This enum type specifies platform-specific style hints.
-
-    \value SnapToDefaultButton Snap the mouse to the center of the default
-                               button. There is corresponding system
-                               setting on Windows.
-
-    \sa styleHint()
-*/
-
-QPlatformDialogHelper::QPlatformDialogHelper()
-{
-}
-
-QPlatformDialogHelper::~QPlatformDialogHelper()
-{
-}
-
-QVariant QPlatformDialogHelper::styleHint(StyleHint hint) const
-{
-    return QPlatformDialogHelper::defaultStyleHint(hint);
-}
-
-QVariant  QPlatformDialogHelper::defaultStyleHint(QPlatformDialogHelper::StyleHint hint)
-{
-    switch (hint) {
-    case QPlatformDialogHelper::SnapToDefaultButton:
-        return QVariant(false);
-    }
-    return QVariant();
-}
-
-// Font dialog
-
-class QFontDialogOptionsPrivate : public QSharedData
-{
-public:
-    QFontDialogOptionsPrivate() : options(0) {}
-
-    QFontDialogOptions::FontDialogOptions options;
-    QString windowTitle;
-};
-
-QFontDialogOptions::QFontDialogOptions() : d(new QFontDialogOptionsPrivate)
-{
-}
-
-QFontDialogOptions::QFontDialogOptions(const QFontDialogOptions &rhs) : d(rhs.d)
-{
-}
-
-QFontDialogOptions &QFontDialogOptions::operator=(const QFontDialogOptions &rhs)
-{
-    if (this != &rhs)
-        d = rhs.d;
-    return *this;
-}
-
-QFontDialogOptions::~QFontDialogOptions()
-{
-}
-
-QString QFontDialogOptions::windowTitle() const
-{
-    return d->windowTitle;
-}
-
-void QFontDialogOptions::setWindowTitle(const QString &title)
-{
-    d->windowTitle = title;
-}
-
-void QFontDialogOptions::setOption(QFontDialogOptions::FontDialogOption option, bool on)
-{
-    if (!(d->options & option) != !on)
-        setOptions(d->options ^ option);
-}
-
-bool QFontDialogOptions::testOption(QFontDialogOptions::FontDialogOption option) const
-{
-    return d->options & option;
-}
-
-void QFontDialogOptions::setOptions(FontDialogOptions options)
-{
-    if (options != d->options)
-        d->options = options;
-}
-
-QFontDialogOptions::FontDialogOptions QFontDialogOptions::options() const
-{
-    return d->options;
-}
-
-/*!
-    \class QPlatformFontDialogHelper
-    \since 5.0
-    \internal
-    \ingroup qpa
-
-    \brief The QPlatformFontDialogHelper class allows for platform-specific customization of font dialogs.
-
-*/
-const QSharedPointer<QFontDialogOptions> &QPlatformFontDialogHelper::options() const
-{
-    return m_options;
-}
-
-void QPlatformFontDialogHelper::setOptions(const QSharedPointer<QFontDialogOptions> &options)
-{
-    m_options = options;
-}
-
-// Color dialog
-
-class QColorDialogStaticData
-{
-public:
-    enum { CustomColorCount = 16, StandardColorCount = 6 * 8 };
-
-    QColorDialogStaticData();
-    inline void readSettings();
-    inline void writeSettings() const;
-
-    QRgb customRgb[CustomColorCount];
-    QRgb standardRgb[StandardColorCount];
-    bool customSet;
-};
-
-QColorDialogStaticData::QColorDialogStaticData() : customSet(false)
-{
-    int i = 0;
-    for (int g = 0; g < 4; ++g)
-        for (int r = 0;  r < 4; ++r)
-            for (int b = 0; b < 3; ++b)
-                standardRgb[i++] = qRgb(r * 255 / 3, g * 255 / 3, b * 255 / 2);
-    qFill(customRgb, customRgb + CustomColorCount, 0xffffffff);
-    readSettings();
-}
-
-void QColorDialogStaticData::readSettings()
-{
-#ifndef QT_NO_SETTINGS
-    const QSettings settings(QSettings::UserScope, QStringLiteral("Trolltech"));
-    for (int i = 0; i < int(CustomColorCount); ++i) {
-        const QVariant v = settings.value(QStringLiteral("Qt/customColors/") + QString::number(i));
-        if (v.isValid())
-            customRgb[i] = v.toUInt();
-    }
-#endif
-}
-
-void QColorDialogStaticData::writeSettings() const
-{
-#ifndef QT_NO_SETTINGS
-    if (!customSet) {
-        QSettings settings(QSettings::UserScope, QStringLiteral("Trolltech"));
-        for (int i = 0; i < int(CustomColorCount); ++i)
-            settings.setValue(QStringLiteral("Qt/customColors/") + QString::number(i), customRgb[i]);
-    }
-#endif
-}
-
-Q_GLOBAL_STATIC(QColorDialogStaticData, qColorDialogStaticData)
-
-class QColorDialogOptionsPrivate : public QSharedData
-{
-public:
-    QColorDialogOptionsPrivate() : options(0) {}
-    // Write out settings around destruction of dialogs
-    ~QColorDialogOptionsPrivate() { qColorDialogStaticData()->writeSettings(); }
-
-    QColorDialogOptions::ColorDialogOptions options;
-    QString windowTitle;
-};
-
-QColorDialogOptions::QColorDialogOptions() : d(new QColorDialogOptionsPrivate)
-{
-}
-
-QColorDialogOptions::QColorDialogOptions(const QColorDialogOptions &rhs) : d(rhs.d)
-{
-}
-
-QColorDialogOptions &QColorDialogOptions::operator=(const QColorDialogOptions &rhs)
-{
-    if (this != &rhs)
-        d = rhs.d;
-    return *this;
-}
-
-QColorDialogOptions::~QColorDialogOptions()
-{
-}
-
-QString QColorDialogOptions::windowTitle() const
-{
-    return d->windowTitle;
-}
-
-void QColorDialogOptions::setWindowTitle(const QString &title)
-{
-    d->windowTitle = title;
-}
-
-void QColorDialogOptions::setOption(QColorDialogOptions::ColorDialogOption option, bool on)
-{
-    if (!(d->options & option) != !on)
-        setOptions(d->options ^ option);
-}
-
-bool QColorDialogOptions::testOption(QColorDialogOptions::ColorDialogOption option) const
-{
-    return d->options & option;
-}
-
-void QColorDialogOptions::setOptions(ColorDialogOptions options)
-{
-    if (options != d->options)
-        d->options = options;
-}
-
-QColorDialogOptions::ColorDialogOptions QColorDialogOptions::options() const
-{
-    return d->options;
-}
-
-int QColorDialogOptions::customColorCount()
-{
-    return QColorDialogStaticData::CustomColorCount;
-}
-
-QRgb QColorDialogOptions::customColor(int index)
-{
-    if (uint(index) >= uint(QColorDialogStaticData::CustomColorCount))
-        return qRgb(255, 255, 255);
-    return qColorDialogStaticData()->customRgb[index];
-}
-
-QRgb *QColorDialogOptions::customColors()
-{
-    return qColorDialogStaticData()->customRgb;
-}
-
-void QColorDialogOptions::setCustomColor(int index, QRgb color)
-{
-    if (uint(index) >= uint(QColorDialogStaticData::CustomColorCount))
-        return;
-    qColorDialogStaticData()->customSet;
-    qColorDialogStaticData()->customRgb[index] = color;
-}
-
-QRgb *QColorDialogOptions::standardColors()
-{
-    return qColorDialogStaticData()->standardRgb;
-}
-
-QRgb QColorDialogOptions::standardColor(int index)
-{
-    if (uint(index) >= uint(QColorDialogStaticData::StandardColorCount))
-        return qRgb(255, 255, 255);
-    return qColorDialogStaticData()->standardRgb[index];
-}
-
-void QColorDialogOptions::setStandardColor(int index, QRgb color)
-{
-    if (uint(index) >= uint(QColorDialogStaticData::StandardColorCount))
-        return;
-    qColorDialogStaticData()->standardRgb[index] = color;
-}
-
-/*!
-    \class QPlatformColorDialogHelper
-    \since 5.0
-    \internal
-    \ingroup qpa
-
-    \brief The QPlatformColorDialogHelper class allows for platform-specific customization of color dialogs.
-
-*/
-const QSharedPointer<QColorDialogOptions> &QPlatformColorDialogHelper::options() const
-{
-    return m_options;
-}
-
-void QPlatformColorDialogHelper::setOptions(const QSharedPointer<QColorDialogOptions> &options)
-{
-    m_options = options;
-}
-
-// File dialog
-
-class QFileDialogOptionsPrivate : public QSharedData
-{
-public:
-    QFileDialogOptionsPrivate() : options(0),
-        viewMode(QFileDialogOptions::Detail),
-        fileMode(QFileDialogOptions::AnyFile),
-        acceptMode(QFileDialogOptions::AcceptOpen),
-        filters(QDir::AllEntries | QDir::NoDotAndDotDot | QDir::AllDirs)
-    {}
-
-    QFileDialogOptions::FileDialogOptions options;
-    QString windowTitle;
-
-    QFileDialogOptions::ViewMode viewMode;
-    QFileDialogOptions::FileMode fileMode;
-    QFileDialogOptions::AcceptMode acceptMode;
-    QString labels[QFileDialogOptions::DialogLabelCount];
-    QDir::Filters filters;
-    QList<QUrl> sidebarUrls;
-    QStringList nameFilters;
-    QString defaultSuffix;
-    QStringList history;
-    QString initialDirectory;
-    QString initiallySelectedNameFilter;
-    QStringList initiallySelectedFiles;
-};
-
-QFileDialogOptions::QFileDialogOptions() : d(new QFileDialogOptionsPrivate)
-{
-}
-
-QFileDialogOptions::QFileDialogOptions(const QFileDialogOptions &rhs) : d(rhs.d)
-{
-}
-
-QFileDialogOptions &QFileDialogOptions::operator=(const QFileDialogOptions &rhs)
-{
-    if (this != &rhs)
-        d = rhs.d;
-    return *this;
-}
-
-QFileDialogOptions::~QFileDialogOptions()
-{
-}
-
-QString QFileDialogOptions::windowTitle() const
-{
-    return d->windowTitle;
-}
-
-void QFileDialogOptions::setWindowTitle(const QString &title)
-{
-    d->windowTitle = title;
-}
-
-void QFileDialogOptions::setOption(QFileDialogOptions::FileDialogOption option, bool on)
-{
-    if (!(d->options & option) != !on)
-        setOptions(d->options ^ option);
-}
-
-bool QFileDialogOptions::testOption(QFileDialogOptions::FileDialogOption option) const
-{
-    return d->options & option;
-}
-
-void QFileDialogOptions::setOptions(FileDialogOptions options)
-{
-    if (options != d->options)
-        d->options = options;
-}
-
-QFileDialogOptions::FileDialogOptions QFileDialogOptions::options() const
-{
-    return d->options;
-}
-
-QDir::Filters QFileDialogOptions::filter() const
-{
-    return d->filters;
-}
-
-void QFileDialogOptions::setFilter(QDir::Filters filters)
-{
-    d->filters  = filters;
-}
-
-void QFileDialogOptions::setViewMode(QFileDialogOptions::ViewMode mode)
-{
-    d->viewMode = mode;
-}
-
-QFileDialogOptions::ViewMode QFileDialogOptions::viewMode() const
-{
-    return d->viewMode;
-}
-
-void QFileDialogOptions::setFileMode(QFileDialogOptions::FileMode mode)
-{
-    d->fileMode = mode;
-}
-
-QFileDialogOptions::FileMode QFileDialogOptions::fileMode() const
-{
-    return d->fileMode;
-}
-
-void QFileDialogOptions::setAcceptMode(QFileDialogOptions::AcceptMode mode)
-{
-    d->acceptMode = mode;
-}
-
-QFileDialogOptions::AcceptMode QFileDialogOptions::acceptMode() const
-{
-    return d->acceptMode;
-}
-
-void QFileDialogOptions::setSidebarUrls(const QList<QUrl> &urls)
-{
-    d->sidebarUrls = urls;
-}
-
-QList<QUrl> QFileDialogOptions::sidebarUrls() const
-{
-    return d->sidebarUrls;
-}
-
-void QFileDialogOptions::setNameFilters(const QStringList &filters)
-{
-    d->nameFilters = filters;
-}
-
-QStringList QFileDialogOptions::nameFilters() const
-{
-    return d->nameFilters;
-}
-
-void QFileDialogOptions::setDefaultSuffix(const QString &suffix)
-{
-    d->defaultSuffix = suffix;
-}
-
-QString QFileDialogOptions::defaultSuffix() const
-{
-    return d->defaultSuffix;
-}
-
-void QFileDialogOptions::setHistory(const QStringList &paths)
-{
-    d->history = paths;
-}
-
-QStringList QFileDialogOptions::history() const
-{
-    return d->history;
-}
-
-void QFileDialogOptions::setLabelText(QFileDialogOptions::DialogLabel label, const QString &text)
-{
-    if (label >= 0 && label < DialogLabelCount)
-        d->labels[label] = text;
-}
-
-QString QFileDialogOptions::labelText(QFileDialogOptions::DialogLabel label) const
-{
-    return (label >= 0 && label < DialogLabelCount) ? d->labels[label] : QString();
-}
-
-bool QFileDialogOptions::isLabelExplicitlySet(DialogLabel label)
-{
-    return label >= 0 && label < DialogLabelCount && !d->labels[label].isEmpty();
-}
-
-QString QFileDialogOptions::initialDirectory() const
-{
-    return d->initialDirectory;
-}
-
-void QFileDialogOptions::setInitialDirectory(const QString &directory)
-{
-    d->initialDirectory = directory;
-}
-
-QString QFileDialogOptions::initiallySelectedNameFilter() const
-{
-    return d->initiallySelectedNameFilter;
-}
-
-void QFileDialogOptions::setInitiallySelectedNameFilter(const QString &filter)
-{
-    d->initiallySelectedNameFilter = filter;
-}
-
-QStringList QFileDialogOptions::initiallySelectedFiles() const
-{
-    return d->initiallySelectedFiles;
-}
-
-void QFileDialogOptions::setInitiallySelectedFiles(const QStringList &files)
-{
-    d->initiallySelectedFiles = files;
-}
-
-/*!
-    \class QPlatformFileDialogHelper
-    \since 5.0
-    \internal
-    \ingroup qpa
-
-    \brief The QPlatformFileDialogHelper class allows for platform-specific customization of file dialogs.
-
-*/
-const QSharedPointer<QFileDialogOptions> &QPlatformFileDialogHelper::options() const
-{
-    return m_options;
-}
-
-void QPlatformFileDialogHelper::setOptions(const QSharedPointer<QFileDialogOptions> &options)
-{
-    m_options = options;
-}
-
-const char *QPlatformFileDialogHelper::filterRegExp =
-"^(.*)\\(([a-zA-Z0-9_.*? +;#\\-\\[\\]@\\{\\}/!<>\\$%&=^~:\\|]*)\\)$";
-
-// Makes a list of filters from a normal filter string "Image Files (*.png *.jpg)"
-QStringList QPlatformFileDialogHelper::cleanFilterList(const QString &filter)
-{
-    QRegExp regexp(QString::fromLatin1(filterRegExp));
-    QString f = filter;
-    int i = regexp.indexIn(f);
-    if (i >= 0)
-        f = regexp.cap(2);
-    return f.split(QLatin1Char(' '), QString::SkipEmptyParts);
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformdrag.cpp b/src/gui/kernel/qplatformdrag.cpp
new file mode 100644
index 0000000..068dfab
--- /dev/null
+++ b/src/gui/kernel/qplatformdrag.cpp
@@ -0,0 +1,201 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformdrag.h"
+
+#include <QtGui/private/qdnd_p.h>
+#include <QtGui/QKeyEvent>
+#include <QtGui/QGuiApplication>
+#include <QtCore/QEventLoop>
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_DRAGANDDROP
+
+QPlatformDropQtResponse::QPlatformDropQtResponse(bool accepted, Qt::DropAction acceptedAction)
+    : m_accepted(accepted)
+    , m_accepted_action(acceptedAction)
+{
+}
+
+bool QPlatformDropQtResponse::isAccepted() const
+{
+    return m_accepted;
+}
+
+Qt::DropAction QPlatformDropQtResponse::acceptedAction() const
+{
+    return m_accepted_action;
+}
+
+QPlatformDragQtResponse::QPlatformDragQtResponse(bool accepted, Qt::DropAction acceptedAction, QRect answerRect)
+    : QPlatformDropQtResponse(accepted,acceptedAction)
+    , m_answer_rect(answerRect)
+{
+}
+
+QRect QPlatformDragQtResponse::answerRect() const
+{
+    return m_answer_rect;
+}
+
+class QPlatformDragPrivate {
+public:
+    QPlatformDragPrivate() : cursor_drop_action(Qt::IgnoreAction) {}
+
+    Qt::DropAction cursor_drop_action;
+};
+
+/*!
+    \class QPlatformDrag
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformDrag class provides an abstraction for drag.
+ */
+QPlatformDrag::QPlatformDrag() : d_ptr(new QPlatformDragPrivate)
+{
+}
+
+QPlatformDrag::~QPlatformDrag()
+{
+    delete d_ptr;
+}
+
+QDrag *QPlatformDrag::currentDrag() const
+{
+    return QDragManager::self()->object();
+}
+
+Qt::DropAction QPlatformDrag::defaultAction(Qt::DropActions possibleActions,
+                                           Qt::KeyboardModifiers modifiers) const
+{
+#ifdef QDND_DEBUG
+    qDebug("QDragManager::defaultAction(Qt::DropActions possibleActions)");
+    qDebug("keyboard modifiers : %s", KeyboardModifiersToString(modifiers).latin1());
+#endif
+
+    Qt::DropAction default_action = Qt::IgnoreAction;
+
+    if (currentDrag()) {
+        default_action = currentDrag()->defaultAction();
+    }
+
+
+    if (default_action == Qt::IgnoreAction) {
+        //This means that the drag was initiated by QDrag::start and we need to
+        //preserve the old behavior
+        default_action = Qt::CopyAction;
+    }
+
+    if (modifiers & Qt::ControlModifier && modifiers & Qt::ShiftModifier)
+        default_action = Qt::LinkAction;
+    else if (modifiers & Qt::ControlModifier)
+        default_action = Qt::CopyAction;
+    else if (modifiers & Qt::ShiftModifier)
+        default_action = Qt::MoveAction;
+    else if (modifiers & Qt::AltModifier)
+        default_action = Qt::LinkAction;
+
+#ifdef QDND_DEBUG
+    qDebug("possible actions : %s", dragActionsToString(possibleActions).latin1());
+#endif
+
+    // Check if the action determined is allowed
+    if (!(possibleActions & default_action)) {
+        if (possibleActions & Qt::CopyAction)
+            default_action = Qt::CopyAction;
+        else if (possibleActions & Qt::MoveAction)
+            default_action = Qt::MoveAction;
+        else if (possibleActions & Qt::LinkAction)
+            default_action = Qt::LinkAction;
+        else
+            default_action = Qt::IgnoreAction;
+    }
+
+#ifdef QDND_DEBUG
+    qDebug("default action : %s", dragActionsToString(defaultAction).latin1());
+#endif
+
+    return default_action;
+}
+
+/*!
+    \brief Called to notify QDrag about changes of the current action.
+ */
+
+void QPlatformDrag::updateAction(Qt::DropAction action)
+{
+    Q_D(QPlatformDrag);
+    if (d->cursor_drop_action != action) {
+        d->cursor_drop_action = action;
+        emit currentDrag()->actionChanged(action);
+    }
+}
+
+static const char *const default_pm[] = {
+"13 9 3 1",
+".      c None",
+"       c #000000",
+"X      c #FFFFFF",
+"X X X X X X X",
+" X X X X X X ",
+"X ......... X",
+" X.........X ",
+"X ......... X",
+" X.........X ",
+"X ......... X",
+" X X X X X X ",
+"X X X X X X X",
+};
+
+Q_GLOBAL_STATIC_WITH_ARGS(QPixmap,qt_drag_default_pixmap,(default_pm))
+
+QPixmap QPlatformDrag::defaultPixmap()
+{
+    return *qt_drag_default_pixmap();
+}
+
+#endif // QT_NO_DRAGANDDROP
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformdrag_qpa.cpp b/src/gui/kernel/qplatformdrag_qpa.cpp
deleted file mode 100644
index 068dfab..0000000
--- a/src/gui/kernel/qplatformdrag_qpa.cpp
+++ /dev/null
@@ -1,201 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformdrag.h"
-
-#include <QtGui/private/qdnd_p.h>
-#include <QtGui/QKeyEvent>
-#include <QtGui/QGuiApplication>
-#include <QtCore/QEventLoop>
-
-QT_BEGIN_NAMESPACE
-
-#ifndef QT_NO_DRAGANDDROP
-
-QPlatformDropQtResponse::QPlatformDropQtResponse(bool accepted, Qt::DropAction acceptedAction)
-    : m_accepted(accepted)
-    , m_accepted_action(acceptedAction)
-{
-}
-
-bool QPlatformDropQtResponse::isAccepted() const
-{
-    return m_accepted;
-}
-
-Qt::DropAction QPlatformDropQtResponse::acceptedAction() const
-{
-    return m_accepted_action;
-}
-
-QPlatformDragQtResponse::QPlatformDragQtResponse(bool accepted, Qt::DropAction acceptedAction, QRect answerRect)
-    : QPlatformDropQtResponse(accepted,acceptedAction)
-    , m_answer_rect(answerRect)
-{
-}
-
-QRect QPlatformDragQtResponse::answerRect() const
-{
-    return m_answer_rect;
-}
-
-class QPlatformDragPrivate {
-public:
-    QPlatformDragPrivate() : cursor_drop_action(Qt::IgnoreAction) {}
-
-    Qt::DropAction cursor_drop_action;
-};
-
-/*!
-    \class QPlatformDrag
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformDrag class provides an abstraction for drag.
- */
-QPlatformDrag::QPlatformDrag() : d_ptr(new QPlatformDragPrivate)
-{
-}
-
-QPlatformDrag::~QPlatformDrag()
-{
-    delete d_ptr;
-}
-
-QDrag *QPlatformDrag::currentDrag() const
-{
-    return QDragManager::self()->object();
-}
-
-Qt::DropAction QPlatformDrag::defaultAction(Qt::DropActions possibleActions,
-                                           Qt::KeyboardModifiers modifiers) const
-{
-#ifdef QDND_DEBUG
-    qDebug("QDragManager::defaultAction(Qt::DropActions possibleActions)");
-    qDebug("keyboard modifiers : %s", KeyboardModifiersToString(modifiers).latin1());
-#endif
-
-    Qt::DropAction default_action = Qt::IgnoreAction;
-
-    if (currentDrag()) {
-        default_action = currentDrag()->defaultAction();
-    }
-
-
-    if (default_action == Qt::IgnoreAction) {
-        //This means that the drag was initiated by QDrag::start and we need to
-        //preserve the old behavior
-        default_action = Qt::CopyAction;
-    }
-
-    if (modifiers & Qt::ControlModifier && modifiers & Qt::ShiftModifier)
-        default_action = Qt::LinkAction;
-    else if (modifiers & Qt::ControlModifier)
-        default_action = Qt::CopyAction;
-    else if (modifiers & Qt::ShiftModifier)
-        default_action = Qt::MoveAction;
-    else if (modifiers & Qt::AltModifier)
-        default_action = Qt::LinkAction;
-
-#ifdef QDND_DEBUG
-    qDebug("possible actions : %s", dragActionsToString(possibleActions).latin1());
-#endif
-
-    // Check if the action determined is allowed
-    if (!(possibleActions & default_action)) {
-        if (possibleActions & Qt::CopyAction)
-            default_action = Qt::CopyAction;
-        else if (possibleActions & Qt::MoveAction)
-            default_action = Qt::MoveAction;
-        else if (possibleActions & Qt::LinkAction)
-            default_action = Qt::LinkAction;
-        else
-            default_action = Qt::IgnoreAction;
-    }
-
-#ifdef QDND_DEBUG
-    qDebug("default action : %s", dragActionsToString(defaultAction).latin1());
-#endif
-
-    return default_action;
-}
-
-/*!
-    \brief Called to notify QDrag about changes of the current action.
- */
-
-void QPlatformDrag::updateAction(Qt::DropAction action)
-{
-    Q_D(QPlatformDrag);
-    if (d->cursor_drop_action != action) {
-        d->cursor_drop_action = action;
-        emit currentDrag()->actionChanged(action);
-    }
-}
-
-static const char *const default_pm[] = {
-"13 9 3 1",
-".      c None",
-"       c #000000",
-"X      c #FFFFFF",
-"X X X X X X X",
-" X X X X X X ",
-"X ......... X",
-" X.........X ",
-"X ......... X",
-" X.........X ",
-"X ......... X",
-" X X X X X X ",
-"X X X X X X X",
-};
-
-Q_GLOBAL_STATIC_WITH_ARGS(QPixmap,qt_drag_default_pixmap,(default_pm))
-
-QPixmap QPlatformDrag::defaultPixmap()
-{
-    return *qt_drag_default_pixmap();
-}
-
-#endif // QT_NO_DRAGANDDROP
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatforminputcontext.cpp b/src/gui/kernel/qplatforminputcontext.cpp
new file mode 100644
index 0000000..0a8633b
--- /dev/null
+++ b/src/gui/kernel/qplatforminputcontext.cpp
@@ -0,0 +1,262 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatforminputcontext.h"
+#include <qguiapplication.h>
+#include <QRect>
+#include "private/qkeymapper_p.h"
+#include <qpa/qplatforminputcontext_p.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformInputContext
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+    \brief The QPlatformInputContext class abstracts the input method dependent data and composing state.
+
+    An input method is responsible for inputting complex text that cannot
+    be inputted via simple keymap. It converts a sequence of input
+    events (typically key events) into a text string through the input
+    method specific converting process. The class of the processes are
+    widely ranging from simple finite state machine to complex text
+    translator that pools a whole paragraph of a text with text
+    editing capability to perform grammar and semantic analysis.
+
+    To abstract such different input method specific intermediate
+    information, Qt offers the QPlatformInputContext as base class. The
+    concept is well known as 'input context' in the input method
+    domain. An input context is created for a text widget in response
+    to a demand. It is ensured that an input context is prepared for
+    an input method before input to a text widget.
+
+    QPlatformInputContext provides an interface the actual input methods
+    can derive from by reimplementing methods.
+
+    \sa QInputMethod
+*/
+
+/*!
+    \internal
+ */
+QPlatformInputContext::QPlatformInputContext()
+    : QObject(*(new QPlatformInputContextPrivate))
+{
+}
+
+/*!
+    \internal
+ */
+QPlatformInputContext::~QPlatformInputContext()
+{
+}
+
+/*!
+    Returns input context validity. Deriving implementations should return true.
+ */
+bool QPlatformInputContext::isValid() const
+{
+    return false;
+}
+
+/*!
+    Method to be called when input method needs to be reset. Called by QInputMethod::reset().
+    No further QInputMethodEvents should be sent as response.
+ */
+void QPlatformInputContext::reset()
+{
+}
+
+void QPlatformInputContext::commit()
+{
+}
+
+/*!
+    Notification on editor updates. Called by QInputMethod::update().
+ */
+void QPlatformInputContext::update(Qt::InputMethodQueries)
+{
+}
+
+/*!
+    Called when when the word currently being composed in input item is tapped by
+    the user. Input methods often use this information to offer more word
+    suggestions to the user.
+ */
+void QPlatformInputContext::invokeAction(QInputMethod::Action action, int cursorPosition)
+{
+    Q_UNUSED(cursorPosition)
+    // Default behavior for simple ephemeral input contexts. Some
+    // complex input contexts should not be reset here.
+    if (action == QInputMethod::Click)
+        reset();
+}
+
+/*!
+    This function can be reimplemented to filter input events.
+    Return true if the event has been consumed. Otherwise, the unfiltered event will
+    be forwarded to widgets as ordinary way. Although the input events have accept()
+    and ignore() methods, leave it untouched.
+*/
+bool QPlatformInputContext::filterEvent(const QEvent *event)
+{
+    Q_UNUSED(event)
+    return false;
+}
+
+/*!
+    This function can be reimplemented to return virtual keyboard rectangle in currently active
+    window coordinates. Default implementation returns invalid rectangle.
+ */
+QRectF QPlatformInputContext::keyboardRect() const
+{
+    return QRectF();
+}
+
+/*!
+    Active QPlatformInputContext is responsible for providing keyboardRectangle property to QInputMethod.
+    In addition of providing the value in keyboardRect function, it also needs to call this emit
+    function whenever the property changes.
+ */
+void QPlatformInputContext::emitKeyboardRectChanged()
+{
+    emit qApp->inputMethod()->keyboardRectangleChanged();
+}
+
+/*!
+    This function can be reimplemented to return true whenever input method is animating
+    shown or hidden. Default implementation returns false.
+ */
+bool QPlatformInputContext::isAnimating() const
+{
+    return false;
+}
+
+/*!
+    Active QPlatformInputContext is responsible for providing animating property to QInputMethod.
+    In addition of providing the value in isAnimation function, it also needs to call this emit
+    function whenever the property changes.
+ */
+void QPlatformInputContext::emitAnimatingChanged()
+{
+    emit qApp->inputMethod()->animatingChanged();
+}
+
+/*!
+    Request to show input panel.
+ */
+void QPlatformInputContext::showInputPanel()
+{
+}
+
+/*!
+    Request to hide input panel.
+ */
+void QPlatformInputContext::hideInputPanel()
+{
+}
+
+/*!
+    Returns input panel visibility status. Default implementation returns false.
+ */
+bool QPlatformInputContext::isInputPanelVisible() const
+{
+    return false;
+}
+
+/*!
+    Active QPlatformInputContext is responsible for providing visible property to QInputMethod.
+    In addition of providing the value in isInputPanelVisible function, it also needs to call this emit
+    function whenever the property changes.
+ */
+void QPlatformInputContext::emitInputPanelVisibleChanged()
+{
+    emit qApp->inputMethod()->visibleChanged();
+}
+
+QLocale QPlatformInputContext::locale() const
+{
+    return qt_keymapper_private()->keyboardInputLocale;
+}
+
+void QPlatformInputContext::emitLocaleChanged()
+{
+    emit qApp->inputMethod()->localeChanged();
+}
+
+Qt::LayoutDirection QPlatformInputContext::inputDirection() const
+{
+    return qt_keymapper_private()->keyboardInputDirection;
+}
+
+void QPlatformInputContext::emitInputDirectionChanged(Qt::LayoutDirection newDirection)
+{
+    emit qApp->inputMethod()->inputDirectionChanged(newDirection);
+}
+
+/*!
+    This virtual method gets called to notify updated focus to \a object.
+    \warning Input methods must not call this function directly.
+ */
+void QPlatformInputContext::setFocusObject(QObject *object)
+{
+    Q_UNUSED(object)
+}
+
+/*!
+    Returns true if current focus object supports input method events.
+ */
+bool QPlatformInputContext::inputMethodAccepted() const
+{
+    return QPlatformInputContextPrivate::s_inputMethodAccepted;
+}
+
+bool QPlatformInputContextPrivate::s_inputMethodAccepted = false;
+
+void QPlatformInputContextPrivate::setInputMethodAccepted(bool accepted)
+{
+    QPlatformInputContextPrivate::s_inputMethodAccepted = accepted;
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatforminputcontext_qpa.cpp b/src/gui/kernel/qplatforminputcontext_qpa.cpp
deleted file mode 100644
index 0a8633b..0000000
--- a/src/gui/kernel/qplatforminputcontext_qpa.cpp
+++ /dev/null
@@ -1,262 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatforminputcontext.h"
-#include <qguiapplication.h>
-#include <QRect>
-#include "private/qkeymapper_p.h"
-#include <qpa/qplatforminputcontext_p.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformInputContext
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-    \brief The QPlatformInputContext class abstracts the input method dependent data and composing state.
-
-    An input method is responsible for inputting complex text that cannot
-    be inputted via simple keymap. It converts a sequence of input
-    events (typically key events) into a text string through the input
-    method specific converting process. The class of the processes are
-    widely ranging from simple finite state machine to complex text
-    translator that pools a whole paragraph of a text with text
-    editing capability to perform grammar and semantic analysis.
-
-    To abstract such different input method specific intermediate
-    information, Qt offers the QPlatformInputContext as base class. The
-    concept is well known as 'input context' in the input method
-    domain. An input context is created for a text widget in response
-    to a demand. It is ensured that an input context is prepared for
-    an input method before input to a text widget.
-
-    QPlatformInputContext provides an interface the actual input methods
-    can derive from by reimplementing methods.
-
-    \sa QInputMethod
-*/
-
-/*!
-    \internal
- */
-QPlatformInputContext::QPlatformInputContext()
-    : QObject(*(new QPlatformInputContextPrivate))
-{
-}
-
-/*!
-    \internal
- */
-QPlatformInputContext::~QPlatformInputContext()
-{
-}
-
-/*!
-    Returns input context validity. Deriving implementations should return true.
- */
-bool QPlatformInputContext::isValid() const
-{
-    return false;
-}
-
-/*!
-    Method to be called when input method needs to be reset. Called by QInputMethod::reset().
-    No further QInputMethodEvents should be sent as response.
- */
-void QPlatformInputContext::reset()
-{
-}
-
-void QPlatformInputContext::commit()
-{
-}
-
-/*!
-    Notification on editor updates. Called by QInputMethod::update().
- */
-void QPlatformInputContext::update(Qt::InputMethodQueries)
-{
-}
-
-/*!
-    Called when when the word currently being composed in input item is tapped by
-    the user. Input methods often use this information to offer more word
-    suggestions to the user.
- */
-void QPlatformInputContext::invokeAction(QInputMethod::Action action, int cursorPosition)
-{
-    Q_UNUSED(cursorPosition)
-    // Default behavior for simple ephemeral input contexts. Some
-    // complex input contexts should not be reset here.
-    if (action == QInputMethod::Click)
-        reset();
-}
-
-/*!
-    This function can be reimplemented to filter input events.
-    Return true if the event has been consumed. Otherwise, the unfiltered event will
-    be forwarded to widgets as ordinary way. Although the input events have accept()
-    and ignore() methods, leave it untouched.
-*/
-bool QPlatformInputContext::filterEvent(const QEvent *event)
-{
-    Q_UNUSED(event)
-    return false;
-}
-
-/*!
-    This function can be reimplemented to return virtual keyboard rectangle in currently active
-    window coordinates. Default implementation returns invalid rectangle.
- */
-QRectF QPlatformInputContext::keyboardRect() const
-{
-    return QRectF();
-}
-
-/*!
-    Active QPlatformInputContext is responsible for providing keyboardRectangle property to QInputMethod.
-    In addition of providing the value in keyboardRect function, it also needs to call this emit
-    function whenever the property changes.
- */
-void QPlatformInputContext::emitKeyboardRectChanged()
-{
-    emit qApp->inputMethod()->keyboardRectangleChanged();
-}
-
-/*!
-    This function can be reimplemented to return true whenever input method is animating
-    shown or hidden. Default implementation returns false.
- */
-bool QPlatformInputContext::isAnimating() const
-{
-    return false;
-}
-
-/*!
-    Active QPlatformInputContext is responsible for providing animating property to QInputMethod.
-    In addition of providing the value in isAnimation function, it also needs to call this emit
-    function whenever the property changes.
- */
-void QPlatformInputContext::emitAnimatingChanged()
-{
-    emit qApp->inputMethod()->animatingChanged();
-}
-
-/*!
-    Request to show input panel.
- */
-void QPlatformInputContext::showInputPanel()
-{
-}
-
-/*!
-    Request to hide input panel.
- */
-void QPlatformInputContext::hideInputPanel()
-{
-}
-
-/*!
-    Returns input panel visibility status. Default implementation returns false.
- */
-bool QPlatformInputContext::isInputPanelVisible() const
-{
-    return false;
-}
-
-/*!
-    Active QPlatformInputContext is responsible for providing visible property to QInputMethod.
-    In addition of providing the value in isInputPanelVisible function, it also needs to call this emit
-    function whenever the property changes.
- */
-void QPlatformInputContext::emitInputPanelVisibleChanged()
-{
-    emit qApp->inputMethod()->visibleChanged();
-}
-
-QLocale QPlatformInputContext::locale() const
-{
-    return qt_keymapper_private()->keyboardInputLocale;
-}
-
-void QPlatformInputContext::emitLocaleChanged()
-{
-    emit qApp->inputMethod()->localeChanged();
-}
-
-Qt::LayoutDirection QPlatformInputContext::inputDirection() const
-{
-    return qt_keymapper_private()->keyboardInputDirection;
-}
-
-void QPlatformInputContext::emitInputDirectionChanged(Qt::LayoutDirection newDirection)
-{
-    emit qApp->inputMethod()->inputDirectionChanged(newDirection);
-}
-
-/*!
-    This virtual method gets called to notify updated focus to \a object.
-    \warning Input methods must not call this function directly.
- */
-void QPlatformInputContext::setFocusObject(QObject *object)
-{
-    Q_UNUSED(object)
-}
-
-/*!
-    Returns true if current focus object supports input method events.
- */
-bool QPlatformInputContext::inputMethodAccepted() const
-{
-    return QPlatformInputContextPrivate::s_inputMethodAccepted;
-}
-
-bool QPlatformInputContextPrivate::s_inputMethodAccepted = false;
-
-void QPlatformInputContextPrivate::setInputMethodAccepted(bool accepted)
-{
-    QPlatformInputContextPrivate::s_inputMethodAccepted = accepted;
-}
-
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatforminputcontextfactory.cpp b/src/gui/kernel/qplatforminputcontextfactory.cpp
new file mode 100644
index 0000000..595c3cc
--- /dev/null
+++ b/src/gui/kernel/qplatforminputcontextfactory.cpp
@@ -0,0 +1,111 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qpa/qplatforminputcontextfactory_p.h>
+#include <qpa/qplatforminputcontextplugin_p.h>
+#include <qpa/qplatforminputcontext.h>
+#include "private/qfactoryloader_p.h"
+
+#include "qguiapplication.h"
+#include "qdebug.h"
+#include <stdlib.h>
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
+    (QPlatformInputContextFactoryInterface_iid, QLatin1String("/platforminputcontexts"), Qt::CaseInsensitive))
+#endif
+
+QStringList QPlatformInputContextFactory::keys()
+{
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+    return loader()->keyMap().values();
+#else
+    return QStringList();
+#endif
+}
+
+QPlatformInputContext *QPlatformInputContextFactory::create(const QString& key)
+{
+    QStringList paramList = key.split(QLatin1Char(':'));
+    const QString platform = paramList.takeFirst().toLower();
+
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+    if (QPlatformInputContext *ret = qLoadPlugin1<QPlatformInputContext, QPlatformInputContextPlugin>(loader(), platform, paramList))
+        return ret;
+#endif
+    return 0;
+}
+
+QPlatformInputContext *QPlatformInputContextFactory::create()
+{
+    QPlatformInputContext *ic = 0;
+
+    QString icString = QString::fromLatin1(qgetenv("QT_IM_MODULE"));
+
+    if (icString == QStringLiteral("none"))
+        return 0;
+
+    ic = create(icString);
+    if (ic && ic->isValid())
+        return ic;
+
+    delete ic;
+    ic = 0;
+
+    QStringList k = keys();
+    for (int i = 0; i < k.size(); ++i) {
+        if (k.at(i) == icString)
+            continue;
+        ic = create(k.at(i));
+        if (ic && ic->isValid())
+            return ic;
+        delete ic;
+        ic = 0;
+    }
+
+    return 0;
+}
+
+
+QT_END_NAMESPACE
+
diff --git a/src/gui/kernel/qplatforminputcontextfactory_qpa.cpp b/src/gui/kernel/qplatforminputcontextfactory_qpa.cpp
deleted file mode 100644
index 595c3cc..0000000
--- a/src/gui/kernel/qplatforminputcontextfactory_qpa.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qpa/qplatforminputcontextfactory_p.h>
-#include <qpa/qplatforminputcontextplugin_p.h>
-#include <qpa/qplatforminputcontext.h>
-#include "private/qfactoryloader_p.h"
-
-#include "qguiapplication.h"
-#include "qdebug.h"
-#include <stdlib.h>
-
-QT_BEGIN_NAMESPACE
-
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
-    (QPlatformInputContextFactoryInterface_iid, QLatin1String("/platforminputcontexts"), Qt::CaseInsensitive))
-#endif
-
-QStringList QPlatformInputContextFactory::keys()
-{
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-    return loader()->keyMap().values();
-#else
-    return QStringList();
-#endif
-}
-
-QPlatformInputContext *QPlatformInputContextFactory::create(const QString& key)
-{
-    QStringList paramList = key.split(QLatin1Char(':'));
-    const QString platform = paramList.takeFirst().toLower();
-
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-    if (QPlatformInputContext *ret = qLoadPlugin1<QPlatformInputContext, QPlatformInputContextPlugin>(loader(), platform, paramList))
-        return ret;
-#endif
-    return 0;
-}
-
-QPlatformInputContext *QPlatformInputContextFactory::create()
-{
-    QPlatformInputContext *ic = 0;
-
-    QString icString = QString::fromLatin1(qgetenv("QT_IM_MODULE"));
-
-    if (icString == QStringLiteral("none"))
-        return 0;
-
-    ic = create(icString);
-    if (ic && ic->isValid())
-        return ic;
-
-    delete ic;
-    ic = 0;
-
-    QStringList k = keys();
-    for (int i = 0; i < k.size(); ++i) {
-        if (k.at(i) == icString)
-            continue;
-        ic = create(k.at(i));
-        if (ic && ic->isValid())
-            return ic;
-        delete ic;
-        ic = 0;
-    }
-
-    return 0;
-}
-
-
-QT_END_NAMESPACE
-
diff --git a/src/gui/kernel/qplatforminputcontextplugin.cpp b/src/gui/kernel/qplatforminputcontextplugin.cpp
new file mode 100644
index 0000000..670bfd0
--- /dev/null
+++ b/src/gui/kernel/qplatforminputcontextplugin.cpp
@@ -0,0 +1,55 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatforminputcontextplugin_p.h"
+
+QT_BEGIN_NAMESPACE
+
+QPlatformInputContextPlugin::QPlatformInputContextPlugin(QObject *parent)
+    : QObject(parent)
+{
+}
+
+QPlatformInputContextPlugin::~QPlatformInputContextPlugin()
+{
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatforminputcontextplugin_qpa.cpp b/src/gui/kernel/qplatforminputcontextplugin_qpa.cpp
deleted file mode 100644
index 670bfd0..0000000
--- a/src/gui/kernel/qplatforminputcontextplugin_qpa.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatforminputcontextplugin_p.h"
-
-QT_BEGIN_NAMESPACE
-
-QPlatformInputContextPlugin::QPlatformInputContextPlugin(QObject *parent)
-    : QObject(parent)
-{
-}
-
-QPlatformInputContextPlugin::~QPlatformInputContextPlugin()
-{
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformintegration.cpp b/src/gui/kernel/qplatformintegration.cpp
new file mode 100644
index 0000000..3021f63
--- /dev/null
+++ b/src/gui/kernel/qplatformintegration.cpp
@@ -0,0 +1,341 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformintegration.h"
+
+#include <qpa/qplatformfontdatabase.h>
+#include <qpa/qplatformclipboard.h>
+#include <qpa/qplatformaccessibility.h>
+#include <qpa/qplatformtheme.h>
+#include <QtGui/private/qguiapplication_p.h>
+#include <QtGui/private/qpixmap_raster_p.h>
+#include <qpa/qplatformscreen_p.h>
+#include <private/qdnd_p.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    Accessor for the platform integration's fontdatabase.
+
+    Default implementation returns a default QPlatformFontDatabase.
+
+    \sa QPlatformFontDatabase
+*/
+QPlatformFontDatabase *QPlatformIntegration::fontDatabase() const
+{
+    static QPlatformFontDatabase *db = 0;
+    if (!db) {
+        db = new QPlatformFontDatabase;
+    }
+    return db;
+}
+
+/*!
+    Accessor for the platform integration's clipboard.
+
+    Default implementation returns a default QPlatformClipboard.
+
+    \sa QPlatformClipboard
+
+*/
+
+#ifndef QT_NO_CLIPBOARD
+
+QPlatformClipboard *QPlatformIntegration::clipboard() const
+{
+    static QPlatformClipboard *clipboard = 0;
+    if (!clipboard) {
+        clipboard = new QPlatformClipboard;
+    }
+    return clipboard;
+}
+
+#endif
+
+#ifndef QT_NO_DRAGANDDROP
+/*!
+    Accessor for the platform integration's drag object.
+
+    Default implementation returns 0, implying no drag and drop support.
+
+*/
+QPlatformDrag *QPlatformIntegration::drag() const
+{
+    return 0;
+}
+#endif
+
+QPlatformNativeInterface * QPlatformIntegration::nativeInterface() const
+{
+    return 0;
+}
+
+QPlatformServices *QPlatformIntegration::services() const
+{
+    return 0;
+}
+
+/*!
+    \class QPlatformIntegration
+    \since 4.8
+    \internal
+    \preliminary
+    \ingroup qpa
+    \brief The QPlatformIntegration class is the entry for WindowSystem specific functionality.
+
+    QPlatformIntegration is the single entry point for windowsystem specific functionality when
+    using the QPA platform. It has factory functions for creating platform specific pixmaps and
+    windows. The class also controls the font subsystem.
+
+    QPlatformIntegration is a singleton class which gets instantiated in the QGuiApplication
+    constructor. The QPlatformIntegration instance do not have ownership of objects it creates in
+    functions where the name starts with create. However, functions which don't have a name
+    starting with create acts as accessors to member variables.
+
+    It is not trivial to create or build a platform plugin outside of the Qt source tree. Therefore
+    the recommended approach for making new platform plugin is to copy an existing plugin inside
+    the QTSRCTREE/src/plugins/platform and develop the plugin inside the source tree.
+
+    The minimal platform integration is the smallest platform integration it is possible to make,
+    which makes it an ideal starting point for new plugins. For a slightly more advanced plugin,
+    consider reviewing the directfb plugin, or the testlite plugin.
+*/
+
+/*!
+    \fn QPlatformPixmap *QPlatformIntegration::createPlatformPixmap(QPlatformPixmap::PixelType type) const
+
+    Factory function for QPlatformPixmap. PixelType can be either PixmapType or BitmapType.
+    \sa QPlatformPixmap
+*/
+
+/*!
+    \fn QPlatformWindow *QPlatformIntegration::createPlatformWindow(QWindow *window) const
+
+    Factory function for QPlatformWindow. The \a window parameter is a pointer to the top level
+    window which the QPlatformWindow is supposed to be created for.
+
+    All top level windows have to have a QPlatformWindow, and it will be created when the
+    QPlatformWindow is set to be visible for the first time. If the top level window's flags are
+    changed, or if the top level window's QPlatformWindowFormat is changed, then the top level
+    window's QPlatformWindow is deleted and a new one is created.
+
+    In the constructor, of the QPlatformWindow, the window flags, state, title and geometry
+    of the \a window should be applied to the underlying window. If the resulting flags or state
+    differs, the resulting values should be set on the \a window using QWindow::setWindowFlags()
+    or QWindow::setWindowState(), respectively.
+
+    \sa QPlatformWindow, QPlatformWindowFormat
+    \sa createPlatformBackingStore()
+*/
+
+/*!
+    \fn QPlatformBackingStore *QPlatformIntegration::createPlatformBackingStore(QWindow *window) const
+
+    Factory function for QPlatformBackingStore. The QWindow parameter is a pointer to the
+    top level widget(tlw) the window surface is created for. A QPlatformWindow is always created
+    before the QPlatformBackingStore for tlw where the widget also requires a backing store.
+
+    \sa QBackingStore
+    \sa createPlatformWindow()
+*/
+
+/*!
+    \enum QPlatformIntegration::Capability
+
+    Capabilities are used to determing specific features of a platform integration
+
+    \value ThreadedPixmaps The platform uses a pixmap implementation that is reentrant
+    and can be used from multiple threads, like the raster paint engine and QImage based
+    pixmaps.
+
+    \value OpenGL The platform supports OpenGL
+
+    \value ThreadedOpenGL The platform supports using OpenGL outside the GUI thread.
+
+    \value SharedGraphicsCache The platform supports a shared graphics cache
+
+    \value BufferQueueingOpenGL The OpenGL implementation on the platform will queue
+    up buffers when swapBuffers() is called and block only when its buffer pipeline
+    is full, rather than block immediately.
+ */
+
+
+/*!
+
+    \fn QAbstractEventDispatcher *QPlatformIntegration::guiThreadEventDispatcher() const = 0
+
+    Accessor function for the event dispatcher. The platform plugin should create
+    an instance of the QAbstractEventDispatcher in its constructor and set it
+    on the application using QGuiApplicationPrivate::instance()->setEventDispatcher().
+    The event dispatcher is owned by QGuiApplication, the accessor should return
+    a flat pointer.
+    \sa QGuiApplicationPrivate
+*/
+
+bool QPlatformIntegration::hasCapability(Capability cap) const
+{
+    Q_UNUSED(cap);
+    return false;
+}
+
+QPlatformPixmap *QPlatformIntegration::createPlatformPixmap(QPlatformPixmap::PixelType type) const
+{
+    return new QRasterPlatformPixmap(type);
+}
+
+#ifndef QT_NO_OPENGL
+QPlatformOpenGLContext *QPlatformIntegration::createPlatformOpenGLContext(QOpenGLContext *context) const
+{
+    Q_UNUSED(context);
+    qWarning("This plugin does not support createPlatformOpenGLContext!");
+    return 0;
+}
+#endif
+
+/*!
+   Factory function for QPlatformSharedGraphicsCache. This function will return 0 if the platform
+   integration does not support any shared graphics cache mechanism for the given \a cacheId.
+*/
+QPlatformSharedGraphicsCache *QPlatformIntegration::createPlatformSharedGraphicsCache(const char *cacheId) const
+{
+    qWarning("This plugin does not support createPlatformSharedGraphicsBuffer for cacheId: %s!",
+             cacheId);
+    return 0;
+}
+
+/*!
+   Factory function for QPaintEngine. This function will return 0 if the platform
+   integration does not support creating any paint engine the given \a paintDevice.
+*/
+QPaintEngine *QPlatformIntegration::createImagePaintEngine(QPaintDevice *paintDevice) const
+{
+    Q_UNUSED(paintDevice)
+    return 0;
+}
+
+/*!
+  Returns the platforms input context.
+
+  The default implementation returns 0, implying no input method support.
+*/
+QPlatformInputContext *QPlatformIntegration::inputContext() const
+{
+    return 0;
+}
+
+#ifndef QT_NO_ACCESSIBILITY
+
+/*!
+  Returns the platforms accessibility.
+
+  The default implementation returns 0, implying no accessibility support.
+*/
+QPlatformAccessibility *QPlatformIntegration::accessibility() const
+{
+    return 0;
+}
+
+#endif
+
+QVariant QPlatformIntegration::styleHint(StyleHint hint) const
+{
+    switch (hint) {
+    case CursorFlashTime:
+        return 1000;
+    case KeyboardInputInterval:
+        return 400;
+    case KeyboardAutoRepeatRate:
+        return 30;
+    case MouseDoubleClickInterval:
+        return 400;
+    case StartDragDistance:
+        return 10;
+    case StartDragTime:
+        return 500;
+    case ShowIsFullScreen:
+        return false;
+    case PasswordMaskDelay:
+        return 0;
+    case FontSmoothingGamma:
+        return qreal(1.7);
+    case StartDragVelocity:
+        return 0; // no limit
+    }
+
+    return 0;
+}
+
+Qt::KeyboardModifiers QPlatformIntegration::queryKeyboardModifiers() const
+{
+    return QGuiApplication::keyboardModifiers();
+}
+
+/*!
+  Should be called by the implementation whenever a new screen is added.
+
+  The first screen added will be the primary screen, used for default-created
+  windows, GL contexts, and other resources unless otherwise specified.
+
+  This adds the screen to QGuiApplication::screens(), and emits the
+  QGuiApplication::screenAdded() signal.
+
+  The screen is automatically removed when the QPlatformScreen is destroyed.
+*/
+void QPlatformIntegration::screenAdded(QPlatformScreen *ps)
+{
+    QScreen *screen = new QScreen(ps);
+    ps->d_func()->screen = screen;
+    QGuiApplicationPrivate::screen_list << screen;
+    emit qGuiApp->screenAdded(screen);
+}
+
+QStringList QPlatformIntegration::themeNames() const
+{
+    return QStringList();
+}
+
+class QPlatformTheme *QPlatformIntegration::createPlatformTheme(const QString &name) const
+{
+    Q_UNUSED(name)
+    return new QPlatformTheme;
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformintegration_qpa.cpp b/src/gui/kernel/qplatformintegration_qpa.cpp
deleted file mode 100644
index 3021f63..0000000
--- a/src/gui/kernel/qplatformintegration_qpa.cpp
+++ /dev/null
@@ -1,341 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformintegration.h"
-
-#include <qpa/qplatformfontdatabase.h>
-#include <qpa/qplatformclipboard.h>
-#include <qpa/qplatformaccessibility.h>
-#include <qpa/qplatformtheme.h>
-#include <QtGui/private/qguiapplication_p.h>
-#include <QtGui/private/qpixmap_raster_p.h>
-#include <qpa/qplatformscreen_p.h>
-#include <private/qdnd_p.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    Accessor for the platform integration's fontdatabase.
-
-    Default implementation returns a default QPlatformFontDatabase.
-
-    \sa QPlatformFontDatabase
-*/
-QPlatformFontDatabase *QPlatformIntegration::fontDatabase() const
-{
-    static QPlatformFontDatabase *db = 0;
-    if (!db) {
-        db = new QPlatformFontDatabase;
-    }
-    return db;
-}
-
-/*!
-    Accessor for the platform integration's clipboard.
-
-    Default implementation returns a default QPlatformClipboard.
-
-    \sa QPlatformClipboard
-
-*/
-
-#ifndef QT_NO_CLIPBOARD
-
-QPlatformClipboard *QPlatformIntegration::clipboard() const
-{
-    static QPlatformClipboard *clipboard = 0;
-    if (!clipboard) {
-        clipboard = new QPlatformClipboard;
-    }
-    return clipboard;
-}
-
-#endif
-
-#ifndef QT_NO_DRAGANDDROP
-/*!
-    Accessor for the platform integration's drag object.
-
-    Default implementation returns 0, implying no drag and drop support.
-
-*/
-QPlatformDrag *QPlatformIntegration::drag() const
-{
-    return 0;
-}
-#endif
-
-QPlatformNativeInterface * QPlatformIntegration::nativeInterface() const
-{
-    return 0;
-}
-
-QPlatformServices *QPlatformIntegration::services() const
-{
-    return 0;
-}
-
-/*!
-    \class QPlatformIntegration
-    \since 4.8
-    \internal
-    \preliminary
-    \ingroup qpa
-    \brief The QPlatformIntegration class is the entry for WindowSystem specific functionality.
-
-    QPlatformIntegration is the single entry point for windowsystem specific functionality when
-    using the QPA platform. It has factory functions for creating platform specific pixmaps and
-    windows. The class also controls the font subsystem.
-
-    QPlatformIntegration is a singleton class which gets instantiated in the QGuiApplication
-    constructor. The QPlatformIntegration instance do not have ownership of objects it creates in
-    functions where the name starts with create. However, functions which don't have a name
-    starting with create acts as accessors to member variables.
-
-    It is not trivial to create or build a platform plugin outside of the Qt source tree. Therefore
-    the recommended approach for making new platform plugin is to copy an existing plugin inside
-    the QTSRCTREE/src/plugins/platform and develop the plugin inside the source tree.
-
-    The minimal platform integration is the smallest platform integration it is possible to make,
-    which makes it an ideal starting point for new plugins. For a slightly more advanced plugin,
-    consider reviewing the directfb plugin, or the testlite plugin.
-*/
-
-/*!
-    \fn QPlatformPixmap *QPlatformIntegration::createPlatformPixmap(QPlatformPixmap::PixelType type) const
-
-    Factory function for QPlatformPixmap. PixelType can be either PixmapType or BitmapType.
-    \sa QPlatformPixmap
-*/
-
-/*!
-    \fn QPlatformWindow *QPlatformIntegration::createPlatformWindow(QWindow *window) const
-
-    Factory function for QPlatformWindow. The \a window parameter is a pointer to the top level
-    window which the QPlatformWindow is supposed to be created for.
-
-    All top level windows have to have a QPlatformWindow, and it will be created when the
-    QPlatformWindow is set to be visible for the first time. If the top level window's flags are
-    changed, or if the top level window's QPlatformWindowFormat is changed, then the top level
-    window's QPlatformWindow is deleted and a new one is created.
-
-    In the constructor, of the QPlatformWindow, the window flags, state, title and geometry
-    of the \a window should be applied to the underlying window. If the resulting flags or state
-    differs, the resulting values should be set on the \a window using QWindow::setWindowFlags()
-    or QWindow::setWindowState(), respectively.
-
-    \sa QPlatformWindow, QPlatformWindowFormat
-    \sa createPlatformBackingStore()
-*/
-
-/*!
-    \fn QPlatformBackingStore *QPlatformIntegration::createPlatformBackingStore(QWindow *window) const
-
-    Factory function for QPlatformBackingStore. The QWindow parameter is a pointer to the
-    top level widget(tlw) the window surface is created for. A QPlatformWindow is always created
-    before the QPlatformBackingStore for tlw where the widget also requires a backing store.
-
-    \sa QBackingStore
-    \sa createPlatformWindow()
-*/
-
-/*!
-    \enum QPlatformIntegration::Capability
-
-    Capabilities are used to determing specific features of a platform integration
-
-    \value ThreadedPixmaps The platform uses a pixmap implementation that is reentrant
-    and can be used from multiple threads, like the raster paint engine and QImage based
-    pixmaps.
-
-    \value OpenGL The platform supports OpenGL
-
-    \value ThreadedOpenGL The platform supports using OpenGL outside the GUI thread.
-
-    \value SharedGraphicsCache The platform supports a shared graphics cache
-
-    \value BufferQueueingOpenGL The OpenGL implementation on the platform will queue
-    up buffers when swapBuffers() is called and block only when its buffer pipeline
-    is full, rather than block immediately.
- */
-
-
-/*!
-
-    \fn QAbstractEventDispatcher *QPlatformIntegration::guiThreadEventDispatcher() const = 0
-
-    Accessor function for the event dispatcher. The platform plugin should create
-    an instance of the QAbstractEventDispatcher in its constructor and set it
-    on the application using QGuiApplicationPrivate::instance()->setEventDispatcher().
-    The event dispatcher is owned by QGuiApplication, the accessor should return
-    a flat pointer.
-    \sa QGuiApplicationPrivate
-*/
-
-bool QPlatformIntegration::hasCapability(Capability cap) const
-{
-    Q_UNUSED(cap);
-    return false;
-}
-
-QPlatformPixmap *QPlatformIntegration::createPlatformPixmap(QPlatformPixmap::PixelType type) const
-{
-    return new QRasterPlatformPixmap(type);
-}
-
-#ifndef QT_NO_OPENGL
-QPlatformOpenGLContext *QPlatformIntegration::createPlatformOpenGLContext(QOpenGLContext *context) const
-{
-    Q_UNUSED(context);
-    qWarning("This plugin does not support createPlatformOpenGLContext!");
-    return 0;
-}
-#endif
-
-/*!
-   Factory function for QPlatformSharedGraphicsCache. This function will return 0 if the platform
-   integration does not support any shared graphics cache mechanism for the given \a cacheId.
-*/
-QPlatformSharedGraphicsCache *QPlatformIntegration::createPlatformSharedGraphicsCache(const char *cacheId) const
-{
-    qWarning("This plugin does not support createPlatformSharedGraphicsBuffer for cacheId: %s!",
-             cacheId);
-    return 0;
-}
-
-/*!
-   Factory function for QPaintEngine. This function will return 0 if the platform
-   integration does not support creating any paint engine the given \a paintDevice.
-*/
-QPaintEngine *QPlatformIntegration::createImagePaintEngine(QPaintDevice *paintDevice) const
-{
-    Q_UNUSED(paintDevice)
-    return 0;
-}
-
-/*!
-  Returns the platforms input context.
-
-  The default implementation returns 0, implying no input method support.
-*/
-QPlatformInputContext *QPlatformIntegration::inputContext() const
-{
-    return 0;
-}
-
-#ifndef QT_NO_ACCESSIBILITY
-
-/*!
-  Returns the platforms accessibility.
-
-  The default implementation returns 0, implying no accessibility support.
-*/
-QPlatformAccessibility *QPlatformIntegration::accessibility() const
-{
-    return 0;
-}
-
-#endif
-
-QVariant QPlatformIntegration::styleHint(StyleHint hint) const
-{
-    switch (hint) {
-    case CursorFlashTime:
-        return 1000;
-    case KeyboardInputInterval:
-        return 400;
-    case KeyboardAutoRepeatRate:
-        return 30;
-    case MouseDoubleClickInterval:
-        return 400;
-    case StartDragDistance:
-        return 10;
-    case StartDragTime:
-        return 500;
-    case ShowIsFullScreen:
-        return false;
-    case PasswordMaskDelay:
-        return 0;
-    case FontSmoothingGamma:
-        return qreal(1.7);
-    case StartDragVelocity:
-        return 0; // no limit
-    }
-
-    return 0;
-}
-
-Qt::KeyboardModifiers QPlatformIntegration::queryKeyboardModifiers() const
-{
-    return QGuiApplication::keyboardModifiers();
-}
-
-/*!
-  Should be called by the implementation whenever a new screen is added.
-
-  The first screen added will be the primary screen, used for default-created
-  windows, GL contexts, and other resources unless otherwise specified.
-
-  This adds the screen to QGuiApplication::screens(), and emits the
-  QGuiApplication::screenAdded() signal.
-
-  The screen is automatically removed when the QPlatformScreen is destroyed.
-*/
-void QPlatformIntegration::screenAdded(QPlatformScreen *ps)
-{
-    QScreen *screen = new QScreen(ps);
-    ps->d_func()->screen = screen;
-    QGuiApplicationPrivate::screen_list << screen;
-    emit qGuiApp->screenAdded(screen);
-}
-
-QStringList QPlatformIntegration::themeNames() const
-{
-    return QStringList();
-}
-
-class QPlatformTheme *QPlatformIntegration::createPlatformTheme(const QString &name) const
-{
-    Q_UNUSED(name)
-    return new QPlatformTheme;
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformintegrationfactory.cpp b/src/gui/kernel/qplatformintegrationfactory.cpp
new file mode 100644
index 0000000..886f50b
--- /dev/null
+++ b/src/gui/kernel/qplatformintegrationfactory.cpp
@@ -0,0 +1,109 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qpa/qplatformintegrationfactory_p.h>
+#include <qpa/qplatformintegrationplugin.h>
+#include "private/qfactoryloader_p.h"
+#include "qmutex.h"
+#include "qdir.h"
+
+#include "qguiapplication.h"
+#include "qdebug.h"
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
+    (QPlatformIntegrationFactoryInterface_iid, QLatin1String("/platforms"), Qt::CaseInsensitive))
+Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, directLoader,
+                          (QPlatformIntegrationFactoryInterface_iid, QLatin1String(""), Qt::CaseInsensitive))
+#endif
+
+QPlatformIntegration *QPlatformIntegrationFactory::create(const QString& key, const QString &platformPluginPath)
+{
+    QStringList paramList = key.split(QLatin1Char(':'));
+    const QString platform = paramList.takeFirst().toLower();
+
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+    // Try loading the plugin from platformPluginPath first:
+    if (!platformPluginPath.isEmpty()) {
+        QCoreApplication::addLibraryPath(platformPluginPath);
+        if (QPlatformIntegration *ret = qLoadPlugin1<QPlatformIntegration, QPlatformIntegrationPlugin>(directLoader(), platform, paramList))
+            return ret;
+    }
+    if (QPlatformIntegration *ret = qLoadPlugin1<QPlatformIntegration, QPlatformIntegrationPlugin>(loader(), platform, paramList))
+        return ret;
+#endif
+    return 0;
+}
+
+/*!
+    Returns the list of valid keys, i.e. the keys this factory can
+    create styles for.
+
+    \sa create()
+*/
+
+QStringList QPlatformIntegrationFactory::keys(const QString &platformPluginPath)
+{
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+    QStringList list;
+    if (!platformPluginPath.isEmpty()) {
+        QCoreApplication::addLibraryPath(platformPluginPath);
+        list = directLoader()->keyMap().values();
+        if (!list.isEmpty()) {
+            const QString postFix = QStringLiteral(" (from ")
+                                    + QDir::toNativeSeparators(platformPluginPath)
+                                    + QLatin1Char(')');
+            const QStringList::iterator end = list.end();
+            for (QStringList::iterator it = list.begin(); it != end; ++it)
+                (*it).append(postFix);
+        }
+    }
+    list.append(loader()->keyMap().values());
+    return list;
+#else
+    return QStringList();
+#endif
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/gui/kernel/qplatformintegrationfactory_qpa.cpp b/src/gui/kernel/qplatformintegrationfactory_qpa.cpp
deleted file mode 100644
index 886f50b..0000000
--- a/src/gui/kernel/qplatformintegrationfactory_qpa.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qpa/qplatformintegrationfactory_p.h>
-#include <qpa/qplatformintegrationplugin.h>
-#include "private/qfactoryloader_p.h"
-#include "qmutex.h"
-#include "qdir.h"
-
-#include "qguiapplication.h"
-#include "qdebug.h"
-
-QT_BEGIN_NAMESPACE
-
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
-    (QPlatformIntegrationFactoryInterface_iid, QLatin1String("/platforms"), Qt::CaseInsensitive))
-Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, directLoader,
-                          (QPlatformIntegrationFactoryInterface_iid, QLatin1String(""), Qt::CaseInsensitive))
-#endif
-
-QPlatformIntegration *QPlatformIntegrationFactory::create(const QString& key, const QString &platformPluginPath)
-{
-    QStringList paramList = key.split(QLatin1Char(':'));
-    const QString platform = paramList.takeFirst().toLower();
-
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-    // Try loading the plugin from platformPluginPath first:
-    if (!platformPluginPath.isEmpty()) {
-        QCoreApplication::addLibraryPath(platformPluginPath);
-        if (QPlatformIntegration *ret = qLoadPlugin1<QPlatformIntegration, QPlatformIntegrationPlugin>(directLoader(), platform, paramList))
-            return ret;
-    }
-    if (QPlatformIntegration *ret = qLoadPlugin1<QPlatformIntegration, QPlatformIntegrationPlugin>(loader(), platform, paramList))
-        return ret;
-#endif
-    return 0;
-}
-
-/*!
-    Returns the list of valid keys, i.e. the keys this factory can
-    create styles for.
-
-    \sa create()
-*/
-
-QStringList QPlatformIntegrationFactory::keys(const QString &platformPluginPath)
-{
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-    QStringList list;
-    if (!platformPluginPath.isEmpty()) {
-        QCoreApplication::addLibraryPath(platformPluginPath);
-        list = directLoader()->keyMap().values();
-        if (!list.isEmpty()) {
-            const QString postFix = QStringLiteral(" (from ")
-                                    + QDir::toNativeSeparators(platformPluginPath)
-                                    + QLatin1Char(')');
-            const QStringList::iterator end = list.end();
-            for (QStringList::iterator it = list.begin(); it != end; ++it)
-                (*it).append(postFix);
-        }
-    }
-    list.append(loader()->keyMap().values());
-    return list;
-#else
-    return QStringList();
-#endif
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/gui/kernel/qplatformintegrationplugin.cpp b/src/gui/kernel/qplatformintegrationplugin.cpp
new file mode 100644
index 0000000..d4debd1
--- /dev/null
+++ b/src/gui/kernel/qplatformintegrationplugin.cpp
@@ -0,0 +1,55 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformintegrationplugin.h"
+
+QT_BEGIN_NAMESPACE
+
+QPlatformIntegrationPlugin::QPlatformIntegrationPlugin(QObject *parent)
+    : QObject(parent)
+{
+}
+
+QPlatformIntegrationPlugin::~QPlatformIntegrationPlugin()
+{
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformintegrationplugin_qpa.cpp b/src/gui/kernel/qplatformintegrationplugin_qpa.cpp
deleted file mode 100644
index d4debd1..0000000
--- a/src/gui/kernel/qplatformintegrationplugin_qpa.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformintegrationplugin.h"
-
-QT_BEGIN_NAMESPACE
-
-QPlatformIntegrationPlugin::QPlatformIntegrationPlugin(QObject *parent)
-    : QObject(parent)
-{
-}
-
-QPlatformIntegrationPlugin::~QPlatformIntegrationPlugin()
-{
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformnativeinterface.cpp b/src/gui/kernel/qplatformnativeinterface.cpp
new file mode 100644
index 0000000..f0bd3f0
--- /dev/null
+++ b/src/gui/kernel/qplatformnativeinterface.cpp
@@ -0,0 +1,196 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformnativeinterface.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformNativeInterface
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformNativeInterface class provides an abstraction for retrieving native
+    resource handles.
+ */
+
+void *QPlatformNativeInterface::nativeResourceForIntegration(const QByteArray &resource)
+{
+    Q_UNUSED(resource);
+    return 0;
+}
+void *QPlatformNativeInterface::nativeResourceForWindow(const QByteArray &resource, QWindow *window)
+{
+    Q_UNUSED(resource);
+    Q_UNUSED(window);
+    return 0;
+}
+
+void *QPlatformNativeInterface::nativeResourceForContext(const QByteArray &resource, QOpenGLContext *context)
+{
+    Q_UNUSED(resource);
+    Q_UNUSED(context);
+    return 0;
+}
+
+void * QPlatformNativeInterface::nativeResourceForBackingStore(const QByteArray &resource, QBackingStore *backingStore)
+{
+    Q_UNUSED(resource);
+    Q_UNUSED(backingStore);
+    return 0;
+}
+
+QPlatformNativeInterface::NativeResourceForIntegrationFunction QPlatformNativeInterface::nativeResourceFunctionForIntegration(const QByteArray &resource)
+{
+    Q_UNUSED(resource);
+    return 0;
+}
+
+QPlatformNativeInterface::NativeResourceForContextFunction QPlatformNativeInterface::nativeResourceFunctionForContext(const QByteArray &resource)
+{
+    Q_UNUSED(resource);
+    return 0;
+}
+
+QPlatformNativeInterface::NativeResourceForWindowFunction QPlatformNativeInterface::nativeResourceFunctionForWindow(const QByteArray &resource)
+{
+    Q_UNUSED(resource);
+    return 0;
+}
+
+QPlatformNativeInterface::NativeResourceForBackingStoreFunction QPlatformNativeInterface::nativeResourceFunctionForBackingStore(const QByteArray &resource)
+{
+    Q_UNUSED(resource);
+    return 0;
+}
+
+/*!
+    Contains generic window properties that the platform may utilize.
+*/
+QVariantMap QPlatformNativeInterface::windowProperties(QPlatformWindow *window) const
+{
+    Q_UNUSED(window)
+    return QVariantMap();
+}
+
+/*!
+    Returns a window property with \a name.
+
+    If the property does not exist, returns a default-constructed value.
+*/
+QVariant QPlatformNativeInterface::windowProperty(QPlatformWindow *window, const QString &name) const
+{
+    Q_UNUSED(window);
+    Q_UNUSED(name);
+    return QVariant();
+}
+
+/*!
+    Returns a window property with \a name. If the value does not exist, defaultValue is returned.
+*/
+QVariant QPlatformNativeInterface::windowProperty(QPlatformWindow *window, const QString &name, const QVariant &defaultValue) const
+{
+    Q_UNUSED(window);
+    Q_UNUSED(name);
+    Q_UNUSED(defaultValue);
+    return QVariant();
+}
+
+/*!
+    Sets a window property with \a name to \a value.
+*/
+void QPlatformNativeInterface::setWindowProperty(QPlatformWindow *window, const QString &name, const QVariant &value)
+{
+    Q_UNUSED(window);
+    Q_UNUSED(name);
+    Q_UNUSED(value);
+}
+
+/*!
+    \typedef QPlatformNativeInterface::EventFilter
+    \since 5.0
+
+    A function with the following signature that can be used as an
+    event filter:
+
+    \code
+    bool myEventFilter(void *message, long *result);
+    \endcode
+
+    \sa setEventFilter()
+*/
+
+/*!
+    \fn EventFilter QPlatformNativeInterface::setEventFilter(const QByteArray &eventType, EventFilter filter)
+    \since 5.0
+
+    Replaces the event filter function for the native interface with
+    \a filter and returns the pointer to the replaced event filter
+    function. Only the current event filter function is called. If you
+    want to use both filter functions, save the replaced EventFilter
+    in a place where you can call it from.
+
+    The event filter function set here is called for all messages
+    received from the platform if they are given type \eventType.
+    It is \e not called for messages that are not meant for Qt objects.
+
+    The type of event is specific to the platform plugin chosen at run-time.
+
+    The event filter function should return \c true if the message should
+    be filtered, (i.e. stopped). It should return \c false to allow
+    processing the message to continue.
+
+    By default, no event filter function is set. For example, this function
+    returns a null EventFilter the first time it is called.
+
+    \note The filter function here receives native messages,
+    for example, MSG or XEvent structs. It is called by the platform plugin.
+*/
+QPlatformNativeInterface::EventFilter QPlatformNativeInterface::setEventFilter(const QByteArray &eventType, QPlatformNativeInterface::EventFilter filter)
+{
+    Q_UNUSED(eventType);
+    Q_UNUSED(filter);
+    return 0;
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformnativeinterface_qpa.cpp b/src/gui/kernel/qplatformnativeinterface_qpa.cpp
deleted file mode 100644
index f0bd3f0..0000000
--- a/src/gui/kernel/qplatformnativeinterface_qpa.cpp
+++ /dev/null
@@ -1,196 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformnativeinterface.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformNativeInterface
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformNativeInterface class provides an abstraction for retrieving native
-    resource handles.
- */
-
-void *QPlatformNativeInterface::nativeResourceForIntegration(const QByteArray &resource)
-{
-    Q_UNUSED(resource);
-    return 0;
-}
-void *QPlatformNativeInterface::nativeResourceForWindow(const QByteArray &resource, QWindow *window)
-{
-    Q_UNUSED(resource);
-    Q_UNUSED(window);
-    return 0;
-}
-
-void *QPlatformNativeInterface::nativeResourceForContext(const QByteArray &resource, QOpenGLContext *context)
-{
-    Q_UNUSED(resource);
-    Q_UNUSED(context);
-    return 0;
-}
-
-void * QPlatformNativeInterface::nativeResourceForBackingStore(const QByteArray &resource, QBackingStore *backingStore)
-{
-    Q_UNUSED(resource);
-    Q_UNUSED(backingStore);
-    return 0;
-}
-
-QPlatformNativeInterface::NativeResourceForIntegrationFunction QPlatformNativeInterface::nativeResourceFunctionForIntegration(const QByteArray &resource)
-{
-    Q_UNUSED(resource);
-    return 0;
-}
-
-QPlatformNativeInterface::NativeResourceForContextFunction QPlatformNativeInterface::nativeResourceFunctionForContext(const QByteArray &resource)
-{
-    Q_UNUSED(resource);
-    return 0;
-}
-
-QPlatformNativeInterface::NativeResourceForWindowFunction QPlatformNativeInterface::nativeResourceFunctionForWindow(const QByteArray &resource)
-{
-    Q_UNUSED(resource);
-    return 0;
-}
-
-QPlatformNativeInterface::NativeResourceForBackingStoreFunction QPlatformNativeInterface::nativeResourceFunctionForBackingStore(const QByteArray &resource)
-{
-    Q_UNUSED(resource);
-    return 0;
-}
-
-/*!
-    Contains generic window properties that the platform may utilize.
-*/
-QVariantMap QPlatformNativeInterface::windowProperties(QPlatformWindow *window) const
-{
-    Q_UNUSED(window)
-    return QVariantMap();
-}
-
-/*!
-    Returns a window property with \a name.
-
-    If the property does not exist, returns a default-constructed value.
-*/
-QVariant QPlatformNativeInterface::windowProperty(QPlatformWindow *window, const QString &name) const
-{
-    Q_UNUSED(window);
-    Q_UNUSED(name);
-    return QVariant();
-}
-
-/*!
-    Returns a window property with \a name. If the value does not exist, defaultValue is returned.
-*/
-QVariant QPlatformNativeInterface::windowProperty(QPlatformWindow *window, const QString &name, const QVariant &defaultValue) const
-{
-    Q_UNUSED(window);
-    Q_UNUSED(name);
-    Q_UNUSED(defaultValue);
-    return QVariant();
-}
-
-/*!
-    Sets a window property with \a name to \a value.
-*/
-void QPlatformNativeInterface::setWindowProperty(QPlatformWindow *window, const QString &name, const QVariant &value)
-{
-    Q_UNUSED(window);
-    Q_UNUSED(name);
-    Q_UNUSED(value);
-}
-
-/*!
-    \typedef QPlatformNativeInterface::EventFilter
-    \since 5.0
-
-    A function with the following signature that can be used as an
-    event filter:
-
-    \code
-    bool myEventFilter(void *message, long *result);
-    \endcode
-
-    \sa setEventFilter()
-*/
-
-/*!
-    \fn EventFilter QPlatformNativeInterface::setEventFilter(const QByteArray &eventType, EventFilter filter)
-    \since 5.0
-
-    Replaces the event filter function for the native interface with
-    \a filter and returns the pointer to the replaced event filter
-    function. Only the current event filter function is called. If you
-    want to use both filter functions, save the replaced EventFilter
-    in a place where you can call it from.
-
-    The event filter function set here is called for all messages
-    received from the platform if they are given type \eventType.
-    It is \e not called for messages that are not meant for Qt objects.
-
-    The type of event is specific to the platform plugin chosen at run-time.
-
-    The event filter function should return \c true if the message should
-    be filtered, (i.e. stopped). It should return \c false to allow
-    processing the message to continue.
-
-    By default, no event filter function is set. For example, this function
-    returns a null EventFilter the first time it is called.
-
-    \note The filter function here receives native messages,
-    for example, MSG or XEvent structs. It is called by the platform plugin.
-*/
-QPlatformNativeInterface::EventFilter QPlatformNativeInterface::setEventFilter(const QByteArray &eventType, QPlatformNativeInterface::EventFilter filter)
-{
-    Q_UNUSED(eventType);
-    Q_UNUSED(filter);
-    return 0;
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformopenglcontext.cpp b/src/gui/kernel/qplatformopenglcontext.cpp
new file mode 100644
index 0000000..d38a586
--- /dev/null
+++ b/src/gui/kernel/qplatformopenglcontext.cpp
@@ -0,0 +1,121 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformopenglcontext.h"
+
+#include <QOpenGLFunctions>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformOpenGLContext
+    \since 4.8
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformOpenGLContext class provides an abstraction for native GL contexts.
+
+    In QPA the way to support OpenGL or OpenVG or other technologies that requires a native GL
+    context is through the QPlatformOpenGLContext wrapper.
+
+    There is no factory function for QPlatformOpenGLContexts, but rather only one accessor function.
+    The only place to retrieve a QPlatformOpenGLContext from is through a QPlatformWindow.
+
+    The context which is current for a specific thread can be collected by the currentContext()
+    function. This is how QPlatformOpenGLContext also makes it possible to use the QtGui module
+    withhout using QOpenGLWidget. When using QOpenGLContext::currentContext(), it will ask
+    QPlatformOpenGLContext for the currentContext. Then a corresponding QOpenGLContext will be returned,
+    which maps to the QPlatformOpenGLContext.
+*/
+
+/*! \fn void QPlatformOpenGLContext::swapBuffers(QPlatformSurface *surface)
+    Reimplement in subclass to native swap buffers calls
+
+    The implementation must support being called in a thread different than the gui-thread.
+*/
+
+/*! \fn QFunctionPointer QPlatformOpenGLContext::getProcAddress(const QByteArray &procName)
+    Reimplement in subclass to native getProcAddr calls.
+
+    Note: its convenient to use qPrintable(const QString &str) to get the const char * pointer
+*/
+
+class QPlatformOpenGLContextPrivate
+{
+public:
+    QPlatformOpenGLContextPrivate() : context(0) {}
+
+    QOpenGLContext *context;
+};
+
+QPlatformOpenGLContext::QPlatformOpenGLContext()
+    : d_ptr(new QPlatformOpenGLContextPrivate)
+{
+}
+
+QPlatformOpenGLContext::~QPlatformOpenGLContext()
+{
+}
+
+/*!
+    Reimplement in subclass if your platform uses framebuffer objects for surfaces.
+
+    The default implementation returns 0.
+*/
+GLuint QPlatformOpenGLContext::defaultFramebufferObject(QPlatformSurface *) const
+{
+    return 0;
+}
+
+QOpenGLContext *QPlatformOpenGLContext::context() const
+{
+    Q_D(const QPlatformOpenGLContext);
+    return d->context;
+}
+
+void QPlatformOpenGLContext::setContext(QOpenGLContext *context)
+{
+    Q_D(QPlatformOpenGLContext);
+    d->context = context;
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformopenglcontext_qpa.cpp b/src/gui/kernel/qplatformopenglcontext_qpa.cpp
deleted file mode 100644
index d38a586..0000000
--- a/src/gui/kernel/qplatformopenglcontext_qpa.cpp
+++ /dev/null
@@ -1,121 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformopenglcontext.h"
-
-#include <QOpenGLFunctions>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformOpenGLContext
-    \since 4.8
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformOpenGLContext class provides an abstraction for native GL contexts.
-
-    In QPA the way to support OpenGL or OpenVG or other technologies that requires a native GL
-    context is through the QPlatformOpenGLContext wrapper.
-
-    There is no factory function for QPlatformOpenGLContexts, but rather only one accessor function.
-    The only place to retrieve a QPlatformOpenGLContext from is through a QPlatformWindow.
-
-    The context which is current for a specific thread can be collected by the currentContext()
-    function. This is how QPlatformOpenGLContext also makes it possible to use the QtGui module
-    withhout using QOpenGLWidget. When using QOpenGLContext::currentContext(), it will ask
-    QPlatformOpenGLContext for the currentContext. Then a corresponding QOpenGLContext will be returned,
-    which maps to the QPlatformOpenGLContext.
-*/
-
-/*! \fn void QPlatformOpenGLContext::swapBuffers(QPlatformSurface *surface)
-    Reimplement in subclass to native swap buffers calls
-
-    The implementation must support being called in a thread different than the gui-thread.
-*/
-
-/*! \fn QFunctionPointer QPlatformOpenGLContext::getProcAddress(const QByteArray &procName)
-    Reimplement in subclass to native getProcAddr calls.
-
-    Note: its convenient to use qPrintable(const QString &str) to get the const char * pointer
-*/
-
-class QPlatformOpenGLContextPrivate
-{
-public:
-    QPlatformOpenGLContextPrivate() : context(0) {}
-
-    QOpenGLContext *context;
-};
-
-QPlatformOpenGLContext::QPlatformOpenGLContext()
-    : d_ptr(new QPlatformOpenGLContextPrivate)
-{
-}
-
-QPlatformOpenGLContext::~QPlatformOpenGLContext()
-{
-}
-
-/*!
-    Reimplement in subclass if your platform uses framebuffer objects for surfaces.
-
-    The default implementation returns 0.
-*/
-GLuint QPlatformOpenGLContext::defaultFramebufferObject(QPlatformSurface *) const
-{
-    return 0;
-}
-
-QOpenGLContext *QPlatformOpenGLContext::context() const
-{
-    Q_D(const QPlatformOpenGLContext);
-    return d->context;
-}
-
-void QPlatformOpenGLContext::setContext(QOpenGLContext *context)
-{
-    Q_D(QPlatformOpenGLContext);
-    d->context = context;
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformscreen.cpp b/src/gui/kernel/qplatformscreen.cpp
new file mode 100644
index 0000000..d946e4f
--- /dev/null
+++ b/src/gui/kernel/qplatformscreen.cpp
@@ -0,0 +1,338 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformscreen.h"
+#include <QtGui/qguiapplication.h>
+#include <qpa/qplatformcursor.h>
+#include <QtGui/private/qguiapplication_p.h>
+#include <qpa/qplatformscreen_p.h>
+#include <qpa/qplatformintegration.h>
+#include <QtGui/qscreen.h>
+#include <QtGui/qwindow.h>
+
+QT_BEGIN_NAMESPACE
+
+QPlatformScreen::QPlatformScreen()
+    : d_ptr(new QPlatformScreenPrivate)
+{
+    Q_D(QPlatformScreen);
+    d->screen = 0;
+}
+
+QPlatformScreen::~QPlatformScreen()
+{
+    Q_D(QPlatformScreen);
+
+    QGuiApplicationPrivate::screen_list.removeOne(d->screen);
+    delete d->screen;
+}
+
+/*!
+    \fn QPixmap QPlatformScreen::grabWindow(WId window, int x, int y, int width, int height) const
+
+    This function is called when Qt needs to be able to grab the content of a window.
+
+    Returnes the content of the window specified with the WId handle within the boundaries of
+    QRect(x,y,width,height).
+*/
+QPixmap QPlatformScreen::grabWindow(WId window, int x, int y, int width, int height) const
+{
+    Q_UNUSED(window);
+    Q_UNUSED(x);
+    Q_UNUSED(y);
+    Q_UNUSED(width);
+    Q_UNUSED(height);
+    return QPixmap();
+}
+
+/*!
+    Return the given top level window for a given position.
+
+    Default implementation retrieves a list of all top level windows and finds the first window
+    which contains point \a pos
+*/
+QWindow *QPlatformScreen::topLevelAt(const QPoint & pos) const
+{
+    QWindowList list = QGuiApplication::topLevelWindows();
+    for (int i = list.size()-1; i >= 0; --i) {
+        QWindow *w = list[i];
+        if (w->isVisible() && w->geometry().contains(pos))
+            return w;
+    }
+
+    return 0;
+}
+
+/*!
+    Returns a list of all the platform screens that are part of the same
+    virtual desktop.
+
+    Screens part of the same virtual desktop share a common coordinate system,
+    and windows can be freely moved between them.
+*/
+QList<QPlatformScreen *> QPlatformScreen::virtualSiblings() const
+{
+    QList<QPlatformScreen *> list;
+    list << const_cast<QPlatformScreen *>(this);
+    return list;
+}
+
+QScreen *QPlatformScreen::screen() const
+{
+    Q_D(const QPlatformScreen);
+    return d->screen;
+}
+
+/*!
+    Reimplement this function in subclass to return the physical size of the
+    screen, in millimeters. The physical size represents the actual physical
+    dimensions of the display.
+
+    The default implementation takes the pixel size of the screen, considers a
+    resolution of 100 dots per inch, and returns the calculated physical size.
+    A device with a screen that has different resolutions will need to be
+    supported by a suitable reimplementation of this function.
+
+    \sa logcalDpi
+*/
+QSizeF QPlatformScreen::physicalSize() const
+{
+    static const int dpi = 100;
+    return QSizeF(geometry().size()) / dpi * qreal(25.4);
+}
+
+/*!
+    Reimplement this function in subclass to return the logical horizontal
+    and vertical dots per inch metrics of the screen.
+
+    The logical dots per inch metrics are used by QFont to convert point sizes
+    to pixel sizes.
+
+    The default implementation uses the screen pixel size and physical size to
+    compute the metrics.
+
+    \sa physicalSize
+*/
+QDpi QPlatformScreen::logicalDpi() const
+{
+    QSizeF ps = physicalSize();
+    QSize s = geometry().size();
+
+    return QDpi(25.4 * s.width() / ps.width(),
+                25.4 * s.height() / ps.height());
+}
+
+/*!
+    Reimplement this function in subclass to return the vertical refresh rate
+    of the screen, in Hz.
+
+    The default returns 60, a sensible default for modern displays.
+*/
+qreal QPlatformScreen::refreshRate() const
+{
+    return 60;
+}
+
+/*!
+    Reimplement this function in subclass to return the native orientation
+    of the screen, e.g. the orientation where the logo sticker of the device
+    appears the right way up.
+
+    The default implementation returns Qt::PrimaryOrientation.
+*/
+Qt::ScreenOrientation QPlatformScreen::nativeOrientation() const
+{
+    return Qt::PrimaryOrientation;
+}
+
+/*!
+    Reimplement this function in subclass to return the current orientation
+    of the screen, for example based on accelerometer data to determine
+    the device orientation.
+
+    The default implementation returns Qt::PrimaryOrientation.
+*/
+Qt::ScreenOrientation QPlatformScreen::orientation() const
+{
+    return Qt::PrimaryOrientation;
+}
+
+/*
+    Reimplement this function in subclass to filter out unneeded screen
+    orientation updates.
+
+    The orientations will anyway be filtered before QScreen::orientationChanged()
+    is emitted, but the mask can be used by the platform plugin for example to
+    prevent having to have an accelerometer sensor running all the time, or to
+    improve the reported values. As an example of the latter, in case of only
+    Landscape | InvertedLandscape being set in the mask, on a platform that gets
+    its orientation readings from an accelerometer sensor embedded in a handheld
+    device, the platform can report transitions between the two even when the
+    device is held in an orientation that's closer to portrait.
+
+    By default, the orientation update mask is empty, so unless this function
+    has been called with a non-empty mask the platform does not need to report
+    any orientation updates through
+    QWindowSystemInterface::handleScreenOrientationChange().
+*/
+void QPlatformScreen::setOrientationUpdateMask(Qt::ScreenOrientations mask)
+{
+    Q_UNUSED(mask);
+}
+
+QPlatformScreen * QPlatformScreen::platformScreenForWindow(const QWindow *window)
+{
+    return window->screen()->handle();
+}
+
+/*!
+    \class QPlatformScreen
+    \since 4.8
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformScreen class provides an abstraction for visual displays.
+
+    Many window systems has support for retrieving information on the attached displays. To be able
+    to query the display QPA uses QPlatformScreen. Qt its self is most dependent on the
+    physicalSize() function, since this is the function it uses to calculate the dpi to use when
+    converting point sizes to pixels sizes. However, this is unfortunate on some systems, as the
+    native system fakes its dpi size.
+
+    QPlatformScreen is also used by the public api QDesktopWidget for information about the desktop.
+ */
+
+/*! \fn QRect QPlatformScreen::geometry() const = 0
+    Reimplement in subclass to return the pixel geometry of the screen
+*/
+
+/*! \fn QRect QPlatformScreen::availableGeometry() const
+    Reimplement in subclass to return the pixel geometry of the available space
+    This normally is the desktop screen minus the task manager, global menubar etc.
+*/
+
+/*! \fn int QPlatformScreen::depth() const = 0
+    Reimplement in subclass to return current depth of the screen
+*/
+
+/*! \fn QImage::Format QPlatformScreen::format() const = 0
+    Reimplement in subclass to return the image format which corresponds to the screen format
+*/
+
+
+/*!
+    \class QPlatformScreenPageFlipper
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformScreenPageFlipper class provides an abstract interface for display buffer swapping
+
+    Implement the displayBuffer() function to initiate a buffer swap. The
+    bufferDisplayed() signal should be emitted once the buffer is actually displayed on
+    the screen. The bufferReleased() signal should be emitted when the buffer data is no
+    longer owned by the display hardware.
+*/
+
+/*!  \fn bool QPlatformScreenPageFlipper::displayBuffer(void *bufferHandle)
+
+Implemented in subclasses to display the buffer referenced by \a bufferHandle directly on
+the screen. Returns \c true if it is possible to display the buffer, and \c false if the
+buffer cannot be displayed.
+
+If this function returns true, the buffer must not be modified or destroyed before the
+bufferReleased() signal is emitted.  The signal bufferDisplayed() is emitted when the buffer
+is displayed on the screen. The two signals may be emitted in either order.
+
+This function is allowed to block.
+*/
+
+
+/*!
+  Implemented in subclasses to return a page flipper object for the screen, or 0 if the
+  hardware does not support page flipping. The default implementation returns 0.
+ */
+QPlatformScreenPageFlipper *QPlatformScreen::pageFlipper() const
+{
+    return 0;
+}
+
+/*!
+    Reimplement this function in subclass to return the cursor of the screen.
+
+    The default implementation returns 0.
+*/
+QPlatformCursor *QPlatformScreen::cursor() const
+{
+    return 0;
+}
+
+/*!
+  Convenience method to resize all the maximized and fullscreen windows
+  of this platform screen.
+*/
+void QPlatformScreen::resizeMaximizedWindows()
+{
+    QList<QWindow*> windows = QGuiApplication::allWindows();
+
+    // 'screen()' still has the old geometry info while 'this' has the new geometry info
+    const QRect oldGeometry = screen()->geometry();
+    const QRect oldAvailableGeometry = screen()->availableGeometry();
+    const QRect newGeometry = geometry();
+    const QRect newAvailableGeometry = availableGeometry();
+
+    // make sure maximized and fullscreen windows are updated
+    for (int i = 0; i < windows.size(); ++i) {
+        QWindow *w = windows.at(i);
+
+        if (platformScreenForWindow(w) != this)
+            continue;
+
+        if (w->windowState() & Qt::WindowFullScreen || w->geometry() == oldGeometry)
+            w->setGeometry(newGeometry);
+        else if (w->windowState() & Qt::WindowMaximized || w->geometry() == oldAvailableGeometry)
+            w->setGeometry(newAvailableGeometry);
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformscreen_qpa.cpp b/src/gui/kernel/qplatformscreen_qpa.cpp
deleted file mode 100644
index d946e4f..0000000
--- a/src/gui/kernel/qplatformscreen_qpa.cpp
+++ /dev/null
@@ -1,338 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformscreen.h"
-#include <QtGui/qguiapplication.h>
-#include <qpa/qplatformcursor.h>
-#include <QtGui/private/qguiapplication_p.h>
-#include <qpa/qplatformscreen_p.h>
-#include <qpa/qplatformintegration.h>
-#include <QtGui/qscreen.h>
-#include <QtGui/qwindow.h>
-
-QT_BEGIN_NAMESPACE
-
-QPlatformScreen::QPlatformScreen()
-    : d_ptr(new QPlatformScreenPrivate)
-{
-    Q_D(QPlatformScreen);
-    d->screen = 0;
-}
-
-QPlatformScreen::~QPlatformScreen()
-{
-    Q_D(QPlatformScreen);
-
-    QGuiApplicationPrivate::screen_list.removeOne(d->screen);
-    delete d->screen;
-}
-
-/*!
-    \fn QPixmap QPlatformScreen::grabWindow(WId window, int x, int y, int width, int height) const
-
-    This function is called when Qt needs to be able to grab the content of a window.
-
-    Returnes the content of the window specified with the WId handle within the boundaries of
-    QRect(x,y,width,height).
-*/
-QPixmap QPlatformScreen::grabWindow(WId window, int x, int y, int width, int height) const
-{
-    Q_UNUSED(window);
-    Q_UNUSED(x);
-    Q_UNUSED(y);
-    Q_UNUSED(width);
-    Q_UNUSED(height);
-    return QPixmap();
-}
-
-/*!
-    Return the given top level window for a given position.
-
-    Default implementation retrieves a list of all top level windows and finds the first window
-    which contains point \a pos
-*/
-QWindow *QPlatformScreen::topLevelAt(const QPoint & pos) const
-{
-    QWindowList list = QGuiApplication::topLevelWindows();
-    for (int i = list.size()-1; i >= 0; --i) {
-        QWindow *w = list[i];
-        if (w->isVisible() && w->geometry().contains(pos))
-            return w;
-    }
-
-    return 0;
-}
-
-/*!
-    Returns a list of all the platform screens that are part of the same
-    virtual desktop.
-
-    Screens part of the same virtual desktop share a common coordinate system,
-    and windows can be freely moved between them.
-*/
-QList<QPlatformScreen *> QPlatformScreen::virtualSiblings() const
-{
-    QList<QPlatformScreen *> list;
-    list << const_cast<QPlatformScreen *>(this);
-    return list;
-}
-
-QScreen *QPlatformScreen::screen() const
-{
-    Q_D(const QPlatformScreen);
-    return d->screen;
-}
-
-/*!
-    Reimplement this function in subclass to return the physical size of the
-    screen, in millimeters. The physical size represents the actual physical
-    dimensions of the display.
-
-    The default implementation takes the pixel size of the screen, considers a
-    resolution of 100 dots per inch, and returns the calculated physical size.
-    A device with a screen that has different resolutions will need to be
-    supported by a suitable reimplementation of this function.
-
-    \sa logcalDpi
-*/
-QSizeF QPlatformScreen::physicalSize() const
-{
-    static const int dpi = 100;
-    return QSizeF(geometry().size()) / dpi * qreal(25.4);
-}
-
-/*!
-    Reimplement this function in subclass to return the logical horizontal
-    and vertical dots per inch metrics of the screen.
-
-    The logical dots per inch metrics are used by QFont to convert point sizes
-    to pixel sizes.
-
-    The default implementation uses the screen pixel size and physical size to
-    compute the metrics.
-
-    \sa physicalSize
-*/
-QDpi QPlatformScreen::logicalDpi() const
-{
-    QSizeF ps = physicalSize();
-    QSize s = geometry().size();
-
-    return QDpi(25.4 * s.width() / ps.width(),
-                25.4 * s.height() / ps.height());
-}
-
-/*!
-    Reimplement this function in subclass to return the vertical refresh rate
-    of the screen, in Hz.
-
-    The default returns 60, a sensible default for modern displays.
-*/
-qreal QPlatformScreen::refreshRate() const
-{
-    return 60;
-}
-
-/*!
-    Reimplement this function in subclass to return the native orientation
-    of the screen, e.g. the orientation where the logo sticker of the device
-    appears the right way up.
-
-    The default implementation returns Qt::PrimaryOrientation.
-*/
-Qt::ScreenOrientation QPlatformScreen::nativeOrientation() const
-{
-    return Qt::PrimaryOrientation;
-}
-
-/*!
-    Reimplement this function in subclass to return the current orientation
-    of the screen, for example based on accelerometer data to determine
-    the device orientation.
-
-    The default implementation returns Qt::PrimaryOrientation.
-*/
-Qt::ScreenOrientation QPlatformScreen::orientation() const
-{
-    return Qt::PrimaryOrientation;
-}
-
-/*
-    Reimplement this function in subclass to filter out unneeded screen
-    orientation updates.
-
-    The orientations will anyway be filtered before QScreen::orientationChanged()
-    is emitted, but the mask can be used by the platform plugin for example to
-    prevent having to have an accelerometer sensor running all the time, or to
-    improve the reported values. As an example of the latter, in case of only
-    Landscape | InvertedLandscape being set in the mask, on a platform that gets
-    its orientation readings from an accelerometer sensor embedded in a handheld
-    device, the platform can report transitions between the two even when the
-    device is held in an orientation that's closer to portrait.
-
-    By default, the orientation update mask is empty, so unless this function
-    has been called with a non-empty mask the platform does not need to report
-    any orientation updates through
-    QWindowSystemInterface::handleScreenOrientationChange().
-*/
-void QPlatformScreen::setOrientationUpdateMask(Qt::ScreenOrientations mask)
-{
-    Q_UNUSED(mask);
-}
-
-QPlatformScreen * QPlatformScreen::platformScreenForWindow(const QWindow *window)
-{
-    return window->screen()->handle();
-}
-
-/*!
-    \class QPlatformScreen
-    \since 4.8
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformScreen class provides an abstraction for visual displays.
-
-    Many window systems has support for retrieving information on the attached displays. To be able
-    to query the display QPA uses QPlatformScreen. Qt its self is most dependent on the
-    physicalSize() function, since this is the function it uses to calculate the dpi to use when
-    converting point sizes to pixels sizes. However, this is unfortunate on some systems, as the
-    native system fakes its dpi size.
-
-    QPlatformScreen is also used by the public api QDesktopWidget for information about the desktop.
- */
-
-/*! \fn QRect QPlatformScreen::geometry() const = 0
-    Reimplement in subclass to return the pixel geometry of the screen
-*/
-
-/*! \fn QRect QPlatformScreen::availableGeometry() const
-    Reimplement in subclass to return the pixel geometry of the available space
-    This normally is the desktop screen minus the task manager, global menubar etc.
-*/
-
-/*! \fn int QPlatformScreen::depth() const = 0
-    Reimplement in subclass to return current depth of the screen
-*/
-
-/*! \fn QImage::Format QPlatformScreen::format() const = 0
-    Reimplement in subclass to return the image format which corresponds to the screen format
-*/
-
-
-/*!
-    \class QPlatformScreenPageFlipper
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformScreenPageFlipper class provides an abstract interface for display buffer swapping
-
-    Implement the displayBuffer() function to initiate a buffer swap. The
-    bufferDisplayed() signal should be emitted once the buffer is actually displayed on
-    the screen. The bufferReleased() signal should be emitted when the buffer data is no
-    longer owned by the display hardware.
-*/
-
-/*!  \fn bool QPlatformScreenPageFlipper::displayBuffer(void *bufferHandle)
-
-Implemented in subclasses to display the buffer referenced by \a bufferHandle directly on
-the screen. Returns \c true if it is possible to display the buffer, and \c false if the
-buffer cannot be displayed.
-
-If this function returns true, the buffer must not be modified or destroyed before the
-bufferReleased() signal is emitted.  The signal bufferDisplayed() is emitted when the buffer
-is displayed on the screen. The two signals may be emitted in either order.
-
-This function is allowed to block.
-*/
-
-
-/*!
-  Implemented in subclasses to return a page flipper object for the screen, or 0 if the
-  hardware does not support page flipping. The default implementation returns 0.
- */
-QPlatformScreenPageFlipper *QPlatformScreen::pageFlipper() const
-{
-    return 0;
-}
-
-/*!
-    Reimplement this function in subclass to return the cursor of the screen.
-
-    The default implementation returns 0.
-*/
-QPlatformCursor *QPlatformScreen::cursor() const
-{
-    return 0;
-}
-
-/*!
-  Convenience method to resize all the maximized and fullscreen windows
-  of this platform screen.
-*/
-void QPlatformScreen::resizeMaximizedWindows()
-{
-    QList<QWindow*> windows = QGuiApplication::allWindows();
-
-    // 'screen()' still has the old geometry info while 'this' has the new geometry info
-    const QRect oldGeometry = screen()->geometry();
-    const QRect oldAvailableGeometry = screen()->availableGeometry();
-    const QRect newGeometry = geometry();
-    const QRect newAvailableGeometry = availableGeometry();
-
-    // make sure maximized and fullscreen windows are updated
-    for (int i = 0; i < windows.size(); ++i) {
-        QWindow *w = windows.at(i);
-
-        if (platformScreenForWindow(w) != this)
-            continue;
-
-        if (w->windowState() & Qt::WindowFullScreen || w->geometry() == oldGeometry)
-            w->setGeometry(newGeometry);
-        else if (w->windowState() & Qt::WindowMaximized || w->geometry() == oldAvailableGeometry)
-            w->setGeometry(newAvailableGeometry);
-    }
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformscreenpageflipper.cpp b/src/gui/kernel/qplatformscreenpageflipper.cpp
new file mode 100644
index 0000000..babecb0
--- /dev/null
+++ b/src/gui/kernel/qplatformscreenpageflipper.cpp
@@ -0,0 +1,104 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformscreenpageflipper.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformScreenBuffer
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformScreenBuffer class provides an abstraction for screen buffers.
+ */
+QPlatformScreenBuffer::QPlatformScreenBuffer()
+    : m_destroyed(false)
+    , m_ready(true)
+{
+
+}
+
+QPlatformScreenBuffer::~QPlatformScreenBuffer()
+{
+
+}
+
+bool QPlatformScreenBuffer::isDestroyed() const
+{
+    return m_destroyed;
+}
+
+bool QPlatformScreenBuffer::isReady() const
+{
+    return m_ready;
+}
+
+void QPlatformScreenBuffer::aboutToBeDisplayed()
+{
+}
+
+void QPlatformScreenBuffer::displayed()
+{
+}
+
+
+/*!
+    \class QPlatformScreenPageFlipper
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformScreenPageFlipper class provides an abstraction for flipping the screen
+    page.
+ */
+
+QPlatformScreenPageFlipper::QPlatformScreenPageFlipper(QObject *parent)
+    :QObject(parent)
+{
+
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/gui/kernel/qplatformscreenpageflipper_qpa.cpp b/src/gui/kernel/qplatformscreenpageflipper_qpa.cpp
deleted file mode 100644
index babecb0..0000000
--- a/src/gui/kernel/qplatformscreenpageflipper_qpa.cpp
+++ /dev/null
@@ -1,104 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformscreenpageflipper.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformScreenBuffer
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformScreenBuffer class provides an abstraction for screen buffers.
- */
-QPlatformScreenBuffer::QPlatformScreenBuffer()
-    : m_destroyed(false)
-    , m_ready(true)
-{
-
-}
-
-QPlatformScreenBuffer::~QPlatformScreenBuffer()
-{
-
-}
-
-bool QPlatformScreenBuffer::isDestroyed() const
-{
-    return m_destroyed;
-}
-
-bool QPlatformScreenBuffer::isReady() const
-{
-    return m_ready;
-}
-
-void QPlatformScreenBuffer::aboutToBeDisplayed()
-{
-}
-
-void QPlatformScreenBuffer::displayed()
-{
-}
-
-
-/*!
-    \class QPlatformScreenPageFlipper
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformScreenPageFlipper class provides an abstraction for flipping the screen
-    page.
- */
-
-QPlatformScreenPageFlipper::QPlatformScreenPageFlipper(QObject *parent)
-    :QObject(parent)
-{
-
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/gui/kernel/qplatformservices.cpp b/src/gui/kernel/qplatformservices.cpp
new file mode 100644
index 0000000..9a1ea40
--- /dev/null
+++ b/src/gui/kernel/qplatformservices.cpp
@@ -0,0 +1,84 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformservices.h"
+
+#include <QtCore/QUrl>
+#include <QtCore/QString>
+#include <QtCore/QDebug>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformServices
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformServices provides the backend for desktop-related functionality.
+*/
+
+bool QPlatformServices::openUrl(const QUrl &url)
+{
+    qWarning("This plugin does not support QPlatformServices::openUrl() for '%s'.",
+             qPrintable(url.toString()));
+    return false;
+}
+
+bool QPlatformServices::openDocument(const QUrl &url)
+{
+    qWarning("This plugin does not support QPlatformServices::openDocument() for '%s'.",
+             qPrintable(url.toString()));
+    return false;
+}
+
+/*!
+ * \brief QPlatformServices::desktopEnvironment returns the active desktop environment.
+ * \return On Unix this function returns KDE, GNOME or UNKNOWN.
+ */
+QByteArray QPlatformServices::desktopEnvironment() const
+{
+    return QByteArray("UNKNOWN");
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformservices_qpa.cpp b/src/gui/kernel/qplatformservices_qpa.cpp
deleted file mode 100644
index 9a1ea40..0000000
--- a/src/gui/kernel/qplatformservices_qpa.cpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformservices.h"
-
-#include <QtCore/QUrl>
-#include <QtCore/QString>
-#include <QtCore/QDebug>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformServices
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformServices provides the backend for desktop-related functionality.
-*/
-
-bool QPlatformServices::openUrl(const QUrl &url)
-{
-    qWarning("This plugin does not support QPlatformServices::openUrl() for '%s'.",
-             qPrintable(url.toString()));
-    return false;
-}
-
-bool QPlatformServices::openDocument(const QUrl &url)
-{
-    qWarning("This plugin does not support QPlatformServices::openDocument() for '%s'.",
-             qPrintable(url.toString()));
-    return false;
-}
-
-/*!
- * \brief QPlatformServices::desktopEnvironment returns the active desktop environment.
- * \return On Unix this function returns KDE, GNOME or UNKNOWN.
- */
-QByteArray QPlatformServices::desktopEnvironment() const
-{
-    return QByteArray("UNKNOWN");
-}
-
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformsharedgraphicscache.cpp b/src/gui/kernel/qplatformsharedgraphicscache.cpp
new file mode 100644
index 0000000..e38ece3
--- /dev/null
+++ b/src/gui/kernel/qplatformsharedgraphicscache.cpp
@@ -0,0 +1,296 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformsharedgraphicscache.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformSharedGraphicsCache
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+    \brief The QPlatformSharedGraphicsCache is an abstraction of a cross-process graphics cache.
+
+    If supported, it is possible to retrieve a QPlatformSharedGraphicsCache object from the
+    platform integration. This is typically used to store graphical items which should be shared
+    between several processes.
+
+    Items are requested from the cache by calling requestItems(). If the cache contains the
+    requested items in the requested cache, the itemsAvailable() signal is emitted with the ID of
+    the graphical buffer and each item's coordinates inside the buffer. Before requesting items
+    from a cache, the user must call ensureCacheInitialized() to set the correct parameters for
+    the cache.
+
+    If the cache does not yet contain the requested items, it will emit a similar itemsMissing()
+    signal. The client can then call updateItems() with rasterizations of the items and they will be
+    entered into the shared cache. As the items are rendered into the cache, itemsAvailable() signals
+    will be emitted for each of the items which have previously been requested and which have not
+    yet been reported as ready.
+
+    Using beginRequestBatch() and endRequestBatch(), it's possible to batch glyph requests, which
+    could improve performance in cases where you have a sequence of requests pending, and you
+    do not need the results during this sequence.
+*/
+
+/*!
+    \enum BufferType
+
+    Defines how the type of buffer required to contain a cache.
+
+    \value OpenGLTexture The buffer will be allocated in graphics memory, and an OpenGL texture
+                         for a buffer belonging to the cache can be requested using
+                         textureIdForBuffer().
+*/
+
+/*!
+    \enum PixelFormat
+
+    Defines the pixel format of a cache.
+
+    \value Alpha8 The cache will use 8 bits to represent the alpha value of each pixel. If an
+                  OpenGL texture is created for a buffer belong to the cache, it will have the
+                  pixel format GL_ALPHA.
+*/
+
+/*!
+   \fn void ensureCacheInitialized(const QByteArray &cacheId, BufferType bufferType, PixelFormat pixelFormat)
+
+   Initializes a cache named \a cacheId if it has not yet been initialized. The \a bufferType and
+   \a pixelFormat gives the format of the buffers that will be used to contain the items in the
+   cache. If a cache with the same \a cacheId has previously been initialized, the call will be
+   ignored. The cache will keep its previously set buffer type and pixel format.
+*/
+
+/*!
+    \fn void QPlatformSharedGraphicsCache::requestItems(const QByteArray &cacheId, const QVector<quint32> &itemIds)
+
+    Requests all the items in \a itemIds from the cache with the name \a cacheId.
+
+    If any or all of the items are available in the cache, one or more itemsAvailable() signals will be
+    emitted corresponding to the items. If the cache does not contain all of the items in question,
+    then an itemsMissing() signal will be emitted corresponding to the missing items. The user
+    is at this point expected to call insertItems() to insert the missing items into the cache. If
+    the inserted items have previously been requested by the user, at which point an itemsAvailable()
+    signal will be emitted corresponding to the items.
+
+    Before requesting items from a cache, the user must call ensureCacheInitialized() with the
+    correct parameters for the cache.
+*/
+
+/*!
+    \fn void QPlatformSharedGraphicsCache::insertItems(const QByteArray &cacheId, const QVector<quint32> &itemIds, const QVector<QImage> &items)
+
+    Inserts the items in \a itemIds into the cache named \a cacheId. The appearance of
+    each item is stored in \a items. The format of the QImage objects is expected to match the
+    pixel format of the cache as it was initialized in ensureCacheInitialized().
+
+    When the items have been successfully entered into the cache, one or more itemsAvailable() signals
+    will be emitted for the items.
+
+    If the cache already contains the items, the behavior is implementation-specific. The
+    implementation may choose to ignore the items or it may overwrite the existing instances in
+    the cache. Either way, itemsAvailable() signals corresponding to the inserted items will be
+    emitted.
+*/
+
+/*!
+    \fn void QPlatformSharedGraphicsCache::releaseItems(const QByteArray &cacheId, const QVector<quint32> &itemIds)
+
+    Releases the reference to the items in \a itemIds from the cache named \a cacheId. This should
+    only be called when all references to the items have been released by the user, and they are no
+    longer needed.
+*/
+
+/*!
+    \fn void itemsMissing(const QByteArray &cacheId, const QVector<quint32> *itemIds)
+
+    This signal is emitted when requestItems() has been called for one or more items in the
+    cache named \a cacheId which are not yet available in the cache. The user is then expected to
+    call insertItems() to update the cache with the respective items, at which point they will
+    become available to all clients of the shared cache.
+
+    The vector \a itemIds contains the IDs of the items that need to be inserted into the cache.
+
+    \sa itemsAvailable(), insertItems(), requestItems()
+*/
+
+/*!
+    \fn void itemsAvailable(const QByteArray &cacheId, void *bufferId, const QSize &bufferSize, const QVector<quint32> &itemIds, const QVector<QPoint> &positionsInBuffer)
+
+    This signal can be emitted at any time when either requestItems() or insertItems() has been
+    called by the application for one or more items in the cache named \a cacheId, as long as
+    releaseItems() has not subsequently been called for the same items. It instructs the application
+    on where to find the items that have been entered into the cache. When the application receives
+    a buffer, it is expected to reference it using referenceBuffer() on it if it keeps a reference
+    to the buffer.
+
+    The \a bufferId is an ID for the buffer that contains the items. The \a bufferId can be
+    converted to a format usable by the application depending on which format it was given at
+    initialization. If it is a OpenGLTexture, its texture ID can be requested using the
+    textureIdForBuffer() function. The dimensions of the buffer are given by \a bufferSize.
+
+    The items provided by the cache are identified in the \a itemIds vector. The
+    \a positionsInBuffer vector contains the locations inside the buffer of each item. Each entry in
+    \a positionsInBuffer corresponds to an item in \a itemIds.
+
+    The buffer and the items' locations within the buffer can be considered valid until an
+    itemsInvalidated() signal has been emitted for the items, or until releaseItems() is called
+    for the items.
+
+    \sa itemsMissing(), requestItems(), bufferType()
+*/
+
+/*!
+    \fn void itemsUpdated(const QByteArray &cacheId, void *bufferId, const QSize &bufferSize, const QVector<quint32> &itemIds, const QVector<QPoint> &positionsInBuffer)
+
+    This signal is similar in usage to the itemsAvailable() signal, but will be emitted when
+    the location of a previously requested or inserted item has been updated. The application
+    must update its data for the respective items and release any references to old buffers held
+    by the items.
+
+    If the application no longer holds any references to previously referenced items in a given
+    cache, it should call releaseItems() for these items, at which point it will no longer receive
+    any itemsUpdated() signal for these items.
+
+    \sa requestItems(), insertItems(), itemsAvailable()
+*/
+
+/*!
+    \fn void itemsInvalidated(const QByteArray &cacheId, const QVector<quint32> &itemIds)
+
+    This signal is emitted when the items given by \a itemIds in the cache named \a cacheId have
+    been removed from the cache and the previously reported information about them is considered
+    invalid. It will only be emitted for items for which a buffer has previously been identified
+    through the itemsAvailable() signal (either as response to a requestItems() call or an
+    insertItems() call.)
+
+    The application is expected to throw away information about the items in the \a itemIds array
+    and drop any references it might have to the memory held by the buffer. If the items are still
+    required by the application, it can re-commit them to the cache using the insertItems() function.
+
+    If the application no longer holds any references to previously referenced items in a given
+    cache, it should call releaseItems() for these items, at which point it will no longer receive
+    any itemsInvalidated() signal for these items.
+*/
+
+/*!
+    \fn void beginRequestBatch()
+
+    This is a hint to the cache that a burst of requests is pending. In some implementations, this
+    will improve performance, as the cache can focus on handling the requests and wait with the
+    results until it is done. It should typically be called prior to a sequence of calls to
+    requestItems() and releaseItems().
+
+    Any call to beginRequestBatch() must be followed at some point by a call to endRequestBatch().
+    Failing to do this may lead to the results of requests never being emitted.
+
+    \note beginRequestBatch() and endRequestBatch() have no stacking logic. Calling
+    beginRequestBatch() twice in a row has no effect, and the single existing batch will be ended
+    by the earliest call to endRequestBatch().
+
+    \sa endRequestBatch(), requestBatchStarted()
+*/
+
+/*!
+    \fn void endRequestBatch()
+
+    Signals to the cache that the request sequence which has previously been commenced using
+    beginRequestBatch() has now finished.
+
+    \sa beginRequestBatch(), requestBatchStarted()
+*/
+
+/*!
+   \fn bool requestBatchStarted() const
+
+   Returns true if a request batch has previously been started using beginRequestBatch()
+   and not yet stopped using endRequestBatch().
+
+   \sa beginRequestBatch(), endRequestBatch()
+*/
+
+/*!
+    \fn uint textureIdForBuffer(void *bufferId)
+
+    Returns an OpenGL texture ID corresponding to the buffer \a bufferId, which has previously
+    been passed through signals itemsAvailable() or itemsUpdated(). The relevant OpenGL context
+    should be current when calling this function.
+
+    \sa eglImageForBuffer(), sizeOfBuffer()
+*/
+
+/*!
+    \fn void *eglImageForBuffer(void *bufferId)
+
+    Returns an EGLImageKHR image corresponding to the buffer \a bufferId.
+
+    \sa textureIdForBuffer(), sizeOfBuffer()
+*/
+
+/*!
+    \fn void referenceBuffer(void *bufferId)
+
+    Registers a reference to the buffer \a bufferId.
+
+    \sa dereferenceBuffer()
+*/
+
+/*!
+    \fn bool dereferenceBuffer(void *bufferId)
+
+    Removed a previously registered reference to the buffer \a bufferId. Returns true if there
+    are still more references to the buffer in question, or false if this was the last reference
+    (in which case the buffer may have been deleted in the cache.)
+
+    \sa dereferenceBuffer()
+*/
+
+/*!
+    \fn QSize sizeOfBuffer(void *bufferId)
+
+    Returns the size of the buffer \a bufferId.
+
+    \sa textureIdForBuffer(), eglImageForBuffer()
+*/
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformsharedgraphicscache_qpa.cpp b/src/gui/kernel/qplatformsharedgraphicscache_qpa.cpp
deleted file mode 100644
index e38ece3..0000000
--- a/src/gui/kernel/qplatformsharedgraphicscache_qpa.cpp
+++ /dev/null
@@ -1,296 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformsharedgraphicscache.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformSharedGraphicsCache
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-    \brief The QPlatformSharedGraphicsCache is an abstraction of a cross-process graphics cache.
-
-    If supported, it is possible to retrieve a QPlatformSharedGraphicsCache object from the
-    platform integration. This is typically used to store graphical items which should be shared
-    between several processes.
-
-    Items are requested from the cache by calling requestItems(). If the cache contains the
-    requested items in the requested cache, the itemsAvailable() signal is emitted with the ID of
-    the graphical buffer and each item's coordinates inside the buffer. Before requesting items
-    from a cache, the user must call ensureCacheInitialized() to set the correct parameters for
-    the cache.
-
-    If the cache does not yet contain the requested items, it will emit a similar itemsMissing()
-    signal. The client can then call updateItems() with rasterizations of the items and they will be
-    entered into the shared cache. As the items are rendered into the cache, itemsAvailable() signals
-    will be emitted for each of the items which have previously been requested and which have not
-    yet been reported as ready.
-
-    Using beginRequestBatch() and endRequestBatch(), it's possible to batch glyph requests, which
-    could improve performance in cases where you have a sequence of requests pending, and you
-    do not need the results during this sequence.
-*/
-
-/*!
-    \enum BufferType
-
-    Defines how the type of buffer required to contain a cache.
-
-    \value OpenGLTexture The buffer will be allocated in graphics memory, and an OpenGL texture
-                         for a buffer belonging to the cache can be requested using
-                         textureIdForBuffer().
-*/
-
-/*!
-    \enum PixelFormat
-
-    Defines the pixel format of a cache.
-
-    \value Alpha8 The cache will use 8 bits to represent the alpha value of each pixel. If an
-                  OpenGL texture is created for a buffer belong to the cache, it will have the
-                  pixel format GL_ALPHA.
-*/
-
-/*!
-   \fn void ensureCacheInitialized(const QByteArray &cacheId, BufferType bufferType, PixelFormat pixelFormat)
-
-   Initializes a cache named \a cacheId if it has not yet been initialized. The \a bufferType and
-   \a pixelFormat gives the format of the buffers that will be used to contain the items in the
-   cache. If a cache with the same \a cacheId has previously been initialized, the call will be
-   ignored. The cache will keep its previously set buffer type and pixel format.
-*/
-
-/*!
-    \fn void QPlatformSharedGraphicsCache::requestItems(const QByteArray &cacheId, const QVector<quint32> &itemIds)
-
-    Requests all the items in \a itemIds from the cache with the name \a cacheId.
-
-    If any or all of the items are available in the cache, one or more itemsAvailable() signals will be
-    emitted corresponding to the items. If the cache does not contain all of the items in question,
-    then an itemsMissing() signal will be emitted corresponding to the missing items. The user
-    is at this point expected to call insertItems() to insert the missing items into the cache. If
-    the inserted items have previously been requested by the user, at which point an itemsAvailable()
-    signal will be emitted corresponding to the items.
-
-    Before requesting items from a cache, the user must call ensureCacheInitialized() with the
-    correct parameters for the cache.
-*/
-
-/*!
-    \fn void QPlatformSharedGraphicsCache::insertItems(const QByteArray &cacheId, const QVector<quint32> &itemIds, const QVector<QImage> &items)
-
-    Inserts the items in \a itemIds into the cache named \a cacheId. The appearance of
-    each item is stored in \a items. The format of the QImage objects is expected to match the
-    pixel format of the cache as it was initialized in ensureCacheInitialized().
-
-    When the items have been successfully entered into the cache, one or more itemsAvailable() signals
-    will be emitted for the items.
-
-    If the cache already contains the items, the behavior is implementation-specific. The
-    implementation may choose to ignore the items or it may overwrite the existing instances in
-    the cache. Either way, itemsAvailable() signals corresponding to the inserted items will be
-    emitted.
-*/
-
-/*!
-    \fn void QPlatformSharedGraphicsCache::releaseItems(const QByteArray &cacheId, const QVector<quint32> &itemIds)
-
-    Releases the reference to the items in \a itemIds from the cache named \a cacheId. This should
-    only be called when all references to the items have been released by the user, and they are no
-    longer needed.
-*/
-
-/*!
-    \fn void itemsMissing(const QByteArray &cacheId, const QVector<quint32> *itemIds)
-
-    This signal is emitted when requestItems() has been called for one or more items in the
-    cache named \a cacheId which are not yet available in the cache. The user is then expected to
-    call insertItems() to update the cache with the respective items, at which point they will
-    become available to all clients of the shared cache.
-
-    The vector \a itemIds contains the IDs of the items that need to be inserted into the cache.
-
-    \sa itemsAvailable(), insertItems(), requestItems()
-*/
-
-/*!
-    \fn void itemsAvailable(const QByteArray &cacheId, void *bufferId, const QSize &bufferSize, const QVector<quint32> &itemIds, const QVector<QPoint> &positionsInBuffer)
-
-    This signal can be emitted at any time when either requestItems() or insertItems() has been
-    called by the application for one or more items in the cache named \a cacheId, as long as
-    releaseItems() has not subsequently been called for the same items. It instructs the application
-    on where to find the items that have been entered into the cache. When the application receives
-    a buffer, it is expected to reference it using referenceBuffer() on it if it keeps a reference
-    to the buffer.
-
-    The \a bufferId is an ID for the buffer that contains the items. The \a bufferId can be
-    converted to a format usable by the application depending on which format it was given at
-    initialization. If it is a OpenGLTexture, its texture ID can be requested using the
-    textureIdForBuffer() function. The dimensions of the buffer are given by \a bufferSize.
-
-    The items provided by the cache are identified in the \a itemIds vector. The
-    \a positionsInBuffer vector contains the locations inside the buffer of each item. Each entry in
-    \a positionsInBuffer corresponds to an item in \a itemIds.
-
-    The buffer and the items' locations within the buffer can be considered valid until an
-    itemsInvalidated() signal has been emitted for the items, or until releaseItems() is called
-    for the items.
-
-    \sa itemsMissing(), requestItems(), bufferType()
-*/
-
-/*!
-    \fn void itemsUpdated(const QByteArray &cacheId, void *bufferId, const QSize &bufferSize, const QVector<quint32> &itemIds, const QVector<QPoint> &positionsInBuffer)
-
-    This signal is similar in usage to the itemsAvailable() signal, but will be emitted when
-    the location of a previously requested or inserted item has been updated. The application
-    must update its data for the respective items and release any references to old buffers held
-    by the items.
-
-    If the application no longer holds any references to previously referenced items in a given
-    cache, it should call releaseItems() for these items, at which point it will no longer receive
-    any itemsUpdated() signal for these items.
-
-    \sa requestItems(), insertItems(), itemsAvailable()
-*/
-
-/*!
-    \fn void itemsInvalidated(const QByteArray &cacheId, const QVector<quint32> &itemIds)
-
-    This signal is emitted when the items given by \a itemIds in the cache named \a cacheId have
-    been removed from the cache and the previously reported information about them is considered
-    invalid. It will only be emitted for items for which a buffer has previously been identified
-    through the itemsAvailable() signal (either as response to a requestItems() call or an
-    insertItems() call.)
-
-    The application is expected to throw away information about the items in the \a itemIds array
-    and drop any references it might have to the memory held by the buffer. If the items are still
-    required by the application, it can re-commit them to the cache using the insertItems() function.
-
-    If the application no longer holds any references to previously referenced items in a given
-    cache, it should call releaseItems() for these items, at which point it will no longer receive
-    any itemsInvalidated() signal for these items.
-*/
-
-/*!
-    \fn void beginRequestBatch()
-
-    This is a hint to the cache that a burst of requests is pending. In some implementations, this
-    will improve performance, as the cache can focus on handling the requests and wait with the
-    results until it is done. It should typically be called prior to a sequence of calls to
-    requestItems() and releaseItems().
-
-    Any call to beginRequestBatch() must be followed at some point by a call to endRequestBatch().
-    Failing to do this may lead to the results of requests never being emitted.
-
-    \note beginRequestBatch() and endRequestBatch() have no stacking logic. Calling
-    beginRequestBatch() twice in a row has no effect, and the single existing batch will be ended
-    by the earliest call to endRequestBatch().
-
-    \sa endRequestBatch(), requestBatchStarted()
-*/
-
-/*!
-    \fn void endRequestBatch()
-
-    Signals to the cache that the request sequence which has previously been commenced using
-    beginRequestBatch() has now finished.
-
-    \sa beginRequestBatch(), requestBatchStarted()
-*/
-
-/*!
-   \fn bool requestBatchStarted() const
-
-   Returns true if a request batch has previously been started using beginRequestBatch()
-   and not yet stopped using endRequestBatch().
-
-   \sa beginRequestBatch(), endRequestBatch()
-*/
-
-/*!
-    \fn uint textureIdForBuffer(void *bufferId)
-
-    Returns an OpenGL texture ID corresponding to the buffer \a bufferId, which has previously
-    been passed through signals itemsAvailable() or itemsUpdated(). The relevant OpenGL context
-    should be current when calling this function.
-
-    \sa eglImageForBuffer(), sizeOfBuffer()
-*/
-
-/*!
-    \fn void *eglImageForBuffer(void *bufferId)
-
-    Returns an EGLImageKHR image corresponding to the buffer \a bufferId.
-
-    \sa textureIdForBuffer(), sizeOfBuffer()
-*/
-
-/*!
-    \fn void referenceBuffer(void *bufferId)
-
-    Registers a reference to the buffer \a bufferId.
-
-    \sa dereferenceBuffer()
-*/
-
-/*!
-    \fn bool dereferenceBuffer(void *bufferId)
-
-    Removed a previously registered reference to the buffer \a bufferId. Returns true if there
-    are still more references to the buffer in question, or false if this was the last reference
-    (in which case the buffer may have been deleted in the cache.)
-
-    \sa dereferenceBuffer()
-*/
-
-/*!
-    \fn QSize sizeOfBuffer(void *bufferId)
-
-    Returns the size of the buffer \a bufferId.
-
-    \sa textureIdForBuffer(), eglImageForBuffer()
-*/
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformsurface.cpp b/src/gui/kernel/qplatformsurface.cpp
new file mode 100644
index 0000000..464c971
--- /dev/null
+++ b/src/gui/kernel/qplatformsurface.cpp
@@ -0,0 +1,70 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformsurface.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformSurface
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformSurface class provides an abstraction for a surface.
+ */
+QPlatformSurface::~QPlatformSurface()
+{
+
+}
+
+QSurface *QPlatformSurface::surface() const
+{
+    return m_surface;
+}
+
+QPlatformSurface::QPlatformSurface(QSurface *surface) : m_surface(surface)
+{
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/gui/kernel/qplatformsurface_qpa.cpp b/src/gui/kernel/qplatformsurface_qpa.cpp
deleted file mode 100644
index 464c971..0000000
--- a/src/gui/kernel/qplatformsurface_qpa.cpp
+++ /dev/null
@@ -1,70 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformsurface.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformSurface
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformSurface class provides an abstraction for a surface.
- */
-QPlatformSurface::~QPlatformSurface()
-{
-
-}
-
-QSurface *QPlatformSurface::surface() const
-{
-    return m_surface;
-}
-
-QPlatformSurface::QPlatformSurface(QSurface *surface) : m_surface(surface)
-{
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/gui/kernel/qplatformtheme.cpp b/src/gui/kernel/qplatformtheme.cpp
new file mode 100644
index 0000000..1038eb2
--- /dev/null
+++ b/src/gui/kernel/qplatformtheme.cpp
@@ -0,0 +1,195 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformtheme.h"
+
+#include <QtCore/QVariant>
+#include <QtCore/QStringList>
+#include <qpalette.h>
+#include <qtextformat.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformTheme
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+    \brief The QPlatformTheme class allows customizing the UI based on themes.
+
+*/
+
+/*!
+    \enum QPlatformTheme::ThemeHint
+
+    This enum describes the available theme hints.
+
+    \value TextCursorWidth  (int) Determines the width of the text cursor.
+
+    \value DropShadow       (bool) Determines whether the drop shadow effect for
+                            tooltips or whatsthis is enabled.
+
+    \value MaximumScrollBarDragDistance (int) Determines the value returned by
+                            QStyle::pixelMetric(PM_MaximumDragDistance)
+
+    \value ToolButtonStyle (int) A value representing a Qt::ToolButtonStyle.
+
+    \value ToolBarIconSize Icon size for tool bars.
+
+    \value SystemIconThemeName (QString) Name of the icon theme.
+
+    \value SystemIconFallbackThemeName (QString) Name of the fallback icon theme.
+
+    \value IconThemeSearchPaths (QStringList) Search paths for icons.
+
+    \value ItemViewActivateItemOnSingleClick (bool) Activate items by single click.
+
+    \value StyleNames (QStringList) A list of preferred style names.
+
+    \value WindowAutoPlacement (bool) A boolean value indicating whether Windows
+                               (particularly dialogs) are placed by the system
+                               (see _NET_WM_FULL_PLACEMENT in X11).
+
+    \value DialogButtonBoxLayout (int) An integer representing a
+                                 QDialogButtonBox::ButtonLayout value.
+
+    \value DialogButtonBoxButtonsHaveIcons (bool) A boolean value indicating whether
+                                            the buttons of a QDialogButtonBox should have icons.
+
+    \value UseFullScreenForPopupMenu (bool) Pop menus can cover the full screen including task bar.
+
+    \value KeyboardScheme (int) An integer value (enum KeyboardSchemes) specifying the
+                           keyboard scheme.
+
+    \value UiEffects (int) A flag value consisting of UiEffect values specifying the enabled UI animations.
+
+    \value SpellCheckUnderlineStyle (int) A QTextCharFormat::UnderlineStyle specifying
+                                    the underline style used misspelled words when spell checking.
+
+    \sa themeHint(), QStyle::pixelMetric()
+*/
+
+QPlatformTheme::~QPlatformTheme()
+{
+
+}
+
+bool QPlatformTheme::usePlatformNativeDialog(DialogType type) const
+{
+    Q_UNUSED(type);
+    return false;
+}
+
+QPlatformDialogHelper *QPlatformTheme::createPlatformDialogHelper(DialogType type) const
+{
+    Q_UNUSED(type);
+    return 0;
+}
+
+const QPalette *QPlatformTheme::palette(Palette type) const
+{
+    Q_UNUSED(type)
+    return 0;
+}
+
+const QFont *QPlatformTheme::font(Font type) const
+{
+    Q_UNUSED(type)
+    return 0;
+}
+
+QVariant QPlatformTheme::themeHint(ThemeHint hint) const
+{
+    switch (hint) {
+    case QPlatformTheme::UseFullScreenForPopupMenu:
+        return QVariant(false);
+    case QPlatformTheme::WindowAutoPlacement:
+        return QVariant(false);
+    case QPlatformTheme::DialogButtonBoxLayout:
+        return QVariant(int(0));
+    case QPlatformTheme::DialogButtonBoxButtonsHaveIcons:
+        return QVariant(false);
+    case QPlatformTheme::ItemViewActivateItemOnSingleClick:
+        return QVariant(false);
+    case QPlatformTheme::ToolButtonStyle:
+        return QVariant(int(Qt::ToolButtonIconOnly));
+    case QPlatformTheme::ToolBarIconSize:
+        return QVariant(int(0));
+    case QPlatformTheme::SystemIconThemeName:
+    case QPlatformTheme::SystemIconFallbackThemeName:
+        return QVariant(QString());
+    case QPlatformTheme::IconThemeSearchPaths:
+        return QVariant(QStringList());
+    case QPlatformTheme::StyleNames:
+        return QVariant(QStringList());
+    case TextCursorWidth:
+        return QVariant(1);
+    case DropShadow:
+        return QVariant(false);
+    case MaximumScrollBarDragDistance:
+        return QVariant(-1);
+    case KeyboardScheme:
+        return QVariant(int(WindowsKeyboardScheme));
+    case UiEffects:
+        return QVariant(int(0));
+    case SpellCheckUnderlineStyle:
+        return QVariant(int(QTextCharFormat::SpellCheckUnderline));
+    }
+    return QVariant();
+}
+
+QPlatformMenuItem *QPlatformTheme::createPlatformMenuItem() const
+{
+    return 0;
+}
+
+QPlatformMenu *QPlatformTheme::createPlatformMenu() const
+{
+    return 0;
+}
+
+QPlatformMenuBar *QPlatformTheme::createPlatformMenuBar() const
+{
+    return 0;
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformtheme_qpa.cpp b/src/gui/kernel/qplatformtheme_qpa.cpp
deleted file mode 100644
index 1038eb2..0000000
--- a/src/gui/kernel/qplatformtheme_qpa.cpp
+++ /dev/null
@@ -1,195 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformtheme.h"
-
-#include <QtCore/QVariant>
-#include <QtCore/QStringList>
-#include <qpalette.h>
-#include <qtextformat.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformTheme
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-    \brief The QPlatformTheme class allows customizing the UI based on themes.
-
-*/
-
-/*!
-    \enum QPlatformTheme::ThemeHint
-
-    This enum describes the available theme hints.
-
-    \value TextCursorWidth  (int) Determines the width of the text cursor.
-
-    \value DropShadow       (bool) Determines whether the drop shadow effect for
-                            tooltips or whatsthis is enabled.
-
-    \value MaximumScrollBarDragDistance (int) Determines the value returned by
-                            QStyle::pixelMetric(PM_MaximumDragDistance)
-
-    \value ToolButtonStyle (int) A value representing a Qt::ToolButtonStyle.
-
-    \value ToolBarIconSize Icon size for tool bars.
-
-    \value SystemIconThemeName (QString) Name of the icon theme.
-
-    \value SystemIconFallbackThemeName (QString) Name of the fallback icon theme.
-
-    \value IconThemeSearchPaths (QStringList) Search paths for icons.
-
-    \value ItemViewActivateItemOnSingleClick (bool) Activate items by single click.
-
-    \value StyleNames (QStringList) A list of preferred style names.
-
-    \value WindowAutoPlacement (bool) A boolean value indicating whether Windows
-                               (particularly dialogs) are placed by the system
-                               (see _NET_WM_FULL_PLACEMENT in X11).
-
-    \value DialogButtonBoxLayout (int) An integer representing a
-                                 QDialogButtonBox::ButtonLayout value.
-
-    \value DialogButtonBoxButtonsHaveIcons (bool) A boolean value indicating whether
-                                            the buttons of a QDialogButtonBox should have icons.
-
-    \value UseFullScreenForPopupMenu (bool) Pop menus can cover the full screen including task bar.
-
-    \value KeyboardScheme (int) An integer value (enum KeyboardSchemes) specifying the
-                           keyboard scheme.
-
-    \value UiEffects (int) A flag value consisting of UiEffect values specifying the enabled UI animations.
-
-    \value SpellCheckUnderlineStyle (int) A QTextCharFormat::UnderlineStyle specifying
-                                    the underline style used misspelled words when spell checking.
-
-    \sa themeHint(), QStyle::pixelMetric()
-*/
-
-QPlatformTheme::~QPlatformTheme()
-{
-
-}
-
-bool QPlatformTheme::usePlatformNativeDialog(DialogType type) const
-{
-    Q_UNUSED(type);
-    return false;
-}
-
-QPlatformDialogHelper *QPlatformTheme::createPlatformDialogHelper(DialogType type) const
-{
-    Q_UNUSED(type);
-    return 0;
-}
-
-const QPalette *QPlatformTheme::palette(Palette type) const
-{
-    Q_UNUSED(type)
-    return 0;
-}
-
-const QFont *QPlatformTheme::font(Font type) const
-{
-    Q_UNUSED(type)
-    return 0;
-}
-
-QVariant QPlatformTheme::themeHint(ThemeHint hint) const
-{
-    switch (hint) {
-    case QPlatformTheme::UseFullScreenForPopupMenu:
-        return QVariant(false);
-    case QPlatformTheme::WindowAutoPlacement:
-        return QVariant(false);
-    case QPlatformTheme::DialogButtonBoxLayout:
-        return QVariant(int(0));
-    case QPlatformTheme::DialogButtonBoxButtonsHaveIcons:
-        return QVariant(false);
-    case QPlatformTheme::ItemViewActivateItemOnSingleClick:
-        return QVariant(false);
-    case QPlatformTheme::ToolButtonStyle:
-        return QVariant(int(Qt::ToolButtonIconOnly));
-    case QPlatformTheme::ToolBarIconSize:
-        return QVariant(int(0));
-    case QPlatformTheme::SystemIconThemeName:
-    case QPlatformTheme::SystemIconFallbackThemeName:
-        return QVariant(QString());
-    case QPlatformTheme::IconThemeSearchPaths:
-        return QVariant(QStringList());
-    case QPlatformTheme::StyleNames:
-        return QVariant(QStringList());
-    case TextCursorWidth:
-        return QVariant(1);
-    case DropShadow:
-        return QVariant(false);
-    case MaximumScrollBarDragDistance:
-        return QVariant(-1);
-    case KeyboardScheme:
-        return QVariant(int(WindowsKeyboardScheme));
-    case UiEffects:
-        return QVariant(int(0));
-    case SpellCheckUnderlineStyle:
-        return QVariant(int(QTextCharFormat::SpellCheckUnderline));
-    }
-    return QVariant();
-}
-
-QPlatformMenuItem *QPlatformTheme::createPlatformMenuItem() const
-{
-    return 0;
-}
-
-QPlatformMenu *QPlatformTheme::createPlatformMenu() const
-{
-    return 0;
-}
-
-QPlatformMenuBar *QPlatformTheme::createPlatformMenuBar() const
-{
-    return 0;
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformthemefactory.cpp b/src/gui/kernel/qplatformthemefactory.cpp
new file mode 100644
index 0000000..cc20399
--- /dev/null
+++ b/src/gui/kernel/qplatformthemefactory.cpp
@@ -0,0 +1,108 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qpa/qplatformthemefactory_p.h>
+#include <qpa/qplatformthemeplugin.h>
+#include <QDir>
+#include "private/qfactoryloader_p.h"
+#include "qmutex.h"
+
+#include "qguiapplication.h"
+#include "qdebug.h"
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
+    (QPlatformThemeFactoryInterface_iid, QLatin1String("/platformthemes"), Qt::CaseInsensitive))
+Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, directLoader,
+                          (QPlatformThemeFactoryInterface_iid, QLatin1String(""), Qt::CaseInsensitive))
+#endif
+
+QPlatformTheme *QPlatformThemeFactory::create(const QString& key, const QString &platformPluginPath)
+{
+    QStringList paramList = key.split(QLatin1Char(':'));
+    const QString platform = paramList.takeFirst().toLower();
+
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+    // Try loading the plugin from platformPluginPath first:
+    if (!platformPluginPath.isEmpty()) {
+        QCoreApplication::addLibraryPath(platformPluginPath);
+        if (QPlatformTheme *ret = qLoadPlugin1<QPlatformTheme, QPlatformThemePlugin>(directLoader(), platform, paramList))
+            return ret;
+    }
+    if (QPlatformTheme *ret = qLoadPlugin1<QPlatformTheme, QPlatformThemePlugin>(loader(), platform, paramList))
+           return ret;
+#endif
+    return 0;
+}
+
+/*!
+    Returns the list of valid keys, i.e. the keys this factory can
+    create styles for.
+
+    \sa create()
+*/
+QStringList QPlatformThemeFactory::keys(const QString &platformPluginPath)
+{
+#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
+    QStringList list;
+
+    if (!platformPluginPath.isEmpty()) {
+        QCoreApplication::addLibraryPath(platformPluginPath);
+        list += directLoader()->keyMap().values();
+        if (!list.isEmpty()) {
+            const QString postFix = QStringLiteral(" (from ")
+                    + QDir::toNativeSeparators(platformPluginPath)
+                    + QLatin1Char(')');
+            const QStringList::iterator end = list.end();
+            for (QStringList::iterator it = list.begin(); it != end; ++it)
+                (*it).append(postFix);
+        }
+    }
+    list += loader()->keyMap().values();
+    return list;
+#else
+    return QStringList();
+#endif
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformthemefactory_qpa.cpp b/src/gui/kernel/qplatformthemefactory_qpa.cpp
deleted file mode 100644
index cc20399..0000000
--- a/src/gui/kernel/qplatformthemefactory_qpa.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qpa/qplatformthemefactory_p.h>
-#include <qpa/qplatformthemeplugin.h>
-#include <QDir>
-#include "private/qfactoryloader_p.h"
-#include "qmutex.h"
-
-#include "qguiapplication.h"
-#include "qdebug.h"
-
-QT_BEGIN_NAMESPACE
-
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
-    (QPlatformThemeFactoryInterface_iid, QLatin1String("/platformthemes"), Qt::CaseInsensitive))
-Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, directLoader,
-                          (QPlatformThemeFactoryInterface_iid, QLatin1String(""), Qt::CaseInsensitive))
-#endif
-
-QPlatformTheme *QPlatformThemeFactory::create(const QString& key, const QString &platformPluginPath)
-{
-    QStringList paramList = key.split(QLatin1Char(':'));
-    const QString platform = paramList.takeFirst().toLower();
-
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-    // Try loading the plugin from platformPluginPath first:
-    if (!platformPluginPath.isEmpty()) {
-        QCoreApplication::addLibraryPath(platformPluginPath);
-        if (QPlatformTheme *ret = qLoadPlugin1<QPlatformTheme, QPlatformThemePlugin>(directLoader(), platform, paramList))
-            return ret;
-    }
-    if (QPlatformTheme *ret = qLoadPlugin1<QPlatformTheme, QPlatformThemePlugin>(loader(), platform, paramList))
-           return ret;
-#endif
-    return 0;
-}
-
-/*!
-    Returns the list of valid keys, i.e. the keys this factory can
-    create styles for.
-
-    \sa create()
-*/
-QStringList QPlatformThemeFactory::keys(const QString &platformPluginPath)
-{
-#if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-    QStringList list;
-
-    if (!platformPluginPath.isEmpty()) {
-        QCoreApplication::addLibraryPath(platformPluginPath);
-        list += directLoader()->keyMap().values();
-        if (!list.isEmpty()) {
-            const QString postFix = QStringLiteral(" (from ")
-                    + QDir::toNativeSeparators(platformPluginPath)
-                    + QLatin1Char(')');
-            const QStringList::iterator end = list.end();
-            for (QStringList::iterator it = list.begin(); it != end; ++it)
-                (*it).append(postFix);
-        }
-    }
-    list += loader()->keyMap().values();
-    return list;
-#else
-    return QStringList();
-#endif
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformthemeplugin.cpp b/src/gui/kernel/qplatformthemeplugin.cpp
new file mode 100644
index 0000000..74cbb1a
--- /dev/null
+++ b/src/gui/kernel/qplatformthemeplugin.cpp
@@ -0,0 +1,64 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformthemeplugin.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformThemePlugin
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformThemePlugin class provides an abstraction for theme plugins.
+ */
+QPlatformThemePlugin::QPlatformThemePlugin(QObject *parent)
+    : QObject(parent)
+{
+}
+
+QPlatformThemePlugin::~QPlatformThemePlugin()
+{
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformthemeplugin_qpa.cpp b/src/gui/kernel/qplatformthemeplugin_qpa.cpp
deleted file mode 100644
index 74cbb1a..0000000
--- a/src/gui/kernel/qplatformthemeplugin_qpa.cpp
+++ /dev/null
@@ -1,64 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformthemeplugin.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformThemePlugin
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformThemePlugin class provides an abstraction for theme plugins.
- */
-QPlatformThemePlugin::QPlatformThemePlugin(QObject *parent)
-    : QObject(parent)
-{
-}
-
-QPlatformThemePlugin::~QPlatformThemePlugin()
-{
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformwindow.cpp b/src/gui/kernel/qplatformwindow.cpp
new file mode 100644
index 0000000..3c2246c
--- /dev/null
+++ b/src/gui/kernel/qplatformwindow.cpp
@@ -0,0 +1,430 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformwindow.h"
+
+#include <QtGui/qwindowsysteminterface_qpa.h>
+#include <QtGui/qwindow.h>
+#include <QtGui/qscreen.h>
+
+QT_BEGIN_NAMESPACE
+
+class QPlatformWindowPrivate
+{
+    QRect rect;
+    friend class QPlatformWindow;
+};
+
+/*!
+    Constructs a platform window with the given top level window.
+*/
+
+QPlatformWindow::QPlatformWindow(QWindow *window)
+    : QPlatformSurface(window)
+    , d_ptr(new QPlatformWindowPrivate)
+{
+    Q_D(QPlatformWindow);
+    d->rect = window->geometry();
+}
+
+/*!
+    Virtual destructor does not delete its top level window.
+*/
+QPlatformWindow::~QPlatformWindow()
+{
+}
+
+/*!
+    Returns the window which belongs to the QPlatformWindow
+*/
+QWindow *QPlatformWindow::window() const
+{
+    return static_cast<QWindow *>(m_surface);
+}
+
+/*!
+    Returns the parent platform window (or 0 if orphan).
+*/
+QPlatformWindow *QPlatformWindow::parent() const
+{
+    return window()->parent() ? window()->parent()->handle() : 0;
+}
+
+/*!
+    Returns the platform screen handle corresponding to this platform window.
+*/
+QPlatformScreen *QPlatformWindow::screen() const
+{
+    return window()->screen()->handle();
+}
+
+/*!
+    Returns the actual surface format of the window.
+*/
+QSurfaceFormat QPlatformWindow::format() const
+{
+    return QSurfaceFormat();
+}
+
+/*!
+    This function is called by Qt whenever a window is moved or the window is resized. The resize
+    can happen programatically(from ie. user application) or by the window manager. This means that
+    there is no need to call this function specifically from the window manager callback, instead
+    call QWindowSystemInterface::handleGeometryChange(QWindow *w, const QRect &newRect);
+
+    The position(x, y) part of the rect might be inclusive or exclusive of the window frame
+    as returned by frameMargins(). You can detect this in the plugin by checking
+    qt_window_private(window())->positionPolicy.
+*/
+void QPlatformWindow::setGeometry(const QRect &rect)
+{
+    Q_D(QPlatformWindow);
+    d->rect = rect;
+}
+
+/*!
+    Returnes the current geometry of a window
+*/
+QRect QPlatformWindow::geometry() const
+{
+    Q_D(const QPlatformWindow);
+    return d->rect;
+}
+
+QMargins QPlatformWindow::frameMargins() const
+{
+    return QMargins();
+}
+
+/*!
+    Reimplemented in subclasses to show the surface
+    if \a visible is \c true, and hide it if \a visible is \c false.
+
+    The default implementation sends a synchronous expose event.
+*/
+void QPlatformWindow::setVisible(bool visible)
+{
+    Q_UNUSED(visible);
+    QRect rect(QPoint(), geometry().size());
+    QWindowSystemInterface::handleSynchronousExposeEvent(window(), rect);
+}
+/*!
+    Requests setting the window flags of this surface
+    to \a type. Returns the actual flags set.
+*/
+Qt::WindowFlags QPlatformWindow::setWindowFlags(Qt::WindowFlags flags)
+{
+    return flags;
+}
+
+
+
+/*!
+    Returns if this window is exposed in the windowing system.
+
+    An exposeEvent() is sent every time this value changes.
+ */
+
+bool QPlatformWindow::isExposed() const
+{
+    return window()->isVisible();
+}
+
+/*!
+    Returns true if the window should appear active from a style perspective.
+
+    This function can make platform-specific isActive checks, such as checking
+    if the QWindow is embedded in an active native window.
+*/
+bool QPlatformWindow::isActive() const
+{
+    return false;
+}
+
+/*!
+    Requests setting the window state of this surface
+    to \a type. Returns the actual state set.
+
+    Qt::WindowActive can be ignored.
+*/
+Qt::WindowState QPlatformWindow::setWindowState(Qt::WindowState)
+{
+    return Qt::WindowNoState;
+}
+
+/*!
+  Reimplement in subclasses to return a handle to the native window
+*/
+WId QPlatformWindow::winId() const
+{
+    // Return anything but 0. Returning 0 would cause havoc with QWidgets on
+    // very basic platform plugins that do not reimplement this function,
+    // because the top-level widget's internalWinId() would always be 0 which
+    // would mean top-levels are never treated as native.
+    return WId(1);
+}
+
+/*!
+    This function is called to enable native child window in QPA. It is common not to support this
+    feature in Window systems, but can be faked. When this function is called all geometry of this
+    platform window will be relative to the parent.
+*/
+//jl: It would be useful to have a property on the platform window which indicated if the sub-class
+// supported the setParent. If not, then geometry would be in screen coordinates.
+void QPlatformWindow::setParent(const QPlatformWindow *parent)
+{
+    Q_UNUSED(parent);
+    qWarning("This plugin does not support setParent!");
+}
+
+/*!
+  Reimplement to set the window title to \a title
+*/
+void QPlatformWindow::setWindowTitle(const QString &title) { Q_UNUSED(title); }
+
+/*!
+  Reimplement to set the window icon to \a icon
+*/
+void QPlatformWindow::setWindowIcon(const QIcon &icon) { Q_UNUSED(icon); }
+
+/*!
+  Reimplement to be able to let Qt raise windows to the top of the desktop
+*/
+void QPlatformWindow::raise() { qWarning("This plugin does not support raise()"); }
+
+/*!
+  Reimplement to be able to let Qt lower windows to the bottom of the desktop
+*/
+void QPlatformWindow::lower() { qWarning("This plugin does not support lower()"); }
+
+/*!
+  Reimplement to propagate the size hints of the QWindow.
+
+  The size hints include QWindow::minimumSize(), QWindow::maximumSize(),
+  QWindow::sizeIncrement(), and QWindow::baseSize().
+*/
+void QPlatformWindow::propagateSizeHints() {qWarning("This plugin does not support propagateSizeHints()"); }
+
+/*!
+  Reimplement to be able to let Qt set the opacity level of a window
+*/
+void QPlatformWindow::setOpacity(qreal level)
+{
+    Q_UNUSED(level);
+    qWarning("This plugin does not support setting window opacity");
+}
+
+/*!
+  Reimplement to  be able to let Qt set the mask of a window
+*/
+
+void QPlatformWindow::setMask(const QRegion &region)
+{
+    Q_UNUSED(region);
+    qWarning("This plugin does not support setting window masks");
+}
+
+/*!
+  Reimplement to let Qt be able to request activation/focus for a window
+
+  Some window systems will probably not have callbacks for this functionality,
+  and then calling QWindowSystemInterface::handleWindowActivated(QWindow *w)
+  would be sufficient.
+
+  If the window system has some event handling/callbacks then call
+  QWindowSystemInterface::handleWindowActivated(QWindow *w) when the window system
+  gives the notification.
+
+  Default implementation calls QWindowSystem::handleWindowActivated(QWindow *w)
+*/
+void QPlatformWindow::requestActivateWindow()
+{
+    QWindowSystemInterface::handleWindowActivated(window());
+}
+
+/*!
+  Handle changes to the orientation of the platform window's contents.
+
+  This is a hint to the window manager in case it needs to display
+  additional content like popups, dialogs, status bars, or similar
+  in relation to the window.
+
+  \sa QWindow::reportContentOrientationChange()
+*/
+void QPlatformWindow::handleContentOrientationChange(Qt::ScreenOrientation orientation)
+{
+    Q_UNUSED(orientation);
+}
+
+/*!
+  Request a different orientation of the platform window.
+
+  This tells the window manager how the window wants to be rotated in order
+  to be displayed, and how input events should be translated.
+
+  As an example, a portrait compositor might rotate the window by 90 degrees,
+  if the window is in landscape. It will also rotate input coordinates from
+  portrait to landscape such that top right in portrait gets mapped to top
+  left in landscape.
+
+  If the implementation doesn't support the requested orientation it should
+  signal this by returning an actual supported orientation.
+
+  If the implementation doesn't support rotating the window at all it should
+  return Qt::PrimaryOrientation, this is also the default value.
+
+  \sa QWindow::requestWindowOrientation()
+*/
+Qt::ScreenOrientation QPlatformWindow::requestWindowOrientation(Qt::ScreenOrientation orientation)
+{
+    Q_UNUSED(orientation);
+    return Qt::PrimaryOrientation;
+}
+
+bool QPlatformWindow::setKeyboardGrabEnabled(bool grab)
+{
+    Q_UNUSED(grab);
+    qWarning("This plugin does not support grabbing the keyboard");
+    return false;
+}
+
+bool QPlatformWindow::setMouseGrabEnabled(bool grab)
+{
+    Q_UNUSED(grab);
+    qWarning("This plugin does not support grabbing the mouse");
+    return false;
+}
+
+/*!
+    Reimplement to be able to let Qt indicate that the window has been
+    modified. Return true if the native window supports setting the modified
+    flag, false otherwise.
+*/
+bool QPlatformWindow::setWindowModified(bool modified)
+{
+    Q_UNUSED(modified);
+    return false;
+}
+
+/*!
+    Reimplement this method to be able to do any platform specific event
+    handling. All events for window() are passed to this function before being
+    sent to QWindow::event().
+
+    The default implementation is empty and does nothing with \a event.
+*/
+void QPlatformWindow::windowEvent(QEvent *event)
+{
+    Q_UNUSED(event);
+}
+
+/*!
+    Reimplement this method to start a system size grip drag
+    operation if the system supports it and return true to indicate
+    success.
+    It is called from the mouse press event handler of the size grip.
+
+    The default implementation is empty and does nothing with \a pos
+    and \a corner.
+*/
+
+bool QPlatformWindow::startSystemResize(const QPoint &pos, Qt::Corner corner)
+{
+    Q_UNUSED(pos)
+    Q_UNUSED(corner)
+    return false;
+}
+
+/*!
+    Reimplement this method to set whether frame strut events
+    should be sent to \a enabled.
+
+    \sa frameStrutEventsEnabled
+*/
+
+void QPlatformWindow::setFrameStrutEventsEnabled(bool enabled)
+{
+    if (enabled)
+        qWarning("This plugin does not support frame strut events.");
+}
+
+/*!
+    Reimplement this method to return whether
+    frame strut events are enabled.
+*/
+
+bool QPlatformWindow::frameStrutEventsEnabled() const
+{
+    return false;
+}
+
+/*!
+    \class QPlatformWindow
+    \since 4.8
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformWindow class provides an abstraction for top-level windows.
+
+    The QPlatformWindow abstraction is used by QWindow for all its top level windows. It is being
+    created by calling the createPlatformWindow function in the loaded QPlatformIntegration
+    instance.
+
+    QPlatformWindow is used to signal to the windowing system, how Qt perceives its frame.
+    However, it is not concerned with how Qt renders into the window it represents.
+
+    Visible QWindows will always have a QPlatformWindow. However, it is not necessary for
+    all windows to have a QBackingStore. This is the case for QOpenGLWidget. And could be the case for
+    windows where some  3.party renders into it.
+
+    The platform specific window handle can be retrieved by the winId function.
+
+    QPlatformWindow is also the way QPA defines how native child windows should be supported
+    through the setParent function.
+
+    The only way to retrieve a QPlatformOpenGLContext in QPA is by calling the glContext() function
+    on QPlatformWindow.
+
+    \sa QBackingStore, QWindow
+*/
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformwindow_qpa.cpp b/src/gui/kernel/qplatformwindow_qpa.cpp
deleted file mode 100644
index 3c2246c..0000000
--- a/src/gui/kernel/qplatformwindow_qpa.cpp
+++ /dev/null
@@ -1,430 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformwindow.h"
-
-#include <QtGui/qwindowsysteminterface_qpa.h>
-#include <QtGui/qwindow.h>
-#include <QtGui/qscreen.h>
-
-QT_BEGIN_NAMESPACE
-
-class QPlatformWindowPrivate
-{
-    QRect rect;
-    friend class QPlatformWindow;
-};
-
-/*!
-    Constructs a platform window with the given top level window.
-*/
-
-QPlatformWindow::QPlatformWindow(QWindow *window)
-    : QPlatformSurface(window)
-    , d_ptr(new QPlatformWindowPrivate)
-{
-    Q_D(QPlatformWindow);
-    d->rect = window->geometry();
-}
-
-/*!
-    Virtual destructor does not delete its top level window.
-*/
-QPlatformWindow::~QPlatformWindow()
-{
-}
-
-/*!
-    Returns the window which belongs to the QPlatformWindow
-*/
-QWindow *QPlatformWindow::window() const
-{
-    return static_cast<QWindow *>(m_surface);
-}
-
-/*!
-    Returns the parent platform window (or 0 if orphan).
-*/
-QPlatformWindow *QPlatformWindow::parent() const
-{
-    return window()->parent() ? window()->parent()->handle() : 0;
-}
-
-/*!
-    Returns the platform screen handle corresponding to this platform window.
-*/
-QPlatformScreen *QPlatformWindow::screen() const
-{
-    return window()->screen()->handle();
-}
-
-/*!
-    Returns the actual surface format of the window.
-*/
-QSurfaceFormat QPlatformWindow::format() const
-{
-    return QSurfaceFormat();
-}
-
-/*!
-    This function is called by Qt whenever a window is moved or the window is resized. The resize
-    can happen programatically(from ie. user application) or by the window manager. This means that
-    there is no need to call this function specifically from the window manager callback, instead
-    call QWindowSystemInterface::handleGeometryChange(QWindow *w, const QRect &newRect);
-
-    The position(x, y) part of the rect might be inclusive or exclusive of the window frame
-    as returned by frameMargins(). You can detect this in the plugin by checking
-    qt_window_private(window())->positionPolicy.
-*/
-void QPlatformWindow::setGeometry(const QRect &rect)
-{
-    Q_D(QPlatformWindow);
-    d->rect = rect;
-}
-
-/*!
-    Returnes the current geometry of a window
-*/
-QRect QPlatformWindow::geometry() const
-{
-    Q_D(const QPlatformWindow);
-    return d->rect;
-}
-
-QMargins QPlatformWindow::frameMargins() const
-{
-    return QMargins();
-}
-
-/*!
-    Reimplemented in subclasses to show the surface
-    if \a visible is \c true, and hide it if \a visible is \c false.
-
-    The default implementation sends a synchronous expose event.
-*/
-void QPlatformWindow::setVisible(bool visible)
-{
-    Q_UNUSED(visible);
-    QRect rect(QPoint(), geometry().size());
-    QWindowSystemInterface::handleSynchronousExposeEvent(window(), rect);
-}
-/*!
-    Requests setting the window flags of this surface
-    to \a type. Returns the actual flags set.
-*/
-Qt::WindowFlags QPlatformWindow::setWindowFlags(Qt::WindowFlags flags)
-{
-    return flags;
-}
-
-
-
-/*!
-    Returns if this window is exposed in the windowing system.
-
-    An exposeEvent() is sent every time this value changes.
- */
-
-bool QPlatformWindow::isExposed() const
-{
-    return window()->isVisible();
-}
-
-/*!
-    Returns true if the window should appear active from a style perspective.
-
-    This function can make platform-specific isActive checks, such as checking
-    if the QWindow is embedded in an active native window.
-*/
-bool QPlatformWindow::isActive() const
-{
-    return false;
-}
-
-/*!
-    Requests setting the window state of this surface
-    to \a type. Returns the actual state set.
-
-    Qt::WindowActive can be ignored.
-*/
-Qt::WindowState QPlatformWindow::setWindowState(Qt::WindowState)
-{
-    return Qt::WindowNoState;
-}
-
-/*!
-  Reimplement in subclasses to return a handle to the native window
-*/
-WId QPlatformWindow::winId() const
-{
-    // Return anything but 0. Returning 0 would cause havoc with QWidgets on
-    // very basic platform plugins that do not reimplement this function,
-    // because the top-level widget's internalWinId() would always be 0 which
-    // would mean top-levels are never treated as native.
-    return WId(1);
-}
-
-/*!
-    This function is called to enable native child window in QPA. It is common not to support this
-    feature in Window systems, but can be faked. When this function is called all geometry of this
-    platform window will be relative to the parent.
-*/
-//jl: It would be useful to have a property on the platform window which indicated if the sub-class
-// supported the setParent. If not, then geometry would be in screen coordinates.
-void QPlatformWindow::setParent(const QPlatformWindow *parent)
-{
-    Q_UNUSED(parent);
-    qWarning("This plugin does not support setParent!");
-}
-
-/*!
-  Reimplement to set the window title to \a title
-*/
-void QPlatformWindow::setWindowTitle(const QString &title) { Q_UNUSED(title); }
-
-/*!
-  Reimplement to set the window icon to \a icon
-*/
-void QPlatformWindow::setWindowIcon(const QIcon &icon) { Q_UNUSED(icon); }
-
-/*!
-  Reimplement to be able to let Qt raise windows to the top of the desktop
-*/
-void QPlatformWindow::raise() { qWarning("This plugin does not support raise()"); }
-
-/*!
-  Reimplement to be able to let Qt lower windows to the bottom of the desktop
-*/
-void QPlatformWindow::lower() { qWarning("This plugin does not support lower()"); }
-
-/*!
-  Reimplement to propagate the size hints of the QWindow.
-
-  The size hints include QWindow::minimumSize(), QWindow::maximumSize(),
-  QWindow::sizeIncrement(), and QWindow::baseSize().
-*/
-void QPlatformWindow::propagateSizeHints() {qWarning("This plugin does not support propagateSizeHints()"); }
-
-/*!
-  Reimplement to be able to let Qt set the opacity level of a window
-*/
-void QPlatformWindow::setOpacity(qreal level)
-{
-    Q_UNUSED(level);
-    qWarning("This plugin does not support setting window opacity");
-}
-
-/*!
-  Reimplement to  be able to let Qt set the mask of a window
-*/
-
-void QPlatformWindow::setMask(const QRegion &region)
-{
-    Q_UNUSED(region);
-    qWarning("This plugin does not support setting window masks");
-}
-
-/*!
-  Reimplement to let Qt be able to request activation/focus for a window
-
-  Some window systems will probably not have callbacks for this functionality,
-  and then calling QWindowSystemInterface::handleWindowActivated(QWindow *w)
-  would be sufficient.
-
-  If the window system has some event handling/callbacks then call
-  QWindowSystemInterface::handleWindowActivated(QWindow *w) when the window system
-  gives the notification.
-
-  Default implementation calls QWindowSystem::handleWindowActivated(QWindow *w)
-*/
-void QPlatformWindow::requestActivateWindow()
-{
-    QWindowSystemInterface::handleWindowActivated(window());
-}
-
-/*!
-  Handle changes to the orientation of the platform window's contents.
-
-  This is a hint to the window manager in case it needs to display
-  additional content like popups, dialogs, status bars, or similar
-  in relation to the window.
-
-  \sa QWindow::reportContentOrientationChange()
-*/
-void QPlatformWindow::handleContentOrientationChange(Qt::ScreenOrientation orientation)
-{
-    Q_UNUSED(orientation);
-}
-
-/*!
-  Request a different orientation of the platform window.
-
-  This tells the window manager how the window wants to be rotated in order
-  to be displayed, and how input events should be translated.
-
-  As an example, a portrait compositor might rotate the window by 90 degrees,
-  if the window is in landscape. It will also rotate input coordinates from
-  portrait to landscape such that top right in portrait gets mapped to top
-  left in landscape.
-
-  If the implementation doesn't support the requested orientation it should
-  signal this by returning an actual supported orientation.
-
-  If the implementation doesn't support rotating the window at all it should
-  return Qt::PrimaryOrientation, this is also the default value.
-
-  \sa QWindow::requestWindowOrientation()
-*/
-Qt::ScreenOrientation QPlatformWindow::requestWindowOrientation(Qt::ScreenOrientation orientation)
-{
-    Q_UNUSED(orientation);
-    return Qt::PrimaryOrientation;
-}
-
-bool QPlatformWindow::setKeyboardGrabEnabled(bool grab)
-{
-    Q_UNUSED(grab);
-    qWarning("This plugin does not support grabbing the keyboard");
-    return false;
-}
-
-bool QPlatformWindow::setMouseGrabEnabled(bool grab)
-{
-    Q_UNUSED(grab);
-    qWarning("This plugin does not support grabbing the mouse");
-    return false;
-}
-
-/*!
-    Reimplement to be able to let Qt indicate that the window has been
-    modified. Return true if the native window supports setting the modified
-    flag, false otherwise.
-*/
-bool QPlatformWindow::setWindowModified(bool modified)
-{
-    Q_UNUSED(modified);
-    return false;
-}
-
-/*!
-    Reimplement this method to be able to do any platform specific event
-    handling. All events for window() are passed to this function before being
-    sent to QWindow::event().
-
-    The default implementation is empty and does nothing with \a event.
-*/
-void QPlatformWindow::windowEvent(QEvent *event)
-{
-    Q_UNUSED(event);
-}
-
-/*!
-    Reimplement this method to start a system size grip drag
-    operation if the system supports it and return true to indicate
-    success.
-    It is called from the mouse press event handler of the size grip.
-
-    The default implementation is empty and does nothing with \a pos
-    and \a corner.
-*/
-
-bool QPlatformWindow::startSystemResize(const QPoint &pos, Qt::Corner corner)
-{
-    Q_UNUSED(pos)
-    Q_UNUSED(corner)
-    return false;
-}
-
-/*!
-    Reimplement this method to set whether frame strut events
-    should be sent to \a enabled.
-
-    \sa frameStrutEventsEnabled
-*/
-
-void QPlatformWindow::setFrameStrutEventsEnabled(bool enabled)
-{
-    if (enabled)
-        qWarning("This plugin does not support frame strut events.");
-}
-
-/*!
-    Reimplement this method to return whether
-    frame strut events are enabled.
-*/
-
-bool QPlatformWindow::frameStrutEventsEnabled() const
-{
-    return false;
-}
-
-/*!
-    \class QPlatformWindow
-    \since 4.8
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformWindow class provides an abstraction for top-level windows.
-
-    The QPlatformWindow abstraction is used by QWindow for all its top level windows. It is being
-    created by calling the createPlatformWindow function in the loaded QPlatformIntegration
-    instance.
-
-    QPlatformWindow is used to signal to the windowing system, how Qt perceives its frame.
-    However, it is not concerned with how Qt renders into the window it represents.
-
-    Visible QWindows will always have a QPlatformWindow. However, it is not necessary for
-    all windows to have a QBackingStore. This is the case for QOpenGLWidget. And could be the case for
-    windows where some  3.party renders into it.
-
-    The platform specific window handle can be retrieved by the winId function.
-
-    QPlatformWindow is also the way QPA defines how native child windows should be supported
-    through the setParent function.
-
-    The only way to retrieve a QPlatformOpenGLContext in QPA is by calling the glContext() function
-    on QPlatformWindow.
-
-    \sa QBackingStore, QWindow
-*/
-
-QT_END_NAMESPACE
diff --git a/src/gui/kernel/qsessionmanager.cpp b/src/gui/kernel/qsessionmanager.cpp
new file mode 100644
index 0000000..2db2e75
--- /dev/null
+++ b/src/gui/kernel/qsessionmanager.cpp
@@ -0,0 +1,174 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qsessionmanager.h>
+#include <qguiapplication.h>
+
+#include <private/qobject_p.h>
+
+#ifndef QT_NO_SESSIONMANAGER
+
+QT_BEGIN_NAMESPACE
+
+class QSessionManagerPrivate : public QObjectPrivate
+{
+public:
+    QSessionManagerPrivate(QSessionManager *m, const QString &id,
+                           const QString &key);
+
+    QStringList restartCommand;
+    QStringList discardCommand;
+    const QString sessionId;
+    const QString sessionKey;
+    QSessionManager::RestartHint restartHint;
+};
+
+QSessionManagerPrivate::QSessionManagerPrivate(QSessionManager*,
+                                               const QString &id,
+                                               const QString &key)
+    : QObjectPrivate(), sessionId(id), sessionKey(key)
+{
+}
+
+QSessionManager::QSessionManager(QGuiApplication *app, QString &id, QString &key)
+    : QObject(*(new QSessionManagerPrivate(this, id, key)), app)
+{
+    Q_D(QSessionManager);
+    d->restartHint = RestartIfRunning;
+}
+
+QSessionManager::~QSessionManager()
+{
+}
+
+QString QSessionManager::sessionId() const
+{
+    Q_D(const QSessionManager);
+    return d->sessionId;
+}
+
+QString QSessionManager::sessionKey() const
+{
+    Q_D(const QSessionManager);
+    return d->sessionKey;
+}
+
+
+bool QSessionManager::allowsInteraction()
+{
+    return false;
+}
+
+bool QSessionManager::allowsErrorInteraction()
+{
+    return false;
+}
+
+void QSessionManager::release()
+{
+}
+
+void QSessionManager::cancel()
+{
+}
+
+void QSessionManager::setRestartHint(QSessionManager::RestartHint hint)
+{
+    Q_D(QSessionManager);
+    d->restartHint = hint;
+}
+
+QSessionManager::RestartHint QSessionManager::restartHint() const
+{
+    Q_D(const QSessionManager);
+    return d->restartHint;
+}
+
+void QSessionManager::setRestartCommand(const QStringList &command)
+{
+    Q_D(QSessionManager);
+    d->restartCommand = command;
+}
+
+QStringList QSessionManager::restartCommand() const
+{
+    Q_D(const QSessionManager);
+    return d->restartCommand;
+}
+
+void QSessionManager::setDiscardCommand(const QStringList &command)
+{
+    Q_D(QSessionManager);
+    d->discardCommand = command;
+}
+
+QStringList QSessionManager::discardCommand() const
+{
+    Q_D(const QSessionManager);
+    return d->discardCommand;
+}
+
+void QSessionManager::setManagerProperty(const QString &name,
+                                         const QString &value)
+{
+    Q_UNUSED(name);
+    Q_UNUSED(value);
+}
+
+void QSessionManager::setManagerProperty(const QString &name,
+                                         const QStringList &value)
+{
+    Q_UNUSED(name);
+    Q_UNUSED(value);
+}
+
+bool QSessionManager::isPhase2() const
+{
+    return false;
+}
+
+void QSessionManager::requestPhase2()
+{
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_SESSIONMANAGER
diff --git a/src/gui/kernel/qsessionmanager_qpa.cpp b/src/gui/kernel/qsessionmanager_qpa.cpp
deleted file mode 100644
index 2db2e75..0000000
--- a/src/gui/kernel/qsessionmanager_qpa.cpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qsessionmanager.h>
-#include <qguiapplication.h>
-
-#include <private/qobject_p.h>
-
-#ifndef QT_NO_SESSIONMANAGER
-
-QT_BEGIN_NAMESPACE
-
-class QSessionManagerPrivate : public QObjectPrivate
-{
-public:
-    QSessionManagerPrivate(QSessionManager *m, const QString &id,
-                           const QString &key);
-
-    QStringList restartCommand;
-    QStringList discardCommand;
-    const QString sessionId;
-    const QString sessionKey;
-    QSessionManager::RestartHint restartHint;
-};
-
-QSessionManagerPrivate::QSessionManagerPrivate(QSessionManager*,
-                                               const QString &id,
-                                               const QString &key)
-    : QObjectPrivate(), sessionId(id), sessionKey(key)
-{
-}
-
-QSessionManager::QSessionManager(QGuiApplication *app, QString &id, QString &key)
-    : QObject(*(new QSessionManagerPrivate(this, id, key)), app)
-{
-    Q_D(QSessionManager);
-    d->restartHint = RestartIfRunning;
-}
-
-QSessionManager::~QSessionManager()
-{
-}
-
-QString QSessionManager::sessionId() const
-{
-    Q_D(const QSessionManager);
-    return d->sessionId;
-}
-
-QString QSessionManager::sessionKey() const
-{
-    Q_D(const QSessionManager);
-    return d->sessionKey;
-}
-
-
-bool QSessionManager::allowsInteraction()
-{
-    return false;
-}
-
-bool QSessionManager::allowsErrorInteraction()
-{
-    return false;
-}
-
-void QSessionManager::release()
-{
-}
-
-void QSessionManager::cancel()
-{
-}
-
-void QSessionManager::setRestartHint(QSessionManager::RestartHint hint)
-{
-    Q_D(QSessionManager);
-    d->restartHint = hint;
-}
-
-QSessionManager::RestartHint QSessionManager::restartHint() const
-{
-    Q_D(const QSessionManager);
-    return d->restartHint;
-}
-
-void QSessionManager::setRestartCommand(const QStringList &command)
-{
-    Q_D(QSessionManager);
-    d->restartCommand = command;
-}
-
-QStringList QSessionManager::restartCommand() const
-{
-    Q_D(const QSessionManager);
-    return d->restartCommand;
-}
-
-void QSessionManager::setDiscardCommand(const QStringList &command)
-{
-    Q_D(QSessionManager);
-    d->discardCommand = command;
-}
-
-QStringList QSessionManager::discardCommand() const
-{
-    Q_D(const QSessionManager);
-    return d->discardCommand;
-}
-
-void QSessionManager::setManagerProperty(const QString &name,
-                                         const QString &value)
-{
-    Q_UNUSED(name);
-    Q_UNUSED(value);
-}
-
-void QSessionManager::setManagerProperty(const QString &name,
-                                         const QStringList &value)
-{
-    Q_UNUSED(name);
-    Q_UNUSED(value);
-}
-
-bool QSessionManager::isPhase2() const
-{
-    return false;
-}
-
-void QSessionManager::requestPhase2()
-{
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_SESSIONMANAGER
diff --git a/src/gui/kernel/qwindowsysteminterface.cpp b/src/gui/kernel/qwindowsysteminterface.cpp
new file mode 100644
index 0000000..e884d7c
--- /dev/null
+++ b/src/gui/kernel/qwindowsysteminterface.cpp
@@ -0,0 +1,594 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "qwindowsysteminterface.h"
+#include <qpa/qplatformwindow.h>
+#include "qwindowsysteminterface_p.h"
+#include "private/qguiapplication_p.h"
+#include "private/qevent_p.h"
+#include "private/qtouchdevice_p.h"
+#include <QAbstractEventDispatcher>
+#include <qpa/qplatformdrag.h>
+#include <qdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+
+QElapsedTimer QWindowSystemInterfacePrivate::eventTime;
+
+//------------------------------------------------------------
+//
+// Callback functions for plugins:
+//
+
+QList<QWindowSystemInterfacePrivate::WindowSystemEvent *> QWindowSystemInterfacePrivate::windowSystemEventQueue;
+QMutex QWindowSystemInterfacePrivate::queueMutex;
+
+extern QPointer<QWindow> qt_last_mouse_receiver;
+
+/*!
+    \class QWindowSystemInterface
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+    \brief The QWindowSystemInterface provides an event queue for the QPA platform.
+
+    The platform plugins call the various functions to notify about events. The events are queued
+    until sendWindowSystemEvents() is called by the event dispatcher.
+*/
+
+void QWindowSystemInterface::handleEnterEvent(QWindow *tlw)
+{
+    if (tlw) {
+        QWindowSystemInterfacePrivate::EnterEvent *e = new QWindowSystemInterfacePrivate::EnterEvent(tlw);
+        QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+    }
+}
+
+void QWindowSystemInterface::handleLeaveEvent(QWindow *tlw)
+{
+    QWindowSystemInterfacePrivate::LeaveEvent *e = new QWindowSystemInterfacePrivate::LeaveEvent(tlw);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleWindowActivated(QWindow *tlw)
+{
+    QWindowSystemInterfacePrivate::ActivatedWindowEvent *e = new QWindowSystemInterfacePrivate::ActivatedWindowEvent(tlw);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleWindowStateChanged(QWindow *tlw, Qt::WindowState newState)
+{
+    QWindowSystemInterfacePrivate::WindowStateChangedEvent *e =
+        new QWindowSystemInterfacePrivate::WindowStateChangedEvent(tlw, newState);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleGeometryChange(QWindow *tlw, const QRect &newRect)
+{
+    QWindowSystemInterfacePrivate::GeometryChangeEvent *e = new QWindowSystemInterfacePrivate::GeometryChangeEvent(tlw,newRect);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleSynchronousGeometryChange(QWindow *tlw, const QRect &newRect)
+{
+    QWindowSystemInterfacePrivate::GeometryChangeEvent e(tlw,newRect);
+    QGuiApplicationPrivate::processWindowSystemEvent(&e); // send event immediately.
+}
+
+void QWindowSystemInterface::handleCloseEvent(QWindow *tlw)
+{
+    if (tlw) {
+        QWindowSystemInterfacePrivate::CloseEvent *e =
+                new QWindowSystemInterfacePrivate::CloseEvent(tlw);
+        QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+    }
+}
+
+void QWindowSystemInterface::handleSynchronousCloseEvent(QWindow *tlw)
+{
+    if (tlw) {
+        QWindowSystemInterfacePrivate::CloseEvent e(tlw);
+        QGuiApplicationPrivate::processWindowSystemEvent(&e);
+    }
+}
+
+/*!
+
+\a w == 0 means that the event is in global coords only, \a local will be ignored in this case
+
+*/
+void QWindowSystemInterface::handleMouseEvent(QWindow *w, const QPointF & local, const QPointF & global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
+{
+    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleMouseEvent(w, time, local, global, b, mods);
+}
+
+void QWindowSystemInterface::handleMouseEvent(QWindow *w, ulong timestamp, const QPointF & local, const QPointF & global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
+{
+    QWindowSystemInterfacePrivate::MouseEvent * e =
+            new QWindowSystemInterfacePrivate::MouseEvent(w, timestamp, local, global, b, mods);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleFrameStrutMouseEvent(QWindow *w, const QPointF & local, const QPointF & global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
+{
+    const unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleFrameStrutMouseEvent(w, time, local, global, b, mods);
+}
+
+void QWindowSystemInterface::handleFrameStrutMouseEvent(QWindow *w, ulong timestamp, const QPointF & local, const QPointF & global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
+{
+    QWindowSystemInterfacePrivate::MouseEvent * e =
+            new QWindowSystemInterfacePrivate::MouseEvent(w, timestamp,
+                                                          QWindowSystemInterfacePrivate::FrameStrutMouse,
+                                                          local, global, b, mods);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+bool QWindowSystemInterface::tryHandleSynchronousShortcutEvent(QWindow *w, int k, Qt::KeyboardModifiers mods,
+                                                               const QString & text, bool autorep, ushort count)
+{
+    unsigned long timestamp = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    return tryHandleSynchronousShortcutEvent(w, timestamp, k, mods, text, autorep, count);
+}
+
+bool QWindowSystemInterface::tryHandleSynchronousShortcutEvent(QWindow *w, ulong timestamp, int k, Qt::KeyboardModifiers mods,
+                                                               const QString & text, bool autorep, ushort count)
+{
+    QGuiApplicationPrivate::modifier_buttons = mods;
+
+    QKeyEvent qevent(QEvent::ShortcutOverride, k, mods, text, autorep, count);
+    qevent.setTimestamp(timestamp);
+    return QGuiApplicationPrivate::instance()->shortcutMap.tryShortcutEvent(w, &qevent);
+}
+
+bool QWindowSystemInterface::tryHandleSynchronousExtendedShortcutEvent(QWindow *w, int k, Qt::KeyboardModifiers mods,
+                                                                       quint32 nativeScanCode, quint32 nativeVirtualKey, quint32 nativeModifiers,
+                                                                       const QString &text, bool autorep, ushort count)
+{
+    unsigned long timestamp = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    return tryHandleSynchronousExtendedShortcutEvent(w, timestamp, k, mods, nativeScanCode, nativeVirtualKey, nativeModifiers, text, autorep, count);
+}
+
+bool QWindowSystemInterface::tryHandleSynchronousExtendedShortcutEvent(QWindow *w, ulong timestamp, int k, Qt::KeyboardModifiers mods,
+                                                                       quint32 nativeScanCode, quint32 nativeVirtualKey, quint32 nativeModifiers,
+                                                                       const QString &text, bool autorep, ushort count)
+{
+    QGuiApplicationPrivate::modifier_buttons = mods;
+
+    QKeyEvent qevent(QEvent::ShortcutOverride, k, mods, nativeScanCode, nativeVirtualKey, nativeModifiers, text, autorep, count);
+    qevent.setTimestamp(timestamp);
+    return QGuiApplicationPrivate::instance()->shortcutMap.tryShortcutEvent(w, &qevent);
+}
+
+
+void QWindowSystemInterface::handleKeyEvent(QWindow *w, QEvent::Type t, int k, Qt::KeyboardModifiers mods, const QString & text, bool autorep, ushort count) {
+    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleKeyEvent(w, time, t, k, mods, text, autorep, count);
+}
+
+void QWindowSystemInterface::handleKeyEvent(QWindow *tlw, ulong timestamp, QEvent::Type t, int k, Qt::KeyboardModifiers mods, const QString & text, bool autorep, ushort count)
+{
+    QWindowSystemInterfacePrivate::KeyEvent * e =
+            new QWindowSystemInterfacePrivate::KeyEvent(tlw, timestamp, t, k, mods, text, autorep, count);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleExtendedKeyEvent(QWindow *w, QEvent::Type type, int key, Qt::KeyboardModifiers modifiers,
+                                                    quint32 nativeScanCode, quint32 nativeVirtualKey,
+                                                    quint32 nativeModifiers,
+                                                    const QString& text, bool autorep,
+                                                    ushort count)
+{
+    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleExtendedKeyEvent(w, time, type, key, modifiers, nativeScanCode, nativeVirtualKey, nativeModifiers,
+                           text, autorep, count);
+}
+
+void QWindowSystemInterface::handleExtendedKeyEvent(QWindow *tlw, ulong timestamp, QEvent::Type type, int key,
+                                                    Qt::KeyboardModifiers modifiers,
+                                                    quint32 nativeScanCode, quint32 nativeVirtualKey,
+                                                    quint32 nativeModifiers,
+                                                    const QString& text, bool autorep,
+                                                    ushort count)
+{
+    QWindowSystemInterfacePrivate::KeyEvent * e =
+            new QWindowSystemInterfacePrivate::KeyEvent(tlw, timestamp, type, key, modifiers,
+                nativeScanCode, nativeVirtualKey, nativeModifiers, text, autorep, count);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleWheelEvent(QWindow *w, const QPointF & local, const QPointF & global, int d, Qt::Orientation o, Qt::KeyboardModifiers mods) {
+    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleWheelEvent(w, time, local, global, d, o, mods);
+}
+
+void QWindowSystemInterface::handleWheelEvent(QWindow *tlw, ulong timestamp, const QPointF & local, const QPointF & global, int d, Qt::Orientation o, Qt::KeyboardModifiers mods)
+{
+    QPoint point = (o == Qt::Vertical) ? QPoint(0, d) : QPoint(d, 0);
+    handleWheelEvent(tlw, timestamp, local, global, QPoint(), point, mods);
+}
+
+void QWindowSystemInterface::handleWheelEvent(QWindow *w, const QPointF & local, const QPointF & global, QPoint pixelDelta, QPoint angleDelta, Qt::KeyboardModifiers mods)
+{
+    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleWheelEvent(w, time, local, global, pixelDelta, angleDelta, mods);
+}
+
+void QWindowSystemInterface::handleWheelEvent(QWindow *tlw, ulong timestamp, const QPointF & local, const QPointF & global, QPoint pixelDelta, QPoint angleDelta, Qt::KeyboardModifiers mods)
+{
+    // Qt 4 sends two separate wheel events for horizontal and vertical
+    // deltas. For Qt 5 we want to send the deltas in one event, but at the
+    // same time preserve source and behavior compatibility with Qt 4.
+    //
+    // In addition high-resolution pixel-based deltas are also supported.
+    // Platforms that does not support these may pass a null point here.
+    // Angle deltas must always be sent in addition to pixel deltas.
+    QWindowSystemInterfacePrivate::WheelEvent *e;
+
+    if (angleDelta.isNull())
+        return;
+
+    // Simple case: vertical deltas only:
+    if (angleDelta.y() != 0 && angleDelta.x() == 0) {
+        e = new QWindowSystemInterfacePrivate::WheelEvent(tlw, timestamp, local, global, pixelDelta, angleDelta, angleDelta.y(), Qt::Vertical, mods);
+        QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+        return;
+    }
+
+    // Simple case: horizontal deltas only:
+    if (angleDelta.y() == 0 && angleDelta.x() != 0) {
+        e = new QWindowSystemInterfacePrivate::WheelEvent(tlw, timestamp, local, global, pixelDelta, angleDelta, angleDelta.x(), Qt::Horizontal, mods);
+        QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+        return;
+    }
+
+    // Both horizontal and vertical deltas: Send two wheel events.
+    // The first event contains the Qt 5 pixel and angle delta as points,
+    // and in addition the Qt 4 compatibility vertical angle delta.
+    e = new QWindowSystemInterfacePrivate::WheelEvent(tlw, timestamp, local, global, pixelDelta, angleDelta, angleDelta.y(), Qt::Vertical, mods);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+
+    // The second event contains null pixel and angle points and the
+    // Qt 4 compatibility horizontal angle delta.
+    e = new QWindowSystemInterfacePrivate::WheelEvent(tlw, timestamp, local, global, QPoint(), QPoint(), angleDelta.x(), Qt::Horizontal, mods);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+
+QWindowSystemInterfacePrivate::ExposeEvent::ExposeEvent(QWindow *exposed, const QRegion &region)
+    : WindowSystemEvent(Expose)
+    , exposed(exposed)
+    , isExposed(exposed && exposed->handle() ? exposed->handle()->isExposed() : false)
+    , region(region)
+{
+}
+
+int QWindowSystemInterfacePrivate::windowSystemEventsQueued()
+{
+    queueMutex.lock();
+    int ret = windowSystemEventQueue.count();
+    queueMutex.unlock();
+    return ret;
+}
+
+QWindowSystemInterfacePrivate::WindowSystemEvent * QWindowSystemInterfacePrivate::getWindowSystemEvent()
+{
+    queueMutex.lock();
+    QWindowSystemInterfacePrivate::WindowSystemEvent *ret;
+    if (windowSystemEventQueue.isEmpty())
+        ret = 0;
+    else
+        ret = windowSystemEventQueue.takeFirst();
+    queueMutex.unlock();
+    return ret;
+}
+
+void QWindowSystemInterfacePrivate::queueWindowSystemEvent(QWindowSystemInterfacePrivate::WindowSystemEvent *ev)
+{
+    queueMutex.lock();
+    windowSystemEventQueue.append(ev);
+    queueMutex.unlock();
+
+    QAbstractEventDispatcher *dispatcher = QGuiApplicationPrivate::qt_qpa_core_dispatcher();
+    if (dispatcher)
+        dispatcher->wakeUp();
+}
+
+void QWindowSystemInterface::registerTouchDevice(QTouchDevice *device)
+{
+    QTouchDevicePrivate::registerDevice(device);
+}
+
+void QWindowSystemInterface::handleTouchEvent(QWindow *w, QTouchDevice *device,
+                                              const QList<TouchPoint> &points, Qt::KeyboardModifiers mods)
+{
+    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleTouchEvent(w, time, device, points, mods);
+}
+
+QList<QTouchEvent::TouchPoint> QWindowSystemInterfacePrivate::convertTouchPoints(const QList<QWindowSystemInterface::TouchPoint> &points, QEvent::Type *type)
+{
+    QList<QTouchEvent::TouchPoint> touchPoints;
+    Qt::TouchPointStates states;
+    QTouchEvent::TouchPoint p;
+
+    QList<QWindowSystemInterface::TouchPoint>::const_iterator point = points.constBegin();
+    QList<QWindowSystemInterface::TouchPoint>::const_iterator end = points.constEnd();
+    while (point != end) {
+        p.setId(point->id);
+        p.setPressure(point->pressure);
+        states |= point->state;
+        p.setState(point->state);
+
+        const QPointF screenPos = point->area.center();
+        p.setScreenPos(screenPos);
+        p.setScreenRect(point->area);
+
+        // The local pos and rect are not set, they will be calculated
+        // when the event gets processed by QGuiApplication.
+
+        p.setNormalizedPos(point->normalPosition);
+        p.setVelocity(point->velocity);
+        p.setFlags(point->flags);
+        p.setRawScreenPositions(point->rawPositions);
+
+        touchPoints.append(p);
+        ++point;
+    }
+
+    // Determine the event type based on the combined point states.
+    if (type) {
+        *type = QEvent::TouchUpdate;
+        if (states == Qt::TouchPointPressed)
+            *type = QEvent::TouchBegin;
+        else if (states == Qt::TouchPointReleased)
+            *type = QEvent::TouchEnd;
+    }
+
+    return touchPoints;
+}
+
+void QWindowSystemInterface::handleTouchEvent(QWindow *tlw, ulong timestamp, QTouchDevice *device,
+                                              const QList<TouchPoint> &points, Qt::KeyboardModifiers mods)
+{
+    if (!points.size()) // Touch events must have at least one point
+        return;
+
+    if (!QTouchDevicePrivate::isRegistered(device)) // Disallow passing bogus, non-registered devices.
+        return;
+
+    QEvent::Type type;
+    QList<QTouchEvent::TouchPoint> touchPoints = QWindowSystemInterfacePrivate::convertTouchPoints(points, &type);
+
+    QWindowSystemInterfacePrivate::TouchEvent *e =
+            new QWindowSystemInterfacePrivate::TouchEvent(tlw, timestamp, type, device, touchPoints, mods);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleTouchCancelEvent(QWindow *w, QTouchDevice *device,
+                                                    Qt::KeyboardModifiers mods)
+{
+    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleTouchCancelEvent(w, time, device, mods);
+}
+
+void QWindowSystemInterface::handleTouchCancelEvent(QWindow *w, ulong timestamp, QTouchDevice *device,
+                                                    Qt::KeyboardModifiers mods)
+{
+    QWindowSystemInterfacePrivate::TouchEvent *e =
+            new QWindowSystemInterfacePrivate::TouchEvent(w, timestamp, QEvent::TouchCancel, device,
+                                                         QList<QTouchEvent::TouchPoint>(), mods);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleScreenOrientationChange(QScreen *screen, Qt::ScreenOrientation orientation)
+{
+    QWindowSystemInterfacePrivate::ScreenOrientationEvent *e =
+            new QWindowSystemInterfacePrivate::ScreenOrientationEvent(screen, orientation);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleScreenGeometryChange(QScreen *screen, const QRect &geometry)
+{
+    QWindowSystemInterfacePrivate::ScreenGeometryEvent *e =
+            new QWindowSystemInterfacePrivate::ScreenGeometryEvent(screen, geometry);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleScreenAvailableGeometryChange(QScreen *screen, const QRect &availableGeometry)
+{
+    QWindowSystemInterfacePrivate::ScreenAvailableGeometryEvent *e =
+            new QWindowSystemInterfacePrivate::ScreenAvailableGeometryEvent(screen, availableGeometry);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleScreenLogicalDotsPerInchChange(QScreen *screen, qreal dpiX, qreal dpiY)
+{
+    QWindowSystemInterfacePrivate::ScreenLogicalDotsPerInchEvent *e =
+            new QWindowSystemInterfacePrivate::ScreenLogicalDotsPerInchEvent(screen, dpiX, dpiY);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleScreenRefreshRateChange(QScreen *screen, qreal newRefreshRate)
+{
+    QWindowSystemInterfacePrivate::ScreenRefreshRateEvent *e =
+            new QWindowSystemInterfacePrivate::ScreenRefreshRateEvent(screen, newRefreshRate);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleThemeChange(QWindow *tlw)
+{
+    QWindowSystemInterfacePrivate::ThemeChangeEvent *e = new QWindowSystemInterfacePrivate::ThemeChangeEvent(tlw);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleExposeEvent(QWindow *tlw, const QRegion &region)
+{
+    QWindowSystemInterfacePrivate::ExposeEvent *e = new QWindowSystemInterfacePrivate::ExposeEvent(tlw, region);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleSynchronousExposeEvent(QWindow *tlw, const QRegion &region)
+{
+    QWindowSystemInterfacePrivate::ExposeEvent e(tlw, region);
+    QGuiApplicationPrivate::processWindowSystemEvent(&e); // send event immediately.
+}
+
+bool QWindowSystemInterface::sendWindowSystemEvents(QAbstractEventDispatcher *eventDispatcher, QEventLoop::ProcessEventsFlags flags)
+{
+    int nevents = 0;
+
+    // handle gui and posted events
+    QCoreApplication::sendPostedEvents();
+
+    while (true) {
+        QWindowSystemInterfacePrivate::WindowSystemEvent *event;
+        if (!(flags & QEventLoop::ExcludeUserInputEvents)
+            && QWindowSystemInterfacePrivate::windowSystemEventsQueued() > 0) {
+            // process a pending user input event
+            event = QWindowSystemInterfacePrivate::getWindowSystemEvent();
+            if (!event)
+                break;
+        } else {
+            break;
+        }
+
+        if (eventDispatcher->filterEvent(event)) {
+            delete event;
+            continue;
+        }
+
+        nevents++;
+
+        QGuiApplicationPrivate::processWindowSystemEvent(event);
+        delete event;
+    }
+
+    return (nevents > 0);
+}
+
+int QWindowSystemInterface::windowSystemEventsQueued()
+{
+    return QWindowSystemInterfacePrivate::windowSystemEventsQueued();
+}
+
+#ifndef QT_NO_DRAGANDDROP
+QPlatformDragQtResponse QWindowSystemInterface::handleDrag(QWindow *w, const QMimeData *dropData, const QPoint &p, Qt::DropActions supportedActions)
+{
+    return QGuiApplicationPrivate::processDrag(w, dropData, p,supportedActions);
+}
+
+QPlatformDropQtResponse QWindowSystemInterface::handleDrop(QWindow *w, const QMimeData *dropData, const QPoint &p, Qt::DropActions supportedActions)
+{
+    return QGuiApplicationPrivate::processDrop(w, dropData, p,supportedActions);
+}
+#endif // QT_NO_DRAGANDDROP
+
+/*!
+    \fn static QWindowSystemInterface::handleNativeEvent(QWindow *window, const QByteArray &eventType, void *message, long *result)
+    \brief Passes a native event identified by \a eventType to the \a window.
+
+    \note This function can only be called from the GUI thread.
+    \sa QPlatformNativeInterface::setEventFilter()
+*/
+
+bool QWindowSystemInterface::handleNativeEvent(QWindow *window, const QByteArray &eventType, void *message, long *result)
+{
+    return QGuiApplicationPrivate::processNativeEvent(window, eventType, message, result);
+}
+
+void QWindowSystemInterface::handleFileOpenEvent(const QString& fileName)
+{
+    QWindowSystemInterfacePrivate::FileOpenEvent e(fileName);
+    QGuiApplicationPrivate::processWindowSystemEvent(&e);
+}
+
+void QWindowSystemInterface::handleTabletEvent(QWindow *w, ulong timestamp, bool down, const QPointF &local, const QPointF &global,
+                                               int device, int pointerType, qreal pressure, int xTilt, int yTilt,
+                                               qreal tangentialPressure, qreal rotation, int z, qint64 uid,
+                                               Qt::KeyboardModifiers modifiers)
+{
+    QWindowSystemInterfacePrivate::TabletEvent *e =
+            new QWindowSystemInterfacePrivate::TabletEvent(w, timestamp, down, local, global, device, pointerType, pressure,
+                                                           xTilt, yTilt, tangentialPressure, rotation, z, uid, modifiers);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleTabletEvent(QWindow *w, bool down, const QPointF &local, const QPointF &global,
+                                               int device, int pointerType, qreal pressure, int xTilt, int yTilt,
+                                               qreal tangentialPressure, qreal rotation, int z, qint64 uid,
+                                               Qt::KeyboardModifiers modifiers)
+{
+    ulong time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleTabletEvent(w, time, down, local, global, device, pointerType, pressure,
+                      xTilt, yTilt, tangentialPressure, rotation, z, uid, modifiers);
+}
+
+void QWindowSystemInterface::handleTabletEnterProximityEvent(ulong timestamp, int device, int pointerType, qint64 uid)
+{
+    QWindowSystemInterfacePrivate::TabletEnterProximityEvent *e =
+            new QWindowSystemInterfacePrivate::TabletEnterProximityEvent(timestamp, device, pointerType, uid);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleTabletEnterProximityEvent(int device, int pointerType, qint64 uid)
+{
+    ulong time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleTabletEnterProximityEvent(time, device, pointerType, uid);
+}
+
+void QWindowSystemInterface::handleTabletLeaveProximityEvent(ulong timestamp, int device, int pointerType, qint64 uid)
+{
+    QWindowSystemInterfacePrivate::TabletLeaveProximityEvent *e =
+            new QWindowSystemInterfacePrivate::TabletLeaveProximityEvent(timestamp, device, pointerType, uid);
+    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
+}
+
+void QWindowSystemInterface::handleTabletLeaveProximityEvent(int device, int pointerType, qint64 uid)
+{
+    ulong time = QWindowSystemInterfacePrivate::eventTime.elapsed();
+    handleTabletLeaveProximityEvent(time, device, pointerType, uid);
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/gui/kernel/qwindowsysteminterface_qpa.cpp b/src/gui/kernel/qwindowsysteminterface_qpa.cpp
deleted file mode 100644
index e884d7c..0000000
--- a/src/gui/kernel/qwindowsysteminterface_qpa.cpp
+++ /dev/null
@@ -1,594 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include "qwindowsysteminterface.h"
-#include <qpa/qplatformwindow.h>
-#include "qwindowsysteminterface_p.h"
-#include "private/qguiapplication_p.h"
-#include "private/qevent_p.h"
-#include "private/qtouchdevice_p.h"
-#include <QAbstractEventDispatcher>
-#include <qpa/qplatformdrag.h>
-#include <qdebug.h>
-
-QT_BEGIN_NAMESPACE
-
-
-QElapsedTimer QWindowSystemInterfacePrivate::eventTime;
-
-//------------------------------------------------------------
-//
-// Callback functions for plugins:
-//
-
-QList<QWindowSystemInterfacePrivate::WindowSystemEvent *> QWindowSystemInterfacePrivate::windowSystemEventQueue;
-QMutex QWindowSystemInterfacePrivate::queueMutex;
-
-extern QPointer<QWindow> qt_last_mouse_receiver;
-
-/*!
-    \class QWindowSystemInterface
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-    \brief The QWindowSystemInterface provides an event queue for the QPA platform.
-
-    The platform plugins call the various functions to notify about events. The events are queued
-    until sendWindowSystemEvents() is called by the event dispatcher.
-*/
-
-void QWindowSystemInterface::handleEnterEvent(QWindow *tlw)
-{
-    if (tlw) {
-        QWindowSystemInterfacePrivate::EnterEvent *e = new QWindowSystemInterfacePrivate::EnterEvent(tlw);
-        QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-    }
-}
-
-void QWindowSystemInterface::handleLeaveEvent(QWindow *tlw)
-{
-    QWindowSystemInterfacePrivate::LeaveEvent *e = new QWindowSystemInterfacePrivate::LeaveEvent(tlw);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleWindowActivated(QWindow *tlw)
-{
-    QWindowSystemInterfacePrivate::ActivatedWindowEvent *e = new QWindowSystemInterfacePrivate::ActivatedWindowEvent(tlw);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleWindowStateChanged(QWindow *tlw, Qt::WindowState newState)
-{
-    QWindowSystemInterfacePrivate::WindowStateChangedEvent *e =
-        new QWindowSystemInterfacePrivate::WindowStateChangedEvent(tlw, newState);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleGeometryChange(QWindow *tlw, const QRect &newRect)
-{
-    QWindowSystemInterfacePrivate::GeometryChangeEvent *e = new QWindowSystemInterfacePrivate::GeometryChangeEvent(tlw,newRect);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleSynchronousGeometryChange(QWindow *tlw, const QRect &newRect)
-{
-    QWindowSystemInterfacePrivate::GeometryChangeEvent e(tlw,newRect);
-    QGuiApplicationPrivate::processWindowSystemEvent(&e); // send event immediately.
-}
-
-void QWindowSystemInterface::handleCloseEvent(QWindow *tlw)
-{
-    if (tlw) {
-        QWindowSystemInterfacePrivate::CloseEvent *e =
-                new QWindowSystemInterfacePrivate::CloseEvent(tlw);
-        QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-    }
-}
-
-void QWindowSystemInterface::handleSynchronousCloseEvent(QWindow *tlw)
-{
-    if (tlw) {
-        QWindowSystemInterfacePrivate::CloseEvent e(tlw);
-        QGuiApplicationPrivate::processWindowSystemEvent(&e);
-    }
-}
-
-/*!
-
-\a w == 0 means that the event is in global coords only, \a local will be ignored in this case
-
-*/
-void QWindowSystemInterface::handleMouseEvent(QWindow *w, const QPointF & local, const QPointF & global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
-{
-    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleMouseEvent(w, time, local, global, b, mods);
-}
-
-void QWindowSystemInterface::handleMouseEvent(QWindow *w, ulong timestamp, const QPointF & local, const QPointF & global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
-{
-    QWindowSystemInterfacePrivate::MouseEvent * e =
-            new QWindowSystemInterfacePrivate::MouseEvent(w, timestamp, local, global, b, mods);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleFrameStrutMouseEvent(QWindow *w, const QPointF & local, const QPointF & global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
-{
-    const unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleFrameStrutMouseEvent(w, time, local, global, b, mods);
-}
-
-void QWindowSystemInterface::handleFrameStrutMouseEvent(QWindow *w, ulong timestamp, const QPointF & local, const QPointF & global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
-{
-    QWindowSystemInterfacePrivate::MouseEvent * e =
-            new QWindowSystemInterfacePrivate::MouseEvent(w, timestamp,
-                                                          QWindowSystemInterfacePrivate::FrameStrutMouse,
-                                                          local, global, b, mods);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-bool QWindowSystemInterface::tryHandleSynchronousShortcutEvent(QWindow *w, int k, Qt::KeyboardModifiers mods,
-                                                               const QString & text, bool autorep, ushort count)
-{
-    unsigned long timestamp = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    return tryHandleSynchronousShortcutEvent(w, timestamp, k, mods, text, autorep, count);
-}
-
-bool QWindowSystemInterface::tryHandleSynchronousShortcutEvent(QWindow *w, ulong timestamp, int k, Qt::KeyboardModifiers mods,
-                                                               const QString & text, bool autorep, ushort count)
-{
-    QGuiApplicationPrivate::modifier_buttons = mods;
-
-    QKeyEvent qevent(QEvent::ShortcutOverride, k, mods, text, autorep, count);
-    qevent.setTimestamp(timestamp);
-    return QGuiApplicationPrivate::instance()->shortcutMap.tryShortcutEvent(w, &qevent);
-}
-
-bool QWindowSystemInterface::tryHandleSynchronousExtendedShortcutEvent(QWindow *w, int k, Qt::KeyboardModifiers mods,
-                                                                       quint32 nativeScanCode, quint32 nativeVirtualKey, quint32 nativeModifiers,
-                                                                       const QString &text, bool autorep, ushort count)
-{
-    unsigned long timestamp = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    return tryHandleSynchronousExtendedShortcutEvent(w, timestamp, k, mods, nativeScanCode, nativeVirtualKey, nativeModifiers, text, autorep, count);
-}
-
-bool QWindowSystemInterface::tryHandleSynchronousExtendedShortcutEvent(QWindow *w, ulong timestamp, int k, Qt::KeyboardModifiers mods,
-                                                                       quint32 nativeScanCode, quint32 nativeVirtualKey, quint32 nativeModifiers,
-                                                                       const QString &text, bool autorep, ushort count)
-{
-    QGuiApplicationPrivate::modifier_buttons = mods;
-
-    QKeyEvent qevent(QEvent::ShortcutOverride, k, mods, nativeScanCode, nativeVirtualKey, nativeModifiers, text, autorep, count);
-    qevent.setTimestamp(timestamp);
-    return QGuiApplicationPrivate::instance()->shortcutMap.tryShortcutEvent(w, &qevent);
-}
-
-
-void QWindowSystemInterface::handleKeyEvent(QWindow *w, QEvent::Type t, int k, Qt::KeyboardModifiers mods, const QString & text, bool autorep, ushort count) {
-    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleKeyEvent(w, time, t, k, mods, text, autorep, count);
-}
-
-void QWindowSystemInterface::handleKeyEvent(QWindow *tlw, ulong timestamp, QEvent::Type t, int k, Qt::KeyboardModifiers mods, const QString & text, bool autorep, ushort count)
-{
-    QWindowSystemInterfacePrivate::KeyEvent * e =
-            new QWindowSystemInterfacePrivate::KeyEvent(tlw, timestamp, t, k, mods, text, autorep, count);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleExtendedKeyEvent(QWindow *w, QEvent::Type type, int key, Qt::KeyboardModifiers modifiers,
-                                                    quint32 nativeScanCode, quint32 nativeVirtualKey,
-                                                    quint32 nativeModifiers,
-                                                    const QString& text, bool autorep,
-                                                    ushort count)
-{
-    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleExtendedKeyEvent(w, time, type, key, modifiers, nativeScanCode, nativeVirtualKey, nativeModifiers,
-                           text, autorep, count);
-}
-
-void QWindowSystemInterface::handleExtendedKeyEvent(QWindow *tlw, ulong timestamp, QEvent::Type type, int key,
-                                                    Qt::KeyboardModifiers modifiers,
-                                                    quint32 nativeScanCode, quint32 nativeVirtualKey,
-                                                    quint32 nativeModifiers,
-                                                    const QString& text, bool autorep,
-                                                    ushort count)
-{
-    QWindowSystemInterfacePrivate::KeyEvent * e =
-            new QWindowSystemInterfacePrivate::KeyEvent(tlw, timestamp, type, key, modifiers,
-                nativeScanCode, nativeVirtualKey, nativeModifiers, text, autorep, count);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleWheelEvent(QWindow *w, const QPointF & local, const QPointF & global, int d, Qt::Orientation o, Qt::KeyboardModifiers mods) {
-    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleWheelEvent(w, time, local, global, d, o, mods);
-}
-
-void QWindowSystemInterface::handleWheelEvent(QWindow *tlw, ulong timestamp, const QPointF & local, const QPointF & global, int d, Qt::Orientation o, Qt::KeyboardModifiers mods)
-{
-    QPoint point = (o == Qt::Vertical) ? QPoint(0, d) : QPoint(d, 0);
-    handleWheelEvent(tlw, timestamp, local, global, QPoint(), point, mods);
-}
-
-void QWindowSystemInterface::handleWheelEvent(QWindow *w, const QPointF & local, const QPointF & global, QPoint pixelDelta, QPoint angleDelta, Qt::KeyboardModifiers mods)
-{
-    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleWheelEvent(w, time, local, global, pixelDelta, angleDelta, mods);
-}
-
-void QWindowSystemInterface::handleWheelEvent(QWindow *tlw, ulong timestamp, const QPointF & local, const QPointF & global, QPoint pixelDelta, QPoint angleDelta, Qt::KeyboardModifiers mods)
-{
-    // Qt 4 sends two separate wheel events for horizontal and vertical
-    // deltas. For Qt 5 we want to send the deltas in one event, but at the
-    // same time preserve source and behavior compatibility with Qt 4.
-    //
-    // In addition high-resolution pixel-based deltas are also supported.
-    // Platforms that does not support these may pass a null point here.
-    // Angle deltas must always be sent in addition to pixel deltas.
-    QWindowSystemInterfacePrivate::WheelEvent *e;
-
-    if (angleDelta.isNull())
-        return;
-
-    // Simple case: vertical deltas only:
-    if (angleDelta.y() != 0 && angleDelta.x() == 0) {
-        e = new QWindowSystemInterfacePrivate::WheelEvent(tlw, timestamp, local, global, pixelDelta, angleDelta, angleDelta.y(), Qt::Vertical, mods);
-        QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-        return;
-    }
-
-    // Simple case: horizontal deltas only:
-    if (angleDelta.y() == 0 && angleDelta.x() != 0) {
-        e = new QWindowSystemInterfacePrivate::WheelEvent(tlw, timestamp, local, global, pixelDelta, angleDelta, angleDelta.x(), Qt::Horizontal, mods);
-        QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-        return;
-    }
-
-    // Both horizontal and vertical deltas: Send two wheel events.
-    // The first event contains the Qt 5 pixel and angle delta as points,
-    // and in addition the Qt 4 compatibility vertical angle delta.
-    e = new QWindowSystemInterfacePrivate::WheelEvent(tlw, timestamp, local, global, pixelDelta, angleDelta, angleDelta.y(), Qt::Vertical, mods);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-
-    // The second event contains null pixel and angle points and the
-    // Qt 4 compatibility horizontal angle delta.
-    e = new QWindowSystemInterfacePrivate::WheelEvent(tlw, timestamp, local, global, QPoint(), QPoint(), angleDelta.x(), Qt::Horizontal, mods);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-
-QWindowSystemInterfacePrivate::ExposeEvent::ExposeEvent(QWindow *exposed, const QRegion &region)
-    : WindowSystemEvent(Expose)
-    , exposed(exposed)
-    , isExposed(exposed && exposed->handle() ? exposed->handle()->isExposed() : false)
-    , region(region)
-{
-}
-
-int QWindowSystemInterfacePrivate::windowSystemEventsQueued()
-{
-    queueMutex.lock();
-    int ret = windowSystemEventQueue.count();
-    queueMutex.unlock();
-    return ret;
-}
-
-QWindowSystemInterfacePrivate::WindowSystemEvent * QWindowSystemInterfacePrivate::getWindowSystemEvent()
-{
-    queueMutex.lock();
-    QWindowSystemInterfacePrivate::WindowSystemEvent *ret;
-    if (windowSystemEventQueue.isEmpty())
-        ret = 0;
-    else
-        ret = windowSystemEventQueue.takeFirst();
-    queueMutex.unlock();
-    return ret;
-}
-
-void QWindowSystemInterfacePrivate::queueWindowSystemEvent(QWindowSystemInterfacePrivate::WindowSystemEvent *ev)
-{
-    queueMutex.lock();
-    windowSystemEventQueue.append(ev);
-    queueMutex.unlock();
-
-    QAbstractEventDispatcher *dispatcher = QGuiApplicationPrivate::qt_qpa_core_dispatcher();
-    if (dispatcher)
-        dispatcher->wakeUp();
-}
-
-void QWindowSystemInterface::registerTouchDevice(QTouchDevice *device)
-{
-    QTouchDevicePrivate::registerDevice(device);
-}
-
-void QWindowSystemInterface::handleTouchEvent(QWindow *w, QTouchDevice *device,
-                                              const QList<TouchPoint> &points, Qt::KeyboardModifiers mods)
-{
-    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleTouchEvent(w, time, device, points, mods);
-}
-
-QList<QTouchEvent::TouchPoint> QWindowSystemInterfacePrivate::convertTouchPoints(const QList<QWindowSystemInterface::TouchPoint> &points, QEvent::Type *type)
-{
-    QList<QTouchEvent::TouchPoint> touchPoints;
-    Qt::TouchPointStates states;
-    QTouchEvent::TouchPoint p;
-
-    QList<QWindowSystemInterface::TouchPoint>::const_iterator point = points.constBegin();
-    QList<QWindowSystemInterface::TouchPoint>::const_iterator end = points.constEnd();
-    while (point != end) {
-        p.setId(point->id);
-        p.setPressure(point->pressure);
-        states |= point->state;
-        p.setState(point->state);
-
-        const QPointF screenPos = point->area.center();
-        p.setScreenPos(screenPos);
-        p.setScreenRect(point->area);
-
-        // The local pos and rect are not set, they will be calculated
-        // when the event gets processed by QGuiApplication.
-
-        p.setNormalizedPos(point->normalPosition);
-        p.setVelocity(point->velocity);
-        p.setFlags(point->flags);
-        p.setRawScreenPositions(point->rawPositions);
-
-        touchPoints.append(p);
-        ++point;
-    }
-
-    // Determine the event type based on the combined point states.
-    if (type) {
-        *type = QEvent::TouchUpdate;
-        if (states == Qt::TouchPointPressed)
-            *type = QEvent::TouchBegin;
-        else if (states == Qt::TouchPointReleased)
-            *type = QEvent::TouchEnd;
-    }
-
-    return touchPoints;
-}
-
-void QWindowSystemInterface::handleTouchEvent(QWindow *tlw, ulong timestamp, QTouchDevice *device,
-                                              const QList<TouchPoint> &points, Qt::KeyboardModifiers mods)
-{
-    if (!points.size()) // Touch events must have at least one point
-        return;
-
-    if (!QTouchDevicePrivate::isRegistered(device)) // Disallow passing bogus, non-registered devices.
-        return;
-
-    QEvent::Type type;
-    QList<QTouchEvent::TouchPoint> touchPoints = QWindowSystemInterfacePrivate::convertTouchPoints(points, &type);
-
-    QWindowSystemInterfacePrivate::TouchEvent *e =
-            new QWindowSystemInterfacePrivate::TouchEvent(tlw, timestamp, type, device, touchPoints, mods);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleTouchCancelEvent(QWindow *w, QTouchDevice *device,
-                                                    Qt::KeyboardModifiers mods)
-{
-    unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleTouchCancelEvent(w, time, device, mods);
-}
-
-void QWindowSystemInterface::handleTouchCancelEvent(QWindow *w, ulong timestamp, QTouchDevice *device,
-                                                    Qt::KeyboardModifiers mods)
-{
-    QWindowSystemInterfacePrivate::TouchEvent *e =
-            new QWindowSystemInterfacePrivate::TouchEvent(w, timestamp, QEvent::TouchCancel, device,
-                                                         QList<QTouchEvent::TouchPoint>(), mods);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleScreenOrientationChange(QScreen *screen, Qt::ScreenOrientation orientation)
-{
-    QWindowSystemInterfacePrivate::ScreenOrientationEvent *e =
-            new QWindowSystemInterfacePrivate::ScreenOrientationEvent(screen, orientation);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleScreenGeometryChange(QScreen *screen, const QRect &geometry)
-{
-    QWindowSystemInterfacePrivate::ScreenGeometryEvent *e =
-            new QWindowSystemInterfacePrivate::ScreenGeometryEvent(screen, geometry);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleScreenAvailableGeometryChange(QScreen *screen, const QRect &availableGeometry)
-{
-    QWindowSystemInterfacePrivate::ScreenAvailableGeometryEvent *e =
-            new QWindowSystemInterfacePrivate::ScreenAvailableGeometryEvent(screen, availableGeometry);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleScreenLogicalDotsPerInchChange(QScreen *screen, qreal dpiX, qreal dpiY)
-{
-    QWindowSystemInterfacePrivate::ScreenLogicalDotsPerInchEvent *e =
-            new QWindowSystemInterfacePrivate::ScreenLogicalDotsPerInchEvent(screen, dpiX, dpiY);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleScreenRefreshRateChange(QScreen *screen, qreal newRefreshRate)
-{
-    QWindowSystemInterfacePrivate::ScreenRefreshRateEvent *e =
-            new QWindowSystemInterfacePrivate::ScreenRefreshRateEvent(screen, newRefreshRate);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleThemeChange(QWindow *tlw)
-{
-    QWindowSystemInterfacePrivate::ThemeChangeEvent *e = new QWindowSystemInterfacePrivate::ThemeChangeEvent(tlw);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleExposeEvent(QWindow *tlw, const QRegion &region)
-{
-    QWindowSystemInterfacePrivate::ExposeEvent *e = new QWindowSystemInterfacePrivate::ExposeEvent(tlw, region);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleSynchronousExposeEvent(QWindow *tlw, const QRegion &region)
-{
-    QWindowSystemInterfacePrivate::ExposeEvent e(tlw, region);
-    QGuiApplicationPrivate::processWindowSystemEvent(&e); // send event immediately.
-}
-
-bool QWindowSystemInterface::sendWindowSystemEvents(QAbstractEventDispatcher *eventDispatcher, QEventLoop::ProcessEventsFlags flags)
-{
-    int nevents = 0;
-
-    // handle gui and posted events
-    QCoreApplication::sendPostedEvents();
-
-    while (true) {
-        QWindowSystemInterfacePrivate::WindowSystemEvent *event;
-        if (!(flags & QEventLoop::ExcludeUserInputEvents)
-            && QWindowSystemInterfacePrivate::windowSystemEventsQueued() > 0) {
-            // process a pending user input event
-            event = QWindowSystemInterfacePrivate::getWindowSystemEvent();
-            if (!event)
-                break;
-        } else {
-            break;
-        }
-
-        if (eventDispatcher->filterEvent(event)) {
-            delete event;
-            continue;
-        }
-
-        nevents++;
-
-        QGuiApplicationPrivate::processWindowSystemEvent(event);
-        delete event;
-    }
-
-    return (nevents > 0);
-}
-
-int QWindowSystemInterface::windowSystemEventsQueued()
-{
-    return QWindowSystemInterfacePrivate::windowSystemEventsQueued();
-}
-
-#ifndef QT_NO_DRAGANDDROP
-QPlatformDragQtResponse QWindowSystemInterface::handleDrag(QWindow *w, const QMimeData *dropData, const QPoint &p, Qt::DropActions supportedActions)
-{
-    return QGuiApplicationPrivate::processDrag(w, dropData, p,supportedActions);
-}
-
-QPlatformDropQtResponse QWindowSystemInterface::handleDrop(QWindow *w, const QMimeData *dropData, const QPoint &p, Qt::DropActions supportedActions)
-{
-    return QGuiApplicationPrivate::processDrop(w, dropData, p,supportedActions);
-}
-#endif // QT_NO_DRAGANDDROP
-
-/*!
-    \fn static QWindowSystemInterface::handleNativeEvent(QWindow *window, const QByteArray &eventType, void *message, long *result)
-    \brief Passes a native event identified by \a eventType to the \a window.
-
-    \note This function can only be called from the GUI thread.
-    \sa QPlatformNativeInterface::setEventFilter()
-*/
-
-bool QWindowSystemInterface::handleNativeEvent(QWindow *window, const QByteArray &eventType, void *message, long *result)
-{
-    return QGuiApplicationPrivate::processNativeEvent(window, eventType, message, result);
-}
-
-void QWindowSystemInterface::handleFileOpenEvent(const QString& fileName)
-{
-    QWindowSystemInterfacePrivate::FileOpenEvent e(fileName);
-    QGuiApplicationPrivate::processWindowSystemEvent(&e);
-}
-
-void QWindowSystemInterface::handleTabletEvent(QWindow *w, ulong timestamp, bool down, const QPointF &local, const QPointF &global,
-                                               int device, int pointerType, qreal pressure, int xTilt, int yTilt,
-                                               qreal tangentialPressure, qreal rotation, int z, qint64 uid,
-                                               Qt::KeyboardModifiers modifiers)
-{
-    QWindowSystemInterfacePrivate::TabletEvent *e =
-            new QWindowSystemInterfacePrivate::TabletEvent(w, timestamp, down, local, global, device, pointerType, pressure,
-                                                           xTilt, yTilt, tangentialPressure, rotation, z, uid, modifiers);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleTabletEvent(QWindow *w, bool down, const QPointF &local, const QPointF &global,
-                                               int device, int pointerType, qreal pressure, int xTilt, int yTilt,
-                                               qreal tangentialPressure, qreal rotation, int z, qint64 uid,
-                                               Qt::KeyboardModifiers modifiers)
-{
-    ulong time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleTabletEvent(w, time, down, local, global, device, pointerType, pressure,
-                      xTilt, yTilt, tangentialPressure, rotation, z, uid, modifiers);
-}
-
-void QWindowSystemInterface::handleTabletEnterProximityEvent(ulong timestamp, int device, int pointerType, qint64 uid)
-{
-    QWindowSystemInterfacePrivate::TabletEnterProximityEvent *e =
-            new QWindowSystemInterfacePrivate::TabletEnterProximityEvent(timestamp, device, pointerType, uid);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleTabletEnterProximityEvent(int device, int pointerType, qint64 uid)
-{
-    ulong time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleTabletEnterProximityEvent(time, device, pointerType, uid);
-}
-
-void QWindowSystemInterface::handleTabletLeaveProximityEvent(ulong timestamp, int device, int pointerType, qint64 uid)
-{
-    QWindowSystemInterfacePrivate::TabletLeaveProximityEvent *e =
-            new QWindowSystemInterfacePrivate::TabletLeaveProximityEvent(timestamp, device, pointerType, uid);
-    QWindowSystemInterfacePrivate::queueWindowSystemEvent(e);
-}
-
-void QWindowSystemInterface::handleTabletLeaveProximityEvent(int device, int pointerType, qint64 uid)
-{
-    ulong time = QWindowSystemInterfacePrivate::eventTime.elapsed();
-    handleTabletLeaveProximityEvent(time, device, pointerType, uid);
-}
-
-
-QT_END_NAMESPACE
diff --git a/src/gui/painting/painting.pri b/src/gui/painting/painting.pri
index 6db0d34..cace864 100644
--- a/src/gui/painting/painting.pri
+++ b/src/gui/painting/painting.pri
@@ -83,7 +83,7 @@ SOURCES += \
         painting/qstroker.cpp \
         painting/qtextureglyphcache.cpp \
         painting/qtransform.cpp \
-        painting/qplatformbackingstore_qpa.cpp \
+        painting/qplatformbackingstore.cpp \
         painting/qpaintbuffer.cpp \
         painting/qpathsimplifier.cpp
 
diff --git a/src/gui/painting/qplatformbackingstore.cpp b/src/gui/painting/qplatformbackingstore.cpp
new file mode 100644
index 0000000..34cda00
--- /dev/null
+++ b/src/gui/painting/qplatformbackingstore.cpp
@@ -0,0 +1,149 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformbackingstore.h"
+#include <qwindow.h>
+#include <qpixmap.h>
+#include <private/qwindow_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QPlatformBackingStorePrivate
+{
+public:
+    QPlatformBackingStorePrivate(QWindow *w)
+        : window(w)
+    {
+    }
+
+    QWindow *window;
+    QSize size;
+};
+
+/*!
+    \class QPlatformBackingStore
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformBackingStore class provides the drawing area for top-level
+    windows.
+*/
+
+/*!
+    \fn void QPlatformBackingStore::flush(QWindow *window, const QRegion &region,
+                                  const QPoint &offset)
+
+    Flushes the given \a region from the specified \a window onto the
+    screen.
+
+    Note that the \a offset parameter is currently unused.
+*/
+
+/*!
+    \fn QPaintDevice* QPlatformBackingStore::paintDevice()
+
+    Implement this function to return the appropriate paint device.
+*/
+
+/*!
+    Constructs an empty surface for the given top-level \a window.
+*/
+QPlatformBackingStore::QPlatformBackingStore(QWindow *window)
+    : d_ptr(new QPlatformBackingStorePrivate(window))
+{
+}
+
+/*!
+    Destroys this surface.
+*/
+QPlatformBackingStore::~QPlatformBackingStore()
+{
+    delete d_ptr;
+}
+
+/*!
+    Returns a pointer to the top-level window associated with this
+    surface.
+*/
+QWindow* QPlatformBackingStore::window() const
+{
+    return d_ptr->window;
+}
+
+/*!
+    This function is called before painting onto the surface begins,
+    with the \a region in which the painting will occur.
+
+    \sa endPaint(), paintDevice()
+*/
+
+void QPlatformBackingStore::beginPaint(const QRegion &)
+{
+}
+
+/*!
+    This function is called after painting onto the surface has ended.
+
+    \sa beginPaint(), paintDevice()
+*/
+
+void QPlatformBackingStore::endPaint()
+{
+}
+
+/*!
+    Scrolls the given \a area \a dx pixels to the right and \a dy
+    downward; both \a dx and \a dy may be negative.
+
+    Returns true if the area was scrolled successfully; false otherwise.
+*/
+bool QPlatformBackingStore::scroll(const QRegion &area, int dx, int dy)
+{
+    Q_UNUSED(area);
+    Q_UNUSED(dx);
+    Q_UNUSED(dy);
+
+    return false;
+}
+
+QT_END_NAMESPACE
diff --git a/src/gui/painting/qplatformbackingstore_qpa.cpp b/src/gui/painting/qplatformbackingstore_qpa.cpp
deleted file mode 100644
index 34cda00..0000000
--- a/src/gui/painting/qplatformbackingstore_qpa.cpp
+++ /dev/null
@@ -1,149 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformbackingstore.h"
-#include <qwindow.h>
-#include <qpixmap.h>
-#include <private/qwindow_p.h>
-
-QT_BEGIN_NAMESPACE
-
-class QPlatformBackingStorePrivate
-{
-public:
-    QPlatformBackingStorePrivate(QWindow *w)
-        : window(w)
-    {
-    }
-
-    QWindow *window;
-    QSize size;
-};
-
-/*!
-    \class QPlatformBackingStore
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformBackingStore class provides the drawing area for top-level
-    windows.
-*/
-
-/*!
-    \fn void QPlatformBackingStore::flush(QWindow *window, const QRegion &region,
-                                  const QPoint &offset)
-
-    Flushes the given \a region from the specified \a window onto the
-    screen.
-
-    Note that the \a offset parameter is currently unused.
-*/
-
-/*!
-    \fn QPaintDevice* QPlatformBackingStore::paintDevice()
-
-    Implement this function to return the appropriate paint device.
-*/
-
-/*!
-    Constructs an empty surface for the given top-level \a window.
-*/
-QPlatformBackingStore::QPlatformBackingStore(QWindow *window)
-    : d_ptr(new QPlatformBackingStorePrivate(window))
-{
-}
-
-/*!
-    Destroys this surface.
-*/
-QPlatformBackingStore::~QPlatformBackingStore()
-{
-    delete d_ptr;
-}
-
-/*!
-    Returns a pointer to the top-level window associated with this
-    surface.
-*/
-QWindow* QPlatformBackingStore::window() const
-{
-    return d_ptr->window;
-}
-
-/*!
-    This function is called before painting onto the surface begins,
-    with the \a region in which the painting will occur.
-
-    \sa endPaint(), paintDevice()
-*/
-
-void QPlatformBackingStore::beginPaint(const QRegion &)
-{
-}
-
-/*!
-    This function is called after painting onto the surface has ended.
-
-    \sa beginPaint(), paintDevice()
-*/
-
-void QPlatformBackingStore::endPaint()
-{
-}
-
-/*!
-    Scrolls the given \a area \a dx pixels to the right and \a dy
-    downward; both \a dx and \a dy may be negative.
-
-    Returns true if the area was scrolled successfully; false otherwise.
-*/
-bool QPlatformBackingStore::scroll(const QRegion &area, int dx, int dy)
-{
-    Q_UNUSED(area);
-    Q_UNUSED(dx);
-    Q_UNUSED(dy);
-
-    return false;
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/text/qplatformfontdatabase.cpp b/src/gui/text/qplatformfontdatabase.cpp
new file mode 100644
index 0000000..7e2b890
--- /dev/null
+++ b/src/gui/text/qplatformfontdatabase.cpp
@@ -0,0 +1,443 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformfontdatabase.h"
+#include <QtGui/private/qfontengine_p.h>
+#include <QtGui/private/qfontengine_qpa_p.h>
+#include <QtCore/QLibraryInfo>
+#include <QtCore/QDir>
+
+QT_BEGIN_NAMESPACE
+
+extern void qt_registerFont(const QString &familyname, const QString &foundryname, int weight,
+                            QFont::Style style, int stretch, bool antialiased,
+                            bool scalable, int pixelSize, bool fixedPitch,
+                            const QSupportedWritingSystems &writingSystems, void *hanlde);
+
+/*!
+    \fn void QPlatformFontDatabase::registerQPF2Font(const QByteArray &dataArray, void *handle)
+
+    Registers the pre-rendered QPF2 font contained in the given \a dataArray.
+
+    \sa registerFont()
+*/
+void QPlatformFontDatabase::registerQPF2Font(const QByteArray &dataArray, void *handle)
+{
+    if (dataArray.size() == 0)
+        return;
+
+    const uchar *data = reinterpret_cast<const uchar *>(dataArray.constData());
+    if (QFontEngineQPA::verifyHeader(data, dataArray.size())) {
+        QString fontName = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_FontName).toString();
+        int pixelSize = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_PixelSize).toInt();
+        QVariant weight = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_Weight);
+        QVariant style = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_Style);
+        QByteArray writingSystemBits = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_WritingSystems).toByteArray();
+
+        if (!fontName.isEmpty() && pixelSize) {
+            QFont::Weight fontWeight = QFont::Normal;
+            if (weight.type() == QVariant::Int || weight.type() == QVariant::UInt)
+                fontWeight = QFont::Weight(weight.toInt());
+
+            QFont::Style fontStyle = static_cast<QFont::Style>(style.toInt());
+
+            QSupportedWritingSystems writingSystems;
+            for (int i = 0; i < writingSystemBits.count(); ++i) {
+                uchar currentByte = writingSystemBits.at(i);
+                for (int j = 0; j < 8; ++j) {
+                    if (currentByte & 1)
+                        writingSystems.setSupported(QFontDatabase::WritingSystem(i * 8 + j));
+                    currentByte >>= 1;
+                }
+            }
+            QFont::Stretch stretch = QFont::Unstretched;
+            registerFont(fontName,QString(),fontWeight,fontStyle,stretch,true,false,pixelSize,false,writingSystems,handle);
+        }
+    } else {
+        qDebug() << "header verification of QPF2 font failed. maybe it is corrupt?";
+    }
+}
+
+/*!
+    Registers a font with the given set of attributes describing the font's
+    foundry, family name, style and stretch information, pixel size, and
+    supported writing systems. Additional information about whether the font
+    can be scaled and antialiased can also be provided.
+
+    The foundry name and font family are described by \a foundryName and
+    \a familyName. The font weight (light, normal, bold, etc.), style (normal,
+    oblique, italic) and stretch information (condensed, expanded, unstretched,
+    etc.) are specified by \a weight, \a style and \a stretch.
+
+    Some fonts can be antialiased and scaled; \a scalable and \a antialiased
+    can be set to true for fonts with these attributes. The intended pixel
+    size of non-scalable fonts is specified by \a pixelSize; this value will be
+    ignored for scalable fonts.
+
+    The writing systems supported by the font are specified by the
+    \a writingSystems argument.
+
+    \sa registerQPF2Font()
+*/
+void QPlatformFontDatabase::registerFont(const QString &familyname, const QString &foundryname, QFont::Weight weight,
+                                         QFont::Style style, QFont::Stretch stretch, bool antialiased,
+                                         bool scalable, int pixelSize, bool fixedPitch,
+                                         const QSupportedWritingSystems &writingSystems, void *usrPtr)
+{
+    if (scalable)
+        pixelSize = 0;
+
+    qt_registerFont(familyname, foundryname, weight, style,
+                    stretch, antialiased, scalable, pixelSize,
+                    fixedPitch, writingSystems, usrPtr);
+}
+
+class QWritingSystemsPrivate
+{
+public:
+    QWritingSystemsPrivate()
+        : ref(1)
+        , vector(QFontDatabase::WritingSystemsCount,false)
+    {
+    }
+
+    QWritingSystemsPrivate(const QWritingSystemsPrivate *other)
+        : ref(1)
+        , vector(other->vector)
+    {
+    }
+
+    QAtomicInt ref;
+    QVector<bool> vector;
+};
+
+/*!
+    Constructs a new object to handle supported writing systems.
+*/
+QSupportedWritingSystems::QSupportedWritingSystems()
+{
+    d = new QWritingSystemsPrivate;
+}
+
+/*!
+    Constructs a copy of the \a other writing systems object.
+*/
+QSupportedWritingSystems::QSupportedWritingSystems(const QSupportedWritingSystems &other)
+{
+    d = other.d;
+    d->ref.ref();
+}
+
+/*!
+    Constructs a copy of the \a other writing systems object.
+*/
+QSupportedWritingSystems &QSupportedWritingSystems::operator=(const QSupportedWritingSystems &other)
+{
+    if (d != other.d) {
+        other.d->ref.ref();
+        if (!d->ref.deref())
+            delete d;
+        d = other.d;
+    }
+    return *this;
+}
+
+/*!
+    Destroys the supported writing systems object.
+*/
+QSupportedWritingSystems::~QSupportedWritingSystems()
+{
+    if (!d->ref.deref())
+        delete d;
+}
+
+/*!
+    \internal
+*/
+void QSupportedWritingSystems::detach()
+{
+    if (d->ref.load() != 1) {
+        QWritingSystemsPrivate *newd = new QWritingSystemsPrivate(d);
+        if (!d->ref.deref())
+            delete d;
+        d = newd;
+    }
+}
+
+/*!
+    Sets or clears support for the specified \a writingSystem based on the
+    value given by \a support.
+*/
+void QSupportedWritingSystems::setSupported(QFontDatabase::WritingSystem writingSystem, bool support)
+{
+    detach();
+    d->vector[writingSystem] = support;
+}
+
+/*!
+    Returns true if the writing system specified by \a writingSystem is
+    supported; otherwise returns false.
+*/
+bool QSupportedWritingSystems::supported(QFontDatabase::WritingSystem writingSystem) const
+{
+    return d->vector.at(writingSystem);
+}
+
+/*!
+    \class QSupportedWritingSystems
+    \brief The QSupportedWritingSystems class is used when registering fonts with the internal Qt
+    fontdatabase
+    \ingroup painting
+    \inmodule QtGui
+
+    Its to provide an easy to use interface for indicating what writing systems a specific font
+    supports.
+
+*/
+
+/*!
+    \internal
+ */
+QPlatformFontDatabase::~QPlatformFontDatabase()
+{
+}
+
+/*!
+  This function is called once at startup by Qt's internal font database.
+  Reimplement this function in a subclass for a convenient place to initialize
+  the internal font database.
+
+  The default implementation looks in the fontDir() location and registers all
+  QPF2 fonts.
+*/
+void QPlatformFontDatabase::populateFontDatabase()
+{
+    QString fontpath = fontDir();
+    if(!QFile::exists(fontpath)) {
+        qWarning("QFontDatabase: Cannot find font directory '%s' - is Qt installed correctly?",
+                 qPrintable(QDir::toNativeSeparators(fontpath)));
+        return;
+    }
+
+    QDir dir(fontpath);
+    dir.setNameFilters(QStringList() << QLatin1String("*.qpf2"));
+    dir.refresh();
+    for (int i = 0; i < int(dir.count()); ++i) {
+        const QByteArray fileName = QFile::encodeName(dir.absoluteFilePath(dir[i]));
+        QFile file(QString::fromLocal8Bit(fileName));
+        if (file.open(QFile::ReadOnly)) {
+            const QByteArray fileData = file.readAll();
+            QByteArray *fileDataPtr = new QByteArray(fileData);
+            registerQPF2Font(fileData, fileDataPtr);
+        }
+    }
+}
+
+/*!
+    Returns a multi font engine in the specified \a script to encapsulate \a fontEngine with the
+    option to fall back to to the fonts given by \a fallbacks if \a fontEngine does not support
+    a certain character.
+*/
+QFontEngineMulti *QPlatformFontDatabase::fontEngineMulti(QFontEngine *fontEngine,
+                                                         QUnicodeTables::Script script)
+{
+    return new QFontEngineMultiQPA(fontEngine, script);
+}
+
+/*!
+    Returns the font engine that can be used to render the font described by
+    the font definition, \a fontDef, in the specified \a script.
+*/
+QFontEngine *QPlatformFontDatabase::fontEngine(const QFontDef &fontDef, QUnicodeTables::Script script, void *handle)
+{
+    Q_UNUSED(script);
+    Q_UNUSED(handle);
+    QByteArray *fileDataPtr = static_cast<QByteArray *>(handle);
+    QFontEngineQPA *engine = new QFontEngineQPA(fontDef,*fileDataPtr);
+    //qDebug() << fontDef.pixelSize << fontDef.weight << fontDef.style << fontDef.stretch << fontDef.styleHint << fontDef.styleStrategy << fontDef.family << script;
+    return engine;
+}
+
+QFontEngine *QPlatformFontDatabase::fontEngine(const QByteArray &fontData, qreal pixelSize,
+                                               QFont::HintingPreference hintingPreference)
+{
+    Q_UNUSED(fontData);
+    Q_UNUSED(pixelSize);
+    Q_UNUSED(hintingPreference);
+    qWarning("This plugin does not support font engines created directly from font data");
+    return 0;
+}
+
+/*!
+    Returns a list of alternative fonts for the specified \a family and
+    \a style and \a script using the \a styleHint given.
+*/
+QStringList QPlatformFontDatabase::fallbacksForFamily(const QString family, const QFont::Style &style, const QFont::StyleHint &styleHint, const QUnicodeTables::Script &script) const
+{
+    Q_UNUSED(family);
+    Q_UNUSED(style);
+    Q_UNUSED(styleHint);
+    Q_UNUSED(script);
+    return QStringList();
+}
+
+/*!
+    Adds an application font described by the font contained supplied \a fontData
+    or using the font contained in the file referenced by \a fileName. Returns
+    a list of family names, or an empty list if the font could not be added.
+
+    \note The default implementation of this function does not add an application
+    font. Subclasses should reimplement this function to perform the necessary
+    loading and registration of fonts.
+*/
+QStringList QPlatformFontDatabase::addApplicationFont(const QByteArray &fontData, const QString &fileName)
+{
+    Q_UNUSED(fontData);
+    Q_UNUSED(fileName);
+
+    qWarning("This plugin does not support application fonts");
+    return QStringList();
+}
+
+/*!
+    Releases the specified font \a handle.
+*/
+void QPlatformFontDatabase::releaseHandle(void *handle)
+{
+    QByteArray *fileDataPtr = static_cast<QByteArray *>(handle);
+    delete fileDataPtr;
+}
+
+/*!
+    Returns the directory containing the fonts used by the database.
+*/
+QString QPlatformFontDatabase::fontDir() const
+{
+    QString fontpath = QString::fromLocal8Bit(qgetenv("QT_QPA_FONTDIR"));
+    if (fontpath.isEmpty()) {
+#ifndef QT_NO_SETTINGS
+        fontpath = QLibraryInfo::location(QLibraryInfo::LibrariesPath);
+        fontpath += QLatin1String("/fonts");
+#endif
+    }
+
+    return fontpath;
+}
+
+/*!
+    Returns the default system font.
+
+    \sa QGuiApplication::font()
+    \since 5.0
+*/
+
+QFont QPlatformFontDatabase::defaultFont() const
+{
+    return QFont(QLatin1String("Helvetica"));
+}
+
+/*!
+    Resolve alias to actual font family names.
+
+    \since 5.0
+ */
+
+QString QPlatformFontDatabase::resolveFontFamilyAlias(const QString &family) const
+{
+    return family;
+}
+
+/*!
+    Return true if all fonts are considered scalable when using this font database.
+    Defaults to false.
+
+    \since 5.0
+ */
+
+bool QPlatformFontDatabase::fontsAlwaysScalable() const
+{
+    return false;
+}
+
+/*!
+    Return list of standard font sizes when using this font database.
+
+    \since 5.0
+ */
+
+ QList<int> QPlatformFontDatabase::standardSizes() const
+{
+    QList<int> ret;
+    static const unsigned short standard[] =
+        { 6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72, 0 };
+    ret.reserve(int(sizeof(standard) / sizeof(standard[0])));
+    const unsigned short *sizes = standard;
+    while (*sizes) ret << *sizes++;
+    return ret;
+}
+
+/*!
+    \class QPlatformFontDatabase
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+    \ingroup painting
+
+    \brief The QPlatformFontDatabase class makes it possible to customize how fonts
+    are discovered and how they are rendered
+
+    QPlatformFontDatabase is the superclass which is intended to let platform implementations use
+    native font handling.
+
+    Qt has its internal font database which it uses to discover available fonts on the
+    user's system. To be able to populate this database subclass this class, and
+    reimplement populateFontDatabase().
+
+    Use the function registerFont() to populate the internal font database.
+
+    Sometimes a specified font does not have the required glyphs; in such a case, the
+    fallbackForFamily() function is called automatically to find alternative font
+    families that can supply alternatives to the missing glyphs.
+
+    \sa QSupportedWritingSystems
+*/
+QT_END_NAMESPACE
diff --git a/src/gui/text/qplatformfontdatabase_qpa.cpp b/src/gui/text/qplatformfontdatabase_qpa.cpp
deleted file mode 100644
index 7e2b890..0000000
--- a/src/gui/text/qplatformfontdatabase_qpa.cpp
+++ /dev/null
@@ -1,443 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformfontdatabase.h"
-#include <QtGui/private/qfontengine_p.h>
-#include <QtGui/private/qfontengine_qpa_p.h>
-#include <QtCore/QLibraryInfo>
-#include <QtCore/QDir>
-
-QT_BEGIN_NAMESPACE
-
-extern void qt_registerFont(const QString &familyname, const QString &foundryname, int weight,
-                            QFont::Style style, int stretch, bool antialiased,
-                            bool scalable, int pixelSize, bool fixedPitch,
-                            const QSupportedWritingSystems &writingSystems, void *hanlde);
-
-/*!
-    \fn void QPlatformFontDatabase::registerQPF2Font(const QByteArray &dataArray, void *handle)
-
-    Registers the pre-rendered QPF2 font contained in the given \a dataArray.
-
-    \sa registerFont()
-*/
-void QPlatformFontDatabase::registerQPF2Font(const QByteArray &dataArray, void *handle)
-{
-    if (dataArray.size() == 0)
-        return;
-
-    const uchar *data = reinterpret_cast<const uchar *>(dataArray.constData());
-    if (QFontEngineQPA::verifyHeader(data, dataArray.size())) {
-        QString fontName = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_FontName).toString();
-        int pixelSize = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_PixelSize).toInt();
-        QVariant weight = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_Weight);
-        QVariant style = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_Style);
-        QByteArray writingSystemBits = QFontEngineQPA::extractHeaderField(data, QFontEngineQPA::Tag_WritingSystems).toByteArray();
-
-        if (!fontName.isEmpty() && pixelSize) {
-            QFont::Weight fontWeight = QFont::Normal;
-            if (weight.type() == QVariant::Int || weight.type() == QVariant::UInt)
-                fontWeight = QFont::Weight(weight.toInt());
-
-            QFont::Style fontStyle = static_cast<QFont::Style>(style.toInt());
-
-            QSupportedWritingSystems writingSystems;
-            for (int i = 0; i < writingSystemBits.count(); ++i) {
-                uchar currentByte = writingSystemBits.at(i);
-                for (int j = 0; j < 8; ++j) {
-                    if (currentByte & 1)
-                        writingSystems.setSupported(QFontDatabase::WritingSystem(i * 8 + j));
-                    currentByte >>= 1;
-                }
-            }
-            QFont::Stretch stretch = QFont::Unstretched;
-            registerFont(fontName,QString(),fontWeight,fontStyle,stretch,true,false,pixelSize,false,writingSystems,handle);
-        }
-    } else {
-        qDebug() << "header verification of QPF2 font failed. maybe it is corrupt?";
-    }
-}
-
-/*!
-    Registers a font with the given set of attributes describing the font's
-    foundry, family name, style and stretch information, pixel size, and
-    supported writing systems. Additional information about whether the font
-    can be scaled and antialiased can also be provided.
-
-    The foundry name and font family are described by \a foundryName and
-    \a familyName. The font weight (light, normal, bold, etc.), style (normal,
-    oblique, italic) and stretch information (condensed, expanded, unstretched,
-    etc.) are specified by \a weight, \a style and \a stretch.
-
-    Some fonts can be antialiased and scaled; \a scalable and \a antialiased
-    can be set to true for fonts with these attributes. The intended pixel
-    size of non-scalable fonts is specified by \a pixelSize; this value will be
-    ignored for scalable fonts.
-
-    The writing systems supported by the font are specified by the
-    \a writingSystems argument.
-
-    \sa registerQPF2Font()
-*/
-void QPlatformFontDatabase::registerFont(const QString &familyname, const QString &foundryname, QFont::Weight weight,
-                                         QFont::Style style, QFont::Stretch stretch, bool antialiased,
-                                         bool scalable, int pixelSize, bool fixedPitch,
-                                         const QSupportedWritingSystems &writingSystems, void *usrPtr)
-{
-    if (scalable)
-        pixelSize = 0;
-
-    qt_registerFont(familyname, foundryname, weight, style,
-                    stretch, antialiased, scalable, pixelSize,
-                    fixedPitch, writingSystems, usrPtr);
-}
-
-class QWritingSystemsPrivate
-{
-public:
-    QWritingSystemsPrivate()
-        : ref(1)
-        , vector(QFontDatabase::WritingSystemsCount,false)
-    {
-    }
-
-    QWritingSystemsPrivate(const QWritingSystemsPrivate *other)
-        : ref(1)
-        , vector(other->vector)
-    {
-    }
-
-    QAtomicInt ref;
-    QVector<bool> vector;
-};
-
-/*!
-    Constructs a new object to handle supported writing systems.
-*/
-QSupportedWritingSystems::QSupportedWritingSystems()
-{
-    d = new QWritingSystemsPrivate;
-}
-
-/*!
-    Constructs a copy of the \a other writing systems object.
-*/
-QSupportedWritingSystems::QSupportedWritingSystems(const QSupportedWritingSystems &other)
-{
-    d = other.d;
-    d->ref.ref();
-}
-
-/*!
-    Constructs a copy of the \a other writing systems object.
-*/
-QSupportedWritingSystems &QSupportedWritingSystems::operator=(const QSupportedWritingSystems &other)
-{
-    if (d != other.d) {
-        other.d->ref.ref();
-        if (!d->ref.deref())
-            delete d;
-        d = other.d;
-    }
-    return *this;
-}
-
-/*!
-    Destroys the supported writing systems object.
-*/
-QSupportedWritingSystems::~QSupportedWritingSystems()
-{
-    if (!d->ref.deref())
-        delete d;
-}
-
-/*!
-    \internal
-*/
-void QSupportedWritingSystems::detach()
-{
-    if (d->ref.load() != 1) {
-        QWritingSystemsPrivate *newd = new QWritingSystemsPrivate(d);
-        if (!d->ref.deref())
-            delete d;
-        d = newd;
-    }
-}
-
-/*!
-    Sets or clears support for the specified \a writingSystem based on the
-    value given by \a support.
-*/
-void QSupportedWritingSystems::setSupported(QFontDatabase::WritingSystem writingSystem, bool support)
-{
-    detach();
-    d->vector[writingSystem] = support;
-}
-
-/*!
-    Returns true if the writing system specified by \a writingSystem is
-    supported; otherwise returns false.
-*/
-bool QSupportedWritingSystems::supported(QFontDatabase::WritingSystem writingSystem) const
-{
-    return d->vector.at(writingSystem);
-}
-
-/*!
-    \class QSupportedWritingSystems
-    \brief The QSupportedWritingSystems class is used when registering fonts with the internal Qt
-    fontdatabase
-    \ingroup painting
-    \inmodule QtGui
-
-    Its to provide an easy to use interface for indicating what writing systems a specific font
-    supports.
-
-*/
-
-/*!
-    \internal
- */
-QPlatformFontDatabase::~QPlatformFontDatabase()
-{
-}
-
-/*!
-  This function is called once at startup by Qt's internal font database.
-  Reimplement this function in a subclass for a convenient place to initialize
-  the internal font database.
-
-  The default implementation looks in the fontDir() location and registers all
-  QPF2 fonts.
-*/
-void QPlatformFontDatabase::populateFontDatabase()
-{
-    QString fontpath = fontDir();
-    if(!QFile::exists(fontpath)) {
-        qWarning("QFontDatabase: Cannot find font directory '%s' - is Qt installed correctly?",
-                 qPrintable(QDir::toNativeSeparators(fontpath)));
-        return;
-    }
-
-    QDir dir(fontpath);
-    dir.setNameFilters(QStringList() << QLatin1String("*.qpf2"));
-    dir.refresh();
-    for (int i = 0; i < int(dir.count()); ++i) {
-        const QByteArray fileName = QFile::encodeName(dir.absoluteFilePath(dir[i]));
-        QFile file(QString::fromLocal8Bit(fileName));
-        if (file.open(QFile::ReadOnly)) {
-            const QByteArray fileData = file.readAll();
-            QByteArray *fileDataPtr = new QByteArray(fileData);
-            registerQPF2Font(fileData, fileDataPtr);
-        }
-    }
-}
-
-/*!
-    Returns a multi font engine in the specified \a script to encapsulate \a fontEngine with the
-    option to fall back to to the fonts given by \a fallbacks if \a fontEngine does not support
-    a certain character.
-*/
-QFontEngineMulti *QPlatformFontDatabase::fontEngineMulti(QFontEngine *fontEngine,
-                                                         QUnicodeTables::Script script)
-{
-    return new QFontEngineMultiQPA(fontEngine, script);
-}
-
-/*!
-    Returns the font engine that can be used to render the font described by
-    the font definition, \a fontDef, in the specified \a script.
-*/
-QFontEngine *QPlatformFontDatabase::fontEngine(const QFontDef &fontDef, QUnicodeTables::Script script, void *handle)
-{
-    Q_UNUSED(script);
-    Q_UNUSED(handle);
-    QByteArray *fileDataPtr = static_cast<QByteArray *>(handle);
-    QFontEngineQPA *engine = new QFontEngineQPA(fontDef,*fileDataPtr);
-    //qDebug() << fontDef.pixelSize << fontDef.weight << fontDef.style << fontDef.stretch << fontDef.styleHint << fontDef.styleStrategy << fontDef.family << script;
-    return engine;
-}
-
-QFontEngine *QPlatformFontDatabase::fontEngine(const QByteArray &fontData, qreal pixelSize,
-                                               QFont::HintingPreference hintingPreference)
-{
-    Q_UNUSED(fontData);
-    Q_UNUSED(pixelSize);
-    Q_UNUSED(hintingPreference);
-    qWarning("This plugin does not support font engines created directly from font data");
-    return 0;
-}
-
-/*!
-    Returns a list of alternative fonts for the specified \a family and
-    \a style and \a script using the \a styleHint given.
-*/
-QStringList QPlatformFontDatabase::fallbacksForFamily(const QString family, const QFont::Style &style, const QFont::StyleHint &styleHint, const QUnicodeTables::Script &script) const
-{
-    Q_UNUSED(family);
-    Q_UNUSED(style);
-    Q_UNUSED(styleHint);
-    Q_UNUSED(script);
-    return QStringList();
-}
-
-/*!
-    Adds an application font described by the font contained supplied \a fontData
-    or using the font contained in the file referenced by \a fileName. Returns
-    a list of family names, or an empty list if the font could not be added.
-
-    \note The default implementation of this function does not add an application
-    font. Subclasses should reimplement this function to perform the necessary
-    loading and registration of fonts.
-*/
-QStringList QPlatformFontDatabase::addApplicationFont(const QByteArray &fontData, const QString &fileName)
-{
-    Q_UNUSED(fontData);
-    Q_UNUSED(fileName);
-
-    qWarning("This plugin does not support application fonts");
-    return QStringList();
-}
-
-/*!
-    Releases the specified font \a handle.
-*/
-void QPlatformFontDatabase::releaseHandle(void *handle)
-{
-    QByteArray *fileDataPtr = static_cast<QByteArray *>(handle);
-    delete fileDataPtr;
-}
-
-/*!
-    Returns the directory containing the fonts used by the database.
-*/
-QString QPlatformFontDatabase::fontDir() const
-{
-    QString fontpath = QString::fromLocal8Bit(qgetenv("QT_QPA_FONTDIR"));
-    if (fontpath.isEmpty()) {
-#ifndef QT_NO_SETTINGS
-        fontpath = QLibraryInfo::location(QLibraryInfo::LibrariesPath);
-        fontpath += QLatin1String("/fonts");
-#endif
-    }
-
-    return fontpath;
-}
-
-/*!
-    Returns the default system font.
-
-    \sa QGuiApplication::font()
-    \since 5.0
-*/
-
-QFont QPlatformFontDatabase::defaultFont() const
-{
-    return QFont(QLatin1String("Helvetica"));
-}
-
-/*!
-    Resolve alias to actual font family names.
-
-    \since 5.0
- */
-
-QString QPlatformFontDatabase::resolveFontFamilyAlias(const QString &family) const
-{
-    return family;
-}
-
-/*!
-    Return true if all fonts are considered scalable when using this font database.
-    Defaults to false.
-
-    \since 5.0
- */
-
-bool QPlatformFontDatabase::fontsAlwaysScalable() const
-{
-    return false;
-}
-
-/*!
-    Return list of standard font sizes when using this font database.
-
-    \since 5.0
- */
-
- QList<int> QPlatformFontDatabase::standardSizes() const
-{
-    QList<int> ret;
-    static const unsigned short standard[] =
-        { 6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72, 0 };
-    ret.reserve(int(sizeof(standard) / sizeof(standard[0])));
-    const unsigned short *sizes = standard;
-    while (*sizes) ret << *sizes++;
-    return ret;
-}
-
-/*!
-    \class QPlatformFontDatabase
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-    \ingroup painting
-
-    \brief The QPlatformFontDatabase class makes it possible to customize how fonts
-    are discovered and how they are rendered
-
-    QPlatformFontDatabase is the superclass which is intended to let platform implementations use
-    native font handling.
-
-    Qt has its internal font database which it uses to discover available fonts on the
-    user's system. To be able to populate this database subclass this class, and
-    reimplement populateFontDatabase().
-
-    Use the function registerFont() to populate the internal font database.
-
-    Sometimes a specified font does not have the required glyphs; in such a case, the
-    fallbackForFamily() function is called automatically to find alternative font
-    families that can supply alternatives to the missing glyphs.
-
-    \sa QSupportedWritingSystems
-*/
-QT_END_NAMESPACE
diff --git a/src/gui/text/text.pri b/src/gui/text/text.pri
index 4cf58fa..fb46642 100644
--- a/src/gui/text/text.pri
+++ b/src/gui/text/text.pri
@@ -86,7 +86,7 @@ contains(QT_CONFIG, directwrite) {
 SOURCES += \
       text/qfont_qpa.cpp \
       text/qfontengine_qpa.cpp \
-      text/qplatformfontdatabase_qpa.cpp \
+      text/qplatformfontdatabase.cpp \
       text/qrawfont_qpa.cpp
 
 HEADERS += \
diff --git a/src/platformsupport/eventdispatchers/eventdispatchers.pri b/src/platformsupport/eventdispatchers/eventdispatchers.pri
index 9e6ff28..6e16a46 100644
--- a/src/platformsupport/eventdispatchers/eventdispatchers.pri
+++ b/src/platformsupport/eventdispatchers/eventdispatchers.pri
@@ -1,6 +1,6 @@
 unix {
 SOURCES +=\
-    $$PWD/qunixeventdispatcher_qpa.cpp\
+    $$PWD/qunixeventdispatcher.cpp\
     $$PWD/qgenericunixeventdispatcher.cpp\
 
 HEADERS +=\
diff --git a/src/platformsupport/eventdispatchers/qunixeventdispatcher.cpp b/src/platformsupport/eventdispatchers/qunixeventdispatcher.cpp
new file mode 100644
index 0000000..985b62e
--- /dev/null
+++ b/src/platformsupport/eventdispatchers/qunixeventdispatcher.cpp
@@ -0,0 +1,91 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformdefs.h"
+#include "qcoreapplication.h"
+#include "qunixeventdispatcher_qpa_p.h"
+#include "private/qguiapplication_p.h"
+
+#include <QWindowSystemInterface>
+#include <QtCore/QElapsedTimer>
+#include <QtCore/QAtomicInt>
+#include <QtCore/QSemaphore>
+
+#include <QtCore/QDebug>
+
+#include <errno.h>
+
+QT_BEGIN_NAMESPACE
+
+QT_USE_NAMESPACE
+
+
+QUnixEventDispatcherQPA::QUnixEventDispatcherQPA(QObject *parent)
+    : QEventDispatcherUNIX(parent)
+{ }
+
+QUnixEventDispatcherQPA::~QUnixEventDispatcherQPA()
+{ }
+
+bool QUnixEventDispatcherQPA::processEvents(QEventLoop::ProcessEventsFlags flags)
+{
+    bool didSendEvents = QWindowSystemInterface::sendWindowSystemEvents(this, flags);
+
+    if (QEventDispatcherUNIX::processEvents(flags)) {
+        return true;
+    }
+
+    return didSendEvents;
+}
+
+bool QUnixEventDispatcherQPA::hasPendingEvents()
+{
+    extern uint qGlobalPostedEventsCount(); // from qapplication.cpp
+    return qGlobalPostedEventsCount() || QWindowSystemInterface::windowSystemEventsQueued();
+}
+
+void QUnixEventDispatcherQPA::flush()
+{
+    if(qApp)
+        qApp->sendPostedEvents();
+}
+
+QT_END_NAMESPACE
diff --git a/src/platformsupport/eventdispatchers/qunixeventdispatcher_qpa.cpp b/src/platformsupport/eventdispatchers/qunixeventdispatcher_qpa.cpp
deleted file mode 100644
index 985b62e..0000000
--- a/src/platformsupport/eventdispatchers/qunixeventdispatcher_qpa.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformdefs.h"
-#include "qcoreapplication.h"
-#include "qunixeventdispatcher_qpa_p.h"
-#include "private/qguiapplication_p.h"
-
-#include <QWindowSystemInterface>
-#include <QtCore/QElapsedTimer>
-#include <QtCore/QAtomicInt>
-#include <QtCore/QSemaphore>
-
-#include <QtCore/QDebug>
-
-#include <errno.h>
-
-QT_BEGIN_NAMESPACE
-
-QT_USE_NAMESPACE
-
-
-QUnixEventDispatcherQPA::QUnixEventDispatcherQPA(QObject *parent)
-    : QEventDispatcherUNIX(parent)
-{ }
-
-QUnixEventDispatcherQPA::~QUnixEventDispatcherQPA()
-{ }
-
-bool QUnixEventDispatcherQPA::processEvents(QEventLoop::ProcessEventsFlags flags)
-{
-    bool didSendEvents = QWindowSystemInterface::sendWindowSystemEvents(this, flags);
-
-    if (QEventDispatcherUNIX::processEvents(flags)) {
-        return true;
-    }
-
-    return didSendEvents;
-}
-
-bool QUnixEventDispatcherQPA::hasPendingEvents()
-{
-    extern uint qGlobalPostedEventsCount(); // from qapplication.cpp
-    return qGlobalPostedEventsCount() || QWindowSystemInterface::windowSystemEventsQueued();
-}
-
-void QUnixEventDispatcherQPA::flush()
-{
-    if(qApp)
-        qApp->sendPostedEvents();
-}
-
-QT_END_NAMESPACE
diff --git a/src/printsupport/kernel/kernel.pri b/src/printsupport/kernel/kernel.pri
index d3c266c..5f14c28 100644
--- a/src/printsupport/kernel/kernel.pri
+++ b/src/printsupport/kernel/kernel.pri
@@ -17,7 +17,7 @@ SOURCES += \
         $$PWD/qprinter.cpp \
         $$PWD/qprinterinfo.cpp \
         $$PWD/qplatformprintplugin.cpp \
-        $$PWD/qplatformprintersupport_qpa.cpp
+        $$PWD/qplatformprintersupport.cpp
 
 win32 {
         HEADERS += \
diff --git a/src/printsupport/kernel/qplatformprintersupport.cpp b/src/printsupport/kernel/qplatformprintersupport.cpp
new file mode 100644
index 0000000..b74a84f
--- /dev/null
+++ b/src/printsupport/kernel/qplatformprintersupport.cpp
@@ -0,0 +1,163 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformprintersupport.h"
+
+#include <QtPrintSupport/qprinterinfo.h>
+
+#include <private/qprinterinfo_p.h>
+
+#ifndef QT_NO_PRINTER
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformPrinterSupport
+    \since 5.0
+    \internal
+    \preliminary
+    \ingroup qpa
+
+    \brief The QPlatformPrinterSupport class provides an abstraction for print support.
+ */
+
+QPlatformPrinterSupport::QPlatformPrinterSupport()
+{
+}
+
+QPlatformPrinterSupport::~QPlatformPrinterSupport()
+{
+}
+
+QPrintEngine *QPlatformPrinterSupport::createNativePrintEngine(QPrinter::PrinterMode)
+{
+    return 0;
+}
+
+QPaintEngine *QPlatformPrinterSupport::createPaintEngine(QPrintEngine *, QPrinter::PrinterMode)
+{
+    return 0;
+}
+
+QList<QPrinter::PaperSize> QPlatformPrinterSupport::supportedPaperSizes(const QPrinterInfo &) const
+{
+    return QList<QPrinter::PaperSize>();
+}
+
+QList<QPrinterInfo> QPlatformPrinterSupport::availablePrinters()
+{
+    return m_printers;
+}
+
+QPrinterInfo QPlatformPrinterSupport::defaultPrinter()
+{
+    const QList<QPrinterInfo> printers = availablePrinters();
+    foreach (const QPrinterInfo &printerInfo, printers) {
+        if (printerInfo.isDefault())
+            return printerInfo;
+    }
+    return QPrinterInfo();
+}
+
+QPrinterInfo QPlatformPrinterSupport::printerInfo(const QString &printerName)
+{
+    const QList<QPrinterInfo> printers = availablePrinters();
+    foreach (const QPrinterInfo &printerInfo, printers) {
+        if (printerInfo.printerName() == printerName)
+            return printerInfo;
+    }
+    return QPrinterInfo();
+}
+
+QString QPlatformPrinterSupport::printerOption(const QPrinterInfo &printer, const QString &key) const
+{
+    Q_UNUSED(printer)
+    Q_UNUSED(key)
+    return QString();
+}
+
+PrinterOptions QPlatformPrinterSupport::printerOptions(const QPrinterInfo &printer) const
+{
+    Q_UNUSED(printer)
+    return PrinterOptions();
+}
+
+int QPlatformPrinterSupport::printerIndex(const QPrinterInfo &printer)
+{
+    return printer.d_func()->index;
+}
+
+QPrinterInfo QPlatformPrinterSupport::createPrinterInfo(const QString &name, const QString &description,
+                                                        const QString &location, const QString &makeAndModel,
+                                                        bool isDefault, int index)
+{
+    QPrinterInfo printer(name);
+    printer.d_func()->description = description;
+    printer.d_func()->location = location;
+    printer.d_func()->makeAndModel = makeAndModel;
+    printer.d_func()->isDefault = isDefault;
+    printer.d_func()->index = index;
+    return printer;
+}
+
+/*
+    Converts QSizeF in millimeters to a predefined PaperSize (returns Custom if
+    the size isn't a standard size)
+*/
+extern QPrinter::PaperSize qSizeFTopaperSize(const QSizeF &);
+QPrinter::PaperSize QPlatformPrinterSupport::convertQSizeFToPaperSize(const QSizeF &sizef)
+{
+    return qSizeFTopaperSize(sizef);
+}
+
+/*
+    Converts a predefined PaperSize to a QSizeF in millimeters (returns
+    QSizeF(0.0, 0.0) if PaperSize is Custom)
+*/
+extern QSizeF qt_paperSizeToQSizeF(QPrinter::PaperSize size);
+QSizeF QPlatformPrinterSupport::convertPaperSizeToQSizeF(QPrinter::PaperSize paperSize)
+{
+    return qt_paperSizeToQSizeF(paperSize);
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_PRINTER
diff --git a/src/printsupport/kernel/qplatformprintersupport_qpa.cpp b/src/printsupport/kernel/qplatformprintersupport_qpa.cpp
deleted file mode 100644
index b74a84f..0000000
--- a/src/printsupport/kernel/qplatformprintersupport_qpa.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplatformprintersupport.h"
-
-#include <QtPrintSupport/qprinterinfo.h>
-
-#include <private/qprinterinfo_p.h>
-
-#ifndef QT_NO_PRINTER
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QPlatformPrinterSupport
-    \since 5.0
-    \internal
-    \preliminary
-    \ingroup qpa
-
-    \brief The QPlatformPrinterSupport class provides an abstraction for print support.
- */
-
-QPlatformPrinterSupport::QPlatformPrinterSupport()
-{
-}
-
-QPlatformPrinterSupport::~QPlatformPrinterSupport()
-{
-}
-
-QPrintEngine *QPlatformPrinterSupport::createNativePrintEngine(QPrinter::PrinterMode)
-{
-    return 0;
-}
-
-QPaintEngine *QPlatformPrinterSupport::createPaintEngine(QPrintEngine *, QPrinter::PrinterMode)
-{
-    return 0;
-}
-
-QList<QPrinter::PaperSize> QPlatformPrinterSupport::supportedPaperSizes(const QPrinterInfo &) const
-{
-    return QList<QPrinter::PaperSize>();
-}
-
-QList<QPrinterInfo> QPlatformPrinterSupport::availablePrinters()
-{
-    return m_printers;
-}
-
-QPrinterInfo QPlatformPrinterSupport::defaultPrinter()
-{
-    const QList<QPrinterInfo> printers = availablePrinters();
-    foreach (const QPrinterInfo &printerInfo, printers) {
-        if (printerInfo.isDefault())
-            return printerInfo;
-    }
-    return QPrinterInfo();
-}
-
-QPrinterInfo QPlatformPrinterSupport::printerInfo(const QString &printerName)
-{
-    const QList<QPrinterInfo> printers = availablePrinters();
-    foreach (const QPrinterInfo &printerInfo, printers) {
-        if (printerInfo.printerName() == printerName)
-            return printerInfo;
-    }
-    return QPrinterInfo();
-}
-
-QString QPlatformPrinterSupport::printerOption(const QPrinterInfo &printer, const QString &key) const
-{
-    Q_UNUSED(printer)
-    Q_UNUSED(key)
-    return QString();
-}
-
-PrinterOptions QPlatformPrinterSupport::printerOptions(const QPrinterInfo &printer) const
-{
-    Q_UNUSED(printer)
-    return PrinterOptions();
-}
-
-int QPlatformPrinterSupport::printerIndex(const QPrinterInfo &printer)
-{
-    return printer.d_func()->index;
-}
-
-QPrinterInfo QPlatformPrinterSupport::createPrinterInfo(const QString &name, const QString &description,
-                                                        const QString &location, const QString &makeAndModel,
-                                                        bool isDefault, int index)
-{
-    QPrinterInfo printer(name);
-    printer.d_func()->description = description;
-    printer.d_func()->location = location;
-    printer.d_func()->makeAndModel = makeAndModel;
-    printer.d_func()->isDefault = isDefault;
-    printer.d_func()->index = index;
-    return printer;
-}
-
-/*
-    Converts QSizeF in millimeters to a predefined PaperSize (returns Custom if
-    the size isn't a standard size)
-*/
-extern QPrinter::PaperSize qSizeFTopaperSize(const QSizeF &);
-QPrinter::PaperSize QPlatformPrinterSupport::convertQSizeFToPaperSize(const QSizeF &sizef)
-{
-    return qSizeFTopaperSize(sizef);
-}
-
-/*
-    Converts a predefined PaperSize to a QSizeF in millimeters (returns
-    QSizeF(0.0, 0.0) if PaperSize is Custom)
-*/
-extern QSizeF qt_paperSizeToQSizeF(QPrinter::PaperSize size);
-QSizeF QPlatformPrinterSupport::convertPaperSizeToQSizeF(QPrinter::PaperSize paperSize)
-{
-    return qt_paperSizeToQSizeF(paperSize);
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_PRINTER
diff --git a/src/widgets/kernel/kernel.pri b/src/widgets/kernel/kernel.pri
index ac363c5..b2f05e3 100644
--- a/src/widgets/kernel/kernel.pri
+++ b/src/widgets/kernel/kernel.pri
@@ -65,7 +65,7 @@ SOURCES += \
         kernel/qapplication_qpa.cpp \
         kernel/qdesktopwidget_qpa.cpp \
         kernel/qwidget_qpa.cpp \
-        kernel/qwidgetwindow_qpa.cpp
+        kernel/qwidgetwindow.cpp
 
 
 # TODO
diff --git a/src/widgets/kernel/qwidgetwindow.cpp b/src/widgets/kernel/qwidgetwindow.cpp
new file mode 100644
index 0000000..1b076d1
--- /dev/null
+++ b/src/widgets/kernel/qwidgetwindow.cpp
@@ -0,0 +1,592 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qwidgetwindow_qpa_p.h"
+
+#include "private/qwidget_p.h"
+#include "private/qapplication_p.h"
+#ifndef QT_NO_ACCESSIBILITY
+#include <QtGui/qaccessible.h>
+#endif
+#include <private/qwidgetbackingstore_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QWidget *qt_button_down = 0; // widget got last button-down
+static QWidget *qt_tablet_target = 0;
+
+// popup control
+QWidget *qt_popup_down = 0; // popup that contains the pressed widget
+extern int openPopupCount;
+bool qt_replay_popup_mouse_event = false;
+extern bool qt_try_modal(QWidget *widget, QEvent::Type type);
+
+QWidgetWindow::QWidgetWindow(QWidget *widget)
+    : m_widget(widget)
+{
+    updateObjectName();
+    connect(m_widget, &QObject::objectNameChanged, this, &QWidgetWindow::updateObjectName);
+}
+
+#ifndef QT_NO_ACCESSIBILITY
+QAccessibleInterface *QWidgetWindow::accessibleRoot() const
+{
+    if (m_widget)
+        return QAccessible::queryAccessibleInterface(m_widget);
+    return 0;
+}
+#endif
+
+QObject *QWidgetWindow::focusObject() const
+{
+    QWidget *widget = m_widget->focusWidget();
+
+    if (!widget)
+        widget = m_widget;
+
+    return widget;
+}
+
+bool QWidgetWindow::event(QEvent *event)
+{
+    if (m_widget->testAttribute(Qt::WA_DontShowOnScreen)) {
+        // \a event is uninteresting for QWidgetWindow, the event was probably
+        // generated before WA_DontShowOnScreen was set
+        return m_widget->event(event);
+    }
+
+    switch (event->type()) {
+    case QEvent::Close:
+        handleCloseEvent(static_cast<QCloseEvent *>(event));
+        return true;
+
+    case QEvent::Enter:
+    case QEvent::Leave:
+        handleEnterLeaveEvent(event);
+        return true;
+
+    // these should not be sent to QWidget, the corresponding events
+    // are sent by QApplicationPrivate::notifyActiveWindowChange()
+    case QEvent::FocusIn:
+    case QEvent::FocusOut: {
+#ifndef QT_NO_ACCESSIBILITY
+        QAccessible::State state;
+        state.active = true;
+        QAccessibleStateChangeEvent ev(widget(), state);
+        QAccessible::updateAccessibility(&ev);
+#endif
+        return false; }
+
+    case QEvent::FocusAboutToChange:
+        if (QApplicationPrivate::focus_widget) {
+            if (QApplicationPrivate::focus_widget->testAttribute(Qt::WA_InputMethodEnabled))
+                qApp->inputMethod()->commit();
+
+            QGuiApplication::sendSpontaneousEvent(QApplicationPrivate::focus_widget, event);
+        }
+        return true;
+
+    case QEvent::KeyPress:
+    case QEvent::KeyRelease:
+    case QEvent::ShortcutOverride:
+        handleKeyEvent(static_cast<QKeyEvent *>(event));
+        return true;
+
+    case QEvent::MouseMove:
+    case QEvent::MouseButtonPress:
+    case QEvent::MouseButtonRelease:
+    case QEvent::MouseButtonDblClick:
+        handleMouseEvent(static_cast<QMouseEvent *>(event));
+        return true;
+
+    case QEvent::NonClientAreaMouseMove:
+    case QEvent::NonClientAreaMouseButtonPress:
+    case QEvent::NonClientAreaMouseButtonRelease:
+    case QEvent::NonClientAreaMouseButtonDblClick:
+        handleNonClientAreaMouseEvent(static_cast<QMouseEvent *>(event));
+        return true;
+
+    case QEvent::TouchBegin:
+    case QEvent::TouchUpdate:
+    case QEvent::TouchEnd:
+    case QEvent::TouchCancel:
+        handleTouchEvent(static_cast<QTouchEvent *>(event));
+        return true;
+
+    case QEvent::Move:
+        handleMoveEvent(static_cast<QMoveEvent *>(event));
+        return true;
+
+    case QEvent::Resize:
+        handleResizeEvent(static_cast<QResizeEvent *>(event));
+        return true;
+
+    case QEvent::Wheel:
+        handleWheelEvent(static_cast<QWheelEvent *>(event));
+        return true;
+
+#ifndef QT_NO_DRAGANDDROP
+    case QEvent::DragEnter:
+    case QEvent::DragLeave:
+    case QEvent::DragMove:
+    case QEvent::Drop:
+        handleDragEvent(event);
+        return true;
+#endif
+
+    case QEvent::Expose:
+        handleExposeEvent(static_cast<QExposeEvent *>(event));
+        return true;
+
+    case QEvent::WindowStateChange:
+        handleWindowStateChangedEvent(static_cast<QWindowStateChangeEvent *>(event));
+        return true;
+
+    case QEvent::ThemeChange: {
+        QEvent widgetEvent(QEvent::ThemeChange);
+        QGuiApplication::sendSpontaneousEvent(m_widget, &widgetEvent);
+    }
+        return true;
+
+#ifndef QT_NO_TABLETEVENT
+    case QEvent::TabletPress:
+    case QEvent::TabletMove:
+    case QEvent::TabletRelease:
+        handleTabletEvent(static_cast<QTabletEvent *>(event));
+        return true;
+#endif
+
+    default:
+        break;
+    }
+
+    return m_widget->event(event) || QWindow::event(event);
+}
+
+QPointer<QWidget> qt_last_mouse_receiver = 0;
+
+void QWidgetWindow::handleEnterLeaveEvent(QEvent *event)
+{
+    if (event->type() == QEvent::Leave) {
+        QWidget *leave = qt_last_mouse_receiver ? qt_last_mouse_receiver.data() : m_widget;
+        QApplicationPrivate::dispatchEnterLeave(0, leave);
+        qt_last_mouse_receiver = 0;
+    } else {
+        QApplicationPrivate::dispatchEnterLeave(m_widget, 0);
+        qt_last_mouse_receiver = m_widget;
+    }
+}
+
+void QWidgetWindow::handleNonClientAreaMouseEvent(QMouseEvent *e)
+{
+    QApplication::sendSpontaneousEvent(m_widget, e);
+}
+
+void QWidgetWindow::handleMouseEvent(QMouseEvent *event)
+{
+    if (qApp->d_func()->inPopupMode()) {
+        QWidget *activePopupWidget = qApp->activePopupWidget();
+        QWidget *popup = activePopupWidget;
+        QPoint mapped = event->pos();
+        if (popup != m_widget)
+            mapped = popup->mapFromGlobal(event->globalPos());
+        bool releaseAfter = false;
+        QWidget *popupChild  = popup->childAt(mapped);
+
+        if (popup != qt_popup_down) {
+            qt_button_down = 0;
+            qt_popup_down = 0;
+        }
+
+        switch (event->type()) {
+        case QEvent::MouseButtonPress:
+        case QEvent::MouseButtonDblClick:
+            qt_button_down = popupChild;
+            qt_popup_down = popup;
+            break;
+        case QEvent::MouseButtonRelease:
+            releaseAfter = true;
+            break;
+        default:
+            break; // nothing for mouse move
+        }
+
+        int oldOpenPopupCount = openPopupCount;
+
+        if (popup->isEnabled()) {
+            // deliver event
+            qt_replay_popup_mouse_event = false;
+            QWidget *receiver = popup;
+            QPoint widgetPos = mapped;
+            if (qt_button_down)
+                receiver = qt_button_down;
+            else if (popupChild)
+                receiver = popupChild;
+            if (receiver != popup)
+                widgetPos = receiver->mapFromGlobal(event->globalPos());
+            QWidget *alien = m_widget->childAt(m_widget->mapFromGlobal(event->globalPos()));
+            QMouseEvent e(event->type(), widgetPos, event->windowPos(), event->screenPos(), event->button(), event->buttons(), event->modifiers());
+            e.setTimestamp(event->timestamp());
+            QApplicationPrivate::sendMouseEvent(receiver, &e, alien, m_widget, &qt_button_down, qt_last_mouse_receiver);
+        } else {
+            // close disabled popups when a mouse button is pressed or released
+            switch (event->type()) {
+            case QEvent::MouseButtonPress:
+            case QEvent::MouseButtonDblClick:
+            case QEvent::MouseButtonRelease:
+                popup->close();
+                break;
+            default:
+                break;
+            }
+        }
+
+        if (qApp->activePopupWidget() != activePopupWidget
+            && qt_replay_popup_mouse_event) {
+            if (m_widget->windowType() != Qt::Popup)
+                qt_button_down = 0;
+            qt_replay_popup_mouse_event = false;
+#ifndef QT_NO_CONTEXTMENU
+        } else if (event->type() == QEvent::MouseButtonPress
+                   && event->button() == Qt::RightButton
+                   && (openPopupCount == oldOpenPopupCount)) {
+            QWidget *popupEvent = popup;
+            if (qt_button_down)
+                popupEvent = qt_button_down;
+            else if(popupChild)
+                popupEvent = popupChild;
+            QContextMenuEvent e(QContextMenuEvent::Mouse, mapped, event->globalPos(), event->modifiers());
+            QApplication::sendSpontaneousEvent(popupEvent, &e);
+#endif
+        }
+
+        if (releaseAfter) {
+            qt_button_down = 0;
+            qt_popup_down = 0;
+        }
+        return;
+    }
+
+    // modal event handling
+    if (QApplicationPrivate::instance()->modalState() && !qt_try_modal(m_widget, event->type()))
+        return;
+
+    // which child should have it?
+    QWidget *widget = m_widget->childAt(event->pos());
+    QPoint mapped = event->pos();
+
+    if (!widget)
+        widget = m_widget;
+
+    if (event->type() == QEvent::MouseButtonPress && !qt_button_down)
+        qt_button_down = widget;
+
+    QWidget *receiver = QApplicationPrivate::pickMouseReceiver(m_widget, event->windowPos().toPoint(), &mapped, event->type(), event->buttons(),
+                                                               qt_button_down, widget);
+
+    if (!receiver) {
+        if (event->type() == QEvent::MouseButtonRelease)
+            QApplicationPrivate::mouse_buttons &= ~event->button();
+        return;
+    }
+
+    QMouseEvent translated(event->type(), mapped, event->windowPos(), event->screenPos(), event->button(), event->buttons(), event->modifiers());
+    translated.setTimestamp(event->timestamp());
+    QApplicationPrivate::sendMouseEvent(receiver, &translated, widget, m_widget, &qt_button_down,
+                                        qt_last_mouse_receiver);
+
+#ifndef QT_NO_CONTEXTMENU
+    if (event->type() == QEvent::MouseButtonPress && event->button() == Qt::RightButton) {
+        QContextMenuEvent e(QContextMenuEvent::Mouse, mapped, event->globalPos(), event->modifiers());
+        QGuiApplication::sendSpontaneousEvent(receiver, &e);
+    }
+#endif
+}
+
+void QWidgetWindow::handleTouchEvent(QTouchEvent *event)
+{
+    if (event->type() == QEvent::TouchCancel)
+        QApplicationPrivate::translateTouchCancel(event->device(), event->timestamp());
+    else
+        QApplicationPrivate::translateRawTouchEvent(m_widget, event->device(), event->touchPoints(), event->timestamp());
+}
+
+void QWidgetWindow::handleKeyEvent(QKeyEvent *event)
+{
+    if (QApplicationPrivate::instance()->modalState() && !qt_try_modal(m_widget, event->type()))
+        return;
+
+    QObject *receiver = 0;
+    if (QApplicationPrivate::inPopupMode()) {
+        QWidget *popup = QApplication::activePopupWidget();
+        QWidget *popupFocusWidget = popup->focusWidget();
+        receiver = popupFocusWidget ? popupFocusWidget : popup;
+    }
+    if (!receiver)
+        receiver = focusObject();
+    QGuiApplication::sendSpontaneousEvent(receiver, event);
+}
+
+void QWidgetWindow::updateGeometry()
+{
+    if (m_widget->testAttribute(Qt::WA_OutsideWSRange))
+        return;
+
+    const QMargins margins = frameMargins();
+
+    m_widget->data->crect = geometry();
+    QTLWExtra *te = m_widget->d_func()->topData();
+    te->posIncludesFrame= false;
+    te->frameStrut.setCoords(margins.left(), margins.top(), margins.right(), margins.bottom());
+    m_widget->data->fstrut_dirty = false;
+}
+
+void QWidgetWindow::handleMoveEvent(QMoveEvent *event)
+{
+    updateGeometry();
+    QGuiApplication::sendSpontaneousEvent(m_widget, event);
+}
+
+void QWidgetWindow::handleResizeEvent(QResizeEvent *event)
+{
+    QSize oldSize = m_widget->data->crect.size();
+
+    updateGeometry();
+    QGuiApplication::sendSpontaneousEvent(m_widget, event);
+
+    if (m_widget->d_func()->paintOnScreen()) {
+        QRegion updateRegion(geometry());
+        if (m_widget->testAttribute(Qt::WA_StaticContents))
+            updateRegion -= QRect(0, 0, oldSize.width(), oldSize.height());
+        m_widget->d_func()->syncBackingStore(updateRegion);
+    } else {
+        m_widget->d_func()->syncBackingStore();
+    }
+}
+
+void QWidgetWindow::handleCloseEvent(QCloseEvent *)
+{
+    m_widget->d_func()->close_helper(QWidgetPrivate::CloseWithSpontaneousEvent);
+}
+
+void QWidgetWindow::handleWheelEvent(QWheelEvent *event)
+{
+    if (QApplicationPrivate::instance()->modalState() && !qt_try_modal(m_widget, event->type()))
+        return;
+
+    // which child should have it?
+    QWidget *widget = m_widget->childAt(event->pos());
+
+    if (!widget)
+        widget = m_widget;
+
+    QPoint mapped = widget->mapFrom(m_widget, event->pos());
+
+    QWheelEvent translated(mapped, event->globalPos(), event->pixelDelta(), event->angleDelta(), event->delta(), event->orientation(), event->buttons(), event->modifiers());
+    QGuiApplication::sendSpontaneousEvent(widget, &translated);
+}
+
+#ifndef QT_NO_DRAGANDDROP
+
+void QWidgetWindow::handleDragEvent(QEvent *event)
+{
+    switch (event->type()) {
+    case QEvent::DragEnter:
+        Q_ASSERT(!m_dragTarget);
+        // fall through
+    case QEvent::DragMove:
+    {
+        QDragMoveEvent *de = static_cast<QDragMoveEvent *>(event);
+        QWidget *widget = m_widget->childAt(de->pos());
+        if (!widget)
+            widget = m_widget;
+
+        if (widget != m_dragTarget.data()) {
+            if (m_dragTarget.data()) {
+                QDragLeaveEvent le;
+                QGuiApplication::sendSpontaneousEvent(m_dragTarget.data(), &le);
+            }
+            m_dragTarget = widget;
+            QPoint mapped = widget->mapFrom(m_widget, de->pos());
+            QDragEnterEvent translated(mapped, de->possibleActions(), de->mimeData(), de->mouseButtons(), de->keyboardModifiers());
+            QGuiApplication::sendSpontaneousEvent(widget, &translated);
+            if (translated.isAccepted())
+                event->accept();
+            de->setDropAction(translated.dropAction());
+        } else {
+            Q_ASSERT(event->type() == QEvent::DragMove);
+            QPoint mapped = widget->mapFrom(m_widget, de->pos());
+            QDragMoveEvent translated(mapped, de->possibleActions(), de->mimeData(), de->mouseButtons(), de->keyboardModifiers());
+            translated.setDropAction(de->dropAction());
+            QGuiApplication::sendSpontaneousEvent(widget, &translated);
+            if (translated.isAccepted())
+                event->accept();
+            de->setDropAction(translated.dropAction());
+        }
+        break;
+    }
+    case QEvent::DragLeave:
+        if (m_dragTarget)
+            QGuiApplication::sendSpontaneousEvent(m_dragTarget.data(), event);
+        m_dragTarget = (QWidget *)0;
+        break;
+    case QEvent::Drop:
+    {
+        QDropEvent *de = static_cast<QDropEvent *>(event);
+        QPoint mapped = m_dragTarget.data()->mapFrom(m_widget, de->pos());
+        QDropEvent translated(mapped, de->possibleActions(), de->mimeData(), de->mouseButtons(), de->keyboardModifiers());
+        QGuiApplication::sendSpontaneousEvent(m_dragTarget.data(), &translated);
+        if (translated.isAccepted())
+            event->accept();
+        de->setDropAction(translated.dropAction());
+        m_dragTarget = (QWidget *)0;
+    }
+    default:
+        break;
+    }
+}
+
+#endif // QT_NO_DRAGANDDROP
+
+void QWidgetWindow::handleExposeEvent(QExposeEvent *event)
+{
+    if (isExposed()) {
+        m_widget->setAttribute(Qt::WA_Mapped);
+        if (!event->region().isNull()) {
+            // Exposed native widgets need to be marked dirty to get them repainted correctly.
+            if (m_widget->internalWinId() && !m_widget->isWindow() && m_widget->updatesEnabled()) {
+                if (QWidgetBackingStore *bs = m_widget->d_func()->maybeBackingStore())
+                    bs->markDirty(event->region(), m_widget);
+            }
+            m_widget->d_func()->syncBackingStore(event->region());
+        }
+    } else {
+        m_widget->setAttribute(Qt::WA_Mapped, false);
+    }
+}
+
+Qt::WindowState effectiveState(Qt::WindowStates state);
+
+void QWidgetWindow::handleWindowStateChangedEvent(QWindowStateChangeEvent *event)
+{
+    // QWindow does currently not know 'active'.
+    Qt::WindowStates eventState = event->oldState();
+    Qt::WindowStates widgetState = m_widget->windowState();
+    if (widgetState & Qt::WindowActive)
+        eventState |= Qt::WindowActive;
+
+    // Determine the new widget state, remember maximized/full screen
+    // during minimized.
+    switch (windowState()) {
+    case Qt::WindowNoState:
+        widgetState &= ~(Qt::WindowMinimized | Qt::WindowMaximized | Qt::WindowFullScreen);
+        break;
+    case Qt::WindowMinimized:
+        widgetState |= Qt::WindowMinimized;
+        break;
+    case Qt::WindowMaximized:
+        if (effectiveState(widgetState) == Qt::WindowNoState)
+            if (QTLWExtra *tle = m_widget->d_func()->maybeTopData())
+                tle->normalGeometry = m_widget->geometry();
+        widgetState &= ~Qt::WindowFullScreen;
+        widgetState |= Qt::WindowMaximized;
+        break;
+    case Qt::WindowFullScreen:
+        if (effectiveState(widgetState) == Qt::WindowNoState)
+            if (QTLWExtra *tle = m_widget->d_func()->maybeTopData())
+                tle->normalGeometry = m_widget->geometry();
+        widgetState &= ~Qt::WindowMaximized;
+        widgetState |= Qt::WindowFullScreen;
+        break;
+    case Qt::WindowActive: // Not handled by QWindow
+        break;
+    }
+
+    // Sent event if the state changed (that is, it is not triggered by
+    // QWidget::setWindowState(), which also sends an event to the widget).
+    if (widgetState != int(m_widget->data->window_state)) {
+        m_widget->data->window_state = widgetState;
+        QWindowStateChangeEvent widgetEvent(eventState);
+        QGuiApplication::sendSpontaneousEvent(m_widget, &widgetEvent);
+    }
+}
+
+bool QWidgetWindow::nativeEvent(const QByteArray &eventType, void *message, long *result)
+{
+    return m_widget->nativeEvent(eventType, message, result);
+}
+
+#ifndef QT_NO_TABLETEVENT
+void QWidgetWindow::handleTabletEvent(QTabletEvent *event)
+{
+    if (event->type() == QEvent::TabletPress) {
+        QWidget *widget = m_widget->childAt(event->pos());
+        if (!widget)
+            widget = m_widget;
+
+        qt_tablet_target = widget;
+    }
+
+    if (qt_tablet_target) {
+        QPointF delta = event->globalPosF() - event->globalPos();
+        QPointF mapped = qt_tablet_target->mapFromGlobal(event->globalPos()) + delta;
+        QTabletEvent ev(event->type(), mapped, event->globalPosF(), event->device(), event->pointerType(),
+                        event->pressure(), event->xTilt(), event->yTilt(), event->tangentialPressure(),
+                        event->rotation(), event->z(), event->modifiers(), event->uniqueId());
+        ev.setTimestamp(event->timestamp());
+        QGuiApplication::sendSpontaneousEvent(qt_tablet_target, &ev);
+    }
+
+    if (event->type() == QEvent::TabletRelease)
+        qt_tablet_target = 0;
+}
+#endif // QT_NO_TABLETEVENT
+
+void QWidgetWindow::updateObjectName()
+{
+    QString name = m_widget->objectName();
+    if (name.isEmpty())
+        name = QString::fromUtf8(m_widget->metaObject()->className()) + QStringLiteral("Class");
+    name += QStringLiteral("Window");
+    setObjectName(name);
+}
+
+QT_END_NAMESPACE
diff --git a/src/widgets/kernel/qwidgetwindow_qpa.cpp b/src/widgets/kernel/qwidgetwindow_qpa.cpp
deleted file mode 100644
index 1b076d1..0000000
--- a/src/widgets/kernel/qwidgetwindow_qpa.cpp
+++ /dev/null
@@ -1,592 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qwidgetwindow_qpa_p.h"
-
-#include "private/qwidget_p.h"
-#include "private/qapplication_p.h"
-#ifndef QT_NO_ACCESSIBILITY
-#include <QtGui/qaccessible.h>
-#endif
-#include <private/qwidgetbackingstore_p.h>
-
-QT_BEGIN_NAMESPACE
-
-QWidget *qt_button_down = 0; // widget got last button-down
-static QWidget *qt_tablet_target = 0;
-
-// popup control
-QWidget *qt_popup_down = 0; // popup that contains the pressed widget
-extern int openPopupCount;
-bool qt_replay_popup_mouse_event = false;
-extern bool qt_try_modal(QWidget *widget, QEvent::Type type);
-
-QWidgetWindow::QWidgetWindow(QWidget *widget)
-    : m_widget(widget)
-{
-    updateObjectName();
-    connect(m_widget, &QObject::objectNameChanged, this, &QWidgetWindow::updateObjectName);
-}
-
-#ifndef QT_NO_ACCESSIBILITY
-QAccessibleInterface *QWidgetWindow::accessibleRoot() const
-{
-    if (m_widget)
-        return QAccessible::queryAccessibleInterface(m_widget);
-    return 0;
-}
-#endif
-
-QObject *QWidgetWindow::focusObject() const
-{
-    QWidget *widget = m_widget->focusWidget();
-
-    if (!widget)
-        widget = m_widget;
-
-    return widget;
-}
-
-bool QWidgetWindow::event(QEvent *event)
-{
-    if (m_widget->testAttribute(Qt::WA_DontShowOnScreen)) {
-        // \a event is uninteresting for QWidgetWindow, the event was probably
-        // generated before WA_DontShowOnScreen was set
-        return m_widget->event(event);
-    }
-
-    switch (event->type()) {
-    case QEvent::Close:
-        handleCloseEvent(static_cast<QCloseEvent *>(event));
-        return true;
-
-    case QEvent::Enter:
-    case QEvent::Leave:
-        handleEnterLeaveEvent(event);
-        return true;
-
-    // these should not be sent to QWidget, the corresponding events
-    // are sent by QApplicationPrivate::notifyActiveWindowChange()
-    case QEvent::FocusIn:
-    case QEvent::FocusOut: {
-#ifndef QT_NO_ACCESSIBILITY
-        QAccessible::State state;
-        state.active = true;
-        QAccessibleStateChangeEvent ev(widget(), state);
-        QAccessible::updateAccessibility(&ev);
-#endif
-        return false; }
-
-    case QEvent::FocusAboutToChange:
-        if (QApplicationPrivate::focus_widget) {
-            if (QApplicationPrivate::focus_widget->testAttribute(Qt::WA_InputMethodEnabled))
-                qApp->inputMethod()->commit();
-
-            QGuiApplication::sendSpontaneousEvent(QApplicationPrivate::focus_widget, event);
-        }
-        return true;
-
-    case QEvent::KeyPress:
-    case QEvent::KeyRelease:
-    case QEvent::ShortcutOverride:
-        handleKeyEvent(static_cast<QKeyEvent *>(event));
-        return true;
-
-    case QEvent::MouseMove:
-    case QEvent::MouseButtonPress:
-    case QEvent::MouseButtonRelease:
-    case QEvent::MouseButtonDblClick:
-        handleMouseEvent(static_cast<QMouseEvent *>(event));
-        return true;
-
-    case QEvent::NonClientAreaMouseMove:
-    case QEvent::NonClientAreaMouseButtonPress:
-    case QEvent::NonClientAreaMouseButtonRelease:
-    case QEvent::NonClientAreaMouseButtonDblClick:
-        handleNonClientAreaMouseEvent(static_cast<QMouseEvent *>(event));
-        return true;
-
-    case QEvent::TouchBegin:
-    case QEvent::TouchUpdate:
-    case QEvent::TouchEnd:
-    case QEvent::TouchCancel:
-        handleTouchEvent(static_cast<QTouchEvent *>(event));
-        return true;
-
-    case QEvent::Move:
-        handleMoveEvent(static_cast<QMoveEvent *>(event));
-        return true;
-
-    case QEvent::Resize:
-        handleResizeEvent(static_cast<QResizeEvent *>(event));
-        return true;
-
-    case QEvent::Wheel:
-        handleWheelEvent(static_cast<QWheelEvent *>(event));
-        return true;
-
-#ifndef QT_NO_DRAGANDDROP
-    case QEvent::DragEnter:
-    case QEvent::DragLeave:
-    case QEvent::DragMove:
-    case QEvent::Drop:
-        handleDragEvent(event);
-        return true;
-#endif
-
-    case QEvent::Expose:
-        handleExposeEvent(static_cast<QExposeEvent *>(event));
-        return true;
-
-    case QEvent::WindowStateChange:
-        handleWindowStateChangedEvent(static_cast<QWindowStateChangeEvent *>(event));
-        return true;
-
-    case QEvent::ThemeChange: {
-        QEvent widgetEvent(QEvent::ThemeChange);
-        QGuiApplication::sendSpontaneousEvent(m_widget, &widgetEvent);
-    }
-        return true;
-
-#ifndef QT_NO_TABLETEVENT
-    case QEvent::TabletPress:
-    case QEvent::TabletMove:
-    case QEvent::TabletRelease:
-        handleTabletEvent(static_cast<QTabletEvent *>(event));
-        return true;
-#endif
-
-    default:
-        break;
-    }
-
-    return m_widget->event(event) || QWindow::event(event);
-}
-
-QPointer<QWidget> qt_last_mouse_receiver = 0;
-
-void QWidgetWindow::handleEnterLeaveEvent(QEvent *event)
-{
-    if (event->type() == QEvent::Leave) {
-        QWidget *leave = qt_last_mouse_receiver ? qt_last_mouse_receiver.data() : m_widget;
-        QApplicationPrivate::dispatchEnterLeave(0, leave);
-        qt_last_mouse_receiver = 0;
-    } else {
-        QApplicationPrivate::dispatchEnterLeave(m_widget, 0);
-        qt_last_mouse_receiver = m_widget;
-    }
-}
-
-void QWidgetWindow::handleNonClientAreaMouseEvent(QMouseEvent *e)
-{
-    QApplication::sendSpontaneousEvent(m_widget, e);
-}
-
-void QWidgetWindow::handleMouseEvent(QMouseEvent *event)
-{
-    if (qApp->d_func()->inPopupMode()) {
-        QWidget *activePopupWidget = qApp->activePopupWidget();
-        QWidget *popup = activePopupWidget;
-        QPoint mapped = event->pos();
-        if (popup != m_widget)
-            mapped = popup->mapFromGlobal(event->globalPos());
-        bool releaseAfter = false;
-        QWidget *popupChild  = popup->childAt(mapped);
-
-        if (popup != qt_popup_down) {
-            qt_button_down = 0;
-            qt_popup_down = 0;
-        }
-
-        switch (event->type()) {
-        case QEvent::MouseButtonPress:
-        case QEvent::MouseButtonDblClick:
-            qt_button_down = popupChild;
-            qt_popup_down = popup;
-            break;
-        case QEvent::MouseButtonRelease:
-            releaseAfter = true;
-            break;
-        default:
-            break; // nothing for mouse move
-        }
-
-        int oldOpenPopupCount = openPopupCount;
-
-        if (popup->isEnabled()) {
-            // deliver event
-            qt_replay_popup_mouse_event = false;
-            QWidget *receiver = popup;
-            QPoint widgetPos = mapped;
-            if (qt_button_down)
-                receiver = qt_button_down;
-            else if (popupChild)
-                receiver = popupChild;
-            if (receiver != popup)
-                widgetPos = receiver->mapFromGlobal(event->globalPos());
-            QWidget *alien = m_widget->childAt(m_widget->mapFromGlobal(event->globalPos()));
-            QMouseEvent e(event->type(), widgetPos, event->windowPos(), event->screenPos(), event->button(), event->buttons(), event->modifiers());
-            e.setTimestamp(event->timestamp());
-            QApplicationPrivate::sendMouseEvent(receiver, &e, alien, m_widget, &qt_button_down, qt_last_mouse_receiver);
-        } else {
-            // close disabled popups when a mouse button is pressed or released
-            switch (event->type()) {
-            case QEvent::MouseButtonPress:
-            case QEvent::MouseButtonDblClick:
-            case QEvent::MouseButtonRelease:
-                popup->close();
-                break;
-            default:
-                break;
-            }
-        }
-
-        if (qApp->activePopupWidget() != activePopupWidget
-            && qt_replay_popup_mouse_event) {
-            if (m_widget->windowType() != Qt::Popup)
-                qt_button_down = 0;
-            qt_replay_popup_mouse_event = false;
-#ifndef QT_NO_CONTEXTMENU
-        } else if (event->type() == QEvent::MouseButtonPress
-                   && event->button() == Qt::RightButton
-                   && (openPopupCount == oldOpenPopupCount)) {
-            QWidget *popupEvent = popup;
-            if (qt_button_down)
-                popupEvent = qt_button_down;
-            else if(popupChild)
-                popupEvent = popupChild;
-            QContextMenuEvent e(QContextMenuEvent::Mouse, mapped, event->globalPos(), event->modifiers());
-            QApplication::sendSpontaneousEvent(popupEvent, &e);
-#endif
-        }
-
-        if (releaseAfter) {
-            qt_button_down = 0;
-            qt_popup_down = 0;
-        }
-        return;
-    }
-
-    // modal event handling
-    if (QApplicationPrivate::instance()->modalState() && !qt_try_modal(m_widget, event->type()))
-        return;
-
-    // which child should have it?
-    QWidget *widget = m_widget->childAt(event->pos());
-    QPoint mapped = event->pos();
-
-    if (!widget)
-        widget = m_widget;
-
-    if (event->type() == QEvent::MouseButtonPress && !qt_button_down)
-        qt_button_down = widget;
-
-    QWidget *receiver = QApplicationPrivate::pickMouseReceiver(m_widget, event->windowPos().toPoint(), &mapped, event->type(), event->buttons(),
-                                                               qt_button_down, widget);
-
-    if (!receiver) {
-        if (event->type() == QEvent::MouseButtonRelease)
-            QApplicationPrivate::mouse_buttons &= ~event->button();
-        return;
-    }
-
-    QMouseEvent translated(event->type(), mapped, event->windowPos(), event->screenPos(), event->button(), event->buttons(), event->modifiers());
-    translated.setTimestamp(event->timestamp());
-    QApplicationPrivate::sendMouseEvent(receiver, &translated, widget, m_widget, &qt_button_down,
-                                        qt_last_mouse_receiver);
-
-#ifndef QT_NO_CONTEXTMENU
-    if (event->type() == QEvent::MouseButtonPress && event->button() == Qt::RightButton) {
-        QContextMenuEvent e(QContextMenuEvent::Mouse, mapped, event->globalPos(), event->modifiers());
-        QGuiApplication::sendSpontaneousEvent(receiver, &e);
-    }
-#endif
-}
-
-void QWidgetWindow::handleTouchEvent(QTouchEvent *event)
-{
-    if (event->type() == QEvent::TouchCancel)
-        QApplicationPrivate::translateTouchCancel(event->device(), event->timestamp());
-    else
-        QApplicationPrivate::translateRawTouchEvent(m_widget, event->device(), event->touchPoints(), event->timestamp());
-}
-
-void QWidgetWindow::handleKeyEvent(QKeyEvent *event)
-{
-    if (QApplicationPrivate::instance()->modalState() && !qt_try_modal(m_widget, event->type()))
-        return;
-
-    QObject *receiver = 0;
-    if (QApplicationPrivate::inPopupMode()) {
-        QWidget *popup = QApplication::activePopupWidget();
-        QWidget *popupFocusWidget = popup->focusWidget();
-        receiver = popupFocusWidget ? popupFocusWidget : popup;
-    }
-    if (!receiver)
-        receiver = focusObject();
-    QGuiApplication::sendSpontaneousEvent(receiver, event);
-}
-
-void QWidgetWindow::updateGeometry()
-{
-    if (m_widget->testAttribute(Qt::WA_OutsideWSRange))
-        return;
-
-    const QMargins margins = frameMargins();
-
-    m_widget->data->crect = geometry();
-    QTLWExtra *te = m_widget->d_func()->topData();
-    te->posIncludesFrame= false;
-    te->frameStrut.setCoords(margins.left(), margins.top(), margins.right(), margins.bottom());
-    m_widget->data->fstrut_dirty = false;
-}
-
-void QWidgetWindow::handleMoveEvent(QMoveEvent *event)
-{
-    updateGeometry();
-    QGuiApplication::sendSpontaneousEvent(m_widget, event);
-}
-
-void QWidgetWindow::handleResizeEvent(QResizeEvent *event)
-{
-    QSize oldSize = m_widget->data->crect.size();
-
-    updateGeometry();
-    QGuiApplication::sendSpontaneousEvent(m_widget, event);
-
-    if (m_widget->d_func()->paintOnScreen()) {
-        QRegion updateRegion(geometry());
-        if (m_widget->testAttribute(Qt::WA_StaticContents))
-            updateRegion -= QRect(0, 0, oldSize.width(), oldSize.height());
-        m_widget->d_func()->syncBackingStore(updateRegion);
-    } else {
-        m_widget->d_func()->syncBackingStore();
-    }
-}
-
-void QWidgetWindow::handleCloseEvent(QCloseEvent *)
-{
-    m_widget->d_func()->close_helper(QWidgetPrivate::CloseWithSpontaneousEvent);
-}
-
-void QWidgetWindow::handleWheelEvent(QWheelEvent *event)
-{
-    if (QApplicationPrivate::instance()->modalState() && !qt_try_modal(m_widget, event->type()))
-        return;
-
-    // which child should have it?
-    QWidget *widget = m_widget->childAt(event->pos());
-
-    if (!widget)
-        widget = m_widget;
-
-    QPoint mapped = widget->mapFrom(m_widget, event->pos());
-
-    QWheelEvent translated(mapped, event->globalPos(), event->pixelDelta(), event->angleDelta(), event->delta(), event->orientation(), event->buttons(), event->modifiers());
-    QGuiApplication::sendSpontaneousEvent(widget, &translated);
-}
-
-#ifndef QT_NO_DRAGANDDROP
-
-void QWidgetWindow::handleDragEvent(QEvent *event)
-{
-    switch (event->type()) {
-    case QEvent::DragEnter:
-        Q_ASSERT(!m_dragTarget);
-        // fall through
-    case QEvent::DragMove:
-    {
-        QDragMoveEvent *de = static_cast<QDragMoveEvent *>(event);
-        QWidget *widget = m_widget->childAt(de->pos());
-        if (!widget)
-            widget = m_widget;
-
-        if (widget != m_dragTarget.data()) {
-            if (m_dragTarget.data()) {
-                QDragLeaveEvent le;
-                QGuiApplication::sendSpontaneousEvent(m_dragTarget.data(), &le);
-            }
-            m_dragTarget = widget;
-            QPoint mapped = widget->mapFrom(m_widget, de->pos());
-            QDragEnterEvent translated(mapped, de->possibleActions(), de->mimeData(), de->mouseButtons(), de->keyboardModifiers());
-            QGuiApplication::sendSpontaneousEvent(widget, &translated);
-            if (translated.isAccepted())
-                event->accept();
-            de->setDropAction(translated.dropAction());
-        } else {
-            Q_ASSERT(event->type() == QEvent::DragMove);
-            QPoint mapped = widget->mapFrom(m_widget, de->pos());
-            QDragMoveEvent translated(mapped, de->possibleActions(), de->mimeData(), de->mouseButtons(), de->keyboardModifiers());
-            translated.setDropAction(de->dropAction());
-            QGuiApplication::sendSpontaneousEvent(widget, &translated);
-            if (translated.isAccepted())
-                event->accept();
-            de->setDropAction(translated.dropAction());
-        }
-        break;
-    }
-    case QEvent::DragLeave:
-        if (m_dragTarget)
-            QGuiApplication::sendSpontaneousEvent(m_dragTarget.data(), event);
-        m_dragTarget = (QWidget *)0;
-        break;
-    case QEvent::Drop:
-    {
-        QDropEvent *de = static_cast<QDropEvent *>(event);
-        QPoint mapped = m_dragTarget.data()->mapFrom(m_widget, de->pos());
-        QDropEvent translated(mapped, de->possibleActions(), de->mimeData(), de->mouseButtons(), de->keyboardModifiers());
-        QGuiApplication::sendSpontaneousEvent(m_dragTarget.data(), &translated);
-        if (translated.isAccepted())
-            event->accept();
-        de->setDropAction(translated.dropAction());
-        m_dragTarget = (QWidget *)0;
-    }
-    default:
-        break;
-    }
-}
-
-#endif // QT_NO_DRAGANDDROP
-
-void QWidgetWindow::handleExposeEvent(QExposeEvent *event)
-{
-    if (isExposed()) {
-        m_widget->setAttribute(Qt::WA_Mapped);
-        if (!event->region().isNull()) {
-            // Exposed native widgets need to be marked dirty to get them repainted correctly.
-            if (m_widget->internalWinId() && !m_widget->isWindow() && m_widget->updatesEnabled()) {
-                if (QWidgetBackingStore *bs = m_widget->d_func()->maybeBackingStore())
-                    bs->markDirty(event->region(), m_widget);
-            }
-            m_widget->d_func()->syncBackingStore(event->region());
-        }
-    } else {
-        m_widget->setAttribute(Qt::WA_Mapped, false);
-    }
-}
-
-Qt::WindowState effectiveState(Qt::WindowStates state);
-
-void QWidgetWindow::handleWindowStateChangedEvent(QWindowStateChangeEvent *event)
-{
-    // QWindow does currently not know 'active'.
-    Qt::WindowStates eventState = event->oldState();
-    Qt::WindowStates widgetState = m_widget->windowState();
-    if (widgetState & Qt::WindowActive)
-        eventState |= Qt::WindowActive;
-
-    // Determine the new widget state, remember maximized/full screen
-    // during minimized.
-    switch (windowState()) {
-    case Qt::WindowNoState:
-        widgetState &= ~(Qt::WindowMinimized | Qt::WindowMaximized | Qt::WindowFullScreen);
-        break;
-    case Qt::WindowMinimized:
-        widgetState |= Qt::WindowMinimized;
-        break;
-    case Qt::WindowMaximized:
-        if (effectiveState(widgetState) == Qt::WindowNoState)
-            if (QTLWExtra *tle = m_widget->d_func()->maybeTopData())
-                tle->normalGeometry = m_widget->geometry();
-        widgetState &= ~Qt::WindowFullScreen;
-        widgetState |= Qt::WindowMaximized;
-        break;
-    case Qt::WindowFullScreen:
-        if (effectiveState(widgetState) == Qt::WindowNoState)
-            if (QTLWExtra *tle = m_widget->d_func()->maybeTopData())
-                tle->normalGeometry = m_widget->geometry();
-        widgetState &= ~Qt::WindowMaximized;
-        widgetState |= Qt::WindowFullScreen;
-        break;
-    case Qt::WindowActive: // Not handled by QWindow
-        break;
-    }
-
-    // Sent event if the state changed (that is, it is not triggered by
-    // QWidget::setWindowState(), which also sends an event to the widget).
-    if (widgetState != int(m_widget->data->window_state)) {
-        m_widget->data->window_state = widgetState;
-        QWindowStateChangeEvent widgetEvent(eventState);
-        QGuiApplication::sendSpontaneousEvent(m_widget, &widgetEvent);
-    }
-}
-
-bool QWidgetWindow::nativeEvent(const QByteArray &eventType, void *message, long *result)
-{
-    return m_widget->nativeEvent(eventType, message, result);
-}
-
-#ifndef QT_NO_TABLETEVENT
-void QWidgetWindow::handleTabletEvent(QTabletEvent *event)
-{
-    if (event->type() == QEvent::TabletPress) {
-        QWidget *widget = m_widget->childAt(event->pos());
-        if (!widget)
-            widget = m_widget;
-
-        qt_tablet_target = widget;
-    }
-
-    if (qt_tablet_target) {
-        QPointF delta = event->globalPosF() - event->globalPos();
-        QPointF mapped = qt_tablet_target->mapFromGlobal(event->globalPos()) + delta;
-        QTabletEvent ev(event->type(), mapped, event->globalPosF(), event->device(), event->pointerType(),
-                        event->pressure(), event->xTilt(), event->yTilt(), event->tangentialPressure(),
-                        event->rotation(), event->z(), event->modifiers(), event->uniqueId());
-        ev.setTimestamp(event->timestamp());
-        QGuiApplication::sendSpontaneousEvent(qt_tablet_target, &ev);
-    }
-
-    if (event->type() == QEvent::TabletRelease)
-        qt_tablet_target = 0;
-}
-#endif // QT_NO_TABLETEVENT
-
-void QWidgetWindow::updateObjectName()
-{
-    QString name = m_widget->objectName();
-    if (name.isEmpty())
-        name = QString::fromUtf8(m_widget->metaObject()->className()) + QStringLiteral("Class");
-    name += QStringLiteral("Window");
-    setObjectName(name);
-}
-
-QT_END_NAMESPACE
diff --git a/src/widgets/util/qcolormap.cpp b/src/widgets/util/qcolormap.cpp
new file mode 100644
index 0000000..8c24a25
--- /dev/null
+++ b/src/widgets/util/qcolormap.cpp
@@ -0,0 +1,228 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qcolormap.h"
+#include "qcolor.h"
+#include "qpaintdevice.h"
+#include "qscreen.h"
+#include "qguiapplication.h"
+
+QT_BEGIN_NAMESPACE
+
+class QColormapPrivate
+{
+public:
+    inline QColormapPrivate()
+        : ref(1), mode(QColormap::Direct), depth(0), numcolors(0)
+    { }
+
+    QAtomicInt ref;
+
+    QColormap::Mode mode;
+    int depth;
+    int numcolors;
+};
+
+static QColormapPrivate *screenMap = 0;
+
+void QColormap::initialize()
+{
+    screenMap = new QColormapPrivate;
+
+    screenMap->depth = QGuiApplication::primaryScreen()->depth();
+    if (screenMap->depth < 8) {
+        screenMap->mode = QColormap::Indexed;
+        screenMap->numcolors = 256;
+    } else {
+        screenMap->mode = QColormap::Direct;
+        screenMap->numcolors = -1;
+    }
+}
+
+void QColormap::cleanup()
+{
+    delete screenMap;
+    screenMap = 0;
+}
+
+QColormap QColormap::instance(int /*screen*/)
+{
+    return QColormap();
+}
+
+QColormap::QColormap()
+    : d(screenMap)
+{ d->ref.ref(); }
+
+QColormap::QColormap(const QColormap &colormap)
+    :d (colormap.d)
+{ d->ref.ref(); }
+
+QColormap::~QColormap()
+{
+    if (!d->ref.deref())
+        delete d;
+}
+
+QColormap::Mode QColormap::mode() const
+{ return d->mode; }
+
+
+int QColormap::depth() const
+{ return d->depth; }
+
+
+int QColormap::size() const
+{
+    return d->numcolors;
+}
+
+#ifndef QT_QWS_DEPTH16_RGB
+#define QT_QWS_DEPTH16_RGB 565
+#endif
+static const int qt_rbits = (QT_QWS_DEPTH16_RGB/100);
+static const int qt_gbits = (QT_QWS_DEPTH16_RGB/10%10);
+static const int qt_bbits = (QT_QWS_DEPTH16_RGB%10);
+static const int qt_red_shift = qt_bbits+qt_gbits-(8-qt_rbits);
+static const int qt_green_shift = qt_bbits-(8-qt_gbits);
+static const int qt_neg_blue_shift = 8-qt_bbits;
+static const int qt_blue_mask = (1<<qt_bbits)-1;
+static const int qt_green_mask = (1<<(qt_gbits+qt_bbits))-(1<<qt_bbits);
+static const int qt_red_mask = (1<<(qt_rbits+qt_gbits+qt_bbits))-(1<<(qt_gbits+qt_bbits));
+
+static const int qt_red_rounding_shift = qt_red_shift + qt_rbits;
+static const int qt_green_rounding_shift = qt_green_shift + qt_gbits;
+static const int qt_blue_rounding_shift = qt_bbits - qt_neg_blue_shift;
+
+inline ushort qt_convRgbTo16(QRgb c)
+{
+    const int tr = qRed(c) << qt_red_shift;
+    const int tg = qGreen(c) << qt_green_shift;
+    const int tb = qBlue(c) >> qt_neg_blue_shift;
+
+    return (tb & qt_blue_mask) | (tg & qt_green_mask) | (tr & qt_red_mask);
+}
+
+inline QRgb qt_conv16ToRgb(ushort c)
+{
+    const int r=(c & qt_red_mask);
+    const int g=(c & qt_green_mask);
+    const int b=(c & qt_blue_mask);
+    const int tr = r >> qt_red_shift | r >> qt_red_rounding_shift;
+    const int tg = g >> qt_green_shift | g >> qt_green_rounding_shift;
+    const int tb = b << qt_neg_blue_shift | b >> qt_blue_rounding_shift;
+
+    return qRgb(tr,tg,tb);
+}
+
+uint QColormap::pixel(const QColor &color) const
+{
+    QRgb rgb = color.rgba();
+    if (d->mode == QColormap::Direct) {
+        switch(d->depth) {
+        case 16:
+            return qt_convRgbTo16(rgb);
+        case 24:
+        case 32:
+        {
+            const int r = qRed(rgb);
+            const int g = qGreen(rgb);
+            const int b = qBlue(rgb);
+            const int red_shift = 16;
+            const int green_shift = 8;
+            const int red_mask   = 0xff0000;
+            const int green_mask = 0x00ff00;
+            const int blue_mask  = 0x0000ff;
+            const int tg = g << green_shift;
+#ifdef QT_QWS_DEPTH_32_BGR
+            if (qt_screen->pixelType() == QScreen::BGRPixel) {
+                const int tb = b << red_shift;
+                return 0xff000000 | (r & blue_mask) | (tg & green_mask) | (tb & red_mask);
+            }
+#endif
+            const int tr = r << red_shift;
+            return 0xff000000 | (b & blue_mask) | (tg & green_mask) | (tr & red_mask);
+        }
+        }
+    }
+    //XXX
+    //return qt_screen->alloc(qRed(rgb), qGreen(rgb), qBlue(rgb));
+    return 0;
+}
+
+const QColor QColormap::colorAt(uint pixel) const
+{
+    if (d->mode == Direct) {
+        if (d->depth == 16) {
+            pixel = qt_conv16ToRgb(pixel);
+        }
+        const int red_shift = 16;
+        const int green_shift = 8;
+        const int red_mask   = 0xff0000;
+        const int green_mask = 0x00ff00;
+        const int blue_mask  = 0x0000ff;
+#ifdef QT_QWS_DEPTH_32_BGR
+        if (qt_screen->pixelType() == QScreen::BGRPixel) {
+            return QColor((pixel & blue_mask),
+                          (pixel & green_mask) >> green_shift,
+                          (pixel & red_mask) >> red_shift);
+        }
+#endif
+        return QColor((pixel & red_mask) >> red_shift,
+                      (pixel & green_mask) >> green_shift,
+                      (pixel & blue_mask));
+    }
+#if 0 // XXX
+    Q_ASSERT_X(int(pixel) < qt_screen->numCols(), "QColormap::colorAt", "pixel out of bounds of palette");
+    return QColor(qt_screen->clut()[pixel]);
+#endif
+    return QColor();
+}
+
+const QVector<QColor> QColormap::colormap() const
+{
+    return QVector<QColor>();
+}
+
+QColormap &QColormap::operator=(const QColormap &colormap)
+{ qAtomicAssign(d, colormap.d); return *this; }
+
+QT_END_NAMESPACE
diff --git a/src/widgets/util/qcolormap_qpa.cpp b/src/widgets/util/qcolormap_qpa.cpp
deleted file mode 100644
index 8c24a25..0000000
--- a/src/widgets/util/qcolormap_qpa.cpp
+++ /dev/null
@@ -1,228 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qcolormap.h"
-#include "qcolor.h"
-#include "qpaintdevice.h"
-#include "qscreen.h"
-#include "qguiapplication.h"
-
-QT_BEGIN_NAMESPACE
-
-class QColormapPrivate
-{
-public:
-    inline QColormapPrivate()
-        : ref(1), mode(QColormap::Direct), depth(0), numcolors(0)
-    { }
-
-    QAtomicInt ref;
-
-    QColormap::Mode mode;
-    int depth;
-    int numcolors;
-};
-
-static QColormapPrivate *screenMap = 0;
-
-void QColormap::initialize()
-{
-    screenMap = new QColormapPrivate;
-
-    screenMap->depth = QGuiApplication::primaryScreen()->depth();
-    if (screenMap->depth < 8) {
-        screenMap->mode = QColormap::Indexed;
-        screenMap->numcolors = 256;
-    } else {
-        screenMap->mode = QColormap::Direct;
-        screenMap->numcolors = -1;
-    }
-}
-
-void QColormap::cleanup()
-{
-    delete screenMap;
-    screenMap = 0;
-}
-
-QColormap QColormap::instance(int /*screen*/)
-{
-    return QColormap();
-}
-
-QColormap::QColormap()
-    : d(screenMap)
-{ d->ref.ref(); }
-
-QColormap::QColormap(const QColormap &colormap)
-    :d (colormap.d)
-{ d->ref.ref(); }
-
-QColormap::~QColormap()
-{
-    if (!d->ref.deref())
-        delete d;
-}
-
-QColormap::Mode QColormap::mode() const
-{ return d->mode; }
-
-
-int QColormap::depth() const
-{ return d->depth; }
-
-
-int QColormap::size() const
-{
-    return d->numcolors;
-}
-
-#ifndef QT_QWS_DEPTH16_RGB
-#define QT_QWS_DEPTH16_RGB 565
-#endif
-static const int qt_rbits = (QT_QWS_DEPTH16_RGB/100);
-static const int qt_gbits = (QT_QWS_DEPTH16_RGB/10%10);
-static const int qt_bbits = (QT_QWS_DEPTH16_RGB%10);
-static const int qt_red_shift = qt_bbits+qt_gbits-(8-qt_rbits);
-static const int qt_green_shift = qt_bbits-(8-qt_gbits);
-static const int qt_neg_blue_shift = 8-qt_bbits;
-static const int qt_blue_mask = (1<<qt_bbits)-1;
-static const int qt_green_mask = (1<<(qt_gbits+qt_bbits))-(1<<qt_bbits);
-static const int qt_red_mask = (1<<(qt_rbits+qt_gbits+qt_bbits))-(1<<(qt_gbits+qt_bbits));
-
-static const int qt_red_rounding_shift = qt_red_shift + qt_rbits;
-static const int qt_green_rounding_shift = qt_green_shift + qt_gbits;
-static const int qt_blue_rounding_shift = qt_bbits - qt_neg_blue_shift;
-
-inline ushort qt_convRgbTo16(QRgb c)
-{
-    const int tr = qRed(c) << qt_red_shift;
-    const int tg = qGreen(c) << qt_green_shift;
-    const int tb = qBlue(c) >> qt_neg_blue_shift;
-
-    return (tb & qt_blue_mask) | (tg & qt_green_mask) | (tr & qt_red_mask);
-}
-
-inline QRgb qt_conv16ToRgb(ushort c)
-{
-    const int r=(c & qt_red_mask);
-    const int g=(c & qt_green_mask);
-    const int b=(c & qt_blue_mask);
-    const int tr = r >> qt_red_shift | r >> qt_red_rounding_shift;
-    const int tg = g >> qt_green_shift | g >> qt_green_rounding_shift;
-    const int tb = b << qt_neg_blue_shift | b >> qt_blue_rounding_shift;
-
-    return qRgb(tr,tg,tb);
-}
-
-uint QColormap::pixel(const QColor &color) const
-{
-    QRgb rgb = color.rgba();
-    if (d->mode == QColormap::Direct) {
-        switch(d->depth) {
-        case 16:
-            return qt_convRgbTo16(rgb);
-        case 24:
-        case 32:
-        {
-            const int r = qRed(rgb);
-            const int g = qGreen(rgb);
-            const int b = qBlue(rgb);
-            const int red_shift = 16;
-            const int green_shift = 8;
-            const int red_mask   = 0xff0000;
-            const int green_mask = 0x00ff00;
-            const int blue_mask  = 0x0000ff;
-            const int tg = g << green_shift;
-#ifdef QT_QWS_DEPTH_32_BGR
-            if (qt_screen->pixelType() == QScreen::BGRPixel) {
-                const int tb = b << red_shift;
-                return 0xff000000 | (r & blue_mask) | (tg & green_mask) | (tb & red_mask);
-            }
-#endif
-            const int tr = r << red_shift;
-            return 0xff000000 | (b & blue_mask) | (tg & green_mask) | (tr & red_mask);
-        }
-        }
-    }
-    //XXX
-    //return qt_screen->alloc(qRed(rgb), qGreen(rgb), qBlue(rgb));
-    return 0;
-}
-
-const QColor QColormap::colorAt(uint pixel) const
-{
-    if (d->mode == Direct) {
-        if (d->depth == 16) {
-            pixel = qt_conv16ToRgb(pixel);
-        }
-        const int red_shift = 16;
-        const int green_shift = 8;
-        const int red_mask   = 0xff0000;
-        const int green_mask = 0x00ff00;
-        const int blue_mask  = 0x0000ff;
-#ifdef QT_QWS_DEPTH_32_BGR
-        if (qt_screen->pixelType() == QScreen::BGRPixel) {
-            return QColor((pixel & blue_mask),
-                          (pixel & green_mask) >> green_shift,
-                          (pixel & red_mask) >> red_shift);
-        }
-#endif
-        return QColor((pixel & red_mask) >> red_shift,
-                      (pixel & green_mask) >> green_shift,
-                      (pixel & blue_mask));
-    }
-#if 0 // XXX
-    Q_ASSERT_X(int(pixel) < qt_screen->numCols(), "QColormap::colorAt", "pixel out of bounds of palette");
-    return QColor(qt_screen->clut()[pixel]);
-#endif
-    return QColor();
-}
-
-const QVector<QColor> QColormap::colormap() const
-{
-    return QVector<QColor>();
-}
-
-QColormap &QColormap::operator=(const QColormap &colormap)
-{ qAtomicAssign(d, colormap.d); return *this; }
-
-QT_END_NAMESPACE
diff --git a/src/widgets/util/util.pri b/src/widgets/util/util.pri
index 958958f..08574dd 100644
--- a/src/widgets/util/util.pri
+++ b/src/widgets/util/util.pri
@@ -18,7 +18,7 @@ HEADERS += \
 
 SOURCES += \
         util/qsystemtrayicon.cpp \
-        util/qcolormap_qpa.cpp \
+        util/qcolormap.cpp \
         util/qcompleter.cpp \
         util/qscroller.cpp \
         util/qscrollerproperties.cpp \