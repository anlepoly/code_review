diff --git a/src/xmlpatterns/acceltree/qacceltreebuilder.cpp b/src/xmlpatterns/acceltree/qacceltreebuilder.cpp
deleted file mode 100644
index 289ab6c..0000000
--- a/src/xmlpatterns/acceltree/qacceltreebuilder.cpp
+++ /dev/null
@@ -1,440 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by qacceltreebuilder_p.h.
- * If you need includes in this file, put them in qacceltreebuilder_p.h, outside of the namespace.
- */
-
-template <bool FromDocument>
-AccelTreeBuilder<FromDocument>::AccelTreeBuilder(const QUrl &docURI,
-                                                 const QUrl &baseURI,
-                                                 const NamePool::Ptr &np,
-                                                 ReportContext *const context,
-                                                 Features features) : m_preNumber(-1)
-                                                                    , m_isPreviousAtomic(false)
-                                                                    , m_hasCharacters(false)
-                                                                    , m_isCharactersCompressed(false)
-                                                                    , m_namePool(np)
-                                                                    , m_document(new AccelTree(docURI, baseURI))
-                                                                    , m_skippedDocumentNodes(0)
-                                                                    , m_documentURI(docURI)
-                                                                    , m_context(context)
-                                                                    , m_features(features)
-{
-    Q_ASSERT(m_namePool);
-
-    /* TODO Perhaps we can merge m_ancestors and m_size
-     * into one, and store a struct for the two instead? */
-    m_ancestors.reserve(DefaultNodeStackSize);
-    m_ancestors.push(-1);
-
-    m_size.reserve(DefaultNodeStackSize);
-    m_size.push(0);
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::startStructure()
-{
-    if(m_hasCharacters)
-    {
-        /* We create a node even if m_characters is empty.
-         * Remember that `text {""}' creates one text node
-         * with string value "". */
-
-        ++m_preNumber;
-        m_document->basicData.append(AccelTree::BasicNodeData(currentDepth(),
-                                                              currentParent(),
-                                                              QXmlNodeModelIndex::Text,
-                                                              m_isCharactersCompressed ? AccelTree::IsCompressed : 0));
-        m_document->data.insert(m_preNumber, m_characters);
-        ++m_size.top();
-
-        m_characters.clear(); /* We don't want it added twice. */
-        m_hasCharacters = false;
-
-        if(m_isCharactersCompressed)
-            m_isCharactersCompressed = false;
-    }
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::item(const Item &it)
-{
-    Q_ASSERT(it);
-
-    if(it.isAtomicValue())
-    {
-        if(m_isPreviousAtomic)
-        {
-            m_characters += QLatin1Char(' ');
-            m_characters += it.stringValue();
-        }
-        else
-        {
-            m_isPreviousAtomic = true;
-            const QString sv(it.stringValue());
-
-            if(!sv.isEmpty())
-            {
-                m_characters += sv;
-                m_hasCharacters = true;
-            }
-        }
-    }
-    else
-        sendAsNode(it);
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::startElement(const QXmlName &name)
-{
-    startElement(name, 1, 1);
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::startElement(const QXmlName &name, qint64 line, qint64 column)
-{
-    startStructure();
-
-    AccelTree::BasicNodeData data(currentDepth(), currentParent(), QXmlNodeModelIndex::Element, -1, name);
-    m_document->basicData.append(data);
-    if (m_features & SourceLocationsFeature)
-        m_document->sourcePositions.insert(m_document->maximumPreNumber(), qMakePair(line, column));
-
-    ++m_preNumber;
-    m_ancestors.push(m_preNumber);
-
-    ++m_size.top();
-    m_size.push(0);
-
-    /* With node constructors, we can receive names for which we have no namespace
-     * constructors, such as in the query '<xs:space/>'. Since the 'xs' prefix has no
-     * NamespaceConstructor in this case, we synthesize the namespace.
-     *
-     * In case we're constructing from an XML document we avoid the call because
-     * although it's redundant, it's on extra virtual call for each element. */
-    if(!FromDocument)
-        namespaceBinding(QXmlName(name.namespaceURI(), 0, name.prefix()));
-
-    m_isPreviousAtomic = false;
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::endElement()
-{
-    startStructure();
-    const AccelTree::PreNumber index = m_ancestors.pop();
-    AccelTree::BasicNodeData &data = m_document->basicData[index];
-
-    /* Sub trees needs to be included in upper trees, so we add the count of this element
-     * to our parent. */
-    m_size[m_size.count() - 2] += m_size.top();
-
-    data.setSize(m_size.pop());
-    m_isPreviousAtomic = false;
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::attribute(const QXmlName &name, const QStringRef &value)
-{
-    /* Attributes adds a namespace binding, so lets synthesize one.
-     *
-     * We optimize by checking whether we have a namespace for which a binding would
-     * be generated. Happens relatively rarely. */
-    if(name.hasPrefix())
-        namespaceBinding(QXmlName(name.namespaceURI(), 0, name.prefix()));
-
-    m_document->basicData.append(AccelTree::BasicNodeData(currentDepth(), currentParent(), QXmlNodeModelIndex::Attribute, 0, name));
-    ++m_preNumber;
-    ++m_size.top();
-
-    m_isPreviousAtomic = false;
-
-    if(name.namespaceURI() == StandardNamespaces::xml && name.localName() == StandardLocalNames::id)
-    {
-        const QString normalized(value.toString().simplified());
-
-        if(QXmlUtils::isNCName(normalized))
-        {
-            const QXmlName::LocalNameCode id = m_namePool->allocateLocalName(normalized);
-
-            const int oldSize = m_document->m_IDs.count();
-            m_document->m_IDs.insert(id, currentParent());
-            /* We don't run the value through m_attributeCompress here, because
-             * the likelyhood of it deing identical to another attribute is
-             * very small. */
-            m_document->data.insert(m_preNumber, normalized);
-
-            /**
-             * In the case that we're called for doc-available(), m_context is
-             * null, and we need to flag somehow that we failed to load this
-             * document.
-             */
-            if(oldSize == m_document->m_IDs.count() && m_context) // TODO
-            {
-                Q_ASSERT(m_context);
-                m_context->error(QtXmlPatterns::tr("An %1-attribute with value %2 has already been declared.")
-                                                   .arg(formatKeyword("xml:id"),
-                                                        formatData(normalized)),
-                                 FromDocument ? ReportContext::FODC0002 : ReportContext::XQDY0091,
-                                 this);
-            }
-        }
-        else if(m_context) // TODO
-        {
-            Q_ASSERT(m_context);
-
-            /* If we're building from an XML Document(e.g, we're fed from QXmlStreamReader, we raise FODC0002,
-             * otherwise XQDY0091. */
-            m_context->error(QtXmlPatterns::tr("An %1-attribute must have a "
-                                               "valid %2 as value, which %3 isn't.").arg(formatKeyword("xml:id"),
-                                                                                         formatType(m_namePool, BuiltinTypes::xsNCName),
-                                                                                         formatData(value.toString())),
-                             FromDocument ? ReportContext::FODC0002 : ReportContext::XQDY0091,
-                             this);
-        }
-    }
-    else
-        m_document->data.insert(m_preNumber, *m_attributeCompress.insert(value.toString()));
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::characters(const QStringRef &ch)
-{
-
-    /* If a text node constructor appears by itself, a node needs to
-     * be created. Therefore, we set m_hasCharacters
-     * if we're the only node.
-     * However, if the text node appears as a child of a document or element
-     * node it is discarded if it's empty.
-     */
-    if(m_hasCharacters && m_isCharactersCompressed)
-    {
-        m_characters = CompressedWhitespace::decompress(m_characters);
-        m_isCharactersCompressed = false;
-    }
-
-    m_characters += ch;
-
-    m_isPreviousAtomic = false;
-    m_hasCharacters = !m_characters.isEmpty() || m_preNumber == -1; /* -1 is our start value. */
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::whitespaceOnly(const QStringRef &ch)
-{
-    Q_ASSERT(!ch.isEmpty());
-    Q_ASSERT(ch.toString().trimmed().isEmpty());
-
-    /* This gets problematic due to how QXmlStreamReader works(which
-     * is the only one we get whitespaceOnly() events from). Namely, text intermingled
-     * with CDATA gets reported as individual Characters events, and
-     * QXmlStreamReader::isWhitespace() can return differently for each of those. However,
-     * it will occur very rarely, so this workaround of 1) mistakenly compressing 2) decompressing 3)
-     * appending, will happen infrequently.
-     */
-    if(m_hasCharacters)
-    {
-        if(m_isCharactersCompressed)
-        {
-            m_characters = CompressedWhitespace::decompress(m_characters);
-            m_isCharactersCompressed = false;
-        }
-
-        m_characters.append(ch.toString());
-    }
-    else
-    {
-        /* We haven't received a text node previously. */
-        m_characters = CompressedWhitespace::compress(ch);
-        m_isCharactersCompressed = true;
-        m_isPreviousAtomic = false;
-        m_hasCharacters = true;
-    }
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::processingInstruction(const QXmlName &target,
-                                                           const QString &data)
-{
-    startStructure();
-    ++m_preNumber;
-    m_document->data.insert(m_preNumber, data);
-
-    m_document->basicData.append(AccelTree::BasicNodeData(currentDepth(),
-                                                          currentParent(),
-                                                          QXmlNodeModelIndex::ProcessingInstruction,
-                                                          0,
-                                                          target));
-    ++m_size.top();
-    m_isPreviousAtomic = false;
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::comment(const QString &content)
-{
-    startStructure();
-    m_document->basicData.append(AccelTree::BasicNodeData(currentDepth(), currentParent(), QXmlNodeModelIndex::Comment, 0));
-    ++m_preNumber;
-    m_document->data.insert(m_preNumber, content);
-    ++m_size.top();
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::namespaceBinding(const QXmlName &nb)
-{
-    /* Note, because attribute() sometimes generate namespaceBinding() calls, this function
-     * can be called after attributes, in contrast to what the class documentation says. This is ok,
-     * as long as we're not dealing with public API. */
-
-    /* If we've received attributes, it means the element's size have changed and m_preNumber have advanced,
-     * so "reverse back" to the actual element. */
-    const AccelTree::PreNumber pn = m_preNumber - m_size.top();
-
-    QVector<QXmlName> &nss = m_document->namespaces[pn];
-
-    /* "xml" hasn't been declared for each node, AccelTree::namespaceBindings() adds it, so avoid it
-     * such that we don't get duplicates. */
-    if(nb.prefix() == StandardPrefixes::xml)
-        return;
-
-    /* If we already have the binding, skip it. */
-    const int len = nss.count();
-    for(int i = 0; i < len; ++i)
-    {
-        if(nss.at(i).prefix() == nb.prefix())
-            return;
-    }
-
-    nss.append(nb);
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::startDocument()
-{
-    /* If we have already received nodes, we can't add a document node. */
-    if(m_preNumber == -1) /* -1 is our start value. */
-    {
-        m_size.push(0);
-        m_document->basicData.append(AccelTree::BasicNodeData(0, -1, QXmlNodeModelIndex::Document, -1));
-        ++m_preNumber;
-        m_ancestors.push(m_preNumber);
-    }
-    else
-        ++m_skippedDocumentNodes;
-
-    m_isPreviousAtomic = false;
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::endDocument()
-{
-    if(m_skippedDocumentNodes == 0)
-    {
-        /* Create text nodes, if we've received any. We do this only if we're the
-         * top node because if we're getting this event as being a child of an element,
-         * text nodes or atomic values can appear after us, and which must get
-         * merged with the previous text.
-         *
-         * We call startStructure() before we pop the ancestor, such that the text node becomes
-         * a child of this document node. */
-        startStructure();
-
-        m_document->basicData.first().setSize(m_size.pop());
-        m_ancestors.pop();
-    }
-    else
-        --m_skippedDocumentNodes;
-
-    m_isPreviousAtomic = false;
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::atomicValue(const QVariant &value)
-{
-    Q_UNUSED(value);
-    // TODO
-}
-
-template <bool FromDocument>
-QAbstractXmlNodeModel::Ptr AccelTreeBuilder<FromDocument>::builtDocument()
-{
-    /* Create a text node, if we have received text in some way. */
-    startStructure();
-    m_document->printStats(m_namePool);
-
-    return m_document;
-}
-
-template <bool FromDocument>
-NodeBuilder::Ptr AccelTreeBuilder<FromDocument>::create(const QUrl &baseURI) const
-{
-    Q_UNUSED(baseURI);
-    return NodeBuilder::Ptr(new AccelTreeBuilder(QUrl(), baseURI, m_namePool, m_context));
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::startOfSequence()
-{
-}
-
-template <bool FromDocument>
-void AccelTreeBuilder<FromDocument>::endOfSequence()
-{
-}
-
-template <bool FromDocument>
-const SourceLocationReflection *AccelTreeBuilder<FromDocument>::actualReflection() const
-{
-    return this;
-}
-
-template <bool FromDocument>
-QSourceLocation AccelTreeBuilder<FromDocument>::sourceLocation() const
-{
-    if(m_documentURI.isEmpty())
-        return QSourceLocation(QUrl(QLatin1String("AnonymousNodeTree")));
-    else
-        return QSourceLocation(m_documentURI);
-}
-
diff --git a/src/xmlpatterns/acceltree/qacceltreebuilder_p.h b/src/xmlpatterns/acceltree/qacceltreebuilder_p.h
index be705b4..9e4da59 100644
--- a/src/xmlpatterns/acceltree/qacceltreebuilder_p.h
+++ b/src/xmlpatterns/acceltree/qacceltreebuilder_p.h
@@ -194,7 +194,7 @@ namespace QPatternist
     Q_DECLARE_OPERATORS_FOR_FLAGS(AccelTreeBuilder<true>::Features)
     Q_DECLARE_OPERATORS_FOR_FLAGS(AccelTreeBuilder<false>::Features)
 
-#include "qacceltreebuilder.cpp"
+#include "qacceltreebuilder_tpl_p.h"
 }
 
 QT_END_NAMESPACE
diff --git a/src/xmlpatterns/acceltree/qacceltreebuilder_tpl_p.h b/src/xmlpatterns/acceltree/qacceltreebuilder_tpl_p.h
new file mode 100644
index 0000000..289ab6c
--- /dev/null
+++ b/src/xmlpatterns/acceltree/qacceltreebuilder_tpl_p.h
@@ -0,0 +1,440 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by qacceltreebuilder_p.h.
+ * If you need includes in this file, put them in qacceltreebuilder_p.h, outside of the namespace.
+ */
+
+template <bool FromDocument>
+AccelTreeBuilder<FromDocument>::AccelTreeBuilder(const QUrl &docURI,
+                                                 const QUrl &baseURI,
+                                                 const NamePool::Ptr &np,
+                                                 ReportContext *const context,
+                                                 Features features) : m_preNumber(-1)
+                                                                    , m_isPreviousAtomic(false)
+                                                                    , m_hasCharacters(false)
+                                                                    , m_isCharactersCompressed(false)
+                                                                    , m_namePool(np)
+                                                                    , m_document(new AccelTree(docURI, baseURI))
+                                                                    , m_skippedDocumentNodes(0)
+                                                                    , m_documentURI(docURI)
+                                                                    , m_context(context)
+                                                                    , m_features(features)
+{
+    Q_ASSERT(m_namePool);
+
+    /* TODO Perhaps we can merge m_ancestors and m_size
+     * into one, and store a struct for the two instead? */
+    m_ancestors.reserve(DefaultNodeStackSize);
+    m_ancestors.push(-1);
+
+    m_size.reserve(DefaultNodeStackSize);
+    m_size.push(0);
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::startStructure()
+{
+    if(m_hasCharacters)
+    {
+        /* We create a node even if m_characters is empty.
+         * Remember that `text {""}' creates one text node
+         * with string value "". */
+
+        ++m_preNumber;
+        m_document->basicData.append(AccelTree::BasicNodeData(currentDepth(),
+                                                              currentParent(),
+                                                              QXmlNodeModelIndex::Text,
+                                                              m_isCharactersCompressed ? AccelTree::IsCompressed : 0));
+        m_document->data.insert(m_preNumber, m_characters);
+        ++m_size.top();
+
+        m_characters.clear(); /* We don't want it added twice. */
+        m_hasCharacters = false;
+
+        if(m_isCharactersCompressed)
+            m_isCharactersCompressed = false;
+    }
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::item(const Item &it)
+{
+    Q_ASSERT(it);
+
+    if(it.isAtomicValue())
+    {
+        if(m_isPreviousAtomic)
+        {
+            m_characters += QLatin1Char(' ');
+            m_characters += it.stringValue();
+        }
+        else
+        {
+            m_isPreviousAtomic = true;
+            const QString sv(it.stringValue());
+
+            if(!sv.isEmpty())
+            {
+                m_characters += sv;
+                m_hasCharacters = true;
+            }
+        }
+    }
+    else
+        sendAsNode(it);
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::startElement(const QXmlName &name)
+{
+    startElement(name, 1, 1);
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::startElement(const QXmlName &name, qint64 line, qint64 column)
+{
+    startStructure();
+
+    AccelTree::BasicNodeData data(currentDepth(), currentParent(), QXmlNodeModelIndex::Element, -1, name);
+    m_document->basicData.append(data);
+    if (m_features & SourceLocationsFeature)
+        m_document->sourcePositions.insert(m_document->maximumPreNumber(), qMakePair(line, column));
+
+    ++m_preNumber;
+    m_ancestors.push(m_preNumber);
+
+    ++m_size.top();
+    m_size.push(0);
+
+    /* With node constructors, we can receive names for which we have no namespace
+     * constructors, such as in the query '<xs:space/>'. Since the 'xs' prefix has no
+     * NamespaceConstructor in this case, we synthesize the namespace.
+     *
+     * In case we're constructing from an XML document we avoid the call because
+     * although it's redundant, it's on extra virtual call for each element. */
+    if(!FromDocument)
+        namespaceBinding(QXmlName(name.namespaceURI(), 0, name.prefix()));
+
+    m_isPreviousAtomic = false;
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::endElement()
+{
+    startStructure();
+    const AccelTree::PreNumber index = m_ancestors.pop();
+    AccelTree::BasicNodeData &data = m_document->basicData[index];
+
+    /* Sub trees needs to be included in upper trees, so we add the count of this element
+     * to our parent. */
+    m_size[m_size.count() - 2] += m_size.top();
+
+    data.setSize(m_size.pop());
+    m_isPreviousAtomic = false;
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::attribute(const QXmlName &name, const QStringRef &value)
+{
+    /* Attributes adds a namespace binding, so lets synthesize one.
+     *
+     * We optimize by checking whether we have a namespace for which a binding would
+     * be generated. Happens relatively rarely. */
+    if(name.hasPrefix())
+        namespaceBinding(QXmlName(name.namespaceURI(), 0, name.prefix()));
+
+    m_document->basicData.append(AccelTree::BasicNodeData(currentDepth(), currentParent(), QXmlNodeModelIndex::Attribute, 0, name));
+    ++m_preNumber;
+    ++m_size.top();
+
+    m_isPreviousAtomic = false;
+
+    if(name.namespaceURI() == StandardNamespaces::xml && name.localName() == StandardLocalNames::id)
+    {
+        const QString normalized(value.toString().simplified());
+
+        if(QXmlUtils::isNCName(normalized))
+        {
+            const QXmlName::LocalNameCode id = m_namePool->allocateLocalName(normalized);
+
+            const int oldSize = m_document->m_IDs.count();
+            m_document->m_IDs.insert(id, currentParent());
+            /* We don't run the value through m_attributeCompress here, because
+             * the likelyhood of it deing identical to another attribute is
+             * very small. */
+            m_document->data.insert(m_preNumber, normalized);
+
+            /**
+             * In the case that we're called for doc-available(), m_context is
+             * null, and we need to flag somehow that we failed to load this
+             * document.
+             */
+            if(oldSize == m_document->m_IDs.count() && m_context) // TODO
+            {
+                Q_ASSERT(m_context);
+                m_context->error(QtXmlPatterns::tr("An %1-attribute with value %2 has already been declared.")
+                                                   .arg(formatKeyword("xml:id"),
+                                                        formatData(normalized)),
+                                 FromDocument ? ReportContext::FODC0002 : ReportContext::XQDY0091,
+                                 this);
+            }
+        }
+        else if(m_context) // TODO
+        {
+            Q_ASSERT(m_context);
+
+            /* If we're building from an XML Document(e.g, we're fed from QXmlStreamReader, we raise FODC0002,
+             * otherwise XQDY0091. */
+            m_context->error(QtXmlPatterns::tr("An %1-attribute must have a "
+                                               "valid %2 as value, which %3 isn't.").arg(formatKeyword("xml:id"),
+                                                                                         formatType(m_namePool, BuiltinTypes::xsNCName),
+                                                                                         formatData(value.toString())),
+                             FromDocument ? ReportContext::FODC0002 : ReportContext::XQDY0091,
+                             this);
+        }
+    }
+    else
+        m_document->data.insert(m_preNumber, *m_attributeCompress.insert(value.toString()));
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::characters(const QStringRef &ch)
+{
+
+    /* If a text node constructor appears by itself, a node needs to
+     * be created. Therefore, we set m_hasCharacters
+     * if we're the only node.
+     * However, if the text node appears as a child of a document or element
+     * node it is discarded if it's empty.
+     */
+    if(m_hasCharacters && m_isCharactersCompressed)
+    {
+        m_characters = CompressedWhitespace::decompress(m_characters);
+        m_isCharactersCompressed = false;
+    }
+
+    m_characters += ch;
+
+    m_isPreviousAtomic = false;
+    m_hasCharacters = !m_characters.isEmpty() || m_preNumber == -1; /* -1 is our start value. */
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::whitespaceOnly(const QStringRef &ch)
+{
+    Q_ASSERT(!ch.isEmpty());
+    Q_ASSERT(ch.toString().trimmed().isEmpty());
+
+    /* This gets problematic due to how QXmlStreamReader works(which
+     * is the only one we get whitespaceOnly() events from). Namely, text intermingled
+     * with CDATA gets reported as individual Characters events, and
+     * QXmlStreamReader::isWhitespace() can return differently for each of those. However,
+     * it will occur very rarely, so this workaround of 1) mistakenly compressing 2) decompressing 3)
+     * appending, will happen infrequently.
+     */
+    if(m_hasCharacters)
+    {
+        if(m_isCharactersCompressed)
+        {
+            m_characters = CompressedWhitespace::decompress(m_characters);
+            m_isCharactersCompressed = false;
+        }
+
+        m_characters.append(ch.toString());
+    }
+    else
+    {
+        /* We haven't received a text node previously. */
+        m_characters = CompressedWhitespace::compress(ch);
+        m_isCharactersCompressed = true;
+        m_isPreviousAtomic = false;
+        m_hasCharacters = true;
+    }
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::processingInstruction(const QXmlName &target,
+                                                           const QString &data)
+{
+    startStructure();
+    ++m_preNumber;
+    m_document->data.insert(m_preNumber, data);
+
+    m_document->basicData.append(AccelTree::BasicNodeData(currentDepth(),
+                                                          currentParent(),
+                                                          QXmlNodeModelIndex::ProcessingInstruction,
+                                                          0,
+                                                          target));
+    ++m_size.top();
+    m_isPreviousAtomic = false;
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::comment(const QString &content)
+{
+    startStructure();
+    m_document->basicData.append(AccelTree::BasicNodeData(currentDepth(), currentParent(), QXmlNodeModelIndex::Comment, 0));
+    ++m_preNumber;
+    m_document->data.insert(m_preNumber, content);
+    ++m_size.top();
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::namespaceBinding(const QXmlName &nb)
+{
+    /* Note, because attribute() sometimes generate namespaceBinding() calls, this function
+     * can be called after attributes, in contrast to what the class documentation says. This is ok,
+     * as long as we're not dealing with public API. */
+
+    /* If we've received attributes, it means the element's size have changed and m_preNumber have advanced,
+     * so "reverse back" to the actual element. */
+    const AccelTree::PreNumber pn = m_preNumber - m_size.top();
+
+    QVector<QXmlName> &nss = m_document->namespaces[pn];
+
+    /* "xml" hasn't been declared for each node, AccelTree::namespaceBindings() adds it, so avoid it
+     * such that we don't get duplicates. */
+    if(nb.prefix() == StandardPrefixes::xml)
+        return;
+
+    /* If we already have the binding, skip it. */
+    const int len = nss.count();
+    for(int i = 0; i < len; ++i)
+    {
+        if(nss.at(i).prefix() == nb.prefix())
+            return;
+    }
+
+    nss.append(nb);
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::startDocument()
+{
+    /* If we have already received nodes, we can't add a document node. */
+    if(m_preNumber == -1) /* -1 is our start value. */
+    {
+        m_size.push(0);
+        m_document->basicData.append(AccelTree::BasicNodeData(0, -1, QXmlNodeModelIndex::Document, -1));
+        ++m_preNumber;
+        m_ancestors.push(m_preNumber);
+    }
+    else
+        ++m_skippedDocumentNodes;
+
+    m_isPreviousAtomic = false;
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::endDocument()
+{
+    if(m_skippedDocumentNodes == 0)
+    {
+        /* Create text nodes, if we've received any. We do this only if we're the
+         * top node because if we're getting this event as being a child of an element,
+         * text nodes or atomic values can appear after us, and which must get
+         * merged with the previous text.
+         *
+         * We call startStructure() before we pop the ancestor, such that the text node becomes
+         * a child of this document node. */
+        startStructure();
+
+        m_document->basicData.first().setSize(m_size.pop());
+        m_ancestors.pop();
+    }
+    else
+        --m_skippedDocumentNodes;
+
+    m_isPreviousAtomic = false;
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::atomicValue(const QVariant &value)
+{
+    Q_UNUSED(value);
+    // TODO
+}
+
+template <bool FromDocument>
+QAbstractXmlNodeModel::Ptr AccelTreeBuilder<FromDocument>::builtDocument()
+{
+    /* Create a text node, if we have received text in some way. */
+    startStructure();
+    m_document->printStats(m_namePool);
+
+    return m_document;
+}
+
+template <bool FromDocument>
+NodeBuilder::Ptr AccelTreeBuilder<FromDocument>::create(const QUrl &baseURI) const
+{
+    Q_UNUSED(baseURI);
+    return NodeBuilder::Ptr(new AccelTreeBuilder(QUrl(), baseURI, m_namePool, m_context));
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::startOfSequence()
+{
+}
+
+template <bool FromDocument>
+void AccelTreeBuilder<FromDocument>::endOfSequence()
+{
+}
+
+template <bool FromDocument>
+const SourceLocationReflection *AccelTreeBuilder<FromDocument>::actualReflection() const
+{
+    return this;
+}
+
+template <bool FromDocument>
+QSourceLocation AccelTreeBuilder<FromDocument>::sourceLocation() const
+{
+    if(m_documentURI.isEmpty())
+        return QSourceLocation(QUrl(QLatin1String("AnonymousNodeTree")));
+    else
+        return QSourceLocation(m_documentURI);
+}
+
diff --git a/src/xmlpatterns/data/qabstractfloat.cpp b/src/xmlpatterns/data/qabstractfloat.cpp
deleted file mode 100644
index 47ac717..0000000
--- a/src/xmlpatterns/data/qabstractfloat.cpp
+++ /dev/null
@@ -1,321 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by qabstractfloat_p.h.
- * If you need includes in this file, put them in qabstractfloat_p.h, outside of the namespace.
- */
-
-template <const bool isDouble>
-AbstractFloat<isDouble>::AbstractFloat(const xsDouble num) : m_value(num)
-{
-}
-
-template <const bool isDouble>
-Numeric::Ptr AbstractFloat<isDouble>::fromValue(const xsDouble num)
-{
-    return Numeric::Ptr(new AbstractFloat<isDouble>(num));
-}
-
-template <const bool isDouble>
-AtomicValue::Ptr AbstractFloat<isDouble>::fromLexical(const QString &strNumeric)
-{
-    /* QString::toDouble() handles the whitespace facet. */
-
-    if(strNumeric == QLatin1String("NaN"))
-        return isDouble ? CommonValues::DoubleNaN : CommonValues::FloatNaN;
-    else if(strNumeric == QLatin1String("-INF"))
-        return isDouble ? CommonValues::NegativeInfDouble : CommonValues::NegativeInfFloat;
-    else if(strNumeric == QLatin1String("INF"))
-        return isDouble ? CommonValues::InfDouble : CommonValues::InfFloat;
-
-    /* QString::toDouble() supports any case as well as +INF, but we don't. */
-    const QString toUpper(strNumeric.toUpper());
-    if(toUpper == QLatin1String("-INF") ||
-       toUpper == QLatin1String("INF")  ||
-       toUpper == QLatin1String("+INF") ||
-       toUpper == QLatin1String("NAN"))
-    {
-        return ValidationError::createError();
-    }
-
-    bool conversionOk = false;
-    const xsDouble num = strNumeric.toDouble(&conversionOk);
-
-    if(conversionOk)
-        return AtomicValue::Ptr(new AbstractFloat<isDouble>(num));
-    else
-        return ValidationError::createError();
-}
-
-template <const bool isDouble>
-int AbstractFloat<isDouble>::internalSignbit(const xsDouble num)
-{
-    Q_ASSERT_X(sizeof(xsDouble) == 8 || sizeof(xsDouble) == 4, Q_FUNC_INFO,
-               "This implementation of signbit assumes xsDouble, that is qreal, is 64 bits large.");
-
-    union
-    {
-        xsDouble asDouble;
-        qint64 asInt;
-    } value;
-
-    value.asDouble = num;
-
-    /* The highest bit, the 64'th for those who have 64bit floats, is the sign bit. So we pull it down until that bit is the
-     * only one left. */
-    if(sizeof(xsDouble) == 8)
-        return value.asInt >> 63;
-    else
-        return value.asInt >> 31;
-}
-
-template <const bool isDouble>
-bool AbstractFloat<isDouble>::isEqual(const xsDouble a, const xsDouble b)
-{
-    if(qIsInf(a))
-        return qIsInf(b) && internalSignbit(a) == internalSignbit(b);
-    else if(qIsInf(b))
-        return qIsInf(a) && internalSignbit(a) == internalSignbit(b);
-    else
-    {
-        /* Preferably, we would use std::numeric_limits<xsDouble>::espilon(), but
-         * we cannot since we cannot depend on the STL. The small xs:double value below,
-         * was extracted by printing the std::numeric_limits<xsDouble>::epsilon() using
-         * gdb. */
-        return qAbs(a - b) <= 2.2204460492503131e-16 * qAbs(a);
-    }
-}
-
-template <const bool isDouble>
-bool AbstractFloat<isDouble>::isZero() const
-{
-    return AbstractFloat<isDouble>::isEqual(m_value, 0.0);
-}
-
-template <const bool isDouble>
-bool AbstractFloat<isDouble>::evaluateEBV(const QExplicitlySharedDataPointer<DynamicContext> &) const
-{
-    if(isZero() || qIsNaN(m_value))
-        return false;
-    else
-        return true;
-}
-
-template <const bool isDouble>
-QString AbstractFloat<isDouble>::stringValue() const
-{
-    if(qIsNaN(m_value))
-        return QLatin1String("NaN");
-    else if(qIsInf(m_value))
-        return internalSignbit(m_value) == 0 ? QLatin1String("INF") : QLatin1String("-INF");
-    /*
-     * If SV has an absolute value that is greater than or equal to 0.000001
-     * (one millionth) and less than 1000000 (one million),
-     * then the value is converted to an xs:decimal and the resulting xs:decimal
-     * is converted to an xs:string according to the rules above.
-     */
-    else if(0.000001 <= qAbs(m_value) && qAbs(m_value) < 1000000.0)
-        return Decimal::toString(toDecimal());
-    /*
-     * If SV has the value positive or negative zero, TV is "0" or "-0" respectively.
-     */
-    else if(isZero())
-        return internalSignbit(m_value) == 0 ? QLatin1String("0") : QLatin1String("-0");
-    else
-    {
-        /*
-         * Besides these special values, the general form of the canonical form for
-         * xs:float and xs:double is a mantissa, which is a xs:decimal, followed by
-         * the letter "E", followed by an exponent which is an xs:integer.
-         */
-        int sign;
-        int decimalPoint;
-        char *result = 0;
-        static_cast<void>(qdtoa(m_value, -1, 0, &decimalPoint, &sign, 0, &result));
-
-        /* If the copy constructor is used instead of QString::operator=(),
-         * it doesn't compile. I have no idea why. */
-        const QString qret(QString::fromLatin1(result));
-
-        /* We use free() instead of delete here, because qlocale.cpp use malloc(). Spotted
-         * by valgrind. */
-        free(result);
-
-        QString valueAsString;
-
-        if(sign)
-            valueAsString += QLatin1Char('-');
-
-        valueAsString += qret.at(0);
-        valueAsString += QLatin1Char('.');
-
-        if(1 == qret.size())
-            valueAsString += QLatin1Char('0');
-        else
-            valueAsString += qret.mid(1);
-
-        valueAsString += QLatin1Char('E');
-        decimalPoint--;
-        valueAsString += QString::number(decimalPoint);
-        return valueAsString;
-    }
-}
-
-template <const bool isDouble>
-xsDouble AbstractFloat<isDouble>::toDouble() const
-{
-    return m_value;
-}
-
-template <const bool isDouble>
-xsInteger AbstractFloat<isDouble>::toInteger() const
-{
-    return static_cast<xsInteger>(m_value);
-}
-
-template <const bool isDouble>
-xsFloat AbstractFloat<isDouble>::toFloat() const
-{
-    /* No cast, since xsFloat and xsDouble are typedef'ed with the same type. */
-    return m_value;
-}
-
-template <const bool isDouble>
-xsDecimal AbstractFloat<isDouble>::toDecimal() const
-{
-    return static_cast<xsDecimal>(m_value);
-}
-
-template <const bool isDouble>
-Numeric::Ptr AbstractFloat<isDouble>::round() const
-{
-    return AbstractFloat<isDouble>::fromValue(static_cast<xsDouble>(roundFloat(m_value)));
-}
-
-template <const bool isDouble>
-Numeric::Ptr AbstractFloat<isDouble>::roundHalfToEven(const xsInteger precision) const
-{
-    if(isNaN() || isInf() || isZero())
-        return Numeric::Ptr(const_cast<AbstractFloat<isDouble> *>(this));
-    else
-    {
-        /* The cast to double helps finding the correct pow() version on irix-cc. */
-        const xsDouble powered = pow(double(10), double(precision));
-        xsDouble val = powered * m_value;
-        bool isHalf = false;
-
-        if(val - 0.5 == ::floor(val))
-            isHalf = true;
-
-        val = m_value * powered + 0.5;
-        val = ::floor(val);
-
-        if(isHalf /*&& isOdd(val) or? TODO */)
-            val -= 1;
-
-        val /= powered;
-
-        return fromValue(val);
-    }
-}
-
-template <const bool isDouble>
-Numeric::Ptr AbstractFloat<isDouble>::floor() const
-{
-    return AbstractFloat<isDouble>::fromValue(static_cast<xsDouble>(::floor(m_value)));
-}
-
-template <const bool isDouble>
-Numeric::Ptr AbstractFloat<isDouble>::ceiling() const
-{
-    return AbstractFloat<isDouble>::fromValue(static_cast<xsDouble>(ceil(m_value)));
-}
-
-template <const bool isDouble>
-Numeric::Ptr AbstractFloat<isDouble>::abs() const
-{
-    /* We must use fabs() instead of qAbs() because qAbs()
-     * doesn't return 0 for -0.0. */
-    return AbstractFloat<isDouble>::fromValue(static_cast<xsDouble>(fabs(m_value)));
-}
-
-template <const bool isDouble>
-bool AbstractFloat<isDouble>::isNaN() const
-{
-    return qIsNaN(m_value);
-}
-
-template <const bool isDouble>
-bool AbstractFloat<isDouble>::isInf() const
-{
-    return qIsInf(m_value);
-}
-
-template <const bool isDouble>
-ItemType::Ptr AbstractFloat<isDouble>::type() const
-{
-    return isDouble ? BuiltinTypes::xsDouble : BuiltinTypes::xsFloat;
-}
-
-template <const bool isDouble>
-Item AbstractFloat<isDouble>::toNegated() const
-{
-    return fromValue(-m_value).data();
-}
-
-template <const bool isDouble>
-bool AbstractFloat<isDouble>::isSigned() const
-{
-    Q_ASSERT_X(false, Q_FUNC_INFO,
-               "It makes no sense to call this function, see Numeric::isSigned().");
-    return false;
-}
-
-template <const bool isDouble>
-qulonglong AbstractFloat<isDouble>::toUnsignedInteger() const
-{
-    Q_ASSERT_X(false, Q_FUNC_INFO,
-               "It makes no sense to call this function, see Numeric::toUnsignedInteger().");
-    return 0;
-}
-
diff --git a/src/xmlpatterns/data/qabstractfloat_p.h b/src/xmlpatterns/data/qabstractfloat_p.h
index 30fa72c..2c73251 100644
--- a/src/xmlpatterns/data/qabstractfloat_p.h
+++ b/src/xmlpatterns/data/qabstractfloat_p.h
@@ -150,7 +150,7 @@ namespace QPatternist
     template <const bool isDouble>
     Numeric::Ptr createFloat(const xsDouble num);
 
-#include "qabstractfloat.cpp"
+#include "qabstractfloat_tpl_p.h"
 
     /**
      * @short An instantiation of AbsbstractFloat suitable for @c xs:double.
diff --git a/src/xmlpatterns/data/qabstractfloat_tpl_p.h b/src/xmlpatterns/data/qabstractfloat_tpl_p.h
new file mode 100644
index 0000000..47ac717
--- /dev/null
+++ b/src/xmlpatterns/data/qabstractfloat_tpl_p.h
@@ -0,0 +1,321 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by qabstractfloat_p.h.
+ * If you need includes in this file, put them in qabstractfloat_p.h, outside of the namespace.
+ */
+
+template <const bool isDouble>
+AbstractFloat<isDouble>::AbstractFloat(const xsDouble num) : m_value(num)
+{
+}
+
+template <const bool isDouble>
+Numeric::Ptr AbstractFloat<isDouble>::fromValue(const xsDouble num)
+{
+    return Numeric::Ptr(new AbstractFloat<isDouble>(num));
+}
+
+template <const bool isDouble>
+AtomicValue::Ptr AbstractFloat<isDouble>::fromLexical(const QString &strNumeric)
+{
+    /* QString::toDouble() handles the whitespace facet. */
+
+    if(strNumeric == QLatin1String("NaN"))
+        return isDouble ? CommonValues::DoubleNaN : CommonValues::FloatNaN;
+    else if(strNumeric == QLatin1String("-INF"))
+        return isDouble ? CommonValues::NegativeInfDouble : CommonValues::NegativeInfFloat;
+    else if(strNumeric == QLatin1String("INF"))
+        return isDouble ? CommonValues::InfDouble : CommonValues::InfFloat;
+
+    /* QString::toDouble() supports any case as well as +INF, but we don't. */
+    const QString toUpper(strNumeric.toUpper());
+    if(toUpper == QLatin1String("-INF") ||
+       toUpper == QLatin1String("INF")  ||
+       toUpper == QLatin1String("+INF") ||
+       toUpper == QLatin1String("NAN"))
+    {
+        return ValidationError::createError();
+    }
+
+    bool conversionOk = false;
+    const xsDouble num = strNumeric.toDouble(&conversionOk);
+
+    if(conversionOk)
+        return AtomicValue::Ptr(new AbstractFloat<isDouble>(num));
+    else
+        return ValidationError::createError();
+}
+
+template <const bool isDouble>
+int AbstractFloat<isDouble>::internalSignbit(const xsDouble num)
+{
+    Q_ASSERT_X(sizeof(xsDouble) == 8 || sizeof(xsDouble) == 4, Q_FUNC_INFO,
+               "This implementation of signbit assumes xsDouble, that is qreal, is 64 bits large.");
+
+    union
+    {
+        xsDouble asDouble;
+        qint64 asInt;
+    } value;
+
+    value.asDouble = num;
+
+    /* The highest bit, the 64'th for those who have 64bit floats, is the sign bit. So we pull it down until that bit is the
+     * only one left. */
+    if(sizeof(xsDouble) == 8)
+        return value.asInt >> 63;
+    else
+        return value.asInt >> 31;
+}
+
+template <const bool isDouble>
+bool AbstractFloat<isDouble>::isEqual(const xsDouble a, const xsDouble b)
+{
+    if(qIsInf(a))
+        return qIsInf(b) && internalSignbit(a) == internalSignbit(b);
+    else if(qIsInf(b))
+        return qIsInf(a) && internalSignbit(a) == internalSignbit(b);
+    else
+    {
+        /* Preferably, we would use std::numeric_limits<xsDouble>::espilon(), but
+         * we cannot since we cannot depend on the STL. The small xs:double value below,
+         * was extracted by printing the std::numeric_limits<xsDouble>::epsilon() using
+         * gdb. */
+        return qAbs(a - b) <= 2.2204460492503131e-16 * qAbs(a);
+    }
+}
+
+template <const bool isDouble>
+bool AbstractFloat<isDouble>::isZero() const
+{
+    return AbstractFloat<isDouble>::isEqual(m_value, 0.0);
+}
+
+template <const bool isDouble>
+bool AbstractFloat<isDouble>::evaluateEBV(const QExplicitlySharedDataPointer<DynamicContext> &) const
+{
+    if(isZero() || qIsNaN(m_value))
+        return false;
+    else
+        return true;
+}
+
+template <const bool isDouble>
+QString AbstractFloat<isDouble>::stringValue() const
+{
+    if(qIsNaN(m_value))
+        return QLatin1String("NaN");
+    else if(qIsInf(m_value))
+        return internalSignbit(m_value) == 0 ? QLatin1String("INF") : QLatin1String("-INF");
+    /*
+     * If SV has an absolute value that is greater than or equal to 0.000001
+     * (one millionth) and less than 1000000 (one million),
+     * then the value is converted to an xs:decimal and the resulting xs:decimal
+     * is converted to an xs:string according to the rules above.
+     */
+    else if(0.000001 <= qAbs(m_value) && qAbs(m_value) < 1000000.0)
+        return Decimal::toString(toDecimal());
+    /*
+     * If SV has the value positive or negative zero, TV is "0" or "-0" respectively.
+     */
+    else if(isZero())
+        return internalSignbit(m_value) == 0 ? QLatin1String("0") : QLatin1String("-0");
+    else
+    {
+        /*
+         * Besides these special values, the general form of the canonical form for
+         * xs:float and xs:double is a mantissa, which is a xs:decimal, followed by
+         * the letter "E", followed by an exponent which is an xs:integer.
+         */
+        int sign;
+        int decimalPoint;
+        char *result = 0;
+        static_cast<void>(qdtoa(m_value, -1, 0, &decimalPoint, &sign, 0, &result));
+
+        /* If the copy constructor is used instead of QString::operator=(),
+         * it doesn't compile. I have no idea why. */
+        const QString qret(QString::fromLatin1(result));
+
+        /* We use free() instead of delete here, because qlocale.cpp use malloc(). Spotted
+         * by valgrind. */
+        free(result);
+
+        QString valueAsString;
+
+        if(sign)
+            valueAsString += QLatin1Char('-');
+
+        valueAsString += qret.at(0);
+        valueAsString += QLatin1Char('.');
+
+        if(1 == qret.size())
+            valueAsString += QLatin1Char('0');
+        else
+            valueAsString += qret.mid(1);
+
+        valueAsString += QLatin1Char('E');
+        decimalPoint--;
+        valueAsString += QString::number(decimalPoint);
+        return valueAsString;
+    }
+}
+
+template <const bool isDouble>
+xsDouble AbstractFloat<isDouble>::toDouble() const
+{
+    return m_value;
+}
+
+template <const bool isDouble>
+xsInteger AbstractFloat<isDouble>::toInteger() const
+{
+    return static_cast<xsInteger>(m_value);
+}
+
+template <const bool isDouble>
+xsFloat AbstractFloat<isDouble>::toFloat() const
+{
+    /* No cast, since xsFloat and xsDouble are typedef'ed with the same type. */
+    return m_value;
+}
+
+template <const bool isDouble>
+xsDecimal AbstractFloat<isDouble>::toDecimal() const
+{
+    return static_cast<xsDecimal>(m_value);
+}
+
+template <const bool isDouble>
+Numeric::Ptr AbstractFloat<isDouble>::round() const
+{
+    return AbstractFloat<isDouble>::fromValue(static_cast<xsDouble>(roundFloat(m_value)));
+}
+
+template <const bool isDouble>
+Numeric::Ptr AbstractFloat<isDouble>::roundHalfToEven(const xsInteger precision) const
+{
+    if(isNaN() || isInf() || isZero())
+        return Numeric::Ptr(const_cast<AbstractFloat<isDouble> *>(this));
+    else
+    {
+        /* The cast to double helps finding the correct pow() version on irix-cc. */
+        const xsDouble powered = pow(double(10), double(precision));
+        xsDouble val = powered * m_value;
+        bool isHalf = false;
+
+        if(val - 0.5 == ::floor(val))
+            isHalf = true;
+
+        val = m_value * powered + 0.5;
+        val = ::floor(val);
+
+        if(isHalf /*&& isOdd(val) or? TODO */)
+            val -= 1;
+
+        val /= powered;
+
+        return fromValue(val);
+    }
+}
+
+template <const bool isDouble>
+Numeric::Ptr AbstractFloat<isDouble>::floor() const
+{
+    return AbstractFloat<isDouble>::fromValue(static_cast<xsDouble>(::floor(m_value)));
+}
+
+template <const bool isDouble>
+Numeric::Ptr AbstractFloat<isDouble>::ceiling() const
+{
+    return AbstractFloat<isDouble>::fromValue(static_cast<xsDouble>(ceil(m_value)));
+}
+
+template <const bool isDouble>
+Numeric::Ptr AbstractFloat<isDouble>::abs() const
+{
+    /* We must use fabs() instead of qAbs() because qAbs()
+     * doesn't return 0 for -0.0. */
+    return AbstractFloat<isDouble>::fromValue(static_cast<xsDouble>(fabs(m_value)));
+}
+
+template <const bool isDouble>
+bool AbstractFloat<isDouble>::isNaN() const
+{
+    return qIsNaN(m_value);
+}
+
+template <const bool isDouble>
+bool AbstractFloat<isDouble>::isInf() const
+{
+    return qIsInf(m_value);
+}
+
+template <const bool isDouble>
+ItemType::Ptr AbstractFloat<isDouble>::type() const
+{
+    return isDouble ? BuiltinTypes::xsDouble : BuiltinTypes::xsFloat;
+}
+
+template <const bool isDouble>
+Item AbstractFloat<isDouble>::toNegated() const
+{
+    return fromValue(-m_value).data();
+}
+
+template <const bool isDouble>
+bool AbstractFloat<isDouble>::isSigned() const
+{
+    Q_ASSERT_X(false, Q_FUNC_INFO,
+               "It makes no sense to call this function, see Numeric::isSigned().");
+    return false;
+}
+
+template <const bool isDouble>
+qulonglong AbstractFloat<isDouble>::toUnsignedInteger() const
+{
+    Q_ASSERT_X(false, Q_FUNC_INFO,
+               "It makes no sense to call this function, see Numeric::toUnsignedInteger().");
+    return 0;
+}
+
diff --git a/src/xmlpatterns/data/qabstractfloatcasters.cpp b/src/xmlpatterns/data/qabstractfloatcasters.cpp
deleted file mode 100644
index f805092..0000000
--- a/src/xmlpatterns/data/qabstractfloatcasters.cpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*
- * NOTE: This file is included by qabstractfloatcasters_p.h
- * if you need some includes, put them in qabstractfloatcasters_p.h (outside of the namespace)
- */
-
-template <const bool isDouble>
-Item NumericToAbstractFloatCaster<isDouble>::castFrom(const Item &from,
-                                                           const QExplicitlySharedDataPointer<DynamicContext> &) const
-{
-    // toDouble() returns same thing than toFloat()
-    return toItem(AbstractFloat<isDouble>::fromValue(from.template as<Numeric>()->toDouble()));
-}
-
-template <const bool isDouble>
-Item StringToAbstractFloatCaster<isDouble>::castFrom(const Item &from,
-                                                          const QExplicitlySharedDataPointer<DynamicContext> &) const
-{
-    return toItem(AbstractFloat<isDouble>::fromLexical(from.stringValue()));
-}
-
-template <const bool isDouble>
-Item BooleanToAbstractFloatCaster<isDouble>::castFrom(const Item &from,
-                                                           const QExplicitlySharedDataPointer<DynamicContext> &context) const
-{
-    // RVCT doesn't like using template parameter in trinary operator when the trinary operator result is
-    // passed directly into another constructor. 
-    bool tempDouble = isDouble;
-    if(from.template as<AtomicValue>()->evaluateEBV(context))
-        return tempDouble ? toItem(CommonValues::DoubleOne) : toItem(CommonValues::FloatOne);
-    else
-        return tempDouble ? toItem(CommonValues::DoubleZero) : toItem(CommonValues::FloatZero);
-}
-
diff --git a/src/xmlpatterns/data/qabstractfloatcasters_p.h b/src/xmlpatterns/data/qabstractfloatcasters_p.h
index d0fa859..ab61924 100644
--- a/src/xmlpatterns/data/qabstractfloatcasters_p.h
+++ b/src/xmlpatterns/data/qabstractfloatcasters_p.h
@@ -113,7 +113,7 @@ namespace QPatternist
                                   const QExplicitlySharedDataPointer<DynamicContext> &context) const;
     };
 
-#include "qabstractfloatcasters.cpp"
+#include "qabstractfloatcasters_tpl_p.h"
 
    /**
     * @short Casts a @c numeric value, such as @c xs:integer or @c xs:float, to @c xs:double.
diff --git a/src/xmlpatterns/data/qabstractfloatcasters_tpl_p.h b/src/xmlpatterns/data/qabstractfloatcasters_tpl_p.h
new file mode 100644
index 0000000..f805092
--- /dev/null
+++ b/src/xmlpatterns/data/qabstractfloatcasters_tpl_p.h
@@ -0,0 +1,74 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*
+ * NOTE: This file is included by qabstractfloatcasters_p.h
+ * if you need some includes, put them in qabstractfloatcasters_p.h (outside of the namespace)
+ */
+
+template <const bool isDouble>
+Item NumericToAbstractFloatCaster<isDouble>::castFrom(const Item &from,
+                                                           const QExplicitlySharedDataPointer<DynamicContext> &) const
+{
+    // toDouble() returns same thing than toFloat()
+    return toItem(AbstractFloat<isDouble>::fromValue(from.template as<Numeric>()->toDouble()));
+}
+
+template <const bool isDouble>
+Item StringToAbstractFloatCaster<isDouble>::castFrom(const Item &from,
+                                                          const QExplicitlySharedDataPointer<DynamicContext> &) const
+{
+    return toItem(AbstractFloat<isDouble>::fromLexical(from.stringValue()));
+}
+
+template <const bool isDouble>
+Item BooleanToAbstractFloatCaster<isDouble>::castFrom(const Item &from,
+                                                           const QExplicitlySharedDataPointer<DynamicContext> &context) const
+{
+    // RVCT doesn't like using template parameter in trinary operator when the trinary operator result is
+    // passed directly into another constructor. 
+    bool tempDouble = isDouble;
+    if(from.template as<AtomicValue>()->evaluateEBV(context))
+        return tempDouble ? toItem(CommonValues::DoubleOne) : toItem(CommonValues::FloatOne);
+    else
+        return tempDouble ? toItem(CommonValues::DoubleZero) : toItem(CommonValues::FloatZero);
+}
+
diff --git a/src/xmlpatterns/data/qabstractfloatmathematician.cpp b/src/xmlpatterns/data/qabstractfloatmathematician.cpp
deleted file mode 100644
index d2e3b85..0000000
--- a/src/xmlpatterns/data/qabstractfloatmathematician.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*
- * @file
- * @short This file is included by qatomicmathematicians_p.h
- * if you need some includes, put them in qabstractfloatmathematician_p.h, outside of the namespace.
- */
-
-template <const bool isDouble>
-Item AbstractFloatMathematician<isDouble>::calculate(const Item &o1,
-                                                          const Operator op,
-                                                          const Item &o2,
-                                                          const QExplicitlySharedDataPointer<DynamicContext> &context) const
-{
-    const Numeric *const num1 = o1.template as<Numeric>();
-    const Numeric *const num2 = o2.template as<Numeric>();
-    switch(op)
-    {
-        case Div:
-            return toItem(AbstractFloat<isDouble>::fromValue(num1->toDouble() / num2->toDouble()));
-        case IDiv:
-        {
-            if(num1->isNaN() || num2->isNaN())
-            {
-                context->error(QtXmlPatterns::tr("No operand in an integer division, %1, can be %2.")
-                                  .arg(formatKeyword("idiv"))
-                                  .arg(formatData("NaN")),
-                               ReportContext::FOAR0002, this);
-            }
-            else if(num1->isInf())
-            {
-                context->error(QtXmlPatterns::tr("The first operand in an integer division, %1, cannot be infinity (%2).")
-                                                 .arg(formatKeyword("idiv"))
-                                                 .arg(formatData("INF")),
-                               ReportContext::FOAR0002, this);
-            }
-            else if(num2->toInteger() == 0)
-                context->error(QtXmlPatterns::tr("The second operand in a division, %1, cannot be zero (%2).")
-                                                 .arg(formatKeyword("idiv"))
-                                                 .arg(formatData("0")),
-                               ReportContext::FOAR0001, this);
-
-            return Integer::fromValue(static_cast<xsInteger>(num1->toDouble() / num2->toDouble()));
-        }
-        case Substract:
-            return toItem(AbstractFloat<isDouble>::fromValue(num1->toDouble() - num2->toDouble()));
-        case Mod:
-            return toItem(AbstractFloat<isDouble>::fromValue(::fmod(num1->toDouble(), num2->toDouble())));
-        case Multiply:
-            return toItem(AbstractFloat<isDouble>::fromValue(num1->toDouble() * num2->toDouble()));
-        case Add:
-            return toItem(AbstractFloat<isDouble>::fromValue(num1->toDouble() + num2->toDouble()));
-    }
-
-    Q_ASSERT(false);
-    return Item(); /* GCC unbarfer. */
-}
-
diff --git a/src/xmlpatterns/data/qabstractfloatmathematician_p.h b/src/xmlpatterns/data/qabstractfloatmathematician_p.h
index 6fa15ac..e2308b8 100644
--- a/src/xmlpatterns/data/qabstractfloatmathematician_p.h
+++ b/src/xmlpatterns/data/qabstractfloatmathematician_p.h
@@ -85,7 +85,7 @@ namespace QPatternist
                                     const QExplicitlySharedDataPointer<DynamicContext> &context) const;
     };
 
-#include "qabstractfloatmathematician.cpp"
+#include "qabstractfloatmathematician_tpl_p.h"
 
     /**
      * An instantiation of AbstractFloatMathematician that handles @c xs:double.
diff --git a/src/xmlpatterns/data/qabstractfloatmathematician_tpl_p.h b/src/xmlpatterns/data/qabstractfloatmathematician_tpl_p.h
new file mode 100644
index 0000000..d2e3b85
--- /dev/null
+++ b/src/xmlpatterns/data/qabstractfloatmathematician_tpl_p.h
@@ -0,0 +1,97 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*
+ * @file
+ * @short This file is included by qatomicmathematicians_p.h
+ * if you need some includes, put them in qabstractfloatmathematician_p.h, outside of the namespace.
+ */
+
+template <const bool isDouble>
+Item AbstractFloatMathematician<isDouble>::calculate(const Item &o1,
+                                                          const Operator op,
+                                                          const Item &o2,
+                                                          const QExplicitlySharedDataPointer<DynamicContext> &context) const
+{
+    const Numeric *const num1 = o1.template as<Numeric>();
+    const Numeric *const num2 = o2.template as<Numeric>();
+    switch(op)
+    {
+        case Div:
+            return toItem(AbstractFloat<isDouble>::fromValue(num1->toDouble() / num2->toDouble()));
+        case IDiv:
+        {
+            if(num1->isNaN() || num2->isNaN())
+            {
+                context->error(QtXmlPatterns::tr("No operand in an integer division, %1, can be %2.")
+                                  .arg(formatKeyword("idiv"))
+                                  .arg(formatData("NaN")),
+                               ReportContext::FOAR0002, this);
+            }
+            else if(num1->isInf())
+            {
+                context->error(QtXmlPatterns::tr("The first operand in an integer division, %1, cannot be infinity (%2).")
+                                                 .arg(formatKeyword("idiv"))
+                                                 .arg(formatData("INF")),
+                               ReportContext::FOAR0002, this);
+            }
+            else if(num2->toInteger() == 0)
+                context->error(QtXmlPatterns::tr("The second operand in a division, %1, cannot be zero (%2).")
+                                                 .arg(formatKeyword("idiv"))
+                                                 .arg(formatData("0")),
+                               ReportContext::FOAR0001, this);
+
+            return Integer::fromValue(static_cast<xsInteger>(num1->toDouble() / num2->toDouble()));
+        }
+        case Substract:
+            return toItem(AbstractFloat<isDouble>::fromValue(num1->toDouble() - num2->toDouble()));
+        case Mod:
+            return toItem(AbstractFloat<isDouble>::fromValue(::fmod(num1->toDouble(), num2->toDouble())));
+        case Multiply:
+            return toItem(AbstractFloat<isDouble>::fromValue(num1->toDouble() * num2->toDouble()));
+        case Add:
+            return toItem(AbstractFloat<isDouble>::fromValue(num1->toDouble() + num2->toDouble()));
+    }
+
+    Q_ASSERT(false);
+    return Item(); /* GCC unbarfer. */
+}
+
diff --git a/src/xmlpatterns/environment/qstackcontextbase.cpp b/src/xmlpatterns/environment/qstackcontextbase.cpp
deleted file mode 100644
index a422182..0000000
--- a/src/xmlpatterns/environment/qstackcontextbase.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by qstackcontextbase_p.h.
- * If you need includes in this file, put them in qstackcontextbase_p.h, outside of the namespace.
- */
-
-template<typename TSuperClass>
-StackContextBase<TSuperClass>::StackContextBase() : m_rangeVariables(10),
-                                                    m_expressionVariables(10),
-                                                    m_positionIterators(5),
-                                                    m_itemCacheCells(5),
-                                                    m_itemSequenceCacheCells(5)
-{
-    /* The m_* containers are initialized with default sizes. Estimated guesses on usage patterns. */
-}
-
-template<typename TSuperClass>
-StackContextBase<TSuperClass>::StackContextBase(const DynamicContext::Ptr &prevContext)
-                                                : TSuperClass(prevContext),
-                                                  m_rangeVariables(10),
-                                                  m_expressionVariables(10),
-                                                  m_positionIterators(5),
-                                                  m_itemCacheCells(5),
-                                                  m_itemSequenceCacheCells(5)
-{
-    Q_ASSERT(prevContext);
-}
-
-template<typename TSuperClass>
-ItemCacheCell &StackContextBase<TSuperClass>::itemCacheCell(const VariableSlotID slot)
-{
-    if(slot >= m_itemCacheCells.size())
-        m_itemCacheCells.resize(qMax(slot + 1, m_itemCacheCells.size()));
-
-    return m_itemCacheCells[slot];
-}
-
-template<typename TSuperClass>
-ItemSequenceCacheCell::Vector &StackContextBase<TSuperClass>::itemSequenceCacheCells(const VariableSlotID slot)
-{
-    if(slot >= m_itemSequenceCacheCells.size())
-        m_itemSequenceCacheCells.resize(qMax(slot + 1, m_itemSequenceCacheCells.size()));
-
-    return m_itemSequenceCacheCells;
-}
-
-template<typename TSuperClass>
-Item StackContextBase<TSuperClass>::rangeVariable(const VariableSlotID slot) const
-{
-    Q_ASSERT(slot < m_rangeVariables.size());
-    Q_ASSERT(m_rangeVariables.at(slot));
-    return m_rangeVariables.at(slot);
-}
-
-template<typename TSuperClass>
-Expression::Ptr StackContextBase<TSuperClass>::expressionVariable(const VariableSlotID slot) const
-{
-    Q_ASSERT(slot < m_expressionVariables.size());
-    Q_ASSERT(m_expressionVariables.at(slot));
-    return m_expressionVariables.at(slot);
-}
-
-template<typename TSuperClass>
-Item::Iterator::Ptr StackContextBase<TSuperClass>::positionIterator(const VariableSlotID slot) const
-{
-    Q_ASSERT(slot < m_positionIterators.size());
-    return m_positionIterators.at(slot);
-}
-
-template<typename TSuperClass>
-template<typename VectorType, typename UnitType>
-inline
-void StackContextBase<TSuperClass>::setSlotVariable(const VariableSlotID slot,
-                                                    const UnitType &newValue,
-                                                    VectorType &container) const
-{
-    if(slot < container.size())
-        container.replace(slot, newValue);
-    else
-    {
-        container.resize(slot + 1);
-        container.replace(slot, newValue);
-    }
-}
-
-template<typename TSuperClass>
-void StackContextBase<TSuperClass>::setRangeVariable(const VariableSlotID slot,
-                                                     const Item &newValue)
-{
-    setSlotVariable(slot, newValue, m_rangeVariables);
-}
-
-template<typename TSuperClass>
-void StackContextBase<TSuperClass>::setExpressionVariable(const VariableSlotID slot,
-                                                          const Expression::Ptr &newValue)
-{
-    setSlotVariable(slot, newValue, m_expressionVariables);
-}
-
-template<typename TSuperClass>
-void StackContextBase<TSuperClass>::setPositionIterator(const VariableSlotID slot,
-                                                        const Item::Iterator::Ptr &newValue)
-{
-    setSlotVariable(slot, newValue, m_positionIterators);
-}
-
-template<typename TSuperClass>
-DynamicContext::TemplateParameterHash &StackContextBase<TSuperClass>::templateParameterStore()
-{
-    return m_templateParameterStore;
-}
-
diff --git a/src/xmlpatterns/environment/qstackcontextbase_p.h b/src/xmlpatterns/environment/qstackcontextbase_p.h
index 8d04b97..043aaf0 100644
--- a/src/xmlpatterns/environment/qstackcontextbase_p.h
+++ b/src/xmlpatterns/environment/qstackcontextbase_p.h
@@ -119,7 +119,7 @@ namespace QPatternist
         DynamicContext::TemplateParameterHash   m_templateParameterStore;
     };
 
-    #include "qstackcontextbase.cpp"
+    #include "qstackcontextbase_tpl_p.h"
 
     /**
      * @short A DynamicContext that creates a new scope for variables.
diff --git a/src/xmlpatterns/environment/qstackcontextbase_tpl_p.h b/src/xmlpatterns/environment/qstackcontextbase_tpl_p.h
new file mode 100644
index 0000000..a422182
--- /dev/null
+++ b/src/xmlpatterns/environment/qstackcontextbase_tpl_p.h
@@ -0,0 +1,153 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by qstackcontextbase_p.h.
+ * If you need includes in this file, put them in qstackcontextbase_p.h, outside of the namespace.
+ */
+
+template<typename TSuperClass>
+StackContextBase<TSuperClass>::StackContextBase() : m_rangeVariables(10),
+                                                    m_expressionVariables(10),
+                                                    m_positionIterators(5),
+                                                    m_itemCacheCells(5),
+                                                    m_itemSequenceCacheCells(5)
+{
+    /* The m_* containers are initialized with default sizes. Estimated guesses on usage patterns. */
+}
+
+template<typename TSuperClass>
+StackContextBase<TSuperClass>::StackContextBase(const DynamicContext::Ptr &prevContext)
+                                                : TSuperClass(prevContext),
+                                                  m_rangeVariables(10),
+                                                  m_expressionVariables(10),
+                                                  m_positionIterators(5),
+                                                  m_itemCacheCells(5),
+                                                  m_itemSequenceCacheCells(5)
+{
+    Q_ASSERT(prevContext);
+}
+
+template<typename TSuperClass>
+ItemCacheCell &StackContextBase<TSuperClass>::itemCacheCell(const VariableSlotID slot)
+{
+    if(slot >= m_itemCacheCells.size())
+        m_itemCacheCells.resize(qMax(slot + 1, m_itemCacheCells.size()));
+
+    return m_itemCacheCells[slot];
+}
+
+template<typename TSuperClass>
+ItemSequenceCacheCell::Vector &StackContextBase<TSuperClass>::itemSequenceCacheCells(const VariableSlotID slot)
+{
+    if(slot >= m_itemSequenceCacheCells.size())
+        m_itemSequenceCacheCells.resize(qMax(slot + 1, m_itemSequenceCacheCells.size()));
+
+    return m_itemSequenceCacheCells;
+}
+
+template<typename TSuperClass>
+Item StackContextBase<TSuperClass>::rangeVariable(const VariableSlotID slot) const
+{
+    Q_ASSERT(slot < m_rangeVariables.size());
+    Q_ASSERT(m_rangeVariables.at(slot));
+    return m_rangeVariables.at(slot);
+}
+
+template<typename TSuperClass>
+Expression::Ptr StackContextBase<TSuperClass>::expressionVariable(const VariableSlotID slot) const
+{
+    Q_ASSERT(slot < m_expressionVariables.size());
+    Q_ASSERT(m_expressionVariables.at(slot));
+    return m_expressionVariables.at(slot);
+}
+
+template<typename TSuperClass>
+Item::Iterator::Ptr StackContextBase<TSuperClass>::positionIterator(const VariableSlotID slot) const
+{
+    Q_ASSERT(slot < m_positionIterators.size());
+    return m_positionIterators.at(slot);
+}
+
+template<typename TSuperClass>
+template<typename VectorType, typename UnitType>
+inline
+void StackContextBase<TSuperClass>::setSlotVariable(const VariableSlotID slot,
+                                                    const UnitType &newValue,
+                                                    VectorType &container) const
+{
+    if(slot < container.size())
+        container.replace(slot, newValue);
+    else
+    {
+        container.resize(slot + 1);
+        container.replace(slot, newValue);
+    }
+}
+
+template<typename TSuperClass>
+void StackContextBase<TSuperClass>::setRangeVariable(const VariableSlotID slot,
+                                                     const Item &newValue)
+{
+    setSlotVariable(slot, newValue, m_rangeVariables);
+}
+
+template<typename TSuperClass>
+void StackContextBase<TSuperClass>::setExpressionVariable(const VariableSlotID slot,
+                                                          const Expression::Ptr &newValue)
+{
+    setSlotVariable(slot, newValue, m_expressionVariables);
+}
+
+template<typename TSuperClass>
+void StackContextBase<TSuperClass>::setPositionIterator(const VariableSlotID slot,
+                                                        const Item::Iterator::Ptr &newValue)
+{
+    setSlotVariable(slot, newValue, m_positionIterators);
+}
+
+template<typename TSuperClass>
+DynamicContext::TemplateParameterHash &StackContextBase<TSuperClass>::templateParameterStore()
+{
+    return m_templateParameterStore;
+}
+
diff --git a/src/xmlpatterns/expr/qcastingplatform.cpp b/src/xmlpatterns/expr/qcastingplatform.cpp
deleted file mode 100644
index 19f3796..0000000
--- a/src/xmlpatterns/expr/qcastingplatform.cpp
+++ /dev/null
@@ -1,221 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by qcastingplatform_p.h.
- * If you need includes in this file, put them in CasttingPlatform.h, outside of the namespace.
- */
-
-template <typename TSubClass, const bool issueError>
-Item CastingPlatform<TSubClass, issueError>::castWithCaster(const Item &sourceValue,
-                                                            const AtomicCaster::Ptr &caster,
-                                                            const ReportContext::Ptr &context) const
-{
-    Q_ASSERT(sourceValue);
-    Q_ASSERT(caster);
-    Q_ASSERT(context);
-
-    const Item retval(caster->castFrom(sourceValue, context));
-
-    if(issueError)
-    {
-        if(retval.template as<AtomicValue>()->hasError())
-        {
-            issueCastError(retval, sourceValue, context);
-            return Item();
-        }
-        else
-            return retval;
-    }
-    else
-        return retval;
-}
-
-template <typename TSubClass, const bool issueError>
-Item CastingPlatform<TSubClass, issueError>::cast(const Item &sourceValue,
-                                                  const ReportContext::Ptr &context) const
-{
-    Q_ASSERT(sourceValue);
-    Q_ASSERT(context);
-    Q_ASSERT(targetType());
-
-    if(m_caster)
-        return castWithCaster(sourceValue, m_caster, context);
-    else
-    {
-        bool castImpossible = false;
-        const AtomicCaster::Ptr caster(locateCaster(sourceValue.type(), context, castImpossible, static_cast<const TSubClass *>(this), targetType()));
-
-        if(!issueError && castImpossible)
-        {
-            /* If we're supposed to issue an error(issueError) then this
-             * line will never be reached, because locateCaster() will in
-             * that case throw. */
-            return ValidationError::createError();
-        }
-        else
-            return castWithCaster(sourceValue, caster, context);
-    }
-}
-
-template <typename TSubClass, const bool issueError>
-bool CastingPlatform<TSubClass, issueError>::prepareCasting(const ReportContext::Ptr &context,
-                                                            const ItemType::Ptr &sourceType)
-{
-    Q_ASSERT(sourceType);
-    Q_ASSERT(context);
-
-    if(*sourceType == *BuiltinTypes::xsAnyAtomicType ||
-       *sourceType == *BuiltinTypes::item ||
-       *sourceType == *CommonSequenceTypes::Empty ||
-       *sourceType == *BuiltinTypes::numeric)
-        return true; /* The type could not be narrowed better than xs:anyAtomicType
-                        or numeric at compile time. We'll do lookup at runtime instead. */
-
-    bool castImpossible = false;
-    m_caster = locateCaster(sourceType, context, castImpossible, static_cast<const TSubClass *>(this), targetType());
-
-    return !castImpossible;
-}
-
-template <typename TSubClass, const bool issueError>
-AtomicCaster::Ptr CastingPlatform<TSubClass, issueError>::locateCaster(const ItemType::Ptr &sourceType,
-                                                                       const ReportContext::Ptr &context,
-                                                                       bool &castImpossible,
-                                                                       const SourceLocationReflection *const location,
-                                                                       const ItemType::Ptr &targetType)
-{
-    Q_ASSERT(sourceType);
-    Q_ASSERT(targetType);
-
-    const AtomicCasterLocator::Ptr locator(static_cast<AtomicType *>(
-            targetType.data())->casterLocator());
-    if(!locator)
-    {
-        if(issueError)
-        {
-            context->error(QtXmlPatterns::tr("No casting is possible with %1 as the target type.")
-                                        .arg(formatType(context->namePool(), targetType)),
-                                       ReportContext::XPTY0004, location);
-        }
-        else
-            castImpossible = true;
-
-        return AtomicCaster::Ptr();
-    }
-
-    const AtomicCaster::Ptr caster(static_cast<const AtomicType *>(sourceType.data())->accept(locator, location));
-    if(!caster)
-    {
-        if(issueError)
-        {
-            context->error(QtXmlPatterns::tr("It is not possible to cast from %1 to %2.")
-                                            .arg(formatType(context->namePool(), sourceType))
-                                            .arg(formatType(context->namePool(), targetType)),
-                                       ReportContext::XPTY0004, location);
-        }
-        else
-            castImpossible = true;
-
-        return AtomicCaster::Ptr();
-    }
-
-    return caster;
-}
-
-template <typename TSubClass, const bool issueError>
-void CastingPlatform<TSubClass, issueError>::checkTargetType(const ReportContext::Ptr &context) const
-{
-    Q_ASSERT(context);
-
-    const ItemType::Ptr tType(targetType());
-    Q_ASSERT(tType);
-    Q_ASSERT(tType->isAtomicType());
-    const AtomicType::Ptr asAtomic(tType);
-
-    /* This catches casting to xs:NOTATION and xs:anyAtomicType. */
-    if(asAtomic->isAbstract())
-    {
-        context->error(QtXmlPatterns::tr("Casting to %1 is not possible because it "
-                                     "is an abstract type, and can therefore never be instantiated.")
-                                .arg(formatType(context->namePool(), tType)),
-                          ReportContext::XPST0080,
-                          static_cast<const TSubClass*>(this));
-    }
-}
-
-template <typename TSubClass, const bool issueError>
-void CastingPlatform<TSubClass, issueError>::issueCastError(const Item &validationError,
-                                                            const Item &sourceValue,
-                                                            const ReportContext::Ptr &context) const
-{
-    Q_ASSERT(validationError);
-    Q_ASSERT(context);
-    Q_ASSERT(validationError.isAtomicValue());
-    Q_ASSERT(validationError.template as<AtomicValue>()->hasError());
-
-    const ValidationError::Ptr err(validationError.template as<ValidationError>());
-    QString msg(err->message());
-
-    if(msg.isNull())
-    {
-        msg = QtXmlPatterns::tr("It's not possible to cast the value %1 of type %2 to %3")
-                 .arg(formatData(sourceValue.stringValue()))
-                 .arg(formatType(context->namePool(), sourceValue.type()))
-                 .arg(formatType(context->namePool(), targetType()));
-    }
-    else
-    {
-        Q_ASSERT(!msg.isEmpty());
-        msg = QtXmlPatterns::tr("Failure when casting from %1 to %2: %3")
-                 .arg(formatType(context->namePool(), sourceValue.type()))
-                 .arg(formatType(context->namePool(), targetType()))
-                 .arg(msg);
-    }
-
-    /* If m_errorCode is FORG0001, we assume our sub-classer doesn't have a
-     * special wish about error code, so then we use the error object's code.
-     */
-    context->error(msg, m_errorCode == ReportContext::FORG0001 ? err->errorCode() : m_errorCode,
-                   static_cast<const TSubClass*>(this));
-}
-
diff --git a/src/xmlpatterns/expr/qcastingplatform_p.h b/src/xmlpatterns/expr/qcastingplatform_p.h
index 675a657..4836fd7 100644
--- a/src/xmlpatterns/expr/qcastingplatform_p.h
+++ b/src/xmlpatterns/expr/qcastingplatform_p.h
@@ -195,7 +195,7 @@ namespace QPatternist
         const ReportContext::ErrorCode m_errorCode;
     };
 
-#include "qcastingplatform.cpp"
+#include "qcastingplatform_tpl_p.h"
 
 }
 
diff --git a/src/xmlpatterns/expr/qcastingplatform_tpl_p.h b/src/xmlpatterns/expr/qcastingplatform_tpl_p.h
new file mode 100644
index 0000000..19f3796
--- /dev/null
+++ b/src/xmlpatterns/expr/qcastingplatform_tpl_p.h
@@ -0,0 +1,221 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by qcastingplatform_p.h.
+ * If you need includes in this file, put them in CasttingPlatform.h, outside of the namespace.
+ */
+
+template <typename TSubClass, const bool issueError>
+Item CastingPlatform<TSubClass, issueError>::castWithCaster(const Item &sourceValue,
+                                                            const AtomicCaster::Ptr &caster,
+                                                            const ReportContext::Ptr &context) const
+{
+    Q_ASSERT(sourceValue);
+    Q_ASSERT(caster);
+    Q_ASSERT(context);
+
+    const Item retval(caster->castFrom(sourceValue, context));
+
+    if(issueError)
+    {
+        if(retval.template as<AtomicValue>()->hasError())
+        {
+            issueCastError(retval, sourceValue, context);
+            return Item();
+        }
+        else
+            return retval;
+    }
+    else
+        return retval;
+}
+
+template <typename TSubClass, const bool issueError>
+Item CastingPlatform<TSubClass, issueError>::cast(const Item &sourceValue,
+                                                  const ReportContext::Ptr &context) const
+{
+    Q_ASSERT(sourceValue);
+    Q_ASSERT(context);
+    Q_ASSERT(targetType());
+
+    if(m_caster)
+        return castWithCaster(sourceValue, m_caster, context);
+    else
+    {
+        bool castImpossible = false;
+        const AtomicCaster::Ptr caster(locateCaster(sourceValue.type(), context, castImpossible, static_cast<const TSubClass *>(this), targetType()));
+
+        if(!issueError && castImpossible)
+        {
+            /* If we're supposed to issue an error(issueError) then this
+             * line will never be reached, because locateCaster() will in
+             * that case throw. */
+            return ValidationError::createError();
+        }
+        else
+            return castWithCaster(sourceValue, caster, context);
+    }
+}
+
+template <typename TSubClass, const bool issueError>
+bool CastingPlatform<TSubClass, issueError>::prepareCasting(const ReportContext::Ptr &context,
+                                                            const ItemType::Ptr &sourceType)
+{
+    Q_ASSERT(sourceType);
+    Q_ASSERT(context);
+
+    if(*sourceType == *BuiltinTypes::xsAnyAtomicType ||
+       *sourceType == *BuiltinTypes::item ||
+       *sourceType == *CommonSequenceTypes::Empty ||
+       *sourceType == *BuiltinTypes::numeric)
+        return true; /* The type could not be narrowed better than xs:anyAtomicType
+                        or numeric at compile time. We'll do lookup at runtime instead. */
+
+    bool castImpossible = false;
+    m_caster = locateCaster(sourceType, context, castImpossible, static_cast<const TSubClass *>(this), targetType());
+
+    return !castImpossible;
+}
+
+template <typename TSubClass, const bool issueError>
+AtomicCaster::Ptr CastingPlatform<TSubClass, issueError>::locateCaster(const ItemType::Ptr &sourceType,
+                                                                       const ReportContext::Ptr &context,
+                                                                       bool &castImpossible,
+                                                                       const SourceLocationReflection *const location,
+                                                                       const ItemType::Ptr &targetType)
+{
+    Q_ASSERT(sourceType);
+    Q_ASSERT(targetType);
+
+    const AtomicCasterLocator::Ptr locator(static_cast<AtomicType *>(
+            targetType.data())->casterLocator());
+    if(!locator)
+    {
+        if(issueError)
+        {
+            context->error(QtXmlPatterns::tr("No casting is possible with %1 as the target type.")
+                                        .arg(formatType(context->namePool(), targetType)),
+                                       ReportContext::XPTY0004, location);
+        }
+        else
+            castImpossible = true;
+
+        return AtomicCaster::Ptr();
+    }
+
+    const AtomicCaster::Ptr caster(static_cast<const AtomicType *>(sourceType.data())->accept(locator, location));
+    if(!caster)
+    {
+        if(issueError)
+        {
+            context->error(QtXmlPatterns::tr("It is not possible to cast from %1 to %2.")
+                                            .arg(formatType(context->namePool(), sourceType))
+                                            .arg(formatType(context->namePool(), targetType)),
+                                       ReportContext::XPTY0004, location);
+        }
+        else
+            castImpossible = true;
+
+        return AtomicCaster::Ptr();
+    }
+
+    return caster;
+}
+
+template <typename TSubClass, const bool issueError>
+void CastingPlatform<TSubClass, issueError>::checkTargetType(const ReportContext::Ptr &context) const
+{
+    Q_ASSERT(context);
+
+    const ItemType::Ptr tType(targetType());
+    Q_ASSERT(tType);
+    Q_ASSERT(tType->isAtomicType());
+    const AtomicType::Ptr asAtomic(tType);
+
+    /* This catches casting to xs:NOTATION and xs:anyAtomicType. */
+    if(asAtomic->isAbstract())
+    {
+        context->error(QtXmlPatterns::tr("Casting to %1 is not possible because it "
+                                     "is an abstract type, and can therefore never be instantiated.")
+                                .arg(formatType(context->namePool(), tType)),
+                          ReportContext::XPST0080,
+                          static_cast<const TSubClass*>(this));
+    }
+}
+
+template <typename TSubClass, const bool issueError>
+void CastingPlatform<TSubClass, issueError>::issueCastError(const Item &validationError,
+                                                            const Item &sourceValue,
+                                                            const ReportContext::Ptr &context) const
+{
+    Q_ASSERT(validationError);
+    Q_ASSERT(context);
+    Q_ASSERT(validationError.isAtomicValue());
+    Q_ASSERT(validationError.template as<AtomicValue>()->hasError());
+
+    const ValidationError::Ptr err(validationError.template as<ValidationError>());
+    QString msg(err->message());
+
+    if(msg.isNull())
+    {
+        msg = QtXmlPatterns::tr("It's not possible to cast the value %1 of type %2 to %3")
+                 .arg(formatData(sourceValue.stringValue()))
+                 .arg(formatType(context->namePool(), sourceValue.type()))
+                 .arg(formatType(context->namePool(), targetType()));
+    }
+    else
+    {
+        Q_ASSERT(!msg.isEmpty());
+        msg = QtXmlPatterns::tr("Failure when casting from %1 to %2: %3")
+                 .arg(formatType(context->namePool(), sourceValue.type()))
+                 .arg(formatType(context->namePool(), targetType()))
+                 .arg(msg);
+    }
+
+    /* If m_errorCode is FORG0001, we assume our sub-classer doesn't have a
+     * special wish about error code, so then we use the error object's code.
+     */
+    context->error(msg, m_errorCode == ReportContext::FORG0001 ? err->errorCode() : m_errorCode,
+                   static_cast<const TSubClass*>(this));
+}
+
diff --git a/src/xmlpatterns/expr/qcomparisonplatform.cpp b/src/xmlpatterns/expr/qcomparisonplatform.cpp
deleted file mode 100644
index 052a47a..0000000
--- a/src/xmlpatterns/expr/qcomparisonplatform.cpp
+++ /dev/null
@@ -1,199 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by qcomparisonplatform_p.h.
- * If you need includes in this file, put them in qcomparisonplatform_p.h, outside of the namespace.
- */
-
-template <typename TSubClass, bool issueError,
-          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
-bool ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
-flexibleCompare(const Item &it1,
-                const Item &it2,
-                const DynamicContext::Ptr &context) const
-{
-    if(m_comparator)
-        /* The comparator was located at compile time. */
-        return compare(it1, it2, m_comparator, operatorID());
-    else
-    {
-        const AtomicComparator::Ptr cp(fetchComparator(it1.type(),
-                                                       it2.type(),
-                                                       context));
-
-        return cp ? compare(it1, it2, cp, operatorID()) : false;
-    }
-}
-
-template <typename TSubClass, bool issueError,
-          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
-AtomicComparator::ComparisonResult
-ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
-detailedFlexibleCompare(const Item &it1,
-                        const Item &it2,
-                        const DynamicContext::Ptr &context) const
-{
-    AtomicComparator::Ptr comp;
-
-    if(m_comparator)
-        comp = m_comparator;
-    else
-    {
-        comp = fetchComparator(it1.type(),
-                               it2.type(),
-                               context);
-    }
-
-    Q_ASSERT_X(operatorID() == AtomicComparator::OperatorLessThanNaNLeast || operatorID() == AtomicComparator::OperatorLessThanNaNGreatest,
-               Q_FUNC_INFO, "Only OperatorLessThan is currently supported for this function.");
-    return comp->compare(it1, operatorID(), it2);
-}
-
-template <typename TSubClass, bool issueError,
-          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
-bool ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
-compare(const Item &oand1,
-        const Item &oand2,
-        const AtomicComparator::Ptr &comp,
-        const AtomicComparator::Operator op) const
-{
-    Q_ASSERT(oand1);
-    Q_ASSERT(oand2);
-    Q_ASSERT(comp);
-
-    switch(op)
-    {
-        case AtomicComparator::OperatorEqual:
-            return comp->equals(oand1, oand2);
-        case AtomicComparator::OperatorNotEqual:
-            return !comp->equals(oand1, oand2);
-        case AtomicComparator::OperatorLessThanNaNLeast:
-        case AtomicComparator::OperatorLessThanNaNGreatest:
-        /* Fallthrough. */
-        case AtomicComparator::OperatorLessThan:
-            return comp->compare(oand1, op, oand2) == AtomicComparator::LessThan;
-        case AtomicComparator::OperatorGreaterThan:
-            return comp->compare(oand1, op, oand2) == AtomicComparator::GreaterThan;
-        case AtomicComparator::OperatorLessOrEqual:
-        {
-            const AtomicComparator::ComparisonResult ret = comp->compare(oand1, op, oand2);
-            return ret == AtomicComparator::LessThan || ret == AtomicComparator::Equal;
-        }
-        case(AtomicComparator::OperatorGreaterOrEqual):
-        {
-            const AtomicComparator::ComparisonResult ret = comp->compare(oand1, op, oand2);
-            return ret == AtomicComparator::GreaterThan || ret == AtomicComparator::Equal;
-        }
-    }
-
-    /* GCC unbarfer, this line should never be reached. */
-    Q_ASSERT(false);
-    return false;
-}
-
-template <typename TSubClass, bool issueError,
-          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
-AtomicComparator::Ptr ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
-fetchComparator(const ItemType::Ptr &t1,
-                const ItemType::Ptr &t2,
-                const ReportContext::Ptr &context) const
-{
-    Q_ASSERT(t1);
-    Q_ASSERT(t2);
-
-    if(*BuiltinTypes::xsAnyAtomicType == *t1    ||
-       *BuiltinTypes::xsAnyAtomicType == *t2    ||
-       *BuiltinTypes::item == *t1               ||
-       *BuiltinTypes::item == *t2               ||
-       *BuiltinTypes::numeric == *t1            ||
-       *BuiltinTypes::numeric == *t2            ||
-       *CommonSequenceTypes::Empty == *t1       ||
-       *CommonSequenceTypes::Empty == *t2)
-    {
-        /* The static type of(at least) one of the operands could not
-         * be narrowed further, so we do the operator
-         * lookup at runtime.
-         */
-        return AtomicComparator::Ptr();
-    }
-
-    const AtomicComparatorLocator::Ptr locator
-        (static_cast<const AtomicType *>(t1.data())->comparatorLocator());
-
-    if(!locator)
-    {
-        if(issueError)
-        {
-            context->error(QtXmlPatterns::tr("No comparisons can be done involving the type %1.")
-                                            .arg(formatType(context->namePool(), t1)),
-                                       errorCode, static_cast<const TSubClass *>(this)->actualReflection());
-        }
-        return AtomicComparator::Ptr();
-    }
-
-    const AtomicComparator::Ptr comp(static_cast<const AtomicType *>(t2.data())->accept(locator, operatorID(),
-                                                                                       static_cast<const TSubClass *>(this)->actualReflection()));
-
-    if(comp)
-        return comp;
-    else if(issueError)
-    {
-        context->error(QtXmlPatterns::tr("Operator %1 is not available between atomic values of type %2 and %3.")
-                                        .arg(formatKeyword(AtomicComparator::displayName(operatorID(),
-                                                                                         comparisonType)),
-                                             formatType(context->namePool(), t1),
-                                             formatType(context->namePool(), t2)),
-                                   errorCode, static_cast<const TSubClass *>(this)->actualReflection());
-    }
-
-    return AtomicComparator::Ptr();
-}
-
-template <typename TSubClass, bool issueError,
-          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
-void ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
-prepareComparison(const AtomicComparator::Ptr &c)
-{
-    m_comparator = c;
-}
-
diff --git a/src/xmlpatterns/expr/qcomparisonplatform_p.h b/src/xmlpatterns/expr/qcomparisonplatform_p.h
index 444f677..aacf6a2 100644
--- a/src/xmlpatterns/expr/qcomparisonplatform_p.h
+++ b/src/xmlpatterns/expr/qcomparisonplatform_p.h
@@ -197,7 +197,7 @@ namespace QPatternist
         AtomicComparator::Ptr m_comparator;
     };
 
-#include "qcomparisonplatform.cpp"
+#include "qcomparisonplatform_tpl_p.h"
 
 }
 
diff --git a/src/xmlpatterns/expr/qcomparisonplatform_tpl_p.h b/src/xmlpatterns/expr/qcomparisonplatform_tpl_p.h
new file mode 100644
index 0000000..052a47a
--- /dev/null
+++ b/src/xmlpatterns/expr/qcomparisonplatform_tpl_p.h
@@ -0,0 +1,199 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by qcomparisonplatform_p.h.
+ * If you need includes in this file, put them in qcomparisonplatform_p.h, outside of the namespace.
+ */
+
+template <typename TSubClass, bool issueError,
+          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
+bool ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
+flexibleCompare(const Item &it1,
+                const Item &it2,
+                const DynamicContext::Ptr &context) const
+{
+    if(m_comparator)
+        /* The comparator was located at compile time. */
+        return compare(it1, it2, m_comparator, operatorID());
+    else
+    {
+        const AtomicComparator::Ptr cp(fetchComparator(it1.type(),
+                                                       it2.type(),
+                                                       context));
+
+        return cp ? compare(it1, it2, cp, operatorID()) : false;
+    }
+}
+
+template <typename TSubClass, bool issueError,
+          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
+AtomicComparator::ComparisonResult
+ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
+detailedFlexibleCompare(const Item &it1,
+                        const Item &it2,
+                        const DynamicContext::Ptr &context) const
+{
+    AtomicComparator::Ptr comp;
+
+    if(m_comparator)
+        comp = m_comparator;
+    else
+    {
+        comp = fetchComparator(it1.type(),
+                               it2.type(),
+                               context);
+    }
+
+    Q_ASSERT_X(operatorID() == AtomicComparator::OperatorLessThanNaNLeast || operatorID() == AtomicComparator::OperatorLessThanNaNGreatest,
+               Q_FUNC_INFO, "Only OperatorLessThan is currently supported for this function.");
+    return comp->compare(it1, operatorID(), it2);
+}
+
+template <typename TSubClass, bool issueError,
+          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
+bool ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
+compare(const Item &oand1,
+        const Item &oand2,
+        const AtomicComparator::Ptr &comp,
+        const AtomicComparator::Operator op) const
+{
+    Q_ASSERT(oand1);
+    Q_ASSERT(oand2);
+    Q_ASSERT(comp);
+
+    switch(op)
+    {
+        case AtomicComparator::OperatorEqual:
+            return comp->equals(oand1, oand2);
+        case AtomicComparator::OperatorNotEqual:
+            return !comp->equals(oand1, oand2);
+        case AtomicComparator::OperatorLessThanNaNLeast:
+        case AtomicComparator::OperatorLessThanNaNGreatest:
+        /* Fallthrough. */
+        case AtomicComparator::OperatorLessThan:
+            return comp->compare(oand1, op, oand2) == AtomicComparator::LessThan;
+        case AtomicComparator::OperatorGreaterThan:
+            return comp->compare(oand1, op, oand2) == AtomicComparator::GreaterThan;
+        case AtomicComparator::OperatorLessOrEqual:
+        {
+            const AtomicComparator::ComparisonResult ret = comp->compare(oand1, op, oand2);
+            return ret == AtomicComparator::LessThan || ret == AtomicComparator::Equal;
+        }
+        case(AtomicComparator::OperatorGreaterOrEqual):
+        {
+            const AtomicComparator::ComparisonResult ret = comp->compare(oand1, op, oand2);
+            return ret == AtomicComparator::GreaterThan || ret == AtomicComparator::Equal;
+        }
+    }
+
+    /* GCC unbarfer, this line should never be reached. */
+    Q_ASSERT(false);
+    return false;
+}
+
+template <typename TSubClass, bool issueError,
+          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
+AtomicComparator::Ptr ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
+fetchComparator(const ItemType::Ptr &t1,
+                const ItemType::Ptr &t2,
+                const ReportContext::Ptr &context) const
+{
+    Q_ASSERT(t1);
+    Q_ASSERT(t2);
+
+    if(*BuiltinTypes::xsAnyAtomicType == *t1    ||
+       *BuiltinTypes::xsAnyAtomicType == *t2    ||
+       *BuiltinTypes::item == *t1               ||
+       *BuiltinTypes::item == *t2               ||
+       *BuiltinTypes::numeric == *t1            ||
+       *BuiltinTypes::numeric == *t2            ||
+       *CommonSequenceTypes::Empty == *t1       ||
+       *CommonSequenceTypes::Empty == *t2)
+    {
+        /* The static type of(at least) one of the operands could not
+         * be narrowed further, so we do the operator
+         * lookup at runtime.
+         */
+        return AtomicComparator::Ptr();
+    }
+
+    const AtomicComparatorLocator::Ptr locator
+        (static_cast<const AtomicType *>(t1.data())->comparatorLocator());
+
+    if(!locator)
+    {
+        if(issueError)
+        {
+            context->error(QtXmlPatterns::tr("No comparisons can be done involving the type %1.")
+                                            .arg(formatType(context->namePool(), t1)),
+                                       errorCode, static_cast<const TSubClass *>(this)->actualReflection());
+        }
+        return AtomicComparator::Ptr();
+    }
+
+    const AtomicComparator::Ptr comp(static_cast<const AtomicType *>(t2.data())->accept(locator, operatorID(),
+                                                                                       static_cast<const TSubClass *>(this)->actualReflection()));
+
+    if(comp)
+        return comp;
+    else if(issueError)
+    {
+        context->error(QtXmlPatterns::tr("Operator %1 is not available between atomic values of type %2 and %3.")
+                                        .arg(formatKeyword(AtomicComparator::displayName(operatorID(),
+                                                                                         comparisonType)),
+                                             formatType(context->namePool(), t1),
+                                             formatType(context->namePool(), t2)),
+                                   errorCode, static_cast<const TSubClass *>(this)->actualReflection());
+    }
+
+    return AtomicComparator::Ptr();
+}
+
+template <typename TSubClass, bool issueError,
+          AtomicComparator::ComparisonType comparisonType, ReportContext::ErrorCode errorCode>
+void ComparisonPlatform<TSubClass, issueError, comparisonType, errorCode>::
+prepareComparison(const AtomicComparator::Ptr &c)
+{
+    m_comparator = c;
+}
+
diff --git a/src/xmlpatterns/expr/qevaluationcache.cpp b/src/xmlpatterns/expr/qevaluationcache.cpp
deleted file mode 100644
index 11c6141..0000000
--- a/src/xmlpatterns/expr/qevaluationcache.cpp
+++ /dev/null
@@ -1,274 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by qevaluationcache_p.h.
- * If you need includes in this file, put them in qevaluationcache_p.h, outside of the namespace.
- */
-
-template<bool IsForGlobal>
-EvaluationCache<IsForGlobal>::EvaluationCache(const Expression::Ptr &op,
-                                              const VariableDeclaration::Ptr &varDecl,
-                                              const VariableSlotID aSlot) : SingleContainer(op)
-                                                                          , m_declaration(varDecl)
-                                                                          , m_varSlot(aSlot)
-{
-    Q_ASSERT(m_declaration);
-    Q_ASSERT(m_varSlot > -1);
-}
-
-template<bool IsForGlobal>
-DynamicContext::Ptr EvaluationCache<IsForGlobal>::topFocusContext(const DynamicContext::Ptr &context)
-{
-    DynamicContext::Ptr result(context);
-
-    while(true)
-    {
-        DynamicContext::Ptr candidate(result->previousContext());
-
-        /* We want the top focus, not GenericDynamicContext. */
-        if(candidate && candidate->focusIterator())
-            result = candidate;
-        else
-            return result;
-    }
-}
-
-template<bool IsForGlobal>
-Item EvaluationCache<IsForGlobal>::evaluateSingleton(const DynamicContext::Ptr &context) const
-{
-    ItemCacheCell &cell = IsForGlobal ? context->globalItemCacheCell(m_varSlot) : context->itemCacheCell(m_varSlot);
-
-    if(cell.cacheState == ItemCacheCell::Full)
-        return cell.cachedItem;
-    else
-    {
-        Q_ASSERT(cell.cacheState == ItemCacheCell::Empty);
-        cell.cachedItem = m_operand->evaluateSingleton(IsForGlobal ? topFocusContext(context) : context);
-        cell.cacheState = ItemCacheCell::Full;
-        return cell.cachedItem;
-    }
-}
-
-#if defined(Q_OS_IRIX) && defined(Q_CC_MIPS)
-/**
- * @short Compile workaround for MIPSPro on IRIX.
- *
- * This function is never called.
- *
- * It's mere presence means the MIPSPro compiler can accept some other code below.
- *
- * I recommend Buddism.
- */
-static inline Item::Iterator::Ptr workaroundIrixMIPSPro(const ItemSequenceCacheCell &cell)
-{
-  return Item::Iterator::Ptr(new ListIterator<Item, Item::List>(cell.cachedItems));
-}
-#endif
-
-template<bool IsForGlobal>
-Item::Iterator::Ptr EvaluationCache<IsForGlobal>::evaluateSequence(const DynamicContext::Ptr &context) const
-{
-    ItemSequenceCacheCell::Vector &cells = IsForGlobal ? context->globalItemSequenceCacheCells(m_varSlot) : context->itemSequenceCacheCells(m_varSlot);
-    ItemSequenceCacheCell &cell = cells[m_varSlot];
-
-
-    if(cell.inUse)
-    {
-        context->error(QtXmlPatterns::tr("Circularity detected"),
-                       ReportContext::XTDE0640, this);
-    }
-
-    switch(cell.cacheState)
-    {
-        case ItemSequenceCacheCell::Full:
-        {
-            /**
-             * We don't use makeListIterator() here because the MIPSPro compiler can't handle it.
-             */
-            return Item::Iterator::Ptr(new ListIterator<Item, Item::List>(cell.cachedItems));
-        }
-        case ItemSequenceCacheCell::Empty:
-        {
-            cell.inUse = true;
-            cell.sourceIterator = m_operand->evaluateSequence(IsForGlobal ? topFocusContext(context) : context);
-            cell.cacheState = ItemSequenceCacheCell::PartiallyPopulated;
-            /* Fallthrough. */
-        }
-        case ItemSequenceCacheCell::PartiallyPopulated:
-        {
-            cell.inUse = false;
-            Q_ASSERT_X(cells.at(m_varSlot).sourceIterator, Q_FUNC_INFO,
-                       "This trigger for a cache bug which hasn't yet been analyzed.");
-            return Item::Iterator::Ptr(new CachingIterator(cells, m_varSlot, IsForGlobal ? topFocusContext(context) : context));
-        }
-        default:
-        {
-            Q_ASSERT_X(false, Q_FUNC_INFO, "This path is not supposed to be run.");
-            return Item::Iterator::Ptr();
-        }
-    }
-}
-
-template<bool IsForGlobal>
-Expression::Ptr EvaluationCache<IsForGlobal>::typeCheck(const StaticContext::Ptr &context,
-                                                        const SequenceType::Ptr &reqType)
-{
-    /* It's important that we do the typeCheck() before checking for the use of local variables,
-     * because ExpressionVariableReference can reference an expression that is a local variable,
-     * so it must rewrite itself to it operand before, and it does that in EvaluationCache::typeCheck(). */
-    const Expression::Ptr me(SingleContainer::typeCheck(context, reqType));
-
-    OperandsIterator it(me, OperandsIterator::ExcludeParent);
-    Expression::Ptr next(it.next());
-
-    /* If our operand or any sub operand gets its value from a for-loop, we cannot
-     * cache it since then our cache would be filled -- but not invalidated -- on the
-     * first for-iteration. Consider this query:
-     *
-     * <tt>for $i in expr
-     * let $v := $i/p
-     * return ($v, $v)</tt>
-     *
-     * An evaluation cache is inserted for the two operands in the return clause. However,
-     * $i changes for each iteration so the cache can only be active on a per-iteration basis,
-     * it it's possible(which it isn't).
-     *
-     * This means that for some queries we don't cache what we really should, and hence evaluate
-     * in a sub-optimal way, since this DependsOnLocalVariable don't communicate whether it references
-     * a loop that affects us. The correct fix for this would be to let ForExpression reset the
-     * relevant caches only, but we don't know which ones that are. */
-    while(next)
-    {
-        if(next->has(DependsOnLocalVariable))
-            return m_operand->typeCheck(context, reqType);
-
-        next = it.next();
-    }
-
-    return me;
-}
-
-template<bool IsForGlobal>
-Expression::Ptr EvaluationCache<IsForGlobal>::compress(const StaticContext::Ptr &context)
-{
-    const Expression::Ptr me(SingleContainer::compress(context));
-
-    if(me != this)
-        return me;
-
-    if(m_operand->is(IDRangeVariableReference))
-        return m_operand;
-
-    if(m_declaration->usedByMany())
-    {
-        /* If it's only an atomic value an EvaluationCache is overkill. However,
-         * it's still needed for functions like fn:current-time() that must adhere to
-         * query stability. */
-        const Properties props(m_operand->properties());
-
-        if(props.testFlag(EvaluationCacheRedundant) ||
-           ((props.testFlag(IsEvaluated)) &&
-            !props.testFlag(DisableElimination) &&
-            CommonSequenceTypes::ExactlyOneAtomicType->matches(m_operand->staticType())))
-        {
-            return m_operand;
-        }
-        else
-            return me;
-    }
-    else
-    {
-        /* If we're only used once, there's no need for an EvaluationCache. */
-        return m_operand;
-    }
-}
-
-template<bool IsForGlobal>
-SequenceType::Ptr EvaluationCache<IsForGlobal>::staticType() const
-{
-    return m_operand->staticType();
-}
-
-template<bool IsForGlobal>
-SequenceType::List EvaluationCache<IsForGlobal>::expectedOperandTypes() const
-{
-    /* Remember that EvaluationCache::typeCheck() will be called from multiple locations,
-     * which potentially have different type requirements. For instance, one wants a node,
-     * and another requires atomization and casting.
-     *
-     * Returning ZeroOrMoreItems is safe here because staticType() returns the operand's type
-     * and therefore the convertors like Atomizer will be parents to us, and hence only affect
-     * the relevant path.
-     *
-     * ZeroOrMoreItems also make sense logically since we're actually only used where the
-     * variable references reference us. */
-    SequenceType::List result;
-    result.append(CommonSequenceTypes::ZeroOrMoreItems);
-
-    return result;
-}
-
-template<bool IsForGlobal>
-Expression::Properties EvaluationCache<IsForGlobal>::properties() const
-{
-    /* We cannot return the operand's properties unconditionally, because some
-     * doesn't hold for this Expression.
-     *
-     * However, some of the properties must propagate through, which are the ones being OR'd here.
-     */
-    return m_operand->properties() & (DisableElimination | IsEvaluated | DisableTypingDeduction);
-}
-
-template<bool IsForGlobal>
-ExpressionVisitorResult::Ptr
-EvaluationCache<IsForGlobal>::accept(const ExpressionVisitor::Ptr &visitor) const
-{
-    return visitor->visit(this);
-}
-
-template<bool IsForGlobal>
-const SourceLocationReflection *EvaluationCache<IsForGlobal>::actualReflection() const
-{
-    return m_operand->actualReflection();
-}
-
diff --git a/src/xmlpatterns/expr/qevaluationcache_p.h b/src/xmlpatterns/expr/qevaluationcache_p.h
index c00adf4..4f0d59b 100644
--- a/src/xmlpatterns/expr/qevaluationcache_p.h
+++ b/src/xmlpatterns/expr/qevaluationcache_p.h
@@ -136,7 +136,7 @@ namespace QPatternist
         const VariableSlotID            m_varSlot;
     };
 
-#include "qevaluationcache.cpp"
+#include "qevaluationcache_tpl_p.h"
 }
 
 QT_END_NAMESPACE
diff --git a/src/xmlpatterns/expr/qevaluationcache_tpl_p.h b/src/xmlpatterns/expr/qevaluationcache_tpl_p.h
new file mode 100644
index 0000000..11c6141
--- /dev/null
+++ b/src/xmlpatterns/expr/qevaluationcache_tpl_p.h
@@ -0,0 +1,274 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by qevaluationcache_p.h.
+ * If you need includes in this file, put them in qevaluationcache_p.h, outside of the namespace.
+ */
+
+template<bool IsForGlobal>
+EvaluationCache<IsForGlobal>::EvaluationCache(const Expression::Ptr &op,
+                                              const VariableDeclaration::Ptr &varDecl,
+                                              const VariableSlotID aSlot) : SingleContainer(op)
+                                                                          , m_declaration(varDecl)
+                                                                          , m_varSlot(aSlot)
+{
+    Q_ASSERT(m_declaration);
+    Q_ASSERT(m_varSlot > -1);
+}
+
+template<bool IsForGlobal>
+DynamicContext::Ptr EvaluationCache<IsForGlobal>::topFocusContext(const DynamicContext::Ptr &context)
+{
+    DynamicContext::Ptr result(context);
+
+    while(true)
+    {
+        DynamicContext::Ptr candidate(result->previousContext());
+
+        /* We want the top focus, not GenericDynamicContext. */
+        if(candidate && candidate->focusIterator())
+            result = candidate;
+        else
+            return result;
+    }
+}
+
+template<bool IsForGlobal>
+Item EvaluationCache<IsForGlobal>::evaluateSingleton(const DynamicContext::Ptr &context) const
+{
+    ItemCacheCell &cell = IsForGlobal ? context->globalItemCacheCell(m_varSlot) : context->itemCacheCell(m_varSlot);
+
+    if(cell.cacheState == ItemCacheCell::Full)
+        return cell.cachedItem;
+    else
+    {
+        Q_ASSERT(cell.cacheState == ItemCacheCell::Empty);
+        cell.cachedItem = m_operand->evaluateSingleton(IsForGlobal ? topFocusContext(context) : context);
+        cell.cacheState = ItemCacheCell::Full;
+        return cell.cachedItem;
+    }
+}
+
+#if defined(Q_OS_IRIX) && defined(Q_CC_MIPS)
+/**
+ * @short Compile workaround for MIPSPro on IRIX.
+ *
+ * This function is never called.
+ *
+ * It's mere presence means the MIPSPro compiler can accept some other code below.
+ *
+ * I recommend Buddism.
+ */
+static inline Item::Iterator::Ptr workaroundIrixMIPSPro(const ItemSequenceCacheCell &cell)
+{
+  return Item::Iterator::Ptr(new ListIterator<Item, Item::List>(cell.cachedItems));
+}
+#endif
+
+template<bool IsForGlobal>
+Item::Iterator::Ptr EvaluationCache<IsForGlobal>::evaluateSequence(const DynamicContext::Ptr &context) const
+{
+    ItemSequenceCacheCell::Vector &cells = IsForGlobal ? context->globalItemSequenceCacheCells(m_varSlot) : context->itemSequenceCacheCells(m_varSlot);
+    ItemSequenceCacheCell &cell = cells[m_varSlot];
+
+
+    if(cell.inUse)
+    {
+        context->error(QtXmlPatterns::tr("Circularity detected"),
+                       ReportContext::XTDE0640, this);
+    }
+
+    switch(cell.cacheState)
+    {
+        case ItemSequenceCacheCell::Full:
+        {
+            /**
+             * We don't use makeListIterator() here because the MIPSPro compiler can't handle it.
+             */
+            return Item::Iterator::Ptr(new ListIterator<Item, Item::List>(cell.cachedItems));
+        }
+        case ItemSequenceCacheCell::Empty:
+        {
+            cell.inUse = true;
+            cell.sourceIterator = m_operand->evaluateSequence(IsForGlobal ? topFocusContext(context) : context);
+            cell.cacheState = ItemSequenceCacheCell::PartiallyPopulated;
+            /* Fallthrough. */
+        }
+        case ItemSequenceCacheCell::PartiallyPopulated:
+        {
+            cell.inUse = false;
+            Q_ASSERT_X(cells.at(m_varSlot).sourceIterator, Q_FUNC_INFO,
+                       "This trigger for a cache bug which hasn't yet been analyzed.");
+            return Item::Iterator::Ptr(new CachingIterator(cells, m_varSlot, IsForGlobal ? topFocusContext(context) : context));
+        }
+        default:
+        {
+            Q_ASSERT_X(false, Q_FUNC_INFO, "This path is not supposed to be run.");
+            return Item::Iterator::Ptr();
+        }
+    }
+}
+
+template<bool IsForGlobal>
+Expression::Ptr EvaluationCache<IsForGlobal>::typeCheck(const StaticContext::Ptr &context,
+                                                        const SequenceType::Ptr &reqType)
+{
+    /* It's important that we do the typeCheck() before checking for the use of local variables,
+     * because ExpressionVariableReference can reference an expression that is a local variable,
+     * so it must rewrite itself to it operand before, and it does that in EvaluationCache::typeCheck(). */
+    const Expression::Ptr me(SingleContainer::typeCheck(context, reqType));
+
+    OperandsIterator it(me, OperandsIterator::ExcludeParent);
+    Expression::Ptr next(it.next());
+
+    /* If our operand or any sub operand gets its value from a for-loop, we cannot
+     * cache it since then our cache would be filled -- but not invalidated -- on the
+     * first for-iteration. Consider this query:
+     *
+     * <tt>for $i in expr
+     * let $v := $i/p
+     * return ($v, $v)</tt>
+     *
+     * An evaluation cache is inserted for the two operands in the return clause. However,
+     * $i changes for each iteration so the cache can only be active on a per-iteration basis,
+     * it it's possible(which it isn't).
+     *
+     * This means that for some queries we don't cache what we really should, and hence evaluate
+     * in a sub-optimal way, since this DependsOnLocalVariable don't communicate whether it references
+     * a loop that affects us. The correct fix for this would be to let ForExpression reset the
+     * relevant caches only, but we don't know which ones that are. */
+    while(next)
+    {
+        if(next->has(DependsOnLocalVariable))
+            return m_operand->typeCheck(context, reqType);
+
+        next = it.next();
+    }
+
+    return me;
+}
+
+template<bool IsForGlobal>
+Expression::Ptr EvaluationCache<IsForGlobal>::compress(const StaticContext::Ptr &context)
+{
+    const Expression::Ptr me(SingleContainer::compress(context));
+
+    if(me != this)
+        return me;
+
+    if(m_operand->is(IDRangeVariableReference))
+        return m_operand;
+
+    if(m_declaration->usedByMany())
+    {
+        /* If it's only an atomic value an EvaluationCache is overkill. However,
+         * it's still needed for functions like fn:current-time() that must adhere to
+         * query stability. */
+        const Properties props(m_operand->properties());
+
+        if(props.testFlag(EvaluationCacheRedundant) ||
+           ((props.testFlag(IsEvaluated)) &&
+            !props.testFlag(DisableElimination) &&
+            CommonSequenceTypes::ExactlyOneAtomicType->matches(m_operand->staticType())))
+        {
+            return m_operand;
+        }
+        else
+            return me;
+    }
+    else
+    {
+        /* If we're only used once, there's no need for an EvaluationCache. */
+        return m_operand;
+    }
+}
+
+template<bool IsForGlobal>
+SequenceType::Ptr EvaluationCache<IsForGlobal>::staticType() const
+{
+    return m_operand->staticType();
+}
+
+template<bool IsForGlobal>
+SequenceType::List EvaluationCache<IsForGlobal>::expectedOperandTypes() const
+{
+    /* Remember that EvaluationCache::typeCheck() will be called from multiple locations,
+     * which potentially have different type requirements. For instance, one wants a node,
+     * and another requires atomization and casting.
+     *
+     * Returning ZeroOrMoreItems is safe here because staticType() returns the operand's type
+     * and therefore the convertors like Atomizer will be parents to us, and hence only affect
+     * the relevant path.
+     *
+     * ZeroOrMoreItems also make sense logically since we're actually only used where the
+     * variable references reference us. */
+    SequenceType::List result;
+    result.append(CommonSequenceTypes::ZeroOrMoreItems);
+
+    return result;
+}
+
+template<bool IsForGlobal>
+Expression::Properties EvaluationCache<IsForGlobal>::properties() const
+{
+    /* We cannot return the operand's properties unconditionally, because some
+     * doesn't hold for this Expression.
+     *
+     * However, some of the properties must propagate through, which are the ones being OR'd here.
+     */
+    return m_operand->properties() & (DisableElimination | IsEvaluated | DisableTypingDeduction);
+}
+
+template<bool IsForGlobal>
+ExpressionVisitorResult::Ptr
+EvaluationCache<IsForGlobal>::accept(const ExpressionVisitor::Ptr &visitor) const
+{
+    return visitor->visit(this);
+}
+
+template<bool IsForGlobal>
+const SourceLocationReflection *EvaluationCache<IsForGlobal>::actualReflection() const
+{
+    return m_operand->actualReflection();
+}
+
diff --git a/src/xmlpatterns/functions/qcomparingaggregator.cpp b/src/xmlpatterns/functions/qcomparingaggregator.cpp
deleted file mode 100644
index f8c8859..0000000
--- a/src/xmlpatterns/functions/qcomparingaggregator.cpp
+++ /dev/null
@@ -1,212 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file qcomparingaggregator.cpp
- * @short This file is included by qcomparingaggregator_p.h.
- * If you need includes in this file, put them in qcomparingaggregator_p.h, outside of the namespace.
- */
-
-template <AtomicComparator::Operator oper, AtomicComparator::ComparisonResult result>
-inline Item
-ComparingAggregator<oper, result>::applyNumericPromotion(const Item &old,
-                                                         const Item &nev,
-                                                         const Item &newVal) const
-{
-    Q_ASSERT(old);
-    Q_ASSERT(nev);
-    Q_ASSERT(newVal);
-    const ItemType::Ptr to(old.type());
-    const ItemType::Ptr tn(nev.type());
-
-    if(!(BuiltinTypes::numeric->xdtTypeMatches(to) && BuiltinTypes::numeric->xdtTypeMatches(tn)))
-        return newVal; /* At least one of them isn't numeric. */
-    else if(BuiltinTypes::xsDouble->xdtTypeMatches(to) || BuiltinTypes::xsDouble->xdtTypeMatches(tn))
-        return toItem(Double::fromValue(newVal.as<Numeric>()->toDouble()));
-    else if(BuiltinTypes::xsFloat->xdtTypeMatches(to) || BuiltinTypes::xsFloat->xdtTypeMatches(tn))
-        return toItem(Float::fromValue(newVal.as<Numeric>()->toDouble()));
-    else if(BuiltinTypes::xsInteger->xdtTypeMatches(to) &&
-            BuiltinTypes::xsInteger->xdtTypeMatches(tn))
-        return newVal; /* Both must be xs:integer. */
-    else
-        return toItem(Decimal::fromValue(newVal.as<Numeric>()->toDecimal()));
-}
-
-template <AtomicComparator::Operator oper, AtomicComparator::ComparisonResult result>
-Item
-ComparingAggregator<oper, result>::evaluateSingleton(const DynamicContext::Ptr &context) const
-{
-    const Item::Iterator::Ptr it(m_operands.first()->evaluateSequence(context));
-    Item largest;
-
-    while(true)
-    {
-        Item next(it->next());
-
-        if(!next)
-        {
-            return largest;
-        }
-
-        AtomicComparator::Ptr comp(comparator());
-
-        if(!comp)
-        {
-            ItemType::Ptr t1(next.type());
-            Q_ASSERT(t1);
-
-            if(BuiltinTypes::xsUntypedAtomic->xdtTypeMatches(t1))
-            {
-                next = cast(next, context);
-                t1 = BuiltinTypes::xsDouble;
-            }
-
-            if(!largest)
-            {
-                largest = next;
-                continue;
-            }
-
-            Q_ASSERT(largest);
-            comp = fetchComparator(largest.type(), t1, context);
-            Q_ASSERT(comp);
-        }
-        else if(!largest)
-        {
-            largest = next;
-            continue;
-        }
-
-        if(comp->compare(next, operatorID(), largest) == result)
-        {
-            largest = applyNumericPromotion(largest, next, next);
-            continue;
-        }
-
-        const ItemType::Ptr t(next.type());
-
-        if(BuiltinTypes::xsDouble->xdtTypeMatches(t) &&
-           next.as<Numeric>()->isNaN())
-        {
-            return CommonValues::DoubleNaN;
-        }
-        else if(BuiltinTypes::xsFloat->xdtTypeMatches(t) &&
-                next.as<Numeric>()->isNaN())
-        {
-            if(BuiltinTypes::xsDouble->xdtTypeMatches(largest.type()))
-                return CommonValues::DoubleNaN;
-
-            /* If we have a xs:double somewhere, we must promote the NaN value to xs:double,
-             * and we really should raise error on invalid value. */
-            largest = it->next();
-
-            while(largest)
-            {
-                const ItemType::Ptr tf(largest.type());
-                if(BuiltinTypes::xsDouble->xdtTypeMatches(tf))
-                    return CommonValues::DoubleNaN;
-                else if(BuiltinTypes::xsUntypedAtomic->xdtTypeMatches(tf))
-                {
-                    /* Attempt a convert, which will raise an error if it doesn't work out. */
-                    cast(largest, context);
-                    return CommonValues::DoubleNaN;
-                }
-                else if(!BuiltinTypes::numeric->xdtTypeMatches(tf))
-                {
-                    fetchComparator(BuiltinTypes::xsFloat, tf, context);
-                }
-                else
-                    largest = it->next();
-            };
-
-            return CommonValues::FloatNaN;
-        }
-        else
-            largest = applyNumericPromotion(largest, next, largest);
-    }
-}
-
-template <AtomicComparator::Operator oper, AtomicComparator::ComparisonResult result>
-Expression::Ptr
-ComparingAggregator<oper, result>::typeCheck(const StaticContext::Ptr &context,
-                                             const SequenceType::Ptr &reqType)
-{
-    Q_ASSERT(oper == AtomicComparator::OperatorGreaterThan ||
-             oper == AtomicComparator::OperatorLessThan);
-    const Expression::Ptr me(FunctionCall::typeCheck(context, reqType));
-
-    ItemType::Ptr t1(m_operands.first()->staticType()->itemType());
-
-    if(*CommonSequenceTypes::Empty == *t1)
-        return EmptySequence::create(this, context);
-    else if(*BuiltinTypes::xsAnyAtomicType == *t1 ||
-            BuiltinTypes::numeric->xdtTypeMatches(t1))
-        return me;
-    else if(BuiltinTypes::xsUntypedAtomic->xdtTypeMatches(t1))
-    {
-        m_operands.replace(0, Expression::Ptr(new UntypedAtomicConverter(m_operands.first(),
-                           BuiltinTypes::xsDouble)));
-        t1 = m_operands.first()->staticType()->itemType();
-    }
-    else if(!BuiltinTypes::xsString->xdtTypeMatches(t1) &&
-            !BuiltinTypes::xsAnyURI->xdtTypeMatches(t1) &&
-            !BuiltinTypes::xsDayTimeDuration->xdtTypeMatches(t1) &&
-            !BuiltinTypes::xsDate->xdtTypeMatches(t1) &&
-            !BuiltinTypes::xsTime->xdtTypeMatches(t1) &&
-            !BuiltinTypes::xsDateTime->xdtTypeMatches(t1) &&
-            !BuiltinTypes::xsYearMonthDuration->xdtTypeMatches(t1))
-    {
-        context->error(QtXmlPatterns::tr("The first argument to %1 cannot be of type %2.")
-                          .arg(QPatternist::formatFunction(context->namePool(), signature()))
-                          .arg(formatType(context->namePool(), m_operands.first()->staticType())),
-                       ReportContext::FORG0006, this);
-        return me;
-    }
-
-    if(!m_operands.first()->staticType()->cardinality().allowsMany())
-        return m_operands.first();
-    
-    // explicit scope needed in RVCT
-    ComparingAggregator<oper, result>::prepareComparison(fetchComparator(t1, t1, context));
-
-    return me;
-}
-
diff --git a/src/xmlpatterns/functions/qcomparingaggregator_p.h b/src/xmlpatterns/functions/qcomparingaggregator_p.h
index b1e6625..c14d48e 100644
--- a/src/xmlpatterns/functions/qcomparingaggregator_p.h
+++ b/src/xmlpatterns/functions/qcomparingaggregator_p.h
@@ -122,7 +122,7 @@ namespace QPatternist
         using CastingPlatform<ComparingAggregator<oper, result>, true>::cast;
     };
 
-#include "qcomparingaggregator.cpp"
+#include "qcomparingaggregator_tpl_p.h"
 
     /**
      * @short An instantiation of ComparingAggregator suitable for <tt>fn:max()</tt>.
diff --git a/src/xmlpatterns/functions/qcomparingaggregator_tpl_p.h b/src/xmlpatterns/functions/qcomparingaggregator_tpl_p.h
new file mode 100644
index 0000000..f8c8859
--- /dev/null
+++ b/src/xmlpatterns/functions/qcomparingaggregator_tpl_p.h
@@ -0,0 +1,212 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file qcomparingaggregator.cpp
+ * @short This file is included by qcomparingaggregator_p.h.
+ * If you need includes in this file, put them in qcomparingaggregator_p.h, outside of the namespace.
+ */
+
+template <AtomicComparator::Operator oper, AtomicComparator::ComparisonResult result>
+inline Item
+ComparingAggregator<oper, result>::applyNumericPromotion(const Item &old,
+                                                         const Item &nev,
+                                                         const Item &newVal) const
+{
+    Q_ASSERT(old);
+    Q_ASSERT(nev);
+    Q_ASSERT(newVal);
+    const ItemType::Ptr to(old.type());
+    const ItemType::Ptr tn(nev.type());
+
+    if(!(BuiltinTypes::numeric->xdtTypeMatches(to) && BuiltinTypes::numeric->xdtTypeMatches(tn)))
+        return newVal; /* At least one of them isn't numeric. */
+    else if(BuiltinTypes::xsDouble->xdtTypeMatches(to) || BuiltinTypes::xsDouble->xdtTypeMatches(tn))
+        return toItem(Double::fromValue(newVal.as<Numeric>()->toDouble()));
+    else if(BuiltinTypes::xsFloat->xdtTypeMatches(to) || BuiltinTypes::xsFloat->xdtTypeMatches(tn))
+        return toItem(Float::fromValue(newVal.as<Numeric>()->toDouble()));
+    else if(BuiltinTypes::xsInteger->xdtTypeMatches(to) &&
+            BuiltinTypes::xsInteger->xdtTypeMatches(tn))
+        return newVal; /* Both must be xs:integer. */
+    else
+        return toItem(Decimal::fromValue(newVal.as<Numeric>()->toDecimal()));
+}
+
+template <AtomicComparator::Operator oper, AtomicComparator::ComparisonResult result>
+Item
+ComparingAggregator<oper, result>::evaluateSingleton(const DynamicContext::Ptr &context) const
+{
+    const Item::Iterator::Ptr it(m_operands.first()->evaluateSequence(context));
+    Item largest;
+
+    while(true)
+    {
+        Item next(it->next());
+
+        if(!next)
+        {
+            return largest;
+        }
+
+        AtomicComparator::Ptr comp(comparator());
+
+        if(!comp)
+        {
+            ItemType::Ptr t1(next.type());
+            Q_ASSERT(t1);
+
+            if(BuiltinTypes::xsUntypedAtomic->xdtTypeMatches(t1))
+            {
+                next = cast(next, context);
+                t1 = BuiltinTypes::xsDouble;
+            }
+
+            if(!largest)
+            {
+                largest = next;
+                continue;
+            }
+
+            Q_ASSERT(largest);
+            comp = fetchComparator(largest.type(), t1, context);
+            Q_ASSERT(comp);
+        }
+        else if(!largest)
+        {
+            largest = next;
+            continue;
+        }
+
+        if(comp->compare(next, operatorID(), largest) == result)
+        {
+            largest = applyNumericPromotion(largest, next, next);
+            continue;
+        }
+
+        const ItemType::Ptr t(next.type());
+
+        if(BuiltinTypes::xsDouble->xdtTypeMatches(t) &&
+           next.as<Numeric>()->isNaN())
+        {
+            return CommonValues::DoubleNaN;
+        }
+        else if(BuiltinTypes::xsFloat->xdtTypeMatches(t) &&
+                next.as<Numeric>()->isNaN())
+        {
+            if(BuiltinTypes::xsDouble->xdtTypeMatches(largest.type()))
+                return CommonValues::DoubleNaN;
+
+            /* If we have a xs:double somewhere, we must promote the NaN value to xs:double,
+             * and we really should raise error on invalid value. */
+            largest = it->next();
+
+            while(largest)
+            {
+                const ItemType::Ptr tf(largest.type());
+                if(BuiltinTypes::xsDouble->xdtTypeMatches(tf))
+                    return CommonValues::DoubleNaN;
+                else if(BuiltinTypes::xsUntypedAtomic->xdtTypeMatches(tf))
+                {
+                    /* Attempt a convert, which will raise an error if it doesn't work out. */
+                    cast(largest, context);
+                    return CommonValues::DoubleNaN;
+                }
+                else if(!BuiltinTypes::numeric->xdtTypeMatches(tf))
+                {
+                    fetchComparator(BuiltinTypes::xsFloat, tf, context);
+                }
+                else
+                    largest = it->next();
+            };
+
+            return CommonValues::FloatNaN;
+        }
+        else
+            largest = applyNumericPromotion(largest, next, largest);
+    }
+}
+
+template <AtomicComparator::Operator oper, AtomicComparator::ComparisonResult result>
+Expression::Ptr
+ComparingAggregator<oper, result>::typeCheck(const StaticContext::Ptr &context,
+                                             const SequenceType::Ptr &reqType)
+{
+    Q_ASSERT(oper == AtomicComparator::OperatorGreaterThan ||
+             oper == AtomicComparator::OperatorLessThan);
+    const Expression::Ptr me(FunctionCall::typeCheck(context, reqType));
+
+    ItemType::Ptr t1(m_operands.first()->staticType()->itemType());
+
+    if(*CommonSequenceTypes::Empty == *t1)
+        return EmptySequence::create(this, context);
+    else if(*BuiltinTypes::xsAnyAtomicType == *t1 ||
+            BuiltinTypes::numeric->xdtTypeMatches(t1))
+        return me;
+    else if(BuiltinTypes::xsUntypedAtomic->xdtTypeMatches(t1))
+    {
+        m_operands.replace(0, Expression::Ptr(new UntypedAtomicConverter(m_operands.first(),
+                           BuiltinTypes::xsDouble)));
+        t1 = m_operands.first()->staticType()->itemType();
+    }
+    else if(!BuiltinTypes::xsString->xdtTypeMatches(t1) &&
+            !BuiltinTypes::xsAnyURI->xdtTypeMatches(t1) &&
+            !BuiltinTypes::xsDayTimeDuration->xdtTypeMatches(t1) &&
+            !BuiltinTypes::xsDate->xdtTypeMatches(t1) &&
+            !BuiltinTypes::xsTime->xdtTypeMatches(t1) &&
+            !BuiltinTypes::xsDateTime->xdtTypeMatches(t1) &&
+            !BuiltinTypes::xsYearMonthDuration->xdtTypeMatches(t1))
+    {
+        context->error(QtXmlPatterns::tr("The first argument to %1 cannot be of type %2.")
+                          .arg(QPatternist::formatFunction(context->namePool(), signature()))
+                          .arg(formatType(context->namePool(), m_operands.first()->staticType())),
+                       ReportContext::FORG0006, this);
+        return me;
+    }
+
+    if(!m_operands.first()->staticType()->cardinality().allowsMany())
+        return m_operands.first();
+    
+    // explicit scope needed in RVCT
+    ComparingAggregator<oper, result>::prepareComparison(fetchComparator(t1, t1, context));
+
+    return me;
+}
+
diff --git a/src/xmlpatterns/functions/qdatetimefns.cpp b/src/xmlpatterns/functions/qdatetimefns.cpp
deleted file mode 100644
index 2108c4d..0000000
--- a/src/xmlpatterns/functions/qdatetimefns.cpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by qdatetimefns_p.h.
- * If you need includes in this file, put them in qdatetimefns_p.h, outside of the namespace.
- */
-
-template<typename TSubClass>
-Item ExtractFromDurationFN<TSubClass>::evaluateSingleton(const DynamicContext::Ptr &context) const
-{
-    const Item item(m_operands.first()->evaluateSingleton(context));
-    if(item)
-    {
-        return static_cast<const TSubClass *>(this)->
-               extract(item.as<AbstractDuration>());
-    }
-    else
-        return Item();
-}
-
-Item YearsFromDurationFN::extract(const AbstractDuration *const duration) const
-{
-    return Integer::fromValue(duration->years() * (duration->isPositive() ? 1 : -1));
-}
-
-Item MonthsFromDurationFN::extract(const AbstractDuration *const duration) const
-{
-    return Integer::fromValue(duration->months() * (duration->isPositive() ? 1 : -1));
-}
-
-Item DaysFromDurationFN::extract(const AbstractDuration *const duration) const
-{
-    return Integer::fromValue(duration->days() * (duration->isPositive() ? 1 : -1));
-}
-
-Item HoursFromDurationFN::extract(const AbstractDuration *const duration) const
-{
-    return Integer::fromValue(duration->hours() * (duration->isPositive() ? 1 : -1));
-}
-
-Item MinutesFromDurationFN::extract(const AbstractDuration *const duration) const
-{
-    return Integer::fromValue(duration->minutes() * (duration->isPositive() ? 1 : -1));
-}
-
-Item SecondsFromDurationFN::extract(const AbstractDuration *const duration) const
-{
-    return toItem(Decimal::fromValue((duration->seconds() + duration->mseconds() / 1000.0) *
-                                     (duration->isPositive() ? 1 : -1)));
-}
-
-template<typename TSubClass>
-Item ExtractFromDateTimeFN<TSubClass>::evaluateSingleton(const DynamicContext::Ptr &context) const
-{
-    const Item item(m_operands.first()->evaluateSingleton(context));
-    if(item)
-    {
-        return static_cast<const TSubClass *>(this)->
-               extract(item.as<AbstractDateTime>()->toDateTime());
-    }
-    else
-        return Item();
-}
-
-Item YearFromAbstractDateTimeFN::extract(const QDateTime &dt) const
-{
-    return Integer::fromValue(dt.date().year());
-}
-
-Item DayFromAbstractDateTimeFN::extract(const QDateTime &dt) const
-{
-    return Integer::fromValue(dt.date().day());
-}
-
-Item MinutesFromAbstractDateTimeFN::extract(const QDateTime &dt) const
-{
-    return Integer::fromValue(dt.time().minute());
-}
-
-Item SecondsFromAbstractDateTimeFN::extract(const QDateTime &dt) const
-{
-    const QTime time(dt.time());
-    return toItem(Decimal::fromValue(time.second() + time.msec() / 1000.0));
-}
-
-Item TimezoneFromAbstractDateTimeFN::extract(const QDateTime &dt) const
-{
-    if(dt.timeSpec() == Qt::UTC)
-        return toItem(CommonValues::DayTimeDurationZero);
-    else if(dt.timeSpec() == Qt::OffsetFromUTC)
-        return toItem(DayTimeDuration::fromSeconds(dt.utcOffset()));
-    else
-        return Item();
-}
-
-Item MonthFromAbstractDateTimeFN::extract(const QDateTime &dt) const
-{
-    return Integer::fromValue(dt.date().month());
-}
-
-Item HoursFromAbstractDateTimeFN::extract(const QDateTime &dt) const
-{
-    return Integer::fromValue(dt.time().hour());
-}
-
diff --git a/src/xmlpatterns/functions/qdatetimefns_p.h b/src/xmlpatterns/functions/qdatetimefns_p.h
index 0e9272e..8f23712 100644
--- a/src/xmlpatterns/functions/qdatetimefns_p.h
+++ b/src/xmlpatterns/functions/qdatetimefns_p.h
@@ -294,7 +294,7 @@ namespace QPatternist
         inline Item extract(const QDateTime &dt) const;
     };
 
-#include "qdatetimefns.cpp"
+#include "qdatetimefns_tpl_p.h"
 
 }
 
diff --git a/src/xmlpatterns/functions/qdatetimefns_tpl_p.h b/src/xmlpatterns/functions/qdatetimefns_tpl_p.h
new file mode 100644
index 0000000..2108c4d
--- /dev/null
+++ b/src/xmlpatterns/functions/qdatetimefns_tpl_p.h
@@ -0,0 +1,145 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by qdatetimefns_p.h.
+ * If you need includes in this file, put them in qdatetimefns_p.h, outside of the namespace.
+ */
+
+template<typename TSubClass>
+Item ExtractFromDurationFN<TSubClass>::evaluateSingleton(const DynamicContext::Ptr &context) const
+{
+    const Item item(m_operands.first()->evaluateSingleton(context));
+    if(item)
+    {
+        return static_cast<const TSubClass *>(this)->
+               extract(item.as<AbstractDuration>());
+    }
+    else
+        return Item();
+}
+
+Item YearsFromDurationFN::extract(const AbstractDuration *const duration) const
+{
+    return Integer::fromValue(duration->years() * (duration->isPositive() ? 1 : -1));
+}
+
+Item MonthsFromDurationFN::extract(const AbstractDuration *const duration) const
+{
+    return Integer::fromValue(duration->months() * (duration->isPositive() ? 1 : -1));
+}
+
+Item DaysFromDurationFN::extract(const AbstractDuration *const duration) const
+{
+    return Integer::fromValue(duration->days() * (duration->isPositive() ? 1 : -1));
+}
+
+Item HoursFromDurationFN::extract(const AbstractDuration *const duration) const
+{
+    return Integer::fromValue(duration->hours() * (duration->isPositive() ? 1 : -1));
+}
+
+Item MinutesFromDurationFN::extract(const AbstractDuration *const duration) const
+{
+    return Integer::fromValue(duration->minutes() * (duration->isPositive() ? 1 : -1));
+}
+
+Item SecondsFromDurationFN::extract(const AbstractDuration *const duration) const
+{
+    return toItem(Decimal::fromValue((duration->seconds() + duration->mseconds() / 1000.0) *
+                                     (duration->isPositive() ? 1 : -1)));
+}
+
+template<typename TSubClass>
+Item ExtractFromDateTimeFN<TSubClass>::evaluateSingleton(const DynamicContext::Ptr &context) const
+{
+    const Item item(m_operands.first()->evaluateSingleton(context));
+    if(item)
+    {
+        return static_cast<const TSubClass *>(this)->
+               extract(item.as<AbstractDateTime>()->toDateTime());
+    }
+    else
+        return Item();
+}
+
+Item YearFromAbstractDateTimeFN::extract(const QDateTime &dt) const
+{
+    return Integer::fromValue(dt.date().year());
+}
+
+Item DayFromAbstractDateTimeFN::extract(const QDateTime &dt) const
+{
+    return Integer::fromValue(dt.date().day());
+}
+
+Item MinutesFromAbstractDateTimeFN::extract(const QDateTime &dt) const
+{
+    return Integer::fromValue(dt.time().minute());
+}
+
+Item SecondsFromAbstractDateTimeFN::extract(const QDateTime &dt) const
+{
+    const QTime time(dt.time());
+    return toItem(Decimal::fromValue(time.second() + time.msec() / 1000.0));
+}
+
+Item TimezoneFromAbstractDateTimeFN::extract(const QDateTime &dt) const
+{
+    if(dt.timeSpec() == Qt::UTC)
+        return toItem(CommonValues::DayTimeDurationZero);
+    else if(dt.timeSpec() == Qt::OffsetFromUTC)
+        return toItem(DayTimeDuration::fromSeconds(dt.utcOffset()));
+    else
+        return Item();
+}
+
+Item MonthFromAbstractDateTimeFN::extract(const QDateTime &dt) const
+{
+    return Integer::fromValue(dt.date().month());
+}
+
+Item HoursFromAbstractDateTimeFN::extract(const QDateTime &dt) const
+{
+    return Integer::fromValue(dt.time().hour());
+}
+
diff --git a/src/xmlpatterns/parser/qmaintainingreader.cpp b/src/xmlpatterns/parser/qmaintainingreader.cpp
deleted file mode 100644
index 2222c01..0000000
--- a/src/xmlpatterns/parser/qmaintainingreader.cpp
+++ /dev/null
@@ -1,274 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by qcastingplatform_p.h.
- * If you need includes in this file, put them in CasttingPlatform.h,
- * outside of the namespace.
- */
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-MaintainingReader<TokenLookupClass, LookupKey>::MaintainingReader(const typename ElementDescription<TokenLookupClass, LookupKey>::Hash &elementDescriptions,
-                                                                  const QSet<typename TokenLookupClass::NodeName> &standardAttributes,
-                                                                  const ReportContext::Ptr &context,
-                                                                  QIODevice *const queryDevice) : QXmlStreamReader(queryDevice)
-                                                                                                , m_hasHandledStandardAttributes(false)
-                                                                                                , m_context(context)
-                                                                                                , m_elementDescriptions(elementDescriptions)
-                                                                                                , m_standardAttributes(standardAttributes)
-{
-    Q_ASSERT(m_context);
-    Q_ASSERT(!m_elementDescriptions.isEmpty());
-
-    /* We start with stripping. */
-    m_stripWhitespace.push(true);
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-MaintainingReader<TokenLookupClass, LookupKey>::~MaintainingReader()
-{
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-QSourceLocation MaintainingReader<TokenLookupClass, LookupKey>::currentLocation() const
-{
-    return QSourceLocation(documentURI(),
-                           lineNumber(),
-                           columnNumber());
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-QXmlStreamReader::TokenType MaintainingReader<TokenLookupClass, LookupKey>::readNext()
-{
-    const TokenType retval = QXmlStreamReader::readNext();
-
-    switch(retval)
-    {
-        case StartElement:
-        {
-            m_currentElementName = TokenLookupClass::toToken(name());
-            m_currentAttributes = attributes();
-            m_hasHandledStandardAttributes = false;
-
-            if(!m_currentAttributes.hasAttribute(QLatin1String("xml:space")))
-                m_stripWhitespace.push(m_stripWhitespace.top());
-            break;
-        }
-        case EndElement:
-            m_currentElementName = TokenLookupClass::toToken(name());
-            m_stripWhitespace.pop();
-            break;
-        default:
-            break;
-    }
-
-    return retval;
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-bool MaintainingReader<TokenLookupClass, LookupKey>::isWhitespace() const
-{
-    return QXmlStreamReader::isWhitespace()
-           || XPathHelper::isWhitespaceOnly(text());
-}
-
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-void MaintainingReader<TokenLookupClass, LookupKey>::error(const QString &message,
-                                                           const ReportContext::ErrorCode code) const
-{
-    m_context->error(message, code, currentLocation());
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-void MaintainingReader<TokenLookupClass, LookupKey>::warning(const QString &message) const
-{
-    m_context->warning(message, currentLocation());
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-typename TokenLookupClass::NodeName MaintainingReader<TokenLookupClass, LookupKey>::currentElementName() const
-{
-    return m_currentElementName;
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-void MaintainingReader<TokenLookupClass, LookupKey>::validateElement(const LookupKey elementName) const
-{
-    Q_ASSERT(tokenType() == QXmlStreamReader::StartElement);
-
-    if(m_elementDescriptions.contains(elementName))
-    {
-        // QHash::value breaks in Metrowerks Compiler
-        const ElementDescription<TokenLookupClass, LookupKey> &desc = *m_elementDescriptions.find(elementName);
-        const int attCount = m_currentAttributes.count();
-
-        QSet<typename TokenLookupClass::NodeName> encounteredXSLTAtts;
-
-        for(int i = 0; i < attCount; ++i)
-        {
-            const QXmlStreamAttribute &attr = m_currentAttributes.at(i);
-            if(attr.namespaceUri().isEmpty())
-            {
-                const typename TokenLookupClass::NodeName attrName(TokenLookupClass::toToken(attr.name()));
-                encounteredXSLTAtts.insert(attrName);
-
-                if(!desc.requiredAttributes.contains(attrName) &&
-                   !desc.optionalAttributes.contains(attrName) &&
-                   !m_standardAttributes.contains(attrName) &&
-                   !isAnyAttributeAllowed())
-                {
-                    QString translationString;
-
-                    QList<typename TokenLookupClass::NodeName> all(desc.requiredAttributes.toList() + desc.optionalAttributes.toList());
-                    const int totalCount = all.count();
-                    QStringList allowed;
-
-                    for(int i = 0; i < totalCount; ++i)
-                        allowed.append(QPatternist::formatKeyword(TokenLookupClass::toString(all.at(i))));
-
-                    /* Note, we can't run toString() on attrName, because we're in this branch,
-                     * the token lookup doesn't have the string(!).*/
-                    const QString stringedName(attr.name().toString());
-
-                    if(totalCount == 0)
-                    {
-                        translationString = QtXmlPatterns::tr("Attribute %1 cannot appear on the element %2. Only the standard attributes can appear.")
-                                            .arg(formatKeyword(stringedName),
-                                                 formatKeyword(name()));
-                    }
-                    else if(totalCount == 1)
-                    {
-                        translationString = QtXmlPatterns::tr("Attribute %1 cannot appear on the element %2. Only %3 is allowed, and the standard attributes.")
-                                            .arg(formatKeyword(stringedName),
-                                                 formatKeyword(name()),
-                                                 allowed.first());
-                    }
-                    else if(totalCount == 1)
-                    {
-                        /* Note, allowed has already had formatKeyword() applied. */
-                        translationString = QtXmlPatterns::tr("Attribute %1 cannot appear on the element %2. Allowed is %3, %4, and the standard attributes.")
-                                            .arg(formatKeyword(stringedName),
-                                                 formatKeyword(name()),
-                                                 allowed.first(),
-                                                 allowed.last());
-                    }
-                    else
-                    {
-                        /* Note, allowed has already had formatKeyword() applied. */
-                        translationString = QtXmlPatterns::tr("Attribute %1 cannot appear on the element %2. Allowed is %3, and the standard attributes.")
-                                            .arg(formatKeyword(stringedName),
-                                                 formatKeyword(name()),
-                                                 allowed.join(QLatin1String(", ")));
-                    }
-
-                    m_context->error(translationString,
-                                     ReportContext::XTSE0090,
-                                     currentLocation());
-                }
-            }
-            else if(attr.namespaceUri() == namespaceUri())
-            {
-                m_context->error(QtXmlPatterns::tr("XSL-T attributes on XSL-T elements must be in the null namespace, not in the XSL-T namespace which %1 is.")
-                                                  .arg(formatKeyword(attr.name())),
-                                 ReportContext::XTSE0090,
-                                 currentLocation());
-            }
-            /* Else, attributes in other namespaces are allowed, continue. */
-        }
-
-        const QSet<typename TokenLookupClass::NodeName> requiredButMissing(QSet<typename TokenLookupClass::NodeName>(desc.requiredAttributes).subtract(encounteredXSLTAtts));
-
-        if(!requiredButMissing.isEmpty())
-        {
-            error(QtXmlPatterns::tr("The attribute %1 must appear on element %2.")
-                             .arg(QPatternist::formatKeyword(TokenLookupClass::toString(*requiredButMissing.constBegin())),
-                                  formatKeyword(name())),
-                  ReportContext::XTSE0010);
-        }
-    }
-    else
-    {
-        error(QtXmlPatterns::tr("The element with local name %1 does not exist in XSL-T.").arg(formatKeyword(name())),
-              ReportContext::XTSE0010);
-    }
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-bool MaintainingReader<TokenLookupClass, LookupKey>::hasAttribute(const QString &namespaceURI,
-                                 const QString &localName) const
-{
-    Q_ASSERT(tokenType() == QXmlStreamReader::StartElement);
-    return m_currentAttributes.hasAttribute(namespaceURI, localName);
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-bool MaintainingReader<TokenLookupClass, LookupKey>::hasAttribute(const QString &localName) const
-{
-    return hasAttribute(QString(), localName);
-}
-
-template<typename TokenLookupClass,
-         typename LookupKey>
-QString MaintainingReader<TokenLookupClass, LookupKey>::readAttribute(const QString &localName,
-                                                                      const QString &namespaceURI) const
-{
-    Q_ASSERT(tokenType() == QXmlStreamReader::StartElement);
-
-    Q_ASSERT_X(m_currentAttributes.hasAttribute(namespaceURI, localName),
-               Q_FUNC_INFO,
-               "Validation must be done before this function is called.");
-
-    return m_currentAttributes.value(namespaceURI, localName).toString();
-}
-
diff --git a/src/xmlpatterns/parser/qmaintainingreader_p.h b/src/xmlpatterns/parser/qmaintainingreader_p.h
index f7ae407..a5d3132 100644
--- a/src/xmlpatterns/parser/qmaintainingreader_p.h
+++ b/src/xmlpatterns/parser/qmaintainingreader_p.h
@@ -223,7 +223,7 @@ namespace QPatternist
         Q_DISABLE_COPY(MaintainingReader)
     };
 
-#include "qmaintainingreader.cpp"
+#include "qmaintainingreader_tpl_p.h"
 
 }
 
diff --git a/src/xmlpatterns/parser/qmaintainingreader_tpl_p.h b/src/xmlpatterns/parser/qmaintainingreader_tpl_p.h
new file mode 100644
index 0000000..2222c01
--- /dev/null
+++ b/src/xmlpatterns/parser/qmaintainingreader_tpl_p.h
@@ -0,0 +1,274 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by qcastingplatform_p.h.
+ * If you need includes in this file, put them in CasttingPlatform.h,
+ * outside of the namespace.
+ */
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+MaintainingReader<TokenLookupClass, LookupKey>::MaintainingReader(const typename ElementDescription<TokenLookupClass, LookupKey>::Hash &elementDescriptions,
+                                                                  const QSet<typename TokenLookupClass::NodeName> &standardAttributes,
+                                                                  const ReportContext::Ptr &context,
+                                                                  QIODevice *const queryDevice) : QXmlStreamReader(queryDevice)
+                                                                                                , m_hasHandledStandardAttributes(false)
+                                                                                                , m_context(context)
+                                                                                                , m_elementDescriptions(elementDescriptions)
+                                                                                                , m_standardAttributes(standardAttributes)
+{
+    Q_ASSERT(m_context);
+    Q_ASSERT(!m_elementDescriptions.isEmpty());
+
+    /* We start with stripping. */
+    m_stripWhitespace.push(true);
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+MaintainingReader<TokenLookupClass, LookupKey>::~MaintainingReader()
+{
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+QSourceLocation MaintainingReader<TokenLookupClass, LookupKey>::currentLocation() const
+{
+    return QSourceLocation(documentURI(),
+                           lineNumber(),
+                           columnNumber());
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+QXmlStreamReader::TokenType MaintainingReader<TokenLookupClass, LookupKey>::readNext()
+{
+    const TokenType retval = QXmlStreamReader::readNext();
+
+    switch(retval)
+    {
+        case StartElement:
+        {
+            m_currentElementName = TokenLookupClass::toToken(name());
+            m_currentAttributes = attributes();
+            m_hasHandledStandardAttributes = false;
+
+            if(!m_currentAttributes.hasAttribute(QLatin1String("xml:space")))
+                m_stripWhitespace.push(m_stripWhitespace.top());
+            break;
+        }
+        case EndElement:
+            m_currentElementName = TokenLookupClass::toToken(name());
+            m_stripWhitespace.pop();
+            break;
+        default:
+            break;
+    }
+
+    return retval;
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+bool MaintainingReader<TokenLookupClass, LookupKey>::isWhitespace() const
+{
+    return QXmlStreamReader::isWhitespace()
+           || XPathHelper::isWhitespaceOnly(text());
+}
+
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+void MaintainingReader<TokenLookupClass, LookupKey>::error(const QString &message,
+                                                           const ReportContext::ErrorCode code) const
+{
+    m_context->error(message, code, currentLocation());
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+void MaintainingReader<TokenLookupClass, LookupKey>::warning(const QString &message) const
+{
+    m_context->warning(message, currentLocation());
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+typename TokenLookupClass::NodeName MaintainingReader<TokenLookupClass, LookupKey>::currentElementName() const
+{
+    return m_currentElementName;
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+void MaintainingReader<TokenLookupClass, LookupKey>::validateElement(const LookupKey elementName) const
+{
+    Q_ASSERT(tokenType() == QXmlStreamReader::StartElement);
+
+    if(m_elementDescriptions.contains(elementName))
+    {
+        // QHash::value breaks in Metrowerks Compiler
+        const ElementDescription<TokenLookupClass, LookupKey> &desc = *m_elementDescriptions.find(elementName);
+        const int attCount = m_currentAttributes.count();
+
+        QSet<typename TokenLookupClass::NodeName> encounteredXSLTAtts;
+
+        for(int i = 0; i < attCount; ++i)
+        {
+            const QXmlStreamAttribute &attr = m_currentAttributes.at(i);
+            if(attr.namespaceUri().isEmpty())
+            {
+                const typename TokenLookupClass::NodeName attrName(TokenLookupClass::toToken(attr.name()));
+                encounteredXSLTAtts.insert(attrName);
+
+                if(!desc.requiredAttributes.contains(attrName) &&
+                   !desc.optionalAttributes.contains(attrName) &&
+                   !m_standardAttributes.contains(attrName) &&
+                   !isAnyAttributeAllowed())
+                {
+                    QString translationString;
+
+                    QList<typename TokenLookupClass::NodeName> all(desc.requiredAttributes.toList() + desc.optionalAttributes.toList());
+                    const int totalCount = all.count();
+                    QStringList allowed;
+
+                    for(int i = 0; i < totalCount; ++i)
+                        allowed.append(QPatternist::formatKeyword(TokenLookupClass::toString(all.at(i))));
+
+                    /* Note, we can't run toString() on attrName, because we're in this branch,
+                     * the token lookup doesn't have the string(!).*/
+                    const QString stringedName(attr.name().toString());
+
+                    if(totalCount == 0)
+                    {
+                        translationString = QtXmlPatterns::tr("Attribute %1 cannot appear on the element %2. Only the standard attributes can appear.")
+                                            .arg(formatKeyword(stringedName),
+                                                 formatKeyword(name()));
+                    }
+                    else if(totalCount == 1)
+                    {
+                        translationString = QtXmlPatterns::tr("Attribute %1 cannot appear on the element %2. Only %3 is allowed, and the standard attributes.")
+                                            .arg(formatKeyword(stringedName),
+                                                 formatKeyword(name()),
+                                                 allowed.first());
+                    }
+                    else if(totalCount == 1)
+                    {
+                        /* Note, allowed has already had formatKeyword() applied. */
+                        translationString = QtXmlPatterns::tr("Attribute %1 cannot appear on the element %2. Allowed is %3, %4, and the standard attributes.")
+                                            .arg(formatKeyword(stringedName),
+                                                 formatKeyword(name()),
+                                                 allowed.first(),
+                                                 allowed.last());
+                    }
+                    else
+                    {
+                        /* Note, allowed has already had formatKeyword() applied. */
+                        translationString = QtXmlPatterns::tr("Attribute %1 cannot appear on the element %2. Allowed is %3, and the standard attributes.")
+                                            .arg(formatKeyword(stringedName),
+                                                 formatKeyword(name()),
+                                                 allowed.join(QLatin1String(", ")));
+                    }
+
+                    m_context->error(translationString,
+                                     ReportContext::XTSE0090,
+                                     currentLocation());
+                }
+            }
+            else if(attr.namespaceUri() == namespaceUri())
+            {
+                m_context->error(QtXmlPatterns::tr("XSL-T attributes on XSL-T elements must be in the null namespace, not in the XSL-T namespace which %1 is.")
+                                                  .arg(formatKeyword(attr.name())),
+                                 ReportContext::XTSE0090,
+                                 currentLocation());
+            }
+            /* Else, attributes in other namespaces are allowed, continue. */
+        }
+
+        const QSet<typename TokenLookupClass::NodeName> requiredButMissing(QSet<typename TokenLookupClass::NodeName>(desc.requiredAttributes).subtract(encounteredXSLTAtts));
+
+        if(!requiredButMissing.isEmpty())
+        {
+            error(QtXmlPatterns::tr("The attribute %1 must appear on element %2.")
+                             .arg(QPatternist::formatKeyword(TokenLookupClass::toString(*requiredButMissing.constBegin())),
+                                  formatKeyword(name())),
+                  ReportContext::XTSE0010);
+        }
+    }
+    else
+    {
+        error(QtXmlPatterns::tr("The element with local name %1 does not exist in XSL-T.").arg(formatKeyword(name())),
+              ReportContext::XTSE0010);
+    }
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+bool MaintainingReader<TokenLookupClass, LookupKey>::hasAttribute(const QString &namespaceURI,
+                                 const QString &localName) const
+{
+    Q_ASSERT(tokenType() == QXmlStreamReader::StartElement);
+    return m_currentAttributes.hasAttribute(namespaceURI, localName);
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+bool MaintainingReader<TokenLookupClass, LookupKey>::hasAttribute(const QString &localName) const
+{
+    return hasAttribute(QString(), localName);
+}
+
+template<typename TokenLookupClass,
+         typename LookupKey>
+QString MaintainingReader<TokenLookupClass, LookupKey>::readAttribute(const QString &localName,
+                                                                      const QString &namespaceURI) const
+{
+    Q_ASSERT(tokenType() == QXmlStreamReader::StartElement);
+
+    Q_ASSERT_X(m_currentAttributes.hasAttribute(namespaceURI, localName),
+               Q_FUNC_INFO,
+               "Validation must be done before this function is called.");
+
+    return m_currentAttributes.value(namespaceURI, localName).toString();
+}
+
diff --git a/src/xmlpatterns/schema/qxsdstatemachine.cpp b/src/xmlpatterns/schema/qxsdstatemachine.cpp
deleted file mode 100644
index 0dbf1d2..0000000
--- a/src/xmlpatterns/schema/qxsdstatemachine.cpp
+++ /dev/null
@@ -1,419 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*
- * NOTE: This file is included by qxsdstatemachine_p.h
- * if you need some includes, put them in qxsdstatemachine_p.h (outside of the namespace)
- */
-
-template <typename TransitionType>
-XsdStateMachine<TransitionType>::XsdStateMachine()
-    : m_counter(50)
-{
-}
-
-template <typename TransitionType>
-XsdStateMachine<TransitionType>::XsdStateMachine(const NamePool::Ptr &namePool)
-    : m_namePool(namePool)
-    , m_counter(50)
-{
-}
-
-template <typename TransitionType>
-typename XsdStateMachine<TransitionType>::StateId XsdStateMachine<TransitionType>::addState(StateType type)
-{
-#ifndef QT_NO_DEBUG
-    // make sure we don't have two start states
-    if (type == StartState) {
-        QHashIterator<StateId, StateType> it(m_states);
-        while (it.hasNext()) {
-            it.next();
-            Q_ASSERT(it.value() != StartState && it.value() != StartEndState);
-        }
-    }
-#endif // QT_NO_DEBUG
-
-    // reserve new state id
-    const StateId id = ++m_counter;
-    m_states.insert(id, type);
-
-    // if it is a start state, we make it to our current state
-    if (type == StartState || type == StartEndState)
-        m_currentState = id;
-
-    return id;
-}
-
-template <typename TransitionType>
-void XsdStateMachine<TransitionType>::addTransition(StateId start, TransitionType transition, StateId end)
-{
-    QHash<TransitionType, QVector<StateId> > &hash = m_transitions[start];
-    QVector<StateId> &states = hash[transition];
-    if (!states.contains(end))
-        states.append(end);
-}
-
-template <typename TransitionType>
-void XsdStateMachine<TransitionType>::addEpsilonTransition(StateId start, StateId end)
-{
-    QVector<StateId> &states = m_epsilonTransitions[start];
-    states.append(end);
-}
-
-template <typename TransitionType>
-void XsdStateMachine<TransitionType>::reset()
-{
-    // reset the machine to the start state
-    QHashIterator<StateId, StateType> it(m_states);
-    while (it.hasNext()) {
-        it.next();
-        if (it.value() == StartState || it.value() == StartEndState) {
-            m_currentState = it.key();
-            return;
-        }
-    }
-
-    Q_ASSERT(false);
-}
-
-template <typename TransitionType>
-void XsdStateMachine<TransitionType>::clear()
-{
-    m_states.clear();
-    m_transitions.clear();
-    m_epsilonTransitions.clear();
-    m_currentState = -1;
-    m_counter = 50;
-}
-
-template <typename TransitionType>
-bool XsdStateMachine<TransitionType>::proceed(TransitionType transition)
-{
-    // check that we are not in an invalid state
-    if (!m_transitions.contains(m_currentState)) {
-        return false;
-    }
-
-    // fetch the transition entry for the current state
-    const QHash<TransitionType, QVector<StateId> > &entry = m_transitions[m_currentState];
-    if (entry.contains(transition)) { // is there an transition for the given input?
-        m_currentState = entry.value(transition).first();
-        m_lastTransition = transition;
-        return true;
-    } else {
-        return false;
-    }
-}
-
-template <typename TransitionType>
-QList<TransitionType> XsdStateMachine<TransitionType>::possibleTransitions() const
-{
-    // check that we are not in an invalid state
-    if (!m_transitions.contains(m_currentState)) {
-        return QList<TransitionType>();
-    }
-
-    // fetch the transition entry for the current state
-    const QHash<TransitionType, QVector<StateId> > &entry = m_transitions[m_currentState];
-
-    return entry.keys();
-}
-
-template <typename TransitionType>
-template <typename InputType>
-bool XsdStateMachine<TransitionType>::proceed(InputType input)
-{
-    // check that we are not in an invalid state
-    if (!m_transitions.contains(m_currentState)) {
-        return false;
-    }
-
-    // fetch the transition entry for the current state
-    const QHash<TransitionType, QVector<StateId> > &entry = m_transitions[m_currentState];
-    QHashIterator<TransitionType, QVector<StateId> > it(entry);
-    while (it.hasNext()) {
-        it.next();
-        if (inputEqualsTransition(input, it.key())) {
-            m_currentState = it.value().first();
-            m_lastTransition = it.key();
-            return true;
-        }
-    }
-
-    return false;
-}
-
-template <typename TransitionType>
-template <typename InputType>
-bool XsdStateMachine<TransitionType>::inputEqualsTransition(InputType input, TransitionType transition) const
-{
-    return false;
-}
-
-template <typename TransitionType>
-bool XsdStateMachine<TransitionType>::inEndState() const
-{
-    // check if current state is an end state
-    return (m_states.value(m_currentState) == StartEndState || m_states.value(m_currentState) == EndState);
-}
-
-template <typename TransitionType>
-TransitionType XsdStateMachine<TransitionType>::lastTransition() const
-{
-    return m_lastTransition;
-}
-
-template <typename TransitionType>
-typename XsdStateMachine<TransitionType>::StateId XsdStateMachine<TransitionType>::startState() const
-{
-    QHashIterator<StateId, StateType> it(m_states);
-    while (it.hasNext()) {
-        it.next();
-        if (it.value() == StartState || it.value() == StartEndState)
-            return it.key();
-    }
-
-    Q_ASSERT(false); // should never be reached
-    return -1;
-}
-
-template <typename TransitionType>
-QString XsdStateMachine<TransitionType>::transitionTypeToString(TransitionType type) const
-{
-    Q_UNUSED(type)
-
-    return QString();
-}
-
-template <typename TransitionType>
-bool XsdStateMachine<TransitionType>::outputGraph(QIODevice *device, const QString &graphName) const
-{
-    if (!device->isOpen()) {
-        qWarning("device must be open for writing");
-        return false;
-    }
-
-    QByteArray graph;
-    QTextStream s(&graph);
-
-    QHashIterator<StateId, QHash<TransitionType, QVector<StateId> > > it(m_transitions);
-    QHashIterator<StateId, StateType> it3(m_states);
-
-    s << "digraph " << graphName << " {\n";
-    s << "  mindist = 2.0\n";
-
-    // draw edges
-    while (it.hasNext()) {
-        it.next();
-
-        QHashIterator<TransitionType, QVector<StateId> > it2(it.value());
-        while (it2.hasNext()) {
-            it2.next();
-            for (int i = 0; i < it2.value().count(); ++i)
-                s << "  " << it.key() << " -> " << it2.value().at(i) << " [label=\"" << transitionTypeToString(it2.key()) << "\"]\n";
-        }
-    }
-
-    QHashIterator<StateId, QVector<StateId> > it4(m_epsilonTransitions);
-    while (it4.hasNext()) {
-        it4.next();
-
-        const QVector<StateId> states = it4.value();
-        for (int i = 0; i < states.count(); ++i)
-            s << "  " << it4.key() << " -> " << states.at(i) << " [label=\"&#949;\"]\n";
-    }
-
-    // draw node infos
-    while (it3.hasNext()) {
-        it3.next();
-
-        QString style;
-        if (it3.value() == StartState) {
-            style = QLatin1String("shape=circle, style=filled, color=blue");
-        } else if (it3.value() == StartEndState) {
-            style = QLatin1String("shape=doublecircle, style=filled, color=blue");
-        } else if (it3.value() == InternalState) {
-            style = QLatin1String("shape=circle, style=filled, color=red");
-        } else if (it3.value() == EndState) {
-            style = QLatin1String("shape=doublecircle, style=filled, color=green");
-        }
-
-        s << "  " << it3.key() << " [" << style << "]\n";
-    }
-
-    s << "}\n";
-
-    s.flush();
-
-    if (device->write(graph) == -1)
-        return false;
-
-    return true;
-}
-
-
-template <typename TransitionType>
-typename XsdStateMachine<TransitionType>::StateId XsdStateMachine<TransitionType>::dfaStateForNfaState(QSet<StateId> nfaState,
-                                                                                                       QList< QPair<QSet<StateId>, StateId> > &stateTable,
-                                                                                                       XsdStateMachine<TransitionType> &dfa) const
-{
-    // check whether we have the given state in our lookup table
-    // already, in that case simply return it
-    for (int i = 0; i < stateTable.count(); ++i) {
-        if (stateTable.at(i).first == nfaState)
-            return stateTable.at(i).second;
-    }
-
-    // check if the NFA state set contains a Start or End
-    // state, in that case our new DFA state will be a
-    // Start or End state as well
-    StateType type = InternalState;
-    QSetIterator<StateId> it(nfaState);
-    bool hasStartState = false;
-    bool hasEndState = false;
-    while (it.hasNext()) {
-        const StateId state = it.next();
-        if (m_states.value(state) == EndState) {
-            hasEndState = true;
-        } else if (m_states.value(state) == StartState) {
-            hasStartState = true;
-        }
-    }
-    if (hasStartState) {
-        if (hasEndState)
-            type = StartEndState;
-        else
-            type = StartState;
-    } else if (hasEndState) {
-        type = EndState;
-    }
-
-    // create the new DFA state
-    const StateId dfaState = dfa.addState(type);
-
-    // add the new DFA state to the lookup table
-    stateTable.append(qMakePair<QSet<StateId>, StateId>(nfaState, dfaState));
-
-    return dfaState;
-}
-
-template <typename TransitionType>
-XsdStateMachine<TransitionType> XsdStateMachine<TransitionType>::toDFA() const
-{
-    XsdStateMachine<TransitionType> dfa(m_namePool);
-    dfa.m_counter = 100;
-    QList< QPair< QSet<StateId>, StateId> > table;
-    QList< QSet<StateId> > isMarked;
-
-    // search the start state as the algorithm starts with it...
-    StateId startState = -1;
-    QHashIterator<StateId, StateType> stateTypeIt(m_states);
-    while (stateTypeIt.hasNext()) {
-        stateTypeIt.next();
-        if (stateTypeIt.value() == StartState) {
-            startState = stateTypeIt.key();
-            break;
-        }
-    }
-    Q_ASSERT(startState != -1);
-
-    // our list of state set that still have to be processed
-    QList< QSet<StateId> > workStates;
-
-    // add the start state to the list of to processed state sets
-    workStates.append(epsilonClosure(QSet<StateId>() << startState));
-
-    while (!workStates.isEmpty()) { // as long as there are state sets to process left
-
-        // enqueue set of states
-        const QSet<StateId> states = workStates.takeFirst();
-
-        if (isMarked.contains(states)) // we processed this state set already
-            continue;
-
-        // mark as processed
-        isMarked.append(states);
-
-        // select a list of all inputs that are possible for
-        // the 'states' set
-        QList<TransitionType> input;
-
-        {
-            QSetIterator<StateId> it(states);
-            while (it.hasNext()) {
-                input << m_transitions.value(it.next()).keys();
-            }
-        }
-
-        // get the state in DFA that corresponds to the 'states' set in the NFA
-        const StateId dfaBegin = dfaStateForNfaState(states, table, dfa);
-
-        for (int i = 0; i < input.count(); ++i) { // for each possible input
-            // retrieve the states that can  be reached from the 'states' set by the
-            // given input or by epsilon transition
-            const QSet<StateId> followStates = epsilonClosure(move(states, input.at(i)));
-
-            // get the state in DFA that corresponds to the 'followStates' set in the NFA
-            const StateId dfaEnd = dfaStateForNfaState(followStates, table, dfa);
-
-            // adds a new transition to the DFA that corresponds to the transitions between
-            // 'states' and 'followStates' in the NFA
-            dfa.addTransition(dfaBegin, input.at(i), dfaEnd);
-
-            // add the 'followStates' to the list of to be processed state sets
-            workStates.append(followStates);
-        }
-    }
-
-    return dfa;
-}
-
-template <typename TransitionType>
-QHash<typename XsdStateMachine<TransitionType>::StateId, typename XsdStateMachine<TransitionType>::StateType> XsdStateMachine<TransitionType>::states() const
-{
-    return m_states;
-}
-
-template <typename TransitionType>
-QHash<typename XsdStateMachine<TransitionType>::StateId, QHash<TransitionType, QVector<typename XsdStateMachine<TransitionType>::StateId> > > XsdStateMachine<TransitionType>::transitions() const
-{
-    return m_transitions;
-}
diff --git a/src/xmlpatterns/schema/qxsdstatemachine_p.h b/src/xmlpatterns/schema/qxsdstatemachine_p.h
index 805d345..72a051e 100644
--- a/src/xmlpatterns/schema/qxsdstatemachine_p.h
+++ b/src/xmlpatterns/schema/qxsdstatemachine_p.h
@@ -292,7 +292,7 @@ namespace QPatternist
             TransitionType                                            m_lastTransition;
     };
 
-    #include "qxsdstatemachine.cpp"
+    #include "qxsdstatemachine_tpl_p.h"
 }
 
 QT_END_NAMESPACE
diff --git a/src/xmlpatterns/schema/qxsdstatemachine_tpl_p.h b/src/xmlpatterns/schema/qxsdstatemachine_tpl_p.h
new file mode 100644
index 0000000..0dbf1d2
--- /dev/null
+++ b/src/xmlpatterns/schema/qxsdstatemachine_tpl_p.h
@@ -0,0 +1,419 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*
+ * NOTE: This file is included by qxsdstatemachine_p.h
+ * if you need some includes, put them in qxsdstatemachine_p.h (outside of the namespace)
+ */
+
+template <typename TransitionType>
+XsdStateMachine<TransitionType>::XsdStateMachine()
+    : m_counter(50)
+{
+}
+
+template <typename TransitionType>
+XsdStateMachine<TransitionType>::XsdStateMachine(const NamePool::Ptr &namePool)
+    : m_namePool(namePool)
+    , m_counter(50)
+{
+}
+
+template <typename TransitionType>
+typename XsdStateMachine<TransitionType>::StateId XsdStateMachine<TransitionType>::addState(StateType type)
+{
+#ifndef QT_NO_DEBUG
+    // make sure we don't have two start states
+    if (type == StartState) {
+        QHashIterator<StateId, StateType> it(m_states);
+        while (it.hasNext()) {
+            it.next();
+            Q_ASSERT(it.value() != StartState && it.value() != StartEndState);
+        }
+    }
+#endif // QT_NO_DEBUG
+
+    // reserve new state id
+    const StateId id = ++m_counter;
+    m_states.insert(id, type);
+
+    // if it is a start state, we make it to our current state
+    if (type == StartState || type == StartEndState)
+        m_currentState = id;
+
+    return id;
+}
+
+template <typename TransitionType>
+void XsdStateMachine<TransitionType>::addTransition(StateId start, TransitionType transition, StateId end)
+{
+    QHash<TransitionType, QVector<StateId> > &hash = m_transitions[start];
+    QVector<StateId> &states = hash[transition];
+    if (!states.contains(end))
+        states.append(end);
+}
+
+template <typename TransitionType>
+void XsdStateMachine<TransitionType>::addEpsilonTransition(StateId start, StateId end)
+{
+    QVector<StateId> &states = m_epsilonTransitions[start];
+    states.append(end);
+}
+
+template <typename TransitionType>
+void XsdStateMachine<TransitionType>::reset()
+{
+    // reset the machine to the start state
+    QHashIterator<StateId, StateType> it(m_states);
+    while (it.hasNext()) {
+        it.next();
+        if (it.value() == StartState || it.value() == StartEndState) {
+            m_currentState = it.key();
+            return;
+        }
+    }
+
+    Q_ASSERT(false);
+}
+
+template <typename TransitionType>
+void XsdStateMachine<TransitionType>::clear()
+{
+    m_states.clear();
+    m_transitions.clear();
+    m_epsilonTransitions.clear();
+    m_currentState = -1;
+    m_counter = 50;
+}
+
+template <typename TransitionType>
+bool XsdStateMachine<TransitionType>::proceed(TransitionType transition)
+{
+    // check that we are not in an invalid state
+    if (!m_transitions.contains(m_currentState)) {
+        return false;
+    }
+
+    // fetch the transition entry for the current state
+    const QHash<TransitionType, QVector<StateId> > &entry = m_transitions[m_currentState];
+    if (entry.contains(transition)) { // is there an transition for the given input?
+        m_currentState = entry.value(transition).first();
+        m_lastTransition = transition;
+        return true;
+    } else {
+        return false;
+    }
+}
+
+template <typename TransitionType>
+QList<TransitionType> XsdStateMachine<TransitionType>::possibleTransitions() const
+{
+    // check that we are not in an invalid state
+    if (!m_transitions.contains(m_currentState)) {
+        return QList<TransitionType>();
+    }
+
+    // fetch the transition entry for the current state
+    const QHash<TransitionType, QVector<StateId> > &entry = m_transitions[m_currentState];
+
+    return entry.keys();
+}
+
+template <typename TransitionType>
+template <typename InputType>
+bool XsdStateMachine<TransitionType>::proceed(InputType input)
+{
+    // check that we are not in an invalid state
+    if (!m_transitions.contains(m_currentState)) {
+        return false;
+    }
+
+    // fetch the transition entry for the current state
+    const QHash<TransitionType, QVector<StateId> > &entry = m_transitions[m_currentState];
+    QHashIterator<TransitionType, QVector<StateId> > it(entry);
+    while (it.hasNext()) {
+        it.next();
+        if (inputEqualsTransition(input, it.key())) {
+            m_currentState = it.value().first();
+            m_lastTransition = it.key();
+            return true;
+        }
+    }
+
+    return false;
+}
+
+template <typename TransitionType>
+template <typename InputType>
+bool XsdStateMachine<TransitionType>::inputEqualsTransition(InputType input, TransitionType transition) const
+{
+    return false;
+}
+
+template <typename TransitionType>
+bool XsdStateMachine<TransitionType>::inEndState() const
+{
+    // check if current state is an end state
+    return (m_states.value(m_currentState) == StartEndState || m_states.value(m_currentState) == EndState);
+}
+
+template <typename TransitionType>
+TransitionType XsdStateMachine<TransitionType>::lastTransition() const
+{
+    return m_lastTransition;
+}
+
+template <typename TransitionType>
+typename XsdStateMachine<TransitionType>::StateId XsdStateMachine<TransitionType>::startState() const
+{
+    QHashIterator<StateId, StateType> it(m_states);
+    while (it.hasNext()) {
+        it.next();
+        if (it.value() == StartState || it.value() == StartEndState)
+            return it.key();
+    }
+
+    Q_ASSERT(false); // should never be reached
+    return -1;
+}
+
+template <typename TransitionType>
+QString XsdStateMachine<TransitionType>::transitionTypeToString(TransitionType type) const
+{
+    Q_UNUSED(type)
+
+    return QString();
+}
+
+template <typename TransitionType>
+bool XsdStateMachine<TransitionType>::outputGraph(QIODevice *device, const QString &graphName) const
+{
+    if (!device->isOpen()) {
+        qWarning("device must be open for writing");
+        return false;
+    }
+
+    QByteArray graph;
+    QTextStream s(&graph);
+
+    QHashIterator<StateId, QHash<TransitionType, QVector<StateId> > > it(m_transitions);
+    QHashIterator<StateId, StateType> it3(m_states);
+
+    s << "digraph " << graphName << " {\n";
+    s << "  mindist = 2.0\n";
+
+    // draw edges
+    while (it.hasNext()) {
+        it.next();
+
+        QHashIterator<TransitionType, QVector<StateId> > it2(it.value());
+        while (it2.hasNext()) {
+            it2.next();
+            for (int i = 0; i < it2.value().count(); ++i)
+                s << "  " << it.key() << " -> " << it2.value().at(i) << " [label=\"" << transitionTypeToString(it2.key()) << "\"]\n";
+        }
+    }
+
+    QHashIterator<StateId, QVector<StateId> > it4(m_epsilonTransitions);
+    while (it4.hasNext()) {
+        it4.next();
+
+        const QVector<StateId> states = it4.value();
+        for (int i = 0; i < states.count(); ++i)
+            s << "  " << it4.key() << " -> " << states.at(i) << " [label=\"&#949;\"]\n";
+    }
+
+    // draw node infos
+    while (it3.hasNext()) {
+        it3.next();
+
+        QString style;
+        if (it3.value() == StartState) {
+            style = QLatin1String("shape=circle, style=filled, color=blue");
+        } else if (it3.value() == StartEndState) {
+            style = QLatin1String("shape=doublecircle, style=filled, color=blue");
+        } else if (it3.value() == InternalState) {
+            style = QLatin1String("shape=circle, style=filled, color=red");
+        } else if (it3.value() == EndState) {
+            style = QLatin1String("shape=doublecircle, style=filled, color=green");
+        }
+
+        s << "  " << it3.key() << " [" << style << "]\n";
+    }
+
+    s << "}\n";
+
+    s.flush();
+
+    if (device->write(graph) == -1)
+        return false;
+
+    return true;
+}
+
+
+template <typename TransitionType>
+typename XsdStateMachine<TransitionType>::StateId XsdStateMachine<TransitionType>::dfaStateForNfaState(QSet<StateId> nfaState,
+                                                                                                       QList< QPair<QSet<StateId>, StateId> > &stateTable,
+                                                                                                       XsdStateMachine<TransitionType> &dfa) const
+{
+    // check whether we have the given state in our lookup table
+    // already, in that case simply return it
+    for (int i = 0; i < stateTable.count(); ++i) {
+        if (stateTable.at(i).first == nfaState)
+            return stateTable.at(i).second;
+    }
+
+    // check if the NFA state set contains a Start or End
+    // state, in that case our new DFA state will be a
+    // Start or End state as well
+    StateType type = InternalState;
+    QSetIterator<StateId> it(nfaState);
+    bool hasStartState = false;
+    bool hasEndState = false;
+    while (it.hasNext()) {
+        const StateId state = it.next();
+        if (m_states.value(state) == EndState) {
+            hasEndState = true;
+        } else if (m_states.value(state) == StartState) {
+            hasStartState = true;
+        }
+    }
+    if (hasStartState) {
+        if (hasEndState)
+            type = StartEndState;
+        else
+            type = StartState;
+    } else if (hasEndState) {
+        type = EndState;
+    }
+
+    // create the new DFA state
+    const StateId dfaState = dfa.addState(type);
+
+    // add the new DFA state to the lookup table
+    stateTable.append(qMakePair<QSet<StateId>, StateId>(nfaState, dfaState));
+
+    return dfaState;
+}
+
+template <typename TransitionType>
+XsdStateMachine<TransitionType> XsdStateMachine<TransitionType>::toDFA() const
+{
+    XsdStateMachine<TransitionType> dfa(m_namePool);
+    dfa.m_counter = 100;
+    QList< QPair< QSet<StateId>, StateId> > table;
+    QList< QSet<StateId> > isMarked;
+
+    // search the start state as the algorithm starts with it...
+    StateId startState = -1;
+    QHashIterator<StateId, StateType> stateTypeIt(m_states);
+    while (stateTypeIt.hasNext()) {
+        stateTypeIt.next();
+        if (stateTypeIt.value() == StartState) {
+            startState = stateTypeIt.key();
+            break;
+        }
+    }
+    Q_ASSERT(startState != -1);
+
+    // our list of state set that still have to be processed
+    QList< QSet<StateId> > workStates;
+
+    // add the start state to the list of to processed state sets
+    workStates.append(epsilonClosure(QSet<StateId>() << startState));
+
+    while (!workStates.isEmpty()) { // as long as there are state sets to process left
+
+        // enqueue set of states
+        const QSet<StateId> states = workStates.takeFirst();
+
+        if (isMarked.contains(states)) // we processed this state set already
+            continue;
+
+        // mark as processed
+        isMarked.append(states);
+
+        // select a list of all inputs that are possible for
+        // the 'states' set
+        QList<TransitionType> input;
+
+        {
+            QSetIterator<StateId> it(states);
+            while (it.hasNext()) {
+                input << m_transitions.value(it.next()).keys();
+            }
+        }
+
+        // get the state in DFA that corresponds to the 'states' set in the NFA
+        const StateId dfaBegin = dfaStateForNfaState(states, table, dfa);
+
+        for (int i = 0; i < input.count(); ++i) { // for each possible input
+            // retrieve the states that can  be reached from the 'states' set by the
+            // given input or by epsilon transition
+            const QSet<StateId> followStates = epsilonClosure(move(states, input.at(i)));
+
+            // get the state in DFA that corresponds to the 'followStates' set in the NFA
+            const StateId dfaEnd = dfaStateForNfaState(followStates, table, dfa);
+
+            // adds a new transition to the DFA that corresponds to the transitions between
+            // 'states' and 'followStates' in the NFA
+            dfa.addTransition(dfaBegin, input.at(i), dfaEnd);
+
+            // add the 'followStates' to the list of to be processed state sets
+            workStates.append(followStates);
+        }
+    }
+
+    return dfa;
+}
+
+template <typename TransitionType>
+QHash<typename XsdStateMachine<TransitionType>::StateId, typename XsdStateMachine<TransitionType>::StateType> XsdStateMachine<TransitionType>::states() const
+{
+    return m_states;
+}
+
+template <typename TransitionType>
+QHash<typename XsdStateMachine<TransitionType>::StateId, QHash<TransitionType, QVector<typename XsdStateMachine<TransitionType>::StateId> > > XsdStateMachine<TransitionType>::transitions() const
+{
+    return m_transitions;
+}
diff --git a/src/xmlpatterns/schema/qxsduserschematype.cpp b/src/xmlpatterns/schema/qxsduserschematype.cpp
deleted file mode 100644
index 841cdb2..0000000
--- a/src/xmlpatterns/schema/qxsduserschematype.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*
- * NOTE: This file is included by qxsduserschematype_p.h
- * if you need some includes, put them in qxsduserschematype_p.h (outside of the namespace)
- */
-
-template<typename TSuperClass>
-void XsdUserSchemaType<TSuperClass>::setName(const QXmlName &name)
-{
-    m_name = name;
-}
-
-template<typename TSuperClass>
-QXmlName XsdUserSchemaType<TSuperClass>::name(const NamePool::Ptr&) const
-{
-    return m_name;
-}
-
-template<typename TSuperClass>
-QString XsdUserSchemaType<TSuperClass>::displayName(const NamePool::Ptr &np) const
-{
-    return np->displayName(m_name);
-}
-
-template<typename TSuperClass>
-void XsdUserSchemaType<TSuperClass>::setDerivationConstraints(const SchemaType::DerivationConstraints &constraints)
-{
-    m_derivationConstraints = constraints;
-}
-
-template<typename TSuperClass>
-SchemaType::DerivationConstraints XsdUserSchemaType<TSuperClass>::derivationConstraints() const
-{
-    return m_derivationConstraints;
-}
diff --git a/src/xmlpatterns/schema/qxsduserschematype_p.h b/src/xmlpatterns/schema/qxsduserschematype_p.h
index 8c70441..b078689 100644
--- a/src/xmlpatterns/schema/qxsduserschematype_p.h
+++ b/src/xmlpatterns/schema/qxsduserschematype_p.h
@@ -114,7 +114,7 @@ namespace QPatternist
             SchemaType::DerivationConstraints m_derivationConstraints;
     };
 
-    #include "qxsduserschematype.cpp"
+    #include "qxsduserschematype_tpl_p.h"
 }
 
 QT_END_NAMESPACE
diff --git a/src/xmlpatterns/schema/qxsduserschematype_tpl_p.h b/src/xmlpatterns/schema/qxsduserschematype_tpl_p.h
new file mode 100644
index 0000000..841cdb2
--- /dev/null
+++ b/src/xmlpatterns/schema/qxsduserschematype_tpl_p.h
@@ -0,0 +1,75 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*
+ * NOTE: This file is included by qxsduserschematype_p.h
+ * if you need some includes, put them in qxsduserschematype_p.h (outside of the namespace)
+ */
+
+template<typename TSuperClass>
+void XsdUserSchemaType<TSuperClass>::setName(const QXmlName &name)
+{
+    m_name = name;
+}
+
+template<typename TSuperClass>
+QXmlName XsdUserSchemaType<TSuperClass>::name(const NamePool::Ptr&) const
+{
+    return m_name;
+}
+
+template<typename TSuperClass>
+QString XsdUserSchemaType<TSuperClass>::displayName(const NamePool::Ptr &np) const
+{
+    return np->displayName(m_name);
+}
+
+template<typename TSuperClass>
+void XsdUserSchemaType<TSuperClass>::setDerivationConstraints(const SchemaType::DerivationConstraints &constraints)
+{
+    m_derivationConstraints = constraints;
+}
+
+template<typename TSuperClass>
+SchemaType::DerivationConstraints XsdUserSchemaType<TSuperClass>::derivationConstraints() const
+{
+    return m_derivationConstraints;
+}
diff --git a/src/xmlpatterns/type/qbuiltinnodetype.cpp b/src/xmlpatterns/type/qbuiltinnodetype.cpp
deleted file mode 100644
index a3d0162..0000000
--- a/src/xmlpatterns/type/qbuiltinnodetype.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtXmlPatterns module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/**
- * @file
- * @short This file is included by BuiltintNodeType.h.
- * If you need includes in this file, put them in BuiltintNodeType.h, outside of the namespace.
- */
-
-template <const QXmlNodeModelIndex::NodeKind kind>
-BuiltinNodeType<kind>::BuiltinNodeType()
-{
-}
-
-template <const QXmlNodeModelIndex::NodeKind kind>
-bool BuiltinNodeType<kind>::xdtTypeMatches(const ItemType::Ptr &other) const
-{
-    if(!other->isNodeType())
-        return false;
-
-    return *static_cast<const BuiltinNodeType *>(other.data()) == *this
-            ? true
-            : xdtTypeMatches(other->xdtSuperType());
-}
-
-template <const QXmlNodeModelIndex::NodeKind kind>
-bool BuiltinNodeType<kind>::itemMatches(const Item &item) const
-{
-    Q_ASSERT(item);
-
-    return item.isNode() &&
-           item.asNode().kind() == kind;
-}
-
-template <const QXmlNodeModelIndex::NodeKind kind>
-ItemType::Ptr BuiltinNodeType<kind>::atomizedType() const
-{
-    switch(kind)
-    {
-        /* Fallthrough all these. */
-        case QXmlNodeModelIndex::Attribute:
-        case QXmlNodeModelIndex::Document:
-        case QXmlNodeModelIndex::Element:
-        case QXmlNodeModelIndex::Text:
-            return BuiltinTypes::xsUntypedAtomic;
-        case QXmlNodeModelIndex::ProcessingInstruction:
-        /* Fallthrough. */
-        case QXmlNodeModelIndex::Comment:
-            return BuiltinTypes::xsString;
-        default:
-        {
-            Q_ASSERT_X(false, Q_FUNC_INFO,
-                       "Encountered invalid XPath Data Model node type.");
-            return BuiltinTypes::xsUntypedAtomic;
-        }
-    }
-}
-
-template <const QXmlNodeModelIndex::NodeKind kind>
-QString BuiltinNodeType<kind>::displayName(const NamePool::Ptr &) const
-{
-    switch(kind)
-    {
-        case QXmlNodeModelIndex::Element:
-            return QLatin1String("element()");
-        case QXmlNodeModelIndex::Document:
-            return QLatin1String("document()");
-        case QXmlNodeModelIndex::Attribute:
-            return QLatin1String("attribute()");
-        case QXmlNodeModelIndex::Text:
-            return QLatin1String("text()");
-        case QXmlNodeModelIndex::ProcessingInstruction:
-            return QLatin1String("processing-instruction()");
-        case QXmlNodeModelIndex::Comment:
-            return QLatin1String("comment()");
-        default:
-        {
-            Q_ASSERT_X(false, Q_FUNC_INFO,
-                       "Encountered invalid XPath Data Model node type.");
-            return QString();
-        }
-    }
-}
-
-template <const QXmlNodeModelIndex::NodeKind kind>
-ItemType::Ptr BuiltinNodeType<kind>::xdtSuperType() const
-{
-    return BuiltinTypes::node;
-}
-
-template <const QXmlNodeModelIndex::NodeKind kind>
-QXmlNodeModelIndex::NodeKind BuiltinNodeType<kind>::nodeKind() const
-{
-    return kind;
-}
-
-template <const QXmlNodeModelIndex::NodeKind kind>
-PatternPriority BuiltinNodeType<kind>::patternPriority() const
-{
-    /* See XSL Transformations (XSLT) Version 2.0, 6.4 Conflict Resolution for
-     * Template Rules */
-    switch(kind)
-    {
-        case QXmlNodeModelIndex::Text:
-        /* Fallthrough. */
-        case QXmlNodeModelIndex::ProcessingInstruction:
-        /* Fallthrough. */
-        case QXmlNodeModelIndex::Comment:
-            /* "If the pattern is any other NodeTest, optionally preceded by a
-             * PatternAxis, then the priority is 0.5."
-             * Fallthrough. */
-        case QXmlNodeModelIndex::Attribute:
-        /* Fallthrough. */
-        case QXmlNodeModelIndex::Element:
-        /* Fallthrough. */
-        case QXmlNodeModelIndex::Document:
-            /* "If the pattern has the form /, then the priority is -0.5.". */
-            return -0.5;
-        default:
-        {
-            Q_ASSERT_X(false, Q_FUNC_INFO, "Unknown node type");
-            return 0;
-        }
-    }
-
-}
-
diff --git a/src/xmlpatterns/type/qbuiltinnodetype_p.h b/src/xmlpatterns/type/qbuiltinnodetype_p.h
index d179e53..99157ff 100644
--- a/src/xmlpatterns/type/qbuiltinnodetype_p.h
+++ b/src/xmlpatterns/type/qbuiltinnodetype_p.h
@@ -99,7 +99,7 @@ namespace QPatternist
         BuiltinNodeType();
     };
 
-#include "qbuiltinnodetype.cpp"
+#include "qbuiltinnodetype_tpl_p.h"
 
 }
 
diff --git a/src/xmlpatterns/type/qbuiltinnodetype_tpl_p.h b/src/xmlpatterns/type/qbuiltinnodetype_tpl_p.h
new file mode 100644
index 0000000..a3d0162
--- /dev/null
+++ b/src/xmlpatterns/type/qbuiltinnodetype_tpl_p.h
@@ -0,0 +1,165 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtXmlPatterns module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/**
+ * @file
+ * @short This file is included by BuiltintNodeType.h.
+ * If you need includes in this file, put them in BuiltintNodeType.h, outside of the namespace.
+ */
+
+template <const QXmlNodeModelIndex::NodeKind kind>
+BuiltinNodeType<kind>::BuiltinNodeType()
+{
+}
+
+template <const QXmlNodeModelIndex::NodeKind kind>
+bool BuiltinNodeType<kind>::xdtTypeMatches(const ItemType::Ptr &other) const
+{
+    if(!other->isNodeType())
+        return false;
+
+    return *static_cast<const BuiltinNodeType *>(other.data()) == *this
+            ? true
+            : xdtTypeMatches(other->xdtSuperType());
+}
+
+template <const QXmlNodeModelIndex::NodeKind kind>
+bool BuiltinNodeType<kind>::itemMatches(const Item &item) const
+{
+    Q_ASSERT(item);
+
+    return item.isNode() &&
+           item.asNode().kind() == kind;
+}
+
+template <const QXmlNodeModelIndex::NodeKind kind>
+ItemType::Ptr BuiltinNodeType<kind>::atomizedType() const
+{
+    switch(kind)
+    {
+        /* Fallthrough all these. */
+        case QXmlNodeModelIndex::Attribute:
+        case QXmlNodeModelIndex::Document:
+        case QXmlNodeModelIndex::Element:
+        case QXmlNodeModelIndex::Text:
+            return BuiltinTypes::xsUntypedAtomic;
+        case QXmlNodeModelIndex::ProcessingInstruction:
+        /* Fallthrough. */
+        case QXmlNodeModelIndex::Comment:
+            return BuiltinTypes::xsString;
+        default:
+        {
+            Q_ASSERT_X(false, Q_FUNC_INFO,
+                       "Encountered invalid XPath Data Model node type.");
+            return BuiltinTypes::xsUntypedAtomic;
+        }
+    }
+}
+
+template <const QXmlNodeModelIndex::NodeKind kind>
+QString BuiltinNodeType<kind>::displayName(const NamePool::Ptr &) const
+{
+    switch(kind)
+    {
+        case QXmlNodeModelIndex::Element:
+            return QLatin1String("element()");
+        case QXmlNodeModelIndex::Document:
+            return QLatin1String("document()");
+        case QXmlNodeModelIndex::Attribute:
+            return QLatin1String("attribute()");
+        case QXmlNodeModelIndex::Text:
+            return QLatin1String("text()");
+        case QXmlNodeModelIndex::ProcessingInstruction:
+            return QLatin1String("processing-instruction()");
+        case QXmlNodeModelIndex::Comment:
+            return QLatin1String("comment()");
+        default:
+        {
+            Q_ASSERT_X(false, Q_FUNC_INFO,
+                       "Encountered invalid XPath Data Model node type.");
+            return QString();
+        }
+    }
+}
+
+template <const QXmlNodeModelIndex::NodeKind kind>
+ItemType::Ptr BuiltinNodeType<kind>::xdtSuperType() const
+{
+    return BuiltinTypes::node;
+}
+
+template <const QXmlNodeModelIndex::NodeKind kind>
+QXmlNodeModelIndex::NodeKind BuiltinNodeType<kind>::nodeKind() const
+{
+    return kind;
+}
+
+template <const QXmlNodeModelIndex::NodeKind kind>
+PatternPriority BuiltinNodeType<kind>::patternPriority() const
+{
+    /* See XSL Transformations (XSLT) Version 2.0, 6.4 Conflict Resolution for
+     * Template Rules */
+    switch(kind)
+    {
+        case QXmlNodeModelIndex::Text:
+        /* Fallthrough. */
+        case QXmlNodeModelIndex::ProcessingInstruction:
+        /* Fallthrough. */
+        case QXmlNodeModelIndex::Comment:
+            /* "If the pattern is any other NodeTest, optionally preceded by a
+             * PatternAxis, then the priority is 0.5."
+             * Fallthrough. */
+        case QXmlNodeModelIndex::Attribute:
+        /* Fallthrough. */
+        case QXmlNodeModelIndex::Element:
+        /* Fallthrough. */
+        case QXmlNodeModelIndex::Document:
+            /* "If the pattern has the form /, then the priority is -0.5.". */
+            return -0.5;
+        default:
+        {
+            Q_ASSERT_X(false, Q_FUNC_INFO, "Unknown node type");
+            return 0;
+        }
+    }
+
+}
+