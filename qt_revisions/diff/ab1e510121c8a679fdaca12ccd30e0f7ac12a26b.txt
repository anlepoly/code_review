diff --git a/src/qml/qml.pro b/src/qml/qml.pro
index 0bbfc9f..acafb9f 100644
--- a/src/qml/qml.pro
+++ b/src/qml/qml.pro
@@ -6,7 +6,7 @@ QPRO_PWD   = $$PWD
 CONFIG += module
 MODULE_PRI += ../../modules/qt_qml.pri
 
-QT = core-private gui gui-private network v8-private
+QT = core-private network v8-private
 
 DEFINES   += QT_BUILD_QML_LIB QT_NO_URL_CAST_FROM_STRING QT_NO_INTEGER_EVENT_COORDINATES
 
diff --git a/src/qml/qml/qml.pri b/src/qml/qml/qml.pri
index 5d26197..fadfc9d 100644
--- a/src/qml/qml/qml.pri
+++ b/src/qml/qml/qml.pri
@@ -1,5 +1,4 @@
 SOURCES += \
-    $$PWD/qquickapplication.cpp \
     $$PWD/qqmlinstruction.cpp \
     $$PWD/qquicklistmodel.cpp \
     $$PWD/qquicklistmodelworkeragent.cpp \
@@ -51,6 +50,7 @@ SOURCES += \
     $$PWD/qqmljavascriptexpression.cpp \
     $$PWD/qqmlabstractbinding.cpp \
     $$PWD/qqmlvaluetypeproxybinding.cpp \
+    $$PWD/qqmlglobal.cpp \
 
 HEADERS += \
     $$PWD/qqmlglobal_p.h \
@@ -61,7 +61,6 @@ HEADERS += \
     $$PWD/qqmlopenmetaobject_p.h \
     $$PWD/qqmlvmemetaobject_p.h \
     $$PWD/qqml.h \
-    $$PWD/qquickapplication_p.h \
     $$PWD/qqmlbinding_p.h \
     $$PWD/qqmlproperty.h \
     $$PWD/qqmlcomponent.h \
diff --git a/src/qml/qml/qqmlcompiler.cpp b/src/qml/qml/qqmlcompiler.cpp
index 51343b6..c3b8152 100644
--- a/src/qml/qml/qqmlcompiler.cpp
+++ b/src/qml/qml/qqmlcompiler.cpp
@@ -63,7 +63,6 @@
 #include "qqmlbinding_p.h"
 #include <private/qv4compiler_p.h>
 
-#include <QColor>
 #include <QDebug>
 #include <QPointF>
 #include <QSizeF>
@@ -350,16 +349,16 @@ bool QQmlCompiler::testLiteralAssignment(QQmlScript::Property *prop,
             break;
         case QVariant::Vector3D:
             {
-            bool ok;
-            QQmlStringConverters::vector3DFromString(value.asString(), &ok);
-            if (!ok) COMPILE_EXCEPTION(v, tr("Invalid property assignment: 3D vector expected"));
+            QQmlInstruction::instr_storeVector3D::QVector3D v3;
+            if (!QQmlStringConverters::createFromString(QMetaType::QVector3D, value.asString(), &v3, sizeof(v3)))
+                COMPILE_EXCEPTION(v, tr("Invalid property assignment: 3D vector expected"));
             }
             break;
         case QVariant::Vector4D:
             {
-            bool ok;
-            QQmlStringConverters::vector4DFromString(value.asString(), &ok);
-            if (!ok) COMPILE_EXCEPTION(v, tr("Invalid property assignment: 4D vector expected"));
+            QQmlInstruction::instr_storeVector4D::QVector4D v4;
+            if (!QQmlStringConverters::createFromString(QMetaType::QVector4D, value.asString(), &v4, sizeof(v4)))
+                COMPILE_EXCEPTION(v, tr("Invalid property assignment: 4D vector expected"));
             }
             break;
         default:
@@ -564,9 +563,8 @@ void QQmlCompiler::genLiteralAssignment(QQmlScript::Property *prop,
         case QVariant::Color:
             {
             Instruction::StoreColor instr;
-            QColor c = QQmlStringConverters::colorFromString(v->value.asString());
             instr.propertyIndex = prop->index;
-            instr.value = c.rgba();
+            instr.value = QQmlStringConverters::rgbaFromString(v->value.asString());
             output->addInstruction(instr);
             }
             break;
@@ -685,25 +683,16 @@ void QQmlCompiler::genLiteralAssignment(QQmlScript::Property *prop,
         case QVariant::Vector3D:
             {
             Instruction::StoreVector3D instr;
-            bool ok;
-            QVector3D vector = QQmlStringConverters::vector3DFromString(v->value.asString(), &ok);
             instr.propertyIndex = prop->index;
-            instr.vector.xp = vector.x();
-            instr.vector.yp = vector.y();
-            instr.vector.zp = vector.z();
+            QQmlStringConverters::createFromString(QMetaType::QVector3D, v->value.asString(), &instr.vector, sizeof(instr.vector));
             output->addInstruction(instr);
             }
             break;
     case QVariant::Vector4D:
             {
             Instruction::StoreVector4D instr;
-            bool ok;
-            QVector4D vector = QQmlStringConverters::vector4DFromString(v->value.asString(), &ok);
             instr.propertyIndex = prop->index;
-            instr.vector.xp = vector.x();
-            instr.vector.yp = vector.y();
-            instr.vector.zp = vector.z();
-            instr.vector.wp = vector.w();
+            QQmlStringConverters::createFromString(QMetaType::QVector4D, v->value.asString(), &instr.vector, sizeof(instr.vector));
             output->addInstruction(instr);
             }
             break;
diff --git a/src/qml/qml/qqmlengine.cpp b/src/qml/qml/qqmlengine.cpp
index 16cd1ec..b1fcadd 100644
--- a/src/qml/qml/qqmlengine.cpp
+++ b/src/qml/qml/qqmlengine.cpp
@@ -65,7 +65,6 @@
 #include "qqmltypenamecache_p.h"
 #include "qqmlnotifier_p.h"
 #include <private/qqmlprofilerservice_p.h>
-#include <private/qquickapplication_p.h>
 #include <private/qv8debugservice_p.h>
 #include <private/qdebugmessageservice_p.h>
 #include "qqmlincubator.h"
@@ -174,7 +173,6 @@ void QQmlEnginePrivate::registerBaseTypes(const char *uri, int versionMajor, int
 void QQmlEnginePrivate::defineModule()
 {
     registerBaseTypes("QtQuick", 2, 0);
-    qmlRegisterUncreatableType<QQuickApplication>("QtQuick",2,0,"Application", QQuickApplication::tr("Application is an abstract class"));
     qmlRegisterUncreatableType<QQmlLocale>("QtQuick",2,0,"Locale",QQmlEngine::tr("Locale cannot be instantiated.  Use Qt.locale()"));
 }
 
diff --git a/src/qml/qml/qqmlglobal.cpp b/src/qml/qml/qqmlglobal.cpp
new file mode 100644
index 0000000..1f8de4f
--- /dev/null
+++ b/src/qml/qml/qqmlglobal.cpp
@@ -0,0 +1,336 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <private/qqmlglobal_p.h>
+
+#include <QtCore/qvariant.h>
+#include <QtCore/qstringlist.h>
+#include <QtCore/qdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+QQmlValueTypeProvider::QQmlValueTypeProvider()
+    : next(0)
+{
+}
+
+QQmlValueType *QQmlValueTypeProvider::createValueType(int type)
+{
+    QQmlValueType *value = 0;
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->create(type, value))
+            return value;
+    } while ((p = p->next));
+
+    return 0;
+}
+
+bool QQmlValueTypeProvider::initValueType(int type, void *data, size_t n)
+{
+    Q_ASSERT(data);
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->init(type, data, n))
+            return true;
+    } while ((p = p->next));
+
+    return false;
+}
+
+bool QQmlValueTypeProvider::destroyValueType(int type, void *data, size_t n)
+{
+    Q_ASSERT(data);
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->destroy(type, data, n))
+            return true;
+    } while ((p = p->next));
+
+    return false;
+}
+
+bool QQmlValueTypeProvider::copyValueType(int type, const void *src, void *dst, size_t n)
+{
+    Q_ASSERT(src);
+    Q_ASSERT(dst);
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->copy(type, src, dst, n))
+            return true;
+    } while ((p = p->next));
+
+    return false;
+}
+
+QVariant QQmlValueTypeProvider::createValueType(int type, int argc, const void *argv[])
+{
+    QVariant v;
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->create(type, argc, argv, &v))
+            return v;
+    } while ((p = p->next));
+
+    return QVariant();
+}
+
+bool QQmlValueTypeProvider::createValueFromString(int type, const QString &s, void *data, size_t n)
+{
+    Q_ASSERT(data);
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->createFromString(type, s, data, n))
+            return true;
+    } while ((p = p->next));
+
+    return false;
+}
+
+bool QQmlValueTypeProvider::createStringFromValue(int type, const void *data, QString *s)
+{
+    Q_ASSERT(data);
+    Q_ASSERT(s);
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->createStringFrom(type, data, s))
+            return true;
+    } while ((p = p->next));
+
+    return false;
+}
+
+QVariant QQmlValueTypeProvider::createVariantFromString(const QString &s)
+{
+    QVariant v;
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->variantFromString(s, &v))
+            return v;
+    } while ((p = p->next));
+
+    // Return a variant containing the string itself
+    return QVariant(s);
+}
+
+QVariant QQmlValueTypeProvider::createVariantFromString(int type, const QString &s, bool *ok)
+{
+    QVariant v;
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->variantFromString(type, s, &v)) {
+            if (ok) *ok = true;
+            return v;
+        }
+    } while ((p = p->next));
+
+    if (ok) *ok = false;
+    return QVariant();
+}
+
+bool QQmlValueTypeProvider::storeValueType(int type, const void *src, void *dst, size_t n)
+{
+    Q_ASSERT(src);
+    Q_ASSERT(dst);
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->store(type, src, dst, n))
+            return true;
+    } while ((p = p->next));
+
+    return false;
+}
+
+bool QQmlValueTypeProvider::readValueType(int srcType, const void *src, int dstType, void *dst)
+{
+    Q_ASSERT(src);
+    Q_ASSERT(dst);
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->read(srcType, src, dstType, dst))
+            return true;
+    } while ((p = p->next));
+
+    return false;
+}
+
+bool QQmlValueTypeProvider::writeValueType(int type, const void *src, void *dst, size_t n)
+{
+    Q_ASSERT(src);
+    Q_ASSERT(dst);
+
+    QQmlValueTypeProvider *p = this;
+    do {
+        if (p->write(type, src, dst, n))
+            return true;
+    } while ((p = p->next));
+
+    return false;
+}
+
+bool QQmlValueTypeProvider::create(int, QQmlValueType *&) { return false; }
+bool QQmlValueTypeProvider::init(int, void *, size_t) { return false; }
+bool QQmlValueTypeProvider::destroy(int, void *, size_t) { return false; }
+bool QQmlValueTypeProvider::copy(int, const void *, void *, size_t) { return false; }
+bool QQmlValueTypeProvider::create(int, int, const void *[], QVariant *) { return false; }
+bool QQmlValueTypeProvider::createFromString(int, const QString &, void *, size_t) { return false; }
+bool QQmlValueTypeProvider::createStringFrom(int, const void *, QString *) { return false; }
+bool QQmlValueTypeProvider::variantFromString(const QString &, QVariant *) { return false; }
+bool QQmlValueTypeProvider::variantFromString(int, const QString &, QVariant *) { return false; }
+bool QQmlValueTypeProvider::store(int, const void *, void *, size_t) { return false; }
+bool QQmlValueTypeProvider::read(int, const void *, int, void *) { return false; }
+bool QQmlValueTypeProvider::write(int, const void *, void *, size_t) { return false; }
+
+static QQmlValueTypeProvider *valueTypeProvider = 0;
+
+static QQmlValueTypeProvider **getValueTypeProvider(void)
+{
+    if (valueTypeProvider == 0) {
+        static QQmlValueTypeProvider nullValueTypeProvider;
+        valueTypeProvider = &nullValueTypeProvider;
+    }
+
+    return &valueTypeProvider;
+}
+
+Q_QML_PRIVATE_EXPORT void QQml_addValueTypeProvider(QQmlValueTypeProvider *newProvider)
+{
+    static QQmlValueTypeProvider **providerPtr = getValueTypeProvider();
+    newProvider->next = *providerPtr;
+    *providerPtr = newProvider;
+}
+
+Q_AUTOTEST_EXPORT QQmlValueTypeProvider *QQml_valueTypeProvider(void)
+{
+    if (valueTypeProvider == 0) {
+        qWarning() << "Warning: QQml_valueTypeProvider: no value type provider has been set!";
+    }
+
+    static QQmlValueTypeProvider **providerPtr = getValueTypeProvider();
+    return *providerPtr;
+}
+
+
+QVariant QQmlColorProvider::colorFromString(const QString &, bool *ok) { if (ok) *ok = false; return QVariant(); }
+unsigned QQmlColorProvider::rgbaFromString(const QString &, bool *ok) { if (ok) *ok = false; return 0; }
+QVariant QQmlColorProvider::fromRgbF(double, double, double, double) { return QVariant(); }
+QVariant QQmlColorProvider::fromHslF(double, double, double, double) { return QVariant(); }
+QVariant QQmlColorProvider::lighter(const QVariant &, qreal) { return QVariant(); }
+QVariant QQmlColorProvider::darker(const QVariant &, qreal) { return QVariant(); }
+QVariant QQmlColorProvider::tint(const QVariant &, const QVariant &) { return QVariant(); }
+
+static QQmlColorProvider *colorProvider = 0;
+
+Q_QML_PRIVATE_EXPORT QQmlColorProvider *QQml_setColorProvider(QQmlColorProvider *newProvider)
+{
+    QQmlColorProvider *old = colorProvider;
+    colorProvider = newProvider;
+    return old;
+}
+
+static QQmlColorProvider **getColorProvider(void)
+{
+    if (colorProvider == 0) {
+        qWarning() << "Warning: QQml_colorProvider: no color provider has been set!";
+        static QQmlColorProvider nullColorProvider;
+        colorProvider = &nullColorProvider;
+    }
+
+    return &colorProvider;
+}
+
+Q_AUTOTEST_EXPORT QQmlColorProvider *QQml_colorProvider(void)
+{
+    static QQmlColorProvider **providerPtr = getColorProvider();
+    return *providerPtr;
+}
+
+
+QObject *QQmlGuiProvider::application(QObject *) { return 0; }
+QStringList QQmlGuiProvider::fontFamilies() { return QStringList(); }
+bool QQmlGuiProvider::openUrlExternally(QUrl &) { return false; }
+
+QObject *QQmlGuiProvider::inputMethod()
+{
+    // We don't have any input method code by default
+    QObject *o = new QObject();
+    o->setObjectName(QString::fromAscii("No inputMethod available"));
+    return o;
+}
+
+static QQmlGuiProvider *guiProvider = 0;
+
+Q_QML_PRIVATE_EXPORT QQmlGuiProvider *QQml_setGuiProvider(QQmlGuiProvider *newProvider)
+{
+    QQmlGuiProvider *old = guiProvider;
+    guiProvider = newProvider;
+    return old;
+}
+
+static QQmlGuiProvider **getGuiProvider(void)
+{
+    if (guiProvider == 0) {
+        qWarning() << "Warning: QQml_guiProvider: no GUI provider has been set!";
+        static QQmlGuiProvider nullGuiProvider;
+        guiProvider = &nullGuiProvider;
+    }
+
+    return &guiProvider;
+}
+
+Q_AUTOTEST_EXPORT QQmlGuiProvider *QQml_guiProvider(void)
+{
+    static QQmlGuiProvider **providerPtr = getGuiProvider();
+    return *providerPtr;
+}
+
+QT_END_NAMESPACE
diff --git a/src/qml/qml/qqmlglobal_p.h b/src/qml/qml/qqmlglobal_p.h
index c41b823..2356b2d 100644
--- a/src/qml/qml/qqmlglobal_p.h
+++ b/src/qml/qml/qqmlglobal_p.h
@@ -42,7 +42,7 @@
 #ifndef QQMLGLOBAL_H
 #define QQMLGLOBAL_H
 
-#include <QtCore/qglobal.h>
+#include <private/qtqmlglobal_p.h>
 #include <QtCore/QObject>
 
 QT_BEGIN_HEADER
@@ -122,6 +122,87 @@ inline void QQml_setParent_noEvent(QObject *object, QObject *parent)
     static_cast<QQmlGraphics_DerivedObject *>(object)->setParent_noEvent(parent);
 }
 
+
+class QQmlValueType;
+
+class Q_QML_PRIVATE_EXPORT QQmlValueTypeProvider
+{
+public:
+    QQmlValueTypeProvider();
+
+    QQmlValueType *createValueType(int);
+
+    bool initValueType(int, void *, size_t);
+    bool destroyValueType(int, void *, size_t);
+    bool copyValueType(int, const void *, void *, size_t);
+
+    QVariant createValueType(int, int, const void *[]);
+    bool createValueFromString(int, const QString &, void *, size_t);
+    bool createStringFromValue(int, const void *, QString *);
+
+    QVariant createVariantFromString(const QString &);
+    QVariant createVariantFromString(int, const QString &, bool *);
+
+    bool storeValueType(int, const void *, void *, size_t);
+    bool readValueType(int, const void *, int, void *);
+    bool writeValueType(int, const void *, void *, size_t);
+
+private:
+    virtual bool create(int, QQmlValueType *&);
+
+    virtual bool init(int, void *, size_t);
+    virtual bool destroy(int, void *, size_t);
+    virtual bool copy(int, const void *, void *, size_t);
+
+    virtual bool create(int, int, const void *[], QVariant *);
+    virtual bool createFromString(int, const QString &, void *, size_t);
+    virtual bool createStringFrom(int, const void *, QString *);
+
+    virtual bool variantFromString(const QString &, QVariant *);
+    virtual bool variantFromString(int, const QString &, QVariant *);
+
+    virtual bool store(int, const void *, void *, size_t);
+    virtual bool read(int, const void *, int, void *);
+    virtual bool write(int, const void *, void *, size_t);
+
+    friend Q_QML_PRIVATE_EXPORT void QQml_addValueTypeProvider(QQmlValueTypeProvider *);
+
+    QQmlValueTypeProvider *next;
+};
+
+Q_QML_PRIVATE_EXPORT void QQml_addValueTypeProvider(QQmlValueTypeProvider *);
+Q_AUTOTEST_EXPORT QQmlValueTypeProvider *QQml_valueTypeProvider();
+
+
+class Q_QML_PRIVATE_EXPORT QQmlColorProvider
+{
+public:
+    virtual QVariant colorFromString(const QString &, bool *);
+    virtual unsigned rgbaFromString(const QString &, bool *);
+
+    virtual QVariant fromRgbF(double, double, double, double);
+    virtual QVariant fromHslF(double, double, double, double);
+    virtual QVariant lighter(const QVariant &, qreal);
+    virtual QVariant darker(const QVariant &, qreal);
+    virtual QVariant tint(const QVariant &, const QVariant &);
+};
+
+Q_QML_PRIVATE_EXPORT QQmlColorProvider *QQml_setColorProvider(QQmlColorProvider *);
+Q_AUTOTEST_EXPORT QQmlColorProvider *QQml_colorProvider();
+
+
+class Q_QML_PRIVATE_EXPORT QQmlGuiProvider
+{
+public:
+    virtual QObject *application(QObject *parent);
+    virtual QObject *inputMethod();
+    virtual QStringList fontFamilies();
+    virtual bool openUrlExternally(QUrl &);
+};
+
+Q_QML_PRIVATE_EXPORT QQmlGuiProvider *QQml_setGuiProvider(QQmlGuiProvider *);
+Q_AUTOTEST_EXPORT QQmlGuiProvider *QQml_guiProvider();
+
 QT_END_NAMESPACE
 
 QT_END_HEADER
diff --git a/src/qml/qml/qqmlstringconverters.cpp b/src/qml/qml/qqmlstringconverters.cpp
index 2c7f6c9..473097f 100644
--- a/src/qml/qml/qqmlstringconverters.cpp
+++ b/src/qml/qml/qqmlstringconverters.cpp
@@ -40,10 +40,9 @@
 ****************************************************************************/
 
 #include "qqmlstringconverters_p.h"
+#include <private/qqmlglobal_p.h>
+#include <private/qqmlinstruction_p.h>
 
-#include <QtGui/qcolor.h>
-#include <QtGui/qvector3d.h>
-#include <QtGui/qvector4d.h>
 #include <QtCore/qpoint.h>
 #include <QtCore/qrect.h>
 #include <QtCore/qsize.h>
@@ -52,52 +51,20 @@
 
 QT_BEGIN_NAMESPACE
 
-static uchar fromHex(const uchar c, const uchar c2)
-{
-    uchar rv = 0;
-    if (c >= '0' && c <= '9')
-        rv += (c - '0') * 16;
-    else if (c >= 'A' && c <= 'F')
-        rv += (c - 'A' + 10) * 16;
-    else if (c >= 'a' && c <= 'f')
-        rv += (c - 'a' + 10) * 16;
-
-    if (c2 >= '0' && c2 <= '9')
-        rv += (c2 - '0');
-    else if (c2 >= 'A' && c2 <= 'F')
-        rv += (c2 - 'A' + 10);
-    else if (c2 >= 'a' && c2 <= 'f')
-        rv += (c2 - 'a' + 10);
-
-    return rv;
-}
-
-static uchar fromHex(const QString &s, int idx)
-{
-    uchar c = s.at(idx).toAscii();
-    uchar c2 = s.at(idx + 1).toAscii();
-    return fromHex(c, c2);
-}
-
 QVariant QQmlStringConverters::variantFromString(const QString &s)
 {
     if (s.isEmpty())
         return QVariant(s);
+
     bool ok = false;
     QRectF r = rectFFromString(s, &ok);
     if (ok) return QVariant(r);
-    QColor c = colorFromString(s, &ok);
-    if (ok) return QVariant(c);
     QPointF p = pointFFromString(s, &ok);
     if (ok) return QVariant(p);
     QSizeF sz = sizeFFromString(s, &ok);
     if (ok) return QVariant(sz);
-    QVector3D v = vector3DFromString(s, &ok);
-    if (ok) return QVariant::fromValue(v);
-    QVector4D v4 = vector4DFromString(s, &ok);
-    if (ok) return QVariant::fromValue(v4);
 
-    return QVariant(s);
+    return QQml_valueTypeProvider()->createVariantFromString(s);
 }
 
 QVariant QQmlStringConverters::variantFromString(const QString &s, int preferredType, bool *ok)
@@ -107,8 +74,6 @@ QVariant QQmlStringConverters::variantFromString(const QString &s, int preferred
         return QVariant(int(qRound(s.toDouble(ok))));
     case QMetaType::UInt:
         return QVariant(uint(qRound(s.toDouble(ok))));
-    case QMetaType::QColor:
-        return QVariant::fromValue(colorFromString(s, ok));
 #ifndef QT_NO_DATESTRING
     case QMetaType::QDate:
         return QVariant::fromValue(dateFromString(s, ok));
@@ -129,30 +94,19 @@ QVariant QQmlStringConverters::variantFromString(const QString &s, int preferred
         return QVariant::fromValue(rectFFromString(s, ok));
     case QMetaType::QRect:
         return QVariant::fromValue(rectFFromString(s, ok).toRect());
-    case QMetaType::QVector3D:
-        return QVariant::fromValue(vector3DFromString(s, ok));
-    case QMetaType::QVector4D:
-        return QVariant::fromValue(vector4DFromString(s, ok));
     default:
-        if (ok) *ok = false;
-        return QVariant();
+        return QQml_valueTypeProvider()->createVariantFromString(preferredType, s, ok);
     }
 }
 
-QColor QQmlStringConverters::colorFromString(const QString &s, bool *ok)
+QVariant QQmlStringConverters::colorFromString(const QString &s, bool *ok)
 {
-    if (s.length() == 9 && s.startsWith(QLatin1Char('#'))) {
-        uchar a = fromHex(s, 1);
-        uchar r = fromHex(s, 3);
-        uchar g = fromHex(s, 5);
-        uchar b = fromHex(s, 7);
-        if (ok) *ok = true;
-        return QColor(r, g, b, a);
-    } else {
-        QColor rv(s);
-        if (ok) *ok = rv.isValid();
-        return rv;
-    }
+    return QQml_colorProvider()->colorFromString(s, ok);
+}
+
+unsigned QQmlStringConverters::rgbaFromString(const QString &s, bool *ok)
+{
+    return QQml_colorProvider()->rgbaFromString(s, ok);
 }
 
 #ifndef QT_NO_DATESTRING
@@ -254,58 +208,95 @@ QRectF QQmlStringConverters::rectFFromString(const QString &s, bool *ok)
     return QRectF(x, y, width, height);
 }
 
-//expects input of "x,y,z"
-QVector3D QQmlStringConverters::vector3DFromString(const QString &s, bool *ok)
+bool QQmlStringConverters::createFromString(int type, const QString &s, void *data, size_t n)
 {
-    if (s.count(QLatin1Char(',')) != 2) {
-        if (ok)
-            *ok = false;
-        return QVector3D();
-    }
-
-    bool xGood, yGood, zGood;
-    int index = s.indexOf(QLatin1Char(','));
-    int index2 = s.indexOf(QLatin1Char(','), index+1);
-    qreal xCoord = s.left(index).toDouble(&xGood);
-    qreal yCoord = s.mid(index+1, index2-index-1).toDouble(&yGood);
-    qreal zCoord = s.mid(index2+1).toDouble(&zGood);
-    if (!xGood || !yGood || !zGood) {
-        if (ok)
-            *ok = false;
-        return QVector3D();
-    }
-
-    if (ok)
-        *ok = true;
-    return QVector3D(xCoord, yCoord, zCoord);
-}
+    Q_ASSERT(data);
 
-//expects input of "x,y,z,w"
-QVector4D QQmlStringConverters::vector4DFromString(const QString &s, bool *ok)
-{
-    if (s.count(QLatin1Char(',')) != 3) {
-        if (ok)
-            *ok = false;
-        return QVector4D();
-    }
+    bool ok = false;
 
-    bool xGood, yGood, zGood, wGood;
-    int index = s.indexOf(QLatin1Char(','));
-    int index2 = s.indexOf(QLatin1Char(','), index+1);
-    int index3 = s.indexOf(QLatin1Char(','), index2+1);
-    qreal xCoord = s.left(index).toDouble(&xGood);
-    qreal yCoord = s.mid(index+1, index2-index-1).toDouble(&yGood);
-    qreal zCoord = s.mid(index2+1, index3-index2-1).toDouble(&zGood);
-    qreal wCoord = s.mid(index3+1).toDouble(&wGood);
-    if (!xGood || !yGood || !zGood || !wGood) {
-        if (ok)
-            *ok = false;
-        return QVector4D();
+    switch (type) {
+    case QMetaType::Int:
+        {
+        Q_ASSERT(n >= sizeof(int));
+        int *p = reinterpret_cast<int *>(data);
+        *p = int(qRound(s.toDouble(&ok)));
+        return ok;
+        }
+    case QMetaType::UInt:
+        {
+        Q_ASSERT(n >= sizeof(uint));
+        uint *p = reinterpret_cast<uint *>(data);
+        *p = uint(qRound(s.toDouble(&ok)));
+        return ok;
+        }
+#ifndef QT_NO_DATESTRING
+    case QMetaType::QDate:
+        {
+        Q_ASSERT(n >= sizeof(QDate));
+        QDate *p = reinterpret_cast<QDate *>(data);
+        *p = dateFromString(s, &ok);
+        return ok;
+        }
+    case QMetaType::QTime:
+        {
+        Q_ASSERT(n >= sizeof(QTime));
+        QTime *p = reinterpret_cast<QTime *>(data);
+        *p = timeFromString(s, &ok);
+        return ok;
+        }
+    case QMetaType::QDateTime:
+        {
+        Q_ASSERT(n >= sizeof(QDateTime));
+        QDateTime *p = reinterpret_cast<QDateTime *>(data);
+        *p = dateTimeFromString(s, &ok);
+        return ok;
+        }
+#endif // QT_NO_DATESTRING
+    case QMetaType::QPointF:
+        {
+        Q_ASSERT(n >= sizeof(QPointF));
+        QPointF *p = reinterpret_cast<QPointF *>(data);
+        *p = pointFFromString(s, &ok);
+        return ok;
+        }
+    case QMetaType::QPoint:
+        {
+        Q_ASSERT(n >= sizeof(QPoint));
+        QPoint *p = reinterpret_cast<QPoint *>(data);
+        *p = pointFFromString(s, &ok).toPoint();
+        return ok;
+        }
+    case QMetaType::QSizeF:
+        {
+        Q_ASSERT(n >= sizeof(QSizeF));
+        QSizeF *p = reinterpret_cast<QSizeF *>(data);
+        *p = sizeFFromString(s, &ok);
+        return ok;
+        }
+    case QMetaType::QSize:
+        {
+        Q_ASSERT(n >= sizeof(QSize));
+        QSize *p = reinterpret_cast<QSize *>(data);
+        *p = sizeFFromString(s, &ok).toSize();
+        return ok;
+        }
+    case QMetaType::QRectF:
+        {
+        Q_ASSERT(n >= sizeof(QRectF));
+        QRectF *p = reinterpret_cast<QRectF *>(data);
+        *p = rectFFromString(s, &ok);
+        return ok;
+        }
+    case QMetaType::QRect:
+        {
+        Q_ASSERT(n >= sizeof(QRect));
+        QRect *p = reinterpret_cast<QRect *>(data);
+        *p = rectFFromString(s, &ok).toRect();
+        return ok;
+        }
+    default:
+        return QQml_valueTypeProvider()->createValueFromString(type, s, data, n);
     }
-
-    if (ok)
-        *ok = true;
-    return QVector4D(xCoord, yCoord, zCoord, wCoord);
 }
 
 QT_END_NAMESPACE
diff --git a/src/qml/qml/qqmlstringconverters_p.h b/src/qml/qml/qqmlstringconverters_p.h
index 8f6fb24..3e637db 100644
--- a/src/qml/qml/qqmlstringconverters_p.h
+++ b/src/qml/qml/qqmlstringconverters_p.h
@@ -60,32 +60,31 @@
 
 QT_BEGIN_NAMESPACE
 
-class QColor;
 class QPointF;
 class QSizeF;
 class QRectF;
 class QString;
 class QByteArray;
-class QVector3D;
-class QVector4D;
 
 // XXX - Bauhaus currently uses these methods which is why they're exported
 namespace QQmlStringConverters
 {
-    QVariant Q_QML_PRIVATE_EXPORT variantFromString(const QString &);
-    QVariant Q_QML_PRIVATE_EXPORT variantFromString(const QString &, int preferredType, bool *ok = 0);
+    Q_QML_PRIVATE_EXPORT QVariant variantFromString(const QString &);
+    Q_QML_PRIVATE_EXPORT QVariant variantFromString(const QString &, int preferredType, bool *ok = 0);
+
+    Q_QML_PRIVATE_EXPORT QVariant colorFromString(const QString &, bool *ok = 0);
+    Q_QML_PRIVATE_EXPORT unsigned rgbaFromString(const QString &, bool *ok = 0);
 
-    QColor Q_QML_PRIVATE_EXPORT colorFromString(const QString &, bool *ok = 0);
 #ifndef QT_NO_DATESTRING
-    QDate Q_QML_PRIVATE_EXPORT dateFromString(const QString &, bool *ok = 0); 
-    QTime Q_QML_PRIVATE_EXPORT timeFromString(const QString &, bool *ok = 0);
-    QDateTime Q_QML_PRIVATE_EXPORT dateTimeFromString(const QString &, bool *ok = 0);
+    Q_QML_PRIVATE_EXPORT QDate dateFromString(const QString &, bool *ok = 0);
+    Q_QML_PRIVATE_EXPORT QTime timeFromString(const QString &, bool *ok = 0);
+    Q_QML_PRIVATE_EXPORT QDateTime dateTimeFromString(const QString &, bool *ok = 0);
 #endif
-    QPointF Q_QML_PRIVATE_EXPORT pointFFromString(const QString &, bool *ok = 0);
-    QSizeF Q_QML_PRIVATE_EXPORT sizeFFromString(const QString &, bool *ok = 0);
-    QRectF Q_QML_PRIVATE_EXPORT rectFFromString(const QString &, bool *ok = 0);
-    QVector3D Q_QML_PRIVATE_EXPORT vector3DFromString(const QString &, bool *ok = 0);
-    QVector4D Q_QML_PRIVATE_EXPORT vector4DFromString(const QString &, bool *ok = 0);
+    Q_QML_PRIVATE_EXPORT QPointF pointFFromString(const QString &, bool *ok = 0);
+    Q_QML_PRIVATE_EXPORT QSizeF sizeFFromString(const QString &, bool *ok = 0);
+    Q_QML_PRIVATE_EXPORT QRectF rectFFromString(const QString &, bool *ok = 0);
+
+    Q_QML_PRIVATE_EXPORT bool createFromString(int, const QString &, void *, size_t);
 }
 
 QT_END_NAMESPACE
diff --git a/src/qml/qml/qqmlvaluetype.cpp b/src/qml/qml/qqmlvaluetype.cpp
index 4ade00f..fdc44c2 100644
--- a/src/qml/qml/qqmlvaluetype.cpp
+++ b/src/qml/qml/qqmlvaluetype.cpp
@@ -40,48 +40,17 @@
 ****************************************************************************/
 
 #include "qqmlvaluetype_p.h"
-
 #include "qqmlmetatype_p.h"
-#include <private/qfont_p.h>
 
+#include <private/qqmlglobal_p.h>
 #include <QtCore/qdebug.h>
 
 QT_BEGIN_NAMESPACE
 
-template<typename T>
-int qmlRegisterValueTypeEnums(const char *uri, int versionMajor, int versionMinor, const char *qmlName)
-{
-    QByteArray name(T::staticMetaObject.className());
-
-    QByteArray pointerName(name + '*');
-
-    QQmlPrivate::RegisterType type = {
-        0,
-
-        qRegisterMetaType<T *>(pointerName.constData()), 0, 0, 0,
-
-        QString(),
-
-        uri, versionMajor, versionMinor, qmlName, &T::staticMetaObject,
-
-        0, 0,
-
-        0, 0, 0,
-
-        0, 0,
-
-        0,
-        0
-    };
-
-    return QQmlPrivate::qmlregister(QQmlPrivate::TypeRegistration, &type);
-}
-
 QQmlValueTypeFactory::QQmlValueTypeFactory()
 {
-    // ### Optimize
     for (unsigned int ii = 0; ii < (QVariant::UserType - 1); ++ii)
-        valueTypes[ii] = valueType(ii);
+        valueTypes[ii] = 0;
 }
 
 QQmlValueTypeFactory::~QQmlValueTypeFactory()
@@ -106,7 +75,6 @@ bool QQmlValueTypeFactory::isValueType(int idx)
 void QQmlValueTypeFactory::registerBaseTypes(const char *uri, int versionMajor, int versionMinor)
 {
     qmlRegisterValueTypeEnums<QQmlEasingValueType>(uri, versionMajor, versionMinor, "Easing");
-    qmlRegisterValueTypeEnums<QQmlFontValueType>(uri, versionMajor, versionMinor, "Font");
 }
 
 void QQmlValueTypeFactory::registerValueTypes()
@@ -137,31 +105,11 @@ QQmlValueType *QQmlValueTypeFactory::valueType(int t)
     case QVariant::RectF:
         rv = new QQmlRectFValueType;
         break;
-    case QVariant::Vector2D:
-        rv = new QQmlVector2DValueType;
-        break;
-    case QVariant::Vector3D:
-        rv = new QQmlVector3DValueType;
-        break;
-    case QVariant::Vector4D:
-        rv = new QQmlVector4DValueType;
-        break;
-    case QVariant::Quaternion:
-        rv = new QQmlQuaternionValueType;
-        break;
-    case QVariant::Matrix4x4:
-        rv = new QQmlMatrix4x4ValueType;
-        break;
     case QVariant::EasingCurve:
         rv = new QQmlEasingValueType;
         break;
-    case QVariant::Font:
-        rv = new QQmlFontValueType;
-        break;
-    case QVariant::Color:
-        rv = new QQmlColorValueType;
-        break;
     default:
+        rv = QQml_valueTypeProvider()->createValueType(t);
         break;
     }
 
@@ -174,445 +122,281 @@ QQmlValueType::QQmlValueType(QObject *parent)
 {
 }
 
-#define QML_VALUETYPE_READWRITE(name, cpptype, var) \
-    QQml ## name ## ValueType::QQml ## name ## ValueType(QObject *parent) \
-    : QQmlValueType(parent) \
-    { \
-    } \
-    void QQml ## name ## ValueType::read(QObject *obj, int idx) \
-    { \
-        void *a[] = { &var, 0 }; \
-        QMetaObject::metacall(obj, QMetaObject::ReadProperty, idx, a); \
-        onLoad(); \
-    } \
-    void QQml ## name ## ValueType::write(QObject *obj, int idx, \
-                                                  QQmlPropertyPrivate::WriteFlags flags) \
-    { \
-        int status = -1; \
-        void *a[] = { &var, 0, &status, &flags }; \
-        QMetaObject::metacall(obj, QMetaObject::WriteProperty, idx, a); \
-    } \
-    bool QQml ## name ## ValueType::isEqual(const QVariant &value) const \
-    { \
-        return QVariant(var) == value; \
-    } \
-    QVariant QQml ## name ## ValueType::value() \
-    { \
-        return QVariant(var); \
-    } \
-    void QQml ## name ## ValueType::setValue(const QVariant &value) \
-    { \
-        var = qvariant_cast<cpptype>(value); \
-        onLoad(); \
-    }
 
-QML_VALUETYPE_READWRITE(PointF, QPointF, point);
-QML_VALUETYPE_READWRITE(Point, QPoint, point);
-QML_VALUETYPE_READWRITE(SizeF, QSizeF, size);
-QML_VALUETYPE_READWRITE(Size, QSize, size);
-QML_VALUETYPE_READWRITE(RectF, QRectF, rect);
-QML_VALUETYPE_READWRITE(Rect, QRect, rect);
-QML_VALUETYPE_READWRITE(Vector2D, QVector2D, vector);
-QML_VALUETYPE_READWRITE(Vector3D, QVector3D, vector);
-QML_VALUETYPE_READWRITE(Vector4D, QVector4D, vector);
-QML_VALUETYPE_READWRITE(Quaternion, QQuaternion, quaternion);
-QML_VALUETYPE_READWRITE(Matrix4x4, QMatrix4x4, matrix);
-QML_VALUETYPE_READWRITE(Easing, QEasingCurve, easing);
-QML_VALUETYPE_READWRITE(Font, QFont, font);
-QML_VALUETYPE_READWRITE(Color, QColor, color);
+QQmlPointFValueType::QQmlPointFValueType(QObject *parent)
+    : QQmlValueTypeBase<QPointF>(parent)
+{
+}
 
 QString QQmlPointFValueType::toString() const
 {
-    return QString(QLatin1String("QPointF(%1, %2)")).arg(point.x()).arg(point.y());
+    return QString(QLatin1String("QPointF(%1, %2)")).arg(v.x()).arg(v.y());
 }
 
 qreal QQmlPointFValueType::x() const
 {
-    return point.x();
+    return v.x();
 }
 
 qreal QQmlPointFValueType::y() const
 {
-    return point.y();
+    return v.y();
 }
 
 void QQmlPointFValueType::setX(qreal x)
 {
-    point.setX(x);
+    v.setX(x);
 }
 
 void QQmlPointFValueType::setY(qreal y)
 {
-    point.setY(y);
+    v.setY(y);
+}
+
+
+QQmlPointValueType::QQmlPointValueType(QObject *parent)
+    : QQmlValueTypeBase<QPoint>(parent)
+{
 }
 
 QString QQmlPointValueType::toString() const
 {
-    return QString(QLatin1String("QPoint(%1, %2)")).arg(point.x()).arg(point.y());
+    return QString(QLatin1String("QPoint(%1, %2)")).arg(v.x()).arg(v.y());
 }
 
 int QQmlPointValueType::x() const
 {
-    return point.x();
+    return v.x();
 }
 
 int QQmlPointValueType::y() const
 {
-    return point.y();
+    return v.y();
 }
 
 void QQmlPointValueType::setX(int x)
 {
-    point.setX(x);
+    v.setX(x);
 }
 
 void QQmlPointValueType::setY(int y)
 {
-    point.setY(y);
+    v.setY(y);
+}
+
+
+QQmlSizeFValueType::QQmlSizeFValueType(QObject *parent)
+    : QQmlValueTypeBase<QSizeF>(parent)
+{
 }
 
 QString QQmlSizeFValueType::toString() const
 {
-    return QString(QLatin1String("QSizeF(%1, %2)")).arg(size.width()).arg(size.height());
+    return QString(QLatin1String("QSizeF(%1, %2)")).arg(v.width()).arg(v.height());
 }
 
 qreal QQmlSizeFValueType::width() const
 {
-    return size.width();
+    return v.width();
 }
 
 qreal QQmlSizeFValueType::height() const
 {
-    return size.height();
+    return v.height();
 }
 
 void QQmlSizeFValueType::setWidth(qreal w)
 {
-    size.setWidth(w);
+    v.setWidth(w);
 }
 
 void QQmlSizeFValueType::setHeight(qreal h)
 {
-    size.setHeight(h);
+    v.setHeight(h);
+}
+
+
+QQmlSizeValueType::QQmlSizeValueType(QObject *parent)
+    : QQmlValueTypeBase<QSize>(parent)
+{
 }
 
 QString QQmlSizeValueType::toString() const
 {
-    return QString(QLatin1String("QSize(%1, %2)")).arg(size.width()).arg(size.height());
+    return QString(QLatin1String("QSize(%1, %2)")).arg(v.width()).arg(v.height());
 }
 
 int QQmlSizeValueType::width() const
 {
-    return size.width();
+    return v.width();
 }
 
 int QQmlSizeValueType::height() const
 {
-    return size.height();
+    return v.height();
 }
 
 void QQmlSizeValueType::setWidth(int w)
 {
-    size.setWidth(w);
+    v.setWidth(w);
 }
 
 void QQmlSizeValueType::setHeight(int h)
 {
-    size.setHeight(h);
+    v.setHeight(h);
+}
+
+
+QQmlRectFValueType::QQmlRectFValueType(QObject *parent)
+    : QQmlValueTypeBase<QRectF>(parent)
+{
 }
 
 QString QQmlRectFValueType::toString() const
 {
-    return QString(QLatin1String("QRectF(%1, %2, %3, %4)")).arg(rect.x()).arg(rect.y()).arg(rect.width()).arg(rect.height());
+    return QString(QLatin1String("QRectF(%1, %2, %3, %4)")).arg(v.x()).arg(v.y()).arg(v.width()).arg(v.height());
 }
 
 qreal QQmlRectFValueType::x() const
 {
-    return rect.x();
+    return v.x();
 }
 
 qreal QQmlRectFValueType::y() const
 {
-    return rect.y();
+    return v.y();
 }
 
 void QQmlRectFValueType::setX(qreal x)
 {
-    rect.moveLeft(x);
+    v.moveLeft(x);
 }
 
 void QQmlRectFValueType::setY(qreal y)
 {
-    rect.moveTop(y);
+    v.moveTop(y);
 }
 
 qreal QQmlRectFValueType::width() const
 {
-    return rect.width();
+    return v.width();
 }
 
 qreal QQmlRectFValueType::height() const
 {
-    return rect.height();
+    return v.height();
 }
 
 void QQmlRectFValueType::setWidth(qreal w)
 {
-    rect.setWidth(w);
+    v.setWidth(w);
 }
 
 void QQmlRectFValueType::setHeight(qreal h)
 {
-    rect.setHeight(h);
+    v.setHeight(h);
+}
+
+
+QQmlRectValueType::QQmlRectValueType(QObject *parent)
+    : QQmlValueTypeBase<QRect>(parent)
+{
 }
 
 QString QQmlRectValueType::toString() const
 {
-    return QString(QLatin1String("QRect(%1, %2, %3, %4)")).arg(rect.x()).arg(rect.y()).arg(rect.width()).arg(rect.height());
+    return QString(QLatin1String("QRect(%1, %2, %3, %4)")).arg(v.x()).arg(v.y()).arg(v.width()).arg(v.height());
 }
 
 int QQmlRectValueType::x() const
 {
-    return rect.x();
+    return v.x();
 }
 
 int QQmlRectValueType::y() const
 {
-    return rect.y();
+    return v.y();
 }
 
 void QQmlRectValueType::setX(int x)
 {
-    rect.moveLeft(x);
+    v.moveLeft(x);
 }
 
 void QQmlRectValueType::setY(int y)
 {
-    rect.moveTop(y);
+    v.moveTop(y);
 }
 
 int QQmlRectValueType::width() const
 {
-    return rect.width();
+    return v.width();
 }
 
 int QQmlRectValueType::height() const
 {
-    return rect.height();
+    return v.height();
 }
 
 void QQmlRectValueType::setWidth(int w)
 {
-    rect.setWidth(w);
+    v.setWidth(w);
 }
 
 void QQmlRectValueType::setHeight(int h)
 {
-    rect.setHeight(h);
+    v.setHeight(h);
 }
 
-QString QQmlVector2DValueType::toString() const
-{
-    return QString(QLatin1String("QVector2D(%1, %2)")).arg(vector.x()).arg(vector.y());
-}
 
-qreal QQmlVector2DValueType::x() const
+QQmlEasingValueType::QQmlEasingValueType(QObject *parent)
+    : QQmlValueTypeBase<QEasingCurve>(parent)
 {
-    return vector.x();
-}
-
-qreal QQmlVector2DValueType::y() const
-{
-    return vector.y();
-}
-
-void QQmlVector2DValueType::setX(qreal x)
-{
-    vector.setX(x);
-}
-
-void QQmlVector2DValueType::setY(qreal y)
-{
-    vector.setY(y);
-}
-
-QString QQmlVector3DValueType::toString() const
-{
-    return QString(QLatin1String("QVector3D(%1, %2, %3)")).arg(vector.x()).arg(vector.y()).arg(vector.z());
-}
-
-qreal QQmlVector3DValueType::x() const
-{
-    return vector.x();
-}
-
-qreal QQmlVector3DValueType::y() const
-{
-    return vector.y();
-}
-
-qreal QQmlVector3DValueType::z() const
-{
-    return vector.z();
-}
-
-void QQmlVector3DValueType::setX(qreal x)
-{
-    vector.setX(x);
-}
-
-void QQmlVector3DValueType::setY(qreal y)
-{
-    vector.setY(y);
-}
-
-void QQmlVector3DValueType::setZ(qreal z)
-{
-    vector.setZ(z);
-}
-
-QString QQmlVector4DValueType::toString() const
-{
-    return QString(QLatin1String("QVector4D(%1, %2, %3, %4)")).arg(vector.x()).arg(vector.y()).arg(vector.z()).arg(vector.w());
-}
-
-qreal QQmlVector4DValueType::x() const
-{
-    return vector.x();
-}
-
-qreal QQmlVector4DValueType::y() const
-{
-    return vector.y();
-}
-
-qreal QQmlVector4DValueType::z() const
-{
-    return vector.z();
-}
-
-qreal QQmlVector4DValueType::w() const
-{
-    return vector.w();
-}
-
-void QQmlVector4DValueType::setX(qreal x)
-{
-    vector.setX(x);
-}
-
-void QQmlVector4DValueType::setY(qreal y)
-{
-    vector.setY(y);
-}
-
-void QQmlVector4DValueType::setZ(qreal z)
-{
-    vector.setZ(z);
-}
-
-void QQmlVector4DValueType::setW(qreal w)
-{
-    vector.setW(w);
-}
-
-QString QQmlQuaternionValueType::toString() const
-{
-    return QString(QLatin1String("QQuaternion(%1, %2, %3, %4)")).arg(quaternion.scalar()).arg(quaternion.x()).arg(quaternion.y()).arg(quaternion.z());
-}
-
-qreal QQmlQuaternionValueType::scalar() const
-{
-    return quaternion.scalar();
-}
-
-qreal QQmlQuaternionValueType::x() const
-{
-    return quaternion.x();
-}
-
-qreal QQmlQuaternionValueType::y() const
-{
-    return quaternion.y();
-}
-
-qreal QQmlQuaternionValueType::z() const
-{
-    return quaternion.z();
-}
-
-void QQmlQuaternionValueType::setScalar(qreal scalar)
-{
-    quaternion.setScalar(scalar);
-}
-
-void QQmlQuaternionValueType::setX(qreal x)
-{
-    quaternion.setX(x);
-}
-
-void QQmlQuaternionValueType::setY(qreal y)
-{
-    quaternion.setY(y);
-}
-
-void QQmlQuaternionValueType::setZ(qreal z)
-{
-    quaternion.setZ(z);
-}
-
-QString QQmlMatrix4x4ValueType::toString() const
-{
-    return QString(QLatin1String("QMatrix4x4(%1, %2, %3, %4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15, %16)"))
-            .arg(matrix(0, 0)).arg(matrix(0, 1)).arg(matrix(0, 2)).arg(matrix(0, 3))
-            .arg(matrix(1, 0)).arg(matrix(1, 1)).arg(matrix(1, 2)).arg(matrix(1, 3))
-            .arg(matrix(2, 0)).arg(matrix(2, 1)).arg(matrix(2, 2)).arg(matrix(2, 3))
-            .arg(matrix(3, 0)).arg(matrix(3, 1)).arg(matrix(3, 2)).arg(matrix(3, 3));
 }
 
 QString QQmlEasingValueType::toString() const
 {
-    return QString(QLatin1String("QEasingCurve(%1, %2, %3, %4)")).arg(easing.type()).arg(easing.amplitude()).arg(easing.overshoot()).arg(easing.period());
+    return QString(QLatin1String("QEasingCurve(%1, %2, %3, %4)")).arg(v.type()).arg(v.amplitude()).arg(v.overshoot()).arg(v.period());
 }
 
 QQmlEasingValueType::Type QQmlEasingValueType::type() const
 {
-    return (QQmlEasingValueType::Type)easing.type();
+    return (QQmlEasingValueType::Type)v.type();
 }
 
 qreal QQmlEasingValueType::amplitude() const
 {
-    return easing.amplitude();
+    return v.amplitude();
 }
 
 qreal QQmlEasingValueType::overshoot() const
 {
-    return easing.overshoot();
+    return v.overshoot();
 }
 
 qreal QQmlEasingValueType::period() const
 {
-    return easing.period();
+    return v.period();
 }
 
 void QQmlEasingValueType::setType(QQmlEasingValueType::Type type)
 {
-    easing.setType((QEasingCurve::Type)type);
+    v.setType((QEasingCurve::Type)type);
 }
 
 void QQmlEasingValueType::setAmplitude(qreal amplitude)
 {
-    easing.setAmplitude(amplitude);
+    v.setAmplitude(amplitude);
 }
 
 void QQmlEasingValueType::setOvershoot(qreal overshoot)
 {
-    easing.setOvershoot(overshoot);
+    v.setOvershoot(overshoot);
 }
 
 void QQmlEasingValueType::setPeriod(qreal period)
 {
-    easing.setPeriod(period);
+    v.setPeriod(period);
 }
 
 void QQmlEasingValueType::setBezierCurve(const QVariantList &customCurveVariant)
@@ -646,7 +430,7 @@ void QQmlEasingValueType::setBezierCurve(const QVariantList &customCurveVariant)
                 const QPointF c3(c3x, c3y);
 
                 newEasingCurve.addCubicBezierSegment(c1, c2, c3);
-                easing = newEasingCurve;
+                v = newEasingCurve;
             }
         }
     }
@@ -655,214 +439,10 @@ void QQmlEasingValueType::setBezierCurve(const QVariantList &customCurveVariant)
 QVariantList QQmlEasingValueType::bezierCurve() const
 {
     QVariantList rv;
-    QList<QPointF> points = easing.cubicBezierSpline();
+    QList<QPointF> points = v.cubicBezierSpline();
     for (int ii = 0; ii < points.count(); ++ii)
         rv << QVariant(points.at(ii).x()) << QVariant(points.at(ii).y());
     return rv;
 }
 
-void QQmlFontValueType::onLoad()
-{
-    pixelSizeSet = false;
-    pointSizeSet = false;
-}
-
-QString QQmlFontValueType::toString() const
-{
-    return QString(QLatin1String("QFont(%1)")).arg(font.toString());
-}
-
-QString QQmlFontValueType::family() const
-{
-    return font.family();
-}
-
-void QQmlFontValueType::setFamily(const QString &family)
-{
-    font.setFamily(family);
-}
-
-bool QQmlFontValueType::bold() const
-{
-    return font.bold();
-}
-
-void QQmlFontValueType::setBold(bool b)
-{
-    font.setBold(b);
-}
-
-QQmlFontValueType::FontWeight QQmlFontValueType::weight() const
-{
-    return (QQmlFontValueType::FontWeight)font.weight();
-}
-
-void QQmlFontValueType::setWeight(QQmlFontValueType::FontWeight w)
-{
-    font.setWeight((QFont::Weight)w);
-}
-
-bool QQmlFontValueType::italic() const
-{
-    return font.italic();
-}
-
-void QQmlFontValueType::setItalic(bool b)
-{
-    font.setItalic(b);
-}
-
-bool QQmlFontValueType::underline() const
-{
-    return font.underline();
-}
-
-void QQmlFontValueType::setUnderline(bool b)
-{
-    font.setUnderline(b);
-}
-
-bool QQmlFontValueType::overline() const
-{
-    return font.overline();
-}
-
-void QQmlFontValueType::setOverline(bool b)
-{
-    font.setOverline(b);
-}
-
-bool QQmlFontValueType::strikeout() const
-{
-    return font.strikeOut();
-}
-
-void QQmlFontValueType::setStrikeout(bool b)
-{
-    font.setStrikeOut(b);
-}
-
-qreal QQmlFontValueType::pointSize() const
-{
-    if (font.pointSizeF() == -1) {
-        if (dpi.isNull)
-            dpi = qt_defaultDpi();
-        return font.pixelSize() * qreal(72.) / qreal(dpi);
-    }
-    return font.pointSizeF();
-}
-
-void QQmlFontValueType::setPointSize(qreal size)
-{
-    if (pixelSizeSet) {
-        qWarning() << "Both point size and pixel size set. Using pixel size.";
-        return;
-    }
-
-    if (size >= 0.0) {
-        pointSizeSet = true;
-        font.setPointSizeF(size);
-    } else {
-        pointSizeSet = false;
-    }
-}
-
-int QQmlFontValueType::pixelSize() const
-{
-    if (font.pixelSize() == -1) {
-        if (dpi.isNull)
-            dpi = qt_defaultDpi();
-        return (font.pointSizeF() * dpi) / qreal(72.);
-    }
-    return font.pixelSize();
-}
-
-void QQmlFontValueType::setPixelSize(int size)
-{
-    if (size >0) {
-        if (pointSizeSet)
-            qWarning() << "Both point size and pixel size set. Using pixel size.";
-        font.setPixelSize(size);
-        pixelSizeSet = true;
-    } else {
-        pixelSizeSet = false;
-    }
-}
-
-QQmlFontValueType::Capitalization QQmlFontValueType::capitalization() const
-{
-    return (QQmlFontValueType::Capitalization)font.capitalization();
-}
-
-void QQmlFontValueType::setCapitalization(QQmlFontValueType::Capitalization c)
-{
-    font.setCapitalization((QFont::Capitalization)c);
-}
-
-qreal QQmlFontValueType::letterSpacing() const
-{
-    return font.letterSpacing();
-}
-
-void QQmlFontValueType::setLetterSpacing(qreal size)
-{
-    font.setLetterSpacing(QFont::AbsoluteSpacing, size);
-}
-
-qreal QQmlFontValueType::wordSpacing() const
-{
-    return font.wordSpacing();
-}
-
-void QQmlFontValueType::setWordSpacing(qreal size)
-{
-    font.setWordSpacing(size);
-}
-
-QString QQmlColorValueType::toString() const
-{
-    // special case - to maintain behaviour with QtQuick 1.0, we just output normal toString() value.
-    return QVariant(color).toString();
-}
-
-qreal QQmlColorValueType::r() const
-{
-    return color.redF();
-}
-
-qreal QQmlColorValueType::g() const
-{
-    return color.greenF();
-}
-
-qreal QQmlColorValueType::b() const
-{
-    return color.blueF();
-}
-
-qreal QQmlColorValueType::a() const
-{
-    return color.alphaF();
-}
-
-void QQmlColorValueType::setR(qreal r)
-{
-    color.setRedF(r);
-}
-
-void QQmlColorValueType::setG(qreal g)
-{
-    color.setGreenF(g);
-}
-
-void QQmlColorValueType::setB(qreal b)
-{
-    color.setBlueF(b);
-}
-
-void QQmlColorValueType::setA(qreal a)
-{
-    color.setAlphaF(a);
-}
-
 QT_END_NAMESPACE
diff --git a/src/qml/qml/qqmlvaluetype_p.h b/src/qml/qml/qqmlvaluetype_p.h
index 71817c2..d55c839 100644
--- a/src/qml/qml/qqmlvaluetype_p.h
+++ b/src/qml/qml/qqmlvaluetype_p.h
@@ -53,6 +53,7 @@
 // We mean it.
 //
 
+#include "qqml.h"
 #include "qqmlproperty.h"
 #include "qqmlproperty_p.h"
 #include "qqmlnullablevalue_p_p.h"
@@ -61,13 +62,6 @@
 #include <QtCore/qrect.h>
 #include <QtCore/qeasingcurve.h>
 #include <QtCore/qvariant.h>
-#include <QtGui/qvector2d.h>
-#include <QtGui/qvector3d.h>
-#include <QtGui/qvector4d.h>
-#include <QtGui/qmatrix4x4.h>
-#include <QtGui/qquaternion.h>
-#include <QtGui/qfont.h>
-#include <QtGui/qcolor.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -84,7 +78,63 @@ public:
     virtual QString toString() const = 0;
     virtual bool isEqual(const QVariant &value) const = 0;
 
-    inline void onLoad();
+    virtual void onLoad() {}
+
+protected:
+    inline void readProperty(QObject *obj, int idx, void *p)
+    {
+        void *a[] = { p, 0 };
+        QMetaObject::metacall(obj, QMetaObject::ReadProperty, idx, a);
+        onLoad();
+    }
+
+    inline void writeProperty(QObject *obj, int idx, QQmlPropertyPrivate::WriteFlags flags, void *p)
+    {
+        int status = -1;
+        void *a[] = { p, 0, &status, &flags };
+        QMetaObject::metacall(obj, QMetaObject::WriteProperty, idx, a);
+    }
+};
+
+template <typename T>
+class QQmlValueTypeBase : public QQmlValueType
+{
+public:
+    typedef T ValueType;
+
+    QQmlValueTypeBase(QObject *parent)
+        : QQmlValueType(parent)
+    {
+    }
+
+    virtual void read(QObject *obj, int idx)
+    {
+        readProperty(obj, idx, &v);
+    }
+
+    virtual void write(QObject *obj, int idx, QQmlPropertyPrivate::WriteFlags flags)
+    {
+        writeProperty(obj, idx, flags, &v);
+    }
+
+    virtual QVariant value()
+    {
+        return QVariant(v);
+    }
+
+    virtual void setValue(const QVariant &value)
+    {
+        v = qvariant_cast<T>(value);
+        onLoad();
+    }
+
+    virtual bool isEqual(const QVariant &other) const
+    {
+        return QVariant(v) == other;
+    }
+
+protected:
+    ValueType v;
 };
 
 class Q_QML_PRIVATE_EXPORT QQmlValueTypeFactory
@@ -99,16 +149,27 @@ public:
     static void registerValueTypes();
 
     QQmlValueType *operator[](int idx) const {
-        if (idx >= (int)QVariant::UserType) return 0;
-        else return valueTypes[idx];
+        if (idx >= (int)QVariant::UserType)
+            return 0;
+
+        QQmlValueType *rv = valueTypes[idx];
+        if (!rv) {
+            // Table update is not thread-safe, but the potential for leaks is
+            // so small that the cost of protection is unwarranted
+            if ((rv = valueType(idx))) {
+                valueTypes[idx] = rv;
+            }
+        }
+        return rv;
     }
 
 private:
-    QQmlValueType *valueTypes[QVariant::UserType - 1]; 
+    mutable QQmlValueType *valueTypes[QVariant::UserType - 1];
 };
 
-// Exported for QtQuick1
-class Q_QML_PRIVATE_EXPORT QQmlPointFValueType : public QQmlValueType
+// These exports of these value types are obsolete since QtQuick1 no longer
+// needs them - they should become Q_AUTOTEST_EXPORT
+class Q_QML_PRIVATE_EXPORT QQmlPointFValueType : public QQmlValueTypeBase<QPointF>
 {
     Q_PROPERTY(qreal x READ x WRITE setX)
     Q_PROPERTY(qreal y READ y WRITE setY)
@@ -116,24 +177,15 @@ class Q_QML_PRIVATE_EXPORT QQmlPointFValueType : public QQmlValueType
 public:
     QQmlPointFValueType(QObject *parent = 0);
 
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
     virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
 
     qreal x() const;
     qreal y() const;
     void setX(qreal);
     void setY(qreal);
-
-private:
-    QPointF point;
 };
 
-// Exported for QtQuick1
-class Q_QML_PRIVATE_EXPORT QQmlPointValueType : public QQmlValueType
+class Q_QML_PRIVATE_EXPORT QQmlPointValueType : public QQmlValueTypeBase<QPoint>
 {
     Q_PROPERTY(int x READ x WRITE setX)
     Q_PROPERTY(int y READ y WRITE setY)
@@ -141,24 +193,15 @@ class Q_QML_PRIVATE_EXPORT QQmlPointValueType : public QQmlValueType
 public:
     QQmlPointValueType(QObject *parent = 0);
 
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
     virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
 
     int x() const;
     int y() const;
     void setX(int);
     void setY(int);
-
-private:
-    QPoint point;
 };
 
-// Exported for QtQuick1
-class Q_QML_PRIVATE_EXPORT QQmlSizeFValueType : public QQmlValueType
+class Q_QML_PRIVATE_EXPORT QQmlSizeFValueType : public QQmlValueTypeBase<QSizeF>
 {
     Q_PROPERTY(qreal width READ width WRITE setWidth)
     Q_PROPERTY(qreal height READ height WRITE setHeight)
@@ -166,24 +209,15 @@ class Q_QML_PRIVATE_EXPORT QQmlSizeFValueType : public QQmlValueType
 public:
     QQmlSizeFValueType(QObject *parent = 0);
 
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
     virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
 
     qreal width() const;
     qreal height() const;
     void setWidth(qreal);
     void setHeight(qreal);
-
-private:
-    QSizeF size;
 };
 
-// Exported for QtQuick1
-class Q_QML_PRIVATE_EXPORT QQmlSizeValueType : public QQmlValueType
+class Q_QML_PRIVATE_EXPORT QQmlSizeValueType : public QQmlValueTypeBase<QSize>
 {
     Q_PROPERTY(int width READ width WRITE setWidth)
     Q_PROPERTY(int height READ height WRITE setHeight)
@@ -191,24 +225,15 @@ class Q_QML_PRIVATE_EXPORT QQmlSizeValueType : public QQmlValueType
 public:
     QQmlSizeValueType(QObject *parent = 0);
 
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
     virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
 
     int width() const;
     int height() const;
     void setWidth(int);
     void setHeight(int);
-
-private:
-    QSize size;
 };
 
-// Exported for QtQuick1
-class Q_QML_PRIVATE_EXPORT QQmlRectFValueType : public QQmlValueType
+class Q_QML_PRIVATE_EXPORT QQmlRectFValueType : public QQmlValueTypeBase<QRectF>
 {
     Q_PROPERTY(qreal x READ x WRITE setX)
     Q_PROPERTY(qreal y READ y WRITE setY)
@@ -218,12 +243,7 @@ class Q_QML_PRIVATE_EXPORT QQmlRectFValueType : public QQmlValueType
 public:
     QQmlRectFValueType(QObject *parent = 0);
 
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
     virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
 
     qreal x() const;
     qreal y() const;
@@ -234,13 +254,9 @@ public:
     qreal height() const;
     void setWidth(qreal);
     void setHeight(qreal);
-
-private:
-    QRectF rect;
 };
 
-// Exported for QtQuick1
-class Q_QML_PRIVATE_EXPORT QQmlRectValueType : public QQmlValueType
+class Q_QML_PRIVATE_EXPORT QQmlRectValueType : public QQmlValueTypeBase<QRect>
 {
     Q_PROPERTY(int x READ x WRITE setX)
     Q_PROPERTY(int y READ y WRITE setY)
@@ -250,12 +266,7 @@ class Q_QML_PRIVATE_EXPORT QQmlRectValueType : public QQmlValueType
 public:
     QQmlRectValueType(QObject *parent = 0);
 
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
     virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
 
     int x() const;
     int y() const;
@@ -266,190 +277,9 @@ public:
     int height() const;
     void setWidth(int);
     void setHeight(int);
-
-private:
-    QRect rect;
 };
 
-class Q_QML_PRIVATE_EXPORT QQmlVector2DValueType : public QQmlValueType
-{
-    Q_PROPERTY(qreal x READ x WRITE setX)
-    Q_PROPERTY(qreal y READ y WRITE setY)
-    Q_OBJECT
-public:
-    QQmlVector2DValueType(QObject *parent = 0);
-
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
-    virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
-
-    qreal x() const;
-    qreal y() const;
-    void setX(qreal);
-    void setY(qreal);
-
-private:
-    QVector2D vector;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlVector3DValueType : public QQmlValueType
-{
-    Q_PROPERTY(qreal x READ x WRITE setX)
-    Q_PROPERTY(qreal y READ y WRITE setY)
-    Q_PROPERTY(qreal z READ z WRITE setZ)
-    Q_OBJECT
-public:
-    QQmlVector3DValueType(QObject *parent = 0);
-
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
-    virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
-
-    qreal x() const;
-    qreal y() const;
-    qreal z() const;
-    void setX(qreal);
-    void setY(qreal);
-    void setZ(qreal);
-
-private:
-    QVector3D vector;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlVector4DValueType : public QQmlValueType
-{
-    Q_PROPERTY(qreal x READ x WRITE setX)
-    Q_PROPERTY(qreal y READ y WRITE setY)
-    Q_PROPERTY(qreal z READ z WRITE setZ)
-    Q_PROPERTY(qreal w READ w WRITE setW)
-    Q_OBJECT
-public:
-    QQmlVector4DValueType(QObject *parent = 0);
-
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
-    virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
-
-    qreal x() const;
-    qreal y() const;
-    qreal z() const;
-    qreal w() const;
-    void setX(qreal);
-    void setY(qreal);
-    void setZ(qreal);
-    void setW(qreal);
-
-private:
-    QVector4D vector;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlQuaternionValueType : public QQmlValueType
-{
-    Q_PROPERTY(qreal scalar READ scalar WRITE setScalar)
-    Q_PROPERTY(qreal x READ x WRITE setX)
-    Q_PROPERTY(qreal y READ y WRITE setY)
-    Q_PROPERTY(qreal z READ z WRITE setZ)
-    Q_OBJECT
-public:
-    QQmlQuaternionValueType(QObject *parent = 0);
-
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
-    virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
-
-    qreal scalar() const;
-    qreal x() const;
-    qreal y() const;
-    qreal z() const;
-    void setScalar(qreal);
-    void setX(qreal);
-    void setY(qreal);
-    void setZ(qreal);
-
-private:
-    QQuaternion quaternion;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlMatrix4x4ValueType : public QQmlValueType
-{
-    Q_PROPERTY(qreal m11 READ m11 WRITE setM11)
-    Q_PROPERTY(qreal m12 READ m12 WRITE setM12)
-    Q_PROPERTY(qreal m13 READ m13 WRITE setM13)
-    Q_PROPERTY(qreal m14 READ m14 WRITE setM14)
-    Q_PROPERTY(qreal m21 READ m21 WRITE setM21)
-    Q_PROPERTY(qreal m22 READ m22 WRITE setM22)
-    Q_PROPERTY(qreal m23 READ m23 WRITE setM23)
-    Q_PROPERTY(qreal m24 READ m24 WRITE setM24)
-    Q_PROPERTY(qreal m31 READ m31 WRITE setM31)
-    Q_PROPERTY(qreal m32 READ m32 WRITE setM32)
-    Q_PROPERTY(qreal m33 READ m33 WRITE setM33)
-    Q_PROPERTY(qreal m34 READ m34 WRITE setM34)
-    Q_PROPERTY(qreal m41 READ m41 WRITE setM41)
-    Q_PROPERTY(qreal m42 READ m42 WRITE setM42)
-    Q_PROPERTY(qreal m43 READ m43 WRITE setM43)
-    Q_PROPERTY(qreal m44 READ m44 WRITE setM44)
-    Q_OBJECT
-public:
-    QQmlMatrix4x4ValueType(QObject *parent = 0);
-
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
-    virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
-
-    qreal m11() const { return matrix(0, 0); }
-    qreal m12() const { return matrix(0, 1); }
-    qreal m13() const { return matrix(0, 2); }
-    qreal m14() const { return matrix(0, 3); }
-    qreal m21() const { return matrix(1, 0); }
-    qreal m22() const { return matrix(1, 1); }
-    qreal m23() const { return matrix(1, 2); }
-    qreal m24() const { return matrix(1, 3); }
-    qreal m31() const { return matrix(2, 0); }
-    qreal m32() const { return matrix(2, 1); }
-    qreal m33() const { return matrix(2, 2); }
-    qreal m34() const { return matrix(2, 3); }
-    qreal m41() const { return matrix(3, 0); }
-    qreal m42() const { return matrix(3, 1); }
-    qreal m43() const { return matrix(3, 2); }
-    qreal m44() const { return matrix(3, 3); }
-
-    void setM11(qreal value) { matrix(0, 0) = value; }
-    void setM12(qreal value) { matrix(0, 1) = value; }
-    void setM13(qreal value) { matrix(0, 2) = value; }
-    void setM14(qreal value) { matrix(0, 3) = value; }
-    void setM21(qreal value) { matrix(1, 0) = value; }
-    void setM22(qreal value) { matrix(1, 1) = value; }
-    void setM23(qreal value) { matrix(1, 2) = value; }
-    void setM24(qreal value) { matrix(1, 3) = value; }
-    void setM31(qreal value) { matrix(2, 0) = value; }
-    void setM32(qreal value) { matrix(2, 1) = value; }
-    void setM33(qreal value) { matrix(2, 2) = value; }
-    void setM34(qreal value) { matrix(2, 3) = value; }
-    void setM41(qreal value) { matrix(3, 0) = value; }
-    void setM42(qreal value) { matrix(3, 1) = value; }
-    void setM43(qreal value) { matrix(3, 2) = value; }
-    void setM44(qreal value) { matrix(3, 3) = value; }
-
-private:
-    QMatrix4x4 matrix;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlEasingValueType : public QQmlValueType
+class Q_QML_PRIVATE_EXPORT QQmlEasingValueType : public QQmlValueTypeBase<QEasingCurve>
 {
     Q_OBJECT
     Q_ENUMS(Type)
@@ -489,12 +319,7 @@ public:
 
     QQmlEasingValueType(QObject *parent = 0);
 
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
     virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
 
     Type type() const;
     qreal amplitude() const;
@@ -506,128 +331,35 @@ public:
     void setPeriod(qreal);
     void setBezierCurve(const QVariantList &);
     QVariantList bezierCurve() const;
-
-
-private:
-    QEasingCurve easing;
 };
 
-class Q_QML_PRIVATE_EXPORT QQmlFontValueType : public QQmlValueType
+template<typename T>
+int qmlRegisterValueTypeEnums(const char *uri, int versionMajor, int versionMinor, const char *qmlName)
 {
-    Q_OBJECT
-    Q_ENUMS(FontWeight)
-    Q_ENUMS(Capitalization)
-
-    Q_PROPERTY(QString family READ family WRITE setFamily)
-    Q_PROPERTY(bool bold READ bold WRITE setBold)
-    Q_PROPERTY(FontWeight weight READ weight WRITE setWeight)
-    Q_PROPERTY(bool italic READ italic WRITE setItalic)
-    Q_PROPERTY(bool underline READ underline WRITE setUnderline)
-    Q_PROPERTY(bool overline READ overline WRITE setOverline)
-    Q_PROPERTY(bool strikeout READ strikeout WRITE setStrikeout)
-    Q_PROPERTY(qreal pointSize READ pointSize WRITE setPointSize)
-    Q_PROPERTY(int pixelSize READ pixelSize WRITE setPixelSize)
-    Q_PROPERTY(Capitalization capitalization READ capitalization WRITE setCapitalization)
-    Q_PROPERTY(qreal letterSpacing READ letterSpacing WRITE setLetterSpacing)
-    Q_PROPERTY(qreal wordSpacing READ wordSpacing WRITE setWordSpacing)
-
-public:
-    enum FontWeight { Light = QFont::Light,
-                       Normal = QFont::Normal,
-                       DemiBold = QFont::DemiBold,
-                       Bold = QFont::Bold,
-                       Black = QFont::Black };
-    enum Capitalization { MixedCase = QFont::MixedCase,
-                           AllUppercase = QFont::AllUppercase,
-                           AllLowercase = QFont::AllLowercase,
-                           SmallCaps = QFont::SmallCaps,
-                           Capitalize = QFont::Capitalize };
-
-    QQmlFontValueType(QObject *parent = 0);
-
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
-    virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
-
-    QString family() const;
-    void setFamily(const QString &);
-
-    bool bold() const;
-    void setBold(bool b);
+    QByteArray name(T::staticMetaObject.className());
 
-    FontWeight weight() const;
-    void setWeight(FontWeight);
+    QByteArray pointerName(name + '*');
 
-    bool italic() const;
-    void setItalic(bool b);
+    QQmlPrivate::RegisterType type = {
+        0,
 
-    bool underline() const;
-    void setUnderline(bool b);
+        qRegisterMetaType<T *>(pointerName.constData()), 0, 0, 0,
 
-    bool overline() const;
-    void setOverline(bool b);
+        QString(),
 
-    bool strikeout() const;
-    void setStrikeout(bool b);
+        uri, versionMajor, versionMinor, qmlName, &T::staticMetaObject,
 
-    qreal pointSize() const;
-    void setPointSize(qreal size);
+        0, 0,
 
-    int pixelSize() const;
-    void setPixelSize(int size);
+        0, 0, 0,
 
-    Capitalization capitalization() const;
-    void setCapitalization(Capitalization);
+        0, 0,
 
-    qreal letterSpacing() const;
-    void setLetterSpacing(qreal spacing);
-
-    qreal wordSpacing() const;
-    void setWordSpacing(qreal spacing);
-
-    void onLoad();
-private:
-    QFont font;
-    bool pixelSizeSet;
-    bool pointSizeSet;
-    mutable QQmlNullableValue<int> dpi;
-};
-
-class Q_QML_PRIVATE_EXPORT QQmlColorValueType : public QQmlValueType
-{
-    Q_PROPERTY(qreal r READ r WRITE setR)
-    Q_PROPERTY(qreal g READ g WRITE setG)
-    Q_PROPERTY(qreal b READ b WRITE setB)
-    Q_PROPERTY(qreal a READ a WRITE setA)
-    Q_OBJECT
-public:
-    QQmlColorValueType(QObject *parent = 0);
-
-    virtual void read(QObject *, int);
-    virtual void write(QObject *, int, QQmlPropertyPrivate::WriteFlags);
-    virtual QVariant value();
-    virtual void setValue(const QVariant &value);
-    virtual QString toString() const;
-    virtual bool isEqual(const QVariant &value) const;
-
-    qreal r() const;
-    qreal g() const;
-    qreal b() const;
-    qreal a() const;
-    void setR(qreal);
-    void setG(qreal);
-    void setB(qreal);
-    void setA(qreal);
-
-private:
-    QColor color;
-};
+        0,
+        0
+    };
 
-void QQmlValueType::onLoad()
-{
+    return QQmlPrivate::qmlregister(QQmlPrivate::TypeRegistration, &type);
 }
 
 QT_END_NAMESPACE
diff --git a/src/qml/qml/qqmlvme.cpp b/src/qml/qml/qqmlvme.cpp
index 86e9f09..6309335 100644
--- a/src/qml/qml/qqmlvme.cpp
+++ b/src/qml/qml/qqmlvme.cpp
@@ -68,7 +68,6 @@
 #include "qqmlvaluetypeproxybinding_p.h"
 
 #include <QStack>
-#include <QColor>
 #include <QPointF>
 #include <QSizeF>
 #include <QRectF>
@@ -267,6 +266,17 @@ static QVariant variantFromString(const QString &string)
         QMetaObject::metacall(target, QMetaObject::WriteProperty, instr.propertyIndex, a); \
     QML_END_INSTR(name)
 
+#define QML_STORE_PROVIDER_VALUE(name, type, value) \
+    QML_BEGIN_INSTR(name) \
+        struct { void *data[4]; } buffer; \
+        if (QQml_valueTypeProvider()->storeValueType(type, &value, &buffer, sizeof(buffer))) { \
+            void *a[] = { reinterpret_cast<void *>(&buffer), 0, &status, &flags }; \
+            QObject *target = objects.top(); \
+            CLEAN_PROPERTY(target, instr.propertyIndex); \
+            QMetaObject::metacall(target, QMetaObject::WriteProperty, instr.propertyIndex, a); \
+        } \
+    QML_END_INSTR(name)
+
 #define QML_STORE_LIST(name, cpptype, value) \
     QML_BEGIN_INSTR(name) \
         cpptype v; \
@@ -366,7 +376,7 @@ QObject *QQmlVME::run(QList<QQmlError> *errors,
         QML_STORE_VALUE(StoreDouble, double, instr.value);
         QML_STORE_VALUE(StoreBool, bool, instr.value);
         QML_STORE_VALUE(StoreInteger, int, instr.value);
-        QML_STORE_VALUE(StoreColor, QColor, QColor::fromRgba(instr.value));
+        QML_STORE_PROVIDER_VALUE(StoreColor, QMetaType::QColor, instr.value);
         QML_STORE_VALUE(StoreDate, QDate, QDate::fromJulianDay(instr.value));
         QML_STORE_VALUE(StoreDateTime, QDateTime,
                         QDateTime(QDate::fromJulianDay(instr.date), *(QTime *)&instr.time));
@@ -377,8 +387,8 @@ QObject *QQmlVME::run(QList<QQmlError> *errors,
         QML_STORE_POINTER(StoreSizeF, (QSizeF *)&instr.size);
         QML_STORE_POINTER(StoreRect, (QRect *)&instr.rect);
         QML_STORE_POINTER(StoreRectF, (QRectF *)&instr.rect);
-        QML_STORE_POINTER(StoreVector3D, (QVector3D *)&instr.vector);
-        QML_STORE_POINTER(StoreVector4D, (QVector4D *)&instr.vector);
+        QML_STORE_PROVIDER_VALUE(StoreVector3D, QMetaType::QVector3D, instr.vector);
+        QML_STORE_PROVIDER_VALUE(StoreVector4D, QMetaType::QVector4D, instr.vector);
         QML_STORE_POINTER(StoreString, &PRIMITIVES.at(instr.value));
         QML_STORE_POINTER(StoreByteArray, &DATAS.at(instr.value));
         QML_STORE_POINTER(StoreUrl, &URLS.at(instr.value));
diff --git a/src/qml/qml/qqmlvmemetaobject.cpp b/src/qml/qml/qqmlvmemetaobject.cpp
index c4e801f..afcc57e 100644
--- a/src/qml/qml/qqmlvmemetaobject.cpp
+++ b/src/qml/qml/qqmlvmemetaobject.cpp
@@ -51,6 +51,7 @@
 #include "qqmlpropertyvalueinterceptor_p.h"
 
 #include <private/qv8variantresource_p.h>
+#include <private/qqmlglobal_p.h>
 
 Q_DECLARE_METATYPE(QJSValue);
 
@@ -87,6 +88,7 @@ public:
     inline const void *dataPtr() const;
     inline void *dataPtr();
     inline int dataType() const;
+    inline size_t dataSize() const;
 
     inline QObject *asQObject();
     inline const QVariant &asQVariant();
@@ -95,7 +97,6 @@ public:
     inline double asDouble();
     inline const QString &asQString();
     inline const QUrl &asQUrl();
-    inline const QColor &asQColor();
     inline const QTime &asQTime();
     inline const QDate &asQDate();
     inline const QDateTime &asQDateTime();
@@ -108,11 +109,13 @@ public:
     inline void setValue(double);
     inline void setValue(const QString &);
     inline void setValue(const QUrl &);
-    inline void setValue(const QColor &);
     inline void setValue(const QTime &);
     inline void setValue(const QDate &);
     inline void setValue(const QDateTime &);
     inline void setValue(const QJSValue &);
+
+    inline void setDataType(int t);
+
 private:
     int type;
     void *data[6]; // Large enough to hold all types
@@ -157,9 +160,6 @@ void QQmlVMEVariant::cleanup()
     } else if (type == QMetaType::QUrl) {
         ((QUrl *)dataPtr())->~QUrl();
         type = QVariant::Invalid;
-    } else if (type == QMetaType::QColor) {
-        ((QColor *)dataPtr())->~QColor();
-        type = QVariant::Invalid;
     } else if (type == QMetaType::QTime) {
         ((QTime *)dataPtr())->~QTime();
         type = QVariant::Invalid;
@@ -175,8 +175,11 @@ void QQmlVMEVariant::cleanup()
     } else if (type == qMetaTypeId<QJSValue>()) {
         ((QJSValue *)dataPtr())->~QJSValue();
         type = QVariant::Invalid;
+    } else {
+        if (QQml_valueTypeProvider()->destroyValueType(type, dataPtr(), dataSize())) {
+            type = QVariant::Invalid;
+        }
     }
-
 }
 
 int QQmlVMEVariant::dataType() const
@@ -194,6 +197,11 @@ void *QQmlVMEVariant::dataPtr()
     return &data;
 }
 
+size_t QQmlVMEVariant::dataSize() const
+{
+    return sizeof(data);
+}
+
 QObject *QQmlVMEVariant::asQObject() 
 {
     if (type != QMetaType::QObjectStar)
@@ -250,14 +258,6 @@ const QUrl &QQmlVMEVariant::asQUrl()
     return *(QUrl *)(dataPtr());
 }
 
-const QColor &QQmlVMEVariant::asQColor() 
-{
-    if (type != QMetaType::QColor)
-        setValue(QColor());
-
-    return *(QColor *)(dataPtr());
-}
-
 const QTime &QQmlVMEVariant::asQTime() 
 {
     if (type != QMetaType::QTime)
@@ -360,17 +360,6 @@ void QQmlVMEVariant::setValue(const QUrl &v)
     }
 }
 
-void QQmlVMEVariant::setValue(const QColor &v)
-{
-    if (type != QMetaType::QColor) {
-        cleanup();
-        type = QMetaType::QColor;
-        new (dataPtr()) QColor(v);
-    } else {
-        *(QColor *)(dataPtr()) = v;
-    }
-}
-
 void QQmlVMEVariant::setValue(const QTime &v)
 {
     if (type != QMetaType::QTime) {
@@ -415,6 +404,11 @@ void QQmlVMEVariant::setValue(const QJSValue &v)
     }
 }
 
+void QQmlVMEVariant::setDataType(int t)
+{
+    type = t;
+}
+
 QQmlVMEMetaObjectEndpoint::QQmlVMEMetaObjectEndpoint()
 {
     callback = &vmecallback;
@@ -587,9 +581,6 @@ int QQmlVMEMetaObject::metaCall(QMetaObject::Call c, int _id, void **a)
                         case QVariant::Url:
                             *reinterpret_cast<QUrl *>(a[0]) = data[id].asQUrl();
                             break;
-                        case QVariant::Color:
-                            *reinterpret_cast<QColor *>(a[0]) = data[id].asQColor();
-                            break;
                         case QVariant::Date:
                             *reinterpret_cast<QDate *>(a[0]) = data[id].asQDate();
                             break;
@@ -603,6 +594,7 @@ int QQmlVMEMetaObject::metaCall(QMetaObject::Call c, int _id, void **a)
                             *reinterpret_cast<QVariant *>(a[0]) = readPropertyAsVariant(id);
                             break;
                         default:
+                            QQml_valueTypeProvider()->readValueType(data[id].dataType(), data[id].dataPtr(), t, a[0]);
                             break;
                         }
                         if (t == qMetaTypeId<QQmlListProperty<QObject> >()) {
@@ -637,10 +629,6 @@ int QQmlVMEMetaObject::metaCall(QMetaObject::Call c, int _id, void **a)
                             needActivate = *reinterpret_cast<QUrl *>(a[0]) != data[id].asQUrl();
                             data[id].setValue(*reinterpret_cast<QUrl *>(a[0]));
                             break;
-                        case QVariant::Color:
-                            needActivate = *reinterpret_cast<QColor *>(a[0]) != data[id].asQColor();
-                            data[id].setValue(*reinterpret_cast<QColor *>(a[0]));
-                            break;
                         case QVariant::Date:
                             needActivate = *reinterpret_cast<QDate *>(a[0]) != data[id].asQDate();
                             data[id].setValue(*reinterpret_cast<QDate *>(a[0]));
@@ -657,6 +645,10 @@ int QQmlVMEMetaObject::metaCall(QMetaObject::Call c, int _id, void **a)
                             writeProperty(id, *reinterpret_cast<QVariant *>(a[0]));
                             break;
                         default:
+                            needActivate = QQml_valueTypeProvider()->writeValueType(t, a[0], data[id].dataPtr(), data[id].dataSize());
+                            if (needActivate) {
+                                data[id].setDataType(t);
+                            }
                             break;
                         }
                     }
diff --git a/src/qml/qml/qqmlvmemetaobject_p.h b/src/qml/qml/qqmlvmemetaobject_p.h
index 1b5ceb8..5bd472a 100644
--- a/src/qml/qml/qqmlvmemetaobject_p.h
+++ b/src/qml/qml/qqmlvmemetaobject_p.h
@@ -58,7 +58,6 @@
 #include <QtCore/QMetaObject>
 #include <QtCore/QBitArray>
 #include <QtCore/QPair>
-#include <QtGui/QColor>
 #include <QtCore/QDate>
 #include <QtCore/qlist.h>
 #include <QtCore/qdebug.h>
diff --git a/src/qml/qml/qquickapplication.cpp b/src/qml/qml/qquickapplication.cpp
deleted file mode 100644
index 198a917..0000000
--- a/src/qml/qml/qquickapplication.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qquickapplication_p.h"
-#include <private/qobject_p.h>
-#include <QtGui/QGuiApplication>
-#include <QtGui/QInputMethod>
-#include <QtCore/QDebug>
-
-QT_BEGIN_NAMESPACE
-
-class QQuickApplicationPrivate : public QObjectPrivate
-{
-    Q_DECLARE_PUBLIC(QQuickApplication)
-public:
-    QQuickApplicationPrivate() : active(QGuiApplication::activeWindow() != 0),
-    layoutDirection(QGuiApplication::layoutDirection()) {}
-    bool active;
-    Qt::LayoutDirection layoutDirection;
-};
-
-/*
-    This object and its properties are documented as part of the Qt object,
-    in qdeclarativengine.cpp
-*/
-
-QQuickApplication::QQuickApplication(QObject *parent) : QObject(*new QQuickApplicationPrivate(), parent)
-{
-    if (qApp)
-        qApp->installEventFilter(this);
-}
-
-QQuickApplication::~QQuickApplication()
-{
-}
-
-bool QQuickApplication::active() const
-{
-    Q_D(const QQuickApplication);
-    return d->active;
-}
-
-Qt::LayoutDirection QQuickApplication::layoutDirection() const
-{
-    Q_D(const QQuickApplication);
-    return d->layoutDirection;
-}
-
-QObject *QQuickApplication::inputPanel() const
-{
-    static bool warned = false;
-    if (!warned) {
-        qWarning() << "Qt.application.inputPanel is deprecated, use Qt.inputMethod instead";
-        warned = true;
-    }
-    return qApp ? qApp->inputMethod() : 0;
-}
-
-bool QQuickApplication::eventFilter(QObject *obj, QEvent *event)
-{
-    Q_UNUSED(obj)
-    Q_D(QQuickApplication);
-    if (event->type() == QEvent::ApplicationActivate
-     || event->type() == QEvent::ApplicationDeactivate) {
-        bool active = d->active;
-        if (event->type() == QEvent::ApplicationActivate)
-            active  = true;
-        else if (event->type() == QEvent::ApplicationDeactivate)
-            active  = false;
-
-        if (d->active != active) {
-            d->active = active;
-            emit activeChanged();
-        }
-    }
-    if (event->type() == QEvent::LayoutDirectionChange) {
-        Qt::LayoutDirection direction = QGuiApplication::layoutDirection();
-        if (d->layoutDirection != direction) {
-            d->layoutDirection = direction;
-            emit layoutDirectionChanged();
-        }
-    }
-    return false;
-}
-
-QT_END_NAMESPACE
diff --git a/src/qml/qml/qquickapplication_p.h b/src/qml/qml/qquickapplication_p.h
deleted file mode 100644
index 6619894..0000000
--- a/src/qml/qml/qquickapplication_p.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QQUICKAPPLICATION_P_H
-#define QQUICKAPPLICATION_P_H
-
-#include <QtCore/QObject>
-#include <qqml.h>
-#include <private/qtqmlglobal_p.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-class QQuickApplicationPrivate;
-class Q_QML_PRIVATE_EXPORT QQuickApplication : public QObject
-{
-    Q_OBJECT
-    Q_PROPERTY(bool active READ active NOTIFY activeChanged)
-    Q_PROPERTY(Qt::LayoutDirection layoutDirection READ layoutDirection NOTIFY layoutDirectionChanged)
-    Q_PROPERTY(QObject *inputPanel READ inputPanel CONSTANT)
-
-public:
-    explicit QQuickApplication(QObject *parent = 0);
-    virtual ~QQuickApplication();
-    bool active() const;
-    Qt::LayoutDirection layoutDirection() const;
-    QT_DEPRECATED QObject *inputPanel() const;
-
-protected:
-    bool eventFilter(QObject *obj, QEvent *event);
-
-Q_SIGNALS:
-    void activeChanged();
-    void layoutDirectionChanged();
-
-private:
-    Q_DISABLE_COPY(QQuickApplication)
-    Q_DECLARE_PRIVATE(QQuickApplication)
-};
-
-QT_END_NAMESPACE
-
-QML_DECLARE_TYPE(QQuickApplication)
-
-QT_END_HEADER
-
-#endif // QQUICKAPPLICATION_P_H
diff --git a/src/qml/qml/qquicklistmodelworkeragent_p.h b/src/qml/qml/qquicklistmodelworkeragent_p.h
index cf2ef45..24198b0 100644
--- a/src/qml/qml/qquicklistmodelworkeragent_p.h
+++ b/src/qml/qml/qquicklistmodelworkeragent_p.h
@@ -55,7 +55,6 @@
 
 #include <qqml.h>
 
-#include <QtGui/qevent.h>
 #include <QMutex>
 #include <QWaitCondition>
 
diff --git a/src/qml/qml/v4/qv4bindings.cpp b/src/qml/qml/v4/qv4bindings.cpp
index 5d367f2..38a3aca 100644
--- a/src/qml/qml/v4/qv4bindings.cpp
+++ b/src/qml/qml/v4/qv4bindings.cpp
@@ -46,6 +46,7 @@
 #include "qv4compiler_p.h"
 #include "qv4compiler_p_p.h"
 
+#include <private/qqmlglobal_p.h>
 #include <private/qqmlaccessors_p.h>
 #include <private/qqmlprofilerservice_p.h>
 #include <private/qqmlmetatype_p.h>
@@ -88,12 +89,11 @@ struct Register {
     QVariant *getvariantptr() { return (QVariant *)typeDataPtr(); }
     QString *getstringptr() { return (QString *)typeDataPtr(); }
     QUrl *geturlptr() { return (QUrl *)typeDataPtr(); }
-    QColor *getcolorptr() { return (QColor *)typeDataPtr(); }
     const QVariant *getvariantptr() const { return (QVariant *)typeDataPtr(); }
     const QString *getstringptr() const { return (QString *)typeDataPtr(); }
     const QUrl *geturlptr() const { return (QUrl *)typeDataPtr(); }
-    const QColor *getcolorptr() const { return (QColor *)typeDataPtr(); }
 
+    size_t dataSize() { return sizeof(data); }
     void *typeDataPtr() { return (void *)&data; }
     void *typeMemory() { return (void *)data; }
     const void *typeDataPtr() const { return (void *)&data; }
@@ -141,7 +141,7 @@ void Register::cleanup()
         } else if (dataType == QUrlType) {
             geturlptr()->~QUrl();
         } else if (dataType == QColorType) {
-            getcolorptr()->~QColor();
+            QQml_valueTypeProvider()->destroyValueType(QMetaType::QColor, typeDataPtr(), dataSize());
         } else if (dataType == QVariantType) {
             getvariantptr()->~QVariant();
         }
@@ -163,7 +163,7 @@ void Register::cleanupUrl()
 
 void Register::cleanupColor()
 {
-    getcolorptr()->~QColor();
+    QQml_valueTypeProvider()->destroyValueType(QMetaType::QColor, typeDataPtr(), dataSize());
     setUndefined();
 }
 
@@ -182,7 +182,7 @@ void Register::copy(const Register &other)
         else if (other.dataType == QUrlType)
             new (geturlptr()) QUrl(*other.geturlptr());
         else if (other.dataType == QColorType)
-            new (getcolorptr()) QColor(*other.getcolorptr());
+            QQml_valueTypeProvider()->copyValueType(QMetaType::QColor, other.typeDataPtr(), typeDataPtr(), dataSize());
         else if (other.dataType == QVariantType)
             new (getvariantptr()) QVariant(*other.getvariantptr());
     } 
@@ -197,7 +197,7 @@ void Register::init(Type type)
         else if (dataType == QUrlType)
             new (geturlptr()) QUrl();
         else if (dataType == QColorType)
-            new (getcolorptr()) QColor();
+            QQml_valueTypeProvider()->initValueType(QMetaType::QColor, typeDataPtr(), dataSize());
         else if (dataType == QVariantType)
             new (getvariantptr()) QVariant();
     }
@@ -1081,8 +1081,7 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
                 output.cleanupString();
                 MARK_CLEAN_REGISTER(instr->unaryop.output);
             }
-            QColor *colorPtr = output.getcolorptr();
-            new (colorPtr) QColor(QQmlStringConverters::colorFromString(tmp));
+            QQml_valueTypeProvider()->createValueFromString(QMetaType::QColor, tmp, output.typeDataPtr(), output.dataSize());
 
             COLOR_REGISTER(instr->unaryop.output);
         }
@@ -1148,13 +1147,7 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
         if (src.isUndefined()) {
             output.setUndefined();
         } else {
-            const QColor tmp(*src.getcolorptr());
-            if (instr->unaryop.src == instr->unaryop.output) {
-                output.cleanupColor();
-                MARK_CLEAN_REGISTER(instr->unaryop.output);
-            }
-            // to maintain behaviour with QtQuick 1.0, we just output normal toString() value.
-            new (output.getstringptr()) QString(QVariant(tmp).toString());
+            QQml_valueTypeProvider()->createStringFromValue(QMetaType::QColor, src.typeDataPtr(), output.getstringptr());
             STRING_REGISTER(instr->unaryop.output);
         }
     }
diff --git a/src/qml/qml/v8/qqmlbuiltinfunctions.cpp b/src/qml/qml/v8/qqmlbuiltinfunctions.cpp
index 68c62ef..0cd5d0a 100644
--- a/src/qml/qml/v8/qqmlbuiltinfunctions.cpp
+++ b/src/qml/qml/v8/qqmlbuiltinfunctions.cpp
@@ -51,6 +51,7 @@
 
 #include <private/qv8profilerservice_p.h>
 #include <private/qqmlprofilerservice_p.h>
+#include <private/qqmlglobal_p.h>
 
 #include <QtCore/qstring.h>
 #include <QtCore/qdatetime.h>
@@ -62,12 +63,6 @@
 #include <QtCore/qfile.h>
 #include <QtCore/qcoreapplication.h>
 
-#include <QtGui/qcolor.h>
-#include <QtGui/qvector3d.h>
-#include <QtGui/qvector4d.h>
-#include <QtGui/qdesktopservices.h>
-#include <QtGui/qfontdatabase.h>
-
 QT_BEGIN_NAMESPACE
 
 namespace QQmlBuiltinFunctions {
@@ -417,7 +412,7 @@ v8::Handle<v8::Value> rgba(const v8::Arguments &args)
     if (a < 0.0) a=0.0;
     if (a > 1.0) a=1.0;
 
-    return V8ENGINE()->fromVariant(QVariant::fromValue(QColor::fromRgbF(r, g, b, a)));
+    return V8ENGINE()->fromVariant(QQml_colorProvider()->fromRgbF(r, g, b, a));
 }
 
 /*!
@@ -446,7 +441,7 @@ v8::Handle<v8::Value> hsla(const v8::Arguments &args)
     if (a < 0.0) a=0.0;
     if (a > 1.0) a=1.0;
 
-    return V8ENGINE()->fromVariant(QVariant::fromValue(QColor::fromHslF(h, s, l, a)));
+    return V8ENGINE()->fromVariant(QQml_colorProvider()->fromHslF(h, s, l, a));
 }
 
 /*!
@@ -508,11 +503,13 @@ v8::Handle<v8::Value> vector3d(const v8::Arguments &args)
     if (args.Length() != 3)
         V8THROW_ERROR("Qt.vector(): Invalid arguments");
 
-    double x = args[0]->ToNumber()->Value();
-    double y = args[1]->ToNumber()->Value();
-    double z = args[2]->ToNumber()->Value();
+    float xyz[3];
+    xyz[0] = args[0]->ToNumber()->Value();
+    xyz[1] = args[1]->ToNumber()->Value();
+    xyz[2] = args[2]->ToNumber()->Value();
 
-    return V8ENGINE()->fromVariant(QVariant::fromValue(QVector3D(x, y, z)));
+    const void *params[] = { xyz };
+    return V8ENGINE()->fromVariant(QQml_valueTypeProvider()->createValueType(QMetaType::QVector3D, 1, params));
 }
 
 /*!
@@ -524,12 +521,14 @@ v8::Handle<v8::Value> vector4d(const v8::Arguments &args)
     if (args.Length() != 4)
         V8THROW_ERROR("Qt.vector4d(): Invalid arguments");
 
-    double x = args[0]->NumberValue();
-    double y = args[1]->NumberValue();
-    double z = args[2]->NumberValue();
-    double w = args[3]->NumberValue();
+    float xyzw[4];
+    xyzw[0] = args[0]->ToNumber()->Value();
+    xyzw[1] = args[1]->ToNumber()->Value();
+    xyzw[2] = args[2]->ToNumber()->Value();
+    xyzw[3] = args[3]->ToNumber()->Value();
 
-    return V8ENGINE()->fromVariant(QVariant::fromValue(QVector4D(x, y, z, w)));
+    const void *params[] = { xyzw };
+    return V8ENGINE()->fromVariant(QQml_valueTypeProvider()->createValueType(QMetaType::QVector4D, 1, params));
 }
 
 /*!
@@ -551,17 +550,14 @@ v8::Handle<v8::Value> lighter(const v8::Arguments &args)
     if (args.Length() != 1 && args.Length() != 2)
         V8THROW_ERROR("Qt.lighter(): Invalid arguments");
 
-    QColor color;
     QVariant v = V8ENGINE()->toVariant(args[0], -1);
-    if (v.userType() == QVariant::Color) {
-        color = v.value<QColor>();
-    } else if (v.userType() == QVariant::String) {
+    if (v.userType() == QVariant::String) {
         bool ok = false;
-        color = QQmlStringConverters::colorFromString(v.toString(), &ok);
+        v = QQmlStringConverters::colorFromString(v.toString(), &ok);
         if (!ok) {
             return v8::Null();
         }
-    } else {
+    } else if (v.userType() != QVariant::Color) {
         return v8::Null();
     }
 
@@ -569,8 +565,7 @@ v8::Handle<v8::Value> lighter(const v8::Arguments &args)
     if (args.Length() == 2)
         factor = args[1]->ToNumber()->Value();
 
-    color = color.lighter(int(qRound(factor*100.)));
-    return V8ENGINE()->fromVariant(QVariant::fromValue(color));
+    return V8ENGINE()->fromVariant(QQml_colorProvider()->lighter(v, factor));
 }
 
 /*!
@@ -593,17 +588,14 @@ v8::Handle<v8::Value> darker(const v8::Arguments &args)
     if (args.Length() != 1 && args.Length() != 2)
         V8THROW_ERROR("Qt.darker(): Invalid arguments");
 
-    QColor color;
     QVariant v = V8ENGINE()->toVariant(args[0], -1);
-    if (v.userType() == QVariant::Color) {
-        color = v.value<QColor>();
-    } else if (v.userType() == QVariant::String) {
+    if (v.userType() == QVariant::String) {
         bool ok = false;
-        color = QQmlStringConverters::colorFromString(v.toString(), &ok);
+        v = QQmlStringConverters::colorFromString(v.toString(), &ok);
         if (!ok) {
             return v8::Null();
         }
-    } else {
+    } else if (v.userType() != QVariant::Color) {
         return v8::Null();
     }
 
@@ -611,8 +603,7 @@ v8::Handle<v8::Value> darker(const v8::Arguments &args)
     if (args.Length() == 2)
         factor = args[1]->ToNumber()->Value();
 
-    color = color.darker(int(qRound(factor*100.)));
-    return V8ENGINE()->fromVariant(QVariant::fromValue(color));
+    return V8ENGINE()->fromVariant(QQml_colorProvider()->darker(v, factor));
 }
 
 /*!
@@ -645,53 +636,30 @@ v8::Handle<v8::Value> tint(const v8::Arguments &args)
         V8THROW_ERROR("Qt.tint(): Invalid arguments");
 
     // base color
-    QColor color;
-    QVariant v = V8ENGINE()->toVariant(args[0], -1);
-    if (v.userType() == QVariant::Color) {
-        color = v.value<QColor>();
-    } else if (v.userType() == QVariant::String) {
+    QVariant v1 = V8ENGINE()->toVariant(args[0], -1);
+    if (v1.userType() == QVariant::String) {
         bool ok = false;
-        color = QQmlStringConverters::colorFromString(v.toString(), &ok);
+        v1 = QQmlStringConverters::colorFromString(v1.toString(), &ok);
         if (!ok) {
             return v8::Null();
         }
-    } else {
+    } else if (v1.userType() != QVariant::Color) {
         return v8::Null();
     }
 
     // tint color
-    QColor tintColor;
-    v = V8ENGINE()->toVariant(args[1], -1);
-    if (v.userType() == QVariant::Color) {
-        tintColor = v.value<QColor>();
-    } else if (v.userType() == QVariant::String) {
+    QVariant v2 = V8ENGINE()->toVariant(args[1], -1);
+    if (v2.userType() == QVariant::String) {
         bool ok = false;
-        tintColor = QQmlStringConverters::colorFromString(v.toString(), &ok);
+        v2 = QQmlStringConverters::colorFromString(v2.toString(), &ok);
         if (!ok) {
             return v8::Null();
         }
-    } else {
+    } else if (v2.userType() != QVariant::Color) {
         return v8::Null();
     }
 
-    // tint the base color and return the final color
-    QColor finalColor;
-    int a = tintColor.alpha();
-    if (a == 0xFF)
-        finalColor = tintColor;
-    else if (a == 0x00)
-        finalColor = color;
-    else {
-        qreal a = tintColor.alphaF();
-        qreal inv_a = 1.0 - a;
-
-        finalColor.setRgbF(tintColor.redF() * a + color.redF() * inv_a,
-                           tintColor.greenF() * a + color.greenF() * inv_a,
-                           tintColor.blueF() * a + color.blueF() * inv_a,
-                           a + inv_a * color.alphaF());
-    }
-
-    return V8ENGINE()->fromVariant(QVariant::fromValue(finalColor));
+    return V8ENGINE()->fromVariant(QQml_colorProvider()->tint(v1, v2));
 }
 
 /*!
@@ -908,11 +876,8 @@ v8::Handle<v8::Value> openUrlExternally(const v8::Arguments &args)
     if (args.Length() != 1)
         return V8ENGINE()->fromVariant(false);
 
-    bool ret = false;
-#ifndef QT_NO_DESKTOPSERVICES
-    ret = QDesktopServices::openUrl(V8ENGINE()->toVariant(resolvedUrl(args), -1).toUrl());
-#endif
-    return V8ENGINE()->fromVariant(ret);
+    QUrl url(V8ENGINE()->toVariant(resolvedUrl(args), -1).toUrl());
+    return V8ENGINE()->fromVariant(QQml_guiProvider()->openUrlExternally(url));
 }
 
 /*!
@@ -945,8 +910,7 @@ v8::Handle<v8::Value> fontFamilies(const v8::Arguments &args)
     if (args.Length() != 0)
         V8THROW_ERROR("Qt.fontFamilies(): Invalid arguments");
 
-    QFontDatabase database;
-    return V8ENGINE()->fromVariant(database.families());
+    return V8ENGINE()->fromVariant(QVariant(QQml_guiProvider()->fontFamilies()));
 }
 
 /*!
diff --git a/src/qml/qml/v8/qv8engine.cpp b/src/qml/qml/v8/qv8engine.cpp
index ab3283f..f0df025 100644
--- a/src/qml/qml/v8/qv8engine.cpp
+++ b/src/qml/qml/v8/qv8engine.cpp
@@ -41,8 +41,6 @@
 
 #include "qv8engine_p.h"
 
-#include <QtGui/QGuiApplication>
-
 #include "qv8contextwrapper_p.h"
 #include "qv8valuetypewrapper_p.h"
 #include "qv8sequencewrapper_p.h"
@@ -53,9 +51,9 @@
 #include <private/qqmlbuiltinfunctions_p.h>
 #include <private/qqmllist_p.h>
 #include <private/qqmlengine_p.h>
-#include <private/qquickapplication_p.h>
 #include <private/qqmlxmlhttprequest_p.h>
 #include <private/qqmllocale_p.h>
+#include <private/qqmlglobal_p.h>
 
 #include "qscript_impl_p.h"
 #include "qv8domerrors_p.h"
@@ -125,6 +123,7 @@ QV8Engine::QV8Engine(QJSEngine* qq, QJSEngine::ContextOwnership ownership)
     , m_ownsV8Context(ownership == QJSEngine::CreateNewContext)
     , m_xmlHttpRequestData(0)
     , m_listModelData(0)
+    , m_application(0)
 {
     qMetaTypeId<QJSValue>();
     qMetaTypeId<QList<int> >();
@@ -538,9 +537,6 @@ QVariant QV8Engine::toBasicVariant(v8::Handle<v8::Value> value)
 
 
 
-#include <QtGui/qvector3d.h>
-#include <QtGui/qvector4d.h>
-
 struct StaticQtMetaObject : public QObject
 {
     static const QMetaObject *get()
@@ -606,8 +602,8 @@ void QV8Engine::initializeGlobal(v8::Handle<v8::Object> global)
     qt->Set(v8::String::New("binding"), V8FUNCTION(binding, this));
 
     if (m_engine) {
-        qt->Set(v8::String::New("application"), newQObject(new QQuickApplication(m_engine)));
-        qt->Set(v8::String::New("inputMethod"), newQObject(qGuiApp->inputMethod(), CppOwnership));
+        qt->SetAccessor(v8::String::New("application"), getApplication, 0, v8::External::New(this));
+        qt->SetAccessor(v8::String::New("inputMethod"), getInputMethod, 0, v8::External::New(this));
         qt->Set(v8::String::New("lighter"), V8FUNCTION(lighter, this));
         qt->Set(v8::String::New("darker"), V8FUNCTION(darker, this));
         qt->Set(v8::String::New("tint"), V8FUNCTION(tint, this));
@@ -1528,6 +1524,22 @@ int QV8Engine::consoleCountHelper(const QString &file, int line, int column)
     return number;
 }
 
+v8::Handle<v8::Value> QV8Engine::getApplication(v8::Local<v8::String>, const v8::AccessorInfo &info)
+{
+    QV8Engine *engine = reinterpret_cast<QV8Engine*>(v8::External::Unwrap(info.Data()));
+    if (!engine->m_application) {
+        // Only allocate an application object once
+        engine->m_application = QQml_guiProvider()->application(engine->m_engine);
+    }
+    return engine->newQObject(engine->m_application);
+}
+
+v8::Handle<v8::Value> QV8Engine::getInputMethod(v8::Local<v8::String>, const v8::AccessorInfo &info)
+{
+    QV8Engine *engine = reinterpret_cast<QV8Engine*>(v8::External::Unwrap(info.Data()));
+    return engine->newQObject(QQml_guiProvider()->inputMethod(), CppOwnership);
+}
+
 void QV8GCCallback::registerGcPrologueCallback()
 {
     QV8Engine::ThreadData *td = QV8Engine::threadData();
diff --git a/src/qml/qml/v8/qv8engine_p.h b/src/qml/qml/v8/qv8engine_p.h
index 825d7a3..2eb3668 100644
--- a/src/qml/qml/v8/qv8engine_p.h
+++ b/src/qml/qml/v8/qv8engine_p.h
@@ -443,6 +443,9 @@ public:
     void addRelationshipForGC(QObject *object, v8::Persistent<v8::Value> handle);
     void addRelationshipForGC(QObject *object, QObject *other);
 
+    static v8::Handle<v8::Value> getApplication(v8::Local<v8::String> property, const v8::AccessorInfo &info);
+    static v8::Handle<v8::Value> getInputMethod(v8::Local<v8::String> property, const v8::AccessorInfo &info);
+
     struct ThreadData {
         ThreadData();
         ~ThreadData();
@@ -492,6 +495,8 @@ protected:
 
     QHash<QString, quint32> m_consoleCount;
 
+    QObject *m_application;
+
     QVariant toBasicVariant(v8::Handle<v8::Value>);
 
     void initializeGlobal(v8::Handle<v8::Object>);
diff --git a/src/quick/qtquick2.cpp b/src/quick/qtquick2.cpp
index a97dade..16cf219 100644
--- a/src/quick/qtquick2.cpp
+++ b/src/quick/qtquick2.cpp
@@ -42,10 +42,11 @@
 #include "qtquick2_p.h"
 #include <private/qqmlengine_p.h>
 #include <private/qquickutilmodule_p.h>
-#include <private/qqmlvaluetype_p.h>
+#include <private/qquickvaluetypes_p.h>
 #include <private/qquickitemsmodule_p.h>
 #include <private/qquickparticlesmodule_p.h>
 #include <private/qquickwindowmodule_p.h>
+#include <private/qquickapplication_p.h>
 
 #include <private/qqmlenginedebugservice_p.h>
 #include <private/qqmldebugstatesdelegate_p.h>
@@ -177,7 +178,10 @@ void QQmlQtQuick2Module::defineModule()
     QQuickItemsModule::defineModule();
     QQuickParticlesModule::defineModule();
     QQuickWindowModule::defineModule();
-    QQmlValueTypeFactory::registerValueTypes();
+
+    qmlRegisterUncreatableType<QQuickApplication>("QtQuick",2,0,"Application", QQuickApplication::tr("Application is an abstract class"));
+
+    QQuickValueTypes::registerValueTypes();
 
     if (QQmlEngineDebugService::isDebuggingEnabled()) {
         QQmlEngineDebugService::instance()->setStatesDelegate(
diff --git a/src/quick/util/qquickanimation.cpp b/src/quick/util/qquickanimation.cpp
index 33a5d0a..fc1e6ec 100644
--- a/src/quick/util/qquickanimation.cpp
+++ b/src/quick/util/qquickanimation.cpp
@@ -1755,38 +1755,19 @@ void QQuickPropertyAnimationPrivate::convertVariant(QVariant &variant, int type)
     }
 
     switch (type) {
-    case QVariant::Rect: {
-        variant.setValue(QQmlStringConverters::rectFFromString(variant.toString()).toRect());
-        break;
-    }
-    case QVariant::RectF: {
-        variant.setValue(QQmlStringConverters::rectFFromString(variant.toString()));
-        break;
-    }
-    case QVariant::Point: {
-        variant.setValue(QQmlStringConverters::pointFFromString(variant.toString()).toPoint());
-        break;
-    }
-    case QVariant::PointF: {
-        variant.setValue(QQmlStringConverters::pointFFromString(variant.toString()));
-        break;
-    }
-    case QVariant::Size: {
-        variant.setValue(QQmlStringConverters::sizeFFromString(variant.toString()).toSize());
-        break;
-    }
-    case QVariant::SizeF: {
-        variant.setValue(QQmlStringConverters::sizeFFromString(variant.toString()));
-        break;
-    }
-    case QVariant::Color: {
-        variant.setValue(QQmlStringConverters::colorFromString(variant.toString()));
-        break;
-    }
-    case QVariant::Vector3D: {
-        variant.setValue(QQmlStringConverters::vector3DFromString(variant.toString()));
+    case QVariant::Rect:
+    case QVariant::RectF:
+    case QVariant::Point:
+    case QVariant::PointF:
+    case QVariant::Size:
+    case QVariant::SizeF:
+    case QVariant::Color:
+    case QVariant::Vector3D:
+        {
+        bool ok = false;
+        variant = QQmlStringConverters::variantFromString(variant.toString(), type, &ok);
+        }
         break;
-    }
     default:
         if (QQmlValueTypeFactory::isValueType((uint)type)) {
             variant.convert((QVariant::Type)type);
diff --git a/src/quick/util/qquickapplication.cpp b/src/quick/util/qquickapplication.cpp
new file mode 100644
index 0000000..55ebb11
--- /dev/null
+++ b/src/quick/util/qquickapplication.cpp
@@ -0,0 +1,124 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQuick module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qquickapplication_p.h"
+
+#include <private/qobject_p.h>
+#include <QtGui/QGuiApplication>
+#include <QtCore/QDebug>
+
+QT_BEGIN_NAMESPACE
+
+class QQuickApplicationPrivate : public QObjectPrivate
+{
+    Q_DECLARE_PUBLIC(QQuickApplication)
+public:
+    QQuickApplicationPrivate()
+        : isActive(QGuiApplication::focusWindow() != 0),
+          direction(QGuiApplication::layoutDirection())
+    {
+    }
+
+private:
+    bool isActive;
+    Qt::LayoutDirection direction;
+};
+
+/*
+    This object and its properties are documented as part of the Qt object,
+    in qqmlengine.cpp
+*/
+
+QQuickApplication::QQuickApplication(QObject *parent)
+    : QObject(*new QQuickApplicationPrivate(), parent)
+{
+    if (qApp) {
+        qApp->installEventFilter(this);
+    }
+}
+
+QQuickApplication::~QQuickApplication()
+{
+}
+
+bool QQuickApplication::active() const
+{
+    Q_D(const QQuickApplication);
+    return d->isActive;
+}
+
+Qt::LayoutDirection QQuickApplication::layoutDirection() const
+{
+    Q_D(const QQuickApplication);
+    return d->direction;
+}
+
+QObject *QQuickApplication::inputPanel() const
+{
+    static bool warned = false;
+    if (!warned) {
+        qWarning() << "Qt.application.inputPanel is deprecated, use Qt.inputMethod instead";
+        warned = true;
+    }
+    return qGuiApp->inputMethod();
+}
+
+bool QQuickApplication::eventFilter(QObject *, QEvent *event)
+{
+    Q_D(QQuickApplication);
+    if ((event->type() == QEvent::ApplicationActivate) ||
+        (event->type() == QEvent::ApplicationDeactivate)) {
+        bool wasActive = d->isActive;
+        d->isActive = (event->type() == QEvent::ApplicationActivate);
+        if (d->isActive != wasActive) {
+            emit activeChanged();
+        }
+    } else if (event->type() == QEvent::LayoutDirectionChange) {
+        Qt::LayoutDirection newDirection = QGuiApplication::layoutDirection();
+        if (d->direction != newDirection) {
+            d->direction = newDirection;
+            emit layoutDirectionChanged();
+        }
+    }
+    return false;
+}
+
+QT_END_NAMESPACE
diff --git a/src/quick/util/qquickapplication_p.h b/src/quick/util/qquickapplication_p.h
new file mode 100644
index 0000000..e8a3cd5
--- /dev/null
+++ b/src/quick/util/qquickapplication_p.h
@@ -0,0 +1,86 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQuick module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQUICKAPPLICATION_P_H
+#define QQUICKAPPLICATION_P_H
+
+#include <QtCore/QObject>
+#include <qqml.h>
+#include <private/qtquickglobal_p.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+
+class QQuickApplicationPrivate;
+class Q_QUICK_PRIVATE_EXPORT QQuickApplication : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(bool active READ active NOTIFY activeChanged)
+    Q_PROPERTY(Qt::LayoutDirection layoutDirection READ layoutDirection NOTIFY layoutDirectionChanged)
+    Q_PROPERTY(QObject *inputPanel READ inputPanel CONSTANT)
+
+public:
+    explicit QQuickApplication(QObject *parent = 0);
+    virtual ~QQuickApplication();
+    bool active() const;
+    Qt::LayoutDirection layoutDirection() const;
+    QT_DEPRECATED QObject *inputPanel() const;
+
+Q_SIGNALS:
+    void activeChanged();
+    void layoutDirectionChanged();
+
+private:
+    bool eventFilter(QObject *, QEvent *event);
+
+    Q_DISABLE_COPY(QQuickApplication)
+    Q_DECLARE_PRIVATE(QQuickApplication)
+};
+
+QT_END_NAMESPACE
+
+QML_DECLARE_TYPE(QQuickApplication)
+
+QT_END_HEADER
+
+#endif // QQUICKAPPLICATION_P_H
diff --git a/src/quick/util/qquickglobal.cpp b/src/quick/util/qquickglobal.cpp
new file mode 100644
index 0000000..b99cb7a
--- /dev/null
+++ b/src/quick/util/qquickglobal.cpp
@@ -0,0 +1,530 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <private/qquickvaluetypes_p.h>
+#include <private/qquickapplication_p.h>
+#include <private/qqmlglobal_p.h>
+
+#include <QtGui/QGuiApplication>
+#include <QtGui/qdesktopservices.h>
+#include <QtGui/qfontdatabase.h>
+
+
+QT_BEGIN_NAMESPACE
+
+class QQuickColorProvider : public QQmlColorProvider
+{
+public:
+    static inline QColor QColorFromString(const QString &s)
+    {
+        // Should we also handle #rrggbb here?
+        if (s.length() == 9 && s.startsWith(QLatin1Char('#'))) {
+            uchar a = fromHex(s, 1);
+            uchar r = fromHex(s, 3);
+            uchar g = fromHex(s, 5);
+            uchar b = fromHex(s, 7);
+            return QColor(r, g, b, a);
+        }
+
+        return QColor(s);
+    }
+
+    QVariant colorFromString(const QString &s, bool *ok)
+    {
+        QColor c(QColorFromString(s));
+        if (c.isValid()) {
+            if (ok) *ok = true;
+            return QVariant(c);
+        }
+
+        if (ok) *ok = false;
+        return QVariant();
+    }
+
+    unsigned rgbaFromString(const QString &s, bool *ok)
+    {
+        QColor c(QColorFromString(s));
+        if (c.isValid()) {
+            if (ok) *ok = true;
+            return c.rgba();
+        }
+
+        if (ok) *ok = false;
+        return 0;
+    }
+
+    QString stringFromRgba(unsigned rgba)
+    {
+        QColor c(QColor::fromRgba(rgba));
+        if (c.isValid()) {
+            return QVariant(c).toString();
+        }
+
+        return QString();
+    }
+
+    QVariant fromRgbF(double r, double g, double b, double a)
+    {
+        return QVariant(QColor::fromRgbF(r, g, b, a));
+    }
+
+    QVariant fromHslF(double h, double s, double l, double a)
+    {
+        return QVariant(QColor::fromHslF(h, s, l, a));
+    }
+
+    QVariant lighter(const QVariant &var, qreal factor)
+    {
+        QColor color = var.value<QColor>();
+        color = color.lighter(int(qRound(factor*100.)));
+        return QVariant::fromValue(color);
+    }
+
+    QVariant darker(const QVariant &var, qreal factor)
+    {
+        QColor color = var.value<QColor>();
+        color = color.darker(int(qRound(factor*100.)));
+        return QVariant::fromValue(color);
+    }
+
+    QVariant tint(const QVariant &baseVar, const QVariant &tintVar)
+    {
+        QColor tintColor = tintVar.value<QColor>();
+
+        int tintAlpha = tintColor.alpha();
+        if (tintAlpha == 0xFF) {
+            return tintVar;
+        } else if (tintAlpha == 0x00) {
+            return baseVar;
+        }
+
+        // tint the base color and return the final color
+        QColor baseColor = baseVar.value<QColor>();
+        qreal a = tintColor.alphaF();
+        qreal inv_a = 1.0 - a;
+
+        qreal r = tintColor.redF() * a + baseColor.redF() * inv_a;
+        qreal g = tintColor.greenF() * a + baseColor.greenF() * inv_a;
+        qreal b = tintColor.blueF() * a + baseColor.blueF() * inv_a;
+
+        return QVariant::fromValue(QColor::fromRgbF(r, g, b, a + inv_a * baseColor.alphaF()));
+    }
+
+private:
+    static uchar fromHex(const uchar c, const uchar c2)
+    {
+        uchar rv = 0;
+        if (c >= '0' && c <= '9')
+            rv += (c - '0') * 16;
+        else if (c >= 'A' && c <= 'F')
+            rv += (c - 'A' + 10) * 16;
+        else if (c >= 'a' && c <= 'f')
+            rv += (c - 'a' + 10) * 16;
+
+        if (c2 >= '0' && c2 <= '9')
+            rv += (c2 - '0');
+        else if (c2 >= 'A' && c2 <= 'F')
+            rv += (c2 - 'A' + 10);
+        else if (c2 >= 'a' && c2 <= 'f')
+            rv += (c2 - 'a' + 10);
+
+        return rv;
+    }
+
+    static inline uchar fromHex(const QString &s, int idx)
+    {
+        uchar c = s.at(idx).toAscii();
+        uchar c2 = s.at(idx + 1).toAscii();
+        return fromHex(c, c2);
+    }
+};
+
+
+class QQuickValueTypeProvider : public QQmlValueTypeProvider
+{
+public:
+    static QVector3D vector3DFromString(const QString &s, bool *ok)
+    {
+        if (s.count(QLatin1Char(',')) == 2) {
+            int index = s.indexOf(QLatin1Char(','));
+            int index2 = s.indexOf(QLatin1Char(','), index+1);
+
+            bool xGood, yGood, zGood;
+            qreal xCoord = s.left(index).toDouble(&xGood);
+            qreal yCoord = s.mid(index+1, index2-index-1).toDouble(&yGood);
+            qreal zCoord = s.mid(index2+1).toDouble(&zGood);
+
+            if (xGood && yGood && zGood) {
+                if (ok) *ok = true;
+                return QVector3D(xCoord, yCoord, zCoord);
+            }
+        }
+
+        if (ok) *ok = false;
+        return QVector3D();
+    }
+
+    static QVector4D vector4DFromString(const QString &s, bool *ok)
+    {
+        if (s.count(QLatin1Char(',')) == 3) {
+            int index = s.indexOf(QLatin1Char(','));
+            int index2 = s.indexOf(QLatin1Char(','), index+1);
+            int index3 = s.indexOf(QLatin1Char(','), index2+1);
+
+            bool xGood, yGood, zGood, wGood;
+            qreal xCoord = s.left(index).toDouble(&xGood);
+            qreal yCoord = s.mid(index+1, index2-index-1).toDouble(&yGood);
+            qreal zCoord = s.mid(index2+1, index3-index2-1).toDouble(&zGood);
+            qreal wCoord = s.mid(index3+1).toDouble(&wGood);
+
+            if (xGood && yGood && zGood && wGood) {
+                if (ok) *ok = true;
+                return QVector4D(xCoord, yCoord, zCoord, wCoord);
+            }
+        }
+
+        if (ok) *ok = false;
+        return QVector4D();
+    }
+
+    bool create(int type, QQmlValueType *&v)
+    {
+        switch (type) {
+        case QMetaType::QColor:
+            v = new QQuickColorValueType;
+            return true;
+        case QMetaType::QVector2D:
+            v = new QQuickVector2DValueType;
+            return true;
+        case QMetaType::QVector3D:
+            v = new QQuickVector3DValueType;
+            return true;
+        case QMetaType::QVector4D:
+            v = new QQuickVector4DValueType;
+            return true;
+        case QMetaType::QQuaternion:
+            v = new QQuickQuaternionValueType;
+            return true;
+        case QMetaType::QMatrix4x4:
+            v = new QQuickMatrix4x4ValueType;
+            return true;
+        case QMetaType::QFont:
+            v = new QQuickFontValueType;
+            return true;
+        default:
+            return false;
+        }
+    }
+
+    bool init(int type, void *data, size_t n)
+    {
+        if (type == QMetaType::QColor) {
+            Q_ASSERT(n >= sizeof(QColor));
+            QColor *color = reinterpret_cast<QColor *>(data);
+            new (color) QColor();
+            return true;
+        }
+
+        return false;
+    }
+
+    bool destroy(int type, void *data, size_t n)
+    {
+        if (type == QMetaType::QColor) {
+            Q_ASSERT(n >= sizeof(QColor));
+            QColor *color = reinterpret_cast<QColor *>(data);
+            color->~QColor();
+            return true;
+        }
+
+        return false;
+    }
+
+    bool copy(int type, const void *src, void *dst, size_t n)
+    {
+        if (type == QMetaType::QColor) {
+            Q_ASSERT(n >= sizeof(QColor));
+            const QColor *srcColor = reinterpret_cast<const QColor *>(src);
+            QColor *dstColor = reinterpret_cast<QColor *>(dst);
+            new (dstColor) QColor(*srcColor);
+            return true;
+        }
+
+        return false;
+    }
+
+    bool create(int type, int argc, const void *argv[], QVariant *v)
+    {
+        switch (type) {
+        case QMetaType::QVector3D:
+            if (argc == 1) {
+                const float *xyz = reinterpret_cast<const float*>(argv[0]);
+                QVector3D v3(xyz[0], xyz[1], xyz[2]);
+                *v = QVariant(v3);
+                return true;
+            }
+            break;
+        case QMetaType::QVector4D:
+            if (argc == 1) {
+                const float *xyzw = reinterpret_cast<const float*>(argv[0]);
+                QVector4D v4(xyzw[0], xyzw[1], xyzw[2], xyzw[3]);
+                *v = QVariant(v4);
+                return true;
+            }
+            break;
+        }
+
+        return false;
+    }
+
+    bool createFromString(int type, const QString &s, void *data, size_t n)
+    {
+        bool ok = false;
+
+        switch (type) {
+        case QMetaType::QColor:
+            {
+            Q_ASSERT(n >= sizeof(QColor));
+            QColor *color = reinterpret_cast<QColor *>(data);
+            new (color) QColor(QQuickColorProvider::QColorFromString(s));
+            return true;
+            }
+        case QMetaType::QVector3D:
+            {
+            Q_ASSERT(n >= sizeof(QVector3D));
+            QVector3D *v3 = reinterpret_cast<QVector3D *>(data);
+            new (v3) QVector3D(vector3DFromString(s, &ok));
+            return true;
+            }
+        case QMetaType::QVector4D:
+            {
+            Q_ASSERT(n >= sizeof(QVector4D));
+            QVector4D *v4 = reinterpret_cast<QVector4D *>(data);
+            new (v4) QVector4D(vector4DFromString(s, &ok));
+            return true;
+            }
+        }
+
+        return false;
+    }
+
+    bool createStringFrom(int type, const void *data, QString *s)
+    {
+        if (type == QMetaType::QColor) {
+            const QColor *color = reinterpret_cast<const QColor *>(data);
+            new (s) QString(QVariant(*color).toString());
+            return true;
+        }
+
+        return false;
+    }
+
+    bool variantFromString(const QString &s, QVariant *v)
+    {
+        QColor c(QQuickColorProvider::QColorFromString(s));
+        if (c.isValid()) {
+            *v = QVariant::fromValue(c);
+            return true;
+        }
+
+        bool ok = false;
+
+        QVector3D v3 = vector3DFromString(s, &ok);
+        if (ok) {
+            *v = QVariant::fromValue(v3);
+            return true;
+        }
+
+        QVector4D v4 = vector4DFromString(s, &ok);
+        if (ok) {
+            *v = QVariant::fromValue(v4);
+            return true;
+        }
+
+        return false;
+    }
+
+    bool variantFromString(int type, const QString &s, QVariant *v)
+    {
+        bool ok = false;
+
+        switch (type) {
+        case QMetaType::QColor:
+            {
+            QColor c(QQuickColorProvider::QColorFromString(s));
+            *v = QVariant::fromValue(c);
+            return true;
+            }
+        case QMetaType::QVector3D:
+            *v = QVariant::fromValue(vector3DFromString(s, &ok));
+            return true;
+        case QMetaType::QVector4D:
+            *v = QVariant::fromValue(vector4DFromString(s, &ok));
+            return true;
+        }
+
+        return false;
+    }
+
+    bool store(int type, const void *src, void *dst, size_t n)
+    {
+        switch (type) {
+        case QMetaType::QColor:
+            {
+            Q_ASSERT(n >= sizeof(QColor));
+            const QRgb *rgb = reinterpret_cast<const QRgb *>(src);
+            QColor *color = reinterpret_cast<QColor *>(dst);
+            new (color) QColor(QColor::fromRgba(*rgb));
+            return true;
+            }
+        case QMetaType::QVector3D:
+            {
+            Q_ASSERT(n >= sizeof(QVector3D));
+            const QVector3D *srcVector = reinterpret_cast<const QVector3D *>(src);
+            QVector3D *dstVector = reinterpret_cast<QVector3D *>(dst);
+            new (dstVector) QVector3D(*srcVector);
+            return true;
+            }
+        case QMetaType::QVector4D:
+            {
+            Q_ASSERT(n >= sizeof(QVector4D));
+            const QVector4D *srcVector = reinterpret_cast<const QVector4D *>(src);
+            QVector4D *dstVector = reinterpret_cast<QVector4D *>(dst);
+            new (dstVector) QVector4D(*srcVector);
+            return true;
+            }
+        }
+
+        return false;
+    }
+
+    bool read(int srcType, const void *src, int dstType, void *dst)
+    {
+        if (dstType == QMetaType::QColor) {
+            QColor *dstColor = reinterpret_cast<QColor *>(dst);
+            if (srcType == QMetaType::QColor) {
+                const QColor *srcColor = reinterpret_cast<const QColor *>(src);
+                *dstColor = *srcColor;
+            } else {
+                *dstColor = QColor();
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    bool write(int type, const void *src, void *dst, size_t n)
+    {
+        if (type == QMetaType::QColor) {
+            Q_ASSERT(n >= sizeof(QColor));
+            const QColor *srcColor = reinterpret_cast<const QColor *>(src);
+            QColor *dstColor = reinterpret_cast<QColor *>(dst);
+            if (*dstColor != *srcColor) {
+                *dstColor = *srcColor;
+                return true;
+            }
+        }
+
+        return false;
+    }
+};
+
+
+class QQuickGuiProvider : public QQmlGuiProvider
+{
+public:
+    QQuickApplication *application(QObject *parent)
+    {
+        return new QQuickApplication(parent);
+    }
+
+    QInputMethod *inputMethod()
+    {
+        return qGuiApp->inputMethod();
+    }
+
+    QStringList fontFamilies()
+    {
+        QFontDatabase database;
+        return database.families();
+    }
+
+    bool openUrlExternally(QUrl &url)
+    {
+#ifndef QT_NO_DESKTOPSERVICES
+        return QDesktopServices::openUrl(url);
+#else
+        return false;
+#endif
+    }
+};
+
+
+static QQuickValueTypeProvider *getValueTypeProvider()
+{
+    static QQuickValueTypeProvider valueTypeProvider;
+    return &valueTypeProvider;
+}
+
+static QQuickColorProvider *getColorProvider()
+{
+    static QQuickColorProvider colorProvider;
+    return &colorProvider;
+}
+
+static QQuickGuiProvider *getGuiProvider()
+{
+    static QQuickGuiProvider guiProvider;
+    return &guiProvider;
+}
+
+static bool initializeProviders()
+{
+    QQml_addValueTypeProvider(getValueTypeProvider());
+    QQml_setColorProvider(getColorProvider());
+    QQml_setGuiProvider(getGuiProvider());
+    return true;
+}
+
+static bool initialized = initializeProviders();
+
+QT_END_NAMESPACE
diff --git a/src/quick/util/qquickvaluetypes.cpp b/src/quick/util/qquickvaluetypes.cpp
new file mode 100644
index 0000000..179f840
--- /dev/null
+++ b/src/quick/util/qquickvaluetypes.cpp
@@ -0,0 +1,468 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <private/qquickvaluetypes_p.h>
+
+#include <qtquickglobal.h>
+#include <private/qqmlvaluetype_p.h>
+#include <private/qfont_p.h>
+
+
+QT_BEGIN_NAMESPACE
+
+namespace QQuickValueTypes {
+
+void registerValueTypes()
+{
+    QQmlValueTypeFactory::registerValueTypes();
+
+    qmlRegisterValueTypeEnums<QQuickFontValueType>("QtQuick", 2, 0, "Font");
+}
+
+}
+
+QQuickColorValueType::QQuickColorValueType(QObject *parent)
+    : QQmlValueTypeBase<QColor>(parent)
+{
+}
+
+QString QQuickColorValueType::toString() const
+{
+    // to maintain behaviour with QtQuick 1.0, we just output normal toString() value.
+    return QVariant(v).toString();
+}
+
+qreal QQuickColorValueType::r() const
+{
+    return v.redF();
+}
+
+qreal QQuickColorValueType::g() const
+{
+    return v.greenF();
+}
+
+qreal QQuickColorValueType::b() const
+{
+    return v.blueF();
+}
+
+qreal QQuickColorValueType::a() const
+{
+    return v.alphaF();
+}
+
+void QQuickColorValueType::setR(qreal r)
+{
+    v.setRedF(r);
+}
+
+void QQuickColorValueType::setG(qreal g)
+{
+    v.setGreenF(g);
+}
+
+void QQuickColorValueType::setB(qreal b)
+{
+    v.setBlueF(b);
+}
+
+void QQuickColorValueType::setA(qreal a)
+{
+    v.setAlphaF(a);
+}
+
+
+QQuickVector2DValueType::QQuickVector2DValueType(QObject *parent)
+    : QQmlValueTypeBase<QVector2D>(parent)
+{
+}
+
+QString QQuickVector2DValueType::toString() const
+{
+    return QString(QLatin1String("QVector2D(%1, %2)")).arg(v.x()).arg(v.y());
+}
+
+qreal QQuickVector2DValueType::x() const
+{
+    return v.x();
+}
+
+qreal QQuickVector2DValueType::y() const
+{
+    return v.y();
+}
+
+void QQuickVector2DValueType::setX(qreal x)
+{
+    v.setX(x);
+}
+
+void QQuickVector2DValueType::setY(qreal y)
+{
+    v.setY(y);
+}
+
+
+QQuickVector3DValueType::QQuickVector3DValueType(QObject *parent)
+    : QQmlValueTypeBase<QVector3D>(parent)
+{
+}
+
+QString QQuickVector3DValueType::toString() const
+{
+    return QString(QLatin1String("QVector3D(%1, %2, %3)")).arg(v.x()).arg(v.y()).arg(v.z());
+}
+
+qreal QQuickVector3DValueType::x() const
+{
+    return v.x();
+}
+
+qreal QQuickVector3DValueType::y() const
+{
+    return v.y();
+}
+
+qreal QQuickVector3DValueType::z() const
+{
+    return v.z();
+}
+
+void QQuickVector3DValueType::setX(qreal x)
+{
+    v.setX(x);
+}
+
+void QQuickVector3DValueType::setY(qreal y)
+{
+    v.setY(y);
+}
+
+void QQuickVector3DValueType::setZ(qreal z)
+{
+    v.setZ(z);
+}
+
+
+QQuickVector4DValueType::QQuickVector4DValueType(QObject *parent)
+    : QQmlValueTypeBase<QVector4D>(parent)
+{
+}
+
+QString QQuickVector4DValueType::toString() const
+{
+    return QString(QLatin1String("QVector4D(%1, %2, %3, %4)")).arg(v.x()).arg(v.y()).arg(v.z()).arg(v.w());
+}
+
+qreal QQuickVector4DValueType::x() const
+{
+    return v.x();
+}
+
+qreal QQuickVector4DValueType::y() const
+{
+    return v.y();
+}
+
+qreal QQuickVector4DValueType::z() const
+{
+    return v.z();
+}
+
+qreal QQuickVector4DValueType::w() const
+{
+    return v.w();
+}
+
+void QQuickVector4DValueType::setX(qreal x)
+{
+    v.setX(x);
+}
+
+void QQuickVector4DValueType::setY(qreal y)
+{
+    v.setY(y);
+}
+
+void QQuickVector4DValueType::setZ(qreal z)
+{
+    v.setZ(z);
+}
+
+void QQuickVector4DValueType::setW(qreal w)
+{
+    v.setW(w);
+}
+
+
+QQuickQuaternionValueType::QQuickQuaternionValueType(QObject *parent)
+    : QQmlValueTypeBase<QQuaternion>(parent)
+{
+}
+
+QString QQuickQuaternionValueType::toString() const
+{
+    return QString(QLatin1String("QQuaternion(%1, %2, %3, %4)")).arg(v.scalar()).arg(v.x()).arg(v.y()).arg(v.z());
+}
+
+qreal QQuickQuaternionValueType::scalar() const
+{
+    return v.scalar();
+}
+
+qreal QQuickQuaternionValueType::x() const
+{
+    return v.x();
+}
+
+qreal QQuickQuaternionValueType::y() const
+{
+    return v.y();
+}
+
+qreal QQuickQuaternionValueType::z() const
+{
+    return v.z();
+}
+
+void QQuickQuaternionValueType::setScalar(qreal scalar)
+{
+    v.setScalar(scalar);
+}
+
+void QQuickQuaternionValueType::setX(qreal x)
+{
+    v.setX(x);
+}
+
+void QQuickQuaternionValueType::setY(qreal y)
+{
+    v.setY(y);
+}
+
+void QQuickQuaternionValueType::setZ(qreal z)
+{
+    v.setZ(z);
+}
+
+
+QQuickMatrix4x4ValueType::QQuickMatrix4x4ValueType(QObject *parent)
+    : QQmlValueTypeBase<QMatrix4x4>(parent)
+{
+}
+
+QString QQuickMatrix4x4ValueType::toString() const
+{
+    return QString(QLatin1String("QMatrix4x4(%1, %2, %3, %4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15, %16)"))
+            .arg(v(0, 0)).arg(v(0, 1)).arg(v(0, 2)).arg(v(0, 3))
+            .arg(v(1, 0)).arg(v(1, 1)).arg(v(1, 2)).arg(v(1, 3))
+            .arg(v(2, 0)).arg(v(2, 1)).arg(v(2, 2)).arg(v(2, 3))
+            .arg(v(3, 0)).arg(v(3, 1)).arg(v(3, 2)).arg(v(3, 3));
+}
+
+
+QQuickFontValueType::QQuickFontValueType(QObject *parent)
+    : QQmlValueTypeBase<QFont>(parent),
+      pixelSizeSet(false),
+      pointSizeSet(false)
+{
+}
+
+void QQuickFontValueType::onLoad()
+{
+    pixelSizeSet = false;
+    pointSizeSet = false;
+}
+
+QString QQuickFontValueType::toString() const
+{
+    return QString(QLatin1String("QFont(%1)")).arg(v.toString());
+}
+
+QString QQuickFontValueType::family() const
+{
+    return v.family();
+}
+
+void QQuickFontValueType::setFamily(const QString &family)
+{
+    v.setFamily(family);
+}
+
+bool QQuickFontValueType::bold() const
+{
+    return v.bold();
+}
+
+void QQuickFontValueType::setBold(bool b)
+{
+    v.setBold(b);
+}
+
+QQuickFontValueType::FontWeight QQuickFontValueType::weight() const
+{
+    return (QQuickFontValueType::FontWeight)v.weight();
+}
+
+void QQuickFontValueType::setWeight(QQuickFontValueType::FontWeight w)
+{
+    v.setWeight((QFont::Weight)w);
+}
+
+bool QQuickFontValueType::italic() const
+{
+    return v.italic();
+}
+
+void QQuickFontValueType::setItalic(bool b)
+{
+    v.setItalic(b);
+}
+
+bool QQuickFontValueType::underline() const
+{
+    return v.underline();
+}
+
+void QQuickFontValueType::setUnderline(bool b)
+{
+    v.setUnderline(b);
+}
+
+bool QQuickFontValueType::overline() const
+{
+    return v.overline();
+}
+
+void QQuickFontValueType::setOverline(bool b)
+{
+    v.setOverline(b);
+}
+
+bool QQuickFontValueType::strikeout() const
+{
+    return v.strikeOut();
+}
+
+void QQuickFontValueType::setStrikeout(bool b)
+{
+    v.setStrikeOut(b);
+}
+
+qreal QQuickFontValueType::pointSize() const
+{
+    if (v.pointSizeF() == -1) {
+        if (dpi.isNull)
+            dpi = qt_defaultDpi();
+        return v.pixelSize() * qreal(72.) / qreal(dpi);
+    }
+    return v.pointSizeF();
+}
+
+void QQuickFontValueType::setPointSize(qreal size)
+{
+    if (pixelSizeSet) {
+        qWarning() << "Both point size and pixel size set. Using pixel size.";
+        return;
+    }
+
+    if (size >= 0.0) {
+        pointSizeSet = true;
+        v.setPointSizeF(size);
+    } else {
+        pointSizeSet = false;
+    }
+}
+
+int QQuickFontValueType::pixelSize() const
+{
+    if (v.pixelSize() == -1) {
+        if (dpi.isNull)
+            dpi = qt_defaultDpi();
+        return (v.pointSizeF() * dpi) / qreal(72.);
+    }
+    return v.pixelSize();
+}
+
+void QQuickFontValueType::setPixelSize(int size)
+{
+    if (size >0) {
+        if (pointSizeSet)
+            qWarning() << "Both point size and pixel size set. Using pixel size.";
+        v.setPixelSize(size);
+        pixelSizeSet = true;
+    } else {
+        pixelSizeSet = false;
+    }
+}
+
+QQuickFontValueType::Capitalization QQuickFontValueType::capitalization() const
+{
+    return (QQuickFontValueType::Capitalization)v.capitalization();
+}
+
+void QQuickFontValueType::setCapitalization(QQuickFontValueType::Capitalization c)
+{
+    v.setCapitalization((QFont::Capitalization)c);
+}
+
+qreal QQuickFontValueType::letterSpacing() const
+{
+    return v.letterSpacing();
+}
+
+void QQuickFontValueType::setLetterSpacing(qreal size)
+{
+    v.setLetterSpacing(QFont::AbsoluteSpacing, size);
+}
+
+qreal QQuickFontValueType::wordSpacing() const
+{
+    return v.wordSpacing();
+}
+
+void QQuickFontValueType::setWordSpacing(qreal size)
+{
+    v.setWordSpacing(size);
+}
+
+QT_END_NAMESPACE
diff --git a/src/quick/util/qquickvaluetypes_p.h b/src/quick/util/qquickvaluetypes_p.h
new file mode 100644
index 0000000..d2767db
--- /dev/null
+++ b/src/quick/util/qquickvaluetypes_p.h
@@ -0,0 +1,310 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQUICKVALUETYPES_P_H
+#define QQUICKVALUETYPES_P_H
+
+#include <qqml.h>
+#include <qtquickglobal.h>
+#include <private/qqmlvaluetype_p.h>
+
+#include <QtGui/QColor>
+#include <QtGui/QVector2D>
+#include <QtGui/QVector3D>
+#include <QtGui/QVector4D>
+#include <QtGui/QQuaternion>
+#include <QtGui/QMatrix4x4>
+#include <QtGui/QFont>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+namespace QQuickValueTypes {
+
+void registerValueTypes();
+
+}
+
+class Q_AUTOTEST_EXPORT QQuickColorValueType : public QQmlValueTypeBase<QColor>
+{
+    Q_PROPERTY(qreal r READ r WRITE setR)
+    Q_PROPERTY(qreal g READ g WRITE setG)
+    Q_PROPERTY(qreal b READ b WRITE setB)
+    Q_PROPERTY(qreal a READ a WRITE setA)
+    Q_OBJECT
+public:
+    QQuickColorValueType(QObject *parent = 0);
+
+    virtual QString toString() const;
+
+    qreal r() const;
+    qreal g() const;
+    qreal b() const;
+    qreal a() const;
+    void setR(qreal);
+    void setG(qreal);
+    void setB(qreal);
+    void setA(qreal);
+};
+
+class Q_AUTOTEST_EXPORT QQuickVector2DValueType : public QQmlValueTypeBase<QVector2D>
+{
+    Q_PROPERTY(qreal x READ x WRITE setX)
+    Q_PROPERTY(qreal y READ y WRITE setY)
+    Q_OBJECT
+public:
+    QQuickVector2DValueType(QObject *parent = 0);
+
+    virtual QString toString() const;
+
+    qreal x() const;
+    qreal y() const;
+    void setX(qreal);
+    void setY(qreal);
+};
+
+class Q_AUTOTEST_EXPORT QQuickVector3DValueType : public QQmlValueTypeBase<QVector3D>
+{
+    Q_PROPERTY(qreal x READ x WRITE setX)
+    Q_PROPERTY(qreal y READ y WRITE setY)
+    Q_PROPERTY(qreal z READ z WRITE setZ)
+    Q_OBJECT
+public:
+    QQuickVector3DValueType(QObject *parent = 0);
+
+    virtual QString toString() const;
+
+    qreal x() const;
+    qreal y() const;
+    qreal z() const;
+    void setX(qreal);
+    void setY(qreal);
+    void setZ(qreal);
+};
+
+class Q_AUTOTEST_EXPORT QQuickVector4DValueType : public QQmlValueTypeBase<QVector4D>
+{
+    Q_PROPERTY(qreal x READ x WRITE setX)
+    Q_PROPERTY(qreal y READ y WRITE setY)
+    Q_PROPERTY(qreal z READ z WRITE setZ)
+    Q_PROPERTY(qreal w READ w WRITE setW)
+    Q_OBJECT
+public:
+    QQuickVector4DValueType(QObject *parent = 0);
+
+    virtual QString toString() const;
+
+    qreal x() const;
+    qreal y() const;
+    qreal z() const;
+    qreal w() const;
+    void setX(qreal);
+    void setY(qreal);
+    void setZ(qreal);
+    void setW(qreal);
+};
+
+class Q_AUTOTEST_EXPORT QQuickQuaternionValueType : public QQmlValueTypeBase<QQuaternion>
+{
+    Q_PROPERTY(qreal scalar READ scalar WRITE setScalar)
+    Q_PROPERTY(qreal x READ x WRITE setX)
+    Q_PROPERTY(qreal y READ y WRITE setY)
+    Q_PROPERTY(qreal z READ z WRITE setZ)
+    Q_OBJECT
+public:
+    QQuickQuaternionValueType(QObject *parent = 0);
+
+    virtual QString toString() const;
+
+    qreal scalar() const;
+    qreal x() const;
+    qreal y() const;
+    qreal z() const;
+    void setScalar(qreal);
+    void setX(qreal);
+    void setY(qreal);
+    void setZ(qreal);
+};
+
+class Q_AUTOTEST_EXPORT QQuickMatrix4x4ValueType : public QQmlValueTypeBase<QMatrix4x4>
+{
+    Q_PROPERTY(qreal m11 READ m11 WRITE setM11)
+    Q_PROPERTY(qreal m12 READ m12 WRITE setM12)
+    Q_PROPERTY(qreal m13 READ m13 WRITE setM13)
+    Q_PROPERTY(qreal m14 READ m14 WRITE setM14)
+    Q_PROPERTY(qreal m21 READ m21 WRITE setM21)
+    Q_PROPERTY(qreal m22 READ m22 WRITE setM22)
+    Q_PROPERTY(qreal m23 READ m23 WRITE setM23)
+    Q_PROPERTY(qreal m24 READ m24 WRITE setM24)
+    Q_PROPERTY(qreal m31 READ m31 WRITE setM31)
+    Q_PROPERTY(qreal m32 READ m32 WRITE setM32)
+    Q_PROPERTY(qreal m33 READ m33 WRITE setM33)
+    Q_PROPERTY(qreal m34 READ m34 WRITE setM34)
+    Q_PROPERTY(qreal m41 READ m41 WRITE setM41)
+    Q_PROPERTY(qreal m42 READ m42 WRITE setM42)
+    Q_PROPERTY(qreal m43 READ m43 WRITE setM43)
+    Q_PROPERTY(qreal m44 READ m44 WRITE setM44)
+    Q_OBJECT
+public:
+    QQuickMatrix4x4ValueType(QObject *parent = 0);
+
+    virtual QString toString() const;
+
+    qreal m11() const { return v(0, 0); }
+    qreal m12() const { return v(0, 1); }
+    qreal m13() const { return v(0, 2); }
+    qreal m14() const { return v(0, 3); }
+    qreal m21() const { return v(1, 0); }
+    qreal m22() const { return v(1, 1); }
+    qreal m23() const { return v(1, 2); }
+    qreal m24() const { return v(1, 3); }
+    qreal m31() const { return v(2, 0); }
+    qreal m32() const { return v(2, 1); }
+    qreal m33() const { return v(2, 2); }
+    qreal m34() const { return v(2, 3); }
+    qreal m41() const { return v(3, 0); }
+    qreal m42() const { return v(3, 1); }
+    qreal m43() const { return v(3, 2); }
+    qreal m44() const { return v(3, 3); }
+
+    void setM11(qreal value) { v(0, 0) = value; }
+    void setM12(qreal value) { v(0, 1) = value; }
+    void setM13(qreal value) { v(0, 2) = value; }
+    void setM14(qreal value) { v(0, 3) = value; }
+    void setM21(qreal value) { v(1, 0) = value; }
+    void setM22(qreal value) { v(1, 1) = value; }
+    void setM23(qreal value) { v(1, 2) = value; }
+    void setM24(qreal value) { v(1, 3) = value; }
+    void setM31(qreal value) { v(2, 0) = value; }
+    void setM32(qreal value) { v(2, 1) = value; }
+    void setM33(qreal value) { v(2, 2) = value; }
+    void setM34(qreal value) { v(2, 3) = value; }
+    void setM41(qreal value) { v(3, 0) = value; }
+    void setM42(qreal value) { v(3, 1) = value; }
+    void setM43(qreal value) { v(3, 2) = value; }
+    void setM44(qreal value) { v(3, 3) = value; }
+};
+
+class Q_AUTOTEST_EXPORT QQuickFontValueType : public QQmlValueTypeBase<QFont>
+{
+    Q_OBJECT
+    Q_ENUMS(FontWeight)
+    Q_ENUMS(Capitalization)
+
+    Q_PROPERTY(QString family READ family WRITE setFamily)
+    Q_PROPERTY(bool bold READ bold WRITE setBold)
+    Q_PROPERTY(FontWeight weight READ weight WRITE setWeight)
+    Q_PROPERTY(bool italic READ italic WRITE setItalic)
+    Q_PROPERTY(bool underline READ underline WRITE setUnderline)
+    Q_PROPERTY(bool overline READ overline WRITE setOverline)
+    Q_PROPERTY(bool strikeout READ strikeout WRITE setStrikeout)
+    Q_PROPERTY(qreal pointSize READ pointSize WRITE setPointSize)
+    Q_PROPERTY(int pixelSize READ pixelSize WRITE setPixelSize)
+    Q_PROPERTY(Capitalization capitalization READ capitalization WRITE setCapitalization)
+    Q_PROPERTY(qreal letterSpacing READ letterSpacing WRITE setLetterSpacing)
+    Q_PROPERTY(qreal wordSpacing READ wordSpacing WRITE setWordSpacing)
+
+public:
+    enum FontWeight { Light = QFont::Light,
+                       Normal = QFont::Normal,
+                       DemiBold = QFont::DemiBold,
+                       Bold = QFont::Bold,
+                       Black = QFont::Black };
+    enum Capitalization { MixedCase = QFont::MixedCase,
+                           AllUppercase = QFont::AllUppercase,
+                           AllLowercase = QFont::AllLowercase,
+                           SmallCaps = QFont::SmallCaps,
+                           Capitalize = QFont::Capitalize };
+
+    QQuickFontValueType(QObject *parent = 0);
+
+    virtual QString toString() const;
+
+    QString family() const;
+    void setFamily(const QString &);
+
+    bool bold() const;
+    void setBold(bool b);
+
+    FontWeight weight() const;
+    void setWeight(FontWeight);
+
+    bool italic() const;
+    void setItalic(bool b);
+
+    bool underline() const;
+    void setUnderline(bool b);
+
+    bool overline() const;
+    void setOverline(bool b);
+
+    bool strikeout() const;
+    void setStrikeout(bool b);
+
+    qreal pointSize() const;
+    void setPointSize(qreal size);
+
+    int pixelSize() const;
+    void setPixelSize(int size);
+
+    Capitalization capitalization() const;
+    void setCapitalization(Capitalization);
+
+    qreal letterSpacing() const;
+    void setLetterSpacing(qreal spacing);
+
+    qreal wordSpacing() const;
+    void setWordSpacing(qreal spacing);
+
+    void onLoad();
+
+private:
+    bool pixelSizeSet;
+    bool pointSizeSet;
+    mutable QQmlNullableValue<int> dpi;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QQUICKVALUETYPES_P_H
diff --git a/src/quick/util/util.pri b/src/quick/util/util.pri
index d720ef0..3d93b9f 100644
--- a/src/quick/util/util.pri
+++ b/src/quick/util/util.pri
@@ -1,4 +1,5 @@
 SOURCES += \
+    $$PWD/qquickapplication.cpp\
     $$PWD/qquickutilmodule.cpp\
     $$PWD/qquickconnections.cpp \
     $$PWD/qquickpackage.cpp \
@@ -26,9 +27,12 @@ SOURCES += \
     $$PWD/qquicklistcompositor.cpp \
     $$PWD/qquickpathinterpolator.cpp \
     $$PWD/qquickimageprovider.cpp \
-    $$PWD/qquicksvgparser.cpp
+    $$PWD/qquicksvgparser.cpp \
+    $$PWD/qquickvaluetypes.cpp \
+    $$PWD/qquickglobal.cpp
 
 HEADERS += \
+    $$PWD/qquickapplication_p.h\
     $$PWD/qquickutilmodule_p.h\
     $$PWD/qquickconnections_p.h \
     $$PWD/qquickpackage_p.h \
@@ -60,4 +64,5 @@ HEADERS += \
     $$PWD/qquicklistcompositor_p.h \
     $$PWD/qquickpathinterpolator_p.h \
     $$PWD/qquickimageprovider.h \
-    $$PWD/qquicksvgparser_p.h
+    $$PWD/qquicksvgparser_p.h \
+    $$PWD/qquickvaluetypes_p.h
diff --git a/tests/auto/qml/qml.pro b/tests/auto/qml/qml.pro
index 4d1644f..0657ea8 100644
--- a/tests/auto/qml/qml.pro
+++ b/tests/auto/qml/qml.pro
@@ -32,6 +32,7 @@ PRIVATETESTS += \
     qqmlecmascript \
     qqmlcontext \
     qqmlexpression \
+    qqmlglobal \
     qqmlinstruction \
     qqmllanguage \
     qqmlproperty \
diff --git a/tests/auto/qml/qqmlecmascript/testtypes.h b/tests/auto/qml/qqmlecmascript/testtypes.h
index 54fab26..ab8f85b 100644
--- a/tests/auto/qml/qqmlecmascript/testtypes.h
+++ b/tests/auto/qml/qqmlecmascript/testtypes.h
@@ -51,6 +51,7 @@
 #include <QtGui/qmatrix.h>
 #include <QtGui/qcolor.h>
 #include <QtGui/qvector3d.h>
+#include <QtGui/QFont>
 #include <QtGui/QPixmap>
 #include <QtCore/qdatetime.h>
 #include <QtQml/qjsvalue.h>
diff --git a/tests/auto/qml/qqmlglobal/qqmlglobal.pro b/tests/auto/qml/qqmlglobal/qqmlglobal.pro
new file mode 100644
index 0000000..b39c045
--- /dev/null
+++ b/tests/auto/qml/qqmlglobal/qqmlglobal.pro
@@ -0,0 +1,7 @@
+CONFIG += testcase
+TARGET = tst_qqmlglobal
+SOURCES += tst_qqmlglobal.cpp
+macx:CONFIG -= app_bundle
+
+CONFIG += parallel_test
+QT += qml-private testlib
diff --git a/tests/auto/qml/qqmlglobal/tst_qqmlglobal.cpp b/tests/auto/qml/qqmlglobal/tst_qqmlglobal.cpp
new file mode 100644
index 0000000..e2cdd50
--- /dev/null
+++ b/tests/auto/qml/qqmlglobal/tst_qqmlglobal.cpp
@@ -0,0 +1,88 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qtest.h>
+#include <qqml.h>
+
+#include <private/qqmlglobal_p.h>
+
+class tst_qqmlglobal : public QObject
+{
+    Q_OBJECT
+public:
+    tst_qqmlglobal() {}
+
+private slots:
+    void initTestCase();
+
+    void valueTypeProviderWarning();
+    void colorProviderWarning();
+    void guiProviderWarning();
+};
+
+void tst_qqmlglobal::initTestCase()
+{
+}
+
+void tst_qqmlglobal::valueTypeProviderWarning()
+{
+    const QLatin1String expected("Warning: QQml_valueTypeProvider: no value type provider has been set! ");
+    QTest::ignoreMessage(QtWarningMsg, expected.data());
+    QQml_valueTypeProvider();
+}
+
+void tst_qqmlglobal::colorProviderWarning()
+{
+    const QLatin1String expected("Warning: QQml_colorProvider: no color provider has been set! ");
+    QTest::ignoreMessage(QtWarningMsg, expected.data());
+    QQml_colorProvider();
+}
+
+void tst_qqmlglobal::guiProviderWarning()
+{
+    const QLatin1String expected("Warning: QQml_guiProvider: no GUI provider has been set! ");
+    QTest::ignoreMessage(QtWarningMsg, expected.data());
+    QQml_guiProvider();
+}
+
+QTEST_MAIN(tst_qqmlglobal)
+
+#include "tst_qqmlglobal.moc"
diff --git a/tests/auto/qml/qqmlinstruction/tst_qqmlinstruction.cpp b/tests/auto/qml/qqmlinstruction/tst_qqmlinstruction.cpp
index d076f03..d0e818f 100644
--- a/tests/auto/qml/qqmlinstruction/tst_qqmlinstruction.cpp
+++ b/tests/auto/qml/qqmlinstruction/tst_qqmlinstruction.cpp
@@ -42,6 +42,9 @@
 #include <qtest.h>
 #include <private/qqmlcompiler_p.h>
 
+#include <QVector3D>
+#include <QVector4D>
+
 class tst_qqmlinstruction : public QObject
 {
     Q_OBJECT
diff --git a/tests/auto/qml/qqmllanguage/data/wrongType.7.errors.txt b/tests/auto/qml/qqmllanguage/data/wrongType.7.errors.txt
index 614346b..8a168d2 100644
--- a/tests/auto/qml/qqmllanguage/data/wrongType.7.errors.txt
+++ b/tests/auto/qml/qqmllanguage/data/wrongType.7.errors.txt
@@ -1 +1 @@
-3:20:Invalid property assignment: color expected
+4:20:Invalid property assignment: color expected
diff --git a/tests/auto/qml/qqmllanguage/data/wrongType.7.qml b/tests/auto/qml/qqmllanguage/data/wrongType.7.qml
index ddc3835..e9dd710 100644
--- a/tests/auto/qml/qqmllanguage/data/wrongType.7.qml
+++ b/tests/auto/qml/qqmllanguage/data/wrongType.7.qml
@@ -1,4 +1,5 @@
 import Test 1.0
+import QtQuick 2.0
 MyTypeObject {
     colorProperty: 12
 }
diff --git a/tests/auto/qml/qqmlqt/qqmlqt.pro b/tests/auto/qml/qqmlqt/qqmlqt.pro
index 92fabf5..012f58a 100644
--- a/tests/auto/qml/qqmlqt/qqmlqt.pro
+++ b/tests/auto/qml/qqmlqt/qqmlqt.pro
@@ -10,4 +10,4 @@ TESTDATA = data/*
 
 CONFIG += parallel_test
 
-QT += core-private gui-private v8-private qml-private quick-private testlib
+QT += core-private v8-private qml-private quick-private testlib gui
diff --git a/tests/auto/qml/qqmlqt/tst_qqmlqt.cpp b/tests/auto/qml/qqmlqt/tst_qqmlqt.cpp
index d3dc3e7..a1d7291 100644
--- a/tests/auto/qml/qqmlqt/tst_qqmlqt.cpp
+++ b/tests/auto/qml/qqmlqt/tst_qqmlqt.cpp
@@ -52,6 +52,8 @@
 #include <QCryptographicHash>
 #include <QtQuick/QQuickItem>
 #include <QSignalSpy>
+#include <QVector3D>
+#include <QVector4D>
 #include "../../shared/util.h"
 
 class tst_qqmlqt : public QQmlDataTest
diff --git a/tests/auto/qml/qqmlvaluetypes/qqmlvaluetypes.pro b/tests/auto/qml/qqmlvaluetypes/qqmlvaluetypes.pro
index 9155cbe..8d9acb6 100644
--- a/tests/auto/qml/qqmlvaluetypes/qqmlvaluetypes.pro
+++ b/tests/auto/qml/qqmlvaluetypes/qqmlvaluetypes.pro
@@ -13,4 +13,4 @@ TESTDATA = data/*
 
 CONFIG += parallel_test
 
-QT += core-private gui-private v8-private qml-private testlib
+QT += core-private gui-private v8-private qml-private quick-private gui testlib
diff --git a/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp b/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
index 54791fc..359653c 100644
--- a/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
+++ b/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
@@ -43,12 +43,12 @@
 #include <QQmlEngine>
 #include <QQmlComponent>
 #include <QDebug>
-#include <private/qqmlvaluetype_p.h>
+#include <private/qquickvaluetypes_p.h>
 #include "../../shared/util.h"
 #include "testtypes.h"
 
 QT_BEGIN_NAMESPACE
-extern int qt_defaultDpi();
+extern int qt_defaultDpi(void);
 QT_END_NAMESPACE
 
 class tst_qqmlvaluetypes : public QQmlDataTest
@@ -1129,13 +1129,13 @@ void tst_qqmlvaluetypes::cppClasses()
     CPP_TEST(QQmlSizeFValueType, QSizeF(-100.7, 18.2));
     CPP_TEST(QQmlRectValueType, QRect(13, 39, 10928, 88));
     CPP_TEST(QQmlRectFValueType, QRectF(88.2, -90.1, 103.2, 118));
-    CPP_TEST(QQmlVector2DValueType, QVector2D(19.7, 1002));
-    CPP_TEST(QQmlVector3DValueType, QVector3D(18.2, 19.7, 1002));
-    CPP_TEST(QQmlVector4DValueType, QVector4D(18.2, 19.7, 1002, 54));
-    CPP_TEST(QQmlQuaternionValueType, QQuaternion(18.2, 19.7, 1002, 54));
-    CPP_TEST(QQmlMatrix4x4ValueType,
+    CPP_TEST(QQuickVector2DValueType, QVector2D(19.7, 1002));
+    CPP_TEST(QQuickVector3DValueType, QVector3D(18.2, 19.7, 1002));
+    CPP_TEST(QQuickVector4DValueType, QVector4D(18.2, 19.7, 1002, 54));
+    CPP_TEST(QQuickQuaternionValueType, QQuaternion(18.2, 19.7, 1002, 54));
+    CPP_TEST(QQuickMatrix4x4ValueType,
              QMatrix4x4(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16));
-    CPP_TEST(QQmlFontValueType, QFont("Helvetica"));
+    CPP_TEST(QQuickFontValueType, QFont("Helvetica"));
 
 }
 
diff --git a/tests/auto/quick/qquickapplication/tst_qquickapplication.cpp b/tests/auto/quick/qquickapplication/tst_qquickapplication.cpp
index 61675d9..4dd7688 100644
--- a/tests/auto/quick/qquickapplication/tst_qquickapplication.cpp
+++ b/tests/auto/quick/qquickapplication/tst_qquickapplication.cpp
@@ -69,7 +69,15 @@ tst_qquickapplication::tst_qquickapplication()
 void tst_qquickapplication::active()
 {
     QQmlComponent component(&engine);
-    component.setData("import QtQuick 2.0; Item { property bool active: Qt.application.active }", QUrl::fromLocalFile(""));
+    component.setData("import QtQuick 2.0; "
+                      "Item { "
+                      "    property bool active: Qt.application.active; "
+                      "    property bool active2: false; "
+                      "    Connections { "
+                      "        target: Qt.application; "
+                      "        onActiveChanged: active2 = Qt.application.active; "
+                      "    } "
+                      "}", QUrl::fromLocalFile(""));
     QQuickItem *item = qobject_cast<QQuickItem *>(component.create());
     QVERIFY(item);
     QQuickView view;
@@ -77,6 +85,7 @@ void tst_qquickapplication::active()
 
     // not active
     QVERIFY(!item->property("active").toBool());
+    QVERIFY(!item->property("active2").toBool());
     QCOMPARE(item->property("active").toBool(), QGuiApplication::activeWindow() != 0);
 
     // active
@@ -86,6 +95,7 @@ void tst_qquickapplication::active()
     QEXPECT_FAIL("", "QTBUG-21573", Abort);
     QTRY_COMPARE(view.status(), QQuickView::Ready);
     QCOMPARE(item->property("active").toBool(), QGuiApplication::activeWindow() != 0);
+    QCOMPARE(item->property("active2").toBool(), QGuiApplication::activeWindow() != 0);
 
 #if 0
     // QGuiApplication has no equivalent of setActiveWindow(0). QTBUG-21573
@@ -128,6 +138,9 @@ void tst_qquickapplication::layoutDirection()
 
 void tst_qquickapplication::inputPanel()
 {
+    const QLatin1String expected("Qt.application.inputPanel is deprecated, use Qt.inputMethod instead ");
+    QTest::ignoreMessage(QtWarningMsg, expected.data());
+
     QQmlComponent component(&engine);
     component.setData("import QtQuick 2.0; Item { property variant inputPanel: Qt.application.inputPanel }", QUrl::fromLocalFile(""));
     QQuickItem *item = qobject_cast<QQuickItem *>(component.create());
diff --git a/tests/auto/quick/qquicktext/tst_qquicktext.cpp b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
index 92e8528..77f0ec1 100644
--- a/tests/auto/quick/qquicktext/tst_qquicktext.cpp
+++ b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
@@ -45,7 +45,7 @@
 #include <QtQml/qqmlcomponent.h>
 #include <QtQuick/private/qquicktext_p.h>
 #include <private/qquicktext_p_p.h>
-#include <private/qqmlvaluetype_p.h>
+#include <private/qquickvaluetypes_p.h>
 #include <QFontMetrics>
 #include <qmath.h>
 #include <QtQuick/QQuickView>
@@ -93,7 +93,7 @@ private slots:
     void color();
     void smooth();
 
-    // QQmlFontValueType
+    // QQuickFontValueType
     void weight();
     void underline();
     void overline();
@@ -1119,7 +1119,7 @@ void tst_qquicktext::weight()
         QQuickText *textObject = qobject_cast<QQuickText*>(textComponent.create());
 
         QVERIFY(textObject != 0);
-        QCOMPARE((int)textObject->font().weight(), (int)QQmlFontValueType::Normal);
+        QCOMPARE((int)textObject->font().weight(), (int)QQuickFontValueType::Normal);
 
         delete textObject;
     }
@@ -1130,7 +1130,7 @@ void tst_qquicktext::weight()
         QQuickText *textObject = qobject_cast<QQuickText*>(textComponent.create());
 
         QVERIFY(textObject != 0);
-        QCOMPARE((int)textObject->font().weight(), (int)QQmlFontValueType::Bold);
+        QCOMPARE((int)textObject->font().weight(), (int)QQuickFontValueType::Bold);
 
         delete textObject;
     }
@@ -1223,7 +1223,7 @@ void tst_qquicktext::capitalization()
         QQuickText *textObject = qobject_cast<QQuickText*>(textComponent.create());
 
         QVERIFY(textObject != 0);
-        QCOMPARE((int)textObject->font().capitalization(), (int)QQmlFontValueType::MixedCase);
+        QCOMPARE((int)textObject->font().capitalization(), (int)QQuickFontValueType::MixedCase);
 
         delete textObject;
     }
@@ -1234,7 +1234,7 @@ void tst_qquicktext::capitalization()
         QQuickText *textObject = qobject_cast<QQuickText*>(textComponent.create());
 
         QVERIFY(textObject != 0);
-        QCOMPARE((int)textObject->font().capitalization(), (int)QQmlFontValueType::AllUppercase);
+        QCOMPARE((int)textObject->font().capitalization(), (int)QQuickFontValueType::AllUppercase);
 
         delete textObject;
     }
@@ -1245,7 +1245,7 @@ void tst_qquicktext::capitalization()
         QQuickText *textObject = qobject_cast<QQuickText*>(textComponent.create());
 
         QVERIFY(textObject != 0);
-        QCOMPARE((int)textObject->font().capitalization(), (int)QQmlFontValueType::AllLowercase);
+        QCOMPARE((int)textObject->font().capitalization(), (int)QQuickFontValueType::AllLowercase);
 
         delete textObject;
     }
@@ -1256,7 +1256,7 @@ void tst_qquicktext::capitalization()
         QQuickText *textObject = qobject_cast<QQuickText*>(textComponent.create());
 
         QVERIFY(textObject != 0);
-        QCOMPARE((int)textObject->font().capitalization(), (int)QQmlFontValueType::SmallCaps);
+        QCOMPARE((int)textObject->font().capitalization(), (int)QQuickFontValueType::SmallCaps);
 
         delete textObject;
     }
@@ -1267,7 +1267,7 @@ void tst_qquicktext::capitalization()
         QQuickText *textObject = qobject_cast<QQuickText*>(textComponent.create());
 
         QVERIFY(textObject != 0);
-        QCOMPARE((int)textObject->font().capitalization(), (int)QQmlFontValueType::Capitalize);
+        QCOMPARE((int)textObject->font().capitalization(), (int)QQuickFontValueType::Capitalize);
 
         delete textObject;
     }