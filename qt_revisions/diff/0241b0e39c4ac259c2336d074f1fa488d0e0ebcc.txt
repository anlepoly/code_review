diff --git a/examples/multimedia/audiodevices/doc/src/audiodevices.qdoc b/examples/multimedia/audiodevices/doc/src/audiodevices.qdoc
index d2522f3..af51e37 100644
--- a/examples/multimedia/audiodevices/doc/src/audiodevices.qdoc
+++ b/examples/multimedia/audiodevices/doc/src/audiodevices.qdoc
@@ -26,9 +26,9 @@
 ****************************************************************************/
 
 /*!
-    \example audiodevices
+    \example multimedia/audiodevices
     \title Audio Devices Example
-    \ingroup audio_examples
+    \ingroup multimedia_examples
     \brief The Audio Devices example shows the application of the audio devices APIs
 
 
diff --git a/examples/multimedia/audioengine/doc/src/audioengine.qdoc b/examples/multimedia/audioengine/doc/src/audioengine.qdoc
index bea4d4b..ba2f17c 100644
--- a/examples/multimedia/audioengine/doc/src/audioengine.qdoc
+++ b/examples/multimedia/audioengine/doc/src/audioengine.qdoc
@@ -26,9 +26,9 @@
 ****************************************************************************/
 
 /*!
-    \example audioengine
+    \example multimedia/audioengine
     \title AudioEngine Example
-    \ingroup audioengine_examples
+    \ingroup multimedia_examples
     \brief The Audio Engine example demonstrates 3D sound control using
     the QtAudioEngine API.
 
diff --git a/examples/multimedia/audioinput/doc/src/audioinput.qdoc b/examples/multimedia/audioinput/doc/src/audioinput.qdoc
index 4fc7e6e..ccd4ed2 100644
--- a/examples/multimedia/audioinput/doc/src/audioinput.qdoc
+++ b/examples/multimedia/audioinput/doc/src/audioinput.qdoc
@@ -26,9 +26,9 @@
 ****************************************************************************/
 
 /*!
-    \example audioinput
+    \example multimedia/audioinput
     \title Audio Input Example
-    \ingroup audio_examples
+    \ingroup multimedia_examples
     \brief The Audio Input Example shows the use of the QAudioInput class.
     The example demonstrates the basic use cases of the QAudioInput class.
 
diff --git a/examples/multimedia/audiooutput/doc/src/audiooutput.qdoc b/examples/multimedia/audiooutput/doc/src/audiooutput.qdoc
index c29fcd8..91c735f 100644
--- a/examples/multimedia/audiooutput/doc/src/audiooutput.qdoc
+++ b/examples/multimedia/audiooutput/doc/src/audiooutput.qdoc
@@ -26,9 +26,9 @@
 ****************************************************************************/
 
 /*!
-    \example audiooutput
+    \example multimedia/audiooutput
     \title Audio Output Example
-    \ingroup audio_examples
+    \ingroup multimedia_examples
     \brief The Audio Output Example show the use of the QAudioOutput API.
 
     The example demonstrates the basic use cases of the QAudioOutput class.
diff --git a/examples/multimedia/audiorecorder/doc/src/audiorecorder.qdoc b/examples/multimedia/audiorecorder/doc/src/audiorecorder.qdoc
index 3dea92c..df3ce13 100644
--- a/examples/multimedia/audiorecorder/doc/src/audiorecorder.qdoc
+++ b/examples/multimedia/audiorecorder/doc/src/audiorecorder.qdoc
@@ -26,9 +26,9 @@
 ****************************************************************************/
 
 /*!
-    \example audiorecorder
+    \example multimedia/audiorecorder
     \title Audio Recorder Example
-    \ingroup audio_examples
+    \ingroup multimedia_examples
     \brief The Audio Recorder Example shows how to create a simple audio recorder.
 
     It demonstrates the discovery of the supported devices and codecs and the use
@@ -95,10 +95,6 @@
     \code
     ui->statusbar->showMessage(tr("Recorded %1 sec").arg(duration / 1000));
     \endcode
-
-
-
-
 */
 
 
diff --git a/examples/multimedia/declarative-radio/doc/src/declarative-radio.qdoc b/examples/multimedia/declarative-radio/doc/src/declarative-radio.qdoc
index 8b52e6c..bf3f39c 100644
--- a/examples/multimedia/declarative-radio/doc/src/declarative-radio.qdoc
+++ b/examples/multimedia/declarative-radio/doc/src/declarative-radio.qdoc
@@ -26,10 +26,13 @@
 ****************************************************************************/
 
 /*!
-    \example declarative-radio
+    \example multimedia/declarative-radio
     \title Declarative Radio Example
+    \brief Demonstrates the radio functionality
+    \ingroup multimedia_examples
 
-
+    This examples uses the Qt Multimedia Radio QML type to list the available
+    channels on the FM frequency.
 */
 
 
diff --git a/examples/multimedia/spectrum/doc/src/spectrum.qdoc b/examples/multimedia/spectrum/doc/src/spectrum.qdoc
index 64c6f83..5e91af4 100644
--- a/examples/multimedia/spectrum/doc/src/spectrum.qdoc
+++ b/examples/multimedia/spectrum/doc/src/spectrum.qdoc
@@ -26,12 +26,12 @@
 ****************************************************************************/
 
 /*!
-    \example spectrum
+    \example multimedia/spectrum
     \title Spectrum Example
-    \ingroup audio_examples
+    \ingroup multimedia_examples
     \brief The Spectrum Example uses a combination multimedia APIs to process microphone input.
 
-    The Spectrum Analyzer example shows how the \l{QtMultimedia Module} can be
+    The Spectrum Analyzer example shows how the \l{Qt Multimedia} module can be
     used to record and then play back an audio stream.
 
     \image spectrum-demo.png
diff --git a/examples/multimedia/video/doc/src/qmlvideo.qdoc b/examples/multimedia/video/doc/src/qmlvideo.qdoc
index c27ca1b..359d071 100644
--- a/examples/multimedia/video/doc/src/qmlvideo.qdoc
+++ b/examples/multimedia/video/doc/src/qmlvideo.qdoc
@@ -26,9 +26,9 @@
 ****************************************************************************/
 
 /*!
-\example video/qmlvideo
+\example multimedia/video/qmlvideo
 \title QML Video Example
-\ingroup video_examples_qml
+\ingroup multimedia_examples
 
 \brief The QML Video Example demonstrates the various manipulations (move;
 resize; rotate; change aspect ratio) which can be applied to QML \l{VideoOutput}
@@ -52,15 +52,15 @@ which moves across the \l{VideoOutput} item.
 
 \section1 Application structure
 
-The \l{video/qmlvideo/qml/qmlvideo/main.qml} file creates a UI which includes
+The \l{multimedia/video/qmlvideo/qml/qmlvideo/main.qml} file creates a UI which includes
 the following items:
 
 \list
-    \li Two \l{video/qmlvideo/qml/qmlvideo/Button.qml}{Button} instances, each
+    \li Two \l{multimedia/video/qmlvideo/qml/qmlvideo/Button.qml}{Button} instances, each
        of which displays a filename, and can be used to launch a
-       \l{video/qmlvideo/qml/qmlvideo/FileBrowser.qml}{FileBrowser}
-    \li An exit \l{video/qmlvideo/qml/qmlvideo/Button.qml}{Button}
-    \li A \l{video/qmlvideo/qml/qmlvideo/SceneSelectionPanel.qml}{SceneSelectionPanel},
+       \l{multimedia/video/qmlvideo/qml/qmlvideo/FileBrowser.qml}{FileBrowser}
+    \li An exit \l{multimedia/video/qmlvideo/qml/qmlvideo/Button.qml}{Button}
+    \li A \l{multimedia/video/qmlvideo/qml/qmlvideo/SceneSelectionPanel.qml}{SceneSelectionPanel},
        which is a flickable list displaying the available scenes
     \li At the lower left, an item which displays the QML repainting rate - the
        upper number is the instantaneous frame rate and the lower number is the
@@ -72,18 +72,18 @@ the following items:
 Each scene in the flickable list is implemented in its own QML file - for
 example the video-basic scene (which just displays a static \l{VideoOutput}
 in the center of the screen) is implemented in the
-\l{video/qmlvideo/qml/qmlvideo/VideoBasic.qml}{VideoBasic.qml} file.  As you
+\l{multimedia/ideo/qmlvideo/qml/qmlvideo/VideoBasic.qml}{VideoBasic.qml} file.  As you
 can see from the code, this makes use of a type of inheritance: a
-\l{video/qmlvideo/qml/qmlvideo/VideoBasic.qml}{VideoBasic} item ...
+\l{multimedia/video/qmlvideo/qml/qmlvideo/VideoBasic.qml}{VideoBasic} item ...
 
-\quotefromfile video/qmlvideo/qml/qmlvideo/VideoBasic.qml
+\quotefromfile multimedia/video/qmlvideo/qml/qmlvideo/VideoBasic.qml
 \skipto import
 \printuntil /^\}/
 
 ... is-a
-\l{video/qmlvideo/qml/qmlvideo/SceneBasic.qml}{SceneBasic} ...
+\l{multimedia/video/qmlvideo/qml/qmlvideo/SceneBasic.qml}{SceneBasic} ...
 
-\quotefromfile video/qmlvideo/qml/qmlvideo/SceneBasic.qml
+\quotefromfile multimedia/video/qmlvideo/qml/qmlvideo/SceneBasic.qml
 \skipto import
 \printuntil contentType
 \dots
@@ -94,9 +94,9 @@ can see from the code, this makes use of a type of inheritance: a
 \printuntil /^\}/
 
 ... which is-a
-\l{video/qmlvideo/qml/qmlvideo/Scene.qml}{Scene}:
+\l{multimedia/video/qmlvideo/qml/qmlvideo/Scene.qml}{Scene}:
 
-\quotefromfile video/qmlvideo/qml/qmlvideo/Scene.qml
+\quotefromfile multimedia/video/qmlvideo/qml/qmlvideo/Scene.qml
 \skipto import
 \printuntil root
 \dots
@@ -106,35 +106,35 @@ can see from the code, this makes use of a type of inheritance: a
 \skipto Button
 \printuntil /^\}/
 
-\l{video/qmlvideo/qml/qmlvideo/SceneBasic.qml}{SceneBasic} describes the
+\l{multimedia/video/qmlvideo/qml/qmlvideo/SceneBasic.qml}{SceneBasic} describes the
 structure and behaviour of the scene, but is agnostic of the type of content
 which will be displayed - this is abstracted by
-\l{video/qmlvideo/qml/qmlvideo/Content.qml}{Content}.
+\l{multimedia/video/qmlvideo/qml/qmlvideo/Content.qml}{Content}.
 
 This pattern allows us to define a particular use case (in this case, simply
 display a static piece of content), and then instantiate that use case for
 both video content
-(\l{video/qmlvideo/qml/qmlvideo/VideoBasic.qml}{VideoBasic}) and cameracontent
-(\l{video/qmlvideo/qml/qmlvideo/CameraBasic.qml}{CameraBasic}).  This approach
+(\l{multimedia/video/qmlvideo/qml/qmlvideo/VideoBasic.qml}{VideoBasic}) and cameracontent
+(\l{multimedia/video/qmlvideo/qml/qmlvideo/CameraBasic.qml}{CameraBasic}).  This approach
 is used to implement many of the other scenes - for example, "repeatedly slide
 the content from left to right and back again" is implemented by
-\l{video/qmlvideo/qml/qmlvideo/SceneMove.qml}{SceneMove}, on which
-\l{video/qmlvideo/qml/qmlvideo/VideoMove.qml}{VideoMove} and
-\l{video/qmlvideo/qml/qmlvideo/CameraMove.qml}{CameraMove} are based.
+\l{multimedia/video/qmlvideo/qml/qmlvideo/SceneMove.qml}{SceneMove}, on which
+\l{multimedia/video/qmlvideo/qml/qmlvideo/VideoMove.qml}{VideoMove} and
+\l{multimedia/video/qmlvideo/qml/qmlvideo/CameraMove.qml}{CameraMove} are based.
 
 Depending on the value of the contentType property in the top-level scene
 instance, the embedded
-\l{video/qmlvideo/qml/qmlvideo/Content.qml}{Content} item creates either a
+\l{multimedia/video/qmlvideo/qml/qmlvideo/Content.qml}{Content} item creates either a
 \l{MediaPlayer} or a \l{Camera} item.
 
 \section1 Calculating and displaying QML painting rate
 
-\input examples/video-qml-paint-rate.qdocinc
+\input video-qml-paint-rate.qdocinc
 
 All that remains is to connect the afterRendering() signal of the QQuickView
 object to a JavaScript function, which will eventually call frequencyItem.notify():
 
-\quotefromfile video/qmlvideo/main.cpp
+\quotefromfile multimedia/video/qmlvideo/main.cpp
 \skipto QmlApplicationViewer
 \printuntil ;
 \dots
diff --git a/examples/multimedia/video/doc/src/qmlvideofx.qdoc b/examples/multimedia/video/doc/src/qmlvideofx.qdoc
index f9b3240..b6535a9 100644
--- a/examples/multimedia/video/doc/src/qmlvideofx.qdoc
+++ b/examples/multimedia/video/doc/src/qmlvideofx.qdoc
@@ -26,10 +26,9 @@
 ****************************************************************************/
 
 /*!
-\example video/qmlvideofx
+\example multimedia/video/qmlvideofx
 \title QML Video Shader Effects Example
-\ingroup video_examples_qml
-\ingroup camera_examples_qml
+\ingroup multimedia_examples
 
 \brief The QML Video Shader Effects Example shows how \l {ShaderEffect}
 can be used to apply postprocessing effects, expressed in \c GLSL, to video
@@ -135,10 +134,10 @@ types is a bit more complicated, for the following reasons:
 \endlist
 
 The abstraction of source item type is achieved by the
-\l{video/qmlvideofx/qml/qmlvideofx/Content.qml}{Content}, which uses a
+\l{multimedia/video/qmlvideofx/qml/qmlvideofx/Content.qml}{Content}, which uses a
 \l{Loader} to create either a \l{MediaPlayer}, \l{Camera} or \l{Image}:
 
-\quotefromfile video/qmlvideofx/qml/qmlvideofx/Content.qml
+\quotefromfile multimedia/video/qmlvideofx/qml/qmlvideofx/Content.qml
 \skipto import
 \printuntil {
 \dots
@@ -165,10 +164,10 @@ The abstraction of source item type is achieved by the
 \printuntil }
 
 Each effect is implemented as a QML item which is based on the
-\l{video/qmlvideofx/qml/qmlvideofx/Effect.qml}{Effect}, which in turn
+\l{multimedia/video/qmlvideofx/qml/qmlvideofx/Effect.qml}{Effect}, which in turn
 is based on the \l{ShaderEffect}:
 
-\quotefromfile video/qmlvideofx/qml/qmlvideofx/Effect.qml
+\quotefromfile multimedia/video/qmlvideofx/qml/qmlvideofx/Effect.qml
 \skipto import
 \printuntil /^\}/
 
@@ -180,20 +179,20 @@ implementation of the pixelation effect.  As you can see, the pixelation effect
 supports one parameter (which controls the pixelation granularity), and states
 that the divider should be displayed.
 
-\quotefromfile video/qmlvideofx/qml/qmlvideofx/EffectPixelate.qml
+\quotefromfile multimedia/video/qmlvideofx/qml/qmlvideofx/EffectPixelate.qml
 \skipto import
 \printuntil /^\}/
 
 The main.qml file shows a
-\l{video/qmlvideofx/qml/qmlvideofx/FileOpen.qml}{FileOpen}, which allows
+\l{multimedia/video/qmlvideofx/qml/qmlvideofx/FileOpen.qml}{FileOpen}, which allows
 the user to select the input source and an
-\l{video/qmlvideofx/qml/qmlvideofx/EffectSelectionPanel.qml}{EffectSelectionPanel}
+\l{multimedia/video/qmlvideofx/qml/qmlvideofx/EffectSelectionPanel.qml}{EffectSelectionPanel}
 item, which lists each of the available shader effects.  As described above, a
-\l{video/qmlvideofx/qml/qmlvideofx/Content.qml}{Content} item is used to load the
+\l{multimedia/video/qmlvideofx/qml/qmlvideofx/Content.qml}{Content} item is used to load the
 appropriate input and effect type.  A
-\l{video/qmlvideofx/qml/qmlvideofx/Divider.qml}{Divider} item draws the
+\l{multimedia/video/qmlvideofx/qml/qmlvideofx/Divider.qml}{Divider} item draws the
 vertical dividing line, which can be dragged left / right by the user.  Finally,
-a \l{video/qmlvideofx/qml/qmlvideofx/ParameterPanel.qml}{ParameterPanel} item
+a \l{multimedia/video/qmlvideofx/qml/qmlvideofx/ParameterPanel.qml}{ParameterPanel} item
 renders the sliders corresponding to each effect parameter.
 
 Here is the source selection menu:
@@ -204,12 +203,12 @@ And here is the effect selection menu:
 
 \section1 Calculating and displaying QML painting rate
 
-\input examples/video-qml-paint-rate.qdocinc
+\input video-qml-paint-rate.qdocinc
 
 All that remains is to connect the afterRendering() signal of the QQuickView
 object to a JavaScript function, which will eventually call frequencyItem.notify():
 
-\quotefromfile video/qmlvideofx/main.cpp
+\quotefromfile multimedia/video/qmlvideofx/main.cpp
 \skipto QmlApplicationViewer
 \printuntil ;
 \dots
diff --git a/examples/multimediawidgets/camera/doc/src/camera.qdoc b/examples/multimediawidgets/camera/doc/src/camera.qdoc
index c40c251..15bf9fd 100644
--- a/examples/multimediawidgets/camera/doc/src/camera.qdoc
+++ b/examples/multimediawidgets/camera/doc/src/camera.qdoc
@@ -29,14 +29,12 @@
 
 /*!
 
-\example camera
+\example multimediawidgets/camera
 \title  Camera Example
-\ingroup camera_examples
+\ingroup multimedia_examples
 \brief  The Camera Example shows how to use the API to capture a still image
 or video.
 
-
-
 The Camera Example demonstrates how you can use QtMultimedia to implement
 some basic Camera functionality to take still images and record video clips
 with audio.
diff --git a/examples/multimediawidgets/declarative-camera/doc/src/declarative-camera.qdoc b/examples/multimediawidgets/declarative-camera/doc/src/declarative-camera.qdoc
index 37f35ea..c98688b 100644
--- a/examples/multimediawidgets/declarative-camera/doc/src/declarative-camera.qdoc
+++ b/examples/multimediawidgets/declarative-camera/doc/src/declarative-camera.qdoc
@@ -26,10 +26,9 @@
 ****************************************************************************/
 
 /*!
-\example declarative-camera
+\example multimediawidgets/declarative-camera
 \title QML Camera Example
-\ingroup camera_examples_qml
-
+\ingroup multimedia_examples
 \brief  The Camera Example shows how to use the API to capture a still image
 or video.
 
diff --git a/examples/multimediawidgets/player/doc/src/player.qdoc b/examples/multimediawidgets/player/doc/src/player.qdoc
index 5e98b91..5522425 100644
--- a/examples/multimediawidgets/player/doc/src/player.qdoc
+++ b/examples/multimediawidgets/player/doc/src/player.qdoc
@@ -26,10 +26,10 @@
 ****************************************************************************/
 
 /*!
-    \example player
+    \example multimediawidgets/player
     \title Media Player Example
-    \ingroup video_examples
-
+    \ingroup multimedia_examples
+    \brief Demonstrates the audio and video playback functionality
 
     This example creates a simple multimedia player. We can play audio and
     or video files using various codecs.
diff --git a/examples/multimediawidgets/videographicsitem/doc/src/videographicsitem.qdoc b/examples/multimediawidgets/videographicsitem/doc/src/videographicsitem.qdoc
index c1eb0cc..6deca4c 100644
--- a/examples/multimediawidgets/videographicsitem/doc/src/videographicsitem.qdoc
+++ b/examples/multimediawidgets/videographicsitem/doc/src/videographicsitem.qdoc
@@ -26,9 +26,9 @@
 ****************************************************************************/
 
 /*!
-\example videographicsitem
+\example multimediawidgets/videographicsitem
 \title Video Graphics Item Example
-\ingroup video_examples
+\ingroup multimedia_examples
 \brief This example demonstrates how to stream video on a graphics scene.
 
     The Video Graphics Item example shows how to implement a QGraphicsItem that displays video on a
diff --git a/examples/multimediawidgets/videowidget/doc/src/videowidget.qdoc b/examples/multimediawidgets/videowidget/doc/src/videowidget.qdoc
index 860cb7a..9a95f0c 100644
--- a/examples/multimediawidgets/videowidget/doc/src/videowidget.qdoc
+++ b/examples/multimediawidgets/videowidget/doc/src/videowidget.qdoc
@@ -26,9 +26,9 @@
 ****************************************************************************/
 
 /*!
-    \example videowidget
+    \example multimediawidgets/videowidget
     \title Video Widget Example
-    \ingroup video_examples
+    \ingroup multimedia_examples
     \brief This example is a simple video player
 
     The Video Widget example denonstrates how to implement a video widget using
diff --git a/src/multimedia/doc/qtmultimedia.qdocconf b/src/multimedia/doc/qtmultimedia.qdocconf
index a6c9576..08a6289 100644
--- a/src/multimedia/doc/qtmultimedia.qdocconf
+++ b/src/multimedia/doc/qtmultimedia.qdocconf
@@ -30,6 +30,7 @@ qhp.qtmultimedia.subprojects.qmltypes.selectors = class fake:headerfile
 qhp.qtmultimedia.subprojects.qmltypes.sortPages = true
 
 exampledirs += ../../../examples \
+               snippets
 
 headerdirs += ../..
 
diff --git a/src/multimedia/doc/snippets/multimedia-snippets/audio.cpp b/src/multimedia/doc/snippets/multimedia-snippets/audio.cpp
new file mode 100644
index 0000000..a39f1c7
--- /dev/null
+++ b/src/multimedia/doc/snippets/multimedia-snippets/audio.cpp
@@ -0,0 +1,251 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Mobility Components.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/* Audio related snippets */
+#include <QFile>
+#include <QTimer>
+#include <QDebug>
+
+#include "qaudiodeviceinfo.h"
+#include "qaudioinput.h"
+#include "qaudiooutput.h"
+#include "qaudioprobe.h"
+#include "qaudiodecoder.h"
+
+class AudioInputExample : public QObject {
+    Q_OBJECT
+public:
+    void setup();
+
+
+public Q_SLOTS:
+    void stopRecording();
+    void stateChanged(QAudio::State newState);
+
+private:
+    //! [Audio input class members]
+    QFile destinationFile;   // class member.
+    QAudioInput* audio; // class member.
+    //! [Audio input class members]
+};
+
+
+void AudioInputExample::setup()
+//! [Audio input setup]
+{
+    destinationFile.setFileName("/tmp/test.raw");
+    destinationFile.open( QIODevice::WriteOnly | QIODevice::Truncate );
+
+    QAudioFormat format;
+    // set up the format you want, eg.
+    format.setSampleRate(8000);
+    format.setChannelCount(1);
+    format.setSampleSize(8);
+    format.setCodec("audio/pcm");
+    format.setByteOrder(QAudioFormat::LittleEndian);
+    format.setSampleType(QAudioFormat::UnSignedInt);
+
+    QAudioDeviceInfo info = QAudioDeviceInfo::defaultInputDevice();
+    if (!info.isFormatSupported(format)) {
+        qWarning()<<"default format not supported try to use nearest";
+        format = info.nearestFormat(format);
+    }
+
+    audio = new QAudioInput(format, this);
+    connect(audio, SIGNAL(stateChanged(QAudio::State)), this, SLOT(stateChanged(QAudio::State)));
+
+    QTimer::singleShot(3000, this, SLOT(stopRecording()));
+    audio->start(&destinationFile);
+    // Records audio for 3000ms
+}
+//! [Audio input setup]
+
+//! [Audio input stop recording]
+void AudioInputExample::stopRecording()
+{
+    audio->stop();
+    destinationFile.close();
+    delete audio;
+}
+//! [Audio input stop recording]
+
+//! [Audio input state changed]
+void AudioInputExample::stateChanged(QAudio::State newState)
+{
+    switch (newState) {
+        case QAudio::StoppedState:
+            if (audio->error() != QAudio::NoError) {
+                // Error handling
+            } else {
+                // Finished recording
+            }
+            break;
+
+        case QAudio::ActiveState:
+            // Started recording - read from IO device
+            break;
+
+        default:
+            // ... other cases as appropriate
+            break;
+    }
+}
+//! [Audio input state changed]
+
+
+class AudioOutputExample : public QObject {
+    Q_OBJECT
+public:
+    void setup();
+
+public Q_SLOTS:
+    void stateChanged(QAudio::State newState);
+
+private:
+    //! [Audio output class members]
+    QFile sourceFile;   // class member.
+    QAudioOutput* audio; // class member.
+    //! [Audio output class members]
+};
+
+
+void AudioOutputExample::setup()
+//! [Audio output setup]
+{
+    sourceFile.setFileName("/tmp/test.raw");
+    sourceFile.open(QIODevice::ReadOnly);
+
+    QAudioFormat format;
+    // Set up the format, eg.
+    format.setSampleRate(8000);
+    format.setChannelCount(1);
+    format.setSampleSize(8);
+    format.setCodec("audio/pcm");
+    format.setByteOrder(QAudioFormat::LittleEndian);
+    format.setSampleType(QAudioFormat::UnSignedInt);
+
+    QAudioDeviceInfo info(QAudioDeviceInfo::defaultOutputDevice());
+    if (!info.isFormatSupported(format)) {
+        qWarning() << "raw audio format not supported by backend, cannot play audio.";
+        return;
+    }
+
+    audio = new QAudioOutput(format, this);
+    connect(audio, SIGNAL(stateChanged(QAudio::State)), this, SLOT(stateChanged(QAudio::State)));
+    audio->start(&sourceFile);
+}
+//! [Audio output setup]
+
+//! [Audio output state changed]
+void AudioOutputExample::stateChanged(QAudio::State newState)
+{
+    switch (newState) {
+        case QAudio::IdleState:
+            // Finished playing (no more data)
+            audio->stop();
+            sourceFile.close();
+            delete audio;
+            break;
+
+        case QAudio::StoppedState:
+            // Stopped for other reasons
+            if (audio->error() != QAudio::NoError) {
+                // Error handling
+            }
+            break;
+
+        default:
+            // ... other cases as appropriate
+            break;
+    }
+}
+//! [Audio output state changed]
+
+void AudioDeviceInfo()
+{
+    //! [Setting audio format]
+    QAudioFormat format;
+    format.setSampleRate(44100);
+    // ... other format parameters
+    format.setSampleType(QAudioFormat::SignedInt);
+
+    QAudioDeviceInfo info(QAudioDeviceInfo::defaultOutputDevice());
+
+    if (!info.isFormatSupported(format))
+        format = info.nearestFormat(format);
+    //! [Setting audio format]
+
+    //! [Dumping audio formats]
+    foreach (const QAudioDeviceInfo &deviceInfo, QAudioDeviceInfo::availableDevices(QAudio::AudioOutput))
+        qDebug() << "Device name: " << deviceInfo.deviceName();
+    //! [Dumping audio formats]
+}
+
+class AudioDecodingExample : public QObject {
+    Q_OBJECT
+public:
+    void decode();
+
+public Q_SLOTS:
+    void stateChanged(QAudio::State newState);
+    void readBuffer();
+};
+
+void AudioDecodingExample::decode()
+{
+    //! [Local audio decoding]
+    QAudioFormat desiredFormat;
+    desiredFormat.setChannelCount(2);
+    desiredFormat.setCodec("audio/x-raw");
+    desiredFormat.setSampleType(QAudioFormat::UnSignedInt);
+    desiredFormat.setSampleRate(48000);
+    desiredFormat.setSampleSize(16);
+
+    QAudioDecoder *decoder = new QAudioDecoder(this);
+    decoder->setAudioFormat(desiredFormat);
+    decoder->setSourceFilename("level1.mp3");
+
+    connect(decoder, SIGNAL(bufferReady()), this, SLOT(readBuffer()));
+    decoder->start();
+
+    // Now wait for bufferReady() signal and call decoder->read()
+    //! [Local audio decoding]
+}
diff --git a/src/multimedia/doc/snippets/multimedia-snippets/audiorecorder.cpp b/src/multimedia/doc/snippets/multimedia-snippets/audiorecorder.cpp
new file mode 100644
index 0000000..e0f1369
--- /dev/null
+++ b/src/multimedia/doc/snippets/multimedia-snippets/audiorecorder.cpp
@@ -0,0 +1,213 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Mobility Components.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtWidgets>
+
+#include <qaudiorecorder.h>
+#include <qmediaservice.h>
+
+#include <QtMultimedia/qaudioformat.h>
+
+#include "audiorecorder.h"
+
+AudioRecorder::AudioRecorder()
+{
+//! [create-objs-1]
+    capture = new QAudioRecorder();
+//! [create-objs-1]
+
+    // set a default file
+    capture->setOutputLocation(QUrl("test.raw"));
+
+    QWidget *window = new QWidget;
+    QGridLayout* layout = new QGridLayout;
+
+    QLabel* deviceLabel = new QLabel;
+    deviceLabel->setText("Devices");
+    deviceBox = new QComboBox(this);
+    deviceBox->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
+
+    QLabel* codecLabel = new QLabel;
+    codecLabel->setText("Codecs");
+    codecsBox = new QComboBox(this);
+    codecsBox->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
+
+    QLabel* qualityLabel = new QLabel;
+    qualityLabel->setText("Quality");
+    qualityBox = new QComboBox(this);
+    qualityBox->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
+
+//! [device-list]
+    for(int i = 0; i < audiosource->deviceCount(); i++)
+        deviceBox->addItem(audiosource->name(i));
+//! [device-list]
+
+//! [codec-list]
+    QStringList codecs = capture->supportedAudioCodecs();
+    for(int i = 0; i < codecs.count(); i++)
+        codecsBox->addItem(codecs.at(i));
+//! [codec-list]
+
+    qualityBox->addItem("Low");
+    qualityBox->addItem("Medium");
+    qualityBox->addItem("High");
+
+    connect(capture, SIGNAL(durationChanged(qint64)), this, SLOT(updateProgress(qint64)));
+    connect(capture, SIGNAL(stateChanged(QMediaRecorder::State)), this, SLOT(stateChanged(QMediaRecorder::State)));
+
+    layout->addWidget(deviceLabel,0,0,Qt::AlignHCenter);
+    connect(deviceBox,SIGNAL(activated(int)),SLOT(deviceChanged(int)));
+    layout->addWidget(deviceBox,0,1,1,3,Qt::AlignLeft);
+
+    layout->addWidget(codecLabel,1,0,Qt::AlignHCenter);
+    connect(codecsBox,SIGNAL(activated(int)),SLOT(codecChanged(int)));
+    layout->addWidget(codecsBox,1,1,Qt::AlignLeft);
+
+    layout->addWidget(qualityLabel,1,2,Qt::AlignHCenter);
+    connect(qualityBox,SIGNAL(activated(int)),SLOT(qualityChanged(int)));
+    layout->addWidget(qualityBox,1,3,Qt::AlignLeft);
+
+    fileButton = new QPushButton(this);
+    fileButton->setText(tr("Output File"));
+    connect(fileButton,SIGNAL(clicked()),SLOT(selectOutputFile()));
+    layout->addWidget(fileButton,3,0,Qt::AlignHCenter);
+
+    button = new QPushButton(this);
+    button->setText(tr("Record"));
+    connect(button,SIGNAL(clicked()),SLOT(toggleRecord()));
+    layout->addWidget(button,3,3,Qt::AlignHCenter);
+
+    recTime = new QLabel;
+    recTime->setText("0 sec");
+    layout->addWidget(recTime,4,0,Qt::AlignHCenter);
+
+    window->setLayout(layout);
+    setCentralWidget(window);
+    window->show();
+
+    active = false;
+}
+
+AudioRecorder::~AudioRecorder()
+{
+    delete capture;
+    delete audiosource;
+}
+
+void AudioRecorder::updateProgress(qint64 pos)
+{
+    currentTime = pos;
+    if(currentTime == 0) currentTime = 1;
+    QString text = QString("%1 secs").arg(currentTime/1000);
+    recTime->setText(text);
+}
+
+void AudioRecorder::stateChanged(QMediaRecorder::State state)
+{
+    qWarning()<<"stateChanged() "<<state;
+}
+
+void AudioRecorder::deviceChanged(int idx)
+{
+//! [get-device]
+    for(int i = 0; i < audiosource->deviceCount(); i++) {
+        if(deviceBox->itemText(idx).compare(audiosource->name(i)) == 0)
+            audiosource->setSelectedDevice(i);
+    }
+//! [get-device]
+}
+
+void AudioRecorder::codecChanged(int idx)
+{
+    Q_UNUSED(idx);
+    //capture->setAudioCodec(codecsBox->itemText(idx));
+}
+
+void AudioRecorder::qualityChanged(int idx)
+{
+    Q_UNUSED(idx);
+    /*
+    if(capture->audioCodec().compare("audio/pcm") == 0) {
+        if(qualityBox->itemText(idx).compare("Low") == 0) {
+            // 8000Hz mono is 8kbps
+            capture->setAudioBitrate(8);
+        } else if(qualityBox->itemText(idx).compare("Medium") == 0) {
+            // 22050Hz mono is 44.1kbps
+            capture->setAudioBitrate(44);
+        } else if(qualityBox->itemText(idx).compare("High") == 0) {
+            // 44100Hz mono is 88.2kbps
+            capture->setAudioBitrate(88);
+        }
+    }
+    */
+}
+
+//! [toggle-record]
+void AudioRecorder::toggleRecord()
+{
+    if(!active) {
+        recTime->setText("0 sec");
+        currentTime = 0;
+        capture->record();
+
+        button->setText(tr("Stop"));
+        active = true;
+    } else {
+        capture->stop();
+        button->setText(tr("Record"));
+        active = false;
+    }
+}
+//! [toggle-record]
+
+void AudioRecorder::selectOutputFile()
+{
+    QStringList fileNames;
+
+    QFileDialog dialog(this);
+
+    dialog.setFileMode(QFileDialog::AnyFile);
+    if (dialog.exec())
+        fileNames = dialog.selectedFiles();
+
+    if(fileNames.size() > 0)
+        capture->setOutputLocation(QUrl(fileNames.first()));
+}
diff --git a/src/multimedia/doc/snippets/multimedia-snippets/camera.cpp b/src/multimedia/doc/snippets/multimedia-snippets/camera.cpp
new file mode 100644
index 0000000..757533b
--- /dev/null
+++ b/src/multimedia/doc/snippets/multimedia-snippets/camera.cpp
@@ -0,0 +1,201 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Mobility Components.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/* Camera snippets */
+
+#include "qcamera.h"
+#include "qcameraviewfinder.h"
+#include "qmediarecorder.h"
+#include "qcameraimagecapture.h"
+#include "qcameraimageprocessing.h"
+#include "qabstractvideosurface.h"
+
+/* Globals so that everything is consistent. */
+QCamera *camera = 0;
+QCameraViewfinder *viewfinder = 0;
+QMediaRecorder *recorder = 0;
+QCameraImageCapture *imageCapture = 0;
+
+void overview_viewfinder()
+{
+    //! [Camera overview viewfinder]
+    camera = new QCamera;
+    viewfinder = new QCameraViewfinder;
+    camera->setViewfinder(viewfinder);
+    viewfinder->show();
+
+    camera->start(); // to start the viewfinder
+    //! [Camera overview viewfinder]
+}
+
+// -.-
+class MyVideoSurface : public QAbstractVideoSurface
+{
+    QList<QVideoFrame::PixelFormat> supportedPixelFormats(QAbstractVideoBuffer::HandleType handleType) const
+    {
+        Q_UNUSED(handleType);
+        return QList<QVideoFrame::PixelFormat>();
+    }
+    bool present(const QVideoFrame &frame)
+    {
+        Q_UNUSED(frame);
+        return true;
+    }
+};
+
+void overview_surface()
+{
+    MyVideoSurface *mySurface;
+    //! [Camera overview surface]
+    camera = new QCamera;
+    mySurface = new MyVideoSurface;
+    camera->setViewfinder(mySurface);
+
+    camera->start();
+    // MyVideoSurface::present(..) will be called with viewfinder frames
+    //! [Camera overview surface]
+}
+
+void overview_still()
+{
+    //! [Camera overview capture]
+    imageCapture = new QCameraImageCapture(camera);
+
+    camera->setCaptureMode(QCamera::CaptureStillImage);
+    camera->start(); // Viewfinder frames start flowing
+
+    //on half pressed shutter button
+    camera->searchAndLock();
+
+    //on shutter button pressed
+    imageCapture->capture();
+
+    //on shutter button released
+    camera->unlock();
+    //! [Camera overview capture]
+}
+
+void overview_movie()
+{
+    //! [Camera overview movie]
+    camera = new QCamera;
+    recorder = new QMediaRecorder(camera);
+
+    camera->setCaptureMode(QCamera::CaptureVideo);
+    camera->start();
+
+    //on shutter button pressed
+    recorder->record();
+
+    // sometime later, or on another press
+    recorder->stop();
+    //! [Camera overview movie]
+}
+
+void camera_blah()
+{
+    //! [Camera]
+    camera = new QCamera;
+
+    viewfinder = new QCameraViewfinder();
+    viewfinder->show();
+
+    camera->setViewfinder(viewfinder);
+
+    imageCapture = new QCameraImageCapture(camera);
+
+    camera->setCaptureMode(QCamera::CaptureStillImage);
+    camera->start();
+    //! [Camera]
+
+    //! [Camera keys]
+    //on half pressed shutter button
+    camera->searchAndLock();
+
+    //on shutter button pressed
+    imageCapture->capture();
+
+    //on shutter button released
+    camera->unlock();
+    //! [Camera keys]
+}
+
+void cameraimageprocessing()
+{
+    //! [Camera image whitebalance]
+    camera = new QCamera;
+    QCameraImageProcessing *imageProcessing = camera->imageProcessing();
+
+    if (imageProcessing->isAvailable()) {
+        imageProcessing->setWhiteBalanceMode(QCameraImageProcessing::WhiteBalanceFluorescent);
+    }
+    //! [Camera image whitebalance]
+
+    //! [Camera image denoising]
+    imageProcessing->setDenoisingLevel(-0.3); //reduce the amount of denoising applied
+    //! [Camera image denoising]
+}
+
+void camerafocus()
+{
+    //! [Camera custom zoom]
+    QCameraFocus *focus = camera->focus();
+    focus->setFocusPointMode(QCameraFocus::FocusPointCustom);
+    focus->setCustomFocusPoint(QPointF(0.25f, 0.75f)); // A point near the bottom left, 25% away from the corner, near that shiny vase
+    //! [Camera custom zoom]
+
+    //! [Camera combined zoom]
+    focus->zoomTo(3.0, 4.0); // Super zoom!
+    //! [Camera combined zoom]
+
+    //! [Camera focus zones]
+    focus->setFocusPointMode(QCameraFocus::FocusPointAuto);
+    QList<QCameraFocusZone> zones = focus->focusZones();
+    foreach (QCameraFocusZone zone, zones) {
+        if (zone.status() == QCameraFocusZone::Focused) {
+            // Draw a green box at zone.area()
+        } else if (zone.status() == QCameraFocusZone::Selected) {
+            // This area is selected for autofocusing, but is not in focus
+            // Draw a yellow box at zone.area()
+        }
+    }
+    //! [Camera focus zones]
+}
diff --git a/src/multimedia/doc/snippets/multimedia-snippets/media.cpp b/src/multimedia/doc/snippets/multimedia-snippets/media.cpp
new file mode 100644
index 0000000..300ad39
--- /dev/null
+++ b/src/multimedia/doc/snippets/multimedia-snippets/media.cpp
@@ -0,0 +1,315 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Mobility Components.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/* Media related snippets */
+#include <QFile>
+#include <QTimer>
+
+#include "qmediaplaylist.h"
+#include "qmediarecorder.h"
+#include "qmediaservice.h"
+#include "qmediaplayercontrol.h"
+#include "qmediaplayer.h"
+#include "qradiotuner.h"
+#include "qradiodata.h"
+#include "qvideowidget.h"
+#include "qcameraimagecapture.h"
+#include "qcamera.h"
+#include "qcameraviewfinder.h"
+#include "qaudioprobe.h"
+#include "qaudiorecorder.h"
+#include "qvideoprobe.h"
+
+class MediaExample : public QObject {
+    Q_OBJECT
+
+    void MediaControl();
+    void MediaPlayer();
+    void RadioTuna();
+    void MediaRecorder();
+    void AudioRecorder();
+    void EncoderSettings();
+    void ImageEncoderSettings();
+    void AudioProbe();
+    void VideoProbe();
+
+private:
+    // Common naming
+    QMediaService *mediaService;
+    QVideoWidget *videoWidget;
+    QWidget *widget;
+    QMediaPlayer *player;
+    QMediaPlaylist *playlist;
+    QMediaContent video;
+    QMediaRecorder *recorder;
+    QCamera *camera;
+    QCameraViewfinder *viewfinder;
+    QCameraImageCapture *imageCapture;
+    QString fileName;
+    QRadioTuner *radio;
+    QRadioData *radioData;
+    QAudioRecorder *audioRecorder;
+    QAudioProbe *audioProbe;
+    QVideoProbe *videoProbe;
+
+    QMediaContent image1;
+    QMediaContent image2;
+    QMediaContent image3;
+
+    static const int yourRadioStationFrequency = 11;
+};
+
+void MediaExample::MediaControl()
+{
+    {
+    //! [Request control]
+    QMediaPlayerControl *control = qobject_cast<QMediaPlayerControl *>(
+            mediaService->requestControl("org.qt-project.qt.mediaplayercontrol/5.0"));
+    //! [Request control]
+    Q_UNUSED(control);
+    }
+
+    {
+    //! [Request control templated]
+    QMediaPlayerControl *control = mediaService->requestControl<QMediaPlayerControl *>();
+    //! [Request control templated]
+    Q_UNUSED(control);
+    }
+}
+
+
+void MediaExample::EncoderSettings()
+{
+    //! [Audio encoder settings]
+    QAudioEncoderSettings audioSettings;
+    audioSettings.setCodec("audio/mpeg");
+    audioSettings.setChannelCount(2);
+
+    recorder->setAudioSettings(audioSettings);
+    //! [Audio encoder settings]
+
+    //! [Video encoder settings]
+    QVideoEncoderSettings videoSettings;
+    videoSettings.setCodec("video/mpeg2");
+    videoSettings.setResolution(640, 480);
+
+    recorder->setVideoSettings(videoSettings);
+    //! [Video encoder settings]
+}
+
+void MediaExample::ImageEncoderSettings()
+{
+    //! [Image encoder settings]
+    QImageEncoderSettings imageSettings;
+    imageSettings.setCodec("image/jpeg");
+    imageSettings.setResolution(1600, 1200);
+
+    imageCapture->setEncodingSettings(imageSettings);
+    //! [Image encoder settings]
+}
+
+void MediaExample::MediaPlayer()
+{
+    //! [Player]
+    player = new QMediaPlayer;
+    connect(player, SIGNAL(positionChanged(qint64)), this, SLOT(positionChanged(qint64)));
+    player->setMedia(QUrl::fromLocalFile("/Users/me/Music/coolsong.mp3"));
+    player->setVolume(50);
+    player->play();
+    //! [Player]
+
+    //! [Local playback]
+    player = new QMediaPlayer;
+    // ...
+    player->setMedia(QUrl::fromLocalFile("/Users/me/Music/coolsong.mp3"));
+    player->setVolume(50);
+    player->play();
+    //! [Local playback]
+
+    //! [Audio playlist]
+    player = new QMediaPlayer;
+
+    playlist = new QMediaPlaylist(player);
+    playlist->addMedia(QUrl("http://example.com/myfile1.mp3"));
+    playlist->addMedia(QUrl("http://example.com/myfile2.mp3"));
+    // ...
+    playlist->setCurrentIndex(1);
+    player->play();
+    //! [Audio playlist]
+
+    //! [Movie playlist]
+    playlist = new QMediaPlaylist;
+    playlist->addMedia(QUrl("http://example.com/movie1.mp4"));
+    playlist->addMedia(QUrl("http://example.com/movie2.mp4"));
+    playlist->addMedia(QUrl("http://example.com/movie3.mp4"));
+    playlist->setCurrentIndex(1);
+
+    player = new QMediaPlayer;
+    player->setPlaylist(playlist);
+
+    videoWidget = new QVideoWidget;
+    player->setVideoOutput(videoWidget);
+    videoWidget->show();
+
+    player->play();
+    //! [Movie playlist]
+}
+
+void MediaExample::MediaRecorder()
+{
+    //! [Media recorder]
+    recorder = new QMediaRecorder(camera);
+
+    QAudioEncoderSettings audioSettings;
+    audioSettings.setCodec("audio/amr");
+    audioSettings.setQuality(QMultimedia::HighQuality);
+
+    recorder->setAudioSettings(audioSettings);
+
+    recorder->setOutputLocation(QUrl::fromLocalFile(fileName));
+    recorder->record();
+    //! [Media recorder]
+}
+
+void MediaExample::AudioRecorder()
+{
+    //! [Audio recorder]
+    audioRecorder = new QAudioRecorder;
+
+    QAudioEncoderSettings audioSettings;
+    audioSettings.setCodec("audio/amr");
+    audioSettings.setQuality(QMultimedia::HighQuality);
+
+    audioRecorder->setEncodingSettings(audioSettings);
+
+    audioRecorder->setOutputLocation(QUrl::fromLocalFile("test.amr"));
+    audioRecorder->record();
+    //! [Audio recorder]
+
+    //! [Audio recorder inputs]
+    QStringList inputs = audioRecorder->audioInputs();
+    QString selectedInput = audioRecorder->defaultAudioInput();
+
+    foreach (QString input, inputs) {
+        QString description = audioRecorder->audioInputDescription(input);
+        // show descriptions to user and allow selection
+        selectedInput = input;
+    }
+
+    audioRecorder->setAudioInput(selectedInput);
+    //! [Audio recorder inputs]
+}
+
+void MediaExample::RadioTuna()
+{
+    //! [Radio tuner]
+    radio = new QRadioTuner;
+    connect(radio, SIGNAL(frequencyChanged(int)), this, SLOT(freqChanged(int)));
+    if (radio->isBandSupported(QRadioTuner::FM)) {
+        radio->setBand(QRadioTuner::FM);
+        radio->setFrequency(yourRadioStationFrequency);
+        radio->setVolume(100);
+        radio->start();
+    }
+    //! [Radio tuner]
+
+    //! [Radio data setup]
+    radio = new QRadioTuner;
+    radioData = radio->radioData();
+    //! [Radio data setup]
+}
+
+void MediaExample::AudioProbe()
+{
+    //! [Audio probe]
+    audioRecorder = new QAudioRecorder;
+
+    QAudioEncoderSettings audioSettings;
+    audioSettings.setCodec("audio/amr");
+    audioSettings.setQuality(QMultimedia::HighQuality);
+
+    audioRecorder->setEncodingSettings(audioSettings);
+
+    audioRecorder->setOutputLocation(QUrl::fromLocalFile("test.amr"));
+
+    audioProbe = new QAudioProbe(this);
+    if (audioProbe->setSource(audioRecorder)) {
+        // Probing succeeded, audioProbe->isValid() should be true.
+        connect(audioProbe, SIGNAL(audioBufferProbed(QAudioBuffer)),
+                this, SLOT(calculateLevel(QAudioBuffer)));
+    }
+
+    audioRecorder->record();
+    // Now audio buffers being recorded should be signaled
+    // by the probe, so we can do things like calculating the
+    // audio power level, or performing a frequency transform
+    //! [Audio probe]
+}
+
+void MediaExample::VideoProbe()
+{
+    //! [Video probe]
+    camera = new QCamera;
+    viewfinder = new QCameraViewfinder();
+    camera->setViewfinder(viewfinder);
+
+    camera->setCaptureMode(QCamera::CaptureVideo);
+
+    videoProbe = new QVideoProbe(this);
+
+    if (videoProbe->setSource(camera)) {
+        // Probing succeeded, videoProbe->isValid() should be true.
+        connect(videoProbe, SIGNAL(videoFrameProbed(QVideoFrame)),
+                this, SLOT(detectBarcodes(QVideoFrame)));
+    }
+
+    camera->start();
+    // Viewfinder frames should now also be emitted by
+    // the video probe, even in still image capture mode.
+    // Another alternative is to install the probe on a
+    // QMediaRecorder connected to the camera to get the
+    // recorded frames, if they are different from the
+    // viewfinder frames.
+
+    //! [Video probe]
+}
+
+
diff --git a/src/multimedia/doc/snippets/multimedia-snippets/multimedia-snippets.pro b/src/multimedia/doc/snippets/multimedia-snippets/multimedia-snippets.pro
new file mode 100644
index 0000000..9571b02
--- /dev/null
+++ b/src/multimedia/doc/snippets/multimedia-snippets/multimedia-snippets.pro
@@ -0,0 +1,24 @@
+# Doc snippets - compiled for truthiness
+
+TEMPLATE = lib
+TARGET = qtmmksnippets
+
+INCLUDEPATH += ../../../../src/global \
+               ../../../../src/multimedia \
+               ../../../../src/multimedia/audio \
+               ../../../../src/multimedia/video \
+               ../../../../src/multimedia/camera
+
+CONFIG += console
+
+QT += multimedia multimediawidgets widgets multimedia-private
+
+SOURCES += \
+    audio.cpp \
+    video.cpp \
+    camera.cpp \
+    media.cpp \
+    qsound.cpp
+
+OTHER_FILES += \
+    soundeffect.qml
diff --git a/src/multimedia/doc/snippets/multimedia-snippets/qsound.cpp b/src/multimedia/doc/snippets/multimedia-snippets/qsound.cpp
new file mode 100644
index 0000000..1f7dad7
--- /dev/null
+++ b/src/multimedia/doc/snippets/multimedia-snippets/qsound.cpp
@@ -0,0 +1,85 @@
+ /****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the documentation of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:BSD$
+** You may use this file under the terms of the BSD license as follows:
+**
+** "Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above copyright
+**     notice, this list of conditions and the following disclaimer in
+**     the documentation and/or other materials provided with the
+**     distribution.
+**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names
+**     of its contributors may be used to endorse or promote products derived
+**     from this software without specific prior written permission.
+**
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qobject.h"
+#include "qsound.h"
+#include "qsoundeffect.h"
+
+void qsoundsnippet() {
+    //! [0]
+    QSound::play("mysounds/bells.wav");
+    //! [0]
+
+
+    //! [1]
+    QSound bells("mysounds/bells.wav");
+    bells.play();
+    //! [1]
+}
+
+void qsoundeffectsnippet() {
+    //! [2]
+    QSoundEffect effect;
+    effect.setSource(QUrl::fromLocalFile("engine.wav"));
+    effect.setLoopCount(QSoundEffect::Infinite);
+    effect.setVolume(0.25f);
+    effect.play();
+    //! [2]
+}
+
+QObject *clickSource;
+
+class MyGame : public QObject {
+    Q_OBJECT
+public:
+    //! [3]
+    MyGame()
+        : m_explosion(this)
+    {
+        m_explosion.setSource(QUrl::fromLocalFile("explosion.wav"));
+        m_explosion.setVolume(0.25f);
+
+        // Set up click handling etc.
+        connect(clickSource, SIGNAL(clicked()), &m_explosion, SLOT(play()));
+    }
+private:
+    QSoundEffect m_explosion;
+    //! [3]
+};
diff --git a/src/multimedia/doc/snippets/multimedia-snippets/soundeffect.qml b/src/multimedia/doc/snippets/multimedia-snippets/soundeffect.qml
new file mode 100644
index 0000000..9b173a4
--- /dev/null
+++ b/src/multimedia/doc/snippets/multimedia-snippets/soundeffect.qml
@@ -0,0 +1,63 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+//! [complete snippet]
+import QtQuick 2.0
+import QtMultimedia 5.0
+
+Text {
+    text: "Click Me!";
+    font.pointSize: 24;
+    width: 150; height: 50;
+
+    //! [play sound on click]
+    SoundEffect {
+        id: playSound
+        source: "soundeffect.wav"
+    }
+    MouseArea {
+        id: playArea
+        anchors.fill: parent
+        onPressed: { playSound.play() }
+    }
+    //! [play sound on click]
+}
+//! [complete snippet]
diff --git a/src/multimedia/doc/snippets/multimedia-snippets/video.cpp b/src/multimedia/doc/snippets/multimedia-snippets/video.cpp
new file mode 100644
index 0000000..37dca08
--- /dev/null
+++ b/src/multimedia/doc/snippets/multimedia-snippets/video.cpp
@@ -0,0 +1,193 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Mobility Components.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/* Video related snippets */
+#include "qvideorenderercontrol.h"
+#include "qmediaservice.h"
+#include "qmediaplayer.h"
+#include "qabstractvideosurface.h"
+#include "qvideowidgetcontrol.h"
+#include "qvideowindowcontrol.h"
+#include "qgraphicsvideoitem.h"
+#include "qmediaplaylist.h"
+#include "qvideosurfaceformat.h"
+
+#include <QFormLayout>
+#include <QGraphicsView>
+
+//! [Derived Surface]
+class MyVideoSurface : public QAbstractVideoSurface
+{
+    QList<QVideoFrame::PixelFormat> supportedPixelFormats(
+            QAbstractVideoBuffer::HandleType handleType = QAbstractVideoBuffer::NoHandle) const
+    {
+        Q_UNUSED(handleType);
+
+        // Return the formats you will support
+        return QList<QVideoFrame::PixelFormat>() << QVideoFrame::Format_RGB565;
+    }
+
+    bool present(const QVideoFrame &frame)
+    {
+        Q_UNUSED(frame);
+        // Handle the frame and do your processing
+
+        return true;
+    }
+};
+//! [Derived Surface]
+
+//! [Video producer]
+class MyVideoProducer : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QAbstractVideoSurface *videoSurface WRITE setVideoSurface)
+
+public:
+    void setVideoSurface(QAbstractVideoSurface *surface)
+    {
+        m_surface = surface;
+        m_surface->start(m_format);
+    }
+
+    // ...
+
+public slots:
+    void onNewVideoContentReceived(const QVideoFrame &frame)
+    {
+        if (m_surface)
+            m_surface->present(frame);
+    }
+
+private:
+    QAbstractVideoSurface *m_surface;
+    QVideoSurfaceFormat m_format;
+};
+
+//! [Video producer]
+
+
+class VideoExample : public QObject {
+    Q_OBJECT
+public:
+    void VideoGraphicsItem();
+    void VideoRendererControl();
+    void VideoWidget();
+    void VideoWindowControl();
+    void VideoWidgetControl();
+
+private:
+    // Common naming
+    QMediaService *mediaService;
+    QMediaPlaylist *playlist;
+    QVideoWidget *videoWidget;
+    QWidget *widget;
+    QFormLayout *layout;
+    QAbstractVideoSurface *myVideoSurface;
+    QMediaPlayer *player;
+    QMediaContent video;
+    QGraphicsView *graphicsView;
+};
+
+void VideoExample::VideoRendererControl()
+{
+    //! [Video renderer control]
+    QVideoRendererControl *rendererControl = mediaService->requestControl<QVideoRendererControl *>();
+    rendererControl->setSurface(myVideoSurface);
+    //! [Video renderer control]
+}
+
+void VideoExample::VideoWidget()
+{
+    //! [Video widget]
+    player = new QMediaPlayer;
+
+    playlist = new QMediaPlaylist(player);
+    playlist->addMedia(QUrl("http://example.com/myclip1.mp4"));
+    playlist->addMedia(QUrl("http://example.com/myclip2.mp4"));
+
+    videoWidget = new QVideoWidget;
+    player->setVideoOutput(videoWidget);
+
+    videoWidget->show();
+    playlist->setCurrentIndex(1);
+    player->play();
+    //! [Video widget]
+
+    player->stop();
+
+    //! [Setting surface in player]
+    player->setVideoOutput(myVideoSurface);
+    //! [Setting surface in player]
+}
+
+void VideoExample::VideoWidgetControl()
+{
+    //! [Video widget control]
+    QVideoWidgetControl *widgetControl = mediaService->requestControl<QVideoWidgetControl *>();
+    layout->addWidget(widgetControl->videoWidget());
+    //! [Video widget control]
+}
+
+void VideoExample::VideoWindowControl()
+{
+    //! [Video window control]
+    QVideoWindowControl *windowControl = mediaService->requestControl<QVideoWindowControl *>();
+    windowControl->setWinId(widget->winId());
+    windowControl->setDisplayRect(widget->rect());
+    windowControl->setAspectRatioMode(Qt::KeepAspectRatio);
+    //! [Video window control]
+}
+
+void VideoExample::VideoGraphicsItem()
+{
+    //! [Video graphics item]
+    player = new QMediaPlayer(this);
+
+    QGraphicsVideoItem *item = new QGraphicsVideoItem;
+    player->setVideoOutput(item);
+    graphicsView->scene()->addItem(item);
+    graphicsView->show();
+
+    player->setMedia(QUrl("http://example.com/myclip4.ogv"));
+    player->play();
+    //! [Video graphics item]
+}
diff --git a/src/multimedia/doc/snippets/snippets.pro b/src/multimedia/doc/snippets/snippets.pro
new file mode 100644
index 0000000..31a3a09
--- /dev/null
+++ b/src/multimedia/doc/snippets/snippets.pro
@@ -0,0 +1,3 @@
+TEMPLATE = subdirs
+
+SUBDIRS += multimedia-snippets
diff --git a/src/multimedia/doc/src/audiooverview.qdoc b/src/multimedia/doc/src/audiooverview.qdoc
index 723afb7..20c5342 100644
--- a/src/multimedia/doc/src/audiooverview.qdoc
+++ b/src/multimedia/doc/src/audiooverview.qdoc
@@ -50,16 +50,16 @@ may have installed.
 
 Here is how you play a local file using C++:
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Local playback
+    \snippet multimedia-snippets/media.cpp Local playback
 
 You can also put files (even remote URLs) into a playlist:
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio playlist
+    \snippet multimedia-snippets/media.cpp Audio playlist
 
 \section2 Recording Audio to a File
 For recording audio to a file, the \l {QAudioRecorder} class allows you
 to compress audio data from an input device and record it.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio recorder
+    \snippet multimedia-snippets/media.cpp Audio recorder
 
 \section2 Low Latency Sound Effects
 
@@ -87,7 +87,7 @@ they may arrive at a slightly different time than the media pipeline
 processes them.
 
 Here's an example of installing a probe during recording:
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio probe
+    \snippet multimedia-snippets/media.cpp Audio probe
 
 \section2 Low Level Audio Playback and Recording
 Qt Multimedia offers classes for raw access to audio input and output
@@ -123,7 +123,7 @@ or from a QIODevice instances.
 
 Here's an example of decoding a local file:
 
-    \snippet doc/src/snippets/multimedia-snippets/audio.cpp Local audio decoding
+    \snippet multimedia-snippets/audio.cpp Local audio decoding
 
 Note:  This API is preliminary at this time - the API may change or be
 removed before the final 5.0 release.
diff --git a/src/multimedia/doc/src/cameraoverview.qdoc b/src/multimedia/doc/src/cameraoverview.qdoc
index f6bf4f5..40c82a6 100644
--- a/src/multimedia/doc/src/cameraoverview.qdoc
+++ b/src/multimedia/doc/src/cameraoverview.qdoc
@@ -118,14 +118,14 @@ In C++, your choice depends on whether you are using widgets, or QGraphicsView.
 The \l QVideoWidget class is used in the widgets case, and \l QGraphicsVideoItem
 is useful for QGraphicsView.
 
-    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera overview viewfinder
+    \snippet multimedia-snippets/camera.cpp Camera overview viewfinder
 
 For advanced usage (like processing viewfinder frames as they come, to detect
 objects or patterns), you can also derive from \l QAbstractVideoSurface and
 set that as the viewfinder for the QCamera object.  In this case you will
 need to render the viewfinder image yourself.
 
-    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera overview surface
+    \snippet multimedia-snippets/camera.cpp Camera overview surface
 
 \section2 Still Images
 
@@ -136,7 +136,7 @@ that things are in focus and the settings are not different from the
 viewfinder while the image capture occurs, capture the image, and
 finally unlock the camera ready for the next photo.
 
-    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera overview capture
+    \snippet multimedia-snippets/camera.cpp Camera overview capture
 
 \section2 Movies
 
@@ -146,7 +146,7 @@ video requires the use of a \l QMediaRecorder object.
 To record video we need to create a camera object as before but this time as
 well as creating a viewfinder, we will also initialize a media recorder object.
 
-    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera overview movie
+    \snippet multimedia-snippets/camera.cpp Camera overview movie
 
 Signals from the \e mediaRecorder can be connected to slots to react to
 changes in the state of the recorder or error events. Recording itself
diff --git a/src/multimedia/doc/src/qtmultimedia-examples.qdoc b/src/multimedia/doc/src/qtmultimedia-examples.qdoc
new file mode 100644
index 0000000..4427e16
--- /dev/null
+++ b/src/multimedia/doc/src/qtmultimedia-examples.qdoc
@@ -0,0 +1,37 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the documentation of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:FDL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Free Documentation License Usage
+** Alternatively, this file may be used under the terms of the GNU Free
+** Documentation License version 1.3 as published by the Free Software
+** Foundation and appearing in the file included in the packaging of
+** this file.  Please review the following information to ensure
+** the GNU Free Documentation License version 1.3 requirements
+** will be met: http://www.gnu.org/copyleft/fdl.html.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+    \group multimedia_examples
+    \ingroup all-examples
+    \title Qt Multimedia Examples
+    \brief Demonstrates the multimedia functionality provided by Qt.
+
+    The \l{Qt Multimedia} module provides low-level audio support on Linux,
+    Windows and Mac OS X. It also provides audio plugin API to allow developers
+    implement their own audio support for custom devices and platforms.
+*/
diff --git a/src/multimedia/doc/src/qtmultimedia-index.qdoc b/src/multimedia/doc/src/qtmultimedia-index.qdoc
index dcf438d..e7838cf 100644
--- a/src/multimedia/doc/src/qtmultimedia-index.qdoc
+++ b/src/multimedia/doc/src/qtmultimedia-index.qdoc
@@ -128,23 +128,6 @@
 
     \section2 Examples
      \list
-      \li QML
-       \list
-        \li \l{video/qmlvideo}{qmlvideo}
-        \li \l{video/qmlvideofx}{qmlvideofx}
-        \li \l{declarative-camera}
-        \li \l{declarative-radio}
-       \endlist
-      \li C++
-       \list
-        \li \l{audiooutput}
-        \li \l{audioinput}
-        \li \l{audiorecorder}
-        \li \l{audiodevices}
-        \li \l{spectrum}
-        \li \l{AudioEngine Example}{Audio Engine}
-        \li \l{player}
-        \li \l{Camera Example}
-       \endlist
+      \li \l{Qt Multimedia Examples}
      \endlist
 */
diff --git a/src/multimedia/doc/src/snippets/multimedia-snippets/audio.cpp b/src/multimedia/doc/src/snippets/multimedia-snippets/audio.cpp
deleted file mode 100644
index a39f1c7..0000000
--- a/src/multimedia/doc/src/snippets/multimedia-snippets/audio.cpp
+++ /dev/null
@@ -1,251 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the Qt Mobility Components.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/* Audio related snippets */
-#include <QFile>
-#include <QTimer>
-#include <QDebug>
-
-#include "qaudiodeviceinfo.h"
-#include "qaudioinput.h"
-#include "qaudiooutput.h"
-#include "qaudioprobe.h"
-#include "qaudiodecoder.h"
-
-class AudioInputExample : public QObject {
-    Q_OBJECT
-public:
-    void setup();
-
-
-public Q_SLOTS:
-    void stopRecording();
-    void stateChanged(QAudio::State newState);
-
-private:
-    //! [Audio input class members]
-    QFile destinationFile;   // class member.
-    QAudioInput* audio; // class member.
-    //! [Audio input class members]
-};
-
-
-void AudioInputExample::setup()
-//! [Audio input setup]
-{
-    destinationFile.setFileName("/tmp/test.raw");
-    destinationFile.open( QIODevice::WriteOnly | QIODevice::Truncate );
-
-    QAudioFormat format;
-    // set up the format you want, eg.
-    format.setSampleRate(8000);
-    format.setChannelCount(1);
-    format.setSampleSize(8);
-    format.setCodec("audio/pcm");
-    format.setByteOrder(QAudioFormat::LittleEndian);
-    format.setSampleType(QAudioFormat::UnSignedInt);
-
-    QAudioDeviceInfo info = QAudioDeviceInfo::defaultInputDevice();
-    if (!info.isFormatSupported(format)) {
-        qWarning()<<"default format not supported try to use nearest";
-        format = info.nearestFormat(format);
-    }
-
-    audio = new QAudioInput(format, this);
-    connect(audio, SIGNAL(stateChanged(QAudio::State)), this, SLOT(stateChanged(QAudio::State)));
-
-    QTimer::singleShot(3000, this, SLOT(stopRecording()));
-    audio->start(&destinationFile);
-    // Records audio for 3000ms
-}
-//! [Audio input setup]
-
-//! [Audio input stop recording]
-void AudioInputExample::stopRecording()
-{
-    audio->stop();
-    destinationFile.close();
-    delete audio;
-}
-//! [Audio input stop recording]
-
-//! [Audio input state changed]
-void AudioInputExample::stateChanged(QAudio::State newState)
-{
-    switch (newState) {
-        case QAudio::StoppedState:
-            if (audio->error() != QAudio::NoError) {
-                // Error handling
-            } else {
-                // Finished recording
-            }
-            break;
-
-        case QAudio::ActiveState:
-            // Started recording - read from IO device
-            break;
-
-        default:
-            // ... other cases as appropriate
-            break;
-    }
-}
-//! [Audio input state changed]
-
-
-class AudioOutputExample : public QObject {
-    Q_OBJECT
-public:
-    void setup();
-
-public Q_SLOTS:
-    void stateChanged(QAudio::State newState);
-
-private:
-    //! [Audio output class members]
-    QFile sourceFile;   // class member.
-    QAudioOutput* audio; // class member.
-    //! [Audio output class members]
-};
-
-
-void AudioOutputExample::setup()
-//! [Audio output setup]
-{
-    sourceFile.setFileName("/tmp/test.raw");
-    sourceFile.open(QIODevice::ReadOnly);
-
-    QAudioFormat format;
-    // Set up the format, eg.
-    format.setSampleRate(8000);
-    format.setChannelCount(1);
-    format.setSampleSize(8);
-    format.setCodec("audio/pcm");
-    format.setByteOrder(QAudioFormat::LittleEndian);
-    format.setSampleType(QAudioFormat::UnSignedInt);
-
-    QAudioDeviceInfo info(QAudioDeviceInfo::defaultOutputDevice());
-    if (!info.isFormatSupported(format)) {
-        qWarning() << "raw audio format not supported by backend, cannot play audio.";
-        return;
-    }
-
-    audio = new QAudioOutput(format, this);
-    connect(audio, SIGNAL(stateChanged(QAudio::State)), this, SLOT(stateChanged(QAudio::State)));
-    audio->start(&sourceFile);
-}
-//! [Audio output setup]
-
-//! [Audio output state changed]
-void AudioOutputExample::stateChanged(QAudio::State newState)
-{
-    switch (newState) {
-        case QAudio::IdleState:
-            // Finished playing (no more data)
-            audio->stop();
-            sourceFile.close();
-            delete audio;
-            break;
-
-        case QAudio::StoppedState:
-            // Stopped for other reasons
-            if (audio->error() != QAudio::NoError) {
-                // Error handling
-            }
-            break;
-
-        default:
-            // ... other cases as appropriate
-            break;
-    }
-}
-//! [Audio output state changed]
-
-void AudioDeviceInfo()
-{
-    //! [Setting audio format]
-    QAudioFormat format;
-    format.setSampleRate(44100);
-    // ... other format parameters
-    format.setSampleType(QAudioFormat::SignedInt);
-
-    QAudioDeviceInfo info(QAudioDeviceInfo::defaultOutputDevice());
-
-    if (!info.isFormatSupported(format))
-        format = info.nearestFormat(format);
-    //! [Setting audio format]
-
-    //! [Dumping audio formats]
-    foreach (const QAudioDeviceInfo &deviceInfo, QAudioDeviceInfo::availableDevices(QAudio::AudioOutput))
-        qDebug() << "Device name: " << deviceInfo.deviceName();
-    //! [Dumping audio formats]
-}
-
-class AudioDecodingExample : public QObject {
-    Q_OBJECT
-public:
-    void decode();
-
-public Q_SLOTS:
-    void stateChanged(QAudio::State newState);
-    void readBuffer();
-};
-
-void AudioDecodingExample::decode()
-{
-    //! [Local audio decoding]
-    QAudioFormat desiredFormat;
-    desiredFormat.setChannelCount(2);
-    desiredFormat.setCodec("audio/x-raw");
-    desiredFormat.setSampleType(QAudioFormat::UnSignedInt);
-    desiredFormat.setSampleRate(48000);
-    desiredFormat.setSampleSize(16);
-
-    QAudioDecoder *decoder = new QAudioDecoder(this);
-    decoder->setAudioFormat(desiredFormat);
-    decoder->setSourceFilename("level1.mp3");
-
-    connect(decoder, SIGNAL(bufferReady()), this, SLOT(readBuffer()));
-    decoder->start();
-
-    // Now wait for bufferReady() signal and call decoder->read()
-    //! [Local audio decoding]
-}
diff --git a/src/multimedia/doc/src/snippets/multimedia-snippets/audiorecorder.cpp b/src/multimedia/doc/src/snippets/multimedia-snippets/audiorecorder.cpp
deleted file mode 100644
index e0f1369..0000000
--- a/src/multimedia/doc/src/snippets/multimedia-snippets/audiorecorder.cpp
+++ /dev/null
@@ -1,213 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the Qt Mobility Components.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QtWidgets>
-
-#include <qaudiorecorder.h>
-#include <qmediaservice.h>
-
-#include <QtMultimedia/qaudioformat.h>
-
-#include "audiorecorder.h"
-
-AudioRecorder::AudioRecorder()
-{
-//! [create-objs-1]
-    capture = new QAudioRecorder();
-//! [create-objs-1]
-
-    // set a default file
-    capture->setOutputLocation(QUrl("test.raw"));
-
-    QWidget *window = new QWidget;
-    QGridLayout* layout = new QGridLayout;
-
-    QLabel* deviceLabel = new QLabel;
-    deviceLabel->setText("Devices");
-    deviceBox = new QComboBox(this);
-    deviceBox->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
-
-    QLabel* codecLabel = new QLabel;
-    codecLabel->setText("Codecs");
-    codecsBox = new QComboBox(this);
-    codecsBox->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
-
-    QLabel* qualityLabel = new QLabel;
-    qualityLabel->setText("Quality");
-    qualityBox = new QComboBox(this);
-    qualityBox->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
-
-//! [device-list]
-    for(int i = 0; i < audiosource->deviceCount(); i++)
-        deviceBox->addItem(audiosource->name(i));
-//! [device-list]
-
-//! [codec-list]
-    QStringList codecs = capture->supportedAudioCodecs();
-    for(int i = 0; i < codecs.count(); i++)
-        codecsBox->addItem(codecs.at(i));
-//! [codec-list]
-
-    qualityBox->addItem("Low");
-    qualityBox->addItem("Medium");
-    qualityBox->addItem("High");
-
-    connect(capture, SIGNAL(durationChanged(qint64)), this, SLOT(updateProgress(qint64)));
-    connect(capture, SIGNAL(stateChanged(QMediaRecorder::State)), this, SLOT(stateChanged(QMediaRecorder::State)));
-
-    layout->addWidget(deviceLabel,0,0,Qt::AlignHCenter);
-    connect(deviceBox,SIGNAL(activated(int)),SLOT(deviceChanged(int)));
-    layout->addWidget(deviceBox,0,1,1,3,Qt::AlignLeft);
-
-    layout->addWidget(codecLabel,1,0,Qt::AlignHCenter);
-    connect(codecsBox,SIGNAL(activated(int)),SLOT(codecChanged(int)));
-    layout->addWidget(codecsBox,1,1,Qt::AlignLeft);
-
-    layout->addWidget(qualityLabel,1,2,Qt::AlignHCenter);
-    connect(qualityBox,SIGNAL(activated(int)),SLOT(qualityChanged(int)));
-    layout->addWidget(qualityBox,1,3,Qt::AlignLeft);
-
-    fileButton = new QPushButton(this);
-    fileButton->setText(tr("Output File"));
-    connect(fileButton,SIGNAL(clicked()),SLOT(selectOutputFile()));
-    layout->addWidget(fileButton,3,0,Qt::AlignHCenter);
-
-    button = new QPushButton(this);
-    button->setText(tr("Record"));
-    connect(button,SIGNAL(clicked()),SLOT(toggleRecord()));
-    layout->addWidget(button,3,3,Qt::AlignHCenter);
-
-    recTime = new QLabel;
-    recTime->setText("0 sec");
-    layout->addWidget(recTime,4,0,Qt::AlignHCenter);
-
-    window->setLayout(layout);
-    setCentralWidget(window);
-    window->show();
-
-    active = false;
-}
-
-AudioRecorder::~AudioRecorder()
-{
-    delete capture;
-    delete audiosource;
-}
-
-void AudioRecorder::updateProgress(qint64 pos)
-{
-    currentTime = pos;
-    if(currentTime == 0) currentTime = 1;
-    QString text = QString("%1 secs").arg(currentTime/1000);
-    recTime->setText(text);
-}
-
-void AudioRecorder::stateChanged(QMediaRecorder::State state)
-{
-    qWarning()<<"stateChanged() "<<state;
-}
-
-void AudioRecorder::deviceChanged(int idx)
-{
-//! [get-device]
-    for(int i = 0; i < audiosource->deviceCount(); i++) {
-        if(deviceBox->itemText(idx).compare(audiosource->name(i)) == 0)
-            audiosource->setSelectedDevice(i);
-    }
-//! [get-device]
-}
-
-void AudioRecorder::codecChanged(int idx)
-{
-    Q_UNUSED(idx);
-    //capture->setAudioCodec(codecsBox->itemText(idx));
-}
-
-void AudioRecorder::qualityChanged(int idx)
-{
-    Q_UNUSED(idx);
-    /*
-    if(capture->audioCodec().compare("audio/pcm") == 0) {
-        if(qualityBox->itemText(idx).compare("Low") == 0) {
-            // 8000Hz mono is 8kbps
-            capture->setAudioBitrate(8);
-        } else if(qualityBox->itemText(idx).compare("Medium") == 0) {
-            // 22050Hz mono is 44.1kbps
-            capture->setAudioBitrate(44);
-        } else if(qualityBox->itemText(idx).compare("High") == 0) {
-            // 44100Hz mono is 88.2kbps
-            capture->setAudioBitrate(88);
-        }
-    }
-    */
-}
-
-//! [toggle-record]
-void AudioRecorder::toggleRecord()
-{
-    if(!active) {
-        recTime->setText("0 sec");
-        currentTime = 0;
-        capture->record();
-
-        button->setText(tr("Stop"));
-        active = true;
-    } else {
-        capture->stop();
-        button->setText(tr("Record"));
-        active = false;
-    }
-}
-//! [toggle-record]
-
-void AudioRecorder::selectOutputFile()
-{
-    QStringList fileNames;
-
-    QFileDialog dialog(this);
-
-    dialog.setFileMode(QFileDialog::AnyFile);
-    if (dialog.exec())
-        fileNames = dialog.selectedFiles();
-
-    if(fileNames.size() > 0)
-        capture->setOutputLocation(QUrl(fileNames.first()));
-}
diff --git a/src/multimedia/doc/src/snippets/multimedia-snippets/camera.cpp b/src/multimedia/doc/src/snippets/multimedia-snippets/camera.cpp
deleted file mode 100644
index 757533b..0000000
--- a/src/multimedia/doc/src/snippets/multimedia-snippets/camera.cpp
+++ /dev/null
@@ -1,201 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the Qt Mobility Components.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/* Camera snippets */
-
-#include "qcamera.h"
-#include "qcameraviewfinder.h"
-#include "qmediarecorder.h"
-#include "qcameraimagecapture.h"
-#include "qcameraimageprocessing.h"
-#include "qabstractvideosurface.h"
-
-/* Globals so that everything is consistent. */
-QCamera *camera = 0;
-QCameraViewfinder *viewfinder = 0;
-QMediaRecorder *recorder = 0;
-QCameraImageCapture *imageCapture = 0;
-
-void overview_viewfinder()
-{
-    //! [Camera overview viewfinder]
-    camera = new QCamera;
-    viewfinder = new QCameraViewfinder;
-    camera->setViewfinder(viewfinder);
-    viewfinder->show();
-
-    camera->start(); // to start the viewfinder
-    //! [Camera overview viewfinder]
-}
-
-// -.-
-class MyVideoSurface : public QAbstractVideoSurface
-{
-    QList<QVideoFrame::PixelFormat> supportedPixelFormats(QAbstractVideoBuffer::HandleType handleType) const
-    {
-        Q_UNUSED(handleType);
-        return QList<QVideoFrame::PixelFormat>();
-    }
-    bool present(const QVideoFrame &frame)
-    {
-        Q_UNUSED(frame);
-        return true;
-    }
-};
-
-void overview_surface()
-{
-    MyVideoSurface *mySurface;
-    //! [Camera overview surface]
-    camera = new QCamera;
-    mySurface = new MyVideoSurface;
-    camera->setViewfinder(mySurface);
-
-    camera->start();
-    // MyVideoSurface::present(..) will be called with viewfinder frames
-    //! [Camera overview surface]
-}
-
-void overview_still()
-{
-    //! [Camera overview capture]
-    imageCapture = new QCameraImageCapture(camera);
-
-    camera->setCaptureMode(QCamera::CaptureStillImage);
-    camera->start(); // Viewfinder frames start flowing
-
-    //on half pressed shutter button
-    camera->searchAndLock();
-
-    //on shutter button pressed
-    imageCapture->capture();
-
-    //on shutter button released
-    camera->unlock();
-    //! [Camera overview capture]
-}
-
-void overview_movie()
-{
-    //! [Camera overview movie]
-    camera = new QCamera;
-    recorder = new QMediaRecorder(camera);
-
-    camera->setCaptureMode(QCamera::CaptureVideo);
-    camera->start();
-
-    //on shutter button pressed
-    recorder->record();
-
-    // sometime later, or on another press
-    recorder->stop();
-    //! [Camera overview movie]
-}
-
-void camera_blah()
-{
-    //! [Camera]
-    camera = new QCamera;
-
-    viewfinder = new QCameraViewfinder();
-    viewfinder->show();
-
-    camera->setViewfinder(viewfinder);
-
-    imageCapture = new QCameraImageCapture(camera);
-
-    camera->setCaptureMode(QCamera::CaptureStillImage);
-    camera->start();
-    //! [Camera]
-
-    //! [Camera keys]
-    //on half pressed shutter button
-    camera->searchAndLock();
-
-    //on shutter button pressed
-    imageCapture->capture();
-
-    //on shutter button released
-    camera->unlock();
-    //! [Camera keys]
-}
-
-void cameraimageprocessing()
-{
-    //! [Camera image whitebalance]
-    camera = new QCamera;
-    QCameraImageProcessing *imageProcessing = camera->imageProcessing();
-
-    if (imageProcessing->isAvailable()) {
-        imageProcessing->setWhiteBalanceMode(QCameraImageProcessing::WhiteBalanceFluorescent);
-    }
-    //! [Camera image whitebalance]
-
-    //! [Camera image denoising]
-    imageProcessing->setDenoisingLevel(-0.3); //reduce the amount of denoising applied
-    //! [Camera image denoising]
-}
-
-void camerafocus()
-{
-    //! [Camera custom zoom]
-    QCameraFocus *focus = camera->focus();
-    focus->setFocusPointMode(QCameraFocus::FocusPointCustom);
-    focus->setCustomFocusPoint(QPointF(0.25f, 0.75f)); // A point near the bottom left, 25% away from the corner, near that shiny vase
-    //! [Camera custom zoom]
-
-    //! [Camera combined zoom]
-    focus->zoomTo(3.0, 4.0); // Super zoom!
-    //! [Camera combined zoom]
-
-    //! [Camera focus zones]
-    focus->setFocusPointMode(QCameraFocus::FocusPointAuto);
-    QList<QCameraFocusZone> zones = focus->focusZones();
-    foreach (QCameraFocusZone zone, zones) {
-        if (zone.status() == QCameraFocusZone::Focused) {
-            // Draw a green box at zone.area()
-        } else if (zone.status() == QCameraFocusZone::Selected) {
-            // This area is selected for autofocusing, but is not in focus
-            // Draw a yellow box at zone.area()
-        }
-    }
-    //! [Camera focus zones]
-}
diff --git a/src/multimedia/doc/src/snippets/multimedia-snippets/media.cpp b/src/multimedia/doc/src/snippets/multimedia-snippets/media.cpp
deleted file mode 100644
index 300ad39..0000000
--- a/src/multimedia/doc/src/snippets/multimedia-snippets/media.cpp
+++ /dev/null
@@ -1,315 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the Qt Mobility Components.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/* Media related snippets */
-#include <QFile>
-#include <QTimer>
-
-#include "qmediaplaylist.h"
-#include "qmediarecorder.h"
-#include "qmediaservice.h"
-#include "qmediaplayercontrol.h"
-#include "qmediaplayer.h"
-#include "qradiotuner.h"
-#include "qradiodata.h"
-#include "qvideowidget.h"
-#include "qcameraimagecapture.h"
-#include "qcamera.h"
-#include "qcameraviewfinder.h"
-#include "qaudioprobe.h"
-#include "qaudiorecorder.h"
-#include "qvideoprobe.h"
-
-class MediaExample : public QObject {
-    Q_OBJECT
-
-    void MediaControl();
-    void MediaPlayer();
-    void RadioTuna();
-    void MediaRecorder();
-    void AudioRecorder();
-    void EncoderSettings();
-    void ImageEncoderSettings();
-    void AudioProbe();
-    void VideoProbe();
-
-private:
-    // Common naming
-    QMediaService *mediaService;
-    QVideoWidget *videoWidget;
-    QWidget *widget;
-    QMediaPlayer *player;
-    QMediaPlaylist *playlist;
-    QMediaContent video;
-    QMediaRecorder *recorder;
-    QCamera *camera;
-    QCameraViewfinder *viewfinder;
-    QCameraImageCapture *imageCapture;
-    QString fileName;
-    QRadioTuner *radio;
-    QRadioData *radioData;
-    QAudioRecorder *audioRecorder;
-    QAudioProbe *audioProbe;
-    QVideoProbe *videoProbe;
-
-    QMediaContent image1;
-    QMediaContent image2;
-    QMediaContent image3;
-
-    static const int yourRadioStationFrequency = 11;
-};
-
-void MediaExample::MediaControl()
-{
-    {
-    //! [Request control]
-    QMediaPlayerControl *control = qobject_cast<QMediaPlayerControl *>(
-            mediaService->requestControl("org.qt-project.qt.mediaplayercontrol/5.0"));
-    //! [Request control]
-    Q_UNUSED(control);
-    }
-
-    {
-    //! [Request control templated]
-    QMediaPlayerControl *control = mediaService->requestControl<QMediaPlayerControl *>();
-    //! [Request control templated]
-    Q_UNUSED(control);
-    }
-}
-
-
-void MediaExample::EncoderSettings()
-{
-    //! [Audio encoder settings]
-    QAudioEncoderSettings audioSettings;
-    audioSettings.setCodec("audio/mpeg");
-    audioSettings.setChannelCount(2);
-
-    recorder->setAudioSettings(audioSettings);
-    //! [Audio encoder settings]
-
-    //! [Video encoder settings]
-    QVideoEncoderSettings videoSettings;
-    videoSettings.setCodec("video/mpeg2");
-    videoSettings.setResolution(640, 480);
-
-    recorder->setVideoSettings(videoSettings);
-    //! [Video encoder settings]
-}
-
-void MediaExample::ImageEncoderSettings()
-{
-    //! [Image encoder settings]
-    QImageEncoderSettings imageSettings;
-    imageSettings.setCodec("image/jpeg");
-    imageSettings.setResolution(1600, 1200);
-
-    imageCapture->setEncodingSettings(imageSettings);
-    //! [Image encoder settings]
-}
-
-void MediaExample::MediaPlayer()
-{
-    //! [Player]
-    player = new QMediaPlayer;
-    connect(player, SIGNAL(positionChanged(qint64)), this, SLOT(positionChanged(qint64)));
-    player->setMedia(QUrl::fromLocalFile("/Users/me/Music/coolsong.mp3"));
-    player->setVolume(50);
-    player->play();
-    //! [Player]
-
-    //! [Local playback]
-    player = new QMediaPlayer;
-    // ...
-    player->setMedia(QUrl::fromLocalFile("/Users/me/Music/coolsong.mp3"));
-    player->setVolume(50);
-    player->play();
-    //! [Local playback]
-
-    //! [Audio playlist]
-    player = new QMediaPlayer;
-
-    playlist = new QMediaPlaylist(player);
-    playlist->addMedia(QUrl("http://example.com/myfile1.mp3"));
-    playlist->addMedia(QUrl("http://example.com/myfile2.mp3"));
-    // ...
-    playlist->setCurrentIndex(1);
-    player->play();
-    //! [Audio playlist]
-
-    //! [Movie playlist]
-    playlist = new QMediaPlaylist;
-    playlist->addMedia(QUrl("http://example.com/movie1.mp4"));
-    playlist->addMedia(QUrl("http://example.com/movie2.mp4"));
-    playlist->addMedia(QUrl("http://example.com/movie3.mp4"));
-    playlist->setCurrentIndex(1);
-
-    player = new QMediaPlayer;
-    player->setPlaylist(playlist);
-
-    videoWidget = new QVideoWidget;
-    player->setVideoOutput(videoWidget);
-    videoWidget->show();
-
-    player->play();
-    //! [Movie playlist]
-}
-
-void MediaExample::MediaRecorder()
-{
-    //! [Media recorder]
-    recorder = new QMediaRecorder(camera);
-
-    QAudioEncoderSettings audioSettings;
-    audioSettings.setCodec("audio/amr");
-    audioSettings.setQuality(QMultimedia::HighQuality);
-
-    recorder->setAudioSettings(audioSettings);
-
-    recorder->setOutputLocation(QUrl::fromLocalFile(fileName));
-    recorder->record();
-    //! [Media recorder]
-}
-
-void MediaExample::AudioRecorder()
-{
-    //! [Audio recorder]
-    audioRecorder = new QAudioRecorder;
-
-    QAudioEncoderSettings audioSettings;
-    audioSettings.setCodec("audio/amr");
-    audioSettings.setQuality(QMultimedia::HighQuality);
-
-    audioRecorder->setEncodingSettings(audioSettings);
-
-    audioRecorder->setOutputLocation(QUrl::fromLocalFile("test.amr"));
-    audioRecorder->record();
-    //! [Audio recorder]
-
-    //! [Audio recorder inputs]
-    QStringList inputs = audioRecorder->audioInputs();
-    QString selectedInput = audioRecorder->defaultAudioInput();
-
-    foreach (QString input, inputs) {
-        QString description = audioRecorder->audioInputDescription(input);
-        // show descriptions to user and allow selection
-        selectedInput = input;
-    }
-
-    audioRecorder->setAudioInput(selectedInput);
-    //! [Audio recorder inputs]
-}
-
-void MediaExample::RadioTuna()
-{
-    //! [Radio tuner]
-    radio = new QRadioTuner;
-    connect(radio, SIGNAL(frequencyChanged(int)), this, SLOT(freqChanged(int)));
-    if (radio->isBandSupported(QRadioTuner::FM)) {
-        radio->setBand(QRadioTuner::FM);
-        radio->setFrequency(yourRadioStationFrequency);
-        radio->setVolume(100);
-        radio->start();
-    }
-    //! [Radio tuner]
-
-    //! [Radio data setup]
-    radio = new QRadioTuner;
-    radioData = radio->radioData();
-    //! [Radio data setup]
-}
-
-void MediaExample::AudioProbe()
-{
-    //! [Audio probe]
-    audioRecorder = new QAudioRecorder;
-
-    QAudioEncoderSettings audioSettings;
-    audioSettings.setCodec("audio/amr");
-    audioSettings.setQuality(QMultimedia::HighQuality);
-
-    audioRecorder->setEncodingSettings(audioSettings);
-
-    audioRecorder->setOutputLocation(QUrl::fromLocalFile("test.amr"));
-
-    audioProbe = new QAudioProbe(this);
-    if (audioProbe->setSource(audioRecorder)) {
-        // Probing succeeded, audioProbe->isValid() should be true.
-        connect(audioProbe, SIGNAL(audioBufferProbed(QAudioBuffer)),
-                this, SLOT(calculateLevel(QAudioBuffer)));
-    }
-
-    audioRecorder->record();
-    // Now audio buffers being recorded should be signaled
-    // by the probe, so we can do things like calculating the
-    // audio power level, or performing a frequency transform
-    //! [Audio probe]
-}
-
-void MediaExample::VideoProbe()
-{
-    //! [Video probe]
-    camera = new QCamera;
-    viewfinder = new QCameraViewfinder();
-    camera->setViewfinder(viewfinder);
-
-    camera->setCaptureMode(QCamera::CaptureVideo);
-
-    videoProbe = new QVideoProbe(this);
-
-    if (videoProbe->setSource(camera)) {
-        // Probing succeeded, videoProbe->isValid() should be true.
-        connect(videoProbe, SIGNAL(videoFrameProbed(QVideoFrame)),
-                this, SLOT(detectBarcodes(QVideoFrame)));
-    }
-
-    camera->start();
-    // Viewfinder frames should now also be emitted by
-    // the video probe, even in still image capture mode.
-    // Another alternative is to install the probe on a
-    // QMediaRecorder connected to the camera to get the
-    // recorded frames, if they are different from the
-    // viewfinder frames.
-
-    //! [Video probe]
-}
-
-
diff --git a/src/multimedia/doc/src/snippets/multimedia-snippets/multimedia-snippets.pro b/src/multimedia/doc/src/snippets/multimedia-snippets/multimedia-snippets.pro
deleted file mode 100644
index 9571b02..0000000
--- a/src/multimedia/doc/src/snippets/multimedia-snippets/multimedia-snippets.pro
+++ /dev/null
@@ -1,24 +0,0 @@
-# Doc snippets - compiled for truthiness
-
-TEMPLATE = lib
-TARGET = qtmmksnippets
-
-INCLUDEPATH += ../../../../src/global \
-               ../../../../src/multimedia \
-               ../../../../src/multimedia/audio \
-               ../../../../src/multimedia/video \
-               ../../../../src/multimedia/camera
-
-CONFIG += console
-
-QT += multimedia multimediawidgets widgets multimedia-private
-
-SOURCES += \
-    audio.cpp \
-    video.cpp \
-    camera.cpp \
-    media.cpp \
-    qsound.cpp
-
-OTHER_FILES += \
-    soundeffect.qml
diff --git a/src/multimedia/doc/src/snippets/multimedia-snippets/qsound.cpp b/src/multimedia/doc/src/snippets/multimedia-snippets/qsound.cpp
deleted file mode 100644
index 1f7dad7..0000000
--- a/src/multimedia/doc/src/snippets/multimedia-snippets/qsound.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
- /****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the documentation of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:BSD$
-** You may use this file under the terms of the BSD license as follows:
-**
-** "Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are
-** met:
-**   * Redistributions of source code must retain the above copyright
-**     notice, this list of conditions and the following disclaimer.
-**   * Redistributions in binary form must reproduce the above copyright
-**     notice, this list of conditions and the following disclaimer in
-**     the documentation and/or other materials provided with the
-**     distribution.
-**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names
-**     of its contributors may be used to endorse or promote products derived
-**     from this software without specific prior written permission.
-**
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qobject.h"
-#include "qsound.h"
-#include "qsoundeffect.h"
-
-void qsoundsnippet() {
-    //! [0]
-    QSound::play("mysounds/bells.wav");
-    //! [0]
-
-
-    //! [1]
-    QSound bells("mysounds/bells.wav");
-    bells.play();
-    //! [1]
-}
-
-void qsoundeffectsnippet() {
-    //! [2]
-    QSoundEffect effect;
-    effect.setSource(QUrl::fromLocalFile("engine.wav"));
-    effect.setLoopCount(QSoundEffect::Infinite);
-    effect.setVolume(0.25f);
-    effect.play();
-    //! [2]
-}
-
-QObject *clickSource;
-
-class MyGame : public QObject {
-    Q_OBJECT
-public:
-    //! [3]
-    MyGame()
-        : m_explosion(this)
-    {
-        m_explosion.setSource(QUrl::fromLocalFile("explosion.wav"));
-        m_explosion.setVolume(0.25f);
-
-        // Set up click handling etc.
-        connect(clickSource, SIGNAL(clicked()), &m_explosion, SLOT(play()));
-    }
-private:
-    QSoundEffect m_explosion;
-    //! [3]
-};
diff --git a/src/multimedia/doc/src/snippets/multimedia-snippets/soundeffect.qml b/src/multimedia/doc/src/snippets/multimedia-snippets/soundeffect.qml
deleted file mode 100644
index 9b173a4..0000000
--- a/src/multimedia/doc/src/snippets/multimedia-snippets/soundeffect.qml
+++ /dev/null
@@ -1,63 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-//! [complete snippet]
-import QtQuick 2.0
-import QtMultimedia 5.0
-
-Text {
-    text: "Click Me!";
-    font.pointSize: 24;
-    width: 150; height: 50;
-
-    //! [play sound on click]
-    SoundEffect {
-        id: playSound
-        source: "soundeffect.wav"
-    }
-    MouseArea {
-        id: playArea
-        anchors.fill: parent
-        onPressed: { playSound.play() }
-    }
-    //! [play sound on click]
-}
-//! [complete snippet]
diff --git a/src/multimedia/doc/src/snippets/multimedia-snippets/video.cpp b/src/multimedia/doc/src/snippets/multimedia-snippets/video.cpp
deleted file mode 100644
index 37dca08..0000000
--- a/src/multimedia/doc/src/snippets/multimedia-snippets/video.cpp
+++ /dev/null
@@ -1,193 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the Qt Mobility Components.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/* Video related snippets */
-#include "qvideorenderercontrol.h"
-#include "qmediaservice.h"
-#include "qmediaplayer.h"
-#include "qabstractvideosurface.h"
-#include "qvideowidgetcontrol.h"
-#include "qvideowindowcontrol.h"
-#include "qgraphicsvideoitem.h"
-#include "qmediaplaylist.h"
-#include "qvideosurfaceformat.h"
-
-#include <QFormLayout>
-#include <QGraphicsView>
-
-//! [Derived Surface]
-class MyVideoSurface : public QAbstractVideoSurface
-{
-    QList<QVideoFrame::PixelFormat> supportedPixelFormats(
-            QAbstractVideoBuffer::HandleType handleType = QAbstractVideoBuffer::NoHandle) const
-    {
-        Q_UNUSED(handleType);
-
-        // Return the formats you will support
-        return QList<QVideoFrame::PixelFormat>() << QVideoFrame::Format_RGB565;
-    }
-
-    bool present(const QVideoFrame &frame)
-    {
-        Q_UNUSED(frame);
-        // Handle the frame and do your processing
-
-        return true;
-    }
-};
-//! [Derived Surface]
-
-//! [Video producer]
-class MyVideoProducer : public QObject
-{
-    Q_OBJECT
-    Q_PROPERTY(QAbstractVideoSurface *videoSurface WRITE setVideoSurface)
-
-public:
-    void setVideoSurface(QAbstractVideoSurface *surface)
-    {
-        m_surface = surface;
-        m_surface->start(m_format);
-    }
-
-    // ...
-
-public slots:
-    void onNewVideoContentReceived(const QVideoFrame &frame)
-    {
-        if (m_surface)
-            m_surface->present(frame);
-    }
-
-private:
-    QAbstractVideoSurface *m_surface;
-    QVideoSurfaceFormat m_format;
-};
-
-//! [Video producer]
-
-
-class VideoExample : public QObject {
-    Q_OBJECT
-public:
-    void VideoGraphicsItem();
-    void VideoRendererControl();
-    void VideoWidget();
-    void VideoWindowControl();
-    void VideoWidgetControl();
-
-private:
-    // Common naming
-    QMediaService *mediaService;
-    QMediaPlaylist *playlist;
-    QVideoWidget *videoWidget;
-    QWidget *widget;
-    QFormLayout *layout;
-    QAbstractVideoSurface *myVideoSurface;
-    QMediaPlayer *player;
-    QMediaContent video;
-    QGraphicsView *graphicsView;
-};
-
-void VideoExample::VideoRendererControl()
-{
-    //! [Video renderer control]
-    QVideoRendererControl *rendererControl = mediaService->requestControl<QVideoRendererControl *>();
-    rendererControl->setSurface(myVideoSurface);
-    //! [Video renderer control]
-}
-
-void VideoExample::VideoWidget()
-{
-    //! [Video widget]
-    player = new QMediaPlayer;
-
-    playlist = new QMediaPlaylist(player);
-    playlist->addMedia(QUrl("http://example.com/myclip1.mp4"));
-    playlist->addMedia(QUrl("http://example.com/myclip2.mp4"));
-
-    videoWidget = new QVideoWidget;
-    player->setVideoOutput(videoWidget);
-
-    videoWidget->show();
-    playlist->setCurrentIndex(1);
-    player->play();
-    //! [Video widget]
-
-    player->stop();
-
-    //! [Setting surface in player]
-    player->setVideoOutput(myVideoSurface);
-    //! [Setting surface in player]
-}
-
-void VideoExample::VideoWidgetControl()
-{
-    //! [Video widget control]
-    QVideoWidgetControl *widgetControl = mediaService->requestControl<QVideoWidgetControl *>();
-    layout->addWidget(widgetControl->videoWidget());
-    //! [Video widget control]
-}
-
-void VideoExample::VideoWindowControl()
-{
-    //! [Video window control]
-    QVideoWindowControl *windowControl = mediaService->requestControl<QVideoWindowControl *>();
-    windowControl->setWinId(widget->winId());
-    windowControl->setDisplayRect(widget->rect());
-    windowControl->setAspectRatioMode(Qt::KeepAspectRatio);
-    //! [Video window control]
-}
-
-void VideoExample::VideoGraphicsItem()
-{
-    //! [Video graphics item]
-    player = new QMediaPlayer(this);
-
-    QGraphicsVideoItem *item = new QGraphicsVideoItem;
-    player->setVideoOutput(item);
-    graphicsView->scene()->addItem(item);
-    graphicsView->show();
-
-    player->setMedia(QUrl("http://example.com/myclip4.ogv"));
-    player->play();
-    //! [Video graphics item]
-}
diff --git a/src/multimedia/doc/src/snippets/snippets.pro b/src/multimedia/doc/src/snippets/snippets.pro
deleted file mode 100644
index 31a3a09..0000000
--- a/src/multimedia/doc/src/snippets/snippets.pro
+++ /dev/null
@@ -1,3 +0,0 @@
-TEMPLATE = subdirs
-
-SUBDIRS += multimedia-snippets
diff --git a/src/multimedia/doc/src/videooverview.qdoc b/src/multimedia/doc/src/videooverview.qdoc
index f0d8de0..45ea87f 100644
--- a/src/multimedia/doc/src/videooverview.qdoc
+++ b/src/multimedia/doc/src/videooverview.qdoc
@@ -47,10 +47,10 @@ You can use the \l QMediaPlayer class to decode a video file, and display
 it using \l QVideoWidget, \l QGraphicsVideoItem, or a custom class.
 
 Here's an example of using QVideoWidget:
-    \snippet doc/src/snippets/multimedia-snippets/video.cpp Video widget
+    \snippet multimedia-snippets/video.cpp Video widget
 
 And an example with QGraphicsVideoItem:
-    \snippet doc/src/snippets/multimedia-snippets/video.cpp Video graphics item
+    \snippet multimedia-snippets/video.cpp Video graphics item
 
 \section2 Playing Video in QML
 
@@ -77,12 +77,12 @@ processing, while deriving a class from \l QAbstractVideoSurface
 allows you to receive these frames from \l QMediaPlayer and
 \l QCamera.
 
-\snippet doc/src/snippets/multimedia-snippets/video.cpp Derived Surface
+\snippet multimedia-snippets/video.cpp Derived Surface
 
 and with an instance of this surface, \c myVideoSurface, you can set
 the surface as the \l {QMediaPlayer::setVideoOutput()}{video output} for QMediaPlayer.
 
-\snippet doc/src/snippets/multimedia-snippets/video.cpp Setting surface in player
+\snippet multimedia-snippets/video.cpp Setting surface in player
 
 Several of the built-in Qt classes offer this functionality
 as well, so if you decode video in your application, you can present
@@ -97,7 +97,7 @@ The following snippet shows a class that has a writable \c videoSurface property
 and receives frames through a public slot \c onNewVideoContentReceived(). These
 frames are then presented on the surface set in \c setVideoSurface().
 
-\snippet doc/src/snippets/multimedia-snippets/video.cpp Video producer
+\snippet multimedia-snippets/video.cpp Video producer
 
 \section2 Recording Video
 You can use the \l QMediaRecorder class in conjunction with other
@@ -116,7 +116,7 @@ the video frames using this class, and they may arrive at a slightly
 different time than they are being rendered.
 
 Here's an example of installing a video probe while recording the camera:
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Video probe
+    \snippet multimedia-snippets/media.cpp Video probe
 
 \section1 Examples
 
diff --git a/src/multimedia/qmediacontrol.cpp b/src/multimedia/qmediacontrol.cpp
index 5933ce4..13a6681 100644
--- a/src/multimedia/qmediacontrol.cpp
+++ b/src/multimedia/qmediacontrol.cpp
@@ -68,14 +68,14 @@ QT_BEGIN_NAMESPACE
     the \l {QMediaService::requestControl()} member of QMediaService.  If the
     service doesn't implement a control it will instead return a null pointer.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Request control
+    \snippet multimedia-snippets/media.cpp Request control
 
     Alternatively if the IId of the control has been declared using
     Q_MEDIA_DECLARE_CONTROL the template version of
     QMediaService::requestControl() can be used to request the service without
     explicitly passing the IId or using qobject_cast().
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Request control templated
+    \snippet multimedia-snippets/media.cpp Request control templated
 
     Most application code will not interface directly with a media service's
     controls, instead the QMediaObject which owns the service acts as an
@@ -95,7 +95,7 @@ QT_BEGIN_NAMESPACE
     be requested from QMediaService::requestControl() without explicitly
     passing the IId.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Request control templated
+    \snippet multimedia-snippets/media.cpp Request control templated
 
     \sa QMediaService::requestControl()
 */
diff --git a/src/multimedia/qmediaservice.cpp b/src/multimedia/qmediaservice.cpp
index c21e1df..6e68e9d 100644
--- a/src/multimedia/qmediaservice.cpp
+++ b/src/multimedia/qmediaservice.cpp
@@ -71,7 +71,7 @@ QT_BEGIN_NAMESPACE
     A pointer to media service's QMediaControl implementation can be obtained
     by passing the control's interface name to the requestControl() function.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Request control
+    \snippet multimedia-snippets/media.cpp Request control
 
     Media objects can use services loaded dynamically from plug-ins or
     implemented statically within an applications.  Plug-in based services
diff --git a/src/multimedia/radio/qradiodata.cpp b/src/multimedia/radio/qradiodata.cpp
index f6d3808..5692248 100644
--- a/src/multimedia/radio/qradiodata.cpp
+++ b/src/multimedia/radio/qradiodata.cpp
@@ -78,7 +78,7 @@ namespace
     You can get a QRadioData instance fromt the \l{QRadioTuner::radioData()}{radioData}
     property from a QRadioTuner instance.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Radio data setup
+    \snippet multimedia-snippets/media.cpp Radio data setup
 
     Alternatively, you can pass an instance of QRadioTuner to the constructor to QRadioData.
 
diff --git a/src/multimedia/radio/qradiotuner.cpp b/src/multimedia/radio/qradiotuner.cpp
index d9d9cb6..a0cbb58 100644
--- a/src/multimedia/radio/qradiotuner.cpp
+++ b/src/multimedia/radio/qradiotuner.cpp
@@ -79,7 +79,7 @@ namespace
 
     You can control the systems analog radio device using this interface, for example:
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Radio tuner
+    \snippet multimedia-snippets/media.cpp Radio tuner
 
     The radio object will emit signals for any changes in state such as:
     bandChanged(), frequencyChanged(), stereoStatusChanged(), searchingChanged(),
diff --git a/src/multimedia/recording/qaudiorecorder.cpp b/src/multimedia/recording/qaudiorecorder.cpp
index 25225e5..71fd219 100644
--- a/src/multimedia/recording/qaudiorecorder.cpp
+++ b/src/multimedia/recording/qaudiorecorder.cpp
@@ -66,11 +66,11 @@ QT_BEGIN_NAMESPACE
     The QAudioRecorder class is a high level media recording class and contains
     the same functionality as \l QMediaRecorder.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio recorder
+    \snippet multimedia-snippets/media.cpp Audio recorder
 
     In addition QAudioRecorder provides functionality for selecting the audio input.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio recorder inputs
+    \snippet multimedia-snippets/media.cpp Audio recorder inputs
 
     The \l {audiorecorder}{Audio Recorder} example shows how to use this class
     in more detail.
diff --git a/src/multimedia/recording/qmediaencodersettings.cpp b/src/multimedia/recording/qmediaencodersettings.cpp
index 8f8287f..1c0f532 100644
--- a/src/multimedia/recording/qmediaencodersettings.cpp
+++ b/src/multimedia/recording/qmediaencodersettings.cpp
@@ -111,7 +111,7 @@ private:
     and then passing it to a QMediaRecorder instance using the
     QMediaRecorder::setEncodingSettings() function.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio encoder settings
+    \snippet multimedia-snippets/media.cpp Audio encoder settings
 
     \sa QMediaRecorder, QAudioEncoderSettingsControl
 */
@@ -425,7 +425,7 @@ private:
     and then passing it to a QMediaRecorder instance using the
     QMediaRecorder::setEncodingSettings() function.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Video encoder settings
+    \snippet multimedia-snippets/media.cpp Video encoder settings
 
     \sa QMediaRecorder, QVideoEncoderSettingsControl
 */
@@ -751,7 +751,7 @@ private:
     properties and then passing it to a QCameraImageCapture instance using the
     QCameraImageCapture::setImageSettings() function.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Image encoder settings
+    \snippet multimedia-snippets/media.cpp Image encoder settings
 
     \sa QImageEncoderControl
 */
diff --git a/src/multimedia/recording/qmediarecorder.cpp b/src/multimedia/recording/qmediarecorder.cpp
index dd303a1..79d70e4 100644
--- a/src/multimedia/recording/qmediarecorder.cpp
+++ b/src/multimedia/recording/qmediarecorder.cpp
@@ -75,7 +75,7 @@ QT_BEGIN_NAMESPACE
     intended to be used alone but for accessing the media recording functions
     of other media objects, like QRadioTuner, or QCamera.
 
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Media recorder
+    \snippet multimedia-snippets/media.cpp Media recorder
 
     \sa QAudioRecorder
 */