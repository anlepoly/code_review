diff --git a/src/imports/audioengine/audioengine.cpp b/src/imports/audioengine/audioengine.cpp
index 0536847..da0c6df 100644
--- a/src/imports/audioengine/audioengine.cpp
+++ b/src/imports/audioengine/audioengine.cpp
@@ -58,6 +58,8 @@ QT_BEGIN_NAMESPACE
 class QAudioEngineDeclarativeModule : public QQmlExtensionPlugin
 {
     Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QQmlExtensionInterface/1.0")
+
 public:
     virtual void registerTypes(const char *uri)
     {
@@ -81,5 +83,3 @@ QT_END_NAMESPACE
 
 #include "audioengine.moc"
 
-Q_EXPORT_PLUGIN2("QtAudioEngine", QT_PREPEND_NAMESPACE(QAudioEngineDeclarativeModule));
-
diff --git a/src/imports/multimedia/multimedia.cpp b/src/imports/multimedia/multimedia.cpp
index 62eb1d4..57ee6c1 100644
--- a/src/imports/multimedia/multimedia.cpp
+++ b/src/imports/multimedia/multimedia.cpp
@@ -66,6 +66,8 @@ QT_BEGIN_NAMESPACE
 class QMultimediaDeclarativeModule : public QQmlExtensionPlugin
 {
     Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QQmlExtensionInterface/1.0")
+
 public:
     virtual void registerTypes(const char *uri)
     {
@@ -129,5 +131,3 @@ QT_END_NAMESPACE
 
 #include "multimedia.moc"
 
-Q_EXPORT_PLUGIN2(qmultimediadeclarativemodule, QT_PREPEND_NAMESPACE(QMultimediaDeclarativeModule));
-
diff --git a/src/imports/multimedia/qdeclarativevideooutput.cpp b/src/imports/multimedia/qdeclarativevideooutput.cpp
index ae8064b..235b217 100644
--- a/src/imports/multimedia/qdeclarativevideooutput.cpp
+++ b/src/imports/multimedia/qdeclarativevideooutput.cpp
@@ -40,7 +40,6 @@
 ****************************************************************************/
 #include "qdeclarativevideooutput_p.h"
 
-#include <private/qsgvideonode_p.h>
 #include "qsgvideonode_i420.h"
 #include "qsgvideonode_rgb.h"
 
@@ -60,7 +59,7 @@ Q_DECLARE_METATYPE(QAbstractVideoSurface*)
 QT_BEGIN_NAMESPACE
 
 Q_GLOBAL_STATIC_WITH_ARGS(QMediaPluginLoader, videoNodeFactoryLoader,
-        (QSGVideoNodeFactory_iid, QLatin1String("video"), Qt::CaseInsensitive))
+        (QSGVideoNodeFactoryInterface_iid, QLatin1String("video"), Qt::CaseInsensitive))
 
 class QSGVideoItemSurface : public QAbstractVideoSurface
 {
@@ -79,7 +78,7 @@ public:
     {
         QList<QVideoFrame::PixelFormat> formats;
 
-        foreach (QSGVideoNodeFactory* factory, m_item->m_videoNodeFactories) {
+        foreach (QSGVideoNodeFactoryInterface* factory, m_item->m_videoNodeFactories) {
             formats.append(factory->supportedPixelFormats(handleType));
         }
 
@@ -177,7 +176,7 @@ QDeclarativeVideoOutput::QDeclarativeVideoOutput(QQuickItem *parent) :
             this, SLOT(_q_updateNativeSize(QVideoSurfaceFormat)), Qt::QueuedConnection);
 
     foreach (QObject *instance, videoNodeFactoryLoader()->instances(QSGVideoNodeFactoryPluginKey)) {
-        QSGVideoNodeFactory* plugin = qobject_cast<QSGVideoNodeFactory*>(instance);
+        QSGVideoNodeFactoryInterface* plugin = qobject_cast<QSGVideoNodeFactoryInterface*>(instance);
         if (plugin) {
             m_videoNodeFactories.append(plugin);
         }
@@ -758,7 +757,7 @@ QSGNode *QDeclarativeVideoOutput::updatePaintNode(QSGNode *oldNode, UpdatePaintN
     }
 
     if (videoNode == 0) {
-        foreach (QSGVideoNodeFactory* factory, m_videoNodeFactories) {
+        foreach (QSGVideoNodeFactoryInterface* factory, m_videoNodeFactories) {
             videoNode = factory->createNode(m_surface->surfaceFormat());
             if (videoNode)
                 break;
diff --git a/src/imports/multimedia/qdeclarativevideooutput_p.h b/src/imports/multimedia/qdeclarativevideooutput_p.h
index 13710b1..7959d12 100644
--- a/src/imports/multimedia/qdeclarativevideooutput_p.h
+++ b/src/imports/multimedia/qdeclarativevideooutput_p.h
@@ -138,7 +138,7 @@ private:
     QWeakPointer<QMediaService> m_service;
     QWeakPointer<QVideoRendererControl> m_rendererControl;
 
-    QList<QSGVideoNodeFactory*> m_videoNodeFactories;
+    QList<QSGVideoNodeFactoryInterface*> m_videoNodeFactories;
     QSGVideoItemSurface *m_surface;
     QVideoFrame m_frame;
     FillMode m_fillMode;
diff --git a/src/imports/multimedia/qsgvideonode_i420.cpp b/src/imports/multimedia/qsgvideonode_i420.cpp
index 3ee9e85..ef075eb 100644
--- a/src/imports/multimedia/qsgvideonode_i420.cpp
+++ b/src/imports/multimedia/qsgvideonode_i420.cpp
@@ -65,11 +65,6 @@ QSGVideoNode *QSGVideoNodeFactory_I420::createNode(const QVideoSurfaceFormat &fo
     return 0;
 }
 
-QStringList QSGVideoNodeFactory_I420::keys() const
-{
-    return QStringList() << QSGVideoNodeFactoryPluginKey;
-}
-
 
 class QSGVideoMaterialShader_YUV420 : public QSGMaterialShader
 {
diff --git a/src/imports/multimedia/qsgvideonode_i420.h b/src/imports/multimedia/qsgvideonode_i420.h
index 4ab1139..a4d26ad 100644
--- a/src/imports/multimedia/qsgvideonode_i420.h
+++ b/src/imports/multimedia/qsgvideonode_i420.h
@@ -64,11 +64,10 @@ private:
     QSGVideoMaterial_YUV420 *m_material;
 };
 
-class QSGVideoNodeFactory_I420 : public QSGVideoNodeFactory {
+class QSGVideoNodeFactory_I420 : public QSGVideoNodeFactoryInterface {
 public:
     QList<QVideoFrame::PixelFormat> supportedPixelFormats(QAbstractVideoBuffer::HandleType handleType) const;
     QSGVideoNode *createNode(const QVideoSurfaceFormat &format);
-    QStringList keys() const;
 };
 
 
diff --git a/src/imports/multimedia/qsgvideonode_rgb.cpp b/src/imports/multimedia/qsgvideonode_rgb.cpp
index 30ebd54..b7fd9c7 100644
--- a/src/imports/multimedia/qsgvideonode_rgb.cpp
+++ b/src/imports/multimedia/qsgvideonode_rgb.cpp
@@ -70,11 +70,6 @@ QSGVideoNode *QSGVideoNodeFactory_RGB::createNode(const QVideoSurfaceFormat &for
     return 0;
 }
 
-QStringList QSGVideoNodeFactory_RGB::keys() const
-{
-    return QStringList() << QSGVideoNodeFactoryPluginKey;
-}
-
 
 class QSGVideoMaterialShader_RGB : public QSGMaterialShader
 {
diff --git a/src/imports/multimedia/qsgvideonode_rgb.h b/src/imports/multimedia/qsgvideonode_rgb.h
index d436535..60d42d6 100644
--- a/src/imports/multimedia/qsgvideonode_rgb.h
+++ b/src/imports/multimedia/qsgvideonode_rgb.h
@@ -64,11 +64,10 @@ private:
     QVideoFrame m_frame;
 };
 
-class QSGVideoNodeFactory_RGB : public QSGVideoNodeFactory {
+class QSGVideoNodeFactory_RGB : public QSGVideoNodeFactoryInterface {
 public:
     QList<QVideoFrame::PixelFormat> supportedPixelFormats(QAbstractVideoBuffer::HandleType handleType) const;
     QSGVideoNode *createNode(const QVideoSurfaceFormat &format);
-    QStringList keys() const;
 };
 
 
diff --git a/src/multimedia/audio/audio.pri b/src/multimedia/audio/audio.pri
index a2cdaa3..b58ecbb 100644
--- a/src/multimedia/audio/audio.pri
+++ b/src/multimedia/audio/audio.pri
@@ -16,7 +16,6 @@ PUBLIC_HEADERS += \
 PRIVATE_HEADERS += \
            audio/qaudiobuffer_p.h \
            audio/qaudiodevicefactory_p.h \
-           audio/qaudiopluginloader_p.h \
            audio/qwavedecoder_p.h \
            audio/qsamplecache_p.h \
            audio/qaudiodecoder_p.h
@@ -30,7 +29,6 @@ SOURCES += \
            audio/qaudiosystemplugin.cpp \
            audio/qaudiosystem.cpp \
            audio/qaudiodevicefactory.cpp \
-           audio/qaudiopluginloader.cpp \
            audio/qsoundeffect.cpp \
            audio/qwavedecoder_p.cpp \
            audio/qsamplecache_p.cpp \
diff --git a/src/multimedia/audio/qaudiodevicefactory.cpp b/src/multimedia/audio/qaudiodevicefactory.cpp
index 9dcf8b1..24972dd 100644
--- a/src/multimedia/audio/qaudiodevicefactory.cpp
+++ b/src/multimedia/audio/qaudiodevicefactory.cpp
@@ -44,7 +44,7 @@
 #include "qaudiosystem.h"
 #include "qaudiosystemplugin.h"
 
-#include "qaudiopluginloader_p.h"
+#include "qmediapluginloader_p.h"
 #include "qaudiodevicefactory_p.h"
 
 #ifndef QT_NO_AUDIO_BACKEND
@@ -66,8 +66,8 @@
 QT_BEGIN_NAMESPACE
 
 #if !defined (QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-Q_GLOBAL_STATIC_WITH_ARGS(QAudioPluginLoader, audioLoader,
-        (QAudioSystemFactoryInterface_iid, QLatin1String("/audio"), Qt::CaseInsensitive))
+Q_GLOBAL_STATIC_WITH_ARGS(QMediaPluginLoader, audioLoader,
+        (QAudioSystemFactoryInterface_iid, QLatin1String("audio"), Qt::CaseInsensitive))
 #endif
 
 class QNullDeviceInfo : public QAbstractAudioDeviceInfo
@@ -142,15 +142,13 @@ QList<QAudioDeviceInfo> QAudioDeviceFactory::availableDevices(QAudio::Mode mode)
 #endif
 
 #if !defined (QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
-    QAudioPluginLoader* l = audioLoader();
+    QMediaPluginLoader* l = audioLoader();
     foreach (const QString& key, l->keys()) {
         QAudioSystemFactoryInterface* plugin = qobject_cast<QAudioSystemFactoryInterface*>(l->instance(key));
         if (plugin) {
             foreach (QByteArray const& handle, plugin->availableDevices(mode))
                 devices << QAudioDeviceInfo(key, handle, mode);
         }
-
-        delete plugin;
     }
 #endif
 
diff --git a/src/multimedia/audio/qaudiopluginloader.cpp b/src/multimedia/audio/qaudiopluginloader.cpp
deleted file mode 100644
index 0ef3c45..0000000
--- a/src/multimedia/audio/qaudiopluginloader.cpp
+++ /dev/null
@@ -1,176 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qaudiosystemplugin.h"
-#include "qaudiopluginloader_p.h"
-
-#include <QtCore/qcoreapplication.h>
-#include <QtCore/qpluginloader.h>
-#include <QtCore/qfactoryinterface.h>
-#include <QtCore/qdir.h>
-#include <QtCore/qdebug.h>
-
-QT_BEGIN_NAMESPACE
-
-QAudioPluginLoader::QAudioPluginLoader(const char *iid, const QString &location, Qt::CaseSensitivity):
-    m_iid(iid)
-{
-    m_location = location + QLatin1Char('/');
-    load();
-}
-
-QAudioPluginLoader::~QAudioPluginLoader()
-{
-    for (int i = 0; i < m_plugins.count(); i++ ) {
-        delete m_plugins.at(i);
-    }
-}
-
-QStringList QAudioPluginLoader::pluginList() const
-{
-#if !defined QT_NO_DEBUG
-    const bool showDebug = qgetenv("QT_DEBUG_PLUGINS").toInt() > 0;
-#endif
-
-    QStringList paths = QCoreApplication::libraryPaths();
-#ifdef QTM_PLUGIN_PATH
-    paths << QLatin1String(QTM_PLUGIN_PATH);
-#endif
-#if !defined QT_NO_DEBUG
-    if (showDebug)
-        qDebug() << "Plugin paths:" << paths;
-#endif
-
-    //temp variable to avoid multiple identic path
-    QSet<QString> processed;
-
-    /* Discover a bunch o plugins */
-    QStringList plugins;
-
-    /* Enumerate our plugin paths */
-    for (int i=0; i < paths.count(); i++) {
-        if (processed.contains(paths.at(i)))
-            continue;
-        processed.insert(paths.at(i));
-        QDir pluginsDir(paths.at(i)+m_location);
-        if (!pluginsDir.exists())
-            continue;
-
-        QStringList files = pluginsDir.entryList(QDir::Files);
-#if !defined QT_NO_DEBUG
-        if (showDebug)
-            qDebug()<<"Looking for plugins in "<<pluginsDir.path()<<files;
-#endif
-        for (int j=0; j < files.count(); j++) {
-            const QString &file = files.at(j);
-            plugins <<  pluginsDir.absoluteFilePath(file);
-        }
-    }
-    return  plugins;
-}
-
-QStringList QAudioPluginLoader::keys() const
-{
-    QMutexLocker locker(const_cast<QMutex *>(&m_mutex));
-
-    QStringList list;
-    for (int i = 0; i < m_plugins.count(); i++) {
-        QAudioSystemPlugin* p = qobject_cast<QAudioSystemPlugin*>(m_plugins.at(i)->instance());
-        if (p) list << p->keys();
-    }
-
-    return list;
-}
-
-QObject* QAudioPluginLoader::instance(QString const &key)
-{
-    QMutexLocker locker(&m_mutex);
-
-    for (int i = 0; i < m_plugins.count(); i++) {
-        QAudioSystemPlugin* p = qobject_cast<QAudioSystemPlugin*>(m_plugins.at(i)->instance());
-        if (p && p->keys().contains(key))
-            return m_plugins.at(i)->instance();
-    }
-    return 0;
-}
-
-QList<QObject*> QAudioPluginLoader::instances(QString const &key)
-{
-    QMutexLocker locker(&m_mutex);
-
-    QList<QObject*> list;
-    for (int i = 0; i < m_plugins.count(); i++) {
-        QAudioSystemPlugin* p = qobject_cast<QAudioSystemPlugin*>(m_plugins.at(i)->instance());
-        if (p && p->keys().contains(key))
-            list << m_plugins.at(i)->instance();
-    }
-    return list;
-}
-
-void QAudioPluginLoader::load()
-{
-    if (!m_plugins.isEmpty())
-        return;
-
-#if !defined QT_NO_DEBUG
-    const bool showDebug = qgetenv("QT_DEBUG_PLUGINS").toInt() > 0;
-#endif
-
-    QStringList plugins = pluginList();
-    for (int i=0; i < plugins.count(); i++) {
-        QPluginLoader* loader = new QPluginLoader(plugins.at(i));
-        QObject *o = loader->instance();
-        if (o != 0 && o->qt_metacast(m_iid) != 0) {
-            m_plugins.append(loader);
-        } else {
-#if !defined QT_NO_DEBUG
-            if (showDebug)
-                qWarning() << "QAudioPluginLoader: Failed to load plugin: "
-                           << plugins.at(i) << loader->errorString();
-#endif
-            delete o;
-            //we are not calling loader->unload here for it may cause problem on some device
-            delete loader;
-        }
-    }
-}
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/audio/qaudiopluginloader_p.h b/src/multimedia/audio/qaudiopluginloader_p.h
deleted file mode 100644
index cb30c38..0000000
--- a/src/multimedia/audio/qaudiopluginloader_p.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QAUDIOPLUGINLOADER_H
-#define QAUDIOPLUGINLOADER_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <qtmultimediadefs.h>
-#include <QObject>
-#include <QtCore/qstring.h>
-#include <QtCore/qmap.h>
-#include <QtCore/qmutex.h>
-#include <QtCore/qpluginloader.h>
-
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QAudioPluginLoader
-{
-public:
-    QAudioPluginLoader(const char *iid,
-                   const QString &suffix = QString(),
-                   Qt::CaseSensitivity = Qt::CaseSensitive);
-
-    ~QAudioPluginLoader();
-
-    QStringList keys() const;
-    QObject* instance(QString const &key);
-    QList<QObject*> instances(QString const &key);
-
-private:
-    QStringList pluginList() const;
-    void load();
-
-    QMutex m_mutex;
-
-    QByteArray  m_iid;
-    QString     m_location;
-    QList<QPluginLoader*> m_plugins;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QAUDIOPLUGINLOADER_H
diff --git a/src/multimedia/audio/qaudiosystemplugin.h b/src/multimedia/audio/qaudiosystemplugin.h
index 232d8a5..d48d89c 100644
--- a/src/multimedia/audio/qaudiosystemplugin.h
+++ b/src/multimedia/audio/qaudiosystemplugin.h
@@ -45,7 +45,6 @@
 
 #include <QtCore/qstring.h>
 #include <QtCore/qplugin.h>
-#include <QtCore/qfactoryinterface.h>
 
 #include <qtmultimediadefs.h>
 #include <qtmedianamespace.h>
@@ -61,7 +60,7 @@ QT_BEGIN_NAMESPACE
 QT_MODULE(Multimedia)
 
 
-struct Q_MULTIMEDIA_EXPORT QAudioSystemFactoryInterface : public QFactoryInterface
+struct Q_MULTIMEDIA_EXPORT QAudioSystemFactoryInterface
 {
     virtual QList<QByteArray> availableDevices(QAudio::Mode) const = 0;
     virtual QAbstractAudioInput* createInput(const QByteArray& device) = 0;
@@ -76,13 +75,12 @@ Q_DECLARE_INTERFACE(QAudioSystemFactoryInterface, QAudioSystemFactoryInterface_i
 class Q_MULTIMEDIA_EXPORT QAudioSystemPlugin : public QObject, public QAudioSystemFactoryInterface
 {
     Q_OBJECT
-    Q_INTERFACES(QAudioSystemFactoryInterface:QFactoryInterface)
+    Q_INTERFACES(QAudioSystemFactoryInterface)
 
 public:
     QAudioSystemPlugin(QObject *parent = 0);
     ~QAudioSystemPlugin();
 
-    virtual QStringList keys() const = 0;
     virtual QList<QByteArray> availableDevices(QAudio::Mode) const = 0;
     virtual QAbstractAudioInput* createInput(const QByteArray& device) = 0;
     virtual QAbstractAudioOutput* createOutput(const QByteArray& device) = 0;
diff --git a/src/multimedia/gsttools_headers/qgstbufferpoolinterface_p.h b/src/multimedia/gsttools_headers/qgstbufferpoolinterface_p.h
index 3e2430e..7bb906a 100644
--- a/src/multimedia/gsttools_headers/qgstbufferpoolinterface_p.h
+++ b/src/multimedia/gsttools_headers/qgstbufferpoolinterface_p.h
@@ -57,7 +57,6 @@
 #include <qvideosurfaceformat.h>
 #include <QtCore/qobject.h>
 #include <QtCore/qplugin.h>
-#include <QtCore/qfactoryinterface.h>
 
 #include <gst/gst.h>
 
@@ -68,7 +67,7 @@ const QLatin1String QGstBufferPoolPluginKey("bufferpool");
 /*!
     Abstract interface for video buffers allocation.
 */
-class QGstBufferPoolInterface : public QFactoryInterface
+class QGstBufferPoolInterface
 {
 public:
     virtual ~QGstBufferPoolInterface() {}
@@ -96,7 +95,7 @@ Q_DECLARE_INTERFACE(QGstBufferPoolInterface, QGstBufferPoolInterface_iid)
 class QGstBufferPoolPlugin : public QObject, public QGstBufferPoolInterface
 {
     Q_OBJECT
-    Q_INTERFACES(QGstBufferPoolInterface:QFactoryInterface)
+    Q_INTERFACES(QGstBufferPoolInterface)
 public:
     explicit QGstBufferPoolPlugin(QObject *parent = 0);
     virtual ~QGstBufferPoolPlugin() {}
@@ -116,8 +115,6 @@ public:
       This method is called from gstreamer video sink thread.
      */
     virtual QAbstractVideoBuffer *prepareVideoBuffer(GstBuffer *buffer, int bytesPerLine) = 0;
-
-    virtual QStringList keys() const = 0;
 };
 
 QT_END_NAMESPACE
diff --git a/src/multimedia/multimedia.pro b/src/multimedia/multimedia.pro
index e7d7b2f..d29ba72 100644
--- a/src/multimedia/multimedia.pro
+++ b/src/multimedia/multimedia.pro
@@ -2,7 +2,7 @@ load(qt_module)
 
 TARGET = QtMultimedia
 QPRO_PWD = $$PWD
-QT = core network gui
+QT = core-private network gui
 
 CONFIG += module
 MODULE_PRI += ../../modules/qt_multimedia.pri
diff --git a/src/multimedia/playback/qmediaplaylistioplugin_p.h b/src/multimedia/playback/qmediaplaylistioplugin_p.h
index 60a12cd..5371a93 100644
--- a/src/multimedia/playback/qmediaplaylistioplugin_p.h
+++ b/src/multimedia/playback/qmediaplaylistioplugin_p.h
@@ -55,7 +55,6 @@
 
 #include <QtCore/qobject.h>
 #include <QtCore/qplugin.h>
-#include <QtCore/qfactoryinterface.h>
 
 #include <qtmultimediadefs.h>
 
@@ -92,7 +91,7 @@ public:
     virtual void close() = 0;
 };
 
-struct Q_MULTIMEDIA_EXPORT QMediaPlaylistIOInterface : public QFactoryInterface
+struct Q_MULTIMEDIA_EXPORT QMediaPlaylistIOInterface
 {
     virtual bool canRead(QIODevice *device, const QByteArray &format = QByteArray() ) const = 0;
     virtual bool canRead(const QUrl& location, const QByteArray &format = QByteArray()) const = 0;
@@ -111,7 +110,7 @@ Q_DECLARE_INTERFACE(QMediaPlaylistIOInterface, QMediaPlaylistIOInterface_iid);
 class Q_MULTIMEDIA_EXPORT QMediaPlaylistIOPlugin : public QObject, public QMediaPlaylistIOInterface
 {
 Q_OBJECT
-Q_INTERFACES(QMediaPlaylistIOInterface:QFactoryInterface)
+Q_INTERFACES(QMediaPlaylistIOInterface)
 public:
     explicit QMediaPlaylistIOPlugin(QObject *parent = 0);
     virtual ~QMediaPlaylistIOPlugin();
@@ -121,8 +120,6 @@ public:
 
     virtual bool canWrite(QIODevice *device, const QByteArray &format) const = 0;
 
-    virtual QStringList keys() const = 0;
-
     virtual QMediaPlaylistReader *createReader(QIODevice *device, const QByteArray &format = QByteArray()) = 0;
     virtual QMediaPlaylistReader *createReader(const QUrl& location, const QByteArray &format = QByteArray()) = 0;
 
diff --git a/src/multimedia/qmediapluginloader.cpp b/src/multimedia/qmediapluginloader.cpp
index 2fc8aba..42787fd 100644
--- a/src/multimedia/qmediapluginloader.cpp
+++ b/src/multimedia/qmediapluginloader.cpp
@@ -41,191 +41,105 @@
 
 #include "qmediapluginloader_p.h"
 #include <QtCore/qcoreapplication.h>
-#include <QtCore/qpluginloader.h>
-#include <QtCore/qdir.h>
 #include <QtCore/qdebug.h>
+#include <QtCore/qjsonarray.h>
+#include <private/qfactoryloader_p.h>
 
 #include "qmediaserviceproviderplugin.h"
 
-#if defined(Q_OS_MAC)
-# include <CoreFoundation/CoreFoundation.h>
-#endif
-
 QT_BEGIN_NAMESPACE
 
-typedef QMap<QString,QObjectList> ObjectListMap;
-Q_GLOBAL_STATIC(ObjectListMap, staticMediaPlugins);
-
-
-QMediaPluginLoader::QMediaPluginLoader(const char *iid, const QString &location, Qt::CaseSensitivity):
+QMediaPluginLoader::QMediaPluginLoader(const char *iid, const QString &location, Qt::CaseSensitivity caseSensitivity):
     m_iid(iid)
 {
     m_location = QString::fromLatin1("/%1").arg(location);
-    load();
+    m_factoryLoader = new QFactoryLoader(m_iid, m_location, caseSensitivity);
+    loadMetadata();
 }
 
-QStringList QMediaPluginLoader::keys() const
+QMediaPluginLoader::~QMediaPluginLoader()
 {
-    return m_instances.keys();
+    delete m_factoryLoader;
 }
 
-QObject* QMediaPluginLoader::instance(QString const &key)
+QStringList QMediaPluginLoader::keys() const
 {
-    return m_instances.value(key).value(0);
+    return m_metadata.keys();
 }
 
-QList<QObject*> QMediaPluginLoader::instances(QString const &key)
+QObject* QMediaPluginLoader::instance(QString const &key)
 {
-    return m_instances.value(key);
-}
+    if (!m_metadata.contains(key))
+        return 0;
 
-//to be used for testing purposes only
-void QMediaPluginLoader::setStaticPlugins(const QString &location, const QObjectList& objects)
-{
-    staticMediaPlugins()->insert(QString::fromLatin1("/%1").arg(location), objects);
+    int idx = m_metadata.value(key).first().value(QStringLiteral("index")).toDouble();
+    if (idx < 0)
+        return 0;
+
+    return m_factoryLoader->instance(idx);
 }
 
-QStringList QMediaPluginLoader::availablePlugins() const
+QList<QObject*> QMediaPluginLoader::instances(QString const &key)
 {
-    QStringList paths;
-    QStringList plugins;
-
-#if defined(Q_OS_MAC)
-    QString imageSuffix(qgetenv("DYLD_IMAGE_SUFFIX"));
-
-    // Bundle plugin directory
-    CFBundleRef mainBundle = CFBundleGetMainBundle();
-    if (mainBundle != 0) {
-        CFURLRef baseUrl = CFBundleCopyBundleURL(mainBundle);
-        CFURLRef pluginUrlPart = CFBundleCopyBuiltInPlugInsURL(mainBundle);
-        CFStringRef pluginPathPart = CFURLCopyFileSystemPath(pluginUrlPart, kCFURLPOSIXPathStyle);
-        CFURLRef pluginUrl = CFURLCreateCopyAppendingPathComponent(0, baseUrl, pluginPathPart, true);
-        CFStringRef pluginPath = CFURLCopyFileSystemPath(pluginUrl, kCFURLPOSIXPathStyle);
-
-        CFIndex length = CFStringGetLength(pluginPath);
-        UniChar buffer[length];
-        CFStringGetCharacters(pluginPath, CFRangeMake(0, length), buffer);
-
-        paths << QString(reinterpret_cast<const QChar *>(buffer), length);
-
-        CFRelease(pluginPath);
-        CFRelease(pluginUrl);
-        CFRelease(pluginPathPart);
-        CFRelease(pluginUrlPart);
-        CFRelease(baseUrl);
-    }
-#endif
-
-    // Qt paths
-    paths << QCoreApplication::libraryPaths();
-
-    foreach (const QString &path, paths) {
-        QDir typeDir(path + m_location);
-        foreach (const QString &file, typeDir.entryList(QDir::Files, QDir::Name)) {
-#if defined(Q_OS_MAC)
-            if (!imageSuffix.isEmpty()) {   // Only add appropriate images
-                if (file.lastIndexOf(imageSuffix, -6) == -1)
-                    continue;
-            } else {
-                int foundSuffix = file.lastIndexOf(QLatin1String("_debug.dylib"));
-                if (foundSuffix == -1) {
-                    foundSuffix = file.lastIndexOf(QLatin1String("_profile.dylib"));
-                }
-                if (foundSuffix != -1) {
-                    /*
-                        If this is a "special" version of the plugin, prefer the release
-                        version, where available.
-                        Avoids warnings like:
-
-                            objc[23101]: Class TransparentQTMovieView is implemented in both
-                            libqqt7engine_debug.dylib and libqqt7engine.dylib. One of the two
-                            will be used. Which one is undefined.
-
-                        Note, this code relies on QDir::Name sorting!
-                    */
-
-                    QString preferred =
-                        typeDir.absoluteFilePath(file.left(foundSuffix) + QLatin1String(".dylib"));
-
-                    if (plugins.contains(preferred)) {
-                        continue;
-                    }
-                }
-            }
-#elif defined(Q_OS_UNIX)
-            // Ignore separate debug files
-            if (file.endsWith(QLatin1String(".debug")))
-                continue;
-#elif defined(Q_OS_WIN)
-            // Ignore non-dlls
-            if (!file.endsWith(QLatin1String(".dll"), Qt::CaseInsensitive))
-                continue;
-#endif
-            plugins << typeDir.absoluteFilePath(file);
+    if (!m_metadata.contains(key))
+        return QList<QObject*>();
+
+    QList<QObject *> objects;
+    foreach (QJsonObject jsonobj, m_metadata.value(key)) {
+        int idx = jsonobj.value(QStringLiteral("index")).toDouble();
+        if (idx < 0)
+            continue;
+
+        QObject *object = m_factoryLoader->instance(idx);
+        if (!objects.contains(object)) {
+            objects.append(object);
         }
     }
 
-    return  plugins;
+    return objects;
 }
 
-void QMediaPluginLoader::load()
+void QMediaPluginLoader::loadMetadata()
 {
-    if (!m_instances.isEmpty())
-        return;
-
 #if !defined QT_NO_DEBUG
     const bool showDebug = qgetenv("QT_DEBUG_PLUGINS").toInt() > 0;
 #endif
 
-    if (staticMediaPlugins() && staticMediaPlugins()->contains(m_location)) {
-        foreach(QObject *o, staticMediaPlugins()->value(m_location)) {
-            if (o != 0 && o->qt_metacast(m_iid) != 0) {
-                QFactoryInterface* p = qobject_cast<QFactoryInterface*>(o);
-                if (p != 0) {
-                    foreach (QString const &key, p->keys())
-                        m_instances[key].append(o);
-                }
-            }
-        }
-    } else {
-        QSet<QString> loadedPlugins;
-
-        foreach (const QString &plugin, availablePlugins()) {
-            QString fileName = QFileInfo(plugin).fileName();
-            //don't try to load plugin with the same name if it's already loaded
-            if (loadedPlugins.contains(fileName)) {
 #if !defined QT_NO_DEBUG
-                if (showDebug)
-                    qDebug() << "Skip loading plugin" << plugin;
+        if (showDebug)
+            qDebug() << "QMediaPluginLoader: loading metadata for iid " << m_iid << " at location " << m_location;
 #endif
-                continue;
-            }
-
-            QPluginLoader   loader(plugin);
 
-            QObject *o = loader.instance();
-            if (o != 0 && o->qt_metacast(m_iid) != 0) {
-                QFactoryInterface* p = qobject_cast<QFactoryInterface*>(o);
-                if (p != 0) {
-                    foreach (const QString &key, p->keys())
-                        m_instances[key].append(o);
+    if (!m_metadata.isEmpty()) {
+#if !defined QT_NO_DEBUG
+        if (showDebug)
+            qDebug() << "QMediaPluginLoader: already loaded metadata, returning";
+#endif
+        return;
+    }
 
-                    loadedPlugins.insert(fileName);
+    QList<QJsonObject> meta = m_factoryLoader->metaData();
+    for (int i = 0; i < meta.size(); i++) {
+        QJsonObject jsonobj = meta.at(i).value(QStringLiteral("MetaData")).toObject();
+        jsonobj.insert(QStringLiteral("index"), i);
 #if !defined QT_NO_DEBUG
-                    if (showDebug)
-                        qDebug() << "Loaded plugin" << plugin << "services:" << p->keys();
+        if (showDebug)
+            qDebug() << "QMediaPluginLoader: Inserted index " << i << " into metadata: " << jsonobj;
 #endif
-                }
 
-                continue;
-            } else {
+        QJsonArray arr = jsonobj.value(QStringLiteral("Keys")).toArray();
+        foreach (QJsonValue value, arr) {
+            QString key = value.toString();
+
+            if (!m_metadata.contains(key)) {
 #if !defined QT_NO_DEBUG
                 if (showDebug)
-                    qWarning() << "QMediaPluginLoader: Failed to load plugin: " << plugin << loader.errorString();
+                    qDebug() << "QMediaPluginLoader: Inserting new list for key: " << key;
 #endif
+                m_metadata.insert(key, QList<QJsonObject>());
             }
 
-            loader.unload();
+            m_metadata[key].append(jsonobj);
         }
     }
 }
diff --git a/src/multimedia/qmediapluginloader_p.h b/src/multimedia/qmediapluginloader_p.h
index 963b6bc..bf5e615 100644
--- a/src/multimedia/qmediapluginloader_p.h
+++ b/src/multimedia/qmediapluginloader_p.h
@@ -58,6 +58,7 @@
 #include <QtCore/qstring.h>
 #include <QtCore/qstringlist.h>
 #include <QtCore/qmap.h>
+#include <QtCore/qjsonobject.h>
 
 
 QT_BEGIN_HEADER
@@ -66,7 +67,7 @@ QT_BEGIN_NAMESPACE
 
 QT_MODULE(Multimedia)
 
-
+class QFactoryLoader;
 class QMediaServiceProviderPlugin;
 
 class Q_MULTIMEDIA_EXPORT QMediaPluginLoader
@@ -75,20 +76,20 @@ public:
     QMediaPluginLoader(const char *iid,
                    const QString &suffix = QString(),
                    Qt::CaseSensitivity = Qt::CaseSensitive);
+    ~QMediaPluginLoader();
 
     QStringList keys() const;
     QObject* instance(QString const &key);
     QList<QObject*> instances(QString const &key);
 
-    static void setStaticPlugins(const QString &location, const QObjectList& objects);
-
 private:
-    void load();
-    QStringList availablePlugins() const;
+    void loadMetadata();
 
     QByteArray  m_iid;
     QString     m_location;
-    QMap<QString, QList<QObject *> > m_instances;
+    QMap<QString, QList<QJsonObject> > m_metadata;
+
+    QFactoryLoader *m_factoryLoader;
 };
 
 QT_END_NAMESPACE
diff --git a/src/multimedia/qmediaserviceproviderplugin.h b/src/multimedia/qmediaserviceproviderplugin.h
index 49638b1..0d98a28 100644
--- a/src/multimedia/qmediaserviceproviderplugin.h
+++ b/src/multimedia/qmediaserviceproviderplugin.h
@@ -44,7 +44,6 @@
 
 #include <QtCore/qstringlist.h>
 #include <QtCore/qplugin.h>
-#include <QtCore/qfactoryinterface.h>
 #include <qtmedianamespace.h>
 #include <qtmultimediadefs.h>
 
@@ -106,9 +105,8 @@ private:
 Q_DECLARE_OPERATORS_FOR_FLAGS(QMediaServiceProviderHint::Features)
 
 
-struct Q_MULTIMEDIA_EXPORT QMediaServiceProviderFactoryInterface : public QFactoryInterface
+struct Q_MULTIMEDIA_EXPORT QMediaServiceProviderFactoryInterface
 {
-    virtual QStringList keys() const = 0;
     virtual QMediaService* create(QString const& key) = 0;
     virtual void release(QMediaService *service) = 0;
 };
@@ -158,10 +156,9 @@ Q_DECLARE_INTERFACE(QMediaServiceFeaturesInterface, QMediaServiceFeaturesInterfa
 class Q_MULTIMEDIA_EXPORT QMediaServiceProviderPlugin : public QObject, public QMediaServiceProviderFactoryInterface
 {
     Q_OBJECT
-    Q_INTERFACES(QMediaServiceProviderFactoryInterface:QFactoryInterface)
+    Q_INTERFACES(QMediaServiceProviderFactoryInterface)
 
 public:
-    virtual QStringList keys() const = 0;
     virtual QMediaService* create(const QString& key) = 0;
     virtual void release(QMediaService *service) = 0;
 };
diff --git a/src/multimedia/qtmultimediaquicktools_headers/qsgvideonode_p.h b/src/multimedia/qtmultimediaquicktools_headers/qsgvideonode_p.h
index f82a337..6bdfc2b 100644
--- a/src/multimedia/qtmultimediaquicktools_headers/qsgvideonode_p.h
+++ b/src/multimedia/qtmultimediaquicktools_headers/qsgvideonode_p.h
@@ -48,7 +48,6 @@
 #include <QtMultimedia/qvideoframe.h>
 #include <QtMultimedia/qvideosurfaceformat.h>
 #include <QtGui/qopenglfunctions.h>
-#include <QtCore/qfactoryinterface.h>
 
 QT_BEGIN_HEADER
 
@@ -74,14 +73,24 @@ private:
     int m_orientation;
 };
 
-class QSGVideoNodeFactory : public QFactoryInterface {
+class QSGVideoNodeFactoryInterface
+{
 public:
     virtual QList<QVideoFrame::PixelFormat> supportedPixelFormats(QAbstractVideoBuffer::HandleType handleType) const = 0;
     virtual QSGVideoNode *createNode(const QVideoSurfaceFormat &format) = 0;
 };
 
-#define QSGVideoNodeFactory_iid "com.nokia.Qt.QSGVideoNodeFactory"
-Q_DECLARE_INTERFACE(QSGVideoNodeFactory, QSGVideoNodeFactory_iid)
+#define QSGVideoNodeFactoryInterface_iid "com.nokia.Qt.QSGVideoNodeFactoryInterface"
+Q_DECLARE_INTERFACE(QSGVideoNodeFactoryInterface, QSGVideoNodeFactoryInterface_iid)
+
+class QSGVideoNodeFactoryPlugin : public QObject, public QSGVideoNodeFactoryInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QSGVideoNodeFactoryInterface)
+public:
+    virtual QList<QVideoFrame::PixelFormat> supportedPixelFormats(QAbstractVideoBuffer::HandleType handleType) const = 0;
+    virtual QSGVideoNode *createNode(const QVideoSurfaceFormat &format) = 0;
+};
 
 QT_END_NAMESPACE
 
diff --git a/src/plugins/audiocapture/audiocapture.json b/src/plugins/audiocapture/audiocapture.json
new file mode 100644
index 0000000..09a8897
--- /dev/null
+++ b/src/plugins/audiocapture/audiocapture.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["com.nokia.qt.audiosource"]
+}
diff --git a/src/plugins/audiocapture/audiocapture.pro b/src/plugins/audiocapture/audiocapture.pro
index f7091c5..3e2015b 100644
--- a/src/plugins/audiocapture/audiocapture.pro
+++ b/src/plugins/audiocapture/audiocapture.pro
@@ -25,3 +25,6 @@ SOURCES += audioencodercontrol.cpp \
 
 target.path += $$[QT_INSTALL_PLUGINS]/$${PLUGIN_TYPE}
 INSTALLS += target
+
+OTHER_FILES += \
+    audiocapture.json
diff --git a/src/plugins/audiocapture/audiocaptureserviceplugin.cpp b/src/plugins/audiocapture/audiocaptureserviceplugin.cpp
index 11eb0c1..3a96ded 100644
--- a/src/plugins/audiocapture/audiocaptureserviceplugin.cpp
+++ b/src/plugins/audiocapture/audiocaptureserviceplugin.cpp
@@ -47,11 +47,6 @@
 #include "qmediaserviceproviderplugin.h"
 
 
-QStringList AudioCaptureServicePlugin::keys() const
-{
-    return QStringList() << QLatin1String(Q_MEDIASERVICE_AUDIOSOURCE);
-}
-
 QMediaService* AudioCaptureServicePlugin::create(QString const& key)
 {
     if (key == QLatin1String(Q_MEDIASERVICE_AUDIOSOURCE))
@@ -65,5 +60,3 @@ void AudioCaptureServicePlugin::release(QMediaService *service)
     delete service;
 }
 
-Q_EXPORT_PLUGIN2(qtmedia_audioengine, AudioCaptureServicePlugin);
-
diff --git a/src/plugins/audiocapture/audiocaptureserviceplugin.h b/src/plugins/audiocapture/audiocaptureserviceplugin.h
index 91630f9..dff93ca 100644
--- a/src/plugins/audiocapture/audiocaptureserviceplugin.h
+++ b/src/plugins/audiocapture/audiocaptureserviceplugin.h
@@ -51,8 +51,9 @@ class AudioCaptureServicePlugin : public QMediaServiceProviderPlugin
 {
     Q_OBJECT
 
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaServiceProviderFactoryInterface/1.0" FILE "audiocapture.json")
+
 public:
-    QStringList keys() const;
     QMediaService* create(QString const& key);
     void release(QMediaService *service);
 };
diff --git a/src/plugins/directshow/directshow.json b/src/plugins/directshow/directshow.json
new file mode 100644
index 0000000..a96b098
--- /dev/null
+++ b/src/plugins/directshow/directshow.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["com.nokia.qt.camera", "com.nokia.qt.mediaplayer"]
+}
diff --git a/src/plugins/directshow/directshow.pro b/src/plugins/directshow/directshow.pro
index bb5bb02..fe1cf5f 100644
--- a/src/plugins/directshow/directshow.pro
+++ b/src/plugins/directshow/directshow.pro
@@ -24,3 +24,6 @@ include(camera/camera.pri)
 
 target.path += $$[QT_INSTALL_PLUGINS]/$${PLUGIN_TYPE}
 INSTALLS += target
+
+OTHER_FILES += \
+    directshow.json
diff --git a/src/plugins/directshow/dsserviceplugin.cpp b/src/plugins/directshow/dsserviceplugin.cpp
index 15b0ecf..d3871c8 100644
--- a/src/plugins/directshow/dsserviceplugin.cpp
+++ b/src/plugins/directshow/dsserviceplugin.cpp
@@ -77,18 +77,6 @@ extern const CLSID CLSID_VideoInputDeviceCategory;
 
 QT_USE_NAMESPACE
 
-QStringList DSServicePlugin::keys() const
-{
-    return QStringList()
-#ifdef QMEDIA_DIRECTSHOW_CAMERA
-            << QLatin1String(Q_MEDIASERVICE_CAMERA)
-#endif
-#ifdef QMEDIA_DIRECTSHOW_PLAYER
-            << QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER)
-#endif
-            ;
-}
-
 QMediaService* DSServicePlugin::create(QString const& key)
 {
 #ifdef QMEDIA_DIRECTSHOW_CAMERA
@@ -100,7 +88,6 @@ QMediaService* DSServicePlugin::create(QString const& key)
         return new DirectShowPlayerService;
 #endif
 
-    qDebug() << "unsupported key:" << key;
     return 0;
 }
 
@@ -208,5 +195,3 @@ void DSServicePlugin::updateDevices() const
 }
 #endif
 
-Q_EXPORT_PLUGIN2(qtmedia_dsengine, DSServicePlugin);
-
diff --git a/src/plugins/directshow/dsserviceplugin.h b/src/plugins/directshow/dsserviceplugin.h
index 0a9b897..2c0b126 100644
--- a/src/plugins/directshow/dsserviceplugin.h
+++ b/src/plugins/directshow/dsserviceplugin.h
@@ -54,8 +54,9 @@ class DSServicePlugin
     Q_OBJECT
     Q_INTERFACES(QMediaServiceSupportedDevicesInterface)
     Q_INTERFACES(QMediaServiceFeaturesInterface)
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaServiceProviderFactoryInterface/1.0", FILE "directshow.json")
+
 public:
-    QStringList keys() const;
     QMediaService* create(QString const& key);
     void release(QMediaService *service);
 
diff --git a/src/plugins/gstreamer/gstreamer.json b/src/plugins/gstreamer/gstreamer.json
new file mode 100644
index 0000000..42d67a0
--- /dev/null
+++ b/src/plugins/gstreamer/gstreamer.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["com.nokia.qt.mediaplayer", "com.nokia.qt.audiosource", "com.nokia.qt.camera", "com.nokia.qt.audiodecode"]
+}
diff --git a/src/plugins/gstreamer/gstreamer.pro b/src/plugins/gstreamer/gstreamer.pro
index 2e20e54..073ef43 100644
--- a/src/plugins/gstreamer/gstreamer.pro
+++ b/src/plugins/gstreamer/gstreamer.pro
@@ -107,6 +107,8 @@ contains(config_test_gstreamer_appsrc, yes) {
     LIBS += -lgstapp-0.10
 }
 
+OTHER_FILES += gstreamer.json
+
 
 #Camerabin2 based camera backend is untested and currently disabled
 #contains(config_test_gstreamer_photography, yes) {
diff --git a/src/plugins/gstreamer/qgstreamerserviceplugin.cpp b/src/plugins/gstreamer/qgstreamerserviceplugin.cpp
index 7c66eac..d9811d6 100644
--- a/src/plugins/gstreamer/qgstreamerserviceplugin.cpp
+++ b/src/plugins/gstreamer/qgstreamerserviceplugin.cpp
@@ -79,25 +79,6 @@
 #include <linux/videodev2.h>
 
 
-QStringList QGstreamerServicePlugin::keys() const
-{
-    return QStringList()
-#ifdef QMEDIA_GSTREAMER_PLAYER
-            << QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER)
-#endif
-#ifdef QMEDIA_GSTREAMER_AUDIO_DECODER
-            << QLatin1String(Q_MEDIASERVICE_AUDIODECODER)
-#endif
-#ifdef QMEDIA_GSTREAMER_CAPTURE
-            << QLatin1String(Q_MEDIASERVICE_AUDIOSOURCE)
-            << QLatin1String(Q_MEDIASERVICE_CAMERA)
-#elif defined(QMEDIA_GSTREAMER_CAMERABIN)
-            << QLatin1String(Q_MEDIASERVICE_CAMERA)
-#endif
-    ;
-
-}
-
 QMediaService* QGstreamerServicePlugin::create(const QString &key)
 {
     static bool initialized = false;
@@ -402,4 +383,3 @@ QStringList QGstreamerServicePlugin::supportedMimeTypes() const
     return QStringList();
 }
 
-Q_EXPORT_PLUGIN2(qtmedia_gstengine, QGstreamerServicePlugin);
diff --git a/src/plugins/gstreamer/qgstreamerserviceplugin.h b/src/plugins/gstreamer/qgstreamerserviceplugin.h
index 9c08231..7695179 100644
--- a/src/plugins/gstreamer/qgstreamerserviceplugin.h
+++ b/src/plugins/gstreamer/qgstreamerserviceplugin.h
@@ -45,6 +45,7 @@
 
 #include <qmediaserviceproviderplugin.h>
 #include <QtCore/qset.h>
+#include <QtCore/QObject>
 
 QT_BEGIN_NAMESPACE
 
@@ -59,8 +60,8 @@ class QGstreamerServicePlugin
     Q_INTERFACES(QMediaServiceSupportedDevicesInterface)
     Q_INTERFACES(QMediaServiceFeaturesInterface)
     Q_INTERFACES(QMediaServiceSupportedFormatsInterface)
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaServiceProviderFactoryInterface/1.0" FILE "gstreamer.json")
 public:
-    QStringList keys() const;
     QMediaService* create(QString const& key);
     void release(QMediaService *service);
 
diff --git a/src/plugins/m3u/m3u.json b/src/plugins/m3u/m3u.json
new file mode 100644
index 0000000..2d69fab
--- /dev/null
+++ b/src/plugins/m3u/m3u.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["m3u"]
+}
diff --git a/src/plugins/m3u/m3u.pro b/src/plugins/m3u/m3u.pro
index cd73b14..98d16c7 100644
--- a/src/plugins/m3u/m3u.pro
+++ b/src/plugins/m3u/m3u.pro
@@ -9,8 +9,10 @@ DESTDIR = $$QT.multimedia.plugins/$${PLUGIN_TYPE}
 
 
 HEADERS += qm3uhandler.h
-SOURCES += main.cpp \
-           qm3uhandler.cpp
+SOURCES += qm3uhandler.cpp
 
 target.path += $$[QT_INSTALL_PLUGINS]/$${PLUGIN_TYPE}
 INSTALLS += target
+
+OTHER_FILES += \
+    m3u.json
diff --git a/src/plugins/m3u/main.cpp b/src/plugins/m3u/main.cpp
deleted file mode 100644
index 45855fb..0000000
--- a/src/plugins/m3u/main.cpp
+++ /dev/null
@@ -1,47 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qm3uhandler.h"
-#include <qstringlist.h>
-
-
-Q_EXPORT_STATIC_PLUGIN(QM3uPlaylistPlugin)
-Q_EXPORT_PLUGIN2(qtmultimedia_m3u, QM3uPlaylistPlugin)
diff --git a/src/plugins/m3u/qm3uhandler.cpp b/src/plugins/m3u/qm3uhandler.cpp
index 0f8d5da..a03e802 100644
--- a/src/plugins/m3u/qm3uhandler.cpp
+++ b/src/plugins/m3u/qm3uhandler.cpp
@@ -212,11 +212,6 @@ bool QM3uPlaylistPlugin::canWrite(QIODevice *device, const QByteArray &format) c
     return device->isOpen() && device->isWritable() && format == "m3u";
 }
 
-QStringList QM3uPlaylistPlugin::keys() const
-{
-    return QStringList() << QLatin1String("m3u");
-}
-
 QMediaPlaylistReader *QM3uPlaylistPlugin::createReader(QIODevice *device, const QByteArray &format)
 {
     Q_UNUSED(format);
diff --git a/src/plugins/m3u/qm3uhandler.h b/src/plugins/m3u/qm3uhandler.h
index 5d8e0e4..b0dd292 100644
--- a/src/plugins/m3u/qm3uhandler.h
+++ b/src/plugins/m3u/qm3uhandler.h
@@ -43,13 +43,15 @@
 #define QM3UHANDLER_H
 
 #include <private/qmediaplaylistioplugin_p.h>
-#include <QObject>
+#include <QtCore/QObject>
 
 QT_USE_NAMESPACE
 
 class QM3uPlaylistPlugin : public QMediaPlaylistIOPlugin
 {
-Q_OBJECT
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaPlaylistIOInterface" FILE "m3u.json")
+
 public:
     explicit QM3uPlaylistPlugin(QObject *parent = 0);
     virtual ~QM3uPlaylistPlugin();
@@ -59,8 +61,6 @@ public:
 
     virtual bool canWrite(QIODevice *device, const QByteArray &format) const;
 
-    virtual QStringList keys() const;
-
     virtual QMediaPlaylistReader *createReader(QIODevice *device, const QByteArray &format = QByteArray());
     virtual QMediaPlaylistReader *createReader(const QUrl& location, const QByteArray &format = QByteArray());
 
diff --git a/src/plugins/pulseaudio/pulseaudio.json b/src/plugins/pulseaudio/pulseaudio.json
new file mode 100644
index 0000000..a31d521
--- /dev/null
+++ b/src/plugins/pulseaudio/pulseaudio.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["default"]
+}
diff --git a/src/plugins/pulseaudio/pulseaudio.pro b/src/plugins/pulseaudio/pulseaudio.pro
index 0897b8f..0a922aa 100644
--- a/src/plugins/pulseaudio/pulseaudio.pro
+++ b/src/plugins/pulseaudio/pulseaudio.pro
@@ -26,3 +26,6 @@ SOURCES += qpulseaudioplugin.cpp \
 
 target.path += $$[QT_INSTALL_PLUGINS]/$${PLUGIN_TYPE}
 INSTALLS += target
+
+OTHER_FILES += \
+    pulseaudio.json
diff --git a/src/plugins/pulseaudio/qpulseaudioplugin.cpp b/src/plugins/pulseaudio/qpulseaudioplugin.cpp
index 85490df..fab7f71 100644
--- a/src/plugins/pulseaudio/qpulseaudioplugin.cpp
+++ b/src/plugins/pulseaudio/qpulseaudioplugin.cpp
@@ -55,11 +55,6 @@ QPulseAudioPlugin::QPulseAudioPlugin(QObject *parent)
 {
 }
 
-QStringList QPulseAudioPlugin::keys() const
-{
-    return QStringList() << "default";
-}
-
 QList<QByteArray> QPulseAudioPlugin::availableDevices(QAudio::Mode mode) const
 {
     return m_pulseEngine->availableDevices(mode);
@@ -84,6 +79,4 @@ QAbstractAudioDeviceInfo *QPulseAudioPlugin::createDeviceInfo(const QByteArray &
     return deviceInfo;
 }
 
-Q_EXPORT_PLUGIN2(qtmedia_pulse, QPulseAudioPlugin);
-
 QT_END_NAMESPACE
diff --git a/src/plugins/pulseaudio/qpulseaudioplugin.h b/src/plugins/pulseaudio/qpulseaudioplugin.h
index d525967..1540f72 100644
--- a/src/plugins/pulseaudio/qpulseaudioplugin.h
+++ b/src/plugins/pulseaudio/qpulseaudioplugin.h
@@ -52,11 +52,12 @@ class QPulseAudioPlugin : public QAudioSystemPlugin
 {
     Q_OBJECT
 
+    Q_PLUGIN_METADATA(IID "com.nokia.qt.QAudioSystemFactoryInterface" FILE "pulseaudio.json")
+
 public:
     QPulseAudioPlugin(QObject *parent = 0);
     ~QPulseAudioPlugin() {}
 
-    QStringList keys() const;
     QList<QByteArray> availableDevices(QAudio::Mode mode) const;
     QAbstractAudioInput *createInput(const QByteArray &device);
     QAbstractAudioOutput *createOutput(const QByteArray &device);
diff --git a/src/plugins/qt7/qt7.json b/src/plugins/qt7/qt7.json
new file mode 100644
index 0000000..6758633
--- /dev/null
+++ b/src/plugins/qt7/qt7.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["com.nokia.qt.mediaplayer"]
+}
diff --git a/src/plugins/qt7/qt7.pro b/src/plugins/qt7/qt7.pro
index 9fe15b0..83b8c13 100644
--- a/src/plugins/qt7/qt7.pro
+++ b/src/plugins/qt7/qt7.pro
@@ -72,3 +72,6 @@ include(mediaplayer/mediaplayer.pri)
 
 target.path += $$[QT_INSTALL_PLUGINS]/$${PLUGIN_TYPE}
 INSTALLS += target
+
+OTHER_FILES += \
+    qt7.json
diff --git a/src/plugins/qt7/qt7serviceplugin.h b/src/plugins/qt7/qt7serviceplugin.h
index 2f1fd90..ef8bed1 100644
--- a/src/plugins/qt7/qt7serviceplugin.h
+++ b/src/plugins/qt7/qt7serviceplugin.h
@@ -52,11 +52,13 @@ class QT7ServicePlugin
     , public QMediaServiceSupportedFormatsInterface
     , public QMediaServiceFeaturesInterface
 {
+    Q_OBJECT
     Q_INTERFACES(QMediaServiceFeaturesInterface)
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaServiceProviderFactoryInterface/1.0" FILE "qt7.json")
+
 public:
     QT7ServicePlugin();
 
-    QStringList keys() const;
     QMediaService* create(QString const& key);
     void release(QMediaService *service);
 
diff --git a/src/plugins/qt7/qt7serviceplugin.mm b/src/plugins/qt7/qt7serviceplugin.mm
index 0cc0a58..a1bbc79 100644
--- a/src/plugins/qt7/qt7serviceplugin.mm
+++ b/src/plugins/qt7/qt7serviceplugin.mm
@@ -59,15 +59,6 @@ QT7ServicePlugin::QT7ServicePlugin()
     buildSupportedTypes();
 }
 
-QStringList QT7ServicePlugin::keys() const
-{
-    return QStringList()
-#ifdef QMEDIA_QT7_PLAYER
-        << QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER)
-#endif
-        ;
-}
-
 QMediaService* QT7ServicePlugin::create(QString const& key)
 {
 #ifdef QT_DEBUG_QT7
@@ -124,6 +115,4 @@ void QT7ServicePlugin::buildSupportedTypes()
     }
 }
 
-Q_EXPORT_PLUGIN2(qtmedia_qt7engine, QT7ServicePlugin);
-
 QT_END_NAMESPACE
diff --git a/tests/auto/unit/qmediaplaylist/tst_qmediaplaylist.cpp b/tests/auto/unit/qmediaplaylist/tst_qmediaplaylist.cpp
index 38b7fd7..f8092b4 100644
--- a/tests/auto/unit/qmediaplaylist/tst_qmediaplaylist.cpp
+++ b/tests/auto/unit/qmediaplaylist/tst_qmediaplaylist.cpp
@@ -122,7 +122,6 @@ void tst_QMediaPlaylist::initTestCase()
     content2 = QMediaContent(QUrl(QLatin1String("file:///2")));
     content3 = QMediaContent(QUrl(QLatin1String("file:///3")));
 
-    QMediaPluginLoader::setStaticPlugins(QLatin1String("playlistformats"), QObjectList() << new QM3uPlaylistPlugin(this));
 }
 
 void tst_QMediaPlaylist::cleanup()
diff --git a/tests/auto/unit/qmediapluginloader/tst_qmediapluginloader.cpp b/tests/auto/unit/qmediapluginloader/tst_qmediapluginloader.cpp
index 16711ad..402d188 100644
--- a/tests/auto/unit/qmediapluginloader/tst_qmediapluginloader.cpp
+++ b/tests/auto/unit/qmediapluginloader/tst_qmediapluginloader.cpp
@@ -69,7 +69,7 @@ private:
 void tst_QMediaPluginLoader::initTestCase()
 {
     loader = new QMediaPluginLoader(QMediaServiceProviderFactoryInterface_iid,
-                                QLatin1String("/mediaservice"),
+                                QLatin1String("mediaservice"),
                                 Qt::CaseInsensitive);
 }
 
diff --git a/tests/auto/unit/qmediaserviceprovider/mockservice.h b/tests/auto/unit/qmediaserviceprovider/mockservice.h
new file mode 100644
index 0000000..ab54f68
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockservice.h
@@ -0,0 +1,59 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef MOCKSERVICE_H
+#define MOCKSERVICE_H
+
+#include <qmediaservice.h>
+
+class MockMediaService : public QMediaService
+{
+    Q_OBJECT
+public:
+    MockMediaService(const QString& name, QObject *parent = 0) : QMediaService(parent)
+    { setObjectName(name); }
+    ~MockMediaService() {}
+
+    QMediaControl* requestControl(const char *) {return 0;}
+    void releaseControl(QMediaControl *) {}
+};
+
+#endif // MOCKSERVICE_H
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.cpp b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.cpp
new file mode 100644
index 0000000..c6887c7
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.cpp
@@ -0,0 +1,108 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qmediaserviceproviderplugin.h>
+#include <qmediaservice.h>
+#include "../mockservice.h"
+
+class MockServicePlugin1 : public QMediaServiceProviderPlugin,
+                           public QMediaServiceSupportedFormatsInterface,
+                           public QMediaServiceSupportedDevicesInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaServiceSupportedFormatsInterface)
+    Q_INTERFACES(QMediaServiceSupportedDevicesInterface)
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaServiceProviderFactoryInterface/1.0" FILE "mockserviceplugin1.json")
+public:
+    QStringList keys() const
+    {
+        return QStringList() <<
+                QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER);
+    }
+
+    QMediaService* create(QString const& key)
+    {
+        if (keys().contains(key))
+            return new MockMediaService("MockServicePlugin1");
+        else
+            return 0;
+    }
+
+    void release(QMediaService *service)
+    {
+        delete service;
+    }
+
+    QtMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs) const
+    {
+        if (codecs.contains(QLatin1String("mpeg4")))
+            return QtMultimedia::NotSupported;
+
+        if (mimeType == "audio/ogg") {
+            return QtMultimedia::ProbablySupported;
+        }
+
+        return QtMultimedia::MaybeSupported;
+    }
+
+    QStringList supportedMimeTypes() const
+    {
+        return QStringList("audio/ogg");
+    }
+
+    QList<QByteArray> devices(const QByteArray &service) const
+    {
+        Q_UNUSED(service);
+        QList<QByteArray> res;
+        return res;
+    }
+
+    QString deviceDescription(const QByteArray &service, const QByteArray &device)
+    {
+        if (devices(service).contains(device))
+            return QString(device)+" description";
+        else
+            return QString();
+    }
+};
+
+#include "mockserviceplugin1.moc"
+
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.json b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.json
new file mode 100644
index 0000000..6758633
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["com.nokia.qt.mediaplayer"]
+}
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.pro b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.pro
new file mode 100644
index 0000000..fbbdf91
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin1/mockserviceplugin1.pro
@@ -0,0 +1,18 @@
+
+load(qt_module)
+
+TARGET = mockserviceplugin1
+QT += multimedia-private
+CONFIG += no_private_qt_headers_warning
+
+PLUGIN_TYPE=mediaservice
+DESTDIR = ../$${PLUGIN_TYPE}
+
+load(qt_plugin)
+
+HEADERS += ../mockservice.h
+SOURCES += mockserviceplugin1.cpp
+OTHER_FILES += mockserviceplugin1.json
+
+target.path += $$[QT_INSTALL_TESTS]/tst_qmediaserviceprovider/$${PLUGIN_TYPE}
+INSTALLS += target
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.cpp b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.cpp
new file mode 100644
index 0000000..299b222
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.cpp
@@ -0,0 +1,99 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qmediaserviceproviderplugin.h>
+#include <qmediaservice.h>
+#include "../mockservice.h"
+
+class MockServicePlugin2 : public QMediaServiceProviderPlugin,
+                            public QMediaServiceSupportedFormatsInterface,
+                            public QMediaServiceFeaturesInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaServiceSupportedFormatsInterface)
+    Q_INTERFACES(QMediaServiceFeaturesInterface)
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaServiceProviderFactoryInterface/1.0" FILE "mockserviceplugin2.json")
+public:
+    QStringList keys() const
+    {
+        return QStringList() << QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER)
+                             << QLatin1String(Q_MEDIASERVICE_RADIO);
+    }
+
+    QMediaService* create(QString const& key)
+    {
+        if (keys().contains(key))
+            return new MockMediaService("MockServicePlugin2");
+        else
+            return 0;
+    }
+
+    void release(QMediaService *service)
+    {
+        delete service;
+    }
+
+    QtMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs) const
+    {
+        Q_UNUSED(codecs);
+
+        if (mimeType == "audio/wav")
+            return QtMultimedia::PreferredService;
+
+        return QtMultimedia::NotSupported;
+    }
+
+    QStringList supportedMimeTypes() const
+    {
+        return QStringList("audio/wav");
+    }
+
+    QMediaServiceProviderHint::Features supportedFeatures(const QByteArray &service) const
+    {
+        if (service == QByteArray(Q_MEDIASERVICE_MEDIAPLAYER))
+            return QMediaServiceProviderHint::LowLatencyPlayback;
+        else
+            return 0;
+    }
+};
+
+#include "mockserviceplugin2.moc"
+
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.json b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.json
new file mode 100644
index 0000000..9472b0b
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["com.nokia.qt.mediaplayer", "com.nokia.qt.radio"]
+}
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.pro b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.pro
new file mode 100644
index 0000000..a64129d
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin2/mockserviceplugin2.pro
@@ -0,0 +1,18 @@
+
+load(qt_module)
+
+TARGET = mockserviceplugin2
+QT += multimedia-private
+CONFIG += no_private_qt_headers_warning
+
+PLUGIN_TYPE=mediaservice
+DESTDIR = ../$${PLUGIN_TYPE}
+
+load(qt_plugin)
+
+HEADERS += ../mockservice.h
+SOURCES += mockserviceplugin2.cpp
+OTHER_FILES += mockserviceplugin2.json
+
+target.path += $$[QT_INSTALL_TESTS]/tst_qmediaserviceprovider/$${PLUGIN_TYPE}
+INSTALLS += target
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.cpp b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.cpp
new file mode 100644
index 0000000..6aae3ea
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.cpp
@@ -0,0 +1,92 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qmediaserviceproviderplugin.h>
+#include <qmediaservice.h>
+#include "../mockservice.h"
+
+class MockServicePlugin3 : public QMediaServiceProviderPlugin,
+                            public QMediaServiceSupportedDevicesInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaServiceSupportedDevicesInterface)
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaServiceProviderFactoryInterface/1.0" FILE "mockserviceplugin3.json")
+public:
+    QStringList keys() const
+    {
+        return QStringList() <<
+               QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER) <<
+               QLatin1String(Q_MEDIASERVICE_AUDIOSOURCE);
+    }
+
+    QMediaService* create(QString const& key)
+    {
+        if (keys().contains(key))
+            return new MockMediaService("MockServicePlugin3");
+        else
+            return 0;
+    }
+
+    void release(QMediaService *service)
+    {
+        delete service;
+    }
+
+    QList<QByteArray> devices(const QByteArray &service) const
+    {
+        QList<QByteArray> res;
+        if (service == QByteArray(Q_MEDIASERVICE_AUDIOSOURCE))
+            res << "audiosource1" << "audiosource2";
+
+        return res;
+    }
+
+    QString deviceDescription(const QByteArray &service, const QByteArray &device)
+    {
+        if (devices(service).contains(device))
+            return QString(device)+" description";
+        else
+            return QString();
+    }
+};
+
+#include "mockserviceplugin3.moc"
+
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.json b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.json
new file mode 100644
index 0000000..9379436
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["com.nokia.qt.mediaplayer", "com.nokia.qt.audiosource"]
+}
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.pro b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.pro
new file mode 100644
index 0000000..13d9cb9
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin3/mockserviceplugin3.pro
@@ -0,0 +1,18 @@
+
+load(qt_module)
+
+TARGET = mockserviceplugin3
+QT += multimedia-private
+CONFIG += no_private_qt_headers_warning
+
+PLUGIN_TYPE=mediaservice
+DESTDIR = ../$${PLUGIN_TYPE}
+
+load(qt_plugin)
+
+HEADERS += ../mockservice.h
+SOURCES += mockserviceplugin3.cpp
+OTHER_FILES += mockserviceplugin3.json
+
+target.path += $$[QT_INSTALL_TESTS]/tst_qmediaserviceprovider/$${PLUGIN_TYPE}
+INSTALLS += target
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.cpp b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.cpp
new file mode 100644
index 0000000..73daa64
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.cpp
@@ -0,0 +1,99 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qmediaserviceproviderplugin.h>
+#include <qmediaservice.h>
+#include "../mockservice.h"
+
+class MockServicePlugin4 : public QMediaServiceProviderPlugin,
+                            public QMediaServiceSupportedFormatsInterface,
+                            public QMediaServiceFeaturesInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaServiceSupportedFormatsInterface)
+    Q_INTERFACES(QMediaServiceFeaturesInterface)
+    Q_PLUGIN_METADATA(IID "com.nokia.Qt.QMediaServiceProviderFactoryInterface/1.0" FILE "mockserviceplugin4.json")
+public:
+    QStringList keys() const
+    {
+        return QStringList() << QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER);
+    }
+
+    QMediaService* create(QString const& key)
+    {
+        if (keys().contains(key))
+            return new MockMediaService("MockServicePlugin4");
+        else
+            return 0;
+    }
+
+    void release(QMediaService *service)
+    {
+        delete service;
+    }
+
+    QtMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs) const
+    {
+        if (codecs.contains(QLatin1String("jpeg2000")))
+            return QtMultimedia::NotSupported;
+
+        if (supportedMimeTypes().contains(mimeType))
+            return QtMultimedia::ProbablySupported;
+
+        return QtMultimedia::MaybeSupported;
+    }
+
+    QStringList supportedMimeTypes() const
+    {
+        return QStringList() << "video/mp4" << "video/quicktime";
+    }
+
+    QMediaServiceProviderHint::Features supportedFeatures(const QByteArray &service) const
+    {
+        if (service == QByteArray(Q_MEDIASERVICE_MEDIAPLAYER))
+            return QMediaServiceProviderHint::StreamPlayback;
+        else
+            return 0;
+    }
+};
+
+#include "mockserviceplugin4.moc"
+
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.json b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.json
new file mode 100644
index 0000000..6758633
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.json
@@ -0,0 +1,3 @@
+{
+    "Keys": ["com.nokia.qt.mediaplayer"]
+}
diff --git a/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.pro b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.pro
new file mode 100644
index 0000000..58fc260
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/mockserviceplugin4/mockserviceplugin4.pro
@@ -0,0 +1,18 @@
+
+load(qt_module)
+
+TARGET = mockserviceplugin4
+QT += multimedia-private
+CONFIG += no_private_qt_headers_warning
+
+PLUGIN_TYPE=mediaservice
+DESTDIR = ../$${PLUGIN_TYPE}
+
+load(qt_plugin)
+
+HEADERS += ../mockservice.h
+SOURCES += mockserviceplugin4.cpp
+OTHER_FILES += mockserviceplugin4.json
+
+target.path += $$[QT_INSTALL_TESTS]/tst_qmediaserviceprovider/$${PLUGIN_TYPE}
+INSTALLS += target
diff --git a/tests/auto/unit/qmediaserviceprovider/qmediaserviceprovider.pro b/tests/auto/unit/qmediaserviceprovider/qmediaserviceprovider.pro
index d74c936..b07c29a 100644
--- a/tests/auto/unit/qmediaserviceprovider/qmediaserviceprovider.pro
+++ b/tests/auto/unit/qmediaserviceprovider/qmediaserviceprovider.pro
@@ -1,8 +1,13 @@
-CONFIG += testcase
-TARGET = tst_qmediaserviceprovider
+TEMPLATE = subdirs
+CONFIG += ORDERED
 
-QT += multimedia-private testlib
-CONFIG += no_private_qt_headers_warning
+SUBDIRS += \
+    test \
+    mockserviceplugin1 \
+    mockserviceplugin2 \
+    mockserviceplugin3 \
+    mockserviceplugin4
 
-SOURCES += tst_qmediaserviceprovider.cpp
+# no special install rule for subdir
+INSTALLS =
 
diff --git a/tests/auto/unit/qmediaserviceprovider/test/test.pro b/tests/auto/unit/qmediaserviceprovider/test/test.pro
new file mode 100644
index 0000000..22d3463
--- /dev/null
+++ b/tests/auto/unit/qmediaserviceprovider/test/test.pro
@@ -0,0 +1,16 @@
+CONFIG += testcase
+TARGET = ../tst_qmediaserviceprovider
+
+QT += multimedia-private testlib
+CONFIG += no_private_qt_headers_warning
+
+SOURCES += ../tst_qmediaserviceprovider.cpp
+
+win32 {
+    CONFIG(debug, debug|release) {
+        TARGET = ../../debug/tst_qmediaserviceprovider
+    } else {
+        TARGET = ../../release/tst_qmediaserviceprovider
+    }
+}
+
diff --git a/tests/auto/unit/qmediaserviceprovider/tst_qmediaserviceprovider.cpp b/tests/auto/unit/qmediaserviceprovider/tst_qmediaserviceprovider.cpp
index d76bd92..6645296 100644
--- a/tests/auto/unit/qmediaserviceprovider/tst_qmediaserviceprovider.cpp
+++ b/tests/auto/unit/qmediaserviceprovider/tst_qmediaserviceprovider.cpp
@@ -54,226 +54,6 @@
 #include <qaudiorecorder.h>
 
 QT_USE_NAMESPACE
-class MockMediaService : public QMediaService
-{
-    Q_OBJECT
-public:
-    MockMediaService(const QString& name, QObject *parent = 0) : QMediaService(parent)
-    { setObjectName(name); }
-    ~MockMediaService() {}
-
-    QMediaControl* requestControl(const char *) {return 0;}
-    void releaseControl(QMediaControl *) {}
-};
-
-class MockServicePlugin1 : public QMediaServiceProviderPlugin,
-                           public QMediaServiceSupportedFormatsInterface,
-                           public QMediaServiceSupportedDevicesInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(QMediaServiceSupportedFormatsInterface)
-    Q_INTERFACES(QMediaServiceSupportedDevicesInterface)
-public:
-    QStringList keys() const
-    {
-        return QStringList() <<
-                QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER);
-    }
-
-    QMediaService* create(QString const& key)
-    {
-        if (keys().contains(key))
-            return new MockMediaService("MockServicePlugin1");
-        else
-            return 0;
-    }
-
-    void release(QMediaService *service)
-    {
-        delete service;
-    }
-
-    QtMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs) const
-    {
-        if (codecs.contains(QLatin1String("mpeg4")))
-            return QtMultimedia::NotSupported;
-
-        if (mimeType == "audio/ogg") {
-            return QtMultimedia::ProbablySupported;
-        }
-
-        return QtMultimedia::MaybeSupported;
-    }
-
-    QStringList supportedMimeTypes() const
-    {
-        return QStringList("audio/ogg");
-    }
-
-    QList<QByteArray> devices(const QByteArray &service) const
-    {
-        Q_UNUSED(service);
-        QList<QByteArray> res;
-        return res;
-    }
-
-    QString deviceDescription(const QByteArray &service, const QByteArray &device)
-    {
-        if (devices(service).contains(device))
-            return QString(device)+" description";
-        else
-            return QString();
-    }
-};
-
-class MockServicePlugin2 : public QMediaServiceProviderPlugin,
-                            public QMediaServiceSupportedFormatsInterface,
-                            public QMediaServiceFeaturesInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(QMediaServiceSupportedFormatsInterface)
-    Q_INTERFACES(QMediaServiceFeaturesInterface)
-public:
-    QStringList keys() const
-    {
-        return QStringList() << QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER)
-                             << QLatin1String(Q_MEDIASERVICE_RADIO);
-    }
-
-    QMediaService* create(QString const& key)
-    {
-        if (keys().contains(key))
-            return new MockMediaService("MockServicePlugin2");
-        else
-            return 0;
-    }
-
-    void release(QMediaService *service)
-    {
-        delete service;
-    }
-
-    QtMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs) const
-    {
-        Q_UNUSED(codecs);
-
-        if (mimeType == "audio/wav")
-            return QtMultimedia::PreferredService;
-
-        return QtMultimedia::NotSupported;
-    }
-
-    QStringList supportedMimeTypes() const
-    {
-        return QStringList("audio/wav");
-    }
-
-    QMediaServiceProviderHint::Features supportedFeatures(const QByteArray &service) const
-    {
-        if (service == QByteArray(Q_MEDIASERVICE_MEDIAPLAYER))
-            return QMediaServiceProviderHint::LowLatencyPlayback;
-        else
-            return 0;
-    }
-};
-
-
-class MockServicePlugin3 : public QMediaServiceProviderPlugin,
-                            public QMediaServiceSupportedDevicesInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(QMediaServiceSupportedDevicesInterface)
-public:
-    QStringList keys() const
-    {
-        return QStringList() <<
-               QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER) <<
-               QLatin1String(Q_MEDIASERVICE_AUDIOSOURCE);
-    }
-
-    QMediaService* create(QString const& key)
-    {
-        if (keys().contains(key))
-            return new MockMediaService("MockServicePlugin3");
-        else
-            return 0;
-    }
-
-    void release(QMediaService *service)
-    {
-        delete service;
-    }
-
-    QList<QByteArray> devices(const QByteArray &service) const
-    {
-        QList<QByteArray> res;
-        if (service == QByteArray(Q_MEDIASERVICE_AUDIOSOURCE))
-            res << "audiosource1" << "audiosource2";
-
-        return res;
-    }
-
-    QString deviceDescription(const QByteArray &service, const QByteArray &device)
-    {
-        if (devices(service).contains(device))
-            return QString(device)+" description";
-        else
-            return QString();
-    }
-};
-
-class MockServicePlugin4 : public QMediaServiceProviderPlugin,
-                            public QMediaServiceSupportedFormatsInterface,
-                            public QMediaServiceFeaturesInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(QMediaServiceSupportedFormatsInterface)
-    Q_INTERFACES(QMediaServiceFeaturesInterface)
-public:
-    QStringList keys() const
-    {
-        return QStringList() << QLatin1String(Q_MEDIASERVICE_MEDIAPLAYER);
-    }
-
-    QMediaService* create(QString const& key)
-    {
-        if (keys().contains(key))
-            return new MockMediaService("MockServicePlugin4");
-        else
-            return 0;
-    }
-
-    void release(QMediaService *service)
-    {
-        delete service;
-    }
-
-    QtMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs) const
-    {
-        if (codecs.contains(QLatin1String("jpeg2000")))
-            return QtMultimedia::NotSupported;
-
-        if (supportedMimeTypes().contains(mimeType))
-            return QtMultimedia::ProbablySupported;
-
-        return QtMultimedia::MaybeSupported;
-    }
-
-    QStringList supportedMimeTypes() const
-    {
-        return QStringList() << "video/mp4" << "video/quicktime";
-    }
-
-    QMediaServiceProviderHint::Features supportedFeatures(const QByteArray &service) const
-    {
-        if (service == QByteArray(Q_MEDIASERVICE_MEDIAPLAYER))
-            return QMediaServiceProviderHint::StreamPlayback;
-        else
-            return 0;
-    }
-};
-
-
 
 class MockMediaServiceProvider : public QMediaServiceProvider
 {
@@ -310,12 +90,8 @@ private:
 
 void tst_QMediaServiceProvider::initTestCase()
 {
-    plugins << new MockServicePlugin1;
-    plugins << new MockServicePlugin2;
-    plugins << new MockServicePlugin3;
-    plugins << new MockServicePlugin4;
-
-    QMediaPluginLoader::setStaticPlugins(QLatin1String("mediaservice"), plugins);
+//    QMediaPluginLoader::setStaticPlugins(QLatin1String("mediaservice"), plugins);
+    QCoreApplication::setLibraryPaths(QStringList() << QCoreApplication::applicationDirPath());
 }
 
 void tst_QMediaServiceProvider::testDefaultProviderAvailable()