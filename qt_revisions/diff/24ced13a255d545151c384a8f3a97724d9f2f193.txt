diff --git a/tests/auto/integration/qaudiodecoderbackend/testdata/test-corrupted.wav b/tests/auto/integration/qaudiodecoderbackend/testdata/test-corrupted.wav
new file mode 100644
index 0000000..abbfb49
Binary files /dev/null and b/tests/auto/integration/qaudiodecoderbackend/testdata/test-corrupted.wav differ
diff --git a/tests/auto/integration/qaudiodecoderbackend/testdata/test-unsupported.avi b/tests/auto/integration/qaudiodecoderbackend/testdata/test-unsupported.avi
new file mode 100644
index 0000000..53b9e38
Binary files /dev/null and b/tests/auto/integration/qaudiodecoderbackend/testdata/test-unsupported.avi differ
diff --git a/tests/auto/integration/qaudiodecoderbackend/tst_qaudiodecoderbackend.cpp b/tests/auto/integration/qaudiodecoderbackend/tst_qaudiodecoderbackend.cpp
index a901520..e754fe8 100644
--- a/tests/auto/integration/qaudiodecoderbackend/tst_qaudiodecoderbackend.cpp
+++ b/tests/auto/integration/qaudiodecoderbackend/tst_qaudiodecoderbackend.cpp
@@ -44,6 +44,8 @@
 #include "qaudiodecoder.h"
 
 #define TEST_FILE_NAME "testdata/test.wav"
+#define TEST_UNSUPPORTED_FILE_NAME "testdata/test-unsupported.avi"
+#define TEST_CORRUPTED_FILE_NAME "testdata/test-corrupted.wav"
 
 QT_USE_NAMESPACE
 
@@ -64,6 +66,8 @@ public slots:
 
 private slots:
     void fileTest();
+    void unsupportedFileTest();
+    void corruptedFileTest();
     void deviceTest();
 };
 
@@ -230,6 +234,7 @@ void tst_QAudioDecoderBackend::fileTest()
         QVERIFY(buffer.isValid());
         QTRY_VERIFY(!positionSpy.isEmpty());
         QVERIFY(positionSpy.takeLast().at(0).toLongLong() == qint64(duration / 1000));
+        QVERIFY(d.position() - (duration / 1000) < 20);
 
         duration += buffer.duration();
         sampleCount += buffer.sampleCount();
@@ -257,6 +262,157 @@ void tst_QAudioDecoderBackend::fileTest()
     QVERIFY(!d.bufferAvailable());
 }
 
+/*
+ The avi file has an audio stream not supported by any codec.
+*/
+void tst_QAudioDecoderBackend::unsupportedFileTest()
+{
+    QAudioDecoder d;
+    QAudioBuffer buffer;
+
+    QVERIFY(d.state() == QAudioDecoder::StoppedState);
+    QVERIFY(d.bufferAvailable() == false);
+    QCOMPARE(d.sourceFilename(), QString(""));
+    QVERIFY(d.audioFormat() == QAudioFormat());
+
+    // Test local file
+    QFileInfo fileInfo(QFINDTESTDATA(TEST_UNSUPPORTED_FILE_NAME));
+    d.setSourceFilename(fileInfo.absoluteFilePath());
+    QVERIFY(d.state() == QAudioDecoder::StoppedState);
+    QVERIFY(!d.bufferAvailable());
+    QCOMPARE(d.sourceFilename(), fileInfo.absoluteFilePath());
+
+    QSignalSpy readySpy(&d, SIGNAL(bufferReady()));
+    QSignalSpy bufferChangedSpy(&d, SIGNAL(bufferAvailableChanged(bool)));
+    QSignalSpy errorSpy(&d, SIGNAL(error(QAudioDecoder::Error)));
+    QSignalSpy stateSpy(&d, SIGNAL(stateChanged(QAudioDecoder::State)));
+    QSignalSpy durationSpy(&d, SIGNAL(durationChanged(qint64)));
+    QSignalSpy finishedSpy(&d, SIGNAL(finished()));
+    QSignalSpy positionSpy(&d, SIGNAL(positionChanged(qint64)));
+
+    d.start();
+    QTRY_VERIFY(d.state() == QAudioDecoder::StoppedState);
+    QVERIFY(!d.bufferAvailable());
+    QCOMPARE(d.audioFormat(), QAudioFormat());
+    QCOMPARE(d.duration(), qint64(-1));
+    QCOMPARE(d.position(), qint64(-1));
+
+    // Check the error code.
+    QTRY_VERIFY(!errorSpy.isEmpty());
+
+    // Have to use qvariant_cast, toInt will return 0 because unrecognized type;
+    QAudioDecoder::Error errorCode = qvariant_cast<QAudioDecoder::Error>(errorSpy.takeLast().at(0));
+    QCOMPARE(errorCode, QAudioDecoder::FormatError);
+    QCOMPARE(d.error(), QAudioDecoder::FormatError);
+
+    // Check all other spies.
+    QVERIFY(readySpy.isEmpty());
+    QVERIFY(bufferChangedSpy.isEmpty());
+    QVERIFY(stateSpy.isEmpty());
+    QVERIFY(finishedSpy.isEmpty());
+    QVERIFY(positionSpy.isEmpty());
+    QVERIFY(durationSpy.isEmpty());
+
+    errorSpy.clear();
+
+    // Try read even if the file is not supported to test robustness.
+    buffer = d.read();
+    QTRY_VERIFY(d.state() == QAudioDecoder::StoppedState);
+    QVERIFY(!buffer.isValid());
+    QVERIFY(!d.bufferAvailable());
+    QCOMPARE(d.position(), qint64(-1));
+
+    QVERIFY(errorSpy.isEmpty());
+    QVERIFY(readySpy.isEmpty());
+    QVERIFY(bufferChangedSpy.isEmpty());
+    QVERIFY(stateSpy.isEmpty());
+    QVERIFY(finishedSpy.isEmpty());
+    QVERIFY(positionSpy.isEmpty());
+    QVERIFY(durationSpy.isEmpty());
+
+
+    d.stop();
+    QTRY_COMPARE(d.state(), QAudioDecoder::StoppedState);
+    QCOMPARE(d.duration(), qint64(-1));
+    QVERIFY(!d.bufferAvailable());
+}
+
+/*
+ The corrupted file is generated by copying a few random numbers
+ from /dev/random on a linux machine.
+*/
+void tst_QAudioDecoderBackend::corruptedFileTest()
+{
+    QAudioDecoder d;
+    QAudioBuffer buffer;
+
+    QVERIFY(d.state() == QAudioDecoder::StoppedState);
+    QVERIFY(d.bufferAvailable() == false);
+    QCOMPARE(d.sourceFilename(), QString(""));
+    QVERIFY(d.audioFormat() == QAudioFormat());
+
+    // Test local file
+    QFileInfo fileInfo(QFINDTESTDATA(TEST_CORRUPTED_FILE_NAME));
+    d.setSourceFilename(fileInfo.absoluteFilePath());
+    QVERIFY(d.state() == QAudioDecoder::StoppedState);
+    QVERIFY(!d.bufferAvailable());
+    QCOMPARE(d.sourceFilename(), fileInfo.absoluteFilePath());
+
+    QSignalSpy readySpy(&d, SIGNAL(bufferReady()));
+    QSignalSpy bufferChangedSpy(&d, SIGNAL(bufferAvailableChanged(bool)));
+    QSignalSpy errorSpy(&d, SIGNAL(error(QAudioDecoder::Error)));
+    QSignalSpy stateSpy(&d, SIGNAL(stateChanged(QAudioDecoder::State)));
+    QSignalSpy durationSpy(&d, SIGNAL(durationChanged(qint64)));
+    QSignalSpy finishedSpy(&d, SIGNAL(finished()));
+    QSignalSpy positionSpy(&d, SIGNAL(positionChanged(qint64)));
+
+    d.start();
+    QTRY_VERIFY(d.state() == QAudioDecoder::StoppedState);
+    QVERIFY(!d.bufferAvailable());
+    QCOMPARE(d.audioFormat(), QAudioFormat());
+    QCOMPARE(d.duration(), qint64(-1));
+    QCOMPARE(d.position(), qint64(-1));
+
+    // Check the error code.
+    QTRY_VERIFY(!errorSpy.isEmpty());
+
+    // Have to use qvariant_cast, toInt will return 0 because unrecognized type;
+    QAudioDecoder::Error errorCode = qvariant_cast<QAudioDecoder::Error>(errorSpy.takeLast().at(0));
+    QCOMPARE(errorCode, QAudioDecoder::FormatError);
+    QCOMPARE(d.error(), QAudioDecoder::FormatError);
+
+    // Check all other spies.
+    QVERIFY(readySpy.isEmpty());
+    QVERIFY(bufferChangedSpy.isEmpty());
+    QVERIFY(stateSpy.isEmpty());
+    QVERIFY(finishedSpy.isEmpty());
+    QVERIFY(positionSpy.isEmpty());
+    QVERIFY(durationSpy.isEmpty());
+
+    errorSpy.clear();
+
+    // Try read even if the file is corrupted to test the robustness.
+    buffer = d.read();
+    QTRY_VERIFY(d.state() == QAudioDecoder::StoppedState);
+    QVERIFY(!buffer.isValid());
+    QVERIFY(!d.bufferAvailable());
+    QCOMPARE(d.position(), qint64(-1));
+
+    QVERIFY(errorSpy.isEmpty());
+    QVERIFY(readySpy.isEmpty());
+    QVERIFY(bufferChangedSpy.isEmpty());
+    QVERIFY(stateSpy.isEmpty());
+    QVERIFY(finishedSpy.isEmpty());
+    QVERIFY(positionSpy.isEmpty());
+    QVERIFY(durationSpy.isEmpty());
+
+
+    d.stop();
+    QTRY_COMPARE(d.state(), QAudioDecoder::StoppedState);
+    QCOMPARE(d.duration(), qint64(-1));
+    QVERIFY(!d.bufferAvailable());
+}
+
 void tst_QAudioDecoderBackend::deviceTest()
 {
     QAudioDecoder d;
@@ -322,6 +478,7 @@ void tst_QAudioDecoderBackend::deviceTest()
         QVERIFY(buffer.isValid());
         QTRY_VERIFY(!positionSpy.isEmpty());
         QVERIFY(positionSpy.takeLast().at(0).toLongLong() == qint64(duration / 1000));
+        QVERIFY(d.position() - (duration / 1000) < 20);
 
         duration += buffer.duration();
         sampleCount += buffer.sampleCount();