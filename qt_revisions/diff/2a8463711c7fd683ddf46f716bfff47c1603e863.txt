diff --git a/examples/declarative-radio/view.qml b/examples/declarative-radio/view.qml
index d772023..bf582e4 100644
--- a/examples/declarative-radio/view.qml
+++ b/examples/declarative-radio/view.qml
@@ -72,7 +72,7 @@ Rectangle {
                 height: 200
 
                 verticalAlignment: Text.AlignVCenter
-                text: (radio.isAvailable() ? "No Signal " : "No Radio Found")
+                text: (radio.availability == Radio.Available ? "No Signal " : "No Radio Found")
             }
         }
 
diff --git a/src/imports/multimedia/Video.qml b/src/imports/multimedia/Video.qml
index bef20a9..861d291 100644
--- a/src/imports/multimedia/Video.qml
+++ b/src/imports/multimedia/Video.qml
@@ -193,6 +193,28 @@ Item {
     property alias errorString:     player.errorString
 
     /*!
+        \qmlproperty enumeration Video::availability
+
+        Returns the availability state of the video element.
+
+        This is one of:
+        \table
+        \header \li Value \li Description
+        \row \li MediaPlayer.Available
+            \li The video player is available to use.
+        \row \li MediaPlayer.Busy
+            \li The video player is usually available, but some other
+               process is utilizing the hardware necessary to play media.
+        \row \li MediaPlayer.Unavailable
+            \li There are no supported video playback facilities.
+        \row \li MediaPlayer.ResourceMissing
+            \li There is one or more resources missing, so the video player cannot
+               be used.  It may be possible to try again at a later time.
+        \endtable
+     */
+    property alias availability:    player.availability
+
+    /*!
         \qmlproperty bool Video::hasAudio
 
         This property holds whether the current media has audio content.
diff --git a/src/imports/multimedia/qdeclarativeaudio.cpp b/src/imports/multimedia/qdeclarativeaudio.cpp
index 6d56610..e1ab6e8 100644
--- a/src/imports/multimedia/qdeclarativeaudio.cpp
+++ b/src/imports/multimedia/qdeclarativeaudio.cpp
@@ -42,6 +42,7 @@
 #include "qdeclarativeaudio_p.h"
 
 #include <qmediaplayercontrol.h>
+#include <qmediaavailabilitycontrol.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -152,6 +153,11 @@ void QDeclarativeAudio::_q_error(int errorCode, const QString &errorString)
     emit errorChanged();
 }
 
+void QDeclarativeAudio::_q_availabilityChanged(QtMultimedia::AvailabilityError)
+{
+    emit availabilityChanged(availability());
+}
+
 
 QDeclarativeAudio::QDeclarativeAudio(QObject *parent)
     : QObject(parent)
@@ -164,6 +170,35 @@ QDeclarativeAudio::~QDeclarativeAudio()
 }
 
 /*!
+    \qmlproperty enumeration QtMultimedia5::Audio::availability
+
+    Returns the availability state of the media player.
+
+    This is one of:
+    \table
+    \header \li Value \li Description
+    \row \li Available
+        \li The media player is available to use.
+    \row \li Busy
+        \li The media player is usually available, but some other
+           process is utilizing the hardware necessary to play media.
+    \row \li Unavailable
+        \li There are no supported media playback facilities.
+    \row \li ResourceMissing
+        \li There is one or more resources missing, so the media player cannot
+           be used.  It may be possible to try again at a later time.
+    \endtable
+ */
+QDeclarativeAudio::Availability QDeclarativeAudio::availability() const
+{
+    if (!m_playerControl)
+        return Unavailable;
+    if (m_availabilityControl)
+        return Availability(m_availabilityControl->availability());
+    return Available;
+}
+
+/*!
     \qmlmethod QtMultimedia5::Audio::play()
 
     Starts playback of the media.
diff --git a/src/imports/multimedia/qdeclarativeaudio_p.h b/src/imports/multimedia/qdeclarativeaudio_p.h
index 9428328..6d2497f 100644
--- a/src/imports/multimedia/qdeclarativeaudio_p.h
+++ b/src/imports/multimedia/qdeclarativeaudio_p.h
@@ -87,10 +87,12 @@ class QDeclarativeAudio : public QObject, public QDeclarativeMediaBase, public Q
     Q_PROPERTY(QString errorString READ errorString NOTIFY errorChanged)
     Q_PROPERTY(QDeclarativeMediaMetaData *metaData READ metaData CONSTANT)
     Q_PROPERTY(QObject *mediaObject READ mediaObject NOTIFY mediaObjectChanged SCRIPTABLE false DESIGNABLE false)
+    Q_PROPERTY(Availability availability READ availability NOTIFY availabilityChanged)
     Q_ENUMS(Status)
     Q_ENUMS(Error)
     Q_ENUMS(Loop)
     Q_ENUMS(PlaybackState)
+    Q_ENUMS(Availability)
     Q_INTERFACES(QDeclarativeParserStatus)
 public:
     enum Status
@@ -128,6 +130,13 @@ public:
         StoppedState = QMediaPlayer::StoppedState
     };
 
+    enum Availability {
+        Available = QtMultimedia::NoError,
+        Busy = QtMultimedia::BusyError,
+        Unavailable = QtMultimedia::ServiceMissingError,
+        ResourceMissing = QtMultimedia::ResourceError
+    };
+
     QDeclarativeAudio(QObject *parent = 0);
     ~QDeclarativeAudio();
 
@@ -143,6 +152,8 @@ public:
 
     QObject *mediaObject() { return m_mediaObject; }
 
+    Availability availability() const;
+
 public Q_SLOTS:
     void play();
     void pause();
@@ -175,6 +186,8 @@ Q_SIGNALS:
     void seekableChanged();
     void playbackRateChanged();
 
+    void availabilityChanged(Availability availability);
+
     void errorChanged();
     void error(QDeclarativeAudio::Error error, const QString &errorString);
 
@@ -182,6 +195,7 @@ Q_SIGNALS:
 
 private Q_SLOTS:
     void _q_error(int, const QString &);
+    void _q_availabilityChanged(QtMultimedia::AvailabilityError);
 
 private:
     Q_DISABLE_COPY(QDeclarativeAudio)
diff --git a/src/imports/multimedia/qdeclarativecamera.cpp b/src/imports/multimedia/qdeclarativecamera.cpp
index b6d2583..60aae91 100644
--- a/src/imports/multimedia/qdeclarativecamera.cpp
+++ b/src/imports/multimedia/qdeclarativecamera.cpp
@@ -68,6 +68,11 @@ void QDeclarativeCamera::_q_updateState(QCamera::State state)
     emit cameraStateChanged(QDeclarativeCamera::State(state));
 }
 
+void QDeclarativeCamera::_q_availabilityChanged(QtMultimedia::AvailabilityError error)
+{
+    emit availabilityChanged(Availability(error));
+}
+
 /*!
     \qmlclass Camera QDeclarativeCamera
     \brief The Camera element allows you to access viewfinder frames, and take photos and movies.
@@ -176,6 +181,9 @@ QDeclarativeCamera::QDeclarativeCamera(QObject *parent) :
     connect(m_camera, SIGNAL(lockStatusChanged(QCamera::LockStatus,QCamera::LockChangeReason)), this, SIGNAL(lockStatusChanged()));
     connect(m_camera, SIGNAL(stateChanged(QCamera::State)), this, SLOT(_q_updateState(QCamera::State)));
 
+    // Note we map availabilityError->availability
+    connect(m_camera, SIGNAL(availabilityErrorChanged(QtMultimedia::AvailabilityError)), this, SLOT(_q_availabilityChanged(QtMultimedia::AvailabilityError)));
+
     connect(m_camera->focus(), SIGNAL(opticalZoomChanged(qreal)), this, SIGNAL(opticalZoomChanged(qreal)));
     connect(m_camera->focus(), SIGNAL(digitalZoomChanged(qreal)), this, SIGNAL(digitalZoomChanged(qreal)));
     connect(m_camera->focus(), SIGNAL(maximumOpticalZoomChanged(qreal)), this, SIGNAL(maximumOpticalZoomChanged(qreal)));
@@ -218,6 +226,35 @@ QString QDeclarativeCamera::errorString() const
 }
 
 /*!
+    \qmlproperty enumeration QtMultimedia5::Camera::availability
+
+    Returns the availability state of the camera.
+
+    This is one of:
+
+    \table
+    \header \li Value \li Description
+    \row \li Available
+        \li The camera is available to use
+    \row \li Busy
+        \li The camera is usually available to use, but is currently busy.
+           This can happen when some other process needs to use the camera
+           hardware.
+    \row \li Unavailable
+        \li The camera is not available to use (there may be no camera
+           hardware)
+    \row \li ResourceMissing
+        \li There is one or more resources missing, so the camera cannot
+           be used.  It may be possible to try again at a later time.
+    \endtable
+ */
+QDeclarativeCamera::Availability QDeclarativeCamera::availability() const
+{
+    return Availability(m_camera->availabilityError());
+}
+
+
+/*!
     \qmlproperty enumeration QtMultimedia5::Camera::captureMode
 
     \table
diff --git a/src/imports/multimedia/qdeclarativecamera_p.h b/src/imports/multimedia/qdeclarativecamera_p.h
index 30604c6..8ac9957 100644
--- a/src/imports/multimedia/qdeclarativecamera_p.h
+++ b/src/imports/multimedia/qdeclarativecamera_p.h
@@ -84,6 +84,8 @@ class QDeclarativeCamera : public QObject, public QDeclarativeParserStatus
     Q_PROPERTY(LockStatus lockStatus READ lockStatus NOTIFY lockStatusChanged)
     Q_PROPERTY(QString errorString READ errorString NOTIFY errorChanged)
 
+    Q_PROPERTY(Availability availability READ availability NOTIFY availabilityChanged)
+
     Q_PROPERTY(qreal opticalZoom READ opticalZoom WRITE setOpticalZoom NOTIFY opticalZoomChanged)
     Q_PROPERTY(qreal maximumOpticalZoom READ maximumOpticalZoom NOTIFY maximumOpticalZoomChanged)
     Q_PROPERTY(qreal digitalZoom READ digitalZoom WRITE setDigitalZoom NOTIFY digitalZoomChanged)
@@ -109,6 +111,8 @@ class QDeclarativeCamera : public QObject, public QDeclarativeParserStatus
     Q_ENUMS(FocusMode)
     Q_ENUMS(FocusPointMode)
     Q_ENUMS(FocusAreaStatus)
+    Q_ENUMS(Availability)
+
 public:
     enum CaptureMode {
         CaptureStillImage = QCamera::CaptureStillImage,
@@ -193,6 +197,12 @@ public:
         FocusAreaFocused = QCameraFocusZone::Focused
     };
 
+    enum Availability {
+        Available = QtMultimedia::NoError,
+        Busy = QtMultimedia::BusyError,
+        Unavailable = QtMultimedia::ServiceMissingError,
+        ResourceMissing = QtMultimedia::ResourceError
+    };
 
     QDeclarativeCamera(QObject *parent = 0);
     ~QDeclarativeCamera();
@@ -220,6 +230,8 @@ public:
     qreal opticalZoom() const;
     qreal digitalZoom() const;
 
+    Availability availability() const;
+
 public Q_SLOTS:
     void setCaptureMode(CaptureMode mode);
 
@@ -250,9 +262,12 @@ Q_SIGNALS:
 
     void mediaObjectChanged();
 
+    void availabilityChanged(Availability availability);
+
 private Q_SLOTS:
     void _q_updateState(QCamera::State);
     void _q_error(int, const QString &);
+    void _q_availabilityChanged(QtMultimedia::AvailabilityError);
 
 protected:
     void classBegin();
diff --git a/src/imports/multimedia/qdeclarativemediabase.cpp b/src/imports/multimedia/qdeclarativemediabase.cpp
index a1f80f2..934464c 100644
--- a/src/imports/multimedia/qdeclarativemediabase.cpp
+++ b/src/imports/multimedia/qdeclarativemediabase.cpp
@@ -49,6 +49,7 @@
 #include <qmediaservice.h>
 #include <private/qmediaserviceprovider_p.h>
 #include <qmetadatareadercontrol.h>
+#include <qmediaavailabilitycontrol.h>
 
 #include "qdeclarativemediametadata_p.h"
 
@@ -98,6 +99,22 @@ public:
     void stop() {}
 };
 
+class QDeclarativeMediaBaseAvailabilityControl : public QMediaAvailabilityControl
+{
+public:
+    QDeclarativeMediaBaseAvailabilityControl(bool available)
+        : m_available(available)
+    {
+    }
+
+    QtMultimedia::AvailabilityError availability() const
+    {
+        return m_available ? QtMultimedia::NoError : QtMultimedia::ServiceMissingError;
+    }
+
+private:
+    bool m_available;
+};
 
 class QDeclarativeMediaBaseMetaDataControl : public QMetaDataReaderControl
 {
@@ -211,6 +228,7 @@ QDeclarativeMediaBase::QDeclarativeMediaBase()
     , m_mediaProvider(0)
     , m_metaDataControl(0)
     , m_animation(0)
+    , m_availabilityControl(0)
     , m_playbackState(QMediaPlayer::StoppedState)
     , m_status(QMediaPlayer::NoMedia)
     , m_error(QMediaPlayer::ServiceMissingError)
@@ -245,9 +263,12 @@ void QDeclarativeMediaBase::setObject(QObject *object, const QByteArray &type)
             m_metaDataControl = qobject_cast<QMetaDataReaderControl *>(
                     m_mediaService->requestControl(QMetaDataReaderControl_iid));
             m_mediaObject = new QDeclarativeMediaBaseObject(m_mediaService);
+            m_availabilityControl = m_mediaService->requestControl<QMediaAvailabilityControl*>();
         }
     }
 
+    bool realPlayer = m_playerControl;
+
     if (m_playerControl) {
         QObject::connect(m_playerControl, SIGNAL(stateChanged(QMediaPlayer::State)),
                 object, SLOT(_q_statusChanged()));
@@ -281,6 +302,12 @@ void QDeclarativeMediaBase::setObject(QObject *object, const QByteArray &type)
     if (!m_metaDataControl)
         m_metaDataControl = new QDeclarativeMediaBaseMetaDataControl(object);
 
+    if (!m_availabilityControl)
+        m_availabilityControl = new QDeclarativeMediaBaseAvailabilityControl(realPlayer);
+
+    QObject::connect(m_availabilityControl, SIGNAL(availabilityChanged(QtMultimedia::AvailabilityError)),
+                     object, SLOT(_q_availabilityChanged(QtMultimedia::AvailabilityError)));
+
     m_metaData.reset(new QDeclarativeMediaMetaData(m_metaDataControl));
 
     QObject::connect(m_metaDataControl, SIGNAL(metaDataChanged()),
diff --git a/src/imports/multimedia/qdeclarativemediabase_p.h b/src/imports/multimedia/qdeclarativemediabase_p.h
index 78c3524..bbf1c24 100644
--- a/src/imports/multimedia/qdeclarativemediabase_p.h
+++ b/src/imports/multimedia/qdeclarativemediabase_p.h
@@ -67,6 +67,7 @@ class QMediaServiceProvider;
 class QMetaDataReaderControl;
 class QDeclarativeMediaBaseAnimation;
 class QDeclarativeMediaMetaData;
+class QMediaAvailabilityControl;
 
 class QDeclarativeMediaBase
 {
@@ -174,6 +175,8 @@ protected:
     QDeclarativeMediaBaseAnimation *m_animation;
     QScopedPointer<QDeclarativeMediaMetaData> m_metaData;
 
+    QMediaAvailabilityControl *m_availabilityControl;
+
     QMediaPlayer::State m_playbackState;
     QMediaPlayer::MediaStatus m_status;
     QMediaPlayer::Error m_error;
diff --git a/src/imports/multimedia/qdeclarativeradio.cpp b/src/imports/multimedia/qdeclarativeradio.cpp
index c029cae..1c7ea4c 100644
--- a/src/imports/multimedia/qdeclarativeradio.cpp
+++ b/src/imports/multimedia/qdeclarativeradio.cpp
@@ -112,6 +112,9 @@ QDeclarativeRadio::QDeclarativeRadio(QObject *parent) :
     connect(m_radioTuner, SIGNAL(stationFound(int, QString)), this, SIGNAL(stationFound(int, QString)));
     connect(m_radioTuner, SIGNAL(antennaConnectedChanged(bool)), this, SIGNAL(antennaConnectedChanged(bool)));
 
+    // Note we map availabilityError->availability
+    connect(m_radioTuner, SIGNAL(availabilityErrorChanged(QtMultimedia::AvailabilityError)), this, SLOT(_q_availabilityChanged(QtMultimedia::AvailabilityError)));
+
     connect(m_radioTuner, SIGNAL(error(QRadioTuner::Error)), this, SLOT(_q_error(QRadioTuner::Error)));
 }
 
@@ -306,13 +309,33 @@ bool QDeclarativeRadio::isAntennaConnected() const
 }
 
 /*!
-    \qmlmethod bool QtMultimedia5::Radio::isAvailable()
+    \qmlproperty enumeration QtMultimedia5::Radio::availability
+
+    Returns the availability state of the radio.
+
+    This is one of:
 
-    Returns whether the radio is ready to use.
+    \table
+    \header \li Value \li Description
+    \row \li Available
+        \li The radio is available to use
+    \row \li Busy
+        \li The radio is usually available to use, but is currently busy.
+           This can happen when some other process needs to use the audio
+           hardware.
+    \row \li Unavailable
+        \li The radio is not available to use (there may be no radio
+           hardware)
+    \row \li ResourceMissing
+        \li There is one or more resources missing, so the radio cannot
+           be used.  It may be possible to try again at a later time.  This
+           can occur if there is no antenna connected - see the \l antennaConnected
+           property as well.
+    \endtable
  */
-bool QDeclarativeRadio::isAvailable() const
+QDeclarativeRadio::Availability QDeclarativeRadio::availability() const
 {
-    return m_radioTuner->isAvailable();
+    return Availability(m_radioTuner->availabilityError());
 }
 
 void QDeclarativeRadio::setBand(QDeclarativeRadio::Band band)
@@ -462,7 +485,7 @@ void QDeclarativeRadio::tuneUp()
 /*!
     \qmlmethod QtMultimedia5::Radio::start()
 
-    Starts the radio. If the radio is available, as determined by the \l isAvailable method,
+    Starts the radio. If the radio is available, as determined by the \l availability property,
     this will result in the \l state becoming \c ActiveState.
  */
 void QDeclarativeRadio::start()
@@ -496,6 +519,11 @@ void QDeclarativeRadio::_q_error(QRadioTuner::Error errorCode)
     emit errorChanged();
 }
 
+void QDeclarativeRadio::_q_availabilityChanged(QtMultimedia::AvailabilityError error)
+{
+    emit availabilityChanged(Availability(error));
+}
+
 /*!
     \qmlsignal QtMultimedia5::Radio::stationFound(int frequency, string stationId)
 
diff --git a/src/imports/multimedia/qdeclarativeradio_p.h b/src/imports/multimedia/qdeclarativeradio_p.h
index d16f248..6444e84 100644
--- a/src/imports/multimedia/qdeclarativeradio_p.h
+++ b/src/imports/multimedia/qdeclarativeradio_p.h
@@ -76,11 +76,13 @@ class QDeclarativeRadio : public QObject
     Q_PROPERTY(int minimumFrequency READ minimumFrequency NOTIFY bandChanged)
     Q_PROPERTY(int maximumFrequency READ maximumFrequency NOTIFY bandChanged)
     Q_PROPERTY(bool antennaConnected READ isAntennaConnected NOTIFY antennaConnectedChanged)
+    Q_PROPERTY(Availability availability READ availability NOTIFY availabilityChanged)
     Q_ENUMS(State)
     Q_ENUMS(Band)
     Q_ENUMS(Error)
     Q_ENUMS(StereoMode)
     Q_ENUMS(SearchMode)
+    Q_ENUMS(Availability)
 
 public:
     enum State {
@@ -114,6 +116,13 @@ public:
         SearchGetStationId = QRadioTuner::SearchGetStationId
     };
 
+    enum Availability {
+        Available = QtMultimedia::NoError,
+        Busy = QtMultimedia::BusyError,
+        Unavailable = QtMultimedia::ServiceMissingError,
+        ResourceMissing = QtMultimedia::ResourceError
+    };
+
     QDeclarativeRadio(QObject *parent = 0);
     ~QDeclarativeRadio();
 
@@ -134,7 +143,8 @@ public:
 
     bool isAntennaConnected() const;
 
-    Q_INVOKABLE bool isAvailable() const;
+    Q_INVOKABLE bool isAvailable() const {return availability() == Available;}
+    Availability availability() const;
 
 public Q_SLOTS:
     void setBand(QDeclarativeRadio::Band band);
@@ -165,6 +175,8 @@ Q_SIGNALS:
     void stationFound(int frequency, QString stationId);
     void antennaConnectedChanged(bool connectionStatus);
 
+    void availabilityChanged(Availability availability);
+
     void errorChanged();
     void error(QDeclarativeRadio::Error errorCode);
 
@@ -172,6 +184,7 @@ private Q_SLOTS:
     void _q_stateChanged(QRadioTuner::State state);
     void _q_bandChanged(QRadioTuner::Band band);
     void _q_error(QRadioTuner::Error errorCode);
+    void _q_availabilityChanged(QtMultimedia::AvailabilityError);
 
 private:
     Q_DISABLE_COPY(QDeclarativeRadio)
diff --git a/src/imports/multimedia/qdeclarativeradiodata.cpp b/src/imports/multimedia/qdeclarativeradiodata.cpp
index ccc3662..5306010 100644
--- a/src/imports/multimedia/qdeclarativeradiodata.cpp
+++ b/src/imports/multimedia/qdeclarativeradiodata.cpp
@@ -112,6 +112,9 @@ QDeclarativeRadioData::QDeclarativeRadioData(QObject *parent) :
     connect(m_radioData, SIGNAL(alternativeFrequenciesEnabledChanged(bool)), this,
                          SIGNAL(alternativeFrequenciesEnabledChanged(bool)));
 
+    // Note we map availabilityError->availability
+    connect(m_radioData, SIGNAL(availabilityErrorChanged(QtMultimedia::AvailabilityError)), this, SLOT(_q_availabilityChanged(QtMultimedia::AvailabilityError)));
+
     connect(m_radioData, SIGNAL(error(QRadioData::Error)), this, SLOT(_q_error(QRadioData::Error)));
 }
 
@@ -120,15 +123,32 @@ QDeclarativeRadioData::~QDeclarativeRadioData()
 }
 
 /*!
-    \qmlmethod bool QtMultimedia5::RadioData::isAvailable()
+    \qmlproperty enumeration QtMultimedia5::RadioData::availability
 
-    Returns whether the radio data element is ready to use.
-  */
-bool QDeclarativeRadioData::isAvailable() const
+    Returns the availability state of the radio data interface.
+
+    This is one of:
+
+    \table
+    \header \li Value \li Description
+    \row \li Available
+        \li The radio data interface is available to use
+    \row \li Busy
+        \li The radio data interface is usually available to use, but is currently busy.
+    \row \li Unavailable
+        \li The radio data interface is not available to use (there may be no radio
+           hardware)
+    \row \li ResourceMissing
+        \li There is one or more resources missing, so the radio cannot
+           be used.  It may be possible to try again at a later time.
+    \endtable
+ */
+QDeclarativeRadioData::Availability QDeclarativeRadioData::availability() const
 {
-    return m_radioData->isAvailable();
+    return Availability(m_radioData->availabilityError());
 }
 
+
 /*!
     \qmlproperty string QtMultimedia5::RadioData::stationId
 
@@ -265,4 +285,9 @@ void QDeclarativeRadioData::_q_error(QRadioData::Error errorCode)
     emit errorChanged();
 }
 
+void QDeclarativeRadioData::_q_availabilityChanged(QtMultimedia::AvailabilityError error)
+{
+    emit availabilityChanged(Availability(error));
+}
+
 QT_END_NAMESPACE
diff --git a/src/imports/multimedia/qdeclarativeradiodata_p.h b/src/imports/multimedia/qdeclarativeradiodata_p.h
index 74763a0..66eb505 100644
--- a/src/imports/multimedia/qdeclarativeradiodata_p.h
+++ b/src/imports/multimedia/qdeclarativeradiodata_p.h
@@ -70,8 +70,10 @@ class QDeclarativeRadioData : public QObject
     Q_PROPERTY(QString radioText READ radioText NOTIFY radioTextChanged)
     Q_PROPERTY(bool alternativeFrequenciesEnabled READ alternativeFrequenciesEnabled
                WRITE setAlternativeFrequenciesEnabled NOTIFY alternativeFrequenciesEnabledChanged)
+    Q_PROPERTY(Availability availability READ availability NOTIFY availabilityChanged)
     Q_ENUMS(Error)
     Q_ENUMS(ProgramType)
+    Q_ENUMS(Availability)
 
 public:
 
@@ -130,14 +132,19 @@ public:
         ReligiousTalk = QRadioData::ReligiousTalk,
         Personality = QRadioData::Personality,
         Public = QRadioData::Public,
-        College = QRadioData::College,
+        College = QRadioData::College
+    };
+
+    enum Availability {
+        Available = QtMultimedia::NoError,
+        Busy = QtMultimedia::BusyError,
+        Unavailable = QtMultimedia::ServiceMissingError,
+        ResourceMissing = QtMultimedia::ResourceError
     };
 
     QDeclarativeRadioData(QObject *parent = 0);
     ~QDeclarativeRadioData();
 
-    Q_INVOKABLE bool isAvailable() const;
-
     QString stationId() const;
     QDeclarativeRadioData::ProgramType programType() const;
     QString programTypeName() const;
@@ -145,6 +152,9 @@ public:
     QString radioText() const;
     bool alternativeFrequenciesEnabled() const;
 
+    Q_INVOKABLE bool isAvailable() const {return availability() == Available;}
+    Availability availability() const;
+
 public Q_SLOTS:
     void setAlternativeFrequenciesEnabled(bool enabled);
 
@@ -156,12 +166,15 @@ Q_SIGNALS:
     void radioTextChanged(QString radioText);
     void alternativeFrequenciesEnabledChanged(bool enabled);
 
+    void availabilityChanged(Availability availability);
+
     void errorChanged();
     void error(QDeclarativeRadioData::Error errorCode);
 
 private Q_SLOTS:
     void _q_programTypeChanged(QRadioData::ProgramType programType);
     void _q_error(QRadioData::Error errorCode);
+    void _q_availabilityChanged(QtMultimedia::AvailabilityError);
 
 private:
     Q_DISABLE_COPY(QDeclarativeRadioData)
diff --git a/src/multimedia/camera/qcamera.cpp b/src/multimedia/camera/qcamera.cpp
index 730a27f..580808c 100644
--- a/src/multimedia/camera/qcamera.cpp
+++ b/src/multimedia/camera/qcamera.cpp
@@ -409,19 +409,9 @@ QCamera::~QCamera()
     }
 }
 
-
 /*!
-    Return true if the camera service is ready to use.
+    Returns the availability state of the camera service.
 */
-bool QCamera::isAvailable() const
-{
-    return availabilityError() == QtMultimedia::NoError;
-}
-
-/*!
-    Returns the error state of the camera service.
-*/
-
 QtMultimedia::AvailabilityError QCamera::availabilityError() const
 {
     Q_D(const QCamera);
@@ -434,7 +424,7 @@ QtMultimedia::AvailabilityError QCamera::availabilityError() const
     if (d->error != QCamera::NoError)
         return QtMultimedia::ResourceError;
 
-    return QtMultimedia::NoError;
+    return QMediaObject::availabilityError();
 }
 
 
diff --git a/src/multimedia/camera/qcamera.h b/src/multimedia/camera/qcamera.h
index c2a7c42..a48bbc9 100644
--- a/src/multimedia/camera/qcamera.h
+++ b/src/multimedia/camera/qcamera.h
@@ -150,7 +150,6 @@ public:
     static QList<QByteArray> availableDevices();
     static QString deviceDescription(const QByteArray &device);
 
-    bool isAvailable() const;
     QtMultimedia::AvailabilityError availabilityError() const;
 
     State state() const;
diff --git a/src/multimedia/controls/controls.pri b/src/multimedia/controls/controls.pri
index 99c9631..919e205 100644
--- a/src/multimedia/controls/controls.pri
+++ b/src/multimedia/controls/controls.pri
@@ -33,7 +33,8 @@ PUBLIC_HEADERS += \
     controls/qvideoencodercontrol.h \
     controls/qvideorenderercontrol.h \
     controls/qmediaaudioprobecontrol.h \
-    controls/qmediavideoprobecontrol.h
+    controls/qmediavideoprobecontrol.h \
+    controls/qmediaavailabilitycontrol.h
 
 PRIVATE_HEADERS += \
     controls/qaudiodecodercontrol_p.h
@@ -71,4 +72,7 @@ SOURCES += \
     controls/qvideorenderercontrol.cpp \
     controls/qmediaaudioprobecontrol.cpp \
     controls/qmediavideoprobecontrol.cpp \
-    controls/qaudiodecodercontrol_p.cpp
+    controls/qaudiodecodercontrol_p.cpp \
+    controls/qmediaavailabilitycontrol.cpp
+
+
diff --git a/src/multimedia/controls/qmediaavailabilitycontrol.cpp b/src/multimedia/controls/qmediaavailabilitycontrol.cpp
new file mode 100644
index 0000000..76f6150
--- /dev/null
+++ b/src/multimedia/controls/qmediaavailabilitycontrol.cpp
@@ -0,0 +1,109 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaavailabilitycontrol.h"
+#include "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaAvailabilityControl
+
+    \brief The QMediaAvailabilityControl class supplies a control for reporting availability of a service.
+
+    \inmodule QtMultimedia
+
+    \ingroup multimedia
+    \ingroup multimedia_control
+
+    An instance of QMediaObject (or its derived classes) can report any changes
+    in availability via this control.
+
+    The interface name of QMediaAvailabilityControl is \c com.nokia.Qt.QMediaAvailabilityControl/1.0 as
+    defined in QMediaAvailabilityControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaObject
+*/
+
+/*!
+    \macro QMediaAvailabilityControl_iid
+
+    \c com.nokia.Qt.QMediaAvailabilityControl/1.0
+
+    Defines the interface name of the QMediaAvailabilityControl class.
+
+    \relates QMediaAvailabilityControl
+*/
+
+/*!
+    Constructs an availability control object with \a parent.
+*/
+QMediaAvailabilityControl::QMediaAvailabilityControl(QObject *parent)
+    : QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destruct the availability control object.
+*/
+QMediaAvailabilityControl::~QMediaAvailabilityControl()
+{
+}
+
+
+/*!
+  \fn QtMultimedia::AvailabilityError QMediaAvailabilityControl::availability() const
+
+  Returns the current availability of this instance of the media service.
+  If the availability changes at run time (for example, some other media
+  client takes all media resources) the availabilityChanges() signal
+  should be emitted.
+*/
+
+
+/*!
+    \fn void QMediaAvailabilityControl::availabilityChanged(QtMultimedia::AvailabilityError availability)
+
+    Signal emitted when the current \a availability value changed.
+*/
+
+#include "moc_qmediaavailabilitycontrol.cpp"
+QT_END_NAMESPACE
diff --git a/src/multimedia/controls/qmediaavailabilitycontrol.h b/src/multimedia/controls/qmediaavailabilitycontrol.h
new file mode 100644
index 0000000..4b0b8a0
--- /dev/null
+++ b/src/multimedia/controls/qmediaavailabilitycontrol.h
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAAVAILABILITYCONTROL_H
+#define QMEDIAAVAILABILITYCONTROL_H
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+#include <qtmedianamespace.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class Q_MULTIMEDIA_EXPORT QMediaAvailabilityControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QMediaAvailabilityControl();
+
+    virtual QtMultimedia::AvailabilityError availability() const = 0;
+
+signals:
+    void availabilityChanged(QtMultimedia::AvailabilityError availability);
+
+protected:
+    QMediaAvailabilityControl(QObject* parent = 0);
+};
+
+#define QMediaAvailabilityControl_iid "com.nokia.Qt.QMediaAvailabilityControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaAvailabilityControl, QMediaAvailabilityControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QMEDIAAVAILABILITYCONTROL_H
diff --git a/src/multimedia/controls/qradiodatacontrol.cpp b/src/multimedia/controls/qradiodatacontrol.cpp
index 845b4a7..19656f6 100644
--- a/src/multimedia/controls/qradiodatacontrol.cpp
+++ b/src/multimedia/controls/qradiodatacontrol.cpp
@@ -94,18 +94,6 @@ QRadioDataControl::~QRadioDataControl()
 }
 
 /*!
-    \fn bool QRadioDataControl::isAvailable() const
-
-    Returns true if the radio service is ready to use.
-*/
-
-/*!
-    \fn QtMultimedia::AvailabilityError QRadioDataControl::availabilityError() const
-
-    Returns the error state of the radio service.
-*/
-
-/*!
     \fn QRadioData::Error QRadioDataControl::error() const
 
     Returns the error state of a radio data.
diff --git a/src/multimedia/controls/qradiodatacontrol.h b/src/multimedia/controls/qradiodatacontrol.h
index c44c6a1..11723f8 100644
--- a/src/multimedia/controls/qradiodatacontrol.h
+++ b/src/multimedia/controls/qradiodatacontrol.h
@@ -59,9 +59,6 @@ class Q_MULTIMEDIA_EXPORT QRadioDataControl : public QMediaControl
 public:
     ~QRadioDataControl();
 
-    virtual bool isAvailable() const = 0;
-    virtual QtMultimedia::AvailabilityError availabilityError() const = 0;
-
     virtual QString stationId() const = 0;
     virtual QRadioData::ProgramType programType() const = 0;
     virtual QString programTypeName() const = 0;
diff --git a/src/multimedia/controls/qradiotunercontrol.cpp b/src/multimedia/controls/qradiotunercontrol.cpp
index c86a0a1..c0f3cc1 100644
--- a/src/multimedia/controls/qradiotunercontrol.cpp
+++ b/src/multimedia/controls/qradiotunercontrol.cpp
@@ -100,18 +100,6 @@ QRadioTunerControl::~QRadioTunerControl()
 }
 
 /*!
-    \fn bool QRadioTunerControl::isAvailable() const
-
-    Returns true if the radio service is ready to use.
-*/
-
-/*!
-    \fn QtMultimedia::AvailabilityError QRadioTunerControl::availabilityError() const
-
-    Returns the error state of the radio service.
-*/
-
-/*!
     \fn QRadioTuner::State QRadioTunerControl::state() const
 
     Returns the current radio tuner state.
@@ -235,7 +223,7 @@ QRadioTunerControl::~QRadioTunerControl()
 */
 
 /*!
-    \fn bool QRadioTunerControl::antennaConnected() const
+    \fn bool QRadioTunerControl::isAntennaConnected() const
 
     Identifies if there is an antenna connected to the device.
 
diff --git a/src/multimedia/controls/qradiotunercontrol.h b/src/multimedia/controls/qradiotunercontrol.h
index 354e9c2..2e64fbf 100644
--- a/src/multimedia/controls/qradiotunercontrol.h
+++ b/src/multimedia/controls/qradiotunercontrol.h
@@ -59,9 +59,6 @@ class Q_MULTIMEDIA_EXPORT QRadioTunerControl : public QMediaControl
 public:
     ~QRadioTunerControl();
 
-    virtual bool isAvailable() const = 0;
-    virtual QtMultimedia::AvailabilityError availabilityError() const = 0;
-
     virtual QRadioTuner::State state() const = 0;
 
     virtual QRadioTuner::Band band() const = 0;
diff --git a/src/multimedia/playback/qmediaplayer.cpp b/src/multimedia/playback/qmediaplayer.cpp
index de78060..0375f5e 100644
--- a/src/multimedia/playback/qmediaplayer.cpp
+++ b/src/multimedia/playback/qmediaplayer.cpp
@@ -778,6 +778,17 @@ void QMediaPlayer::setVideoOutput(QAbstractVideoSurface *surface)
     }
 }
 
+/*! \reimp */
+QtMultimedia::AvailabilityError QMediaPlayer::availabilityError() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (!d->control)
+        return QtMultimedia::ServiceMissingError;
+
+    return QMediaObject::availabilityError();
+}
+
 // Enums
 /*!
     \enum QMediaPlayer::State
diff --git a/src/multimedia/playback/qmediaplayer.h b/src/multimedia/playback/qmediaplayer.h
index bf50024..eed09b5 100644
--- a/src/multimedia/playback/qmediaplayer.h
+++ b/src/multimedia/playback/qmediaplayer.h
@@ -158,6 +158,8 @@ public:
 
     QNetworkConfiguration currentNetworkConfiguration() const;
 
+    QtMultimedia::AvailabilityError availabilityError() const;
+
 public Q_SLOTS:
     void play();
     void pause();
diff --git a/src/multimedia/qmediaobject.cpp b/src/multimedia/qmediaobject.cpp
index b957e95..3e5773c 100644
--- a/src/multimedia/qmediaobject.cpp
+++ b/src/multimedia/qmediaobject.cpp
@@ -47,7 +47,7 @@
 #include <qmediaservice.h>
 #include <qmetadatareadercontrol.h>
 #include <qmediabindableinterface.h>
-
+#include <qmediaavailabilitycontrol.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -64,6 +64,17 @@ void QMediaObjectPrivate::_q_notify()
     }
 }
 
+void QMediaObjectPrivate::_q_availabilityChanged()
+{
+    Q_Q(QMediaObject);
+
+    // Really this should not always emit, but
+    // we can't really tell from here (isAvailable
+    // may not have changed, or the mediaobject's overridden
+    // availabilityError() may not have changed).
+    q->availabilityErrorChanged(q->availabilityError());
+    q->availabilityChanged(q->isAvailable());
+}
 
 /*!
     \class QMediaObject
@@ -104,7 +115,13 @@ QMediaObject::~QMediaObject()
 
 QtMultimedia::AvailabilityError QMediaObject::availabilityError() const
 {
-    return d_func()->service == 0 ? QtMultimedia::ServiceMissingError : QtMultimedia::NoError;
+    if (d_func()->service == 0)
+        return QtMultimedia::ServiceMissingError;
+
+    if (d_func()->availabilityControl)
+        return d_func()->availabilityControl->availability();
+
+    return QtMultimedia::NoError;
 }
 
 /*!
@@ -113,7 +130,7 @@ QtMultimedia::AvailabilityError QMediaObject::availabilityError() const
 
 bool QMediaObject::isAvailable() const
 {
-    return d_func()->service != 0;
+    return availabilityError() == QtMultimedia::NoError;
 }
 
 /*!
@@ -216,7 +233,7 @@ QMediaObject::QMediaObject(QObject *parent, QMediaService *service):
 
     d->service = service;
 
-    setupMetaData();
+    setupControls();
 }
 
 /*!
@@ -237,7 +254,7 @@ QMediaObject::QMediaObject(QMediaObjectPrivate &dd, QObject *parent,
 
     d->service = service;
 
-    setupMetaData();
+    setupControls();
 }
 
 /*!
@@ -360,7 +377,7 @@ QStringList QMediaObject::availableMetaData() const
 */
 
 
-void QMediaObject::setupMetaData()
+void QMediaObject::setupControls()
 {
     Q_D(QMediaObject);
 
@@ -377,6 +394,13 @@ void QMediaObject::setupMetaData()
                     SIGNAL(metaDataAvailableChanged(bool)),
                     SIGNAL(metaDataAvailableChanged(bool)));
         }
+
+        d->availabilityControl = d->service->requestControl<QMediaAvailabilityControl*>();
+        if (d->availabilityControl) {
+            connect(d->availabilityControl,
+                    SIGNAL(availabilityChanged(QtMultimedia::AvailabilityError)),
+                    SLOT(_q_availabilityChanged()));
+        }
     }
 }
 
diff --git a/src/multimedia/qmediaobject.h b/src/multimedia/qmediaobject.h
index f1805da..3c67dd6 100644
--- a/src/multimedia/qmediaobject.h
+++ b/src/multimedia/qmediaobject.h
@@ -90,6 +90,7 @@ Q_SIGNALS:
     void metaDataChanged(const QString &key, const QVariant &value);
 
     void availabilityChanged(bool available);
+    void availabilityErrorChanged(QtMultimedia::AvailabilityError error);
 
 protected:
     QMediaObject(QObject *parent, QMediaService *service);
@@ -101,10 +102,11 @@ protected:
     QMediaObjectPrivate *d_ptr;
 
 private:
-    void setupMetaData();
+    void setupControls();
 
     Q_DECLARE_PRIVATE(QMediaObject)
     Q_PRIVATE_SLOT(d_func(), void _q_notify())
+    Q_PRIVATE_SLOT(d_func(), void _q_availabilityChanged())
 };
 
 
diff --git a/src/multimedia/qmediaobject_p.h b/src/multimedia/qmediaobject_p.h
index 310dd04..33f7134 100644
--- a/src/multimedia/qmediaobject_p.h
+++ b/src/multimedia/qmediaobject_p.h
@@ -67,6 +67,7 @@ QT_MODULE(Multimedia)
 
 
 class QMetaDataReaderControl;
+class QMediaAvailabilityControl;
 
 #define Q_DECLARE_NON_CONST_PUBLIC(Class) \
     inline Class* q_func() { return static_cast<Class *>(q_ptr); } \
@@ -82,9 +83,12 @@ public:
     virtual ~QMediaObjectPrivate() {}
 
     void _q_notify();
+    void _q_availabilityChanged();
 
     QMediaService *service;
     QMetaDataReaderControl *metaDataControl;
+    QMediaAvailabilityControl *availabilityControl;
+
     QTimer* notifyTimer;
     QSet<int> notifyProperties;
 
diff --git a/src/multimedia/radio/qradiodata.cpp b/src/multimedia/radio/qradiodata.cpp
index 7ea099c..30a495a 100644
--- a/src/multimedia/radio/qradiodata.cpp
+++ b/src/multimedia/radio/qradiodata.cpp
@@ -133,29 +133,16 @@ QRadioData::~QRadioData()
 }
 
 /*!
-    Returns true if the radio data service is ready to use.
-*/
-bool QRadioData::isAvailable() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d_func()->control->isAvailable();
-    else
-        return false;
-}
-
-/*!
-    Returns the availability error state.
+    Returns the availability of the radio data service.
 */
 QtMultimedia::AvailabilityError QRadioData::availabilityError() const
 {
     Q_D(const QRadioData);
 
-    if (d->control != 0)
-        return d_func()->control->availabilityError();
-    else
+    if (d->control == 0)
         return QtMultimedia::ServiceMissingError;
+
+    return QMediaObject::availabilityError();
 }
 
 /*!
diff --git a/src/multimedia/radio/qradiodata.h b/src/multimedia/radio/qradiodata.h
index c6c07ad..03c5031 100644
--- a/src/multimedia/radio/qradiodata.h
+++ b/src/multimedia/radio/qradiodata.h
@@ -90,7 +90,6 @@ public:
     QRadioData(QObject *parent = 0);
     ~QRadioData();
 
-    bool isAvailable() const;
     QtMultimedia::AvailabilityError availabilityError() const;
 
     QString stationId() const;
diff --git a/src/multimedia/radio/qradiotuner.cpp b/src/multimedia/radio/qradiotuner.cpp
index 30b77eb..e847d05 100644
--- a/src/multimedia/radio/qradiotuner.cpp
+++ b/src/multimedia/radio/qradiotuner.cpp
@@ -149,25 +149,17 @@ QRadioTuner::~QRadioTuner()
 }
 
 /*!
-    Returns true if the radio tuner service is ready to use.
-*/
-bool QRadioTuner::isAvailable() const
-{
-    if (d_func()->control != NULL)
-        return d_func()->control->isAvailable();
-    else
-        return false;
-}
-
-/*!
-    Returns the availability error state.
+    Returns the availability of the radio tuner.
 */
 QtMultimedia::AvailabilityError QRadioTuner::availabilityError() const
 {
-    if (d_func()->control != NULL)
-        return d_func()->control->availabilityError();
-    else
+    if (d_func()->control == 0)
         return QtMultimedia::ServiceMissingError;
+
+    if (!d_func()->control->isAntennaConnected())
+        return QtMultimedia::ResourceError;
+
+    return QMediaObject::availabilityError();
 }
 
 /*!
diff --git a/src/multimedia/radio/qradiotuner.h b/src/multimedia/radio/qradiotuner.h
index 46c6cfe..059d540 100644
--- a/src/multimedia/radio/qradiotuner.h
+++ b/src/multimedia/radio/qradiotuner.h
@@ -86,7 +86,6 @@ public:
     QRadioTuner(QObject *parent = 0);
     ~QRadioTuner();
 
-    bool isAvailable() const;
     QtMultimedia::AvailabilityError availabilityError() const;
 
     State state() const;
diff --git a/src/multimedia/recording/qmediarecorder.cpp b/src/multimedia/recording/qmediarecorder.cpp
index d1f3bdd..d57ca0b 100644
--- a/src/multimedia/recording/qmediarecorder.cpp
+++ b/src/multimedia/recording/qmediarecorder.cpp
@@ -50,6 +50,7 @@
 #include <qaudioencodercontrol.h>
 #include <qvideoencodercontrol.h>
 #include <qmediacontainercontrol.h>
+#include <qmediaavailabilitycontrol.h>
 #include <qcamera.h>
 #include <qcameracontrol.h>
 
@@ -99,6 +100,7 @@ QMediaRecorderPrivate::QMediaRecorderPrivate():
      audioControl(0),
      videoControl(0),
      metaDataControl(0),
+     availabilityControl(0),
      notifyTimer(0),
      state(QMediaRecorder::StoppedState),
      error(QMediaRecorder::NoError)
@@ -143,6 +145,7 @@ void QMediaRecorderPrivate::_q_serviceDestroyed()
     audioControl = 0;
     videoControl = 0;
     metaDataControl = 0;
+    availabilityControl = 0;
 }
 
 void QMediaRecorderPrivate::_q_updateActualLocation(const QUrl &location)
@@ -179,6 +182,19 @@ void QMediaRecorderPrivate::_q_applySettings()
     }
 }
 
+void QMediaRecorderPrivate::_q_availabilityChanged(QtMultimedia::AvailabilityError error)
+{
+    Q_Q(QMediaRecorder);
+    Q_UNUSED(error);
+
+    // Really this should not always emit, but
+    // we can't really tell from here (isAvailable
+    // may not have changed, or the mediaobject's overridden
+    // availabilityError() may not have changed).
+    q->availabilityErrorChanged(q->availabilityError());
+    q->availabilityChanged(q->isAvailable());
+}
+
 void QMediaRecorderPrivate::restartCamera()
 {
     //restart camera if it can't apply new settings in the Active state
@@ -299,6 +315,11 @@ bool QMediaRecorder::setMediaObject(QMediaObject *object)
 
                 service->releaseControl(d->metaDataControl);
             }
+            if (d->availabilityControl) {
+                disconnect(d->availabilityControl, SIGNAL(availabilityChanged(QtMultimedia::AvailabilityError)),
+                           this, SLOT(_q_availabilityChanged(QtMultimedia::AvailabilityError)));
+                service->releaseControl(d->availabilityControl);
+            }
         }
     }
 
@@ -307,6 +328,7 @@ bool QMediaRecorder::setMediaObject(QMediaObject *object)
     d->audioControl = 0;
     d->videoControl = 0;
     d->metaDataControl = 0;
+    d->availabilityControl = 0;
 
     d->mediaObject = object;
 
@@ -344,6 +366,12 @@ bool QMediaRecorder::setMediaObject(QMediaObject *object)
                     }
                 }
 
+                d->availabilityControl = service->requestControl<QMediaAvailabilityControl*>();
+                if (d->availabilityControl) {
+                    connect(d->availabilityControl, SIGNAL(availabilityChanged(QtMultimedia::AvailabilityError)),
+                            this, SLOT(_q_availabilityChanged(QtMultimedia::AvailabilityError)));
+                }
+
                 connect(d->control, SIGNAL(stateChanged(QMediaRecorder::State)),
                         this, SLOT(_q_stateChanged(QMediaRecorder::State)));
 
@@ -399,24 +427,28 @@ bool QMediaRecorder::setMediaObject(QMediaObject *object)
 
 /*!
     Returns true if media recorder service ready to use.
+
+    \sa availabilityChanged()
 */
 bool QMediaRecorder::isAvailable() const
 {
-    if (d_func()->control != NULL)
-        return true;
-    else
-        return false;
+    return availabilityError() == QtMultimedia::NoError;
 }
 
 /*!
     Returns the availability error code.
+
+    \sa availabilityErrorChanged()
 */
 QtMultimedia::AvailabilityError QMediaRecorder::availabilityError() const
 {
-    if (d_func()->control != NULL)
-        return QtMultimedia::NoError;
-    else
+    if (d_func()->control == NULL)
         return QtMultimedia::ServiceMissingError;
+
+    if (d_func()->availabilityControl)
+        return d_func()->availabilityControl->availability();
+
+    return QtMultimedia::NoError;
 }
 
 QUrl QMediaRecorder::outputLocation() const
@@ -767,7 +799,7 @@ void QMediaRecorder::setEncodingSettings(const QAudioEncoderSettings &audio,
     Start recording.
 
     This is an asynchronous call, with signal
-    stateCahnged(QMediaRecorder::RecordingState) being emitted when recording
+    stateChanged(QMediaRecorder::RecordingState) being emitted when recording
     started, otherwise the error() signal is emitted.
 */
 
@@ -852,6 +884,18 @@ void QMediaRecorder::stop()
 */
 
 /*!
+    \fn QMediaRecorder::availableChanged(bool available)
+
+    Signals that the media recorder is now available (if \a available is true), or not.
+*/
+
+/*!
+    \fn QMediaRecorder::availabilityErrorChanged(QtMultimedia::AvailabilityError availability)
+
+    Signals that the service availability has changed to \a availability.
+*/
+
+/*!
     \fn QMediaRecorder::mutedChanged(bool muted)
 
     Signals that the \a muted state has changed. If true the recording is being muted.
diff --git a/src/multimedia/recording/qmediarecorder.h b/src/multimedia/recording/qmediarecorder.h
index 1aac73c..84a6eca 100644
--- a/src/multimedia/recording/qmediarecorder.h
+++ b/src/multimedia/recording/qmediarecorder.h
@@ -42,6 +42,7 @@
 #ifndef QMEDIARECORDER_H
 #define QMEDIARECORDER_H
 
+#include <qtmedianamespace.h>
 #include <qmediaobject.h>
 #include <qmediaencodersettings.h>
 #include <qmediabindableinterface.h>
@@ -173,6 +174,9 @@ Q_SIGNALS:
     void metaDataChanged();
     void metaDataChanged(const QString &key, const QVariant &value);
 
+    void availabilityChanged(bool available);
+    void availabilityErrorChanged(QtMultimedia::AvailabilityError error);
+
 protected:
     QMediaRecorder(QMediaRecorderPrivate &dd, QMediaObject *mediaObject, QObject *parent = 0);
     bool setMediaObject(QMediaObject *object);
@@ -188,6 +192,7 @@ private:
     Q_PRIVATE_SLOT(d_func(), void _q_updateActualLocation(const QUrl &))
     Q_PRIVATE_SLOT(d_func(), void _q_updateNotifyInterval(int))
     Q_PRIVATE_SLOT(d_func(), void _q_applySettings())
+    Q_PRIVATE_SLOT(d_func(), void _q_availabilityChanged(QtMultimedia::AvailabilityError))
 };
 
 QT_END_NAMESPACE
diff --git a/src/multimedia/recording/qmediarecorder_p.h b/src/multimedia/recording/qmediarecorder_p.h
index b899665..03919ef 100644
--- a/src/multimedia/recording/qmediarecorder_p.h
+++ b/src/multimedia/recording/qmediarecorder_p.h
@@ -53,6 +53,7 @@ class QMediaContainerControl;
 class QAudioEncoderControl;
 class QVideoEncoderControl;
 class QMetaDataWriterControl;
+class QMediaAvailabilityControl;
 class QTimer;
 
 class QMediaRecorderPrivate
@@ -73,6 +74,7 @@ public:
     QAudioEncoderControl *audioControl;
     QVideoEncoderControl *videoControl;
     QMetaDataWriterControl *metaDataControl;
+    QMediaAvailabilityControl *availabilityControl;
 
     bool settingsChanged;
 
@@ -90,6 +92,7 @@ public:
     void _q_notify();
     void _q_updateNotifyInterval(int ms);
     void _q_applySettings();
+    void _q_availabilityChanged(QtMultimedia::AvailabilityError error);
 
     QMediaRecorder *q_ptr;
 };
diff --git a/tests/auto/unit/qmediaobject/qmediaobject.pro b/tests/auto/unit/qmediaobject/qmediaobject.pro
index e84e5c7..71a22ee 100644
--- a/tests/auto/unit/qmediaobject/qmediaobject.pro
+++ b/tests/auto/unit/qmediaobject/qmediaobject.pro
@@ -3,5 +3,6 @@ TARGET = tst_qmediaobject
 QT += multimedia-private testlib
 
 include (../qmultimedia_common/mockrecorder.pri)
+include (../qmultimedia_common/mock.pri)
 
 SOURCES += tst_qmediaobject.cpp
diff --git a/tests/auto/unit/qmediaobject/tst_qmediaobject.cpp b/tests/auto/unit/qmediaobject/tst_qmediaobject.cpp
index 3887463..977037d 100644
--- a/tests/auto/unit/qmediaobject/tst_qmediaobject.cpp
+++ b/tests/auto/unit/qmediaobject/tst_qmediaobject.cpp
@@ -53,12 +53,17 @@
 #include "mockmediarecorderservice.h"
 #include "mockmediaserviceprovider.h"
 #include "mockmetadatareadercontrol.h"
+#include "mockavailabilitycontrol.h"
 
-class QtTestMetaDataService : public QMediaService
+class QtTestMediaObjectService : public QMediaService
 {
     Q_OBJECT
 public:
-    QtTestMetaDataService(QObject *parent = 0):QMediaService(parent), metaDataRef(0), hasMetaData(true)
+    QtTestMediaObjectService(QObject *parent = 0, MockAvailabilityControl *availability = 0)
+        : QMediaService(parent)
+        , availabilityControl(availability)
+        , metaDataRef(0)
+        , hasMetaData(true)
     {
     }
 
@@ -66,6 +71,8 @@ public:
     {
         if (hasMetaData && qstrcmp(iid, QMetaDataReaderControl_iid) == 0)
             return &metaData;
+        else if (qstrcmp(iid, QMediaAvailabilityControl_iid) == 0)
+            return availabilityControl;
         else
             return 0;
     }
@@ -75,6 +82,7 @@ public:
     }
 
     MockMetaDataReaderControl metaData;
+    MockAvailabilityControl *availabilityControl;
     int metaDataRef;
     bool hasMetaData;
 };
@@ -329,7 +337,7 @@ void tst_QMediaObject::nullMetaDataControl()
     const QString titleKey(QLatin1String("Title"));
     const QString title(QLatin1String("Host of Seraphim"));
 
-    QtTestMetaDataService service;
+    QtTestMediaObjectService service;
     service.hasMetaData = false;
 
     QtTestMediaObject object(&service);
@@ -345,7 +353,7 @@ void tst_QMediaObject::nullMetaDataControl()
 
 void tst_QMediaObject::isMetaDataAvailable()
 {
-    QtTestMetaDataService service;
+    QtTestMediaObjectService service;
     service.metaData.setMetaDataAvailable(false);
 
     QtTestMediaObject object(&service);
@@ -367,7 +375,7 @@ void tst_QMediaObject::isMetaDataAvailable()
 
 void tst_QMediaObject::metaDataChanged()
 {
-    QtTestMetaDataService service;
+    QtTestMediaObjectService service;
     QtTestMediaObject object(&service);
 
     QSignalSpy changedSpy(&object, SIGNAL(metaDataChanged()));
@@ -408,7 +416,7 @@ void tst_QMediaObject::metaData()
     QFETCH(QString, title);
     QFETCH(QString, genre);
 
-    QtTestMetaDataService service;
+    QtTestMediaObjectService service;
     service.metaData.populateMetaData();
 
     QtTestMediaObject object(&service);
@@ -430,20 +438,64 @@ void tst_QMediaObject::metaData()
 
 void tst_QMediaObject::availability()
 {
-    QtTestMediaObject nullObject(0);
-    QCOMPARE(nullObject.isAvailable(), false);
-    QCOMPARE(nullObject.availabilityError(), QtMultimedia::ServiceMissingError);
+    {
+        QtTestMediaObject nullObject(0);
+        QCOMPARE(nullObject.isAvailable(), false);
+        QCOMPARE(nullObject.availabilityError(), QtMultimedia::ServiceMissingError);
+    }
 
-    QtTestMetaDataService service;
-    QtTestMediaObject object(&service);
-    QCOMPARE(object.isAvailable(), true);
-    QCOMPARE(object.availabilityError(), QtMultimedia::NoError);
+    {
+        QtTestMediaObjectService service;
+        QtTestMediaObject object(&service);
+        QCOMPARE(object.isAvailable(), true);
+        QCOMPARE(object.availabilityError(), QtMultimedia::NoError);
+    }
+
+    {
+        MockAvailabilityControl available(QtMultimedia::NoError);
+        QtTestMediaObjectService service(0, &available);
+        QtTestMediaObject object(&service);
+        QSignalSpy availabilitySpy(&object, SIGNAL(availabilityChanged(bool)));
+        QSignalSpy availabilityErrorSpy(&object, SIGNAL(availabilityChanged(bool)));
+
+        QCOMPARE(object.isAvailable(), true);
+        QCOMPARE(object.availabilityError(), QtMultimedia::NoError);
+
+        available.setAvailability(QtMultimedia::BusyError);
+        QCOMPARE(object.isAvailable(), false);
+        QCOMPARE(object.availabilityError(), QtMultimedia::BusyError);
+        QCOMPARE(availabilitySpy.count(), 1);
+        QCOMPARE(availabilityErrorSpy.count(), 1);
+
+        available.setAvailability(QtMultimedia::NoError);
+        QCOMPARE(object.isAvailable(), true);
+        QCOMPARE(object.availabilityError(), QtMultimedia::NoError);
+        QCOMPARE(availabilitySpy.count(), 2);
+        QCOMPARE(availabilityErrorSpy.count(), 2);
+    }
+
+    {
+        MockAvailabilityControl available(QtMultimedia::BusyError);
+        QtTestMediaObjectService service(0, &available);
+        QtTestMediaObject object(&service);
+        QSignalSpy availabilitySpy(&object, SIGNAL(availabilityChanged(bool)));
+        QSignalSpy availabilityErrorSpy(&object, SIGNAL(availabilityChanged(bool)));
+
+        QCOMPARE(object.isAvailable(), false);
+        QCOMPARE(object.availabilityError(), QtMultimedia::BusyError);
+
+        available.setAvailability(QtMultimedia::NoError);
+        QCOMPARE(object.isAvailable(), true);
+        QCOMPARE(object.availabilityError(), QtMultimedia::NoError);
+        QCOMPARE(availabilitySpy.count(), 1);
+        QCOMPARE(availabilityErrorSpy.count(), 1);
+    }
 }
 
  void tst_QMediaObject::service()
  {
      // Create the mediaobject with service.
-     QtTestMetaDataService service;
+     QtTestMediaObjectService service;
      QtTestMediaObject mediaObject1(&service);
 
      // Get service and Compare if it equal to the service passed as an argument in mediaObject1.
diff --git a/tests/auto/unit/qmediarecorder/tst_qmediarecorder.cpp b/tests/auto/unit/qmediarecorder/tst_qmediarecorder.cpp
index 220bb20..b26164d 100644
--- a/tests/auto/unit/qmediarecorder/tst_qmediarecorder.cpp
+++ b/tests/auto/unit/qmediarecorder/tst_qmediarecorder.cpp
@@ -1059,17 +1059,55 @@ void tst_QMediaRecorder::testAudioSettingsDestructor()
 /* availabilityError() API test. */
 void tst_QMediaRecorder::testAvailabilityError()
 {
-    MockMediaRecorderService service(0, 0);
-    MockMediaObject object(0, &service);
-    QMediaRecorder recorder(&object);
-    QCOMPARE(recorder.availabilityError(), QtMultimedia::ServiceMissingError);
-
-    MockMediaRecorderControl recorderControl(0);
-    MockMediaRecorderService service1(0, &recorderControl);
-    service1.mockMetaDataControl->populateMetaData();
-    MockMediaObject object1(0, &service1);
-    QMediaRecorder recorder1(&object1);
-    QCOMPARE(recorder1.availabilityError(), QtMultimedia::NoError);
+    {
+        MockMediaRecorderService service(0, 0);
+        MockMediaObject object(0, &service);
+        QMediaRecorder recorder(&object);
+        QCOMPARE(recorder.availabilityError(), QtMultimedia::ServiceMissingError);
+        QCOMPARE(recorder.isAvailable(), false);
+    }
+    {
+        MockMediaRecorderControl recorderControl(0);
+        MockMediaRecorderService service1(0, &recorderControl);
+        service1.mockMetaDataControl->populateMetaData();
+        MockMediaObject object1(0, &service1);
+        QMediaRecorder recorder1(&object1);
+        QCOMPARE(recorder1.availabilityError(), QtMultimedia::NoError);
+        QCOMPARE(recorder1.isAvailable(), true);
+    }
+    {
+        MockMediaRecorderControl recorderControl(0);
+        MockMediaRecorderService service1(0, &recorderControl, 0);
+        service1.mockMetaDataControl->populateMetaData();
+        MockMediaObject object1(0, &service1);
+        QMediaRecorder recorder1(&object1);
+
+        QCOMPARE(recorder1.availabilityError(), QtMultimedia::NoError);
+        QCOMPARE(recorder1.isAvailable(), true);
+    }
+    {
+        MockMediaRecorderControl recorderControl(0);
+        MockAvailabilityControl availability(QtMultimedia::NoError);
+        MockMediaRecorderService service1(0, &recorderControl, &availability);
+        service1.mockMetaDataControl->populateMetaData();
+        MockMediaObject object1(0, &service1);
+        QMediaRecorder recorder1(&object1);
+
+        QSignalSpy spy(&object1, SIGNAL(availabilityErrorChanged(QtMultimedia::AvailabilityError)));
+
+        QCOMPARE(recorder1.availabilityError(), QtMultimedia::NoError);
+        QCOMPARE(recorder1.isAvailable(), true);
+
+        availability.setAvailability(QtMultimedia::BusyError);
+        QCOMPARE(recorder1.availabilityError(), QtMultimedia::BusyError);
+        QCOMPARE(recorder1.isAvailable(), false);
+        QCOMPARE(spy.count(), 1);
+
+        availability.setAvailability(QtMultimedia::NoError);
+        QCOMPARE(recorder1.availabilityError(), QtMultimedia::NoError);
+        QCOMPARE(recorder1.isAvailable(), true);
+        QCOMPARE(spy.count(), 2);
+    }
 }
 
 /* isAvailable() API test. */
diff --git a/tests/auto/unit/qmultimedia_common/mock.pri b/tests/auto/unit/qmultimedia_common/mock.pri
index 8b8f3e7..269981a 100644
--- a/tests/auto/unit/qmultimedia_common/mock.pri
+++ b/tests/auto/unit/qmultimedia_common/mock.pri
@@ -4,4 +4,5 @@ INCLUDEPATH += $$PWD \
 HEADERS *= \
     ../qmultimedia_common/mockmediaserviceprovider.h \
     ../qmultimedia_common/mockmediaservice.h \
-    ../qmultimedia_common/mockmediaobject.h
+    ../qmultimedia_common/mockmediaobject.h \
+    ../qmultimedia_common/mockavailabilitycontrol.h
diff --git a/tests/auto/unit/qmultimedia_common/mockavailabilitycontrol.h b/tests/auto/unit/qmultimedia_common/mockavailabilitycontrol.h
new file mode 100644
index 0000000..9e449da
--- /dev/null
+++ b/tests/auto/unit/qmultimedia_common/mockavailabilitycontrol.h
@@ -0,0 +1,75 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef MOCKAVAILABILITYCONTROL_H
+#define MOCKAVAILABILITYCONTROL_H
+
+#include <qmediaavailabilitycontrol.h>
+
+class MockAvailabilityControl : public QMediaAvailabilityControl
+{
+    Q_OBJECT
+
+public:
+    MockAvailabilityControl(QtMultimedia::AvailabilityError available)
+        : m_availability(available)
+    {
+
+    }
+
+    QtMultimedia::AvailabilityError availability() const
+    {
+        return m_availability;
+    }
+
+    void setAvailability(QtMultimedia::AvailabilityError availability)
+    {
+        if (m_availability != availability) {
+            m_availability = availability;
+            emit availabilityChanged(availability);
+        }
+    }
+
+    QtMultimedia::AvailabilityError m_availability;
+};
+
+#endif // MOCKAVAILABILITYCONTROL_H
diff --git a/tests/auto/unit/qmultimedia_common/mockmediarecorderservice.h b/tests/auto/unit/qmultimedia_common/mockmediarecorderservice.h
index bce8c42..7d23073 100644
--- a/tests/auto/unit/qmultimedia_common/mockmediarecorderservice.h
+++ b/tests/auto/unit/qmultimedia_common/mockmediarecorderservice.h
@@ -50,14 +50,16 @@
 #include "mockaudioendpointselector.h"
 #include "mockmediacontainercontrol.h"
 #include "mockmetadatawritercontrol.h"
+#include "mockavailabilitycontrol.h"
 
 class MockMediaRecorderService : public QMediaService
 {
     Q_OBJECT
 public:
-    MockMediaRecorderService(QObject *parent = 0, QMediaControl *control = 0):
+    MockMediaRecorderService(QObject *parent = 0, QMediaControl *control = 0, MockAvailabilityControl *availability = 0):
         QMediaService(parent),
         mockControl(control),
+        mockAvailabilityControl(availability),
         hasControls(true)
     {
         mockAudioEndpointSelector = new MockAudioEndpointSelector(parent);
@@ -81,6 +83,8 @@ public:
             return mockVideoEncoderControl;
         if (hasControls && qstrcmp(name, QMetaDataWriterControl_iid) == 0)
             return mockMetaDataControl;
+        if (hasControls && qstrcmp(name, QMediaAvailabilityControl_iid) == 0)
+            return mockAvailabilityControl;
 
         return 0;
     }
@@ -95,6 +99,8 @@ public:
     QMediaContainerControl     *mockFormatControl;
     QVideoEncoderControl    *mockVideoEncoderControl;
     MockMetaDataWriterControl *mockMetaDataControl;
+    MockAvailabilityControl *mockAvailabilityControl;
+
     bool hasControls;
 };
 
diff --git a/tests/auto/unit/qmultimedia_common/mockradiodatacontrol.h b/tests/auto/unit/qmultimedia_common/mockradiodatacontrol.h
index 45bec9e..35e482f 100644
--- a/tests/auto/unit/qmultimedia_common/mockradiodatacontrol.h
+++ b/tests/auto/unit/qmultimedia_common/mockradiodatacontrol.h
@@ -57,15 +57,6 @@ public:
 
     using QRadioDataControl::error;
 
-    bool isAvailable() const
-    {
-        return true;
-    }
-    QtMultimedia::AvailabilityError availabilityError() const
-    {
-        return QtMultimedia::NoError;
-    }
-
     QRadioData::Error error() const
     {
         return m_err;
diff --git a/tests/auto/unit/qmultimedia_common/mockradiotunercontrol.h b/tests/auto/unit/qmultimedia_common/mockradiotunercontrol.h
index 5b1fe7a..226cd94 100644
--- a/tests/auto/unit/qmultimedia_common/mockradiotunercontrol.h
+++ b/tests/auto/unit/qmultimedia_common/mockradiotunercontrol.h
@@ -66,15 +66,6 @@ public:
         return m_active ? QRadioTuner::ActiveState : QRadioTuner::StoppedState;
     }
 
-    bool isAvailable() const
-    {
-        return true;
-    }
-    QtMultimedia::AvailabilityError availabilityError() const
-    {
-        return QtMultimedia::NoError;
-    }
-
     QRadioTuner::Band band() const
     {
         return m_band;