diff --git a/src/gui/text/qabstracttextdocumentlayout.h b/src/gui/text/qabstracttextdocumentlayout.h
index 9014775..3835584 100644
--- a/src/gui/text/qabstracttextdocumentlayout.h
+++ b/src/gui/text/qabstracttextdocumentlayout.h
@@ -122,7 +122,6 @@ protected:
 
 private:
     friend class QWidgetTextControl;
-    friend class QTextControl;
     friend class QTextDocument;
     friend class QTextDocumentPrivate;
     friend class QTextEngine;
diff --git a/src/gui/text/qlinecontrol.cpp b/src/gui/text/qlinecontrol.cpp
deleted file mode 100644
index fd8659c..0000000
--- a/src/gui/text/qlinecontrol.cpp
+++ /dev/null
@@ -1,1729 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-// ###
-#define QT_NO_ACCESSIBILITY
-
-#include "qlinecontrol_p.h"
-
-#ifndef QT_NO_LINEEDIT
-
-#include "qclipboard.h"
-#ifndef QT_NO_ACCESSIBILITY
-#include "qaccessible.h"
-#endif
-#include "qguiapplication.h"
-#include "qstylehints.h"
-
-QT_BEGIN_NAMESPACE
-
-// ### these should come from QStyleHints
-const int textCursorWidth = 1;
-const bool fullWidthSelection = true;
-
-/*!
-    \internal
-
-    Updates the display text based of the current edit text
-    If the text has changed will emit displayTextChanged()
-*/
-void QLineControl::updateDisplayText(bool forceUpdate)
-{
-    QString orig = m_textLayout.text();
-    QString str;
-    if (m_echoMode == NoEcho)
-        str = QString::fromLatin1("");
-    else
-        str = m_text;
-
-    if (m_echoMode == Password || (m_echoMode == PasswordEchoOnEdit
-                && !m_passwordEchoEditing))
-        str.fill(m_passwordCharacter);
-
-    // replace certain non-printable characters with spaces (to avoid
-    // drawing boxes when using fonts that don't have glyphs for such
-    // characters)
-    QChar* uc = str.data();
-    for (int i = 0; i < (int)str.length(); ++i) {
-        if ((uc[i] < 0x20 && uc[i] != 0x09)
-            || uc[i] == QChar::LineSeparator
-            || uc[i] == QChar::ParagraphSeparator
-            || uc[i] == QChar::ObjectReplacementCharacter)
-            uc[i] = QChar(0x0020);
-    }
-
-    m_textLayout.setText(str);
-
-    QTextOption option = m_textLayout.textOption();
-    option.setTextDirection(m_layoutDirection);
-    option.setFlags(QTextOption::IncludeTrailingSpaces);
-    m_textLayout.setTextOption(option);
-
-    m_textLayout.beginLayout();
-    QTextLine l = m_textLayout.createLine();
-    m_textLayout.endLayout();
-    m_ascent = qRound(l.ascent());
-
-    if (str != orig || forceUpdate)
-        emit displayTextChanged(str);
-}
-
-#ifndef QT_NO_CLIPBOARD
-/*!
-    \internal
-
-    Copies the currently selected text into the clipboard using the given
-    \a mode.
-
-    \note If the echo mode is set to a mode other than Normal then copy
-    will not work.  This is to prevent using copy as a method of bypassing
-    password features of the line control.
-*/
-void QLineControl::copy(QClipboard::Mode mode) const
-{
-    QString t = selectedText();
-    if (!t.isEmpty() && m_echoMode == Normal) {
-        disconnect(QGuiApplication::clipboard(), SIGNAL(selectionChanged()), this, 0);
-        QGuiApplication::clipboard()->setText(t, mode);
-        connect(QGuiApplication::clipboard(), SIGNAL(selectionChanged()),
-                   this, SLOT(_q_clipboardChanged()));
-    }
-}
-
-/*!
-    \internal
-
-    Inserts the text stored in the application clipboard into the line
-    control.
-
-    \sa insert()
-*/
-void QLineControl::paste(QClipboard::Mode clipboardMode)
-{
-    QString clip = QGuiApplication::clipboard()->text(clipboardMode);
-    if (!clip.isEmpty() || hasSelectedText()) {
-        separate(); //make it a separate undo/redo command
-        insert(clip);
-        separate();
-    }
-}
-
-#endif // !QT_NO_CLIPBOARD
-
-/*!
-    \internal
-
-    Exits preedit mode and commits parts marked as tentative commit
-*/
-void QLineControl::commitPreedit()
-{
-    if (!composeMode())
-        return;
-
-    qApp->inputPanel()->reset();
-
-    if (!m_tentativeCommit.isEmpty()) {
-        internalInsert(m_tentativeCommit);
-        m_tentativeCommit.clear();
-        finishChange(-1, true/*not used, not documented*/, false);
-    }
-
-    m_preeditCursor = 0;
-    setPreeditArea(-1, QString());
-    m_textLayout.clearAdditionalFormats();
-    updateDisplayText(/*force*/ true);
-}
-
-/*!
-    \internal
-
-    Handles the behavior for the backspace key or function.
-    Removes the current selection if there is a selection, otherwise
-    removes the character prior to the cursor position.
-
-    \sa del()
-*/
-void QLineControl::backspace()
-{
-    int priorState = m_undoState;
-    if (hasSelectedText()) {
-        removeSelectedText();
-    } else if (m_cursor) {
-            --m_cursor;
-            if (m_maskData)
-                m_cursor = prevMaskBlank(m_cursor);
-            QChar uc = m_text.at(m_cursor);
-            if (m_cursor > 0 && uc.unicode() >= 0xdc00 && uc.unicode() < 0xe000) {
-                // second half of a surrogate, check if we have the first half as well,
-                // if yes delete both at once
-                uc = m_text.at(m_cursor - 1);
-                if (uc.unicode() >= 0xd800 && uc.unicode() < 0xdc00) {
-                    internalDelete(true);
-                    --m_cursor;
-                }
-            }
-            internalDelete(true);
-    }
-    finishChange(priorState);
-}
-
-/*!
-    \internal
-
-    Handles the behavior for the delete key or function.
-    Removes the current selection if there is a selection, otherwise
-    removes the character after the cursor position.
-
-    \sa del()
-*/
-void QLineControl::del()
-{
-    int priorState = m_undoState;
-    if (hasSelectedText()) {
-        removeSelectedText();
-    } else {
-        int n = m_textLayout.nextCursorPosition(m_cursor) - m_cursor;
-        while (n--)
-            internalDelete();
-    }
-    finishChange(priorState);
-}
-
-/*!
-    \internal
-
-    Inserts the given \a newText at the current cursor position.
-    If there is any selected text it is removed prior to insertion of
-    the new text.
-*/
-void QLineControl::insert(const QString &newText)
-{
-    int priorState = m_undoState;
-    removeSelectedText();
-    internalInsert(newText);
-    finishChange(priorState);
-}
-
-/*!
-    \internal
-
-    Clears the line control text.
-*/
-void QLineControl::clear()
-{
-    int priorState = m_undoState;
-    m_selstart = 0;
-    m_selend = m_text.length();
-    removeSelectedText();
-    separate();
-    finishChange(priorState, /*update*/false, /*edited*/false);
-}
-
-/*!
-    \internal
-
-    Sets \a length characters from the given \a start position as selected.
-    The given \a start position must be within the current text for
-    the line control.  If \a length characters cannot be selected, then
-    the selection will extend to the end of the current text.
-*/
-void QLineControl::setSelection(int start, int length)
-{
-    commitPreedit();
-
-    if(start < 0 || start > (int)m_text.length()){
-        qWarning("QLineControl::setSelection: Invalid start position");
-        return;
-    }
-
-    if (length > 0) {
-        if (start == m_selstart && start + length == m_selend && m_cursor == m_selend)
-            return;
-        m_selstart = start;
-        m_selend = qMin(start + length, (int)m_text.length());
-        m_cursor = m_selend;
-    } else if (length < 0){
-        if (start == m_selend && start + length == m_selstart && m_cursor == m_selstart)
-            return;
-        m_selstart = qMax(start + length, 0);
-        m_selend = start;
-        m_cursor = m_selstart;
-    } else if (m_selstart != m_selend) {
-        m_selstart = 0;
-        m_selend = 0;
-        m_cursor = start;
-    } else {
-        m_cursor = start;
-        emitCursorPositionChanged();
-        return;
-    }
-    emit selectionChanged();
-    emitCursorPositionChanged();
-}
-
-void QLineControl::_q_clipboardChanged()
-{
-}
-
-void QLineControl::_q_deleteSelected()
-{
-    if (!hasSelectedText())
-        return;
-
-    int priorState = m_undoState;
-    emit resetInputContext();
-    removeSelectedText();
-    separate();
-    finishChange(priorState);
-}
-
-/*!
-    \internal
-
-    Initializes the line control with a starting text value of \a txt.
-*/
-void QLineControl::init(const QString &txt)
-{
-    m_text = txt;
-
-    updateDisplayText();
-    m_cursor = m_text.length();
-}
-
-/*!
-    \internal
-
-    Sets the password echo editing to \a editing.  If password echo editing
-    is true, then the text of the password is displayed even if the echo
-    mode is set to QLineEdit::PasswordEchoOnEdit.  Password echoing editing
-    does not affect other echo modes.
-*/
-void QLineControl::updatePasswordEchoEditing(bool editing)
-{
-    m_passwordEchoEditing = editing;
-    updateDisplayText();
-}
-
-/*!
-    \internal
-
-    Returns the cursor position of the given \a x pixel value in relation
-    to the displayed text.  The given \a betweenOrOn specified what kind
-    of cursor position is requested.
-*/
-int QLineControl::xToPos(int x, QTextLine::CursorPosition betweenOrOn) const
-{
-    return m_textLayout.lineAt(0).xToCursor(x, betweenOrOn);
-}
-
-/*!
-    \internal
-
-    Returns the bounds of the current cursor, as defined as a
-    between characters cursor.
-*/
-QRect QLineControl::cursorRect() const
-{
-    QTextLine l = m_textLayout.lineAt(0);
-    int c = m_cursor;
-    if (m_preeditCursor != -1)
-        c += m_preeditCursor;
-    int cix = qRound(l.cursorToX(c));
-    int w = m_cursorWidth;
-    int ch = l.height() + 1;
-
-    return QRect(cix-5, 0, w+9, ch);
-}
-
-QString QLineControl::text() const
-{
-    QString content = m_text;
-    if (!m_tentativeCommit.isEmpty())
-        content.insert(m_cursor, m_tentativeCommit);
-    QString res = m_maskData ? stripString(content) : content;
-    return (res.isNull() ? QString::fromLatin1("") : res);
-}
-
-// like text() but doesn't include preedit
-QString QLineControl::realText() const
-{
-    QString res = m_maskData ? stripString(m_text) : m_text;
-    return (res.isNull() ? QString::fromLatin1("") : res);
-}
-
-void QLineControl::setText(const QString &txt)
-{
-    if (composeMode())
-        qApp->inputPanel()->reset();
-    m_tentativeCommit.clear();
-    internalSetText(txt, -1, false);
-}
-
-/*!
-    \internal
-
-    Fixes the current text so that it is valid given any set validators.
-
-    Returns true if the text was changed.  Otherwise returns false.
-*/
-bool QLineControl::fixup() // this function assumes that validate currently returns != Acceptable
-{
-#ifndef QT_NO_VALIDATOR
-    if (m_validator) {
-        QString textCopy = m_text;
-        int cursorCopy = m_cursor;
-        m_validator->fixup(textCopy);
-        if (m_validator->validate(textCopy, cursorCopy) == QValidator::Acceptable) {
-            if (textCopy != m_text || cursorCopy != m_cursor)
-                internalSetText(textCopy, cursorCopy);
-            return true;
-        }
-    }
-#endif
-    return false;
-}
-
-/*!
-    \internal
-
-    Moves the cursor to the given position \a pos.   If \a mark is true will
-    adjust the currently selected text.
-*/
-void QLineControl::moveCursor(int pos, bool mark)
-{
-    commitPreedit();
-
-    if (pos != m_cursor) {
-        separate();
-        if (m_maskData)
-            pos = pos > m_cursor ? nextMaskBlank(pos) : prevMaskBlank(pos);
-    }
-    if (mark) {
-        int anchor;
-        if (m_selend > m_selstart && m_cursor == m_selstart)
-            anchor = m_selend;
-        else if (m_selend > m_selstart && m_cursor == m_selend)
-            anchor = m_selstart;
-        else
-            anchor = m_cursor;
-        m_selstart = qMin(anchor, pos);
-        m_selend = qMax(anchor, pos);
-        updateDisplayText();
-    } else {
-        internalDeselect();
-    }
-    m_cursor = pos;
-    if (mark || m_selDirty) {
-        m_selDirty = false;
-        emit selectionChanged();
-    }
-    emitCursorPositionChanged();
-}
-
-/*!
-    \internal
-
-    Applies the given input method event \a event to the text of the line
-    control
-*/
-void QLineControl::processInputMethodEvent(QInputMethodEvent *event)
-{
-    int priorState = -1;
-    bool isGettingInput = !event->commitString().isEmpty()
-            || event->preeditString() != preeditAreaText()
-            || event->replacementLength() > 0;
-    bool cursorPositionChanged = false;
-    bool selectionChange = false;
-
-    if (isGettingInput) {
-        // If any text is being input, remove selected text.
-        priorState = m_undoState;
-        if (echoMode() == PasswordEchoOnEdit && !passwordEchoEditing()) {
-            updatePasswordEchoEditing(true);
-            m_selstart = 0;
-            m_selend = m_text.length();
-        }
-        removeSelectedText();
-    }
-
-    int c = m_cursor; // cursor position after insertion of commit string
-    if (event->replacementStart() <= 0)
-        c += event->commitString().length() - qMin(-event->replacementStart(), event->replacementLength());
-
-    m_cursor += event->replacementStart();
-    if (m_cursor < 0)
-        m_cursor = 0;
-
-    // insert commit string
-    if (event->replacementLength()) {
-        m_selstart = m_cursor;
-        m_selend = m_selstart + event->replacementLength();
-        removeSelectedText();
-    }
-    if (!event->commitString().isEmpty()) {
-        internalInsert(event->commitString());
-        cursorPositionChanged = true;
-    }
-
-    m_cursor = qBound(0, c, m_text.length());
-
-    for (int i = 0; i < event->attributes().size(); ++i) {
-        const QInputMethodEvent::Attribute &a = event->attributes().at(i);
-        if (a.type == QInputMethodEvent::Selection) {
-            m_cursor = qBound(0, a.start + a.length, m_text.length());
-            if (a.length) {
-                m_selstart = qMax(0, qMin(a.start, m_text.length()));
-                m_selend = m_cursor;
-                if (m_selend < m_selstart) {
-                    qSwap(m_selstart, m_selend);
-                }
-                selectionChange = true;
-            } else {
-                m_selstart = m_selend = 0;
-            }
-            cursorPositionChanged = true;
-        }
-    }
-#ifndef QT_NO_IM
-    setPreeditArea(m_cursor, event->preeditString());
-#endif //QT_NO_IM
-    const int oldPreeditCursor = m_preeditCursor;
-    m_preeditCursor = event->preeditString().length();
-    m_hideCursor = false;
-    QList<QTextLayout::FormatRange> formats;
-    for (int i = 0; i < event->attributes().size(); ++i) {
-        const QInputMethodEvent::Attribute &a = event->attributes().at(i);
-        if (a.type == QInputMethodEvent::Cursor) {
-            m_preeditCursor = a.start;
-            m_hideCursor = !a.length;
-        } else if (a.type == QInputMethodEvent::TextFormat) {
-            QTextCharFormat f = qvariant_cast<QTextFormat>(a.value).toCharFormat();
-            if (f.isValid()) {
-                QTextLayout::FormatRange o;
-                o.start = a.start + m_cursor;
-                o.length = a.length;
-                o.format = f;
-                formats.append(o);
-            }
-        }
-    }
-    m_textLayout.setAdditionalFormats(formats);
-    updateDisplayText(/*force*/ true);
-    if (cursorPositionChanged)
-        emitCursorPositionChanged();
-    else if (m_preeditCursor != oldPreeditCursor)
-        emit updateMicroFocus();
-
-    bool tentativeCommitChanged = (m_tentativeCommit != event->tentativeCommitString());
-
-    if (tentativeCommitChanged) {
-        m_textDirty = true;
-        m_tentativeCommit = event->tentativeCommitString();
-    }
-
-    if (isGettingInput || tentativeCommitChanged)
-        finishChange(priorState);
-
-    if (selectionChange)
-        emit selectionChanged();
-}
-
-/*!
-    \internal
-
-    Draws the display text for the line control using the given
-    \a painter, \a clip, and \a offset.  Which aspects of the display text
-    are drawn is specified by the given \a flags.
-
-    If the flags contain DrawSelections, then the selection or input mask
-    backgrounds and foregrounds will be applied before drawing the text.
-
-    If the flags contain DrawCursor a cursor of the current cursorWidth()
-    will be drawn after drawing the text.
-
-    The display text will only be drawn if the flags contain DrawText
-*/
-void QLineControl::draw(QPainter *painter, const QPoint &offset, const QRect &clip, int flags)
-{
-    QVector<QTextLayout::FormatRange> selections;
-    if (flags & DrawSelections) {
-        QTextLayout::FormatRange o;
-        if (m_selstart < m_selend) {
-            o.start = m_selstart;
-            o.length = m_selend - m_selstart;
-            o.format.setBackground(m_palette.brush(QPalette::Highlight));
-            o.format.setForeground(m_palette.brush(QPalette::HighlightedText));
-        } else {
-            // mask selection
-            if(!m_blinkPeriod || m_blinkStatus){
-                o.start = m_cursor;
-                o.length = 1;
-                o.format.setBackground(m_palette.brush(QPalette::Text));
-                o.format.setForeground(m_palette.brush(QPalette::Window));
-            }
-        }
-        selections.append(o);
-    }
-
-    if (flags & DrawText)
-        m_textLayout.draw(painter, offset, selections, clip);
-
-    if (flags & DrawCursor){
-        int cursor = m_cursor;
-        if (m_preeditCursor != -1)
-            cursor += m_preeditCursor;
-        if (!m_hideCursor && (!m_blinkPeriod || m_blinkStatus))
-            m_textLayout.drawCursor(painter, offset, cursor, m_cursorWidth);
-    }
-}
-
-/*!
-    \internal
-
-    Sets the selection to cover the word at the given cursor position.
-    The word boundaries are defined by the behavior of QTextLayout::SkipWords
-    cursor mode.
-*/
-void QLineControl::selectWordAtPos(int cursor)
-{
-    int next = cursor + 1;
-    if(next > end())
-        --next;
-    int c = m_textLayout.previousCursorPosition(next, QTextLayout::SkipWords);
-    moveCursor(c, false);
-    // ## text layout should support end of words.
-    int end = m_textLayout.nextCursorPosition(c, QTextLayout::SkipWords);
-    while (end > cursor && m_text[end-1].isSpace())
-        --end;
-    moveCursor(end, true);
-}
-
-/*!
-    \internal
-
-    Completes a change to the line control text.  If the change is not valid
-    will undo the line control state back to the given \a validateFromState.
-
-    If \a edited is true and the change is valid, will emit textEdited() in
-    addition to textChanged().  Otherwise only emits textChanged() on a valid
-    change.
-
-    The \a update value is currently unused.
-*/
-bool QLineControl::finishChange(int validateFromState, bool update, bool edited)
-{
-    Q_UNUSED(update)
-
-    if (m_textDirty) {
-        // do validation
-        bool wasValidInput = m_validInput;
-        m_validInput = true;
-#ifndef QT_NO_VALIDATOR
-        if (m_validator) {
-            QString textCopy = m_text;
-            int cursorCopy = m_cursor;
-            m_validInput = (m_validator->validate(textCopy, cursorCopy) != QValidator::Invalid);
-            if (m_validInput) {
-                if (m_text != textCopy) {
-                    internalSetText(textCopy, cursorCopy);
-                    return true;
-                }
-                m_cursor = cursorCopy;
-
-                if (!m_tentativeCommit.isEmpty()) {
-                    textCopy.insert(m_cursor, m_tentativeCommit);
-                    bool validInput = (m_validator->validate(textCopy, cursorCopy) != QValidator::Invalid);
-                    if (!validInput)
-                        m_tentativeCommit.clear();
-                }
-            } else {
-                m_tentativeCommit.clear();
-            }
-        }
-#endif
-        if (validateFromState >= 0 && wasValidInput && !m_validInput) {
-            if (m_transactions.count())
-                return false;
-            internalUndo(validateFromState);
-            m_history.resize(m_undoState);
-            if (m_modifiedState > m_undoState)
-                m_modifiedState = -1;
-            m_validInput = true;
-            m_textDirty = false;
-        }
-        updateDisplayText();
-
-        if (m_textDirty) {
-            m_textDirty = false;
-            QString actualText = text();
-            if (edited)
-                emit textEdited(actualText);
-            emit textChanged(actualText);
-        }
-    }
-    if (m_selDirty) {
-        m_selDirty = false;
-        emit selectionChanged();
-    }
-    emitCursorPositionChanged();
-    return true;
-}
-
-/*!
-    \internal
-
-    An internal function for setting the text of the line control.
-*/
-void QLineControl::internalSetText(const QString &txt, int pos, bool edited)
-{
-    internalDeselect();
-    emit resetInputContext();
-    QString oldText = m_text;
-    if (m_maskData) {
-        m_text = maskString(0, txt, true);
-        m_text += clearString(m_text.length(), m_maxLength - m_text.length());
-    } else {
-        m_text = txt.isEmpty() ? txt : txt.left(m_maxLength);
-    }
-    m_history.clear();
-    m_modifiedState =  m_undoState = 0;
-    m_cursor = (pos < 0 || pos > m_text.length()) ? m_text.length() : pos;
-    m_textDirty = (oldText != m_text);
-
-    bool changed = finishChange(-1, true, edited);
-#ifdef QT_NO_ACCESSIBILITY
-    Q_UNUSED(changed)
-#else
-    if (changed)
-        QAccessible::updateAccessibility(parent(), 0, QAccessible::TextUpdated);
-#endif
-}
-
-
-/*!
-    \internal
-
-    Adds the given \a command to the undo history
-    of the line control.  Does not apply the command.
-*/
-void QLineControl::addCommand(const Command &cmd)
-{
-    if (m_separator && m_undoState && m_history[m_undoState - 1].type != Separator) {
-        m_history.resize(m_undoState + 2);
-        m_history[m_undoState++] = Command(Separator, m_cursor, 0, m_selstart, m_selend);
-    } else {
-        m_history.resize(m_undoState + 1);
-    }
-    m_separator = false;
-    m_history[m_undoState++] = cmd;
-}
-
-/*!
-    \internal
-
-    Inserts the given string \a s into the line
-    control.
-
-    Also adds the appropriate commands into the undo history.
-    This function does not call finishChange(), and may leave the text
-    in an invalid state.
-*/
-void QLineControl::internalInsert(const QString &s)
-{
-    if (hasSelectedText())
-        addCommand(Command(SetSelection, m_cursor, 0, m_selstart, m_selend));
-    if (m_maskData) {
-        QString ms = maskString(m_cursor, s);
-        for (int i = 0; i < (int) ms.length(); ++i) {
-            addCommand (Command(DeleteSelection, m_cursor + i, m_text.at(m_cursor + i), -1, -1));
-            addCommand(Command(Insert, m_cursor + i, ms.at(i), -1, -1));
-        }
-        m_text.replace(m_cursor, ms.length(), ms);
-        m_cursor += ms.length();
-        m_cursor = nextMaskBlank(m_cursor);
-        m_textDirty = true;
-    } else {
-        int remaining = m_maxLength - m_text.length();
-        if (remaining != 0) {
-            m_text.insert(m_cursor, s.left(remaining));
-            for (int i = 0; i < (int) s.left(remaining).length(); ++i)
-               addCommand(Command(Insert, m_cursor++, s.at(i), -1, -1));
-            m_textDirty = true;
-        }
-    }
-}
-
-/*!
-    \internal
-
-    deletes a single character from the current text.  If \a wasBackspace,
-    the character prior to the cursor is removed.  Otherwise the character
-    after the cursor is removed.
-
-    Also adds the appropriate commands into the undo history.
-    This function does not call finishChange(), and may leave the text
-    in an invalid state.
-*/
-void QLineControl::internalDelete(bool wasBackspace)
-{
-    if (m_cursor < (int) m_text.length()) {
-        if (hasSelectedText())
-            addCommand(Command(SetSelection, m_cursor, 0, m_selstart, m_selend));
-        addCommand(Command((CommandType)((m_maskData ? 2 : 0) + (wasBackspace ? Remove : Delete)),
-                   m_cursor, m_text.at(m_cursor), -1, -1));
-        if (m_maskData) {
-            m_text.replace(m_cursor, 1, clearString(m_cursor, 1));
-            addCommand(Command(Insert, m_cursor, m_text.at(m_cursor), -1, -1));
-        } else {
-            m_text.remove(m_cursor, 1);
-        }
-        m_textDirty = true;
-    }
-}
-
-/*!
-    \internal
-
-    removes the currently selected text from the line control.
-
-    Also adds the appropriate commands into the undo history.
-    This function does not call finishChange(), and may leave the text
-    in an invalid state.
-*/
-void QLineControl::removeSelectedText()
-{
-    if (m_selstart < m_selend && m_selend <= (int) m_text.length()) {
-        separate();
-        int i ;
-        addCommand(Command(SetSelection, m_cursor, 0, m_selstart, m_selend));
-        if (m_selstart <= m_cursor && m_cursor < m_selend) {
-            // cursor is within the selection. Split up the commands
-            // to be able to restore the correct cursor position
-            for (i = m_cursor; i >= m_selstart; --i)
-                addCommand (Command(DeleteSelection, i, m_text.at(i), -1, 1));
-            for (i = m_selend - 1; i > m_cursor; --i)
-                addCommand (Command(DeleteSelection, i - m_cursor + m_selstart - 1, m_text.at(i), -1, -1));
-        } else {
-            for (i = m_selend-1; i >= m_selstart; --i)
-                addCommand (Command(RemoveSelection, i, m_text.at(i), -1, -1));
-        }
-        if (m_maskData) {
-            m_text.replace(m_selstart, m_selend - m_selstart,  clearString(m_selstart, m_selend - m_selstart));
-            for (int i = 0; i < m_selend - m_selstart; ++i)
-                addCommand(Command(Insert, m_selstart + i, m_text.at(m_selstart + i), -1, -1));
-        } else {
-            m_text.remove(m_selstart, m_selend - m_selstart);
-        }
-        if (m_cursor > m_selstart)
-            m_cursor -= qMin(m_cursor, m_selend) - m_selstart;
-        internalDeselect();
-        m_textDirty = true;
-    }
-}
-
-/*!
-    \internal
-
-    Parses the input mask specified by \a maskFields to generate
-    the mask data used to handle input masks.
-*/
-void QLineControl::parseInputMask(const QString &maskFields)
-{
-    int delimiter = maskFields.indexOf(QLatin1Char(';'));
-    if (maskFields.isEmpty() || delimiter == 0) {
-        if (m_maskData) {
-            delete [] m_maskData;
-            m_maskData = 0;
-            m_maxLength = 32767;
-            internalSetText(QString());
-        }
-        return;
-    }
-
-    if (delimiter == -1) {
-        m_blank = QLatin1Char(' ');
-        m_inputMask = maskFields;
-    } else {
-        m_inputMask = maskFields.left(delimiter);
-        m_blank = (delimiter + 1 < maskFields.length()) ? maskFields[delimiter + 1] : QLatin1Char(' ');
-    }
-
-    // calculate m_maxLength / m_maskData length
-    m_maxLength = 0;
-    QChar c = 0;
-    for (int i=0; i<m_inputMask.length(); i++) {
-        c = m_inputMask.at(i);
-        if (i > 0 && m_inputMask.at(i-1) == QLatin1Char('\\')) {
-            m_maxLength++;
-            continue;
-        }
-        if (c != QLatin1Char('\\') && c != QLatin1Char('!') &&
-             c != QLatin1Char('<') && c != QLatin1Char('>') &&
-             c != QLatin1Char('{') && c != QLatin1Char('}') &&
-             c != QLatin1Char('[') && c != QLatin1Char(']'))
-            m_maxLength++;
-    }
-
-    delete [] m_maskData;
-    m_maskData = new MaskInputData[m_maxLength];
-
-    MaskInputData::Casemode m = MaskInputData::NoCaseMode;
-    c = 0;
-    bool s;
-    bool escape = false;
-    int index = 0;
-    for (int i = 0; i < m_inputMask.length(); i++) {
-        c = m_inputMask.at(i);
-        if (escape) {
-            s = true;
-            m_maskData[index].maskChar = c;
-            m_maskData[index].separator = s;
-            m_maskData[index].caseMode = m;
-            index++;
-            escape = false;
-        } else if (c == QLatin1Char('<')) {
-                m = MaskInputData::Lower;
-        } else if (c == QLatin1Char('>')) {
-            m = MaskInputData::Upper;
-        } else if (c == QLatin1Char('!')) {
-            m = MaskInputData::NoCaseMode;
-        } else if (c != QLatin1Char('{') && c != QLatin1Char('}') && c != QLatin1Char('[') && c != QLatin1Char(']')) {
-            switch (c.unicode()) {
-            case 'A':
-            case 'a':
-            case 'N':
-            case 'n':
-            case 'X':
-            case 'x':
-            case '9':
-            case '0':
-            case 'D':
-            case 'd':
-            case '#':
-            case 'H':
-            case 'h':
-            case 'B':
-            case 'b':
-                s = false;
-                break;
-            case '\\':
-                escape = true;
-            default:
-                s = true;
-                break;
-            }
-
-            if (!escape) {
-                m_maskData[index].maskChar = c;
-                m_maskData[index].separator = s;
-                m_maskData[index].caseMode = m;
-                index++;
-            }
-        }
-    }
-    internalSetText(m_text);
-}
-
-
-/*!
-    \internal
-
-    checks if the key is valid compared to the inputMask
-*/
-bool QLineControl::isValidInput(QChar key, QChar mask) const
-{
-    switch (mask.unicode()) {
-    case 'A':
-        if (key.isLetter())
-            return true;
-        break;
-    case 'a':
-        if (key.isLetter() || key == m_blank)
-            return true;
-        break;
-    case 'N':
-        if (key.isLetterOrNumber())
-            return true;
-        break;
-    case 'n':
-        if (key.isLetterOrNumber() || key == m_blank)
-            return true;
-        break;
-    case 'X':
-        if (key.isPrint())
-            return true;
-        break;
-    case 'x':
-        if (key.isPrint() || key == m_blank)
-            return true;
-        break;
-    case '9':
-        if (key.isNumber())
-            return true;
-        break;
-    case '0':
-        if (key.isNumber() || key == m_blank)
-            return true;
-        break;
-    case 'D':
-        if (key.isNumber() && key.digitValue() > 0)
-            return true;
-        break;
-    case 'd':
-        if ((key.isNumber() && key.digitValue() > 0) || key == m_blank)
-            return true;
-        break;
-    case '#':
-        if (key.isNumber() || key == QLatin1Char('+') || key == QLatin1Char('-') || key == m_blank)
-            return true;
-        break;
-    case 'B':
-        if (key == QLatin1Char('0') || key == QLatin1Char('1'))
-            return true;
-        break;
-    case 'b':
-        if (key == QLatin1Char('0') || key == QLatin1Char('1') || key == m_blank)
-            return true;
-        break;
-    case 'H':
-        if (key.isNumber() || (key >= QLatin1Char('a') && key <= QLatin1Char('f')) || (key >= QLatin1Char('A') && key <= QLatin1Char('F')))
-            return true;
-        break;
-    case 'h':
-        if (key.isNumber() || (key >= QLatin1Char('a') && key <= QLatin1Char('f')) || (key >= QLatin1Char('A') && key <= QLatin1Char('F')) || key == m_blank)
-            return true;
-        break;
-    default:
-        break;
-    }
-    return false;
-}
-
-/*!
-    \internal
-
-    Returns true if the given text \a str is valid for any
-    validator or input mask set for the line control.
-
-    Otherwise returns false
-*/
-bool QLineControl::hasAcceptableInput(const QString &str) const
-{
-#ifndef QT_NO_VALIDATOR
-    QString textCopy = str;
-    int cursorCopy = m_cursor;
-    if (m_validator && m_validator->validate(textCopy, cursorCopy)
-        != QValidator::Acceptable)
-        return false;
-#endif
-
-    if (!m_maskData)
-        return true;
-
-    if (str.length() != m_maxLength)
-        return false;
-
-    for (int i=0; i < m_maxLength; ++i) {
-        if (m_maskData[i].separator) {
-            if (str.at(i) != m_maskData[i].maskChar)
-                return false;
-        } else {
-            if (!isValidInput(str.at(i), m_maskData[i].maskChar))
-                return false;
-        }
-    }
-    return true;
-}
-
-/*!
-    \internal
-
-    Applies the inputMask on \a str starting from position \a pos in the mask. \a clear
-    specifies from where characters should be gotten when a separator is met in \a str - true means
-    that blanks will be used, false that previous input is used.
-    Calling this when no inputMask is set is undefined.
-*/
-QString QLineControl::maskString(uint pos, const QString &str, bool clear) const
-{
-    if (pos >= (uint)m_maxLength)
-        return QString::fromLatin1("");
-
-    QString fill;
-    fill = clear ? clearString(0, m_maxLength) : m_text;
-
-    int strIndex = 0;
-    QString s = QString::fromLatin1("");
-    int i = pos;
-    while (i < m_maxLength) {
-        if (strIndex < str.length()) {
-            if (m_maskData[i].separator) {
-                s += m_maskData[i].maskChar;
-                if (str[(int)strIndex] == m_maskData[i].maskChar)
-                    strIndex++;
-                ++i;
-            } else {
-                if (isValidInput(str[(int)strIndex], m_maskData[i].maskChar)) {
-                    switch (m_maskData[i].caseMode) {
-                    case MaskInputData::Upper:
-                        s += str[(int)strIndex].toUpper();
-                        break;
-                    case MaskInputData::Lower:
-                        s += str[(int)strIndex].toLower();
-                        break;
-                    default:
-                        s += str[(int)strIndex];
-                    }
-                    ++i;
-                } else {
-                    // search for separator first
-                    int n = findInMask(i, true, true, str[(int)strIndex]);
-                    if (n != -1) {
-                        if (str.length() != 1 || i == 0 || (i > 0 && (!m_maskData[i-1].separator || m_maskData[i-1].maskChar != str[(int)strIndex]))) {
-                            s += fill.mid(i, n-i+1);
-                            i = n + 1; // update i to find + 1
-                        }
-                    } else {
-                        // search for valid m_blank if not
-                        n = findInMask(i, true, false, str[(int)strIndex]);
-                        if (n != -1) {
-                            s += fill.mid(i, n-i);
-                            switch (m_maskData[n].caseMode) {
-                            case MaskInputData::Upper:
-                                s += str[(int)strIndex].toUpper();
-                                break;
-                            case MaskInputData::Lower:
-                                s += str[(int)strIndex].toLower();
-                                break;
-                            default:
-                                s += str[(int)strIndex];
-                            }
-                            i = n + 1; // updates i to find + 1
-                        }
-                    }
-                }
-                ++strIndex;
-            }
-        } else
-            break;
-    }
-
-    return s;
-}
-
-
-
-/*!
-    \internal
-
-    Returns a "cleared" string with only separators and blank chars.
-    Calling this when no inputMask is set is undefined.
-*/
-QString QLineControl::clearString(uint pos, uint len) const
-{
-    if (pos >= (uint)m_maxLength)
-        return QString();
-
-    QString s;
-    int end = qMin((uint)m_maxLength, pos + len);
-    for (int i = pos; i < end; ++i)
-        if (m_maskData[i].separator)
-            s += m_maskData[i].maskChar;
-        else
-            s += m_blank;
-
-    return s;
-}
-
-/*!
-    \internal
-
-    Strips blank parts of the input in a QLineControl when an inputMask is set,
-    separators are still included. Typically "127.0__.0__.1__" becomes "127.0.0.1".
-*/
-QString QLineControl::stripString(const QString &str) const
-{
-    if (!m_maskData)
-        return str;
-
-    QString s;
-    int end = qMin(m_maxLength, (int)str.length());
-    for (int i = 0; i < end; ++i)
-        if (m_maskData[i].separator)
-            s += m_maskData[i].maskChar;
-        else
-            if (str[i] != m_blank)
-                s += str[i];
-
-    return s;
-}
-
-/*!
-    \internal
-    searches forward/backward in m_maskData for either a separator or a m_blank
-*/
-int QLineControl::findInMask(int pos, bool forward, bool findSeparator, QChar searchChar) const
-{
-    if (pos >= m_maxLength || pos < 0)
-        return -1;
-
-    int end = forward ? m_maxLength : -1;
-    int step = forward ? 1 : -1;
-    int i = pos;
-
-    while (i != end) {
-        if (findSeparator) {
-            if (m_maskData[i].separator && m_maskData[i].maskChar == searchChar)
-                return i;
-        } else {
-            if (!m_maskData[i].separator) {
-                if (searchChar.isNull())
-                    return i;
-                else if (isValidInput(searchChar, m_maskData[i].maskChar))
-                    return i;
-            }
-        }
-        i += step;
-    }
-    return -1;
-}
-
-void QLineControl::internalUndo(int until)
-{
-    if (!isUndoAvailable())
-        return;
-    internalDeselect();
-    while (m_undoState && m_undoState > until) {
-        Command& cmd = m_history[--m_undoState];
-        switch (cmd.type) {
-        case Insert:
-            m_text.remove(cmd.pos, 1);
-            m_cursor = cmd.pos;
-            break;
-        case SetSelection:
-            m_selstart = cmd.selStart;
-            m_selend = cmd.selEnd;
-            m_cursor = cmd.pos;
-            break;
-        case Remove:
-        case RemoveSelection:
-            m_text.insert(cmd.pos, cmd.uc);
-            m_cursor = cmd.pos + 1;
-            break;
-        case Delete:
-        case DeleteSelection:
-            m_text.insert(cmd.pos, cmd.uc);
-            m_cursor = cmd.pos;
-            break;
-        case Separator:
-            continue;
-        }
-        if (until < 0 && m_undoState) {
-            Command& next = m_history[m_undoState-1];
-            if (next.type != cmd.type && next.type < RemoveSelection
-                 && (cmd.type < RemoveSelection || next.type == Separator))
-                break;
-        }
-    }
-    m_textDirty = true;
-    emitCursorPositionChanged();
-}
-
-void QLineControl::internalRedo()
-{
-    if (!isRedoAvailable())
-        return;
-    internalDeselect();
-    while (m_undoState < (int)m_history.size()) {
-        Command& cmd = m_history[m_undoState++];
-        switch (cmd.type) {
-        case Insert:
-            m_text.insert(cmd.pos, cmd.uc);
-            m_cursor = cmd.pos + 1;
-            break;
-        case SetSelection:
-            m_selstart = cmd.selStart;
-            m_selend = cmd.selEnd;
-            m_cursor = cmd.pos;
-            break;
-        case Remove:
-        case Delete:
-        case RemoveSelection:
-        case DeleteSelection:
-            m_text.remove(cmd.pos, 1);
-            m_selstart = cmd.selStart;
-            m_selend = cmd.selEnd;
-            m_cursor = cmd.pos;
-            break;
-        case Separator:
-            m_selstart = cmd.selStart;
-            m_selend = cmd.selEnd;
-            m_cursor = cmd.pos;
-            break;
-        }
-        if (m_undoState < (int)m_history.size()) {
-            Command& next = m_history[m_undoState];
-            if (next.type != cmd.type && cmd.type < RemoveSelection && next.type != Separator
-                 && (next.type < RemoveSelection || cmd.type == Separator))
-                break;
-        }
-    }
-    m_textDirty = true;
-    emitCursorPositionChanged();
-}
-
-/*!
-    \internal
-
-    If the current cursor position differs from the last emitted cursor
-    position, emits cursorPositionChanged().
-*/
-void QLineControl::emitCursorPositionChanged()
-{
-    if (m_cursor != m_lastCursorPos) {
-        const int oldLast = m_lastCursorPos;
-        m_lastCursorPos = m_cursor;
-        cursorPositionChanged(oldLast, m_cursor);
-#ifndef QT_NO_ACCESSIBILITY
-        QAccessible::updateAccessibility(parent(), 0, QAccessible::TextCaretMoved);
-#endif
-    }
-}
-
-
-void QLineControl::setCursorBlinkPeriod(int msec)
-{
-    if (msec == m_blinkPeriod)
-        return;
-    if (m_blinkTimer) {
-        killTimer(m_blinkTimer);
-    }
-    if (msec) {
-        m_blinkTimer = startTimer(msec / 2);
-        m_blinkStatus = 1;
-    } else {
-        m_blinkTimer = 0;
-        if (m_blinkStatus == 1)
-            emit updateNeeded(inputMask().isEmpty() ? cursorRect() : QRect());
-    }
-    m_blinkPeriod = msec;
-}
-
-void QLineControl::resetCursorBlinkTimer()
-{
-    if (m_blinkPeriod == 0 || m_blinkTimer == 0)
-        return;
-    killTimer(m_blinkTimer);
-    m_blinkTimer = startTimer(m_blinkPeriod / 2);
-    m_blinkStatus = 1;
-}
-
-void QLineControl::timerEvent(QTimerEvent *event)
-{
-    if (event->timerId() == m_blinkTimer) {
-        m_blinkStatus = !m_blinkStatus;
-        emit updateNeeded(inputMask().isEmpty() ? cursorRect() : QRect());
-    } else if (event->timerId() == m_deleteAllTimer) {
-        killTimer(m_deleteAllTimer);
-        m_deleteAllTimer = 0;
-        clear();
-    } else if (event->timerId() == m_tripleClickTimer) {
-        killTimer(m_tripleClickTimer);
-        m_tripleClickTimer = 0;
-    }
-}
-
-bool QLineControl::processEvent(QEvent* ev)
-{
-#ifdef QT_KEYPAD_NAVIGATION
-    if (QGuiApplication::keypadNavigationEnabled()) {
-        if ((ev->type() == QEvent::KeyPress) || (ev->type() == QEvent::KeyRelease)) {
-            QKeyEvent *ke = (QKeyEvent *)ev;
-            if (ke->key() == Qt::Key_Back) {
-                if (ke->isAutoRepeat()) {
-                    // Swallow it. We don't want back keys running amok.
-                    ke->accept();
-                    return true;
-                }
-                if ((ev->type() == QEvent::KeyRelease)
-                    && !isReadOnly()
-                    && m_deleteAllTimer) {
-                    killTimer(m_deleteAllTimer);
-                    m_deleteAllTimer = 0;
-                    backspace();
-                    ke->accept();
-                    return true;
-                }
-            }
-        }
-    }
-#endif
-    switch(ev->type()){
-        case QEvent::MouseButtonPress:
-        case QEvent::MouseButtonRelease:
-        case QEvent::MouseButtonDblClick:
-        case QEvent::MouseMove:
-            processMouseEvent(static_cast<QMouseEvent*>(ev)); break;
-        case QEvent::KeyPress:
-        case QEvent::KeyRelease:
-            processKeyEvent(static_cast<QKeyEvent*>(ev)); break;
-        case QEvent::InputMethod:
-            processInputMethodEvent(static_cast<QInputMethodEvent*>(ev)); break;
-#ifndef QT_NO_SHORTCUT
-        case QEvent::ShortcutOverride:{
-            if (isReadOnly())
-                return false;
-            QKeyEvent* ke = static_cast<QKeyEvent*>(ev);
-            if (ke == QKeySequence::Copy
-                || ke == QKeySequence::Paste
-                || ke == QKeySequence::Cut
-                || ke == QKeySequence::Redo
-                || ke == QKeySequence::Undo
-                || ke == QKeySequence::MoveToNextWord
-                || ke == QKeySequence::MoveToPreviousWord
-                || ke == QKeySequence::MoveToStartOfDocument
-                || ke == QKeySequence::MoveToEndOfDocument
-                || ke == QKeySequence::SelectNextWord
-                || ke == QKeySequence::SelectPreviousWord
-                || ke == QKeySequence::SelectStartOfLine
-                || ke == QKeySequence::SelectEndOfLine
-                || ke == QKeySequence::SelectStartOfBlock
-                || ke == QKeySequence::SelectEndOfBlock
-                || ke == QKeySequence::SelectStartOfDocument
-                || ke == QKeySequence::SelectAll
-                || ke == QKeySequence::SelectEndOfDocument) {
-                ke->accept();
-            } else if (ke->modifiers() == Qt::NoModifier || ke->modifiers() == Qt::ShiftModifier
-                       || ke->modifiers() == Qt::KeypadModifier) {
-                if (ke->key() < Qt::Key_Escape) {
-                    ke->accept();
-                } else {
-                    switch (ke->key()) {
-                    case Qt::Key_Delete:
-                    case Qt::Key_Home:
-                    case Qt::Key_End:
-                    case Qt::Key_Backspace:
-                    case Qt::Key_Left:
-                    case Qt::Key_Right:
-                        ke->accept();
-                    default:
-                        break;
-                    }
-                }
-            }
-        }
-#endif
-        default:
-            return false;
-    }
-    return true;
-}
-
-void QLineControl::processMouseEvent(QMouseEvent* ev)
-{
-
-    switch (ev->type()) {
-        case QEvent::MouseButtonPress:{
-            if (m_tripleClickTimer
-                && (ev->pos() - m_tripleClick).manhattanLength() < qApp->styleHints()->startDragDistance()) {
-                selectAll();
-                return;
-            }
-            if (ev->button() == Qt::RightButton)
-                return;
-
-            bool mark = ev->modifiers() & Qt::ShiftModifier;
-            int cursor = xToPos(ev->pos().x());
-            moveCursor(cursor, mark);
-            break;
-        }
-        case QEvent::MouseButtonDblClick:
-            if (ev->button() == Qt::LeftButton) {
-                selectWordAtPos(xToPos(ev->pos().x()));
-                if (m_tripleClickTimer)
-                    killTimer(m_tripleClickTimer);
-                m_tripleClickTimer = startTimer(qApp->styleHints()->mouseDoubleClickInterval());
-                m_tripleClick = ev->pos();
-            }
-            break;
-        case QEvent::MouseButtonRelease:
-#ifndef QT_NO_CLIPBOARD
-            if (QGuiApplication::clipboard()->supportsSelection()) {
-                if (ev->button() == Qt::LeftButton) {
-                    copy(QClipboard::Selection);
-                } else if (!isReadOnly() && ev->button() == Qt::MidButton) {
-                    deselect();
-                    insert(QGuiApplication::clipboard()->text(QClipboard::Selection));
-                }
-            }
-#endif
-            break;
-        case QEvent::MouseMove:
-            if (ev->buttons() & Qt::LeftButton) {
-                moveCursor(xToPos(ev->pos().x()), true);
-            }
-            break;
-        default:
-            break;
-    }
-}
-
-void QLineControl::processKeyEvent(QKeyEvent* event)
-{
-    bool inlineCompletionAccepted = false;
-
-    if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
-        if (hasAcceptableInput() || fixup()) {
-            emit accepted();
-            emit editingFinished();
-        }
-        if (inlineCompletionAccepted)
-            event->accept();
-        else
-            event->ignore();
-        return;
-    }
-
-    if (echoMode() == PasswordEchoOnEdit
-        && !passwordEchoEditing()
-        && !isReadOnly()
-        && !event->text().isEmpty()
-#ifdef QT_KEYPAD_NAVIGATION
-        && event->key() != Qt::Key_Select
-        && event->key() != Qt::Key_Up
-        && event->key() != Qt::Key_Down
-        && event->key() != Qt::Key_Back
-#endif
-        && !(event->modifiers() & Qt::ControlModifier)) {
-        // Clear the edit and reset to normal echo mode while editing; the
-        // echo mode switches back when the edit loses focus
-        // ### resets current content.  dubious code; you can
-        // navigate with keys up, down, back, and select(?), but if you press
-        // "left" or "right" it clears?
-        updatePasswordEchoEditing(true);
-        clear();
-    }
-
-    bool unknown = false;
-    bool visual = cursorMoveStyle() == Qt::VisualMoveStyle;
-
-    if (false) {
-    }
-#ifndef QT_NO_SHORTCUT
-    else if (event == QKeySequence::Undo) {
-        if (!isReadOnly())
-            undo();
-    }
-    else if (event == QKeySequence::Redo) {
-        if (!isReadOnly())
-            redo();
-    }
-    else if (event == QKeySequence::SelectAll) {
-        selectAll();
-    }
-#ifndef QT_NO_CLIPBOARD
-    else if (event == QKeySequence::Copy) {
-        copy();
-    }
-    else if (event == QKeySequence::Paste) {
-        if (!isReadOnly()) {
-            QClipboard::Mode mode = QClipboard::Clipboard;
-            paste(mode);
-        }
-    }
-    else if (event == QKeySequence::Cut) {
-        if (!isReadOnly()) {
-            copy();
-            del();
-        }
-    }
-    else if (event == QKeySequence::DeleteEndOfLine) {
-        if (!isReadOnly()) {
-            setSelection(cursor(), end());
-            copy();
-            del();
-        }
-    }
-#endif //QT_NO_CLIPBOARD
-    else if (event == QKeySequence::MoveToStartOfLine || event == QKeySequence::MoveToStartOfBlock) {
-        home(0);
-    }
-    else if (event == QKeySequence::MoveToEndOfLine || event == QKeySequence::MoveToEndOfBlock) {
-        end(0);
-    }
-    else if (event == QKeySequence::SelectStartOfLine || event == QKeySequence::SelectStartOfBlock) {
-        home(1);
-    }
-    else if (event == QKeySequence::SelectEndOfLine || event == QKeySequence::SelectEndOfBlock) {
-        end(1);
-    }
-    else if (event == QKeySequence::MoveToNextChar) {
-        if (hasSelectedText()) {
-            moveCursor(selectionEnd(), false);
-        } else {
-            cursorForward(0, visual ? 1 : (layoutDirection() == Qt::LeftToRight ? 1 : -1));
-        }
-    }
-    else if (event == QKeySequence::SelectNextChar) {
-        cursorForward(1, visual ? 1 : (layoutDirection() == Qt::LeftToRight ? 1 : -1));
-    }
-    else if (event == QKeySequence::MoveToPreviousChar) {
-        if (hasSelectedText()) {
-            moveCursor(selectionStart(), false);
-        } else {
-            cursorForward(0, visual ? -1 : (layoutDirection() == Qt::LeftToRight ? -1 : 1));
-        }
-    }
-    else if (event == QKeySequence::SelectPreviousChar) {
-        cursorForward(1, visual ? -1 : (layoutDirection() == Qt::LeftToRight ? -1 : 1));
-    }
-    else if (event == QKeySequence::MoveToNextWord) {
-        if (echoMode() == Normal)
-            layoutDirection() == Qt::LeftToRight ? cursorWordForward(0) : cursorWordBackward(0);
-        else
-            layoutDirection() == Qt::LeftToRight ? end(0) : home(0);
-    }
-    else if (event == QKeySequence::MoveToPreviousWord) {
-        if (echoMode() == Normal)
-            layoutDirection() == Qt::LeftToRight ? cursorWordBackward(0) : cursorWordForward(0);
-        else if (!isReadOnly()) {
-            layoutDirection() == Qt::LeftToRight ? home(0) : end(0);
-        }
-    }
-    else if (event == QKeySequence::SelectNextWord) {
-        if (echoMode() == Normal)
-            layoutDirection() == Qt::LeftToRight ? cursorWordForward(1) : cursorWordBackward(1);
-        else
-            layoutDirection() == Qt::LeftToRight ? end(1) : home(1);
-    }
-    else if (event == QKeySequence::SelectPreviousWord) {
-        if (echoMode() == Normal)
-            layoutDirection() == Qt::LeftToRight ? cursorWordBackward(1) : cursorWordForward(1);
-        else
-            layoutDirection() == Qt::LeftToRight ? home(1) : end(1);
-    }
-    else if (event == QKeySequence::Delete) {
-        if (!isReadOnly())
-            del();
-    }
-    else if (event == QKeySequence::DeleteEndOfWord) {
-        if (!isReadOnly()) {
-            cursorWordForward(true);
-            del();
-        }
-    }
-    else if (event == QKeySequence::DeleteStartOfWord) {
-        if (!isReadOnly()) {
-            cursorWordBackward(true);
-            del();
-        }
-    }
-#endif // QT_NO_SHORTCUT
-    else {
-        bool handled = false;
-        if (event->modifiers() & Qt::ControlModifier) {
-            switch (event->key()) {
-            case Qt::Key_Backspace:
-                if (!isReadOnly()) {
-                    cursorWordBackward(true);
-                    del();
-                }
-                break;
-            default:
-                if (!handled)
-                    unknown = true;
-            }
-        } else { // ### check for *no* modifier
-            switch (event->key()) {
-            case Qt::Key_Backspace:
-                if (!isReadOnly()) {
-                    backspace();
-                }
-                break;
-#ifdef QT_KEYPAD_NAVIGATION
-            case Qt::Key_Back:
-                if (QGuiApplication::keypadNavigationEnabled() && !event->isAutoRepeat()
-                    && !isReadOnly()) {
-                    if (text().length() == 0) {
-                        setText(m_cancelText);
-
-                        if (passwordEchoEditing())
-                            updatePasswordEchoEditing(false);
-
-                        emit editFocusChange(false);
-                    } else if (!m_deleteAllTimer) {
-                        m_deleteAllTimer = startTimer(750);
-                    }
-                } else {
-                    unknown = true;
-                }
-                break;
-#endif
-            default:
-                if (!handled)
-                    unknown = true;
-            }
-        }
-    }
-
-    if (event->key() == Qt::Key_Direction_L || event->key() == Qt::Key_Direction_R) {
-        setLayoutDirection((event->key() == Qt::Key_Direction_L) ? Qt::LeftToRight : Qt::RightToLeft);
-        unknown = false;
-    }
-
-    if (unknown && !isReadOnly()) {
-        QString t = event->text();
-        if (!t.isEmpty() && t.at(0).isPrint()) {
-            insert(t);
-            event->accept();
-            return;
-        }
-    }
-
-    if (unknown)
-        event->ignore();
-    else
-        event->accept();
-}
-
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/gui/text/qlinecontrol_p.h b/src/gui/text/qlinecontrol_p.h
deleted file mode 100644
index 4c97acc..0000000
--- a/src/gui/text/qlinecontrol_p.h
+++ /dev/null
@@ -1,455 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QLINECONTROL_P_H
-#define QLINECONTROL_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "QtCore/qglobal.h"
-
-#include "QtGui/qtextlayout.h"
-#include "QtCore/qpointer.h"
-#include "QtGui/qclipboard.h"
-#include "QtGui/qvalidator.h"
-#include "QtGui/qpalette.h"
-#include "QtGui/qguiapplication.h"
-#include "QtGui/qinputpanel.h"
-#include "QtCore/qpoint.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-class Q_GUI_EXPORT QLineControl : public QObject
-{
-    Q_OBJECT
-
-public:
-    QLineControl(const QString &txt = QString())
-        : m_cursor(0), m_preeditCursor(0), m_cursorWidth(0), m_layoutDirection(Qt::LayoutDirectionAuto),
-        m_hideCursor(false), m_separator(0), m_readOnly(0),
-        m_dragEnabled(0), m_echoMode(Normal), m_textDirty(0), m_selDirty(0),
-        m_validInput(1), m_blinkStatus(0), m_blinkPeriod(0), m_blinkTimer(0), m_deleteAllTimer(0),
-        m_ascent(0), m_maxLength(32767), m_lastCursorPos(-1),
-        m_tripleClickTimer(0), m_maskData(0), m_modifiedState(0), m_undoState(0),
-        m_selstart(0), m_selend(0), m_passwordEchoEditing(false)
-    {
-        init(txt);
-    }
-
-    enum EchoMode {
-        Normal,
-        NoEcho,
-        Password,
-        PasswordEchoOnEdit
-    };
-
-
-    ~QLineControl()
-    {
-        delete [] m_maskData;
-    }
-
-    int nextMaskBlank(int pos)
-    {
-        int c = findInMask(pos, true, false);
-        m_separator |= (c != pos);
-        return (c != -1 ?  c : m_maxLength);
-    }
-
-    int prevMaskBlank(int pos)
-    {
-        int c = findInMask(pos, false, false);
-        m_separator |= (c != pos);
-        return (c != -1 ? c : 0);
-    }
-
-    bool isUndoAvailable() const { return !m_readOnly && m_undoState; }
-    bool isRedoAvailable() const { return !m_readOnly && m_undoState < (int)m_history.size(); }
-    void clearUndo() { m_history.clear(); m_modifiedState = m_undoState = 0; }
-
-    bool isModified() const { return m_modifiedState != m_undoState; }
-    void setModified(bool modified) { m_modifiedState = modified ? -1 : m_undoState; }
-
-    bool allSelected() const { return !m_text.isEmpty() && m_selstart == 0 && m_selend == (int)m_text.length(); }
-    bool hasSelectedText() const { return !m_text.isEmpty() && m_selend > m_selstart; }
-
-    int width() const { return qRound(m_textLayout.lineAt(0).width()) + 1; }
-    int height() const { return qRound(m_textLayout.lineAt(0).height()) + 1; }
-    int ascent() const { return m_ascent; }
-    qreal naturalTextWidth() const { return m_textLayout.lineAt(0).naturalTextWidth(); }
-
-    void setSelection(int start, int length);
-
-    inline QString selectedText() const { return hasSelectedText() ? m_text.mid(m_selstart, m_selend - m_selstart) : QString(); }
-    QString textBeforeSelection() const { return hasSelectedText() ? m_text.left(m_selstart) : QString(); }
-    QString textAfterSelection() const { return hasSelectedText() ? m_text.mid(m_selend) : QString(); }
-
-    int selectionStart() const { return hasSelectedText() ? m_selstart : -1; }
-    int selectionEnd() const { return hasSelectedText() ? m_selend : -1; }
-    bool inSelection(int x) const
-    {
-        if (m_selstart >= m_selend)
-            return false;
-        int pos = xToPos(x, QTextLine::CursorOnCharacter);
-        return pos >= m_selstart && pos < m_selend;
-    }
-
-    void removeSelection()
-    {
-        int priorState = m_undoState;
-        removeSelectedText();
-        finishChange(priorState);
-    }
-
-    int start() const { return 0; }
-    int end() const { return m_text.length(); }
-
-#ifndef QT_NO_CLIPBOARD
-    void copy(QClipboard::Mode mode = QClipboard::Clipboard) const;
-    void paste(QClipboard::Mode mode = QClipboard::Clipboard);
-#endif
-
-    int cursor() const{ return m_cursor; }
-    int preeditCursor() const { return m_preeditCursor; }
-
-    int cursorWidth() const { return m_cursorWidth; }
-    void setCursorWidth(int value) { m_cursorWidth = value; }
-
-    Qt::CursorMoveStyle cursorMoveStyle() const { return m_textLayout.cursorMoveStyle(); }
-    void setCursorMoveStyle(Qt::CursorMoveStyle style) { m_textLayout.setCursorMoveStyle(style); }
-
-    void moveCursor(int pos, bool mark = false);
-    void cursorForward(bool mark, int steps)
-    {
-        int c = m_cursor;
-        if (steps > 0) {
-            while (steps--)
-                c = cursorMoveStyle() == Qt::VisualMoveStyle ? m_textLayout.rightCursorPosition(c)
-                                                             : m_textLayout.nextCursorPosition(c);
-        } else if (steps < 0) {
-            while (steps++)
-                c = cursorMoveStyle() == Qt::VisualMoveStyle ? m_textLayout.leftCursorPosition(c)
-                                                             : m_textLayout.previousCursorPosition(c);
-        }
-        moveCursor(c, mark);
-    }
-
-    void cursorWordForward(bool mark) { moveCursor(m_textLayout.nextCursorPosition(m_cursor, QTextLayout::SkipWords), mark); }
-    void cursorWordBackward(bool mark) { moveCursor(m_textLayout.previousCursorPosition(m_cursor, QTextLayout::SkipWords), mark); }
-
-    void home(bool mark) { moveCursor(0, mark); }
-    void end(bool mark) { moveCursor(text().length(), mark); }
-
-    int xToPos(int x, QTextLine::CursorPosition = QTextLine::CursorBetweenCharacters) const;
-    QRect cursorRect() const;
-
-    qreal cursorToX(int cursor) const { return m_textLayout.lineAt(0).cursorToX(cursor); }
-    qreal cursorToX() const
-    {
-        int cursor = m_cursor;
-        if (m_preeditCursor != -1)
-            cursor += m_preeditCursor;
-        return cursorToX(cursor);
-    }
-
-    bool isReadOnly() const { return m_readOnly; }
-    void setReadOnly(bool enable) { m_readOnly = enable; }
-
-    QString text() const;
-    QString realText() const;
-    void setText(const QString &txt);
-    void commitPreedit();
-
-    QString displayText() const { return m_textLayout.text(); }
-
-    void backspace();
-    void del();
-    void deselect() { internalDeselect(); finishChange(); }
-    void selectAll() { m_selstart = m_selend = m_cursor = 0; moveCursor(m_text.length(), true); }
-
-    void insert(const QString &);
-    void clear();
-    void undo() { internalUndo(); finishChange(-1, true); }
-    void redo() { internalRedo(); finishChange(); }
-    void selectWordAtPos(int);
-
-    EchoMode echoMode() const { return EchoMode(m_echoMode); }
-    void setEchoMode(EchoMode mode)
-    {
-        m_echoMode = mode;
-        m_passwordEchoEditing = false;
-        updateDisplayText();
-    }
-
-    int maxLength() const { return m_maxLength; }
-    void setMaxLength(int maxLength)
-    {
-        if (m_maskData)
-            return;
-        m_maxLength = maxLength;
-        setText(m_text);
-    }
-
-#ifndef QT_NO_VALIDATOR
-    const QValidator *validator() const { return m_validator; }
-    void setValidator(const QValidator *v) { m_validator = const_cast<QValidator*>(v); }
-#endif
-
-    int cursorPosition() const { return m_cursor; }
-    void setCursorPosition(int pos) { if (pos <= m_text.length()) moveCursor(qMax(0, pos)); }
-
-    bool hasAcceptableInput() const { return hasAcceptableInput(m_text); }
-    bool fixup();
-
-    QString inputMask() const { return m_maskData ? m_inputMask + QLatin1Char(';') + m_blank : QString(); }
-    void setInputMask(const QString &mask)
-    {
-        parseInputMask(mask);
-        if (m_maskData)
-            moveCursor(nextMaskBlank(0));
-    }
-
-    // input methods
-#ifndef QT_NO_IM
-    bool composeMode() const { return !m_textLayout.preeditAreaText().isEmpty(); }
-    void setPreeditArea(int cursor, const QString &text) { m_textLayout.setPreeditArea(cursor, text); }
-#endif
-
-    QString preeditAreaText() const { return m_textLayout.preeditAreaText(); }
-
-    void updatePasswordEchoEditing(bool editing);
-    bool passwordEchoEditing() const { return m_passwordEchoEditing; }
-
-    QChar passwordCharacter() const { return m_passwordCharacter; }
-    void setPasswordCharacter(const QChar &character) { m_passwordCharacter = character; updateDisplayText(); }
-
-    Qt::LayoutDirection layoutDirection() const {
-        if (m_layoutDirection == Qt::LayoutDirectionAuto) {
-            if (m_text.isEmpty())
-                return qApp->inputPanel()->inputDirection();
-            return m_text.isRightToLeft() ? Qt::RightToLeft : Qt::LeftToRight;
-        }
-        return m_layoutDirection;
-    }
-    void setLayoutDirection(Qt::LayoutDirection direction)
-    {
-        if (direction != m_layoutDirection) {
-            m_layoutDirection = direction;
-            updateDisplayText();
-        }
-    }
-
-    void setFont(const QFont &font) { m_textLayout.setFont(font); updateDisplayText(); }
-
-    void processInputMethodEvent(QInputMethodEvent *event);
-    void processMouseEvent(QMouseEvent* ev);
-    void processKeyEvent(QKeyEvent* ev);
-
-    int cursorBlinkPeriod() const { return m_blinkPeriod; }
-    void setCursorBlinkPeriod(int msec);
-    void resetCursorBlinkTimer();
-
-    bool cursorBlinkStatus() const { return m_blinkStatus; }
-
-    QString cancelText() const { return m_cancelText; }
-    void setCancelText(const QString &text) { m_cancelText = text; }
-
-    const QPalette &palette() const { return m_palette; }
-    void setPalette(const QPalette &p) { m_palette = p; }
-
-    enum DrawFlags {
-        DrawText = 0x01,
-        DrawSelections = 0x02,
-        DrawCursor = 0x04,
-        DrawAll = DrawText | DrawSelections | DrawCursor
-    };
-    void draw(QPainter *, const QPoint &, const QRect &, int flags = DrawAll);
-
-    bool processEvent(QEvent *ev);
-
-    QTextLayout *textLayout()
-    {
-        return &m_textLayout;
-    }
-
-private:
-    void init(const QString &txt);
-    void removeSelectedText();
-    void internalSetText(const QString &txt, int pos = -1, bool edited = true);
-    void updateDisplayText(bool forceUpdate = false);
-
-    void internalInsert(const QString &s);
-    void internalDelete(bool wasBackspace = false);
-    void internalRemove(int pos);
-
-    inline void internalDeselect()
-    {
-        m_selDirty |= (m_selend > m_selstart);
-        m_selstart = m_selend = 0;
-    }
-
-    void internalUndo(int until = -1);
-    void internalRedo();
-
-    QString m_text;
-    QPalette m_palette;
-    int m_cursor;
-    int m_preeditCursor;
-    int m_cursorWidth;
-    QString m_tentativeCommit;
-    Qt::LayoutDirection m_layoutDirection;
-    uint m_hideCursor : 1; // used to hide the m_cursor inside preedit areas
-    uint m_separator : 1;
-    uint m_readOnly : 1;
-    uint m_dragEnabled : 1;
-    uint m_echoMode : 2;
-    uint m_textDirty : 1;
-    uint m_selDirty : 1;
-    uint m_validInput : 1;
-    uint m_blinkStatus : 1;
-    int m_blinkPeriod; // 0 for non-blinking cursor
-    int m_blinkTimer;
-    int m_deleteAllTimer;
-    int m_ascent;
-    int m_maxLength;
-    int m_lastCursorPos;
-    QList<int> m_transactions;
-    QPoint m_tripleClick;
-    int m_tripleClickTimer;
-    QString m_cancelText;
-
-    void emitCursorPositionChanged();
-
-    bool finishChange(int validateFromState = -1, bool update = false, bool edited = true);
-
-#ifndef QT_NO_VALIDATOR
-    QPointer<QValidator> m_validator;
-#endif
-
-    struct MaskInputData {
-        enum Casemode { NoCaseMode, Upper, Lower };
-        QChar maskChar; // either the separator char or the inputmask
-        bool separator;
-        Casemode caseMode;
-    };
-    QString m_inputMask;
-    QChar m_blank;
-    MaskInputData *m_maskData;
-
-    // undo/redo handling
-    enum CommandType { Separator, Insert, Remove, Delete, RemoveSelection, DeleteSelection, SetSelection };
-    struct Command {
-        inline Command() {}
-        inline Command(CommandType t, int p, QChar c, int ss, int se) : type(t),uc(c),pos(p),selStart(ss),selEnd(se) {}
-        uint type : 4;
-        QChar uc;
-        int pos, selStart, selEnd;
-    };
-    int m_modifiedState;
-    int m_undoState;
-    QVector<Command> m_history;
-    void addCommand(const Command& cmd);
-
-    inline void separate() { m_separator = true; }
-
-    // selection
-    int m_selstart;
-    int m_selend;
-
-    // masking
-    void parseInputMask(const QString &maskFields);
-    bool isValidInput(QChar key, QChar mask) const;
-    bool hasAcceptableInput(const QString &text) const;
-    QString maskString(uint pos, const QString &str, bool clear = false) const;
-    QString clearString(uint pos, uint len) const;
-    QString stripString(const QString &str) const;
-    int findInMask(int pos, bool forward, bool findSeparator, QChar searchChar = QChar()) const;
-
-    // complex text layout
-    QTextLayout m_textLayout;
-
-    bool m_passwordEchoEditing;
-    QChar m_passwordCharacter;
-
-Q_SIGNALS:
-    void cursorPositionChanged(int, int);
-    void selectionChanged();
-
-    void displayTextChanged(const QString &);
-    void textChanged(const QString &);
-    void textEdited(const QString &);
-
-    void resetInputContext();
-    void updateMicroFocus();
-
-    void accepted();
-    void editingFinished();
-    void updateNeeded(const QRect &);
-
-#ifdef QT_KEYPAD_NAVIGATION
-    void editFocusChange(bool);
-#endif
-protected:
-    virtual void timerEvent(QTimerEvent *event);
-
-private Q_SLOTS:
-    void _q_clipboardChanged();
-    void _q_deleteSelected();
-
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QLineControl_P_H
diff --git a/src/gui/text/qtextcontrol.cpp b/src/gui/text/qtextcontrol.cpp
deleted file mode 100644
index fb11661..0000000
--- a/src/gui/text/qtextcontrol.cpp
+++ /dev/null
@@ -1,2893 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qtextcontrol_p.h"
-#include "qtextcontrol_p_p.h"
-
-#ifndef QT_NO_TEXTCONTROL
-
-#include <qfont.h>
-#include <qpainter.h>
-#include <qevent.h>
-#include <qdebug.h>
-#include <qdrag.h>
-#include <qclipboard.h>
-#include <qtimer.h>
-#include <qinputpanel.h>
-#include "private/qtextdocumentlayout_p.h"
-#include "private/qabstracttextdocumentlayout_p.h"
-#include "qtextdocument.h"
-#include "private/qtextdocument_p.h"
-#include "qtextlist.h"
-#include "qtextdocumentwriter.h"
-#include "private/qtextcursor_p.h"
-#include "qpagedpaintdevice.h"
-#include "private/qpagedpaintdevice_p.h"
-
-#include <qtextformat.h>
-#include <qdatetime.h>
-#include <qbuffer.h>
-#include <qguiapplication.h>
-#include <limits.h>
-#include <qtexttable.h>
-#include <qvariant.h>
-#include <qurl.h>
-#include <qstylehints.h>
-
-// ### these should come from QStyleHints
-const int textCursorWidth = 1;
-const bool fullWidthSelection = true;
-
-QT_BEGIN_NAMESPACE
-
-#ifndef QT_NO_CONTEXTMENU
-#endif
-
-// could go into QTextCursor...
-static QTextLine currentTextLine(const QTextCursor &cursor)
-{
-    const QTextBlock block = cursor.block();
-    if (!block.isValid())
-        return QTextLine();
-
-    const QTextLayout *layout = block.layout();
-    if (!layout)
-        return QTextLine();
-
-    const int relativePos = cursor.position() - block.position();
-    return layout->lineForTextPosition(relativePos);
-}
-
-QTextControlPrivate::QTextControlPrivate()
-    : doc(0), cursorOn(false), cursorIsFocusIndicator(false),
-      interactionFlags(Qt::TextEditorInteraction),
-      dragEnabled(true),
-#ifndef QT_NO_DRAGANDDROP
-      mousePressed(false), mightStartDrag(false),
-#endif
-      lastSelectionState(false), ignoreAutomaticScrollbarAdjustement(false),
-      overwriteMode(false),
-      acceptRichText(true),
-      preeditCursor(0), hideCursor(false),
-      hasFocus(false),
-#ifdef QT_KEYPAD_NAVIGATION
-      hasEditFocus(false),
-#endif
-      isEnabled(true),
-      hadSelectionOnMousePress(false),
-      ignoreUnusedNavigationEvents(false),
-      openExternalLinks(false),
-      wordSelectionEnabled(false)
-{}
-
-bool QTextControlPrivate::cursorMoveKeyEvent(QKeyEvent *e)
-{
-#ifdef QT_NO_SHORTCUT
-    Q_UNUSED(e);
-#endif
-
-    Q_Q(QTextControl);
-    if (cursor.isNull())
-        return false;
-
-    const QTextCursor oldSelection = cursor;
-    const int oldCursorPos = cursor.position();
-
-    QTextCursor::MoveMode mode = QTextCursor::MoveAnchor;
-    QTextCursor::MoveOperation op = QTextCursor::NoMove;
-
-    if (false) {
-    }
-#ifndef QT_NO_SHORTCUT
-    if (e == QKeySequence::MoveToNextChar) {
-            op = QTextCursor::Right;
-    }
-    else if (e == QKeySequence::MoveToPreviousChar) {
-            op = QTextCursor::Left;
-    }
-    else if (e == QKeySequence::SelectNextChar) {
-           op = QTextCursor::Right;
-           mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectPreviousChar) {
-            op = QTextCursor::Left;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectNextWord) {
-            op = QTextCursor::WordRight;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectPreviousWord) {
-            op = QTextCursor::WordLeft;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectStartOfLine) {
-            op = QTextCursor::StartOfLine;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectEndOfLine) {
-            op = QTextCursor::EndOfLine;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectStartOfBlock) {
-            op = QTextCursor::StartOfBlock;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectEndOfBlock) {
-            op = QTextCursor::EndOfBlock;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectStartOfDocument) {
-            op = QTextCursor::Start;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectEndOfDocument) {
-            op = QTextCursor::End;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectPreviousLine) {
-            op = QTextCursor::Up;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectNextLine) {
-            op = QTextCursor::Down;
-            mode = QTextCursor::KeepAnchor;
-            {
-                QTextBlock block = cursor.block();
-                QTextLine line = currentTextLine(cursor);
-                if (!block.next().isValid()
-                    && line.isValid()
-                    && line.lineNumber() == block.layout()->lineCount() - 1)
-                    op = QTextCursor::End;
-            }
-    }
-    else if (e == QKeySequence::MoveToNextWord) {
-            op = QTextCursor::WordRight;
-    }
-    else if (e == QKeySequence::MoveToPreviousWord) {
-            op = QTextCursor::WordLeft;
-    }
-    else if (e == QKeySequence::MoveToEndOfBlock) {
-            op = QTextCursor::EndOfBlock;
-    }
-    else if (e == QKeySequence::MoveToStartOfBlock) {
-            op = QTextCursor::StartOfBlock;
-    }
-    else if (e == QKeySequence::MoveToNextLine) {
-            op = QTextCursor::Down;
-    }
-    else if (e == QKeySequence::MoveToPreviousLine) {
-            op = QTextCursor::Up;
-    }
-    else if (e == QKeySequence::MoveToStartOfLine) {
-            op = QTextCursor::StartOfLine;
-    }
-    else if (e == QKeySequence::MoveToEndOfLine) {
-            op = QTextCursor::EndOfLine;
-    }
-    else if (e == QKeySequence::MoveToStartOfDocument) {
-            op = QTextCursor::Start;
-    }
-    else if (e == QKeySequence::MoveToEndOfDocument) {
-            op = QTextCursor::End;
-    }
-#endif // QT_NO_SHORTCUT
-    else {
-        return false;
-    }
-
-// Except for pageup and pagedown, Mac OS X has very different behavior, we don't do it all, but
-// here's the breakdown:
-// Shift still works as an anchor, but only one of the other keys can be down Ctrl (Command),
-// Alt (Option), or Meta (Control).
-// Command/Control + Left/Right -- Move to left or right of the line
-//                 + Up/Down -- Move to top bottom of the file. (Control doesn't move the cursor)
-// Option + Left/Right -- Move one word Left/right.
-//        + Up/Down  -- Begin/End of Paragraph.
-// Home/End Top/Bottom of file. (usually don't move the cursor, but will select)
-
-    bool visualNavigation = cursor.visualNavigation();
-    cursor.setVisualNavigation(true);
-    const bool moved = cursor.movePosition(op, mode);
-    cursor.setVisualNavigation(visualNavigation);
-    q->ensureCursorVisible();
-
-    bool ignoreNavigationEvents = ignoreUnusedNavigationEvents;
-    bool isNavigationEvent = e->key() == Qt::Key_Up || e->key() == Qt::Key_Down;
-
-#ifdef QT_KEYPAD_NAVIGATION
-    ignoreNavigationEvents = ignoreNavigationEvents || QGuiApplication::keypadNavigationEnabled();
-    isNavigationEvent = isNavigationEvent ||
-                        (QGuiApplication::navigationMode() == Qt::NavigationModeKeypadDirectional
-                         && (e->key() == Qt::Key_Left || e->key() == Qt::Key_Right));
-#else
-    isNavigationEvent = isNavigationEvent || e->key() == Qt::Key_Left || e->key() == Qt::Key_Right;
-#endif
-
-    if (moved) {
-        if (cursor.position() != oldCursorPos)
-            emit q->cursorPositionChanged();
-        emit q->microFocusChanged();
-    } else if (ignoreNavigationEvents && isNavigationEvent && oldSelection.anchor() == cursor.anchor()) {
-        return false;
-    }
-
-    selectionChanged(/*forceEmitSelectionChanged =*/(mode == QTextCursor::KeepAnchor));
-
-    repaintOldAndNewSelection(oldSelection);
-
-    return true;
-}
-
-void QTextControlPrivate::updateCurrentCharFormat()
-{
-    Q_Q(QTextControl);
-
-    QTextCharFormat fmt = cursor.charFormat();
-    if (fmt == lastCharFormat)
-        return;
-    lastCharFormat = fmt;
-
-    emit q->currentCharFormatChanged(fmt);
-    emit q->microFocusChanged();
-}
-
-void QTextControlPrivate::indent()
-{
-    QTextBlockFormat blockFmt = cursor.blockFormat();
-
-    QTextList *list = cursor.currentList();
-    if (!list) {
-        QTextBlockFormat modifier;
-        modifier.setIndent(blockFmt.indent() + 1);
-        cursor.mergeBlockFormat(modifier);
-    } else {
-        QTextListFormat format = list->format();
-        format.setIndent(format.indent() + 1);
-
-        if (list->itemNumber(cursor.block()) == 1)
-            list->setFormat(format);
-        else
-            cursor.createList(format);
-    }
-}
-
-void QTextControlPrivate::outdent()
-{
-    QTextBlockFormat blockFmt = cursor.blockFormat();
-
-    QTextList *list = cursor.currentList();
-
-    if (!list) {
-        QTextBlockFormat modifier;
-        modifier.setIndent(blockFmt.indent() - 1);
-        cursor.mergeBlockFormat(modifier);
-    } else {
-        QTextListFormat listFmt = list->format();
-        listFmt.setIndent(listFmt.indent() - 1);
-        list->setFormat(listFmt);
-    }
-}
-
-void QTextControlPrivate::gotoNextTableCell()
-{
-    QTextTable *table = cursor.currentTable();
-    QTextTableCell cell = table->cellAt(cursor);
-
-    int newColumn = cell.column() + cell.columnSpan();
-    int newRow = cell.row();
-
-    if (newColumn >= table->columns()) {
-        newColumn = 0;
-        ++newRow;
-        if (newRow >= table->rows())
-            table->insertRows(table->rows(), 1);
-    }
-
-    cell = table->cellAt(newRow, newColumn);
-    cursor = cell.firstCursorPosition();
-}
-
-void QTextControlPrivate::gotoPreviousTableCell()
-{
-    QTextTable *table = cursor.currentTable();
-    QTextTableCell cell = table->cellAt(cursor);
-
-    int newColumn = cell.column() - 1;
-    int newRow = cell.row();
-
-    if (newColumn < 0) {
-        newColumn = table->columns() - 1;
-        --newRow;
-        if (newRow < 0)
-            return;
-    }
-
-    cell = table->cellAt(newRow, newColumn);
-    cursor = cell.firstCursorPosition();
-}
-
-void QTextControlPrivate::createAutoBulletList()
-{
-    cursor.beginEditBlock();
-
-    QTextBlockFormat blockFmt = cursor.blockFormat();
-
-    QTextListFormat listFmt;
-    listFmt.setStyle(QTextListFormat::ListDisc);
-    listFmt.setIndent(blockFmt.indent() + 1);
-
-    blockFmt.setIndent(0);
-    cursor.setBlockFormat(blockFmt);
-
-    cursor.createList(listFmt);
-
-    cursor.endEditBlock();
-}
-
-void QTextControlPrivate::init(Qt::TextFormat format, const QString &text, QTextDocument *document)
-{
-    Q_Q(QTextControl);
-    setContent(format, text, document);
-
-    doc->setUndoRedoEnabled(interactionFlags & Qt::TextEditable);
-    q->setCursorWidth(-1);
-
-    QObject::connect(q, SIGNAL(updateCursorRequest(QRectF)), q, SIGNAL(updateRequest(QRectF)));
-}
-
-void QTextControlPrivate::setContent(Qt::TextFormat format, const QString &text, QTextDocument *document)
-{
-    Q_Q(QTextControl);
-
-    // for use when called from setPlainText. we may want to re-use the currently
-    // set char format then.
-    const QTextCharFormat charFormatForInsertion = cursor.charFormat();
-
-    bool clearDocument = true;
-    if (!doc) {
-        if (document) {
-            doc = document;
-            clearDocument = false;
-        } else {
-            palette = QGuiApplication::palette();
-            doc = new QTextDocument(q);
-        }
-        _q_documentLayoutChanged();
-        cursor = QTextCursor(doc);
-
-// ####        doc->documentLayout()->setPaintDevice(viewport);
-
-        QObject::connect(doc, SIGNAL(contentsChanged()), q, SLOT(_q_updateCurrentCharFormatAndSelection()));
-        QObject::connect(doc, SIGNAL(cursorPositionChanged(QTextCursor)), q, SLOT(_q_emitCursorPosChanged(QTextCursor)));
-        QObject::connect(doc, SIGNAL(documentLayoutChanged()), q, SLOT(_q_documentLayoutChanged()));
-
-        // convenience signal forwards
-        QObject::connect(doc, SIGNAL(undoAvailable(bool)), q, SIGNAL(undoAvailable(bool)));
-        QObject::connect(doc, SIGNAL(redoAvailable(bool)), q, SIGNAL(redoAvailable(bool)));
-        QObject::connect(doc, SIGNAL(modificationChanged(bool)), q, SIGNAL(modificationChanged(bool)));
-        QObject::connect(doc, SIGNAL(blockCountChanged(int)), q, SIGNAL(blockCountChanged(int)));
-    }
-
-    bool previousUndoRedoState = doc->isUndoRedoEnabled();
-    if (!document)
-        doc->setUndoRedoEnabled(false);
-
-    //Saving the index save some time.
-    static int contentsChangedIndex = QTextDocument::staticMetaObject.indexOfSignal("contentsChanged()");
-    static int textChangedIndex = QTextControl::staticMetaObject.indexOfSignal("textChanged()");
-    // avoid multiple textChanged() signals being emitted
-    QMetaObject::disconnect(doc, contentsChangedIndex, q, textChangedIndex);
-
-    if (!text.isEmpty()) {
-        // clear 'our' cursor for insertion to prevent
-        // the emission of the cursorPositionChanged() signal.
-        // instead we emit it only once at the end instead of
-        // at the end of the document after loading and when
-        // positioning the cursor again to the start of the
-        // document.
-        cursor = QTextCursor();
-        if (format == Qt::PlainText) {
-            QTextCursor formatCursor(doc);
-            // put the setPlainText and the setCharFormat into one edit block,
-            // so that the syntax highlight triggers only /once/ for the entire
-            // document, not twice.
-            formatCursor.beginEditBlock();
-            doc->setPlainText(text);
-            doc->setUndoRedoEnabled(false);
-            formatCursor.select(QTextCursor::Document);
-            formatCursor.setCharFormat(charFormatForInsertion);
-            formatCursor.endEditBlock();
-        } else {
-#ifndef QT_NO_TEXTHTMLPARSER
-            doc->setHtml(text);
-#else
-            doc->setPlainText(text);
-#endif
-            doc->setUndoRedoEnabled(false);
-        }
-        cursor = QTextCursor(doc);
-    } else if (clearDocument) {
-        doc->clear();
-    }
-    cursor.setCharFormat(charFormatForInsertion);
-
-    QMetaObject::connect(doc, contentsChangedIndex, q, textChangedIndex);
-    emit q->textChanged();
-    if (!document)
-        doc->setUndoRedoEnabled(previousUndoRedoState);
-    _q_updateCurrentCharFormatAndSelection();
-    if (!document)
-        doc->setModified(false);
-
-    q->ensureCursorVisible();
-    emit q->cursorPositionChanged();
-}
-
-void QTextControlPrivate::startDrag()
-{
-#ifndef QT_NO_DRAGANDDROP
-    Q_Q(QTextControl);
-    mousePressed = false;
-    if (!contextObject)
-        return;
-    QMimeData *data = q->createMimeDataFromSelection();
-
-    QDrag *drag = new QDrag(contextObject);
-    drag->setMimeData(data);
-
-    Qt::DropActions actions = Qt::CopyAction;
-    Qt::DropAction action;
-    if (interactionFlags & Qt::TextEditable) {
-        actions |= Qt::MoveAction;
-        action = drag->exec(actions, Qt::MoveAction);
-    } else {
-        action = drag->exec(actions, Qt::CopyAction);
-    }
-
-    if (action == Qt::MoveAction && drag->target() != contextObject)
-        cursor.removeSelectedText();
-#endif
-}
-
-void QTextControlPrivate::setCursorPosition(const QPointF &pos)
-{
-    Q_Q(QTextControl);
-    const int cursorPos = q->hitTest(pos, Qt::FuzzyHit);
-    if (cursorPos == -1)
-        return;
-    cursor.setPosition(cursorPos);
-}
-
-void QTextControlPrivate::setCursorPosition(int pos, QTextCursor::MoveMode mode)
-{
-    cursor.setPosition(pos, mode);
-
-    if (mode != QTextCursor::KeepAnchor) {
-        selectedWordOnDoubleClick = QTextCursor();
-        selectedBlockOnTrippleClick = QTextCursor();
-    }
-}
-
-void QTextControlPrivate::repaintCursor()
-{
-    Q_Q(QTextControl);
-    emit q->updateCursorRequest(cursorRectPlusUnicodeDirectionMarkers(cursor));
-}
-
-void QTextControlPrivate::repaintOldAndNewSelection(const QTextCursor &oldSelection)
-{
-    Q_Q(QTextControl);
-    if (cursor.hasSelection()
-        && oldSelection.hasSelection()
-        && cursor.currentFrame() == oldSelection.currentFrame()
-        && !cursor.hasComplexSelection()
-        && !oldSelection.hasComplexSelection()
-        && cursor.anchor() == oldSelection.anchor()
-        ) {
-        QTextCursor differenceSelection(doc);
-        differenceSelection.setPosition(oldSelection.position());
-        differenceSelection.setPosition(cursor.position(), QTextCursor::KeepAnchor);
-        emit q->updateRequest(q->selectionRect(differenceSelection));
-    } else {
-        if (!oldSelection.hasSelection() && !cursor.hasSelection()) {
-            if (!oldSelection.isNull())
-                emit q->updateCursorRequest(q->selectionRect(oldSelection) | cursorRectPlusUnicodeDirectionMarkers(oldSelection));
-            emit q->updateCursorRequest(q->selectionRect() | cursorRectPlusUnicodeDirectionMarkers(cursor));
-
-        } else {
-            if (!oldSelection.isNull())
-                emit q->updateRequest(q->selectionRect(oldSelection) | cursorRectPlusUnicodeDirectionMarkers(oldSelection));
-            emit q->updateRequest(q->selectionRect() | cursorRectPlusUnicodeDirectionMarkers(cursor));
-        }
-    }
-}
-
-void QTextControlPrivate::selectionChanged(bool forceEmitSelectionChanged /*=false*/)
-{
-    Q_Q(QTextControl);
-    if (forceEmitSelectionChanged)
-        emit q->selectionChanged();
-
-    bool current = cursor.hasSelection();
-    if (current == lastSelectionState)
-        return;
-
-    lastSelectionState = current;
-    emit q->copyAvailable(current);
-    if (!forceEmitSelectionChanged)
-        emit q->selectionChanged();
-    emit q->microFocusChanged();
-}
-
-void QTextControlPrivate::_q_updateCurrentCharFormatAndSelection()
-{
-    updateCurrentCharFormat();
-    selectionChanged();
-}
-
-#ifndef QT_NO_CLIPBOARD
-void QTextControlPrivate::setClipboardSelection()
-{
-    QClipboard *clipboard = QGuiApplication::clipboard();
-    if (!cursor.hasSelection() || !clipboard->supportsSelection())
-        return;
-    Q_Q(QTextControl);
-    QMimeData *data = q->createMimeDataFromSelection();
-    clipboard->setMimeData(data, QClipboard::Selection);
-}
-#endif
-
-void QTextControlPrivate::_q_emitCursorPosChanged(const QTextCursor &someCursor)
-{
-    Q_Q(QTextControl);
-    if (someCursor.isCopyOf(cursor)) {
-        emit q->cursorPositionChanged();
-        emit q->microFocusChanged();
-    }
-}
-
-void QTextControlPrivate::_q_documentLayoutChanged()
-{
-    Q_Q(QTextControl);
-    QAbstractTextDocumentLayout *layout = doc->documentLayout();
-    QObject::connect(layout, SIGNAL(update(QRectF)), q, SIGNAL(updateRequest(QRectF)));
-    QObject::connect(layout, SIGNAL(updateBlock(QTextBlock)), q, SLOT(_q_updateBlock(QTextBlock)));
-    QObject::connect(layout, SIGNAL(documentSizeChanged(QSizeF)), q, SIGNAL(documentSizeChanged(QSizeF)));
-
-}
-
-void QTextControlPrivate::setBlinkingCursorEnabled(bool enable)
-{
-    Q_Q(QTextControl);
-
-    if (enable && qApp->styleHints()->cursorFlashTime() > 0)
-        cursorBlinkTimer.start(qApp->styleHints()->cursorFlashTime() / 2, q);
-    else
-        cursorBlinkTimer.stop();
-
-    cursorOn = enable;
-
-    repaintCursor();
-}
-
-void QTextControlPrivate::extendWordwiseSelection(int suggestedNewPosition, qreal mouseXPosition)
-{
-    Q_Q(QTextControl);
-
-    // if inside the initial selected word keep that
-    if (suggestedNewPosition >= selectedWordOnDoubleClick.selectionStart()
-        && suggestedNewPosition <= selectedWordOnDoubleClick.selectionEnd()) {
-        q->setTextCursor(selectedWordOnDoubleClick);
-        return;
-    }
-
-    QTextCursor curs = selectedWordOnDoubleClick;
-    curs.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
-
-    if (!curs.movePosition(QTextCursor::StartOfWord))
-        return;
-    const int wordStartPos = curs.position();
-
-    const int blockPos = curs.block().position();
-    const QPointF blockCoordinates = q->blockBoundingRect(curs.block()).topLeft();
-
-    QTextLine line = currentTextLine(curs);
-    if (!line.isValid())
-        return;
-
-    const qreal wordStartX = line.cursorToX(curs.position() - blockPos) + blockCoordinates.x();
-
-    if (!curs.movePosition(QTextCursor::EndOfWord))
-        return;
-    const int wordEndPos = curs.position();
-
-    const QTextLine otherLine = currentTextLine(curs);
-    if (otherLine.textStart() != line.textStart()
-        || wordEndPos == wordStartPos)
-        return;
-
-    const qreal wordEndX = line.cursorToX(curs.position() - blockPos) + blockCoordinates.x();
-
-    if (!wordSelectionEnabled && (mouseXPosition < wordStartX || mouseXPosition > wordEndX))
-        return;
-
-    if (wordSelectionEnabled) {
-        if (suggestedNewPosition < selectedWordOnDoubleClick.position()) {
-            cursor.setPosition(selectedWordOnDoubleClick.selectionEnd());
-            setCursorPosition(wordStartPos, QTextCursor::KeepAnchor);
-        } else {
-            cursor.setPosition(selectedWordOnDoubleClick.selectionStart());
-            setCursorPosition(wordEndPos, QTextCursor::KeepAnchor);
-        }
-    } else {
-        // keep the already selected word even when moving to the left
-        // (#39164)
-        if (suggestedNewPosition < selectedWordOnDoubleClick.position())
-            cursor.setPosition(selectedWordOnDoubleClick.selectionEnd());
-        else
-            cursor.setPosition(selectedWordOnDoubleClick.selectionStart());
-
-        const qreal differenceToStart = mouseXPosition - wordStartX;
-        const qreal differenceToEnd = wordEndX - mouseXPosition;
-
-        if (differenceToStart < differenceToEnd)
-            setCursorPosition(wordStartPos, QTextCursor::KeepAnchor);
-        else
-            setCursorPosition(wordEndPos, QTextCursor::KeepAnchor);
-    }
-
-    if (interactionFlags & Qt::TextSelectableByMouse) {
-#ifndef QT_NO_CLIPBOARD
-        setClipboardSelection();
-#endif
-        selectionChanged(true);
-    }
-}
-
-void QTextControlPrivate::extendBlockwiseSelection(int suggestedNewPosition)
-{
-    Q_Q(QTextControl);
-
-    // if inside the initial selected line keep that
-    if (suggestedNewPosition >= selectedBlockOnTrippleClick.selectionStart()
-        && suggestedNewPosition <= selectedBlockOnTrippleClick.selectionEnd()) {
-        q->setTextCursor(selectedBlockOnTrippleClick);
-        return;
-    }
-
-    if (suggestedNewPosition < selectedBlockOnTrippleClick.position()) {
-        cursor.setPosition(selectedBlockOnTrippleClick.selectionEnd());
-        cursor.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::StartOfBlock, QTextCursor::KeepAnchor);
-    } else {
-        cursor.setPosition(selectedBlockOnTrippleClick.selectionStart());
-        cursor.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
-    }
-
-    if (interactionFlags & Qt::TextSelectableByMouse) {
-#ifndef QT_NO_CLIPBOARD
-        setClipboardSelection();
-#endif
-        selectionChanged(true);
-    }
-}
-
-void QTextControlPrivate::_q_deleteSelected()
-{
-    if (!(interactionFlags & Qt::TextEditable) || !cursor.hasSelection())
-        return;
-    cursor.removeSelectedText();
-}
-
-void QTextControl::undo()
-{
-    Q_D(QTextControl);
-    d->repaintSelection();
-    const int oldCursorPos = d->cursor.position();
-    d->doc->undo(&d->cursor);
-    if (d->cursor.position() != oldCursorPos)
-        emit cursorPositionChanged();
-    emit microFocusChanged();
-    ensureCursorVisible();
-}
-
-void QTextControl::redo()
-{
-    Q_D(QTextControl);
-    d->repaintSelection();
-    const int oldCursorPos = d->cursor.position();
-    d->doc->redo(&d->cursor);
-        if (d->cursor.position() != oldCursorPos)
-        emit cursorPositionChanged();
-    emit microFocusChanged();
-    ensureCursorVisible();
-}
-
-QTextControl::QTextControl(QObject *parent)
-    : QObject(*new QTextControlPrivate, parent)
-{
-    Q_D(QTextControl);
-    d->init();
-}
-
-QTextControl::QTextControl(const QString &text, QObject *parent)
-    : QObject(*new QTextControlPrivate, parent)
-{
-    Q_D(QTextControl);
-    d->init(Qt::RichText, text);
-}
-
-QTextControl::QTextControl(QTextDocument *doc, QObject *parent)
-    : QObject(*new QTextControlPrivate, parent)
-{
-    Q_D(QTextControl);
-    d->init(Qt::RichText, QString(), doc);
-}
-
-QTextControl::~QTextControl()
-{
-}
-
-void QTextControl::setView(QObject *view)
-{
-    Q_D(QTextControl);
-    d->contextObject = view;
-}
-
-QObject *QTextControl::view() const
-{
-    Q_D(const QTextControl);
-    return d->contextObject;
-}
-
-void QTextControl::setDocument(QTextDocument *document)
-{
-    Q_D(QTextControl);
-    if (d->doc == document)
-        return;
-
-    d->doc->disconnect(this);
-    d->doc->documentLayout()->disconnect(this);
-    d->doc->documentLayout()->setPaintDevice(0);
-
-    if (d->doc->parent() == this)
-        delete d->doc;
-
-    d->doc = 0;
-    d->setContent(Qt::RichText, QString(), document);
-}
-
-QTextDocument *QTextControl::document() const
-{
-    Q_D(const QTextControl);
-    return d->doc;
-}
-
-void QTextControl::setTextCursor(const QTextCursor &cursor)
-{
-    Q_D(QTextControl);
-    d->cursorIsFocusIndicator = false;
-    const bool posChanged = cursor.position() != d->cursor.position();
-    const QTextCursor oldSelection = d->cursor;
-    d->cursor = cursor;
-    d->cursorOn = d->hasFocus && (d->interactionFlags & Qt::TextEditable);
-    d->_q_updateCurrentCharFormatAndSelection();
-    ensureCursorVisible();
-    d->repaintOldAndNewSelection(oldSelection);
-    if (posChanged)
-        emit cursorPositionChanged();
-}
-
-QTextCursor QTextControl::textCursor() const
-{
-    Q_D(const QTextControl);
-    return d->cursor;
-}
-
-#ifndef QT_NO_CLIPBOARD
-
-void QTextControl::cut()
-{
-    Q_D(QTextControl);
-    if (!(d->interactionFlags & Qt::TextEditable) || !d->cursor.hasSelection())
-        return;
-    copy();
-    d->cursor.removeSelectedText();
-}
-
-void QTextControl::copy()
-{
-    Q_D(QTextControl);
-    if (!d->cursor.hasSelection())
-        return;
-    QMimeData *data = createMimeDataFromSelection();
-    QGuiApplication::clipboard()->setMimeData(data);
-}
-
-void QTextControl::paste(QClipboard::Mode mode)
-{
-    const QMimeData *md = QGuiApplication::clipboard()->mimeData(mode);
-    if (md)
-        insertFromMimeData(md);
-}
-#endif
-
-void QTextControl::clear()
-{
-    Q_D(QTextControl);
-    // clears and sets empty content
-    d->extraSelections.clear();
-    d->setContent();
-}
-
-
-void QTextControl::selectAll()
-{
-    Q_D(QTextControl);
-    const int selectionLength = qAbs(d->cursor.position() - d->cursor.anchor());
-    d->cursor.select(QTextCursor::Document);
-    d->selectionChanged(selectionLength != qAbs(d->cursor.position() - d->cursor.anchor()));
-    d->cursorIsFocusIndicator = false;
-    emit updateRequest();
-}
-
-void QTextControl::processEvent(QEvent *e, const QPointF &coordinateOffset)
-{
-    QMatrix m;
-    m.translate(coordinateOffset.x(), coordinateOffset.y());
-    processEvent(e, m);
-}
-
-void QTextControl::processEvent(QEvent *e, const QMatrix &matrix)
-{
-    Q_D(QTextControl);
-    if (d->interactionFlags == Qt::NoTextInteraction) {
-        e->ignore();
-        return;
-    }
-
-    switch (e->type()) {
-        case QEvent::KeyPress:
-            d->keyPressEvent(static_cast<QKeyEvent *>(e));
-            break;
-        case QEvent::MouseButtonPress: {
-            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
-            d->mousePressEvent(ev, ev->button(), matrix.map(ev->pos()), ev->modifiers(),
-                               ev->buttons(), ev->globalPos());
-            break; }
-        case QEvent::MouseMove: {
-            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
-            d->mouseMoveEvent(ev, ev->button(), matrix.map(ev->pos()), ev->modifiers(),
-                              ev->buttons(), ev->globalPos());
-            break; }
-        case QEvent::MouseButtonRelease: {
-            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
-            d->mouseReleaseEvent(ev, ev->button(), matrix.map(ev->pos()), ev->modifiers(),
-                                 ev->buttons(), ev->globalPos());
-            break; }
-        case QEvent::MouseButtonDblClick: {
-            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
-            d->mouseDoubleClickEvent(ev, ev->button(), matrix.map(ev->pos()), ev->modifiers(),
-                                     ev->buttons(), ev->globalPos());
-            break; }
-        case QEvent::InputMethod:
-            d->inputMethodEvent(static_cast<QInputMethodEvent *>(e));
-            break;
-        case QEvent::FocusIn:
-        case QEvent::FocusOut:
-            d->focusEvent(static_cast<QFocusEvent *>(e));
-            break;
-
-        case QEvent::EnabledChange:
-            d->isEnabled = e->isAccepted();
-            break;
-
-#ifndef QT_NO_DRAGANDDROP
-        case QEvent::DragEnter: {
-            QDragEnterEvent *ev = static_cast<QDragEnterEvent *>(e);
-            if (d->dragEnterEvent(e, ev->mimeData()))
-                ev->acceptProposedAction();
-            break;
-        }
-        case QEvent::DragLeave:
-            d->dragLeaveEvent();
-            break;
-        case QEvent::DragMove: {
-            QDragMoveEvent *ev = static_cast<QDragMoveEvent *>(e);
-            if (d->dragMoveEvent(e, ev->mimeData(), matrix.map(ev->pos())))
-                ev->acceptProposedAction();
-            break;
-        }
-        case QEvent::Drop: {
-            QDropEvent *ev = static_cast<QDropEvent *>(e);
-            if (d->dropEvent(ev->mimeData(), matrix.map(ev->pos()), ev->dropAction(), ev->source()))
-                ev->acceptProposedAction();
-            break;
-        }
-#endif
-
-#ifdef QT_KEYPAD_NAVIGATION
-        case QEvent::EnterEditFocus:
-        case QEvent::LeaveEditFocus:
-            if (QGuiApplication::keypadNavigationEnabled())
-                d->editFocusEvent(e);
-            break;
-#endif
-        case QEvent::ShortcutOverride:
-            if (d->interactionFlags & Qt::TextEditable) {
-                QKeyEvent* ke = static_cast<QKeyEvent *>(e);
-                if (ke->modifiers() == Qt::NoModifier
-                    || ke->modifiers() == Qt::ShiftModifier
-                    || ke->modifiers() == Qt::KeypadModifier) {
-                    if (ke->key() < Qt::Key_Escape) {
-                        ke->accept();
-                    } else {
-                        switch (ke->key()) {
-                            case Qt::Key_Return:
-                            case Qt::Key_Enter:
-                            case Qt::Key_Delete:
-                            case Qt::Key_Home:
-                            case Qt::Key_End:
-                            case Qt::Key_Backspace:
-                            case Qt::Key_Left:
-                            case Qt::Key_Right:
-                            case Qt::Key_Up:
-                            case Qt::Key_Down:
-                            case Qt::Key_Tab:
-                            ke->accept();
-                        default:
-                            break;
-                        }
-                    }
-#ifndef QT_NO_SHORTCUT
-                } else if (ke == QKeySequence::Copy
-                           || ke == QKeySequence::Paste
-                           || ke == QKeySequence::Cut
-                           || ke == QKeySequence::Redo
-                           || ke == QKeySequence::Undo
-                           || ke == QKeySequence::MoveToNextWord
-                           || ke == QKeySequence::MoveToPreviousWord
-                           || ke == QKeySequence::MoveToStartOfDocument
-                           || ke == QKeySequence::MoveToEndOfDocument
-                           || ke == QKeySequence::SelectNextWord
-                           || ke == QKeySequence::SelectPreviousWord
-                           || ke == QKeySequence::SelectStartOfLine
-                           || ke == QKeySequence::SelectEndOfLine
-                           || ke == QKeySequence::SelectStartOfBlock
-                           || ke == QKeySequence::SelectEndOfBlock
-                           || ke == QKeySequence::SelectStartOfDocument
-                           || ke == QKeySequence::SelectEndOfDocument
-                           || ke == QKeySequence::SelectAll
-                          ) {
-                    ke->accept();
-#endif
-                }
-            }
-            break;
-        default:
-            break;
-    }
-}
-
-bool QTextControl::event(QEvent *e)
-{
-    return QObject::event(e);
-}
-
-void QTextControl::timerEvent(QTimerEvent *e)
-{
-    Q_D(QTextControl);
-    if (e->timerId() == d->cursorBlinkTimer.timerId()) {
-        d->cursorOn = !d->cursorOn;
-
-        // ###
-//        if (d->cursor.hasSelection())
-//            d->cursorOn &= (QGuiApplication::style()->styleHint(QStyle::SH_BlinkCursorWhenTextSelected)
-//                            != 0);
-
-        d->repaintCursor();
-    } else if (e->timerId() == d->trippleClickTimer.timerId()) {
-        d->trippleClickTimer.stop();
-    }
-}
-
-void QTextControl::setPlainText(const QString &text)
-{
-    Q_D(QTextControl);
-    d->setContent(Qt::PlainText, text);
-}
-
-void QTextControl::setHtml(const QString &text)
-{
-    Q_D(QTextControl);
-    d->setContent(Qt::RichText, text);
-}
-
-void QTextControlPrivate::keyPressEvent(QKeyEvent *e)
-{
-    Q_Q(QTextControl);
-#ifndef QT_NO_SHORTCUT
-    if (e == QKeySequence::SelectAll) {
-            e->accept();
-            q->selectAll();
-            return;
-    }
-#ifndef QT_NO_CLIPBOARD
-    else if (e == QKeySequence::Copy) {
-            e->accept();
-            q->copy();
-            return;
-    }
-#endif
-#endif // QT_NO_SHORTCUT
-
-    if (interactionFlags & Qt::TextSelectableByKeyboard
-        && cursorMoveKeyEvent(e))
-        goto accept;
-
-    if (interactionFlags & Qt::LinksAccessibleByKeyboard) {
-        if ((e->key() == Qt::Key_Return
-             || e->key() == Qt::Key_Enter
-#ifdef QT_KEYPAD_NAVIGATION
-             || e->key() == Qt::Key_Select
-#endif
-             )
-            && cursor.hasSelection()) {
-
-            e->accept();
-            activateLinkUnderCursor();
-            return;
-        }
-    }
-
-    if (!(interactionFlags & Qt::TextEditable)) {
-        e->ignore();
-        return;
-    }
-
-    if (e->key() == Qt::Key_Direction_L || e->key() == Qt::Key_Direction_R) {
-        QTextBlockFormat fmt;
-        fmt.setLayoutDirection((e->key() == Qt::Key_Direction_L) ? Qt::LeftToRight : Qt::RightToLeft);
-        cursor.mergeBlockFormat(fmt);
-        goto accept;
-    }
-
-    // schedule a repaint of the region of the cursor, as when we move it we
-    // want to make sure the old cursor disappears (not noticeable when moving
-    // only a few pixels but noticeable when jumping between cells in tables for
-    // example)
-    repaintSelection();
-
-    if (e->key() == Qt::Key_Backspace && !(e->modifiers() & ~Qt::ShiftModifier)) {
-        QTextBlockFormat blockFmt = cursor.blockFormat();
-        QTextList *list = cursor.currentList();
-        if (list && cursor.atBlockStart() && !cursor.hasSelection()) {
-            list->remove(cursor.block());
-        } else if (cursor.atBlockStart() && blockFmt.indent() > 0) {
-            blockFmt.setIndent(blockFmt.indent() - 1);
-            cursor.setBlockFormat(blockFmt);
-        } else {
-            QTextCursor localCursor = cursor;
-            localCursor.deletePreviousChar();
-        }
-        goto accept;
-    }
-#ifndef QT_NO_SHORTCUT
-      else if (e == QKeySequence::InsertParagraphSeparator) {
-        cursor.insertBlock();
-        e->accept();
-        goto accept;
-    } else if (e == QKeySequence::InsertLineSeparator) {
-        cursor.insertText(QString(QChar::LineSeparator));
-        e->accept();
-        goto accept;
-    }
-#endif
-    if (false) {
-    }
-#ifndef QT_NO_SHORTCUT
-    else if (e == QKeySequence::Undo) {
-            q->undo();
-    }
-    else if (e == QKeySequence::Redo) {
-           q->redo();
-    }
-#ifndef QT_NO_CLIPBOARD
-    else if (e == QKeySequence::Cut) {
-           q->cut();
-    }
-    else if (e == QKeySequence::Paste) {
-        QClipboard::Mode mode = QClipboard::Clipboard;
-        q->paste(mode);
-    }
-#endif
-    else if (e == QKeySequence::Delete) {
-        QTextCursor localCursor = cursor;
-        localCursor.deleteChar();
-    }
-    else if (e == QKeySequence::DeleteEndOfWord) {
-        if (!cursor.hasSelection())
-            cursor.movePosition(QTextCursor::NextWord, QTextCursor::KeepAnchor);
-        cursor.removeSelectedText();
-    }
-    else if (e == QKeySequence::DeleteStartOfWord) {
-        if (!cursor.hasSelection())
-            cursor.movePosition(QTextCursor::PreviousWord, QTextCursor::KeepAnchor);
-        cursor.removeSelectedText();
-    }
-    else if (e == QKeySequence::DeleteEndOfLine) {
-        QTextBlock block = cursor.block();
-        if (cursor.position() == block.position() + block.length() - 2)
-            cursor.movePosition(QTextCursor::Right, QTextCursor::KeepAnchor);
-        else
-            cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
-        cursor.removeSelectedText();
-    }
-#endif // QT_NO_SHORTCUT
-    else {
-        goto process;
-    }
-    goto accept;
-
-process:
-    {
-        QString text = e->text();
-        if (!text.isEmpty() && (text.at(0).isPrint() || text.at(0) == QLatin1Char('\t'))) {
-            if (overwriteMode
-                // no need to call deleteChar() if we have a selection, insertText
-                // does it already
-                && !cursor.hasSelection()
-                && !cursor.atBlockEnd())
-                cursor.deleteChar();
-
-            cursor.insertText(text);
-            selectionChanged();
-        } else {
-            e->ignore();
-            return;
-        }
-    }
-
- accept:
-
-    e->accept();
-    cursorOn = true;
-
-    q->ensureCursorVisible();
-
-    updateCurrentCharFormat();
-}
-
-QVariant QTextControl::loadResource(int type, const QUrl &name)
-{
-#if 1
-    Q_UNUSED(type);
-    Q_UNUSED(name);
-#else
-    if (QTextEdit *textEdit = qobject_cast<QTextEdit *>(parent())) {
-        QUrl resolvedName = textEdit->d_func()->resolveUrl(name);
-        return textEdit->loadResource(type, resolvedName);
-    }
-#endif
-    return QVariant();
-}
-
-void QTextControlPrivate::_q_updateBlock(const QTextBlock &block)
-{
-    Q_Q(QTextControl);
-    QRectF br = q->blockBoundingRect(block);
-    br.setRight(qreal(INT_MAX)); // the block might have shrunk
-    emit q->updateRequest(br);
-}
-
-QRectF QTextControlPrivate::rectForPosition(int position) const
-{
-    Q_Q(const QTextControl);
-    const QTextBlock block = doc->findBlock(position);
-    if (!block.isValid())
-        return QRectF();
-    const QAbstractTextDocumentLayout *docLayout = doc->documentLayout();
-    const QTextLayout *layout = block.layout();
-    const QPointF layoutPos = q->blockBoundingRect(block).topLeft();
-    int relativePos = position - block.position();
-    if (preeditCursor != 0) {
-        int preeditPos = layout->preeditAreaPosition();
-        if (relativePos == preeditPos)
-            relativePos += preeditCursor;
-        else if (relativePos > preeditPos)
-            relativePos += layout->preeditAreaText().length();
-    }
-    QTextLine line = layout->lineForTextPosition(relativePos);
-
-    int cursorWidth;
-    {
-        bool ok = false;
-#ifndef QT_NO_PROPERTIES
-        cursorWidth = docLayout->property("cursorWidth").toInt(&ok);
-#endif
-        if (!ok)
-            cursorWidth = 1;
-    }
-
-    QRectF r;
-
-    if (line.isValid()) {
-        qreal x = line.cursorToX(relativePos);
-        qreal w = 0;
-        if (overwriteMode) {
-            if (relativePos < line.textLength() - line.textStart())
-                w = line.cursorToX(relativePos + 1) - x;
-            else
-                w = QFontMetrics(block.layout()->font()).width(QLatin1Char(' ')); // in sync with QTextLine::draw()
-        }
-        r = QRectF(layoutPos.x() + x, layoutPos.y() + line.y(),
-                   cursorWidth + w, line.height());
-    } else {
-        r = QRectF(layoutPos.x(), layoutPos.y(), cursorWidth, 10); // #### correct height
-    }
-
-    return r;
-}
-
-static inline bool firstFramePosLessThanCursorPos(QTextFrame *frame, int position)
-{
-    return frame->firstPosition() < position;
-}
-
-static inline bool cursorPosLessThanLastFramePos(int position, QTextFrame *frame)
-{
-    return position < frame->lastPosition();
-}
-
-static QRectF boundingRectOfFloatsInSelection(const QTextCursor &cursor)
-{
-    QRectF r;
-    QTextFrame *frame = cursor.currentFrame();
-    const QList<QTextFrame *> children = frame->childFrames();
-
-    const QList<QTextFrame *>::ConstIterator firstFrame = qLowerBound(children.constBegin(), children.constEnd(),
-                                                                      cursor.selectionStart(), firstFramePosLessThanCursorPos);
-    const QList<QTextFrame *>::ConstIterator lastFrame = qUpperBound(children.constBegin(), children.constEnd(),
-                                                                     cursor.selectionEnd(), cursorPosLessThanLastFramePos);
-    for (QList<QTextFrame *>::ConstIterator it = firstFrame; it != lastFrame; ++it) {
-        if ((*it)->frameFormat().position() != QTextFrameFormat::InFlow)
-            r |= frame->document()->documentLayout()->frameBoundingRect(*it);
-    }
-    return r;
-}
-
-QRectF QTextControl::selectionRect(const QTextCursor &cursor) const
-{
-    Q_D(const QTextControl);
-
-    QRectF r = d->rectForPosition(cursor.selectionStart());
-
-    if (cursor.hasComplexSelection() && cursor.currentTable()) {
-        QTextTable *table = cursor.currentTable();
-
-        r = d->doc->documentLayout()->frameBoundingRect(table);
-        /*
-        int firstRow, numRows, firstColumn, numColumns;
-        cursor.selectedTableCells(&firstRow, &numRows, &firstColumn, &numColumns);
-
-        const QTextTableCell firstCell = table->cellAt(firstRow, firstColumn);
-        const QTextTableCell lastCell = table->cellAt(firstRow + numRows - 1, firstColumn + numColumns - 1);
-
-        const QAbstractTextDocumentLayout * const layout = doc->documentLayout();
-
-        QRectF tableSelRect = layout->blockBoundingRect(firstCell.firstCursorPosition().block());
-
-        for (int col = firstColumn; col < firstColumn + numColumns; ++col) {
-            const QTextTableCell cell = table->cellAt(firstRow, col);
-            const qreal y = layout->blockBoundingRect(cell.firstCursorPosition().block()).top();
-
-            tableSelRect.setTop(qMin(tableSelRect.top(), y));
-        }
-
-        for (int row = firstRow; row < firstRow + numRows; ++row) {
-            const QTextTableCell cell = table->cellAt(row, firstColumn);
-            const qreal x = layout->blockBoundingRect(cell.firstCursorPosition().block()).left();
-
-            tableSelRect.setLeft(qMin(tableSelRect.left(), x));
-        }
-
-        for (int col = firstColumn; col < firstColumn + numColumns; ++col) {
-            const QTextTableCell cell = table->cellAt(firstRow + numRows - 1, col);
-            const qreal y = layout->blockBoundingRect(cell.lastCursorPosition().block()).bottom();
-
-            tableSelRect.setBottom(qMax(tableSelRect.bottom(), y));
-        }
-
-        for (int row = firstRow; row < firstRow + numRows; ++row) {
-            const QTextTableCell cell = table->cellAt(row, firstColumn + numColumns - 1);
-            const qreal x = layout->blockBoundingRect(cell.lastCursorPosition().block()).right();
-
-            tableSelRect.setRight(qMax(tableSelRect.right(), x));
-        }
-
-        r = tableSelRect.toRect();
-        */
-    } else if (cursor.hasSelection()) {
-        const int position = cursor.selectionStart();
-        const int anchor = cursor.selectionEnd();
-        const QTextBlock posBlock = d->doc->findBlock(position);
-        const QTextBlock anchorBlock = d->doc->findBlock(anchor);
-        if (posBlock == anchorBlock && posBlock.isValid() && posBlock.layout()->lineCount()) {
-            const QTextLine posLine = posBlock.layout()->lineForTextPosition(position - posBlock.position());
-            const QTextLine anchorLine = anchorBlock.layout()->lineForTextPosition(anchor - anchorBlock.position());
-
-            const int firstLine = qMin(posLine.lineNumber(), anchorLine.lineNumber());
-            const int lastLine = qMax(posLine.lineNumber(), anchorLine.lineNumber());
-            const QTextLayout *layout = posBlock.layout();
-            r = QRectF();
-            for (int i = firstLine; i <= lastLine; ++i) {
-                r |= layout->lineAt(i).rect();
-                r |= layout->lineAt(i).naturalTextRect(); // might be bigger in the case of wrap not enabled
-            }
-            r.translate(blockBoundingRect(posBlock).topLeft());
-        } else {
-            QRectF anchorRect = d->rectForPosition(cursor.selectionEnd());
-            r |= anchorRect;
-            r |= boundingRectOfFloatsInSelection(cursor);
-            QRectF frameRect(d->doc->documentLayout()->frameBoundingRect(cursor.currentFrame()));
-            r.setLeft(frameRect.left());
-            r.setRight(frameRect.right());
-        }
-        if (r.isValid())
-            r.adjust(-1, -1, 1, 1);
-    }
-
-    return r;
-}
-
-QRectF QTextControl::selectionRect() const
-{
-    Q_D(const QTextControl);
-    return selectionRect(d->cursor);
-}
-
-void QTextControlPrivate::mousePressEvent(QEvent *e, Qt::MouseButton button, const QPointF &pos, Qt::KeyboardModifiers modifiers,
-                                          Qt::MouseButtons buttons, const QPoint &globalPos)
-{
-    Q_Q(QTextControl);
-
-    if (sendMouseEventToInputContext(
-            e, QEvent::MouseButtonPress, button, pos, modifiers, buttons, globalPos)) {
-        return;
-    }
-
-    if (interactionFlags & Qt::LinksAccessibleByMouse) {
-        anchorOnMousePress = q->anchorAt(pos);
-
-        if (cursorIsFocusIndicator) {
-            cursorIsFocusIndicator = false;
-            repaintSelection();
-            cursor.clearSelection();
-        }
-    }
-    if (!(button & Qt::LeftButton) ||
-        !((interactionFlags & Qt::TextSelectableByMouse) || (interactionFlags & Qt::TextEditable))) {
-            e->ignore();
-            return;
-    }
-
-    cursorIsFocusIndicator = false;
-    const QTextCursor oldSelection = cursor;
-    const int oldCursorPos = cursor.position();
-
-    mousePressed = (interactionFlags & Qt::TextSelectableByMouse);
-#ifndef QT_NO_DRAGANDDROP
-    mightStartDrag = false;
-#endif
-
-    if (trippleClickTimer.isActive()
-        && ((pos - trippleClickPoint).toPoint().manhattanLength() < qApp->styleHints()->startDragDistance())) {
-
-        cursor.movePosition(QTextCursor::StartOfBlock);
-        cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
-        selectedBlockOnTrippleClick = cursor;
-
-        anchorOnMousePress = QString();
-
-        trippleClickTimer.stop();
-    } else {
-        int cursorPos = q->hitTest(pos, Qt::FuzzyHit);
-        if (cursorPos == -1) {
-            e->ignore();
-            return;
-        }
-
-        if (modifiers == Qt::ShiftModifier && (interactionFlags & Qt::TextSelectableByMouse)) {
-            if (wordSelectionEnabled && !selectedWordOnDoubleClick.hasSelection()) {
-                selectedWordOnDoubleClick = cursor;
-                selectedWordOnDoubleClick.select(QTextCursor::WordUnderCursor);
-            }
-
-            if (selectedBlockOnTrippleClick.hasSelection())
-                extendBlockwiseSelection(cursorPos);
-            else if (selectedWordOnDoubleClick.hasSelection())
-                extendWordwiseSelection(cursorPos, pos.x());
-            else if (!wordSelectionEnabled)
-                setCursorPosition(cursorPos, QTextCursor::KeepAnchor);
-        } else {
-
-            if (dragEnabled
-                && cursor.hasSelection()
-                && !cursorIsFocusIndicator
-                && cursorPos >= cursor.selectionStart()
-                && cursorPos <= cursor.selectionEnd()
-                && q->hitTest(pos, Qt::ExactHit) != -1) {
-#ifndef QT_NO_DRAGANDDROP
-                mightStartDrag = true;
-                dragStartPos = pos.toPoint();
-#endif
-                return;
-            }
-
-            setCursorPosition(cursorPos);
-        }
-    }
-
-    if (interactionFlags & Qt::TextEditable) {
-        q->ensureCursorVisible();
-        if (cursor.position() != oldCursorPos)
-            emit q->cursorPositionChanged();
-        _q_updateCurrentCharFormatAndSelection();
-    } else {
-        if (cursor.position() != oldCursorPos) {
-            emit q->cursorPositionChanged();
-            emit q->microFocusChanged();
-        }
-        selectionChanged();
-    }
-    repaintOldAndNewSelection(oldSelection);
-    hadSelectionOnMousePress = cursor.hasSelection();
-}
-
-void QTextControlPrivate::mouseMoveEvent(QEvent *e, Qt::MouseButton button, const QPointF &mousePos, Qt::KeyboardModifiers modifiers,
-                                         Qt::MouseButtons buttons, const QPoint &globalPos)
-{
-    Q_Q(QTextControl);
-
-    if (sendMouseEventToInputContext(
-            e, QEvent::MouseMove, button, mousePos, modifiers, buttons, globalPos)) {
-        return;
-    }
-
-    if (interactionFlags & Qt::LinksAccessibleByMouse) {
-        QString anchor = q->anchorAt(mousePos);
-        if (anchor != highlightedAnchor) {
-            highlightedAnchor = anchor;
-            emit q->linkHovered(anchor);
-        }
-    }
-
-    if (!(buttons & Qt::LeftButton))
-        return;
-
-    const bool editable = interactionFlags & Qt::TextEditable;
-
-    if (!(mousePressed
-          || editable
-          || mightStartDrag
-          || selectedWordOnDoubleClick.hasSelection()
-          || selectedBlockOnTrippleClick.hasSelection()))
-        return;
-
-    const QTextCursor oldSelection = cursor;
-    const int oldCursorPos = cursor.position();
-
-    if (mightStartDrag) {
-        if ((mousePos.toPoint() - dragStartPos).manhattanLength() > qApp->styleHints()->startDragDistance())
-            startDrag();
-        return;
-    }
-
-    if (!mousePressed)
-        return;
-
-    const qreal mouseX = qreal(mousePos.x());
-
-    int newCursorPos = q->hitTest(mousePos, Qt::FuzzyHit);
-    if (newCursorPos == -1)
-        return;
-
-    if (wordSelectionEnabled && !selectedWordOnDoubleClick.hasSelection()) {
-        selectedWordOnDoubleClick = cursor;
-        selectedWordOnDoubleClick.select(QTextCursor::WordUnderCursor);
-    }
-
-    if (selectedBlockOnTrippleClick.hasSelection())
-        extendBlockwiseSelection(newCursorPos);
-    else if (selectedWordOnDoubleClick.hasSelection())
-        extendWordwiseSelection(newCursorPos, mouseX);
-    else
-        setCursorPosition(newCursorPos, QTextCursor::KeepAnchor);
-
-    if (interactionFlags & Qt::TextEditable) {
-        // don't call ensureVisible for the visible cursor to avoid jumping
-        // scrollbars. the autoscrolling ensures smooth scrolling if necessary.
-        //q->ensureCursorVisible();
-        if (cursor.position() != oldCursorPos)
-            emit q->cursorPositionChanged();
-        _q_updateCurrentCharFormatAndSelection();
-        if (qGuiApp)
-            qGuiApp->inputPanel()->update(Qt::ImQueryInput);
-    } else {
-        //emit q->visibilityRequest(QRectF(mousePos, QSizeF(1, 1)));
-        if (cursor.position() != oldCursorPos) {
-            emit q->cursorPositionChanged();
-            emit q->microFocusChanged();
-        }
-    }
-    selectionChanged(true);
-    repaintOldAndNewSelection(oldSelection);
-}
-
-void QTextControlPrivate::mouseReleaseEvent(QEvent *e, Qt::MouseButton button, const QPointF &pos, Qt::KeyboardModifiers modifiers,
-                                            Qt::MouseButtons buttons, const QPoint &globalPos)
-{
-    Q_Q(QTextControl);
-
-    if (sendMouseEventToInputContext(
-            e, QEvent::MouseButtonRelease, button, pos, modifiers, buttons, globalPos)) {
-        return;
-    }
-
-    const QTextCursor oldSelection = cursor;
-    const int oldCursorPos = cursor.position();
-
-#ifndef QT_NO_DRAGANDDROP
-    if (mightStartDrag && (button & Qt::LeftButton)) {
-        mousePressed = false;
-        setCursorPosition(pos);
-        cursor.clearSelection();
-        selectionChanged();
-    }
-#endif
-    if (mousePressed) {
-        mousePressed = false;
-#ifndef QT_NO_CLIPBOARD
-        setClipboardSelection();
-        selectionChanged(true);
-    } else if (button == Qt::MidButton
-               && (interactionFlags & Qt::TextEditable)
-               && QGuiApplication::clipboard()->supportsSelection()) {
-        setCursorPosition(pos);
-        const QMimeData *md = QGuiApplication::clipboard()->mimeData(QClipboard::Selection);
-        if (md)
-            q->insertFromMimeData(md);
-#endif
-    }
-
-    repaintOldAndNewSelection(oldSelection);
-
-    if (cursor.position() != oldCursorPos) {
-        emit q->cursorPositionChanged();
-        emit q->microFocusChanged();
-    }
-
-    if (interactionFlags & Qt::LinksAccessibleByMouse) {
-        if (!(button & Qt::LeftButton))
-            return;
-
-        const QString anchor = q->anchorAt(pos);
-
-        if (anchor.isEmpty())
-            return;
-
-        if (!cursor.hasSelection()
-            || (anchor == anchorOnMousePress && hadSelectionOnMousePress)) {
-
-            const int anchorPos = q->hitTest(pos, Qt::ExactHit);
-            if (anchorPos != -1) {
-                cursor.setPosition(anchorPos);
-
-                QString anchor = anchorOnMousePress;
-                anchorOnMousePress = QString();
-                activateLinkUnderCursor(anchor);
-            }
-        }
-    }
-}
-
-void QTextControlPrivate::mouseDoubleClickEvent(QEvent *e, Qt::MouseButton button, const QPointF &pos, Qt::KeyboardModifiers modifiers,
-                                                Qt::MouseButtons buttons, const QPoint &globalPos)
-{
-    Q_Q(QTextControl);
-
-    if (sendMouseEventToInputContext(
-            e, QEvent::MouseButtonDblClick, button, pos, modifiers, buttons, globalPos)) {
-        return;
-    }
-
-    if (button != Qt::LeftButton
-        || !(interactionFlags & Qt::TextSelectableByMouse)) {
-        e->ignore();
-        return;
-    }
-
-#ifndef QT_NO_DRAGANDDROP
-    mightStartDrag = false;
-#endif
-    const QTextCursor oldSelection = cursor;
-    setCursorPosition(pos);
-    QTextLine line = currentTextLine(cursor);
-    bool doEmit = false;
-    if (line.isValid() && line.textLength()) {
-        cursor.select(QTextCursor::WordUnderCursor);
-        doEmit = true;
-    }
-    repaintOldAndNewSelection(oldSelection);
-
-    cursorIsFocusIndicator = false;
-    selectedWordOnDoubleClick = cursor;
-
-    trippleClickPoint = pos;
-    trippleClickTimer.start(qApp->styleHints()->mouseDoubleClickInterval(), q);
-    if (doEmit) {
-        selectionChanged();
-#ifndef QT_NO_CLIPBOARD
-        setClipboardSelection();
-#endif
-        emit q->cursorPositionChanged();
-    }
-}
-
-bool QTextControlPrivate::sendMouseEventToInputContext(
-        QEvent *e, QEvent::Type eventType, Qt::MouseButton button, const QPointF &pos,
-        Qt::KeyboardModifiers modifiers, Qt::MouseButtons buttons, const QPoint &globalPos)
-{
-#if 0 // ### !defined(QT_NO_IM)
-    Q_Q(QTextControl);
-
-    QTextLayout *layout = cursor.block().layout();
-    if (contextObject && layout && !layout->preeditAreaText().isEmpty()) {
-        QInputContext *ctx = inputContext();
-        int cursorPos = q->hitTest(pos, Qt::FuzzyHit) - cursor.position();
-
-        if (cursorPos < 0 || cursorPos > layout->preeditAreaText().length()) {
-            cursorPos = -1;
-            // don't send move events outside the preedit area
-            if (eventType == QEvent::MouseMove)
-                return true;
-        }
-        if (ctx) {
-            QMouseEvent ev(eventType, contextObject->mapFromGlobal(globalPos), globalPos,
-                           button, buttons, modifiers);
-            ctx->mouseHandler(cursorPos, &ev);
-            e->setAccepted(ev.isAccepted());
-        }
-        if (!layout->preeditAreaText().isEmpty())
-            return true;
-    }
-#else
-    Q_UNUSED(e);
-    Q_UNUSED(eventType);
-    Q_UNUSED(button);
-    Q_UNUSED(pos);
-    Q_UNUSED(modifiers);
-    Q_UNUSED(buttons);
-    Q_UNUSED(globalPos);
-#endif
-    return false;
-}
-
-bool QTextControlPrivate::dragEnterEvent(QEvent *e, const QMimeData *mimeData)
-{
-    Q_Q(QTextControl);
-    if (!(interactionFlags & Qt::TextEditable) || !q->canInsertFromMimeData(mimeData)) {
-        e->ignore();
-        return false;
-    }
-
-    dndFeedbackCursor = QTextCursor();
-
-    return true; // accept proposed action
-}
-
-void QTextControlPrivate::dragLeaveEvent()
-{
-    Q_Q(QTextControl);
-
-    const QRectF crect = q->cursorRect(dndFeedbackCursor);
-    dndFeedbackCursor = QTextCursor();
-
-    if (crect.isValid())
-        emit q->updateRequest(crect);
-}
-
-bool QTextControlPrivate::dragMoveEvent(QEvent *e, const QMimeData *mimeData, const QPointF &pos)
-{
-    Q_Q(QTextControl);
-    if (!(interactionFlags & Qt::TextEditable) || !q->canInsertFromMimeData(mimeData)) {
-        e->ignore();
-        return false;
-    }
-
-    const int cursorPos = q->hitTest(pos, Qt::FuzzyHit);
-    if (cursorPos != -1) {
-        QRectF crect = q->cursorRect(dndFeedbackCursor);
-        if (crect.isValid())
-            emit q->updateRequest(crect);
-
-        dndFeedbackCursor = cursor;
-        dndFeedbackCursor.setPosition(cursorPos);
-
-        crect = q->cursorRect(dndFeedbackCursor);
-        emit q->updateRequest(crect);
-    }
-
-    return true; // accept proposed action
-}
-
-bool QTextControlPrivate::dropEvent(const QMimeData *mimeData, const QPointF &pos, Qt::DropAction dropAction, QObject *source)
-{
-    Q_Q(QTextControl);
-    dndFeedbackCursor = QTextCursor();
-
-    if (!(interactionFlags & Qt::TextEditable) || !q->canInsertFromMimeData(mimeData))
-        return false;
-
-    repaintSelection();
-
-    QTextCursor insertionCursor = q->cursorForPosition(pos);
-    insertionCursor.beginEditBlock();
-
-    if (dropAction == Qt::MoveAction && source == contextObject)
-        cursor.removeSelectedText();
-
-    cursor = insertionCursor;
-    q->insertFromMimeData(mimeData);
-    insertionCursor.endEditBlock();
-    q->ensureCursorVisible();
-    return true; // accept proposed action
-}
-
-void QTextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
-{
-    Q_Q(QTextControl);
-    if (!(interactionFlags & Qt::TextEditable) || cursor.isNull()) {
-        e->ignore();
-        return;
-    }
-    bool isGettingInput = !e->commitString().isEmpty()
-            || e->preeditString() != cursor.block().layout()->preeditAreaText()
-            || e->replacementLength() > 0;
-    bool forceSelectionChanged = false;
-
-    cursor.beginEditBlock();
-    if (isGettingInput) {
-        cursor.removeSelectedText();
-    }
-
-    // insert commit string
-    if (!e->commitString().isEmpty() || e->replacementLength()) {
-        QTextCursor c = cursor;
-        c.setPosition(c.position() + e->replacementStart());
-        c.setPosition(c.position() + e->replacementLength(), QTextCursor::KeepAnchor);
-        c.insertText(e->commitString());
-    }
-
-    for (int i = 0; i < e->attributes().size(); ++i) {
-        const QInputMethodEvent::Attribute &a = e->attributes().at(i);
-        if (a.type == QInputMethodEvent::Selection) {
-            QTextCursor oldCursor = cursor;
-            int blockStart = a.start + cursor.block().position();
-            cursor.setPosition(blockStart, QTextCursor::MoveAnchor);
-            cursor.setPosition(blockStart + a.length, QTextCursor::KeepAnchor);
-            q->ensureCursorVisible();
-            repaintOldAndNewSelection(oldCursor);
-            forceSelectionChanged = true;
-        }
-    }
-
-    QTextBlock block = cursor.block();
-    QTextLayout *layout = block.layout();
-    if (isGettingInput)
-        layout->setPreeditArea(cursor.position() - block.position(), e->preeditString());
-    QList<QTextLayout::FormatRange> overrides;
-    const int oldPreeditCursor = preeditCursor;
-    preeditCursor = e->preeditString().length();
-    hideCursor = false;
-    for (int i = 0; i < e->attributes().size(); ++i) {
-        const QInputMethodEvent::Attribute &a = e->attributes().at(i);
-        if (a.type == QInputMethodEvent::Cursor) {
-            preeditCursor = a.start;
-            hideCursor = !a.length;
-        } else if (a.type == QInputMethodEvent::TextFormat) {
-            QTextCharFormat f = qvariant_cast<QTextFormat>(a.value).toCharFormat();
-            if (f.isValid()) {
-                QTextLayout::FormatRange o;
-                o.start = a.start + cursor.position() - block.position();
-                o.length = a.length;
-                o.format = f;
-                overrides.append(o);
-            }
-        }
-    }
-    layout->setAdditionalFormats(overrides);
-    cursor.endEditBlock();
-    QTextCursorPrivate *cursor_d = QTextCursorPrivate::getPrivate(&cursor);
-    if (cursor_d)
-        cursor_d->setX();
-    if (oldPreeditCursor != preeditCursor)
-        emit q->microFocusChanged();
-    selectionChanged(forceSelectionChanged);
-}
-
-QVariant QTextControl::inputMethodQuery(Qt::InputMethodQuery property) const
-{
-    Q_D(const QTextControl);
-    QTextBlock block = d->cursor.block();
-    switch(property) {
-    case Qt::ImCursorRectangle:
-        return cursorRect();
-    case Qt::ImFont:
-        return QVariant(d->cursor.charFormat().font());
-    case Qt::ImCursorPosition:
-        return QVariant(d->cursor.position() - block.position());
-    case Qt::ImSurroundingText:
-        return QVariant(block.text());
-    case Qt::ImCurrentSelection:
-        return QVariant(d->cursor.selectedText());
-    case Qt::ImMaximumTextLength:
-        return QVariant(); // No limit.
-    case Qt::ImAnchorPosition:
-        return QVariant(d->cursor.anchor() - block.position());
-    default:
-        return QVariant();
-    }
-}
-
-void QTextControl::setFocus(bool focus, Qt::FocusReason reason)
-{
-    QFocusEvent ev(focus ? QEvent::FocusIn : QEvent::FocusOut,
-                   reason);
-    processEvent(&ev);
-}
-
-void QTextControlPrivate::focusEvent(QFocusEvent *e)
-{
-    Q_Q(QTextControl);
-    emit q->updateRequest(q->selectionRect());
-    if (e->gotFocus()) {
-#ifdef QT_KEYPAD_NAVIGATION
-        if (!QGuiApplication::keypadNavigationEnabled() || (hasEditFocus && (e->reason() == Qt::PopupFocusReason
-            ))) {
-#endif
-            setBlinkingCursorEnabled(interactionFlags & (Qt::TextEditable | Qt::TextSelectableByKeyboard));
-#ifdef QT_KEYPAD_NAVIGATION
-        }
-#endif
-    } else {
-        setBlinkingCursorEnabled(false);
-
-        if (cursorIsFocusIndicator
-            && e->reason() != Qt::ActiveWindowFocusReason
-            && e->reason() != Qt::PopupFocusReason
-            && cursor.hasSelection()) {
-            cursor.clearSelection();
-        }
-    }
-    hasFocus = e->gotFocus();
-}
-
-QString QTextControlPrivate::anchorForCursor(const QTextCursor &anchorCursor) const
-{
-    if (anchorCursor.hasSelection()) {
-        QTextCursor cursor = anchorCursor;
-        if (cursor.selectionStart() != cursor.position())
-            cursor.setPosition(cursor.selectionStart());
-        cursor.movePosition(QTextCursor::NextCharacter);
-        QTextCharFormat fmt = cursor.charFormat();
-        if (fmt.isAnchor() && fmt.hasProperty(QTextFormat::AnchorHref))
-            return fmt.stringProperty(QTextFormat::AnchorHref);
-    }
-    return QString();
-}
-
-#ifdef QT_KEYPAD_NAVIGATION
-void QTextControlPrivate::editFocusEvent(QEvent *e)
-{
-    Q_Q(QTextControl);
-
-    if (QGuiApplication::keypadNavigationEnabled()) {
-        if (e->type() == QEvent::EnterEditFocus && interactionFlags & Qt::TextEditable) {
-            const QTextCursor oldSelection = cursor;
-            const int oldCursorPos = cursor.position();
-            const bool moved = cursor.movePosition(QTextCursor::End, QTextCursor::MoveAnchor);
-            q->ensureCursorVisible();
-            if (moved) {
-                if (cursor.position() != oldCursorPos)
-                    emit q->cursorPositionChanged();
-                emit q->microFocusChanged();
-            }
-            selectionChanged();
-            repaintOldAndNewSelection(oldSelection);
-
-            setBlinkingCursorEnabled(true);
-        } else
-            setBlinkingCursorEnabled(false);
-    }
-
-    hasEditFocus = e->type() == QEvent::EnterEditFocus ? true : false;
-}
-#endif
-
-QTextCursor QTextControl::cursorForPosition(const QPointF &pos) const
-{
-    Q_D(const QTextControl);
-    int cursorPos = hitTest(pos, Qt::FuzzyHit);
-    if (cursorPos == -1)
-        cursorPos = 0;
-    QTextCursor c(d->doc);
-    c.setPosition(cursorPos);
-    return c;
-}
-
-QRectF QTextControl::cursorRect(const QTextCursor &cursor) const
-{
-    Q_D(const QTextControl);
-    if (cursor.isNull())
-        return QRectF();
-
-    return d->rectForPosition(cursor.position());
-}
-
-QRectF QTextControl::cursorRect() const
-{
-    Q_D(const QTextControl);
-    return cursorRect(d->cursor);
-}
-
-QRectF QTextControlPrivate::cursorRectPlusUnicodeDirectionMarkers(const QTextCursor &cursor) const
-{
-    if (cursor.isNull())
-        return QRectF();
-
-    return rectForPosition(cursor.position()).adjusted(-4, 0, 4, 0);
-}
-
-QString QTextControl::anchorAt(const QPointF &pos) const
-{
-    Q_D(const QTextControl);
-    return d->doc->documentLayout()->anchorAt(pos);
-}
-
-QString QTextControl::anchorAtCursor() const
-{
-    Q_D(const QTextControl);
-
-    return d->anchorForCursor(d->cursor);
-}
-
-bool QTextControl::overwriteMode() const
-{
-    Q_D(const QTextControl);
-    return d->overwriteMode;
-}
-
-void QTextControl::setOverwriteMode(bool overwrite)
-{
-    Q_D(QTextControl);
-    d->overwriteMode = overwrite;
-}
-
-int QTextControl::cursorWidth() const
-{
-#ifndef QT_NO_PROPERTIES
-    Q_D(const QTextControl);
-    return d->doc->documentLayout()->property("cursorWidth").toInt();
-#else
-    return 1;
-#endif
-}
-
-void QTextControl::setCursorWidth(int width)
-{
-    Q_D(QTextControl);
-#ifdef QT_NO_PROPERTIES
-    Q_UNUSED(width);
-#else
-    if (width == -1)
-        width = textCursorWidth;
-    d->doc->documentLayout()->setProperty("cursorWidth", width);
-#endif
-    d->repaintCursor();
-}
-
-bool QTextControl::acceptRichText() const
-{
-    Q_D(const QTextControl);
-    return d->acceptRichText;
-}
-
-void QTextControl::setAcceptRichText(bool accept)
-{
-    Q_D(QTextControl);
-    d->acceptRichText = accept;
-}
-
-void QTextControl::setExtraSelections(const QVector<QAbstractTextDocumentLayout::Selection> &selections)
-{
-    Q_D(QTextControl);
-
-    QHash<int, int> hash;
-    for (int i = 0; i < d->extraSelections.count(); ++i) {
-        const QAbstractTextDocumentLayout::Selection &esel = d->extraSelections.at(i);
-        hash.insertMulti(esel.cursor.anchor(), i);
-    }
-
-    for (int i = 0; i < selections.count(); ++i) {
-        const QAbstractTextDocumentLayout::Selection &sel = selections.at(i);
-        QHash<int, int>::iterator it = hash.find(sel.cursor.anchor());
-        if (it != hash.end()) {
-            const QAbstractTextDocumentLayout::Selection &esel = d->extraSelections.at(it.value());
-            if (esel.cursor.position() == sel.cursor.position()
-                && esel.format == sel.format) {
-                hash.erase(it);
-                continue;
-            }
-        }
-        QRectF r = selectionRect(sel.cursor);
-        if (sel.format.boolProperty(QTextFormat::FullWidthSelection)) {
-            r.setLeft(0);
-            r.setWidth(qreal(INT_MAX));
-        }
-        emit updateRequest(r);
-    }
-
-    for (QHash<int, int>::iterator it = hash.begin(); it != hash.end(); ++it) {
-        const QAbstractTextDocumentLayout::Selection &esel = d->extraSelections.at(it.value());
-        QRectF r = selectionRect(esel.cursor);
-        if (esel.format.boolProperty(QTextFormat::FullWidthSelection)) {
-            r.setLeft(0);
-            r.setWidth(qreal(INT_MAX));
-        }
-        emit updateRequest(r);
-    }
-
-    d->extraSelections = selections;
-}
-
-QVector<QAbstractTextDocumentLayout::Selection> QTextControl::extraSelections() const
-{
-    Q_D(const QTextControl);
-    return d->extraSelections;
-}
-
-void QTextControl::setTextWidth(qreal width)
-{
-    Q_D(QTextControl);
-    d->doc->setTextWidth(width);
-}
-
-qreal QTextControl::textWidth() const
-{
-    Q_D(const QTextControl);
-    return d->doc->textWidth();
-}
-
-QSizeF QTextControl::size() const
-{
-    Q_D(const QTextControl);
-    return d->doc->size();
-}
-
-void QTextControl::setOpenExternalLinks(bool open)
-{
-    Q_D(QTextControl);
-    d->openExternalLinks = open;
-}
-
-bool QTextControl::openExternalLinks() const
-{
-    Q_D(const QTextControl);
-    return d->openExternalLinks;
-}
-
-bool QTextControl::ignoreUnusedNavigationEvents() const
-{
-    Q_D(const QTextControl);
-    return d->ignoreUnusedNavigationEvents;
-}
-
-void QTextControl::setIgnoreUnusedNavigationEvents(bool ignore)
-{
-    Q_D(QTextControl);
-    d->ignoreUnusedNavigationEvents = ignore;
-}
-
-void QTextControl::moveCursor(QTextCursor::MoveOperation op, QTextCursor::MoveMode mode)
-{
-    Q_D(QTextControl);
-    const QTextCursor oldSelection = d->cursor;
-    const bool moved = d->cursor.movePosition(op, mode);
-    d->_q_updateCurrentCharFormatAndSelection();
-    ensureCursorVisible();
-    d->repaintOldAndNewSelection(oldSelection);
-    if (moved)
-        emit cursorPositionChanged();
-}
-
-bool QTextControl::canPaste() const
-{
-#ifndef QT_NO_CLIPBOARD
-    Q_D(const QTextControl);
-    if (d->interactionFlags & Qt::TextEditable) {
-        const QMimeData *md = QGuiApplication::clipboard()->mimeData();
-        return md && canInsertFromMimeData(md);
-    }
-#endif
-    return false;
-}
-
-void QTextControl::setCursorIsFocusIndicator(bool b)
-{
-    Q_D(QTextControl);
-    d->cursorIsFocusIndicator = b;
-    d->repaintCursor();
-}
-
-bool QTextControl::cursorIsFocusIndicator() const
-{
-    Q_D(const QTextControl);
-    return d->cursorIsFocusIndicator;
-}
-
-
-void QTextControl::setDragEnabled(bool enabled)
-{
-    Q_D(QTextControl);
-    d->dragEnabled = enabled;
-}
-
-bool QTextControl::isDragEnabled() const
-{
-    Q_D(const QTextControl);
-    return d->dragEnabled;
-}
-
-void QTextControl::setWordSelectionEnabled(bool enabled)
-{
-    Q_D(QTextControl);
-    d->wordSelectionEnabled = enabled;
-}
-
-bool QTextControl::isWordSelectionEnabled() const
-{
-    Q_D(const QTextControl);
-    return d->wordSelectionEnabled;
-}
-
-void QTextControl::print(QPagedPaintDevice *printer) const
-{
-    Q_D(const QTextControl);
-    if (!printer)
-        return;
-    QTextDocument *tempDoc = 0;
-    const QTextDocument *doc = d->doc;
-    if (QPagedPaintDevicePrivate::get(printer)->printSelectionOnly) {
-        if (!d->cursor.hasSelection())
-            return;
-        tempDoc = new QTextDocument(const_cast<QTextDocument *>(doc));
-        tempDoc->setMetaInformation(QTextDocument::DocumentTitle, doc->metaInformation(QTextDocument::DocumentTitle));
-        tempDoc->setPageSize(doc->pageSize());
-        tempDoc->setDefaultFont(doc->defaultFont());
-        tempDoc->setUseDesignMetrics(doc->useDesignMetrics());
-        QTextCursor(tempDoc).insertFragment(d->cursor.selection());
-        doc = tempDoc;
-
-        // copy the custom object handlers
-        doc->documentLayout()->d_func()->handlers = d->doc->documentLayout()->d_func()->handlers;
-    }
-    doc->print(printer);
-    delete tempDoc;
-}
-
-QMimeData *QTextControl::createMimeDataFromSelection() const
-{
-    Q_D(const QTextControl);
-    const QTextDocumentFragment fragment(d->cursor);
-    return new QTextEditMimeData(fragment);
-}
-
-bool QTextControl::canInsertFromMimeData(const QMimeData *source) const
-{
-    Q_D(const QTextControl);
-    if (d->acceptRichText)
-        return (source->hasText() && !source->text().isEmpty())
-            || source->hasHtml()
-            || source->hasFormat(QLatin1String("application/x-qrichtext"))
-            || source->hasFormat(QLatin1String("application/x-qt-richtext"));
-    else
-        return source->hasText() && !source->text().isEmpty();
-}
-
-void QTextControl::insertFromMimeData(const QMimeData *source)
-{
-    Q_D(QTextControl);
-    if (!(d->interactionFlags & Qt::TextEditable) || !source)
-        return;
-
-    bool hasData = false;
-    QTextDocumentFragment fragment;
-#ifndef QT_NO_TEXTHTMLPARSER
-    if (source->hasFormat(QLatin1String("application/x-qrichtext")) && d->acceptRichText) {
-        // x-qrichtext is always UTF-8 (taken from Qt3 since we don't use it anymore).
-        QString richtext = QString::fromUtf8(source->data(QLatin1String("application/x-qrichtext")));
-        richtext.prepend(QLatin1String("<meta name=\"qrichtext\" content=\"1\" />"));
-        fragment = QTextDocumentFragment::fromHtml(richtext, d->doc);
-        hasData = true;
-    } else if (source->hasHtml() && d->acceptRichText) {
-        fragment = QTextDocumentFragment::fromHtml(source->html(), d->doc);
-        hasData = true;
-    } else {
-        QString text = source->text();
-        if (!text.isNull()) {
-            fragment = QTextDocumentFragment::fromPlainText(text);
-            hasData = true;
-        }
-    }
-#else
-    fragment = QTextDocumentFragment::fromPlainText(source->text());
-#endif // QT_NO_TEXTHTMLPARSER
-
-    if (hasData)
-        d->cursor.insertFragment(fragment);
-    ensureCursorVisible();
-}
-
-bool QTextControl::findNextPrevAnchor(const QTextCursor &startCursor, bool next, QTextCursor &newAnchor)
-{
-    Q_D(QTextControl);
-
-    int anchorStart = -1;
-    QString anchorHref;
-    int anchorEnd = -1;
-
-    if (next) {
-        const int startPos = startCursor.selectionEnd();
-
-        QTextBlock block = d->doc->findBlock(startPos);
-        QTextBlock::Iterator it = block.begin();
-
-        while (!it.atEnd() && it.fragment().position() < startPos)
-            ++it;
-
-        while (block.isValid()) {
-            anchorStart = -1;
-
-            // find next anchor
-            for (; !it.atEnd(); ++it) {
-                const QTextFragment fragment = it.fragment();
-                const QTextCharFormat fmt = fragment.charFormat();
-
-                if (fmt.isAnchor() && fmt.hasProperty(QTextFormat::AnchorHref)) {
-                    anchorStart = fragment.position();
-                    anchorHref = fmt.anchorHref();
-                    break;
-                }
-            }
-
-            if (anchorStart != -1) {
-                anchorEnd = -1;
-
-                // find next non-anchor fragment
-                for (; !it.atEnd(); ++it) {
-                    const QTextFragment fragment = it.fragment();
-                    const QTextCharFormat fmt = fragment.charFormat();
-
-                    if (!fmt.isAnchor() || fmt.anchorHref() != anchorHref) {
-                        anchorEnd = fragment.position();
-                        break;
-                    }
-                }
-
-                if (anchorEnd == -1)
-                    anchorEnd = block.position() + block.length() - 1;
-
-                // make found selection
-                break;
-            }
-
-            block = block.next();
-            it = block.begin();
-        }
-    } else {
-        int startPos = startCursor.selectionStart();
-        if (startPos > 0)
-            --startPos;
-
-        QTextBlock block = d->doc->findBlock(startPos);
-        QTextBlock::Iterator blockStart = block.begin();
-        QTextBlock::Iterator it = block.end();
-
-        if (startPos == block.position()) {
-            it = block.begin();
-        } else {
-            do {
-                if (it == blockStart) {
-                    it = QTextBlock::Iterator();
-                    block = QTextBlock();
-                } else {
-                    --it;
-                }
-            } while (!it.atEnd() && it.fragment().position() + it.fragment().length() - 1 > startPos);
-        }
-
-        while (block.isValid()) {
-            anchorStart = -1;
-
-            if (!it.atEnd()) {
-                do {
-                    const QTextFragment fragment = it.fragment();
-                    const QTextCharFormat fmt = fragment.charFormat();
-
-                    if (fmt.isAnchor() && fmt.hasProperty(QTextFormat::AnchorHref)) {
-                        anchorStart = fragment.position() + fragment.length();
-                        anchorHref = fmt.anchorHref();
-                        break;
-                    }
-
-                    if (it == blockStart)
-                        it = QTextBlock::Iterator();
-                    else
-                        --it;
-                } while (!it.atEnd());
-            }
-
-            if (anchorStart != -1 && !it.atEnd()) {
-                anchorEnd = -1;
-
-                do {
-                    const QTextFragment fragment = it.fragment();
-                    const QTextCharFormat fmt = fragment.charFormat();
-
-                    if (!fmt.isAnchor() || fmt.anchorHref() != anchorHref) {
-                        anchorEnd = fragment.position() + fragment.length();
-                        break;
-                    }
-
-                    if (it == blockStart)
-                        it = QTextBlock::Iterator();
-                    else
-                        --it;
-                } while (!it.atEnd());
-
-                if (anchorEnd == -1)
-                    anchorEnd = qMax(0, block.position());
-
-                break;
-            }
-
-            block = block.previous();
-            it = block.end();
-            if (it != block.begin())
-                --it;
-            blockStart = block.begin();
-        }
-
-    }
-
-    if (anchorStart != -1 && anchorEnd != -1) {
-        newAnchor = d->cursor;
-        newAnchor.setPosition(anchorStart);
-        newAnchor.setPosition(anchorEnd, QTextCursor::KeepAnchor);
-        return true;
-    }
-
-    return false;
-}
-
-void QTextControlPrivate::activateLinkUnderCursor(QString href)
-{
-    QTextCursor oldCursor = cursor;
-
-    if (href.isEmpty()) {
-        QTextCursor tmp = cursor;
-        if (tmp.selectionStart() != tmp.position())
-            tmp.setPosition(tmp.selectionStart());
-        tmp.movePosition(QTextCursor::NextCharacter);
-        href = tmp.charFormat().anchorHref();
-    }
-    if (href.isEmpty())
-        return;
-
-    if (!cursor.hasSelection()) {
-        QTextBlock block = cursor.block();
-        const int cursorPos = cursor.position();
-
-        QTextBlock::Iterator it = block.begin();
-        QTextBlock::Iterator linkFragment;
-
-        for (; !it.atEnd(); ++it) {
-            QTextFragment fragment = it.fragment();
-            const int fragmentPos = fragment.position();
-            if (fragmentPos <= cursorPos &&
-                fragmentPos + fragment.length() > cursorPos) {
-                linkFragment = it;
-                break;
-            }
-        }
-
-        if (!linkFragment.atEnd()) {
-            it = linkFragment;
-            cursor.setPosition(it.fragment().position());
-            if (it != block.begin()) {
-                do {
-                    --it;
-                    QTextFragment fragment = it.fragment();
-                    if (fragment.charFormat().anchorHref() != href)
-                        break;
-                    cursor.setPosition(fragment.position());
-                } while (it != block.begin());
-            }
-
-            for (it = linkFragment; !it.atEnd(); ++it) {
-                QTextFragment fragment = it.fragment();
-                if (fragment.charFormat().anchorHref() != href)
-                    break;
-                cursor.setPosition(fragment.position() + fragment.length(), QTextCursor::KeepAnchor);
-            }
-        }
-    }
-
-    if (hasFocus) {
-        cursorIsFocusIndicator = true;
-    } else {
-        cursorIsFocusIndicator = false;
-        cursor.clearSelection();
-    }
-    repaintOldAndNewSelection(oldCursor);
-
-#if 0 // ###ndef QT_NO_DESKTOPSERVICES
-    if (openExternalLinks)
-        QDesktopServices::openUrl(href);
-    else
-#endif
-        emit q_func()->linkActivated(href);
-}
-
-bool QTextControl::setFocusToNextOrPreviousAnchor(bool next)
-{
-    Q_D(QTextControl);
-
-    if (!(d->interactionFlags & Qt::LinksAccessibleByKeyboard))
-        return false;
-
-    QRectF crect = selectionRect();
-    emit updateRequest(crect);
-
-    // If we don't have a current anchor, we start from the start/end
-    if (!d->cursor.hasSelection()) {
-        d->cursor = QTextCursor(d->doc);
-        if (next)
-            d->cursor.movePosition(QTextCursor::Start);
-        else
-            d->cursor.movePosition(QTextCursor::End);
-    }
-
-    QTextCursor newAnchor;
-    if (findNextPrevAnchor(d->cursor, next, newAnchor)) {
-        d->cursor = newAnchor;
-        d->cursorIsFocusIndicator = true;
-    } else {
-        d->cursor.clearSelection();
-    }
-
-    if (d->cursor.hasSelection()) {
-        crect = selectionRect();
-        emit updateRequest(crect);
-        emit visibilityRequest(crect);
-        return true;
-    } else {
-        return false;
-    }
-}
-
-bool QTextControl::setFocusToAnchor(const QTextCursor &newCursor)
-{
-    Q_D(QTextControl);
-
-    if (!(d->interactionFlags & Qt::LinksAccessibleByKeyboard))
-        return false;
-
-    // Verify that this is an anchor.
-    const QString anchorHref = d->anchorForCursor(newCursor);
-    if (anchorHref.isEmpty())
-        return false;
-
-    // and process it
-    QRectF crect = selectionRect();
-    emit updateRequest(crect);
-
-    d->cursor.setPosition(newCursor.selectionStart());
-    d->cursor.setPosition(newCursor.selectionEnd(), QTextCursor::KeepAnchor);
-    d->cursorIsFocusIndicator = true;
-
-    crect = selectionRect();
-    emit updateRequest(crect);
-    emit visibilityRequest(crect);
-    return true;
-}
-
-void QTextControl::setTextInteractionFlags(Qt::TextInteractionFlags flags)
-{
-    Q_D(QTextControl);
-    if (flags == d->interactionFlags)
-        return;
-    d->interactionFlags = flags;
-
-    if (d->hasFocus)
-        d->setBlinkingCursorEnabled(flags & (Qt::TextEditable | Qt::TextSelectableByKeyboard));
-}
-
-Qt::TextInteractionFlags QTextControl::textInteractionFlags() const
-{
-    Q_D(const QTextControl);
-    return d->interactionFlags;
-}
-
-void QTextControl::mergeCurrentCharFormat(const QTextCharFormat &modifier)
-{
-    Q_D(QTextControl);
-    d->cursor.mergeCharFormat(modifier);
-    d->updateCurrentCharFormat();
-}
-
-void QTextControl::setCurrentCharFormat(const QTextCharFormat &format)
-{
-    Q_D(QTextControl);
-    d->cursor.setCharFormat(format);
-    d->updateCurrentCharFormat();
-}
-
-QTextCharFormat QTextControl::currentCharFormat() const
-{
-    Q_D(const QTextControl);
-    return d->cursor.charFormat();
-}
-
-void QTextControl::insertPlainText(const QString &text)
-{
-    Q_D(QTextControl);
-    d->cursor.insertText(text);
-}
-
-#ifndef QT_NO_TEXTHTMLPARSER
-void QTextControl::insertHtml(const QString &text)
-{
-    Q_D(QTextControl);
-    d->cursor.insertHtml(text);
-}
-#endif // QT_NO_TEXTHTMLPARSER
-
-QPointF QTextControl::anchorPosition(const QString &name) const
-{
-    Q_D(const QTextControl);
-    if (name.isEmpty())
-        return QPointF();
-
-    QRectF r;
-    for (QTextBlock block = d->doc->begin(); block.isValid(); block = block.next()) {
-        QTextCharFormat format = block.charFormat();
-        if (format.isAnchor() && format.anchorNames().contains(name)) {
-            r = d->rectForPosition(block.position());
-            break;
-        }
-
-        for (QTextBlock::Iterator it = block.begin(); !it.atEnd(); ++it) {
-            QTextFragment fragment = it.fragment();
-            format = fragment.charFormat();
-            if (format.isAnchor() && format.anchorNames().contains(name)) {
-                r = d->rectForPosition(fragment.position());
-                block = QTextBlock();
-                break;
-            }
-        }
-    }
-    if (!r.isValid())
-        return QPointF();
-    return QPointF(0, r.top());
-}
-
-void QTextControl::adjustSize()
-{
-    Q_D(QTextControl);
-    d->doc->adjustSize();
-}
-
-bool QTextControl::find(const QString &exp, QTextDocument::FindFlags options)
-{
-    Q_D(QTextControl);
-    QTextCursor search = d->doc->find(exp, d->cursor, options);
-    if (search.isNull())
-        return false;
-
-    setTextCursor(search);
-    return true;
-}
-
-
-
-void QTextControlPrivate::append(const QString &text, Qt::TextFormat format)
-{
-    QTextCursor tmp(doc);
-    tmp.beginEditBlock();
-    tmp.movePosition(QTextCursor::End);
-
-    if (!doc->isEmpty())
-        tmp.insertBlock(cursor.blockFormat(), cursor.charFormat());
-    else
-        tmp.setCharFormat(cursor.charFormat());
-
-    // preserve the char format
-    QTextCharFormat oldCharFormat = cursor.charFormat();
-
-#ifndef QT_NO_TEXTHTMLPARSER
-    if (format == Qt::RichText || (format == Qt::AutoText && Qt::mightBeRichText(text))) {
-        tmp.insertHtml(text);
-    } else {
-        tmp.insertText(text);
-    }
-#else
-    tmp.insertText(text);
-#endif // QT_NO_TEXTHTMLPARSER
-    if (!cursor.hasSelection())
-        cursor.setCharFormat(oldCharFormat);
-
-    tmp.endEditBlock();
-}
-
-void QTextControl::append(const QString &text)
-{
-    Q_D(QTextControl);
-    d->append(text, Qt::AutoText);
-}
-
-void QTextControl::appendHtml(const QString &html)
-{
-    Q_D(QTextControl);
-    d->append(html, Qt::RichText);
-}
-
-void QTextControl::appendPlainText(const QString &text)
-{
-    Q_D(QTextControl);
-    d->append(text, Qt::PlainText);
-}
-
-
-void QTextControl::ensureCursorVisible()
-{
-    Q_D(QTextControl);
-    QRectF crect = d->rectForPosition(d->cursor.position()).adjusted(-5, 0, 5, 0);
-    emit visibilityRequest(crect);
-    emit microFocusChanged();
-}
-
-QPalette QTextControl::palette() const
-{
-    Q_D(const QTextControl);
-    return d->palette;
-}
-
-void QTextControl::setPalette(const QPalette &pal)
-{
-    Q_D(QTextControl);
-    d->palette = pal;
-}
-
-bool QTextControl::cursorOn() const
-{
-    Q_D(const QTextControl);
-    return d->cursorOn;
-}
-
-QAbstractTextDocumentLayout::PaintContext QTextControl::getPaintContext() const
-{
-    Q_D(const QTextControl);
-
-    QAbstractTextDocumentLayout::PaintContext ctx;
-
-    ctx.selections = d->extraSelections;
-    ctx.palette = d->palette;
-    if (d->cursorOn && d->isEnabled) {
-        if (d->hideCursor)
-            ctx.cursorPosition = -1;
-        else if (d->preeditCursor != 0)
-            ctx.cursorPosition = - (d->preeditCursor + 2);
-        else
-            ctx.cursorPosition = d->cursor.position();
-    }
-
-    if (!d->dndFeedbackCursor.isNull())
-        ctx.cursorPosition = d->dndFeedbackCursor.position();
-#ifdef QT_KEYPAD_NAVIGATION
-    if (!QGuiApplication::keypadNavigationEnabled() || d->hasEditFocus)
-#endif
-    if (d->cursor.hasSelection()) {
-        QAbstractTextDocumentLayout::Selection selection;
-        selection.cursor = d->cursor;
-        if (0 && d->cursorIsFocusIndicator) {
-#if 0
-            // ###
-            QStyleOption opt;
-            opt.palette = ctx.palette;
-            QStyleHintReturnVariant ret;
-            QStyle *style = QGuiApplication::style();
-            if (widget)
-                style = widget->style();
-            style->styleHint(QStyle::SH_TextControl_FocusIndicatorTextCharFormat, &opt, widget, &ret);
-            selection.format = qvariant_cast<QTextFormat>(ret.variant).toCharFormat();
-#endif
-        } else {
-            QPalette::ColorGroup cg = d->hasFocus ? QPalette::Active : QPalette::Inactive;
-            selection.format.setBackground(ctx.palette.brush(cg, QPalette::Highlight));
-            selection.format.setForeground(ctx.palette.brush(cg, QPalette::HighlightedText));
-            if (fullWidthSelection)
-                selection.format.setProperty(QTextFormat::FullWidthSelection, true);
-        }
-        ctx.selections.append(selection);
-    }
-
-    return ctx;
-}
-
-void QTextControl::drawContents(QPainter *p, const QRectF &rect)
-{
-    Q_D(QTextControl);
-    p->save();
-    QAbstractTextDocumentLayout::PaintContext ctx = getPaintContext();
-    if (rect.isValid())
-        p->setClipRect(rect, Qt::IntersectClip);
-    ctx.clip = rect;
-
-    d->doc->documentLayout()->draw(p, ctx);
-    p->restore();
-}
-
-void QTextControlPrivate::_q_copyLink()
-{
-#ifndef QT_NO_CLIPBOARD
-    QMimeData *md = new QMimeData;
-    md->setText(linkToCopy);
-    QGuiApplication::clipboard()->setMimeData(md);
-#endif
-}
-
-QInputContext *QTextControlPrivate::inputContext()
-{
-#if 0
-    // ###
-    QInputContext *ctx = contextObject->inputContext();
-    if (!ctx && contextObject->parentWidget())
-        ctx = contextObject->parentWidget()->inputContext();
-    return ctx;
-#else
-    return 0;
-#endif
-}
-
-int QTextControl::hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const
-{
-    Q_D(const QTextControl);
-    return d->doc->documentLayout()->hitTest(point, accuracy);
-}
-
-QRectF QTextControl::blockBoundingRect(const QTextBlock &block) const
-{
-    Q_D(const QTextControl);
-    return d->doc->documentLayout()->blockBoundingRect(block);
-}
-
-
-
-QStringList QTextEditMimeData::formats() const
-{
-    if (!fragment.isEmpty())
-        return QStringList() << QString::fromLatin1("text/plain") << QString::fromLatin1("text/html")
-#ifndef QT_NO_TEXTODFWRITER
-            << QString::fromLatin1("application/vnd.oasis.opendocument.text")
-#endif
-        ;
-    else
-        return QMimeData::formats();
-}
-
-QVariant QTextEditMimeData::retrieveData(const QString &mimeType, QVariant::Type type) const
-{
-    if (!fragment.isEmpty())
-        setup();
-    return QMimeData::retrieveData(mimeType, type);
-}
-
-void QTextEditMimeData::setup() const
-{
-    QTextEditMimeData *that = const_cast<QTextEditMimeData *>(this);
-#ifndef QT_NO_TEXTHTMLPARSER
-    that->setData(QLatin1String("text/html"), fragment.toHtml("utf-8").toUtf8());
-#endif
-#ifndef QT_NO_TEXTODFWRITER
-    {
-        QBuffer buffer;
-        QTextDocumentWriter writer(&buffer, "ODF");
-        writer.write(fragment);
-        buffer.close();
-        that->setData(QLatin1String("application/vnd.oasis.opendocument.text"), buffer.data());
-    }
-#endif
-    that->setText(fragment.toPlainText());
-    fragment = QTextDocumentFragment();
-}
-
-
-QT_END_NAMESPACE
-
-#include "moc_qtextcontrol_p.cpp"
-
-#endif // QT_NO_TEXTCONTROL
diff --git a/src/gui/text/qtextcontrol_p.h b/src/gui/text/qtextcontrol_p.h
deleted file mode 100644
index dc8631f..0000000
--- a/src/gui/text/qtextcontrol_p.h
+++ /dev/null
@@ -1,287 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTEXTCONTROL_P_H
-#define QTEXTCONTROL_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtGui/qtextdocument.h>
-#include <QtGui/qtextoption.h>
-#include <QtGui/qtextcursor.h>
-#include <QtGui/qtextformat.h>
-#include <QtCore/qrect.h>
-#include <QtGui/qabstracttextdocumentlayout.h>
-#include <QtGui/qtextdocumentfragment.h>
-#include <QtGui/qclipboard.h>
-#include <QtCore/qmimedata.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-class QStyleSheet;
-class QTextDocument;
-class QTextControlPrivate;
-class QAbstractScrollArea;
-class QEvent;
-class QTimerEvent;
-class QPagedPaintDevice;
-
-class Q_GUI_EXPORT QTextControl : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QTextControl)
-#ifndef QT_NO_TEXTHTMLPARSER
-    Q_PROPERTY(QString html READ toHtml WRITE setHtml NOTIFY textChanged USER true)
-#endif
-    Q_PROPERTY(bool overwriteMode READ overwriteMode WRITE setOverwriteMode)
-    Q_PROPERTY(bool acceptRichText READ acceptRichText WRITE setAcceptRichText)
-    Q_PROPERTY(int cursorWidth READ cursorWidth WRITE setCursorWidth)
-    Q_PROPERTY(Qt::TextInteractionFlags textInteractionFlags READ textInteractionFlags WRITE setTextInteractionFlags)
-    Q_PROPERTY(bool openExternalLinks READ openExternalLinks WRITE setOpenExternalLinks)
-    Q_PROPERTY(bool ignoreUnusedNavigationEvents READ ignoreUnusedNavigationEvents WRITE setIgnoreUnusedNavigationEvents)
-public:
-    explicit QTextControl(QObject *parent = 0);
-    explicit QTextControl(const QString &text, QObject *parent = 0);
-    explicit QTextControl(QTextDocument *doc, QObject *parent = 0);
-    virtual ~QTextControl();
-
-    void setView(QObject *view);
-    QObject *view() const;
-
-    void setDocument(QTextDocument *document);
-    QTextDocument *document() const;
-
-    void setTextCursor(const QTextCursor &cursor);
-    QTextCursor textCursor() const;
-
-    void setTextInteractionFlags(Qt::TextInteractionFlags flags);
-    Qt::TextInteractionFlags textInteractionFlags() const;
-
-    void mergeCurrentCharFormat(const QTextCharFormat &modifier);
-
-    void setCurrentCharFormat(const QTextCharFormat &format);
-    QTextCharFormat currentCharFormat() const;
-
-    bool find(const QString &exp, QTextDocument::FindFlags options = 0);
-
-    inline QString toPlainText() const
-    { return document()->toPlainText(); }
-#ifndef QT_NO_TEXTHTMLPARSER
-    inline QString toHtml() const
-    { return document()->toHtml(); }
-#endif
-
-    virtual void ensureCursorVisible();
-
-    virtual QVariant loadResource(int type, const QUrl &name);
-
-    QTextCursor cursorForPosition(const QPointF &pos) const;
-    QRectF cursorRect(const QTextCursor &cursor) const;
-    QRectF cursorRect() const;
-    QRectF selectionRect(const QTextCursor &cursor) const;
-    QRectF selectionRect() const;
-
-    QString anchorAt(const QPointF &pos) const;
-    QPointF anchorPosition(const QString &name) const;
-
-    QString anchorAtCursor() const;
-
-    bool overwriteMode() const;
-    void setOverwriteMode(bool overwrite);
-
-    int cursorWidth() const;
-    void setCursorWidth(int width);
-
-    bool acceptRichText() const;
-    void setAcceptRichText(bool accept);
-
-    void setExtraSelections(const QVector<QAbstractTextDocumentLayout::Selection> &selections);
-    QVector<QAbstractTextDocumentLayout::Selection> extraSelections() const;
-
-    void setTextWidth(qreal width);
-    qreal textWidth() const;
-    QSizeF size() const;
-
-    void setOpenExternalLinks(bool open);
-    bool openExternalLinks() const;
-
-    void setIgnoreUnusedNavigationEvents(bool ignore);
-    bool ignoreUnusedNavigationEvents() const;
-
-    void moveCursor(QTextCursor::MoveOperation op, QTextCursor::MoveMode mode = QTextCursor::MoveAnchor);
-
-    bool canPaste() const;
-
-    void setCursorIsFocusIndicator(bool b);
-    bool cursorIsFocusIndicator() const;
-
-    void setDragEnabled(bool enabled);
-    bool isDragEnabled() const;
-
-    bool isWordSelectionEnabled() const;
-    void setWordSelectionEnabled(bool enabled);
-
-    void print(QPagedPaintDevice *printer) const;
-
-    virtual int hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const;
-    virtual QRectF blockBoundingRect(const QTextBlock &block) const;
-    QAbstractTextDocumentLayout::PaintContext getPaintContext() const;
-
-public Q_SLOTS:
-    void setPlainText(const QString &text);
-    void setHtml(const QString &text);
-
-#ifndef QT_NO_CLIPBOARD
-    void cut();
-    void copy();
-    void paste(QClipboard::Mode mode = QClipboard::Clipboard);
-#endif
-
-    void undo();
-    void redo();
-
-    void clear();
-    void selectAll();
-
-    void insertPlainText(const QString &text);
-#ifndef QT_NO_TEXTHTMLPARSER
-    void insertHtml(const QString &text);
-#endif
-
-    void append(const QString &text);
-    void appendHtml(const QString &html);
-    void appendPlainText(const QString &text);
-
-    void adjustSize();
-
-Q_SIGNALS:
-    void textChanged();
-    void undoAvailable(bool b);
-    void redoAvailable(bool b);
-    void currentCharFormatChanged(const QTextCharFormat &format);
-    void copyAvailable(bool b);
-    void selectionChanged();
-    void cursorPositionChanged();
-
-    // control signals
-    void updateCursorRequest(const QRectF &rect = QRectF());
-    void updateRequest(const QRectF &rect = QRectF());
-    void documentSizeChanged(const QSizeF &);
-    void blockCountChanged(int newBlockCount);
-    void visibilityRequest(const QRectF &rect);
-    void microFocusChanged();
-    void linkActivated(const QString &link);
-    void linkHovered(const QString &);
-    void modificationChanged(bool m);
-
-public:
-    // control properties
-    QPalette palette() const;
-    void setPalette(const QPalette &pal);
-
-    virtual void processEvent(QEvent *e, const QMatrix &matrix);
-    void processEvent(QEvent *e, const QPointF &coordinateOffset = QPointF());
-
-    // control methods
-    void drawContents(QPainter *painter, const QRectF &rect = QRectF());
-
-    void setFocus(bool focus, Qt::FocusReason = Qt::OtherFocusReason);
-
-    virtual QVariant inputMethodQuery(Qt::InputMethodQuery property) const;
-
-    virtual QMimeData *createMimeDataFromSelection() const;
-    virtual bool canInsertFromMimeData(const QMimeData *source) const;
-    virtual void insertFromMimeData(const QMimeData *source);
-
-    bool setFocusToAnchor(const QTextCursor &newCursor);
-    bool setFocusToNextOrPreviousAnchor(bool next);
-    bool findNextPrevAnchor(const QTextCursor& from, bool next, QTextCursor& newAnchor);
-
-    bool cursorOn() const;
-
-protected:
-    virtual void timerEvent(QTimerEvent *e);
-
-    virtual bool event(QEvent *e);
-
-private:
-    Q_DISABLE_COPY(QTextControl)
-    Q_PRIVATE_SLOT(d_func(), void _q_updateCurrentCharFormatAndSelection())
-    Q_PRIVATE_SLOT(d_func(), void _q_emitCursorPosChanged(const QTextCursor &))
-    Q_PRIVATE_SLOT(d_func(), void _q_deleteSelected())
-    Q_PRIVATE_SLOT(d_func(), void _q_copyLink())
-    Q_PRIVATE_SLOT(d_func(), void _q_updateBlock(const QTextBlock &))
-    Q_PRIVATE_SLOT(d_func(), void _q_documentLayoutChanged())
-};
-
-
-// also used by QLabel
-class QTextEditMimeData : public QMimeData
-{
-public:
-    inline QTextEditMimeData(const QTextDocumentFragment &aFragment) : fragment(aFragment) {}
-
-    virtual QStringList formats() const;
-protected:
-    virtual QVariant retrieveData(const QString &mimeType, QVariant::Type type) const;
-private:
-    void setup() const;
-
-    mutable QTextDocumentFragment fragment;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QTextControl_H
diff --git a/src/gui/text/qtextcontrol_p_p.h b/src/gui/text/qtextcontrol_p_p.h
deleted file mode 100644
index 20dcea3..0000000
--- a/src/gui/text/qtextcontrol_p_p.h
+++ /dev/null
@@ -1,232 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QTEXTCONTROL_P_P_H
-#define QTEXTCONTROL_P_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "QtGui/qtextdocumentfragment.h"
-#include "QtGui/qtextcursor.h"
-#include "QtGui/qtextformat.h"
-#include "QtGui/qabstracttextdocumentlayout.h"
-#include "QtCore/qbasictimer.h"
-#include "QtCore/qpointer.h"
-#include "private/qobject_p.h"
-
-QT_BEGIN_NAMESPACE
-
-class QMimeData;
-class QAbstractScrollArea;
-class QInputContext;
-
-class QTextControlPrivate : public QObjectPrivate
-{
-    Q_DECLARE_PUBLIC(QTextControl)
-public:
-    QTextControlPrivate();
-
-    bool cursorMoveKeyEvent(QKeyEvent *e);
-
-    void updateCurrentCharFormat();
-
-    void indent();
-    void outdent();
-
-    void gotoNextTableCell();
-    void gotoPreviousTableCell();
-
-    void createAutoBulletList();
-
-    void init(Qt::TextFormat format = Qt::RichText, const QString &text = QString(),
-              QTextDocument *document = 0);
-    void setContent(Qt::TextFormat format = Qt::RichText, const QString &text = QString(),
-                    QTextDocument *document = 0);
-    void startDrag();
-
-    void paste(const QMimeData *source);
-
-    void setCursorPosition(const QPointF &pos);
-    void setCursorPosition(int pos, QTextCursor::MoveMode mode = QTextCursor::MoveAnchor);
-
-    void repaintCursor();
-    inline void repaintSelection()
-    { repaintOldAndNewSelection(QTextCursor()); }
-    void repaintOldAndNewSelection(const QTextCursor &oldSelection);
-
-    void selectionChanged(bool forceEmitSelectionChanged = false);
-
-    void _q_updateCurrentCharFormatAndSelection();
-
-#ifndef QT_NO_CLIPBOARD
-    void setClipboardSelection();
-#endif
-
-    void _q_emitCursorPosChanged(const QTextCursor &someCursor);
-
-    void setBlinkingCursorEnabled(bool enable);
-
-    void extendWordwiseSelection(int suggestedNewPosition, qreal mouseXPosition);
-    void extendBlockwiseSelection(int suggestedNewPosition);
-
-    void _q_deleteSelected();
-
-    void _q_setCursorAfterUndoRedo(int undoPosition, int charsAdded, int charsRemoved);
-
-    QRectF cursorRectPlusUnicodeDirectionMarkers(const QTextCursor &cursor) const;
-    QRectF rectForPosition(int position) const;
-    QRectF selectionRect(const QTextCursor &cursor) const;
-    inline QRectF selectionRect() const
-    { return selectionRect(this->cursor); }
-
-    QString anchorForCursor(const QTextCursor &anchor) const;
-
-    void keyPressEvent(QKeyEvent *e);
-    void mousePressEvent(QEvent *e, Qt::MouseButton button, const QPointF &pos,
-                         Qt::KeyboardModifiers modifiers,
-                         Qt::MouseButtons buttons,
-                         const QPoint &globalPos);
-    void mouseMoveEvent(QEvent *e, Qt::MouseButton button, const QPointF &pos,
-                        Qt::KeyboardModifiers modifiers,
-                        Qt::MouseButtons buttons,
-                        const QPoint &globalPos);
-    void mouseReleaseEvent(QEvent *e, Qt::MouseButton button, const QPointF &pos,
-                           Qt::KeyboardModifiers modifiers,
-                           Qt::MouseButtons buttons,
-                           const QPoint &globalPos);
-    void mouseDoubleClickEvent(QEvent *e, Qt::MouseButton button, const QPointF &pos,
-                               Qt::KeyboardModifiers modifiers,
-                               Qt::MouseButtons buttons,
-                               const QPoint &globalPos);
-    bool sendMouseEventToInputContext(QEvent *e,  QEvent::Type eventType, Qt::MouseButton button,
-                                      const QPointF &pos,
-                                      Qt::KeyboardModifiers modifiers,
-                                      Qt::MouseButtons buttons,
-                                      const QPoint &globalPos);
-    void contextMenuEvent(const QPoint &screenPos, const QPointF &docPos, QWidget *contextWidget);
-    void focusEvent(QFocusEvent *e);
-#ifdef QT_KEYPAD_NAVIGATION
-    void editFocusEvent(QEvent *e);
-#endif
-    bool dragEnterEvent(QEvent *e, const QMimeData *mimeData);
-    void dragLeaveEvent();
-    bool dragMoveEvent(QEvent *e, const QMimeData *mimeData, const QPointF &pos);
-    bool dropEvent(const QMimeData *mimeData, const QPointF &pos, Qt::DropAction dropAction, QObject *source);
-
-    void inputMethodEvent(QInputMethodEvent *);
-
-    void activateLinkUnderCursor(QString href = QString());
-
-    void append(const QString &text, Qt::TextFormat format = Qt::AutoText);
-
-    QInputContext *inputContext();
-
-    QTextDocument *doc;
-    bool cursorOn;
-    QTextCursor cursor;
-    bool cursorIsFocusIndicator;
-    QTextCharFormat lastCharFormat;
-
-    QTextCursor dndFeedbackCursor;
-
-    Qt::TextInteractionFlags interactionFlags;
-
-    QBasicTimer cursorBlinkTimer;
-    QBasicTimer trippleClickTimer;
-    QPointF trippleClickPoint;
-
-    bool dragEnabled;
-
-    bool mousePressed;
-
-    bool mightStartDrag;
-    QPoint dragStartPos;
-    QPointer<QObject> contextObject;
-
-    bool lastSelectionState;
-
-    bool ignoreAutomaticScrollbarAdjustement;
-
-    QTextCursor selectedWordOnDoubleClick;
-    QTextCursor selectedBlockOnTrippleClick;
-
-    bool overwriteMode;
-    bool acceptRichText;
-
-    int preeditCursor;
-    bool hideCursor; // used to hide the cursor in the preedit area
-
-    QVector<QAbstractTextDocumentLayout::Selection> extraSelections;
-
-    QPalette palette;
-    bool hasFocus;
-#ifdef QT_KEYPAD_NAVIGATION
-    bool hasEditFocus;
-#endif
-    bool isEnabled;
-
-    QString highlightedAnchor; // Anchor below cursor
-    QString anchorOnMousePress;
-    bool hadSelectionOnMousePress;
-
-    bool ignoreUnusedNavigationEvents;
-    bool openExternalLinks;
-
-    bool wordSelectionEnabled;
-
-    QString linkToCopy;
-    void _q_copyLink();
-    void _q_updateBlock(const QTextBlock &);
-    void _q_documentLayoutChanged();
-};
-
-QT_END_NAMESPACE
-
-#endif // QTextControl_P_H
diff --git a/src/gui/text/text.pri b/src/gui/text/text.pri
index a5135cb..63a731f 100644
--- a/src/gui/text/text.pri
+++ b/src/gui/text/text.pri
@@ -9,7 +9,6 @@ HEADERS += \
 	text/qfontmetrics.h \
 	text/qfont_p.h \
 	text/qfontsubset_p.h \
-        text/qlinecontrol_p.h \
         text/qtextengine_p.h \
 	text/qtextlayout.h \
 	text/qtextformat.h \
@@ -23,8 +22,6 @@ HEADERS += \
 	text/qtexthtmlparser_p.h \
 	text/qabstracttextdocumentlayout.h \
 	text/qtextdocumentlayout_p.h \
-        text/qtextcontrol_p.h \
-        text/qtextcontrol_p_p.h \
         text/qtextcursor.h \
         text/qtextcursor_p.h \
 	text/qtextdocumentfragment.h \
@@ -53,8 +50,6 @@ SOURCES += \
 	text/qfontsubset.cpp \
 	text/qfontmetrics.cpp \
 	text/qfontdatabase.cpp \
-        text/qlinecontrol.cpp \
-        text/qtextcontrol.cpp \
         text/qtextengine.cpp \
 	text/qtextlayout.cpp \
 	text/qtextformat.cpp \
diff --git a/tests/auto/widgets/graphicsview/qgraphicsitem/tst_qgraphicsitem.cpp b/tests/auto/widgets/graphicsview/qgraphicsitem/tst_qgraphicsitem.cpp
index c94eca5..ad1dbc1 100644
--- a/tests/auto/widgets/graphicsview/qgraphicsitem/tst_qgraphicsitem.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicsitem/tst_qgraphicsitem.cpp
@@ -4243,14 +4243,14 @@ void tst_QGraphicsItem::textControlGetterSetter()
 {
     QGraphicsTextItem *item = new QGraphicsTextItem;
     QVERIFY(item->textControl()->parent() == item);
-    QPointer<QTextControl> control = item->textControl();
+    QPointer<QWidgetTextControl> control = item->textControl();
     delete item;
     QVERIFY(!control);
 
     item = new QGraphicsTextItem;
 
-    QPointer<QTextControl> oldControl = control;
-    control = new QTextControl;
+    QPointer<QWidgetTextControl> oldControl = control;
+    control = new QWidgetTextControl;
 
     item->setTextControl(control);
     QVERIFY(item->textControl() == control);
@@ -4269,7 +4269,7 @@ void tst_QGraphicsItem::textControlGetterSetter()
     // test that on setting a control the item size
     // is adjusted
     oldControl = control;
-    control = new QTextControl;
+    control = new QWidgetTextControl;
     control->setPlainText("foo!");
     item->setTextControl(control);
     QCOMPARE(item->boundingRect().size(), control->document()->documentLayout()->documentSize());
diff --git a/tests/benchmarks/gui/text/qtext/main.cpp b/tests/benchmarks/gui/text/qtext/main.cpp
index 0cbb38a..a5e27cf 100644
--- a/tests/benchmarks/gui/text/qtext/main.cpp
+++ b/tests/benchmarks/gui/text/qtext/main.cpp
@@ -44,7 +44,6 @@
 #include <QTextDocumentWriter>
 #include <QTextLayout>
 #include <QTextCursor>
-#include <private/qtextcontrol_p.h>
 #include <qmath.h>
 #include <QFile>
 #include <QPainter>
@@ -73,7 +72,6 @@ private slots:
     void odfWriting_text();
     void odfWriting_images();
 
-    void constructControl();
     void constructDocument();
 
     void newLineReplacement();
@@ -90,10 +88,6 @@ private slots:
     void paintDocToPixmap();
     void paintDocToPixmap_painterFill();
 
-    void control();
-    void paintControlToPixmap();
-    void paintControlToPixmap_painterFill();
-
 private:
     QSize setupTextLayout(QTextLayout *layout, bool wrap = true, int wrapWidth = 100);
 
@@ -255,17 +249,6 @@ QSize tst_QText::setupTextLayout(QTextLayout *layout, bool wrap, int wrapWidth)
     return QSize(qCeil(widthUsed), height);
 }
 
-void tst_QText::constructControl()
-{
-    QTextControl *control = new QTextControl;
-    delete control;
-
-    QBENCHMARK {
-        QTextControl *control = new QTextControl;
-        delete control;
-    }
-}
-
 void tst_QText::constructDocument()
 {
     QTextDocument *doc = new QTextDocument;
@@ -441,52 +424,6 @@ void tst_QText::paintDocToPixmap_painterFill()
     }
 }
 
-void tst_QText::control()
-{
-    QTextControl *control = new QTextControl(m_shortLorem);
-    Q_UNUSED(control);
-
-    QBENCHMARK {
-        QTextControl *control = new QTextControl;
-        QTextDocument *doc = control->document();
-        doc->setHtml(m_shortLorem);
-    }
-}
-
-void tst_QText::paintControlToPixmap()
-{
-    QTextControl *control = new QTextControl;
-    QTextDocument *doc = control->document();
-    doc->setHtml(m_shortLorem);
-    doc->setTextWidth(300);
-    QSize size = doc->size().toSize();
-
-    QBENCHMARK {
-        QPixmap img(size);
-        img.fill(Qt::transparent);
-        QPainter p(&img);
-        control->drawContents(&p, QRectF(QPointF(0, 0), QSizeF(size)));
-    }
-}
-
-void tst_QText::paintControlToPixmap_painterFill()
-{
-    QTextControl *control = new QTextControl;
-    QTextDocument *doc = control->document();
-    doc->setHtml(m_shortLorem);
-    doc->setTextWidth(300);
-    QSize size = doc->size().toSize();
-
-    QBENCHMARK {
-        QPixmap img(size);
-        QPainter p(&img);
-        p.setCompositionMode(QPainter::CompositionMode_Source);
-        p.fillRect(0, 0, img.width(), img.height(), Qt::transparent);
-        p.setCompositionMode(QPainter::CompositionMode_SourceOver);
-        control->drawContents(&p, QRectF(QPointF(0, 0), QSizeF(size)));
-    }
-}
-
 QTEST_MAIN(tst_QText)
 
 #include "main.moc"