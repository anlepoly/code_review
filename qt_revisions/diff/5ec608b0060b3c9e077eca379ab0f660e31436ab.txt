diff --git a/doc/config/qtmultimedia_doc.pri b/doc/config/qtmultimedia_doc.pri
index 05af067..1295485 100644
--- a/doc/config/qtmultimedia_doc.pri
+++ b/doc/config/qtmultimedia_doc.pri
@@ -36,8 +36,10 @@ QMAKE_CLEAN += \
 
 
 OTHER_FILES += \
-    doc/src/multimedia.qdoc \
-    doc/src/camera.qdoc \
+    doc/src/cameraoverview.qdoc \
     doc/src/multimediabackend.qdoc \
+    doc/src/multimediaoverview.qdoc \
+    doc/src/audiooverview.qdoc \
     doc/src/radiooverview.qdoc \
+    doc/src/videooverview.qdoc \
     doc/src/plugins/qml-multimedia.qdoc
diff --git a/doc/src/audiooverview.qdoc b/doc/src/audiooverview.qdoc
new file mode 100644
index 0000000..c47aed9
--- /dev/null
+++ b/doc/src/audiooverview.qdoc
@@ -0,0 +1,127 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the documentation of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:FDL$
+** GNU Free Documentation License
+** Alternatively, this file may be used under the terms of the GNU Free
+** Documentation License version 1.3 as published by the Free Software
+** Foundation and appearing in the file included in the packaging of
+** this file.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms
+** and conditions contained in a signed written agreement between you
+** and Nokia.
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+\page audiooverview.html
+\title Audio Overview
+\brief Audio playback and recording
+
+\section1 Audio Features
+
+Qt Multimedia offers a range of audio classes, covering both low and
+high level approaches to audio input and output.
+
+\section1 Audio Implementation Details
+
+\section2 Low level audio playback and recording
+Qt Multimedia offers classes for raw access to audio input and output
+facilities, allowing applications to receive raw data from devices like
+microphones, and to write raw data to speakers or other devices.  Generally
+these classes do not do any audio decoding, or other processing, but they
+can support different types of raw audio data.
+
+The QAudioOutput class offers raw audio data output, while QAudioInput
+offers raw audio data input.  Both classes have adjustable buffers and
+latency, so they are suitable for both low latency usecases (like games
+or VOIP) and high latency (like music playback).  The available hardware
+determines what audio outputs and inputs are available.
+
+\section3 Push and Pull
+[TBD] - description of push vs. pull mode.
+
+\section2 Low latency sound effects
+
+In addition to the raw access to sound devices described above, the QSoundEffect class (and
+\l {SoundEffect} QML element) offers a slightly higher level way to play
+sounds.  These classes allow you to specify a WAV format file which can
+then be played with low latency when necessary.  Both QSoundEffect and the
+SoundEffect element have essentially the same API.
+
+You can adjust the number of \l {QSoundEffect::setLoops()}{loops} a sound effect is played, as well as
+the \l {QSoundEffect::setVolume()}{volume} (or \l {QSoundEffect::setMuted()}{muting}) of the effect.
+
+For older, Qt 4.x based applications \l QSound is also available.  Applications
+are recommended to use QSoundEffect where possible.
+
+\section2 Playing compressed audio
+For playing media or audio files that are not simple, raw audio, you can
+use the \l QMediaPlayer C++ class, or the \l {Audio} and \l {MediaPlayer} QML elements.
+The QMediaPlayer class (and MediaPlayer element) is also capable of playing
+\l{multimedia-playing-video}{video}, if required.  The compressed audio formats supported does depend
+on the operating system environment, and also what media plugins the user
+may have installed.
+
+Here is how you play a local file using C++:
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Local playback
+
+You can also put files (even remote URLs) into a playlist:
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio playlist
+
+\section2 Recording audio to a file
+For recording audio to a file, the \l {QAudioRecorder} class allows you
+to compress audio data from an input device and record it.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio recorder
+
+\section1 Examples
+
+There are both C++ and QML examples available.
+
+C++ Examples:
+
+\section2 Record a Sound Source
+
+\l{audiorecorder}{AudioRecorder} is a demonstration of the discovery of
+the supported devices and codecs and the use of recording functions in the
+QAudioRecorder class.
+
+\list
+    \o \l audiodevices
+    \o \l audioinput
+    \o \l audiooutput
+    \o \l audiorecorder
+    \o \l spectrum
+\endlist
+
+QML Examples:
+[TBD]
+
+\section1 Reference Documentation
+
+\section2 Audio Classes
+
+\annotatedlist multimedia_audio
+
+\section2 QML Elements
+
+\list
+    \o \l Audio
+    \o \l MediaPlayer
+\endlist
+
+*/
diff --git a/doc/src/camera.qdoc b/doc/src/camera.qdoc
deleted file mode 100644
index 1fc5d1e..0000000
--- a/doc/src/camera.qdoc
+++ /dev/null
@@ -1,170 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the documentation of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:FDL$
-** GNU Free Documentation License
-** Alternatively, this file may be used under the terms of the GNU Free
-** Documentation License version 1.3 as published by the Free Software
-** Foundation and appearing in the file included in the packaging of
-** this file.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms
-** and conditions contained in a signed written agreement between you
-** and Nokia.
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-
-\page camera.html
-
-\title Camera
-\brief An API to control camera devices.
-
-The Camera API provides control of system camera devices. Providing support
-for still or video image capture with sound support.
-
-\tableofcontents
-
-\section1 Overview
-
-The Camera API allows high level control of various aspects of still images
-and video. Camera is a part of the Multimedia API and this relationship is
-apparent when you notice that certain core classes are subclassed from some
-Multimedia base classes including \l QMediaObject and \l QMediaControl.
-
-\section1 Still Images
-
-In order to capture an image we need to create a \l QCamera object and use
-it to initialize a \l QVideoWidget, so we can see where the camera is
-pointing - a viewfinder. The camera object is also used to initialize a new
-QCameraImageCapture object, imageCapture. All that is then needed is to start
-the camera, lock it so that the settings are not changed while the image
-capture occurs, capture the image, and finally unlock the camera ready for
-the next photo.
-
-    \code
-        camera = new QCamera;
-        viewFinder = new QCameraViewfinder;
-        camera->setViewfinder(viewFinder);
-        viewFinder->show();
-
-        imageCapture = new QCameraImageCapture(camera);
-
-        camera->setCaptureMode(QCamera::CaptureStillImage);
-        camera->start();
-
-        //on half pressed shutter button
-        camera->searchA{QCameraFocus::FocusMode}{ndLock();
-
-        //on shutter button pressed
-        imageCapture->capture();
-
-        //on shutter button released
-        camera->unlock();
-    \endcode
-
-Alternatively, we could have used a QGraphicsVideoItem as a viewfinder.
-
-
-\section1 Video Clips
-
-Previously we saw code that allowed the capture of a still image. Recording
-video requires the use of a \l QMediaRecorder object and a \l
-QAudioCaptureSource for sound.
-
-To record video we need to create a camera object as before but this time as
-well as creating a viewfinder, we will also initialize a media recorder object.
-
-    \code
-    camera = new QCamera;
-    mediaRecorder = new QMediaRecorder(camera);
-
-    camera->setCaptureMode(QCamera::CaptureVideo);
-    camera->start();
-
-    //on shutter button pressed
-    mediaRecorder->record();
-    \endcode
-
-Signals from the \i mediaRecorder can be connected to slots to react to
-changes in the state of the recorder or error events. Recording itself
-starts with the \l {QMediaRecorder::record()}{record()} function of
-mediaRecorder being called, this causes the signal \l
-{QMediaRecorder::stateChanged()}{stateChanged()} to be emitted. The
-recording process can be changed with the \l {QMediaRecorder::record()}{record()},
-\l {QMediaRecorder::pause()}{pause()}, \l {QMediaRecorder::stop()}{stop()} and
-\l {QMediaRecorder::setMuted()}{setMuted()} slots in \l QMediaRecorder.
-
-When the camera is in video mode, as decided by the application, then as the
-shutter button is pressed the camera is locked as before but instead the
-\l {QMediaRecorder::record()}{record()} function in \l QMediaRecorder is used.
-
-
-
-\section1 Focus
-
-Focusing is managed by the classes \l QCameraFocus and \l QCameraFocusControl.
-QCameraFocus allows the developer to set the general policy by means of the
-enums for the \l {QCameraFocus::FocusMode}{FocusMode} and the
-\l {QCameraFocus::FocusPointMode}{FocusPointMode}. \l {QCameraFocus::FocusMode}{FocusMode}
-deals with settings such as \l {QCameraFocus::FocusMode}{AutoFocus},
-\l {QCameraFocus::FocusMode}{ContinuousFocus} and \l {QCameraFocus::FocusMode}{InfinityFocus}, whereas \l {QCameraFocus::FocusMode}{FocusPointMode} deals with the various focus zones within the view. \l {QCameraFocus::FocusMode}{FocusPointMode} has support for face recognition, center focus and a custom
-focus where the focus point can be specified.
-
-
-
-\section1 Cancelling Asynchronous Operations
-
-Various operations such as image capture and auto focusing occur
-asynchrously. These operations can often be cancelled by the start of a new
-operation as long as this is supported by the backend. For image capture,
-the operation can be cancelled by calling
-\l {QCameraImageCapture::cancelCapture()}{cancelCapture()}. For AutoFocus,
-autoexposure or white balance cancellation can be done by calling
-\i {QCamera::unlock(QCamera::LockFocus)}.
-
-
-
-\section1 Camera Controls
-
-    \table
-        \header
-            \o Control Name
-            \o Description
-        \row
-            \o camera
-            \o the interface for system camera devices
-        \row
-            \o exposure
-            \o Includes: flash mode; flash power; metering mode; aperture; shutter speed, iso setting
-        \row
-            \o focus
-            \o Includes: optical zoom; digital zoom; focus point; focus zones
-        \row
-            \o image processing
-            \o white balance; contrast; saturation; sharpen; denoise
-        \row
-            \o locks
-            \o handles the locking and unlocking of camera devices
-    \endtable
-
-
-\section1 Classes
-\annotatedlist multimedia_camera
-
-
-*/
-
-
diff --git a/doc/src/cameraoverview.qdoc b/doc/src/cameraoverview.qdoc
new file mode 100644
index 0000000..fa4762c
--- /dev/null
+++ b/doc/src/cameraoverview.qdoc
@@ -0,0 +1,269 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the documentation of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:FDL$
+** GNU Free Documentation License
+** Alternatively, this file may be used under the terms of the GNU Free
+** Documentation License version 1.3 as published by the Free Software
+** Foundation and appearing in the file included in the packaging of
+** this file.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms
+** and conditions contained in a signed written agreement between you
+** and Nokia.
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+\page cameraoverview.html
+\title Camera Overview
+\brief Camera viewfinder, still image capture, and video recording.
+
+The Qt Multimedia API provides a number of camera related classes, so you
+can access images and videos from mobile device cameras or webcameras.
+There are both C++ and QML apis for common tasks.
+
+\section1 Camera Features
+
+In order to use the camera classes a quick overview of the way a camera
+works is needed.  If you're already familiar with this, you can skip ahead to
+\l {camera-tldr}{Camera implementation details}.
+
+[TBD - this needs a diagram]
+* Camera features
+ * lens -> sensors -> image processing -> capture/recording
+
+\section2 The lens assembly
+At one end of the camera assembly is the lens assembly (one or
+more lenses, arranged to focus light onto the sensor).  The lens
+themselves can sometimes be moved to adjust things like focus and zoom,
+or they might be fixed in an arrangement to give a good balance between
+objects in focus, and cost.
+
+Some lens assemblies can automatically be adjusted so that
+an object at different distances from the camera can be kept in focus.
+This is usually done by measuring how sharp a particular area of the
+frame is, and by adjusting the lens assembly until it is maximally
+sharp.  In some cases the camera will always use the center of the
+frame for this.  Other cameras may also allow the region to focus
+to be specified (for "touch to zoom", or "face zoom" features).
+
+\section2 The sensor
+Once light arrives at the sensor, it gets converted into digital pixels.
+This process can depend on a number of things but ultimately comes down
+to two things - how long the conversion is allowed to take, and how
+bright the light is.  The longer a conversion can take, the better the
+quality.  Using a flash can assist with letting more light hit the sensor,
+allowing it to convert pixels faster, giving better quality for the same
+amount of time.  Conversely, allowing a longer conversion time can let you
+take photos in darker environments, as long as the camera is steady.
+
+\section2 Image processing
+After the image has been captured by the sensor, the camera firmware performs
+various image processing tasks on it to compensate for various sensor
+characteristics, current lighting, and desired image properties.  Faster sensor
+pixel conversion times tend to introduce digital noise, so some amount of image
+processing can be done to remove this based on the camera sensor settings.
+
+The color of the image can also be adjusted at this stage to compensate for
+different light sources - fluorescent lights and sunlight give very different
+appearances to the same object, so the image can be adjusted based on the
+white balance of the picture (due to the different color temperatures of the
+light sources).
+
+Some forms of "special effects" can also be performed at this stage.  Black
+and white, sepia, or "negative" style images can be produced.
+
+\section2 Recording for posterity
+Finally, once a perfectly focused, exposed and processed image has been
+created, it can be put to good use.  Camera images can be further processed
+by application code (for example, to detect barcodes, or to stitch together),
+or saved to a common format like JPEG, or used to create a movie.  Many of
+these tasks have classes to assist them.
+
+\target camera-tldr
+\section1 Camera Implementation Details
+\section2 Viewfinder
+
+While not strictly necessary, it's often useful to be able to see
+what the camera is pointing at.  Most digital cameras allow an image
+feed from the camera sensor at a lower resolution (usually up to
+the size of the display of the camera) so you can compose
+a photo or video, and then switch to a slower but higher resolution
+mode for capturing the image.
+
+Depending on whether you're using QML or C++, you can do this in multiple ways.
+In QML, you can use the Camera and VideoOutput elements together to show a
+simple viewfinder:
+
+\qml
+    Camera {
+        id: camera
+        // You can adjust various settings in here
+    }
+
+    VideoOutput {
+        source: camera
+    }
+\endqml
+
+In C++, your choice depends on whether you are using widgets, or QGraphicsView.
+The \l QVideoWidget class is used in the widgets case, and \l QGraphicsVideoItem
+is useful for QGraphicsView.
+
+    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera overview viewfinder
+
+For advanced usage (like processing viewfinder frames as they come, to detect
+objects or patterns), you can also derive from \l QAbstractVideoSurface and
+set that as the viewfinder for the QCamera object.  In this case you will
+need to render the viewfinder image yourself.
+
+    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera overview surface
+
+\section2 Still Images
+
+After setting up a viewfinder and finding something photogenic,
+to capture an image we need to initialize a new QCameraImageCapture
+object. All that is then needed is to start the camera, lock it so
+that things are in focus and the settings are not different from the
+viewfinder while the image capture occurs, capture the image, and
+finally unlock the camera ready for the next photo.
+
+    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera overview capture
+
+\section2 Movies
+
+Previously we saw code that allowed the capture of a still image. Recording
+video requires the use of a \l QMediaRecorder object.
+
+To record video we need to create a camera object as before but this time as
+well as creating a viewfinder, we will also initialize a media recorder object.
+
+    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera overview movie
+
+Signals from the \i mediaRecorder can be connected to slots to react to
+changes in the state of the recorder or error events. Recording itself
+starts with the \l {QMediaRecorder::record()}{record()} function of
+mediaRecorder being called, this causes the signal \l
+{QMediaRecorder::stateChanged()}{stateChanged()} to be emitted. The
+recording process can be changed with the \l {QMediaRecorder::record()}{record()},
+\l {QMediaRecorder::stop()}{stop()} and \l {QMediaRecorder::setMuted()}{setMuted()}
+slots in \l QMediaRecorder.
+
+\section2 Controlling the imaging pipeline
+
+Now that the basics of capturing images or movies are covered, there are a number
+of ways to control the imaging pipeline to implement some interesting techniques.
+As explained earlier, several physical and electronic elements combine to determine
+the final images, and you can control them with different classes.
+
+\section3 Focus and zoom
+
+Focusing (and zoom) is managed primarily by the \l QCameraFocus class.
+QCameraFocus allows the developer to set the general policy by means of the
+enums for the \l {QCameraFocus::FocusMode}{FocusMode} and the
+\l {QCameraFocus::FocusPointMode}{FocusPointMode}. \l {QCameraFocus::FocusMode}{FocusMode}
+deals with settings such as \l {QCameraFocus::FocusMode}{AutoFocus},
+\l {QCameraFocus::FocusMode}{ContinuousFocus} and \l {QCameraFocus::FocusMode}{InfinityFocus},
+whereas \l {QCameraFocus::FocusMode}{FocusPointMode} deals with the
+various focus zones within the view that are used for autofocus modes. \l {QCameraFocus::FocusMode}{FocusPointMode}
+has support for face recognition (where the camera supports it), center focus and a custom
+focus where the focus point can be specified.
+
+For camera hardware that supports it, \l {QCameraFocus::FocusMode}{Macro focus} allows
+imaging of things that are close to the sensor.  This is useful in applications like
+barcode recognition, or business card scanning.
+
+In addition to focus, QCameraFocus allows you to control any available optical or
+digital zoom.  In general, optical zoom is higher quality, but more expensive to
+manufacture, so the available zoom range might be limited (or fixed to unity).
+
+\section3 Exposure, aperture, shutter speed and flash
+
+There are a number of settings that affect the amount of light that hits the
+camera sensor, and hence the quality of the resulting image.  The \l QCameraExposure
+class allows you to adjust these settings.  You can use this class to implement
+some techniques like High Dynamic Range (HDR) photos by locking the exposure
+parameters (with \l {QCamera::lock()}), or motion blur by setting slow shutter speeds
+with small apertures.
+
+The main settings for automatic image taking are the \l {QCameraExposure::ExposureMode}{exposure mode}
+and \l {QCameraExposure::FlashMode}{flash mode}.  Several other settings (aperture, ISO setting,
+ shutter speed) are usually managed automatically but can also be overridden if desired.
+
+You can also adjust the \l {QCameraExposure::meteringMode()} to control which parts
+of the camera frame to measure exposure at.  Some camera implementations also allow
+you to specify a specific point that should be used for exposure metering - this is
+useful if you can let the user touch or click on an interesting part of the viewfinder,
+and then use this point so that the image exposure is best at that point.
+
+Finally, you can control the flash hardware (if present) using this class.  In some cases
+the hardware may also double as a torch (typically when the flash is LED based, rather than
+a xenon or other bulb).  See also the \l {Torch} QML element for an easy to use API for
+torch functionality.
+
+\section3 Image processing
+
+The QCameraImageProcessing class lets you adjust the image processing
+part of the pipeline.  This includes the \l {QCameraImageCapture::WhiteBalanceMode}{white balance}
+(or color temperature), \l {QCameraImageCapture::contrast()}{contrast},
+\l {QCameraImageCapture::saturation()}{saturation}, \l {QCameraImageCapture::setSharpening()}{sharpening}
+and \l {QCameraImageCapture::setDenoisingLevel()}{denoising}.  Most cameras support automatic settings
+for all of these, so you shouldn't need to adjust them unless the user wants a specific setting.
+
+If you're taking a series of images (for example, to stitch them together for
+a panoramic image), you should lock the image processing settings so that all the
+images taken appear similar with \i {QCamera::lock(QCamera::LockWhiteBalance)}/
+
+\section3 Cancelling Asynchronous Operations
+
+Various operations such as image capture and auto focusing occur
+asynchrously. These operations can often be cancelled by the start of a new
+operation as long as this is supported by the camera. For image capture,
+the operation can be cancelled by calling
+\l {QCameraImageCapture::cancelCapture()}{cancelCapture()}. For AutoFocus,
+autoexposure or white balance cancellation can be done by calling
+\i {QCamera::unlock(QCamera::LockFocus)}.
+
+\section1 Examples
+
+There are both C++ and QML examples available.
+
+C++ Examples:
+\list
+    \o \l Camera
+\endlist
+
+QML Examples:
+\list
+    \o \l declarative-camera
+    \o \l qmlvideofx
+\endlist
+
+\section1 Reference Documentation
+
+\section2 Camera Classes
+
+\annotatedlist multimedia_camera
+
+\section2 QML Elements
+
+\section2 QML Elements
+
+\list
+    \o \l Radio
+    \o \l RadioData
+\endlist
+
+*/
diff --git a/doc/src/multimedia.qdoc b/doc/src/multimedia.qdoc
deleted file mode 100644
index cd0e402..0000000
--- a/doc/src/multimedia.qdoc
+++ /dev/null
@@ -1,386 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the documentation of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:FDL$
-** GNU Free Documentation License
-** Alternatively, this file may be used under the terms of the GNU Free
-** Documentation License version 1.3 as published by the Free Software
-** Foundation and appearing in the file included in the packaging of
-** this file.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms
-** and conditions contained in a signed written agreement between you
-** and Nokia.
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-/*!
-    \group multimedia
-    \title QtMultimedia
-    APIs to play and record sound, play videos, access camera and radio hardware, and manage media playlists.
-*/
-
-/*!
-
-\page multimedia.html
-\title Multimedia
-\brief Provides a set of APIs to play and record sound, play videos, access camera and radio hardware, and manage media playlists.
-
-Multimedia provides a set of APIs that allow the developer to play, record
-and manage a collection of media content. It also allows access and control to camera
-or analog radio hardware.
-
-\tableofcontents
-
-\section1 Overview
-
-This API delivers an easy to use interface to multimedia functions. The
-developer can use the API to display an image, or a video, record sound or play a
-multimedia stream.
-
-The supplied \l {qtmultimedia examples}{examples} give a good idea at the ease of use of the API. When
-the supporting user interface code is ignored we can see that functionality
-is immediately available with minimal effort.
-
-\section2 Audio
-
-The Audio Recorder example is a good introduction to the basic use of the API. We will use snippets from this example to illustrate how to use the
-API to quickly build functionality.
-
-The first step is to demonstrate recording audio to a file. When recording from an audio source there are a number of things we may want to control beyond the essential user interface. We may want a particular encoding of the file, MP3 or Ogg Vorbis for instance, or select a different input source. The user may modify the bitrate, number of channels, quality and sample rate. Here the example will only modify the codec and the source device, since they are essential.
-
-To begin, the developer sets up an audio recorder object. A
-\l{QAudioRecorder} object is created. The output file name is then set for the \l{QMediaRecorder} object.
-
-\code
-    audioRecorder = new QAudioRecorder;
-    audioRecorder->setOutputLocation(QUrl("test.raw"));
-\endcode
-
-A list of devices is needed so that an input can be selected in the user interface
-
-\code
-    for (int i = 0; i < audioRecorder->deviceCount(); i++)
-        deviceBox->addItem(audiosource->name(i));
-\endcode
-
-and a list of the supported codecs for the user to select a codec,
-
-\code
-    QStringList codecs = audioRecorder->supportedAudioCodecs();
-    for (int i = 0; i < codecs.count(); i++)
-        codecsBox->addItem(codecs.at(i));
-\endcode
-
-To set the selected device or codec just use the index of the device or codec by calling the setter in \i {audiosource} or \i {capture} as appropriate, for example,
-
-\code
-    audioRecorder->setSelectedDevice(i);
-    ...
-    audioRecorder->setAudioCodec(codecIdx);
-\endcode
-
-Now start recording by using the \l {QMediaRecorder}{record()} function from the new \l{QMediaRecorder} object
-
-\code
-    audioRecorder->record();
-\endcode
-
-And stop recording by calling the matching function \l {QMediaRecorder::stop()}{stop()} in \l{QMediaRecorder}.
-
-\code
-    audioRecorder->stop();
-\endcode
-
-How then would this audio file be played? The \l {QMediaPlayer} class will be
-used as a generic player. Since the player can play both video and audio files the interface will be more complex, but for now the example will concentrate on the audio aspect.
-
-Playing the file is simple: create a player object, pass in the filename, set
-the volume or other parameters, then play. Not forgetting that the code will
-need to be hooked up to the user interface.
-
-\code
-    QMediaPlayer *player = new QMediaPlayer;
-    ...
-    player->setMedia(QUrl::fromLocalFile("test.raw"));
-    player->setVolume(50);
-    player->play();
-\endcode
-
-The filename does not have to be a local file. It could be a URL to a
-remote resource. Also by using the \l{QMediaPlaylist} class from this API
-we can play a list of local or remote files. The \l{QMediaPlaylist}
-class supports constructing, managing and playing playlists.
-
-\code
-    player = new QMediaPlayer;
-
-    playlist = new QMediaPlaylist(player);
-    playlist->addMedia(QUrl("http://example.com/myfile1.mp3"));
-    playlist->addMedia(QUrl("http://example.com/myfile2.mp3"));
-    ...
-    playlist->setCurrentPosition(1);
-    player->play();
-\endcode
-
-To manipulate the playlist there are the usual management functions (which are in fact slots): previous, next, setCurrentPosition and shuffle. Playlists can be built, saved and loaded using the API.
-
-
-
-\section2 Video
-
-Continuing with the example discussed for an Audio recorder/player, we can use this to show how to play video files with little change to the code.
-
-Moving from audio to video requires few changes in the sample code. To play a
-video playlist the code can be changed to include another new QtMobility
-Project class: \l{QVideoWidget}. This class enables control of a video
-resource with signals and slots for the control of brightness, contrast,
-hue, saturation and full screen mode.
-
-\code
-    player = new QMediaPlayer;
-
-    playlist = new QMediaPlaylist(player);
-    playlist->addMedia(QUrl("http://example.com/myclip1.mp4"));
-    playlist->addMedia(QUrl("http://example.com/myclip2.mp4"));
-    ...
-    widget = new QVideoWidget(player);
-    widget->show();
-
-    playlist->setCurrentPosition(1);
-    player->play();
-\endcode
-
-The \l {player}{Player} example does things a bit differently to our sample
-code. Instead of using a QVideoWidget object directly, the Player example
-has a \i {VideoWidget} class that inherits from QVideoWidget. This means
-that functions can be added to provide functions such as full screen display,
-either on a double click or on a particular keypress.
-
-\snippet ../../demos/player/player.cpp  2
-
-\omit
-\section2 Radio
-
-QRadioTunerControl is a pure virtual base class that will be the basis for
-any platform specific radio device control. When the functions are
-implemented the developer will be able to quickly produce an application
-that supports the typical uses of an FM radio including tuning, volume,
-start, stop and various other controls.
-\endomit
-
-
-\section1 Camera Support
-
-Creating still images and video.
-
-\section2 Still Images
-
-In order to capture an image we need to create a \l QCamera object and use
-it to initialize a \l QVideoWidget, so we can see where the camera is
-pointing - a viewfinder. The camera object is also used to initialize a new
-QCameraImageCapture object, \i imageCapture. All that is then needed is to start
-the camera, lock it so that the settings are not changed while the image
-capture occurs, capture the image, and finally unlock the camera ready for
-the next photo.
-
-    \code
-            camera = new QCamera;
-            viewFinder = new QCameraViewfinder();
-            viewFinder->show();
-
-            camera->setViewfinder(viewFinder);
-
-            imageCapture = new QCameraImageCapture(camera);
-
-            camera->setCaptureMode(QCamera::CaptureStillImage);
-            camera->start();
-
-            //on half pressed shutter button
-            camera->searchAndLock();
-
-            ...
-
-            //on shutter button pressed
-            imageCapture->capture();
-
-            //on shutter button released
-            camera->unlock();
-    \endcode
-
-\note Alternatively, we could have used a QGraphicsVideoItem as a viewfinder.
-
-
-\section2 Video Clips
-
-Previously we saw code that allowed the capture of a still image. Recording
-video requires the use of a \l QMediaRecorder object.
-
-To record video we need a camera object, as before, a media recorder and a
-viewfinder object. The media recorder object will need to be initialized.
-
-    \code
-    camera = new QCamera;
-    mediaRecorder = new QMediaRecorder(camera);
-
-    camera->setCaptureMode(QCamera::CaptureVideo);
-    camera->start();
-
-    //on shutter button pressed
-    mediaRecorder->record();
-    \endcode
-
-Signals from the \i mediaRecorder can be connected to slots to react to
-changes in the state of the recorder or error events. Recording itself
-starts with the \l {QMediaRecorder::record()}{record()} function of
-mediaRecorder being called, this causes the signal \l
-{QMediaRecorder::stateChanged()}{stateChanged()} to be emitted. The
-recording process can be changed with the \l {QMediaRecorder::record()}{record()},
-\l {QMediaRecorder::pause()}{pause()}, \l {QMediaRecorder::stop()}{stop()} and
-\l {QMediaRecorder::setMuted()}{setMuted()} slots in \l QMediaRecorder.
-
-When the camera is in video mode, as decided by the application, then as the
-shutter button is pressed the camera is locked as before but instead the
-\l {QMediaRecorder::record()}{record()} function in \l QMediaRecorder is used.
-
-
-
-\section2 Focus
-
-Focusing is managed by the classes \l QCameraFocus and \l QCameraFocusControl.
-QCameraFocus allows the developer to set the general policy by means of the
-enums for the \l {QCameraFocus::FocusMode}{FocusMode} and the
-\l {QCameraFocus::FocusPointMode}{FocusPointMode}.
-\l {QCameraFocus::FocusMode}{FocusMode} deals with
-settings such as \l {QCameraFocus::FocusMode}{AutoFocus},
-\l {QCameraFocus::FocusMode}{ContinuousFocus} and
-\l {QCameraFocus::FocusMode}{InfinityFocus}, whereas
-\l {QCameraFocus::FocusPointMode}{FocusPointMode} deals with the various focus zones within the view.
-\l {QCameraFocus::FocusPointMode}{FocusPointMode} has support for face
-recognition, center focus and a custom focus where the focus point can be specified.
-
-
-
-\section2 Canceling Asynchronous Operations
-
-Various operations such as image capture and auto focusing occur
-asynchrously. These operations can often be cancelled by the start of a new
-operation as long as this is supported by the backend. For image capture,
-the operation can be cancelled by calling
-\l {QCameraImageCapture::cancelCapture()}{cancelCapture()}. For \l {QCameraFocus::FocusMode}{auto-focus},
-\l {QCameraExposure::ExposureMode}{auto-exposure} or \l {QCameraImageProcessing::WhiteBalanceMode}{white balance}
-cancellation can be done by calling \l {QCamera::unlock()}{unlock}(QCamera::LockFocus).
-
-
-\target qtmultimedia examples
-\section1 Examples
-
-\section2 Record a Sound Source
-
-\l{audiorecorder}{AudioRecorder} is a demonstration of the discovery of
-the supported devices and codecs and the use of recording functions in the
-QMediaRecorder class.
-
-\section2 Play a Media File
-
-The \l{player}{Player} example is a simple multimedia player. Select a
-video file to play, stop, pause, show in fullscreen or manipulate various
-image attributes using the Color Options button.
-
-\section2 Slide Show
-
-The \l{slideshow}{Slide Show} shows the use of the QMediaImageViewer and
-QVideoWidget classes.
-
-\section2 Camera Example
-
-The \l{Camera Example} shows how use the QtMultimedia API to quickly
-write a camera application in C++.
-
-\section2 QML Camera Example
-
-The \l {QML Camera Example} demonstrates still image capture and controls
-using the QML plugin. Video recording is not currently available.
-
-\section2 QML Video Example
-
-The \l {video/qmlvideo}{QML Video Example} demonstrates the various manipulations
-(move; resize; rotate; change aspect ratio) which can be applied to QML
-\l {VideoOutput} items.
-
-It also shows how native code can be combined with QML to implement more
-advanced functionality - in this case, C++ code is used to calculate the QML
-frame rate.  This value is rendered in QML as a semi-transparent item overlaid
-on the video content.
-
-\section2 QML Video Shader Effects Example
-The \l {video/qmlvideofx}{QML Video Shader Effects Example} shows how the
-\l {ShaderEffect} element can be used to apply postprocessing effects,
-expressed in GLSL, to QML \l {VideoOutput} items.
-
-It re-uses the frame rate display code used by the \l {QML Video Example}.
-
-Finally, this application demonstrates the use of different top-level QML
-files to handle different physical screen sizes.  On small-screen devices,
-menus are by default hidden, and only appear when summoned by a gesture.
-Large-screen devices show a more traditional layout in which menus are
-displayed around the video content pane.
-
-
-\section1 Reference documentation
-
-\section2 Core classes
-
-\annotatedlist multimedia_core
-
-\section2 Media playback classes
-
-\annotatedlist multimedia_playback
-
-\section2 Camera classes
-
-\annotatedlist multimedia_camera
-
-\section2 Radio classes
-
-\annotatedlist multimedia_radio
-
-\section2 Media recording classes
-
-\annotatedlist multimedia_recording
-
-\section2 Low level Audio related classes
-
-\annotatedlist multimedia_audio
-
-\section2 Low level Video related classes
-
-\annotatedlist multimedia_video
-
-\section2 QML Elements
-\annotatedlist multimedia_qml
-
-See also \l{Multimedia QML Plugin}
-
-\section2 Advanced usage.
-
-For developers wishing to access some platform specific settings, or to
-port the Qt Multimedia APIs to a new platform or technology, see \l{Multimedia Backend Development}.
-
-*
-***/
-
-
-
diff --git a/doc/src/multimediaoverview.qdoc b/doc/src/multimediaoverview.qdoc
new file mode 100644
index 0000000..440a9fe
--- /dev/null
+++ b/doc/src/multimediaoverview.qdoc
@@ -0,0 +1,158 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the documentation of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:FDL$
+** GNU Free Documentation License
+** Alternatively, this file may be used under the terms of the GNU Free
+** Documentation License version 1.3 as published by the Free Software
+** Foundation and appearing in the file included in the packaging of
+** this file.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms
+** and conditions contained in a signed written agreement between you
+** and Nokia.
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+
+\page multimediaoverview.html
+\title Multimedia Overview
+\brief A set of APIs for working with audio, video, radio and camera devices.
+
+\section1 Multimedia Features
+
+Qt Multimedia offers APIs for doing many multimedia related tasks:
+
+\list
+\o Accessing raw audio devices for input and output
+\o Play low latency sound effects
+\o Play media files in playlists (like compressed audio, or video files)
+\o Record audio and compress it
+\o Tune and listen to radio stations, and receive radio program information
+\o Use a camera, including viewfinder, image capture, and movie recording
+\endlist
+
+\section1 Multimedia Components
+
+All of these tasks can be broadly broken down into four main areas.  More information
+(including background information and class references) are available here:
+
+\list
+\o \l {Audio Overview}
+\o \l {Video Overview}
+\o \l {Camera Overview}
+\o \l {Radio Overview}
+\endlist
+
+\section1 Multimedia recipes
+For some quick recipes for specific tasks, look at the overviews above and consult this table:
+
+\table 70%
+    \header
+        \o Use case
+        \o Examples
+        \o QML Classes
+        \o C++ Classes
+    \row
+        \o Playing a sound effect
+        \o TBD
+        \o SoundEffect
+        \o QSoundEffect
+    \row
+        \o Playing low latency audio
+        \o audiooutput, spectrum
+        \o
+        \o QAudioOutput
+    \row
+        \o Playing encoded audio (MP3, AAC etc)
+        \o player
+        \o Audio, MediaPlayer
+        \o QMediaPlayer
+    \row
+        \o Accessing raw audio input data
+        \o spectrum, audioinput
+        \o
+        \o QAudioInput
+    \row
+        \o Recording encoded audio data
+        \o audiorecorder
+        \o
+        \o QAudioRecorder
+    \row
+        \o Discovering raw audio devices
+        \o audiodevices
+        \o
+        \o QAudioDeviceInfo
+    \row
+        \o Video Playback
+        \o player, qmlvideo, qmlvideofx
+        \o MediaPlayer, VideoOutput, Video
+        \o QMediaPlayer, QVideoWidget, QGraphicsVideoItem
+    \row
+        \o Video Processing
+        \o qmlvideofx
+        \o MediaPlayer, VideoOutput
+        \o QMediaPlayer, QAbstractVideoSurface, QVideoFrame
+    \row
+        \o Listening to the radio
+        \o radio, declarative-radio
+        \o Radio, RadioData
+        \o QRadioTuner, QRadioData
+    \row
+        \o Accessing camera viewfinder
+        \o camera, declarative-camera
+        \o Camera, VideoOutput
+        \o QCamera, QVideoWidget, QGraphicsVideoItem
+    \row
+        \o Viewfinder processing
+        \o
+        \o Camera, VideoOutput
+        \o QCamera, QAbstractVideoSurface, QVideoFrame
+    \row
+        \o Capturing photos
+        \o camera, declarative-camera
+        \o Camera
+        \o QCamera, QCameraImageCapture
+    \row
+        \o Capturing movies
+        \o camera, declarative-camera
+        \o Camera
+        \o QCamera, QMediaRecorder
+\endtable
+
+\section1 Multimedia Limitations
+
+In many cases the Qt Multimedia APIs build upon the multimedia framework of the underlying system.
+This can mean that support for various codec or containers can vary between machines,
+depending on what the end user has installed.  See \l {Multimedia Platform Support} for more
+information on what frameworks are used and what this can mean.
+
+\section1 Advanced Usage
+
+For developers wishing to access some platform specific settings,
+or to port the Qt Multimedia APIs to a new platform or technology,
+see \l{Multimedia Backend Development}.
+
+\section1 Reference Documentation
+
+\section2 QML Elements
+
+\annotatedlist multimedia_qml
+
+\section2 Multimedia Classes
+
+\annotatedlist multimedia
+
+*/
diff --git a/doc/src/radiooverview.qdoc b/doc/src/radiooverview.qdoc
index b49281b..b7ec44d 100644
--- a/doc/src/radiooverview.qdoc
+++ b/doc/src/radiooverview.qdoc
@@ -31,9 +31,9 @@
 \title Radio Overview
 \brief An API to control system radio tuner
 
-The Radio API provides control over the radio tuner of the system, and
-gives access to Radio Data System (RDS) information for radio stations that
-broadcasts it.
+The Qt Multimedia API provides a number of radio related classes for control
+over the radio tuner of the system, and gives access to Radio Data System
+(RDS) information for radio stations that broadcasts it.
 
 \section1 Radio Features
 
@@ -78,12 +78,9 @@ current frequency inside the band.
 
 \section1 Reference documentation
 
-\section2 Radio Classes
+\section2 Radio C++ Classes
 
-\list
-    \o \l QRadioTuner
-    \o \l QRadioData
-\endlist
+\annotatedlist multimedia_radio
 
 \section2 QML Elements
 
diff --git a/doc/src/snippets/multimedia-snippets/camera.cpp b/doc/src/snippets/multimedia-snippets/camera.cpp
index ab91423..a42ae62 100644
--- a/doc/src/snippets/multimedia-snippets/camera.cpp
+++ b/doc/src/snippets/multimedia-snippets/camera.cpp
@@ -46,14 +46,92 @@
 #include "qmediarecorder.h"
 #include "qcameraimagecapture.h"
 #include "qcameraimageprocessing.h"
+#include "qabstractvideosurface.h"
 
-void camera()
+/* Globals so that everything is consistent. */
+QCamera *camera = 0;
+QCameraViewfinder *viewfinder = 0;
+QMediaRecorder *recorder = 0;
+QCameraImageCapture *imageCapture = 0;
+
+void overview_viewfinder()
+{
+    //! [Camera overview viewfinder]
+    camera = new QCamera;
+    viewfinder = new QCameraViewfinder;
+    camera->setViewfinder(viewfinder);
+    viewfinder->show();
+
+    camera->start(); // to start the viewfinder
+    //! [Camera overview viewfinder]
+}
+
+// -.-
+class MyVideoSurface : public QAbstractVideoSurface
 {
-    QCamera *camera = 0;
-    QCameraViewfinder *viewfinder = 0;
-    QMediaRecorder *recorder = 0;
-    QCameraImageCapture *imageCapture = 0;
+    QList<QVideoFrame::PixelFormat> supportedPixelFormats(QAbstractVideoBuffer::HandleType handleType) const
+    {
+        Q_UNUSED(handleType);
+        return QList<QVideoFrame::PixelFormat>();
+    }
+    bool present(const QVideoFrame &frame)
+    {
+        Q_UNUSED(frame);
+        return true;
+    }
+};
 
+void overview_surface()
+{
+    MyVideoSurface *mySurface;
+    //! [Camera overview surface]
+    camera = new QCamera;
+    mySurface = new MyVideoSurface;
+    camera->setViewfinder(mySurface);
+
+    camera->start();
+    // MyVideoSurface::present(..) will be called with viewfinder frames
+    //! [Camera overview surface]
+}
+
+void overview_still()
+{
+    //! [Camera overview capture]
+    imageCapture = new QCameraImageCapture(camera);
+
+    camera->setCaptureMode(QCamera::CaptureStillImage);
+    camera->start(); // Viewfinder frames start flowing
+
+    //on half pressed shutter button
+    camera->searchAndLock();
+
+    //on shutter button pressed
+    imageCapture->capture();
+
+    //on shutter button released
+    camera->unlock();
+    //! [Camera overview surface]
+}
+
+void overview_movie()
+{
+    //! [Camera overview movie]
+    camera = new QCamera;
+    recorder = new QMediaRecorder(camera);
+
+    camera->setCaptureMode(QCamera::CaptureVideo);
+    camera->start();
+
+    //on shutter button pressed
+    recorder->record();
+
+    // sometime later, or on another press
+    recorder->stop();
+    //! [Camera overview movie]
+}
+
+void camera_blah()
+{
     //! [Camera]
     camera = new QCamera;
 
@@ -62,7 +140,6 @@ void camera()
 
     camera->setViewfinder(viewfinder);
 
-    recorder = new QMediaRecorder(camera);
     imageCapture = new QCameraImageCapture(camera);
 
     camera->setCaptureMode(QCamera::CaptureStillImage);
@@ -83,8 +160,6 @@ void camera()
 
 void cameraimageprocessing()
 {
-    QCamera *camera = 0;
-
     //! [Camera image whitebalance]
     camera = new QCamera;
     QCameraImageProcessing *imageProcessing = camera->imageProcessing();
@@ -103,8 +178,6 @@ void cameraimageprocessing()
 
 void camerafocus()
 {
-    QCamera *camera = 0;
-
     //! [Camera custom zoom]
     QCameraFocus *focus = camera->focus();
     focus->setFocusPointMode(QCameraFocus::FocusPointCustom);
diff --git a/doc/src/snippets/multimedia-snippets/media.cpp b/doc/src/snippets/multimedia-snippets/media.cpp
index 005e25f..571fea2 100644
--- a/doc/src/snippets/multimedia-snippets/media.cpp
+++ b/doc/src/snippets/multimedia-snippets/media.cpp
@@ -169,6 +169,25 @@ void MediaExample::MediaPlayer()
     player->play();
     //! [Player]
 
+    //! [Local playback]
+    player = new QMediaPlayer;
+    // ...
+    player->setMedia(QUrl::fromLocalFile("/Users/me/Music/coolsong.mp3"));
+    player->setVolume(50);
+    player->play();
+    //! [Local playback]
+
+    //! [Audio playlist]
+    player = new QMediaPlayer;
+
+    playlist = new QMediaPlaylist(player);
+    playlist->addMedia(QUrl("http://example.com/myfile1.mp3"));
+    playlist->addMedia(QUrl("http://example.com/myfile2.mp3"));
+    // ...
+    playlist->setCurrentIndex(1);
+    player->play();
+    //! [Audio playlist]
+
     //! [Movie playlist]
     playlist = new QMediaPlaylist;
     playlist->addMedia(QUrl("http://example.com/movie1.mp4"));
@@ -194,7 +213,7 @@ void MediaExample::MediaRecorder()
     recorder = new QMediaRecorder(camera);
 
     QAudioEncoderSettings audioSettings;
-    audioSettings.setCodec("audio/vorbis");
+    audioSettings.setCodec("audio/amr");
     audioSettings.setQuality(QtMultimedia::HighQuality);
 
     recorder->setEncodingSettings(audioSettings);
@@ -202,6 +221,21 @@ void MediaExample::MediaRecorder()
     recorder->setOutputLocation(QUrl::fromLocalFile(fileName));
     recorder->record();
     //! [Media recorder]
+
+#if 0
+    //! [Audio recorder]
+    audioRecorder = new QAudioRecorder;
+
+    QAudioEncoderSettings audioSettings;
+    audioSettings.setCodec("audio/amr");
+    audioSettings.setQuality(QtMultimedia::HighQuality);
+
+    audioRecorder->setEncodingSettings(audioSettings);
+
+    audioRecorder->setOutputLocation(QUrl::fromLocalFile("test.amr"));
+    audioRecorder->record();
+    //! [Audio recorder]
+#endif
 }
 
 void MediaExample::RadioTuna()
diff --git a/doc/src/snippets/multimedia-snippets/player.cpp b/doc/src/snippets/multimedia-snippets/player.cpp
deleted file mode 100644
index 84d09c0..0000000
--- a/doc/src/snippets/multimedia-snippets/player.cpp
+++ /dev/null
@@ -1,317 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Mobility Components.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "player.h"
-
-#include "playercontrols.h"
-#include "playlistmodel.h"
-#include "videowidget.h"
-
-#include <qmediaservice.h>
-#include <qmediaplaylist.h>
-
-#include <QtWidgets>
-
-Player::Player(QWidget *parent)
-    : QWidget(parent)
-    , videoWidget(0)
-    , coverLabel(0)
-    , slider(0)
-    , colorDialog(0)
-{
-//! [create-objs]
-    player = new QMediaPlayer;
-    playlist = new QMediaPlaylist(player);
-//! [create-objs]
-
-    connect(player, SIGNAL(durationChanged(qint64)), SLOT(durationChanged(qint64)));
-    connect(player, SIGNAL(positionChanged(qint64)), SLOT(positionChanged(qint64)));
-    connect(player, SIGNAL(metaDataChanged()), SLOT(metaDataChanged()));
-    connect(playlist, SIGNAL(playlistPositionChanged(int)), SLOT(playlistPositionChanged(int)));
-    connect(player, SIGNAL(mediaStatusChanged(QMediaPlayer::MediaStatus)),
-            this, SLOT(statusChanged(QMediaPlayer::MediaStatus)));
-    connect(player, SIGNAL(bufferStatusChanged(int)), this, SLOT(bufferingProgress(int)));
-
-    videoWidget = new VideoWidget(player);
-
-    playlistModel = new PlaylistModel(this);
-    playlistModel->setPlaylist(playlist);
-
-    playlistView = new QListView;
-    playlistView->setModel(playlistModel);
-    playlistView->setCurrentIndex(playlistModel->index(playlist->currentPosition(), 0));
-
-    connect(playlistView, SIGNAL(activated(QModelIndex)), this, SLOT(jump(QModelIndex)));
-
-    slider = new QSlider(Qt::Horizontal);
-    slider->setRange(0, player->duration() / 1000);
-
-    connect(slider, SIGNAL(sliderMoved(int)), this, SLOT(seek(int)));
-
-    QPushButton *openButton = new QPushButton(tr("Open"));
-
-    connect(openButton, SIGNAL(clicked()), this, SLOT(open()));
-
-    PlayerControls *controls = new PlayerControls;
-    controls->setState(player->state());
-    controls->setVolume(player->volume());
-    controls->setMuted(controls->isMuted());
-
-    connect(controls, SIGNAL(play()), player, SLOT(play()));
-    connect(controls, SIGNAL(pause()), player, SLOT(pause()));
-    connect(controls, SIGNAL(stop()), player, SLOT(stop()));
-    connect(controls, SIGNAL(next()), playlist, SLOT(next()));
-    connect(controls, SIGNAL(previous()), playlist, SLOT(previous()));
-    connect(controls, SIGNAL(changeVolume(int)), player, SLOT(setVolume(int)));
-    connect(controls, SIGNAL(changeMuting(bool)), player, SLOT(setMuted(bool)));
-    connect(controls, SIGNAL(changeRate(qreal)), player, SLOT(setPlaybackRate(qreal)));
-
-    connect(player, SIGNAL(stateChanged(QMediaPlayer::State)),
-            controls, SLOT(setState(QMediaPlayer::State)));
-    connect(player, SIGNAL(volumeChanged(int)), controls, SLOT(setVolume(int)));
-    connect(player, SIGNAL(mutingChanged(bool)), controls, SLOT(setMuted(bool)));
-
-    QPushButton *fullScreenButton = new QPushButton(tr("FullScreen"));
-    fullScreenButton->setCheckable(true);
-
-    if (videoWidget != 0) {
-        connect(fullScreenButton, SIGNAL(clicked(bool)), videoWidget, SLOT(setFullScreen(bool)));
-        connect(videoWidget, SIGNAL(fullScreenChanged(bool)),
-                fullScreenButton, SLOT(setChecked(bool)));
-    } else {
-        fullScreenButton->setEnabled(false);
-    }
-
-    QPushButton *colorButton = new QPushButton(tr("Color Options..."));
-    if (videoWidget)
-        connect(colorButton, SIGNAL(clicked()), this, SLOT(showColorDialog()));
-    else
-        colorButton->setEnabled(false);
-
-    QBoxLayout *displayLayout = new QHBoxLayout;
-    if (videoWidget)
-        displayLayout->addWidget(videoWidget, 2);
-    else
-        displayLayout->addWidget(coverLabel, 2);
-    displayLayout->addWidget(playlistView);
-
-    QBoxLayout *controlLayout = new QHBoxLayout;
-    controlLayout->setMargin(0);
-    controlLayout->addWidget(openButton);
-    controlLayout->addStretch(1);
-    controlLayout->addWidget(controls);
-    controlLayout->addStretch(1);
-    controlLayout->addWidget(fullScreenButton);
-    controlLayout->addWidget(colorButton);
-
-    QBoxLayout *layout = new QVBoxLayout;
-    layout->addLayout(displayLayout);
-    layout->addWidget(slider);
-    layout->addLayout(controlLayout);
-
-    setLayout(layout);
-
-    metaDataChanged();
-}
-
-Player::~Player()
-{
-    delete playlist;
-    delete player;
-}
-
-void Player::open()
-{
-    QStringList fileNames = QFileDialog::getOpenFileNames();
-    foreach (QString const &fileName, fileNames)
-        playlist->appendItem(QUrl::fromLocalFile(fileName));
-}
-
-void Player::durationChanged(qint64 duration)
-{
-    slider->setMaximum(duration / 1000);
-}
-
-void Player::positionChanged(qint64 progress)
-{
-    slider->setValue(progress / 1000);
-}
-
-void Player::metaDataChanged()
-{
-    //qDebug() << "update metadata" << player->metaData(QtMultimedia::MetaData::Title).toString();
-    if (player->isMetaDataAvailable()) {
-        setTrackInfo(QString("%1 - %2")
-                .arg(player->metaData(QtMultimedia::MetaData::AlbumArtist).toString())
-                .arg(player->metaData(QtMultimedia::MetaData::Title).toString()));
-
-        if (coverLabel) {
-            QUrl url = player->metaData(QtMultimedia::MetaData::CoverArtUrlLarge).value<QUrl>();
-
-            coverLabel->setPixmap(!url.isEmpty()
-                    ? QPixmap(url.toString())
-                    : QPixmap());
-        }
-    }
-}
-
-void Player::jump(const QModelIndex &index)
-{
-    if (index.isValid()) {
-        playlist->setCurrentPosition(index.row());
-    }
-}
-
-void Player::playlistPositionChanged(int currentItem)
-{
-    playlistView->setCurrentIndex(playlistModel->index(currentItem, 0));
-}
-
-void Player::seek(int seconds)
-{
-    player->setPosition(seconds * 1000);
-}
-
-void Player::statusChanged(QMediaPlayer::MediaStatus status)
-{
-    switch (status) {
-    case QMediaPlayer::UnknownMediaStatus:
-    case QMediaPlayer::NoMedia:
-    case QMediaPlayer::LoadedMedia:
-    case QMediaPlayer::BufferingMedia:
-    case QMediaPlayer::BufferedMedia:
-#ifndef QT_NO_CURSOR
-        unsetCursor();
-#endif
-        setStatusInfo(QString());
-        break;
-    case QMediaPlayer::LoadingMedia:
-#ifndef QT_NO_CURSOR
-        setCursor(QCursor(Qt::BusyCursor));
-#endif
-        setStatusInfo(tr("Loading..."));
-        break;
-    case QMediaPlayer::StalledMedia:
-#ifndef QT_NO_CURSOR
-        setCursor(QCursor(Qt::BusyCursor));
-#endif
-        break;
-    case QMediaPlayer::EndOfMedia:
-#ifndef QT_NO_CURSOR
-        unsetCursor();
-#endif
-        setStatusInfo(QString());
-        QApplication::alert(this);
-        break;
-    case QMediaPlayer::InvalidMedia:
-#ifndef QT_NO_CURSOR
-        unsetCursor();
-#endif
-        setStatusInfo(player->errorString());
-        break;
-    }
-}
-
-void Player::bufferingProgress(int progress)
-{
-    setStatusInfo(tr("Buffering %4%%").arg(progress));
-}
-
-void Player::setTrackInfo(const QString &info)
-{
-    trackInfo = info;
-
-    if (!statusInfo.isEmpty())
-        setWindowTitle(QString("%1 | %2").arg(trackInfo).arg(statusInfo));
-    else
-        setWindowTitle(trackInfo);
-
-}
-
-void Player::setStatusInfo(const QString &info)
-{
-    statusInfo = info;
-
-    if (!statusInfo.isEmpty())
-        setWindowTitle(QString("%1 | %2").arg(trackInfo).arg(statusInfo));
-    else
-        setWindowTitle(trackInfo);
-}
-
-void Player::showColorDialog()
-{
-    if (!colorDialog) {
-        QSlider *brightnessSlider = new QSlider(Qt::Horizontal);
-        brightnessSlider->setRange(-100, 100);
-        brightnessSlider->setValue(videoWidget->brightness());
-        connect(brightnessSlider, SIGNAL(sliderMoved(int)), videoWidget, SLOT(setBrightness(int)));
-        connect(videoWidget, SIGNAL(brightnessChanged(int)), brightnessSlider, SLOT(setValue(int)));
-
-        QSlider *contrastSlider = new QSlider(Qt::Horizontal);
-        contrastSlider->setRange(-100, 100);
-        contrastSlider->setValue(videoWidget->contrast());
-        connect(contrastSlider, SIGNAL(sliderMoved(int)), videoWidget, SLOT(setContrast(int)));
-        connect(videoWidget, SIGNAL(contrastChanged(int)), contrastSlider, SLOT(setValue(int)));
-
-        QSlider *hueSlider = new QSlider(Qt::Horizontal);
-        hueSlider->setRange(-100, 100);
-        hueSlider->setValue(videoWidget->hue());
-        connect(hueSlider, SIGNAL(sliderMoved(int)), videoWidget, SLOT(setHue(int)));
-        connect(videoWidget, SIGNAL(hueChanged(int)), hueSlider, SLOT(setValue(int)));
-
-        QSlider *saturationSlider = new QSlider(Qt::Horizontal);
-        saturationSlider->setRange(-100, 100);
-        saturationSlider->setValue(videoWidget->saturation());
-        connect(saturationSlider, SIGNAL(sliderMoved(int)), videoWidget, SLOT(setSaturation(int)));
-        connect(videoWidget, SIGNAL(saturationChanged(int)), saturationSlider, SLOT(setValue(int)));
-
-        QFormLayout *layout = new QFormLayout;
-        layout->addRow(tr("Brightness"), brightnessSlider);
-        layout->addRow(tr("Contrast"), contrastSlider);
-        layout->addRow(tr("Hue"), hueSlider);
-        layout->addRow(tr("Saturation"), saturationSlider);
-
-        colorDialog = new QDialog(this);
-        colorDialog->setWindowTitle(tr("Color Options"));
-        colorDialog->setLayout(layout);
-    }
-    colorDialog->show();
-}
diff --git a/doc/src/snippets/multimedia-snippets/video.cpp b/doc/src/snippets/multimedia-snippets/video.cpp
index 740635f..26d6424 100644
--- a/doc/src/snippets/multimedia-snippets/video.cpp
+++ b/doc/src/snippets/multimedia-snippets/video.cpp
@@ -47,6 +47,7 @@
 #include "qvideowidgetcontrol.h"
 #include "qvideowindowcontrol.h"
 #include "qgraphicsvideoitem.h"
+#include "qmediaplaylist.h"
 
 #include <QFormLayout>
 #include <QGraphicsView>
@@ -63,6 +64,7 @@ public:
 private:
     // Common naming
     QMediaService *mediaService;
+    QMediaPlaylist *playlist;
     QVideoWidget *videoWidget;
     QWidget *widget;
     QFormLayout *layout;
@@ -85,12 +87,15 @@ void VideoExample::VideoWidget()
     //! [Video widget]
     player = new QMediaPlayer;
 
-    videoWidget = new QVideoWidget;
+    playlist = new QMediaPlaylist(player);
+    playlist->addMedia(QUrl("http://example.com/myclip1.mp4"));
+    playlist->addMedia(QUrl("http://example.com/myclip2.mp4"));
 
+    videoWidget = new QVideoWidget;
     player->setVideoOutput(videoWidget);
-    player->setMedia(QUrl("http://example.com/movie.mp4"));
 
     videoWidget->show();
+    playlist->setCurrentIndex(1);
     player->play();
     //! [Video widget]
 }
@@ -123,7 +128,7 @@ void VideoExample::VideoGraphicsItem()
     graphicsView->scene()->addItem(item);
     graphicsView->show();
 
-    player->setMedia(video);
+    player->setMedia(QUrl("http://example.com/myclip4.ogv"));
     player->play();
     //! [Video graphics item]
 }
diff --git a/doc/src/videooverview.qdoc b/doc/src/videooverview.qdoc
new file mode 100644
index 0000000..b45fa0d
--- /dev/null
+++ b/doc/src/videooverview.qdoc
@@ -0,0 +1,124 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the documentation of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:FDL$
+** GNU Free Documentation License
+** Alternatively, this file may be used under the terms of the GNU Free
+** Documentation License version 1.3 as published by the Free Software
+** Foundation and appearing in the file included in the packaging of
+** this file.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms
+** and conditions contained in a signed written agreement between you
+** and Nokia.
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+
+\page videooverview.html
+\title Video Overview
+\brief Video playback
+
+\section1 Video Features
+
+Qt Multimedia offers both high and low level C++ classes for playing and
+manipulating video data, and QML elements for playback and control.  Some
+of these classes also overlap with both \l {Camera Overview}{camera} and
+\l {Audio Overview}{audio} classes, which can be useful.
+
+\section1 Video Implementation Details
+
+\target multimedia-playing-video
+\section2 Playing video in C++
+
+You can use the \l QMediaPlayer class to decode a video file, and display
+it using \l QVideoWidget, \l QGraphicsVideoItem, or a custom class.
+
+Here's an example of using QVideoWidget:
+    \snippet doc/src/snippets/multimedia-snippets/video.cpp Video widget
+
+And an example with QGraphicsVideoItem:
+    \snippet doc/src/snippets/multimedia-snippets/video.cpp Video graphics item
+
+\section2 Playing video in QML
+
+You can use the \l VideoOutput QML element to render content that is
+provided by either a \l MediaPlayer element or a \l Camera element.
+The VideoOutput element is a visual element that can be transformed
+or acted upon by shaders (as the \l {qmlvideofx} example shows), while
+all media decoding and playback control is handled by the MediaPlayer
+element.
+
+Alternatively there is also a higher level \l Video element that
+acts as a single, visual element to play video and control playback.
+
+\section2 Working with low level video frames
+
+Qt Multimedia offers a number of low level classes to make handling
+video frames a bit easier.  These classes are primarily used when
+writing code that processes video or camera frames (for example,
+detecting barcodes, or applying a fancy vignette effect), or needs
+to display video in a special way that is otherwise unsupported.
+
+The \l QVideoFrame class encapsulates a video frame and allows the
+contents to be mapped into system memory for manipulation or
+processing, while deriving a class from \l QAbstractVideoSurface
+allows you to receive these frames from \l QMediaPlayer and
+\l QCamera.  Several of the built in Qt classes offer this functionality
+as well, so if you decode video in your application, you can present
+it to classes that offer a \l QVideoRendererControl class, and in QML
+you can set a custom object for the source of the \l VideoOutput element
+with either a writable \c videoSurface property (that the element will
+set it's internal video surface to) or a readable \c mediaObject property
+with a QMediaObject derived class that implements the \l QVideoRendererControl
+interface.
+
+\section2 Recording video
+You can use the \l QMediaRecorder class in conjunction with other
+classes to record video to disk.  Primarily this is used with
+the camera, so consult the \l {Camera Overview} for more information.
+
+\section1 Examples
+
+There are both C++ and QML examples available.
+
+C++ Examples:
+\list
+    \o \l video
+    \o \l videographicsitem
+    \o \l videowidget
+\endlist
+
+QML Examples:
+\list
+    \o \l qmlvideo
+    \o \l qmlvideofx
+\endlist
+
+\section1 Reference Documentation
+
+\section2 Video Classes
+
+\annotatedlist multimedia_video
+
+\section2 QML Elements
+
+\list
+    \o \l MediaPlayer
+    \o \l VideoOutput
+    \o \l Video
+\endlist
+
+*/
diff --git a/src/multimedia/camera/qcamera.cpp b/src/multimedia/camera/qcamera.cpp
index dab990c..f8f7c85 100644
--- a/src/multimedia/camera/qcamera.cpp
+++ b/src/multimedia/camera/qcamera.cpp
@@ -87,6 +87,8 @@ QT_BEGIN_NAMESPACE
     QCamera can be used with QVideoWidget for viewfinder display,
     QMediaRecorder for video recording and QCameraImageCapture for image taking.
 
+    See the \l{Camera Overview}{camera overview} for more information.
+
     \snippet doc/src/snippets/multimedia-snippets/media.cpp Request control
 
 */