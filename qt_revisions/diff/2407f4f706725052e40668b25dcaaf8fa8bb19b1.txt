diff --git a/src/platformsupport/fb_base/fb_base.cpp b/src/platformsupport/fb_base/fb_base.cpp
deleted file mode 100644
index a796811..0000000
--- a/src/platformsupport/fb_base/fb_base.cpp
+++ /dev/null
@@ -1,507 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "fb_base_p.h"
-#include <qpainter.h>
-#include <qdebug.h>
-#include <qbitmap.h>
-#include <qpa/qplatformcursor.h>
-#include <qpa/qwindowsysteminterface.h>
-
-QPlatformSoftwareCursor::QPlatformSoftwareCursor(QPlatformScreen *scr)
-        : QPlatformCursor(scr), currentRect(QRect()), prevRect(QRect())
-{
-    graphic = new QPlatformCursorImage(0, 0, 0, 0, 0, 0);
-    setCursor(Qt::ArrowCursor);
-}
-
-QRect QPlatformSoftwareCursor::getCurrentRect()
-{
-    QRect rect = graphic->image()->rect().translated(-graphic->hotspot().x(),
-                                                     -graphic->hotspot().y());
-    rect.translate(QCursor::pos());
-    QPoint screenOffset = screen->geometry().topLeft();
-    rect.translate(-screenOffset);  // global to local translation
-    return rect;
-}
-
-
-void QPlatformSoftwareCursor::pointerEvent(const QMouseEvent & e)
-{
-    Q_UNUSED(e);
-    QPoint screenOffset = screen->geometry().topLeft();
-    currentRect = getCurrentRect();
-    // global to local translation
-    if (onScreen || screen->geometry().intersects(currentRect.translated(screenOffset))) {
-        setDirty();
-    }
-}
-
-QRect QPlatformSoftwareCursor::drawCursor(QPainter & painter)
-{
-    dirty = false;
-    if (currentRect.isNull())
-        return QRect();
-
-    // We need this because the cursor might be dirty due to moving off screen
-    QPoint screenOffset = screen->geometry().topLeft();
-    // global to local translation
-    if (!currentRect.translated(screenOffset).intersects(screen->geometry()))
-        return QRect();
-
-    prevRect = currentRect;
-    painter.drawImage(prevRect, *graphic->image());
-    onScreen = true;
-    return prevRect;
-}
-
-QRect QPlatformSoftwareCursor::dirtyRect()
-{
-    if (onScreen) {
-        onScreen = false;
-        return prevRect;
-    }
-    return QRect();
-}
-
-void QPlatformSoftwareCursor::setCursor(Qt::CursorShape shape)
-{
-    graphic->set(shape);
-}
-
-void QPlatformSoftwareCursor::setCursor(const QImage &image, int hotx, int hoty)
-{
-    graphic->set(image, hotx, hoty);
-}
-
-void QPlatformSoftwareCursor::setCursor(const uchar *data, const uchar *mask, int width, int height, int hotX, int hotY)
-{
-    graphic->set(data, mask, width, height, hotX, hotY);
-}
-
-void QPlatformSoftwareCursor::changeCursor(QCursor * widgetCursor, QWidget * widget)
-{
-    Q_UNUSED(widget);
-    Qt::CursorShape shape = widgetCursor->shape();
-
-    if (shape == Qt::BitmapCursor) {
-        // application supplied cursor
-        QPoint spot = widgetCursor->hotSpot();
-        setCursor(widgetCursor->pixmap().toImage(), spot.x(), spot.y());
-    } else {
-        // system cursor
-        setCursor(shape);
-    }
-    currentRect = getCurrentRect();
-    QPoint screenOffset = screen->geometry().topLeft(); // global to local translation
-    if (onScreen || screen->geometry().intersects(currentRect.translated(screenOffset)))
-        setDirty();
-}
-
-QFbScreen::QFbScreen() : cursor(0), mGeometry(), mDepth(16), mFormat(QImage::Format_RGB16), mScreenImage(0), compositePainter(0), isUpToDate(false)
-{
-    mScreenImage = new QImage(mGeometry.size(), mFormat);
-    redrawTimer.setSingleShot(true);
-    redrawTimer.setInterval(0);
-    QObject::connect(&redrawTimer, SIGNAL(timeout()), this, SLOT(doRedraw()));
-}
-
-void QFbScreen::setGeometry(QRect rect)
-{
-    delete mScreenImage;
-    mGeometry = rect;
-    mScreenImage = new QImage(mGeometry.size(), mFormat);
-    delete compositePainter;
-    compositePainter = 0;
-    invalidateRectCache();
-}
-
-void QFbScreen::setDepth(int depth)
-{
-    mDepth = depth;
-}
-
-void QFbScreen::setPhysicalSize(QSize size)
-{
-    mPhysicalSize = size;
-}
-
-void QFbScreen::setFormat(QImage::Format format)
-{
-    mFormat = format;
-    delete mScreenImage;
-    mScreenImage = new QImage(mGeometry.size(), mFormat);
-    delete compositePainter;
-    compositePainter = 0;
-}
-
-QFbScreen::~QFbScreen()
-{
-    delete compositePainter;
-    delete mScreenImage;
-}
-
-void QFbScreen::setDirty(const QRect &rect)
-{
-    QRect intersection = rect.intersected(mGeometry);
-    QPoint screenOffset = mGeometry.topLeft();
-    repaintRegion += intersection.translated(-screenOffset);    // global to local translation
-    if (!redrawTimer.isActive()) {
-        redrawTimer.start();
-    }
-}
-
-void QFbScreen::generateRects()
-{
-    cachedRects.clear();
-    QPoint screenOffset = mGeometry.topLeft();
-    QRegion remainingScreen(mGeometry.translated(-screenOffset)); // global to local translation
-
-    for (int i = 0; i < windowStack.length(); i++) {
-        if (remainingScreen.isEmpty())
-            break;
-        if (!windowStack[i]->visible())
-            continue;
-        if (windowStack[i]->widget()->isMinimized())
-            continue;
-
-        if (!windowStack[i]->widget()->testAttribute(Qt::WA_TranslucentBackground)) {
-            QRect localGeometry = windowStack.at(i)->geometry().translated(-screenOffset); // global to local translation
-            remainingScreen -= localGeometry;
-            QRegion windowRegion(localGeometry);
-            windowRegion -= remainingScreen;
-            foreach(QRect rect, windowRegion.rects()) {
-                cachedRects += QPair<QRect, int>(rect, i);
-            }
-        }
-    }
-    foreach (QRect rect, remainingScreen.rects())
-        cachedRects += QPair<QRect, int>(rect, -1);
-    isUpToDate = true;
-    return;
-}
-
-
-
-QRegion QFbScreen::doRedraw()
-{
-    QPoint screenOffset = mGeometry.topLeft();
-
-    QRegion touchedRegion;
-    if (cursor && cursor->isDirty() && cursor->isOnScreen()) {
-        QRect lastCursor = cursor->dirtyRect();
-        repaintRegion += lastCursor;
-    }
-    if (repaintRegion.isEmpty() && (!cursor || !cursor->isDirty())) {
-        return touchedRegion;
-    }
-
-    QVector<QRect> rects = repaintRegion.rects();
-
-    if (!isUpToDate)
-        generateRects();
-
-    if (!compositePainter)
-        compositePainter = new QPainter(mScreenImage);
-    for (int rectIndex = 0; rectIndex < repaintRegion.numRects(); rectIndex++) {
-        QRegion rectRegion = rects[rectIndex];
-
-        for(int i = 0; i < cachedRects.length(); i++) {
-            QRect screenSubRect = cachedRects[i].first;
-            int layer = cachedRects[i].second;
-            QRegion intersect = rectRegion.intersected(screenSubRect);
-
-            if (intersect.isEmpty())
-                continue;
-
-            rectRegion -= intersect;
-
-            // we only expect one rectangle, but defensive coding...
-            foreach (QRect rect, intersect.rects()) {
-                bool firstLayer = true;
-                if (layer == -1) {
-                    compositePainter->fillRect(rect, Qt::black);
-                    firstLayer = false;
-                    layer = windowStack.size() - 1;
-                }
-
-                for (int layerIndex = layer; layerIndex != -1; layerIndex--) {
-                    if (!windowStack[layerIndex]->visible())
-                        continue;
-                    if (windowStack[layerIndex]->widget()->isMinimized())
-                        continue;
-                    QRect windowRect = windowStack[layerIndex]->geometry().translated(-screenOffset);
-                    QRect windowIntersect = rect.translated(-windowRect.left(),
-                                                            -windowRect.top());
-                    compositePainter->drawImage(rect, windowStack[layerIndex]->surface->image(),
-                                                windowIntersect);
-                    if (firstLayer) {
-                        firstLayer = false;
-                    }
-                }
-            }
-        }
-    }
-
-    QRect cursorRect;
-    if (cursor && (cursor->isDirty() || repaintRegion.intersects(cursor->lastPainted()))) {
-        cursorRect = cursor->drawCursor(*compositePainter);
-        touchedRegion += cursorRect;
-    }
-    touchedRegion += repaintRegion;
-    repaintRegion = QRegion();
-
-
-
-//    qDebug() << "QFbScreen::doRedraw"  << windowStack.size() << mScreenImage->size() << touchedRegion;
-
-
-    return touchedRegion;
-}
-
-void QFbScreen::addWindow(QFbWindow *surface)
-{
-    windowStack.prepend(surface);
-    surface->mScreens.append(this);
-    invalidateRectCache();
-    setDirty(surface->geometry());
-}
-
-void QFbScreen::removeWindow(QFbWindow * surface)
-{
-    windowStack.removeOne(surface);
-    surface->mScreens.removeOne(this);
-    invalidateRectCache();
-    setDirty(surface->geometry());
-}
-
-void QFbWindow::raise()
-{
-    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
-    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
-    while (i != end) {
-        (*i)->raise(this);
-        ++i;
-    }
-}
-
-void QFbScreen::raise(QPlatformWindow * surface)
-{
-    QFbWindow *s = static_cast<QFbWindow *>(surface);
-    int index = windowStack.indexOf(s);
-    if (index <= 0)
-        return;
-    windowStack.move(index, 0);
-    invalidateRectCache();
-    setDirty(s->geometry());
-}
-
-void QFbWindow::lower()
-{
-    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
-    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
-    while (i != end) {
-        (*i)->lower(this);
-        ++i;
-    }
-}
-
-void QFbScreen::lower(QPlatformWindow * surface)
-{
-    QFbWindow *s = static_cast<QFbWindow *>(surface);
-    int index = windowStack.indexOf(s);
-    if (index == -1 || index == (windowStack.size() - 1))
-        return;
-    windowStack.move(index, windowStack.size() - 1);
-    invalidateRectCache();
-    setDirty(s->geometry());
-}
-
-QWidget * QFbScreen::topLevelAt(const QPoint & p) const
-{
-    for(int i = 0; i < windowStack.size(); i++) {
-        if (windowStack[i]->geometry().contains(p, false) &&
-            windowStack[i]->visible() &&
-            !windowStack[i]->widget()->isMinimized()) {
-            return windowStack[i]->widget();
-        }
-    }
-    return 0;
-}
-
-QFbWindow::QFbWindow(QWidget *window)
-    :QPlatformWindow(window),
-      visibleFlag(false)
-{
-    static QAtomicInt winIdGenerator(1);
-    windowId = winIdGenerator.fetchAndAddRelaxed(1);
-}
-
-
-QFbWindow::~QFbWindow()
-{
-    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
-    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
-    while (i != end) {
-        (*i)->removeWindow(this);
-        ++i;
-    }
-}
-
-
-QFbWindowSurface::QFbWindowSurface(QFbScreen *screen, QWidget *window)
-    : QWindowSurface(window),
-      mScreen(screen)
-{
-    mImage = QImage(window->size(), mScreen->format());
-
-    platformWindow = static_cast<QFbWindow*>(window->platformWindow());
-    platformWindow->surface = this;
-}
-
-QFbWindowSurface::~QFbWindowSurface()
-{
-}
-
-void QFbWindowSurface::flush(QWidget *widget, const QRegion &region, const QPoint &offset)
-{
-    Q_UNUSED(widget);
-    Q_UNUSED(offset);
-
-
-//    qDebug() << "QFbWindowSurface::flush" << region;
-
-
-    platformWindow->repaint(region);
-}
-
-
-void QFbWindow::repaint(const QRegion &region)
-{
-    QRect currentGeometry = geometry();
-
-    QRect dirtyClient = region.boundingRect();
-    QRect dirtyRegion(currentGeometry.left() + dirtyClient.left(),
-                      currentGeometry.top() + dirtyClient.top(),
-                      dirtyClient.width(),
-                      dirtyClient.height());
-    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
-    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
-    QRect oldGeometryLocal = oldGeometry;
-    oldGeometry = currentGeometry;
-    while (i != end) {
-        // If this is a move, redraw the previous location
-        if (oldGeometryLocal != currentGeometry) {
-            (*i)->setDirty(oldGeometryLocal);
-        }
-        (*i)->setDirty(dirtyRegion);
-        ++i;
-    }
-}
-
-void QFbWindowSurface::resize(const QSize &size)
-{
-    // change the widget's QImage if this is a resize
-    if (mImage.size() != size)
-        mImage = QImage(size, mScreen->format());
-    QWindowSurface::resize(size);
-}
-
-void QFbWindow::setGeometry(const QRect &rect)
-{
-// store previous geometry for screen update
-    oldGeometry = geometry();
-
-
-    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
-    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
-    while (i != end) {
-        (*i)->invalidateRectCache();
-        ++i;
-    }
-//###    QWindowSystemInterface::handleGeometryChange(window(), rect);
-
-    QPlatformWindow::setGeometry(rect);
-}
-
-bool QFbWindowSurface::scroll(const QRegion &area, int dx, int dy)
-{
-    return QWindowSurface::scroll(area, dx, dy);
-}
-
-void QFbWindowSurface::beginPaint(const QRegion &region)
-{
-    Q_UNUSED(region);
-}
-
-void QFbWindowSurface::endPaint(const QRegion &region)
-{
-    Q_UNUSED(region);
-}
-
-void QFbWindow::setVisible(bool visible)
-{
-    visibleFlag = visible;
-    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
-    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
-    while (i != end) {
-        (*i)->invalidateRectCache();
-        (*i)->setDirty(geometry());
-        ++i;
-    }
-}
-
-Qt::WindowFlags QFbWindow::setWindowFlags(Qt::WindowFlags type)
-{
-    flags = type;
-    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
-    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
-    while (i != end) {
-        (*i)->invalidateRectCache();
-        ++i;
-    }
-    return flags;
-}
-
-Qt::WindowFlags QFbWindow::windowFlags() const
-{
-    return flags;
-}
diff --git a/src/platformsupport/fb_base/fb_base.pri b/src/platformsupport/fb_base/fb_base.pri
deleted file mode 100644
index aab6ccd..0000000
--- a/src/platformsupport/fb_base/fb_base.pri
+++ /dev/null
@@ -1,4 +0,0 @@
-do_not_compile_until_ported_to_qt5 {
-    SOURCES += $$PWD/fb_base.cpp
-    HEADERS += $$PWD/fb_base_p.h
-}
diff --git a/src/platformsupport/fb_base/fb_base_p.h b/src/platformsupport/fb_base/fb_base_p.h
deleted file mode 100644
index 187ae96..0000000
--- a/src/platformsupport/fb_base/fb_base_p.h
+++ /dev/null
@@ -1,210 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QLIGHTHOUSEGRAPHICSSCREEN_H
-#define QLIGHTHOUSEGRAPHICSSCREEN_H
-
-#include <qrect.h>
-#include <qimage.h>
-#include <qtimer.h>
-#include <qpainter.h>
-#include <qpa/qplatformcursor.h>
-#include <qpa/qplatformscreen.h>
-#include <qpa/qplatformwindow.h>
-#include <QtGui/private/qwindowsurface_p.h>
-
-class QMouseEvent;
-class QSize;
-class QPainter;
-
-class QFbScreen;
-
-class QPlatformSoftwareCursor : public QPlatformCursor
-{
-public:
-    QPlatformSoftwareCursor(QPlatformScreen * scr);
-
-    // output methods
-    QRect dirtyRect();
-    virtual QRect drawCursor(QPainter & painter);
-
-    // input methods
-    virtual void pointerEvent(const QMouseEvent & event);
-    virtual void changeCursor(QCursor * widgetCursor, QWidget * widget);
-
-    virtual void setDirty() { dirty = true; screen->setDirty(QRect()); }
-    virtual bool isDirty() { return dirty; }
-    virtual bool isOnScreen() { return onScreen; }
-    virtual QRect lastPainted() { return prevRect; }
-
-protected:
-    QPlatformCursorImage * graphic;
-
-private:
-    void setCursor(const uchar *data, const uchar *mask, int width, int height, int hotX, int hotY);
-    void setCursor(Qt::CursorShape shape);
-    void setCursor(const QImage &image, int hotx, int hoty);
-    QRect currentRect;      // next place to draw the cursor
-    QRect prevRect;         // last place the cursor was drawn
-    QRect getCurrentRect();
-    bool dirty;
-    bool onScreen;
-};
-
-class QFbWindow;
-
-class QFbWindowSurface : public QWindowSurface
-{
-public:
-    QFbWindowSurface(QFbScreen *screen, QWidget *window);
-    ~QFbWindowSurface();
-
-    virtual QPaintDevice *paintDevice() { return &mImage; }
-    virtual void flush(QWidget *widget, const QRegion &region, const QPoint &offset);
-    virtual bool scroll(const QRegion &area, int dx, int dy);
-
-    virtual void beginPaint(const QRegion &region);
-    virtual void endPaint(const QRegion &region);
-
-
-    const QImage image() { return mImage; }
-    void resize(const QSize &size);
-
-protected:
-    friend class QFbWindow;
-    QFbWindow *platformWindow;
-
-    QFbScreen *mScreen;
-    QImage mImage;
-};
-
-
-class QFbWindow : public QPlatformWindow
-{
-public:
-
-    QFbWindow(QWidget *window);
-    ~QFbWindow();
-
-
-    virtual void setVisible(bool visible);
-    virtual bool visible() { return visibleFlag; }
-
-    virtual void raise();
-    virtual void lower();
-
-    void setGeometry(const QRect &rect);
-
-    virtual Qt::WindowFlags setWindowFlags(Qt::WindowFlags type);
-    virtual Qt::WindowFlags windowFlags() const;
-
-    WId winId() const { return windowId; }
-
-    virtual void repaint(const QRegion&);
-
-protected:
-    friend class QFbWindowSurface;
-    friend class QFbScreen;
-    QFbWindowSurface *surface;
-    QList<QFbScreen *> mScreens;
-    QRect oldGeometry;
-    bool visibleFlag;
-    Qt::WindowFlags flags;
-
-    WId windowId;
-};
-
-class QFbScreen : public QPlatformScreen
-{
-    Q_OBJECT
-public:
-    QFbScreen();
-    ~QFbScreen();
-
-    virtual QRect geometry() const { return mGeometry; }
-    virtual int depth() const { return mDepth; }
-    virtual QImage::Format format() const { return mFormat; }
-    virtual QSize physicalSize() const { return mPhysicalSize; }
-
-    virtual void setGeometry(QRect rect);
-    virtual void setDepth(int depth);
-    virtual void setFormat(QImage::Format format);
-    virtual void setPhysicalSize(QSize size);
-
-    virtual void setDirty(const QRect &rect);
-
-    virtual void removeWindow(QFbWindow * surface);
-    virtual void addWindow(QFbWindow * surface);
-    virtual void raise(QPlatformWindow * surface);
-    virtual void lower(QPlatformWindow * surface);
-    virtual QWidget * topLevelAt(const QPoint & p) const;
-
-    QImage * image() const { return mScreenImage; }
-    QPaintDevice * paintDevice() const { return mScreenImage; }
-
-protected:
-    QList<QFbWindow *> windowStack;
-    QRegion repaintRegion;
-    QPlatformSoftwareCursor * cursor;
-    QTimer redrawTimer;
-
-protected slots:
-    virtual QRegion doRedraw();
-
-protected:
-    QRect mGeometry;
-    int mDepth;
-    QImage::Format mFormat;
-    QSize mPhysicalSize;
-    QImage *mScreenImage;
-
-private:
-    QPainter * compositePainter;
-    void generateRects();
-    QList<QPair<QRect, int> > cachedRects;
-
-    void invalidateRectCache() { isUpToDate = false; }
-    friend class QFbWindowSurface;
-    friend class QFbWindow;
-    bool isUpToDate;
-};
-
-#endif // QLIGHTHOUSEGRAPHICSSCREEN_H
diff --git a/src/platformsupport/fbconvenience/fbconvenience.pri b/src/platformsupport/fbconvenience/fbconvenience.pri
new file mode 100644
index 0000000..6ccaa50
--- /dev/null
+++ b/src/platformsupport/fbconvenience/fbconvenience.pri
@@ -0,0 +1,10 @@
+SOURCES += $$PWD/qfbscreen.cpp \
+           $$PWD/qfbbackingstore.cpp \
+           $$PWD/qfbwindow.cpp \
+           $$PWD/qfbcursor.cpp
+
+HEADERS += $$PWD/qfbscreen_p.h \
+           $$PWD/qfbbackingstore_p.h \
+           $$PWD/qfbwindow_p.h \
+           $$PWD/qfbcursor_p.h
+
diff --git a/src/platformsupport/fbconvenience/qfbbackingstore.cpp b/src/platformsupport/fbconvenience/qfbbackingstore.cpp
new file mode 100644
index 0000000..e7d2bc8
--- /dev/null
+++ b/src/platformsupport/fbconvenience/qfbbackingstore.cpp
@@ -0,0 +1,97 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfbbackingstore_p.h"
+#include "qfbwindow_p.h"
+#include "qfbscreen_p.h"
+
+#include <qpa/qplatformwindow.h>
+
+QT_BEGIN_NAMESPACE
+
+QFbBackingStore::QFbBackingStore(QFbScreen *screen, QWindow *window)
+    : QPlatformBackingStore(window),
+      mScreen(screen)
+{
+    mImage = QImage(window->size(), mScreen->format());
+
+    platformWindow = static_cast<QFbWindow*>(window->handle());
+    platformWindow->surface = this;
+}
+
+QFbBackingStore::~QFbBackingStore()
+{
+}
+
+void QFbBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
+{
+    Q_UNUSED(window);
+    Q_UNUSED(offset);
+
+    platformWindow->repaint(region);
+}
+
+void QFbBackingStore::resize(const QSize &size, const QRegion &region)
+{
+    Q_UNUSED(region);
+    // change the widget's QImage if this is a resize
+    if (mImage.size() != size)
+        mImage = QImage(size, mScreen->format());
+    // QPlatformBackingStore::resize(size);
+}
+
+bool QFbBackingStore::scroll(const QRegion &area, int dx, int dy)
+{
+    return QPlatformBackingStore::scroll(area, dx, dy);
+}
+
+void QFbBackingStore::beginPaint(const QRegion &region)
+{
+    Q_UNUSED(region);
+}
+
+void QFbBackingStore::endPaint(const QRegion &region)
+{
+    Q_UNUSED(region);
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/platformsupport/fbconvenience/qfbbackingstore_p.h b/src/platformsupport/fbconvenience/qfbbackingstore_p.h
new file mode 100644
index 0000000..52a154b
--- /dev/null
+++ b/src/platformsupport/fbconvenience/qfbbackingstore_p.h
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFBBACKINGSTORE_P_H
+#define QFBBACKINGSTORE_P_H
+
+#include <qpa/qplatformbackingstore.h>
+
+QT_BEGIN_NAMESPACE
+
+class QFbScreen;
+class QFbWindow;
+class QWindow;
+
+class QFbBackingStore : public QPlatformBackingStore
+{
+public:
+    QFbBackingStore(QFbScreen *screen, QWindow *window);
+    ~QFbBackingStore();
+
+    virtual QPaintDevice *paintDevice() { return &mImage; }
+    virtual void flush(QWindow *window, const QRegion &region, const QPoint &offset);
+    virtual bool scroll(const QRegion &area, int dx, int dy);
+
+    virtual void beginPaint(const QRegion &region);
+    virtual void endPaint(const QRegion &region);
+
+    const QImage image() { return mImage; }
+    void resize(const QSize &size, const QRegion &region);
+
+protected:
+    friend class QFbWindow;
+    QFbWindow *platformWindow;
+
+    QFbScreen *mScreen;
+    QImage mImage;
+};
+
+QT_END_NAMESPACE
+
+#endif // QFBBACKINGSTORE_P_H
+
diff --git a/src/platformsupport/fbconvenience/qfbcursor.cpp b/src/platformsupport/fbconvenience/qfbcursor.cpp
new file mode 100644
index 0000000..712177f
--- /dev/null
+++ b/src/platformsupport/fbconvenience/qfbcursor.cpp
@@ -0,0 +1,138 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfbcursor_p.h"
+#include <QtGui/QPainter>
+
+QT_BEGIN_NAMESPACE
+
+QFbCursor::QFbCursor(QPlatformScreen *scr)
+        : screen(scr), currentRect(QRect()), prevRect(QRect())
+{
+    graphic = new QPlatformCursorImage(0, 0, 0, 0, 0, 0);
+    setCursor(Qt::ArrowCursor);
+}
+
+QRect QFbCursor::getCurrentRect()
+{
+    QRect rect = graphic->image()->rect().translated(-graphic->hotspot().x(),
+                                                     -graphic->hotspot().y());
+    rect.translate(QCursor::pos());
+    QPoint screenOffset = screen->geometry().topLeft();
+    rect.translate(-screenOffset);  // global to local translation
+    return rect;
+}
+
+
+void QFbCursor::pointerEvent(const QMouseEvent & e)
+{
+    Q_UNUSED(e);
+    QPoint screenOffset = screen->geometry().topLeft();
+    currentRect = getCurrentRect();
+    // global to local translation
+    if (onScreen || screen->geometry().intersects(currentRect.translated(screenOffset))) {
+        setDirty();
+    }
+}
+
+QRect QFbCursor::drawCursor(QPainter & painter)
+{
+    dirty = false;
+    if (currentRect.isNull())
+        return QRect();
+
+    // We need this because the cursor might be dirty due to moving off screen
+    QPoint screenOffset = screen->geometry().topLeft();
+    // global to local translation
+    if (!currentRect.translated(screenOffset).intersects(screen->geometry()))
+        return QRect();
+
+    prevRect = currentRect;
+    painter.drawImage(prevRect, *graphic->image());
+    onScreen = true;
+    return prevRect;
+}
+
+QRect QFbCursor::dirtyRect()
+{
+    if (onScreen) {
+        onScreen = false;
+        return prevRect;
+    }
+    return QRect();
+}
+
+void QFbCursor::setCursor(Qt::CursorShape shape)
+{
+    graphic->set(shape);
+}
+
+void QFbCursor::setCursor(const QImage &image, int hotx, int hoty)
+{
+    graphic->set(image, hotx, hoty);
+}
+
+void QFbCursor::setCursor(const uchar *data, const uchar *mask, int width, int height, int hotX, int hotY)
+{
+    graphic->set(data, mask, width, height, hotX, hotY);
+}
+
+void QFbCursor::changeCursor(QCursor * widgetCursor, QWindow *window)
+{
+    Q_UNUSED(window);
+    Qt::CursorShape shape = widgetCursor->shape();
+
+    if (shape == Qt::BitmapCursor) {
+        // application supplied cursor
+        QPoint spot = widgetCursor->hotSpot();
+        setCursor(widgetCursor->pixmap().toImage(), spot.x(), spot.y());
+    } else {
+        // system cursor
+        setCursor(shape);
+    }
+    currentRect = getCurrentRect();
+    QPoint screenOffset = screen->geometry().topLeft(); // global to local translation
+    if (onScreen || screen->geometry().intersects(currentRect.translated(screenOffset)))
+        setDirty();
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/platformsupport/fbconvenience/qfbcursor_p.h b/src/platformsupport/fbconvenience/qfbcursor_p.h
new file mode 100644
index 0000000..6511fc7
--- /dev/null
+++ b/src/platformsupport/fbconvenience/qfbcursor_p.h
@@ -0,0 +1,86 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFBCURSOR_P_H
+#define QFBCURSOR_P_H
+
+#include <qpa/qplatformcursor.h>
+
+QT_BEGIN_NAMESPACE
+
+class QFbCursor : public QPlatformCursor
+{
+public:
+    QFbCursor(QPlatformScreen * scr);
+
+    // output methods
+    QRect dirtyRect();
+    virtual QRect drawCursor(QPainter & painter);
+
+    // input methods
+    virtual void pointerEvent(const QMouseEvent & event);
+    virtual void changeCursor(QCursor * widgetCursor, QWindow *window);
+
+    virtual void setDirty() { dirty = true; /* screen->setDirty(QRect()); */ }
+    virtual bool isDirty() { return dirty; }
+    virtual bool isOnScreen() { return onScreen; }
+    virtual QRect lastPainted() { return prevRect; }
+
+protected:
+    QPlatformCursorImage *graphic;
+
+private:
+    void setCursor(const uchar *data, const uchar *mask, int width, int height, int hotX, int hotY);
+    void setCursor(Qt::CursorShape shape);
+    void setCursor(const QImage &image, int hotx, int hoty);
+
+    QPlatformScreen *screen;
+    QRect currentRect;      // next place to draw the cursor
+    QRect prevRect;         // last place the cursor was drawn
+    QRect getCurrentRect();
+    bool dirty;
+    bool onScreen;
+};
+
+QT_END_NAMESPACE
+
+#endif // QFBCURSOR_P_H
+
diff --git a/src/platformsupport/fbconvenience/qfbscreen.cpp b/src/platformsupport/fbconvenience/qfbscreen.cpp
new file mode 100644
index 0000000..843300d
--- /dev/null
+++ b/src/platformsupport/fbconvenience/qfbscreen.cpp
@@ -0,0 +1,269 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfbscreen_p.h"
+#include "qfbcursor_p.h"
+#include "qfbwindow_p.h"
+#include "qfbbackingstore_p.h"
+
+#include <QtGui/QPainter>
+
+QT_BEGIN_NAMESPACE
+
+QFbScreen::QFbScreen() : cursor(0), mGeometry(), mDepth(16), mFormat(QImage::Format_RGB16), mScreenImage(0), compositePainter(0), isUpToDate(false)
+{
+    mScreenImage = new QImage(mGeometry.size(), mFormat);
+    redrawTimer.setSingleShot(true);
+    redrawTimer.setInterval(0);
+    connect(&redrawTimer, SIGNAL(timeout()), this, SLOT(doRedraw()));
+}
+
+void QFbScreen::raise(QPlatformWindow * surface)
+{
+    QFbWindow *s = static_cast<QFbWindow *>(surface);
+    int index = windowStack.indexOf(s);
+    if (index <= 0)
+        return;
+    windowStack.move(index, 0);
+    invalidateRectCache();
+    setDirty(s->geometry());
+}
+
+void QFbScreen::lower(QPlatformWindow * surface)
+{
+    QFbWindow *s = static_cast<QFbWindow *>(surface);
+    int index = windowStack.indexOf(s);
+    if (index == -1 || index == (windowStack.size() - 1))
+        return;
+    windowStack.move(index, windowStack.size() - 1);
+    invalidateRectCache();
+    setDirty(s->geometry());
+}
+
+QWindow *QFbScreen::topLevelAt(const QPoint & p) const
+{
+    Q_UNUSED(p);
+#if 0
+    for (int i = 0; i < windowStack.size(); i++) {
+        if (windowStack[i]->geometry().contains(p, false) &&
+            windowStack[i]->visible() &&
+            !windowStack[i]->widget()->isMinimized()) {
+            return windowStack[i]->widget();
+        }
+    }
+#endif
+    return 0;
+}
+
+
+void QFbScreen::setGeometry(QRect rect)
+{
+    delete mScreenImage;
+    mGeometry = rect;
+    mScreenImage = new QImage(mGeometry.size(), mFormat);
+    delete compositePainter;
+    compositePainter = 0;
+    invalidateRectCache();
+}
+
+void QFbScreen::setDepth(int depth)
+{
+    mDepth = depth;
+}
+
+void QFbScreen::setPhysicalSize(QSize size)
+{
+    mPhysicalSize = size;
+}
+
+void QFbScreen::setFormat(QImage::Format format)
+{
+    mFormat = format;
+    delete mScreenImage;
+    mScreenImage = new QImage(mGeometry.size(), mFormat);
+    delete compositePainter;
+    compositePainter = 0;
+}
+
+QFbScreen::~QFbScreen()
+{
+    delete compositePainter;
+    delete mScreenImage;
+}
+
+void QFbScreen::setDirty(const QRect &rect)
+{
+    QRect intersection = rect.intersected(mGeometry);
+    QPoint screenOffset = mGeometry.topLeft();
+    repaintRegion += intersection.translated(-screenOffset);    // global to local translation
+    if (!redrawTimer.isActive()) {
+        redrawTimer.start();
+    }
+}
+
+void QFbScreen::generateRects()
+{
+    cachedRects.clear();
+    QPoint screenOffset = mGeometry.topLeft();
+    QRegion remainingScreen(mGeometry.translated(-screenOffset)); // global to local translation
+
+    for (int i = 0; i < windowStack.length(); i++) {
+        if (remainingScreen.isEmpty())
+            break;
+#if 0
+        if (!windowStack[i]->isVisible())
+            continue;
+        if (windowStack[i]->isMinimized())
+            continue;
+
+        if (!windowStack[i]->testAttribute(Qt::WA_TranslucentBackground)) {
+            QRect localGeometry = windowStack.at(i)->geometry().translated(-screenOffset); // global to local translation
+            remainingScreen -= localGeometry;
+            QRegion windowRegion(localGeometry);
+            windowRegion -= remainingScreen;
+            foreach (QRect rect, windowRegion.rects()) {
+                cachedRects += QPair<QRect, int>(rect, i);
+            }
+        }
+#endif
+    }
+    foreach (QRect rect, remainingScreen.rects())
+        cachedRects += QPair<QRect, int>(rect, -1);
+    isUpToDate = true;
+    return;
+}
+
+
+
+QRegion QFbScreen::doRedraw()
+{
+    QPoint screenOffset = mGeometry.topLeft();
+
+    QRegion touchedRegion;
+    if (cursor && cursor->isDirty() && cursor->isOnScreen()) {
+        QRect lastCursor = cursor->dirtyRect();
+        repaintRegion += lastCursor;
+    }
+    if (repaintRegion.isEmpty() && (!cursor || !cursor->isDirty())) {
+        return touchedRegion;
+    }
+
+    QVector<QRect> rects = repaintRegion.rects();
+
+    if (!isUpToDate)
+        generateRects();
+
+    if (!compositePainter)
+        compositePainter = new QPainter(mScreenImage);
+    for (int rectIndex = 0; rectIndex < repaintRegion.rectCount(); rectIndex++) {
+        QRegion rectRegion = rects[rectIndex];
+
+        for (int i = 0; i < cachedRects.length(); i++) {
+            QRect screenSubRect = cachedRects[i].first;
+            int layer = cachedRects[i].second;
+            QRegion intersect = rectRegion.intersected(screenSubRect);
+
+            if (intersect.isEmpty())
+                continue;
+
+            rectRegion -= intersect;
+
+            // we only expect one rectangle, but defensive coding...
+            foreach (QRect rect, intersect.rects()) {
+                bool firstLayer = true;
+                if (layer == -1) {
+                    compositePainter->fillRect(rect, Qt::black);
+                    firstLayer = false;
+                    layer = windowStack.size() - 1;
+                }
+
+                for (int layerIndex = layer; layerIndex != -1; layerIndex--) {
+                    if (!windowStack[layerIndex]->isVisible())
+                        continue;
+                    // if (windowStack[layerIndex]->isMinimized())
+                    //     continue;
+                    QRect windowRect = windowStack[layerIndex]->geometry().translated(-screenOffset);
+                    QRect windowIntersect = rect.translated(-windowRect.left(),
+                                                            -windowRect.top());
+                    compositePainter->drawImage(rect, windowStack[layerIndex]->surface->image(),
+                                                windowIntersect);
+                    if (firstLayer) {
+                        firstLayer = false;
+                    }
+                }
+            }
+        }
+    }
+
+    QRect cursorRect;
+    if (cursor && (cursor->isDirty() || repaintRegion.intersects(cursor->lastPainted()))) {
+        cursorRect = cursor->drawCursor(*compositePainter);
+        touchedRegion += cursorRect;
+    }
+    touchedRegion += repaintRegion;
+    repaintRegion = QRegion();
+
+
+
+//    qDebug() << "QFbScreen::doRedraw"  << windowStack.size() << mScreenImage->size() << touchedRegion;
+
+
+    return touchedRegion;
+}
+
+void QFbScreen::addWindow(QFbWindow *surface)
+{
+    windowStack.prepend(surface);
+    surface->mScreens.append(this);
+    invalidateRectCache();
+    setDirty(surface->geometry());
+}
+
+void QFbScreen::removeWindow(QFbWindow * surface)
+{
+    windowStack.removeOne(surface);
+    surface->mScreens.removeOne(this);
+    invalidateRectCache();
+    setDirty(surface->geometry());
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/platformsupport/fbconvenience/qfbscreen_p.h b/src/platformsupport/fbconvenience/qfbscreen_p.h
new file mode 100644
index 0000000..71d8d45
--- /dev/null
+++ b/src/platformsupport/fbconvenience/qfbscreen_p.h
@@ -0,0 +1,112 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFBSCREEN_P_H
+#define QFBSCREEN_P_H
+
+#include <qpa/qplatformscreen.h>
+#include <QtCore/QTimer>
+#include <QtCore/QSize>
+
+QT_BEGIN_NAMESPACE
+
+class QFbWindow;
+class QFbCursor;
+class QPainter;
+
+class QFbScreen : public QObject, public QPlatformScreen
+{
+    Q_OBJECT
+public:
+    QFbScreen();
+    ~QFbScreen();
+
+    virtual QRect geometry() const { return mGeometry; }
+    virtual int depth() const { return mDepth; }
+    virtual QImage::Format format() const { return mFormat; }
+    virtual QSizeF physicalSize() const { return mPhysicalSize; }
+
+    virtual void setGeometry(QRect rect);
+    virtual void setDepth(int depth);
+    virtual void setFormat(QImage::Format format);
+    virtual void setPhysicalSize(QSize size);
+
+    virtual void setDirty(const QRect &rect);
+
+    virtual void removeWindow(QFbWindow * surface);
+    virtual void addWindow(QFbWindow * surface);
+    virtual void raise(QPlatformWindow * surface);
+    virtual void lower(QPlatformWindow * surface);
+    virtual QWindow *topLevelAt(const QPoint & p) const;
+
+    QImage * image() const { return mScreenImage; }
+    QPaintDevice * paintDevice() const { return mScreenImage; }
+
+protected:
+    QList<QFbWindow *> windowStack;
+    QRegion repaintRegion;
+    QFbCursor * cursor;
+    QTimer redrawTimer;
+
+protected slots:
+    virtual QRegion doRedraw();
+
+protected:
+    QRect mGeometry;
+    int mDepth;
+    QImage::Format mFormat;
+    QSizeF mPhysicalSize;
+    QImage *mScreenImage;
+
+private:
+    QPainter *compositePainter;
+    void generateRects();
+    QList<QPair<QRect, int> > cachedRects;
+
+    void invalidateRectCache() { isUpToDate = false; }
+    friend class QFbWindow;
+    bool isUpToDate;
+};
+
+QT_END_NAMESPACE
+
+#endif // QFBSCREEN_P_H
+
diff --git a/src/platformsupport/fbconvenience/qfbwindow.cpp b/src/platformsupport/fbconvenience/qfbwindow.cpp
new file mode 100644
index 0000000..4729f9d
--- /dev/null
+++ b/src/platformsupport/fbconvenience/qfbwindow.cpp
@@ -0,0 +1,155 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfbwindow_p.h"
+#include "qfbscreen_p.h"
+
+QT_BEGIN_NAMESPACE
+
+void QFbWindow::setGeometry(const QRect &rect)
+{
+// store previous geometry for screen update
+    oldGeometry = geometry();
+
+
+    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
+    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
+    while (i != end) {
+        (*i)->invalidateRectCache();
+        ++i;
+    }
+//###    QWindowSystemInterface::handleGeometryChange(window(), rect);
+
+    QPlatformWindow::setGeometry(rect);
+}
+
+void QFbWindow::setVisible(bool visible)
+{
+    visibleFlag = visible;
+    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
+    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
+    while (i != end) {
+        (*i)->invalidateRectCache();
+        (*i)->setDirty(geometry());
+        ++i;
+    }
+}
+
+Qt::WindowFlags QFbWindow::setWindowFlags(Qt::WindowFlags type)
+{
+    flags = type;
+    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
+    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
+    while (i != end) {
+        (*i)->invalidateRectCache();
+        ++i;
+    }
+    return flags;
+}
+
+Qt::WindowFlags QFbWindow::windowFlags() const
+{
+    return flags;
+}
+
+QFbWindow::QFbWindow(QWindow *window)
+    : QPlatformWindow(window), visibleFlag(false)
+{
+    static QAtomicInt winIdGenerator(1);
+    windowId = winIdGenerator.fetchAndAddRelaxed(1);
+}
+
+QFbWindow::~QFbWindow()
+{
+    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
+    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
+    while (i != end) {
+        (*i)->removeWindow(this);
+        ++i;
+    }
+}
+
+void QFbWindow::raise()
+{
+    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
+    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
+    while (i != end) {
+        (*i)->raise(this);
+        ++i;
+    }
+}
+
+void QFbWindow::lower()
+{
+    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
+    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
+    while (i != end) {
+        (*i)->lower(this);
+        ++i;
+    }
+}
+
+void QFbWindow::repaint(const QRegion &region)
+{
+    QRect currentGeometry = geometry();
+
+    QRect dirtyClient = region.boundingRect();
+    QRect dirtyRegion(currentGeometry.left() + dirtyClient.left(),
+                      currentGeometry.top() + dirtyClient.top(),
+                      dirtyClient.width(),
+                      dirtyClient.height());
+    QList<QFbScreen *>::const_iterator i = mScreens.constBegin();
+    QList<QFbScreen *>::const_iterator end = mScreens.constEnd();
+    QRect oldGeometryLocal = oldGeometry;
+    oldGeometry = currentGeometry;
+    while (i != end) {
+        // If this is a move, redraw the previous location
+        if (oldGeometryLocal != currentGeometry) {
+            (*i)->setDirty(oldGeometryLocal);
+        }
+        (*i)->setDirty(dirtyRegion);
+        ++i;
+    }
+}
+
+
+QT_END_NAMESPACE
+
diff --git a/src/platformsupport/fbconvenience/qfbwindow_p.h b/src/platformsupport/fbconvenience/qfbwindow_p.h
new file mode 100644
index 0000000..81b6634
--- /dev/null
+++ b/src/platformsupport/fbconvenience/qfbwindow_p.h
@@ -0,0 +1,89 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFBWINDOW_P_H
+#define QFBWINDOW_P_H
+
+#include <qpa/qplatformwindow.h>
+
+QT_BEGIN_NAMESPACE
+
+class QFbBackingStore;
+class QFbScreen;
+
+class QFbWindow : public QPlatformWindow
+{
+public:
+    QFbWindow(QWindow *window);
+    ~QFbWindow();
+
+    virtual void setVisible(bool visible);
+    virtual bool isVisible() { return visibleFlag; }
+
+    virtual void raise();
+    virtual void lower();
+
+    void setGeometry(const QRect &rect);
+
+    virtual Qt::WindowFlags setWindowFlags(Qt::WindowFlags type);
+    virtual Qt::WindowFlags windowFlags() const;
+
+    WId winId() const { return windowId; }
+
+    virtual void repaint(const QRegion&);
+
+protected:
+    friend class QFbScreen;
+    friend class QFbBackingStore;
+
+    QFbBackingStore *surface;
+    QList<QFbScreen *> mScreens;
+    QRect oldGeometry;
+    bool visibleFlag;
+    Qt::WindowFlags flags;
+
+    WId windowId;
+};
+
+QT_END_NAMESPACE
+
+#endif // QFBWINDOW_P_H
+
diff --git a/src/platformsupport/platformsupport.pro b/src/platformsupport/platformsupport.pro
index 3840f82..d048fec 100644
--- a/src/platformsupport/platformsupport.pro
+++ b/src/platformsupport/platformsupport.pro
@@ -14,7 +14,7 @@ include(cglconvenience/cglconvenience.pri)
 include(dnd/dnd.pri)
 include(eglconvenience/eglconvenience.pri)
 include(eventdispatchers/eventdispatchers.pri)
-include(fb_base/fb_base.pri)
+include(fbconvenience/fbconvenience.pri)
 include(fontdatabases/fontdatabases.pri)
 include(glxconvenience/glxconvenience.pri)
 include(input/input.pri)