diff --git a/src/serialport.cpp b/src/serialport.cpp
old mode 100644
new mode 100755
index 318c216..a29fa97
--- a/src/serialport.cpp
+++ b/src/serialport.cpp
@@ -28,29 +28,22 @@ QT_BEGIN_NAMESPACE_SERIALPORT
     Constructs a SerialPortPrivate. Initializes all members.
 */
 SerialPortPrivate::SerialPortPrivate(SerialPort *parent)
-    : m_readBufferMaxSize(0)
-    , m_readBuffer(SERIALPORT_BUFFERSIZE)
-    , m_writeBuffer(SERIALPORT_BUFFERSIZE)
-    , m_isBuffered(false)
-    , m_readSerialNotifierCalled(false)
-    , m_readSerialNotifierState(false)
-    , m_readSerialNotifierStateSet(false)
-    , m_emittedReadyRead(false)
-    , m_emittedBytesWritten(false)
-    , m_engine(0)
+    : readBufferMaxSize(0)
+    , readBuffer(SERIALPORT_BUFFERSIZE)
+    , writeBuffer(SERIALPORT_BUFFERSIZE)
+    , isBuffered(true)
+    , readSerialNotifierCalled(false)
+    , readSerialNotifierState(false)
+    , readSerialNotifierStateSet(false)
+    , emittedReadyRead(false)
+    , emittedBytesWritten(false)
+    , portError(SerialPort::NoError)
+    , engine(0)
     , q_ptr(parent)
-    , m_inRate(SerialPort::UnknownRate)
-    , m_outRate(SerialPort::UnknownRate)
-    , m_dataBits(SerialPort::UnknownDataBits)
-    , m_parity(SerialPort::UnknownParity)
-    , m_stopBits(SerialPort::UnknownStopBits)
-    , m_flow(SerialPort::UnknownFlowControl)
-    , m_policy(SerialPort::IgnorePolicy)
-    , m_portError(SerialPort::NoError)
-    , m_restoreSettingsOnClose(true)
+
 {
-    m_engine = SerialPortEngine::create(this);
-    Q_ASSERT(m_engine);
+    engine = SerialPortEngine::create(this);
+    Q_ASSERT(engine);
 }
 
 /*! \internal
@@ -60,8 +53,8 @@ SerialPortPrivate::SerialPortPrivate(SerialPort *parent)
 */
 SerialPortPrivate::~SerialPortPrivate()
 {
-    if (m_engine)
-        delete m_engine;
+    if (engine)
+        delete engine;
 }
 
 /*! \internal
@@ -74,7 +67,7 @@ SerialPortPrivate::~SerialPortPrivate()
 */
 void SerialPortPrivate::setPort(const QString &port)
 {
-    m_systemLocation = m_engine->toSystemLocation(port);
+    options.systemLocation = engine->toSystemLocation(port);
 }
 
 /*! \internal
@@ -87,7 +80,7 @@ void SerialPortPrivate::setPort(const QString &port)
 */
 QString SerialPortPrivate::port() const
 {
-    return m_engine->fromSystemLocation(m_systemLocation);
+    return engine->fromSystemLocation(options.systemLocation);
 }
 
 /*! \internal
@@ -98,7 +91,7 @@ QString SerialPortPrivate::port() const
 */
 bool SerialPortPrivate::open(QIODevice::OpenMode mode)
 {
-    return m_engine->open(m_systemLocation, mode);
+    return engine->open(options.systemLocation, mode);
 }
 
 /*! \internal
@@ -109,7 +102,7 @@ bool SerialPortPrivate::open(QIODevice::OpenMode mode)
 */
 void SerialPortPrivate::close()
 {
-    m_engine->close(m_systemLocation);
+    engine->close(options.systemLocation);
 }
 
 /*! \internal
@@ -120,11 +113,11 @@ void SerialPortPrivate::close()
 */
 bool SerialPortPrivate::setRate(qint32 rate, SerialPort::Directions dir)
 {
-    if (m_engine->setRate(rate, dir)) {
+    if (engine->setRate(rate, dir)) {
         if (dir & SerialPort::Input)
-            m_inRate = rate;
+            options.inputRate = rate;
         if (dir & SerialPort::Output)
-            m_outRate = rate;
+            options.outputRate = rate;
         return true;
     }
     return false;
@@ -138,8 +131,8 @@ bool SerialPortPrivate::setRate(qint32 rate, SerialPort::Directions dir)
 qint32 SerialPortPrivate::rate(SerialPort::Directions dir) const
 {
     if (dir == SerialPort::AllDirections)
-        return (m_inRate == m_outRate) ? (m_inRate) : SerialPort::UnknownRate;
-    return (dir & SerialPort::Input) ? (m_inRate) : (m_outRate);
+        return (options.inputRate == options.outputRate) ? (options.inputRate) : SerialPort::UnknownRate;
+    return (dir & SerialPort::Input) ? (options.inputRate) : (options.outputRate);
 }
 
 /*! \internal
@@ -150,8 +143,8 @@ qint32 SerialPortPrivate::rate(SerialPort::Directions dir) const
 */
 bool SerialPortPrivate::setDataBits(SerialPort::DataBits dataBits)
 {
-    if (m_engine->setDataBits(dataBits)) {
-        m_dataBits = dataBits;
+    if (engine->setDataBits(dataBits)) {
+        options.dataBits = dataBits;
         return true;
     }
     return false;
@@ -164,7 +157,7 @@ bool SerialPortPrivate::setDataBits(SerialPort::DataBits dataBits)
 */
 SerialPort::DataBits SerialPortPrivate::dataBits() const
 {
-    return m_dataBits;
+    return options.dataBits;
 }
 
 /*! \internal
@@ -175,8 +168,8 @@ SerialPort::DataBits SerialPortPrivate::dataBits() const
 */
 bool SerialPortPrivate::setParity(SerialPort::Parity parity)
 {
-    if (m_engine->setParity(parity)) {
-        m_parity = parity;
+    if (engine->setParity(parity)) {
+        options.parity = parity;
         return true;
     }
     return false;
@@ -189,7 +182,7 @@ bool SerialPortPrivate::setParity(SerialPort::Parity parity)
 */
 SerialPort::Parity SerialPortPrivate::parity() const
 {
-    return m_parity;
+    return options.parity;
 }
 
 /*! \internal
@@ -200,8 +193,8 @@ SerialPort::Parity SerialPortPrivate::parity() const
 */
 bool SerialPortPrivate::setStopBits(SerialPort::StopBits stopBits)
 {
-    if (m_engine->setStopBits(stopBits)) {
-        m_stopBits = stopBits;
+    if (engine->setStopBits(stopBits)) {
+        options.stopBits = stopBits;
         return true;
     }
     return false;
@@ -214,7 +207,7 @@ bool SerialPortPrivate::setStopBits(SerialPort::StopBits stopBits)
 */
 SerialPort::StopBits SerialPortPrivate::stopBits() const
 {
-    return m_stopBits;
+    return options.stopBits;
 }
 
 /*! \internal
@@ -225,8 +218,8 @@ SerialPort::StopBits SerialPortPrivate::stopBits() const
 */
 bool SerialPortPrivate::setFlowControl(SerialPort::FlowControl flow)
 {
-    if (m_engine->setFlowControl(flow)) {
-        m_flow = flow;
+    if (engine->setFlowControl(flow)) {
+        options.flow = flow;
         return true;
     }
     return false;
@@ -239,7 +232,7 @@ bool SerialPortPrivate::setFlowControl(SerialPort::FlowControl flow)
 */
 SerialPort::FlowControl SerialPortPrivate::flowControl() const
 {
-    return m_flow;
+    return options.flow;
 }
 
 /*! \internal
@@ -249,7 +242,7 @@ SerialPort::FlowControl SerialPortPrivate::flowControl() const
 */
 bool SerialPortPrivate::dtr() const
 {
-    return m_engine->lines() & SerialPort::Dtr;
+    return engine->lines() & SerialPort::Dtr;
 }
 
 /*! \internal
@@ -259,7 +252,7 @@ bool SerialPortPrivate::dtr() const
 */
 bool SerialPortPrivate::rts() const
 {
-    return m_engine->lines() & SerialPort::Rts;
+    return engine->lines() & SerialPort::Rts;
 }
 
 /*! \internal
@@ -269,7 +262,7 @@ bool SerialPortPrivate::rts() const
 */
 bool SerialPortPrivate::setDtr(bool set)
 {
-    return m_engine->setDtr(set);
+    return engine->setDtr(set);
 }
 
 /*! \internal
@@ -279,7 +272,7 @@ bool SerialPortPrivate::setDtr(bool set)
 */
 bool SerialPortPrivate::setRts(bool set)
 {
-    return m_engine->setRts(set);
+    return engine->setRts(set);
 }
 
 /*! \internal
@@ -289,7 +282,7 @@ bool SerialPortPrivate::setRts(bool set)
 */
 SerialPort::Lines SerialPortPrivate::lines() const
 {
-    return m_engine->lines();
+    return engine->lines();
 }
 
 /*! \internal
@@ -306,32 +299,32 @@ bool SerialPortPrivate::flush()
 {
     Q_Q(SerialPort);
 
-    if (m_writeBuffer.isEmpty())
+    if (writeBuffer.isEmpty())
         return false;
 
-    int nextSize = m_writeBuffer.nextDataBlockSize();
-    const char *ptr = m_writeBuffer.readPointer();
+    int nextSize = writeBuffer.nextDataBlockSize();
+    const char *ptr = writeBuffer.readPointer();
 
     // Attempt to write it all in one chunk.
     qint64 written = write(ptr, nextSize);
     if (written < 0) {
-        m_writeBuffer.clear();
+        writeBuffer.clear();
         return false;
     }
 
     // Remove what we wrote so far.
-    m_writeBuffer.free(written);
+    writeBuffer.free(written);
     if (written > 0) {
         // Don't emit bytesWritten() recursively.
-        if (!m_emittedBytesWritten) {
-            m_emittedBytesWritten = true;
+        if (!emittedBytesWritten) {
+            emittedBytesWritten = true;
             emit q->bytesWritten(written);
-            m_emittedBytesWritten = false;
+            emittedBytesWritten = false;
         }
     }
 
-    if (m_writeBuffer.isEmpty() && m_engine->isWriteNotificationEnabled())
-        m_engine->setWriteNotificationEnabled(false);
+    if (writeBuffer.isEmpty() && engine->isWriteNotificationEnabled())
+        engine->setWriteNotificationEnabled(false);
 
     return true;
 }
@@ -344,7 +337,7 @@ bool SerialPortPrivate::flush()
 */
 bool SerialPortPrivate::reset()
 {
-    return m_engine->reset();
+    return engine->reset();
 }
 
 /*! \internal
@@ -355,7 +348,7 @@ bool SerialPortPrivate::reset()
 */
 bool SerialPortPrivate::sendBreak(int duration)
 {
-    return m_engine->sendBreak(duration);
+    return engine->sendBreak(duration);
 }
 
 /*! \internal
@@ -365,7 +358,7 @@ bool SerialPortPrivate::sendBreak(int duration)
 */
 bool SerialPortPrivate::setBreak(bool set)
 {
-    return m_engine->setBreak(set);
+    return engine->setBreak(set);
 }
 
 /*! \internal
@@ -378,9 +371,9 @@ bool SerialPortPrivate::setBreak(bool set)
 */
 bool SerialPortPrivate::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
 {
-    const bool ret = (policy == m_policy) || m_engine->setDataErrorPolicy(policy);
+    const bool ret = (options.policy == policy) || engine->setDataErrorPolicy(policy);
     if (ret)
-        m_policy = policy;
+        options.policy = policy;
     return ret;
 }
 
@@ -390,7 +383,7 @@ bool SerialPortPrivate::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
 */
 SerialPort::DataErrorPolicy SerialPortPrivate::dataErrorPolicy() const
 {
-    return m_policy;
+    return options.policy;
 }
 
 /*! \internal
@@ -399,7 +392,7 @@ SerialPort::DataErrorPolicy SerialPortPrivate::dataErrorPolicy() const
 */
 SerialPort::PortError SerialPortPrivate::error() const
 {
-    return m_portError;
+    return portError;
 }
 
 /*! \internal
@@ -408,7 +401,7 @@ SerialPort::PortError SerialPortPrivate::error() const
 */
 void SerialPortPrivate::unsetError()
 {
-    m_portError = SerialPort::NoError;
+    portError = SerialPort::NoError;
 }
 
 /*! \internal
@@ -417,7 +410,7 @@ void SerialPortPrivate::unsetError()
 */
 void SerialPortPrivate::setError(SerialPort::PortError error)
 {
-    m_portError = error;
+    portError = error;
 }
 
 /*! \internal
@@ -428,7 +421,7 @@ void SerialPortPrivate::setError(SerialPort::PortError error)
 */
 qint64 SerialPortPrivate::bytesAvailable() const
 {
-    return m_engine->bytesAvailable();
+    return engine->bytesAvailable();
 }
 
 /*! \internal
@@ -439,7 +432,7 @@ qint64 SerialPortPrivate::bytesAvailable() const
 */
 qint64 SerialPortPrivate::bytesToWrite() const
 {
-    return m_engine->bytesToWrite();
+    return engine->bytesToWrite();
 }
 
 /*! \internal
@@ -451,7 +444,7 @@ qint64 SerialPortPrivate::bytesToWrite() const
 */
 qint64 SerialPortPrivate::read(char *data, qint64 len)
 {
-    return m_engine->read(data, len);
+    return engine->read(data, len);
 }
 
 /*! \internal
@@ -463,7 +456,7 @@ qint64 SerialPortPrivate::read(char *data, qint64 len)
 */
 qint64 SerialPortPrivate::write(const char *data, qint64 len)
 {
-    return m_engine->write(data, len);
+    return engine->write(data, len);
 }
 
 /*! \internal
@@ -485,7 +478,7 @@ bool SerialPortPrivate::waitForReadOrWrite(int timeout,
                                            bool checkRead, bool checkWrite,
                                            bool *selectForRead, bool *selectForWrite)
 {
-    return m_engine->select(timeout, checkRead, checkWrite, selectForRead, selectForWrite);
+    return engine->select(timeout, checkRead, checkWrite, selectForRead, selectForWrite);
 }
 
 /*! \internal
@@ -494,8 +487,8 @@ bool SerialPortPrivate::waitForReadOrWrite(int timeout,
 */
 void SerialPortPrivate::clearBuffers()
 {
-    m_writeBuffer.clear();
-    m_readBuffer.clear();
+    writeBuffer.clear();
+    readBuffer.clear();
 }
 
 /*! \internal
@@ -507,26 +500,26 @@ void SerialPortPrivate::clearBuffers()
 */
 bool SerialPortPrivate::readFromPort()
 {
-    qint64 bytesToRead = (m_policy == SerialPort::IgnorePolicy) ?
+    qint64 bytesToRead = (options.policy == SerialPort::IgnorePolicy) ?
                 bytesAvailable() : 1;
 
     if (bytesToRead <= 0)
         return false;
 
-    if (m_readBufferMaxSize
-            && (bytesToRead > (m_readBufferMaxSize - m_readBuffer.size()))) {
+    if (readBufferMaxSize
+            && (bytesToRead > (readBufferMaxSize - readBuffer.size()))) {
 
-        bytesToRead = m_readBufferMaxSize - m_readBuffer.size();
+        bytesToRead = readBufferMaxSize - readBuffer.size();
     }
 
-    char *ptr = m_readBuffer.reserve(bytesToRead);
+    char *ptr = readBuffer.reserve(bytesToRead);
     qint64 readBytes = read(ptr, bytesToRead);
 
     if (readBytes <= 0) {
-        m_readBuffer.chop(bytesToRead);
+        readBuffer.chop(bytesToRead);
         return false;
     }
-    m_readBuffer.chop(int(bytesToRead - ((readBytes < 0) ? qint64(0) : readBytes)));
+    readBuffer.chop(int(bytesToRead - ((readBytes < 0) ? qint64(0) : readBytes)));
     return true;
 }
 
@@ -541,71 +534,71 @@ bool SerialPortPrivate::canReadNotification()
     Q_Q(SerialPort);
 
 #if defined (Q_OS_WINCE)
-    m_engine->lockNotification(SerialPortEngine::CanReadLocker, true);
+    engine->lockNotification(SerialPortEngine::CanReadLocker, true);
 #endif
     // Prevent recursive calls.
-    if (m_readSerialNotifierCalled) {
-        if (!m_readSerialNotifierStateSet) {
-            m_readSerialNotifierStateSet = true;
-            m_readSerialNotifierState = m_engine->isReadNotificationEnabled();
-            m_engine->setReadNotificationEnabled(false);
+    if (readSerialNotifierCalled) {
+        if (!readSerialNotifierStateSet) {
+            readSerialNotifierStateSet = true;
+            readSerialNotifierState = engine->isReadNotificationEnabled();
+            engine->setReadNotificationEnabled(false);
         }
     }
-    m_readSerialNotifierCalled = true;
+    readSerialNotifierCalled = true;
 
-    //if (!m_isBuffered)
+    //if (!isBuffered)
     //    this->serialEngine->setReadNotificationEnabled(false);
 
     // If buffered, read data from the serial into the read buffer.
     qint64 newBytes = 0;
-    if (m_isBuffered) {
+    if (isBuffered) {
         // Return if there is no space in the buffer.
-        if (m_readBufferMaxSize
-                && (m_readBuffer.size() >= m_readBufferMaxSize)) {
+        if (readBufferMaxSize
+                && (readBuffer.size() >= readBufferMaxSize)) {
 
-            m_readSerialNotifierCalled = false;
+            readSerialNotifierCalled = false;
             return false;
         }
 
         // If reading from the serial fails after getting a read
         // notification, close the serial.
-        newBytes = m_readBuffer.size();
+        newBytes = readBuffer.size();
 
         if (!readFromPort()) {
-            m_readSerialNotifierCalled = false;
+            readSerialNotifierCalled = false;
             return false;
         }
-        newBytes = m_readBuffer.size() - newBytes;
+        newBytes = readBuffer.size() - newBytes;
 
         // If read buffer is full, disable the read serial notifier.
-        if (m_readBufferMaxSize
-                && (m_readBuffer.size() == m_readBufferMaxSize)) {
+        if (readBufferMaxSize
+                && (readBuffer.size() == readBufferMaxSize)) {
 
-            m_engine->setReadNotificationEnabled(false);
+            engine->setReadNotificationEnabled(false);
         }
     }
 
     // Only emit readyRead() when not recursing, and only if there is data available.
-    bool hasData = (m_isBuffered) ? (newBytes > 0) : (bytesAvailable() > 0);
+    bool hasData = (isBuffered) ? (newBytes > 0) : (bytesAvailable() > 0);
 
-    if ((!m_emittedReadyRead) && hasData) {
-        m_emittedReadyRead = true;
+    if ((!emittedReadyRead) && hasData) {
+        emittedReadyRead = true;
         emit q->readyRead();
-        m_emittedReadyRead = false;
+        emittedReadyRead = false;
     }
 
-    if ((!hasData) && m_engine->isReadNotificationEnabled())
-        m_engine->setReadNotificationEnabled(true);
+    if ((!hasData) && engine->isReadNotificationEnabled())
+        engine->setReadNotificationEnabled(true);
 
     // Reset the read serial notifier state if we reentered inside the
     // readyRead() connected slot.
-    if (m_readSerialNotifierStateSet &&
-            (m_readSerialNotifierState != m_engine->isReadNotificationEnabled())) {
+    if (readSerialNotifierStateSet &&
+            (readSerialNotifierState != engine->isReadNotificationEnabled())) {
 
-        m_engine->setReadNotificationEnabled(m_readSerialNotifierState);
-        m_readSerialNotifierStateSet = false;
+        engine->setReadNotificationEnabled(readSerialNotifierState);
+        readSerialNotifierStateSet = false;
     }
-    m_readSerialNotifierCalled = false;
+    readSerialNotifierCalled = false;
     return true;
 }
 
@@ -618,25 +611,25 @@ bool SerialPortPrivate::canReadNotification()
 bool SerialPortPrivate::canWriteNotification()
 {
 #if defined (Q_OS_WINCE)
-    m_engine->lockNotification(SerialPortEngine::CanWriteLocker, true);
+    engine->lockNotification(SerialPortEngine::CanWriteLocker, true);
 #endif
 
 #if defined (Q_OS_WIN)
-    if (m_engine->isWriteNotificationEnabled())
-        m_engine->setWriteNotificationEnabled(false);
+    if (engine->isWriteNotificationEnabled())
+        engine->setWriteNotificationEnabled(false);
 #endif
 
-    int tmp = m_writeBuffer.size();
+    int tmp = writeBuffer.size();
     flush();
 
 #if defined (Q_OS_WIN)
-    if (!m_writeBuffer.isEmpty())
-        m_engine->setWriteNotificationEnabled(true);
+    if (!writeBuffer.isEmpty())
+        engine->setWriteNotificationEnabled(true);
 #else
-    if (m_writeBuffer.isEmpty())
-        m_engine->setWriteNotificationEnabled(false);
+    if (writeBuffer.isEmpty())
+        engine->setWriteNotificationEnabled(false);
 #endif
-    return (m_writeBuffer.size() < tmp);
+    return (writeBuffer.size() < tmp);
 }
 
 /*! \internal
@@ -649,9 +642,9 @@ bool SerialPortPrivate::canWriteNotification()
 bool SerialPortPrivate::canErrorNotification()
 {
 #if defined (Q_OS_WINCE)
-    m_engine->lockNotification(SerialPortEngine::CanErrorLocker, true);
+    engine->lockNotification(SerialPortEngine::CanErrorLocker, true);
 #endif
-    return m_engine->processIOErrors();
+    return engine->processIOErrors();
 }
 
 //----------------------------------------------------------------
@@ -1101,11 +1094,11 @@ bool SerialPort::open(OpenMode mode)
         d->clearBuffers();
 
         if (mode & ReadOnly)
-            d->m_engine->setReadNotificationEnabled(true);
+            d->engine->setReadNotificationEnabled(true);
         if (mode & WriteOnly)
-            d->m_engine->setWriteNotificationEnabled(true);
+            d->engine->setWriteNotificationEnabled(true);
 
-        d->m_isBuffered = !(mode & Unbuffered);
+        d->isBuffered = !(mode & Unbuffered);
         return true;
     }
     return false;
@@ -1127,8 +1120,8 @@ void SerialPort::close()
 
     flush();
     QIODevice::close();
-    d->m_engine->setReadNotificationEnabled(false);
-    d->m_engine->setWriteNotificationEnabled(false);
+    d->engine->setReadNotificationEnabled(false);
+    d->engine->setWriteNotificationEnabled(false);
     d->clearBuffers();
     d->close();
 }
@@ -1144,7 +1137,7 @@ void SerialPort::close()
 void SerialPort::setRestoreSettingsOnClose(bool restore)
 {
     Q_D( SerialPort);
-    d->m_restoreSettingsOnClose = restore;
+    d->options.restoreSettingsOnClose = restore;
 }
 
 /*!
@@ -1157,7 +1150,7 @@ void SerialPort::setRestoreSettingsOnClose(bool restore)
 bool SerialPort::restoreSettingsOnClose() const
 {
     Q_D(const SerialPort);
-    return d->m_restoreSettingsOnClose;
+    return d->options.restoreSettingsOnClose;
 }
 
 /*!
@@ -1344,7 +1337,7 @@ SerialPort::Lines SerialPort::lines() const
 bool SerialPort::flush()
 {
     Q_D(SerialPort);
-    return d->flush() || d->m_engine->flush();
+    return d->flush() || d->engine->flush();
 }
 
 /*! \reimp
@@ -1376,7 +1369,7 @@ bool SerialPort::reset()
 bool SerialPort::atEnd() const
 {
     Q_D(const SerialPort);
-    return QIODevice::atEnd() && (!isOpen() || d->m_readBuffer.isEmpty());
+    return QIODevice::atEnd() && (!isOpen() || d->readBuffer.isEmpty());
 }
 
 /*!
@@ -1442,7 +1435,7 @@ void SerialPort::unsetError()
 qint64 SerialPort::readBufferSize() const
 {
     Q_D(const SerialPort);
-    return d->m_readBufferMaxSize;
+    return d->readBufferMaxSize;
 }
 
 /*!
@@ -1465,16 +1458,16 @@ void SerialPort::setReadBufferSize(qint64 size)
 {
     Q_D(SerialPort);
 
-    if (d->m_readBufferMaxSize == size)
+    if (d->readBufferMaxSize == size)
         return;
-    d->m_readBufferMaxSize = size;
-    if (!d->m_readSerialNotifierCalled && d->m_engine) {
+    d->readBufferMaxSize = size;
+    if (!d->readSerialNotifierCalled && d->engine) {
         // Ensure that the read notification is enabled if we've now got
         // room in the read buffer.
         // But only if we're not inside canReadNotification --
         // that will take care on its own.
-        if (size == 0 || d->m_readBuffer.size() < size)
-            d->m_engine->setReadNotificationEnabled(true);
+        if (size == 0 || d->readBuffer.size() < size)
+            d->engine->setReadNotificationEnabled(true);
     }
 }
 
@@ -1495,8 +1488,8 @@ qint64 SerialPort::bytesAvailable() const
 {
     Q_D(const SerialPort);
     qint64 ret;
-    if (d->m_isBuffered)
-        ret = qint64(d->m_readBuffer.size());
+    if (d->isBuffered)
+        ret = qint64(d->readBuffer.size());
     else
         ret = d->bytesAvailable();
     return ret + QIODevice::bytesAvailable();
@@ -1513,8 +1506,8 @@ qint64 SerialPort::bytesToWrite() const
 {
     Q_D(const SerialPort);
     qint64 ret;
-    if (d->m_isBuffered)
-        ret = qint64(d->m_writeBuffer.size());
+    if (d->isBuffered)
+        ret = qint64(d->writeBuffer.size());
     else
         ret = d->bytesToWrite();
     return ret + QIODevice::bytesToWrite();
@@ -1529,7 +1522,7 @@ qint64 SerialPort::bytesToWrite() const
 bool SerialPort::canReadLine() const
 {
     Q_D(const SerialPort);
-    bool hasLine = d->m_readBuffer.canReadLine();
+    bool hasLine = d->readBuffer.canReadLine();
     return (hasLine || QIODevice::canReadLine());
 }
 
@@ -1557,11 +1550,11 @@ bool SerialPort::waitForReadyRead(int msecs)
 {
     Q_D(SerialPort);
 
-    if (d->m_isBuffered && (!d->m_readBuffer.isEmpty()))
+    if (d->isBuffered && (!d->readBuffer.isEmpty()))
         return true;
 
-    if (d->m_engine->isReadNotificationEnabled())
-        d->m_engine->setReadNotificationEnabled(false);
+    if (d->engine->isReadNotificationEnabled())
+        d->engine->setReadNotificationEnabled(false);
 
 #if QT_VERSION >= 0x040700
     QElapsedTimer stopWatch;
@@ -1575,7 +1568,7 @@ bool SerialPort::waitForReadyRead(int msecs)
         bool readyToRead = false;
         bool readyToWrite = false;
         if (!d->waitForReadOrWrite(qt_timeout_value(msecs, stopWatch.elapsed()),
-                                   true, (!d->m_writeBuffer.isEmpty()),
+                                   true, (!d->writeBuffer.isEmpty()),
                                    &readyToRead, &readyToWrite)) {
             return false;
         }
@@ -1595,7 +1588,7 @@ bool SerialPort::waitForBytesWritten(int msecs)
 {
     Q_D(SerialPort);
 
-    if (d->m_isBuffered && d->m_writeBuffer.isEmpty())
+    if (d->isBuffered && d->writeBuffer.isEmpty())
         return false;
 
 #if QT_VERSION >= 0x040700
@@ -1610,7 +1603,7 @@ bool SerialPort::waitForBytesWritten(int msecs)
         bool readyToRead = false;
         bool readyToWrite = false;
         if (!d->waitForReadOrWrite(qt_timeout_value(msecs, stopWatch.elapsed()),
-                                   true, (!d->m_writeBuffer.isEmpty()),
+                                   true, (!d->writeBuffer.isEmpty()),
                                    &readyToRead, &readyToWrite)) {
             return false;
         }
@@ -1702,32 +1695,32 @@ qint64 SerialPort::readData(char *data, qint64 maxSize)
 {
     Q_D(SerialPort);
 
-    if (d->m_engine->isReadNotificationEnabled() && d->m_isBuffered)
-        d->m_engine->setReadNotificationEnabled(true);
+    if (d->engine->isReadNotificationEnabled() && d->isBuffered)
+        d->engine->setReadNotificationEnabled(true);
 
-    if (!d->m_isBuffered) {
+    if (!d->isBuffered) {
         qint64 readBytes = d->read(data, maxSize);
         return readBytes;
     }
 
-    if (d->m_readBuffer.isEmpty())
+    if (d->readBuffer.isEmpty())
         return qint64(0);
 
     // If readFromSerial() read data, copy it to its destination.
     if (maxSize == 1) {
-        *data = d->m_readBuffer.getChar();
+        *data = d->readBuffer.getChar();
         return 1;
     }
 
-    qint64 bytesToRead = qMin(qint64(d->m_readBuffer.size()), maxSize);
+    qint64 bytesToRead = qMin(qint64(d->readBuffer.size()), maxSize);
     qint64 readSoFar = 0;
     while (readSoFar < bytesToRead) {
-        const char *ptr = d->m_readBuffer.readPointer();
+        const char *ptr = d->readBuffer.readPointer();
         int bytesToReadFromThisBlock = qMin(int(bytesToRead - readSoFar),
-                                            d->m_readBuffer.nextDataBlockSize());
+                                            d->readBuffer.nextDataBlockSize());
         memcpy(data + readSoFar, ptr, bytesToReadFromThisBlock);
         readSoFar += bytesToReadFromThisBlock;
-        d->m_readBuffer.free(bytesToReadFromThisBlock);
+        d->readBuffer.free(bytesToReadFromThisBlock);
     }
     return readSoFar;
 }
@@ -1745,12 +1738,12 @@ qint64 SerialPort::writeData(const char *data, qint64 maxSize)
 {
     Q_D(SerialPort);
 
-    if (!d->m_isBuffered) {
+    if (!d->isBuffered) {
         qint64 written = d->write(data, maxSize);
         if (written < 0) {
             //Error
-        } else if (!d->m_writeBuffer.isEmpty()) {
-            d->m_engine->setWriteNotificationEnabled(true);
+        } else if (!d->writeBuffer.isEmpty()) {
+            d->engine->setWriteNotificationEnabled(true);
         }
 
         if (written >= 0)
@@ -1759,14 +1752,14 @@ qint64 SerialPort::writeData(const char *data, qint64 maxSize)
         return written;
     }
 
-    char *ptr = d->m_writeBuffer.reserve(maxSize);
+    char *ptr = d->writeBuffer.reserve(maxSize);
     if (maxSize == 1)
         *ptr = *data;
     else
         memcpy(ptr, data, maxSize);
 
-    if (!d->m_writeBuffer.isEmpty())
-        d->m_engine->setWriteNotificationEnabled(true);
+    if (!d->writeBuffer.isEmpty())
+        d->engine->setWriteNotificationEnabled(true);
 
     return maxSize;
 }
diff --git a/src/serialport_p.h b/src/serialport_p.h
old mode 100644
new mode 100755
index 3576d51..b91e6e2
--- a/src/serialport_p.h
+++ b/src/serialport_p.h
@@ -12,6 +12,32 @@ QT_BEGIN_NAMESPACE_SERIALPORT
 
 class SerialPortEngine;
 
+// General port parameters (for any OS).
+class SerialPortOptions
+{
+public:
+    SerialPortOptions()
+        : inputRate(SerialPort::UnknownRate)
+        , outputRate(SerialPort::UnknownRate)
+        , dataBits(SerialPort::UnknownDataBits)
+        , parity(SerialPort::UnknownParity)
+        , stopBits(SerialPort::UnknownStopBits)
+        , flow(SerialPort::UnknownFlowControl)
+        , policy(SerialPort::IgnorePolicy)
+        , restoreSettingsOnClose(true)
+    {}
+
+    QString systemLocation;
+    qint32 inputRate;
+    qint32 outputRate;
+    SerialPort::DataBits dataBits;
+    SerialPort::Parity parity;
+    SerialPort::StopBits stopBits;
+    SerialPort::FlowControl flow;
+    SerialPort::DataErrorPolicy policy;
+    bool restoreSettingsOnClose;
+};
+
 class SerialPortPrivate
 {
     Q_DECLARE_PUBLIC(SerialPort)
@@ -77,30 +103,26 @@ public:
     bool canWriteNotification();
     bool canErrorNotification();
 
-    qint64 m_readBufferMaxSize;
-    RingBuffer m_readBuffer;
-    RingBuffer m_writeBuffer;
-    bool m_isBuffered;
-    bool m_readSerialNotifierCalled;
-    bool m_readSerialNotifierState;
-    bool m_readSerialNotifierStateSet;
-    bool m_emittedReadyRead;
-    bool m_emittedBytesWritten;
-
-    SerialPortEngine *m_engine;
-
-    // General port parameters (for any OS).
-    SerialPort *q_ptr;
-    QString m_systemLocation;
-    qint32 m_inRate;
-    qint32 m_outRate;
-    SerialPort::DataBits m_dataBits;
-    SerialPort::Parity m_parity;
-    SerialPort::StopBits m_stopBits;
-    SerialPort::FlowControl m_flow;
-    SerialPort::DataErrorPolicy m_policy;
-    SerialPort::PortError m_portError;
-    bool m_restoreSettingsOnClose;
+public:
+    qint64 readBufferMaxSize;
+    RingBuffer readBuffer;
+    RingBuffer writeBuffer;
+    bool isBuffered;
+
+    bool readSerialNotifierCalled;
+    bool readSerialNotifierState;
+    bool readSerialNotifierStateSet;
+    bool emittedReadyRead;
+    bool emittedBytesWritten;
+
+    SerialPort::PortError portError;
+
+    SerialPortEngine *engine;
+
+    SerialPortOptions options;
+
+private:
+    SerialPort * const q_ptr;
 };
 
 QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialportengine_p.h b/src/serialportengine_p.h
old mode 100644
new mode 100755
index e163342..d707dfb
--- a/src/serialportengine_p.h
+++ b/src/serialportengine_p.h
@@ -15,6 +15,7 @@ class SerialPortEngine
 public:
 
 #if defined (Q_OS_WINCE)
+    // FIXME
     // Only for WinCE.
     enum NotificationLockerType {
         CanReadLocker,
@@ -25,7 +26,7 @@ public:
 
     virtual ~SerialPortEngine() {}
 
-    static SerialPortEngine *create(SerialPortPrivate *parent);
+    static SerialPortEngine *create(SerialPortPrivate *d);
 
     virtual bool open(const QString &location, QIODevice::OpenMode mode) = 0;
     virtual void close(const QString &location) = 0;
@@ -69,14 +70,16 @@ public:
     virtual bool processIOErrors() = 0;
 
 #if defined (Q_OS_WINCE)
+    // FIXME
     virtual void lockNotification(NotificationLockerType type, bool uselocker) = 0;
     virtual void unlockNotification(NotificationLockerType type) = 0;
 #endif
 
 protected:
-    SerialPortPrivate *m_parent;
-
     virtual void detectDefaultSettings() = 0;
+
+protected:
+    SerialPortPrivate *dptr;
 };
 
 QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialportengine_symbian.cpp b/src/serialportengine_symbian.cpp
old mode 100644
new mode 100755
index 175a193..1c242f3
--- a/src/serialportengine_symbian.cpp
+++ b/src/serialportengine_symbian.cpp
@@ -101,11 +101,11 @@ QT_BEGIN_NAMESPACE_SERIALPORT
     A pointer \a parent to the object class SerialPortPrivate
     is required for the recursive call some of its methods.
 */
-SymbianSerialPortEngine::SymbianSerialPortEngine(SerialPortPrivate *parent)
+SymbianSerialPortEngine::SymbianSerialPortEngine(SerialPortPrivate *d)
 {
-    Q_ASSERT(parent);
+    Q_ASSERT(d);
     // Impl me
-    m_parent = parent;
+    dptr = d;
 }
 
 /*!
@@ -137,14 +137,14 @@ bool SymbianSerialPortEngine::open(const QString &location, QIODevice::OpenMode
     Q_UNUSED(mode)
 
     if (!loadDevices()) {
-        m_parent->setError(SerialPort::UnknownPortError);
+        dptr->setError(SerialPort::UnknownPortError);
         return false;
     }
 
     RCommServ server;
     TInt r = server.Connect();
     if (r != KErrNone) {
-        m_parent->setError(SerialPort::UnknownPortError);
+        dptr->setError(SerialPort::UnknownPortError);
         return false;
     }
 
@@ -158,7 +158,7 @@ bool SymbianSerialPortEngine::open(const QString &location, QIODevice::OpenMode
         r = server.LoadCommModule(KRS232ModuleName);
 
     if (r != KErrNone) {
-        m_parent->setError(SerialPort::UnknownPortError);
+        dptr->setError(SerialPort::UnknownPortError);
         return false;
     }
 
@@ -169,20 +169,20 @@ bool SymbianSerialPortEngine::open(const QString &location, QIODevice::OpenMode
     if (r != KErrNone) {
         switch (r) {
         case KErrPermissionDenied:
-            m_parent->setError(SerialPort::NoSuchDeviceError); break;
+            dptr->setError(SerialPort::NoSuchDeviceError); break;
         case KErrLocked:
         case KErrAccessDenied:
-            m_parent->setError(SerialPort::PermissionDeniedError); break;
+            dptr->setError(SerialPort::PermissionDeniedError); break;
         default:
-            m_parent->setError(SerialPort::UnknownPortError);
+            dptr->setError(SerialPort::UnknownPortError);
         }
         return false;
     }
 
     // Save current port settings.
-    r = m_descriptor.Config(m_oldSettings);
+    r = m_descriptor.Config(m_restoredSettings);
     if (r != KErrNone) {
-        m_parent->setError(SerialPort::UnknownPortError);
+        dptr->setError(SerialPort::UnknownPortError);
         return false;
     }
 
@@ -198,8 +198,8 @@ void SymbianSerialPortEngine::close(const QString &location)
 {
     Q_UNUSED(location);
 
-    if (m_parent->m_restoreSettingsOnClose) {
-        m_descriptor.SetConfig(m_oldSettings);
+    if (dptr->options.restoreSettingsOnClose) {
+        m_descriptor.SetConfig(m_restoredSettings);
     }
 
     m_descriptor.Close();
@@ -354,13 +354,13 @@ qint64 SymbianSerialPortEngine::bytesToWrite() const
 
     Reads data from a serial port only if it arrives before a
     specified time-out (zero). All reads from the serial device
-    use 8-bit descriptors as data buffers, even on a Unicode system.
+    use 8-bit m_descriptors as data buffers, even on a Unicode system.
 
     The length of the TDes8 is set to zero on entry, which means that
     buffers can be reused without having to be zeroed first.
 
     The number of bytes to read is set to the maximum length of the
-    descriptor.
+    m_descriptor.
 
     If a read is issued with a data length of zero the Read() completes
     immediately but with the side effect that the serial hardware is
@@ -369,7 +369,7 @@ qint64 SymbianSerialPortEngine::bytesToWrite() const
     When a Read() terminates with KErrTimedOut, different protocol
     modules can show different behaviours. Some may write any data
     received into the aDes buffer, while others may return just an
-    empty descriptor. In the case of a returned empty descriptor use
+    empty m_descriptor. In the case of a returned empty m_descriptor use
     ReadOneOrMore() to read any data left in the buffer.
 
     The behaviour of this API after a call to NotifyDataAvailable() is
@@ -387,7 +387,7 @@ qint64 SymbianSerialPortEngine::read(char *data, qint64 len)
     User::WaitForRequest(status);
     TInt err = status.Int();
     if (err != KErrNone) {
-        m_parent->setError(SerialPort::IoError);
+        dptr->setError(SerialPort::IoError);
         return qint64(-1);
     }
     return qint64(buffer.Length());
@@ -396,10 +396,10 @@ qint64 SymbianSerialPortEngine::read(char *data, qint64 len)
 /*!
 
     Writes data to a serial port. All writes to the serial device
-    use 8-bit descriptors as data buffers, even on a Unicode system.
+    use 8-bit m_descriptors as data buffers, even on a Unicode system.
 
     The number of bytes to write is set to the maximum length of
-    the descriptor.
+    the m_descriptor.
 
     When a Write() is issued with a data length of zero it cannot
     complete until the current handshaking configuration and the
@@ -420,7 +420,7 @@ qint64 SymbianSerialPortEngine::write(const char *data, qint64 len)
     TInt err = status.Int();
 
     if (err != KErrNone) {
-        m_parent->setError(SerialPort::IoError);
+        dptr->setError(SerialPort::IoError);
         len = -1;
     }
     // FIXME: How to get the actual number of bytes written?
@@ -537,89 +537,89 @@ QString SymbianSerialPortEngine::fromSystemLocation(const QString &location) con
 bool SymbianSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 {
     if (dir != SerialPort::AllDirections) {
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
 
     switch (rate) {
     case 50:
-        m_currSettings().iRate = EBps50;
+        m_currentSettings().iRate = EBps50;
         break;
     case 75:
-        m_currSettings().iRate = EBps75;
+        m_currentSettings().iRate = EBps75;
         break;
     case 110:
-        m_currSettings().iRate = EBps110;
+        m_currentSettings().iRate = EBps110;
         break;
     case 134:
-        m_currSettings().iRate = EBps134;
+        m_currentSettings().iRate = EBps134;
         break;
     case 150:
-        m_currSettings().iRate = EBps150;
+        m_currentSettings().iRate = EBps150;
         break;
     case 300:
-        m_currSettings().iRate = EBps300;
+        m_currentSettings().iRate = EBps300;
         break;
     case 600:
-        m_currSettings().iRate = EBps600;
+        m_currentSettings().iRate = EBps600;
         break;
     case 1200:
-        m_currSettings().iRate = EBps1200;
+        m_currentSettings().iRate = EBps1200;
         break;
     case 1800:
-        m_currSettings().iRate = EBps1800;
+        m_currentSettings().iRate = EBps1800;
         break;
     case 2000:
-        m_currSettings().iRate = EBps2000;
+        m_currentSettings().iRate = EBps2000;
         break;
     case 2400:
-        m_currSettings().iRate = EBps2400;
+        m_currentSettings().iRate = EBps2400;
         break;
     case 3600:
-        m_currSettings().iRate = EBps3600;
+        m_currentSettings().iRate = EBps3600;
         break;
     case 4800:
-        m_currSettings().iRate = EBps4800;
+        m_currentSettings().iRate = EBps4800;
         break;
     case 7200:
-        m_currSettings().iRate = EBps7200;
+        m_currentSettings().iRate = EBps7200;
         break;
     case 9600:
-        m_currSettings().iRate = EBps9600;
+        m_currentSettings().iRate = EBps9600;
         break;
     case 19200:
-        m_currSettings().iRate = EBps19200;
+        m_currentSettings().iRate = EBps19200;
         break;
     case 38400:
-        m_currSettings().iRate = EBps38400;
+        m_currentSettings().iRate = EBps38400;
         break;
     case 57600:
-        m_currSettings().iRate = EBps57600;
+        m_currentSettings().iRate = EBps57600;
         break;
     case 115200:
-        m_currSettings().iRate = EBps115200;
+        m_currentSettings().iRate = EBps115200;
         break;
     case 230400:
-        m_currSettings().iRate = EBps230400;
+        m_currentSettings().iRate = EBps230400;
         break;
     case 460800:
-        m_currSettings().iRate = EBps460800;
+        m_currentSettings().iRate = EBps460800;
         break;
     case 576000:
-        m_currSettings().iRate = EBps576000;
+        m_currentSettings().iRate = EBps576000;
         break;
     case 1152000:
-        m_currSettings().iRate = EBps1152000;
+        m_currentSettings().iRate = EBps1152000;
         break;
     case 4000000:
-        m_currSettings().iRate = EBps4000000;
+        m_currentSettings().iRate = EBps4000000;
         break;
     case 921600:
-        m_currSettings().iRate = EBps921600;
+        m_currentSettings().iRate = EBps921600;
         break;
         //case 1843200:; // Only for  Symbian SR1
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
 
@@ -637,19 +637,19 @@ bool SymbianSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 {
     switch (dataBits) {
     case SerialPort::Data5:
-        m_currSettings().iDataBits = EData5;
+        m_currentSettings().iDataBits = EData5;
         break;
     case SerialPort::Data6:
-        m_currSettings().iDataBits = EData6;
+        m_currentSettings().iDataBits = EData6;
         break;
     case SerialPort::Data7:
-        m_currSettings().iDataBits = EData7;
+        m_currentSettings().iDataBits = EData7;
         break;
     case SerialPort::Data8:
-        m_currSettings().iDataBits = EData8;
+        m_currentSettings().iDataBits = EData8;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
 
@@ -667,22 +667,22 @@ bool SymbianSerialPortEngine::setParity(SerialPort::Parity parity)
 {
     switch (parity) {
     case SerialPort::NoParity:
-        m_currSettings().iParity = EParityNone;
+        m_currentSettings().iParity = EParityNone;
         break;
     case SerialPort::EvenParity:
-        m_currSettings().iParity = EParityEven;
+        m_currentSettings().iParity = EParityEven;
         break;
     case SerialPort::OddParity:
-        m_currSettings().iParity = EParityOdd;
+        m_currentSettings().iParity = EParityOdd;
         break;
     case SerialPort::MarkParity:
-        m_currSettings().iParity = EParityMark;
+        m_currentSettings().iParity = EParityMark;
         break;
     case SerialPort::SpaceParity:
-        m_currSettings().iParity = EParitySpace;
+        m_currentSettings().iParity = EParitySpace;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
 
@@ -700,13 +700,13 @@ bool SymbianSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
 {
     switch (stopBits) {
     case SerialPort::OneStop:
-        m_currSettings().iStopBits = EStop1;
+        m_currentSettings().iStopBits = EStop1;
         break;
     case SerialPort::TwoStop:
-        m_currSettings().iStopBits = EStop2;
+        m_currentSettings().iStopBits = EStop2;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
 
@@ -725,16 +725,16 @@ bool SymbianSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
 {
     switch (flow) {
     case SerialPort::NoFlowControl:
-        m_currSettings().iHandshake = KConfigFailDSR;
+        m_currentSettings().iHandshake = KConfigFailDSR;
         break;
     case SerialPort::HardwareControl:
-        m_currSettings().iHandshake = KConfigObeyCTS | KConfigFreeRTS;
+        m_currentSettings().iHandshake = KConfigObeyCTS | KConfigFreeRTS;
         break;
     case SerialPort::SoftwareControl:
-        m_currSettings().iHandshake = KConfigObeyXoff | KConfigSendXoff;
+        m_currentSettings().iHandshake = KConfigObeyXoff | KConfigSendXoff;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
 
@@ -807,150 +807,150 @@ bool SymbianSerialPortEngine::processIOErrors()
 void SymbianSerialPortEngine::detectDefaultSettings()
 {
     // Detect rate.
-    switch (m_currSettings().iRate) {
+    switch (m_currentSettings().iRate) {
     case EBps50:
-        m_parent->m_inRate = 50;
+        dptr->options.inputRate = 50;
         break;
     case EBps75:
-        m_parent->m_inRate = 75;
+        dptr->options.inputRate = 75;
         break;
     case EBps110:
-        m_parent->m_inRate = 110;
+        dptr->options.inputRate = 110;
         break;
     case EBps134:
-        m_parent->m_inRate = 134;
+        dptr->options.inputRate = 134;
         break;
     case EBps150:
-        m_parent->m_inRate = 150;
+        dptr->options.inputRate = 150;
         break;
     case EBps300:
-        m_parent->m_inRate = 300;
+        dptr->options.inputRate = 300;
         break;
     case EBps600:
-        m_parent->m_inRate = 600;
+        dptr->options.inputRate = 600;
         break;
     case EBps1200:
-        m_parent->m_inRate = 1200;
+        dptr->options.inputRate = 1200;
         break;
     case EBps1800:
-        m_parent->m_inRate = 1800;
+        dptr->options.inputRate = 1800;
         break;
     case EBps2000:
-        m_parent->m_inRate = 2000;
+        dptr->options.inputRate = 2000;
         break;
     case EBps2400:
-        m_parent->m_inRate = 2400;
+        dptr->options.inputRate = 2400;
         break;
     case EBps3600:
-        m_parent->m_inRate = 3600;
+        dptr->options.inputRate = 3600;
         break;
     case EBps4800:
-        m_parent->m_inRate = 4800;
+        dptr->options.inputRate = 4800;
         break;
     case EBps7200:
-        m_parent->m_inRate = 7200;
+        dptr->options.inputRate = 7200;
         break;
     case EBps9600:
-        m_parent->m_inRate = 9600;
+        dptr->options.inputRate = 9600;
         break;
     case EBps19200:
-        m_parent->m_inRate = 19200;
+        dptr->options.inputRate = 19200;
         break;
     case EBps38400:
-        m_parent->m_inRate = 38400;
+        dptr->options.inputRate = 38400;
         break;
     case EBps57600:
-        m_parent->m_inRate = 57600;
+        dptr->options.inputRate = 57600;
         break;
     case EBps115200:
-        m_parent->m_inRate = 115200;
+        dptr->options.inputRate = 115200;
         break;
     case EBps230400:
-        m_parent->m_inRate = 230400;
+        dptr->options.inputRate = 230400;
         break;
     case EBps460800:
-        m_parent->m_inRate = 460800;
+        dptr->options.inputRate = 460800;
         break;
     case EBps576000:
-        m_parent->m_inRate = 576000;
+        dptr->options.inputRate = 576000;
         break;
     case EBps1152000:
-        m_parent->m_inRate = 1152000;
+        dptr->options.inputRate = 1152000;
         break;
     case EBps4000000:
-        m_parent->m_inRate = 4000000;
+        dptr->options.inputRate = 4000000;
         break;
     case EBps921600:
-        m_parent->m_inRate = 921600;
+        dptr->options.inputRate = 921600;
         break;
-        //case EBps1843200: m_inRate = 1843200; break;
+        //case EBps1843200: inRate = 1843200; break;
     default:
-        m_parent->m_inRate = SerialPort::UnknownRate;
+        dptr->options.inputRate = SerialPort::UnknownRate;
     }
-    m_parent->m_outRate = m_parent->m_inRate;
+    dptr->options.outputRate = dptr->options.inputRate;
 
     // Detect databits.
-    switch (m_currSettings().iDataBits) {
+    switch (m_currentSettings().iDataBits) {
     case EData5:
-        m_parent->m_dataBits = SerialPort::Data5;
+        dptr->options.dataBits = SerialPort::Data5;
         break;
     case EData6:
-        m_parent->m_dataBits = SerialPort::Data6;
+        dptr->options.dataBits = SerialPort::Data6;
         break;
     case EData7:
-        m_parent->m_dataBits = SerialPort::Data7;
+        dptr->options.dataBits = SerialPort::Data7;
         break;
     case EData8:
-        m_parent->m_dataBits = SerialPort::Data8;
+        dptr->options.dataBits = SerialPort::Data8;
         break;
     default:
-        m_parent->m_dataBits = SerialPort::UnknownDataBits;
+        dptr->options.dataBits = SerialPort::UnknownDataBits;
     }
 
     // Detect parity.
-    switch (m_currSettings().iParity) {
+    switch (m_currentSettings().iParity) {
     case EParityNone:
-        m_parent->m_parity = SerialPort::NoParity;
+        dptr->options.parity = SerialPort::NoParity;
         break;
     case EParityEven:
-        m_parent->m_parity = SerialPort::EvenParity;
+        dptr->options.parity = SerialPort::EvenParity;
         break;
     case EParityOdd:
-        m_parent->m_parity = SerialPort::OddParity;
+        dptr->options.parity = SerialPort::OddParity;
         break;
     case EParityMark:
-        m_parent->m_parity = SerialPort::MarkParity;
+        dptr->options.parity = SerialPort::MarkParity;
         break;
     case EParitySpace:
-        m_parent->m_parity = SerialPort::SpaceParity;
+        dptr->options.parity = SerialPort::SpaceParity;
         break;
     default:
-        m_parent->m_parity = SerialPort::UnknownParity;
+        dptr->options.parity = SerialPort::UnknownParity;
     }
 
     // Detect stopbits.
-    switch (m_currSettings().iStopBits) {
+    switch (m_currentSettings().iStopBits) {
     case EStop1:
-        m_parent->m_stopBits = SerialPort::OneStop;
+        dptr->options.stopBits = SerialPort::OneStop;
         break;
     case EStop2:
-        m_parent->m_stopBits = SerialPort::TwoStop;
+        dptr->options.stopBits = SerialPort::TwoStop;
         break;
     default:
-        m_parent->m_stopBits = SerialPort::UnknownStopBits;
+        dptr->options.stopBits = SerialPort::UnknownStopBits;
     }
 
     // Detect flow control.
-    if ((m_currSettings().iHandshake & (KConfigObeyXoff | KConfigSendXoff))
+    if ((m_currentSettings().iHandshake & (KConfigObeyXoff | KConfigSendXoff))
             == (KConfigObeyXoff | KConfigSendXoff))
-        m_parent->m_flow = SerialPort::SoftwareControl;
-    else if ((m_currSettings().iHandshake & (KConfigObeyCTS | KConfigFreeRTS))
+        dptr->options.flow = SerialPort::SoftwareControl;
+    else if ((m_currentSettings().iHandshake & (KConfigObeyCTS | KConfigFreeRTS))
              == (KConfigObeyCTS | KConfigFreeRTS))
-        m_parent->m_flow = SerialPort::HardwareControl;
-    else if (m_currSettings().iHandshake & KConfigFailDSR)
-        m_parent->m_flow = SerialPort::NoFlowControl;
+        dptr->options.flow = SerialPort::HardwareControl;
+    else if (m_currentSettings().iHandshake & KConfigFailDSR)
+        dptr->options.flow = SerialPort::NoFlowControl;
     else
-        m_parent->m_flow = SerialPort::UnknownFlowControl;
+        dptr->options.flow = SerialPort::UnknownFlowControl;
 }
 
 /* Private methods */
@@ -963,17 +963,17 @@ void SymbianSerialPortEngine::detectDefaultSettings()
 */
 bool SymbianSerialPortEngine::updateCommConfig()
 {
-    if (m_descriptor.SetConfig(m_currSettings) != KErrNone) {
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+    if (m_descriptor.SetConfig(m_currentSettings) != KErrNone) {
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return true;
 }
 
 // From <serialportengine_p.h>
-SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *parent)
+SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
 {
-    return new SymbianSerialPortEngine(parent);
+    return new SymbianSerialPortEngine(d);
 }
 
 #include "moc_serialportengine_symbian_p.cpp"
diff --git a/src/serialportengine_symbian_p.h b/src/serialportengine_symbian_p.h
old mode 100644
new mode 100755
index ce3851f..2a99a54
--- a/src/serialportengine_symbian_p.h
+++ b/src/serialportengine_symbian_p.h
@@ -16,7 +16,7 @@ class SymbianSerialPortEngine : public QObject, public SerialPortEngine
 {
     Q_OBJECT
 public:
-    SymbianSerialPortEngine(SerialPortPrivate *parent);
+    SymbianSerialPortEngine(SerialPortPrivate *d);
     virtual ~SymbianSerialPortEngine();
 
     virtual bool open(const QString &location, QIODevice::OpenMode mode);
@@ -65,12 +65,13 @@ protected:
     //virtual bool eventFilter(QObject *obj, QEvent *e);
 
 private:
-    TCommConfig m_currSettings;
-    TCommConfig m_oldSettings;
+    bool updateCommConfig();
+
+private:
+    TCommConfig m_currentSettings;
+    TCommConfig m_restoredSettings;
     RComm m_descriptor;
     mutable RTimer m_selectTimer;
-
-    bool updateCommConfig();
 };
 
 QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialportengine_unix.cpp b/src/serialportengine_unix.cpp
old mode 100644
new mode 100755
index dc66a16..95d9315
--- a/src/serialportengine_unix.cpp
+++ b/src/serialportengine_unix.cpp
@@ -66,17 +66,17 @@ QT_BEGIN_NAMESPACE_SERIALPORT
     A pointer \a parent to the object class SerialPortPrivate
     is required for the recursive call some of its methods.
 */
-UnixSerialPortEngine::UnixSerialPortEngine(SerialPortPrivate *parent)
+UnixSerialPortEngine::UnixSerialPortEngine(SerialPortPrivate *d)
     : m_descriptor(-1)
     , m_readNotifier(0)
     , m_writeNotifier(0)
     , m_exceptionNotifier(0)
 {
-    Q_ASSERT(parent);
-    m_parent = parent;
+    Q_ASSERT(d);
+    dptr = d;
     int size = sizeof(struct termios);
-    ::memset(&m_currTermios, 0, size);
-    ::memset(&m_oldTermios, 0, size);
+    ::memset(&m_currentTermios, 0, size);
+    ::memset(&m_restoredTermios, 0, size);
 }
 
 /*!
@@ -94,7 +94,7 @@ UnixSerialPortEngine::~UnixSerialPortEngine()
 }
 
 /*!
-    Tries to open the descriptor desired serial port by \a location
+    Tries to open the m_descriptor desired serial port by \a location
     in the given open \a mode.
 
     Before the opening of the serial port, checking for on exists the
@@ -110,7 +110,7 @@ UnixSerialPortEngine::~UnixSerialPortEngine()
     Since the port in the POSIX OS by default opens in shared mode,
     then this method forcibly puts a port in exclusive mode access.
     This is done simultaneously in two ways:
-    - set to the pre-open descriptor a flag TIOCEXCL
+    - set to the pre-open m_descriptor a flag TIOCEXCL
     - creates a lock file, which writes the pid of the process, that
     opened the port and other information
 
@@ -127,7 +127,7 @@ bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mod
     // First, here need check locked device or not.
     bool byCurrPid = false;
     if (TTYLocker::isLocked(location, &byCurrPid)) {
-        m_parent->setError(SerialPort::PermissionDeniedError);
+        dptr->setError(SerialPort::PermissionDeniedError);
         return false;
     }
 
@@ -151,13 +151,13 @@ bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mod
     if (m_descriptor == -1) {
         switch (errno) {
         case ENODEV:
-            m_parent->setError(SerialPort::NoSuchDeviceError);
+            dptr->setError(SerialPort::NoSuchDeviceError);
             break;
         case EACCES:
-            m_parent->setError(SerialPort::PermissionDeniedError);
+            dptr->setError(SerialPort::PermissionDeniedError);
             break;
         default:
-            m_parent->setError(SerialPort::UnknownPortError);
+            dptr->setError(SerialPort::UnknownPortError);
         }
         return false;
     }
@@ -165,7 +165,7 @@ bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mod
     // Try lock device by location and check it state is locked.
     TTYLocker::lock(location);
     if (!TTYLocker::isLocked(location, &byCurrPid)) {
-        m_parent->setError(SerialPort::PermissionDeniedError);
+        dptr->setError(SerialPort::PermissionDeniedError);
         return false;
     }
 
@@ -175,16 +175,16 @@ bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mod
 #endif
 
     // Save current port settings.
-    if (::tcgetattr(m_descriptor, &m_oldTermios) == -1) {
-        m_parent->setError(SerialPort::UnknownPortError);
+    if (::tcgetattr(m_descriptor, &m_restoredTermios) == -1) {
+        dptr->setError(SerialPort::UnknownPortError);
         return false;
     }
-    ::memcpy(&m_currTermios, &m_oldTermios, sizeof(struct termios));
+    ::memcpy(&m_currentTermios, &m_restoredTermios, sizeof(struct termios));
 
     // Set other options.
-    ::cfmakeraw(&m_currTermios);
-    m_currTermios.c_cflag |= (CREAD | CLOCAL);
-    m_currTermios.c_cc[VTIME] = 0;
+    ::cfmakeraw(&m_currentTermios);
+    m_currentTermios.c_cflag |= (CREAD | CLOCAL);
+    m_currentTermios.c_cc[VTIME] = 0;
 
     // Apply new init settings.
     if (!updateTermios())
@@ -195,15 +195,15 @@ bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mod
 }
 
 /*!
-    Closes a serial port descriptor. Before closing - clears exclusive
+    Closes a serial port m_descriptor. Before closing - clears exclusive
     access flag and removes the lock file, restore previous serial port
     settings if necessary.
 */
 void UnixSerialPortEngine::close(const QString &location)
 {
     // Restore saved port settings.
-    if (m_parent->m_restoreSettingsOnClose)
-        ::tcsetattr(m_descriptor, TCSANOW, &m_oldTermios);
+    if (dptr->options.restoreSettingsOnClose)
+        ::tcsetattr(m_descriptor, TCSANOW, &m_restoredTermios);
 
     // Try clean exclusive mode.
 #if defined (TIOCNXCL)
@@ -238,39 +238,39 @@ SerialPort::Lines UnixSerialPortEngine::lines() const
         return ret;
     }
 
-#if defined (TIOCM_LE)
-    if (arg & TIOCM_LE) ret |= SerialPort::Le;
+#if defined (TIOCLE)
+    if (arg & TIOCLE) ret |= SerialPort::Le;
 #endif
-#if defined (TIOCM_DTR)
-    if (arg & TIOCM_DTR) ret |= SerialPort::Dtr;
+#if defined (TIOCDTR)
+    if (arg & TIOCDTR) ret |= SerialPort::Dtr;
 #endif
-#if defined (TIOCM_RTS)
-    if (arg & TIOCM_RTS) ret |= SerialPort::Rts;
+#if defined (TIOCRTS)
+    if (arg & TIOCRTS) ret |= SerialPort::Rts;
 #endif
-#if defined (TIOCM_ST)
-    if (arg & TIOCM_ST) ret |= SerialPort::St;
+#if defined (TIOCST)
+    if (arg & TIOCST) ret |= SerialPort::St;
 #endif
-#if defined (TIOCM_SR)
-    if (arg & TIOCM_SR) ret |= SerialPort::Sr;
+#if defined (TIOCSR)
+    if (arg & TIOCSR) ret |= SerialPort::Sr;
 #endif
-#if defined (TIOCM_CTS)
-    if (arg & TIOCM_CTS) ret |= SerialPort::Cts;
+#if defined (TIOCCTS)
+    if (arg & TIOCCTS) ret |= SerialPort::Cts;
 #endif
 
-#if defined (TIOCM_CAR)
-    if (arg & TIOCM_CAR) ret |= SerialPort::Dcd;
-#elif defined (TIOCM_CD)
-    if (arg & TIOCM_CD) ret |= SerialPort::Dcd;
+#if defined (TIOCCAR)
+    if (arg & TIOCCAR) ret |= SerialPort::Dcd;
+#elif defined (TIOCCD)
+    if (arg & TIOCCD) ret |= SerialPort::Dcd;
 #endif
 
-#if defined (TIOCM_RNG)
-    if (arg & TIOCM_RNG) ret |= SerialPort::Ri;
-#elif defined (TIOCM_RI)
-    if (arg & TIOCM_RI) ret |= SerialPort::Ri;
+#if defined (TIOCRNG)
+    if (arg & TIOCRNG) ret |= SerialPort::Ri;
+#elif defined (TIOCRI)
+    if (arg & TIOCRI) ret |= SerialPort::Ri;
 #endif
 
-#if defined (TIOCM_DSR)
-    if (arg & TIOCM_DSR) ret |= SerialPort::Dsr;
+#if defined (TIOCDSR)
+    if (arg & TIOCDSR) ret |= SerialPort::Dsr;
 #endif
 
     return ret;
@@ -437,9 +437,11 @@ qint64 UnixSerialPortEngine::read(char *data, qint64 len)
 {
     qint64 bytesRead = 0;
 #if defined (CMSPAR)
-    if ((m_parent->m_parity == SerialPort::NoParity) || (m_parent->m_policy != SerialPort::StopReceivingPolicy))
+    if ((dptr->options.parity == SerialPort::NoParity)
+            || (dptr->options.policy != SerialPort::StopReceivingPolicy))
 #else
-    if ((m_parent->m_parity != SerialPort::MarkParity) && (m_parent->m_parity != SerialPort::SpaceParity))
+    if ((dptr->options.parity != SerialPort::MarkParity)
+            && (dptr->options.parity != SerialPort::SpaceParity))
 #endif
         bytesRead = ::read(m_descriptor, data, len);
     else // Perform parity emulation.
@@ -475,7 +477,7 @@ qint64 UnixSerialPortEngine::read(char *data, qint64 len)
         // FIXME: Here need call errno
         // and set error type?
         if (bytesRead == -1)
-            m_parent->setError(SerialPort::IoError);
+            dptr->setError(SerialPort::IoError);
     }
     return bytesRead;
 }
@@ -495,7 +497,7 @@ qint64 UnixSerialPortEngine::write(const char *data, qint64 len)
 #if defined (CMSPAR)
     bytesWritten = ::write(m_descriptor, data, len);
 #else
-    if ((m_parent->m_parity != SerialPort::MarkParity) && (m_parent->m_parity != SerialPort::SpaceParity))
+    if ((dptr->options.parity != SerialPort::MarkParity) && (dptr->options.parity != SerialPort::SpaceParity))
         bytesWritten = ::write(m_descriptor, data, len);
     else // Perform parity emulation.
         bytesWritten = writePerChar(data, len);
@@ -519,7 +521,7 @@ qint64 UnixSerialPortEngine::write(const char *data, qint64 len)
         // FIXME: Here need call errno
         // and set error type?
         if (bytesWritten == -1)
-            m_parent->setError(SerialPort::IoError);
+            dptr->setError(SerialPort::IoError);
     }
     return bytesWritten;
 }
@@ -528,7 +530,7 @@ qint64 UnixSerialPortEngine::write(const char *data, qint64 len)
     Implements a function blocking for waiting of events on the
     \a timeout in millisecond, those listed in fdread will be watched
     to see if characters become available for reading (more precisely,
-    to see if a read will not block; in particular, a file descriptor
+    to see if a read will not block; in particular, a file m_descriptor
     is also ready on end-of-file), those in fdwrite will be watched
     to see if a write will not block.
 
@@ -620,7 +622,8 @@ QString UnixSerialPortEngine::fromSystemLocation(const QString &location) const
 
 static QHash<qint32, qint32> generateStandardRatesMachTable()
 {
-   QHash<qint32, qint32> h;
+    QHash<qint32, qint32> h;
+
 #if defined (B0)
     h[0] = B0;
 #endif
@@ -640,7 +643,7 @@ static QHash<qint32, qint32> generateStandardRatesMachTable()
     h[150] = B150;
 #endif
 #if defined (B200)
-    h[2000] = B200;
+    h[200] = B200;
 #endif
 #if defined (B300)
     h[300] = B300;
@@ -714,6 +717,7 @@ static QHash<qint32, qint32> generateStandardRatesMachTable()
 #if defined (B4000000)
     h[4000000] = B4000000;
 #endif
+
     return h;
 }
 
@@ -759,8 +763,8 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
             ser_info.custom_divisor = 0;
 #endif
             // prepare to set standard rate
-            ret = !(((dir & SerialPort::Input) && (::cfsetispeed(&m_currTermios, unixRate) < 0))
-                    || ((dir & SerialPort::Output) && (::cfsetospeed(&m_currTermios, unixRate) < 0)));
+            ret = !(((dir & SerialPort::Input) && (::cfsetispeed(&m_currentTermios, unixRate) < 0))
+                    || ((dir & SerialPort::Output) && (::cfsetospeed(&m_currentTermios, unixRate) < 0)));
         } else {
             // try prepate to set custom baud rate
 
@@ -773,7 +777,7 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
                 ser_info.custom_divisor = 1;
 
             // for custom mode needed prepare to set B38400 rate
-            ret = (::cfsetspeed(&m_currTermios, B38400) != -1);
+            ret = (::cfsetspeed(&m_currentTermios, B38400) != -1);
 #elif defined (Q_OS_MAC)
 
 #  if defined (MAC_OS_X_VERSION_10_4) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4)
@@ -809,7 +813,7 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
     }
 
     if (!ret)
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
     return ret;
 }
 
@@ -822,22 +826,22 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 */
 bool UnixSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 {
-    m_currTermios.c_cflag &= (~CSIZE);
+    m_currentTermios.c_cflag &= (~CSIZE);
     switch (dataBits) {
     case SerialPort::Data5:
-        m_currTermios.c_cflag |= CS5;
+        m_currentTermios.c_cflag |= CS5;
         break;
     case SerialPort::Data6:
-        m_currTermios.c_cflag |= CS6;
+        m_currentTermios.c_cflag |= CS6;
         break;
     case SerialPort::Data7:
-        m_currTermios.c_cflag |= CS7;
+        m_currentTermios.c_cflag |= CS7;
         break;
     case SerialPort::Data8:
-        m_currTermios.c_cflag |= CS8;
+        m_currentTermios.c_cflag |= CS8;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return updateTermios();
@@ -855,35 +859,35 @@ bool UnixSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 */
 bool UnixSerialPortEngine::setParity(SerialPort::Parity parity)
 {
-    m_currTermios.c_iflag &= ~(PARMRK | INPCK);
-    m_currTermios.c_iflag |= IGNPAR;
+    m_currentTermios.c_iflag &= ~(PARMRK | INPCK);
+    m_currentTermios.c_iflag |= IGNPAR;
 
     switch (parity) {
 
 #if defined (CMSPAR)
     // Here Installation parity only for GNU/Linux where the macro CMSPAR.
     case SerialPort::SpaceParity:
-        m_currTermios.c_cflag &= (~PARODD);
-        m_currTermios.c_cflag |= (PARENB | CMSPAR);
+        m_currentTermios.c_cflag &= (~PARODD);
+        m_currentTermios.c_cflag |= (PARENB | CMSPAR);
         break;
     case SerialPort::MarkParity:
-        m_currTermios.c_cflag |= (PARENB | CMSPAR | PARODD);
+        m_currentTermios.c_cflag |= (PARENB | CMSPAR | PARODD);
         break;
 #endif
     case SerialPort::NoParity:
-        m_currTermios.c_cflag &= (~PARENB);
+        m_currentTermios.c_cflag &= (~PARENB);
         break;
     case SerialPort::EvenParity:
-        m_currTermios.c_cflag &= (~PARODD);
-        m_currTermios.c_cflag |= PARENB;
+        m_currentTermios.c_cflag &= (~PARODD);
+        m_currentTermios.c_cflag |= PARENB;
         break;
     case SerialPort::OddParity:
-        m_currTermios.c_cflag |= (PARENB | PARODD);
+        m_currentTermios.c_cflag |= (PARENB | PARODD);
         break;
     default:
-        m_currTermios.c_cflag |= PARENB;
-        m_currTermios.c_iflag |= (PARMRK | INPCK);
-        m_currTermios.c_iflag &= ~IGNPAR;
+        m_currentTermios.c_cflag |= PARENB;
+        m_currentTermios.c_iflag |= (PARMRK | INPCK);
+        m_currentTermios.c_iflag &= ~IGNPAR;
         break;
     }
 
@@ -901,13 +905,13 @@ bool UnixSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
 {
     switch (stopBits) {
     case SerialPort::OneStop:
-        m_currTermios.c_cflag &= (~CSTOPB);
+        m_currentTermios.c_cflag &= (~CSTOPB);
         break;
     case SerialPort::TwoStop:
-        m_currTermios.c_cflag |= CSTOPB;
+        m_currentTermios.c_cflag |= CSTOPB;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return updateTermios();
@@ -925,19 +929,19 @@ bool UnixSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
 {
     switch (flow) {
     case SerialPort::NoFlowControl:
-        m_currTermios.c_cflag &= (~CRTSCTS);
-        m_currTermios.c_iflag &= (~(IXON | IXOFF | IXANY));
+        m_currentTermios.c_cflag &= (~CRTSCTS);
+        m_currentTermios.c_iflag &= (~(IXON | IXOFF | IXANY));
         break;
     case SerialPort::HardwareControl:
-        m_currTermios.c_cflag |= CRTSCTS;
-        m_currTermios.c_iflag &= (~(IXON | IXOFF | IXANY));
+        m_currentTermios.c_cflag |= CRTSCTS;
+        m_currentTermios.c_iflag &= (~(IXON | IXOFF | IXANY));
         break;
     case SerialPort::SoftwareControl:
-        m_currTermios.c_cflag &= (~CRTSCTS);
-        m_currTermios.c_iflag |= (IXON | IXOFF | IXANY);
+        m_currentTermios.c_cflag &= (~CRTSCTS);
+        m_currentTermios.c_iflag |= (IXON | IXOFF | IXANY);
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return updateTermios();
@@ -952,27 +956,27 @@ bool UnixSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy
     tcflag_t parmrkMask = PARMRK;
 #ifndef CMSPAR
     //in space/mark parity emulation also used PARMRK flag
-    if (m_parent->m_parity == SerialPort::SpaceParity || m_parent->m_parity == SerialPort::MarkParity)
+    if (dptr->options.parity == SerialPort::SpaceParity || dptr->options.parity == SerialPort::MarkParity)
         parmrkMask = 0;
 #endif //CMSPAR
     switch(policy) {
     case SerialPort::SkipPolicy:
-        m_currTermios.c_iflag &= ~parmrkMask;
-        m_currTermios.c_iflag |= IGNPAR | INPCK;
+        m_currentTermios.c_iflag &= ~parmrkMask;
+        m_currentTermios.c_iflag |= IGNPAR | INPCK;
         break;
     case SerialPort::PassZeroPolicy:
-        m_currTermios.c_iflag &= ~(IGNPAR | parmrkMask);
-        m_currTermios.c_iflag |= INPCK;
+        m_currentTermios.c_iflag &= ~(IGNPAR | parmrkMask);
+        m_currentTermios.c_iflag |= INPCK;
         break;
     case SerialPort::IgnorePolicy:
-        m_currTermios.c_iflag &= ~INPCK;
+        m_currentTermios.c_iflag &= ~INPCK;
         break;
     case SerialPort::StopReceivingPolicy:
-        m_currTermios.c_iflag &= ~IGNPAR;
-        m_currTermios.c_iflag |= (parmrkMask | INPCK);
+        m_currentTermios.c_iflag &= ~IGNPAR;
+        m_currentTermios.c_iflag |= (parmrkMask | INPCK);
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return updateTermios();
@@ -1059,8 +1063,8 @@ void UnixSerialPortEngine::detectDefaultSettings()
     bool isCustomRate = false;
 #if defined (Q_OS_LINUX)
     // first assume that the baud rate of custom
-    isCustomRate = ((::cfgetispeed(&m_currTermios) == B38400)
-                    && (::cfgetospeed(&m_currTermios) == B38400));
+    isCustomRate = ((::cfgetispeed(&m_currentTermios) == B38400)
+                    && (::cfgetospeed(&m_currentTermios) == B38400));
 
     if (isCustomRate) {
         struct serial_struct ser_info;
@@ -1069,83 +1073,83 @@ void UnixSerialPortEngine::detectDefaultSettings()
                     && (ser_info.custom_divisor > 0)) {
 
                 // yes, speed is really custom
-                m_parent->m_inRate = ser_info.baud_base / ser_info.custom_divisor;
+                dptr->options.inputRate = ser_info.baud_base / ser_info.custom_divisor;
             } else {
                 // no, we were wrong and the speed of a standard 38400 baud
-                m_parent->m_inRate = 38400;
+                dptr->options.inputRate = 38400;
             }
         } else {
             // error get ioctl()
-            m_parent->m_inRate = SerialPort::UnknownRate;
+            dptr->options.inputRate = SerialPort::UnknownRate;
         }
-        m_parent->m_outRate = m_parent->m_inRate;
+        dptr->options.outputRate = dptr->options.inputRate;
     }
 #else
     // other *nix
 #endif
     if (!isCustomRate) {
-        m_parent->m_inRate = standardRatesMachTable().key(::cfgetispeed(&m_currTermios));
-        m_parent->m_outRate = standardRatesMachTable().key(::cfgetospeed(&m_currTermios));
+        dptr->options.inputRate = standardRatesMachTable().key(::cfgetispeed(&m_currentTermios));
+        dptr->options.outputRate = standardRatesMachTable().key(::cfgetospeed(&m_currentTermios));
     }
 
     // Detect databits.
-    switch (m_currTermios.c_cflag & CSIZE) {
+    switch (m_currentTermios.c_cflag & CSIZE) {
     case CS5:
-        m_parent->m_dataBits = SerialPort::Data5;
+        dptr->options.dataBits = SerialPort::Data5;
         break;
     case CS6:
-        m_parent->m_dataBits = SerialPort::Data6;
+        dptr->options.dataBits = SerialPort::Data6;
         break;
     case CS7:
-        m_parent->m_dataBits = SerialPort::Data7;
+        dptr->options.dataBits = SerialPort::Data7;
         break;
     case CS8:
-        m_parent->m_dataBits = SerialPort::Data8;
+        dptr->options.dataBits = SerialPort::Data8;
         break;
     default:
-        m_parent->m_dataBits = SerialPort::UnknownDataBits;
+        dptr->options.dataBits = SerialPort::UnknownDataBits;
     }
 
     // Detect parity.
 #if defined (CMSPAR)
-    if (m_currTermios.c_cflag & CMSPAR) {
-        m_parent->m_parity = (m_currTermios.c_cflag & PARODD) ?
+    if (m_currentTermios.c_cflag & CMSPAR) {
+        dptr->options.parity = (m_currentTermios.c_cflag & PARODD) ?
                     SerialPort::MarkParity : SerialPort::SpaceParity;
     } else {
 #endif
-        if (m_currTermios.c_cflag & PARENB) {
-            m_parent->m_parity = (m_currTermios.c_cflag & PARODD) ?
+        if (m_currentTermios.c_cflag & PARENB) {
+            dptr->options.parity = (m_currentTermios.c_cflag & PARODD) ?
                         SerialPort::OddParity : SerialPort::EvenParity;
         } else
-            m_parent->m_parity = SerialPort::NoParity;
+            dptr->options.parity = SerialPort::NoParity;
 #if defined (CMSPAR)
     }
 #endif
 
     // Detect stopbits.
-    m_parent->m_stopBits = (m_currTermios.c_cflag & CSTOPB) ?
+    dptr->options.stopBits = (m_currentTermios.c_cflag & CSTOPB) ?
                 SerialPort::TwoStop : SerialPort::OneStop;
 
     // Detect flow control.
-    if ((!(m_currTermios.c_cflag & CRTSCTS)) && (!(m_currTermios.c_iflag & (IXON | IXOFF | IXANY))))
-        m_parent->m_flow = SerialPort::NoFlowControl;
-    else if ((!(m_currTermios.c_cflag & CRTSCTS)) && (m_currTermios.c_iflag & (IXON | IXOFF | IXANY)))
-        m_parent->m_flow = SerialPort::SoftwareControl;
-    else if ((m_currTermios.c_cflag & CRTSCTS) && (!(m_currTermios.c_iflag & (IXON | IXOFF | IXANY))))
-        m_parent->m_flow = SerialPort::HardwareControl;
+    if ((!(m_currentTermios.c_cflag & CRTSCTS)) && (!(m_currentTermios.c_iflag & (IXON | IXOFF | IXANY))))
+        dptr->options.flow = SerialPort::NoFlowControl;
+    else if ((!(m_currentTermios.c_cflag & CRTSCTS)) && (m_currentTermios.c_iflag & (IXON | IXOFF | IXANY)))
+        dptr->options.flow = SerialPort::SoftwareControl;
+    else if ((m_currentTermios.c_cflag & CRTSCTS) && (!(m_currentTermios.c_iflag & (IXON | IXOFF | IXANY))))
+        dptr->options.flow = SerialPort::HardwareControl;
     else
-        m_parent->m_flow = SerialPort::UnknownFlowControl;
+        dptr->options.flow = SerialPort::UnknownFlowControl;
 
     //detect error policy
-    if (m_currTermios.c_iflag & INPCK) {
-        if (m_currTermios.c_iflag & IGNPAR)
-            m_parent->m_policy = SerialPort::SkipPolicy;
-        else if (m_currTermios.c_iflag & PARMRK)
-            m_parent->m_policy = SerialPort::StopReceivingPolicy;
+    if (m_currentTermios.c_iflag & INPCK) {
+        if (m_currentTermios.c_iflag & IGNPAR)
+            dptr->options.policy = SerialPort::SkipPolicy;
+        else if (m_currentTermios.c_iflag & PARMRK)
+            dptr->options.policy = SerialPort::StopReceivingPolicy;
         else
-            m_parent->m_policy = SerialPort::PassZeroPolicy;
+            dptr->options.policy = SerialPort::PassZeroPolicy;
     } else {
-        m_parent->m_policy = SerialPort::IgnorePolicy;
+        dptr->options.policy = SerialPort::IgnorePolicy;
     }
 }
 
@@ -1160,15 +1164,15 @@ bool UnixSerialPortEngine::eventFilter(QObject *obj, QEvent *e)
 {
     if (e->type() == QEvent::SockAct) {
         if (obj == m_readNotifier) {
-            m_parent->canReadNotification();
+            dptr->canReadNotification();
             return true;
         }
         if (obj == m_writeNotifier) {
-            m_parent->canWriteNotification();
+            dptr->canWriteNotification();
             return true;
         }
         if (obj == m_exceptionNotifier) {
-            m_parent->canErrorNotification();
+            dptr->canErrorNotification();
             return true;
         }
     }
@@ -1185,8 +1189,8 @@ bool UnixSerialPortEngine::eventFilter(QObject *obj, QEvent *e)
 */
 bool UnixSerialPortEngine::updateTermios()
 {
-    if (::tcsetattr(m_descriptor, TCSANOW, &m_currTermios) == -1) {
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+    if (::tcsetattr(m_descriptor, TCSANOW, &m_currentTermios) == -1) {
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return true;
@@ -1211,15 +1215,15 @@ static inline bool evenParity(quint8 c)
 qint64 UnixSerialPortEngine::writePerChar(const char *data, qint64 maxSize)
 {
     qint64 ret = 0;
-    quint8 const charMask = (0xFF >> (8 - m_parent->m_dataBits));
+    quint8 const charMask = (0xFF >> (8 - dptr->options.dataBits));
 
     while (ret < maxSize) {
 
         bool par = evenParity(*data & charMask);
         // False if need EVEN, true if need ODD.
-        par ^= (m_parent->m_parity == SerialPort::MarkParity);
-        if (par ^ bool(m_currTermios.c_cflag & PARODD)) { // Need switch parity mode?
-            m_currTermios.c_cflag ^= PARODD;
+        par ^= (dptr->options.parity == SerialPort::MarkParity);
+        if (par ^ bool(m_currentTermios.c_cflag & PARODD)) { // Need switch parity mode?
+            m_currentTermios.c_cflag ^= PARODD;
             flush(); //force sending already buffered data, because updateTermios() cleares buffers
             //todo: add receiving buffered data!!!
             if (!updateTermios())
@@ -1246,7 +1250,7 @@ qint64 UnixSerialPortEngine::writePerChar(const char *data, qint64 maxSize)
 qint64 UnixSerialPortEngine::readPerChar(char *data, qint64 maxSize)
 {
     qint64 ret = 0;
-    quint8 const charMask = (0xFF >> (8 - m_parent->m_dataBits));
+    quint8 const charMask = (0xFF >> (8 - dptr->options.dataBits));
 
     // 0 - prefix not started,
     // 1 - received 0xFF,
@@ -1285,16 +1289,16 @@ qint64 UnixSerialPortEngine::readPerChar(char *data, qint64 maxSize)
         }
         // Now: par contains parity ok or error, *data contains received character
         par ^= evenParity(*data & charMask); //par contains parity bit value for EVEN mode
-        par ^= bool(m_currTermios.c_cflag & PARODD); //par contains parity bit value for current mode
-        if (par ^ bool(m_parent->m_parity == SerialPort::SpaceParity)) { //if parity error
-            switch(m_parent->m_policy) {
+        par ^= bool(m_currentTermios.c_cflag & PARODD); //par contains parity bit value for current mode
+        if (par ^ bool(dptr->options.parity == SerialPort::SpaceParity)) { //if parity error
+            switch (dptr->options.policy) {
             case SerialPort::SkipPolicy:
                 continue;       //ignore received character
             case SerialPort::StopReceivingPolicy:
-                if (m_parent->m_parity != SerialPort::NoParity)
-                    m_parent->m_portError = SerialPort::ParityError;
+                if (dptr->options.parity != SerialPort::NoParity)
+                    dptr->portError = SerialPort::ParityError;
                 else
-                    m_parent->m_portError = (*data == '\0') ? SerialPort::BreakConditionError : SerialPort::FramingError;
+                    dptr->portError = (*data == '\0') ? SerialPort::BreakConditionError : SerialPort::FramingError;
                 return ++ret;   //abort receiving
                 break;
             case SerialPort::UnknownPolicy:
@@ -1313,9 +1317,9 @@ qint64 UnixSerialPortEngine::readPerChar(char *data, qint64 maxSize)
 }
 
 // From <serialportengine_p.h>
-SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *parent)
+SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
 {
-    return new UnixSerialPortEngine(parent);
+    return new UnixSerialPortEngine(d);
 }
 
 #include "moc_serialportengine_unix_p.cpp"
diff --git a/src/serialportengine_unix_p.h b/src/serialportengine_unix_p.h
old mode 100644
new mode 100755
index b53dde3..a59b4b3
--- a/src/serialportengine_unix_p.h
+++ b/src/serialportengine_unix_p.h
@@ -19,7 +19,7 @@ class UnixSerialPortEngine : public QObject, public SerialPortEngine
 {
     Q_OBJECT
 public:
-    UnixSerialPortEngine(SerialPortPrivate *parent);
+    UnixSerialPortEngine(SerialPortPrivate *d);
     virtual ~UnixSerialPortEngine();
 
     virtual bool open(const QString &location, QIODevice::OpenMode mode);
@@ -68,20 +68,21 @@ protected:
     virtual bool eventFilter(QObject *obj, QEvent *e);
 
 private:
-    struct termios m_currTermios;
-    struct termios m_oldTermios;
-    int m_descriptor;
-
-    QSocketNotifier *m_readNotifier;
-    QSocketNotifier *m_writeNotifier;
-    QSocketNotifier *m_exceptionNotifier;
-
     bool updateTermios();
 
 #if !defined (CMSPAR)
     qint64 writePerChar(const char *data, qint64 maxSize);
 #endif
     qint64 readPerChar(char *data, qint64 maxSize);
+
+private:
+    struct termios m_currentTermios;
+    struct termios m_restoredTermios;
+    int m_descriptor;
+
+    QSocketNotifier *m_readNotifier;
+    QSocketNotifier *m_writeNotifier;
+    QSocketNotifier *m_exceptionNotifier;
 };
 
 QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialportengine_win.cpp b/src/serialportengine_win.cpp
old mode 100644
new mode 100755
index 37e4ea2..61ed45a
--- a/src/serialportengine_win.cpp
+++ b/src/serialportengine_win.cpp
@@ -92,30 +92,30 @@ QT_BEGIN_NAMESPACE_SERIALPORT
     A pointer \a parent to the object class SerialPortPrivate
     is required for the recursive call some of its methods.
 */
-WinSerialPortEngine::WinSerialPortEngine(SerialPortPrivate *parent)
+WinSerialPortEngine::WinSerialPortEngine(SerialPortPrivate *d)
     : m_descriptor(INVALID_HANDLE_VALUE)
     , m_flagErrorFromCommEvent(false)
     , m_currentMask(0)
-    , m_setMask(EV_ERR)
-    #if defined (Q_OS_WINCE)
+    , m_desiredMask(EV_ERR)
+#if defined (Q_OS_WINCE)
     , m_running(true)
-    #endif
+#endif
 {
-    Q_ASSERT(parent);
-    m_parent = parent;
+    Q_ASSERT(d);
+    dptr = d;
     size_t size = sizeof(DCB);
-    ::memset(&m_currDCB, 0, size);
-    ::memset(&m_oldDCB, 0, size);
+    ::memset(&m_currentDcb, 0, size);
+    ::memset(&m_restoredDcb, 0, size);
     size = sizeof(COMMTIMEOUTS);
-    ::memset(&m_currCommTimeouts, 0, size);
-    ::memset(&m_oldCommTimeouts, 0, size);
+    ::memset(&m_currentCommTimeouts, 0, size);
+    ::memset(&m_restoredCommTimeouts, 0, size);
 
 #if !defined (Q_OS_WINCE)
     size = sizeof(OVERLAPPED);
     ::memset(&m_ovRead, 0, size);
     ::memset(&m_ovWrite, 0, size);
     ::memset(&m_ovSelect, 0, size);
-    ::memset(&m_ov, 0, size);
+    ::memset(&m_ovNotify, 0, size);
 #endif
 }
 
@@ -186,32 +186,32 @@ bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode
     if (m_descriptor == INVALID_HANDLE_VALUE) {
         switch (::GetLastError()) {
         case ERROR_FILE_NOT_FOUND:
-            m_parent->setError(SerialPort::NoSuchDeviceError);
+            dptr->setError(SerialPort::NoSuchDeviceError);
             break;
         case ERROR_ACCESS_DENIED:
-            m_parent->setError(SerialPort::PermissionDeniedError);
+            dptr->setError(SerialPort::PermissionDeniedError);
             break;
         default:
-            m_parent->setError(SerialPort::UnknownPortError);
+            dptr->setError(SerialPort::UnknownPortError);
         }
         return false;
     }
 
     // Save current DCB port settings.
     DWORD confSize = sizeof(DCB);
-    if (::GetCommState(m_descriptor, &m_oldDCB) == 0) {
-        m_parent->setError(SerialPort::UnknownPortError);
+    if (::GetCommState(m_descriptor, &m_restoredDcb) == 0) {
+        dptr->setError(SerialPort::UnknownPortError);
         return false;
     }
-    ::memcpy(&m_currDCB, &m_oldDCB, confSize);
+    ::memcpy(&m_currentDcb, &m_restoredDcb, confSize);
 
     // Set other DCB port options.
-    m_currDCB.fBinary = true;
-    m_currDCB.fInX = false;
-    m_currDCB.fOutX = false;
-    m_currDCB.fAbortOnError = false;
-    m_currDCB.fNull = false;
-    m_currDCB.fErrorChar = false;
+    m_currentDcb.fBinary = true;
+    m_currentDcb.fInX = false;
+    m_currentDcb.fOutX = false;
+    m_currentDcb.fAbortOnError = false;
+    m_currentDcb.fNull = false;
+    m_currentDcb.fErrorChar = false;
 
     // Apply new DCB init settings.
     if (!updateDcb())
@@ -219,15 +219,15 @@ bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode
 
     // Save current port timeouts.
     confSize = sizeof(COMMTIMEOUTS);
-    if (::GetCommTimeouts(m_descriptor, &m_oldCommTimeouts) == 0) {
-        m_parent->setError(SerialPort::UnknownPortError);
+    if (::GetCommTimeouts(m_descriptor, &m_restoredCommTimeouts) == 0) {
+        dptr->setError(SerialPort::UnknownPortError);
         return false;
     }
-    ::memcpy(&m_currCommTimeouts, &m_oldCommTimeouts, confSize);
+    ::memcpy(&m_currentCommTimeouts, &m_restoredCommTimeouts, confSize);
 
     // Set new port timeouts.
-    ::memset(&m_currCommTimeouts, 0, confSize);
-    m_currCommTimeouts.ReadIntervalTimeout = MAXDWORD;
+    ::memset(&m_currentCommTimeouts, 0, confSize);
+    m_currentCommTimeouts.ReadIntervalTimeout = MAXDWORD;
 
     // Apply new port timeouts.
     if (!updateCommTimeouts())
@@ -235,7 +235,7 @@ bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode
 
 #if !defined (Q_OS_WINCE)
     if (!createEvents(rxflag, txflag)) {
-        m_parent->setError(SerialPort::UnknownPortError);
+        dptr->setError(SerialPort::UnknownPortError);
         return false;
     }
 #endif
@@ -256,9 +256,9 @@ void WinSerialPortEngine::close(const QString &location)
     ::CancelIo(m_descriptor);
 #endif
 
-    if (m_parent->m_restoreSettingsOnClose) {
-        ::SetCommState(m_descriptor, &m_oldDCB);
-        ::SetCommTimeouts(m_descriptor, &m_oldCommTimeouts);
+    if (dptr->options.restoreSettingsOnClose) {
+        ::SetCommState(m_descriptor, &m_restoredDcb);
+        ::SetCommTimeouts(m_descriptor, &m_restoredCommTimeouts);
     }
 
     ::CloseHandle(m_descriptor);
@@ -409,11 +409,11 @@ bool WinSerialPortEngine::setBreak(bool set)
 }
 
 enum CommStatQue { CS_IN_QUE, CS_OUT_QUE };
-static qint64 get_commstat_que(HANDLE descriptor, enum CommStatQue que)
+static qint64 get_commstat_que(HANDLE m_descriptor, enum CommStatQue que)
 {
     DWORD err;
     COMSTAT cs;
-    if (::ClearCommError(descriptor, &err, &cs) == 0)
+    if (::ClearCommError(m_descriptor, &err, &cs) == 0)
         return -1;
     return qint64((que == CS_IN_QUE) ? (cs.cbInQue) : (cs.cbOutQue));
 }
@@ -487,7 +487,7 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
     bool sucessResult = false;
 
     // FIXME:
-    if (m_parent->m_policy != SerialPort::IgnorePolicy)
+    if (dptr->options.policy != SerialPort::IgnorePolicy)
         len = 1;
 
 #if defined (Q_OS_WINCE)
@@ -511,7 +511,7 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
 #endif
 
     if(!sucessResult) {
-        m_parent->setError(SerialPort::IoError);
+        dptr->setError(SerialPort::IoError);
         return -1;
     }
 
@@ -519,7 +519,7 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
     if (m_flagErrorFromCommEvent) {
         m_flagErrorFromCommEvent = false;
 
-        switch (m_parent->m_policy) {
+        switch (dptr->options.policy) {
         case SerialPort::SkipPolicy:
             return 0;
         case SerialPort::PassZeroPolicy:
@@ -572,7 +572,7 @@ qint64 WinSerialPortEngine::write(const char *data, qint64 len)
 #endif
 
     if(!sucessResult) {
-        m_parent->setError(SerialPort::IoError);
+        dptr->setError(SerialPort::IoError);
         return -1;
     }
     return quint64(writeBytes);
@@ -738,10 +738,10 @@ QString WinSerialPortEngine::fromSystemLocation(const QString &location) const
 bool WinSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 {
     if (dir != SerialPort::AllDirections) {
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
-    m_currDCB.BaudRate = DWORD(rate);
+    m_currentDcb.BaudRate = DWORD(rate);
     return updateDcb();
 }
 
@@ -754,7 +754,7 @@ bool WinSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 */
 bool WinSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 {
-    m_currDCB.ByteSize = BYTE(dataBits);
+    m_currentDcb.ByteSize = BYTE(dataBits);
     return updateDcb();
 }
 
@@ -767,26 +767,26 @@ bool WinSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 */
 bool WinSerialPortEngine::setParity(SerialPort::Parity parity)
 {
-    m_currDCB.fParity = true;
+    m_currentDcb.fParity = true;
     switch (parity) {
     case SerialPort::NoParity:
-        m_currDCB.Parity = NOPARITY;
-        m_currDCB.fParity = false;
+        m_currentDcb.Parity = NOPARITY;
+        m_currentDcb.fParity = false;
         break;
     case SerialPort::SpaceParity:
-        m_currDCB.Parity = SPACEPARITY;
+        m_currentDcb.Parity = SPACEPARITY;
         break;
     case SerialPort::MarkParity:
-        m_currDCB.Parity = MARKPARITY;
+        m_currentDcb.Parity = MARKPARITY;
         break;
     case SerialPort::EvenParity:
-        m_currDCB.Parity = EVENPARITY;
+        m_currentDcb.Parity = EVENPARITY;
         break;
     case SerialPort::OddParity:
-        m_currDCB.Parity = ODDPARITY;
+        m_currentDcb.Parity = ODDPARITY;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return updateDcb();
@@ -804,16 +804,16 @@ bool WinSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
 {
     switch (stopBits) {
     case SerialPort::OneStop:
-        m_currDCB.StopBits = ONESTOPBIT;
+        m_currentDcb.StopBits = ONESTOPBIT;
         break;
     case SerialPort::OneAndHalfStop:
-        m_currDCB.StopBits = ONE5STOPBITS;
+        m_currentDcb.StopBits = ONE5STOPBITS;
         break;
     case SerialPort::TwoStop:
-        m_currDCB.StopBits = TWOSTOPBITS;
+        m_currentDcb.StopBits = TWOSTOPBITS;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return updateDcb();
@@ -831,22 +831,22 @@ bool WinSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
 {
     switch (flow) {
     case SerialPort::NoFlowControl:
-        m_currDCB.fOutxCtsFlow = false;
-        m_currDCB.fRtsControl = RTS_CONTROL_DISABLE;
-        m_currDCB.fInX = m_currDCB.fOutX = false;
+        m_currentDcb.fOutxCtsFlow = false;
+        m_currentDcb.fRtsControl = RTS_CONTROL_DISABLE;
+        m_currentDcb.fInX = m_currentDcb.fOutX = false;
         break;
     case SerialPort::SoftwareControl:
-        m_currDCB.fOutxCtsFlow = false;
-        m_currDCB.fRtsControl = RTS_CONTROL_DISABLE;
-        m_currDCB.fInX = m_currDCB.fOutX = true;
+        m_currentDcb.fOutxCtsFlow = false;
+        m_currentDcb.fRtsControl = RTS_CONTROL_DISABLE;
+        m_currentDcb.fInX = m_currentDcb.fOutX = true;
         break;
     case SerialPort::HardwareControl:
-        m_currDCB.fOutxCtsFlow = true;
-        m_currDCB.fRtsControl = RTS_CONTROL_HANDSHAKE;
-        m_currDCB.fInX = m_currDCB.fOutX = false;
+        m_currentDcb.fOutxCtsFlow = true;
+        m_currentDcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
+        m_currentDcb.fInX = m_currentDcb.fOutX = false;
         break;
     default:
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return updateDcb();
@@ -872,7 +872,7 @@ bool WinSerialPortEngine::isReadNotificationEnabled() const
 #else
     bool flag = isEnabled();
 #endif
-    return (flag && (m_setMask & EV_RXCHAR));
+    return (flag && (m_desiredMask & EV_RXCHAR));
 }
 
 /*!
@@ -891,13 +891,13 @@ void WinSerialPortEngine::setReadNotificationEnabled(bool enable)
 #endif
 
     if (enable)
-        m_setMask |= EV_RXCHAR;
+        m_desiredMask |= EV_RXCHAR;
     else
-        m_setMask &= ~EV_RXCHAR;
+        m_desiredMask &= ~EV_RXCHAR;
 
 #if defined (Q_OS_WINCE)
-    if (m_setMask != m_currentMask)
-        ::SetCommMask(m_descriptor, m_setMask);
+    if (m_desiredMask != m_currentMask)
+        ::SetCommMask(m_descriptor, m_desiredMask);
 
     m_setCommMaskMutex.unlock();
 
@@ -918,7 +918,7 @@ bool WinSerialPortEngine::isWriteNotificationEnabled() const
 #else
     bool flag = isEnabled();
 #endif
-    return (flag && (m_setMask & EV_TXEMPTY));
+    return (flag && (m_desiredMask & EV_TXEMPTY));
 }
 
 /*!
@@ -936,13 +936,13 @@ void WinSerialPortEngine::setWriteNotificationEnabled(bool enable)
 #endif
 
     if (enable)
-        m_setMask |= EV_TXEMPTY;
+        m_desiredMask |= EV_TXEMPTY;
     else
-        m_setMask &= ~EV_TXEMPTY;
+        m_desiredMask &= ~EV_TXEMPTY;
 
 #if defined (Q_OS_WINCE)
-    if (m_setMask != m_currentMask)
-        ::SetCommMask(m_descriptor, m_setMask);
+    if (m_desiredMask != m_currentMask)
+        ::SetCommMask(m_descriptor, m_desiredMask);
 
     m_setCommMaskMutex.unlock();
 
@@ -955,7 +955,7 @@ void WinSerialPortEngine::setWriteNotificationEnabled(bool enable)
     // after the last byte of data.
     // Therefore, we are forced to run writeNotification(), as EV_TXEMPTY does not work.
     if (enable)
-        m_parent->canWriteNotification();
+        dptr->canWriteNotification();
 }
 
 /*!
@@ -976,13 +976,13 @@ bool WinSerialPortEngine::processIOErrors()
     bool ret = (::ClearCommError(m_descriptor, &err, &cs) != 0);
     if (ret && err) {
         if (err & CE_FRAME)
-            m_parent->setError(SerialPort::FramingError);
+            dptr->setError(SerialPort::FramingError);
         else if (err & CE_RXPARITY)
-            m_parent->setError(SerialPort::ParityError);
+            dptr->setError(SerialPort::ParityError);
         else if (err & CE_BREAK)
-            m_parent->setError(SerialPort::BreakConditionError);
+            dptr->setError(SerialPort::BreakConditionError);
         else
-            m_parent->setError(SerialPort::UnknownPortError);
+            dptr->setError(SerialPort::UnknownPortError);
 
         m_flagErrorFromCommEvent = true;
     }
@@ -1015,11 +1015,14 @@ void WinSerialPortEngine::lockNotification(NotificationLockerType type, bool use
 void WinSerialPortEngine::unlockNotification(NotificationLockerType type)
 {
     switch (type) {
-    case CanReadLocker: m_readNotificationMutex.unlock();
+    case CanReadLocker:
+        m_readNotificationMutex.unlock();
         break;
-    case CanWriteLocker: m_writeNotificationMutex.unlock();
+    case CanWriteLocker:
+        m_writeNotificationMutex.unlock();
         break;
-    case CanErrorLocker: m_errorNotificationMutex.unlock();
+    case CanErrorLocker:
+        m_errorNotificationMutex.unlock();
         break;
     }
 }
@@ -1035,68 +1038,68 @@ void WinSerialPortEngine::unlockNotification(NotificationLockerType type)
 void WinSerialPortEngine::detectDefaultSettings()
 {
     // Detect rate.
-    m_parent->m_inRate = quint32(m_currDCB.BaudRate);
-    m_parent->m_outRate = m_parent->m_inRate;
+    dptr->options.inputRate = quint32(m_currentDcb.BaudRate);
+    dptr->options.outputRate = dptr->options.inputRate;
 
     // Detect databits.
-    switch (m_currDCB.ByteSize) {
+    switch (m_currentDcb.ByteSize) {
     case 5:
-        m_parent->m_dataBits = SerialPort::Data5;
+        dptr->options.dataBits = SerialPort::Data5;
         break;
     case 6:
-        m_parent->m_dataBits = SerialPort::Data6;
+        dptr->options.dataBits = SerialPort::Data6;
         break;
     case 7:
-        m_parent->m_dataBits = SerialPort::Data7;
+        dptr->options.dataBits = SerialPort::Data7;
         break;
     case 8:
-        m_parent->m_dataBits = SerialPort::Data8;
+        dptr->options.dataBits = SerialPort::Data8;
         break;
     default:
-        m_parent->m_dataBits = SerialPort::UnknownDataBits;
+        dptr->options.dataBits = SerialPort::UnknownDataBits;
     }
 
     // Detect parity.
-    if ((m_currDCB.Parity == NOPARITY) && !m_currDCB.fParity)
-        m_parent->m_parity = SerialPort::NoParity;
-    else if ((m_currDCB.Parity == SPACEPARITY) && m_currDCB.fParity)
-        m_parent->m_parity = SerialPort::SpaceParity;
-    else if ((m_currDCB.Parity == MARKPARITY) && m_currDCB.fParity)
-        m_parent->m_parity = SerialPort::MarkParity;
-    else if ((m_currDCB.Parity == EVENPARITY) && m_currDCB.fParity)
-        m_parent->m_parity = SerialPort::EvenParity;
-    else if ((m_currDCB.Parity == ODDPARITY) && m_currDCB.fParity)
-        m_parent->m_parity = SerialPort::OddParity;
+    if ((m_currentDcb.Parity == NOPARITY) && !m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::NoParity;
+    else if ((m_currentDcb.Parity == SPACEPARITY) && m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::SpaceParity;
+    else if ((m_currentDcb.Parity == MARKPARITY) && m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::MarkParity;
+    else if ((m_currentDcb.Parity == EVENPARITY) && m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::EvenParity;
+    else if ((m_currentDcb.Parity == ODDPARITY) && m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::OddParity;
     else
-        m_parent->m_parity = SerialPort::UnknownParity;
+        dptr->options.parity = SerialPort::UnknownParity;
 
     // Detect stopbits.
-    switch (m_currDCB.StopBits) {
+    switch (m_currentDcb.StopBits) {
     case ONESTOPBIT:
-        m_parent->m_stopBits = SerialPort::OneStop;
+        dptr->options.stopBits = SerialPort::OneStop;
         break;
     case ONE5STOPBITS:
-        m_parent->m_stopBits = SerialPort::OneAndHalfStop;
+        dptr->options.stopBits = SerialPort::OneAndHalfStop;
         break;
     case TWOSTOPBITS:
-        m_parent->m_stopBits = SerialPort::TwoStop;
+        dptr->options.stopBits = SerialPort::TwoStop;
         break;
     default:
-        m_parent->m_stopBits = SerialPort::UnknownStopBits;
+        dptr->options.stopBits = SerialPort::UnknownStopBits;
     }
 
     // Detect flow control.
-    if (!m_currDCB.fOutxCtsFlow && (m_currDCB.fRtsControl == RTS_CONTROL_DISABLE)
-            && !m_currDCB.fInX && !m_currDCB.fOutX) {
-        m_parent->m_flow = SerialPort::NoFlowControl;
-    } else if (!m_currDCB.fOutxCtsFlow && (m_currDCB.fRtsControl == RTS_CONTROL_DISABLE)
-               && m_currDCB.fInX && m_currDCB.fOutX) {
-        m_parent->m_flow = SerialPort::SoftwareControl;
-    } else if (m_currDCB.fOutxCtsFlow && (m_currDCB.fRtsControl == RTS_CONTROL_HANDSHAKE)
-               && !m_currDCB.fInX && !m_currDCB.fOutX) {
-        m_parent->m_flow = SerialPort::HardwareControl;
+    if (!m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
+            && !m_currentDcb.fInX && !m_currentDcb.fOutX) {
+        dptr->options.flow = SerialPort::NoFlowControl;
+    } else if (!m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
+               && m_currentDcb.fInX && m_currentDcb.fOutX) {
+        dptr->options.flow = SerialPort::SoftwareControl;
+    } else if (m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_HANDSHAKE)
+               && !m_currentDcb.fInX && !m_currentDcb.fOutX) {
+        dptr->options.flow = SerialPort::HardwareControl;
     } else
-        m_parent->m_flow = SerialPort::UnknownFlowControl;
+        dptr->options.flow = SerialPort::UnknownFlowControl;
 }
 
 #if defined (Q_OS_WINCE)
@@ -1114,7 +1117,7 @@ void WinSerialPortEngine::run()
     while (m_running) {
 
         m_setCommMaskMutex.lock();
-        ::SetCommMask(m_descriptor, m_setMask);
+        ::SetCommMask(m_descriptor, m_desiredMask);
         m_setCommMaskMutex.unlock();
 
         if (::WaitCommEvent(m_descriptor, &m_currentMask, 0) != 0) {
@@ -1124,15 +1127,15 @@ void WinSerialPortEngine::run()
             m_settingsChangeMutex.lock();
             m_settingsChangeMutex.unlock();
 
-            if (EV_ERR & m_currentMask & m_setMask) {
-                m_parent->canErrorNotification();
+            if (EV_ERR & m_currentMask & m_desiredMask) {
+                dptr->canErrorNotification();
             }
-            if (EV_RXCHAR & m_currentMask & m_setMask) {
-                m_parent->canReadNotification();
+            if (EV_RXCHAR & m_currentMask & m_desiredMask) {
+                dptr->canReadNotification();
             }
             //FIXME: This is why it does not work?
-            if (EV_TXEMPTY & m_currentMask & m_setMask) {
-                m_parent->canWriteNotification();
+            if (EV_TXEMPTY & m_currentMask & m_desiredMask) {
+                dptr->canWriteNotification();
             }
         }
     }
@@ -1151,24 +1154,24 @@ bool WinSerialPortEngine::event(QEvent *e)
 {
     bool ret = false;
     if (e->type() == QEvent::WinEventAct) {
-        if (EV_ERR & m_currentMask & m_setMask) {
-            m_parent->canErrorNotification();
+        if (EV_ERR & m_currentMask & m_desiredMask) {
+            dptr->canErrorNotification();
             ret = true;
         }
-        if (EV_RXCHAR & m_currentMask & m_setMask) {
-            m_parent->canReadNotification();
+        if (EV_RXCHAR & m_currentMask & m_desiredMask) {
+            dptr->canReadNotification();
             ret = true;
         }
         //FIXME: This is why it does not work?
-        if (EV_TXEMPTY & m_currentMask & m_setMask) {
-            m_parent->canWriteNotification();
+        if (EV_TXEMPTY & m_currentMask & m_desiredMask) {
+            dptr->canWriteNotification();
             ret = true;
         }
     }
     else
         ret = QWinEventNotifier::event(e);
 
-    ::WaitCommEvent(m_descriptor, &m_currentMask, &m_ov);
+    ::WaitCommEvent(m_descriptor, &m_currentMask, &m_ovNotify);
     return ret;
 }
 
@@ -1198,10 +1201,10 @@ bool WinSerialPortEngine::createEvents(bool rx, bool tx)
     }
     m_ovSelect.hEvent = ::CreateEvent(0, false, false, 0);
     Q_ASSERT(m_ovSelect.hEvent);
-    m_ov.hEvent = ::CreateEvent(0, false, false, 0);
-    Q_ASSERT(m_ov.hEvent);
+    m_ovNotify.hEvent = ::CreateEvent(0, false, false, 0);
+    Q_ASSERT(m_ovNotify.hEvent);
 
-    setHandle(m_ov.hEvent);
+    setHandle(m_ovNotify.hEvent);
     return true;
 }
 
@@ -1217,14 +1220,14 @@ void WinSerialPortEngine::closeEvents()
         ::CloseHandle(m_ovWrite.hEvent);
     if (m_ovSelect.hEvent)
         ::CloseHandle(m_ovSelect.hEvent);
-    if (m_ov.hEvent)
-        ::CloseHandle(m_ov.hEvent);
+    if (m_ovNotify.hEvent)
+        ::CloseHandle(m_ovNotify.hEvent);
 
     size_t size = sizeof(OVERLAPPED);
     ::memset(&m_ovRead, 0, size);
     ::memset(&m_ovWrite, 0, size);
     ::memset(&m_ovSelect, 0, size);
-    ::memset(&m_ov, 0, size);
+    ::memset(&m_ovNotify, 0, size);
 }
 
 /*!
@@ -1232,10 +1235,10 @@ void WinSerialPortEngine::closeEvents()
 */
 void WinSerialPortEngine::setMaskAndActivateEvent()
 {
-    ::SetCommMask(m_descriptor, m_setMask);
-    if (m_setMask)
-        ::WaitCommEvent(m_descriptor, &m_currentMask, &m_ov);
-    switch (m_setMask) {
+    ::SetCommMask(m_descriptor, m_desiredMask);
+    if (m_desiredMask)
+        ::WaitCommEvent(m_descriptor, &m_currentMask, &m_ovNotify);
+    switch (m_desiredMask) {
     case 0:
         if (isEnabled())
             setEnabled(false);
@@ -1265,8 +1268,8 @@ bool WinSerialPortEngine::updateDcb()
     // Otherwise WaitCommEvent blocking any change!
     ::SetCommMask(m_descriptor, 0);
 #endif
-    if (::SetCommState(m_descriptor, &m_currDCB) == 0) {
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+    if (::SetCommState(m_descriptor, &m_currentDcb) == 0) {
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return true;
@@ -1280,17 +1283,17 @@ bool WinSerialPortEngine::updateDcb()
 */
 bool WinSerialPortEngine::updateCommTimeouts()
 {
-    if (::SetCommTimeouts(m_descriptor, &m_currCommTimeouts) == 0) {
-        m_parent->setError(SerialPort::UnsupportedPortOperationError);
+    if (::SetCommTimeouts(m_descriptor, &m_currentCommTimeouts) == 0) {
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
         return false;
     }
     return true;
 }
 
 // From <serialportengine_p.h>
-SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *parent)
+SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
 {
-    return new WinSerialPortEngine(parent);
+    return new WinSerialPortEngine(d);
 }
 
 #include "moc_serialportengine_win_p.cpp"
diff --git a/src/serialportengine_win_p.h b/src/serialportengine_win_p.h
old mode 100644
new mode 100755
index e30335f..f8672f8
--- a/src/serialportengine_win_p.h
+++ b/src/serialportengine_win_p.h
@@ -26,8 +26,10 @@ class WinCeWaitCommEventBreaker : public QThread
     Q_OBJECT
 public:
     WinCeWaitCommEventBreaker(HANDLE descriptor, int timeout, QObject *parent = 0)
-        : QThread(parent), m_descriptor(descriptor),
-          m_timeout(timeout), m_worked(false) {
+        : QThread(parent)
+        , m_descriptor(descriptor)
+        , m_timeout(timeout)
+        , m_worked(false) {
         start();
     }
     virtual ~WinCeWaitCommEventBreaker() {
@@ -61,13 +63,13 @@ private:
 
 #if defined (Q_OS_WINCE)
 class WinSerialPortEngine : public QThread, public SerialPortEngine
-        #else
+#else
 class WinSerialPortEngine : public QWinEventNotifier, public SerialPortEngine
-        #endif
+#endif
 {
     Q_OBJECT
 public:
-    WinSerialPortEngine(SerialPortPrivate *parent);
+    WinSerialPortEngine(SerialPortPrivate *d);
     virtual ~WinSerialPortEngine();
 
     virtual bool open(const QString &location, QIODevice::OpenMode mode);
@@ -112,6 +114,7 @@ public:
     virtual bool processIOErrors();
 
 #if defined (Q_OS_WINCE)
+    // FIXME
     virtual void lockNotification(NotificationLockerType type, bool uselocker);
     virtual void unlockNotification(NotificationLockerType type);
 #endif
@@ -126,14 +129,25 @@ protected:
 #endif
 
 private:
-    DCB m_currDCB;
-    DCB m_oldDCB;
-    COMMTIMEOUTS m_currCommTimeouts;
-    COMMTIMEOUTS m_oldCommTimeouts;
+
+#if !defined (Q_OS_WINCE)
+    bool createEvents(bool rx, bool tx);
+    void closeEvents();
+    void setMaskAndActivateEvent();
+#endif
+
+    bool updateDcb();
+    bool updateCommTimeouts();
+
+private:
+    DCB m_currentDcb;
+    DCB m_restoredDcb;
+    COMMTIMEOUTS m_currentCommTimeouts;
+    COMMTIMEOUTS m_restoredCommTimeouts;
     HANDLE m_descriptor;
     bool m_flagErrorFromCommEvent;
     DWORD m_currentMask;
-    DWORD m_setMask;
+    DWORD m_desiredMask;
 
 #if defined (Q_OS_WINCE)
     QMutex m_readNotificationMutex;
@@ -146,15 +160,8 @@ private:
     OVERLAPPED m_ovRead;
     OVERLAPPED m_ovWrite;
     OVERLAPPED m_ovSelect;
-    OVERLAPPED m_ov;
-
-    bool createEvents(bool rx, bool tx);
-    void closeEvents();
-    void setMaskAndActivateEvent();
+    OVERLAPPED m_ovNotify;
 #endif
-
-    bool updateDcb();
-    bool updateCommTimeouts();
 };
 
 QT_END_NAMESPACE_SERIALPORT