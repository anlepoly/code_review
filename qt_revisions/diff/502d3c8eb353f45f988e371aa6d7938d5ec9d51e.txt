diff --git a/src/multimedia/audio/audio.pri b/src/multimedia/audio/audio.pri
index 86c379d..8c8daa5 100644
--- a/src/multimedia/audio/audio.pri
+++ b/src/multimedia/audio/audio.pri
@@ -1,17 +1,24 @@
 INCLUDEPATH += audio
 
-PUBLIC_HEADERS += audio/qaudio.h \
+PUBLIC_HEADERS += \
+           audio/qaudio.h \
            audio/qaudioformat.h \
            audio/qaudioinput.h \
            audio/qaudiooutput.h \
            audio/qaudiodeviceinfo.h \
            audio/qaudiosystemplugin.h \
-           audio/qaudiosystem.h 
+           audio/qaudiosystem.h  \
+           audio/qsoundeffect.h \
+           audio/qsound.h
 
-PRIVATE_HEADERS += audio/qaudiodevicefactory_p.h audio/qaudiopluginloader_p.h
+PRIVATE_HEADERS += \
+           audio/qaudiodevicefactory_p.h \
+           audio/qaudiopluginloader_p.h \
+           audio/qwavedecoder_p.h \
+           audio/qsamplecache_p.h
 
-
-SOURCES += audio/qaudio.cpp \
+SOURCES += \
+           audio/qaudio.cpp \
            audio/qaudioformat.cpp  \
            audio/qaudiodeviceinfo.cpp \
            audio/qaudiooutput.cpp \
@@ -19,7 +26,11 @@ SOURCES += audio/qaudio.cpp \
            audio/qaudiosystemplugin.cpp \
            audio/qaudiosystem.cpp \
            audio/qaudiodevicefactory.cpp \
-           audio/qaudiopluginloader.cpp
+           audio/qaudiopluginloader.cpp \
+           audio/qsoundeffect.cpp \
+           audio/qwavedecoder_p.cpp \
+           audio/qsamplecache_p.cpp \
+           audio/qsound.cpp
 
 mac {
     PRIVATE_HEADERS +=  audio/qaudioinput_mac_p.h \
@@ -46,15 +57,29 @@ win32 {
 unix:!mac {
     contains(config_test_pulseaudio, yes) {
         DEFINES += QT_NO_AUDIO_BACKEND
-    }
-    else:contains(config_test_alsa, yes) {
-        linux-*|freebsd-*|openbsd-* {
+        CONFIG += link_pkgconfig
+        PKGCONFIG += libpulse
+
+        DEFINES += QT_MULTIMEDIA_PULSEAUDIO
+        PRIVATE_HEADERS += audio/qsoundeffect_pulse_p.h
+        SOURCES += audio/qsoundeffect_pulse_p.cpp
+        !maemo*:DEFINES += QTM_PULSEAUDIO_DEFAULTBUFFER
+    } else {
+        DEFINES += QT_MULTIMEDIA_QMEDIAPLAYER
+        PRIVATE_HEADERS += audio/qsoundeffect_qmedia_p.h
+        SOURCES += audio/qsoundeffect_qmedia_p.cpp
+
+        contains(config_test_alsa, yes):linux-*|freebsd-*|openbsd-* {
             DEFINES += HAS_ALSA
             PRIVATE_HEADERS += audio/qaudiooutput_alsa_p.h audio/qaudioinput_alsa_p.h audio/qaudiodeviceinfo_alsa_p.h
             SOURCES += audio/qaudiodeviceinfo_alsa_p.cpp \
-                   audio/qaudiooutput_alsa_p.cpp \
-                   audio/qaudioinput_alsa_p.cpp
+                audio/qaudiooutput_alsa_p.cpp \
+                audio/qaudioinput_alsa_p.cpp
             LIBS_PRIVATE += -lasound
         }
     }
+} else {
+    DEFINES += QT_MULTIMEDIA_QMEDIAPLAYER
+    PRIVATE_HEADERS += audio/qsoundeffect_qmedia_p.h
+    SOURCES += audio/qsoundeffect_qmedia_p.cpp
 }
diff --git a/src/multimedia/audio/qsamplecache_p.cpp b/src/multimedia/audio/qsamplecache_p.cpp
new file mode 100644
index 0000000..1a06cd1
--- /dev/null
+++ b/src/multimedia/audio/qsamplecache_p.cpp
@@ -0,0 +1,401 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qsamplecache_p.h"
+#include "qwavedecoder_p.h"
+#include <QtNetwork>
+
+//#define QT_SAMPLECACHE_DEBUG
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QSampleCache
+    \internal
+
+    When you want to get a sound sample data, you need to request the QSample reference from QSampleCache.
+
+    \since 1.1
+
+    \code
+        QSample *m_sample;     // class member.
+
+      private Q_SLOTS:
+        void decoderError();
+        void sampleReady();
+    \endcode
+
+    \code
+      Q_GLOBAL_STATIC(QSampleCache, sampleCache) //declare a singleton manager
+    \endcode
+
+    \code
+        m_sample = sampleCache()->requestSample(url);
+        switch(m_sample->state()) {
+        case QSample::Ready:
+            sampleReady();
+            break;
+        case QSample::Error:
+            decoderError();
+            break;
+        default:
+            connect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
+            connect(m_sample, SIGNAL(ready()), this, SLOT(sampleReady()));
+            break;
+        }
+    \endcode
+
+    When you no longer need the sound sample data, you need to release it:
+
+    \code
+       if (m_sample) {
+           m_sample->release();
+           m_sample = 0;
+       }
+    \endcode
+*/
+
+QSampleCache::QSampleCache()
+    : m_networkAccessManager(0)
+    , m_mutex(QMutex::Recursive)
+    , m_capacity(0)
+    , m_usage(0)
+{
+    m_loadingThread.setObjectName(QLatin1String("QSampleCache::LoadingThread"));
+}
+
+QNetworkAccessManager& QSampleCache::networkAccessManager()
+{
+    if (!m_networkAccessManager)
+        m_networkAccessManager = new QNetworkAccessManager();
+    return *m_networkAccessManager;
+}
+
+QSampleCache::~QSampleCache()
+{
+    QMutexLocker m(&m_mutex);
+
+    m_loadingThread.quit();
+    m_loadingThread.wait();
+
+    // Killing the loading thread means that no samples can be
+    // deleted using deleteLater.  And some samples that had deleteLater
+    // already called won't have been processed (m_staleSamples)
+    foreach (QSample* sample, m_samples)
+        delete sample;
+
+    foreach (QSample* sample, m_staleSamples)
+        delete sample; // deleting a sample does affect the m_staleSamples list, but foreach copies it
+
+    delete m_networkAccessManager;
+}
+
+QSample* QSampleCache::requestSample(const QUrl& url)
+{
+    if (!m_loadingThread.isRunning())
+        m_loadingThread.start();
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "QSampleCache: request sample [" << url << "]";
+#endif
+    QMutexLocker locker(&m_mutex);
+    QMap<QUrl, QSample*>::iterator it = m_samples.find(url);
+    QSample* sample;
+    if (it == m_samples.end()) {
+        sample = new QSample(url, this);
+        m_samples.insert(url, sample);
+        sample->moveToThread(&m_loadingThread);
+    } else {
+        sample = *it;
+    }
+
+    sample->addRef();
+    locker.unlock();
+
+    sample->loadIfNecessary();
+    return sample;
+}
+
+void QSampleCache::setCapacity(qint64 capacity)
+{
+    QMutexLocker locker(&m_mutex);
+    if (m_capacity == capacity)
+        return;
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "QSampleCache: capacity changes from " << m_capacity << "to " << capacity;
+#endif
+    if (m_capacity > 0 && capacity <= 0) { //memory management strategy changed
+        for (QMap<QUrl, QSample*>::iterator it = m_samples.begin(); it != m_samples.end();) {
+            QSample* sample = *it;
+            if (sample->m_ref == 0) {
+                unloadSample(sample);
+                it = m_samples.erase(it);
+            } else
+                it++;
+        }
+    }
+
+    m_capacity = capacity;
+    refresh(0);
+}
+
+// Called locked
+void QSampleCache::unloadSample(QSample *sample)
+{
+    m_usage -= sample->m_soundData.size();
+    m_staleSamples.insert(sample);
+    sample->deleteLater();
+}
+
+// Called in both threads
+void QSampleCache::refresh(qint64 usageChange)
+{
+    QMutexLocker locker(&m_mutex);
+    m_usage += usageChange;
+    if (m_capacity <= 0 || m_usage <= m_capacity)
+        return;
+
+#ifdef QT_SAMPLECACHE_DEBUG
+    qint64 recoveredSize = 0;
+#endif
+
+    //free unused samples to keep usage under capacity limit.
+    for (QMap<QUrl, QSample*>::iterator it = m_samples.begin(); it != m_samples.end();) {
+        QSample* sample = *it;
+        if (sample->m_ref > 0) {
+            ++it;
+            continue;
+        }
+#ifdef QT_SAMPLECACHE_DEBUG
+        recoveredSize += sample->m_soundData.size();
+#endif
+        unloadSample(sample);
+        it = m_samples.erase(it);
+        if (m_usage <= m_capacity)
+            return;
+    }
+
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "QSampleCache: refresh(" << usageChange
+             << ") recovered size =" << recoveredSize
+             << "new usage =" << m_usage;
+#endif
+
+    if (m_usage > m_capacity)
+        qWarning() << "QSampleCache: usage[" << m_usage << " out of limit[" << m_capacity << "]";
+}
+
+// Called in both threads
+void QSampleCache::removeUnreferencedSample(QSample *sample)
+{
+    QMutexLocker m(&m_mutex);
+    m_staleSamples.remove(sample);
+}
+
+// Called in loader thread (since this lives in that thread)
+// Also called from application thread after loader thread dies.
+QSample::~QSample()
+{
+    // Remove ourselves from our parent
+    m_parent->removeUnreferencedSample(this);
+
+    QMutexLocker locker(&m_mutex);
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "~QSample" << this << ": deleted [" << m_url << "]" << QThread::currentThread();
+#endif
+    cleanup();
+}
+
+// Called in application thread
+void QSample::loadIfNecessary()
+{
+    QMutexLocker locker(&m_mutex);
+    if (m_state == QSample::Error || m_state == QSample::Creating) {
+        m_state = QSample::Loading;
+        QMetaObject::invokeMethod(this, "load", Qt::QueuedConnection);
+    }
+}
+
+// Called in both threads
+bool QSampleCache::notifyUnreferencedSample(QSample* sample)
+{
+    QMutexLocker locker(&m_mutex);
+    if (m_capacity > 0)
+        return false;
+    m_samples.remove(sample->m_url);
+    m_staleSamples.insert(sample);
+    sample->deleteLater();
+    return true;
+}
+
+// Called in application threadd
+void QSample::release()
+{
+    QMutexLocker locker(&m_mutex);
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "Sample:: release" << this << QThread::currentThread() << m_ref;
+#endif
+    m_ref--;
+    if (m_ref == 0)
+        m_parent->notifyUnreferencedSample(this);
+}
+
+// Called in dtor and when stream is loaded
+// must be called locked.
+void QSample::cleanup()
+{
+    if (m_waveDecoder)
+        m_waveDecoder->deleteLater();
+    if (m_stream)
+        m_stream->deleteLater();
+
+    m_waveDecoder = 0;
+    m_stream = 0;
+}
+
+// Called in application thread
+void QSample::addRef()
+{
+    m_ref++;
+}
+
+// Called in loading thread
+void QSample::readSample()
+{
+    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
+    QMutexLocker m(&m_mutex);
+#ifdef  QT_SAMPLECACHE_DEBUG
+    qDebug() << "QSample: readSample";
+#endif
+    qint64 read = m_waveDecoder->read(m_soundData.data() + m_sampleReadLength,
+                      qMin(m_waveDecoder->bytesAvailable(),
+                           qint64(m_waveDecoder->size() - m_sampleReadLength)));
+    if (read > 0)
+        m_sampleReadLength += read;
+    if (m_sampleReadLength < m_waveDecoder->size())
+        return;
+    Q_ASSERT(m_sampleReadLength == qint64(m_soundData.size()));
+    onReady();
+}
+
+// Called in loading thread
+void QSample::decoderReady()
+{
+    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
+    QMutexLocker m(&m_mutex);
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "QSample: decoder ready";
+#endif
+    m_parent->refresh(m_waveDecoder->size());
+
+    m_soundData.resize(m_waveDecoder->size());
+    m_sampleReadLength = 0;
+    qint64 read = m_waveDecoder->read(m_soundData.data(), m_waveDecoder->size());
+    if (read > 0)
+        m_sampleReadLength += read;
+    if (m_sampleReadLength >= m_waveDecoder->size())
+        onReady();
+}
+
+// Called in all threads
+QSample::State QSample::state() const
+{
+    QMutexLocker m(&m_mutex);
+    return m_state;
+}
+
+// Called in loading thread
+// Essentially a second ctor, doesn't need locks (?)
+void QSample::load()
+{
+    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "QSample: load [" << m_url << "]";
+#endif
+    m_stream = m_parent->networkAccessManager().get(QNetworkRequest(m_url));
+    connect(m_stream, SIGNAL(error(QNetworkReply::NetworkError)), SLOT(decoderError()));
+    m_waveDecoder = new QWaveDecoder(m_stream);
+    connect(m_waveDecoder, SIGNAL(formatKnown()), SLOT(decoderReady()));
+    connect(m_waveDecoder, SIGNAL(parsingError()), SLOT(decoderError()));
+    connect(m_waveDecoder, SIGNAL(readyRead()), SLOT(readSample()));
+}
+
+// Called in loading thread
+void QSample::decoderError()
+{
+    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
+    QMutexLocker m(&m_mutex);
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "QSample: decoder error";
+#endif
+    cleanup();
+    m_state = QSample::Error;
+    emit error();
+}
+
+// Called in loading thread from decoder when sample is done. Locked already.
+void QSample::onReady()
+{
+    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
+#ifdef QT_SAMPLECACHE_DEBUG
+    qDebug() << "QSample: load ready";
+#endif
+    m_audioFormat = m_waveDecoder->audioFormat();
+    cleanup();
+    m_state = QSample::Ready;
+    emit ready();
+}
+
+// Called in application thread, then moved to loader thread
+QSample::QSample(const QUrl& url, QSampleCache *parent)
+    : m_parent(parent)
+    , m_stream(0)
+    , m_waveDecoder(0)
+    , m_url(url)
+    , m_sampleReadLength(0)
+    , m_state(Creating)
+    , m_ref(0)
+{
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qsamplecache_p.cpp"
diff --git a/src/multimedia/audio/qsamplecache_p.h b/src/multimedia/audio/qsamplecache_p.h
new file mode 100644
index 0000000..91ca457
--- /dev/null
+++ b/src/multimedia/audio/qsamplecache_p.h
@@ -0,0 +1,161 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSAMPLECACHE_P_H
+#define QSAMPLECACHE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qobject.h>
+#include <QtCore/qthread.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qmutex.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qset.h>
+#include <qaudioformat.h>
+
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QNetworkAccessManager;
+class QSampleCache;
+class QWaveDecoder;
+
+// Lives in application thread
+class QSample : public QObject
+{
+    Q_OBJECT
+public:
+    friend class QSampleCache;
+    enum State
+    {
+        Creating,
+        Loading,
+        Error,
+        Ready,
+    };
+
+    State state() const;
+    // These are not (currently) locked because they are only meant to be called after these
+    // variables are updated to their final states
+    const QByteArray& data() const { Q_ASSERT(state() == Ready); return m_soundData; }
+    const QAudioFormat& format() const { Q_ASSERT(state() == Ready); return m_audioFormat; }
+    void release();
+
+Q_SIGNALS:
+    void error();
+    void ready();
+
+protected:
+    QSample(const QUrl& url, QSampleCache *parent);
+
+private Q_SLOTS:
+    void load();
+    void decoderError();
+    void readSample();
+    void decoderReady();
+
+private:
+    void onReady();
+    void cleanup();
+    void addRef();
+    void loadIfNecessary();
+    QSample();
+    ~QSample();
+
+    mutable QMutex m_mutex;
+    QSampleCache *m_parent;
+    QByteArray   m_soundData;
+    QAudioFormat m_audioFormat;
+    QIODevice    *m_stream;
+    QWaveDecoder *m_waveDecoder;
+    QUrl         m_url;
+    qint64       m_sampleReadLength;
+    State        m_state;
+    int          m_ref;
+};
+
+class QSampleCache
+{
+public:
+    friend class QSample;
+
+    QSampleCache();
+    ~QSampleCache();
+
+    QSample* requestSample(const QUrl& url);
+    void setCapacity(qint64 capacity);
+
+private:
+    QMap<QUrl, QSample*> m_samples;
+    QSet<QSample*> m_staleSamples;
+    QNetworkAccessManager *m_networkAccessManager;
+    QMutex m_mutex;
+    qint64 m_capacity;
+    qint64 m_usage;
+    QThread m_loadingThread;
+
+    QNetworkAccessManager& networkAccessManager();
+    void refresh(qint64 usageChange);
+    bool notifyUnreferencedSample(QSample* sample);
+    void removeUnreferencedSample(QSample* sample);
+    void unloadSample(QSample* sample);
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QSAMPLECACHE_P_H
diff --git a/src/multimedia/audio/qsound.cpp b/src/multimedia/audio/qsound.cpp
new file mode 100644
index 0000000..3749764
--- /dev/null
+++ b/src/multimedia/audio/qsound.cpp
@@ -0,0 +1,236 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qsound.h"
+#include "qsoundeffect.h"
+#include "qcoreapplication.h"
+
+
+/*!
+    \class QSound
+    \brief The QSound class provides a way to play .wav sound files.
+
+    \ingroup multimedia
+
+
+    Qt provides the most commonly required audio operation in GUI
+    applications: asynchronously playing a sound file. This is most
+    easily accomplished using the static play() function:
+
+    \snippet doc/src/snippets/multimedia-snippets/qsound.cpp 0
+
+    Alternatively, create a QSound object from the sound file first
+    and then call the play() slot:
+
+    \snippet doc/src/snippets/multimedia-snippets/qsound.cpp 1
+
+    Once created a QSound object can be queried for its fileName() and
+    total number of loops() (i.e. the number of times the sound will
+    play). The number of repetitions can be altered using the
+    setLoops() function. While playing the sound, the loopsRemaining()
+    function returns the remaining number of repetitions. Use the
+    isFinished() function to determine whether the sound has finished
+    playing.
+
+    Sounds played using a QSound object may use more memory than the
+    static play() function, but it may also play more immediately
+    (depending on the underlying platform audio facilities).
+
+*/
+
+
+/*!
+    Plays the sound stored in the file specified by the given \a filename.
+
+    \since 5.0
+    \sa stop(), loopsRemaining(), isFinished()
+*/
+void QSound::play(const QString& filename)
+{
+    // Object destruction is generaly handled via deleteOnComplete
+    // Unexpected cases will be handled via parenting of QSound objects to qApp
+    QSound *sound = new QSound(filename, qApp);
+    sound->connect(sound->m_soundEffect, SIGNAL(playingChanged()), SLOT(deleteOnComplete()));
+    sound->play();
+}
+
+/*!
+    Constructs a QSound object from the file specified by the given \a
+    filename and with the given \a parent.
+
+    \since 5.0
+    \sa play()
+*/
+QSound::QSound(const QString& filename, QObject* parent)
+    : QObject(parent)
+{
+    m_soundEffect = new QSoundEffect(this);
+    m_soundEffect->setSource(QUrl::fromLocalFile(filename));
+}
+
+/*!
+    Destroys this sound object. If the sound is not finished playing,
+    the stop() function is called before the sound object is
+    destroyed.
+
+    \since 5.0
+    \sa stop(), isFinished()
+*/
+QSound::~QSound()
+{
+    if (!isFinished())
+        stop();
+}
+
+/*!
+    Returns true if the sound has finished playing; otherwise returns false.
+*/
+bool QSound::isFinished() const
+{
+    return !m_soundEffect->isPlaying();
+}
+
+/*!
+    \overload
+
+    Starts playing the sound specified by this QSound object.
+
+    The function returns immediately.  Depending on the platform audio
+    facilities, other sounds may stop or be mixed with the new
+    sound. The sound can be played again at any time, possibly mixing
+    or replacing previous plays of the sound.
+
+    \since 5.0
+    \sa fileName()
+*/
+void QSound::play()
+{
+    m_soundEffect->play();
+}
+
+/*!
+    Returns the number of times the sound will play.
+    Return value of \c QSound::Infinite indicates infinite number of loops
+
+    \since 5.0
+    \sa loopsRemaining(), setLoops()
+*/
+int QSound::loops() const
+{
+    // retain old API value for infite loops
+    int loopCount = m_soundEffect->loopCount();
+    if (loopCount == QSoundEffect::Infinite)
+        loopCount = Infinite;
+
+    return loopCount;
+}
+
+/*!
+    Returns the remaining number of times the sound will loop (for all
+    positive values this value decreases each time the sound is played).
+    Return value of \c QSound::Infinite indicates infinite number of loops
+
+    \since 5.0
+    \sa loops(), isFinished()
+*/
+int QSound::loopsRemaining() const
+{
+    // retain old API value for infite loops
+    int loopsRemaining = m_soundEffect->loopsRemaining();
+    if (loopsRemaining == QSoundEffect::Infinite)
+        loopsRemaining = Infinite;
+
+    return loopsRemaining;
+}
+
+/*!
+    \fn void QSound::setLoops(int number)
+
+    Sets the sound to repeat the given \a number of times when it is
+    played.
+
+    Note that passing the value \c QSound::Infinite will cause the sound to loop
+    indefinitely.
+
+    \since 5.0
+    \sa loops()
+*/
+void QSound::setLoops(int n)
+{
+    if (n == Infinite)
+        n = QSoundEffect::Infinite;
+
+    m_soundEffect->setLoopCount(n);
+}
+
+/*!
+    Returns the filename associated with this QSound object.
+
+    \since 5.0
+    \sa QSound()
+*/
+QString QSound::fileName() const
+{
+    return m_soundEffect->source().toLocalFile();
+}
+
+/*!
+    Stops the sound playing.
+
+    \since 5.0
+    \sa play()
+*/
+void QSound::stop()
+{
+    m_soundEffect->stop();
+}
+
+/*!
+    \internal
+    \since 5.0
+*/
+void QSound::deleteOnComplete()
+{
+    if (!m_soundEffect->isPlaying())
+        deleteLater();
+}
+
+#include "moc_qsound.cpp"
diff --git a/src/multimedia/audio/qsound.h b/src/multimedia/audio/qsound.h
new file mode 100644
index 0000000..c45ddb1
--- /dev/null
+++ b/src/multimedia/audio/qsound.h
@@ -0,0 +1,93 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSOUND_H
+#define QSOUND_H
+
+#include <qtmultimediadefs.h>
+#include <QtCore/qobject.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QSoundEffect;
+
+class Q_MULTIMEDIA_EXPORT QSound : public QObject
+{
+    Q_OBJECT
+public:
+    enum Loop
+    {
+        Infinite = -1,
+    };
+
+    static void play(const QString& filename);
+
+    explicit QSound(const QString& filename, QObject* parent = 0);
+    ~QSound();
+
+    int loops() const;
+    int loopsRemaining() const;
+    void setLoops(int);
+    QString fileName() const;
+
+    bool isFinished() const;
+
+public Q_SLOTS:
+    void play();
+    void stop();
+
+private Q_SLOTS:
+    void deleteOnComplete();
+
+private:
+    QSoundEffect *m_soundEffect;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QSOUND_H
diff --git a/src/multimedia/audio/qsoundeffect.cpp b/src/multimedia/audio/qsoundeffect.cpp
new file mode 100644
index 0000000..b1c359e
--- /dev/null
+++ b/src/multimedia/audio/qsoundeffect.cpp
@@ -0,0 +1,311 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qsoundeffect.h"
+
+#if defined(QT_MULTIMEDIA_PULSEAUDIO)
+#include "qsoundeffect_pulse_p.h"
+#elif(QT_MULTIMEDIA_QMEDIAPLAYER)
+#include "qsoundeffect_qmedia_p.h"
+#endif
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \qmlclass SoundEffect QSoundEffect
+    \brief The SoundEffect element provides a way to play sound effects in QML.
+    \since 1.0
+
+    \inmodule QtMultimedia
+
+    This element is part of the \bold{QtMultimedia 4.0} module.
+
+    The following example plays a WAV file on mouse click.
+
+    \snippet doc/src/snippets/multimedia-snippets/soundeffect.qml complete snippet
+*/
+
+/*!
+    \qmlproperty url SoundEffect::source
+    \since 1.0
+
+    This property provides a way to control the sound to play.
+*/
+
+/*!
+    \qmlproperty int SoundEffect::loops
+    \since 1.0
+
+    This property provides a way to control the number of times to repeat the sound on each play().
+
+    Set to -1 (infinite) to enable infinite loop.
+*/
+
+/*!
+    \qmlproperty qreal SoundEffect::volume
+    \since 1.0
+
+    This property holds the volume of the playback, from 0.0 (silent) to 1.0 (maximum volume).
+    Note: Currently this has no effect on Mac OS X.
+*/
+
+/*!
+    \qmlproperty bool SoundEffect::muted
+    \since 1.0
+
+    This property provides a way to control muting.
+*/
+
+/*!
+    \qmlproperty bool SoundEffect::playing
+    \since 1.1
+
+    This property indicates if the soundeffect is playing or not.
+*/
+
+/*!
+    \qmlproperty int SoundEffect::status
+    \since 1.0
+
+    This property indicates the following status of the soundeffect.
+
+    Null: no source has been set or is null.
+    Loading: the soundeffect is trying to load the source.
+    Ready: the source is loaded and ready for play.
+    Error: some error happened during operation, such as failure of loading the source.
+*/
+
+/*!
+    \qmlsignal SoundEffect::sourceChanged()
+    \since 1.0
+
+    This handler is called when the source has changed.
+*/
+
+/*!
+    \qmlsignal SoundEffect::loopCountChanged()
+    \since 1.0
+
+    This handler is called when the initial number of loops has changed.
+*/
+
+/*!
+    \qmlsignal SoundEffect::loopsRemainingChanged()
+    \since 1.0
+
+    This handler is called when the remaining number of loops has changed.
+*/
+
+/*!
+    \qmlsignal SoundEffect::volumeChanged()
+    \since 1.0
+
+    This handler is called when the volume has changed.
+*/
+
+/*!
+    \qmlsignal SoundEffect::mutedChanged()
+    \since 1.0
+
+    This handler is called when the mute state has changed.
+*/
+
+/*!
+    \qmlsignal SoundEffect::playingChanged()
+    \since 1.0
+
+    This handler is called when the playing property has changed.
+*/
+
+/*!
+    \qmlsignal SoundEffect::statusChanged()
+
+    This handler is called when the status property has changed.
+    \since 1.0
+*/
+
+
+/*!
+    \since 1.0
+*/
+
+QSoundEffect::QSoundEffect(QObject *parent) :
+    QObject(parent)
+{
+    d = new QSoundEffectPrivate(this);
+    connect(d, SIGNAL(loopsRemainingChanged()), SIGNAL(loopsRemainingChanged()));
+    connect(d, SIGNAL(volumeChanged()), SIGNAL(volumeChanged()));
+    connect(d, SIGNAL(mutedChanged()), SIGNAL(mutedChanged()));
+    connect(d, SIGNAL(loadedChanged()), SIGNAL(loadedChanged()));
+    connect(d, SIGNAL(playingChanged()), SIGNAL(playingChanged()));
+    connect(d, SIGNAL(statusChanged()), SIGNAL(statusChanged()));
+}
+
+QSoundEffect::~QSoundEffect()
+{
+    d->release();
+}
+
+QStringList QSoundEffect::supportedMimeTypes()
+{
+    return QSoundEffectPrivate::supportedMimeTypes();
+}
+
+QUrl QSoundEffect::source() const
+{
+    return d->source();
+}
+
+void QSoundEffect::setSource(const QUrl &url)
+{
+    if (d->source() == url)
+        return;
+
+    d->setSource(url);
+
+    emit sourceChanged();
+}
+
+int QSoundEffect::loopCount() const
+{
+    return d->loopCount();
+}
+
+int QSoundEffect::loopsRemaining() const
+{
+    return d->loopsRemaining();
+}
+
+void QSoundEffect::setLoopCount(int loopCount)
+{
+    if (loopCount < 0 && loopCount != Infinite) {
+        qWarning("SoundEffect: loops should be SoundEffect.Infinite, 0 or positive integer");
+        return;
+    }
+    if (loopCount == 0)
+        loopCount = 1;
+    if (d->loopCount() == loopCount)
+        return;
+
+    d->setLoopCount(loopCount);
+    emit loopCountChanged();
+}
+
+qreal QSoundEffect::volume() const
+{
+    return qreal(d->volume()) / 100;
+}
+
+void QSoundEffect::setVolume(qreal volume)
+{
+    if (volume < 0 || volume > 1) {
+        qWarning("SoundEffect: volume should be between 0.0 and 1.0");
+        return;
+    }
+    int iVolume = qRound(volume * 100);
+    if (d->volume() == iVolume)
+        return;
+
+    d->setVolume(iVolume);
+}
+
+bool QSoundEffect::isMuted() const
+{
+    return d->isMuted();
+}
+
+void QSoundEffect::setMuted(bool muted)
+{
+    if (d->isMuted() == muted)
+        return;
+
+    d->setMuted(muted);
+}
+
+bool QSoundEffect::isLoaded() const
+{
+    return d->isLoaded();
+}
+
+/*!
+  \qmlmethod SoundEffect::play()
+
+  Start playback of the sound effect, looping the effect for the number of
+  times as specificed in the loops property.
+
+  This is the default method for SoundEffect.
+
+  \snippet doc/src/snippets/multimedia-snippets/soundeffect.qml play sound on click
+  \since 1.0
+*/
+void QSoundEffect::play()
+{
+    d->play();
+}
+
+bool QSoundEffect::isPlaying() const
+{
+    return d->isPlaying();
+}
+
+QSoundEffect::Status QSoundEffect::status() const
+{
+    return d->status();
+}
+
+
+/*!
+  \qmlmethod SoundEffect::stop()
+
+  Stop current playback.
+  Note that if the backend is PulseAudio, due to the limitation of the underlying API,
+  tis stop will only prevent next looping but will not be able to stop current playback immediately.
+
+  \since 1.0
+ */
+void QSoundEffect::stop()
+{
+    d->stop();
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qsoundeffect.cpp"
diff --git a/src/multimedia/audio/qsoundeffect.h b/src/multimedia/audio/qsoundeffect.h
new file mode 100644
index 0000000..f5df832
--- /dev/null
+++ b/src/multimedia/audio/qsoundeffect.h
@@ -0,0 +1,135 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSOUNDEFFECT_H
+#define QSOUNDEFFECT_H
+
+#include <qtmultimediadefs.h>
+#include <QtCore/qobject.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qstringlist.h>
+
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QSoundEffectPrivate;
+
+class Q_MULTIMEDIA_EXPORT QSoundEffect : public QObject
+{
+    Q_OBJECT
+    Q_CLASSINFO("DefaultMethod", "play()")
+    Q_PROPERTY(QUrl source READ source WRITE setSource NOTIFY sourceChanged)
+    Q_PROPERTY(int loops READ loopCount WRITE setLoopCount NOTIFY loopCountChanged)
+    Q_PROPERTY(int loopsRemaining READ loopsRemaining NOTIFY loopsRemainingChanged)
+    Q_PROPERTY(qreal volume READ volume WRITE setVolume NOTIFY volumeChanged)
+    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
+    Q_PROPERTY(bool playing READ isPlaying NOTIFY playingChanged)
+    Q_PROPERTY(Status status READ status NOTIFY statusChanged)
+    Q_ENUMS(Loop)
+    Q_ENUMS(Status)
+
+public:
+    enum Loop
+    {
+        Infinite = -2,
+    };
+
+    enum Status
+    {
+        Null,
+        Loading,
+        Ready,
+        Error
+    };
+
+    explicit QSoundEffect(QObject *parent = 0);
+    ~QSoundEffect();
+
+    static QStringList supportedMimeTypes();
+
+    QUrl source() const;
+    void setSource(const QUrl &url);
+
+    int loopCount() const;
+    int loopsRemaining() const;
+    void setLoopCount(int loopCount);
+
+    qreal volume() const;
+    void setVolume(qreal volume);
+
+    bool isMuted() const;
+    void setMuted(bool muted);
+
+    bool isLoaded() const;
+
+    bool isPlaying() const;
+    Status status() const;
+
+Q_SIGNALS:
+    void sourceChanged();
+    void loopCountChanged();
+    void loopsRemainingChanged();
+    void volumeChanged();
+    void mutedChanged();
+    void loadedChanged();
+    void playingChanged();
+    void statusChanged();
+
+public Q_SLOTS:
+    void play();
+    void stop();
+
+private:
+    Q_DISABLE_COPY(QSoundEffect)
+    QSoundEffectPrivate* d;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QSOUNDEFFECT_H
diff --git a/src/multimedia/audio/qsoundeffect_pulse_p.cpp b/src/multimedia/audio/qsoundeffect_pulse_p.cpp
new file mode 100644
index 0000000..373586e
--- /dev/null
+++ b/src/multimedia/audio/qsoundeffect_pulse_p.cpp
@@ -0,0 +1,1100 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// INTERNAL USE ONLY: Do NOT use for any other purpose.
+//
+
+#include <QtCore/qcoreapplication.h>
+#include <qaudioformat.h>
+#include <QtNetwork>
+#include <QTime>
+
+#include "qsoundeffect_pulse_p.h"
+
+#if defined(Q_WS_MAEMO_6)
+#include <pulse/ext-stream-restore.h>
+#endif
+
+#include <unistd.h>
+
+//#define QT_PA_DEBUG
+#ifndef QTM_PULSEAUDIO_DEFAULTBUFFER
+#define QT_PA_STREAM_BUFFER_SIZE_MAX (1024 * 64)  //64KB is a trade-off for balancing control latency and uploading overhead
+#endif
+
+QT_BEGIN_NAMESPACE
+
+namespace
+{
+inline pa_sample_spec audioFormatToSampleSpec(const QAudioFormat &format)
+{
+    pa_sample_spec  spec;
+
+    spec.rate = format.frequency();
+    spec.channels = format.channels();
+
+    if (format.sampleSize() == 8)
+        spec.format = PA_SAMPLE_U8;
+    else if (format.sampleSize() == 16) {
+        switch (format.byteOrder()) {
+            case QAudioFormat::BigEndian: spec.format = PA_SAMPLE_S16BE; break;
+            case QAudioFormat::LittleEndian: spec.format = PA_SAMPLE_S16LE; break;
+        }
+    }
+    else if (format.sampleSize() == 32) {
+        switch (format.byteOrder()) {
+            case QAudioFormat::BigEndian: spec.format = PA_SAMPLE_S32BE; break;
+            case QAudioFormat::LittleEndian: spec.format = PA_SAMPLE_S32LE; break;
+        }
+    }
+
+    return spec;
+}
+
+class PulseDaemon : public QObject
+{
+    Q_OBJECT
+public:
+    PulseDaemon(): m_prepared(false)
+    {
+        prepare();
+    }
+
+    ~PulseDaemon()
+    {
+        if (m_prepared)
+            release();
+    }
+
+    inline void lock()
+    {
+        pa_threaded_mainloop_lock(m_mainLoop);
+    }
+
+    inline void unlock()
+    {
+        pa_threaded_mainloop_unlock(m_mainLoop);
+    }
+
+    inline pa_context *context() const
+    {
+        return m_context;
+    }
+
+    inline pa_cvolume * calcVolume(pa_cvolume *dest, int soundEffectVolume)
+    {
+        pa_volume_t v = m_vol * soundEffectVolume / 100;
+        for (int i = 0; i < dest->channels; ++i)
+            dest->values[i] = v;
+        return dest;
+    }
+
+    void updateStatus(const pa_cvolume& volume)
+    {
+        if (m_vol != pa_cvolume_max(&volume)) {
+            m_vol = pa_cvolume_max(&volume);
+            emit volumeChanged();
+        }
+    }
+
+Q_SIGNALS:
+    void contextReady();
+    void volumeChanged();
+
+private:
+    void prepare()
+    {
+        m_vol = PA_VOLUME_NORM;
+
+        m_mainLoop = pa_threaded_mainloop_new();
+        if (m_mainLoop == 0) {
+            qWarning("PulseAudioService: unable to create pulseaudio mainloop");
+            return;
+        }
+
+        if (pa_threaded_mainloop_start(m_mainLoop) != 0) {
+            qWarning("PulseAudioService: unable to start pulseaudio mainloop");
+            pa_threaded_mainloop_free(m_mainLoop);
+            return;
+        }
+
+        m_mainLoopApi = pa_threaded_mainloop_get_api(m_mainLoop);
+
+        lock();
+        m_context = pa_context_new(m_mainLoopApi, QString(QLatin1String("QtPulseAudio:%1")).arg(::getpid()).toAscii().constData());
+
+        pa_context_set_state_callback(m_context, context_state_callback, this);
+
+        if (m_context == 0) {
+            qWarning("PulseAudioService: Unable to create new pulseaudio context");
+            pa_threaded_mainloop_free(m_mainLoop);
+            return;
+        }
+
+        if (pa_context_connect(m_context, 0, (pa_context_flags_t)0, 0) < 0) {
+            qWarning("PulseAudioService: pa_context_connect() failed");
+            pa_context_unref(m_context);
+            pa_threaded_mainloop_free(m_mainLoop);
+            return;
+        }
+        unlock();
+
+        m_prepared = true;
+    }
+
+    void release()
+    {
+        if (!m_prepared) return;
+        pa_threaded_mainloop_stop(m_mainLoop);
+        pa_threaded_mainloop_free(m_mainLoop);
+        m_prepared = false;
+    }
+
+    static void context_state_callback(pa_context *c, void *userdata)
+    {
+        PulseDaemon *self = reinterpret_cast<PulseDaemon*>(userdata);
+        switch (pa_context_get_state(c)) {
+            case PA_CONTEXT_CONNECTING:
+            case PA_CONTEXT_AUTHORIZING:
+            case PA_CONTEXT_SETTING_NAME:
+                break;
+            case PA_CONTEXT_READY:
+    #if defined(Q_WS_MAEMO_6)
+                pa_ext_stream_restore_read(c, &stream_restore_info_callback, self);
+                pa_ext_stream_restore_set_subscribe_cb(c, &stream_restore_monitor_callback, self);
+                pa_ext_stream_restore_subscribe(c, 1, 0, self);
+    #endif
+                QMetaObject::invokeMethod(self, "contextReady", Qt::QueuedConnection);
+                break;
+            default:
+                break;
+        }
+    }
+
+#if defined(Q_WS_MAEMO_6)
+
+    static void stream_restore_monitor_callback(pa_context *c, void *userdata)
+    {
+        PulseDaemon *self = reinterpret_cast<PulseDaemon*>(userdata);
+        pa_ext_stream_restore_read(c, &stream_restore_info_callback, self);
+    }
+
+    static void stream_restore_info_callback(pa_context *c,
+            const pa_ext_stream_restore_info *info,
+            int eol, void *userdata)
+    {
+        Q_UNUSED(c)
+
+        PulseDaemon *self = reinterpret_cast<PulseDaemon*>(userdata);
+
+        if (!eol) {
+            if (QString(info->name).startsWith(QLatin1String("sink-input-by-media-role:x-maemo"))) {
+#ifdef QT_PA_DEBUG
+                qDebug() << "x-maemo volume =(" << info->volume.values[0] * 100 / PA_VOLUME_NORM << ","
+                         << info->volume.values[1] * 100 / PA_VOLUME_NORM << "), "
+                         << "mute = " << info->mute;
+#endif
+                self->updateStatus(info->volume);
+            }
+        }
+    }
+#endif
+
+    pa_volume_t m_vol;
+
+    bool m_prepared;
+    pa_context *m_context;
+    pa_threaded_mainloop *m_mainLoop;
+    pa_mainloop_api *m_mainLoopApi;
+};
+
+}
+
+Q_GLOBAL_STATIC(PulseDaemon, daemon)
+Q_GLOBAL_STATIC(QSampleCache, sampleCache)
+
+namespace
+{
+class PulseDaemonLocker
+{
+public:
+    PulseDaemonLocker()
+    {
+        daemon()->lock();
+    }
+
+    ~PulseDaemonLocker()
+    {
+        daemon()->unlock();
+    }
+};
+}
+
+class QSoundEffectRef
+{
+public:
+    QSoundEffectRef(QSoundEffectPrivate *target)
+        : m_ref(1)
+        , m_target(target)
+    {
+#ifdef QT_PA_DEBUG
+        qDebug() << "QSoundEffectRef(" << this << ") ctor";
+#endif
+    }
+
+    QSoundEffectRef *getRef()
+    {
+#ifdef QT_PA_DEBUG
+        qDebug() << "QSoundEffectRef(" << this << ") getRef";
+#endif
+        QMutexLocker locker(&m_mutex);
+        m_ref++;
+        return this;
+    }
+
+    void release()
+    {
+#ifdef QT_PA_DEBUG
+        qDebug() << "QSoundEffectRef(" << this << ") Release";
+#endif
+        m_mutex.lock();
+        --m_ref;
+        if (m_ref == 0) {
+            m_mutex.unlock();
+#ifdef QT_PA_DEBUG
+            qDebug() << "QSoundEffectRef(" << this << ") deleted";
+#endif
+            delete this;
+            return;
+        }
+        m_mutex.unlock();
+    }
+
+    QSoundEffectPrivate* soundEffect() const
+    {
+        QMutexLocker locker(&m_mutex);
+        return m_target;
+    }
+
+    void notifyDeleted()
+    {
+#ifdef QT_PA_DEBUG
+        qDebug() << "QSoundEffectRef(" << this << ") notifyDeleted";
+#endif
+        QMutexLocker locker(&m_mutex);
+        m_target = NULL;
+    }
+
+private:
+    int m_ref;
+    mutable QMutex m_mutex;
+    QSoundEffectPrivate *m_target;
+};
+
+QSoundEffectPrivate::QSoundEffectPrivate(QObject* parent):
+    QObject(parent),
+    m_pulseStream(0),
+    m_sinkInputId(-1),
+    m_emptying(false),
+    m_sampleReady(false),
+    m_playing(false),
+    m_status(QSoundEffect::Null),
+    m_muted(false),
+    m_playQueued(false),
+    m_stopping(false),
+    m_volume(100),
+    m_loopCount(1),
+    m_runningCount(0),
+    m_sample(0) ,
+    m_position(0)
+{
+    m_ref = new QSoundEffectRef(this);
+    pa_sample_spec_init(&m_pulseSpec);
+}
+
+void QSoundEffectPrivate::release()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "release";
+#endif
+    m_ref->notifyDeleted();
+    unloadPulseStream();
+    if (m_sample) {
+        m_sample->release();
+        m_sample = 0;
+    }
+
+    this->deleteLater();
+}
+
+QSoundEffectPrivate::~QSoundEffectPrivate()
+{
+    m_ref->release();
+}
+
+QStringList QSoundEffectPrivate::supportedMimeTypes()
+{
+    QStringList supportedTypes;
+    supportedTypes << QLatin1String("audio/x-wav") << QLatin1String("audio/vnd.wave") ;
+    return supportedTypes;
+}
+
+QUrl QSoundEffectPrivate::source() const
+{
+    return m_source;
+}
+
+void QSoundEffectPrivate::setSource(const QUrl &url)
+{
+    Q_ASSERT(m_source != url);
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "setSource =" << url;
+#endif
+    stop();
+    if (m_sample) {
+        if (!m_sampleReady) {
+            disconnect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
+            disconnect(m_sample, SIGNAL(ready()), this, SLOT(sampleReady()));
+        }
+        m_sample->release();
+        m_sample = 0;
+    }
+
+    m_source = url;
+    m_sampleReady = false;
+
+    PulseDaemonLocker locker;
+    setLoopsRemaining(0);
+    if (m_pulseStream && !pa_stream_is_corked(m_pulseStream)) {
+        pa_stream_set_write_callback(m_pulseStream, 0, 0);
+        pa_stream_set_underflow_callback(m_pulseStream, 0, 0);
+        pa_operation_unref(pa_stream_cork(m_pulseStream, 1, 0, 0));
+    }
+    setPlaying(false);
+
+    if (url.isEmpty()) {
+        setStatus(QSoundEffect::Null);
+        return;
+    }
+
+    setStatus(QSoundEffect::Loading);
+    m_sample = sampleCache()->requestSample(url);
+    connect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
+    connect(m_sample, SIGNAL(ready()), this, SLOT(sampleReady()));
+    switch(m_sample->state()) {
+    case QSample::Ready:
+        sampleReady();
+        break;
+    case QSample::Error:
+        decoderError();
+        break;
+    default:
+        break;
+    }
+}
+
+int QSoundEffectPrivate::loopCount() const
+{
+    return m_loopCount;
+}
+
+int QSoundEffectPrivate::loopsRemaining() const
+{
+    return m_runningCount;
+}
+
+void QSoundEffectPrivate::setLoopCount(int loopCount)
+{
+    if (loopCount == 0)
+        loopCount = 1;
+    m_loopCount = loopCount;
+}
+
+int QSoundEffectPrivate::volume() const
+{
+    return m_volume;
+}
+
+void QSoundEffectPrivate::setVolume(int volume)
+{
+    m_volume = volume;
+    emit volumeChanged();
+    updateVolume();
+}
+
+void QSoundEffectPrivate::updateVolume()
+{
+    if (m_sinkInputId < 0)
+        return;
+    PulseDaemonLocker locker;
+    pa_cvolume volume;
+    volume.channels = m_pulseSpec.channels;
+    pa_operation_unref(pa_context_set_sink_input_volume(daemon()->context(), m_sinkInputId, daemon()->calcVolume(&volume, m_volume), setvolume_callback, m_ref->getRef()));
+    Q_ASSERT(pa_cvolume_valid(&volume));
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "updateVolume =" << pa_cvolume_max(&volume);
+#endif
+}
+
+bool QSoundEffectPrivate::isMuted() const
+{
+    return m_muted;
+}
+
+void QSoundEffectPrivate::setMuted(bool muted)
+{
+    m_muted = muted;
+    emit mutedChanged();
+    updateMuted();
+}
+
+void QSoundEffectPrivate::updateMuted()
+{
+    if (m_sinkInputId < 0)
+        return;
+    PulseDaemonLocker locker;
+    pa_operation_unref(pa_context_set_sink_input_mute(daemon()->context(), m_sinkInputId, m_muted, setmuted_callback, m_ref->getRef()));
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "updateMuted = " << m_muted;
+#endif
+}
+
+bool QSoundEffectPrivate::isLoaded() const
+{
+    return m_status == QSoundEffect::Ready;
+}
+
+bool QSoundEffectPrivate::isPlaying() const
+{
+    return m_playing;
+}
+
+QSoundEffect::Status QSoundEffectPrivate::status() const
+{
+    return m_status;
+}
+
+void QSoundEffectPrivate::setPlaying(bool playing)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "setPlaying(" << playing << ")";
+#endif
+    if (m_playing == playing)
+        return;
+    if (!playing)
+        m_playQueued = false;
+    m_playing = playing;
+    emit playingChanged();
+}
+
+void QSoundEffectPrivate::setStatus(QSoundEffect::Status status)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "setStatus" << status;
+#endif
+    if (m_status == status)
+        return;
+    bool oldLoaded = isLoaded();
+    m_status = status;
+    emit statusChanged();
+    if (oldLoaded != isLoaded())
+        emit loadedChanged();
+}
+
+void QSoundEffectPrivate::setLoopsRemaining(int loopsRemaining)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "setLoopsRemaining " << loopsRemaining;
+#endif
+    if (m_runningCount == loopsRemaining)
+        return;
+    m_runningCount = loopsRemaining;
+    emit loopsRemainingChanged();
+}
+
+void QSoundEffectPrivate::play()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "play";
+#endif
+    if (m_status == QSoundEffect::Null || m_status == QSoundEffect::Error || m_playQueued)
+        return;
+
+    PulseDaemonLocker locker;
+    if (!m_sampleReady || !m_pulseStream || m_stopping || m_emptying) {
+#ifdef QT_PA_DEBUG
+        qDebug() << this << "play deferred";
+#endif
+        m_playQueued = true;
+    } else {
+        if (m_playing) { //restart playing from the beginning
+#ifdef QT_PA_DEBUG
+           qDebug() << this << "restart playing";
+#endif
+            setLoopsRemaining(0);
+            m_playQueued = true;
+            Q_ASSERT(m_pulseStream);
+            emptyStream();
+            return;
+        }
+        m_runningCount = m_loopCount;
+        playSample();
+    }
+
+    setPlaying(true);
+}
+
+void QSoundEffectPrivate::emptyStream()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "emptyStream";
+#endif
+    m_emptying = true;
+    pa_stream_set_write_callback(m_pulseStream, 0, 0);
+    pa_stream_set_underflow_callback(m_pulseStream, 0, 0);
+    pa_operation_unref(pa_stream_flush(m_pulseStream, stream_flush_callback, m_ref->getRef()));
+}
+
+void QSoundEffectPrivate::emptyComplete()
+{
+    PulseDaemonLocker locker;
+    m_emptying = false;
+    pa_operation_unref(pa_stream_cork(m_pulseStream, 1, stream_cork_callback, m_ref->getRef()));
+}
+
+void QSoundEffectPrivate::sampleReady()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "sampleReady";
+#endif
+    disconnect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
+    disconnect(m_sample, SIGNAL(ready()), this, SLOT(sampleReady()));
+    pa_sample_spec newFormatSpec = audioFormatToSampleSpec(m_sample->format());
+
+    if (m_pulseStream && (memcmp(&m_pulseSpec, &newFormatSpec, sizeof(m_pulseSpec)) != 0)) {
+        unloadPulseStream();
+    }
+    m_pulseSpec = newFormatSpec;
+
+    m_sampleReady = true;
+    m_position = 0;
+
+    if (m_name.isNull())
+        m_name = QString(QLatin1String("QtPulseSample-%1-%2")).arg(::getpid()).arg(quintptr(this)).toUtf8();
+
+    PulseDaemonLocker locker;
+    if (m_pulseStream) {
+#ifdef QT_PA_DEBUG
+        qDebug() << this << "reuse existing pulsestream";
+#endif
+#ifdef QTM_PULSEAUDIO_DEFAULTBUFFER
+        const pa_buffer_attr *bufferAttr = pa_stream_get_buffer_attr(m_pulseStream);
+        if (bufferAttr->prebuf > uint32_t(m_sample->data().size())) {
+            pa_buffer_attr newBufferAttr;
+            newBufferAttr = *bufferAttr;
+            newBufferAttr.prebuf = m_sample->data().size();
+            pa_operation_unref(pa_stream_set_buffer_attr(m_pulseStream, &newBufferAttr, stream_adjust_prebuffer_callback, m_ref->getRef()));
+        } else {
+            streamReady();
+        }
+#else
+        const pa_buffer_attr *bufferAttr = pa_stream_get_buffer_attr(m_pulseStream);
+        if (bufferAttr->tlength < m_sample->data().size() && bufferAttr->tlength < QT_PA_STREAM_BUFFER_SIZE_MAX) {
+            pa_buffer_attr newBufferAttr;
+            newBufferAttr.maxlength = -1;
+            newBufferAttr.tlength = qMin(m_sample->data().size(), QT_PA_STREAM_BUFFER_SIZE_MAX);
+            newBufferAttr.minreq = bufferAttr->tlength / 2;
+            newBufferAttr.prebuf = -1;
+            newBufferAttr.fragsize = -1;
+            pa_operation_unref(pa_stream_set_buffer_attr(m_pulseStream, &newBufferAttr, stream_reset_buffer_callback, m_ref->getRef()));
+        } else if (bufferAttr->prebuf > uint32_t(m_sample->data().size())) {
+            pa_buffer_attr newBufferAttr;
+            newBufferAttr = *bufferAttr;
+            newBufferAttr.prebuf = m_sample->data().size();
+            pa_operation_unref(pa_stream_set_buffer_attr(m_pulseStream, &newBufferAttr, stream_adjust_prebuffer_callback, m_ref->getRef()));
+        } else {
+            streamReady();
+        }
+#endif
+    } else {
+        if (pa_context_get_state(daemon()->context()) != PA_CONTEXT_READY) {
+            connect(daemon(), SIGNAL(contextReady()), SLOT(contextReady()));
+            return;
+        }
+        createPulseStream();
+    }
+}
+
+void QSoundEffectPrivate::decoderError()
+{
+    qWarning("QSoundEffect(pulseaudio): Error decoding source");
+    disconnect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
+    bool playingDirty = false;
+    if (m_playing) {
+        m_playing = false;
+        playingDirty = true;
+    }
+    setStatus(QSoundEffect::Error);
+    if (playingDirty)
+        emit playingChanged();
+}
+
+void QSoundEffectPrivate::unloadPulseStream()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "unloadPulseStream";
+#endif
+    m_sinkInputId = -1;
+    PulseDaemonLocker locker;
+    if (m_pulseStream) {
+        pa_stream_set_state_callback(m_pulseStream, 0, 0);
+        pa_stream_set_write_callback(m_pulseStream, 0, 0);
+        pa_stream_set_underflow_callback(m_pulseStream, 0, 0);
+        pa_stream_disconnect(m_pulseStream);
+        pa_stream_unref(m_pulseStream);
+        disconnect(daemon(), SIGNAL(volumeChanged()), this, SLOT(updateVolume()));
+        m_pulseStream = 0;
+    }
+}
+
+void QSoundEffectPrivate::prepare()
+{
+    if (!m_pulseStream || !m_sampleReady)
+        return;
+    PulseDaemonLocker locker;
+    pa_stream_set_write_callback(m_pulseStream, stream_write_callback, this);
+    pa_stream_set_underflow_callback(m_pulseStream, stream_underrun_callback, this);
+    m_stopping = false;
+    size_t writeBytes = size_t(qMin(m_pulseBufferSize, m_sample->data().size()));
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "prepare(): writable size =" << pa_stream_writable_size(m_pulseStream)
+             << "actual writeBytes =" << writeBytes
+             << "m_playQueued =" << m_playQueued;
+#endif
+    m_position = int(writeBytes);
+    if (pa_stream_write(m_pulseStream, reinterpret_cast<void *>(const_cast<char*>(m_sample->data().data())), writeBytes,
+                        stream_write_done_callback, 0, PA_SEEK_RELATIVE) != 0) {
+        qWarning("QSoundEffect(pulseaudio): pa_stream_write, error = %s", pa_strerror(pa_context_errno(daemon()->context())));
+    }
+    if (m_playQueued) {
+        m_playQueued = false;
+        setLoopsRemaining(m_loopCount);
+        playSample();
+    }
+}
+
+void QSoundEffectPrivate::uploadSample()
+{
+    if (m_runningCount == 0) {
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "uploadSample: return due to 0 m_runningCount";
+#endif
+        return;
+    }
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "uploadSample: m_runningCount =" << m_runningCount;
+#endif
+    if (m_position == m_sample->data().size()) {
+        m_position = 0;
+        if (m_runningCount > 0)
+            setLoopsRemaining(m_runningCount - 1);
+        if (m_runningCount == 0) {
+            return;
+        }
+    }
+
+    int writtenBytes = 0;
+    int writableSize = int(pa_stream_writable_size(m_pulseStream));
+    int firstPartLength = qMin(m_sample->data().size() - m_position, writableSize);
+    if (pa_stream_write(m_pulseStream, reinterpret_cast<void *>(const_cast<char*>(m_sample->data().data()) + m_position),
+                        firstPartLength, stream_write_done_callback, 0, PA_SEEK_RELATIVE) != 0) {
+        qWarning("QSoundEffect(pulseaudio): pa_stream_write, error = %s", pa_strerror(pa_context_errno(daemon()->context())));
+    }
+    writtenBytes = firstPartLength;
+    m_position += firstPartLength;
+    if (m_position == m_sample->data().size()) {
+        m_position = 0;
+        if (m_runningCount > 0)
+            setLoopsRemaining(m_runningCount - 1);
+        if (m_runningCount != 0 && firstPartLength < writableSize)
+        {
+            while (writtenBytes < writableSize) {
+                int writeSize = qMin(writableSize - writtenBytes, m_sample->data().size());
+                if (pa_stream_write(m_pulseStream, reinterpret_cast<void *>(const_cast<char*>(m_sample->data().data())),
+                                    writeSize, stream_write_done_callback, 0, PA_SEEK_RELATIVE) != 0) {
+                    qWarning("QSoundEffect(pulseaudio): pa_stream_write, error = %s", pa_strerror(pa_context_errno(daemon()->context())));
+                }
+                writtenBytes += writeSize;
+                if (writeSize < m_sample->data().size()) {
+                    m_position = writeSize;
+                    break;
+                }
+                if (m_runningCount > 0)
+                    setLoopsRemaining(m_runningCount - 1);
+                if (m_runningCount == 0)
+                    break;
+            }
+        }
+    }
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "uploadSample: use direct write, writeable size =" << writableSize
+             << "actual writtenBytes =" << writtenBytes;
+#endif
+}
+
+void QSoundEffectPrivate::playSample()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "playSample";
+#endif
+    Q_ASSERT(m_pulseStream);
+    pa_operation_unref(pa_stream_cork(m_pulseStream, 0, 0, 0));
+}
+
+void QSoundEffectPrivate::stop()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "stop";
+#endif
+    if (!m_playing)
+        return;
+    setPlaying(false);
+    PulseDaemonLocker locker;
+    m_stopping = true;
+    if (m_pulseStream)
+        emptyStream();
+    setLoopsRemaining(0);
+    m_position = 0;
+    m_playQueued = false;
+}
+
+void QSoundEffectPrivate::underRun()
+{
+    stop();
+}
+
+void QSoundEffectPrivate::streamReady()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "streamReady";
+#endif
+    PulseDaemonLocker locker;
+    m_sinkInputId =  pa_stream_get_index(m_pulseStream);
+    updateMuted();
+    updateVolume();
+#ifdef QT_PA_DEBUG
+    const pa_buffer_attr *realBufAttr = pa_stream_get_buffer_attr(m_pulseStream);
+    qDebug() << this << "m_sinkInputId =" << m_sinkInputId
+             << "tlength =" << realBufAttr->tlength << "maxlength =" << realBufAttr->maxlength
+             << "minreq = " << realBufAttr->minreq << "prebuf =" << realBufAttr->prebuf;
+#endif
+    prepare();
+    setStatus(QSoundEffect::Ready);
+}
+
+void QSoundEffectPrivate::createPulseStream()
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << this << "createPulseStream";
+#endif
+
+    pa_proplist *propList = pa_proplist_new();
+    pa_proplist_sets(propList, PA_PROP_MEDIA_ROLE, "soundeffect");
+    pa_stream *stream = pa_stream_new_with_proplist(daemon()->context(), m_name.constData(), &m_pulseSpec, 0, propList);
+    pa_proplist_free(propList);
+
+    connect(daemon(), SIGNAL(volumeChanged()), this, SLOT(updateVolume()));
+
+    if (stream == 0) {
+        qWarning("QSoundEffect(pulseaudio): Failed to create stream");
+        m_pulseStream = 0;
+        setStatus(QSoundEffect::Error);
+        setPlaying(false);
+        return;
+    }
+    else {
+        pa_stream_set_state_callback(stream, stream_state_callback, this);
+        pa_stream_set_write_callback(stream, stream_write_callback, this);
+        pa_stream_set_underflow_callback(stream, stream_underrun_callback, this);
+    }
+    m_pulseStream = stream;
+
+#ifndef QTM_PULSEAUDIO_DEFAULTBUFFER
+    pa_buffer_attr bufferAttr;
+    bufferAttr.tlength = qMin(m_sample->data().size(), QT_PA_STREAM_BUFFER_SIZE_MAX);
+    bufferAttr.maxlength = -1;
+    bufferAttr.minreq = bufferAttr.tlength / 2;
+    bufferAttr.prebuf = -1;
+    bufferAttr.fragsize = -1;
+    if (pa_stream_connect_playback(m_pulseStream, 0, &bufferAttr,
+#else
+    if (pa_stream_connect_playback(m_pulseStream, 0, 0,
+#endif
+                                   m_muted ? pa_stream_flags_t(PA_STREAM_START_MUTED | PA_STREAM_START_CORKED)
+                                           : pa_stream_flags_t(PA_STREAM_START_UNMUTED | PA_STREAM_START_CORKED),
+                                   0, 0) < 0) {
+        qWarning("QSoundEffect(pulseaudio): Failed to connect stream, error = %s",
+                 pa_strerror(pa_context_errno(daemon()->context())));
+    }
+}
+
+void QSoundEffectPrivate::contextReady()
+{
+    disconnect(daemon(), SIGNAL(contextReady()), this, SLOT(contextReady()));
+    PulseDaemonLocker locker;
+    createPulseStream();
+}
+
+void QSoundEffectPrivate::stream_write_callback(pa_stream *s, size_t length, void *userdata)
+{
+    Q_UNUSED(length);
+    Q_UNUSED(s);
+
+    QSoundEffectPrivate *self = reinterpret_cast<QSoundEffectPrivate*>(userdata);
+#ifdef QT_PA_DEBUG
+    qDebug() << self << "stream_write_callback";
+#endif
+    self->uploadSample();
+}
+
+void QSoundEffectPrivate::stream_state_callback(pa_stream *s, void *userdata)
+{
+    QSoundEffectPrivate *self = reinterpret_cast<QSoundEffectPrivate*>(userdata);
+    switch (pa_stream_get_state(s)) {
+        case PA_STREAM_READY:
+        {
+#ifdef QT_PA_DEBUG
+            qDebug() << self << "pulse stream ready";
+#endif
+            const pa_buffer_attr *bufferAttr = pa_stream_get_buffer_attr(self->m_pulseStream);
+            self->m_pulseBufferSize = bufferAttr->tlength;
+            if (bufferAttr->prebuf > uint32_t(self->m_sample->data().size())) {
+                pa_buffer_attr newBufferAttr;
+                newBufferAttr = *bufferAttr;
+                newBufferAttr.prebuf = self->m_sample->data().size();
+                pa_stream_set_buffer_attr(self->m_pulseStream, &newBufferAttr, stream_adjust_prebuffer_callback, self->m_ref->getRef());
+            } else {
+                QMetaObject::invokeMethod(self, "streamReady", Qt::QueuedConnection);
+            }
+            break;
+        }
+        case PA_STREAM_CREATING:
+#ifdef QT_PA_DEBUG
+            qDebug() << self << "pulse stream creating";
+#endif
+            break;
+        case PA_STREAM_TERMINATED:
+#ifdef QT_PA_DEBUG
+            qDebug() << self << "pulse stream terminated";
+#endif
+            break;
+
+        case PA_STREAM_FAILED:
+        default:
+            qWarning("QSoundEffect(pulseaudio): Error in pulse audio stream");
+            break;
+    }
+}
+
+void QSoundEffectPrivate::stream_reset_buffer_callback(pa_stream *s, int success, void *userdata)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << "stream_reset_buffer_callback";
+#endif
+    Q_UNUSED(s);
+    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
+    QSoundEffectPrivate *self = ref->soundEffect();
+    ref->release();
+    if (!self)
+        return;
+
+    if (!success)
+        qWarning("QSoundEffect(pulseaudio): faild to reset buffer attribute");
+#ifdef QT_PA_DEBUG
+    qDebug() << self << "stream_reset_buffer_callback";
+#endif
+    const pa_buffer_attr *bufferAttr = pa_stream_get_buffer_attr(self->m_pulseStream);
+    self->m_pulseBufferSize = bufferAttr->tlength;
+    if (bufferAttr->prebuf > uint32_t(self->m_sample->data().size())) {
+        pa_buffer_attr newBufferAttr;
+        newBufferAttr = *bufferAttr;
+        newBufferAttr.prebuf = self->m_sample->data().size();
+        pa_stream_set_buffer_attr(self->m_pulseStream, &newBufferAttr, stream_adjust_prebuffer_callback, userdata);
+    } else {
+        QMetaObject::invokeMethod(self, "streamReady", Qt::QueuedConnection);
+    }
+}
+
+void QSoundEffectPrivate::stream_adjust_prebuffer_callback(pa_stream *s, int success, void *userdata)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << "stream_adjust_prebuffer_callback";
+#endif
+    Q_UNUSED(s);
+    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
+    QSoundEffectPrivate *self = ref->soundEffect();
+    ref->release();
+    if (!self)
+        return;
+
+    if (!success)
+        qWarning("QSoundEffect(pulseaudio): faild to adjust pre-buffer attribute");
+#ifdef QT_PA_DEBUG
+    qDebug() << self << "stream_adjust_prebuffer_callback";
+#endif
+    QMetaObject::invokeMethod(self, "streamReady", Qt::QueuedConnection);
+}
+
+void QSoundEffectPrivate::setvolume_callback(pa_context *c, int success, void *userdata)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << "setvolume_callback";
+#endif
+    Q_UNUSED(c);
+    Q_UNUSED(userdata);
+    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
+    QSoundEffectPrivate *self = ref->soundEffect();
+    ref->release();
+    if (!self)
+        return;
+#ifdef QT_PA_DEBUG
+    qDebug() << self << "setvolume_callback";
+#endif
+    if (!success) {
+        qWarning("QSoundEffect(pulseaudio): faild to set volume");
+    }
+}
+
+void QSoundEffectPrivate::setmuted_callback(pa_context *c, int success, void *userdata)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << "setmuted_callback";
+#endif
+    Q_UNUSED(c);
+    Q_UNUSED(userdata);
+    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
+    QSoundEffectPrivate *self = ref->soundEffect();
+    ref->release();
+    if (!self)
+        return;
+#ifdef QT_PA_DEBUG
+    qDebug() << self << "setmuted_callback";
+#endif
+    if (!success) {
+        qWarning("QSoundEffect(pulseaudio): faild to set muted");
+    }
+}
+
+void QSoundEffectPrivate::stream_underrun_callback(pa_stream *s, void *userdata)
+{
+    Q_UNUSED(s);
+    QSoundEffectPrivate *self = reinterpret_cast<QSoundEffectPrivate*>(userdata);
+#ifdef QT_PA_DEBUG
+    qDebug() << self << "stream_underrun_callback";
+#endif
+    if (self->m_runningCount == 0 && !self->m_playQueued)
+        QMetaObject::invokeMethod(self, "underRun", Qt::QueuedConnection);
+#ifdef QT_PA_DEBUG
+    else
+        qDebug() << "underun corked =" << pa_stream_is_corked(s);
+#endif
+}
+
+void QSoundEffectPrivate::stream_cork_callback(pa_stream *s, int success, void *userdata)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << "stream_cork_callback";
+#endif
+    Q_UNUSED(s);
+    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
+    QSoundEffectPrivate *self = ref->soundEffect();
+    ref->release();
+    if (!self)
+        return;
+
+    if (!success)
+        qWarning("QSoundEffect(pulseaudio): faild to stop");
+#ifdef QT_PA_DEBUG
+    qDebug() << self << "stream_cork_callback";
+#endif
+    QMetaObject::invokeMethod(self, "prepare", Qt::QueuedConnection);
+}
+
+void QSoundEffectPrivate::stream_flush_callback(pa_stream *s, int success, void *userdata)
+{
+#ifdef QT_PA_DEBUG
+    qDebug() << "stream_flush_callback";
+#endif
+    Q_UNUSED(s);
+    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
+    QSoundEffectPrivate *self = ref->soundEffect();
+    ref->release();
+    if (!self)
+        return;
+
+    if (!success)
+        qWarning("QSoundEffect(pulseaudio): faild to drain");
+#ifdef QT_PA_DEBUG
+    qDebug() << self << "stream_flush_callback";
+#endif
+    QMetaObject::invokeMethod(self, "emptyComplete", Qt::QueuedConnection);
+}
+
+void QSoundEffectPrivate::stream_write_done_callback(void *p)
+{
+    Q_UNUSED(p);
+#ifdef QT_PA_DEBUG
+    qDebug() << "stream_write_done_callback";
+#endif
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qsoundeffect_pulse_p.cpp"
+#include "qsoundeffect_pulse_p.moc"
diff --git a/src/multimedia/audio/qsoundeffect_pulse_p.h b/src/multimedia/audio/qsoundeffect_pulse_p.h
new file mode 100644
index 0000000..35b586e
--- /dev/null
+++ b/src/multimedia/audio/qsoundeffect_pulse_p.h
@@ -0,0 +1,170 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSOUNDEFFECT_PULSE_H
+#define QSOUNDEFFECT_PULSE_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+
+#include "qsoundeffect.h"
+
+#include <QtCore/qobject.h>
+#include <QtCore/qdatetime.h>
+#include <qmediaplayer.h>
+#include <pulse/pulseaudio.h>
+#include "qsamplecache_p.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QSoundEffectRef;
+
+class QSoundEffectPrivate : public QObject
+{
+    Q_OBJECT
+public:
+    explicit QSoundEffectPrivate(QObject* parent);
+    ~QSoundEffectPrivate();
+
+    static QStringList supportedMimeTypes();
+
+    QUrl source() const;
+    void setSource(const QUrl &url);
+    int loopCount() const;
+    int loopsRemaining() const;
+    void setLoopCount(int loopCount);
+    int volume() const;
+    void setVolume(int volume);
+    bool isMuted() const;
+    void setMuted(bool muted);
+    bool isLoaded() const;
+    bool isPlaying() const;
+    QSoundEffect::Status status() const;
+
+    void release();
+
+public Q_SLOTS:
+    void play();
+    void stop();
+
+Q_SIGNALS:
+    void loopsRemainingChanged();
+    void volumeChanged();
+    void mutedChanged();
+    void loadedChanged();
+    void playingChanged();
+    void statusChanged();
+
+private Q_SLOTS:
+    void decoderError();
+    void sampleReady();
+    void uploadSample();
+    void contextReady();
+    void underRun();
+    void prepare();
+    void streamReady();
+    void emptyComplete();
+    void updateVolume();
+    void updateMuted();
+
+private:
+    void playSample();
+
+    void emptyStream();
+    void createPulseStream();
+    void unloadPulseStream();
+
+    void setPlaying(bool playing);
+    void setStatus(QSoundEffect::Status status);
+    void setLoopsRemaining(int loopsRemaining);
+
+    static void stream_write_callback(pa_stream *s, size_t length, void *userdata);
+    static void stream_state_callback(pa_stream *s, void *userdata);
+    static void stream_underrun_callback(pa_stream *s, void *userdata);
+    static void stream_cork_callback(pa_stream *s, int success, void *userdata);
+    static void stream_flush_callback(pa_stream *s, int success, void *userdata);
+    static void stream_write_done_callback(void *p);
+    static void stream_adjust_prebuffer_callback(pa_stream *s, int success, void *userdata);
+    static void stream_reset_buffer_callback(pa_stream *s, int success, void *userdata);
+    static void setvolume_callback(pa_context *c, int success, void *userdata);
+    static void setmuted_callback(pa_context *c, int success, void *userdata);
+
+    pa_stream *m_pulseStream;
+    int        m_sinkInputId;
+    pa_sample_spec m_pulseSpec;
+    int        m_pulseBufferSize;
+
+    bool    m_emptying;
+    bool    m_sampleReady;
+    bool    m_playing;
+    QSoundEffect::Status  m_status;
+    bool    m_muted;
+    bool    m_playQueued;
+    bool    m_stopping;
+    int     m_volume;
+    int     m_loopCount;
+    int     m_runningCount;
+    QUrl    m_source;
+    QByteArray m_name;
+
+    QSample *m_sample;
+    int m_position;
+    QSoundEffectRef *m_ref;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QSOUNDEFFECT_PULSE_H
diff --git a/src/multimedia/audio/qsoundeffect_qmedia_p.cpp b/src/multimedia/audio/qsoundeffect_qmedia_p.cpp
new file mode 100644
index 0000000..511aa06
--- /dev/null
+++ b/src/multimedia/audio/qsoundeffect_qmedia_p.cpp
@@ -0,0 +1,254 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// INTERNAL USE ONLY: Do NOT use for any other purpose.
+//
+
+#include "qsoundeffect_qmedia_p.h"
+
+#include <QtCore/qcoreapplication.h>
+
+#include "qmediacontent.h"
+#include "qmediaplayer.h"
+
+
+QT_BEGIN_NAMESPACE
+
+QSoundEffectPrivate::QSoundEffectPrivate(QObject* parent):
+    QObject(parent),
+    m_loopCount(1),
+    m_runningCount(0),
+    m_playing(false),
+    m_status(QSoundEffect::Null),
+    m_player(0)
+{
+    m_player = new QMediaPlayer(this, QMediaPlayer::LowLatency);
+    connect(m_player, SIGNAL(stateChanged(QMediaPlayer::State)), SLOT(stateChanged(QMediaPlayer::State)));
+    connect(m_player, SIGNAL(mediaStatusChanged(QMediaPlayer::MediaStatus)), SLOT(mediaStatusChanged(QMediaPlayer::MediaStatus)));
+    connect(m_player, SIGNAL(error(QMediaPlayer::Error)), SLOT(error(QMediaPlayer::Error)));
+    connect(m_player, SIGNAL(mutedChanged(bool)), SIGNAL(mutedChanged()));
+    connect(m_player, SIGNAL(volumeChanged(int)), SIGNAL(volumeChanged()));
+}
+
+void QSoundEffectPrivate::release()
+{
+    this->deleteLater();
+}
+
+QSoundEffectPrivate::~QSoundEffectPrivate()
+{
+}
+
+QStringList QSoundEffectPrivate::supportedMimeTypes()
+{
+    return QMediaPlayer::supportedMimeTypes();
+}
+
+QUrl QSoundEffectPrivate::source() const
+{
+    return m_player->media().canonicalUrl();
+}
+
+void QSoundEffectPrivate::setSource(const QUrl &url)
+{
+    m_player->setMedia(url);
+}
+
+int QSoundEffectPrivate::loopCount() const
+{
+    return m_loopCount;
+}
+
+int QSoundEffectPrivate::loopsRemaining() const
+{
+    return m_runningCount;
+}
+
+void QSoundEffectPrivate::setLoopCount(int loopCount)
+{
+    m_loopCount = loopCount;
+}
+
+int QSoundEffectPrivate::volume() const
+{
+    return m_player->volume();
+}
+
+void QSoundEffectPrivate::setVolume(int volume)
+{
+    m_player->setVolume(volume);
+}
+
+bool QSoundEffectPrivate::isMuted() const
+{
+    return m_player->isMuted();
+}
+
+void QSoundEffectPrivate::setMuted(bool muted)
+{
+    m_player->setMuted(muted);
+}
+
+bool QSoundEffectPrivate::isLoaded() const
+{
+    return m_status == QSoundEffect::Ready;
+}
+
+bool QSoundEffectPrivate::isPlaying() const
+{
+    return m_playing;
+}
+
+QSoundEffect::Status QSoundEffectPrivate::status() const
+{
+    return m_status;
+}
+
+void QSoundEffectPrivate::play()
+{
+    if (m_status == QSoundEffect::Null || m_status == QSoundEffect::Error)
+        return;
+    if (m_loopCount < 0) {
+        setLoopsRemaining(-1);
+    }
+    else {
+        if (m_runningCount < 0)
+            setLoopsRemaining(0);
+        setLoopsRemaining(m_runningCount + m_loopCount);
+    }
+    m_player->play();
+}
+
+void QSoundEffectPrivate::stop()
+{
+    setLoopsRemaining(0);
+    m_player->stop();
+}
+
+void QSoundEffectPrivate::stateChanged(QMediaPlayer::State state)
+{
+    if (state == QMediaPlayer::StoppedState) {
+        if (m_runningCount < 0) {
+            m_player->play();
+        } else if (m_runningCount == 0) {
+            setPlaying(false);
+            return;
+        } else {
+            setLoopsRemaining(m_runningCount - 1);
+            if (m_runningCount > 0) {
+                m_player->play();
+            } else {
+             setPlaying(false);
+            }
+        }
+    } else {
+        setPlaying(true);
+    }
+}
+
+void QSoundEffectPrivate::mediaStatusChanged(QMediaPlayer::MediaStatus status)
+{
+    switch(status) {
+    case QMediaPlayer::LoadingMedia:
+        setStatus(QSoundEffect::Loading);
+        break;
+    case QMediaPlayer::NoMedia:
+        setStatus(QSoundEffect::Null);
+        break;
+    case QMediaPlayer::InvalidMedia:
+        setStatus(QSoundEffect::Error);
+        break;
+    default:
+        setStatus(QSoundEffect::Ready);
+        break;
+    }
+}
+
+void QSoundEffectPrivate::error(QMediaPlayer::Error err)
+{
+    bool playingDirty = false;
+    if (m_playing) {
+        m_playing = false;
+        playingDirty = true;
+    }
+    setStatus(QSoundEffect::Error);
+    if (playingDirty)
+        emit playingChanged();
+}
+
+void QSoundEffectPrivate::setStatus(QSoundEffect::Status status)
+{
+    if (m_status == status)
+        return;
+    bool oldLoaded = isLoaded();
+    m_status = status;
+    emit statusChanged();
+    if (oldLoaded != isLoaded())
+        emit loadedChanged();
+}
+
+void QSoundEffectPrivate::setPlaying(bool playing)
+{
+    if (m_playing == playing)
+        return;
+    m_playing = playing;
+    emit playingChanged();
+}
+
+void QSoundEffectPrivate::setLoopsRemaining(int loopsRemaining)
+{
+    if (m_runningCount == loopsRemaining)
+        return;
+    m_runningCount = loopsRemaining;
+    emit loopsRemainingChanged();
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qsoundeffect_qmedia_p.cpp"
diff --git a/src/multimedia/audio/qsoundeffect_qmedia_p.h b/src/multimedia/audio/qsoundeffect_qmedia_p.h
new file mode 100644
index 0000000..bb91e50
--- /dev/null
+++ b/src/multimedia/audio/qsoundeffect_qmedia_p.h
@@ -0,0 +1,127 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSOUNDEFFECT_QMEDIA_H
+#define QSOUNDEFFECT_QMEDIA_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qobject.h>
+#include <QtCore/qurl.h>
+#include "qmediaplayer.h"
+#include "qsoundeffect.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+
+class QSoundEffectPrivate : public QObject
+{
+    Q_OBJECT
+public:
+
+    explicit QSoundEffectPrivate(QObject* parent);
+    ~QSoundEffectPrivate();
+
+    static QStringList supportedMimeTypes();
+
+    QUrl source() const;
+    void setSource(const QUrl &url);
+    int loopCount() const;
+    int loopsRemaining() const;
+    void setLoopCount(int loopCount);
+    int volume() const;
+    void setVolume(int volume);
+    bool isMuted() const;
+    void setMuted(bool muted);
+    bool isLoaded() const;
+    bool isPlaying() const;
+    QSoundEffect::Status status() const;
+
+    void release();
+
+public Q_SLOTS:
+    void play();
+    void stop();
+
+Q_SIGNALS:
+    void loopsRemainingChanged();
+    void volumeChanged();
+    void mutedChanged();
+    void loadedChanged();
+    void playingChanged();
+    void statusChanged();
+
+private Q_SLOTS:
+    void stateChanged(QMediaPlayer::State);
+    void mediaStatusChanged(QMediaPlayer::MediaStatus);
+    void error(QMediaPlayer::Error);
+
+private:
+    void setStatus(QSoundEffect::Status status);
+    void setPlaying(bool playing);
+    void setLoopsRemaining(int loopsRemaining);
+
+    int            m_loopCount;
+    int            m_runningCount;
+    bool           m_playing;
+    QSoundEffect::Status  m_status;
+    QMediaPlayer  *m_player;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QSOUNDEFFECT_QMEDIA_H
diff --git a/src/multimedia/audio/qwavedecoder_p.cpp b/src/multimedia/audio/qwavedecoder_p.cpp
new file mode 100644
index 0000000..eb65a3a
--- /dev/null
+++ b/src/multimedia/audio/qwavedecoder_p.cpp
@@ -0,0 +1,307 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qwavedecoder_p.h"
+
+#include <QtCore/qtimer.h>
+#include <QtCore/qendian.h>
+
+QT_BEGIN_NAMESPACE
+
+QWaveDecoder::QWaveDecoder(QIODevice *s, QObject *parent):
+    QIODevice(parent),
+    haveFormat(false),
+    dataSize(0),
+    source(s),
+    state(QWaveDecoder::InitialState),
+    junkToSkip(0),
+    bigEndian(false)
+{
+    open(QIODevice::ReadOnly | QIODevice::Unbuffered);
+
+    if (enoughDataAvailable())
+        QTimer::singleShot(0, this, SLOT(handleData()));
+    else
+        connect(source, SIGNAL(readyRead()), SLOT(handleData()));
+}
+
+QWaveDecoder::~QWaveDecoder()
+{
+}
+
+QAudioFormat QWaveDecoder::audioFormat() const
+{
+    return format;
+}
+
+int QWaveDecoder::duration() const
+{
+    return size() * 1000 / (format.sampleSize() / 8) / format.channels() / format.frequency();
+}
+
+qint64 QWaveDecoder::size() const
+{
+    return haveFormat ? dataSize : 0;
+}
+
+bool QWaveDecoder::isSequential() const
+{
+    return source->isSequential();
+}
+
+qint64 QWaveDecoder::bytesAvailable() const
+{
+    return haveFormat ? source->bytesAvailable() : 0;
+}
+
+qint64 QWaveDecoder::readData(char *data, qint64 maxlen)
+{
+    return haveFormat ? source->read(data, maxlen) : 0;
+}
+
+qint64 QWaveDecoder::writeData(const char *data, qint64 len)
+{
+    Q_UNUSED(data);
+    Q_UNUSED(len);
+
+    return -1;
+}
+
+void QWaveDecoder::parsingFailed()
+{
+    Q_ASSERT(source);
+    source->disconnect(SIGNAL(readyRead()), this, SLOT(handleData()));
+    emit parsingError();
+}
+
+void QWaveDecoder::handleData()
+{
+    // As a special "state", if we have junk to skip, we do
+    if (junkToSkip > 0) {
+        discardBytes(junkToSkip); // this also updates junkToSkip
+
+        // If we couldn't skip all the junk, return
+        if (junkToSkip > 0) {
+            // We might have run out
+            if (source->atEnd())
+                parsingFailed();
+            return;
+        }
+    }
+
+    if (state == QWaveDecoder::InitialState) {
+        if (source->bytesAvailable() < qint64(sizeof(RIFFHeader)))
+            return;
+
+        RIFFHeader riff;
+        source->read(reinterpret_cast<char *>(&riff), sizeof(RIFFHeader));
+
+        // RIFF = little endian RIFF, RIFX = big endian RIFF
+        if (((qstrncmp(riff.descriptor.id, "RIFF", 4) != 0) && (qstrncmp(riff.descriptor.id, "RIFX", 4) != 0))
+                || qstrncmp(riff.type, "WAVE", 4) != 0) {
+            parsingFailed();
+            return;
+        } else {
+            state = QWaveDecoder::WaitingForFormatState;
+            if (qstrncmp(riff.descriptor.id, "RIFX", 4) == 0)
+                bigEndian = true;
+            else
+                bigEndian = false;
+        }
+    }
+
+    if (state == QWaveDecoder::WaitingForFormatState) {
+        if (findChunk("fmt ")) {
+            chunk descriptor;
+            peekChunk(&descriptor);
+
+            if (source->bytesAvailable() < qint64(descriptor.size + sizeof(chunk)))
+                return;
+
+            WAVEHeader wave;
+            source->read(reinterpret_cast<char *>(&wave), sizeof(WAVEHeader));
+            if (descriptor.size > sizeof(WAVEHeader))
+                discardBytes(descriptor.size - sizeof(WAVEHeader));
+
+            // Swizzle this
+            if (bigEndian) {
+                wave.audioFormat = qFromBigEndian<quint16>(wave.audioFormat);
+            }
+
+            if (wave.audioFormat != 0 && wave.audioFormat != 1) {
+                // 32bit wave files have format == 0xFFFE (WAVE_FORMAT_EXTENSIBLE).
+                // but don't support them at the moment.
+                parsingFailed();
+                return;
+            } else {
+                format.setCodec(QLatin1String("audio/pcm"));
+
+                if (bigEndian) {
+                    int bps = qFromBigEndian<quint16>(wave.bitsPerSample);
+
+                    format.setSampleType(bps == 8 ? QAudioFormat::UnSignedInt : QAudioFormat::SignedInt);
+                    format.setByteOrder(QAudioFormat::BigEndian);
+                    format.setFrequency(qFromBigEndian<quint32>(wave.sampleRate));
+                    format.setSampleSize(bps);
+                    format.setChannels(qFromBigEndian<quint16>(wave.numChannels));
+                } else {
+                    int bps = qFromLittleEndian<quint16>(wave.bitsPerSample);
+
+                    format.setSampleType(bps == 8 ? QAudioFormat::UnSignedInt : QAudioFormat::SignedInt);
+                    format.setByteOrder(QAudioFormat::LittleEndian);
+                    format.setFrequency(qFromLittleEndian<quint32>(wave.sampleRate));
+                    format.setSampleSize(bps);
+                    format.setChannels(qFromLittleEndian<quint16>(wave.numChannels));
+                }
+
+                state = QWaveDecoder::WaitingForDataState;
+            }
+        }
+    }
+
+    if (state == QWaveDecoder::WaitingForDataState) {
+        if (findChunk("data")) {
+            source->disconnect(SIGNAL(readyRead()), this, SLOT(handleData()));
+
+            chunk descriptor;
+            source->read(reinterpret_cast<char *>(&descriptor), sizeof(chunk));
+            if (bigEndian)
+                descriptor.size = qFromBigEndian<quint32>(descriptor.size);
+
+            dataSize = descriptor.size;
+
+            haveFormat = true;
+            connect(source, SIGNAL(readyRead()), SIGNAL(readyRead()));
+            emit formatKnown();
+
+            return;
+        }
+    }
+
+    // If we hit the end without finding data, it's a parsing error
+    if (source->atEnd()) {
+        parsingFailed();
+    }
+}
+
+bool QWaveDecoder::enoughDataAvailable()
+{
+    chunk descriptor;
+    if (!peekChunk(&descriptor))
+        return false;
+
+    // This is only called for the RIFF/RIFX header, before bigEndian is set,
+    // so we have to manually swizzle
+    if (qstrncmp(descriptor.id, "RIFX", 4) == 0)
+        descriptor.size = qFromBigEndian<quint32>(descriptor.size);
+
+    if (source->bytesAvailable() < qint64(sizeof(chunk) + descriptor.size))
+        return false;
+
+    return true;
+}
+
+bool QWaveDecoder::findChunk(const char *chunkId)
+{
+    chunk descriptor;
+    if (!peekChunk(&descriptor))
+        return false;
+
+    if (qstrncmp(descriptor.id, chunkId, 4) == 0)
+        return true;
+
+    // It's possible that bytes->available() is less than the chunk size
+    // if it's corrupt.
+    junkToSkip = qint64(sizeof(chunk) + descriptor.size);
+    while (source->bytesAvailable() > 0) {
+        // Skip the current amount
+        if (junkToSkip > 0)
+            discardBytes(junkToSkip);
+
+        // If we still have stuff left, just exit and try again later
+        // since we can't call peekChunk
+        if (junkToSkip > 0)
+            return false;
+
+        if (!peekChunk(&descriptor))
+            return false;
+
+        if (qstrncmp(descriptor.id, chunkId, 4) == 0)
+            return true;
+    }
+
+    return false;
+}
+
+// Handles endianness
+bool QWaveDecoder::peekChunk(chunk *pChunk)
+{
+    if (source->bytesAvailable() < qint64(sizeof(chunk)))
+        return false;
+
+    source->peek(reinterpret_cast<char *>(pChunk), sizeof(chunk));
+    if (bigEndian)
+        pChunk->size = qFromBigEndian<quint32>(pChunk->size);
+
+    return true;
+}
+
+void QWaveDecoder::discardBytes(qint64 numBytes)
+{
+    // Discards a number of bytes
+    // If the iodevice doesn't have this many bytes in it,
+    // remember how much more junk we have to skip.
+    if (source->isSequential()) {
+        QByteArray r = source->read(qMin(numBytes, qint64(16384))); // uggh, wasted memory, limit to a max of 16k
+        if (r.size() < numBytes)
+            junkToSkip = numBytes - r.size();
+        else
+            junkToSkip = 0;
+    } else {
+        quint64 origPos = source->pos();
+        source->seek(source->pos() + numBytes);
+        junkToSkip = origPos + numBytes - source->pos();
+    }
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qwavedecoder_p.cpp"
diff --git a/src/multimedia/audio/qwavedecoder_p.h b/src/multimedia/audio/qwavedecoder_p.h
new file mode 100644
index 0000000..1a7bef9
--- /dev/null
+++ b/src/multimedia/audio/qwavedecoder_p.h
@@ -0,0 +1,141 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef WAVEDECODER_H
+#define WAVEDECODER_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of other Qt classes.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qiodevice.h>
+#include <qaudioformat.h>
+
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+
+class QWaveDecoder : public QIODevice
+{
+    Q_OBJECT
+
+public:
+    explicit QWaveDecoder(QIODevice *source, QObject *parent = 0);
+    ~QWaveDecoder();
+
+    QAudioFormat audioFormat() const;
+    int duration() const;
+
+    qint64 size() const;
+    bool isSequential() const;
+    qint64 bytesAvailable() const;
+
+Q_SIGNALS:
+    void formatKnown();
+    void parsingError();
+
+private Q_SLOTS:
+    void handleData();
+
+private:
+    qint64 readData(char *data, qint64 maxlen);
+    qint64 writeData(const char *data, qint64 len);
+
+    bool enoughDataAvailable();
+    bool findChunk(const char *chunkId);
+    void discardBytes(qint64 numBytes);
+    void parsingFailed();
+
+    enum State {
+        InitialState,
+        WaitingForFormatState,
+        WaitingForDataState
+    };
+
+    struct chunk
+    {
+        char        id[4];
+        quint32     size;
+    };
+    bool peekChunk(chunk* pChunk);
+
+    struct RIFFHeader
+    {
+        chunk       descriptor;
+        char        type[4];
+    };
+    struct WAVEHeader
+    {
+        chunk       descriptor;
+        quint16     audioFormat;
+        quint16     numChannels;
+        quint32     sampleRate;
+        quint32     byteRate;
+        quint16     blockAlign;
+        quint16     bitsPerSample;
+    };
+
+    bool haveFormat;
+    qint64 dataSize;
+    QAudioFormat format;
+    QIODevice *source;
+    State state;
+    quint32 junkToSkip;
+    bool bigEndian;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // WAVEDECODER_H
diff --git a/src/multimedia/camera/camera.pri b/src/multimedia/camera/camera.pri
new file mode 100644
index 0000000..be7868c
--- /dev/null
+++ b/src/multimedia/camera/camera.pri
@@ -0,0 +1,16 @@
+INCLUDEPATH += camera
+
+PUBLIC_HEADERS += \
+    camera/qcamera.h \
+    camera/qcameraimagecapture.h \
+    camera/qcameraexposure.h \
+    camera/qcamerafocus.h \
+    camera/qcameraimageprocessing.h
+
+SOURCES += \
+    camera/qcamera.cpp \
+    camera/qcameraexposure.cpp \
+    camera/qcamerafocus.cpp \
+    camera/qcameraimageprocessing.cpp \
+    camera/qcameraimagecapture.cpp
+
diff --git a/src/multimedia/camera/qcamera.cpp b/src/multimedia/camera/qcamera.cpp
new file mode 100644
index 0000000..8ba3aa6
--- /dev/null
+++ b/src/multimedia/camera/qcamera.cpp
@@ -0,0 +1,1035 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qvideosurfaceoutput_p.h"
+#include "qmediaobject_p.h"
+
+#include <qcamera.h>
+#include <qcameracontrol.h>
+#include <qcameralockscontrol.h>
+#include <qcameraexposurecontrol.h>
+#include <qcamerafocuscontrol.h>
+#include <qmediarecordercontrol.h>
+#include <qcameraimageprocessingcontrol.h>
+#include <qcameraimagecapturecontrol.h>
+#include <qvideodevicecontrol.h>
+
+#include <QDebug>
+
+namespace
+{
+class CameraRegisterMetaTypes
+{
+public:
+    CameraRegisterMetaTypes()
+    {
+        qRegisterMetaType<QCamera::Error>("QCamera::Error");
+        qRegisterMetaType<QCamera::State>("QCamera::State");
+        qRegisterMetaType<QCamera::Status>("QCamera::Status");
+        qRegisterMetaType<QCamera::CaptureMode>("QCamera::CaptureMode");
+        qRegisterMetaType<QCamera::LockType>("QCamera::LockType");
+        qRegisterMetaType<QCamera::LockStatus>("QCamera::LockStatus");
+        qRegisterMetaType<QCamera::LockChangeReason>("QCamera::LockChangeReason");
+    }
+} _registerCameraMetaTypes;
+}
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCamera
+
+
+    \brief The QCamera class provides interface for system camera devices.
+
+    \inmodule QtMultimedia
+    \ingroup camera
+    \since 1.1
+
+    QCamera can be used with QVideoWidget for viewfinder display,
+    QMediaRecorder for video recording and QCameraImageCapture for image taking.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Request control
+
+*/
+
+
+class QCameraPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QCamera)
+public:
+    QCameraPrivate():
+        QMediaObjectPrivate(),
+        provider(0),
+        control(0),
+        deviceControl(0),
+        viewfinder(0),
+        capture(0),
+        state(QCamera::UnloadedState),
+        error(QCamera::NoError),
+        supportedLocks(QCamera::NoLock),
+        requestedLocks(QCamera::NoLock),
+        lockStatus(QCamera::Unlocked),
+        lockChangeReason(QCamera::UserRequest),
+        supressLockChangedSignal(false),
+        restartPending(false)
+    {
+    }
+
+    void initControls();
+
+    QMediaServiceProvider *provider;
+
+    QCameraControl *control;
+    QVideoDeviceControl *deviceControl;
+    QCameraLocksControl *locksControl;
+
+    QCameraExposure *cameraExposure;
+    QCameraFocus *cameraFocus;
+    QCameraImageProcessing *imageProcessing;
+
+    QObject *viewfinder;
+    QObject *capture;
+
+    QCamera::State state;
+
+    QCamera::Error error;
+    QString errorString;
+
+    QCamera::LockTypes supportedLocks;
+    QCamera::LockTypes requestedLocks;
+
+    QCamera::LockStatus lockStatus;
+    QCamera::LockChangeReason lockChangeReason;
+    bool supressLockChangedSignal;
+
+    bool restartPending;
+
+    QVideoSurfaceOutput surfaceViewfinder;
+
+    void _q_error(int error, const QString &errorString);
+    void unsetError() { error = QCamera::NoError; errorString.clear(); }
+
+    void setState(QCamera::State);
+
+    void _q_updateLockStatus(QCamera::LockType, QCamera::LockStatus, QCamera::LockChangeReason);
+    void _q_updateState(QCamera::State newState);
+    void _q_preparePropertyChange(int changeType);
+    void _q_restartCamera();
+    void updateLockStatus();
+};
+
+
+void QCameraPrivate::_q_error(int error, const QString &errorString)
+{
+    Q_Q(QCamera);
+
+    this->error = QCamera::Error(error);
+    this->errorString = errorString;
+
+    qWarning() << "Camera error:" << errorString;
+
+    emit q->error(this->error);
+}
+
+void QCameraPrivate::setState(QCamera::State newState)
+{
+    Q_Q(QCamera);
+
+    unsetError();
+
+    if (!control) {
+        _q_error(QCamera::ServiceMissingError, q_ptr->tr("The camera service is missing"));
+        return;
+    }
+
+    if (state == newState)
+        return;
+
+    restartPending = false;
+    state = newState;
+    control->setState(state);
+    emit q->stateChanged(state);
+}
+
+void QCameraPrivate::_q_updateState(QCamera::State newState)
+{
+    Q_Q(QCamera);
+
+    //omit changins state to Loaded when the camera is temporarily
+    //stopped to apply shanges
+    if (restartPending)
+        return;
+
+    if (newState != state) {
+        qDebug() << "Camera state changed:" << newState;
+        state = newState;
+        emit q->stateChanged(state);
+    }
+}
+
+void QCameraPrivate::_q_preparePropertyChange(int changeType)
+{
+    if (!control)
+        return;
+
+    QCamera::Status status = control->status();
+
+    //all the changes are allowed until the camera is starting
+    if (control->state() != QCamera::ActiveState)
+        return;
+
+    if (control->canChangeProperty(QCameraControl::PropertyChangeType(changeType), status))
+        return;
+
+    restartPending = true;
+    control->setState(QCamera::LoadedState);
+    QMetaObject::invokeMethod(q_ptr, "_q_restartCamera", Qt::QueuedConnection);
+}
+
+void QCameraPrivate::_q_restartCamera()
+{
+    if (restartPending) {
+        restartPending = false;
+        control->setState(QCamera::ActiveState);
+    }
+}
+
+void QCameraPrivate::initControls()
+{
+    Q_Q(QCamera);
+
+    supportedLocks = 0;
+
+    if (service) {
+        control = qobject_cast<QCameraControl *>(service->requestControl(QCameraControl_iid));
+        locksControl = qobject_cast<QCameraLocksControl *>(service->requestControl(QCameraLocksControl_iid));
+        deviceControl = qobject_cast<QVideoDeviceControl*>(service->requestControl(QVideoDeviceControl_iid));
+
+        if (control) {
+            q->connect(control, SIGNAL(stateChanged(QCamera::State)), q, SLOT(_q_updateState(QCamera::State)));
+            q->connect(control, SIGNAL(statusChanged(QCamera::Status)), q, SIGNAL(statusChanged(QCamera::Status)));
+            q->connect(control, SIGNAL(captureModeChanged(QCamera::CaptureMode)),
+                       q, SIGNAL(captureModeChanged(QCamera::CaptureMode)));
+            q->connect(control, SIGNAL(error(int,QString)), q, SLOT(_q_error(int,QString)));
+
+        }
+
+        if (locksControl) {
+            q->connect(locksControl, SIGNAL(lockStatusChanged(QCamera::LockType,QCamera::LockStatus,QCamera::LockChangeReason)),
+                       q, SLOT(_q_updateLockStatus(QCamera::LockType,QCamera::LockStatus,QCamera::LockChangeReason)));
+            supportedLocks = locksControl->supportedLocks();
+        }
+
+        error = QCamera::NoError;
+    } else {
+        control = 0;
+        locksControl = 0;
+        deviceControl = 0;
+
+        error = QCamera::ServiceMissingError;
+        errorString = QCamera::tr("The camera service is missing");
+    }
+}
+
+void QCameraPrivate::updateLockStatus()
+{
+    Q_Q(QCamera);
+
+    QCamera::LockStatus oldStatus = lockStatus;
+
+    QMap<QCamera::LockStatus, int> lockStatusPriority;
+    lockStatusPriority.insert(QCamera::Locked, 1);
+    lockStatusPriority.insert(QCamera::Searching, 2);
+    lockStatusPriority.insert(QCamera::Unlocked, 3);
+
+    lockStatus = requestedLocks ? QCamera::Locked : QCamera::Unlocked;
+    int priority = 0;
+
+    QList<QCamera::LockStatus> lockStatuses;
+
+    if (requestedLocks & QCamera::LockFocus)
+        lockStatuses << q->lockStatus(QCamera::LockFocus);
+
+    if (requestedLocks & QCamera::LockExposure)
+        lockStatuses << q->lockStatus(QCamera::LockExposure);
+
+    if (requestedLocks & QCamera::LockWhiteBalance)
+        lockStatuses << q->lockStatus(QCamera::LockWhiteBalance);
+
+
+    foreach (QCamera::LockStatus currentStatus, lockStatuses) {
+        int currentPriority = lockStatusPriority.value(currentStatus, -1);
+        if (currentPriority > priority) {
+            priority = currentPriority;
+            lockStatus = currentStatus;
+        }
+    }
+
+    if (!supressLockChangedSignal && oldStatus != lockStatus) {
+        emit q->lockStatusChanged(lockStatus, lockChangeReason);
+
+        if (lockStatus == QCamera::Locked)
+            emit q->locked();
+        else if (lockStatus == QCamera::Unlocked && lockChangeReason == QCamera::LockFailed)
+            emit q->lockFailed();
+    }
+/*
+    qDebug() << "Requested locks:" << (requestedLocks & QCamera::LockExposure ? 'e' : ' ')
+            << (requestedLocks & QCamera::LockFocus ? 'f' : ' ')
+            << (requestedLocks & QCamera::LockWhiteBalance ? 'w' : ' ');
+    qDebug() << "Lock status: f:" << q->lockStatus(QCamera::LockFocus)
+             << " e:" << q->lockStatus(QCamera::LockExposure)
+             << " w:" << q->lockStatus(QCamera::LockWhiteBalance)
+             << " composite:" << lockStatus;
+*/
+}
+
+void QCameraPrivate::_q_updateLockStatus(QCamera::LockType type, QCamera::LockStatus status, QCamera::LockChangeReason reason)
+{
+    Q_Q(QCamera);
+    lockChangeReason = reason;
+    updateLockStatus();
+    emit q->lockStatusChanged(type, status, reason);
+}
+
+
+/*!
+    Construct a QCamera from service \a provider and \a parent.
+*/
+
+QCamera::QCamera(QObject *parent, QMediaServiceProvider *provider):
+    QMediaObject(*new QCameraPrivate, parent, provider->requestService(Q_MEDIASERVICE_CAMERA))
+{
+    Q_D(QCamera);
+    d->provider = provider;
+    d->initControls();
+    d->cameraExposure = new QCameraExposure(this);
+    d->cameraFocus = new QCameraFocus(this);
+    d->imageProcessing = new QCameraImageProcessing(this);
+}
+
+/*!
+    Construct a QCamera from device name \a device and \a parent.
+*/
+
+QCamera::QCamera(const QByteArray& device, QObject *parent):
+    QMediaObject(*new QCameraPrivate, parent,
+                  QMediaServiceProvider::defaultServiceProvider()->requestService(Q_MEDIASERVICE_CAMERA, QMediaServiceProviderHint(device)))
+{
+    Q_D(QCamera);
+    d->provider = QMediaServiceProvider::defaultServiceProvider();
+    d->initControls();
+
+    if (d->service != 0) {
+        //pass device name to service
+        if (d->deviceControl) {
+            QString deviceName = QString::fromLatin1(device);
+
+            for (int i=0; i<d->deviceControl->deviceCount(); i++) {
+                if (d->deviceControl->deviceName(i) == deviceName) {
+                    d->deviceControl->setSelectedDevice(i);
+                    break;
+                }
+            }
+        }
+    }
+
+    d->cameraExposure = new QCameraExposure(this);
+    d->cameraFocus = new QCameraFocus(this);
+    d->imageProcessing = new QCameraImageProcessing(this);
+}
+
+/*!
+    Destroys the camera object.
+*/
+
+QCamera::~QCamera()
+{
+    Q_D(QCamera);
+    delete d->cameraExposure;
+    d->cameraExposure = 0;
+    delete d->cameraFocus;
+    d->cameraFocus = 0;
+    delete d->imageProcessing;
+    d->imageProcessing = 0;
+
+    if (d->service) {
+        if (d->control)
+            d->service->releaseControl(d->control);
+        if (d->locksControl)
+            d->service->releaseControl(d->locksControl);
+        if (d->deviceControl)
+            d->service->releaseControl(d->deviceControl);
+
+        d->provider->releaseService(d->service);
+    }
+}
+
+
+/*!
+    Return true if the camera service is ready to use.
+    \since 1.1
+*/
+bool QCamera::isAvailable() const
+{
+    return availabilityError() == QtMultimedia::NoError;
+}
+
+/*!
+    Returns the error state of the camera service.
+    \since 1.1
+*/
+
+QtMultimedia::AvailabilityError QCamera::availabilityError() const
+{
+    Q_D(const QCamera);
+    if (d->control == NULL)
+        return QtMultimedia::ServiceMissingError;
+
+    if (d->deviceControl && d->deviceControl->deviceCount() == 0)
+        return QtMultimedia::ResourceError;
+
+    if (d->error != QCamera::NoError)
+        return QtMultimedia::ResourceError;
+
+    return QtMultimedia::NoError;
+}
+
+
+/*!
+    Returns the camera exposure control object.
+    \since 1.1
+*/
+QCameraExposure *QCamera::exposure() const
+{
+    return d_func()->cameraExposure;
+}
+
+/*!
+    Returns the camera focus control object.
+    \since 1.1
+*/
+QCameraFocus *QCamera::focus() const
+{
+    return d_func()->cameraFocus;
+}
+
+/*!
+    Returns the camera image processing control object.
+    \since 1.1
+*/
+QCameraImageProcessing *QCamera::imageProcessing() const
+{
+    return d_func()->imageProcessing;
+}
+
+/*!
+  Sets the QVideoWidget based camera \a viewfinder.
+  The previously set viewfinder is detached.
+  \since 1.1
+*/
+
+// QVideoWidget is forward declared
+void QCamera::setViewfinder(QVideoWidget *viewfinder)
+{
+    Q_D(QCamera);
+    d->_q_preparePropertyChange(QCameraControl::Viewfinder);
+
+    if (d->viewfinder)
+        unbind(d->viewfinder);
+
+    // We don't know (in this library) that QVideoWidget inherits QObject
+    QObject *viewFinderObject = reinterpret_cast<QObject*>(viewfinder);
+
+    d->viewfinder = viewFinderObject && bind(viewFinderObject) ? viewFinderObject : 0;
+}
+
+/*!
+  Sets the QGraphicsVideoItem based camera \a viewfinder.
+  The previously set viewfinder is detached.
+  \since 1.1
+*/
+// QGraphicsVideoItem is forward declared
+void QCamera::setViewfinder(QGraphicsVideoItem *viewfinder)
+{
+    Q_D(QCamera);
+    d->_q_preparePropertyChange(QCameraControl::Viewfinder);
+
+    if (d->viewfinder)
+        unbind(d->viewfinder);
+
+    // We don't know (in this library) that QGraphicsVideoItem (multiply) inherits QObject
+    // but QObject inheritance depends on QObject coming first, so try this out.
+    QObject *viewFinderObject = reinterpret_cast<QObject*>(viewfinder);
+
+    d->viewfinder = viewFinderObject && bind(viewFinderObject) ? viewFinderObject : 0;
+}
+
+/*!
+    Sets a video \a surface as the viewfinder of a camera.
+
+    If a viewfinder has already been set on the camera the new surface
+    will replace it.
+    \since 1.2
+*/
+
+void QCamera::setViewfinder(QAbstractVideoSurface *surface)
+{
+    Q_D(QCamera);
+
+    d->surfaceViewfinder.setVideoSurface(surface);
+
+    if (d->viewfinder != &d->surfaceViewfinder) {
+        if (d->viewfinder)
+            unbind(d->viewfinder);
+
+        d->viewfinder = bind(&d->surfaceViewfinder) ? &d->surfaceViewfinder : 0;
+    }
+}
+
+/*!
+    Returns the error state of the object.
+    \since 1.1
+*/
+
+QCamera::Error QCamera::error() const
+{
+    return d_func()->error;
+}
+
+/*!
+    Returns a string describing a camera's error state.
+    \since 1.1
+*/
+QString QCamera::errorString() const
+{
+    return d_func()->errorString;
+}
+
+
+/*!
+    Returns true if the capture \a mode is suported.
+    \since 1.1
+*/
+bool QCamera::isCaptureModeSupported(QCamera::CaptureMode mode) const
+{
+    return d_func()->control ? d_func()->control->isCaptureModeSupported(mode) : false;
+}
+
+/*!
+  \property QCamera::captureMode
+
+  The type of media (video or still images),
+  the camera is configured to capture.
+
+  It's allowed to change capture mode in any camera state,
+  but if the camera is currently active,
+  chaging capture mode is likely to lead to camera status
+  chaged to QCamera::LoadedStatus, QCamera::LoadingStatus,
+  and when the camera is ready to QCamera::ActiveStatus.
+  \since 1.1
+*/
+
+QCamera::CaptureMode QCamera::captureMode() const
+{
+    return d_func()->control ? d_func()->control->captureMode() : QCamera::CaptureStillImage;
+}
+
+void QCamera::setCaptureMode(QCamera::CaptureMode mode)
+{
+    Q_D(QCamera);
+
+    if (mode != captureMode()) {
+        if (d->control) {
+            d->_q_preparePropertyChange(QCameraControl::CaptureMode);
+            d->control->setCaptureMode(mode);
+        }
+    }
+}
+
+
+/*!
+    Starts the camera.
+
+    State is changed to QCamera::ActiveState if camera is started
+    successfully, otherwise error() signal is emitted.
+
+    While the camera state is changed to QCamera::ActiveState,
+    starting the camera service can be asynchronous with the actual
+    status reported with QCamera::status property.
+    \since 1.1
+*/
+void QCamera::start()
+{
+    Q_D(QCamera);
+    d->setState(QCamera::ActiveState);
+}
+
+/*!
+    Stops the camera.
+    The camera state is changed from QCamera::ActiveState to QCamera::LoadedState.
+    \since 1.1
+*/
+void QCamera::stop()
+{
+    Q_D(QCamera);
+    d->setState(QCamera::LoadedState);
+}
+
+/*!
+    Open the camera device.
+    The camera state is changed to QCamera::LoadedStatus.
+
+    It's not necessary to explcitly load the camera,
+    unless unless the application have to read the supported camera
+    settings and change the default depending on the camera capabilities.
+
+    In all the other cases it's possible to start the camera directly
+    from unloaded state.
+    \since 1.1
+*/
+void QCamera::load()
+{
+    Q_D(QCamera);
+    d->setState(QCamera::LoadedState);
+}
+
+/*!
+    Close the camera device and deallocate the related resources.
+    The camera state is changed to QCamera::UnloadedStatus.
+    \since 1.1
+*/
+void QCamera::unload()
+{
+    Q_D(QCamera);
+    d->setState(QCamera::UnloadedState);
+}
+
+
+/*!
+    Returns a list of camera device's available from the default service provider.
+    \since 1.1
+*/
+
+QList<QByteArray> QCamera::availableDevices()
+{
+    return QMediaServiceProvider::defaultServiceProvider()->devices(QByteArray(Q_MEDIASERVICE_CAMERA));
+}
+
+/*!
+    Returns the description of the \a device.
+    \since 1.1
+*/
+
+QString QCamera::deviceDescription(const QByteArray &device)
+{
+    return QMediaServiceProvider::defaultServiceProvider()->deviceDescription(QByteArray(Q_MEDIASERVICE_CAMERA), device);
+}
+
+QCamera::State QCamera::state() const
+{
+    return d_func()->state;
+}
+
+QCamera::Status QCamera::status() const
+{
+    if(d_func()->control)
+        return (QCamera::Status)d_func()->control->status();
+
+    return QCamera::UnavailableStatus;
+}
+
+
+/*!
+    Returns the lock types, camera supports.
+    \since 1.1
+*/
+QCamera::LockTypes QCamera::supportedLocks() const
+{
+    return d_func()->supportedLocks;
+}
+
+/*!
+    Returns the requested lock types.
+    \since 1.1
+*/
+QCamera::LockTypes QCamera::requestedLocks() const
+{
+    return d_func()->requestedLocks;
+}
+
+/*!
+    Returns the status of requested camera settings locks.
+    \since 1.1
+*/
+QCamera::LockStatus QCamera::lockStatus() const
+{
+    return d_func()->lockStatus;
+}
+
+/*!
+    Returns the status of camera settings \a lock.
+    \since 1.1
+*/
+QCamera::LockStatus QCamera::lockStatus(QCamera::LockType lockType) const
+{
+    const QCameraPrivate *d = d_func();
+
+    if (!(lockType & d->supportedLocks))
+        return lockType & d->requestedLocks ? QCamera::Locked : QCamera::Unlocked;
+
+    if (!(lockType & d->requestedLocks))
+        return QCamera::Unlocked;
+
+    if (d->locksControl)
+        return d->locksControl->lockStatus(lockType);
+
+    return QCamera::Unlocked;
+}
+
+/*!
+    \fn void QCamera::searchAndLock(QCamera::LockTypes locks)
+
+    Locks the camera settings with the requested \a locks, including focusing in the single autofocus mode,
+    exposure and white balance if the exposure and white balance modes are not manual.
+
+    The camera settings are usually locked before taking one or multiple still images,
+    in responce to the shutter button being half pressed.
+
+    The QCamera::locked() signal is emitted when camera settings are successfully locked,
+    otherwise QCamera::lockFailed() is emitted.
+
+    QCamera also emits lockStatusChanged(QCamera::LockType, QCamera::LockStatus)
+    on individual lock status changes and lockStatusChanged(QCamera::LockStatus) signal on composite status changes.
+
+    Locking serves two roles: it initializes calculation of automatic parameter
+    (focusing, calculating the correct exposure and white balance) and allows
+    to keep some or all of those parameters during number of shots.
+
+    If the camera doesn't support keeping one of parameters between shots, the related
+    lock state changes to QCamera::Unlocked.
+
+    It's also acceptable to relock already locked settings,
+    depending on the lock parameter this initiates new focusing, exposure or white balance calculation.
+    \since 1.1
+ */
+void QCamera::searchAndLock(QCamera::LockTypes locks)
+{
+    Q_D(QCamera);
+
+    QCamera::LockStatus oldStatus = d->lockStatus;
+    d->supressLockChangedSignal = true;
+
+    d->requestedLocks |= locks;
+
+    locks &= d->supportedLocks;
+
+    if (d->locksControl)
+        d->locksControl->searchAndLock(locks);
+
+    d->supressLockChangedSignal = false;
+
+    d->lockStatus = oldStatus;
+    d->updateLockStatus();
+}
+
+/*!
+    Lock all the supported camera settings.
+    \since 1.1
+ */
+void QCamera::searchAndLock()
+{
+    searchAndLock(LockExposure | LockWhiteBalance | LockFocus);
+}
+
+/*!
+    Unlocks the camera settings specified with \a locks or cancel the current locking if one is active.
+    \since 1.1
+ */
+void QCamera::unlock(QCamera::LockTypes locks)
+{
+    Q_D(QCamera);
+
+    QCamera::LockStatus oldStatus = d->lockStatus;
+    d->supressLockChangedSignal = true;
+
+    d->requestedLocks &= ~locks;
+
+    locks &= d->supportedLocks;
+
+    if (d->locksControl)
+        d->locksControl->unlock(locks);
+
+    d->supressLockChangedSignal = false;
+
+    d->lockStatus = oldStatus;
+    d->updateLockStatus();
+}
+
+/*!
+    Unlock all the requested camera locks.
+    \since 1.1
+ */
+void QCamera::unlock()
+{
+    unlock(d_func()->requestedLocks);
+}
+
+
+/*!
+    \enum QCamera::State
+    \value UnloadedState
+           The initial camera state, with camera not loaded,
+           the camera capabilities except of supported capture modes
+           are unknown.
+
+           While the supported settings are unknown in this state,
+           it's allowed to set the camera capture settings like codec,
+           resolution, or frame rate.
+
+    \value LoadedState
+           The camera is loaded and ready to be configured.
+
+           In the Idle state it's allowed to query camera capabilities,
+           set capture resolution, codecs, etc.
+
+           The viewfinder is not active in the loaded state.
+
+    \value ActiveState
+           In the active state as soon as camera is started
+           the viewfinder displays video frames and the
+           camera is ready for capture.
+*/
+
+
+/*!
+    \property QCamera::state
+    \brief The current state of the camera object.
+    \since 1.1
+*/
+
+/*!
+    \enum QCamera::Status
+    \value ActiveStatus
+           The camera has been started and can produce data.
+           The viewfinder displays video frames in active state.
+
+           Depending on backend, changing some camera settings like
+           capture mode, codecs or resolution in ActiveState may lead
+           to changing the camera status to LoadedStatus and StartingStatus while
+           the settings are applied and back to ActiveStatus when the camera is ready.
+
+    \value StartingStatus
+           The camera is starting in result of state transition to QCamera::ActiveState.
+           The camera service is not ready to capture yet.
+
+    \value StandbyStatus
+           The camera is in the power saving standby mode.
+           The camera may come to the standby mode after some time of inactivity
+           in the QCamera::LoadedState state.
+
+    \value LoadedStatus
+           The camera is loaded and ready to be configured.
+           This status indicates the camera device is opened and
+           it's possible to query for supported image and video capture settings,
+           like resolution, framerate and codecs.
+
+    \value LoadingStatus
+           The camera device loading in result of state transition from
+           QCamera::UnloadedState to QCamera::LoadedState or QCamera::ActiveState.
+
+    \value UnloadedStatus
+           The initial camera status, with camera not loaded.
+           The camera capabilities including supported capture settings may be unknown.
+
+    \value UnavailableStatus
+           The camera or camera backend is not available.
+*/
+
+
+/*!
+    \property QCamera::status
+    \brief The current status of the camera object.
+    \since 1.1
+*/
+
+
+/*!
+    \enum QCamera::CaptureMode
+    \value CaptureStillImage Camera is configured for still frames capture.
+    \value CaptureVideo  Camera is configured for video capture.
+    \since 1.1
+*/
+
+/*!
+    \enum QCamera::LockType
+
+    \value NoLock
+    \value LockExposure
+        Lock camera exposure.
+    \value LockWhiteBalance
+        Lock the white balance.
+    \value LockFocus
+        Lock camera focus.
+*/
+
+
+/*!
+    \property QCamera::lockStatus
+    \brief The overall status for all the requested camera locks.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCamera::locked()
+
+    Signals all the requested camera settings are locked.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCamera::lockFailed()
+
+    Signals locking of at least one requested camera settings failed.
+    \since 1.1
+*/
+
+/*!
+    \fn QCamera::lockStatusChanged(QCamera::LockStatus status, QCamera::LockChangeReason reason)
+
+    Signals the overall \a status for all the requested camera locks was changed with specified \a reason.
+    \since 1.1
+*/
+
+/*!
+    \fn QCamera::lockStatusChanged(QCamera::LockType lock, QCamera::LockStatus status, QCamera::LockChangeReason reason)
+    Signals the \a lock \a status was changed with specified \a reason.
+    \since 1.1
+*/
+
+/*!
+  \enum QCamera::LockStatus
+    \value Unlocked
+        The application is not interested in camera settings value.
+        The camera may keep this parameter without changes, this is common with camera focus,
+        or adjust exposure and white balance constantly to keep the viewfinder image nice.
+
+    \value Searching
+        The application has requested the camera focus, exposure or white balance lock with
+        QCamera::searchAndLock(). This state indicates the camera is focusing or calculating exposure and white balance.
+
+    \value Locked
+        The camera focus, exposure or white balance is locked.
+        The camera is ready to capture, application may check the exposure parameters.
+
+        The locked state usually means the requested parameter stays the same,
+        except of the cases when the parameter is requested to be constantly updated.
+        For example in continuous focusing mode, the focus is considered locked as long
+        and the object is in focus, even while the actual focusing distance may be constantly changing.
+*/
+
+/*!
+    \enum QCamera::LockChangeReason
+
+    \value UserRequest
+        The lock status changed in result of user request, usually to unlock camera settings.
+    \value LockAcquired
+        The lock status successfuly changed to QCamera::Locked.
+    \value LockFailed
+        The camera failed to acquire the requested lock in result of
+        autofocus failure, exposure out of supported range, etc.
+    \value LockLost
+        The camera is not able to maintain the requested lock any more.
+        Lock status is changed to QCamera::Unlocked.
+    \value LockTemporaryLost
+        The lock is lost, but the camera is working hard to reacquire it.
+        This value may be used in continuous focusing mode,
+        when the camera loses the focus, the focus lock state is changed to Qcamera::Searching
+        with LockTemporaryLost reason.
+*/
+
+/*!
+    \enum QCamera::Error
+
+    \value  NoError      No errors have occurred.
+    \value  CameraError  An error has occurred.
+    \value  InvalidRequestError System resource doesn't support requested functionality.
+    \value  ServiceMissingError No camera service available.
+    \value  NotSupportedFeatureError The feature is not supported.
+*/
+
+/*!
+    \fn void QCamera::error(QCamera::Error value)
+
+    Signal emitted when error state changes to \a value.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCamera::captureModeChanged(QCamera::CaptureMode mode)
+
+    Signals the capture \a mode has changed.
+    \since 1.1
+*/
+
+/*!
+  \fn QCamera::stateChanged(QCamera::State state)
+
+  Signals the camera \a state has changed.
+
+  Usually the state changes is caused by calling
+  load(), unload(), start() and stop(),
+  but the state can also be changed change as a result of camera error.
+    \since 1.1
+*/
+
+/*!
+  \fn QCamera::statusChanged(QCamera::Status status)
+
+  Signals the camera \a status has changed.
+
+  \since 1.1
+*/
+
+QT_END_NAMESPACE
+
+#include "moc_qcamera.cpp"
diff --git a/src/multimedia/camera/qcamera.h b/src/multimedia/camera/qcamera.h
new file mode 100644
index 0000000..da009e1
--- /dev/null
+++ b/src/multimedia/camera/qcamera.h
@@ -0,0 +1,238 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERA_H
+#define QCAMERA_H
+
+#include <QtCore/qstringlist.h>
+#include <QtCore/qpair.h>
+#include <QtCore/qsize.h>
+#include <QtCore/qpoint.h>
+#include <QtCore/qrect.h>
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+#include <qmediaservice.h>
+
+#include <qcameraexposure.h>
+#include <qcamerafocus.h>
+#include <qcameraimageprocessing.h>
+
+#include <qmediaserviceprovider.h>
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QAbstractVideoSurface;
+class QVideoWidget;
+class QGraphicsVideoItem;
+
+class QCameraPrivate;
+class Q_MULTIMEDIA_EXPORT QCamera : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QCamera::State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(QCamera::Status status READ status NOTIFY statusChanged)
+    Q_PROPERTY(QCamera::CaptureMode captureMode READ captureMode WRITE setCaptureMode NOTIFY captureModeChanged)
+    Q_PROPERTY(QCamera::LockStatus lockStatus READ lockStatus NOTIFY lockStatusChanged)
+
+    Q_ENUMS(Status)
+    Q_ENUMS(State)
+    Q_ENUMS(CaptureMode)
+    Q_ENUMS(Error)
+    Q_ENUMS(LockStatus)
+    Q_ENUMS(LockChangeReason)
+    Q_ENUMS(LockType)
+public:
+    enum Status {
+        UnavailableStatus,
+        UnloadedStatus,
+        LoadingStatus,
+        LoadedStatus,
+        StandbyStatus,
+        StartingStatus,
+        ActiveStatus
+    };
+
+    enum State {
+        UnloadedState,
+        LoadedState,
+        ActiveState
+    };
+
+    enum CaptureMode
+    {
+        CaptureStillImage,
+        CaptureVideo
+    };
+
+    enum Error
+    {
+        NoError,
+        CameraError,
+        InvalidRequestError,
+        ServiceMissingError,
+        NotSupportedFeatureError
+    };
+
+    enum LockStatus
+    {
+        Unlocked,
+        Searching,
+        Locked
+    };
+
+    enum LockChangeReason {
+        UserRequest,
+        LockAcquired,
+        LockFailed,
+        LockLost,
+        LockTemporaryLost
+    };
+
+    enum LockType
+    {
+        NoLock = 0,
+        LockExposure = 0x01,
+        LockWhiteBalance = 0x02,
+        LockFocus = 0x04
+    };
+    Q_DECLARE_FLAGS(LockTypes, LockType)
+
+    QCamera(QObject *parent = 0, QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider());
+    QCamera(const QByteArray& device, QObject *parent = 0);
+    ~QCamera();
+
+    static QList<QByteArray> availableDevices();
+    static QString deviceDescription(const QByteArray &device);
+
+    bool isAvailable() const;
+    QtMultimedia::AvailabilityError availabilityError() const;
+
+    State state() const;
+    Status status() const;
+
+    CaptureMode captureMode() const;
+    bool isCaptureModeSupported(CaptureMode mode) const;
+
+    QCameraExposure *exposure() const;
+    QCameraFocus *focus() const;
+    QCameraImageProcessing *imageProcessing() const;
+
+    void setViewfinder(QVideoWidget *viewfinder);
+    void setViewfinder(QGraphicsVideoItem *viewfinder);
+    void setViewfinder(QAbstractVideoSurface *surface);
+
+    Error error() const;
+    QString errorString() const;
+
+    QCamera::LockTypes supportedLocks() const;
+    QCamera::LockTypes requestedLocks() const;
+
+    QCamera::LockStatus lockStatus() const;
+    QCamera::LockStatus lockStatus(QCamera::LockType lock) const;
+
+public Q_SLOTS:
+    void setCaptureMode(QCamera::CaptureMode mode);
+
+    void load();
+    void unload();
+
+    void start();
+    void stop();
+
+    void searchAndLock();
+    void unlock();
+
+    void searchAndLock(QCamera::LockTypes locks);
+    void unlock(QCamera::LockTypes locks);
+
+Q_SIGNALS:
+    void stateChanged(QCamera::State);
+    void captureModeChanged(QCamera::CaptureMode);
+    void statusChanged(QCamera::Status);
+
+    void locked();
+    void lockFailed();
+
+    void lockStatusChanged(QCamera::LockStatus, QCamera::LockChangeReason);
+    void lockStatusChanged(QCamera::LockType, QCamera::LockStatus, QCamera::LockChangeReason);
+
+    void error(QCamera::Error);
+
+private:
+    Q_DISABLE_COPY(QCamera)
+    Q_DECLARE_PRIVATE(QCamera)
+    Q_PRIVATE_SLOT(d_func(), void _q_preparePropertyChange(int))
+    Q_PRIVATE_SLOT(d_func(), void _q_restartCamera())
+    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
+    Q_PRIVATE_SLOT(d_func(), void _q_updateLockStatus(QCamera::LockType, QCamera::LockStatus, QCamera::LockChangeReason))
+    Q_PRIVATE_SLOT(d_func(), void _q_updateState(QCamera::State))
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCamera::LockTypes)
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QCamera::State)
+Q_DECLARE_METATYPE(QCamera::Status)
+Q_DECLARE_METATYPE(QCamera::Error)
+Q_DECLARE_METATYPE(QCamera::CaptureMode)
+Q_DECLARE_METATYPE(QCamera::LockType)
+Q_DECLARE_METATYPE(QCamera::LockStatus)
+Q_DECLARE_METATYPE(QCamera::LockChangeReason)
+
+Q_MEDIA_ENUM_DEBUG(QCamera, State)
+Q_MEDIA_ENUM_DEBUG(QCamera, Status)
+Q_MEDIA_ENUM_DEBUG(QCamera, Error)
+Q_MEDIA_ENUM_DEBUG(QCamera, CaptureMode)
+Q_MEDIA_ENUM_DEBUG(QCamera, LockType)
+Q_MEDIA_ENUM_DEBUG(QCamera, LockStatus)
+Q_MEDIA_ENUM_DEBUG(QCamera, LockChangeReason)
+
+QT_END_HEADER
+
+#endif  // QCAMERA_H
diff --git a/src/multimedia/camera/qcameraexposure.cpp b/src/multimedia/camera/qcameraexposure.cpp
new file mode 100644
index 0000000..5c75ad9
--- /dev/null
+++ b/src/multimedia/camera/qcameraexposure.cpp
@@ -0,0 +1,646 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qcameraexposure.h"
+#include "qmediaobject_p.h"
+
+#include <qcamera.h>
+#include <qcameraexposurecontrol.h>
+#include <qcameraflashcontrol.h>
+
+#include <QtCore/QMetaObject>
+#include <QtCore/QDebug>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraExposure
+
+
+    \brief The QCameraExposure class provides interface for exposure related camera settings.
+
+    \inmodule QtMultimedia
+    \ingroup camera
+    \since 1.1
+
+*/
+
+//#define DEBUG_EXPOSURE_CHANGES 1
+
+#ifdef DEBUG_EXPOSURE_CHANGES
+#define ENUM_NAME(c,e,v) (c::staticMetaObject.enumerator(c::staticMetaObject.indexOfEnumerator(e)).valueToKey((v)))
+#endif
+
+namespace
+{
+class CameraExposureRegisterMetaTypes
+{
+public:
+    CameraExposureRegisterMetaTypes()
+    {
+        qRegisterMetaType<QCameraExposure::ExposureMode>("QCameraExposure::ExposureMode");
+        qRegisterMetaType<QCameraExposure::FlashModes>("QCameraExposure::FlashModes");
+        qRegisterMetaType<QCameraExposure::MeteringMode>("QCameraExposure::MeteringMode");
+    }
+} _registerCameraExposureMetaTypes;
+}
+
+
+
+class QCameraExposurePrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QCameraExposure)
+public:
+    void initControls();
+    QCameraExposure *q_ptr;
+
+    QCamera *camera;
+    QCameraExposureControl *exposureControl;
+    QCameraFlashControl *flashControl;
+
+    void _q_exposureParameterChanged(int parameter);
+    void _q_exposureParameterRangeChanged(int parameter);
+};
+
+void QCameraExposurePrivate::initControls()
+{
+    Q_Q(QCameraExposure);
+
+    QMediaService *service = camera->service();
+    exposureControl = 0;
+    flashControl = 0;
+    if (service) {
+        exposureControl = qobject_cast<QCameraExposureControl *>(service->requestControl(QCameraExposureControl_iid));
+        flashControl = qobject_cast<QCameraFlashControl *>(service->requestControl(QCameraFlashControl_iid));
+    }
+    if (exposureControl) {
+        q->connect(exposureControl, SIGNAL(exposureParameterChanged(int)),
+                   q, SLOT(_q_exposureParameterChanged(int)));
+        q->connect(exposureControl, SIGNAL(exposureParameterRangeChanged(int)),
+                   q, SLOT(_q_exposureParameterRangeChanged(int)));
+    }
+
+    if (flashControl)
+        q->connect(flashControl, SIGNAL(flashReady(bool)), q, SIGNAL(flashReady(bool)));
+}
+
+void QCameraExposurePrivate::_q_exposureParameterChanged(int parameter)
+{
+    Q_Q(QCameraExposure);
+
+#if DEBUG_EXPOSURE_CHANGES
+    qDebug() << "Exposure parameter changed:"
+             << ENUM_NAME(QCameraExposureControl, "ExposureParameter", parameter)
+             << exposureControl->exposureParameter(QCameraExposureControl::ExposureParameter(parameter));
+#endif
+
+    switch (parameter) {
+    case QCameraExposureControl::ISO:
+        emit q->isoSensitivityChanged(q->isoSensitivity());
+        break;
+    case QCameraExposureControl::Aperture:
+        emit q->apertureChanged(q->aperture());
+        break;
+    case QCameraExposureControl::ShutterSpeed:
+        emit q->shutterSpeedChanged(q->shutterSpeed());
+        break;
+    case QCameraExposureControl::ExposureCompensation:
+        emit q->exposureCompensationChanged(q->exposureCompensation());
+        break;
+    }
+}
+
+void QCameraExposurePrivate::_q_exposureParameterRangeChanged(int parameter)
+{
+    Q_Q(QCameraExposure);
+
+    switch (parameter) {
+    case QCameraExposureControl::Aperture:
+        emit q->apertureRangeChanged();
+        break;
+    case QCameraExposureControl::ShutterSpeed:
+        emit q->shutterSpeedRangeChanged();
+        break;
+    }
+}
+
+/*!
+    Construct a QCameraExposure from service \a provider and \a parent.
+*/
+
+QCameraExposure::QCameraExposure(QCamera *parent):
+    QObject(parent), d_ptr(new QCameraExposurePrivate)
+{
+    Q_D(QCameraExposure);
+    d->camera = parent;
+    d->q_ptr = this;
+    d->initControls();
+}
+
+
+/*!
+    Destroys the camera exposure object.
+*/
+
+QCameraExposure::~QCameraExposure()
+{
+    Q_D(QCameraExposure);
+    if (d->exposureControl)
+        d->camera->service()->releaseControl(d->exposureControl);
+}
+
+/*!
+    Returns true if exposure settings are supported by this camera.
+    \since 1.1
+*/
+bool QCameraExposure::isAvailable() const
+{
+    return d_func()->exposureControl != 0;
+}
+
+
+/*!
+  \property QCameraExposure::flashMode
+  \brief The flash mode being used.
+
+  Usually the single QCameraExposure::FlashMode flag is used,
+  but some non conflicting flags combination are also allowed,
+  like QCameraExposure::FlashManual | QCameraExposure::FlashSlowSyncRearCurtain.
+
+  \since 1.1
+  \sa QCameraExposure::isFlashModeSupported(), QCameraExposure::isFlashReady()
+*/
+
+QCameraExposure::FlashModes QCameraExposure::flashMode() const
+{
+    return d_func()->flashControl ? d_func()->flashControl->flashMode() : QCameraExposure::FlashOff;
+}
+
+void QCameraExposure::setFlashMode(QCameraExposure::FlashModes mode)
+{
+    if (d_func()->flashControl)
+        d_func()->flashControl->setFlashMode(mode);
+}
+
+/*!
+    Returns true if the flash \a mode is supported.
+    \since 1.1
+*/
+
+bool QCameraExposure::isFlashModeSupported(QCameraExposure::FlashModes mode) const
+{
+    return d_func()->flashControl ? d_func()->flashControl->isFlashModeSupported(mode) : false;
+}
+
+/*!
+    Returns true if flash is charged.
+*/
+
+bool QCameraExposure::isFlashReady() const
+{
+    return d_func()->flashControl ? d_func()->flashControl->isFlashReady() : false;
+}
+
+
+/*!
+  \property QCameraExposure::exposureMode
+  \brief The exposure mode being used.
+
+  \since 1.1
+  \sa QCameraExposure::isExposureModeSupported()
+*/
+
+QCameraExposure::ExposureMode QCameraExposure::exposureMode() const
+{
+    return d_func()->exposureControl ? d_func()->exposureControl->exposureMode() : QCameraExposure::ExposureAuto;
+}
+
+void QCameraExposure::setExposureMode(QCameraExposure::ExposureMode mode)
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setExposureMode(mode);
+}
+
+/*!
+    Returns true if the exposure \a mode is supported.
+    \since 1.1
+*/
+
+bool QCameraExposure::isExposureModeSupported(QCameraExposure::ExposureMode mode) const
+{
+    return d_func()->exposureControl ?
+            d_func()->exposureControl->isExposureModeSupported(mode) : false;
+}
+
+/*!
+  \property QCameraExposure::exposureCompensation
+  \brief Exposure compensation in EV units.
+
+  Exposure compensation property allows to adjust the automatically calculated exposure.
+  \since 1.1
+*/
+
+qreal QCameraExposure::exposureCompensation() const
+{
+    if (d_func()->exposureControl)
+        return d_func()->exposureControl->exposureParameter(QCameraExposureControl::ExposureCompensation).toReal();
+    else
+        return 0;
+}
+
+void QCameraExposure::setExposureCompensation(qreal ev)
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ExposureCompensation, QVariant(ev));
+}
+
+/*!
+  \property QCameraExposure::meteringMode
+  \brief The metering mode being used.
+
+  \since 1.1
+  \sa QCameraExposure::isMeteringModeSupported()
+*/
+
+QCameraExposure::MeteringMode QCameraExposure::meteringMode() const
+{
+    return d_func()->exposureControl ? d_func()->exposureControl->meteringMode() : QCameraExposure::MeteringMatrix;
+}
+
+void QCameraExposure::setMeteringMode(QCameraExposure::MeteringMode mode)
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setMeteringMode(mode);
+}
+
+/*!
+    Returns true if the metering \a mode is supported.
+    \since 1.1
+*/
+bool QCameraExposure::isMeteringModeSupported(QCameraExposure::MeteringMode mode) const
+{
+    return d_func()->exposureControl ? d_func()->exposureControl->isMeteringModeSupported(mode) : false;
+}
+
+int QCameraExposure::isoSensitivity() const
+{
+    if (d_func()->exposureControl)
+        return d_func()->exposureControl->exposureParameter(QCameraExposureControl::ISO).toInt();
+
+    return -1;
+}
+
+/*!
+    Returns the list of ISO senitivities camera supports.
+
+    If the camera supports arbitrary ISO sensitivities within the supported range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+    \since 1.1
+*/
+QList<int> QCameraExposure::supportedIsoSensitivities(bool *continuous) const
+{
+    QList<int> res;
+    QCameraExposureControl *control = d_func()->exposureControl;
+
+    if (!control)
+        return res;
+
+    foreach (const QVariant &value,
+             control->supportedParameterRange(QCameraExposureControl::ISO)) {
+        bool ok = false;
+        int intValue = value.toInt(&ok);
+        if (ok)
+            res.append(intValue);
+        else
+            qWarning() << "Incompatible ISO value type, int is expected";
+    }
+
+    if (continuous)
+        *continuous = control->exposureParameterFlags(QCameraExposureControl::ISO) &
+                      QCameraExposureControl::ContinuousRange;
+
+    return res;
+}
+
+/*!
+    \fn QCameraExposure::setManualIsoSensitivity(int iso)
+    Sets the manual sensitivity to \a iso
+    \since 1.1
+*/
+
+void QCameraExposure::setManualIsoSensitivity(int iso)
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ISO, QVariant(iso));
+}
+
+/*!
+     \fn QCameraExposure::setAutoIsoSensitivity()
+     Turn on auto sensitivity
+    \since 1.1
+*/
+
+void QCameraExposure::setAutoIsoSensitivity()
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ISO, QVariant());
+}
+
+/*!
+    \property QCameraExposure::shutterSpeed
+    \brief Camera's shutter speed in seconds.
+
+    \since 1.1
+    \sa supportedShutterSpeeds(), setAutoShutterSpeed(), setManualShutterSpeed()
+*/
+
+/*!
+    \fn QCameraExposure::shutterSpeedChanged(qreal speed)
+
+    Signals that a camera's shutter \a speed has changed.
+    \since 1.1
+*/
+
+/*!
+    \property QCameraExposure::isoSensitivity
+    \brief The sensor ISO sensitivity.
+
+    \sa supportedIsoSensitivities(), setAutoIsoSensitivity(), setManualIsoSensitivity()
+    \since 1.1
+*/
+
+/*!
+    \property QCameraExposure::aperture
+    \brief Lens aperture is specified as an F number, the ratio of the focal length to effective aperture diameter.
+
+    \since 1.1
+    \sa supportedApertures(), setAutoAperture(), setManualAperture()
+*/
+
+
+qreal QCameraExposure::aperture() const
+{
+    if (d_func()->exposureControl)
+        return d_func()->exposureControl->exposureParameter(QCameraExposureControl::Aperture).toReal();
+
+    return -1.0;
+}
+
+/*!
+    Returns the list of aperture values camera supports.
+    The apertures list can change depending on the focal length,
+    in such a case the apertureRangeChanged() signal is emitted.
+
+    If the camera supports arbitrary aperture values within the supported range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+    \since 1.1
+*/
+QList<qreal> QCameraExposure::supportedApertures(bool * continuous) const
+{
+    QList<qreal> res;
+    QCameraExposureControl *control = d_func()->exposureControl;
+
+    if (!control)
+        return res;
+
+    foreach (const QVariant &value,
+             control->supportedParameterRange(QCameraExposureControl::Aperture)) {
+        bool ok = false;
+        qreal realValue = value.toReal(&ok);
+        if (ok)
+            res.append(realValue);
+        else
+            qWarning() << "Incompatible aperture value type, qreal is expected";
+    }
+
+    if (continuous)
+        *continuous = control->exposureParameterFlags(QCameraExposureControl::Aperture) &
+                      QCameraExposureControl::ContinuousRange;
+
+    return res;
+}
+
+/*!
+    \fn QCameraExposure::setManualAperture(qreal aperture)
+    Sets the manual camera \a aperture value.
+    \since 1.1
+*/
+
+void QCameraExposure::setManualAperture(qreal aperture)
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::Aperture, QVariant(aperture));
+}
+
+/*!
+    \fn QCameraExposure::setAutoAperture()
+    Turn on auto aperture
+    \since 1.1
+*/
+
+void QCameraExposure::setAutoAperture()
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::Aperture, QVariant());
+}
+
+/*!
+    Returns the current shutter speed in seconds.
+    \since 1.1
+*/
+
+qreal QCameraExposure::shutterSpeed() const
+{
+    if (d_func()->exposureControl)
+        return d_func()->exposureControl->exposureParameter(QCameraExposureControl::ShutterSpeed).toReal();
+
+    return -1.0;
+}
+
+/*!
+    Returns the list of shutter speed values in seconds camera supports.
+
+    If the camera supports arbitrary shutter speed values within the supported range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+    \since 1.1
+*/
+QList<qreal> QCameraExposure::supportedShutterSpeeds(bool *continuous) const
+{
+    QList<qreal> res;
+
+    QCameraExposureControl *control = d_func()->exposureControl;
+    if (!control)
+        return res;
+
+    foreach (const QVariant &value,
+             control->supportedParameterRange(QCameraExposureControl::ShutterSpeed)) {
+        bool ok = false;
+        qreal realValue = value.toReal(&ok);
+        if (ok)
+            res.append(realValue);
+        else
+            qWarning() << "Incompatible shutter speed value type, qreal is expected";
+    }
+
+    if (continuous)
+        *continuous = control->exposureParameterFlags(QCameraExposureControl::ShutterSpeed) &
+                      QCameraExposureControl::ContinuousRange;
+
+    return res;
+}
+
+/*!
+    Set the manual shutter speed to \a seconds
+    \since 1.1
+*/
+
+void QCameraExposure::setManualShutterSpeed(qreal seconds)
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ShutterSpeed, QVariant(seconds));
+}
+
+/*!
+    Turn on auto shutter speed
+    \since 1.1
+*/
+
+void QCameraExposure::setAutoShutterSpeed()
+{
+    if (d_func()->exposureControl)
+        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ShutterSpeed, QVariant());
+}
+
+
+/*!
+    \enum QCameraExposure::FlashMode
+
+    \value FlashOff             Flash is Off.
+    \value FlashOn              Flash is On.
+    \value FlashAuto            Automatic flash.
+    \value FlashRedEyeReduction Red eye reduction flash.
+    \value FlashFill            Use flash to fillin shadows.
+    \value FlashTorch           Constant light source, useful for focusing and video capture.
+    \value FlashSlowSyncFrontCurtain
+                                Use the flash in conjunction with a slow shutter speed.
+                                This mode allows better exposure of distant objects and/or motion blur effect.
+    \value FlashSlowSyncRearCurtain
+                                The similar mode to FlashSlowSyncFrontCurtain but flash is fired at the end of exposure.
+    \value FlashManual          Flash power is manualy set.
+*/
+
+/*!
+    \enum QCameraExposure::ExposureMode
+
+    \value ExposureManual        Manual mode.
+    \value ExposureAuto          Automatic mode.
+    \value ExposureNight         Night mode.
+    \value ExposureBacklight     Backlight exposure mode.
+    \value ExposureSpotlight     Spotlight exposure mode.
+    \value ExposureSports        Spots exposure mode.
+    \value ExposureSnow          Snow exposure mode.
+    \value ExposureBeach         Beach exposure mode.
+    \value ExposureLargeAperture Use larger aperture with small depth of field.
+    \value ExposureSmallAperture Use smaller aperture.
+    \value ExposurePortrait      Portrait exposure mode.
+    \value ExposureModeVendor    The base value for device specific exposure modes.
+*/
+
+/*!
+    \enum QCameraExposure::MeteringMode
+
+    \value MeteringAverage       Center weighted average metering mode.
+    \value MeteringSpot          Spot metering mode.
+    \value MeteringMatrix        Matrix metering mode.
+*/
+
+/*!
+    \property QCameraExposure::flashReady
+    \brief Indicates if the flash is charged and ready to use.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraExposure::flashReady(bool ready)
+
+    Signal the flash \a ready status has changed.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraExposure::apertureChanged(qreal value)
+
+    Signal emitted when aperature changes to \a value.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraExposure::apertureRangeChanged()
+
+    Signal emitted when aperature range has changed.
+    \since 1.1
+*/
+
+
+/*!
+    \fn void QCameraExposure::shutterSpeedRangeChanged()
+
+    Signal emitted when the shutter speed range has changed.
+    \since 1.1
+*/
+
+
+/*!
+    \fn void QCameraExposure::isoSensitivityChanged(int value)
+
+    Signal emitted when sensitivity changes to \a value.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraExposure::exposureCompensationChanged(qreal value)
+
+    Signal emitted when the exposure compensation changes to \a value.
+    \since 1.1
+*/
+
+#include "moc_qcameraexposure.cpp"
+QT_END_NAMESPACE
diff --git a/src/multimedia/camera/qcameraexposure.h b/src/multimedia/camera/qcameraexposure.h
new file mode 100644
index 0000000..088e7c0
--- /dev/null
+++ b/src/multimedia/camera/qcameraexposure.h
@@ -0,0 +1,185 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAEXPOSURE_H
+#define QCAMERAEXPOSURE_H
+
+#include <qmediaobject.h>
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QCamera;
+class QCameraExposurePrivate;
+
+class Q_MULTIMEDIA_EXPORT QCameraExposure : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(qreal aperture READ aperture NOTIFY apertureChanged)
+    Q_PROPERTY(qreal shutterSpeed READ shutterSpeed NOTIFY shutterSpeedChanged)
+    Q_PROPERTY(int isoSensitivity READ isoSensitivity NOTIFY isoSensitivityChanged)
+    Q_PROPERTY(qreal exposureCompensation READ exposureCompensation WRITE setExposureCompensation NOTIFY exposureCompensationChanged)
+    Q_PROPERTY(bool flashReady READ isFlashReady NOTIFY flashReady)
+    Q_PROPERTY(QCameraExposure::FlashModes flashMode READ flashMode WRITE setFlashMode)
+    Q_PROPERTY(QCameraExposure::ExposureMode exposureMode READ exposureMode WRITE setExposureMode)
+    Q_PROPERTY(QCameraExposure::MeteringMode meteringMode READ meteringMode WRITE setMeteringMode)
+
+    Q_ENUMS(FlashMode)
+    Q_ENUMS(ExposureMode)
+    Q_ENUMS(MeteringMode)
+public:
+    enum FlashMode {
+        FlashAuto = 0x1,
+        FlashOff = 0x2,
+        FlashOn = 0x4,
+        FlashRedEyeReduction  = 0x8,
+        FlashFill = 0x10,
+        FlashTorch = 0x20,
+        FlashSlowSyncFrontCurtain = 0x40,
+        FlashSlowSyncRearCurtain = 0x80,
+        FlashManual = 0x100
+    };
+    Q_DECLARE_FLAGS(FlashModes, FlashMode)
+
+    enum ExposureMode {
+        ExposureAuto = 0,
+        ExposureManual = 1,
+        ExposurePortrait = 2,
+        ExposureNight = 3,
+        ExposureBacklight = 4,
+        ExposureSpotlight = 5,
+        ExposureSports = 6,
+        ExposureSnow = 7,
+        ExposureBeach = 8,
+        ExposureLargeAperture = 9,
+        ExposureSmallAperture = 10,
+        ExposureModeVendor = 1000
+    };
+
+    enum MeteringMode {
+        MeteringMatrix = 1,
+        MeteringAverage = 2,
+        MeteringSpot = 3
+    };
+
+    bool isAvailable() const;
+
+    FlashModes flashMode() const;
+    bool isFlashModeSupported(FlashModes mode) const;
+    bool isFlashReady() const;
+
+    ExposureMode exposureMode() const;
+    bool isExposureModeSupported(ExposureMode mode) const;
+
+    qreal exposureCompensation() const;
+
+    MeteringMode meteringMode() const;
+
+    bool isMeteringModeSupported(MeteringMode mode) const;
+
+    int isoSensitivity() const;
+    QList<int> supportedIsoSensitivities(bool *continuous = 0) const;
+
+    qreal aperture() const;
+    QList<qreal> supportedApertures(bool *continuous = 0) const;
+
+    qreal shutterSpeed() const;
+    QList<qreal> supportedShutterSpeeds(bool *continuous = 0) const;
+
+public Q_SLOTS:
+    void setFlashMode(FlashModes mode);
+    void setExposureMode(ExposureMode mode);
+
+    void setExposureCompensation(qreal ev);
+
+    void setMeteringMode(MeteringMode mode);
+
+    void setManualIsoSensitivity(int iso);
+    void setAutoIsoSensitivity();
+
+    void setManualAperture(qreal aperture);
+    void setAutoAperture();
+
+    void setManualShutterSpeed(qreal seconds);
+    void setAutoShutterSpeed();
+
+Q_SIGNALS:
+    void flashReady(bool);
+
+    void apertureChanged(qreal);
+    void apertureRangeChanged();
+    void shutterSpeedChanged(qreal);
+    void shutterSpeedRangeChanged();
+    void isoSensitivityChanged(int);
+    void exposureCompensationChanged(qreal);
+
+private:
+    friend class QCamera;
+    explicit QCameraExposure(QCamera *parent = 0);
+    virtual ~QCameraExposure();
+
+    Q_DISABLE_COPY(QCameraExposure)
+    Q_DECLARE_PRIVATE(QCameraExposure)
+    Q_PRIVATE_SLOT(d_func(), void _q_exposureParameterChanged(int))
+    Q_PRIVATE_SLOT(d_func(), void _q_exposureParameterRangeChanged(int))
+    QCameraExposurePrivate *d_ptr;
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCameraExposure::FlashModes)
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QCameraExposure::ExposureMode)
+Q_DECLARE_METATYPE(QCameraExposure::FlashModes)
+Q_DECLARE_METATYPE(QCameraExposure::MeteringMode)
+
+Q_MEDIA_ENUM_DEBUG(QCameraExposure, ExposureMode)
+Q_MEDIA_ENUM_DEBUG(QCameraExposure, FlashMode)
+Q_MEDIA_ENUM_DEBUG(QCameraExposure, MeteringMode)
+
+QT_END_HEADER
+
+#endif // QCAMERAEXPOSURE_H
diff --git a/src/multimedia/camera/qcamerafocus.cpp b/src/multimedia/camera/qcamerafocus.cpp
new file mode 100644
index 0000000..9b9caed
--- /dev/null
+++ b/src/multimedia/camera/qcamerafocus.cpp
@@ -0,0 +1,478 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qcamerafocus.h"
+#include "qmediaobject_p.h"
+
+#include <qcamera.h>
+#include <qcameracontrol.h>
+#include <qcameraexposurecontrol.h>
+#include <qcamerafocuscontrol.h>
+#include <qmediarecordercontrol.h>
+#include <qcameraimagecapturecontrol.h>
+#include <qvideodevicecontrol.h>
+
+#include <QtCore/QDebug>
+
+QT_BEGIN_NAMESPACE
+
+namespace
+{
+class CameraFocusRegisterMetaTypes
+{
+public:
+    CameraFocusRegisterMetaTypes()
+    {
+        qRegisterMetaType<QCameraFocus::FocusModes>("QCameraFocus::FocusModes");
+        qRegisterMetaType<QCameraFocus::FocusPointMode>("QCameraFocus::FocusPointMode");
+    }
+} _registerCameraFocusMetaTypes;
+}
+
+
+class QCameraFocusZoneData : public QSharedData
+{
+public:
+    QCameraFocusZoneData():
+        status(QCameraFocusZone::Invalid)
+    {
+
+    }
+
+    QCameraFocusZoneData(const QRectF &_area, QCameraFocusZone::FocusZoneStatus _status):
+        area(_area),
+        status(_status)
+    {
+
+    }
+
+
+    QCameraFocusZoneData(const QCameraFocusZoneData &other):
+        QSharedData(other),
+        area(other.area),
+        status(other.status)
+    {
+    }
+
+    QCameraFocusZoneData& operator=(const QCameraFocusZoneData &other)
+    {
+        area = other.area;
+        status = other.status;
+        return *this;
+    }
+
+    QRectF area;
+    QCameraFocusZone::FocusZoneStatus status;
+};
+
+QCameraFocusZone::QCameraFocusZone()
+    :d(new QCameraFocusZoneData)
+{
+
+}
+
+QCameraFocusZone::QCameraFocusZone(const QRectF &area, QCameraFocusZone::FocusZoneStatus status)
+    :d(new QCameraFocusZoneData(area, status))
+{
+}
+
+QCameraFocusZone::QCameraFocusZone(const QCameraFocusZone &other)
+    :d(other.d)
+{
+
+}
+
+QCameraFocusZone::~QCameraFocusZone()
+{
+
+}
+
+QCameraFocusZone& QCameraFocusZone::operator=(const QCameraFocusZone &other)
+{
+    d = other.d;
+    return *this;
+}
+
+bool QCameraFocusZone::operator==(const QCameraFocusZone &other) const
+{
+    return d == other.d ||
+           (d->area == other.d->area && d->status == other.d->status);
+}
+
+bool QCameraFocusZone::operator!=(const QCameraFocusZone &other) const
+{
+    return !(*this == other);
+}
+
+bool QCameraFocusZone::isValid() const
+{
+    return d->status != Invalid && !d->area.isValid();
+}
+
+QRectF QCameraFocusZone::area() const
+{
+    return d->area;
+}
+
+QCameraFocusZone::FocusZoneStatus QCameraFocusZone::status() const
+{
+    return d->status;
+}
+
+void QCameraFocusZone::setStatus(QCameraFocusZone::FocusZoneStatus status)
+{
+    d->status = status;
+}
+
+
+/*!
+    \class QCameraFocus
+
+
+    \brief The QCameraFocus class provides interface for
+    focus and zoom related camera settings.
+
+    \inmodule QtMultimedia
+    \ingroup camera
+    \since 1.1
+
+*/
+
+
+class QCameraFocusPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QCameraFocus)
+public:
+    void initControls();
+
+    QCameraFocus *q_ptr;
+
+    QCamera *camera;
+    QCameraFocusControl *focusControl;
+};
+
+
+void QCameraFocusPrivate::initControls()
+{
+    Q_Q(QCameraFocus);
+
+    focusControl = 0;
+
+    QMediaService *service = camera->service();
+    if (service)
+        focusControl = qobject_cast<QCameraFocusControl *>(service->requestControl(QCameraFocusControl_iid));
+
+    if (focusControl) {
+        q->connect(focusControl, SIGNAL(opticalZoomChanged(qreal)), q, SIGNAL(opticalZoomChanged(qreal)));
+        q->connect(focusControl, SIGNAL(digitalZoomChanged(qreal)), q, SIGNAL(digitalZoomChanged(qreal)));
+        q->connect(focusControl, SIGNAL(maximumOpticalZoomChanged(qreal)),
+                   q, SIGNAL(maximumOpticalZoomChanged(qreal)));
+        q->connect(focusControl, SIGNAL(maximumDigitalZoomChanged(qreal)),
+                   q, SIGNAL(maximumDigitalZoomChanged(qreal)));
+        q->connect(focusControl, SIGNAL(focusZonesChanged()), q, SIGNAL(focusZonesChanged()));
+    }
+}
+
+/*!
+    Construct a QCameraFocus for \a camera.
+*/
+
+QCameraFocus::QCameraFocus(QCamera *camera):
+    QObject(camera), d_ptr(new QCameraFocusPrivate)
+{
+    Q_D(QCameraFocus);
+    d->camera = camera;
+    d->q_ptr = this;
+    d->initControls();
+}
+
+
+/*!
+    Destroys the camera focus object.
+*/
+
+QCameraFocus::~QCameraFocus()
+{
+}
+
+/*!
+    Returns true if focus related settings are supported by this camera.
+    \since 1.1
+*/
+bool QCameraFocus::isAvailable() const
+{
+    return d_func()->focusControl != 0;
+}
+
+/*!
+  \property QCameraFocus::focusMode
+  \brief The current camera focus mode.
+
+  \since 1.1
+  \sa QCameraFocus::isFocusModeSupported()
+*/
+
+QCameraFocus::FocusMode QCameraFocus::focusMode() const
+{
+    return d_func()->focusControl ? d_func()->focusControl->focusMode() : QCameraFocus::AutoFocus;
+}
+
+void QCameraFocus::setFocusMode(QCameraFocus::FocusMode mode)
+{
+    if (d_func()->focusControl)
+        d_func()->focusControl->setFocusMode(mode);
+}
+
+/*!
+    Returns true if the focus \a mode is supported by camera.
+    \since 1.1
+*/
+
+bool QCameraFocus::isFocusModeSupported(QCameraFocus::FocusMode mode) const
+{
+    return d_func()->focusControl ? d_func()->focusControl->isFocusModeSupported(mode) : false;
+}
+
+/*!
+  \property QCameraFocus::focusPointMode
+  \brief The current camera focus point selection mode.
+
+  \sa QCameraFocus::isFocusPointModeSupported()
+  \since 1.1
+*/
+
+QCameraFocus::FocusPointMode QCameraFocus::focusPointMode() const
+{
+    return d_func()->focusControl ?
+            d_func()->focusControl->focusPointMode() :
+            QCameraFocus::FocusPointAuto;
+}
+
+void QCameraFocus::setFocusPointMode(QCameraFocus::FocusPointMode mode)
+{
+    if (d_func()->focusControl)
+        d_func()->focusControl->setFocusPointMode(mode);
+    else
+        qWarning("Focus points mode selection is not supported");
+}
+
+/*!
+  Returns true if focus point \a mode is supported.
+  \since 1.1
+ */
+bool QCameraFocus::isFocusPointModeSupported(QCameraFocus::FocusPointMode mode) const
+{
+    return d_func()->focusControl ?
+            d_func()->focusControl->isFocusPointModeSupported(mode) :
+            false;
+
+}
+
+/*!
+  \property QCameraFocus::customFocusPoint
+
+  Position of custom focus point, in relative frame coordinates:
+  QPointF(0,0) points to the left top frame point, QPointF(0.5,0.5) points to the frame center.
+
+  Custom focus point is used only in FocusPointCustom focus mode.
+  \since 1.1
+ */
+
+QPointF QCameraFocus::customFocusPoint() const
+{
+    return d_func()->focusControl ?
+            d_func()->focusControl->customFocusPoint() :
+            QPointF(0.5,0.5);
+}
+
+void QCameraFocus::setCustomFocusPoint(const QPointF &point)
+{
+    if (d_func()->focusControl)
+        d_func()->focusControl->setCustomFocusPoint(point);
+    else
+        qWarning("Focus points selection is not supported");
+
+}
+
+/*!
+  \property QCameraFocus::focusZones
+
+  Returns the list of active focus zones.
+
+  If QCamera::FocusPointAuto or QCamera::FocusPointFaceDetection focus mode is selected
+  this method returns the list of zones the camera is actually focused on.
+
+  The coordinates system is the same as for custom focus points:
+  QPointF(0,0) points to the left top frame point, QPointF(0.5,0.5) points to the frame center.
+  \since 1.1
+ */
+QCameraFocusZoneList QCameraFocus::focusZones() const
+{
+    return d_func()->focusControl ?
+            d_func()->focusControl->focusZones() :
+            QCameraFocusZoneList();
+}
+
+/*!
+    Returns the maximum optical zoom
+    \since 1.1
+*/
+
+qreal QCameraFocus::maximumOpticalZoom() const
+{
+    return d_func()->focusControl ? d_func()->focusControl->maximumOpticalZoom() : 1.0;
+}
+
+/*!
+    Returns the maximum digital zoom
+    \since 1.1
+*/
+
+qreal QCameraFocus::maximumDigitalZoom() const
+{
+    return d_func()->focusControl ? d_func()->focusControl->maximumDigitalZoom() : 1.0;
+}
+
+/*!
+  \property QCameraFocus::opticalZoom
+  \brief The current optical zoom value.
+
+  \since 1.1
+  \sa QCameraFocus::digitalZoom
+*/
+
+qreal QCameraFocus::opticalZoom() const
+{
+    return d_func()->focusControl ? d_func()->focusControl->opticalZoom() : 1.0;
+}
+
+/*!
+  \property QCameraFocus::digitalZoom
+  \brief The current digital zoom value.
+
+  \since 1.1
+  \sa QCameraFocus::opticalZoom
+*/
+qreal QCameraFocus::digitalZoom() const
+{
+    return d_func()->focusControl ? d_func()->focusControl->digitalZoom() : 1.0;
+}
+
+
+/*!
+    Set the camera \a optical and \a digital zoom values.
+    \since 1.1
+*/
+void QCameraFocus::zoomTo(qreal optical, qreal digital)
+{
+    if (d_func()->focusControl)
+        d_func()->focusControl->zoomTo(optical, digital);
+    else
+        qWarning("The camera doesn't support zooming.");
+}
+
+/*!
+    \enum QCameraFocus::FocusMode
+
+    \value ManualFocus          Manual or fixed focus mode.
+    \value AutoFocus            One-shot auto focus mode.
+    \value ContinuousFocus      Continuous auto focus mode.
+    \value InfinityFocus        Focus strictly to infinity.
+    \value HyperfocalFocus      Focus to hyperfocal distance, with with the maximum depth of field achieved.
+                                All objects at distances from half of this
+                                distance out to infinity will be acceptably sharp.
+    \value MacroFocus           One shot auto focus to objects close to camera.
+*/
+
+/*!
+    \enum QCameraFocus::FocusPointMode
+
+    \value FocusPointAuto       Automatically select one or multiple focus points.
+    \value FocusPointCenter     Focus to the frame center.
+    \value FocusPointFaceDetection Focus on faces in the frame.
+    \value FocusPointCustom     Focus to the custom point, defined by QCameraFocus::customFocusPoint property.
+*/
+
+/*!
+    \fn void QCameraFocus::opticalZoomChanged(qreal value)
+
+    Signal emitted when optical zoom value changes to new \a value.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraFocus::digitalZoomChanged(qreal value)
+
+    Signal emitted when digital zoom value changes to new \a value.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraFocus::maximumOpticalZoomChanged(qreal zoom)
+
+    Signal emitted when the maximum supported optical \a zoom value changed.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraFocus::maximumDigitalZoomChanged(qreal zoom)
+
+    Signal emitted when the maximum supported digital \a zoom value changed.
+
+    The maximum supported zoom value can depend on other camera settings,
+    like capture mode or resolution.
+    \since 1.1
+*/
+
+
+
+/*!
+  \fn QCameraFocus::focusZonesChanged()
+
+  Signal is emitted when the set of zones, camera focused on is changed.
+
+  Usually the zones list is changed when the camera is focused.
+  \since 1.1
+*/
+
+
+#include "moc_qcamerafocus.cpp"
+QT_END_NAMESPACE
diff --git a/src/multimedia/camera/qcamerafocus.h b/src/multimedia/camera/qcamerafocus.h
new file mode 100644
index 0000000..064af7a
--- /dev/null
+++ b/src/multimedia/camera/qcamerafocus.h
@@ -0,0 +1,183 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAFOCUS_H
+#define QCAMERAFOCUS_H
+
+#include <QtCore/qstringlist.h>
+#include <QtCore/qpair.h>
+#include <QtCore/qsize.h>
+#include <QtCore/qpoint.h>
+#include <QtCore/qrect.h>
+#include <QtCore/qshareddata.h>
+
+#include <qmediaobject.h>
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QCamera;
+
+class QCameraFocusZoneData;
+
+class Q_MULTIMEDIA_EXPORT QCameraFocusZone {
+public:
+    enum FocusZoneStatus {
+        Invalid,
+        Unused,
+        Selected,
+        Focused
+    };
+
+    QCameraFocusZone();
+    QCameraFocusZone(const QRectF &area, FocusZoneStatus status = Selected);
+    QCameraFocusZone(const QCameraFocusZone &other);
+
+    QCameraFocusZone& operator=(const QCameraFocusZone &other);
+    bool operator==(const QCameraFocusZone &other) const;
+    bool operator!=(const QCameraFocusZone &other) const;
+
+    ~QCameraFocusZone();
+
+    bool isValid() const;
+
+    QRectF area() const;
+
+    FocusZoneStatus status() const;
+    void setStatus(FocusZoneStatus status);
+
+private:
+     QSharedDataPointer<QCameraFocusZoneData> d;
+};
+
+typedef QList<QCameraFocusZone> QCameraFocusZoneList;
+
+
+class QCameraFocusPrivate;
+class Q_MULTIMEDIA_EXPORT QCameraFocus : public QObject
+{
+    Q_OBJECT
+
+    Q_PROPERTY(FocusMode focusMode READ focusMode WRITE setFocusMode)
+    Q_PROPERTY(FocusPointMode focusPointMode READ focusPointMode WRITE setFocusPointMode)
+    Q_PROPERTY(QPointF customFocusPoint READ customFocusPoint WRITE setCustomFocusPoint)
+    Q_PROPERTY(QCameraFocusZoneList focusZones READ focusZones NOTIFY focusZonesChanged)
+    Q_PROPERTY(qreal opticalZoom READ opticalZoom NOTIFY opticalZoomChanged)
+    Q_PROPERTY(qreal digitalZoom READ digitalZoom NOTIFY digitalZoomChanged)
+
+    Q_ENUMS(FocusMode)
+    Q_ENUMS(FocusPointMode)
+public:
+    enum FocusMode {
+        ManualFocus = 0x1,
+        HyperfocalFocus = 0x02,
+        InfinityFocus = 0x04,
+        AutoFocus = 0x8,
+        ContinuousFocus = 0x10,
+        MacroFocus = 0x20
+    };
+    Q_DECLARE_FLAGS(FocusModes, FocusMode)
+
+    enum FocusPointMode {
+        FocusPointAuto,
+        FocusPointCenter,
+        FocusPointFaceDetection,
+        FocusPointCustom
+    };
+
+    bool isAvailable() const;
+
+    FocusMode focusMode() const;
+    void setFocusMode(FocusMode mode);
+    bool isFocusModeSupported(FocusMode mode) const;
+
+    FocusPointMode focusPointMode() const;
+    void setFocusPointMode(FocusPointMode mode);
+    bool isFocusPointModeSupported(FocusPointMode) const;
+    QPointF customFocusPoint() const;
+    void setCustomFocusPoint(const QPointF &point);
+
+    QCameraFocusZoneList focusZones() const;
+
+    qreal maximumOpticalZoom() const;
+    qreal maximumDigitalZoom() const;
+    qreal opticalZoom() const;
+    qreal digitalZoom() const;
+
+    void zoomTo(qreal opticalZoom, qreal digitalZoom);
+
+Q_SIGNALS:
+    void opticalZoomChanged(qreal);
+    void digitalZoomChanged(qreal);
+
+    void focusZonesChanged();
+
+    void maximumOpticalZoomChanged(qreal);
+    void maximumDigitalZoomChanged(qreal);
+
+private:
+    friend class QCamera;
+    QCameraFocus(QCamera *camera);
+    ~QCameraFocus();
+
+    Q_DISABLE_COPY(QCameraFocus)
+    Q_DECLARE_PRIVATE(QCameraFocus)
+    QCameraFocusPrivate *d_ptr;
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCameraFocus::FocusModes)
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QCameraFocus::FocusModes)
+Q_DECLARE_METATYPE(QCameraFocus::FocusPointMode)
+
+Q_MEDIA_ENUM_DEBUG(QCameraFocus, FocusMode)
+Q_MEDIA_ENUM_DEBUG(QCameraFocus, FocusPointMode)
+
+QT_END_HEADER
+
+#endif  // QCAMERAFOCUS_H
diff --git a/src/multimedia/camera/qcameraimagecapture.cpp b/src/multimedia/camera/qcameraimagecapture.cpp
new file mode 100644
index 0000000..f49531e
--- /dev/null
+++ b/src/multimedia/camera/qcameraimagecapture.cpp
@@ -0,0 +1,681 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qcameraimagecapture.h>
+#include <qcameraimagecapturecontrol.h>
+#include <qmediaencodersettings.h>
+#include <qcameracapturedestinationcontrol.h>
+#include <qcameracapturebufferformatcontrol.h>
+
+#include <qimageencodercontrol.h>
+#include "qmediaobject_p.h"
+#include <qmediaservice.h>
+#include <qcamera.h>
+#include <qcameracontrol.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qstringlist.h>
+#include <QtCore/qmetaobject.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraImageCapture
+    \inmodule QtMultimedia
+    \ingroup camera
+    \since 1.1
+
+
+    \brief The QCameraImageCapture class is used for the recording of media content.
+
+    The QCameraImageCapture class is a high level images recording class.
+    It's not intended to be used alone but for accessing the media
+    recording functions of other media objects, like QCamera.
+
+    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera
+
+    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera keys
+
+    \sa QCamera
+*/
+
+namespace
+{
+class MediaRecorderRegisterMetaTypes
+{
+public:
+    MediaRecorderRegisterMetaTypes()
+    {
+        qRegisterMetaType<QCameraImageCapture::Error>("QCameraImageCapture::Error");
+        qRegisterMetaType<QCameraImageCapture::CaptureDestination>("QCameraImageCapture::CaptureDestination");
+        qRegisterMetaType<QCameraImageCapture::CaptureDestinations>("QCameraImageCapture::CaptureDestinations");
+    }
+} _registerRecorderMetaTypes;
+}
+
+
+class QCameraImageCapturePrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QCameraImageCapture)
+public:
+    QCameraImageCapturePrivate();
+
+    QMediaObject *mediaObject;
+
+    QCameraImageCaptureControl *control;
+    QImageEncoderControl *encoderControl;
+    QCameraCaptureDestinationControl *captureDestinationControl;
+    QCameraCaptureBufferFormatControl *bufferFormatControl;
+
+    QCameraImageCapture::Error error;
+    QString errorString;
+
+    void _q_error(int id, int error, const QString &errorString);
+    void _q_readyChanged(bool);
+    void _q_serviceDestroyed();
+
+    void unsetError() { error = QCameraImageCapture::NoError; errorString.clear(); }
+
+    QCameraImageCapture *q_ptr;
+};
+
+QCameraImageCapturePrivate::QCameraImageCapturePrivate():
+     mediaObject(0),
+     control(0),
+     encoderControl(0),
+     captureDestinationControl(0),
+     bufferFormatControl(0),
+     error(QCameraImageCapture::NoError)
+{
+}
+
+void QCameraImageCapturePrivate::_q_error(int id, int error, const QString &errorString)
+{
+    Q_Q(QCameraImageCapture);
+
+    this->error = QCameraImageCapture::Error(error);
+    this->errorString = errorString;
+
+    emit q->error(id, this->error, errorString);
+}
+
+void QCameraImageCapturePrivate::_q_readyChanged(bool ready)
+{
+    Q_Q(QCameraImageCapture);
+    emit q->readyForCaptureChanged(ready);
+}
+
+void QCameraImageCapturePrivate::_q_serviceDestroyed()
+{
+    mediaObject = 0;
+    control = 0;
+    encoderControl = 0;
+    captureDestinationControl = 0;
+    bufferFormatControl = 0;
+}
+
+/*!
+    Constructs a media recorder which records the media produced by \a mediaObject.
+
+    The \a parent is passed to QMediaObject.
+*/
+
+QCameraImageCapture::QCameraImageCapture(QMediaObject *mediaObject, QObject *parent):
+    QObject(parent), d_ptr(new QCameraImageCapturePrivate)
+{
+    Q_D(QCameraImageCapture);
+
+    d->q_ptr = this;
+
+    if (mediaObject)
+        mediaObject->bind(this);
+}
+
+/*!
+    Destroys images capture object.
+*/
+
+QCameraImageCapture::~QCameraImageCapture()
+{
+    Q_D(QCameraImageCapture);
+
+    if (d->mediaObject)
+        d->mediaObject->unbind(this);
+}
+
+/*!
+  \reimp
+  \since 1.1
+*/
+QMediaObject *QCameraImageCapture::mediaObject() const
+{
+    return d_func()->mediaObject;
+}
+
+/*!
+  \reimp
+  \since 1.1
+*/
+bool QCameraImageCapture::setMediaObject(QMediaObject *mediaObject)
+{
+    Q_D(QCameraImageCapture);
+
+    if (d->mediaObject) {
+        if (d->control) {
+            disconnect(d->control, SIGNAL(imageExposed(int)),
+                       this, SIGNAL(imageExposed(int)));
+            disconnect(d->control, SIGNAL(imageCaptured(int,QImage)),
+                       this, SIGNAL(imageCaptured(int,QImage)));
+            disconnect(d->control, SIGNAL(imageAvailable(int,QVideoFrame)),
+                       this, SIGNAL(imageAvailable(int,QVideoFrame)));
+            disconnect(d->control, SIGNAL(imageMetadataAvailable(int,QtMultimedia::MetaData,QVariant)),
+                       this, SIGNAL(imageMetadataAvailable(int,QtMultimedia::MetaData,QVariant)));
+            disconnect(d->control, SIGNAL(imageMetadataAvailable(int,QString,QVariant)),
+                       this, SIGNAL(imageMetadataAvailable(int,QString,QVariant)));
+            disconnect(d->control, SIGNAL(imageSaved(int,QString)),
+                       this, SIGNAL(imageSaved(int,QString)));
+            disconnect(d->control, SIGNAL(readyForCaptureChanged(bool)),
+                       this, SLOT(_q_readyChanged(bool)));
+            disconnect(d->control, SIGNAL(error(int,int,QString)),
+                       this, SLOT(_q_error(int,int,QString)));
+
+            if (d->captureDestinationControl) {
+                disconnect(d->captureDestinationControl, SIGNAL(captureDestinationChanged(QCameraImageCapture::CaptureDestinations)),
+                           this, SIGNAL(captureDestinationChanged(QCameraImageCapture::CaptureDestinations)));
+            }
+
+            if (d->bufferFormatControl) {
+                disconnect(d->bufferFormatControl, SIGNAL(bufferFormatChanged(QVideoFrame::PixelFormat)),
+                           this, SIGNAL(bufferFormatChanged(QVideoFrame::PixelFormat)));
+            }
+
+            QMediaService *service = d->mediaObject->service();
+            service->releaseControl(d->control);
+            if (d->encoderControl)
+                service->releaseControl(d->encoderControl);
+            if (d->captureDestinationControl)
+                service->releaseControl(d->captureDestinationControl);
+            if (d->bufferFormatControl)
+                service->releaseControl(d->bufferFormatControl);
+
+            disconnect(service, SIGNAL(destroyed()), this, SLOT(_q_serviceDestroyed()));
+        }
+    }
+
+    d->mediaObject = mediaObject;
+
+    if (d->mediaObject) {
+        QMediaService *service = mediaObject->service();
+        if (service) {
+            d->control = qobject_cast<QCameraImageCaptureControl*>(service->requestControl(QCameraImageCaptureControl_iid));
+
+            if (d->control) {
+                d->encoderControl = qobject_cast<QImageEncoderControl *>(service->requestControl(QImageEncoderControl_iid));
+                d->captureDestinationControl = qobject_cast<QCameraCaptureDestinationControl *>(
+                    service->requestControl(QCameraCaptureDestinationControl_iid));
+                d->bufferFormatControl = qobject_cast<QCameraCaptureBufferFormatControl *>(
+                    service->requestControl(QCameraCaptureBufferFormatControl_iid));
+
+                connect(d->control, SIGNAL(imageExposed(int)),
+                        this, SIGNAL(imageExposed(int)));
+                connect(d->control, SIGNAL(imageCaptured(int,QImage)),
+                        this, SIGNAL(imageCaptured(int,QImage)));
+                connect(d->control, SIGNAL(imageMetadataAvailable(int,QtMultimedia::MetaData,QVariant)),
+                        this, SIGNAL(imageMetadataAvailable(int,QtMultimedia::MetaData,QVariant)));
+                connect(d->control, SIGNAL(imageMetadataAvailable(int,QString,QVariant)),
+                        this, SIGNAL(imageMetadataAvailable(int,QString,QVariant)));
+                connect(d->control, SIGNAL(imageAvailable(int,QVideoFrame)),
+                        this, SIGNAL(imageAvailable(int,QVideoFrame)));
+                connect(d->control, SIGNAL(imageSaved(int, QString)),
+                        this, SIGNAL(imageSaved(int, QString)));
+                connect(d->control, SIGNAL(readyForCaptureChanged(bool)),
+                        this, SLOT(_q_readyChanged(bool)));
+                connect(d->control, SIGNAL(error(int,int,QString)),
+                        this, SLOT(_q_error(int,int,QString)));
+
+                if (d->captureDestinationControl) {
+                    connect(d->captureDestinationControl, SIGNAL(captureDestinationChanged(QCameraImageCapture::CaptureDestinations)),
+                            this, SIGNAL(captureDestinationChanged(QCameraImageCapture::CaptureDestinations)));
+                }
+
+                if (d->bufferFormatControl) {
+                    connect(d->bufferFormatControl, SIGNAL(bufferFormatChanged(QVideoFrame::PixelFormat)),
+                            this, SIGNAL(bufferFormatChanged(QVideoFrame::PixelFormat)));
+                }
+
+                connect(service, SIGNAL(destroyed()), this, SLOT(_q_serviceDestroyed()));
+
+                return true;
+            }
+        }
+    }
+
+    // without QCameraImageCaptureControl discard the media object
+    d->mediaObject = 0;
+    d->control = 0;
+    d->encoderControl = 0;
+    d->captureDestinationControl = 0;
+    d->bufferFormatControl = 0;
+
+    return false;
+}
+
+/*!
+    Returns true if the images capture service ready to use.
+    \since 1.1
+*/
+bool QCameraImageCapture::isAvailable() const
+{
+    if (d_func()->control != NULL)
+        return true;
+    else
+        return false;
+}
+
+/*!
+    Returns the availability error code.
+    \since 1.1
+*/
+QtMultimedia::AvailabilityError QCameraImageCapture::availabilityError() const
+{
+    if (d_func()->control != NULL)
+        return QtMultimedia::NoError;
+    else
+        return QtMultimedia::ServiceMissingError;
+}
+
+/*!
+    Returns the current error state.
+
+    \since 1.1
+    \sa errorString()
+*/
+
+QCameraImageCapture::Error QCameraImageCapture::error() const
+{
+    return d_func()->error;
+}
+
+/*!
+    Returns a string describing the current error state.
+
+    \since 1.1
+    \sa error()
+*/
+
+QString QCameraImageCapture::errorString() const
+{
+    return d_func()->errorString;
+}
+
+
+/*!
+    Returns a list of supported image codecs.
+    \since 1.1
+*/
+QStringList QCameraImageCapture::supportedImageCodecs() const
+{
+    return d_func()->encoderControl ?
+           d_func()->encoderControl->supportedImageCodecs() : QStringList();
+}
+
+/*!
+    Returns a description of an image \a codec.
+    \since 1.1
+*/
+QString QCameraImageCapture::imageCodecDescription(const QString &codec) const
+{
+    return d_func()->encoderControl ?
+           d_func()->encoderControl->imageCodecDescription(codec) : QString();
+}
+
+/*!
+    Returns a list of resolutions images can be encoded at.
+
+    If non null image \a settings parameter is passed,
+    the returned list is reduced to resolution supported with partial settings like image codec or quality applied.
+
+    If the encoder supports arbitrary resolutions within the supported range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+
+    \since 1.1
+    \sa QImageEncoderSettings::resolution()
+*/
+QList<QSize> QCameraImageCapture::supportedResolutions(const QImageEncoderSettings &settings, bool *continuous) const
+{
+    if (continuous)
+        *continuous = false;
+
+    return d_func()->encoderControl ?
+           d_func()->encoderControl->supportedResolutions(settings, continuous) : QList<QSize>();
+}
+
+/*!
+    Returns the image encoder settings being used.
+
+    \since 1.1
+    \sa setEncodingSettings()
+*/
+
+QImageEncoderSettings QCameraImageCapture::encodingSettings() const
+{
+    return d_func()->encoderControl ?
+           d_func()->encoderControl->imageSettings() : QImageEncoderSettings();
+}
+
+/*!
+    Sets the image encoding \a settings.
+
+    If some parameters are not specified, or null settings are passed,
+    the encoder choose the default encoding parameters.
+
+    \since 1.1
+    \sa encodingSettings()
+*/
+
+void QCameraImageCapture::setEncodingSettings(const QImageEncoderSettings &settings)
+{
+    Q_D(QCameraImageCapture);
+
+    if (d->encoderControl) {
+        QCamera *camera = qobject_cast<QCamera*>(d->mediaObject);
+        if (camera && camera->captureMode() == QCamera::CaptureStillImage) {
+            QMetaObject::invokeMethod(camera,
+                                      "_q_preparePropertyChange",
+                                      Qt::DirectConnection,
+                                      Q_ARG(int, QCameraControl::ImageEncodingSettings));
+        }
+
+        d->encoderControl->setImageSettings(settings);
+    }
+}
+
+/*!
+    Returns the list of supported buffer image capture formats.
+
+    \since 1.1
+    \sa bufferFormat() setBufferFormat()
+*/
+QList<QVideoFrame::PixelFormat> QCameraImageCapture::supportedBufferFormats() const
+{
+    if (d_func()->bufferFormatControl)
+        return d_func()->bufferFormatControl->supportedBufferFormats();
+    else
+        return QList<QVideoFrame::PixelFormat>();
+}
+
+/*!
+    Returns the buffer image capture format being used.
+
+    \since 1.2
+    \sa supportedBufferCaptureFormats() setBufferCaptureFormat()
+*/
+QVideoFrame::PixelFormat QCameraImageCapture::bufferFormat() const
+{
+    if (d_func()->bufferFormatControl)
+        return d_func()->bufferFormatControl->bufferFormat();
+    else
+        return QVideoFrame::Format_Invalid;
+}
+
+/*!
+    Sets the buffer image capture format to be used.
+
+    \since 1.2
+    \sa bufferCaptureFormat() supportedBufferCaptureFormats() captureDestination()
+*/
+void QCameraImageCapture::setBufferFormat(const QVideoFrame::PixelFormat format)
+{
+    if (d_func()->bufferFormatControl)
+        d_func()->bufferFormatControl->setBufferFormat(format);
+}
+
+/*!
+    Returns true if the image capture \a destination is supported; otherwise returns false.
+
+    \since 1.2
+    \sa captureDestination() setCaptureDestination()
+*/
+bool QCameraImageCapture::isCaptureDestinationSupported(QCameraImageCapture::CaptureDestinations destination) const
+{
+    if (d_func()->captureDestinationControl)
+        return d_func()->captureDestinationControl->isCaptureDestinationSupported(destination);
+    else
+        return destination == CaptureToFile;
+}
+
+/*!
+    Returns the image capture destination being used.
+
+    \since 1.2
+    \sa isCaptureDestinationSupported() setCaptureDestination()
+*/
+QCameraImageCapture::CaptureDestinations QCameraImageCapture::captureDestination() const
+{
+    if (d_func()->captureDestinationControl)
+        return d_func()->captureDestinationControl->captureDestination();
+    else
+        return CaptureToFile;
+}
+
+/*!
+    Sets the capture \a destination to be used.
+
+    \since 1.2
+    \sa isCaptureDestinationSupported() captureDestination()
+*/
+void QCameraImageCapture::setCaptureDestination(QCameraImageCapture::CaptureDestinations destination)
+{
+    Q_D(QCameraImageCapture);
+
+    if (d->captureDestinationControl)
+        d->captureDestinationControl->setCaptureDestination(destination);
+}
+
+/*!
+  \property QCameraImageCapture::readyForCapture
+   Indicates the service is ready to capture a an image immediately.
+  \since 1.1
+*/
+
+bool QCameraImageCapture::isReadyForCapture() const
+{
+    if (d_func()->control)
+        return d_func()->control->isReadyForCapture();
+    else
+        return false;
+}
+
+/*!
+    \fn QCameraImageCapture::readyForCaptureChanged(bool ready)
+
+    Signals that a camera's \a ready for capture state has changed.
+    \since 1.1
+*/
+
+
+/*!
+    Capture the image and save it to \a file.
+    This operation is asynchronous in majority of cases,
+    followed by signals QCameraImageCapture::imageCaptured(), QCameraImageCapture::imageSaved()
+    or QCameraImageCapture::error().
+
+    If an empty \a file is passed, the camera backend choses
+    the default location and naming scheme for photos on the system,
+    if only file name without full path is specified, the image will be saved to
+    the default directory, with a full path reported with imageCaptured() and imageSaved() signals.
+
+    QCameraImageCapture::capture returns the capture Id parameter, used with
+    imageExposed(), imageCaptured() and imageSaved() signals.
+    \since 1.1
+*/
+int QCameraImageCapture::capture(const QString &file)
+{
+    Q_D(QCameraImageCapture);
+
+    d->unsetError();
+
+    if (d->control) {
+        return d->control->capture(file);
+    } else {
+        d->error = NotSupportedFeatureError;
+        d->errorString = tr("Device does not support images capture.");
+
+        emit error(-1, d->error, d->errorString);
+    }
+
+    return -1;
+}
+
+/*!
+    Cancel incomplete capture requests.
+    Already captured and queused for proicessing images may be discarded.
+    \since 1.1
+*/
+void QCameraImageCapture::cancelCapture()
+{
+    Q_D(QCameraImageCapture);
+
+    d->unsetError();
+
+    if (d->control) {
+        d->control->cancelCapture();
+    } else {
+        d->error = NotSupportedFeatureError;
+        d->errorString = tr("Device does not support images capture.");
+
+        emit error(-1, d->error, d->errorString);
+    }
+}
+
+
+/*!
+    \enum QCameraImageCapture::Error
+
+    \value NoError         No Errors.
+    \value NotReadyError   The service is not ready for capture yet.
+    \value ResourceError   Device is not ready or not available.
+    \value NotSupportedFeatureError Device does not support stillimages capture.
+    \value FormatError     Current format is not supported.
+    \value OutOfSpaceError No space left on device.
+*/
+
+/*!
+    \enum QCameraImageCapture::DriveMode
+
+    \value SingleImageCapture Drive mode is capturing a single picture.
+*/
+
+/*!
+    \fn QCameraImageCapture::error(int id, QCameraImageCapture::Error error, const QString &errorString)
+
+    Signals that the capture request \a id has failed with an \a error
+    and \a errorString description.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCapture::bufferFormatChanged(QVideoFrame::PixelFormat format)
+
+    Signal emitted when the buffer \a format for the buffer image capture has changed.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraImageCapture::captureDestinationChanged(CaptureDestinations destination)
+
+    Signal emitted when the capture \a destination has changed.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraImageCapture::imageExposed(int id)
+
+    Signal emitted when the frame with request \a id was exposed.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCapture::imageCaptured(int id, const QImage &preview);
+
+    Signal emitted when the frame with request \a id was captured, but not processed and saved yet.
+    Frame \a preview can be displayed to user.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCapture::imageMetadataAvailable(int id, QtMultimedia::MetaData key, const QVariant &value)
+
+    Signals that a metadata for an image with request \a id is available.
+    This signal is emitted for metadata \a value with a \a key listed in QtMultimedia::MetaData enum.
+
+    This signal is emitted between imageExposed and imageSaved signals.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraImageCapture::imageMetadataAvailable(int id, const QString &key, const QVariant &value)
+
+    Signals that a metadata for an image with request \a id is available.
+    This signal is emitted for extended metadata \a value with a \a key not listed in QtMultimedia::MetaData enum.
+
+    This signal is emitted between imageExposed and imageSaved signals.
+    \since 1.2
+*/
+
+
+/*!
+    \fn QCameraImageCapture::imageAvailable(int id, const QVideoFrame &buffer)
+
+    Signal emitted when the frame with request \a id is available as \a buffer.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraImageCapture::imageSaved(int id, const QString &fileName)
+
+    Signal emitted when the frame with request \a id was saved to \a fileName.
+    \since 1.1
+*/
+
+
+#include "moc_qcameraimagecapture.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/camera/qcameraimagecapture.h b/src/multimedia/camera/qcameraimagecapture.h
new file mode 100644
index 0000000..bc41622
--- /dev/null
+++ b/src/multimedia/camera/qcameraimagecapture.h
@@ -0,0 +1,170 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAIMAGECAPTURE_H
+#define QCAMERAIMAGECAPTURE_H
+
+#include <qmediaobject.h>
+#include <qmediaencodersettings.h>
+#include <qmediabindableinterface.h>
+#include <qvideoframe.h>
+
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QSize;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class QImageEncoderSettings;
+
+class QCameraImageCapturePrivate;
+class Q_MULTIMEDIA_EXPORT QCameraImageCapture : public QObject, public QMediaBindableInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaBindableInterface)
+    Q_ENUMS(Error)
+    Q_ENUMS(CaptureDestination)
+    Q_PROPERTY(bool readyForCapture READ isReadyForCapture NOTIFY readyForCaptureChanged)
+public:
+    enum Error
+    {
+        NoError,
+        NotReadyError,
+        ResourceError,
+        OutOfSpaceError,
+        NotSupportedFeatureError,
+        FormatError
+    };
+
+    enum DriveMode
+    {
+        SingleImageCapture
+    };
+
+    enum CaptureDestination
+    {
+        CaptureToFile = 0x01,
+        CaptureToBuffer = 0x02
+    };
+    Q_DECLARE_FLAGS(CaptureDestinations, CaptureDestination)
+
+    QCameraImageCapture(QMediaObject *mediaObject, QObject *parent = 0);
+    ~QCameraImageCapture();
+
+    bool isAvailable() const;
+    QtMultimedia::AvailabilityError availabilityError() const;
+
+    QMediaObject *mediaObject() const;
+
+    Error error() const;
+    QString errorString() const;
+
+    bool isReadyForCapture() const;
+
+    QStringList supportedImageCodecs() const;
+    QString imageCodecDescription(const QString &codecName) const;
+
+    QList<QSize> supportedResolutions(const QImageEncoderSettings &settings = QImageEncoderSettings(),
+                                      bool *continuous = 0) const;
+
+    QImageEncoderSettings encodingSettings() const;
+    void setEncodingSettings(const QImageEncoderSettings& settings);
+
+    QList<QVideoFrame::PixelFormat> supportedBufferFormats() const;
+    QVideoFrame::PixelFormat bufferFormat() const;
+    void setBufferFormat(QVideoFrame::PixelFormat format);
+
+    bool isCaptureDestinationSupported(CaptureDestinations destination) const;
+    CaptureDestinations captureDestination() const;
+    void setCaptureDestination(CaptureDestinations destination);
+
+public Q_SLOTS:
+    int capture(const QString &location = QString());
+    void cancelCapture();
+
+Q_SIGNALS:
+    void error(int id, QCameraImageCapture::Error error, const QString &errorString);
+
+    void readyForCaptureChanged(bool);
+    void bufferFormatChanged(QVideoFrame::PixelFormat);
+    void captureDestinationChanged(QCameraImageCapture::CaptureDestinations);
+
+    void imageExposed(int id);
+    void imageCaptured(int id, const QImage &preview);
+    void imageMetadataAvailable(int id, QtMultimedia::MetaData key, const QVariant &value);
+    void imageMetadataAvailable(int id, const QString &key, const QVariant &value);
+    void imageAvailable(int id, const QVideoFrame &image);
+    void imageSaved(int id, const QString &fileName);
+
+protected:
+    bool setMediaObject(QMediaObject *);
+
+    QCameraImageCapturePrivate *d_ptr;
+private:
+    Q_DISABLE_COPY(QCameraImageCapture)
+    Q_DECLARE_PRIVATE(QCameraImageCapture)
+    Q_PRIVATE_SLOT(d_func(), void _q_error(int, int, const QString &))
+    Q_PRIVATE_SLOT(d_func(), void _q_readyChanged(bool))
+    Q_PRIVATE_SLOT(d_func(), void _q_serviceDestroyed())
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCameraImageCapture::CaptureDestinations)
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QCameraImageCapture::Error)
+Q_DECLARE_METATYPE(QCameraImageCapture::CaptureDestination)
+Q_DECLARE_METATYPE(QCameraImageCapture::CaptureDestinations)
+
+Q_MEDIA_ENUM_DEBUG(QCameraImageCapture, Error)
+Q_MEDIA_ENUM_DEBUG(QCameraImageCapture, CaptureDestination)
+
+QT_END_HEADER
+
+#endif
+
diff --git a/src/multimedia/camera/qcameraimageprocessing.cpp b/src/multimedia/camera/qcameraimageprocessing.cpp
new file mode 100644
index 0000000..8506067
--- /dev/null
+++ b/src/multimedia/camera/qcameraimageprocessing.cpp
@@ -0,0 +1,365 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qcameraimageprocessing.h"
+#include "qmediaobject_p.h"
+
+#include <qcameracontrol.h>
+#include <qcameraexposurecontrol.h>
+#include <qcamerafocuscontrol.h>
+#include <qmediarecordercontrol.h>
+#include <qcameraimageprocessingcontrol.h>
+#include <qcameraimagecapturecontrol.h>
+#include <qvideodevicecontrol.h>
+
+#include <QtCore/QDebug>
+
+namespace
+{
+    class QCameraImageProcessingPrivateRegisterMetaTypes
+    {
+    public:
+        QCameraImageProcessingPrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QCameraImageProcessing::WhiteBalanceMode>();
+        }
+    } _registerMetaTypes;
+}
+
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraImageProcessing
+
+
+    \brief The QCameraImageProcessing class provides interface for
+    focus and zoom related camera settings.
+
+    \inmodule QtMultimedia
+    \ingroup camera
+    \since 1.1
+
+*/
+
+
+class QCameraImageProcessingPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QCameraImageProcessing)
+public:
+    void initControls();
+
+    QCameraImageProcessing *q_ptr;
+
+    QCamera *camera;
+    QCameraImageProcessingControl *imageControl;
+};
+
+
+void QCameraImageProcessingPrivate::initControls()
+{
+    imageControl = 0;
+
+    QMediaService *service = camera->service();
+    if (service)
+        imageControl = qobject_cast<QCameraImageProcessingControl *>(service->requestControl(QCameraImageProcessingControl_iid));
+}
+
+/*!
+    Construct a QCameraImageProcessing for \a camera.
+*/
+
+QCameraImageProcessing::QCameraImageProcessing(QCamera *camera):
+    QObject(camera), d_ptr(new QCameraImageProcessingPrivate)
+{
+    Q_D(QCameraImageProcessing);
+    d->camera = camera;
+    d->q_ptr = this;
+    d->initControls();
+}
+
+
+/*!
+    Destroys the camera focus object.
+*/
+
+QCameraImageProcessing::~QCameraImageProcessing()
+{
+}
+
+
+/*!
+    Returns true if image processing related settings are supported by this camera.
+    \since 1.1
+*/
+bool QCameraImageProcessing::isAvailable() const
+{
+    return d_func()->imageControl != 0;
+}
+
+
+/*!
+    Returns the white balance mode being used.
+    \since 1.1
+*/
+
+QCameraImageProcessing::WhiteBalanceMode QCameraImageProcessing::whiteBalanceMode() const
+{
+    return d_func()->imageControl ? d_func()->imageControl->whiteBalanceMode() : QCameraImageProcessing::WhiteBalanceAuto;
+}
+
+/*!
+    Sets the white balance to \a mode.
+    \since 1.1
+*/
+
+void QCameraImageProcessing::setWhiteBalanceMode(QCameraImageProcessing::WhiteBalanceMode mode)
+{
+    if (d_func()->imageControl)
+        d_func()->imageControl->setWhiteBalanceMode(mode);
+}
+
+/*!
+    Returns true if the white balance \a mode is supported.
+    \since 1.1
+*/
+
+bool QCameraImageProcessing::isWhiteBalanceModeSupported(QCameraImageProcessing::WhiteBalanceMode mode) const
+{
+    return d_func()->imageControl ? d_func()->imageControl->isWhiteBalanceModeSupported(mode) : false;
+}
+
+/*!
+    Returns the current color temperature if the
+    manual white balance is active, otherwise the
+    return value is undefined.
+    \since 1.1
+*/
+
+int QCameraImageProcessing::manualWhiteBalance() const
+{
+    QVariant value;
+
+    if (d_func()->imageControl)
+        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::ColorTemperature);
+
+    return value.toInt();
+}
+
+/*!
+    Sets manual white balance to \a colorTemperature
+    \since 1.1
+*/
+
+void QCameraImageProcessing::setManualWhiteBalance(int colorTemperature)
+{
+    if (d_func()->imageControl) {
+        d_func()->imageControl->setProcessingParameter(
+                    QCameraImageProcessingControl::ColorTemperature,
+                    QVariant(colorTemperature));
+    }
+}
+
+/*!
+    Return the contrast.
+    \since 1.1
+*/
+int QCameraImageProcessing::contrast() const
+{
+    QVariant value;
+
+    if (d_func()->imageControl)
+        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::Contrast);
+
+    return value.toInt();
+}
+
+/*!
+    Set the contrast to \a value.
+
+    Valid contrast values range between -100 and 100, the default is 0.
+    \since 1.1
+*/
+void QCameraImageProcessing::setContrast(int value)
+{
+    if (d_func()->imageControl)
+        d_func()->imageControl->setProcessingParameter(QCameraImageProcessingControl::Contrast,
+                                                       QVariant(value));
+}
+
+/*!
+    Returns the saturation value.
+    \since 1.1
+*/
+int QCameraImageProcessing::saturation() const
+{
+    QVariant value;
+
+    if (d_func()->imageControl)
+        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::Saturation);
+
+    return value.toInt();
+}
+
+/*!
+    Sets the saturation value to \a value.
+
+    Valid saturation values range between -100 and 100, the default is 0.
+    \since 1.1
+*/
+
+void QCameraImageProcessing::setSaturation(int value)
+{
+    if (d_func()->imageControl)
+        d_func()->imageControl->setProcessingParameter(QCameraImageProcessingControl::Saturation,
+                                                       QVariant(value));
+}
+
+/*!
+    Identifies if sharpening is supported.
+
+    Returns true if sharpening is supported; and false if it is not.
+    \since 1.1
+*/
+bool QCameraImageProcessing::isSharpeningSupported() const
+{
+    if (d_func()->imageControl)
+        return d_func()->imageControl->isProcessingParameterSupported(QCameraImageProcessingControl::Sharpening);
+    else
+        return false;
+}
+
+/*!
+    Returns the sharpening level.
+    \since 1.1
+*/
+int QCameraImageProcessing::sharpeningLevel() const
+{
+    QVariant value;
+
+    if (d_func()->imageControl)
+        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::Sharpening);
+
+    if (value.isNull())
+        return -1;
+    else
+        return value.toInt();
+}
+
+/*!
+    Sets the sharpening \a level.
+
+    Valid sharpening level values range between -1 for default sharpening level,
+    0 for sharpening disabled and 100 for maximum sharpening applied.
+    \since 1.1
+*/
+
+void QCameraImageProcessing::setSharpeningLevel(int level)
+{
+    Q_D(QCameraImageProcessing);
+    if (d->imageControl)
+        d->imageControl->setProcessingParameter(QCameraImageProcessingControl::Sharpening,
+                                                level == -1 ? QVariant() : QVariant(level));
+}
+
+/*!
+    Returns true if denoising is supported.
+    \since 1.1
+*/
+bool QCameraImageProcessing::isDenoisingSupported() const
+{
+    if (d_func()->imageControl)
+        return d_func()->imageControl->isProcessingParameterSupported(QCameraImageProcessingControl::Denoising);
+    else
+        return false;
+}
+
+/*!
+    Returns the denoising level.
+    \since 1.1
+*/
+int QCameraImageProcessing::denoisingLevel() const
+{
+    QVariant value;
+
+    if (d_func()->imageControl)
+        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::Denoising);
+
+    if (value.isNull())
+        return -1;
+    else
+        return value.toInt();
+}
+
+/*!
+    Sets the denoising \a level.
+
+    Valid denoising level values range between -1 for default denoising level,
+    0 for denoising disabled and 100 for maximum denoising applied.
+    \since 1.1
+*/
+void QCameraImageProcessing::setDenoisingLevel(int level)
+{
+    Q_D(QCameraImageProcessing);
+    if (d->imageControl)
+        d->imageControl->setProcessingParameter(QCameraImageProcessingControl::Denoising,
+                                                level == -1 ? QVariant() : QVariant(level));
+}
+
+
+/*!
+    \enum QCameraImageProcessing::WhiteBalanceMode
+
+    \value WhiteBalanceManual       Manual white balance. In this mode the white balance should be set with
+                                    setManualWhiteBalance()
+    \value WhiteBalanceAuto         Auto white balance mode.
+    \value WhiteBalanceSunlight     Sunlight white balance mode.
+    \value WhiteBalanceCloudy       Cloudy white balance mode.
+    \value WhiteBalanceShade        Shade white balance mode.
+    \value WhiteBalanceTungsten     Tungsten white balance mode.
+    \value WhiteBalanceFluorescent  Fluorescent white balance mode.
+    \value WhiteBalanceFlash        Flash white balance mode.
+    \value WhiteBalanceSunset       Sunset white balance mode.
+    \value WhiteBalanceVendor       Vendor defined white balance mode.
+*/
+
+#include "moc_qcameraimageprocessing.cpp"
+QT_END_NAMESPACE
diff --git a/src/multimedia/camera/qcameraimageprocessing.h b/src/multimedia/camera/qcameraimageprocessing.h
new file mode 100644
index 0000000..42a7eb5
--- /dev/null
+++ b/src/multimedia/camera/qcameraimageprocessing.h
@@ -0,0 +1,124 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAIMAGEPROCESSING_H
+#define QCAMERAIMAGEPROCESSING_H
+
+#include <QtCore/qstringlist.h>
+#include <QtCore/qpair.h>
+#include <QtCore/qsize.h>
+#include <QtCore/qpoint.h>
+#include <QtCore/qrect.h>
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+#include <qmediaservice.h>
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QCamera;
+
+class QCameraImageProcessingPrivate;
+class Q_MULTIMEDIA_EXPORT QCameraImageProcessing : public QObject
+{
+    Q_OBJECT
+    Q_ENUMS(WhiteBalanceMode)
+public:
+    enum WhiteBalanceMode {
+        WhiteBalanceAuto = 0,
+        WhiteBalanceManual = 1,
+        WhiteBalanceSunlight = 2,
+        WhiteBalanceCloudy = 3,
+        WhiteBalanceShade = 4,
+        WhiteBalanceTungsten = 5,
+        WhiteBalanceFluorescent = 6,
+        WhiteBalanceFlash = 7,
+        WhiteBalanceSunset = 8,
+        WhiteBalanceVendor = 1000
+    };
+
+    bool isAvailable() const;
+
+    WhiteBalanceMode whiteBalanceMode() const;
+    void setWhiteBalanceMode(WhiteBalanceMode mode);
+    bool isWhiteBalanceModeSupported(WhiteBalanceMode mode) const;
+    int manualWhiteBalance() const;
+    void setManualWhiteBalance(int colorTemperature);
+
+    int contrast() const;
+    void setContrast(int value);
+
+    int saturation() const;
+    void setSaturation(int value);
+
+    bool isSharpeningSupported() const;
+    int sharpeningLevel() const;
+    void setSharpeningLevel(int value);
+
+    bool isDenoisingSupported() const;
+    int denoisingLevel() const;
+    void setDenoisingLevel(int value);
+
+private:
+    friend class QCamera;
+    QCameraImageProcessing(QCamera *camera);
+    ~QCameraImageProcessing();
+
+    Q_DISABLE_COPY(QCameraImageProcessing)
+    Q_DECLARE_PRIVATE(QCameraImageProcessing)
+    QCameraImageProcessingPrivate *d_ptr;
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QCameraImageProcessing::WhiteBalanceMode)
+
+Q_MEDIA_ENUM_DEBUG(QCameraImageProcessing, WhiteBalanceMode)
+
+QT_END_HEADER
+
+#endif  // QCAMERAIMAGEPROCESSING_H
diff --git a/src/multimedia/controls/controls.pri b/src/multimedia/controls/controls.pri
new file mode 100644
index 0000000..98137dc
--- /dev/null
+++ b/src/multimedia/controls/controls.pri
@@ -0,0 +1,60 @@
+
+INCLUDEPATH += controls
+
+PUBLIC_HEADERS += \
+    controls/qaudioencodercontrol.h \
+    controls/qcameracapturebufferformatcontrol.h \
+    controls/qcameracapturedestinationcontrol.h \
+    controls/qcameracontrol.h \
+    controls/qcameraexposurecontrol.h \
+    controls/qcameraflashcontrol.h \
+    controls/qcamerafocuscontrol.h \
+    controls/qcameraimagecapturecontrol.h \
+    controls/qcameraimageprocessingcontrol.h \
+    controls/qcameralockscontrol.h \
+    controls/qimageencodercontrol.h \
+    controls/qmediabackgroundplaybackcontrol.h \
+    controls/qmediacontainercontrol.h \
+    controls/qmediagaplessplaybackcontrol.h \
+    controls/qmedianetworkaccesscontrol.h \
+    controls/qmediaplayercontrol.h \
+    controls/qmediaplaylistcontrol.h \
+    controls/qmediaplaylistsourcecontrol.h \
+    controls/qmediarecordercontrol.h \
+    controls/qmediastreamscontrol.h \
+    controls/qmetadatareadercontrol.h \
+    controls/qmetadatawritercontrol.h \
+    controls/qradiodatacontrol.h \
+    controls/qradiotunercontrol.h \
+    controls/qvideodevicecontrol.h \
+    controls/qvideoencodercontrol.h \
+    controls/qvideorenderercontrol.h
+
+SOURCES += \
+    controls/qaudioencodercontrol.cpp \
+    controls/qcameracapturebufferformatcontrol.cpp \
+    controls/qcameracapturedestinationcontrol.cpp \
+    controls/qcameracontrol.cpp \
+    controls/qcameraexposurecontrol.cpp \
+    controls/qcameraflashcontrol.cpp \
+    controls/qcamerafocuscontrol.cpp \
+    controls/qcameraimagecapturecontrol.cpp \
+    controls/qcameraimageprocessingcontrol.cpp \
+    controls/qcameralockscontrol.cpp \
+    controls/qimageencodercontrol.cpp \
+    controls/qmediabackgroundplaybackcontrol.cpp \
+    controls/qmediacontainercontrol.cpp \
+    controls/qmediagaplessplaybackcontrol.cpp \
+    controls/qmedianetworkaccesscontrol.cpp \
+    controls/qmediaplayercontrol.cpp \
+    controls/qmediaplaylistcontrol.cpp \
+    controls/qmediaplaylistsourcecontrol.cpp \
+    controls/qmediarecordercontrol.cpp \
+    controls/qmediastreamscontrol.cpp \
+    controls/qmetadatareadercontrol.cpp \
+    controls/qmetadatawritercontrol.cpp \
+    controls/qradiodatacontrol.cpp \
+    controls/qradiotunercontrol.cpp \
+    controls/qvideodevicecontrol.cpp \
+    controls/qvideoencodercontrol.cpp \
+    controls/qvideorenderercontrol.cpp
diff --git a/src/multimedia/controls/qaudioencodercontrol.cpp b/src/multimedia/controls/qaudioencodercontrol.cpp
new file mode 100644
index 0000000..62fa893
--- /dev/null
+++ b/src/multimedia/controls/qaudioencodercontrol.cpp
@@ -0,0 +1,167 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qaudioencodercontrol.h"
+#include <QtCore/qstringlist.h>
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QAudioEncoderControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+    \brief The QAudioEncoderControl class provides access to the settings of a
+    media service that performs audio encoding.
+
+    If a QMediaService supports encoding audio data it will implement
+    QAudioEncoderControl.  This control provides information about the limits
+    of restricted audio encoder options and allows the selection of a set of
+    audio encoder settings as specified in a QAudioEncoderSettings object.
+
+    The functionality provided by this control is exposed to application code through the
+    QMediaRecorder class.
+
+    The interface name of QAudioEncoderControl is \c com.nokia.Qt.QAudioEncoderControl/1.0 as
+    defined in QAudioEncoderControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaRecorder
+*/
+
+/*!
+    \macro QAudioEncoderControl_iid
+
+    \c com.nokia.Qt.AudioEncoderControl/1.0
+
+    Defines the interface name of the QAudioEncoderControl class.
+
+    \relates QAudioEncoderControl
+*/
+
+/*!
+  Create a new audio encode control object with the given \a parent.
+*/
+QAudioEncoderControl::QAudioEncoderControl(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+  Destroys the audio encode control.
+*/
+QAudioEncoderControl::~QAudioEncoderControl()
+{
+}
+
+/*!
+  \fn QAudioEncoderControl::supportedAudioCodecs() const
+
+  Returns the list of supported audio codec names.
+  \since 1.0
+*/
+
+/*!
+  \fn QAudioEncoderControl::codecDescription(const QString &codec) const
+
+  Returns description of audio \a codec.
+  \since 1.0
+*/
+
+/*!
+  \fn QAudioEncoderControl::supportedSampleRates(const QAudioEncoderSettings &settings = QAudioEncoderSettings(),
+                                                 bool *continuous) const
+
+  Returns the list of supported audio sample rates, if known.
+
+  If non null audio \a settings parameter is passed,
+  the returned list is reduced to sample rates supported with partial settings applied.
+
+  It can be used for example to query the list of sample rates, supported by specific audio codec.
+
+  If the encoder supports arbitrary sample rates within the supported rates range,
+  *\a continuous is set to true, otherwise *\a continuous is set to false.
+  \since 1.0
+*/
+
+/*!
+    \fn QAudioEncoderControl::supportedEncodingOptions(const QString &codec) const
+
+    Returns the list of \a codec specific audio encoding options.
+    \since 1.0
+*/
+
+/*!
+    \fn QAudioEncoderControl::encodingOption(const QString &codec, const QString &option) const
+
+    Returns the value of audio encoding \a option for \a codec.
+    \since 1.0
+*/
+
+/*!
+    \fn QAudioEncoderControl::setEncodingOption(const QString &codec, const QString &option, const QVariant &value)
+
+    Set the \a codec specific \a option to \a value.
+    \since 1.0
+*/
+
+/*!
+    \fn QAudioEncoderControl::audioSettings() const
+
+    Returns the audio encoder settings.
+
+    The returned value may be different tha passed to QAudioEncoderControl::setAudioSettings()
+    if the settings contains the default or undefined parameters.
+    In this case if the undefined parameters are already resolved, they should be returned.
+    \since 1.0
+*/
+
+/*!
+    \fn QAudioEncoderControl::setAudioSettings(const QAudioEncoderSettings &settings)
+
+    Sets the selected audio \a settings.
+    \since 1.0
+*/
+
+#include "moc_qaudioencodercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qaudioencodercontrol.h b/src/multimedia/controls/qaudioencodercontrol.h
new file mode 100644
index 0000000..2e3a4bf
--- /dev/null
+++ b/src/multimedia/controls/qaudioencodercontrol.h
@@ -0,0 +1,95 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAUDIOENCODERCONTROL_H
+#define QAUDIOENCODERCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qmediarecorder.h"
+#include <QtCore/qlist.h>
+#include <QtCore/qpair.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QStringList;
+class QAudioFormat;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class Q_MULTIMEDIA_EXPORT QAudioEncoderControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QAudioEncoderControl();
+
+    virtual QStringList supportedAudioCodecs() const = 0;
+    virtual QString codecDescription(const QString &codecName) const = 0;
+
+    virtual QList<int> supportedSampleRates(const QAudioEncoderSettings &settings,
+                                            bool *continuous = 0) const = 0;
+
+    virtual QAudioEncoderSettings audioSettings() const = 0;
+    virtual void setAudioSettings(const QAudioEncoderSettings&) = 0;
+
+    virtual QStringList supportedEncodingOptions(const QString &codec) const = 0;
+    virtual QVariant encodingOption(const QString &codec, const QString &name) const = 0;
+    virtual void setEncodingOption(
+            const QString &codec, const QString &name, const QVariant &value) = 0;
+
+protected:
+    QAudioEncoderControl(QObject *parent = 0);
+};
+
+#define QAudioEncoderControl_iid "com.nokia.Qt.QAudioEncoderControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QAudioEncoderControl, QAudioEncoderControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QAUDIOCAPTUREPROPERTIESCONTROL_H
diff --git a/src/multimedia/controls/qcameracapturebufferformatcontrol.cpp b/src/multimedia/controls/qcameracapturebufferformatcontrol.cpp
new file mode 100644
index 0000000..536c8b3
--- /dev/null
+++ b/src/multimedia/controls/qcameracapturebufferformatcontrol.cpp
@@ -0,0 +1,117 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcameracapturebufferformatcontrol.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraCaptureBufferFormatControl
+
+    \brief The QCameraCaptureBufferFormatControl class provides a control for setting the capture buffer format.
+
+    The format is of type QVideoFrame::PixelFormat.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+
+    The interface name of QCameraCaptureBufferFormatControl is \c com.nokia.Qt.QCameraCaptureBufferFormatControl/1.0 as
+    defined in QCameraCaptureBufferFormatControl_iid.
+
+    \sa QMediaService::requestControl()
+*/
+
+/*!
+    \macro QCameraCaptureBufferFormatControl_iid
+
+    \c com.nokia.Qt.QCameraCaptureBufferFormatControl/1.0
+
+    Defines the interface name of the QCameraCaptureBufferFormatControl class.
+
+    \relates QCameraCaptureBufferFormatControl
+*/
+
+/*!
+    Constructs a new image buffer capture format control object with the given \a parent
+*/
+QCameraCaptureBufferFormatControl::QCameraCaptureBufferFormatControl(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys an image buffer capture format control.
+*/
+QCameraCaptureBufferFormatControl::~QCameraCaptureBufferFormatControl()
+{
+}
+
+/*!
+    \fn QCameraCaptureBufferFormatControl::supportedBufferFormats() const
+
+    Returns the list of the supported buffer capture formats.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraCaptureBufferFormatControl::bufferFormat() const
+
+    Returns the current buffer capture format.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraCaptureBufferFormatControl::setBufferFormat(QVideoFrame::PixelFormat format)
+
+    Sets the buffer capture \a format.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraCaptureBufferFormatControl::bufferFormatChanged(QVideoFrame::PixelFormat format)
+
+    Signals the buffer image capture format changed to \a format.
+    \since 1.2
+*/
+
+#include "moc_qcameracapturebufferformatcontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qcameracapturebufferformatcontrol.h b/src/multimedia/controls/qcameracapturebufferformatcontrol.h
new file mode 100644
index 0000000..81079a7
--- /dev/null
+++ b/src/multimedia/controls/qcameracapturebufferformatcontrol.h
@@ -0,0 +1,81 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERACAPTUREBUFFERFORMATCONTROL_H
+#define QCAMERACAPTUREBUFFERFORMATCONTROL_H
+
+#include <qmediacontrol.h>
+#include <qcameraimagecapture.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QCameraCaptureBufferFormatControl : public QMediaControl
+{
+    Q_OBJECT
+public:
+    ~QCameraCaptureBufferFormatControl();
+
+    virtual QList<QVideoFrame::PixelFormat> supportedBufferFormats() const = 0;
+    virtual QVideoFrame::PixelFormat bufferFormat() const = 0;
+    virtual void setBufferFormat(QVideoFrame::PixelFormat format) = 0;
+
+Q_SIGNALS:
+    void bufferFormatChanged(QVideoFrame::PixelFormat);
+
+protected:
+    QCameraCaptureBufferFormatControl(QObject* parent = 0);
+};
+
+#define QCameraCaptureBufferFormatControl_iid "com.nokia.Qt.QCameraCaptureBufferFormatControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraCaptureBufferFormatControl, QCameraCaptureBufferFormatControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
+
diff --git a/src/multimedia/controls/qcameracapturedestinationcontrol.cpp b/src/multimedia/controls/qcameracapturedestinationcontrol.cpp
new file mode 100644
index 0000000..5072ae7
--- /dev/null
+++ b/src/multimedia/controls/qcameracapturedestinationcontrol.cpp
@@ -0,0 +1,121 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcameracapturedestinationcontrol.h>
+#include <QtCore/qstringlist.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraCaptureDestinationControl
+
+    \brief The QCameraCaptureDestinationControl class provides a control for setting capture destination.
+
+    Depending on backend capabilities capture to file, buffer or both can be supported.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+
+
+
+    The interface name of QCameraCaptureDestinationControl is \c com.nokia.Qt.QCameraCaptureDestinationControl/1.0 as
+    defined in QCameraCaptureDestinationControl_iid.
+
+
+    \sa QMediaService::requestControl()
+*/
+
+/*!
+    \macro QCameraCaptureDestinationControl_iid
+
+    \c com.nokia.Qt.QCameraCaptureDestinationControl/1.0
+
+    Defines the interface name of the QCameraCaptureDestinationControl class.
+
+    \relates QCameraCaptureDestinationControl
+*/
+
+/*!
+    Constructs a new image capture destination control object with the given \a parent
+*/
+QCameraCaptureDestinationControl::QCameraCaptureDestinationControl(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys an image capture destination control.
+*/
+QCameraCaptureDestinationControl::~QCameraCaptureDestinationControl()
+{
+}
+
+/*!
+    \fn QCameraCaptureDestinationControl::isCaptureDestinationSupported(QCameraImageCapture::CaptureDestinations destination) const
+
+    Returns true if the capture \a destination is supported; and false if it is not.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraCaptureDestinationControl::captureDestination() const
+
+    Returns the current capture \a destination. The default destination is QCameraImageCapture::CaptureToFile.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraCaptureDestinationControl::setCaptureDestination(QCameraImageCapture::CaptureDestinations destination)
+
+    Sets the capture \a destination.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraCaptureDestinationControl::captureDestinationChanged(QCameraImageCapture::CaptureDestinations destination)
+
+    Signals the image capture \a destination changed.
+    \since 1.2
+*/
+
+#include "moc_qcameracapturedestinationcontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qcameracapturedestinationcontrol.h b/src/multimedia/controls/qcameracapturedestinationcontrol.h
new file mode 100644
index 0000000..cdd769a
--- /dev/null
+++ b/src/multimedia/controls/qcameracapturedestinationcontrol.h
@@ -0,0 +1,81 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERACAPTUREDESTINATIONCONTROL_H
+#define QCAMERACAPTUREDESTINATIONCONTROL_H
+
+#include <qmediacontrol.h>
+#include <qcameraimagecapture.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QCameraCaptureDestinationControl : public QMediaControl
+{
+    Q_OBJECT
+public:
+    ~QCameraCaptureDestinationControl();
+
+    virtual bool isCaptureDestinationSupported(QCameraImageCapture::CaptureDestinations destination) const = 0;
+    virtual QCameraImageCapture::CaptureDestinations captureDestination() const = 0;
+    virtual void setCaptureDestination(QCameraImageCapture::CaptureDestinations destination) = 0;
+
+Q_SIGNALS:
+    void captureDestinationChanged(QCameraImageCapture::CaptureDestinations);
+
+protected:
+    QCameraCaptureDestinationControl(QObject* parent = 0);
+};
+
+#define QCameraCaptureDestinationControl_iid "com.nokia.Qt.QCameraCaptureDestinationControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraCaptureDestinationControl, QCameraCaptureDestinationControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
+
diff --git a/src/multimedia/controls/qcameracontrol.cpp b/src/multimedia/controls/qcameracontrol.cpp
new file mode 100644
index 0000000..df5c44c
--- /dev/null
+++ b/src/multimedia/controls/qcameracontrol.cpp
@@ -0,0 +1,215 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcameracontrol.h>
+#include  "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraControl
+
+
+
+    \brief The QCameraControl class is an abstract base class for
+    classes that control still cameras or video cameras.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.1
+
+    This service is provided by a QMediaService object via
+    QMediaService::control().  It is used by QCamera.
+
+    The interface name of QCameraControl is \c com.nokia.Qt.QCameraControl/1.0 as
+    defined in QCameraControl_iid.
+
+
+
+    \sa QMediaService::requestControl(), QCamera
+*/
+
+/*!
+    \macro QCameraControl_iid
+
+    \c com.nokia.Qt.QCameraControl/1.0
+
+    Defines the interface name of the QCameraControl class.
+
+    \relates QCameraControl
+*/
+
+/*!
+    Constructs a camera control object with \a parent.
+*/
+
+QCameraControl::QCameraControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destruct the camera control object.
+*/
+
+QCameraControl::~QCameraControl()
+{
+}
+
+/*!
+    \fn QCameraControl::state() const
+
+    Returns the state of the camera service.
+
+    \since 1.1
+    \sa QCamera::state
+*/
+
+/*!
+    \fn QCameraControl::setState(QCamera::State state)
+
+    Sets the camera \a state.
+
+    State changes are synchronous and indicate user intention,
+    while camera status is used as a feedback mechanism to inform application about backend status.
+    Status changes are reported asynchronously with QCameraControl::statusChanged() signal.
+
+    \since 1.1
+    \sa QCamera::State
+*/
+
+/*!
+    \fn void QCameraControl::stateChanged(QCamera::State state)
+
+    Signal emitted when the camera \a state changes.
+
+    In most cases the state chage is caused by QCameraControl::setState(),
+    but if critical error has occurred the state changes to QCamera::UnloadedState.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraControl::status() const
+
+    Returns the status of the camera service.
+
+    \since 1.1
+    \sa QCamera::state
+*/
+
+/*!
+    \fn void QCameraControl::statusChanged(QCamera::Status status)
+
+    Signal emitted when the camera \a status changes.
+    \since 1.1
+*/
+
+
+/*!
+    \fn void QCameraControl::error(int error, const QString &errorString)
+
+    Signal emitted when an error occurs with error code \a error and
+    a description of the error \a errorString.
+    \since 1.1
+*/
+
+/*!
+    \fn Camera::CaptureMode QCameraControl::captureMode() const = 0
+
+    Returns the current capture mode.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraControl::setCaptureMode(QCamera::CaptureMode mode) = 0;
+
+    Sets the current capture \a mode.
+
+    The capture mode changes are synchronous and allowed in any camera state.
+
+    If the capture mode is changed while camera is active,
+    it's recommended to change status to QCamera::LoadedStatus
+    and start activating the camera in the next event loop
+    with the status changed to QCamera::StartingStatus.
+    This allows the capture settings to be applied before camera is started.
+    Than change the status to QCamera::StartedStatus when the capture mode change is done.
+    \since 1.1
+*/
+
+/*!
+    \fn bool QCameraControl::isCaptureModeSupported(QCamera::CaptureMode mode) const = 0;
+
+    Returns true if the capture \a mode is suported.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraControl::captureModeChanged(QCamera::CaptureMode mode)
+
+    Signal emitted when the camera capture \a mode changes.
+    \since 1.1
+ */
+
+/*!
+    \fn bool QCameraControl::canChangeProperty(PropertyChangeType changeType, QCamera::Status status) const
+
+    Returns true if backend can effectively apply changing camera properties of \a changeType type
+    while the camera state is QCamera::Active and camera status matches \a status parameter.
+
+    If backend doesn't support applying this change in the active state, it will be stopped
+    before the settings are changed and restarted after.
+    Otherwise the backend should apply the change in the current state,
+    with the camera status indicating the progress, if necessary.
+    \since 1.1
+*/
+
+/*!
+  \enum QCameraControl::PropertyChangeType
+
+  \value CaptureMode Indicates the capture mode is changed.
+  \value ImageEncodingSettings Image encoder settings are changed, including resolution.
+  \value VideoEncodingSettings
+        Video encoder settings are changed, including audio, video and container settings.
+  \value Viewfinder Viewfinder is changed.
+*/
+
+#include "moc_qcameracontrol.cpp"
+QT_END_NAMESPACE
diff --git a/src/multimedia/controls/qcameracontrol.h b/src/multimedia/controls/qcameracontrol.h
new file mode 100644
index 0000000..dfc2b37
--- /dev/null
+++ b/src/multimedia/controls/qcameracontrol.h
@@ -0,0 +1,101 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERACONTROL_H
+#define QCAMERACONTROL_H
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+
+#include <qcamera.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QCameraControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    enum PropertyChangeType {
+        CaptureMode = 1,
+        ImageEncodingSettings = 2,
+        VideoEncodingSettings = 3,
+        Viewfinder = 4
+    };
+
+    ~QCameraControl();
+
+    virtual QCamera::State state() const = 0;
+    virtual void setState(QCamera::State state) = 0;
+
+    virtual QCamera::Status status() const = 0;
+
+    virtual QCamera::CaptureMode captureMode() const = 0;
+    virtual void setCaptureMode(QCamera::CaptureMode) = 0;
+    virtual bool isCaptureModeSupported(QCamera::CaptureMode mode) const = 0;
+
+    virtual bool canChangeProperty(PropertyChangeType changeType, QCamera::Status status) const = 0;
+
+Q_SIGNALS:
+    void stateChanged(QCamera::State);
+    void statusChanged(QCamera::Status);
+    void error(int error, const QString &errorString);
+    void captureModeChanged(QCamera::CaptureMode);
+
+protected:
+    QCameraControl(QObject* parent = 0);
+};
+
+#define QCameraControl_iid "com.nokia.Qt.QCameraControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraControl, QCameraControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QCAMERACONTROL_H
+
diff --git a/src/multimedia/controls/qcameraexposurecontrol.cpp b/src/multimedia/controls/qcameraexposurecontrol.cpp
new file mode 100644
index 0000000..4a6f655
--- /dev/null
+++ b/src/multimedia/controls/qcameraexposurecontrol.cpp
@@ -0,0 +1,252 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcameraexposurecontrol.h>
+#include  "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraExposureControl
+
+    \brief The QCameraExposureControl class allows controlling camera exposure parameters.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.1
+
+    You can adjust a number of parameters that will affect images and video taken with
+    the corresponding QCamera object.
+
+    There are a number of different parameters that can be adjusted, including:
+
+    \table
+    \row
+    \header
+    \
+
+    \endtable
+
+    The interface name of QCameraExposureControl is \c com.nokia.Qt.QCameraExposureControl/1.0 as
+    defined in QCameraExposureControl_iid.
+
+    \sa QCamera
+*/
+
+/*!
+    \macro QCameraExposureControl_iid
+
+    \c com.nokia.Qt.QCameraExposureControl/1.0
+
+    Defines the interface name of the QCameraExposureControl class.
+
+    \relates QCameraExposureControl
+*/
+
+/*!
+    Constructs a camera exposure control object with \a parent.
+*/
+QCameraExposureControl::QCameraExposureControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destroys the camera control object.
+*/
+QCameraExposureControl::~QCameraExposureControl()
+{
+}
+
+/*!
+  \fn QCamera::ExposureMode QCameraExposureControl::exposureMode() const
+
+  Returns the exposure mode.
+  \since 1.1
+*/
+
+
+/*!
+  \fn void QCameraExposureControl::setExposureMode(QCameraExposure::ExposureMode mode)
+
+  Set the exposure mode to \a mode.
+  \since 1.1
+*/
+
+
+/*!
+  \fn bool QCameraExposureControl::isExposureModeSupported(QCameraExposure::ExposureMode mode) const
+
+  Returns true if the exposure \a mode is supported.
+  \since 1.1
+*/
+
+
+/*!
+  \fn QCameraExposure::MeteringMode QCameraExposureControl::meteringMode() const
+  Returns the current metering mode.
+  \since 1.1
+*/
+
+/*!
+  \fn void QCameraExposureControl::setMeteringMode(QCameraExposure::MeteringMode mode)
+
+  Set the metering mode to \a mode.
+  \since 1.1
+*/
+
+
+/*!
+  \fn bool QCameraExposureControl::isMeteringModeSupported(QCameraExposure::MeteringMode mode) const
+    Returns true if the metering \a mode is supported.
+  \since 1.1
+*/
+
+/*!
+  \enum QCameraExposureControl::ExposureParameter
+  \value InvalidParameter
+         Parameter is invalid.
+  \value ISO
+         Camera ISO sensitivity, specified as integer value.
+  \value Aperture
+         Lens aperture is specified as an qreal F number.
+         The supported apertures list can change depending on the focal length,
+         in such a case the exposureParameterRangeChanged() signal is emitted.
+  \value ShutterSpeed
+         Shutter speed in seconds, specified as qreal.
+  \value ExposureCompensation
+         Exposure compensation, specified as qreal EV value.
+  \value FlashPower
+         Manual flash power, specified as qreal value.
+         Accepted power range is [0..1.0],
+         with 0 value means no flash and 1.0 corresponds to full flash power.
+
+         This value is only used in the \l{QCameraExposure::FlashManual}{manual flash mode}.
+  \value FlashCompensation
+         Flash compensation, specified as qreal EV value.
+  \value ExtendedExposureParameter
+         The base value for platform specific extended parameters.
+         For such parameters the sequential values starting from ExtendedExposureParameter shuld be used.
+*/
+
+/*!
+  \enum QCameraExposureControl::ParameterFlag
+  \value AutomaticValue
+         Use the automatic values for parameters.
+  \value ReadOnly
+         Parameters are read only.
+  \value ContinuousRange
+         Parameters are continuous in their range.
+*/
+
+/*!
+  \fn QCameraExposureControl::isParameterSupported(ExposureParameter parameter) const
+
+  Returns true is exposure \a parameter is supported by backend.
+  \since 1.1
+*/
+
+/*!
+  \fn QCameraExposureControl::exposureParameter(ExposureParameter parameter) const
+
+  Returns the exposure \a parameter value, or invalid QVariant() if the value is unknown or not supported.
+  \since 1.1
+*/
+
+/*!
+  \fn QCameraExposureControl::exposureParameterFlags(ExposureParameter parameter) const
+
+  Returns the properties of exposure \a parameter.
+  \since 1.1
+*/
+
+
+/*!
+  \fn QCameraExposureControl::supportedParameterRange(ExposureParameter parameter) const
+
+  Returns the list of supported \a parameter values;
+  \since 1.1
+*/
+
+/*!
+  \fn bool QCameraExposureControl::setExposureParameter(ExposureParameter parameter, const QVariant& value)
+
+  Set the exposure \a parameter to \a value.
+  If a null or invalid QVariant is passed, backend should choose the value automatically,
+  and if possible report the actual value to user with QCameraExposureControl::exposureParameter().
+
+  Returns true if parameter is supported and value is correct.
+  \since 1.1
+*/
+
+/*!
+  \fn QCameraExposureControl::extendedParameterName(ExposureParameter parameter)
+
+  Returns the extended exposure \a parameter name.
+  \since 1.1
+*/
+
+/*!
+    \fn void QCameraExposureControl::flashReady(bool ready)
+
+    Signal emitted when flash state changes, flash is charged \a ready.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraExposureControl::exposureParameterChanged(int parameter)
+
+    Signal emitted when the exposure \a parameter has changed.
+    \since 1.1
+*/
+
+/*!
+
+    \fn void QCameraExposureControl::exposureParameterRangeChanged(int parameter)
+
+    Signal emitted when the exposure \a parameter range has changed.
+    \since 1.1
+*/
+
+
+#include "moc_qcameraexposurecontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qcameraexposurecontrol.h b/src/multimedia/controls/qcameraexposurecontrol.h
new file mode 100644
index 0000000..ff60784
--- /dev/null
+++ b/src/multimedia/controls/qcameraexposurecontrol.h
@@ -0,0 +1,124 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAEXPOSURECONTROL_H
+#define QCAMERAEXPOSURECONTROL_H
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+
+#include <qcameraexposure.h>
+#include <qcamera.h>
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QCameraExposureControl : public QMediaControl
+{
+    Q_OBJECT
+    Q_ENUMS(ExposureParameter)
+
+public:
+    ~QCameraExposureControl();
+
+    enum ExposureParameter {
+        InvalidParameter = 0,
+        ISO = 1,
+        Aperture = 2,
+        ShutterSpeed = 3,
+        ExposureCompensation = 4,
+        FlashPower = 5,
+        FlashCompensation = 6,
+        ExtendedExposureParameter = 1000
+    };
+
+    enum ParameterFlag {
+        AutomaticValue = 0x01,
+        ReadOnly = 0x02,
+        ContinuousRange = 0x04
+    };
+    Q_DECLARE_FLAGS(ParameterFlags, ParameterFlag)
+
+    virtual QCameraExposure::ExposureMode exposureMode() const = 0;
+    virtual void setExposureMode(QCameraExposure::ExposureMode mode) = 0;
+    virtual bool isExposureModeSupported(QCameraExposure::ExposureMode mode) const = 0;
+
+    virtual QCameraExposure::MeteringMode meteringMode() const = 0;
+    virtual void setMeteringMode(QCameraExposure::MeteringMode mode) = 0;
+    virtual bool isMeteringModeSupported(QCameraExposure::MeteringMode mode) const = 0;
+
+    virtual bool isParameterSupported(ExposureParameter parameter) const = 0;
+    virtual QVariant exposureParameter(ExposureParameter parameter) const = 0;
+    virtual ParameterFlags exposureParameterFlags(ExposureParameter parameter) const = 0;
+    virtual QVariantList supportedParameterRange(ExposureParameter parameter) const = 0;
+    virtual bool setExposureParameter(ExposureParameter parameter, const QVariant& value) = 0;
+
+    virtual QString extendedParameterName(ExposureParameter parameter) = 0;
+
+Q_SIGNALS:
+    void flashReady(bool);
+
+    void exposureParameterChanged(int parameter);
+    void exposureParameterRangeChanged(int parameter);
+
+protected:
+    QCameraExposureControl(QObject* parent = 0);
+};
+
+#define QCameraExposureControl_iid "com.nokia.Qt.QCameraExposureControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraExposureControl, QCameraExposureControl_iid)
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QCameraExposureControl::ParameterFlags)
+
+Q_MEDIA_ENUM_DEBUG(QCameraExposureControl, ExposureParameter)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QCAMERAEXPOSURECONTROL_H
+
diff --git a/src/multimedia/controls/qcameraflashcontrol.cpp b/src/multimedia/controls/qcameraflashcontrol.cpp
new file mode 100644
index 0000000..34dcbde
--- /dev/null
+++ b/src/multimedia/controls/qcameraflashcontrol.cpp
@@ -0,0 +1,141 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcameraflashcontrol.h>
+#include  "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraFlashControl
+
+    \brief The QCameraFlashControl class allows controlling a camera's flash.
+
+    \ingroup multimedia-serv
+    \inmodule QtMultimedia
+    \since 1.1
+
+    \inmodule QtMultimedia
+
+    You can set the type of flash effect used when an image is captured, and test to see
+    if the flash hardware is ready to fire.
+
+    You can retrieve this control from the camera object in the usual way:
+
+    Some camera devices may not have flash hardware, or may not be configurable.  In that
+    case, there will be no QCameraFlashControl available.
+
+    The interface name of QCameraFlashControl is \c com.nokia.Qt.QCameraFlashControl/1.0 as
+    defined in QCameraFlashControl_iid.
+
+    \sa QCamera
+*/
+
+/*!
+    \macro QCameraFlashControl_iid
+
+    \c com.nokia.Qt.QCameraFlashControl/1.0
+
+    Defines the interface name of the QCameraFlashControl class.
+
+    \relates QCameraFlashControl
+*/
+
+/*!
+    Constructs a camera flash control object with \a parent.
+*/
+QCameraFlashControl::QCameraFlashControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destroys the camera control object.
+*/
+QCameraFlashControl::~QCameraFlashControl()
+{
+}
+
+/*!
+  \fn QCamera::FlashModes QCameraFlashControl::flashMode() const
+
+  Returns the current flash mode.
+  \since 1.1
+*/
+
+/*!
+  \fn void QCameraFlashControl::setFlashMode(QCameraExposure::FlashModes mode)
+
+  Set the current flash \a mode.
+
+  Usually a single QCameraExposure::FlashMode flag is used,
+  but some non conflicting flags combination are also allowed,
+  like QCameraExposure::FlashManual | QCameraExposure::FlashSlowSyncRearCurtain.
+  \since 1.1
+*/
+
+
+/*!
+  \fn QCameraFlashControl::isFlashModeSupported(QCameraExposure::FlashModes mode) const
+
+  Return true if the reqested flash \a mode is supported.
+  Some QCameraExposure::FlashMode values can be combined,
+  for example QCameraExposure::FlashManual | QCameraExposure::FlashSlowSyncRearCurtain
+  \since 1.1
+*/
+
+/*!
+  \fn bool QCameraFlashControl::isFlashReady() const
+
+  Returns true if flash is charged.
+  \since 1.1
+*/
+
+/*!
+    \fn void QCameraFlashControl::flashReady(bool ready)
+
+    Signal emitted when flash state changes to \a ready.
+    \since 1.1
+*/
+
+#include "moc_qcameraflashcontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qcameraflashcontrol.h b/src/multimedia/controls/qcameraflashcontrol.h
new file mode 100644
index 0000000..89b3b9d
--- /dev/null
+++ b/src/multimedia/controls/qcameraflashcontrol.h
@@ -0,0 +1,87 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAFLASHCONTROL_H
+#define QCAMERAFLASHCONTROL_H
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+
+#include <qcameraexposure.h>
+#include <qcamera.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QCameraFlashControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QCameraFlashControl();
+    
+    virtual QCameraExposure::FlashModes flashMode() const = 0;
+    virtual void setFlashMode(QCameraExposure::FlashModes mode) = 0;
+    virtual bool isFlashModeSupported(QCameraExposure::FlashModes mode) const = 0;
+
+    virtual bool isFlashReady() const = 0;
+
+Q_SIGNALS:
+    void flashReady(bool);
+
+protected:
+    QCameraFlashControl(QObject* parent = 0);
+};
+
+#define QCameraFlashControl_iid "com.nokia.Qt.QCameraFlashControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraFlashControl, QCameraFlashControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QCAMERAFLASHCONTROL_H
+
diff --git a/src/multimedia/controls/qcamerafocuscontrol.cpp b/src/multimedia/controls/qcamerafocuscontrol.cpp
new file mode 100644
index 0000000..93c4668
--- /dev/null
+++ b/src/multimedia/controls/qcamerafocuscontrol.cpp
@@ -0,0 +1,253 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcamerafocuscontrol.h>
+#include  "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraFocusControl
+
+
+    \brief The QCameraFocusControl class supplies control for
+    focusing related camera parameters.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.1
+
+    The interface name of QCameraFocusControl is \c com.nokia.Qt.QCameraFocusControl/1.0 as
+    defined in QCameraFocusControl_iid.
+
+
+    \sa QMediaService::requestControl(), QCamera
+*/
+
+/*!
+    \macro QCameraFocusControl_iid
+
+    \c com.nokia.Qt.QCameraFocusControl/1.0
+
+    Defines the interface name of the QCameraFocusControl class.
+
+    \relates QCameraFocusControl
+*/
+
+/*!
+    Constructs a camera control object with \a parent.
+*/
+
+QCameraFocusControl::QCameraFocusControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destruct the camera control object.
+*/
+
+QCameraFocusControl::~QCameraFocusControl()
+{
+}
+
+
+/*!
+  \fn QCameraFocus::FocusMode QCameraFocusControl::focusMode() const
+
+  Returns the focus mode being used.
+  \since 1.1
+*/
+
+
+/*!
+  \fn void QCameraFocusControl::setFocusMode(QCameraFocus::FocusMode mode)
+
+  Set the focus mode to \a mode.
+  \since 1.1
+*/
+
+
+/*!
+  \fn bool QCameraFocusControl::isFocusModeSupported(QCameraFocus::FocusMode mode) const
+
+  Returns true if focus \a mode is supported.
+  \since 1.1
+*/
+
+
+/*!
+  \fn qreal QCameraFocusControl::maximumOpticalZoom() const
+
+  Returns the maximum optical zoom value, or 1.0 if optical zoom is not supported.
+  \since 1.1
+*/
+
+
+/*!
+  \fn qreal QCameraFocusControl::maximumDigitalZoom() const
+
+  Returns the maximum digital zoom value, or 1.0 if digital zoom is not supported.
+  \since 1.1
+*/
+
+
+/*!
+  \fn qreal QCameraFocusControl::opticalZoom() const
+
+  Return the current optical zoom value.
+  \since 1.1
+*/
+
+/*!
+  \fn qreal QCameraFocusControl::digitalZoom() const
+
+  Return the current digital zoom value.
+  \since 1.1
+*/
+
+
+/*!
+  \fn void QCameraFocusControl::zoomTo(qreal optical, qreal digital)
+
+  Sets \a optical and \a digital zoom values.
+  \since 1.1
+*/
+
+/*!
+  \fn QCameraFocusControl::focusPointMode() const
+
+  Returns the camera focus point selection mode.
+  \since 1.1
+*/
+
+/*!
+  \fn QCameraFocusControl::setFocusPointMode(QCameraFocus::FocusPointMode mode)
+
+  Sets the camera focus point selection \a mode.
+  \since 1.1
+*/
+
+/*!
+  \fn QCameraFocusControl::isFocusPointModeSupported(QCameraFocus::FocusPointMode mode) const
+
+  Returns true if the camera focus point \a mode is supported.
+  \since 1.1
+*/
+
+/*!
+  \fn QCameraFocusControl::customFocusPoint() const
+
+  Return the position of custom focus point, in relative frame coordinates:
+  QPointF(0,0) points to the left top frame point, QPointF(0.5,0.5) points to the frame center.
+
+  Custom focus point is used only in FocusPointCustom focus mode.
+  \since 1.1
+*/
+
+/*!
+  \fn QCameraFocusControl::setCustomFocusPoint(const QPointF &point)
+
+  Sets the custom focus \a point.
+
+  If camera supports fixed set of focus points,
+  it should use the nearest supported focus point,
+  and return the actual focus point with QCameraFocusControl::focusZones().
+
+  \since 1.1
+  \sa QCameraFocusControl::customFocusPoint(), QCameraFocusControl::focusZones()
+*/
+
+/*!
+  \fn QCameraFocusControl::focusZones() const
+
+  Returns the list of zones, the camera is using for focusing or focused on.
+  \since 1.1
+*/
+
+/*!
+    \fn void QCameraFocusControl::opticalZoomChanged(qreal zoom)
+
+    Signal emitted when the optical \a zoom value changed.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraFocusControl::digitalZoomChanged(qreal zoom)
+
+    Signal emitted when the digital \a zoom value changed.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraFocusControl::maximumOpticalZoomChanged(qreal zoom)
+
+    Signal emitted when the maximum supported optical \a zoom value changed.
+    \since 1.1
+*/
+
+/*!
+    \fn void QCameraFocusControl::maximumDigitalZoomChanged(qreal zoom)
+
+    Signal emitted when the maximum supported digital \a zoom value changed.
+
+    The maximum supported zoom value can depend on other camera settings,
+    like capture mode or resolution.
+    \since 1.1
+*/
+
+
+/*!
+  \fn QCameraFocusControl::focusZonesChanged()
+
+  Signal is emitted when the set of zones, camera focused on is changed.
+
+  Usually the zones list is changed when the camera is focused.
+
+  \since 1.1
+  \sa QCameraFocusControl::focusZones()
+*/
+
+
+
+#include "moc_qcamerafocuscontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qcamerafocuscontrol.h b/src/multimedia/controls/qcamerafocuscontrol.h
new file mode 100644
index 0000000..20ffe6a
--- /dev/null
+++ b/src/multimedia/controls/qcamerafocuscontrol.h
@@ -0,0 +1,103 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAFOCUSCONTROL_H
+#define QCAMERAFOCUSCONTROL_H
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+
+#include <qcamerafocus.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QCameraFocusControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QCameraFocusControl();
+
+    virtual QCameraFocus::FocusMode focusMode() const = 0;
+    virtual void setFocusMode(QCameraFocus::FocusMode mode) = 0;
+    virtual bool isFocusModeSupported(QCameraFocus::FocusMode mode) const = 0;
+
+    virtual qreal maximumOpticalZoom() const = 0;
+    virtual qreal maximumDigitalZoom() const = 0;
+    virtual qreal opticalZoom() const = 0;
+    virtual qreal digitalZoom() const = 0;
+
+    virtual void zoomTo(qreal optical, qreal digital) = 0;
+
+    virtual QCameraFocus::FocusPointMode focusPointMode() const = 0;
+    virtual void setFocusPointMode(QCameraFocus::FocusPointMode mode) = 0;
+    virtual bool isFocusPointModeSupported(QCameraFocus::FocusPointMode mode) const = 0;
+    virtual QPointF customFocusPoint() const = 0;
+    virtual void setCustomFocusPoint(const QPointF &point) = 0;
+
+    virtual QCameraFocusZoneList focusZones() const = 0;
+
+Q_SIGNALS:
+    void opticalZoomChanged(qreal opticalZoom);
+    void digitalZoomChanged(qreal digitalZoom);
+    void focusZonesChanged();
+    void maximumOpticalZoomChanged(qreal);
+    void maximumDigitalZoomChanged(qreal);
+
+protected:
+    QCameraFocusControl(QObject* parent = 0);
+};
+
+#define QCameraFocusControl_iid "com.nokia.Qt.QCameraFocusingControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraFocusControl, QCameraFocusControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QCAMERAFOCUSCONTROL_H
+
diff --git a/src/multimedia/controls/qcameraimagecapturecontrol.cpp b/src/multimedia/controls/qcameraimagecapturecontrol.cpp
new file mode 100644
index 0000000..ad4c55e
--- /dev/null
+++ b/src/multimedia/controls/qcameraimagecapturecontrol.cpp
@@ -0,0 +1,208 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcameraimagecapturecontrol.h>
+#include <QtCore/qstringlist.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraImageCaptureControl
+
+    \brief The QCameraImageCaptureControl class provides a control interface
+    for image capture services.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.1
+
+
+
+    The interface name of QCameraImageCaptureControl is \c com.nokia.Qt.QCameraImageCaptureControl/1.0 as
+    defined in QCameraImageCaptureControl_iid.
+
+
+    \sa QMediaService::requestControl()
+*/
+
+/*!
+    \macro QCameraImageCaptureControl_iid
+
+    \c com.nokia.Qt.QCameraImageCaptureControl/1.0
+
+    Defines the interface name of the QCameraImageCaptureControl class.
+
+    \relates QCameraImageCaptureControl
+*/
+
+/*!
+    Constructs a new image capture control object with the given \a parent
+*/
+QCameraImageCaptureControl::QCameraImageCaptureControl(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys an image capture control.
+*/
+QCameraImageCaptureControl::~QCameraImageCaptureControl()
+{
+}
+
+/*!
+    \fn QCameraImageCaptureControl::isReadyForCapture() const
+
+    Identifies if a capture control is ready to perform a capture
+    immediately (all the resources necessary for image capture are allocated,
+    hardware initialized, flash is charged, etc).
+
+    Returns true if the camera is ready for capture; and false if it is not.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::readyForCaptureChanged(bool ready)
+
+    Signals that a capture control's \a ready state has changed.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::capture(const QString &fileName)
+
+    Initiates the capture of an image to \a fileName.
+    The \a fileName can be relative or empty,
+    in this case the service should use the system specific place
+    and file naming scheme.
+
+    Returns the capture request id number, which is used later
+    with imageExposed(), imageCaptured() and imageSaved() signals.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::cancelCapture()
+
+    Cancel pending capture requests.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::imageExposed(int requestId)
+
+    Signals that an image with it \a requestId
+    has just been exposed.
+    This signal can be used for the shutter sound or other indicaton.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::imageCaptured(int requestId, const QImage &preview)
+
+    Signals that an image with it \a requestId
+    has been captured and a \a preview is available.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::imageMetadataAvailable(int id, QtMultimedia::MetaData key, const QVariant &value)
+
+    Signals that a metadata for an image with request \a id is available.
+    This signal is emitted for metadata \a value with a \a key listed in QtMultimedia::MetaData enum.
+
+    This signal should be emitted between imageExposed and imageSaved signals.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::imageMetadataAvailable(int id, const QString &key, const QVariant &value)
+
+    Signals that a metadata for an image with request \a id is available.
+    This signal is emitted for extended metadata \a value with a \a key not listed in QtMultimedia::MetaData enum.
+
+    This signal should be emitted between imageExposed and imageSaved signals.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::imageAvailable(int requestId, const QVideoFrame &buffer)
+
+    Signals that a captured \a buffer with a \a requestId is available.
+    \since 1.2
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::imageSaved(int requestId, const QString &fileName)
+
+    Signals that a captured image with a \a requestId has been saved
+    to \a fileName.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::driveMode() const
+
+    Returns the current camera drive mode.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageCaptureControl::setDriveMode(QCameraImageCapture::DriveMode mode)
+
+    Sets the current camera drive \a mode.
+    \since 1.1
+*/
+
+
+/*!
+    \fn QCameraImageCaptureControl::error(int id, int error, const QString &errorString)
+
+    Signals the capture request \a id failed with \a error code and message \a errorString.
+
+    \since 1.1
+    \sa QCameraImageCapture::Error
+*/
+
+
+#include "moc_qcameraimagecapturecontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qcameraimagecapturecontrol.h b/src/multimedia/controls/qcameraimagecapturecontrol.h
new file mode 100644
index 0000000..0459c14
--- /dev/null
+++ b/src/multimedia/controls/qcameraimagecapturecontrol.h
@@ -0,0 +1,99 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAIMAGECAPTURECONTROL_H
+#define QCAMERAIMAGECAPTURECONTROL_H
+
+#include <qmediacontrol.h>
+#include <qcameraimagecapture.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QImage;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class Q_MULTIMEDIA_EXPORT QCameraImageCaptureControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QCameraImageCaptureControl();
+
+    virtual bool isReadyForCapture() const = 0;
+
+    virtual QCameraImageCapture::DriveMode driveMode() const = 0;
+    virtual void setDriveMode(QCameraImageCapture::DriveMode mode) = 0;
+
+    virtual int capture(const QString &fileName) = 0;
+    virtual void cancelCapture() = 0;
+
+Q_SIGNALS:
+    void readyForCaptureChanged(bool);
+
+    void imageExposed(int id);
+    void imageCaptured(int id, const QImage &preview);
+    void imageMetadataAvailable(int id, QtMultimedia::MetaData key, const QVariant &value);
+    void imageMetadataAvailable(int id, const QString &key, const QVariant &value);
+    void imageAvailable(int id, const QVideoFrame &buffer);
+    void imageSaved(int id, const QString &fileName);
+
+    void error(int id, int error, const QString &errorString);
+
+protected:
+    QCameraImageCaptureControl(QObject* parent = 0);
+};
+
+#define QCameraImageCaptureControl_iid "com.nokia.Qt.QCameraImageCaptureControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraImageCaptureControl, QCameraImageCaptureControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QCAMERAIMAGECAPTURECONTROL_H
+
diff --git a/src/multimedia/controls/qcameraimageprocessingcontrol.cpp b/src/multimedia/controls/qcameraimageprocessingcontrol.cpp
new file mode 100644
index 0000000..fb72a16
--- /dev/null
+++ b/src/multimedia/controls/qcameraimageprocessingcontrol.cpp
@@ -0,0 +1,181 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcameraimageprocessingcontrol.h>
+#include  "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace
+{
+    class QCameraImageProcessingControlPrivateRegisterMetaTypes
+    {
+    public:
+        QCameraImageProcessingControlPrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QCameraImageProcessingControl::ProcessingParameter>();
+        }
+    } _registerMetaTypes;
+}
+
+/*!
+    \class QCameraImageProcessingControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.1
+
+
+    \brief The QCameraImageProcessingControl class provides an abstract class
+    for controlling image processing parameters, like white balance,
+    contrast, saturation, sharpening and denoising.
+
+    The interface name of QCameraImageProcessingControl is \c com.nokia.Qt.QCameraImageProcessingControl/1.0 as
+    defined in QCameraImageProcessingControl_iid.
+
+
+
+    \sa QMediaService::requestControl(), QCamera
+*/
+
+/*!
+    \macro QCameraImageProcessingControl_iid
+
+    \c com.nokia.Qt.QCameraImageProcessingControl/1.0
+
+    Defines the interface name of the QCameraImageProcessingControl class.
+
+    \relates QCameraImageProcessingControl
+*/
+
+/*!
+    Constructs an image processing control object with \a parent.
+*/
+
+QCameraImageProcessingControl::QCameraImageProcessingControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destruct the image processing control object.
+*/
+
+QCameraImageProcessingControl::~QCameraImageProcessingControl()
+{
+}
+
+
+/*!
+    \fn QCameraImageProcessingControl::whiteBalanceMode() const
+    Return the white balance mode being used.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageProcessingControl::setWhiteBalanceMode(QCameraImageProcessing::WhiteBalanceMode mode)
+    Set the white balance mode to \a mode
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageProcessingControl::isWhiteBalanceModeSupported(QCameraImageProcessing::WhiteBalanceMode mode) const
+    Returns true if the white balance \a mode is supported.
+    The backend should support at least QCameraImageProcessing::WhiteBalanceAuto mode.
+    \since 1.1
+*/
+
+/*!
+    \fn bool QCameraImageProcessingControl::isProcessingParameterSupported(ProcessingParameter parameter) const
+
+    Returns true if the camera supports adjusting image processing \a parameter.
+
+    Usually the the supported settings is static,
+    but some parameter may not be available depending on other
+    camera settings, like presets.
+    In such case the currently supported parameters should be returned.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageProcessingControl::processingParameter(ProcessingParameter parameter) const
+    Returns the image processing \a parameter value.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraImageProcessingControl::setProcessingParameter(ProcessingParameter parameter, QVariant value)
+
+    Sets the image processing \a parameter \a value.
+    Passing the null or invalid QVariant value allows
+    backend to choose the suitable parameter value.
+
+    The valid values range depends on the parameter type,
+    for contrast, saturation and brightness value should be
+    between -100 and 100, the default is 0,
+
+    For sharpening and denoising the range is 0..100,
+    0 for sharpening or denoising disabled
+    and 100 for maximum sharpening/denoising applied.
+    \since 1.1
+*/
+
+/*!
+  \enum QCameraImageProcessingControl::ProcessingParameter
+
+  \value Contrast
+    Image contrast.
+  \value Saturation
+    Image saturation.
+  \value Brightness
+    Image brightness.
+  \value Sharpening
+    Amount of sharpening applied.
+  \value Denoising
+    Amount of denoising applied.
+  \value ColorTemperature
+    Color temperature in K. This value is used when the manual white balance mode is selected.
+  \value ExtendedParameter
+    The base value for platform specific extended parameters.
+ */
+
+#include "moc_qcameraimageprocessingcontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qcameraimageprocessingcontrol.h b/src/multimedia/controls/qcameraimageprocessingcontrol.h
new file mode 100644
index 0000000..8c73928
--- /dev/null
+++ b/src/multimedia/controls/qcameraimageprocessingcontrol.h
@@ -0,0 +1,100 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERAIMAGEPROCESSINGCONTROL_H
+#define QCAMERAIMAGEPROCESSINGCONTROL_H
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+
+#include <qcamera.h>
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QCameraImageProcessingControl : public QMediaControl
+{
+    Q_OBJECT
+    Q_ENUMS(ProcessingParameter)
+
+public:
+    ~QCameraImageProcessingControl();
+
+    enum ProcessingParameter {
+        Contrast = 0,
+        Saturation = 1,
+        Brightness = 2,
+        Sharpening = 3,
+        Denoising = 4,
+        ColorTemperature = 5,
+        ExtendedParameter = 1000
+    };
+
+    virtual QCameraImageProcessing::WhiteBalanceMode whiteBalanceMode() const = 0;
+    virtual void setWhiteBalanceMode(QCameraImageProcessing::WhiteBalanceMode mode) = 0;
+    virtual bool isWhiteBalanceModeSupported(QCameraImageProcessing::WhiteBalanceMode) const = 0;
+
+    virtual bool isProcessingParameterSupported(ProcessingParameter) const = 0;
+    virtual QVariant processingParameter(ProcessingParameter parameter) const = 0;
+    virtual void setProcessingParameter(ProcessingParameter parameter, QVariant value) = 0;
+
+protected:
+    QCameraImageProcessingControl(QObject* parent = 0);
+};
+
+#define QCameraImageProcessingControl_iid "com.nokia.Qt.QCameraImageProcessingControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraImageProcessingControl, QCameraImageProcessingControl_iid)
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QCameraImageProcessingControl::ProcessingParameter)
+
+Q_MEDIA_ENUM_DEBUG(QCameraImageProcessingControl, ProcessingParameter)
+
+QT_END_HEADER
+
+#endif
+
diff --git a/src/multimedia/controls/qcameralockscontrol.cpp b/src/multimedia/controls/qcameralockscontrol.cpp
new file mode 100644
index 0000000..289a07b
--- /dev/null
+++ b/src/multimedia/controls/qcameralockscontrol.cpp
@@ -0,0 +1,134 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qcameralockscontrol.h>
+#include  "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCameraLocksControl
+
+
+
+    \brief The QCameraLocksControl class is an abstract base class for
+    classes that control still cameras or video cameras.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.1
+
+    This service is provided by a QMediaService object via
+    QMediaService::control().  It is used by QCamera.
+
+    The interface name of QCameraLocksControl is \c com.nokia.Qt.QCameraLocksControl/1.0 as
+    defined in QCameraLocksControl_iid.
+
+
+    \sa QMediaService::requestControl(), QCamera
+*/
+
+/*!
+    \macro QCameraLocksControl_iid
+
+    \c com.nokia.Qt.QCameraLocksControl/1.0
+
+    Defines the interface name of the QCameraLocksControl class.
+
+    \relates QCameraLocksControl
+*/
+
+/*!
+    Constructs a camera locks control object with \a parent.
+*/
+
+QCameraLocksControl::QCameraLocksControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destruct the camera locks control object.
+*/
+
+QCameraLocksControl::~QCameraLocksControl()
+{
+}
+
+/*!
+    \fn QCameraLocksControl::supportedLocks() const
+
+    Returns the lock types, the camera supports.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraLocksControl::lockStatus(QCamera::LockType lock) const
+
+    Returns the camera \a lock status.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraLocksControl::searchAndLock(QCamera::LockTypes locks)
+
+    Request camera \a locks.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraLocksControl::unlock(QCamera::LockTypes locks)
+
+    Unlock camera \a locks.
+    \since 1.1
+*/
+
+/*!
+    \fn QCameraLocksControl::lockStatusChanged(QCamera::LockType lock, QCamera::LockStatus status, QCamera::LockChangeReason reason)
+
+    Signals the \a lock \a status was changed with a specified \a reason.
+    \since 1.1
+*/
+
+
+
+#include "moc_qcameralockscontrol.cpp"
+QT_END_NAMESPACE
diff --git a/src/multimedia/controls/qcameralockscontrol.h b/src/multimedia/controls/qcameralockscontrol.h
new file mode 100644
index 0000000..93120ee
--- /dev/null
+++ b/src/multimedia/controls/qcameralockscontrol.h
@@ -0,0 +1,86 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCAMERALOCKSCONTROL_H
+#define QCAMERALOCKSCONTROL_H
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+
+#include <qcamera.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QCameraLocksControl : public QMediaControl
+{
+    Q_OBJECT
+public:
+    ~QCameraLocksControl();
+    
+    virtual QCamera::LockTypes supportedLocks() const = 0;
+
+    virtual QCamera::LockStatus lockStatus(QCamera::LockType lock) const = 0;
+
+    virtual void searchAndLock(QCamera::LockTypes locks) = 0;
+    virtual void unlock(QCamera::LockTypes locks) = 0;
+
+Q_SIGNALS:
+    void lockStatusChanged(QCamera::LockType type, QCamera::LockStatus status, QCamera::LockChangeReason reason);
+
+protected:
+    QCameraLocksControl(QObject* parent = 0);
+};
+
+#define QCameraLocksControl_iid "com.nokia.Qt.QCameraLocksControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QCameraLocksControl, QCameraLocksControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QCAMERALOCKSCONTROL_H
+
diff --git a/src/multimedia/controls/qimageencodercontrol.cpp b/src/multimedia/controls/qimageencodercontrol.cpp
new file mode 100644
index 0000000..ee62a50
--- /dev/null
+++ b/src/multimedia/controls/qimageencodercontrol.cpp
@@ -0,0 +1,142 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qimageencodercontrol.h"
+#include <QtCore/qstringlist.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QImageEncoderControl
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+    \brief The QImageEncoderControl class provides access to the settings of a media service that
+    performs image encoding.
+
+    If a QMediaService supports encoding image data it will implement QImageEncoderControl.
+    This control allows to \l {setImageSettings()}{set image encoding settings} and
+    provides functions for quering supported image \l {supportedImageCodecs()}{codecs} and
+    \l {supportedResolutions()}{resolutions}.
+
+    The interface name of QImageEncoderControl is \c com.nokia.Qt.QImageEncoderControl/1.0 as
+    defined in QImageEncoderControl_iid.
+
+    \sa QImageEncoderSettings, QMediaService::requestControl()
+*/
+
+/*!
+    \macro QImageEncoderControl_iid
+
+    \c com.nokia.Qt.QImageEncoderControl/1.0
+
+    Defines the interface name of the QImageEncoderControl class.
+
+    \relates QImageEncoderControl
+*/
+
+/*!
+    Constructs a new image encoder control object with the given \a parent
+*/
+QImageEncoderControl::QImageEncoderControl(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys the image encoder control.
+*/
+QImageEncoderControl::~QImageEncoderControl()
+{
+}
+
+/*!
+    \fn QImageEncoderControl::supportedResolutions(const QImageEncoderSettings &settings = QImageEncoderSettings(),
+                                                   bool *continuous = 0) const
+
+    Returns a list of supported resolutions.
+
+    If non null image \a settings parameter is passed,
+    the returned list is reduced to resolutions supported with partial settings applied.
+    It can be used to query the list of resolutions, supported by specific image codec.
+
+    If the encoder supports arbitrary resolutions within the supported resolutions range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+    \since 1.0
+*/
+
+/*!
+    \fn QImageEncoderControl::supportedImageCodecs() const
+
+    Returns a list of supported image codecs.
+    \since 1.0
+*/
+
+/*!
+    \fn QImageEncoderControl::imageCodecDescription(const QString &codec) const
+
+    Returns a description of an image \a codec.
+    \since 1.0
+*/
+
+/*!
+    \fn QImageEncoderControl::imageSettings() const
+
+    Returns the currently used image encoder settings.
+
+    The returned value may be different tha passed to QImageEncoderControl::setImageSettings()
+    if the settings contains the default or undefined parameters.
+    In this case if the undefined parameters are already resolved, they should be returned.
+    \since 1.0
+*/
+
+/*!
+    \fn QImageEncoderControl::setImageSettings(const QImageEncoderSettings &settings)
+
+    Sets the selected image encoder \a settings.
+    \since 1.0
+*/
+
+#include "moc_qimageencodercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qimageencodercontrol.h b/src/multimedia/controls/qimageencodercontrol.h
new file mode 100644
index 0000000..c8a8261
--- /dev/null
+++ b/src/multimedia/controls/qimageencodercontrol.h
@@ -0,0 +1,91 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QIMAGEENCODERCONTROL_H
+#define QIMAGEENCODERCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qmediarecorder.h"
+#include "qmediaencodersettings.h"
+
+#include <QtCore/qsize.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QByteArray;
+class QStringList;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class Q_MULTIMEDIA_EXPORT QImageEncoderControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QImageEncoderControl();    
+
+    virtual QStringList supportedImageCodecs() const = 0;
+    virtual QString imageCodecDescription(const QString &codecName) const = 0;
+
+    virtual QList<QSize> supportedResolutions(const QImageEncoderSettings &settings,
+                                              bool *continuous = 0) const = 0;
+
+    virtual QImageEncoderSettings imageSettings() const = 0;
+    virtual void setImageSettings(const QImageEncoderSettings &settings) = 0;
+
+protected:
+    QImageEncoderControl(QObject *parent = 0);
+};
+
+#define QImageEncoderControl_iid "com.nokia.Qt.QImageEncoderControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QImageEncoderControl, QImageEncoderControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
diff --git a/src/multimedia/controls/qmediabackgroundplaybackcontrol.cpp b/src/multimedia/controls/qmediabackgroundplaybackcontrol.cpp
new file mode 100644
index 0000000..d7cbd38
--- /dev/null
+++ b/src/multimedia/controls/qmediabackgroundplaybackcontrol.cpp
@@ -0,0 +1,149 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediabackgroundplaybackcontrol.h"
+#include "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QMediaBackgroundPlaybackControl
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 5.0
+
+
+    \brief The QMediaBackgroundPlaybackControl class provides access to the background playback
+    related control of a QMediaService.
+
+    If a QMediaService can play media in background, it should implement QMediaBackgroundPlaybackControl.
+    This control provides a means to set the \l {setContextId()}{contextId} for application,
+    \l {acquire()}{acquire the resource for playback} and \l {release()} {release the playback resource}.
+
+    The interface name of QMediaBackgroundPlaybackControl is \c com.nokia.Qt.QMediaBackgroundPlaybackControl/1.0 as
+    defined in QMediaBackgroundPlaybackControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaPlayer
+*/
+
+/*!
+    \macro QMediaBackgroundPlaybackControl_iid
+
+    \c com.nokia.Qt.QMediaBackgroundPlaybackControl/1.0
+
+    Defines the interface name of the QMediaBackgroundPlaybackControl class.
+
+    \relates QMediaBackgroundPlaybackControl
+*/
+
+/*!
+    Destroys a media background playback control.
+*/
+QMediaBackgroundPlaybackControl::~QMediaBackgroundPlaybackControl()
+{
+}
+
+/*!
+    Constructs a new media background playback control with the given \a parent.
+*/
+QMediaBackgroundPlaybackControl::QMediaBackgroundPlaybackControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    \fn QMediaBackgroundPlaybackControl::setContextId(const QString& contextId)
+
+    Sets the contextId for the application, the last contextId will be released if previously set.
+    \l {acquire()}{acquire method} will be automatically invoked after setting a new contextId.
+
+    contextId is an unique string set by the application and is used by the background daemon to
+    distinguish and manage different context for different application.
+
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaBackgroundPlaybackControl::acquire()
+
+    Try to acquire the playback resource for current application
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaBackgroundPlaybackControl::release()
+
+    Give up the playback resource if current applicaiton holds it.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaBackgroundPlaybackControl::isAcquired()
+    \brief indicate whether the background playback resource is granted or not
+
+    It may take sometime for the backend to actually update this value before the first use.
+
+    By default this property is false
+
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaBackgroundPlaybackControl::acquired()
+
+    Signals that the playback resource is acquired
+
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaBackgroundPlaybackControl::lost()
+
+    Signals that the playback resource is lost
+
+    \since 1.0
+*/
+
+#include "moc_qmediabackgroundplaybackcontrol.cpp"
+QT_END_NAMESPACE
+
+
diff --git a/src/multimedia/controls/qmediabackgroundplaybackcontrol.h b/src/multimedia/controls/qmediabackgroundplaybackcontrol.h
new file mode 100644
index 0000000..2cf8d19
--- /dev/null
+++ b/src/multimedia/controls/qmediabackgroundplaybackcontrol.h
@@ -0,0 +1,83 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIABACKGROUNDPLAYBACKCONTROL_H
+#define QMEDIABACKGROUNDPLAYBACKCONTROL_H
+
+#include "qmediacontrol.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QMediaBackgroundPlaybackControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QMediaBackgroundPlaybackControl();
+
+    virtual void setContextId(const QString& contextId) = 0;
+    virtual void acquire() = 0;
+    virtual void release() = 0;
+
+    virtual bool isAcquired() const = 0;
+
+Q_SIGNALS:
+    void acquired();
+    void lost();
+
+protected:
+    QMediaBackgroundPlaybackControl(QObject* parent = 0);
+};
+
+#define QMediaBackgroundPlaybackControl_iid "com.nokia.Qt.QMediaBackgroundPlaybackControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaBackgroundPlaybackControl, QMediaBackgroundPlaybackControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QMEDIABACKGROUNDPLAYBACKCONTROL_H
diff --git a/src/multimedia/controls/qmediacontainercontrol.cpp b/src/multimedia/controls/qmediacontainercontrol.cpp
new file mode 100644
index 0000000..5a4e618
--- /dev/null
+++ b/src/multimedia/controls/qmediacontainercontrol.cpp
@@ -0,0 +1,126 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#include "qmediacontainercontrol.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaContainerControl
+
+    \brief The QMediaContainerControl class provides access to the output container format of a QMediaService
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+    If a QMediaService supports writing encoded data it will implement
+    QMediaContainerControl.  This control provides information about the output
+    containers supported by a media service and allows one to be selected as
+    the current output containers.
+
+    The functionality provided by this control is exposed to application code
+    through the QMediaRecorder class.
+
+    The interface name of QMediaContainerControl is \c com.nokia.Qt.QMediaContainerControl/1.0 as
+    defined in QMediaContainerControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaRecorder
+*/
+
+/*!
+    \macro QMediaContainerControl_iid
+
+    \c com.nokia.Qt.QMediaContainerControl/1.0
+
+    Defines the interface name of the QMediaContainerControl class.
+
+    \relates QMediaContainerControl
+*/
+
+/*!
+    Constructs a new media container control with the given \a parent.
+*/
+QMediaContainerControl::QMediaContainerControl(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys a media container control.
+*/
+QMediaContainerControl::~QMediaContainerControl()
+{
+}
+
+
+/*!
+    \fn QMediaContainerControl::supportedContainers() const
+
+    Returns a list of MIME types of supported container formats.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaContainerControl::containerMimeType() const
+
+    Returns the MIME type of the selected container format.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaContainerControl::setContainerMimeType(const QString &mimeType)
+
+    Sets the current container format to the format identified by the given \a mimeType.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaContainerControl::containerDescription(const QString &mimeType) const
+
+    Returns a description of the container format identified by the given \a mimeType.
+    \since 1.0
+*/
+
+#include "moc_qmediacontainercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qmediacontainercontrol.h b/src/multimedia/controls/qmediacontainercontrol.h
new file mode 100644
index 0000000..af48605
--- /dev/null
+++ b/src/multimedia/controls/qmediacontainercontrol.h
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QMEDIACONTAINERCONTROL_H
+#define QMEDIACONTAINERCONTROL_H
+
+#include "qmediacontrol.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QMediaContainerControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QMediaContainerControl();
+
+    virtual QStringList supportedContainers() const = 0;
+    virtual QString containerMimeType() const = 0;
+    virtual void setContainerMimeType(const QString &formatMimeType) = 0;
+
+    virtual QString containerDescription(const QString &formatMimeType) const = 0;
+
+protected:
+    QMediaContainerControl(QObject *parent = 0);
+};
+
+#define QMediaContainerControl_iid "com.nokia.Qt.QMediaContainerControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaContainerControl, QMediaContainerControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QMEDIACONTAINERCONTROL_H
diff --git a/src/multimedia/controls/qmediagaplessplaybackcontrol.cpp b/src/multimedia/controls/qmediagaplessplaybackcontrol.cpp
new file mode 100644
index 0000000..84363e0
--- /dev/null
+++ b/src/multimedia/controls/qmediagaplessplaybackcontrol.cpp
@@ -0,0 +1,165 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediagaplessplaybackcontrol.h"
+#include "qmediacontrol_p.h"
+
+/*!
+    \class QMediaGaplessPlaybackControl
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 5.0
+
+    \brief The QMediaGaplessPlaybackControl class provides access to the gapless playback
+    related control of a QMediaService.
+
+    If a QMediaService supports gapless playback it will implement QMediaGaplessPlaybackControl.
+    This control provides a means to set the \l {setNextMedia()}{next media} or
+    \l {setCrossfadeTime()}{crossfade time} for smooth transitions between tracks.
+
+    The functionality provided by this control is exposed to application
+    code through the QMediaPlayer class.
+
+    The interface name of QMediaGaplessPlaybackControl is
+    \c com.nokia.Qt.QMediaGaplessPlaybackControl/1.0 as defined in QMediaGaplessPlaybackControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaPlayer
+*/
+
+/*!
+    \macro QMediaGaplessPlaybackControl_iid
+
+    \c com.nokia.Qt.QMediaGaplessPlaybackControl/1.0
+
+    Defines the interface name of the QMediaGaplessPlaybackControl class.
+
+    \relates QMediaGaplessPlaybackControl
+*/
+
+/*!
+    Destroys a gapless playback control.
+*/
+QMediaGaplessPlaybackControl::~QMediaGaplessPlaybackControl()
+{
+}
+
+/*!
+    Constructs a new gapless playback control with the given \a parent.
+*/
+QMediaGaplessPlaybackControl::QMediaGaplessPlaybackControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    \fn QMediaGaplessPlaybackControl::nextMedia() const
+
+    Returns the content of the next media
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaGaplessPlaybackControl::setNextMedia(const QMediaContent& media)
+
+    Sets the next media for smooth transition.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaGaplessPlaybackControl::nextMediaChanged(const QMediaContent& media)
+
+    Signals that the next media has changed (either explicitly via \l setNextMedia() or when the
+    player clears the next media while advancing to it).
+
+    \since 1.0
+    \sa nextMedia()
+*/
+
+/*!
+    \fn QMediaGaplessPlaybackControl::advancedToNextMedia()
+
+    Signals when the player advances to the next media (the content of next media will be cleared).
+
+    \since 1.0
+    \sa nextMedia()
+*/
+
+/*!
+    \fn QMediaGaplessPlaybackControl::isCrossfadeSupported() const
+
+    Indicates whether crossfading is supported or not.
+    If crossfading is not supported, \l setCrossfadTime() will be ignored and \l crossfadeTime() will
+    always return 0.
+
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaGaplessPlaybackControl::setCrossfadeTime(qreal crossfadeTime)
+
+    Sets the crossfade time in seconds for smooth transition.
+
+    Positive value means how much time it will take for the next media to transit from silent to
+    full volume and vice versa for current one. So both current and the next one will be playing
+    during this period of time.
+
+    A crossfade time of zero or negative will result in gapless playback (suitable for some
+    continuous media).
+
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaGaplessPlaybackControl::crossfadeTime() const
+
+    Returns current crossfade time in seconds.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaGaplessPlaybackControl::crossfadeTimeChanged(qreal crossfadeTime)
+
+    Signals that the crossfade time has changed.
+
+    \since 1.0
+    \sa crossfadeTime()
+*/
+
diff --git a/src/multimedia/controls/qmediagaplessplaybackcontrol.h b/src/multimedia/controls/qmediagaplessplaybackcontrol.h
new file mode 100644
index 0000000..1ee548d
--- /dev/null
+++ b/src/multimedia/controls/qmediagaplessplaybackcontrol.h
@@ -0,0 +1,82 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QMEDIAGAPLESSPLAYBACKCONTROL_H
+#define QMEDIAGAPLESSPLAYBACKCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qmediacontent.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class Q_MULTIMEDIA_EXPORT QMediaGaplessPlaybackControl : public QMediaControl
+{
+    Q_OBJECT
+public:
+    virtual ~QMediaGaplessPlaybackControl();
+
+    virtual QMediaContent nextMedia() const = 0;
+    virtual void setNextMedia(const QMediaContent &media) = 0;
+
+    virtual bool isCrossfadeSupported() const = 0;
+    virtual qreal crossfadeTime() const = 0;
+    virtual void setCrossfadeTime(qreal crossfadeTime) = 0;
+
+Q_SIGNALS:
+    void crossfadeTimeChanged(qreal crossfadeTime);
+    void nextMediaChanged(const QMediaContent& media);
+    void advancedToNextMedia();
+
+protected:
+    QMediaGaplessPlaybackControl(QObject* parent = 0);
+};
+
+#define QMediaGaplessPlaybackControl_iid "com.nokia.Qt.QMediaGaplessPlaybackControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaGaplessPlaybackControl, QMediaGaplessPlaybackControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QMEDIAGAPLESSPLAYBACKCONTROL_H
diff --git a/src/multimedia/controls/qmedianetworkaccesscontrol.cpp b/src/multimedia/controls/qmedianetworkaccesscontrol.cpp
new file mode 100644
index 0000000..a976859
--- /dev/null
+++ b/src/multimedia/controls/qmedianetworkaccesscontrol.cpp
@@ -0,0 +1,103 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmedianetworkaccesscontrol.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaNetworkAccessControl
+    \preliminary
+    \brief The QMediaNetworkAccessControl class allows the setting of the Network Access Point for media related activities.
+    \ingroup multimedia-serv
+    \inmodule QtMultimedia
+    \since 1.2
+
+    The functionality provided by this control allows the
+    setting of a Network Access Point.
+
+    This control can be used to set a network access for various
+    network related activities. the exact nature in dependant on the underlying
+    usage by the supported QMediaObject
+*/
+
+QMediaNetworkAccessControl::QMediaNetworkAccessControl(QObject *parent) :
+    QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys a network access control.
+*/
+QMediaNetworkAccessControl::~QMediaNetworkAccessControl()
+{
+}
+
+/*!
+    \fn void QMediaNetworkAccessControl::setConfigurations(const QList<QNetworkConfiguration> &configurations);
+
+    \a configurations contains a list of network configurations to be used for network access.
+
+    It is assumed the list is given in highest to lowest preference order.
+    By calling this function all previous configurations will be invalidated
+    and replaced with the new list.
+    \since 1.2
+*/
+
+/*
+    \fn QNetworkConfiguration QMediaNetworkAccessControl::currentConfiguration() const
+
+    Returns the current active configuration in use.
+    A default constructed QNetworkConfigration is returned if no user supplied configuration are in use.
+*/
+
+
+/*!
+    \fn QMediaNetworkAccessControl::configurationChanged(const QNetworkConfiguration &configuration)
+    This signal is emitted when the current active network configuration changes
+    to \a configuration.
+    \since 1.2
+*/
+
+
+
+#include "moc_qmedianetworkaccesscontrol.cpp"
+QT_END_NAMESPACE
diff --git a/src/multimedia/controls/qmedianetworkaccesscontrol.h b/src/multimedia/controls/qmedianetworkaccesscontrol.h
new file mode 100644
index 0000000..22ee957
--- /dev/null
+++ b/src/multimedia/controls/qmedianetworkaccesscontrol.h
@@ -0,0 +1,83 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QMEDIANETWORKACCESSCONTROL_H
+#define QMEDIANETWORKACCESSCONTROL_H
+
+#include "qmediacontrol.h"
+
+#include <QtCore/qlist.h>
+#include <QtNetwork/qnetworkconfiguration.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QMediaNetworkAccessControl : public QMediaControl
+{
+    Q_OBJECT
+public:
+
+    virtual ~QMediaNetworkAccessControl();
+
+    virtual void setConfigurations(const QList<QNetworkConfiguration> &configuration) = 0;
+    virtual QNetworkConfiguration currentConfiguration() const = 0;
+
+Q_SIGNALS:
+    void configurationChanged(const QNetworkConfiguration& configuration);
+
+protected:
+    QMediaNetworkAccessControl(QObject *parent = 0);
+};
+
+#define QMediaNetworkAccessControl_iid "com.nokia.Qt.QMediaNetworkAccessControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaNetworkAccessControl, QMediaNetworkAccessControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
diff --git a/src/multimedia/controls/qmediaplayercontrol.cpp b/src/multimedia/controls/qmediaplayercontrol.cpp
new file mode 100644
index 0000000..2585b04
--- /dev/null
+++ b/src/multimedia/controls/qmediaplayercontrol.cpp
@@ -0,0 +1,414 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaplayercontrol.h"
+#include "qmediacontrol_p.h"
+#include "qmediaplayer.h"
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QMediaPlayerControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+
+    \brief The QMediaPlayerControl class provides access to the media playing
+    functionality of a QMediaService.
+
+    If a QMediaService can play media is will implement QMediaPlayerControl.
+    This control provides a means to set the \l {setMedia()}{media} to play,
+    \l {play()}{start}, \l {pause()} {pause} and \l {stop()}{stop} playback,
+    \l {setPosition()}{seek}, and control the \l {setVolume()}{volume}.
+    It also provides feedback on the \l {duration()}{duration} of the media,
+    the current \l {position()}{position}, and \l {bufferStatus()}{buffering}
+    progress.
+
+    The functionality provided by this control is exposed to application
+    code through the QMediaPlayer class.
+
+    The interface name of QMediaPlayerControl is \c com.nokia.Qt.QMediaPlayerControl/1.0 as
+    defined in QMediaPlayerControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaPlayer
+*/
+
+/*!
+    \macro QMediaPlayerControl_iid
+
+    \c com.nokia.Qt.QMediaPlayerControl/1.0
+
+    Defines the interface name of the QMediaPlayerControl class.
+
+    \relates QMediaPlayerControl
+*/
+
+/*!
+    Destroys a media player control.
+*/
+QMediaPlayerControl::~QMediaPlayerControl()
+{
+}
+
+/*!
+    Constructs a new media player control with the given \a parent.
+*/
+QMediaPlayerControl::QMediaPlayerControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    \fn QMediaPlayerControl::state() const
+
+    Returns the state of a player control.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::stateChanged(QMediaPlayer::State state)
+
+    Signals that the \a state of a player control has changed.
+
+    \since 1.0
+    \sa state()
+*/
+
+/*!
+    \fn QMediaPlayerControl::mediaStatus() const
+
+    Returns the status of the current media.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::mediaStatusChanged(QMediaPlayer::MediaStatus status)
+
+    Signals that the \a status of the current media has changed.
+
+    \since 1.0
+    \sa mediaStatus()
+*/
+
+
+/*!
+    \fn QMediaPlayerControl::duration() const
+
+    Returns the duration of the current media in milliseconds.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::durationChanged(qint64 duration)
+
+    Signals that the \a duration of the current media has changed.
+
+    \since 1.0
+    \sa duration()
+*/
+
+/*!
+    \fn QMediaPlayerControl::position() const
+
+    Returns the current playback position in milliseconds.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::setPosition(qint64 position)
+
+    Sets the playback \a position of the current media.  This will initiate a seek and it may take
+    some time for playback to reach the position set.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::positionChanged(qint64 position)
+
+    Signals the playback \a position has changed.
+
+    This is only emitted in when there has been a discontinous change in the playback postion, such
+    as a seek or the position being reset.
+
+    \since 1.0
+    \sa position()
+*/
+
+/*!
+    \fn QMediaPlayerControl::volume() const
+
+    Returns the audio volume of a player control.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::setVolume(int volume)
+
+    Sets the audio \a volume of a player control.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::volumeChanged(int volume)
+
+    Signals the audio \a volume of a player control has changed.
+
+    \since 1.0
+    \sa volume()
+*/
+
+/*!
+    \fn QMediaPlayerControl::isMuted() const
+
+    Returns the mute state of a player control.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::setMuted(bool mute)
+
+    Sets the \a mute state of a player control.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::mutedChanged(bool mute)
+
+    Signals a change in the \a mute status of a player control.
+
+    \since 1.0
+    \sa isMuted()
+*/
+
+/*!
+    \fn QMediaPlayerControl::bufferStatus() const
+
+    Returns the buffering progress of the current media.  Progress is measured in the percentage
+    of the buffer filled.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::bufferStatusChanged(int progress)
+
+    Signals that buffering \a progress has changed.
+
+    \since 1.0
+    \sa bufferStatus()
+*/
+
+/*!
+    \fn QMediaPlayerControl::isAudioAvailable() const
+
+    Identifies if there is audio output available for the current media.
+
+    Returns true if audio output is available and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::audioAvailableChanged(bool audio)
+
+    Signals that there has been a change in the availability of \a audio output.
+
+    \since 1.0
+    \sa isAudioAvailable()
+*/
+
+/*!
+    \fn QMediaPlayerControl::isVideoAvailable() const
+
+    Identifies if there is video output available for the current media.
+
+    Returns true if video output is available and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::videoAvailableChanged(bool video)
+
+    Signals that there has been a change in the availability of \a video output.
+
+    \since 1.0
+    \sa isVideoAvailable()
+*/
+
+/*!
+    \fn QMediaPlayerControl::isSeekable() const
+
+    Identifies if the current media is seekable.
+
+    Returns true if it possible to seek within the current media, and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::seekableChanged(bool seekable)
+
+    Signals that the \a seekable state of a player control has changed.
+
+    \since 1.0
+    \sa isSeekable()
+*/
+
+/*!
+    \fn QMediaPlayerControl::availablePlaybackRanges() const
+
+    Returns a range of times in milliseconds that can be played back.
+
+    Usually for local files this is a continuous interval equal to [0..duration()]
+    or an empty time range if seeking is not supported, but for network sources
+    it refers to the buffered parts of the media.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::availablePlaybackRangesChanged(const QMediaTimeRange &ranges)
+
+    Signals that the available media playback \a ranges have changed.
+
+    \since 1.0
+    \sa QMediaPlayerControl::availablePlaybackRanges()
+*/
+
+/*!
+    \fn qreal QMediaPlayerControl::playbackRate() const
+
+    Returns the rate of playback.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::setPlaybackRate(qreal rate)
+
+    Sets the \a rate of playback.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::media() const
+
+    Returns the current media source.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::mediaStream() const
+
+    Returns the current media stream. This is only a valid if a stream was passed to setMedia().
+
+    \since 1.0
+    \sa setMedia()
+*/
+
+/*!
+    \fn QMediaPlayerControl::setMedia(const QMediaContent &media, QIODevice *stream)
+
+    Sets the current \a media source.  If a \a stream is supplied; data will be read from that
+    instead of attempting to resolve the media source.  The media source may still be used to
+    supply media information such as mime type.
+
+    Setting the media to a null QMediaContent will cause the control to discard all
+    information relating to the current media source and to cease all I/O operations related
+    to that media.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::mediaChanged(const QMediaContent& content)
+
+    Signals that the current media \a content has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::play()
+
+    Starts playback of the current media.
+
+    If successful the player control will immediately enter the \l {QMediaPlayer::PlayingState}
+    {playing} state.
+
+    \since 1.0
+    \sa state()
+*/
+
+/*!
+    \fn QMediaPlayerControl::pause()
+
+    Pauses playback of the current media.
+
+    If sucessful the player control will immediately enter the \l {QMediaPlayer::PausedState}
+    {paused} state.
+
+    \since 1.0
+    \sa state(), play(), stop()
+*/
+
+/*!
+    \fn QMediaPlayerControl::stop()
+
+    Stops playback of the current media.
+
+    If successful the player control will immediately enter the \l {QMediaPlayer::StoppedState}
+    {stopped} state.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::error(int error, const QString &errorString)
+
+    Signals that an \a error has occurred.  The \a errorString provides a more detailed explanation.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlayerControl::playbackRateChanged(qreal rate)
+
+    Signal emitted when playback rate changes to \a rate.
+    \since 1.0
+*/
+
+#include "moc_qmediaplayercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qmediaplayercontrol.h b/src/multimedia/controls/qmediaplayercontrol.h
new file mode 100644
index 0000000..a6e02ee
--- /dev/null
+++ b/src/multimedia/controls/qmediaplayercontrol.h
@@ -0,0 +1,131 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAPLAYERCONTROL_H
+#define QMEDIAPLAYERCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qmediaplayer.h"
+#include "qmediatimerange.h"
+
+#include <QtCore/qpair.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QMediaPlaylist;
+
+class Q_MULTIMEDIA_EXPORT QMediaPlayerControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QMediaPlayerControl();
+
+    virtual QMediaPlayer::State state() const = 0;
+
+    virtual QMediaPlayer::MediaStatus mediaStatus() const = 0;
+
+    virtual qint64 duration() const = 0;
+
+    virtual qint64 position() const = 0;
+    virtual void setPosition(qint64 position) = 0;
+
+    virtual int volume() const = 0;
+    virtual void setVolume(int volume) = 0;
+
+    virtual bool isMuted() const = 0;
+    virtual void setMuted(bool muted) = 0;
+
+    virtual int bufferStatus() const = 0;
+
+    virtual bool isAudioAvailable() const = 0;
+    virtual bool isVideoAvailable() const = 0;
+
+    virtual bool isSeekable() const = 0;
+
+    virtual QMediaTimeRange availablePlaybackRanges() const = 0;
+
+    virtual qreal playbackRate() const = 0;
+    virtual void setPlaybackRate(qreal rate) = 0;
+
+    virtual QMediaContent media() const = 0;
+    virtual const QIODevice *mediaStream() const = 0;
+    virtual void setMedia(const QMediaContent &media, QIODevice *stream) = 0;
+
+    virtual void play() = 0;
+    virtual void pause() = 0;
+    virtual void stop() = 0;
+
+Q_SIGNALS:
+    void mediaChanged(const QMediaContent& content);
+    void durationChanged(qint64 duration);
+    void positionChanged(qint64 position);
+    void stateChanged(QMediaPlayer::State newState);
+    void mediaStatusChanged(QMediaPlayer::MediaStatus status);
+    void volumeChanged(int volume);
+    void mutedChanged(bool muted);
+    void audioAvailableChanged(bool audioAvailable);
+    void videoAvailableChanged(bool videoAvailable);
+    void bufferStatusChanged(int percentFilled);
+    void seekableChanged(bool);
+    void availablePlaybackRangesChanged(const QMediaTimeRange&);
+    void playbackRateChanged(qreal rate);
+    void error(int error, const QString &errorString);
+
+protected:
+    QMediaPlayerControl(QObject* parent = 0);
+};
+
+#define QMediaPlayerControl_iid "com.nokia.Qt.QMediaPlayerControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaPlayerControl, QMediaPlayerControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QMEDIAPLAYERCONTROL_H
+
diff --git a/src/multimedia/controls/qmediaplaylistcontrol.cpp b/src/multimedia/controls/qmediaplaylistcontrol.cpp
new file mode 100644
index 0000000..dc23489
--- /dev/null
+++ b/src/multimedia/controls/qmediaplaylistcontrol.cpp
@@ -0,0 +1,219 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#include "qmediaplaylistcontrol.h"
+#include "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaPlaylistControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+
+    \brief The QMediaPlaylistControl class provides access to the playlist
+    functionality of a QMediaService.
+
+    If a QMediaService contains an internal playlist it will implement
+    QMediaPlaylistControl.  This control provides access to the contents of the
+    \l {playlistProvider()}{playlist}, as well as the \l
+    {currentIndex()}{position} of the current media, and a means of navigating
+    to the \l {next()}{next} and \l {previous()}{previous} media.
+
+    The functionality provided by the control is exposed to application code
+    through the QMediaPlaylist class.
+
+    The interface name of QMediaPlaylistControl is \c com.nokia.Qt.QMediaPlaylistControl/1.0 as
+    defined in QMediaPlaylistControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaPlayer
+*/
+
+/*!
+    \macro QMediaPlaylistControl_iid
+
+    \c com.nokia.Qt.QMediaPlaylistControl/1.0
+
+    Defines the interface name of the QMediaPlaylistControl class.
+
+    \relates QMediaPlaylistControl
+*/
+
+/*!
+  Create a new playlist control object with the given \a parent.
+*/
+QMediaPlaylistControl::QMediaPlaylistControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+  Destroys the playlist control.
+*/
+QMediaPlaylistControl::~QMediaPlaylistControl()
+{
+}
+
+
+/*!
+  \fn QMediaPlaylistControl::playlistProvider() const
+
+  Returns the playlist used by this media player.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::setPlaylistProvider(QMediaPlaylistProvider *playlist)
+
+  Set the playlist of this media player to \a playlist.
+
+  In many cases it is possible just to use the playlist
+  constructed by player, but sometimes replacing the whole
+  playlist allows to avoid copyting of all the items bettween playlists.
+
+  Returns true if player can use this passed playlist; otherwise returns false.
+
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::currentIndex() const
+
+  Returns position of the current media source in the playlist.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::setCurrentIndex(int position)
+
+  Jump to the item at the given \a position.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::nextIndex(int step) const
+
+  Returns the index of item, which were current after calling next()
+  \a step times.
+
+  Returned value depends on the size of playlist, current position
+  and playback mode.
+
+  \since 1.0
+  \sa QMediaPlaylist::playbackMode
+*/
+
+/*!
+  \fn QMediaPlaylistControl::previousIndex(int step) const
+
+  Returns the index of item, which were current after calling previous()
+  \a step times.
+
+  \since 1.0
+  \sa QMediaPlaylist::playbackMode
+*/
+
+/*!
+  \fn QMediaPlaylistControl::next()
+
+  Moves to the next item in playlist.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::previous()
+
+  Returns to the previous item in playlist.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::playbackMode() const
+
+  Returns the playlist navigation mode.
+
+  \since 1.0
+  \sa QMediaPlaylist::PlaybackMode
+*/
+
+/*!
+  \fn QMediaPlaylistControl::setPlaybackMode(QMediaPlaylist::PlaybackMode mode)
+
+  Sets the playback \a mode.
+
+  \since 1.0
+  \sa QMediaPlaylist::PlaybackMode
+*/
+
+/*!
+  \fn QMediaPlaylistControl::playlistProviderChanged()
+
+  Signal emitted when the playlist provider has changed.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::currentIndexChanged(int position)
+
+  Signal emitted when the playlist \a position is changed.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::playbackModeChanged(QMediaPlaylist::PlaybackMode mode)
+
+  Signal emitted when the playback \a mode is changed.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistControl::currentMediaChanged(const QMediaContent& content)
+
+  Signal emitted when current media changes to \a content.
+  \since 1.0
+*/
+
+#include "moc_qmediaplaylistcontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qmediaplaylistcontrol.h b/src/multimedia/controls/qmediaplaylistcontrol.h
new file mode 100644
index 0000000..2cce448
--- /dev/null
+++ b/src/multimedia/controls/qmediaplaylistcontrol.h
@@ -0,0 +1,98 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QMEDIAPLAYLISTCONTROL_H
+#define QMEDIAPLAYLISTCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qmediaplaylistnavigator.h"
+
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QMediaPlaylistProvider;
+
+class Q_MULTIMEDIA_EXPORT QMediaPlaylistControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QMediaPlaylistControl();
+
+    virtual QMediaPlaylistProvider* playlistProvider() const = 0;
+    virtual bool setPlaylistProvider(QMediaPlaylistProvider *playlist) = 0;
+
+    virtual int currentIndex() const = 0;
+    virtual void setCurrentIndex(int position) = 0;
+    virtual int nextIndex(int steps) const = 0;
+    virtual int previousIndex(int steps) const = 0;
+
+    virtual void next() = 0;
+    virtual void previous() = 0;
+
+    virtual QMediaPlaylist::PlaybackMode playbackMode() const = 0;
+    virtual void setPlaybackMode(QMediaPlaylist::PlaybackMode mode) = 0;
+
+Q_SIGNALS:
+    void playlistProviderChanged();
+    void currentIndexChanged(int position);
+    void currentMediaChanged(const QMediaContent&);
+    void playbackModeChanged(QMediaPlaylist::PlaybackMode mode);
+
+protected:
+    QMediaPlaylistControl(QObject* parent = 0);
+};
+
+#define QMediaPlaylistControl_iid "com.nokia.Qt.QMediaPlaylistControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaPlaylistControl, QMediaPlaylistControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QMEDIAPLAYLISTCONTROL_H
diff --git a/src/multimedia/controls/qmediaplaylistsourcecontrol.cpp b/src/multimedia/controls/qmediaplaylistsourcecontrol.cpp
new file mode 100644
index 0000000..2ab8aee
--- /dev/null
+++ b/src/multimedia/controls/qmediaplaylistsourcecontrol.cpp
@@ -0,0 +1,128 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#include "qmediaplaylistsourcecontrol.h"
+#include "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaPlaylistSourceControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+
+    \brief The QMediaPlaylistSourceControl class provides access to the playlist playback
+    functionality of a QMediaService.
+
+    This control allows QMediaPlaylist to be passed directly to the service
+    instead of playing media sources one by one.  This control should be
+    implemented if backend benefits from knowing the next media source to be
+    played, for example for preloading, cross fading or gap-less playback.
+
+    If QMediaPlaylistSourceControl is provided, the backend must listen for
+    current playlist item changes to load corresponding media source and
+    advance the playlist  with QMediaPlaylist::next() when playback of the
+    current media is finished.
+
+    The interface name of QMediaPlaylistSourceControl is \c com.nokia.Qt.QMediaPlaylistSourceControl/1.0 as
+    defined in QMediaPlaylistSourceControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaPlayer
+*/
+
+/*!
+    \macro QMediaPlaylistSourceControl_iid
+
+    \c com.nokia.Qt.QMediaPlaylistSourceControl/1.0
+
+    Defines the interface name of the QMediaPlaylistSourceControl class.
+
+    \relates QMediaPlaylistSourceControl
+*/
+
+/*!
+  Create a new playlist source control object with the given \a parent.
+*/
+QMediaPlaylistSourceControl::QMediaPlaylistSourceControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+  Destroys the playlist control.
+*/
+QMediaPlaylistSourceControl::~QMediaPlaylistSourceControl()
+{
+}
+
+
+/*!
+  \fn QMediaPlaylistSourceControl::playlist() const
+
+  Returns the current playlist.
+  Should return a null pointer if no playlist is assigned.
+  \since 1.0
+*/
+
+/*!
+  \fn QMediaPlaylistSourceControl::setPlaylist(QMediaPlaylist *playlist)
+
+  Set the playlist of this media player to \a playlist.
+  If a null pointer is passed, the playlist source should be disabled.
+
+  The current media should be replaced with the current item of the media playlist.
+  \since 1.0
+*/
+
+
+/*!
+  \fn QMediaPlaylistSourceControl::playlistChanged(QMediaPlaylist* playlist)
+
+  Signal emitted when the playlist has changed to \a playlist.
+  \since 1.0
+*/
+
+#include "moc_qmediaplaylistsourcecontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qmediaplaylistsourcecontrol.h b/src/multimedia/controls/qmediaplaylistsourcecontrol.h
new file mode 100644
index 0000000..040bb64
--- /dev/null
+++ b/src/multimedia/controls/qmediaplaylistsourcecontrol.h
@@ -0,0 +1,82 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QMEDIAPLAYLISTSOURCECONTROL_H
+#define QMEDIAPLAYLISTSOURCECONTROL_H
+
+#include <qmediacontrol.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QMediaPlaylist;
+
+class Q_MULTIMEDIA_EXPORT QMediaPlaylistSourceControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QMediaPlaylistSourceControl();
+
+    virtual QMediaPlaylist *playlist() const = 0;
+    virtual void setPlaylist(QMediaPlaylist *) = 0;
+
+Q_SIGNALS:
+    void playlistChanged(QMediaPlaylist* playlist);
+
+protected:
+    QMediaPlaylistSourceControl(QObject* parent = 0);
+};
+
+#define QMediaPlaylistSourceControl_iid "com.nokia.Qt.QMediaPlaylistSourceControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaPlaylistSourceControl, QMediaPlaylistSourceControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QMEDIAPLAYLISTCONTROL_H
diff --git a/src/multimedia/controls/qmediarecordercontrol.cpp b/src/multimedia/controls/qmediarecordercontrol.cpp
new file mode 100644
index 0000000..ffc5102
--- /dev/null
+++ b/src/multimedia/controls/qmediarecordercontrol.cpp
@@ -0,0 +1,209 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediarecordercontrol.h"
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QMediaRecorderControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+
+    \brief The QMediaRecorderControl class provides access to the recording
+    functionality of a QMediaService.
+
+    If a QMediaService can record media it will implement QMediaRecorderControl.
+    This control provides a means to set the \l {outputLocation()}{output location},
+    and \l {record()}{start}, \l {pause()}{pause} and \l {stop()}{stop}
+    recording.  It also provides feedback on the \l {duration()}{duration}
+    of the recording.
+
+    The functionality provided by this control is exposed to application
+    code through the QMediaRecorder class.
+
+    The interface name of QMediaRecorderControl is \c com.nokia.Qt.QMediaRecorderControl/1.0 as
+    defined in QMediaRecorderControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaRecorder
+
+*/
+
+/*!
+    \macro QMediaRecorderControl_iid
+
+    \c com.nokia.Qt.QMediaRecorderControl/1.0
+
+    Defines the interface name of the QMediaRecorderControl class.
+
+    \relates QMediaRecorderControl
+*/
+
+/*!
+    Constructs a media recorder control with the given \a parent.
+*/
+
+QMediaRecorderControl::QMediaRecorderControl(QObject* parent)
+    : QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys a media recorder control.
+*/
+
+QMediaRecorderControl::~QMediaRecorderControl()
+{
+}
+
+/*!
+    \fn QUrl QMediaRecorderControl::outputLocation() const
+
+    Returns the current output location being used.
+    \since 1.0
+*/
+
+/*!
+    \fn bool QMediaRecorderControl::setOutputLocation(const QUrl &location)
+
+    Sets the output \a location and returns if this operation is successful.
+    If file at the output location already exists, it should be overwritten.
+
+    The \a location can be relative or empty;
+    in this case the service should use the system specific place and file naming scheme.
+    After recording has stated, QMediaRecorderControl::outputLocation() should return the actual output location.
+    \since 1.0
+*/
+
+/*!
+    \fn int QMediaRecorderControl::state() const
+
+    Return the current recording state.
+    \since 1.0
+*/
+
+/*!
+    \fn qint64 QMediaRecorderControl::duration() const
+
+    Return the current duration in milliseconds.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaRecorderControl::record()
+
+    Start recording.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaRecorderControl::pause()
+
+    Pause recording.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaRecorderControl::stop()
+
+    Stop recording.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaRecorderControl::applySettings()
+
+    Commits the encoder settings and performs pre-initialization to reduce delays when recording
+    is started.
+    \since 1.0
+*/
+
+/*!
+    \fn bool QMediaRecorderControl::isMuted() const
+
+    Returns true if the recorder is muted, and false if it is not.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaRecorderControl::setMuted(bool muted)
+
+    Sets the \a muted state of a media recorder.
+    \since 1.0
+*/
+
+
+/*!
+    \fn void QMediaRecorderControl::stateChanged(QMediaRecorder::State state)
+
+    Signals that the \a state of a media recorder has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaRecorderControl::durationChanged(qint64 duration)
+
+    Signals that the \a duration of the recorded media has changed.
+
+    This only emitted when there is a discontinuous change in the duration such as being reset to 0.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaRecorderControl::mutedChanged(bool muted)
+
+    Signals that the \a muted state of a media recorder has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaRecorderControl::error(int error, const QString &errorString)
+
+    Signals that an \a error has occurred.  The \a errorString describes the error.
+    \since 1.0
+*/
+
+#include "moc_qmediarecordercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qmediarecordercontrol.h b/src/multimedia/controls/qmediarecordercontrol.h
new file mode 100644
index 0000000..26f244c
--- /dev/null
+++ b/src/multimedia/controls/qmediarecordercontrol.h
@@ -0,0 +1,101 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIARECORDERCONTROL_H
+#define QMEDIARECORDERCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qmediarecorder.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QUrl;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class Q_MULTIMEDIA_EXPORT QMediaRecorderControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QMediaRecorderControl();
+
+    virtual QUrl outputLocation() const = 0;
+    virtual bool setOutputLocation(const QUrl &location) = 0;
+
+    virtual QMediaRecorder::State state() const = 0;
+
+    virtual qint64 duration() const = 0;
+
+    virtual bool isMuted() const = 0;
+
+    virtual void applySettings() = 0;
+
+Q_SIGNALS:
+    void stateChanged(QMediaRecorder::State state);
+    void durationChanged(qint64 position);
+    void mutedChanged(bool muted);
+    void error(int error, const QString &errorString);
+
+public Q_SLOTS:
+    virtual void record() = 0;
+    virtual void pause() = 0;
+    virtual void stop() = 0;
+    virtual void setMuted(bool muted) = 0;
+
+protected:
+    QMediaRecorderControl(QObject* parent = 0);
+};
+
+#define QMediaRecorderControl_iid "com.nokia.Qt.QMediaRecorderControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaRecorderControl, QMediaRecorderControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
diff --git a/src/multimedia/controls/qmediastreamscontrol.cpp b/src/multimedia/controls/qmediastreamscontrol.cpp
new file mode 100644
index 0000000..fb624c6
--- /dev/null
+++ b/src/multimedia/controls/qmediastreamscontrol.cpp
@@ -0,0 +1,173 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediastreamscontrol.h"
+#include "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace
+{
+    class QMediaStreamsControlPrivateRegisterMetaTypes
+    {
+    public:
+        QMediaStreamsControlPrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QMediaStreamsControl::StreamType>();
+        }
+    } _registerMetaTypes;
+}
+
+/*!
+    \class QMediaStreamsControl
+    \preliminary
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \brief The QMediaStreamsControl class provides a media stream selection control.
+
+    \since 1.0
+
+    The QMediaStreamsControl class provides descriptions of the available media streams
+    and allows individual streams to be activated and deactivated.
+
+    The interface name of QMediaStreamsControl is \c com.nokia.Qt.MediaStreamsControl as
+    defined in QMediaStreamsControl_iid.
+
+    \sa QMediaService::requestControl()
+*/
+
+/*!
+    \macro QMediaStreamsControl_iid
+
+    \c com.nokia.Qt.MediaStreamsControl
+
+    Defines the interface name of the QMediaStreamsControl class.
+
+    \relates QMediaStreamsControl
+    \since 1.0
+*/
+
+/*!
+    Constructs a new media streams control with the given \a parent.
+*/
+QMediaStreamsControl::QMediaStreamsControl(QObject *parent)
+    :QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destroys a media streams control.
+*/
+QMediaStreamsControl::~QMediaStreamsControl()
+{
+}
+
+/*!
+  \enum QMediaStreamsControl::StreamType
+
+  Media stream type.
+
+  \value AudioStream Audio stream.
+  \value VideoStream Video stream.
+  \value SubPictureStream Subpicture or teletext stream.
+  \value UnknownStream The stream type is unknown.
+  \value DataStream
+*/
+
+/*!
+    \fn QMediaStreamsControl::streamCount()
+
+    Returns the number of media streams.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaStreamsControl::streamType(int stream)
+
+    Return the type of a media \a stream.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaStreamsControl::metaData(int stream, QtMultimedia::MetaData key)
+
+    Returns the meta-data value of \a key for a given \a stream.
+
+    Useful metadata keya are QtMultimedia::Title, QtMultimedia::Description and QtMultimedia::Language.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaStreamsControl::isActive(int stream)
+
+    Returns true if the media \a stream is active.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaStreamsControl::setActive(int stream, bool state)
+
+    Sets the active \a state of a media \a stream.
+
+    Setting the active state of a media stream to true will activate it.  If any other stream
+    of the same type was previously active it will be deactivated. Setting the active state fo a
+    media stream to false will deactivate it.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaStreamsControl::streamsChanged()
+
+    The signal is emitted when the available streams list is changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaStreamsControl::activeStreamsChanged()
+
+    The signal is emitted when the active streams list is changed.
+    \since 1.0
+*/
+
+#include "moc_qmediastreamscontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qmediastreamscontrol.h b/src/multimedia/controls/qmediastreamscontrol.h
new file mode 100644
index 0000000..bbd8a2a
--- /dev/null
+++ b/src/multimedia/controls/qmediastreamscontrol.h
@@ -0,0 +1,95 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QMEDIASTREAMSCONTROL_H
+#define QMEDIASTREAMSCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qtmedianamespace.h"
+#include "qtmultimediadefs.h"
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QMediaStreamsControl : public QMediaControl
+{
+    Q_OBJECT
+    Q_ENUMS(SteamType)
+public:
+    enum StreamType { UnknownStream, VideoStream, AudioStream, SubPictureStream, DataStream };
+
+    virtual ~QMediaStreamsControl();
+
+    virtual int streamCount() = 0;
+    virtual StreamType streamType(int streamNumber) = 0;
+
+    virtual QVariant metaData(int streamNumber, QtMultimedia::MetaData key) = 0;
+
+    virtual bool isActive(int streamNumber) = 0;
+    virtual void setActive(int streamNumber, bool state) = 0;
+
+Q_SIGNALS:
+    void streamsChanged();
+    void activeStreamsChanged();
+
+protected:
+    QMediaStreamsControl(QObject *parent = 0);
+};
+
+#define QMediaStreamsControl_iid "com.nokia.Qt.QMediaStreamsControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaStreamsControl, QMediaStreamsControl_iid)
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMediaStreamsControl::StreamType)
+
+Q_MEDIA_ENUM_DEBUG(QMediaStreamsControl, StreamType)
+
+QT_END_HEADER
+
+#endif // QMEDIASTREAMSCONTROL_H
+
diff --git a/src/multimedia/controls/qmetadatareadercontrol.cpp b/src/multimedia/controls/qmetadatareadercontrol.cpp
new file mode 100644
index 0000000..63dd375
--- /dev/null
+++ b/src/multimedia/controls/qmetadatareadercontrol.cpp
@@ -0,0 +1,163 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediacontrol_p.h"
+#include <qmetadatareadercontrol.h>
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QMetaDataReaderControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+
+    \brief The QMetaDataReaderControl class provides read access to the
+    meta-data of a QMediaService's media.
+
+    If a QMediaService can provide read or write access to the meta-data of
+    its current media it will implement QMetaDataReaderControl.  This control
+    provides functions for both retrieving and setting meta-data values.
+    Meta-data may be addressed by the well defined keys in the
+    QtMultimedia::MetaData enumeration using the metaData() functions, or by
+    string keys using the extendedMetaData() functions.
+
+    The functionality provided by this control is exposed to application
+    code by the meta-data members of QMediaObject, and so meta-data access
+    is potentially available in any of the media object classes.  Any media
+    service may implement QMetaDataReaderControl.
+
+    The interface name of QMetaDataReaderControl is
+    \c com.nokia.Qt.QMetaDataReaderControl/1.0 as defined in
+    QMetaDataReaderControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaObject
+*/
+
+/*!
+    \macro QMetaDataReaderControl_iid
+
+    \c com.nokia.Qt.QMetaDataReaderControl/1.0
+
+    Defines the interface name of the QMetaDataReaderControl class.
+
+    \relates QMetaDataReaderControl
+*/
+
+/*!
+    Construct a QMetaDataReaderControl with \a parent. This class is meant as a base class
+    for service specific meta data providers so this constructor is protected.
+*/
+
+QMetaDataReaderControl::QMetaDataReaderControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destroy the meta-data object.
+*/
+
+QMetaDataReaderControl::~QMetaDataReaderControl()
+{
+}
+
+/*!
+    \fn bool QMetaDataReaderControl::isMetaDataAvailable() const
+
+    Identifies if meta-data is available from a media service.
+
+    Returns true if the meta-data is available and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QVariant QMetaDataReaderControl::metaData(QtMultimedia::MetaData key) const
+
+    Returns the meta-data for the given \a key.
+    \since 1.0
+*/
+
+/*!
+    \fn QMetaDataReaderControl::availableMetaData() const
+
+    Returns a list of keys there is meta-data available for.
+    \since 1.0
+*/
+
+/*!
+    \fn QMetaDataReaderControl::extendedMetaData(const QString &key) const
+
+    Returns the metaData for an abitrary string \a key.
+
+    The valid selection of keys for extended meta-data is determined by the provider and the meaning
+    and type may differ between providers.
+    \since 1.0
+*/
+
+/*!
+    \fn QMetaDataReaderControl::availableExtendedMetaData() const
+
+    Returns a list of keys there is extended meta-data available for.
+    \since 1.0
+*/
+
+
+/*!
+    \fn void QMetaDataReaderControl::metaDataChanged()
+
+    Signal the changes of meta-data.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMetaDataReaderControl::metaDataAvailableChanged(bool available)
+
+    Signal the availability of meta-data has changed, \a available will
+    be true if the multimedia object has meta-data.
+    \since 1.0
+*/
+
+#include "moc_qmetadatareadercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qmetadatareadercontrol.h b/src/multimedia/controls/qmetadatareadercontrol.h
new file mode 100644
index 0000000..0d370b5
--- /dev/null
+++ b/src/multimedia/controls/qmetadatareadercontrol.h
@@ -0,0 +1,92 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMETADATAREADERCONTROL_H
+#define QMETADATAREADERCONTROL_H
+
+#include <qmediacontrol.h>
+#include <qmediaobject.h>
+
+#include <qmediaresource.h>
+
+#include <qtmultimediadefs.h>
+#include "qtmedianamespace.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+
+class Q_MULTIMEDIA_EXPORT QMetaDataReaderControl : public QMediaControl
+{
+    Q_OBJECT
+public:
+    ~QMetaDataReaderControl();
+
+    virtual bool isMetaDataAvailable() const = 0;
+
+    virtual QVariant metaData(QtMultimedia::MetaData key) const = 0;
+    virtual QList<QtMultimedia::MetaData> availableMetaData() const = 0;
+
+    virtual QVariant extendedMetaData(const QString &key) const = 0;
+    virtual QStringList availableExtendedMetaData() const = 0;
+
+Q_SIGNALS:
+    void metaDataChanged();
+
+    void metaDataAvailableChanged(bool available);
+
+protected:
+    QMetaDataReaderControl(QObject *parent = 0);
+};
+
+#define QMetaDataReaderControl_iid "com.nokia.Qt.QMetaDataReaderControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMetaDataReaderControl, QMetaDataReaderControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QMETADATAPROVIDER_H
diff --git a/src/multimedia/controls/qmetadatawritercontrol.cpp b/src/multimedia/controls/qmetadatawritercontrol.cpp
new file mode 100644
index 0000000..9d01662
--- /dev/null
+++ b/src/multimedia/controls/qmetadatawritercontrol.cpp
@@ -0,0 +1,195 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediacontrol_p.h"
+#include <qmetadatawritercontrol.h>
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QMetaDataWriterControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+
+    \brief The QMetaDataWriterControl class provides write access to the
+    meta-data of a QMediaService's media.
+
+    If a QMediaService can provide write access to the meta-data of its
+    current media it will implement QMetaDataWriterControl.  This control
+    provides functions for both retrieving and setting meta-data values.
+    Meta-data may be addressed by the well defined keys in the
+    QtMultimedia::MetaData enumeration using the metaData() functions, or
+    by string keys using the extendedMetaData() functions.
+
+    The functionality provided by this control is exposed to application code
+    by the meta-data members of QMediaObject, and so meta-data access is
+    potentially available in any of the media object classes.  Any media
+    service may implement QMetaDataControl.
+
+    The interface name of QMetaDataWriterControl is \c com.nokia.Qt.QMetaDataWriterControl/1.0 as
+    defined in QMetaDataWriterControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaObject
+*/
+
+/*!
+    \macro QMetaDataWriterControl_iid
+
+    \c com.nokia.Qt.QMetaDataWriterControl/1.0
+
+    Defines the interface name of the QMetaDataWriterControl class.
+
+    \relates QMetaDataWriterControl
+*/
+
+/*!
+    Construct a QMetaDataWriterControl with \a parent. This class is meant as a base class
+    for service specific meta data providers so this constructor is protected.
+*/
+
+QMetaDataWriterControl::QMetaDataWriterControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destroy the meta-data writer control.
+*/
+
+QMetaDataWriterControl::~QMetaDataWriterControl()
+{
+}
+
+/*!
+    \fn bool QMetaDataWriterControl::isMetaDataAvailable() const
+
+    Identifies if meta-data is available from a media service.
+
+    Returns true if the meta-data is available and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn bool QMetaDataWriterControl::isWritable() const
+
+    Identifies if a media service's meta-data can be edited.
+
+    Returns true if the meta-data is writable and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QVariant QMetaDataWriterControl::metaData(QtMultimedia::MetaData key) const
+
+    Returns the meta-data for the given \a key.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMetaDataWriterControl::setMetaData(QtMultimedia::MetaData key, const QVariant &value)
+
+    Sets the \a value of the meta-data element with the given \a key.
+    \since 1.0
+*/
+
+/*!
+    \fn QMetaDataWriterControl::availableMetaData() const
+
+    Returns a list of keys there is meta-data available for.
+*/
+
+/*!
+    \fn QMetaDataWriterControl::extendedMetaData(const QString &key) const
+
+    Returns the meta-data for an abitrary string \a key.
+
+    The valid selection of keys for extended meta-data is determined by the provider and the meaning
+    and type may differ between providers.
+    \since 1.0
+*/
+
+/*!
+    \fn QMetaDataWriterControl::setExtendedMetaData(const QString &key, const QVariant &value)
+
+    Change the value of the meta-data element with an abitrary string \a key to \a value.
+
+    The valid selection of keys for extended meta-data is determined by the provider and the meaning
+    and type may differ between providers.
+    \since 1.0
+*/
+
+/*!
+    \fn QMetaDataWriterControl::availableExtendedMetaData() const
+
+    Returns a list of keys there is extended meta-data available for.
+    \since 1.0
+*/
+
+
+/*!
+    \fn void QMetaDataWriterControl::metaDataChanged()
+
+    Signal the changes of meta-data.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMetaDataWriterControl::metaDataAvailableChanged(bool available)
+
+    Signal the availability of meta-data has changed, \a available will
+    be true if the multimedia object has meta-data.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMetaDataWriterControl::writableChanged(bool writable)
+
+    Signal a change in the writable status of meta-data, \a writable will be
+    true if meta-data elements can be added or adjusted.
+    \since 1.0
+*/
+
+#include "moc_qmetadatawritercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qmetadatawritercontrol.h b/src/multimedia/controls/qmetadatawritercontrol.h
new file mode 100644
index 0000000..3f8b8c3
--- /dev/null
+++ b/src/multimedia/controls/qmetadatawritercontrol.h
@@ -0,0 +1,97 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMETADATAWRITERCONTROL_H
+#define QMETADATAWRITERCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qmediaobject.h"
+
+#include "qmediaresource.h"
+
+#include <qtmultimediadefs.h>
+#include "qtmedianamespace.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+
+class Q_MULTIMEDIA_EXPORT QMetaDataWriterControl : public QMediaControl
+{
+    Q_OBJECT
+public:
+    ~QMetaDataWriterControl();
+
+    virtual bool isWritable() const = 0;
+    virtual bool isMetaDataAvailable() const = 0;
+
+    virtual QVariant metaData(QtMultimedia::MetaData key) const = 0;
+    virtual void setMetaData(QtMultimedia::MetaData key, const QVariant &value) = 0;
+    virtual QList<QtMultimedia::MetaData> availableMetaData() const = 0;
+
+    virtual QVariant extendedMetaData(const QString &key) const = 0;
+    virtual void setExtendedMetaData(const QString &key, const QVariant &value) = 0;
+    virtual QStringList availableExtendedMetaData() const = 0;
+
+
+Q_SIGNALS:
+    void metaDataChanged();
+
+    void writableChanged(bool writable);
+    void metaDataAvailableChanged(bool available);
+
+protected:
+    QMetaDataWriterControl(QObject *parent = 0);
+};
+
+#define QMetaDataWriterControl_iid "com.nokia.Qt.QMetaDataWriterControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMetaDataWriterControl, QMetaDataWriterControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
diff --git a/src/multimedia/controls/qradiodatacontrol.cpp b/src/multimedia/controls/qradiodatacontrol.cpp
new file mode 100644
index 0000000..28b9a99
--- /dev/null
+++ b/src/multimedia/controls/qradiodatacontrol.cpp
@@ -0,0 +1,216 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qtmultimediadefs.h>
+#include "qradiodatacontrol.h"
+#include "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QRadioDataControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 5.0
+
+
+    \brief The QRadioDataControl class provides access to the RDS functionality of the
+    radio in the QMediaService.
+
+    The functionality provided by this control is exposed to application code
+    through the QRadioData class.
+
+    The interface name of QRadioDataControl is \c com.nokia.Qt.QRadioDataControl/5.0 as
+    defined in QRadioDataControl_iid.
+
+    \sa QMediaService::requestControl(), QRadioData
+*/
+
+/*!
+    \macro QRadioDataControl_iid
+
+    \c com.nokia.Qt.QRadioDataControl/5.0
+
+    Defines the interface name of the QRadioDataControl class.
+
+    \relates QRadioDataControl
+*/
+
+/*!
+    Constructs a radio data control with the given \a parent.
+*/
+
+QRadioDataControl::QRadioDataControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destroys a radio data control.
+*/
+
+QRadioDataControl::~QRadioDataControl()
+{
+}
+
+/*!
+    \fn bool QRadioDataControl::isAvailable() const
+
+    Returns true if the radio service is ready to use.
+    \since 5.0
+*/
+
+/*!
+    \fn QtMultimedia::AvailabilityError QRadioDataControl::availabilityError() const
+
+    Returns the error state of the radio service.
+    \since 5.0
+*/
+
+/*!
+    \fn QRadioData::Error QRadioDataControl::error() const
+
+    Returns the error state of a radio data.
+    \since 5.0
+*/
+
+/*!
+    \fn QString QRadioDataControl::errorString() const
+
+    Returns a string describing a radio data's error state.
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioDataControl::error(QRadioData::Error error)
+
+    Signals that an \a error has occurred.
+    \since 5.0
+*/
+
+/*!
+    \fn int QRadioDataControl::stationId()
+
+    Returns the current Program Identification
+    \since 5.0
+*/
+
+/*!
+    \fn QRadioData::ProgramType QRadioDataControl::programType()
+
+    Returns the current Program Type
+    \since 5.0
+*/
+
+/*!
+    \fn QString QRadioDataControl::programTypeName()
+
+    Returns the current Program Type Name
+    \since 5.0
+*/
+
+/*!
+    \fn QString QRadioDataControl::stationName()
+
+    Returns the current Program Service
+    \since 5.0
+*/
+
+/*!
+    \fn QString QRadioDataControl::radioText()
+
+    Returns the current Radio Text
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioDataControl::setAlternativeFrequenciesEnabled(bool enabled)
+
+    Sets the Alternative Frequency to \a enabled
+    \since 5.0
+*/
+
+/*!
+    \fn bool QRadioDataControl::isAlternativeFrequenciesEnabled()
+
+    Returns true if Alternative Frequency is currently enabled
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioDataControl::stationIdChanged(QString stationId)
+
+    Signals that the Program Identification \a stationId has changed
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioDataControl::programTypeChanged(QRadioData::ProgramType programType)
+
+    Signals that the Program Type \a programType has changed
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioDataControl::programTypeNameChanged(QString programTypeName)
+
+    Signals that the Program Type Name \a programTypeName has changed
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioDataControl::stationNameChanged(QString stationName)
+
+    Signals that the Program Service \a stationName has changed
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioDataControl::radioTextChanged(QString radioText)
+
+    Signals that the Radio Text \a radioText has changed
+    \since 5.0
+*/
+
+#include "moc_qradiodatacontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qradiodatacontrol.h b/src/multimedia/controls/qradiodatacontrol.h
new file mode 100644
index 0000000..487236c
--- /dev/null
+++ b/src/multimedia/controls/qradiodatacontrol.h
@@ -0,0 +1,97 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QRADIODATACONTROL_H
+#define QRADIODATACONTROL_H
+
+#include "qmediacontrol.h"
+#include "qradiodata.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QRadioDataControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QRadioDataControl();
+
+    virtual bool isAvailable() const = 0;
+    virtual QtMultimedia::AvailabilityError availabilityError() const = 0;
+
+    virtual QString stationId() const = 0;
+    virtual QRadioData::ProgramType programType() const = 0;
+    virtual QString programTypeName() const = 0;
+    virtual QString stationName() const = 0;
+    virtual QString radioText() const = 0;
+    virtual void setAlternativeFrequenciesEnabled(bool enabled) = 0;
+    virtual bool isAlternativeFrequenciesEnabled() const = 0;
+
+    virtual QRadioData::Error error() const = 0;
+    virtual QString errorString() const = 0;
+
+Q_SIGNALS:
+    void stationIdChanged(QString stationId);
+    void programTypeChanged(QRadioData::ProgramType programType);
+    void programTypeNameChanged(QString programTypeName);
+    void stationNameChanged(QString stationName);
+    void radioTextChanged(QString radioText);
+    void alternativeFrequenciesEnabledChanged(bool enabled);
+    void error(QRadioData::Error err);
+
+protected:
+    QRadioDataControl(QObject *parent = 0);
+};
+
+#define QRadioDataControl_iid "com.nokia.Qt.QRadioDataControl/5.0"
+Q_MEDIA_DECLARE_CONTROL(QRadioDataControl, QRadioDataControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QRADIODATACONTROL_H
diff --git a/src/multimedia/controls/qradiotunercontrol.cpp b/src/multimedia/controls/qradiotunercontrol.cpp
new file mode 100644
index 0000000..6e2b488
--- /dev/null
+++ b/src/multimedia/controls/qradiotunercontrol.cpp
@@ -0,0 +1,378 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qtmultimediadefs.h>
+#include "qradiotunercontrol.h"
+#include "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QRadioTunerControl
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+
+    \brief The QRadioTunerControl class provides access to the radio tuning
+    functionality of a QMediaService.
+
+    If a QMediaService can tune an analog radio device it will implement
+    QRadioTunerControl.  This control provides a means to tune a radio device
+    to a specific \l {setFrequency()}{frequency} as well as search \l
+    {searchForward()}{forwards} and \l {searchBackward()}{backwards} for a
+    signal.
+
+    The functionality provided by this control is exposed to application code
+    through the QRadioTuner class.
+
+    The interface name of QRadioTunerControl is \c com.nokia.Qt.QRadioTunerControl/1.0 as
+    defined in QRadioTunerControl_iid.
+
+    \sa QMediaService::requestControl(), QRadioTuner
+*/
+
+/*!
+    \macro QRadioTunerControl_iid
+
+    \c com.nokia.Qt.QRadioTunerControl/1.0
+
+    Defines the interface name of the QRadioTunerControl class.
+
+    \relates QRadioTunerControl
+*/
+
+/*!
+    Constructs a radio tuner control with the given \a parent.
+*/
+
+QRadioTunerControl::QRadioTunerControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    Destroys a radio tuner control.
+*/
+
+QRadioTunerControl::~QRadioTunerControl()
+{
+}
+
+/*!
+    \fn bool QRadioTunerControl::isAvailable() const
+
+    Returns true if the radio service is ready to use.
+    \since 1.0
+*/
+
+/*!
+    \fn QtMultimedia::AvailabilityError QRadioTunerControl::availabilityError() const
+
+    Returns the error state of the radio service.
+    \since 1.0
+*/
+
+/*!
+    \fn QRadioTuner::State QRadioTunerControl::state() const
+
+    Returns the current radio tuner state.
+    \since 1.0
+*/
+
+/*!
+    \fn QRadioTuner::Band QRadioTunerControl::band() const
+
+    Returns the frequency band a radio tuner is tuned to.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::bandChanged(QRadioTuner::Band band)
+
+    Signals that the frequency \a band a radio tuner is tuned to has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::setBand(QRadioTuner::Band band)
+
+    Sets the frequecy \a band a radio tuner is tuned to.
+
+    Changing the frequency band will reset the frequency to the minimum frequency of the new band.
+    \since 1.0
+*/
+
+/*!
+    \fn bool QRadioTunerControl::isBandSupported(QRadioTuner::Band band) const
+
+    Identifies if a frequency \a band is supported.
+
+    Returns true if the band is supported, and false if it is not.
+    \since 1.0
+*/
+
+/*!
+    \fn int QRadioTunerControl::frequency() const
+
+    Returns the frequency a radio tuner is tuned to.
+    \since 1.0
+*/
+
+/*!
+    \fn int QRadioTunerControl::frequencyStep(QRadioTuner::Band band) const
+
+    Returns the number of Hertz to increment the frequency by when stepping through frequencies
+    within a given \a band.
+    \since 1.0
+*/
+
+/*!
+    \fn QPair<int,int> QRadioTunerControl::frequencyRange(QRadioTuner::Band band) const
+
+    Returns a frequency \a band's minimum and maximum frequency.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::setFrequency(int frequency)
+
+    Sets the \a frequency a radio tuner is tuned to.
+    \since 1.0
+*/
+
+/*!
+    \fn bool QRadioTunerControl::isStereo() const
+
+    Identifies if a radio tuner is receiving a stereo signal.
+
+    Returns true if the tuner is receiving a stereo signal, and false if it is not.
+    \since 1.0
+*/
+
+/*!
+    \fn QRadioTuner::StereoMode QRadioTunerControl::stereoMode() const
+
+    Returns a radio tuner's stereo mode.
+
+    \since 1.0
+    \sa QRadioTuner::StereoMode
+*/
+
+/*!
+    \fn void QRadioTunerControl::setStereoMode(QRadioTuner::StereoMode mode)
+
+    Sets a radio tuner's stereo \a mode.
+
+    \since 1.0
+    \sa QRadioTuner::StereoMode
+*/
+
+/*!
+    \fn int QRadioTunerControl::signalStrength() const
+
+    Return a radio tuner's current signal strength as a percentage.
+    \since 1.0
+*/
+
+/*!
+    \fn int QRadioTunerControl::volume() const
+
+    Returns the volume of a radio tuner's audio output as a percentage.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::setVolume(int volume)
+
+    Sets the percentage \a volume of a radio tuner's audio output.
+    \since 1.0
+*/
+
+/*!
+    \fn bool QRadioTunerControl::isMuted() const
+
+    Identifies if a radio tuner's audio output is muted.
+
+    Returns true if the audio is muted, and false if it is not.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::setMuted(bool muted)
+
+    Sets the \a muted state of a radio tuner's audio output.
+    \since 1.0
+*/
+
+/*!
+    \fn bool QRadioTunerControl::isSearching() const
+
+    Identifies if a radio tuner is currently scanning for signal.
+
+    Returns true if the tuner is scanning, and false if it is not.
+    \since 1.0
+*/
+
+/*!
+    \fn  void QRadioTunerControl::searchForward()
+
+    Starts a forward scan for a signal, starting from the current \l frequency().
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::searchBackward()
+
+    Starts a backwards scan for a signal, starting from the current \l frequency().
+    \since 1.0
+*/
+
+/*!
+    \fn  void QRadioTunerControl::searchAllStations()
+
+    Starts a scan through the whole frequency band searching all stations
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::cancelSearch()
+
+    Stops scanning for a signal.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::start()
+
+    Activate the radio device.
+    \since 1.0
+*/
+
+/*!
+    \fn QRadioTunerControl::stop()
+
+    Deactivate the radio device.
+    \since 1.0
+*/
+
+/*!
+    \fn QRadioTuner::Error QRadioTunerControl::error() const
+
+    Returns the error state of a radio tuner.
+    \since 1.0
+*/
+
+/*!
+    \fn QString QRadioTunerControl::errorString() const
+
+    Returns a string describing a radio tuner's error state.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::stateChanged(QRadioTuner::State state)
+
+    Signals that the \a state of a radio tuner has changed.
+    \since 1.0
+*/
+
+
+/*!
+    \fn void QRadioTunerControl::frequencyChanged(int frequency)
+
+    Signals that the \a frequency a radio tuner is tuned to has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::stereoStatusChanged(bool stereo)
+
+    Signals that the \a stereo state of a radio tuner has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::searchingChanged(bool searching)
+
+    Signals that the \a searching state of a radio tuner has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::signalStrengthChanged(int strength)
+
+    Signals that the percentage \a strength of the signal received by a radio tuner has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::volumeChanged(int volume)
+
+    Signals that the percentage \a volume of radio tuner's audio output has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::mutedChanged(bool muted)
+
+    Signals that the \a muted state of a radio tuner's audio output has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::error(QRadioTuner::Error error)
+
+    Signals that an \a error has occurred.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTunerControl::stationFound(int frequency)
+
+    Signals that new station with \a frequency was found when scanning
+    \since 5.0
+*/
+
+#include "moc_qradiotunercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qradiotunercontrol.h b/src/multimedia/controls/qradiotunercontrol.h
new file mode 100644
index 0000000..b0ea542
--- /dev/null
+++ b/src/multimedia/controls/qradiotunercontrol.h
@@ -0,0 +1,125 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QRADIOTUNERCONTROL_H
+#define QRADIOTUNERCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qradiotuner.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QRadioTunerControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QRadioTunerControl();
+
+    virtual bool isAvailable() const = 0;
+    virtual QtMultimedia::AvailabilityError availabilityError() const = 0;
+
+    virtual QRadioTuner::State state() const = 0;
+
+    virtual QRadioTuner::Band band() const = 0;
+    virtual void setBand(QRadioTuner::Band b) = 0;
+    virtual bool isBandSupported(QRadioTuner::Band b) const = 0;
+
+    virtual int frequency() const = 0;
+    virtual int frequencyStep(QRadioTuner::Band b) const = 0;
+    virtual QPair<int,int> frequencyRange(QRadioTuner::Band b) const = 0;
+    virtual void setFrequency(int frequency) = 0;
+
+    virtual bool isStereo() const = 0;
+    virtual QRadioTuner::StereoMode stereoMode() const = 0;
+    virtual void setStereoMode(QRadioTuner::StereoMode mode) = 0;
+
+    virtual int signalStrength() const = 0;
+
+    virtual int volume() const = 0;
+    virtual void setVolume(int volume) = 0;
+
+    virtual bool isMuted() const = 0;
+    virtual void setMuted(bool muted) = 0;
+
+    virtual bool isSearching() const = 0;
+
+    virtual void searchForward() = 0;
+    virtual void searchBackward() = 0;
+    virtual void searchAllStations(QRadioTuner::SearchMode searchMode = QRadioTuner::SearchFast) = 0;
+    virtual void cancelSearch() = 0;
+
+    virtual void start() = 0;
+    virtual void stop() = 0;
+
+    virtual QRadioTuner::Error error() const = 0;
+    virtual QString errorString() const = 0;
+
+Q_SIGNALS:
+    void stateChanged(QRadioTuner::State state);
+    void bandChanged(QRadioTuner::Band band);
+    void frequencyChanged(int frequency);
+    void stereoStatusChanged(bool stereo);
+    void searchingChanged(bool searching);
+    void signalStrengthChanged(int signalStrength);
+    void volumeChanged(int volume);
+    void mutedChanged(bool muted);
+    void error(QRadioTuner::Error err);
+    void stationFound(int frequency, QString stationId);
+
+protected:
+    QRadioTunerControl(QObject *parent = 0);
+};
+
+#define QRadioTunerControl_iid "com.nokia.Qt.QRadioTunerControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QRadioTunerControl, QRadioTunerControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QRADIOTUNERCONTROL_H
diff --git a/src/multimedia/controls/qvideodevicecontrol.cpp b/src/multimedia/controls/qvideodevicecontrol.cpp
new file mode 100644
index 0000000..a864fd5
--- /dev/null
+++ b/src/multimedia/controls/qvideodevicecontrol.cpp
@@ -0,0 +1,159 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qvideodevicecontrol.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QVideoDeviceControl
+
+    \brief The QVideoDeviceControl class provides an video device selector media control.
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+    The QVideoDeviceControl class provides descriptions of the video devices
+    available on a system and allows one to be selected as the  endpoint of a
+    media service.
+
+    The interface name of QVideoDeviceControl is \c com.nokia.Qt.VideoDeviceControl as
+    defined in QVideoDeviceControl_iid.
+*/
+
+/*!
+    \macro QVideoDeviceControl_iid
+
+    \c com.nokia.Qt.VideoDeviceControl
+
+    Defines the interface name of the QVideoDeviceControl class.
+
+    \relates QVideoDeviceControl
+*/
+
+/*!
+    Constructs a video device control with the given \a parent.
+*/
+QVideoDeviceControl::QVideoDeviceControl(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys a video device control.
+*/
+QVideoDeviceControl::~QVideoDeviceControl()
+{
+}
+
+/*!
+    \fn QVideoDeviceControl::deviceCount() const
+
+    Returns the number of available video devices;
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::deviceName(int index) const
+
+    Returns the name of the video device at \a index.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::deviceDescription(int index) const
+
+    Returns a description of the video device at \a index.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::deviceIcon(int index) const
+
+    Returns an icon for the video device at \a index.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::defaultDevice() const
+
+    Returns the index of the default video device.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::selectedDevice() const
+
+    Returns the index of the selected video device.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::setSelectedDevice(int index)
+
+    Sets the selected video device \a index.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::devicesChanged()
+
+    Signals that the list of available video devices has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::selectedDeviceChanged(int index)
+
+    Signals that the selected video device \a index has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoDeviceControl::selectedDeviceChanged(const QString &name)
+
+    Signals that the selected video device \a name has changed.
+    \since 1.0
+*/
+
+#include "moc_qvideodevicecontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qvideodevicecontrol.h b/src/multimedia/controls/qvideodevicecontrol.h
new file mode 100644
index 0000000..6f44c46
--- /dev/null
+++ b/src/multimedia/controls/qvideodevicecontrol.h
@@ -0,0 +1,88 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QVIDEODEVICECONTROL_H
+#define QVIDEODEVICECONTROL_H
+
+#include "qmediacontrol.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class Q_MULTIMEDIA_EXPORT QVideoDeviceControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QVideoDeviceControl();
+
+    virtual int deviceCount() const = 0;
+
+    virtual QString deviceName(int index) const = 0;
+    virtual QString deviceDescription(int index) const = 0;
+    virtual QIcon deviceIcon(int index) const = 0;
+
+    virtual int defaultDevice() const = 0;
+    virtual int selectedDevice() const = 0;
+
+public Q_SLOTS:
+    virtual void setSelectedDevice(int index) = 0;
+
+Q_SIGNALS:
+    void selectedDeviceChanged(int index);
+    void selectedDeviceChanged(const QString &deviceName);
+    void devicesChanged();
+
+protected:
+    QVideoDeviceControl(QObject *parent = 0);
+};
+
+#define QVideoDeviceControl_iid "com.nokia.Qt.QVideoDeviceControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QVideoDeviceControl, QVideoDeviceControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QVIDEODEVICECONTROL_H
diff --git a/src/multimedia/controls/qvideoencodercontrol.cpp b/src/multimedia/controls/qvideoencodercontrol.cpp
new file mode 100644
index 0000000..1551f2c
--- /dev/null
+++ b/src/multimedia/controls/qvideoencodercontrol.cpp
@@ -0,0 +1,190 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qvideoencodercontrol.h"
+#include <QtCore/qstringlist.h>
+#include <QtCore/qvariant.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QVideoEncoderControl
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+    \brief The QVideoEncoderControl class provides access to the settings
+    of a media service that performs video encoding.
+
+    If a QMediaService supports encoding video data it will implement
+    QVideoEncoderControl.  This control provides information about the limits
+    of restricted video encoder options and allows the selection of a set of
+    video encoder settings as specified in a QVideoEncoderSettings object.
+
+    The functionality provided by this control is exposed to application code
+    through the QMediaRecorder class.
+
+    The interface name of QVideoEncoderControl is \c com.nokia.Qt.QVideoEncoderControl/1.0 as
+    defined in QVideoEncoderControl_iid.
+
+    \sa QMediaRecorder, QVideoEncoderSettings, QMediaService::requestControl()
+*/
+
+/*!
+    \macro QVideoEncoderControl_iid
+
+    \c com.nokia.Qt.QVideoEncoderControl/1.0
+
+    Defines the interface name of the QVideoEncoderControl class.
+
+    \relates QVideoEncoderControl
+*/
+
+/*!
+    Create a new video encoder control object with the given \a parent.
+*/
+QVideoEncoderControl::QVideoEncoderControl(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys a video encoder control.
+*/
+QVideoEncoderControl::~QVideoEncoderControl()
+{
+}
+
+/*!
+    \fn QVideoEncoderControl::supportedVideoCodecs() const
+
+    Returns the list of supported video codecs.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoEncoderControl::videoCodecDescription(const QString &codec) const
+
+    Returns a description of a video \a codec.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoEncoderControl::supportedEncodingOptions(const QString &codec) const
+
+    Returns a list of supported encoding options for a video \a codec.
+
+    The names and types of the options in the list is system dependent.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoEncoderControl::encodingOption(const QString &codec, const QString &option) const
+
+    Returns the value of a video \a codec \a option.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoEncoderControl::setEncodingOption(const QString &codec, const QString &option, const QVariant &value)
+
+    Sets the \a value of a \a codec specific \a option.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoEncoderControl::supportedResolutions(const QVideoEncoderSettings &settings = QVideoEncoderSettings(),
+                                                   bool *continuous = 0) const
+
+    Returns a list of supported resolutions.
+
+    If non null video \a settings parameter is passed,
+    the returned list is reduced to resolution supported with partial settings like
+    \l {QVideoEncoderSettings::setCodec()}{video codec} or
+    \l {QVideoEncoderSettings::setFrameRate()}{frame rate} applied.
+
+    If the encoder supports arbitrary resolutions within the supported resolutions range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+
+    \since 1.0
+    \sa QVideoEncoderSettings::resolution()
+*/
+
+/*!
+    \fn QVideoEncoderControl::supportedFrameRates(const QVideoEncoderSettings &settings = QVideoEncoderSettings(),
+                                                  bool *continuous = 0) const
+
+    Returns a list of supported frame rates.
+
+    If non null video \a settings parameter is passed,
+    the returned list is reduced to frame rates supported with partial settings like
+    \l {QVideoEncoderSettings::setCodec()}{video codec} or
+    \l {QVideoEncoderSettings::setResolution()}{video resolution} applied.
+
+    If the encoder supports arbitrary frame rates within the supported range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+
+    \since 1.0
+    \sa QVideoEncoderSettings::frameRate()
+*/
+
+/*!
+    \fn QVideoEncoderControl::videoSettings() const
+
+    Returns the video encoder settings.
+
+    The returned value may be different tha passed to QVideoEncoderControl::setVideoSettings()
+    if the settings contains the default or undefined parameters.
+    In this case if the undefined parameters are already resolved, they should be returned.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoEncoderControl::setVideoSettings(const QVideoEncoderSettings &settings)
+
+    Sets the selected video encoder \a settings.
+    \since 1.0
+*/
+
+#include "moc_qvideoencodercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qvideoencodercontrol.h b/src/multimedia/controls/qvideoencodercontrol.h
new file mode 100644
index 0000000..343af80
--- /dev/null
+++ b/src/multimedia/controls/qvideoencodercontrol.h
@@ -0,0 +1,98 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QVIDEOENCODERCONTROL_H
+#define QVIDEOENCODERCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qmediarecorder.h"
+
+#include <QtCore/qpair.h>
+#include <QtCore/qsize.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QByteArray;
+class QStringList;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class Q_MULTIMEDIA_EXPORT QVideoEncoderControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QVideoEncoderControl();
+
+    virtual QList<QSize> supportedResolutions(const QVideoEncoderSettings &settings,
+                                              bool *continuous = 0) const = 0;
+
+    virtual QList<qreal> supportedFrameRates(const QVideoEncoderSettings &settings,
+                                             bool *continuous = 0) const = 0;
+
+    virtual QStringList supportedVideoCodecs() const = 0;
+    virtual QString videoCodecDescription(const QString &codecName) const = 0;
+
+    virtual QVideoEncoderSettings videoSettings() const = 0;
+    virtual void setVideoSettings(const QVideoEncoderSettings &settings) = 0;
+
+    virtual QStringList supportedEncodingOptions(const QString &codec) const = 0;
+    virtual QVariant encodingOption(const QString &codec, const QString &name) const = 0;
+    virtual void setEncodingOption(const QString &codec, const QString &name, const QVariant &value) = 0;
+
+protected:
+    QVideoEncoderControl(QObject *parent = 0);
+};
+
+#define QVideoEncoderControl_iid "com.nokia.Qt.QVideoEncoderControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QVideoEncoderControl, QVideoEncoderControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
diff --git a/src/multimedia/controls/qvideorenderercontrol.cpp b/src/multimedia/controls/qvideorenderercontrol.cpp
new file mode 100644
index 0000000..9914226
--- /dev/null
+++ b/src/multimedia/controls/qvideorenderercontrol.cpp
@@ -0,0 +1,114 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qvideorenderercontrol.h"
+
+#include "qmediacontrol_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QVideoRendererControl
+
+
+    \brief The QVideoRendererControl class provides a control for rendering
+    to a video surface.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia-serv
+    \since 1.0
+
+    Using the surface() property of QVideoRendererControl a
+    QAbstractVideoSurface may be set as the video render target of a
+    QMediaService.
+
+    \snippet doc/src/snippets/multimedia-snippets/video.cpp Video renderer control
+
+    QVideoRendererControl is one of a number of possible video output controls.
+
+    The interface name of QVideoRendererControl is \c com.nokia.Qt.QVideoRendererControl/1.0 as
+    defined in QVideoRendererControl_iid.
+
+    \sa QMediaService::requestControl(), QVideoWidget
+*/
+
+/*!
+    \macro QVideoRendererControl_iid
+
+    \c com.nokia.Qt.QVideoRendererControl/1.0
+
+    Defines the interface name of the QVideoRendererControl class.
+
+    \relates QVideoRendererControl
+*/
+
+/*!
+    Constructs a new video renderer media end point with the given \a parent.
+*/
+QVideoRendererControl::QVideoRendererControl(QObject *parent)
+    : QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys a video renderer media end point.
+*/
+QVideoRendererControl::~QVideoRendererControl()
+{
+}
+
+/*!
+    \fn QVideoRendererControl::surface() const
+
+    Returns the surface a video producer renders to.
+    \since 1.0
+*/
+
+/*!
+    \fn QVideoRendererControl::setSurface(QAbstractVideoSurface *surface)
+
+    Sets the \a surface a video producer renders to.
+    \since 1.0
+*/
+
+#include "moc_qvideorenderercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qvideorenderercontrol.h b/src/multimedia/controls/qvideorenderercontrol.h
new file mode 100644
index 0000000..b3a7083
--- /dev/null
+++ b/src/multimedia/controls/qvideorenderercontrol.h
@@ -0,0 +1,81 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QVIDEORENDERERCONTROL_H
+#define QVIDEORENDERERCONTROL_H
+
+#include "qmediacontrol.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QAbstractVideoSurface;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+
+class Q_MULTIMEDIA_EXPORT QVideoRendererControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QVideoRendererControl();
+
+    virtual QAbstractVideoSurface *surface() const = 0;
+    virtual void setSurface(QAbstractVideoSurface *surface) = 0;
+
+protected:
+    QVideoRendererControl(QObject *parent = 0);
+};
+
+#define QVideoRendererControl_iid "com.nokia.Qt.QVideoRendererControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QVideoRendererControl, QVideoRendererControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QVIDEORENDERERCONTROL_H
diff --git a/src/multimedia/effects/effects.pri b/src/multimedia/effects/effects.pri
deleted file mode 100644
index 531a9b3..0000000
--- a/src/multimedia/effects/effects.pri
+++ /dev/null
@@ -1,37 +0,0 @@
-INCLUDEPATH += effects
-
-unix:!mac {
-   contains(config_test_pulseaudio, yes) {
-        CONFIG += link_pkgconfig
-        PKGCONFIG += libpulse
-
-        DEFINES += QT_MULTIMEDIA_PULSEAUDIO
-        PRIVATE_HEADERS += effects/qsoundeffect_pulse_p.h
-        SOURCES += effects/qsoundeffect_pulse_p.cpp
-        !maemo*:DEFINES += QTM_PULSEAUDIO_DEFAULTBUFFER
-    } else {
-        DEFINES += QT_MULTIMEDIA_QMEDIAPLAYER
-        PRIVATE_HEADERS += effects/qsoundeffect_qmedia_p.h
-        SOURCES += effects/qsoundeffect_qmedia_p.cpp
-    }
-} else {
-    DEFINES += QT_MULTIMEDIA_QMEDIAPLAYER
-    PRIVATE_HEADERS += effects/qsoundeffect_qmedia_p.h
-    SOURCES += effects/qsoundeffect_qmedia_p.cpp
-}
-
-PUBLIC_HEADERS += \
-        effects/qsoundeffect.h \
-        effects/qsound.h
-
-PRIVATE_HEADERS += \
-        effects/qwavedecoder_p.h \
-        effects/qsamplecache_p.h
-
-SOURCES += \
-    effects/qsoundeffect.cpp \
-    effects/qwavedecoder_p.cpp \
-    effects/qsamplecache_p.cpp \
-    effects/qsound.cpp
-
-HEADERS +=
diff --git a/src/multimedia/effects/qsamplecache_p.cpp b/src/multimedia/effects/qsamplecache_p.cpp
deleted file mode 100644
index 1a06cd1..0000000
--- a/src/multimedia/effects/qsamplecache_p.cpp
+++ /dev/null
@@ -1,401 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qsamplecache_p.h"
-#include "qwavedecoder_p.h"
-#include <QtNetwork>
-
-//#define QT_SAMPLECACHE_DEBUG
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QSampleCache
-    \internal
-
-    When you want to get a sound sample data, you need to request the QSample reference from QSampleCache.
-
-    \since 1.1
-
-    \code
-        QSample *m_sample;     // class member.
-
-      private Q_SLOTS:
-        void decoderError();
-        void sampleReady();
-    \endcode
-
-    \code
-      Q_GLOBAL_STATIC(QSampleCache, sampleCache) //declare a singleton manager
-    \endcode
-
-    \code
-        m_sample = sampleCache()->requestSample(url);
-        switch(m_sample->state()) {
-        case QSample::Ready:
-            sampleReady();
-            break;
-        case QSample::Error:
-            decoderError();
-            break;
-        default:
-            connect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
-            connect(m_sample, SIGNAL(ready()), this, SLOT(sampleReady()));
-            break;
-        }
-    \endcode
-
-    When you no longer need the sound sample data, you need to release it:
-
-    \code
-       if (m_sample) {
-           m_sample->release();
-           m_sample = 0;
-       }
-    \endcode
-*/
-
-QSampleCache::QSampleCache()
-    : m_networkAccessManager(0)
-    , m_mutex(QMutex::Recursive)
-    , m_capacity(0)
-    , m_usage(0)
-{
-    m_loadingThread.setObjectName(QLatin1String("QSampleCache::LoadingThread"));
-}
-
-QNetworkAccessManager& QSampleCache::networkAccessManager()
-{
-    if (!m_networkAccessManager)
-        m_networkAccessManager = new QNetworkAccessManager();
-    return *m_networkAccessManager;
-}
-
-QSampleCache::~QSampleCache()
-{
-    QMutexLocker m(&m_mutex);
-
-    m_loadingThread.quit();
-    m_loadingThread.wait();
-
-    // Killing the loading thread means that no samples can be
-    // deleted using deleteLater.  And some samples that had deleteLater
-    // already called won't have been processed (m_staleSamples)
-    foreach (QSample* sample, m_samples)
-        delete sample;
-
-    foreach (QSample* sample, m_staleSamples)
-        delete sample; // deleting a sample does affect the m_staleSamples list, but foreach copies it
-
-    delete m_networkAccessManager;
-}
-
-QSample* QSampleCache::requestSample(const QUrl& url)
-{
-    if (!m_loadingThread.isRunning())
-        m_loadingThread.start();
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "QSampleCache: request sample [" << url << "]";
-#endif
-    QMutexLocker locker(&m_mutex);
-    QMap<QUrl, QSample*>::iterator it = m_samples.find(url);
-    QSample* sample;
-    if (it == m_samples.end()) {
-        sample = new QSample(url, this);
-        m_samples.insert(url, sample);
-        sample->moveToThread(&m_loadingThread);
-    } else {
-        sample = *it;
-    }
-
-    sample->addRef();
-    locker.unlock();
-
-    sample->loadIfNecessary();
-    return sample;
-}
-
-void QSampleCache::setCapacity(qint64 capacity)
-{
-    QMutexLocker locker(&m_mutex);
-    if (m_capacity == capacity)
-        return;
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "QSampleCache: capacity changes from " << m_capacity << "to " << capacity;
-#endif
-    if (m_capacity > 0 && capacity <= 0) { //memory management strategy changed
-        for (QMap<QUrl, QSample*>::iterator it = m_samples.begin(); it != m_samples.end();) {
-            QSample* sample = *it;
-            if (sample->m_ref == 0) {
-                unloadSample(sample);
-                it = m_samples.erase(it);
-            } else
-                it++;
-        }
-    }
-
-    m_capacity = capacity;
-    refresh(0);
-}
-
-// Called locked
-void QSampleCache::unloadSample(QSample *sample)
-{
-    m_usage -= sample->m_soundData.size();
-    m_staleSamples.insert(sample);
-    sample->deleteLater();
-}
-
-// Called in both threads
-void QSampleCache::refresh(qint64 usageChange)
-{
-    QMutexLocker locker(&m_mutex);
-    m_usage += usageChange;
-    if (m_capacity <= 0 || m_usage <= m_capacity)
-        return;
-
-#ifdef QT_SAMPLECACHE_DEBUG
-    qint64 recoveredSize = 0;
-#endif
-
-    //free unused samples to keep usage under capacity limit.
-    for (QMap<QUrl, QSample*>::iterator it = m_samples.begin(); it != m_samples.end();) {
-        QSample* sample = *it;
-        if (sample->m_ref > 0) {
-            ++it;
-            continue;
-        }
-#ifdef QT_SAMPLECACHE_DEBUG
-        recoveredSize += sample->m_soundData.size();
-#endif
-        unloadSample(sample);
-        it = m_samples.erase(it);
-        if (m_usage <= m_capacity)
-            return;
-    }
-
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "QSampleCache: refresh(" << usageChange
-             << ") recovered size =" << recoveredSize
-             << "new usage =" << m_usage;
-#endif
-
-    if (m_usage > m_capacity)
-        qWarning() << "QSampleCache: usage[" << m_usage << " out of limit[" << m_capacity << "]";
-}
-
-// Called in both threads
-void QSampleCache::removeUnreferencedSample(QSample *sample)
-{
-    QMutexLocker m(&m_mutex);
-    m_staleSamples.remove(sample);
-}
-
-// Called in loader thread (since this lives in that thread)
-// Also called from application thread after loader thread dies.
-QSample::~QSample()
-{
-    // Remove ourselves from our parent
-    m_parent->removeUnreferencedSample(this);
-
-    QMutexLocker locker(&m_mutex);
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "~QSample" << this << ": deleted [" << m_url << "]" << QThread::currentThread();
-#endif
-    cleanup();
-}
-
-// Called in application thread
-void QSample::loadIfNecessary()
-{
-    QMutexLocker locker(&m_mutex);
-    if (m_state == QSample::Error || m_state == QSample::Creating) {
-        m_state = QSample::Loading;
-        QMetaObject::invokeMethod(this, "load", Qt::QueuedConnection);
-    }
-}
-
-// Called in both threads
-bool QSampleCache::notifyUnreferencedSample(QSample* sample)
-{
-    QMutexLocker locker(&m_mutex);
-    if (m_capacity > 0)
-        return false;
-    m_samples.remove(sample->m_url);
-    m_staleSamples.insert(sample);
-    sample->deleteLater();
-    return true;
-}
-
-// Called in application threadd
-void QSample::release()
-{
-    QMutexLocker locker(&m_mutex);
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "Sample:: release" << this << QThread::currentThread() << m_ref;
-#endif
-    m_ref--;
-    if (m_ref == 0)
-        m_parent->notifyUnreferencedSample(this);
-}
-
-// Called in dtor and when stream is loaded
-// must be called locked.
-void QSample::cleanup()
-{
-    if (m_waveDecoder)
-        m_waveDecoder->deleteLater();
-    if (m_stream)
-        m_stream->deleteLater();
-
-    m_waveDecoder = 0;
-    m_stream = 0;
-}
-
-// Called in application thread
-void QSample::addRef()
-{
-    m_ref++;
-}
-
-// Called in loading thread
-void QSample::readSample()
-{
-    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
-    QMutexLocker m(&m_mutex);
-#ifdef  QT_SAMPLECACHE_DEBUG
-    qDebug() << "QSample: readSample";
-#endif
-    qint64 read = m_waveDecoder->read(m_soundData.data() + m_sampleReadLength,
-                      qMin(m_waveDecoder->bytesAvailable(),
-                           qint64(m_waveDecoder->size() - m_sampleReadLength)));
-    if (read > 0)
-        m_sampleReadLength += read;
-    if (m_sampleReadLength < m_waveDecoder->size())
-        return;
-    Q_ASSERT(m_sampleReadLength == qint64(m_soundData.size()));
-    onReady();
-}
-
-// Called in loading thread
-void QSample::decoderReady()
-{
-    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
-    QMutexLocker m(&m_mutex);
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "QSample: decoder ready";
-#endif
-    m_parent->refresh(m_waveDecoder->size());
-
-    m_soundData.resize(m_waveDecoder->size());
-    m_sampleReadLength = 0;
-    qint64 read = m_waveDecoder->read(m_soundData.data(), m_waveDecoder->size());
-    if (read > 0)
-        m_sampleReadLength += read;
-    if (m_sampleReadLength >= m_waveDecoder->size())
-        onReady();
-}
-
-// Called in all threads
-QSample::State QSample::state() const
-{
-    QMutexLocker m(&m_mutex);
-    return m_state;
-}
-
-// Called in loading thread
-// Essentially a second ctor, doesn't need locks (?)
-void QSample::load()
-{
-    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "QSample: load [" << m_url << "]";
-#endif
-    m_stream = m_parent->networkAccessManager().get(QNetworkRequest(m_url));
-    connect(m_stream, SIGNAL(error(QNetworkReply::NetworkError)), SLOT(decoderError()));
-    m_waveDecoder = new QWaveDecoder(m_stream);
-    connect(m_waveDecoder, SIGNAL(formatKnown()), SLOT(decoderReady()));
-    connect(m_waveDecoder, SIGNAL(parsingError()), SLOT(decoderError()));
-    connect(m_waveDecoder, SIGNAL(readyRead()), SLOT(readSample()));
-}
-
-// Called in loading thread
-void QSample::decoderError()
-{
-    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
-    QMutexLocker m(&m_mutex);
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "QSample: decoder error";
-#endif
-    cleanup();
-    m_state = QSample::Error;
-    emit error();
-}
-
-// Called in loading thread from decoder when sample is done. Locked already.
-void QSample::onReady()
-{
-    Q_ASSERT(QThread::currentThread()->objectName() == QLatin1String("QSampleCache::LoadingThread"));
-#ifdef QT_SAMPLECACHE_DEBUG
-    qDebug() << "QSample: load ready";
-#endif
-    m_audioFormat = m_waveDecoder->audioFormat();
-    cleanup();
-    m_state = QSample::Ready;
-    emit ready();
-}
-
-// Called in application thread, then moved to loader thread
-QSample::QSample(const QUrl& url, QSampleCache *parent)
-    : m_parent(parent)
-    , m_stream(0)
-    , m_waveDecoder(0)
-    , m_url(url)
-    , m_sampleReadLength(0)
-    , m_state(Creating)
-    , m_ref(0)
-{
-}
-
-QT_END_NAMESPACE
-
-#include "moc_qsamplecache_p.cpp"
diff --git a/src/multimedia/effects/qsamplecache_p.h b/src/multimedia/effects/qsamplecache_p.h
deleted file mode 100644
index 91ca457..0000000
--- a/src/multimedia/effects/qsamplecache_p.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QSAMPLECACHE_P_H
-#define QSAMPLECACHE_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtCore/qobject.h>
-#include <QtCore/qthread.h>
-#include <QtCore/qurl.h>
-#include <QtCore/qmutex.h>
-#include <QtCore/qmap.h>
-#include <QtCore/qset.h>
-#include <qaudioformat.h>
-
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QNetworkAccessManager;
-class QSampleCache;
-class QWaveDecoder;
-
-// Lives in application thread
-class QSample : public QObject
-{
-    Q_OBJECT
-public:
-    friend class QSampleCache;
-    enum State
-    {
-        Creating,
-        Loading,
-        Error,
-        Ready,
-    };
-
-    State state() const;
-    // These are not (currently) locked because they are only meant to be called after these
-    // variables are updated to their final states
-    const QByteArray& data() const { Q_ASSERT(state() == Ready); return m_soundData; }
-    const QAudioFormat& format() const { Q_ASSERT(state() == Ready); return m_audioFormat; }
-    void release();
-
-Q_SIGNALS:
-    void error();
-    void ready();
-
-protected:
-    QSample(const QUrl& url, QSampleCache *parent);
-
-private Q_SLOTS:
-    void load();
-    void decoderError();
-    void readSample();
-    void decoderReady();
-
-private:
-    void onReady();
-    void cleanup();
-    void addRef();
-    void loadIfNecessary();
-    QSample();
-    ~QSample();
-
-    mutable QMutex m_mutex;
-    QSampleCache *m_parent;
-    QByteArray   m_soundData;
-    QAudioFormat m_audioFormat;
-    QIODevice    *m_stream;
-    QWaveDecoder *m_waveDecoder;
-    QUrl         m_url;
-    qint64       m_sampleReadLength;
-    State        m_state;
-    int          m_ref;
-};
-
-class QSampleCache
-{
-public:
-    friend class QSample;
-
-    QSampleCache();
-    ~QSampleCache();
-
-    QSample* requestSample(const QUrl& url);
-    void setCapacity(qint64 capacity);
-
-private:
-    QMap<QUrl, QSample*> m_samples;
-    QSet<QSample*> m_staleSamples;
-    QNetworkAccessManager *m_networkAccessManager;
-    QMutex m_mutex;
-    qint64 m_capacity;
-    qint64 m_usage;
-    QThread m_loadingThread;
-
-    QNetworkAccessManager& networkAccessManager();
-    void refresh(qint64 usageChange);
-    bool notifyUnreferencedSample(QSample* sample);
-    void removeUnreferencedSample(QSample* sample);
-    void unloadSample(QSample* sample);
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QSAMPLECACHE_P_H
diff --git a/src/multimedia/effects/qsound.cpp b/src/multimedia/effects/qsound.cpp
deleted file mode 100644
index 3749764..0000000
--- a/src/multimedia/effects/qsound.cpp
+++ /dev/null
@@ -1,236 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qsound.h"
-#include "qsoundeffect.h"
-#include "qcoreapplication.h"
-
-
-/*!
-    \class QSound
-    \brief The QSound class provides a way to play .wav sound files.
-
-    \ingroup multimedia
-
-
-    Qt provides the most commonly required audio operation in GUI
-    applications: asynchronously playing a sound file. This is most
-    easily accomplished using the static play() function:
-
-    \snippet doc/src/snippets/multimedia-snippets/qsound.cpp 0
-
-    Alternatively, create a QSound object from the sound file first
-    and then call the play() slot:
-
-    \snippet doc/src/snippets/multimedia-snippets/qsound.cpp 1
-
-    Once created a QSound object can be queried for its fileName() and
-    total number of loops() (i.e. the number of times the sound will
-    play). The number of repetitions can be altered using the
-    setLoops() function. While playing the sound, the loopsRemaining()
-    function returns the remaining number of repetitions. Use the
-    isFinished() function to determine whether the sound has finished
-    playing.
-
-    Sounds played using a QSound object may use more memory than the
-    static play() function, but it may also play more immediately
-    (depending on the underlying platform audio facilities).
-
-*/
-
-
-/*!
-    Plays the sound stored in the file specified by the given \a filename.
-
-    \since 5.0
-    \sa stop(), loopsRemaining(), isFinished()
-*/
-void QSound::play(const QString& filename)
-{
-    // Object destruction is generaly handled via deleteOnComplete
-    // Unexpected cases will be handled via parenting of QSound objects to qApp
-    QSound *sound = new QSound(filename, qApp);
-    sound->connect(sound->m_soundEffect, SIGNAL(playingChanged()), SLOT(deleteOnComplete()));
-    sound->play();
-}
-
-/*!
-    Constructs a QSound object from the file specified by the given \a
-    filename and with the given \a parent.
-
-    \since 5.0
-    \sa play()
-*/
-QSound::QSound(const QString& filename, QObject* parent)
-    : QObject(parent)
-{
-    m_soundEffect = new QSoundEffect(this);
-    m_soundEffect->setSource(QUrl::fromLocalFile(filename));
-}
-
-/*!
-    Destroys this sound object. If the sound is not finished playing,
-    the stop() function is called before the sound object is
-    destroyed.
-
-    \since 5.0
-    \sa stop(), isFinished()
-*/
-QSound::~QSound()
-{
-    if (!isFinished())
-        stop();
-}
-
-/*!
-    Returns true if the sound has finished playing; otherwise returns false.
-*/
-bool QSound::isFinished() const
-{
-    return !m_soundEffect->isPlaying();
-}
-
-/*!
-    \overload
-
-    Starts playing the sound specified by this QSound object.
-
-    The function returns immediately.  Depending on the platform audio
-    facilities, other sounds may stop or be mixed with the new
-    sound. The sound can be played again at any time, possibly mixing
-    or replacing previous plays of the sound.
-
-    \since 5.0
-    \sa fileName()
-*/
-void QSound::play()
-{
-    m_soundEffect->play();
-}
-
-/*!
-    Returns the number of times the sound will play.
-    Return value of \c QSound::Infinite indicates infinite number of loops
-
-    \since 5.0
-    \sa loopsRemaining(), setLoops()
-*/
-int QSound::loops() const
-{
-    // retain old API value for infite loops
-    int loopCount = m_soundEffect->loopCount();
-    if (loopCount == QSoundEffect::Infinite)
-        loopCount = Infinite;
-
-    return loopCount;
-}
-
-/*!
-    Returns the remaining number of times the sound will loop (for all
-    positive values this value decreases each time the sound is played).
-    Return value of \c QSound::Infinite indicates infinite number of loops
-
-    \since 5.0
-    \sa loops(), isFinished()
-*/
-int QSound::loopsRemaining() const
-{
-    // retain old API value for infite loops
-    int loopsRemaining = m_soundEffect->loopsRemaining();
-    if (loopsRemaining == QSoundEffect::Infinite)
-        loopsRemaining = Infinite;
-
-    return loopsRemaining;
-}
-
-/*!
-    \fn void QSound::setLoops(int number)
-
-    Sets the sound to repeat the given \a number of times when it is
-    played.
-
-    Note that passing the value \c QSound::Infinite will cause the sound to loop
-    indefinitely.
-
-    \since 5.0
-    \sa loops()
-*/
-void QSound::setLoops(int n)
-{
-    if (n == Infinite)
-        n = QSoundEffect::Infinite;
-
-    m_soundEffect->setLoopCount(n);
-}
-
-/*!
-    Returns the filename associated with this QSound object.
-
-    \since 5.0
-    \sa QSound()
-*/
-QString QSound::fileName() const
-{
-    return m_soundEffect->source().toLocalFile();
-}
-
-/*!
-    Stops the sound playing.
-
-    \since 5.0
-    \sa play()
-*/
-void QSound::stop()
-{
-    m_soundEffect->stop();
-}
-
-/*!
-    \internal
-    \since 5.0
-*/
-void QSound::deleteOnComplete()
-{
-    if (!m_soundEffect->isPlaying())
-        deleteLater();
-}
-
-#include "moc_qsound.cpp"
diff --git a/src/multimedia/effects/qsound.h b/src/multimedia/effects/qsound.h
deleted file mode 100644
index c45ddb1..0000000
--- a/src/multimedia/effects/qsound.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QSOUND_H
-#define QSOUND_H
-
-#include <qtmultimediadefs.h>
-#include <QtCore/qobject.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QSoundEffect;
-
-class Q_MULTIMEDIA_EXPORT QSound : public QObject
-{
-    Q_OBJECT
-public:
-    enum Loop
-    {
-        Infinite = -1,
-    };
-
-    static void play(const QString& filename);
-
-    explicit QSound(const QString& filename, QObject* parent = 0);
-    ~QSound();
-
-    int loops() const;
-    int loopsRemaining() const;
-    void setLoops(int);
-    QString fileName() const;
-
-    bool isFinished() const;
-
-public Q_SLOTS:
-    void play();
-    void stop();
-
-private Q_SLOTS:
-    void deleteOnComplete();
-
-private:
-    QSoundEffect *m_soundEffect;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QSOUND_H
diff --git a/src/multimedia/effects/qsoundeffect.cpp b/src/multimedia/effects/qsoundeffect.cpp
deleted file mode 100644
index b1c359e..0000000
--- a/src/multimedia/effects/qsoundeffect.cpp
+++ /dev/null
@@ -1,311 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qsoundeffect.h"
-
-#if defined(QT_MULTIMEDIA_PULSEAUDIO)
-#include "qsoundeffect_pulse_p.h"
-#elif(QT_MULTIMEDIA_QMEDIAPLAYER)
-#include "qsoundeffect_qmedia_p.h"
-#endif
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \qmlclass SoundEffect QSoundEffect
-    \brief The SoundEffect element provides a way to play sound effects in QML.
-    \since 1.0
-
-    \inmodule QtMultimedia
-
-    This element is part of the \bold{QtMultimedia 4.0} module.
-
-    The following example plays a WAV file on mouse click.
-
-    \snippet doc/src/snippets/multimedia-snippets/soundeffect.qml complete snippet
-*/
-
-/*!
-    \qmlproperty url SoundEffect::source
-    \since 1.0
-
-    This property provides a way to control the sound to play.
-*/
-
-/*!
-    \qmlproperty int SoundEffect::loops
-    \since 1.0
-
-    This property provides a way to control the number of times to repeat the sound on each play().
-
-    Set to -1 (infinite) to enable infinite loop.
-*/
-
-/*!
-    \qmlproperty qreal SoundEffect::volume
-    \since 1.0
-
-    This property holds the volume of the playback, from 0.0 (silent) to 1.0 (maximum volume).
-    Note: Currently this has no effect on Mac OS X.
-*/
-
-/*!
-    \qmlproperty bool SoundEffect::muted
-    \since 1.0
-
-    This property provides a way to control muting.
-*/
-
-/*!
-    \qmlproperty bool SoundEffect::playing
-    \since 1.1
-
-    This property indicates if the soundeffect is playing or not.
-*/
-
-/*!
-    \qmlproperty int SoundEffect::status
-    \since 1.0
-
-    This property indicates the following status of the soundeffect.
-
-    Null: no source has been set or is null.
-    Loading: the soundeffect is trying to load the source.
-    Ready: the source is loaded and ready for play.
-    Error: some error happened during operation, such as failure of loading the source.
-*/
-
-/*!
-    \qmlsignal SoundEffect::sourceChanged()
-    \since 1.0
-
-    This handler is called when the source has changed.
-*/
-
-/*!
-    \qmlsignal SoundEffect::loopCountChanged()
-    \since 1.0
-
-    This handler is called when the initial number of loops has changed.
-*/
-
-/*!
-    \qmlsignal SoundEffect::loopsRemainingChanged()
-    \since 1.0
-
-    This handler is called when the remaining number of loops has changed.
-*/
-
-/*!
-    \qmlsignal SoundEffect::volumeChanged()
-    \since 1.0
-
-    This handler is called when the volume has changed.
-*/
-
-/*!
-    \qmlsignal SoundEffect::mutedChanged()
-    \since 1.0
-
-    This handler is called when the mute state has changed.
-*/
-
-/*!
-    \qmlsignal SoundEffect::playingChanged()
-    \since 1.0
-
-    This handler is called when the playing property has changed.
-*/
-
-/*!
-    \qmlsignal SoundEffect::statusChanged()
-
-    This handler is called when the status property has changed.
-    \since 1.0
-*/
-
-
-/*!
-    \since 1.0
-*/
-
-QSoundEffect::QSoundEffect(QObject *parent) :
-    QObject(parent)
-{
-    d = new QSoundEffectPrivate(this);
-    connect(d, SIGNAL(loopsRemainingChanged()), SIGNAL(loopsRemainingChanged()));
-    connect(d, SIGNAL(volumeChanged()), SIGNAL(volumeChanged()));
-    connect(d, SIGNAL(mutedChanged()), SIGNAL(mutedChanged()));
-    connect(d, SIGNAL(loadedChanged()), SIGNAL(loadedChanged()));
-    connect(d, SIGNAL(playingChanged()), SIGNAL(playingChanged()));
-    connect(d, SIGNAL(statusChanged()), SIGNAL(statusChanged()));
-}
-
-QSoundEffect::~QSoundEffect()
-{
-    d->release();
-}
-
-QStringList QSoundEffect::supportedMimeTypes()
-{
-    return QSoundEffectPrivate::supportedMimeTypes();
-}
-
-QUrl QSoundEffect::source() const
-{
-    return d->source();
-}
-
-void QSoundEffect::setSource(const QUrl &url)
-{
-    if (d->source() == url)
-        return;
-
-    d->setSource(url);
-
-    emit sourceChanged();
-}
-
-int QSoundEffect::loopCount() const
-{
-    return d->loopCount();
-}
-
-int QSoundEffect::loopsRemaining() const
-{
-    return d->loopsRemaining();
-}
-
-void QSoundEffect::setLoopCount(int loopCount)
-{
-    if (loopCount < 0 && loopCount != Infinite) {
-        qWarning("SoundEffect: loops should be SoundEffect.Infinite, 0 or positive integer");
-        return;
-    }
-    if (loopCount == 0)
-        loopCount = 1;
-    if (d->loopCount() == loopCount)
-        return;
-
-    d->setLoopCount(loopCount);
-    emit loopCountChanged();
-}
-
-qreal QSoundEffect::volume() const
-{
-    return qreal(d->volume()) / 100;
-}
-
-void QSoundEffect::setVolume(qreal volume)
-{
-    if (volume < 0 || volume > 1) {
-        qWarning("SoundEffect: volume should be between 0.0 and 1.0");
-        return;
-    }
-    int iVolume = qRound(volume * 100);
-    if (d->volume() == iVolume)
-        return;
-
-    d->setVolume(iVolume);
-}
-
-bool QSoundEffect::isMuted() const
-{
-    return d->isMuted();
-}
-
-void QSoundEffect::setMuted(bool muted)
-{
-    if (d->isMuted() == muted)
-        return;
-
-    d->setMuted(muted);
-}
-
-bool QSoundEffect::isLoaded() const
-{
-    return d->isLoaded();
-}
-
-/*!
-  \qmlmethod SoundEffect::play()
-
-  Start playback of the sound effect, looping the effect for the number of
-  times as specificed in the loops property.
-
-  This is the default method for SoundEffect.
-
-  \snippet doc/src/snippets/multimedia-snippets/soundeffect.qml play sound on click
-  \since 1.0
-*/
-void QSoundEffect::play()
-{
-    d->play();
-}
-
-bool QSoundEffect::isPlaying() const
-{
-    return d->isPlaying();
-}
-
-QSoundEffect::Status QSoundEffect::status() const
-{
-    return d->status();
-}
-
-
-/*!
-  \qmlmethod SoundEffect::stop()
-
-  Stop current playback.
-  Note that if the backend is PulseAudio, due to the limitation of the underlying API,
-  tis stop will only prevent next looping but will not be able to stop current playback immediately.
-
-  \since 1.0
- */
-void QSoundEffect::stop()
-{
-    d->stop();
-}
-
-QT_END_NAMESPACE
-
-#include "moc_qsoundeffect.cpp"
diff --git a/src/multimedia/effects/qsoundeffect.h b/src/multimedia/effects/qsoundeffect.h
deleted file mode 100644
index f5df832..0000000
--- a/src/multimedia/effects/qsoundeffect.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QSOUNDEFFECT_H
-#define QSOUNDEFFECT_H
-
-#include <qtmultimediadefs.h>
-#include <QtCore/qobject.h>
-#include <QtCore/qurl.h>
-#include <QtCore/qstringlist.h>
-
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QSoundEffectPrivate;
-
-class Q_MULTIMEDIA_EXPORT QSoundEffect : public QObject
-{
-    Q_OBJECT
-    Q_CLASSINFO("DefaultMethod", "play()")
-    Q_PROPERTY(QUrl source READ source WRITE setSource NOTIFY sourceChanged)
-    Q_PROPERTY(int loops READ loopCount WRITE setLoopCount NOTIFY loopCountChanged)
-    Q_PROPERTY(int loopsRemaining READ loopsRemaining NOTIFY loopsRemainingChanged)
-    Q_PROPERTY(qreal volume READ volume WRITE setVolume NOTIFY volumeChanged)
-    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
-    Q_PROPERTY(bool playing READ isPlaying NOTIFY playingChanged)
-    Q_PROPERTY(Status status READ status NOTIFY statusChanged)
-    Q_ENUMS(Loop)
-    Q_ENUMS(Status)
-
-public:
-    enum Loop
-    {
-        Infinite = -2,
-    };
-
-    enum Status
-    {
-        Null,
-        Loading,
-        Ready,
-        Error
-    };
-
-    explicit QSoundEffect(QObject *parent = 0);
-    ~QSoundEffect();
-
-    static QStringList supportedMimeTypes();
-
-    QUrl source() const;
-    void setSource(const QUrl &url);
-
-    int loopCount() const;
-    int loopsRemaining() const;
-    void setLoopCount(int loopCount);
-
-    qreal volume() const;
-    void setVolume(qreal volume);
-
-    bool isMuted() const;
-    void setMuted(bool muted);
-
-    bool isLoaded() const;
-
-    bool isPlaying() const;
-    Status status() const;
-
-Q_SIGNALS:
-    void sourceChanged();
-    void loopCountChanged();
-    void loopsRemainingChanged();
-    void volumeChanged();
-    void mutedChanged();
-    void loadedChanged();
-    void playingChanged();
-    void statusChanged();
-
-public Q_SLOTS:
-    void play();
-    void stop();
-
-private:
-    Q_DISABLE_COPY(QSoundEffect)
-    QSoundEffectPrivate* d;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QSOUNDEFFECT_H
diff --git a/src/multimedia/effects/qsoundeffect_pulse_p.cpp b/src/multimedia/effects/qsoundeffect_pulse_p.cpp
deleted file mode 100644
index 373586e..0000000
--- a/src/multimedia/effects/qsoundeffect_pulse_p.cpp
+++ /dev/null
@@ -1,1100 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// INTERNAL USE ONLY: Do NOT use for any other purpose.
-//
-
-#include <QtCore/qcoreapplication.h>
-#include <qaudioformat.h>
-#include <QtNetwork>
-#include <QTime>
-
-#include "qsoundeffect_pulse_p.h"
-
-#if defined(Q_WS_MAEMO_6)
-#include <pulse/ext-stream-restore.h>
-#endif
-
-#include <unistd.h>
-
-//#define QT_PA_DEBUG
-#ifndef QTM_PULSEAUDIO_DEFAULTBUFFER
-#define QT_PA_STREAM_BUFFER_SIZE_MAX (1024 * 64)  //64KB is a trade-off for balancing control latency and uploading overhead
-#endif
-
-QT_BEGIN_NAMESPACE
-
-namespace
-{
-inline pa_sample_spec audioFormatToSampleSpec(const QAudioFormat &format)
-{
-    pa_sample_spec  spec;
-
-    spec.rate = format.frequency();
-    spec.channels = format.channels();
-
-    if (format.sampleSize() == 8)
-        spec.format = PA_SAMPLE_U8;
-    else if (format.sampleSize() == 16) {
-        switch (format.byteOrder()) {
-            case QAudioFormat::BigEndian: spec.format = PA_SAMPLE_S16BE; break;
-            case QAudioFormat::LittleEndian: spec.format = PA_SAMPLE_S16LE; break;
-        }
-    }
-    else if (format.sampleSize() == 32) {
-        switch (format.byteOrder()) {
-            case QAudioFormat::BigEndian: spec.format = PA_SAMPLE_S32BE; break;
-            case QAudioFormat::LittleEndian: spec.format = PA_SAMPLE_S32LE; break;
-        }
-    }
-
-    return spec;
-}
-
-class PulseDaemon : public QObject
-{
-    Q_OBJECT
-public:
-    PulseDaemon(): m_prepared(false)
-    {
-        prepare();
-    }
-
-    ~PulseDaemon()
-    {
-        if (m_prepared)
-            release();
-    }
-
-    inline void lock()
-    {
-        pa_threaded_mainloop_lock(m_mainLoop);
-    }
-
-    inline void unlock()
-    {
-        pa_threaded_mainloop_unlock(m_mainLoop);
-    }
-
-    inline pa_context *context() const
-    {
-        return m_context;
-    }
-
-    inline pa_cvolume * calcVolume(pa_cvolume *dest, int soundEffectVolume)
-    {
-        pa_volume_t v = m_vol * soundEffectVolume / 100;
-        for (int i = 0; i < dest->channels; ++i)
-            dest->values[i] = v;
-        return dest;
-    }
-
-    void updateStatus(const pa_cvolume& volume)
-    {
-        if (m_vol != pa_cvolume_max(&volume)) {
-            m_vol = pa_cvolume_max(&volume);
-            emit volumeChanged();
-        }
-    }
-
-Q_SIGNALS:
-    void contextReady();
-    void volumeChanged();
-
-private:
-    void prepare()
-    {
-        m_vol = PA_VOLUME_NORM;
-
-        m_mainLoop = pa_threaded_mainloop_new();
-        if (m_mainLoop == 0) {
-            qWarning("PulseAudioService: unable to create pulseaudio mainloop");
-            return;
-        }
-
-        if (pa_threaded_mainloop_start(m_mainLoop) != 0) {
-            qWarning("PulseAudioService: unable to start pulseaudio mainloop");
-            pa_threaded_mainloop_free(m_mainLoop);
-            return;
-        }
-
-        m_mainLoopApi = pa_threaded_mainloop_get_api(m_mainLoop);
-
-        lock();
-        m_context = pa_context_new(m_mainLoopApi, QString(QLatin1String("QtPulseAudio:%1")).arg(::getpid()).toAscii().constData());
-
-        pa_context_set_state_callback(m_context, context_state_callback, this);
-
-        if (m_context == 0) {
-            qWarning("PulseAudioService: Unable to create new pulseaudio context");
-            pa_threaded_mainloop_free(m_mainLoop);
-            return;
-        }
-
-        if (pa_context_connect(m_context, 0, (pa_context_flags_t)0, 0) < 0) {
-            qWarning("PulseAudioService: pa_context_connect() failed");
-            pa_context_unref(m_context);
-            pa_threaded_mainloop_free(m_mainLoop);
-            return;
-        }
-        unlock();
-
-        m_prepared = true;
-    }
-
-    void release()
-    {
-        if (!m_prepared) return;
-        pa_threaded_mainloop_stop(m_mainLoop);
-        pa_threaded_mainloop_free(m_mainLoop);
-        m_prepared = false;
-    }
-
-    static void context_state_callback(pa_context *c, void *userdata)
-    {
-        PulseDaemon *self = reinterpret_cast<PulseDaemon*>(userdata);
-        switch (pa_context_get_state(c)) {
-            case PA_CONTEXT_CONNECTING:
-            case PA_CONTEXT_AUTHORIZING:
-            case PA_CONTEXT_SETTING_NAME:
-                break;
-            case PA_CONTEXT_READY:
-    #if defined(Q_WS_MAEMO_6)
-                pa_ext_stream_restore_read(c, &stream_restore_info_callback, self);
-                pa_ext_stream_restore_set_subscribe_cb(c, &stream_restore_monitor_callback, self);
-                pa_ext_stream_restore_subscribe(c, 1, 0, self);
-    #endif
-                QMetaObject::invokeMethod(self, "contextReady", Qt::QueuedConnection);
-                break;
-            default:
-                break;
-        }
-    }
-
-#if defined(Q_WS_MAEMO_6)
-
-    static void stream_restore_monitor_callback(pa_context *c, void *userdata)
-    {
-        PulseDaemon *self = reinterpret_cast<PulseDaemon*>(userdata);
-        pa_ext_stream_restore_read(c, &stream_restore_info_callback, self);
-    }
-
-    static void stream_restore_info_callback(pa_context *c,
-            const pa_ext_stream_restore_info *info,
-            int eol, void *userdata)
-    {
-        Q_UNUSED(c)
-
-        PulseDaemon *self = reinterpret_cast<PulseDaemon*>(userdata);
-
-        if (!eol) {
-            if (QString(info->name).startsWith(QLatin1String("sink-input-by-media-role:x-maemo"))) {
-#ifdef QT_PA_DEBUG
-                qDebug() << "x-maemo volume =(" << info->volume.values[0] * 100 / PA_VOLUME_NORM << ","
-                         << info->volume.values[1] * 100 / PA_VOLUME_NORM << "), "
-                         << "mute = " << info->mute;
-#endif
-                self->updateStatus(info->volume);
-            }
-        }
-    }
-#endif
-
-    pa_volume_t m_vol;
-
-    bool m_prepared;
-    pa_context *m_context;
-    pa_threaded_mainloop *m_mainLoop;
-    pa_mainloop_api *m_mainLoopApi;
-};
-
-}
-
-Q_GLOBAL_STATIC(PulseDaemon, daemon)
-Q_GLOBAL_STATIC(QSampleCache, sampleCache)
-
-namespace
-{
-class PulseDaemonLocker
-{
-public:
-    PulseDaemonLocker()
-    {
-        daemon()->lock();
-    }
-
-    ~PulseDaemonLocker()
-    {
-        daemon()->unlock();
-    }
-};
-}
-
-class QSoundEffectRef
-{
-public:
-    QSoundEffectRef(QSoundEffectPrivate *target)
-        : m_ref(1)
-        , m_target(target)
-    {
-#ifdef QT_PA_DEBUG
-        qDebug() << "QSoundEffectRef(" << this << ") ctor";
-#endif
-    }
-
-    QSoundEffectRef *getRef()
-    {
-#ifdef QT_PA_DEBUG
-        qDebug() << "QSoundEffectRef(" << this << ") getRef";
-#endif
-        QMutexLocker locker(&m_mutex);
-        m_ref++;
-        return this;
-    }
-
-    void release()
-    {
-#ifdef QT_PA_DEBUG
-        qDebug() << "QSoundEffectRef(" << this << ") Release";
-#endif
-        m_mutex.lock();
-        --m_ref;
-        if (m_ref == 0) {
-            m_mutex.unlock();
-#ifdef QT_PA_DEBUG
-            qDebug() << "QSoundEffectRef(" << this << ") deleted";
-#endif
-            delete this;
-            return;
-        }
-        m_mutex.unlock();
-    }
-
-    QSoundEffectPrivate* soundEffect() const
-    {
-        QMutexLocker locker(&m_mutex);
-        return m_target;
-    }
-
-    void notifyDeleted()
-    {
-#ifdef QT_PA_DEBUG
-        qDebug() << "QSoundEffectRef(" << this << ") notifyDeleted";
-#endif
-        QMutexLocker locker(&m_mutex);
-        m_target = NULL;
-    }
-
-private:
-    int m_ref;
-    mutable QMutex m_mutex;
-    QSoundEffectPrivate *m_target;
-};
-
-QSoundEffectPrivate::QSoundEffectPrivate(QObject* parent):
-    QObject(parent),
-    m_pulseStream(0),
-    m_sinkInputId(-1),
-    m_emptying(false),
-    m_sampleReady(false),
-    m_playing(false),
-    m_status(QSoundEffect::Null),
-    m_muted(false),
-    m_playQueued(false),
-    m_stopping(false),
-    m_volume(100),
-    m_loopCount(1),
-    m_runningCount(0),
-    m_sample(0) ,
-    m_position(0)
-{
-    m_ref = new QSoundEffectRef(this);
-    pa_sample_spec_init(&m_pulseSpec);
-}
-
-void QSoundEffectPrivate::release()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "release";
-#endif
-    m_ref->notifyDeleted();
-    unloadPulseStream();
-    if (m_sample) {
-        m_sample->release();
-        m_sample = 0;
-    }
-
-    this->deleteLater();
-}
-
-QSoundEffectPrivate::~QSoundEffectPrivate()
-{
-    m_ref->release();
-}
-
-QStringList QSoundEffectPrivate::supportedMimeTypes()
-{
-    QStringList supportedTypes;
-    supportedTypes << QLatin1String("audio/x-wav") << QLatin1String("audio/vnd.wave") ;
-    return supportedTypes;
-}
-
-QUrl QSoundEffectPrivate::source() const
-{
-    return m_source;
-}
-
-void QSoundEffectPrivate::setSource(const QUrl &url)
-{
-    Q_ASSERT(m_source != url);
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "setSource =" << url;
-#endif
-    stop();
-    if (m_sample) {
-        if (!m_sampleReady) {
-            disconnect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
-            disconnect(m_sample, SIGNAL(ready()), this, SLOT(sampleReady()));
-        }
-        m_sample->release();
-        m_sample = 0;
-    }
-
-    m_source = url;
-    m_sampleReady = false;
-
-    PulseDaemonLocker locker;
-    setLoopsRemaining(0);
-    if (m_pulseStream && !pa_stream_is_corked(m_pulseStream)) {
-        pa_stream_set_write_callback(m_pulseStream, 0, 0);
-        pa_stream_set_underflow_callback(m_pulseStream, 0, 0);
-        pa_operation_unref(pa_stream_cork(m_pulseStream, 1, 0, 0));
-    }
-    setPlaying(false);
-
-    if (url.isEmpty()) {
-        setStatus(QSoundEffect::Null);
-        return;
-    }
-
-    setStatus(QSoundEffect::Loading);
-    m_sample = sampleCache()->requestSample(url);
-    connect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
-    connect(m_sample, SIGNAL(ready()), this, SLOT(sampleReady()));
-    switch(m_sample->state()) {
-    case QSample::Ready:
-        sampleReady();
-        break;
-    case QSample::Error:
-        decoderError();
-        break;
-    default:
-        break;
-    }
-}
-
-int QSoundEffectPrivate::loopCount() const
-{
-    return m_loopCount;
-}
-
-int QSoundEffectPrivate::loopsRemaining() const
-{
-    return m_runningCount;
-}
-
-void QSoundEffectPrivate::setLoopCount(int loopCount)
-{
-    if (loopCount == 0)
-        loopCount = 1;
-    m_loopCount = loopCount;
-}
-
-int QSoundEffectPrivate::volume() const
-{
-    return m_volume;
-}
-
-void QSoundEffectPrivate::setVolume(int volume)
-{
-    m_volume = volume;
-    emit volumeChanged();
-    updateVolume();
-}
-
-void QSoundEffectPrivate::updateVolume()
-{
-    if (m_sinkInputId < 0)
-        return;
-    PulseDaemonLocker locker;
-    pa_cvolume volume;
-    volume.channels = m_pulseSpec.channels;
-    pa_operation_unref(pa_context_set_sink_input_volume(daemon()->context(), m_sinkInputId, daemon()->calcVolume(&volume, m_volume), setvolume_callback, m_ref->getRef()));
-    Q_ASSERT(pa_cvolume_valid(&volume));
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "updateVolume =" << pa_cvolume_max(&volume);
-#endif
-}
-
-bool QSoundEffectPrivate::isMuted() const
-{
-    return m_muted;
-}
-
-void QSoundEffectPrivate::setMuted(bool muted)
-{
-    m_muted = muted;
-    emit mutedChanged();
-    updateMuted();
-}
-
-void QSoundEffectPrivate::updateMuted()
-{
-    if (m_sinkInputId < 0)
-        return;
-    PulseDaemonLocker locker;
-    pa_operation_unref(pa_context_set_sink_input_mute(daemon()->context(), m_sinkInputId, m_muted, setmuted_callback, m_ref->getRef()));
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "updateMuted = " << m_muted;
-#endif
-}
-
-bool QSoundEffectPrivate::isLoaded() const
-{
-    return m_status == QSoundEffect::Ready;
-}
-
-bool QSoundEffectPrivate::isPlaying() const
-{
-    return m_playing;
-}
-
-QSoundEffect::Status QSoundEffectPrivate::status() const
-{
-    return m_status;
-}
-
-void QSoundEffectPrivate::setPlaying(bool playing)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "setPlaying(" << playing << ")";
-#endif
-    if (m_playing == playing)
-        return;
-    if (!playing)
-        m_playQueued = false;
-    m_playing = playing;
-    emit playingChanged();
-}
-
-void QSoundEffectPrivate::setStatus(QSoundEffect::Status status)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "setStatus" << status;
-#endif
-    if (m_status == status)
-        return;
-    bool oldLoaded = isLoaded();
-    m_status = status;
-    emit statusChanged();
-    if (oldLoaded != isLoaded())
-        emit loadedChanged();
-}
-
-void QSoundEffectPrivate::setLoopsRemaining(int loopsRemaining)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "setLoopsRemaining " << loopsRemaining;
-#endif
-    if (m_runningCount == loopsRemaining)
-        return;
-    m_runningCount = loopsRemaining;
-    emit loopsRemainingChanged();
-}
-
-void QSoundEffectPrivate::play()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "play";
-#endif
-    if (m_status == QSoundEffect::Null || m_status == QSoundEffect::Error || m_playQueued)
-        return;
-
-    PulseDaemonLocker locker;
-    if (!m_sampleReady || !m_pulseStream || m_stopping || m_emptying) {
-#ifdef QT_PA_DEBUG
-        qDebug() << this << "play deferred";
-#endif
-        m_playQueued = true;
-    } else {
-        if (m_playing) { //restart playing from the beginning
-#ifdef QT_PA_DEBUG
-           qDebug() << this << "restart playing";
-#endif
-            setLoopsRemaining(0);
-            m_playQueued = true;
-            Q_ASSERT(m_pulseStream);
-            emptyStream();
-            return;
-        }
-        m_runningCount = m_loopCount;
-        playSample();
-    }
-
-    setPlaying(true);
-}
-
-void QSoundEffectPrivate::emptyStream()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "emptyStream";
-#endif
-    m_emptying = true;
-    pa_stream_set_write_callback(m_pulseStream, 0, 0);
-    pa_stream_set_underflow_callback(m_pulseStream, 0, 0);
-    pa_operation_unref(pa_stream_flush(m_pulseStream, stream_flush_callback, m_ref->getRef()));
-}
-
-void QSoundEffectPrivate::emptyComplete()
-{
-    PulseDaemonLocker locker;
-    m_emptying = false;
-    pa_operation_unref(pa_stream_cork(m_pulseStream, 1, stream_cork_callback, m_ref->getRef()));
-}
-
-void QSoundEffectPrivate::sampleReady()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "sampleReady";
-#endif
-    disconnect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
-    disconnect(m_sample, SIGNAL(ready()), this, SLOT(sampleReady()));
-    pa_sample_spec newFormatSpec = audioFormatToSampleSpec(m_sample->format());
-
-    if (m_pulseStream && (memcmp(&m_pulseSpec, &newFormatSpec, sizeof(m_pulseSpec)) != 0)) {
-        unloadPulseStream();
-    }
-    m_pulseSpec = newFormatSpec;
-
-    m_sampleReady = true;
-    m_position = 0;
-
-    if (m_name.isNull())
-        m_name = QString(QLatin1String("QtPulseSample-%1-%2")).arg(::getpid()).arg(quintptr(this)).toUtf8();
-
-    PulseDaemonLocker locker;
-    if (m_pulseStream) {
-#ifdef QT_PA_DEBUG
-        qDebug() << this << "reuse existing pulsestream";
-#endif
-#ifdef QTM_PULSEAUDIO_DEFAULTBUFFER
-        const pa_buffer_attr *bufferAttr = pa_stream_get_buffer_attr(m_pulseStream);
-        if (bufferAttr->prebuf > uint32_t(m_sample->data().size())) {
-            pa_buffer_attr newBufferAttr;
-            newBufferAttr = *bufferAttr;
-            newBufferAttr.prebuf = m_sample->data().size();
-            pa_operation_unref(pa_stream_set_buffer_attr(m_pulseStream, &newBufferAttr, stream_adjust_prebuffer_callback, m_ref->getRef()));
-        } else {
-            streamReady();
-        }
-#else
-        const pa_buffer_attr *bufferAttr = pa_stream_get_buffer_attr(m_pulseStream);
-        if (bufferAttr->tlength < m_sample->data().size() && bufferAttr->tlength < QT_PA_STREAM_BUFFER_SIZE_MAX) {
-            pa_buffer_attr newBufferAttr;
-            newBufferAttr.maxlength = -1;
-            newBufferAttr.tlength = qMin(m_sample->data().size(), QT_PA_STREAM_BUFFER_SIZE_MAX);
-            newBufferAttr.minreq = bufferAttr->tlength / 2;
-            newBufferAttr.prebuf = -1;
-            newBufferAttr.fragsize = -1;
-            pa_operation_unref(pa_stream_set_buffer_attr(m_pulseStream, &newBufferAttr, stream_reset_buffer_callback, m_ref->getRef()));
-        } else if (bufferAttr->prebuf > uint32_t(m_sample->data().size())) {
-            pa_buffer_attr newBufferAttr;
-            newBufferAttr = *bufferAttr;
-            newBufferAttr.prebuf = m_sample->data().size();
-            pa_operation_unref(pa_stream_set_buffer_attr(m_pulseStream, &newBufferAttr, stream_adjust_prebuffer_callback, m_ref->getRef()));
-        } else {
-            streamReady();
-        }
-#endif
-    } else {
-        if (pa_context_get_state(daemon()->context()) != PA_CONTEXT_READY) {
-            connect(daemon(), SIGNAL(contextReady()), SLOT(contextReady()));
-            return;
-        }
-        createPulseStream();
-    }
-}
-
-void QSoundEffectPrivate::decoderError()
-{
-    qWarning("QSoundEffect(pulseaudio): Error decoding source");
-    disconnect(m_sample, SIGNAL(error()), this, SLOT(decoderError()));
-    bool playingDirty = false;
-    if (m_playing) {
-        m_playing = false;
-        playingDirty = true;
-    }
-    setStatus(QSoundEffect::Error);
-    if (playingDirty)
-        emit playingChanged();
-}
-
-void QSoundEffectPrivate::unloadPulseStream()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "unloadPulseStream";
-#endif
-    m_sinkInputId = -1;
-    PulseDaemonLocker locker;
-    if (m_pulseStream) {
-        pa_stream_set_state_callback(m_pulseStream, 0, 0);
-        pa_stream_set_write_callback(m_pulseStream, 0, 0);
-        pa_stream_set_underflow_callback(m_pulseStream, 0, 0);
-        pa_stream_disconnect(m_pulseStream);
-        pa_stream_unref(m_pulseStream);
-        disconnect(daemon(), SIGNAL(volumeChanged()), this, SLOT(updateVolume()));
-        m_pulseStream = 0;
-    }
-}
-
-void QSoundEffectPrivate::prepare()
-{
-    if (!m_pulseStream || !m_sampleReady)
-        return;
-    PulseDaemonLocker locker;
-    pa_stream_set_write_callback(m_pulseStream, stream_write_callback, this);
-    pa_stream_set_underflow_callback(m_pulseStream, stream_underrun_callback, this);
-    m_stopping = false;
-    size_t writeBytes = size_t(qMin(m_pulseBufferSize, m_sample->data().size()));
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "prepare(): writable size =" << pa_stream_writable_size(m_pulseStream)
-             << "actual writeBytes =" << writeBytes
-             << "m_playQueued =" << m_playQueued;
-#endif
-    m_position = int(writeBytes);
-    if (pa_stream_write(m_pulseStream, reinterpret_cast<void *>(const_cast<char*>(m_sample->data().data())), writeBytes,
-                        stream_write_done_callback, 0, PA_SEEK_RELATIVE) != 0) {
-        qWarning("QSoundEffect(pulseaudio): pa_stream_write, error = %s", pa_strerror(pa_context_errno(daemon()->context())));
-    }
-    if (m_playQueued) {
-        m_playQueued = false;
-        setLoopsRemaining(m_loopCount);
-        playSample();
-    }
-}
-
-void QSoundEffectPrivate::uploadSample()
-{
-    if (m_runningCount == 0) {
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "uploadSample: return due to 0 m_runningCount";
-#endif
-        return;
-    }
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "uploadSample: m_runningCount =" << m_runningCount;
-#endif
-    if (m_position == m_sample->data().size()) {
-        m_position = 0;
-        if (m_runningCount > 0)
-            setLoopsRemaining(m_runningCount - 1);
-        if (m_runningCount == 0) {
-            return;
-        }
-    }
-
-    int writtenBytes = 0;
-    int writableSize = int(pa_stream_writable_size(m_pulseStream));
-    int firstPartLength = qMin(m_sample->data().size() - m_position, writableSize);
-    if (pa_stream_write(m_pulseStream, reinterpret_cast<void *>(const_cast<char*>(m_sample->data().data()) + m_position),
-                        firstPartLength, stream_write_done_callback, 0, PA_SEEK_RELATIVE) != 0) {
-        qWarning("QSoundEffect(pulseaudio): pa_stream_write, error = %s", pa_strerror(pa_context_errno(daemon()->context())));
-    }
-    writtenBytes = firstPartLength;
-    m_position += firstPartLength;
-    if (m_position == m_sample->data().size()) {
-        m_position = 0;
-        if (m_runningCount > 0)
-            setLoopsRemaining(m_runningCount - 1);
-        if (m_runningCount != 0 && firstPartLength < writableSize)
-        {
-            while (writtenBytes < writableSize) {
-                int writeSize = qMin(writableSize - writtenBytes, m_sample->data().size());
-                if (pa_stream_write(m_pulseStream, reinterpret_cast<void *>(const_cast<char*>(m_sample->data().data())),
-                                    writeSize, stream_write_done_callback, 0, PA_SEEK_RELATIVE) != 0) {
-                    qWarning("QSoundEffect(pulseaudio): pa_stream_write, error = %s", pa_strerror(pa_context_errno(daemon()->context())));
-                }
-                writtenBytes += writeSize;
-                if (writeSize < m_sample->data().size()) {
-                    m_position = writeSize;
-                    break;
-                }
-                if (m_runningCount > 0)
-                    setLoopsRemaining(m_runningCount - 1);
-                if (m_runningCount == 0)
-                    break;
-            }
-        }
-    }
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "uploadSample: use direct write, writeable size =" << writableSize
-             << "actual writtenBytes =" << writtenBytes;
-#endif
-}
-
-void QSoundEffectPrivate::playSample()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "playSample";
-#endif
-    Q_ASSERT(m_pulseStream);
-    pa_operation_unref(pa_stream_cork(m_pulseStream, 0, 0, 0));
-}
-
-void QSoundEffectPrivate::stop()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "stop";
-#endif
-    if (!m_playing)
-        return;
-    setPlaying(false);
-    PulseDaemonLocker locker;
-    m_stopping = true;
-    if (m_pulseStream)
-        emptyStream();
-    setLoopsRemaining(0);
-    m_position = 0;
-    m_playQueued = false;
-}
-
-void QSoundEffectPrivate::underRun()
-{
-    stop();
-}
-
-void QSoundEffectPrivate::streamReady()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "streamReady";
-#endif
-    PulseDaemonLocker locker;
-    m_sinkInputId =  pa_stream_get_index(m_pulseStream);
-    updateMuted();
-    updateVolume();
-#ifdef QT_PA_DEBUG
-    const pa_buffer_attr *realBufAttr = pa_stream_get_buffer_attr(m_pulseStream);
-    qDebug() << this << "m_sinkInputId =" << m_sinkInputId
-             << "tlength =" << realBufAttr->tlength << "maxlength =" << realBufAttr->maxlength
-             << "minreq = " << realBufAttr->minreq << "prebuf =" << realBufAttr->prebuf;
-#endif
-    prepare();
-    setStatus(QSoundEffect::Ready);
-}
-
-void QSoundEffectPrivate::createPulseStream()
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << this << "createPulseStream";
-#endif
-
-    pa_proplist *propList = pa_proplist_new();
-    pa_proplist_sets(propList, PA_PROP_MEDIA_ROLE, "soundeffect");
-    pa_stream *stream = pa_stream_new_with_proplist(daemon()->context(), m_name.constData(), &m_pulseSpec, 0, propList);
-    pa_proplist_free(propList);
-
-    connect(daemon(), SIGNAL(volumeChanged()), this, SLOT(updateVolume()));
-
-    if (stream == 0) {
-        qWarning("QSoundEffect(pulseaudio): Failed to create stream");
-        m_pulseStream = 0;
-        setStatus(QSoundEffect::Error);
-        setPlaying(false);
-        return;
-    }
-    else {
-        pa_stream_set_state_callback(stream, stream_state_callback, this);
-        pa_stream_set_write_callback(stream, stream_write_callback, this);
-        pa_stream_set_underflow_callback(stream, stream_underrun_callback, this);
-    }
-    m_pulseStream = stream;
-
-#ifndef QTM_PULSEAUDIO_DEFAULTBUFFER
-    pa_buffer_attr bufferAttr;
-    bufferAttr.tlength = qMin(m_sample->data().size(), QT_PA_STREAM_BUFFER_SIZE_MAX);
-    bufferAttr.maxlength = -1;
-    bufferAttr.minreq = bufferAttr.tlength / 2;
-    bufferAttr.prebuf = -1;
-    bufferAttr.fragsize = -1;
-    if (pa_stream_connect_playback(m_pulseStream, 0, &bufferAttr,
-#else
-    if (pa_stream_connect_playback(m_pulseStream, 0, 0,
-#endif
-                                   m_muted ? pa_stream_flags_t(PA_STREAM_START_MUTED | PA_STREAM_START_CORKED)
-                                           : pa_stream_flags_t(PA_STREAM_START_UNMUTED | PA_STREAM_START_CORKED),
-                                   0, 0) < 0) {
-        qWarning("QSoundEffect(pulseaudio): Failed to connect stream, error = %s",
-                 pa_strerror(pa_context_errno(daemon()->context())));
-    }
-}
-
-void QSoundEffectPrivate::contextReady()
-{
-    disconnect(daemon(), SIGNAL(contextReady()), this, SLOT(contextReady()));
-    PulseDaemonLocker locker;
-    createPulseStream();
-}
-
-void QSoundEffectPrivate::stream_write_callback(pa_stream *s, size_t length, void *userdata)
-{
-    Q_UNUSED(length);
-    Q_UNUSED(s);
-
-    QSoundEffectPrivate *self = reinterpret_cast<QSoundEffectPrivate*>(userdata);
-#ifdef QT_PA_DEBUG
-    qDebug() << self << "stream_write_callback";
-#endif
-    self->uploadSample();
-}
-
-void QSoundEffectPrivate::stream_state_callback(pa_stream *s, void *userdata)
-{
-    QSoundEffectPrivate *self = reinterpret_cast<QSoundEffectPrivate*>(userdata);
-    switch (pa_stream_get_state(s)) {
-        case PA_STREAM_READY:
-        {
-#ifdef QT_PA_DEBUG
-            qDebug() << self << "pulse stream ready";
-#endif
-            const pa_buffer_attr *bufferAttr = pa_stream_get_buffer_attr(self->m_pulseStream);
-            self->m_pulseBufferSize = bufferAttr->tlength;
-            if (bufferAttr->prebuf > uint32_t(self->m_sample->data().size())) {
-                pa_buffer_attr newBufferAttr;
-                newBufferAttr = *bufferAttr;
-                newBufferAttr.prebuf = self->m_sample->data().size();
-                pa_stream_set_buffer_attr(self->m_pulseStream, &newBufferAttr, stream_adjust_prebuffer_callback, self->m_ref->getRef());
-            } else {
-                QMetaObject::invokeMethod(self, "streamReady", Qt::QueuedConnection);
-            }
-            break;
-        }
-        case PA_STREAM_CREATING:
-#ifdef QT_PA_DEBUG
-            qDebug() << self << "pulse stream creating";
-#endif
-            break;
-        case PA_STREAM_TERMINATED:
-#ifdef QT_PA_DEBUG
-            qDebug() << self << "pulse stream terminated";
-#endif
-            break;
-
-        case PA_STREAM_FAILED:
-        default:
-            qWarning("QSoundEffect(pulseaudio): Error in pulse audio stream");
-            break;
-    }
-}
-
-void QSoundEffectPrivate::stream_reset_buffer_callback(pa_stream *s, int success, void *userdata)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << "stream_reset_buffer_callback";
-#endif
-    Q_UNUSED(s);
-    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
-    QSoundEffectPrivate *self = ref->soundEffect();
-    ref->release();
-    if (!self)
-        return;
-
-    if (!success)
-        qWarning("QSoundEffect(pulseaudio): faild to reset buffer attribute");
-#ifdef QT_PA_DEBUG
-    qDebug() << self << "stream_reset_buffer_callback";
-#endif
-    const pa_buffer_attr *bufferAttr = pa_stream_get_buffer_attr(self->m_pulseStream);
-    self->m_pulseBufferSize = bufferAttr->tlength;
-    if (bufferAttr->prebuf > uint32_t(self->m_sample->data().size())) {
-        pa_buffer_attr newBufferAttr;
-        newBufferAttr = *bufferAttr;
-        newBufferAttr.prebuf = self->m_sample->data().size();
-        pa_stream_set_buffer_attr(self->m_pulseStream, &newBufferAttr, stream_adjust_prebuffer_callback, userdata);
-    } else {
-        QMetaObject::invokeMethod(self, "streamReady", Qt::QueuedConnection);
-    }
-}
-
-void QSoundEffectPrivate::stream_adjust_prebuffer_callback(pa_stream *s, int success, void *userdata)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << "stream_adjust_prebuffer_callback";
-#endif
-    Q_UNUSED(s);
-    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
-    QSoundEffectPrivate *self = ref->soundEffect();
-    ref->release();
-    if (!self)
-        return;
-
-    if (!success)
-        qWarning("QSoundEffect(pulseaudio): faild to adjust pre-buffer attribute");
-#ifdef QT_PA_DEBUG
-    qDebug() << self << "stream_adjust_prebuffer_callback";
-#endif
-    QMetaObject::invokeMethod(self, "streamReady", Qt::QueuedConnection);
-}
-
-void QSoundEffectPrivate::setvolume_callback(pa_context *c, int success, void *userdata)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << "setvolume_callback";
-#endif
-    Q_UNUSED(c);
-    Q_UNUSED(userdata);
-    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
-    QSoundEffectPrivate *self = ref->soundEffect();
-    ref->release();
-    if (!self)
-        return;
-#ifdef QT_PA_DEBUG
-    qDebug() << self << "setvolume_callback";
-#endif
-    if (!success) {
-        qWarning("QSoundEffect(pulseaudio): faild to set volume");
-    }
-}
-
-void QSoundEffectPrivate::setmuted_callback(pa_context *c, int success, void *userdata)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << "setmuted_callback";
-#endif
-    Q_UNUSED(c);
-    Q_UNUSED(userdata);
-    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
-    QSoundEffectPrivate *self = ref->soundEffect();
-    ref->release();
-    if (!self)
-        return;
-#ifdef QT_PA_DEBUG
-    qDebug() << self << "setmuted_callback";
-#endif
-    if (!success) {
-        qWarning("QSoundEffect(pulseaudio): faild to set muted");
-    }
-}
-
-void QSoundEffectPrivate::stream_underrun_callback(pa_stream *s, void *userdata)
-{
-    Q_UNUSED(s);
-    QSoundEffectPrivate *self = reinterpret_cast<QSoundEffectPrivate*>(userdata);
-#ifdef QT_PA_DEBUG
-    qDebug() << self << "stream_underrun_callback";
-#endif
-    if (self->m_runningCount == 0 && !self->m_playQueued)
-        QMetaObject::invokeMethod(self, "underRun", Qt::QueuedConnection);
-#ifdef QT_PA_DEBUG
-    else
-        qDebug() << "underun corked =" << pa_stream_is_corked(s);
-#endif
-}
-
-void QSoundEffectPrivate::stream_cork_callback(pa_stream *s, int success, void *userdata)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << "stream_cork_callback";
-#endif
-    Q_UNUSED(s);
-    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
-    QSoundEffectPrivate *self = ref->soundEffect();
-    ref->release();
-    if (!self)
-        return;
-
-    if (!success)
-        qWarning("QSoundEffect(pulseaudio): faild to stop");
-#ifdef QT_PA_DEBUG
-    qDebug() << self << "stream_cork_callback";
-#endif
-    QMetaObject::invokeMethod(self, "prepare", Qt::QueuedConnection);
-}
-
-void QSoundEffectPrivate::stream_flush_callback(pa_stream *s, int success, void *userdata)
-{
-#ifdef QT_PA_DEBUG
-    qDebug() << "stream_flush_callback";
-#endif
-    Q_UNUSED(s);
-    QSoundEffectRef *ref = reinterpret_cast<QSoundEffectRef*>(userdata);
-    QSoundEffectPrivate *self = ref->soundEffect();
-    ref->release();
-    if (!self)
-        return;
-
-    if (!success)
-        qWarning("QSoundEffect(pulseaudio): faild to drain");
-#ifdef QT_PA_DEBUG
-    qDebug() << self << "stream_flush_callback";
-#endif
-    QMetaObject::invokeMethod(self, "emptyComplete", Qt::QueuedConnection);
-}
-
-void QSoundEffectPrivate::stream_write_done_callback(void *p)
-{
-    Q_UNUSED(p);
-#ifdef QT_PA_DEBUG
-    qDebug() << "stream_write_done_callback";
-#endif
-}
-
-QT_END_NAMESPACE
-
-#include "moc_qsoundeffect_pulse_p.cpp"
-#include "qsoundeffect_pulse_p.moc"
diff --git a/src/multimedia/effects/qsoundeffect_pulse_p.h b/src/multimedia/effects/qsoundeffect_pulse_p.h
deleted file mode 100644
index 35b586e..0000000
--- a/src/multimedia/effects/qsoundeffect_pulse_p.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QSOUNDEFFECT_PULSE_H
-#define QSOUNDEFFECT_PULSE_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-
-#include "qsoundeffect.h"
-
-#include <QtCore/qobject.h>
-#include <QtCore/qdatetime.h>
-#include <qmediaplayer.h>
-#include <pulse/pulseaudio.h>
-#include "qsamplecache_p.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QSoundEffectRef;
-
-class QSoundEffectPrivate : public QObject
-{
-    Q_OBJECT
-public:
-    explicit QSoundEffectPrivate(QObject* parent);
-    ~QSoundEffectPrivate();
-
-    static QStringList supportedMimeTypes();
-
-    QUrl source() const;
-    void setSource(const QUrl &url);
-    int loopCount() const;
-    int loopsRemaining() const;
-    void setLoopCount(int loopCount);
-    int volume() const;
-    void setVolume(int volume);
-    bool isMuted() const;
-    void setMuted(bool muted);
-    bool isLoaded() const;
-    bool isPlaying() const;
-    QSoundEffect::Status status() const;
-
-    void release();
-
-public Q_SLOTS:
-    void play();
-    void stop();
-
-Q_SIGNALS:
-    void loopsRemainingChanged();
-    void volumeChanged();
-    void mutedChanged();
-    void loadedChanged();
-    void playingChanged();
-    void statusChanged();
-
-private Q_SLOTS:
-    void decoderError();
-    void sampleReady();
-    void uploadSample();
-    void contextReady();
-    void underRun();
-    void prepare();
-    void streamReady();
-    void emptyComplete();
-    void updateVolume();
-    void updateMuted();
-
-private:
-    void playSample();
-
-    void emptyStream();
-    void createPulseStream();
-    void unloadPulseStream();
-
-    void setPlaying(bool playing);
-    void setStatus(QSoundEffect::Status status);
-    void setLoopsRemaining(int loopsRemaining);
-
-    static void stream_write_callback(pa_stream *s, size_t length, void *userdata);
-    static void stream_state_callback(pa_stream *s, void *userdata);
-    static void stream_underrun_callback(pa_stream *s, void *userdata);
-    static void stream_cork_callback(pa_stream *s, int success, void *userdata);
-    static void stream_flush_callback(pa_stream *s, int success, void *userdata);
-    static void stream_write_done_callback(void *p);
-    static void stream_adjust_prebuffer_callback(pa_stream *s, int success, void *userdata);
-    static void stream_reset_buffer_callback(pa_stream *s, int success, void *userdata);
-    static void setvolume_callback(pa_context *c, int success, void *userdata);
-    static void setmuted_callback(pa_context *c, int success, void *userdata);
-
-    pa_stream *m_pulseStream;
-    int        m_sinkInputId;
-    pa_sample_spec m_pulseSpec;
-    int        m_pulseBufferSize;
-
-    bool    m_emptying;
-    bool    m_sampleReady;
-    bool    m_playing;
-    QSoundEffect::Status  m_status;
-    bool    m_muted;
-    bool    m_playQueued;
-    bool    m_stopping;
-    int     m_volume;
-    int     m_loopCount;
-    int     m_runningCount;
-    QUrl    m_source;
-    QByteArray m_name;
-
-    QSample *m_sample;
-    int m_position;
-    QSoundEffectRef *m_ref;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QSOUNDEFFECT_PULSE_H
diff --git a/src/multimedia/effects/qsoundeffect_qmedia_p.cpp b/src/multimedia/effects/qsoundeffect_qmedia_p.cpp
deleted file mode 100644
index 511aa06..0000000
--- a/src/multimedia/effects/qsoundeffect_qmedia_p.cpp
+++ /dev/null
@@ -1,254 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// INTERNAL USE ONLY: Do NOT use for any other purpose.
-//
-
-#include "qsoundeffect_qmedia_p.h"
-
-#include <QtCore/qcoreapplication.h>
-
-#include "qmediacontent.h"
-#include "qmediaplayer.h"
-
-
-QT_BEGIN_NAMESPACE
-
-QSoundEffectPrivate::QSoundEffectPrivate(QObject* parent):
-    QObject(parent),
-    m_loopCount(1),
-    m_runningCount(0),
-    m_playing(false),
-    m_status(QSoundEffect::Null),
-    m_player(0)
-{
-    m_player = new QMediaPlayer(this, QMediaPlayer::LowLatency);
-    connect(m_player, SIGNAL(stateChanged(QMediaPlayer::State)), SLOT(stateChanged(QMediaPlayer::State)));
-    connect(m_player, SIGNAL(mediaStatusChanged(QMediaPlayer::MediaStatus)), SLOT(mediaStatusChanged(QMediaPlayer::MediaStatus)));
-    connect(m_player, SIGNAL(error(QMediaPlayer::Error)), SLOT(error(QMediaPlayer::Error)));
-    connect(m_player, SIGNAL(mutedChanged(bool)), SIGNAL(mutedChanged()));
-    connect(m_player, SIGNAL(volumeChanged(int)), SIGNAL(volumeChanged()));
-}
-
-void QSoundEffectPrivate::release()
-{
-    this->deleteLater();
-}
-
-QSoundEffectPrivate::~QSoundEffectPrivate()
-{
-}
-
-QStringList QSoundEffectPrivate::supportedMimeTypes()
-{
-    return QMediaPlayer::supportedMimeTypes();
-}
-
-QUrl QSoundEffectPrivate::source() const
-{
-    return m_player->media().canonicalUrl();
-}
-
-void QSoundEffectPrivate::setSource(const QUrl &url)
-{
-    m_player->setMedia(url);
-}
-
-int QSoundEffectPrivate::loopCount() const
-{
-    return m_loopCount;
-}
-
-int QSoundEffectPrivate::loopsRemaining() const
-{
-    return m_runningCount;
-}
-
-void QSoundEffectPrivate::setLoopCount(int loopCount)
-{
-    m_loopCount = loopCount;
-}
-
-int QSoundEffectPrivate::volume() const
-{
-    return m_player->volume();
-}
-
-void QSoundEffectPrivate::setVolume(int volume)
-{
-    m_player->setVolume(volume);
-}
-
-bool QSoundEffectPrivate::isMuted() const
-{
-    return m_player->isMuted();
-}
-
-void QSoundEffectPrivate::setMuted(bool muted)
-{
-    m_player->setMuted(muted);
-}
-
-bool QSoundEffectPrivate::isLoaded() const
-{
-    return m_status == QSoundEffect::Ready;
-}
-
-bool QSoundEffectPrivate::isPlaying() const
-{
-    return m_playing;
-}
-
-QSoundEffect::Status QSoundEffectPrivate::status() const
-{
-    return m_status;
-}
-
-void QSoundEffectPrivate::play()
-{
-    if (m_status == QSoundEffect::Null || m_status == QSoundEffect::Error)
-        return;
-    if (m_loopCount < 0) {
-        setLoopsRemaining(-1);
-    }
-    else {
-        if (m_runningCount < 0)
-            setLoopsRemaining(0);
-        setLoopsRemaining(m_runningCount + m_loopCount);
-    }
-    m_player->play();
-}
-
-void QSoundEffectPrivate::stop()
-{
-    setLoopsRemaining(0);
-    m_player->stop();
-}
-
-void QSoundEffectPrivate::stateChanged(QMediaPlayer::State state)
-{
-    if (state == QMediaPlayer::StoppedState) {
-        if (m_runningCount < 0) {
-            m_player->play();
-        } else if (m_runningCount == 0) {
-            setPlaying(false);
-            return;
-        } else {
-            setLoopsRemaining(m_runningCount - 1);
-            if (m_runningCount > 0) {
-                m_player->play();
-            } else {
-             setPlaying(false);
-            }
-        }
-    } else {
-        setPlaying(true);
-    }
-}
-
-void QSoundEffectPrivate::mediaStatusChanged(QMediaPlayer::MediaStatus status)
-{
-    switch(status) {
-    case QMediaPlayer::LoadingMedia:
-        setStatus(QSoundEffect::Loading);
-        break;
-    case QMediaPlayer::NoMedia:
-        setStatus(QSoundEffect::Null);
-        break;
-    case QMediaPlayer::InvalidMedia:
-        setStatus(QSoundEffect::Error);
-        break;
-    default:
-        setStatus(QSoundEffect::Ready);
-        break;
-    }
-}
-
-void QSoundEffectPrivate::error(QMediaPlayer::Error err)
-{
-    bool playingDirty = false;
-    if (m_playing) {
-        m_playing = false;
-        playingDirty = true;
-    }
-    setStatus(QSoundEffect::Error);
-    if (playingDirty)
-        emit playingChanged();
-}
-
-void QSoundEffectPrivate::setStatus(QSoundEffect::Status status)
-{
-    if (m_status == status)
-        return;
-    bool oldLoaded = isLoaded();
-    m_status = status;
-    emit statusChanged();
-    if (oldLoaded != isLoaded())
-        emit loadedChanged();
-}
-
-void QSoundEffectPrivate::setPlaying(bool playing)
-{
-    if (m_playing == playing)
-        return;
-    m_playing = playing;
-    emit playingChanged();
-}
-
-void QSoundEffectPrivate::setLoopsRemaining(int loopsRemaining)
-{
-    if (m_runningCount == loopsRemaining)
-        return;
-    m_runningCount = loopsRemaining;
-    emit loopsRemainingChanged();
-}
-
-QT_END_NAMESPACE
-
-#include "moc_qsoundeffect_qmedia_p.cpp"
diff --git a/src/multimedia/effects/qsoundeffect_qmedia_p.h b/src/multimedia/effects/qsoundeffect_qmedia_p.h
deleted file mode 100644
index bb91e50..0000000
--- a/src/multimedia/effects/qsoundeffect_qmedia_p.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QSOUNDEFFECT_QMEDIA_H
-#define QSOUNDEFFECT_QMEDIA_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtCore/qobject.h>
-#include <QtCore/qurl.h>
-#include "qmediaplayer.h"
-#include "qsoundeffect.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-
-class QSoundEffectPrivate : public QObject
-{
-    Q_OBJECT
-public:
-
-    explicit QSoundEffectPrivate(QObject* parent);
-    ~QSoundEffectPrivate();
-
-    static QStringList supportedMimeTypes();
-
-    QUrl source() const;
-    void setSource(const QUrl &url);
-    int loopCount() const;
-    int loopsRemaining() const;
-    void setLoopCount(int loopCount);
-    int volume() const;
-    void setVolume(int volume);
-    bool isMuted() const;
-    void setMuted(bool muted);
-    bool isLoaded() const;
-    bool isPlaying() const;
-    QSoundEffect::Status status() const;
-
-    void release();
-
-public Q_SLOTS:
-    void play();
-    void stop();
-
-Q_SIGNALS:
-    void loopsRemainingChanged();
-    void volumeChanged();
-    void mutedChanged();
-    void loadedChanged();
-    void playingChanged();
-    void statusChanged();
-
-private Q_SLOTS:
-    void stateChanged(QMediaPlayer::State);
-    void mediaStatusChanged(QMediaPlayer::MediaStatus);
-    void error(QMediaPlayer::Error);
-
-private:
-    void setStatus(QSoundEffect::Status status);
-    void setPlaying(bool playing);
-    void setLoopsRemaining(int loopsRemaining);
-
-    int            m_loopCount;
-    int            m_runningCount;
-    bool           m_playing;
-    QSoundEffect::Status  m_status;
-    QMediaPlayer  *m_player;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QSOUNDEFFECT_QMEDIA_H
diff --git a/src/multimedia/effects/qwavedecoder_p.cpp b/src/multimedia/effects/qwavedecoder_p.cpp
deleted file mode 100644
index eb65a3a..0000000
--- a/src/multimedia/effects/qwavedecoder_p.cpp
+++ /dev/null
@@ -1,307 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qwavedecoder_p.h"
-
-#include <QtCore/qtimer.h>
-#include <QtCore/qendian.h>
-
-QT_BEGIN_NAMESPACE
-
-QWaveDecoder::QWaveDecoder(QIODevice *s, QObject *parent):
-    QIODevice(parent),
-    haveFormat(false),
-    dataSize(0),
-    source(s),
-    state(QWaveDecoder::InitialState),
-    junkToSkip(0),
-    bigEndian(false)
-{
-    open(QIODevice::ReadOnly | QIODevice::Unbuffered);
-
-    if (enoughDataAvailable())
-        QTimer::singleShot(0, this, SLOT(handleData()));
-    else
-        connect(source, SIGNAL(readyRead()), SLOT(handleData()));
-}
-
-QWaveDecoder::~QWaveDecoder()
-{
-}
-
-QAudioFormat QWaveDecoder::audioFormat() const
-{
-    return format;
-}
-
-int QWaveDecoder::duration() const
-{
-    return size() * 1000 / (format.sampleSize() / 8) / format.channels() / format.frequency();
-}
-
-qint64 QWaveDecoder::size() const
-{
-    return haveFormat ? dataSize : 0;
-}
-
-bool QWaveDecoder::isSequential() const
-{
-    return source->isSequential();
-}
-
-qint64 QWaveDecoder::bytesAvailable() const
-{
-    return haveFormat ? source->bytesAvailable() : 0;
-}
-
-qint64 QWaveDecoder::readData(char *data, qint64 maxlen)
-{
-    return haveFormat ? source->read(data, maxlen) : 0;
-}
-
-qint64 QWaveDecoder::writeData(const char *data, qint64 len)
-{
-    Q_UNUSED(data);
-    Q_UNUSED(len);
-
-    return -1;
-}
-
-void QWaveDecoder::parsingFailed()
-{
-    Q_ASSERT(source);
-    source->disconnect(SIGNAL(readyRead()), this, SLOT(handleData()));
-    emit parsingError();
-}
-
-void QWaveDecoder::handleData()
-{
-    // As a special "state", if we have junk to skip, we do
-    if (junkToSkip > 0) {
-        discardBytes(junkToSkip); // this also updates junkToSkip
-
-        // If we couldn't skip all the junk, return
-        if (junkToSkip > 0) {
-            // We might have run out
-            if (source->atEnd())
-                parsingFailed();
-            return;
-        }
-    }
-
-    if (state == QWaveDecoder::InitialState) {
-        if (source->bytesAvailable() < qint64(sizeof(RIFFHeader)))
-            return;
-
-        RIFFHeader riff;
-        source->read(reinterpret_cast<char *>(&riff), sizeof(RIFFHeader));
-
-        // RIFF = little endian RIFF, RIFX = big endian RIFF
-        if (((qstrncmp(riff.descriptor.id, "RIFF", 4) != 0) && (qstrncmp(riff.descriptor.id, "RIFX", 4) != 0))
-                || qstrncmp(riff.type, "WAVE", 4) != 0) {
-            parsingFailed();
-            return;
-        } else {
-            state = QWaveDecoder::WaitingForFormatState;
-            if (qstrncmp(riff.descriptor.id, "RIFX", 4) == 0)
-                bigEndian = true;
-            else
-                bigEndian = false;
-        }
-    }
-
-    if (state == QWaveDecoder::WaitingForFormatState) {
-        if (findChunk("fmt ")) {
-            chunk descriptor;
-            peekChunk(&descriptor);
-
-            if (source->bytesAvailable() < qint64(descriptor.size + sizeof(chunk)))
-                return;
-
-            WAVEHeader wave;
-            source->read(reinterpret_cast<char *>(&wave), sizeof(WAVEHeader));
-            if (descriptor.size > sizeof(WAVEHeader))
-                discardBytes(descriptor.size - sizeof(WAVEHeader));
-
-            // Swizzle this
-            if (bigEndian) {
-                wave.audioFormat = qFromBigEndian<quint16>(wave.audioFormat);
-            }
-
-            if (wave.audioFormat != 0 && wave.audioFormat != 1) {
-                // 32bit wave files have format == 0xFFFE (WAVE_FORMAT_EXTENSIBLE).
-                // but don't support them at the moment.
-                parsingFailed();
-                return;
-            } else {
-                format.setCodec(QLatin1String("audio/pcm"));
-
-                if (bigEndian) {
-                    int bps = qFromBigEndian<quint16>(wave.bitsPerSample);
-
-                    format.setSampleType(bps == 8 ? QAudioFormat::UnSignedInt : QAudioFormat::SignedInt);
-                    format.setByteOrder(QAudioFormat::BigEndian);
-                    format.setFrequency(qFromBigEndian<quint32>(wave.sampleRate));
-                    format.setSampleSize(bps);
-                    format.setChannels(qFromBigEndian<quint16>(wave.numChannels));
-                } else {
-                    int bps = qFromLittleEndian<quint16>(wave.bitsPerSample);
-
-                    format.setSampleType(bps == 8 ? QAudioFormat::UnSignedInt : QAudioFormat::SignedInt);
-                    format.setByteOrder(QAudioFormat::LittleEndian);
-                    format.setFrequency(qFromLittleEndian<quint32>(wave.sampleRate));
-                    format.setSampleSize(bps);
-                    format.setChannels(qFromLittleEndian<quint16>(wave.numChannels));
-                }
-
-                state = QWaveDecoder::WaitingForDataState;
-            }
-        }
-    }
-
-    if (state == QWaveDecoder::WaitingForDataState) {
-        if (findChunk("data")) {
-            source->disconnect(SIGNAL(readyRead()), this, SLOT(handleData()));
-
-            chunk descriptor;
-            source->read(reinterpret_cast<char *>(&descriptor), sizeof(chunk));
-            if (bigEndian)
-                descriptor.size = qFromBigEndian<quint32>(descriptor.size);
-
-            dataSize = descriptor.size;
-
-            haveFormat = true;
-            connect(source, SIGNAL(readyRead()), SIGNAL(readyRead()));
-            emit formatKnown();
-
-            return;
-        }
-    }
-
-    // If we hit the end without finding data, it's a parsing error
-    if (source->atEnd()) {
-        parsingFailed();
-    }
-}
-
-bool QWaveDecoder::enoughDataAvailable()
-{
-    chunk descriptor;
-    if (!peekChunk(&descriptor))
-        return false;
-
-    // This is only called for the RIFF/RIFX header, before bigEndian is set,
-    // so we have to manually swizzle
-    if (qstrncmp(descriptor.id, "RIFX", 4) == 0)
-        descriptor.size = qFromBigEndian<quint32>(descriptor.size);
-
-    if (source->bytesAvailable() < qint64(sizeof(chunk) + descriptor.size))
-        return false;
-
-    return true;
-}
-
-bool QWaveDecoder::findChunk(const char *chunkId)
-{
-    chunk descriptor;
-    if (!peekChunk(&descriptor))
-        return false;
-
-    if (qstrncmp(descriptor.id, chunkId, 4) == 0)
-        return true;
-
-    // It's possible that bytes->available() is less than the chunk size
-    // if it's corrupt.
-    junkToSkip = qint64(sizeof(chunk) + descriptor.size);
-    while (source->bytesAvailable() > 0) {
-        // Skip the current amount
-        if (junkToSkip > 0)
-            discardBytes(junkToSkip);
-
-        // If we still have stuff left, just exit and try again later
-        // since we can't call peekChunk
-        if (junkToSkip > 0)
-            return false;
-
-        if (!peekChunk(&descriptor))
-            return false;
-
-        if (qstrncmp(descriptor.id, chunkId, 4) == 0)
-            return true;
-    }
-
-    return false;
-}
-
-// Handles endianness
-bool QWaveDecoder::peekChunk(chunk *pChunk)
-{
-    if (source->bytesAvailable() < qint64(sizeof(chunk)))
-        return false;
-
-    source->peek(reinterpret_cast<char *>(pChunk), sizeof(chunk));
-    if (bigEndian)
-        pChunk->size = qFromBigEndian<quint32>(pChunk->size);
-
-    return true;
-}
-
-void QWaveDecoder::discardBytes(qint64 numBytes)
-{
-    // Discards a number of bytes
-    // If the iodevice doesn't have this many bytes in it,
-    // remember how much more junk we have to skip.
-    if (source->isSequential()) {
-        QByteArray r = source->read(qMin(numBytes, qint64(16384))); // uggh, wasted memory, limit to a max of 16k
-        if (r.size() < numBytes)
-            junkToSkip = numBytes - r.size();
-        else
-            junkToSkip = 0;
-    } else {
-        quint64 origPos = source->pos();
-        source->seek(source->pos() + numBytes);
-        junkToSkip = origPos + numBytes - source->pos();
-    }
-}
-
-QT_END_NAMESPACE
-
-#include "moc_qwavedecoder_p.cpp"
diff --git a/src/multimedia/effects/qwavedecoder_p.h b/src/multimedia/effects/qwavedecoder_p.h
deleted file mode 100644
index 1a7bef9..0000000
--- a/src/multimedia/effects/qwavedecoder_p.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef WAVEDECODER_H
-#define WAVEDECODER_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience
-// of other Qt classes.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtCore/qiodevice.h>
-#include <qaudioformat.h>
-
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-
-class QWaveDecoder : public QIODevice
-{
-    Q_OBJECT
-
-public:
-    explicit QWaveDecoder(QIODevice *source, QObject *parent = 0);
-    ~QWaveDecoder();
-
-    QAudioFormat audioFormat() const;
-    int duration() const;
-
-    qint64 size() const;
-    bool isSequential() const;
-    qint64 bytesAvailable() const;
-
-Q_SIGNALS:
-    void formatKnown();
-    void parsingError();
-
-private Q_SLOTS:
-    void handleData();
-
-private:
-    qint64 readData(char *data, qint64 maxlen);
-    qint64 writeData(const char *data, qint64 len);
-
-    bool enoughDataAvailable();
-    bool findChunk(const char *chunkId);
-    void discardBytes(qint64 numBytes);
-    void parsingFailed();
-
-    enum State {
-        InitialState,
-        WaitingForFormatState,
-        WaitingForDataState
-    };
-
-    struct chunk
-    {
-        char        id[4];
-        quint32     size;
-    };
-    bool peekChunk(chunk* pChunk);
-
-    struct RIFFHeader
-    {
-        chunk       descriptor;
-        char        type[4];
-    };
-    struct WAVEHeader
-    {
-        chunk       descriptor;
-        quint16     audioFormat;
-        quint16     numChannels;
-        quint32     sampleRate;
-        quint32     byteRate;
-        quint16     blockAlign;
-        quint16     bitsPerSample;
-    };
-
-    bool haveFormat;
-    qint64 dataSize;
-    QAudioFormat format;
-    QIODevice *source;
-    State state;
-    quint32 junkToSkip;
-    bool bigEndian;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // WAVEDECODER_H
diff --git a/src/multimedia/imageviewer/imageviewer.pri b/src/multimedia/imageviewer/imageviewer.pri
new file mode 100644
index 0000000..409615c
--- /dev/null
+++ b/src/multimedia/imageviewer/imageviewer.pri
@@ -0,0 +1,13 @@
+
+INCLUDEPATH += imageviewer
+
+PUBLIC_HEADERS += \
+    imageviewer/qmediaimageviewer.h
+
+PRIVATE_HEADERS += \
+    imageviewer/qmediaimageviewerservice_p.h
+
+SOURCES += \
+    imageviewer/qmediaimageviewer.cpp \
+    imageviewer/qmediaimageviewerservice.cpp
+
diff --git a/src/multimedia/imageviewer/qmediaimageviewer.cpp b/src/multimedia/imageviewer/qmediaimageviewer.cpp
new file mode 100644
index 0000000..562aad4
--- /dev/null
+++ b/src/multimedia/imageviewer/qmediaimageviewer.cpp
@@ -0,0 +1,617 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaimageviewer.h"
+
+#include "qmediaobject_p.h"
+#include "qmediaimageviewerservice_p.h"
+
+#include <qmediaplaylist.h>
+#include <qmediaplaylistsourcecontrol.h>
+#include <qmediacontent.h>
+#include <qmediaresource.h>
+#include "qvideosurfaceoutput_p.h"
+
+#include <QtCore/qcoreevent.h>
+#include <QtCore/qdatetime.h>
+#include <QtCore/qpointer.h>
+#include <QtCore/qtextstream.h>
+
+QT_BEGIN_NAMESPACE
+
+namespace
+{
+    class QMediaImageViewerPrivateRegisterMetaTypes
+    {
+    public:
+        QMediaImageViewerPrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QMediaImageViewer::MediaStatus>();
+            qRegisterMetaType<QMediaImageViewer::State>();
+        }
+    } _registerMetaTypes;
+}
+
+class QMediaImageViewerPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QMediaImageViewer)
+public:
+    QMediaImageViewerPrivate():
+        viewerControl(0), playlist(0),
+        state(QMediaImageViewer::StoppedState), timeout(3000), pauseTime(0)
+    {
+    }
+
+    void _q_mediaStatusChanged(QMediaImageViewer::MediaStatus status);
+    void _q_playlistMediaChanged(const QMediaContent &content);
+    void _q_playlistDestroyed();
+
+    QMediaImageViewerControl *viewerControl;
+    QMediaPlaylist *playlist;
+    QPointer<QObject> videoOutput;
+    QVideoSurfaceOutput surfaceOutput;
+    QMediaImageViewer::State state;
+    int timeout;
+    int pauseTime;
+    QTime time;
+    QBasicTimer timer;
+    QMediaContent media;
+};
+
+void QMediaImageViewerPrivate::_q_mediaStatusChanged(QMediaImageViewer::MediaStatus status)
+{
+    switch (status) {
+    case QMediaImageViewer::NoMedia:
+    case QMediaImageViewer::LoadingMedia:
+        emit q_func()->mediaStatusChanged(status);
+        break;
+    case QMediaImageViewer::LoadedMedia:
+        if (state == QMediaImageViewer::PlayingState) {
+            time.start();
+            timer.start(qMax(0, timeout), q_func());
+            q_func()->addPropertyWatch("elapsedTime");
+        }
+        emit q_func()->mediaStatusChanged(status);
+        emit q_func()->elapsedTimeChanged(0);
+        break;
+    case QMediaImageViewer::InvalidMedia:
+        emit q_func()->mediaStatusChanged(status);
+
+        if (state == QMediaImageViewer::PlayingState) {
+            playlist->next();
+            if (playlist->currentIndex() < 0)
+                emit q_func()->stateChanged(state = QMediaImageViewer::StoppedState);
+        }
+        break;
+    }
+}
+
+void QMediaImageViewerPrivate::_q_playlistMediaChanged(const QMediaContent &content)
+{
+    media = content;
+    pauseTime = 0;
+
+    viewerControl->showMedia(media);
+
+    emit q_func()->mediaChanged(media);
+}
+
+void QMediaImageViewerPrivate::_q_playlistDestroyed()
+{
+    playlist = 0;
+    timer.stop();
+
+    if (state != QMediaImageViewer::StoppedState)
+        emit q_func()->stateChanged(state = QMediaImageViewer::StoppedState);
+
+    q_func()->setMedia(QMediaContent());
+}
+
+/*!
+    \class QMediaImageViewer
+    \brief The QMediaImageViewer class provides a means of viewing image media.
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+
+    QMediaImageViewer is used together with a media display object such as
+    QVideoWidget to present an image.  A display object is attached to the
+    image viewer by means of the bind function.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Binding
+
+    QMediaImageViewer can be paired with a QMediaPlaylist to create a slide
+    show of images. Constructing a QMediaPlaylist with a pointer to an
+    instance of QMediaImageViewer will attach it to the image viewer;
+    changing the playlist's selection will then change the media displayed
+    by the image viewer.  With a playlist attached QMediaImageViewer's
+    play(), pause(), and stop() slots can be control the progression of the
+    playlist.  The \l timeout property determines how long an image is
+    displayed for before progressing to the next in the playlist, and the
+    \l elapsedTime property holds how the duration the current image has
+    been displayed for.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Playlist
+*/
+
+/*!
+    \enum QMediaImageViewer::State
+
+    Enumerates the possible control states an image viewer may be in.  The
+    control state of an image viewer determines whether the image viewer is
+    automatically progressing through images in an attached playlist.
+
+    \value StoppedState The image viewer is stopped, and will not automatically move to the next
+    image.  The \l elapsedTime is fixed at 0.
+    \value PlayingState The slide show is playing, and will move to the next image when the
+    \l elapsedTime reaches the \l timeout.  The \l elapsedTime is being incremented.
+    \value PausedState The image viewer is paused, and will not automatically move the to next
+    image.  The \l elapsedTime is fixed at the time the image viewer was paused.
+*/
+
+/*!
+    \enum QMediaImageViewer::MediaStatus
+
+    Enumerates the status of an image viewer's current media.
+
+    \value NoMedia  There is no current media.
+    \value LoadingMedia The image viewer is loading the current media.
+    \value LoadedMedia The image viewer has loaded the current media.
+    \value InvalidMedia The current media cannot be loaded.
+*/
+
+/*!
+    Constructs a new image viewer with the given \a parent.
+*/
+QMediaImageViewer::QMediaImageViewer(QObject *parent)
+    : QMediaObject(*new QMediaImageViewerPrivate, parent, new QMediaImageViewerService)
+{
+    Q_D(QMediaImageViewer);
+
+    d->viewerControl = qobject_cast<QMediaImageViewerControl*>(
+            d->service->requestControl(QMediaImageViewerControl_iid));
+
+    connect(d->viewerControl, SIGNAL(mediaStatusChanged(QMediaImageViewer::MediaStatus)),
+            this, SLOT(_q_mediaStatusChanged(QMediaImageViewer::MediaStatus)));
+}
+
+/*!
+    Destroys an image viewer.
+*/
+QMediaImageViewer::~QMediaImageViewer()
+{
+    Q_D(QMediaImageViewer);
+
+    delete d->service;
+}
+
+/*!
+    \property QMediaImageViewer::state
+    \brief the playlist control state of a slide show.
+    \since 1.0
+*/
+
+QMediaImageViewer::State QMediaImageViewer::state() const
+{
+    return d_func()->state;
+}
+
+/*!
+    \fn QMediaImageViewer::stateChanged(QMediaImageViewer::State state)
+
+    Signals that the playlist control \a state of an image viewer has changed.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaImageViewer::mediaStatus
+    \brief the status of the current media.
+    \since 1.0
+*/
+
+QMediaImageViewer::MediaStatus QMediaImageViewer::mediaStatus() const
+{
+    return d_func()->viewerControl->mediaStatus();
+}
+
+/*!
+    \fn QMediaImageViewer::mediaStatusChanged(QMediaImageViewer::MediaStatus status)
+
+    Signals the the \a status of the current media has changed.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaImageViewer::media
+    \brief the media an image viewer is presenting.
+    \since 1.0
+*/
+
+QMediaContent QMediaImageViewer::media() const
+{
+    Q_D(const QMediaImageViewer);
+
+    return d->media;
+}
+
+void QMediaImageViewer::setMedia(const QMediaContent &media)
+{
+    Q_D(QMediaImageViewer);
+
+    if (d->playlist && d->playlist->currentMedia() != media) {
+        disconnect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
+                   this, SLOT(_q_playlistMediaChanged(QMediaContent)));
+        disconnect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
+
+        d->playlist = 0;
+    }
+
+    d->media = media;
+
+    if (d->timer.isActive()) {
+        d->pauseTime = 0;
+        d->timer.stop();
+        removePropertyWatch("elapsedTime");
+        emit elapsedTimeChanged(0);
+    }
+
+    if (d->state != QMediaImageViewer::StoppedState)
+        emit stateChanged(d->state = QMediaImageViewer::StoppedState);
+
+    d->viewerControl->showMedia(d->media);
+
+    emit mediaChanged(d->media);
+}
+
+/*!
+  Use \a playlist as the source of images to be displayed in the viewer.
+  \since 1.0
+*/
+void QMediaImageViewer::setPlaylist(QMediaPlaylist *playlist)
+{
+    Q_D(QMediaImageViewer);
+
+    if (d->playlist) {
+        disconnect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
+                   this, SLOT(_q_playlistMediaChanged(QMediaContent)));
+        disconnect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
+
+        QMediaObject::unbind(d->playlist);
+    }
+
+    d->playlist = playlist;
+
+    if (d->playlist) {
+        connect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
+                this, SLOT(_q_playlistMediaChanged(QMediaContent)));
+        connect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
+
+        QMediaObject::bind(d->playlist);
+
+        setMedia(d->playlist->currentMedia());
+    } else {
+        setMedia(QMediaContent());
+    }
+}
+
+/*!
+  Returns the current playlist, or 0 if none.
+  \since 1.0
+*/
+QMediaPlaylist *QMediaImageViewer::playlist() const
+{
+    return d_func()->playlist;
+}
+
+/*!
+    \fn QMediaImageViewer::mediaChanged(const QMediaContent &media)
+
+    Signals that the \a media an image viewer is presenting has changed.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaImageViewer::timeout
+    \brief the amount of time in milliseconds an image is displayed for before moving to the next
+    image.
+
+    The timeout only applies if the image viewer has a playlist attached and is in the PlayingState.
+    \since 1.0
+*/
+
+int QMediaImageViewer::timeout() const
+{
+    return d_func()->timeout;
+}
+
+void QMediaImageViewer::setTimeout(int timeout)
+{
+    Q_D(QMediaImageViewer);
+
+    d->timeout = qMax(0, timeout);
+
+    if (d->timer.isActive())
+        d->timer.start(qMax(0, d->timeout - d->pauseTime - d->time.elapsed()), this);
+}
+
+/*!
+    \property QMediaImageViewer::elapsedTime
+    \brief the amount of time in milliseconds that has elapsed since the current image was loaded.
+
+    The elapsed time only increases while the image viewer is in the PlayingState.  If stopped the
+    elapsed time will be reset to 0.
+    \since 1.0
+*/
+
+int QMediaImageViewer::elapsedTime() const
+{
+    Q_D(const QMediaImageViewer);
+
+    int elapsedTime = d->pauseTime;
+
+    if (d->timer.isActive())
+        elapsedTime += d->time.elapsed();
+
+    return elapsedTime;
+}
+
+/*!
+    \fn QMediaImageViewer::elapsedTimeChanged(int time)
+
+    Signals that the amount of \a time in milliseconds since the current
+    image was loaded has changed.
+
+    This signal is emitted at a regular interval when the image viewer is
+    in the PlayingState and an image is loaded.  The notification interval
+    is controlled by the QMediaObject::notifyInterval property.
+
+    \since 1.0
+    \sa timeout, QMediaObject::notifyInterval
+*/
+
+/*!
+    Sets a video \a widget as the current video output.
+
+    This will unbind any previous video output bound with setVideoOutput().
+    \since 1.1
+*/
+
+void QMediaImageViewer::setVideoOutput(QVideoWidget *widget)
+{
+    Q_D(QMediaImageViewer);
+
+    if (d->videoOutput)
+        unbind(d->videoOutput);
+
+    // We don't know (in this library) that QVideoWidget inherits QObject
+    QObject *widgetObject = reinterpret_cast<QObject*>(widget);
+
+    d->videoOutput = widgetObject && bind(widgetObject) ? widgetObject : 0;
+}
+
+/*!
+    Sets a video \a item as the current video output.
+
+    This will unbind any previous video output bound with setVideoOutput().
+    \since 1.1
+*/
+
+void QMediaImageViewer::setVideoOutput(QGraphicsVideoItem *item)
+{
+    Q_D(QMediaImageViewer);
+
+    if (d->videoOutput)
+        unbind(d->videoOutput);
+
+    // We don't know (in this library) that QGraphicsVideoItem (multiply) inherits QObject
+    // but QObject inheritance depends on QObject coming first, so try this out.
+    QObject *itemObject = reinterpret_cast<QObject*>(item);
+
+    d->videoOutput = itemObject && bind(itemObject) ? itemObject : 0;
+}
+
+/*!
+    Sets a video \a surface as the video output of a image viewer.
+
+    If a video output has already been set on the image viewer the new surface
+    will replace it.
+    \since 1.2
+*/
+
+void QMediaImageViewer::setVideoOutput(QAbstractVideoSurface *surface)
+{
+    Q_D(QMediaImageViewer);
+
+    d->surfaceOutput.setVideoSurface(surface);
+
+    if (d->videoOutput != &d->surfaceOutput) {
+        if (d->videoOutput)
+            unbind(d->videoOutput);
+
+        d->videoOutput = bind(&d->surfaceOutput) ? &d->surfaceOutput : 0;
+    }
+}
+
+/*!
+    \internal
+    \since 1.0
+*/
+bool QMediaImageViewer::bind(QObject *object)
+{
+    if (QMediaPlaylist *playlist = qobject_cast<QMediaPlaylist *>(object)) {
+        setPlaylist(playlist);
+
+        return true;
+    } else {
+        return QMediaObject::bind(object);
+    }
+}
+
+/*!
+     \internal
+     \since 1.0
+ */
+void QMediaImageViewer::unbind(QObject *object)
+{
+    if (object == d_func()->playlist)
+        setPlaylist(0);
+    else
+        QMediaObject::unbind(object);
+}
+
+/*!
+    Starts a slide show.
+
+    If the playlist has no current media this will start at the beginning of the playlist, otherwise
+    it will resume from the current media.
+
+    If no playlist is attached to an image viewer this will do nothing.
+    \since 1.0
+*/
+void QMediaImageViewer::play()
+{
+    Q_D(QMediaImageViewer);
+
+    if (d->playlist && d->playlist->mediaCount() > 0 && d->state != PlayingState) {
+        d->state = PlayingState;
+
+        switch (d->viewerControl->mediaStatus()) {
+        case NoMedia:
+        case InvalidMedia:
+            d->playlist->next();
+            if (d->playlist->currentIndex() < 0)
+                d->state = StoppedState;
+            break;
+        case LoadingMedia:
+            break;
+        case LoadedMedia:
+            d->time.start();
+            d->timer.start(qMax(0, d->timeout - d->pauseTime), this);
+            break;
+        }
+
+        if (d->state == PlayingState)
+            emit stateChanged(d->state);
+    }
+}
+
+/*!
+    Pauses a slide show.
+
+    The current media and elapsed time are retained.  If resumed, the current image will be
+    displayed for the remainder of the time out period before the next image is loaded.
+    \since 1.0
+*/
+void QMediaImageViewer::pause()
+{
+    Q_D(QMediaImageViewer);
+
+    if (d->state == PlayingState) {
+        if (d->viewerControl->mediaStatus() == LoadedMedia) {
+            d->pauseTime += d->timeout - d->time.elapsed();
+            d->timer.stop();
+            removePropertyWatch("elapsedTime");
+        }
+
+        emit stateChanged(d->state = PausedState);
+        emit elapsedTimeChanged(d->pauseTime);
+    }
+}
+
+/*!
+    Stops a slide show.
+
+    The current media is retained, but the elapsed time is discarded.  If resumed, the current
+    image will be displayed for the full time out period before the next image is loaded.
+    \since 1.0
+*/
+void QMediaImageViewer::stop()
+{
+    Q_D(QMediaImageViewer);
+
+    switch (d->state) {
+    case PlayingState:
+        d->timer.stop();
+        removePropertyWatch("elapsedTime");
+        // fall through.
+    case PausedState:
+        d->pauseTime = 0;
+        d->state = QMediaImageViewer::StoppedState;
+
+        emit stateChanged(d->state);
+        emit elapsedTimeChanged(0);
+        break;
+    case StoppedState:
+        break;
+    }
+}
+
+/*!
+    \reimp
+
+    \internal
+    \since 1.0
+*/
+void QMediaImageViewer::timerEvent(QTimerEvent *event)
+{
+    Q_D(QMediaImageViewer);
+
+    if (event->timerId() == d->timer.timerId()) {
+        d->timer.stop();
+        removePropertyWatch("elapsedTime");
+        emit elapsedTimeChanged(d->pauseTime = d->timeout);
+
+        d->playlist->next();
+
+        if (d->playlist->currentIndex() < 0) {
+            d->pauseTime = 0;
+            emit stateChanged(d->state = StoppedState);
+            emit elapsedTimeChanged(0);
+        }
+    } else {
+        QMediaObject::timerEvent(event);
+    }
+}
+
+#include "moc_qmediaimageviewer.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/imageviewer/qmediaimageviewer.h b/src/multimedia/imageviewer/qmediaimageviewer.h
new file mode 100644
index 0000000..7010fad
--- /dev/null
+++ b/src/multimedia/imageviewer/qmediaimageviewer.h
@@ -0,0 +1,142 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAIMAGEVIEWER_H
+#define QMEDIAIMAGEVIEWER_H
+
+#include "qmediaobject.h"
+#include "qmediacontent.h"
+#include <qmediaenumdebug.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QAbstractVideoSurface;
+class QGraphicsVideoItem;
+class QMediaPlaylist;
+class QVideoWidget;
+
+class QMediaImageViewerPrivate;
+class Q_MULTIMEDIA_EXPORT QMediaImageViewer : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(MediaStatus mediaStatus READ mediaStatus NOTIFY mediaStatusChanged)
+    Q_PROPERTY(QMediaContent media READ media WRITE setMedia NOTIFY mediaChanged)
+    Q_PROPERTY(int timeout READ timeout WRITE setTimeout)
+    Q_PROPERTY(int elapsedTime READ elapsedTime NOTIFY elapsedTimeChanged)
+    Q_ENUMS(State MediaStatus)
+
+public:
+    enum State
+    {
+        StoppedState,
+        PlayingState,
+        PausedState
+    };
+
+    enum MediaStatus
+    {
+        NoMedia,
+        LoadingMedia,
+        LoadedMedia,
+        InvalidMedia
+    };
+
+    explicit QMediaImageViewer(QObject *parent = 0);
+    ~QMediaImageViewer();
+
+    State state() const;
+    MediaStatus mediaStatus() const;
+
+    QMediaContent media() const;
+    QMediaPlaylist *playlist() const;
+
+    int timeout() const;
+    int elapsedTime() const;
+
+    void setVideoOutput(QVideoWidget *widget);
+    void setVideoOutput(QGraphicsVideoItem *item);
+    void setVideoOutput(QAbstractVideoSurface *surface);
+
+    bool bind(QObject *);
+    void unbind(QObject *);
+
+public Q_SLOTS:
+    void setMedia(const QMediaContent &media);
+    void setPlaylist(QMediaPlaylist *playlist);
+
+    void play();
+    void pause();
+    void stop();
+
+    void setTimeout(int timeout);
+
+Q_SIGNALS:
+    void stateChanged(QMediaImageViewer::State state);
+    void mediaStatusChanged(QMediaImageViewer::MediaStatus status);
+    void mediaChanged(const QMediaContent &media);
+    void elapsedTimeChanged(int time);
+protected:
+    void timerEvent(QTimerEvent *event);
+
+private:
+    Q_DECLARE_PRIVATE(QMediaImageViewer)
+    Q_PRIVATE_SLOT(d_func(), void _q_mediaStatusChanged(QMediaImageViewer::MediaStatus))
+    Q_PRIVATE_SLOT(d_func(), void _q_playlistMediaChanged(const QMediaContent &))
+    Q_PRIVATE_SLOT(d_func(), void _q_playlistDestroyed())
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMediaImageViewer::State)
+Q_DECLARE_METATYPE(QMediaImageViewer::MediaStatus)
+
+Q_MEDIA_ENUM_DEBUG(QMediaImageViewer, State)
+Q_MEDIA_ENUM_DEBUG(QMediaImageViewer, MediaStatus)
+
+QT_END_HEADER
+
+#endif
diff --git a/src/multimedia/imageviewer/qmediaimageviewerservice.cpp b/src/multimedia/imageviewer/qmediaimageviewerservice.cpp
new file mode 100644
index 0000000..94c6d2e
--- /dev/null
+++ b/src/multimedia/imageviewer/qmediaimageviewerservice.cpp
@@ -0,0 +1,463 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaimageviewerservice_p.h"
+
+#include "qmediacontrol_p.h"
+#include "qmediaservice_p.h"
+
+#include <qmediacontent.h>
+#include <qmediaresource.h>
+#include "qmediaobject_p.h"
+#include <qvideorenderercontrol.h>
+
+#include <QtCore/qdebug.h>
+
+#include <QtCore/qurl.h>
+#include <QtGui/qimagereader.h>
+
+#include <QtNetwork/qnetworkaccessmanager.h>
+#include <QtNetwork/qnetworkreply.h>
+#include <QtNetwork/qnetworkrequest.h>
+
+#include <qabstractvideosurface.h>
+#include <qvideosurfaceformat.h>
+
+QT_BEGIN_NAMESPACE
+
+class QMediaImageViewerServicePrivate : public QMediaServicePrivate
+{
+public:
+    QMediaImageViewerServicePrivate()
+        : viewerControl(0)
+        , rendererControl(0)
+        , network(0)
+        , internalNetwork(0)
+    {
+    }
+
+    bool load(QIODevice *device);
+    void clear();
+
+    QMediaImageViewerControl *viewerControl;
+    QMediaImageViewerRenderer *rendererControl;
+    QNetworkAccessManager *network;
+    QNetworkAccessManager *internalNetwork;
+    QImage m_image;
+};
+
+
+QMediaImageViewerRenderer::QMediaImageViewerRenderer(QObject *parent)
+    : QVideoRendererControl(parent)
+    , m_surface(0)
+{
+}
+
+QMediaImageViewerRenderer::~QMediaImageViewerRenderer()
+{
+    if (m_surface)
+        m_surface->stop();
+}
+
+QAbstractVideoSurface *QMediaImageViewerRenderer::surface() const
+{
+    return m_surface;
+}
+
+void QMediaImageViewerRenderer::setSurface(QAbstractVideoSurface *surface)
+{
+    if (m_surface)
+        m_surface->stop();
+
+    m_surface = surface;
+
+    if (m_surface && !m_image.isNull())
+        showImage(m_image);
+}
+
+void QMediaImageViewerRenderer::showImage(const QImage &image)
+{
+    m_image = image;
+
+    if (m_surface) {
+        if (m_image.isNull()) {
+            m_surface->stop();
+        } else {
+            QVideoSurfaceFormat format(
+                    image.size(), QVideoFrame::pixelFormatFromImageFormat(image.format()));
+
+            if (!m_surface->isFormatSupported(format)) {
+                foreach (QVideoFrame::PixelFormat pixelFormat, m_surface->supportedPixelFormats()) {
+                    const QImage::Format imageFormat
+                            = QVideoFrame::imageFormatFromPixelFormat(pixelFormat);
+
+                    if (imageFormat != QImage::Format_Invalid) {
+                        format = QVideoSurfaceFormat(image.size(), pixelFormat);
+
+                        if (m_surface->isFormatSupported(format) && m_surface->start(format)) {
+                            m_image = image.convertToFormat(imageFormat);
+
+                            m_surface->present(QVideoFrame(m_image));
+
+                            return;
+                        }
+                    }
+                }
+            } else if (m_surface->start(format)) {
+                m_surface->present(QVideoFrame(image));
+            }
+        }
+    }
+}
+
+bool QMediaImageViewerServicePrivate::load(QIODevice *device)
+{
+    QImageReader reader(device);
+
+    if (!reader.canRead()) {
+        m_image = QImage();
+    } else {
+        m_image = reader.read();
+    }
+
+    if (rendererControl)
+        rendererControl->showImage(m_image);
+
+    return !m_image.isNull();
+}
+
+void QMediaImageViewerServicePrivate::clear()
+{
+    m_image = QImage();
+
+    if (rendererControl)
+        rendererControl->showImage(m_image);
+}
+
+/*!
+    \class QMediaImageViewerService
+    \since 1.0
+    \internal
+*/
+
+/*!
+*/
+QMediaImageViewerService::QMediaImageViewerService(QObject *parent)
+    : QMediaService(*new QMediaImageViewerServicePrivate, parent)
+{
+    Q_D(QMediaImageViewerService);
+
+    d->viewerControl = new QMediaImageViewerControl(this);
+}
+
+/*!
+*/
+QMediaImageViewerService::~QMediaImageViewerService()
+{
+    Q_D(QMediaImageViewerService);
+
+    delete d->rendererControl;
+    delete d->viewerControl;
+}
+
+/*!
+*/
+QMediaControl *QMediaImageViewerService::requestControl(const char *name)
+{
+    Q_D(QMediaImageViewerService);
+
+    if (qstrcmp(name, QMediaImageViewerControl_iid) == 0) {
+        return d->viewerControl;
+    } else if (qstrcmp(name, QVideoRendererControl_iid) == 0) {
+        if (!d->rendererControl) {
+            d->rendererControl = new QMediaImageViewerRenderer;
+            d->rendererControl->showImage(d->m_image);
+
+            return d->rendererControl;
+        }
+    }
+    return 0;
+}
+
+void QMediaImageViewerService::releaseControl(QMediaControl *control)
+{
+    Q_D(QMediaImageViewerService);
+
+    if (!control) {
+        qWarning("QMediaService::releaseControl():"
+                " Attempted release of null control");
+    } else if (control == d->rendererControl) {
+        delete d->rendererControl;
+
+        d->rendererControl = 0;
+    }
+}
+
+/*!
+*/
+QNetworkAccessManager *QMediaImageViewerService::networkManager() const
+{
+    Q_D(const QMediaImageViewerService);
+
+    if (!d->network) {
+        QMediaImageViewerServicePrivate *_d = const_cast<QMediaImageViewerServicePrivate *>(d);
+
+        if (!_d->internalNetwork)
+            _d->internalNetwork = new QNetworkAccessManager(
+                    const_cast<QMediaImageViewerService *>(this));
+
+        _d->network = d->internalNetwork;
+    }
+
+    return d->network;
+}
+
+
+void QMediaImageViewerService::setNetworkManager(QNetworkAccessManager *manager)
+{
+    d_func()->network = manager;
+}
+
+class QMediaImageViewerControlPrivate : public QMediaControlPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QMediaImageViewerControl)
+public:
+    QMediaImageViewerControlPrivate()
+        : service(0)
+        , getReply(0)
+        , headReply(0)
+        , status(QMediaImageViewer::NoMedia)
+    {
+        foreach (const QByteArray &format, QImageReader::supportedImageFormats()) {
+            supportedExtensions.append(
+                    QLatin1Char('.') + QString::fromLatin1(format.data(), format.size()));
+        }
+    }
+
+    bool isImageType(const QUrl &url, const QString &mimeType) const;
+
+    void loadImage();
+    void cancelRequests();
+
+    void _q_getFinished();
+    void _q_headFinished();
+
+    QMediaImageViewerService *service;
+    QNetworkReply *getReply;
+    QNetworkReply *headReply;
+    QMediaImageViewer::MediaStatus status;
+    QMediaContent media;
+    QMediaResource currentMedia;
+    QList<QMediaResource> possibleResources;
+    QStringList supportedExtensions;
+};
+
+bool QMediaImageViewerControlPrivate::isImageType(const QUrl &url, const QString &mimeType) const
+{
+    if (!mimeType.isEmpty()) {
+        return mimeType.startsWith(QLatin1String("image/"))
+                || mimeType == QLatin1String("application/xml+svg");
+    } else if (url.scheme() == QLatin1String("file")) {
+        QString path = url.path();
+
+        foreach (const QString &extension, supportedExtensions) {
+            if (path.endsWith(extension, Qt::CaseInsensitive))
+                return true;
+        }
+    }
+    return false;
+}
+
+void QMediaImageViewerControlPrivate::loadImage()
+{
+    cancelRequests();
+
+    QMediaImageViewer::MediaStatus currentStatus = status;
+    status = QMediaImageViewer::InvalidMedia;
+
+    QNetworkAccessManager *network = service->networkManager();
+
+    while (!possibleResources.isEmpty() && !headReply && !getReply) {
+        currentMedia = possibleResources.takeFirst();
+
+        QUrl url = currentMedia.url();
+        QString mimeType = currentMedia.mimeType();
+
+        if (isImageType(url, mimeType)) {
+            getReply = network->get(QNetworkRequest(url));
+            QObject::connect(getReply, SIGNAL(finished()), q_func(), SLOT(_q_getFinished()));
+
+            status = QMediaImageViewer::LoadingMedia;
+        } else if (mimeType.isEmpty() && url.scheme() != QLatin1String("file")) {
+            headReply = network->head(QNetworkRequest(currentMedia.url()));
+            QObject::connect(headReply, SIGNAL(finished()), q_func(), SLOT(_q_headFinished()));
+
+            status = QMediaImageViewer::LoadingMedia;
+        }
+    }
+
+    if (status == QMediaImageViewer::InvalidMedia)
+        currentMedia = QMediaResource();
+
+    if (status != currentStatus)
+        emit q_func()->mediaStatusChanged(status);
+}
+
+void QMediaImageViewerControlPrivate::cancelRequests()
+{
+    if (getReply) {
+        getReply->abort();
+        getReply->deleteLater();
+        getReply = 0;
+    }
+
+    if (headReply) {
+        headReply->abort();
+        headReply->deleteLater();
+        headReply = 0;
+    }
+}
+
+void QMediaImageViewerControlPrivate::_q_getFinished()
+{
+    if (getReply != q_func()->sender())
+        return;
+
+    QImage image;
+
+    if (service->d_func()->load(getReply)) {
+        possibleResources.clear();
+
+        status = QMediaImageViewer::LoadedMedia;
+
+        emit q_func()->mediaStatusChanged(status);
+    } else {
+        loadImage();
+    }
+}
+
+void QMediaImageViewerControlPrivate::_q_headFinished()
+{
+    if (headReply != q_func()->sender())
+        return;
+
+    QString mimeType = headReply->header(QNetworkRequest::ContentTypeHeader)
+            .toString().section(QLatin1Char(';'), 0, 0);
+    QUrl url = headReply->url();
+    if (url.isEmpty())
+        url = headReply->request().url();
+
+    headReply->deleteLater();
+    headReply = 0;
+
+    if (isImageType(url, mimeType) || mimeType.isEmpty()) {
+        QNetworkAccessManager *network = service->networkManager();
+
+        getReply = network->get(QNetworkRequest(url));
+
+        QObject::connect(getReply, SIGNAL(finished()), q_func(), SLOT(_q_getFinished()));
+    } else {
+        loadImage();
+    }
+}
+
+/*!
+    \class QMediaImageViewerControl
+    \internal
+    \since 1.1
+*/
+QMediaImageViewerControl::QMediaImageViewerControl(QMediaImageViewerService *parent)
+    : QMediaControl(*new QMediaImageViewerControlPrivate, parent)
+{
+    Q_D(QMediaImageViewerControl);
+
+    d->service = parent;
+}
+
+/*!
+*/
+QMediaImageViewerControl::~QMediaImageViewerControl()
+{
+    Q_D(QMediaImageViewerControl);
+
+    delete d->getReply;
+}
+
+/*!
+    \since 1.1
+*/
+QMediaImageViewer::MediaStatus QMediaImageViewerControl::mediaStatus() const
+{
+    return d_func()->status;
+}
+
+/*!
+    \fn QMediaImageViewerControl::mediaStatusChanged(QMediaImageViewer::MediaStatus status);
+    \since 1.1
+*/
+
+/*!
+    \since 1.1
+*/
+void QMediaImageViewerControl::showMedia(const QMediaContent &media)
+{
+    Q_D(QMediaImageViewerControl);
+
+    d->media = media;
+    d->currentMedia = QMediaResource();
+    d->cancelRequests();
+
+    if (media.isNull()) {
+        d->service->d_func()->clear();
+        if (d->status != QMediaImageViewer::NoMedia) {
+            d->status = QMediaImageViewer::NoMedia;
+            emit mediaStatusChanged(d->status);
+        }
+    } else {
+        d->possibleResources = media.resources();
+        d->loadImage();
+    }
+}
+
+
+#include "moc_qmediaimageviewerservice_p.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/imageviewer/qmediaimageviewerservice_p.h b/src/multimedia/imageviewer/qmediaimageviewerservice_p.h
new file mode 100644
index 0000000..d1b6956
--- /dev/null
+++ b/src/multimedia/imageviewer/qmediaimageviewerservice_p.h
@@ -0,0 +1,147 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIASLIDESHOWSERVICE_P_H
+#define QMEDIASLIDESHOWSERVICE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <qtmultimediadefs.h>
+#include <qmediaservice.h>
+#include <qmediaimageviewer.h>
+#include <qvideorenderercontrol.h>
+
+#include <QtCore/qpointer.h>
+#include <QtGui/qimage.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QAbstractVideoSurface;
+class QNetworkAccessManager;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class QMediaImageViewerServicePrivate;
+
+class Q_AUTOTEST_EXPORT QMediaImageViewerService : public QMediaService
+{
+    Q_OBJECT
+public:
+    explicit QMediaImageViewerService(QObject *parent = 0);
+    ~QMediaImageViewerService();
+
+    QMediaControl *requestControl(const char *name);
+    void releaseControl(QMediaControl *);
+
+    QNetworkAccessManager *networkManager() const;
+    void setNetworkManager(QNetworkAccessManager *manager);
+
+private:
+    Q_DECLARE_PRIVATE(QMediaImageViewerService)
+    friend class QMediaImageViewerControl;
+    friend class QMediaImageViewerControlPrivate;
+};
+
+class QMediaImageViewerControlPrivate;
+
+class QMediaImageViewerControl : public QMediaControl
+{
+    Q_OBJECT
+public:
+    explicit QMediaImageViewerControl(QMediaImageViewerService *parent);
+    ~QMediaImageViewerControl();
+
+    QMediaImageViewer::MediaStatus mediaStatus() const;
+
+    void showMedia(const QMediaContent &media);
+
+Q_SIGNALS:
+    void mediaStatusChanged(QMediaImageViewer::MediaStatus status);
+
+private:
+    Q_DECLARE_PRIVATE(QMediaImageViewerControl)
+    Q_PRIVATE_SLOT(d_func(), void _q_headFinished())
+    Q_PRIVATE_SLOT(d_func(), void _q_getFinished())
+};
+
+#define QMediaImageViewerControl_iid "com.nokia.Qt.QMediaImageViewerControl/1.0"
+Q_MEDIA_DECLARE_CONTROL(QMediaImageViewerControl, QMediaImageViewerControl_iid)
+
+class QMediaImageViewerRenderer : public QVideoRendererControl
+{
+    Q_OBJECT
+public:
+    QMediaImageViewerRenderer(QObject *parent = 0);
+    ~QMediaImageViewerRenderer();
+
+    QAbstractVideoSurface *surface() const;
+    void setSurface(QAbstractVideoSurface *surface);
+
+    void showImage(const QImage &image);
+
+Q_SIGNALS:
+    void surfaceChanged(QAbstractVideoSurface *surface);
+
+private:
+    QPointer<QAbstractVideoSurface> m_surface;
+    QImage m_image;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
diff --git a/src/multimedia/multimedia.pro b/src/multimedia/multimedia.pro
index 120f8fa..05213b0 100644
--- a/src/multimedia/multimedia.pro
+++ b/src/multimedia/multimedia.pro
@@ -19,141 +19,44 @@ load(qt_module_config)
 
 HEADERS += qtmultimediaversion.h
 
+INCLUDEPATH *= .
+
 PRIVATE_HEADERS += \
     qmediacontrol_p.h \
     qmediaobject_p.h \
-    qmediaservice_p.h  \
-    qmediaplaylist_p.h \
-    qmediaplaylistprovider_p.h \
-    qmediaimageviewerservice_p.h \
     qmediapluginloader_p.h \
-    qvideosurfaceoutput_p.h
+    qmediaservice_p.h \
 
 PUBLIC_HEADERS += \
+    qmediabindableinterface.h \
     qmediacontrol.h \
+    qmediaenumdebug.h \
     qmediaobject.h \
     qmediaservice.h \
-    qmediabindableinterface.h \
-    qlocalmediaplaylistprovider.h \
-    qmediaimageviewer.h \
-    qmediaplayer.h \
-    qmediaplayercontrol.h \
-    qmediaplaylist.h \
-    qmediaplaylistnavigator.h \
-    qmediaplaylistprovider.h \
-    qmediaplaylistioplugin.h \
-    qmediabackgroundplaybackcontrol.h \
-    qmediacontent.h \
-    qmediaresource.h \
-    qmediarecorder.h \
-    qmediaencodersettings.h \
-    qmediarecordercontrol.h \
     qmediaserviceprovider.h \
     qmediaserviceproviderplugin.h \
-    qmetadatareadercontrol.h \
-    qmetadatawritercontrol.h \
-    qmediastreamscontrol.h \
-    qradiotuner.h \
-    qradiodata.h \
-    qradiotunercontrol.h \
-    qradiodatacontrol.h \
-    qtmedianamespace.h \
-    qaudioencodercontrol.h \
-    qvideoencodercontrol.h \
-    qimageencodercontrol.h \
-    qaudiocapturesource.h \
-    qmediacontainercontrol.h \
-    qmediaplaylistcontrol.h \
-    qmediaplaylistsourcecontrol.h \
-    qaudioendpointselector.h \
-    qvideodevicecontrol.h \
-    qvideorenderercontrol.h \
     qmediatimerange.h \
-    qmedianetworkaccesscontrol.h \
-    qmediaenumdebug.h \
+    qtmedianamespace.h \
     qtmultimediadefs.h \
-    qmediagaplessplaybackcontrol.h
 
-SOURCES += qmediacontrol.cpp \
+SOURCES += \
+    qmediabindableinterface.cpp \
+    qmediacontrol.cpp \
     qmediaobject.cpp \
+    qmediapluginloader.cpp \
     qmediaservice.cpp \
-    qmediabindableinterface.cpp \
-    qlocalmediaplaylistprovider.cpp \
-    qmediaimageviewer.cpp \
-    qmediaimageviewerservice.cpp \
-    qmediaplayer.cpp \
-    qmediaplayercontrol.cpp \
-    qmediaplaylist.cpp \
-    qmediaplaylistioplugin.cpp \
-    qmediaplaylistnavigator.cpp \
-    qmediaplaylistprovider.cpp \
-    qmediarecorder.cpp \
-    qmediaencodersettings.cpp \
-    qmediarecordercontrol.cpp \
-    qmediacontent.cpp \
-    qmediaresource.cpp \
     qmediaserviceprovider.cpp \
-    qmetadatareadercontrol.cpp \
-    qmetadatawritercontrol.cpp \
-    qmediastreamscontrol.cpp \
-    qradiotuner.cpp \
-    qradiodata.cpp \
-    qradiotunercontrol.cpp \
-    qradiodatacontrol.cpp \
-    qaudioencodercontrol.cpp \
-    qvideoencodercontrol.cpp \
-    qimageencodercontrol.cpp \
-    qaudiocapturesource.cpp \
-    qmediacontainercontrol.cpp \
-    qmediaplaylistcontrol.cpp \
-    qmediaplaylistsourcecontrol.cpp \
-    qaudioendpointselector.cpp \
-    qvideodevicecontrol.cpp \
-    qmediapluginloader.cpp \
-    qvideorenderercontrol.cpp \
     qmediatimerange.cpp \
-    qmedianetworkaccesscontrol.cpp \
-    qvideosurfaceoutput.cpp \
-    qmediabackgroundplaybackcontrol.cpp \
-    qtmedianamespace.cpp \
-    qmediagaplessplaybackcontrol.cpp
-
-#Camera
-PUBLIC_HEADERS += \
-    qcamera.h \
-    qcameraimagecapture.h \
-    qcameraimagecapturecontrol.h \
-    qcameraexposure.h \
-    qcamerafocus.h \
-    qcameraimageprocessing.h \
-    qcameracontrol.h \
-    qcameralockscontrol.h \
-    qcameraexposurecontrol.h \
-    qcamerafocuscontrol.h \
-    qcameraflashcontrol.h \
-    qcameraimageprocessingcontrol.h \
-    qcameracapturedestinationcontrol.h \
-    qcameracapturebufferformatcontrol.h
-
-SOURCES += \
-    qcamera.cpp \
-    qcameraexposure.cpp \
-    qcamerafocus.cpp \
-    qcameraimageprocessing.cpp \
-    qcameraimagecapture.cpp \
-    qcameraimagecapturecontrol.cpp \
-    qcameracontrol.cpp \
-    qcameralockscontrol.cpp \
-    qcameraexposurecontrol.cpp \
-    qcamerafocuscontrol.cpp \
-    qcameraflashcontrol.cpp \
-    qcameraimageprocessingcontrol.cpp \
-    qcameracapturedestinationcontrol.cpp \
-    qcameracapturebufferformatcontrol.cpp
+    qtmedianamespace.cpp
 
 include(audio/audio.pri)
+include(camera/camera.pri)
+include(controls/controls.pri)
+include(imageviewer/imageviewer.pri)
+include(playback/playback.pri)
+include(radio/radio.pri)
+include(recording/recording.pri)
 include(video/video.pri)
-include(effects/effects.pri)
 
 mac {
    LIBS += -framework AppKit -framework QuartzCore -framework QTKit
diff --git a/src/multimedia/playback/playback.pri b/src/multimedia/playback/playback.pri
new file mode 100644
index 0000000..f43f608
--- /dev/null
+++ b/src/multimedia/playback/playback.pri
@@ -0,0 +1,27 @@
+INCLUDEPATH += playback
+
+PUBLIC_HEADERS += \
+    playback/qaudioendpointselector.h \
+    playback/qlocalmediaplaylistprovider.h \
+    playback/qmediacontent.h \
+    playback/qmediaplayer.h \
+    playback/qmediaplaylist.h \
+    playback/qmediaplaylistioplugin.h \
+    playback/qmediaplaylistnavigator.h \
+    playback/qmediaplaylistprovider.h \
+    playback/qmediaresource.h
+
+PRIVATE_HEADERS += \
+    playback/qmediaplaylist_p.h \
+    playback/qmediaplaylistprovider_p.h
+
+SOURCES += \
+    playback/qaudioendpointselector.cpp \
+    playback/qlocalmediaplaylistprovider.cpp \
+    playback/qmediacontent.cpp \
+    playback/qmediaplayer.cpp \
+    playback/qmediaplaylist.cpp \
+    playback/qmediaplaylistioplugin.cpp \
+    playback/qmediaplaylistnavigator.cpp \
+    playback/qmediaplaylistprovider.cpp \
+    playback/qmediaresource.cpp
diff --git a/src/multimedia/playback/qaudioendpointselector.cpp b/src/multimedia/playback/qaudioendpointselector.cpp
new file mode 100644
index 0000000..ba02c8d
--- /dev/null
+++ b/src/multimedia/playback/qaudioendpointselector.cpp
@@ -0,0 +1,140 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qaudioendpointselector.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QAudioEndpointSelector
+
+    \brief The QAudioEndpointSelector class provides an audio endpoint selector media control.
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+    The QAudioEndpointSelector class provides descriptions of the audio
+    endpoints available on a system and allows one to be selected as the audio
+    of a media service.
+
+    The interface name of QAudioEndpointSelector is \c com.nokia.Qt.QAudioEndpointSelector/1.0 as
+    defined in QAudioEndpointSelector_iid.
+
+    \sa QMediaService::requestControl()
+*/
+
+/*!
+    \macro QAudioEndpointSelector_iid
+
+    \c com.nokia.Qt.QAudioEndpointSelector/1.0
+
+    Defines the interface name of the QAudioEndpointSelector class.
+
+    \relates QAudioEndpointSelector
+*/
+
+/*!
+    Constructs a new audio endpoint selector with the given \a parent.
+*/
+QAudioEndpointSelector::QAudioEndpointSelector(QObject *parent)
+    :QMediaControl(parent)
+{
+}
+
+/*!
+    Destroys an audio endpoint selector.
+*/
+QAudioEndpointSelector::~QAudioEndpointSelector()
+{
+}
+
+/*!
+    \fn QList<QString> QAudioEndpointSelector::availableEndpoints() const
+
+    Returns a list of the names of the available audio endpoints.
+    \since 1.0
+*/
+
+/*!
+    \fn QString QAudioEndpointSelector::endpointDescription(const QString& name) const
+
+    Returns the description of the endpoint \a name.
+    \since 1.0
+*/
+
+/*!
+    \fn QString QAudioEndpointSelector::defaultEndpoint() const
+
+    Returns the name of the default audio endpoint.
+    \since 1.0
+*/
+
+/*!
+    \fn QString QAudioEndpointSelector::activeEndpoint() const
+
+    Returns the name of the currently selected audio endpoint.
+    \since 1.0
+*/
+
+/*!
+    \fn QAudioEndpointSelector::setActiveEndpoint(const QString& name)
+
+    Set the active audio endpoint to \a name.
+    \since 1.0
+*/
+
+/*!
+    \fn QAudioEndpointSelector::activeEndpointChanged(const QString& name)
+
+    Signals that the audio endpoint has changed to \a name.
+    \since 1.0
+*/
+
+/*!
+    \fn QAudioEndpointSelector::availableEndpointsChanged()
+
+    Signals that list of available endpoints has changed.
+    \since 1.0
+*/
+
+#include "moc_qaudioendpointselector.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qaudioendpointselector.h b/src/multimedia/playback/qaudioendpointselector.h
new file mode 100644
index 0000000..00250bc
--- /dev/null
+++ b/src/multimedia/playback/qaudioendpointselector.h
@@ -0,0 +1,86 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAUDIOENDPOINTSELECTOR_H
+#define QAUDIOENDPOINTSELECTOR_H
+
+#include <qaudio.h>
+#include <qmediacontrol.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QAudioEndpointSelector : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    virtual ~QAudioEndpointSelector();
+
+    virtual QList<QString> availableEndpoints() const = 0;
+    virtual QString endpointDescription(const QString& name) const = 0;
+    virtual QString defaultEndpoint() const = 0;
+    virtual QString activeEndpoint() const = 0;
+
+public Q_SLOTS:
+    virtual void setActiveEndpoint(const QString& name) = 0;
+
+Q_SIGNALS:
+    void activeEndpointChanged(const QString& name);
+    void availableEndpointsChanged();
+
+protected:
+    QAudioEndpointSelector(QObject *parent = 0);
+};
+
+#define QAudioEndpointSelector_iid "com.nokia.Qt.QAudioEndpointSelector/1.0"
+Q_MEDIA_DECLARE_CONTROL(QAudioEndpointSelector, QAudioEndpointSelector_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QAUDIOENDPOINTSELECTOR_H
diff --git a/src/multimedia/playback/qlocalmediaplaylistprovider.cpp b/src/multimedia/playback/qlocalmediaplaylistprovider.cpp
new file mode 100644
index 0000000..84d54ec
--- /dev/null
+++ b/src/multimedia/playback/qlocalmediaplaylistprovider.cpp
@@ -0,0 +1,194 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qlocalmediaplaylistprovider.h"
+#include "qmediaplaylistprovider_p.h"
+#include "qmediacontent.h"
+
+QT_BEGIN_NAMESPACE
+
+class QLocalMediaPlaylistProviderPrivate: public QMediaPlaylistProviderPrivate
+{
+public:
+    QList<QMediaContent> resources;
+};
+
+QLocalMediaPlaylistProvider::QLocalMediaPlaylistProvider(QObject *parent)
+    :QMediaPlaylistProvider(*new QLocalMediaPlaylistProviderPrivate, parent)
+{
+}
+
+QLocalMediaPlaylistProvider::~QLocalMediaPlaylistProvider()
+{
+}
+
+bool QLocalMediaPlaylistProvider::isReadOnly() const
+{
+    return false;
+}
+
+int QLocalMediaPlaylistProvider::mediaCount() const
+{
+    return d_func()->resources.size();
+}
+
+QMediaContent QLocalMediaPlaylistProvider::media(int pos) const
+{
+    return d_func()->resources.value(pos);
+}
+
+bool QLocalMediaPlaylistProvider::addMedia(const QMediaContent &content)
+{
+    Q_D(QLocalMediaPlaylistProvider);
+
+    int pos = d->resources.count();
+
+    emit mediaAboutToBeInserted(pos, pos);
+    d->resources.append(content);
+    emit mediaInserted(pos, pos);
+
+    return true;
+}
+
+bool QLocalMediaPlaylistProvider::addMedia(const QList<QMediaContent> &items)
+{
+    Q_D(QLocalMediaPlaylistProvider);
+
+    if (items.isEmpty())
+        return true;
+
+    int pos = d->resources.count();
+    int end = pos+items.count()-1;
+
+    emit mediaAboutToBeInserted(pos, end);
+    d->resources.append(items);
+    emit mediaInserted(pos, end);
+
+    return true;
+}
+
+
+bool QLocalMediaPlaylistProvider::insertMedia(int pos, const QMediaContent &content)
+{
+    Q_D(QLocalMediaPlaylistProvider);
+
+    emit mediaAboutToBeInserted(pos, pos);
+    d->resources.insert(pos, content);
+    emit mediaInserted(pos,pos);
+
+    return true;
+}
+
+bool QLocalMediaPlaylistProvider::insertMedia(int pos, const QList<QMediaContent> &items)
+{
+    Q_D(QLocalMediaPlaylistProvider);
+
+    if (items.isEmpty())
+        return true;
+
+    const int last = pos+items.count()-1;
+
+    emit mediaAboutToBeInserted(pos, last);
+    for (int i=0; i<items.count(); i++)
+        d->resources.insert(pos+i, items.at(i));
+    emit mediaInserted(pos, last);
+
+    return true;
+}
+
+bool QLocalMediaPlaylistProvider::removeMedia(int fromPos, int toPos)
+{
+    Q_D(QLocalMediaPlaylistProvider);
+
+    Q_ASSERT(fromPos >= 0);
+    Q_ASSERT(fromPos <= toPos);
+    Q_ASSERT(toPos < mediaCount());
+
+    emit mediaAboutToBeRemoved(fromPos, toPos);
+    d->resources.erase(d->resources.begin()+fromPos, d->resources.begin()+toPos+1);
+    emit mediaRemoved(fromPos, toPos);
+
+    return true;
+}
+
+bool QLocalMediaPlaylistProvider::removeMedia(int pos)
+{
+    Q_D(QLocalMediaPlaylistProvider);
+
+    emit mediaAboutToBeRemoved(pos, pos);
+    d->resources.removeAt(pos);
+    emit mediaRemoved(pos, pos);
+
+    return true;
+}
+
+bool QLocalMediaPlaylistProvider::clear()
+{
+    Q_D(QLocalMediaPlaylistProvider);
+    if (!d->resources.isEmpty()) {
+        int lastPos = mediaCount()-1;
+        emit mediaAboutToBeRemoved(0, lastPos);
+        d->resources.clear();
+        emit mediaRemoved(0, lastPos);
+    }
+
+    return true;
+}
+
+void QLocalMediaPlaylistProvider::shuffle()
+{
+    Q_D(QLocalMediaPlaylistProvider);
+    if (!d->resources.isEmpty()) {
+        QList<QMediaContent> resources;
+
+        while (!d->resources.isEmpty()) {
+            resources.append(d->resources.takeAt(qrand() % d->resources.size()));
+        }
+
+        d->resources = resources;
+        emit mediaChanged(0, mediaCount()-1);
+    }
+
+}
+
+#include "moc_qlocalmediaplaylistprovider.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qlocalmediaplaylistprovider.h b/src/multimedia/playback/qlocalmediaplaylistprovider.h
new file mode 100644
index 0000000..e712a3f
--- /dev/null
+++ b/src/multimedia/playback/qlocalmediaplaylistprovider.h
@@ -0,0 +1,87 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QLOCALMEDIAPAYLISTPROVIDER_H
+#define QLOCALMEDIAPAYLISTPROVIDER_H
+
+#include "qmediaplaylistprovider.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QLocalMediaPlaylistProviderPrivate;
+class Q_MULTIMEDIA_EXPORT QLocalMediaPlaylistProvider : public QMediaPlaylistProvider
+{
+    Q_OBJECT
+public:
+    QLocalMediaPlaylistProvider(QObject *parent=0);
+    virtual ~QLocalMediaPlaylistProvider();
+
+    virtual int mediaCount() const;
+    virtual QMediaContent media(int pos) const;
+
+    virtual bool isReadOnly() const;
+
+    virtual bool addMedia(const QMediaContent &content);
+    virtual bool addMedia(const QList<QMediaContent> &items);
+    virtual bool insertMedia(int pos, const QMediaContent &content);
+    virtual bool insertMedia(int pos, const QList<QMediaContent> &items);
+    virtual bool removeMedia(int pos);
+    virtual bool removeMedia(int start, int end);
+    virtual bool clear();
+
+public Q_SLOTS:
+    virtual void shuffle();
+
+private:
+    Q_DECLARE_PRIVATE(QLocalMediaPlaylistProvider)
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QLOCALMEDIAPAYLISTSOURCE_H
diff --git a/src/multimedia/playback/qmediacontent.cpp b/src/multimedia/playback/qmediacontent.cpp
new file mode 100644
index 0000000..373710c
--- /dev/null
+++ b/src/multimedia/playback/qmediacontent.cpp
@@ -0,0 +1,266 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/qurl.h>
+#include <QtCore/qvariant.h>
+
+#include "qmediacontent.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace
+{
+    class QMediaContentPrivateRegisterMetaTypes
+    {
+    public:
+        QMediaContentPrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QMediaContent>();
+        }
+    } _registerMetaTypes;
+}
+
+
+class QMediaContentPrivate : public QSharedData
+{
+public:
+    QMediaContentPrivate() {}
+    QMediaContentPrivate(const QMediaResourceList &r):
+        resources(r) {}
+
+    QMediaContentPrivate(const QMediaContentPrivate &other):
+        QSharedData(other),
+        resources(other.resources)
+    {}
+
+    bool operator ==(const QMediaContentPrivate &other) const
+    {
+        return resources == other.resources;
+    }
+
+    QMediaResourceList  resources;
+private:
+    QMediaContentPrivate& operator=(const QMediaContentPrivate &other);
+};
+
+
+/*!
+    \class QMediaContent
+
+    \brief The QMediaContent class provides access to the resources relating to a media content.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+    QMediaContent is used within the multimedia framework as the logical handle
+    to media content.  A QMediaContent object is composed of one or more
+    \l {QMediaResource}s where each resource provides the URL and format
+    information of a different encoding of the content.
+
+    A non-null QMediaContent will always have a primary or canonical reference to
+    the content available through the canonicalUrl() or canonicalResource()
+    methods, any additional resources are optional.
+*/
+
+
+/*!
+    Constructs a null QMediaContent.
+*/
+
+QMediaContent::QMediaContent()
+{
+}
+
+/*!
+    Constructs a media content with \a url providing a reference to the content.
+    \since 1.0
+*/
+
+QMediaContent::QMediaContent(const QUrl &url):
+    d(new QMediaContentPrivate)
+{
+    d->resources << QMediaResource(url);
+}
+
+/*!
+    Constructs a media content with \a request providing a reference to the content.
+
+    This constructor can be used to reference media content via network protocols such as HTTP.
+    This may include additional information required to obtain the resource, such as Cookies or HTTP headers.
+    \since 1.0
+*/
+
+QMediaContent::QMediaContent(const QNetworkRequest &request):
+    d(new QMediaContentPrivate)
+{
+    d->resources << QMediaResource(request);
+}
+
+/*!
+    Constructs a media content with \a resource providing a reference to the content.
+    \since 1.0
+*/
+
+QMediaContent::QMediaContent(const QMediaResource &resource):
+    d(new QMediaContentPrivate)
+{
+    d->resources << resource;
+}
+
+/*!
+    Constructs a media content with \a resources providing a reference to the content.
+    \since 1.0
+*/
+
+QMediaContent::QMediaContent(const QMediaResourceList &resources):
+    d(new QMediaContentPrivate(resources))
+{
+}
+
+/*!
+    Constructs a copy of the media content \a other.
+    \since 1.0
+*/
+
+QMediaContent::QMediaContent(const QMediaContent &other):
+    d(other.d)
+{
+}
+
+/*!
+    Destroys the media content object.
+*/
+
+QMediaContent::~QMediaContent()
+{
+}
+
+/*!
+    Assigns the value of \a other to this media content.
+    \since 1.0
+*/
+
+QMediaContent& QMediaContent::operator=(const QMediaContent &other)
+{
+    d = other.d;
+    return *this;
+}
+
+/*!
+    Returns true if \a other is equivalent to this media content; false otherwise.
+    \since 1.0
+*/
+
+bool QMediaContent::operator==(const QMediaContent &other) const
+{
+    return (d.constData() == 0 && other.d.constData() == 0) ||
+            (d.constData() != 0 && other.d.constData() != 0 &&
+             *d.constData() == *other.d.constData());
+}
+
+/*!
+    Returns true if \a other is not equivalent to this media content; false otherwise.
+    \since 1.0
+*/
+
+bool QMediaContent::operator!=(const QMediaContent &other) const
+{
+    return !(*this == other);
+}
+
+/*!
+    Returns true if this media content is null (uninitialized); false otherwise.
+    \since 1.0
+*/
+
+bool QMediaContent::isNull() const
+{
+    return d.constData() == 0;
+}
+
+/*!
+    Returns a QUrl that represents that canonical resource for this media content.
+    \since 1.0
+*/
+
+QUrl QMediaContent::canonicalUrl() const
+{
+    return canonicalResource().url();
+}
+
+/*!
+    Returns a QNetworkRequest that represents that canonical resource for this media content.
+    \since 1.0
+*/
+
+QNetworkRequest QMediaContent::canonicalRequest() const
+{
+    return canonicalResource().request();
+}
+
+/*!
+    Returns a QMediaResource that represents that canonical resource for this media content.
+    \since 1.0
+*/
+
+QMediaResource QMediaContent::canonicalResource() const
+{
+    return d.constData() != 0
+            ?  d->resources.value(0)
+            : QMediaResource();
+}
+
+/*!
+    Returns a list of alternative resources for this media content.  The first item in this list
+    is always the canonical resource.
+    \since 1.0
+*/
+
+QMediaResourceList QMediaContent::resources() const
+{
+    return d.constData() != 0
+            ? d->resources
+            : QMediaResourceList();
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qmediacontent.h b/src/multimedia/playback/qmediacontent.h
new file mode 100644
index 0000000..cfd109d
--- /dev/null
+++ b/src/multimedia/playback/qmediacontent.h
@@ -0,0 +1,95 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIACONTENT_H
+#define QMEDIACONTENT_H
+
+#include <QtCore/qmetatype.h>
+#include <QtCore/qshareddata.h>
+
+#include "qmediaresource.h"
+
+#include <qtmultimediadefs.h>
+
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QMediaContentPrivate;
+class Q_MULTIMEDIA_EXPORT QMediaContent
+{
+public:
+    QMediaContent();
+    QMediaContent(const QUrl &contentUrl);
+    QMediaContent(const QNetworkRequest &contentRequest);
+    QMediaContent(const QMediaResource &contentResource);
+    QMediaContent(const QMediaResourceList &resources);
+    QMediaContent(const QMediaContent &other);
+    ~QMediaContent();
+
+    QMediaContent& operator=(const QMediaContent &other);
+
+    bool operator==(const QMediaContent &other) const;
+    bool operator!=(const QMediaContent &other) const;
+
+    bool isNull() const;
+
+    QUrl canonicalUrl() const;
+    QNetworkRequest canonicalRequest() const;
+    QMediaResource canonicalResource() const;
+
+    QMediaResourceList resources() const;
+
+private:
+    QSharedDataPointer<QMediaContentPrivate> d;
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMediaContent)
+
+QT_END_HEADER
+
+#endif  // QMEDIACONTENT_H
diff --git a/src/multimedia/playback/qmediaplayer.cpp b/src/multimedia/playback/qmediaplayer.cpp
new file mode 100644
index 0000000..312122d
--- /dev/null
+++ b/src/multimedia/playback/qmediaplayer.cpp
@@ -0,0 +1,1139 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaplayer.h"
+#include "qvideosurfaceoutput_p.h"
+
+#include "qmediaobject_p.h"
+#include <qmediaservice.h>
+#include <qmediaplayercontrol.h>
+#include <qmediaserviceprovider.h>
+#include <qmediaplaylist.h>
+#include <qmediaplaylistcontrol.h>
+#include <qmediaplaylistsourcecontrol.h>
+
+#include <qmedianetworkaccesscontrol.h>
+
+#include <QtCore/qcoreevent.h>
+#include <QtCore/qmetaobject.h>
+#include <QtCore/qtimer.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qpointer.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaPlayer
+    \brief The QMediaPlayer class allows the playing of a media source.
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+
+
+    The QMediaPlayer class is a high level media playback class. It can be used
+    to playback such content as songs, movies and internet radio. The content
+    to playback is specified as a QMediaContent, which can be thought of as a
+    main or canonical URL with addition information attached. When provided
+    with a QMediaContent playback may be able to commence.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Player
+
+    QVideoWidget can be used with QMediaPlayer for video rendering and QMediaPlaylist
+    for accessing playlist functionality.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Movie playlist
+
+    \sa QMediaObject, QMediaService, QVideoWidget, QMediaPlaylist
+*/
+
+namespace
+{
+class MediaPlayerRegisterMetaTypes
+{
+public:
+    MediaPlayerRegisterMetaTypes()
+    {
+        qRegisterMetaType<QMediaPlayer::State>("QMediaPlayer::State");
+        qRegisterMetaType<QMediaPlayer::MediaStatus>("QMediaPlayer::MediaStatus");
+        qRegisterMetaType<QMediaPlayer::Error>("QMediaPlayer::Error");
+    }
+} _registerPlayerMetaTypes;
+}
+
+class QMediaPlayerPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QMediaPlayer)
+
+public:
+    QMediaPlayerPrivate()
+        : provider(0)
+        , control(0)
+        , playlistSourceControl(0)
+        , state(QMediaPlayer::StoppedState)
+        , error(QMediaPlayer::NoError)
+        , filterStates(false)
+        , playlist(0)
+    {}
+
+    QMediaServiceProvider *provider;
+    QMediaPlayerControl* control;
+    QMediaPlaylistSourceControl* playlistSourceControl;
+    QMediaPlayer::State state;
+    QMediaPlayer::Error error;
+    QString errorString;
+    bool filterStates;
+
+    QPointer<QObject> videoOutput;
+    QMediaPlaylist *playlist;
+    QMediaNetworkAccessControl *networkAccessControl;
+    QVideoSurfaceOutput surfaceOutput;
+
+    void _q_stateChanged(QMediaPlayer::State state);
+    void _q_mediaStatusChanged(QMediaPlayer::MediaStatus status);
+    void _q_error(int error, const QString &errorString);
+    void _q_updateMedia(const QMediaContent&);
+    void _q_playlistDestroyed();
+};
+
+void QMediaPlayerPrivate::_q_stateChanged(QMediaPlayer::State ps)
+{
+    Q_Q(QMediaPlayer);
+
+    if (filterStates)
+        return;
+
+    if (playlist
+            && ps != state && ps == QMediaPlayer::StoppedState
+            && (control->mediaStatus() == QMediaPlayer::EndOfMedia ||
+                control->mediaStatus() == QMediaPlayer::InvalidMedia)) {
+        playlist->next();
+        ps = control->state();
+    }
+
+    if (ps != state) {
+        state = ps;
+
+        if (ps == QMediaPlayer::PlayingState)
+            q->addPropertyWatch("position");
+        else
+            q->removePropertyWatch("position");
+
+        emit q->stateChanged(ps);
+    }
+}
+
+void QMediaPlayerPrivate::_q_mediaStatusChanged(QMediaPlayer::MediaStatus status)
+{
+    Q_Q(QMediaPlayer);
+
+    switch (status) {
+    case QMediaPlayer::StalledMedia:
+    case QMediaPlayer::BufferingMedia:
+        q->addPropertyWatch("bufferStatus");
+        emit q->mediaStatusChanged(status);
+        break;
+    default:
+        q->removePropertyWatch("bufferStatus");
+        emit q->mediaStatusChanged(status);
+        break;
+    }
+
+}
+
+void QMediaPlayerPrivate::_q_error(int error, const QString &errorString)
+{
+    Q_Q(QMediaPlayer);
+
+    this->error = QMediaPlayer::Error(error);
+    this->errorString = errorString;
+
+    emit q->error(this->error);
+}
+
+void QMediaPlayerPrivate::_q_updateMedia(const QMediaContent &media)
+{
+    Q_Q(QMediaPlayer);
+
+    if (!control)
+        return;
+
+    const QMediaPlayer::State currentState = state;
+
+    filterStates = true;
+    control->setMedia(media, 0);
+
+    if (!media.isNull()) {
+        switch (currentState) {
+        case QMediaPlayer::PlayingState:
+            control->play();
+            break;
+        case QMediaPlayer::PausedState:
+            control->pause();
+            break;
+        default:
+            break;
+        }
+    }
+    filterStates = false;
+
+    state = control->state();
+
+    if (state != currentState) {
+        if (state == QMediaPlayer::PlayingState)
+            q->addPropertyWatch("position");
+        else
+            q->removePropertyWatch("position");
+
+        emit q->stateChanged(state);
+    }
+}
+
+void QMediaPlayerPrivate::_q_playlistDestroyed()
+{
+    playlist = 0;
+
+    if (!control)
+        return;
+
+    if (playlistSourceControl)
+        playlistSourceControl->setPlaylist(0);
+
+    control->setMedia(QMediaContent(), 0);
+}
+
+static QMediaService *playerService(QMediaPlayer::Flags flags, QMediaServiceProvider *provider)
+{
+    if (flags) {
+        QMediaServiceProviderHint::Features features = 0;
+        if (flags & QMediaPlayer::LowLatency)
+            features |= QMediaServiceProviderHint::LowLatencyPlayback;
+
+        if (flags & QMediaPlayer::StreamPlayback)
+            features |= QMediaServiceProviderHint::StreamPlayback;
+
+        if (flags & QMediaPlayer::VideoSurface)
+            features |= QMediaServiceProviderHint::VideoSurface;
+
+        return provider->requestService(Q_MEDIASERVICE_MEDIAPLAYER,
+                                        QMediaServiceProviderHint(features));
+    } else
+        return provider->requestService(Q_MEDIASERVICE_MEDIAPLAYER);
+}
+
+
+/*!
+    Construct a QMediaPlayer that uses the playback service from \a provider,
+    parented to \a parent and with \a flags.
+
+    If a playback service is not specified the system default will be used.
+    \since 1.0
+*/
+
+QMediaPlayer::QMediaPlayer(QObject *parent, QMediaPlayer::Flags flags, QMediaServiceProvider *provider):
+    QMediaObject(*new QMediaPlayerPrivate,
+                 parent,
+                 playerService(flags,provider))
+{
+    Q_D(QMediaPlayer);
+
+    d->provider = provider;
+
+    if (d->service == 0) {
+        d->error = ServiceMissingError;
+    } else {
+        d->control = qobject_cast<QMediaPlayerControl*>(d->service->requestControl(QMediaPlayerControl_iid));
+        d->playlistSourceControl = qobject_cast<QMediaPlaylistSourceControl*>(d->service->requestControl(QMediaPlaylistSourceControl_iid));
+        d->networkAccessControl = qobject_cast<QMediaNetworkAccessControl*>(d->service->requestControl(QMediaNetworkAccessControl_iid));
+        if (d->control != 0) {
+            connect(d->control, SIGNAL(mediaChanged(QMediaContent)), SIGNAL(mediaChanged(QMediaContent)));
+            connect(d->control, SIGNAL(stateChanged(QMediaPlayer::State)), SLOT(_q_stateChanged(QMediaPlayer::State)));
+            connect(d->control, SIGNAL(mediaStatusChanged(QMediaPlayer::MediaStatus)),
+                    SLOT(_q_mediaStatusChanged(QMediaPlayer::MediaStatus)));
+            connect(d->control, SIGNAL(error(int,QString)), SLOT(_q_error(int,QString)));
+
+            connect(d->control, SIGNAL(durationChanged(qint64)), SIGNAL(durationChanged(qint64)));
+            connect(d->control, SIGNAL(positionChanged(qint64)), SIGNAL(positionChanged(qint64)));
+            connect(d->control, SIGNAL(audioAvailableChanged(bool)), SIGNAL(audioAvailableChanged(bool)));
+            connect(d->control, SIGNAL(videoAvailableChanged(bool)), SIGNAL(videoAvailableChanged(bool)));
+            connect(d->control, SIGNAL(volumeChanged(int)), SIGNAL(volumeChanged(int)));
+            connect(d->control, SIGNAL(mutedChanged(bool)), SIGNAL(mutedChanged(bool)));
+            connect(d->control, SIGNAL(seekableChanged(bool)), SIGNAL(seekableChanged(bool)));
+            connect(d->control, SIGNAL(playbackRateChanged(qreal)), SIGNAL(playbackRateChanged(qreal)));
+            connect(d->control, SIGNAL(bufferStatusChanged(int)), SIGNAL(bufferStatusChanged(int)));
+
+            if (d->control->state() == PlayingState)
+                addPropertyWatch("position");
+
+            if (d->control->mediaStatus() == StalledMedia || d->control->mediaStatus() == BufferingMedia)
+                addPropertyWatch("bufferStatus");
+        }
+        if (d->networkAccessControl != 0) {
+            connect(d->networkAccessControl, SIGNAL(configurationChanged(QNetworkConfiguration)),
+            this, SIGNAL(networkConfigurationChanged(QNetworkConfiguration)));
+        }
+    }
+}
+
+
+/*!
+    Destroys the player object.
+*/
+
+QMediaPlayer::~QMediaPlayer()
+{
+    Q_D(QMediaPlayer);
+
+    if (d->service) {
+        if (d->control)
+            d->service->releaseControl(d->control);
+    }
+
+    d->provider->releaseService(d->service);
+}
+
+QMediaContent QMediaPlayer::media() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->media();
+
+    return QMediaContent();
+}
+
+/*!
+    Returns the stream source of media data.
+
+    This is only valid if a stream was passed to setMedia().
+
+    \since 1.0
+    \sa setMedia()
+*/
+
+const QIODevice *QMediaPlayer::mediaStream() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->mediaStream();
+
+    return 0;
+}
+
+QMediaPlaylist *QMediaPlayer::playlist() const
+{
+    return d_func()->playlistSourceControl ?
+            d_func()->playlistSourceControl->playlist() :
+            d_func()->playlist;
+}
+
+void QMediaPlayer::setPlaylist(QMediaPlaylist *playlist)
+{
+    Q_D(QMediaPlayer);
+
+    if (d->playlistSourceControl) {
+        if (d->playlistSourceControl->playlist())
+            disconnect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
+
+        d->playlistSourceControl->setPlaylist(playlist);
+
+        if (playlist)
+            connect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
+    } else {
+        if (d->playlist) {
+            disconnect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
+                    this, SLOT(_q_updateMedia(QMediaContent)));
+            disconnect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
+        }
+
+        d->playlist = playlist;
+
+        if (d->playlist) {
+            connect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
+                    this, SLOT(_q_updateMedia(QMediaContent)));
+            connect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
+
+            if (d->control != 0)
+                d->control->setMedia(playlist->currentMedia(), 0);
+        } else {
+            setMedia(QMediaContent(), 0);
+        }
+
+    }
+}
+
+/*!
+    Sets the network access points for remote media playback.
+    \a configurations contains, in ascending preferential order, a list of
+    configuration  that can be used for network access.
+
+    This will invalidate the choice of previous configurations.
+    \since 1.2
+*/
+void QMediaPlayer::setNetworkConfigurations(const QList<QNetworkConfiguration> &configurations)
+{
+    Q_D(QMediaPlayer);
+
+    if (d->networkAccessControl)
+        d->networkAccessControl->setConfigurations(configurations);
+}
+
+QMediaPlayer::State QMediaPlayer::state() const
+{
+    return d_func()->state;
+}
+
+QMediaPlayer::MediaStatus QMediaPlayer::mediaStatus() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->mediaStatus();
+
+    return QMediaPlayer::UnknownMediaStatus;
+}
+
+qint64 QMediaPlayer::duration() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->duration();
+
+    return -1;
+}
+
+qint64 QMediaPlayer::position() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->position();
+
+    return 0;
+}
+
+int QMediaPlayer::volume() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->volume();
+
+    return 0;
+}
+
+bool QMediaPlayer::isMuted() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->isMuted();
+
+    return false;
+}
+
+int QMediaPlayer::bufferStatus() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->bufferStatus();
+
+    return 0;
+}
+
+bool QMediaPlayer::isAudioAvailable() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->isAudioAvailable();
+
+    return false;
+}
+
+bool QMediaPlayer::isVideoAvailable() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->isVideoAvailable();
+
+    return false;
+}
+
+bool QMediaPlayer::isSeekable() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->isSeekable();
+
+    return false;
+}
+
+qreal QMediaPlayer::playbackRate() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->control != 0)
+        return d->control->playbackRate();
+
+    return 0.0;
+}
+
+/*!
+    Returns the current error state.
+    \since 1.0
+*/
+
+QMediaPlayer::Error QMediaPlayer::error() const
+{
+    return d_func()->error;
+}
+
+QString QMediaPlayer::errorString() const
+{
+    return d_func()->errorString;
+}
+
+/*!
+    Returns the current network access point  in use.
+    If a default contructed QNetworkConfiguration is returned
+    this feature is not available or that none of the
+    current supplied configurations are in use.
+    \since 1.2
+*/
+QNetworkConfiguration QMediaPlayer::currentNetworkConfiguration() const
+{
+    Q_D(const QMediaPlayer);
+
+    if (d->networkAccessControl)
+        return d_func()->networkAccessControl->currentConfiguration();
+
+    return QNetworkConfiguration();
+}
+
+//public Q_SLOTS:
+/*!
+    Start or resume playing the current source.
+    \since 1.0
+*/
+
+void QMediaPlayer::play()
+{
+    Q_D(QMediaPlayer);
+
+    if (d->control == 0) {
+        QMetaObject::invokeMethod(this, "_q_error", Qt::QueuedConnection,
+                                    Q_ARG(int, QMediaPlayer::ServiceMissingError),
+                                    Q_ARG(QString, tr("The QMediaPlayer object does not have a valid service")));
+        return;
+    }
+
+    //if playlist control is available, the service should advance itself
+    if (d->playlist && d->playlist->currentIndex() == -1 && !d->playlist->isEmpty())
+        d->playlist->setCurrentIndex(0);
+
+    // Reset error conditions
+    d->error = NoError;
+    d->errorString = QString();
+
+    d->control->play();
+}
+
+/*!
+    Pause playing the current source.
+    \since 1.0
+*/
+
+void QMediaPlayer::pause()
+{
+    Q_D(QMediaPlayer);
+
+    if (d->control != 0)
+        d->control->pause();
+}
+
+/*!
+    Stop playing, and reset the play position to the beginning.
+    \since 1.0
+*/
+
+void QMediaPlayer::stop()
+{
+    Q_D(QMediaPlayer);
+
+    if (d->control != 0)
+        d->control->stop();
+}
+
+void QMediaPlayer::setPosition(qint64 position)
+{
+    Q_D(QMediaPlayer);
+
+    if (d->control == 0 || !isSeekable())
+        return;
+
+    d->control->setPosition(qBound(qint64(0), position, duration()));
+}
+
+void QMediaPlayer::setVolume(int v)
+{
+    Q_D(QMediaPlayer);
+
+    if (d->control == 0)
+        return;
+
+    int clamped = qBound(0, v, 100);
+    if (clamped == volume())
+        return;
+
+    d->control->setVolume(clamped);
+}
+
+void QMediaPlayer::setMuted(bool muted)
+{
+    Q_D(QMediaPlayer);
+
+    if (d->control == 0 || muted == isMuted())
+        return;
+
+    d->control->setMuted(muted);
+}
+
+void QMediaPlayer::setPlaybackRate(qreal rate)
+{
+    Q_D(QMediaPlayer);
+
+    if (d->control != 0)
+        d->control->setPlaybackRate(rate);
+}
+
+/*!
+    Sets the current \a media source.
+
+    If a \a stream is supplied; media data will be read from it instead of resolving the media
+    source.  In this case the media source may still be used to resolve additional information
+    about the media such as mime type.
+
+    Setting the media to a null QMediaContent will cause the player to discard all
+    information relating to the current media source and to cease all I/O operations related
+    to that media.
+    \since 1.0
+*/
+
+void QMediaPlayer::setMedia(const QMediaContent &media, QIODevice *stream)
+{
+    Q_D(QMediaPlayer);
+
+    if (playlist() && playlist()->currentMedia() != media)
+        setPlaylist(0);
+
+    if (d->control != 0)
+        d_func()->control->setMedia(media, stream);
+}
+
+/*!
+    \internal
+    \since 1.0
+*/
+
+bool QMediaPlayer::bind(QObject *obj)
+{
+    return QMediaObject::bind(obj);
+}
+
+/*!
+    \internal
+    \since 1.0
+*/
+
+void QMediaPlayer::unbind(QObject *obj)
+{
+    QMediaObject::unbind(obj);
+}
+
+/*!
+    Returns the level of support a media player has for a \a mimeType and a set of \a codecs.
+
+    The \a flags argument allows additional requirements such as performance indicators to be
+    specified.
+    \since 1.0
+*/
+QtMultimedia::SupportEstimate QMediaPlayer::hasSupport(const QString &mimeType,
+                                               const QStringList& codecs,
+                                               Flags flags)
+{
+    return QMediaServiceProvider::defaultServiceProvider()->hasSupport(QByteArray(Q_MEDIASERVICE_MEDIAPLAYER),
+                                                                    mimeType,
+                                                                    codecs,
+                                                                    flags);
+}
+
+/*!
+    \deprecated
+    Returns a list of MIME types supported by the media player.
+
+    The \a flags argument causes the resultant list to be restricted to MIME types which can be supported
+    given additional requirements, such as performance indicators.
+
+    This function may not return useful results on some platforms, and support for a specific file of a
+    given mime type is not guaranteed even if the mime type is in general supported.  In addition, in some
+    cases this function will need to load all available media plugins and query them for their support, which
+    may take some time.
+    \since 1.0
+*/
+QStringList QMediaPlayer::supportedMimeTypes(Flags flags)
+{
+    return QMediaServiceProvider::defaultServiceProvider()->supportedMimeTypes(QByteArray(Q_MEDIASERVICE_MEDIAPLAYER),
+                                                                               flags);
+}
+
+/*!
+    \fn void QMediaPlayer::setVideoOutput(QVideoWidget* output)
+
+    Attach a QVideoWidget video \a output to the media player.
+
+    If the media player has already video output attached,
+    it will be replaced with a new one.
+    \since 1.0
+*/
+void QMediaPlayer::setVideoOutput(QVideoWidget *output)
+{
+    Q_D(QMediaPlayer);
+
+    if (d->videoOutput)
+        unbind(d->videoOutput);
+
+    // We don't know (in this library) that QVideoWidget inherits QObject
+    QObject *outputObject = reinterpret_cast<QObject*>(output);
+
+    d->videoOutput = outputObject && bind(outputObject) ? outputObject : 0;
+}
+
+/*!
+    \fn void QMediaPlayer::setVideoOutput(QGraphicsVideoItem* output)
+
+    Attach a QGraphicsVideoItem video \a output to the media player.
+
+    If the media player has already video output attached,
+    it will be replaced with a new one.
+    \since 1.0
+*/
+void QMediaPlayer::setVideoOutput(QGraphicsVideoItem *output)
+{
+    Q_D(QMediaPlayer);
+
+    if (d->videoOutput)
+        unbind(d->videoOutput);
+
+    // We don't know (in this library) that QGraphicsVideoItem (multiply) inherits QObject
+    // but QObject inheritance depends on QObject coming first, so try this out.
+    QObject *outputObject = reinterpret_cast<QObject*>(output);
+
+    d->videoOutput = outputObject && bind(outputObject) ? outputObject : 0;
+}
+
+/*!
+    Sets a video \a surface as the video output of a media player.
+
+    If a video output has already been set on the media player the new surface
+    will replace it.
+    \since 1.2
+*/
+
+void QMediaPlayer::setVideoOutput(QAbstractVideoSurface *surface)
+{
+    Q_D(QMediaPlayer);
+
+    d->surfaceOutput.setVideoSurface(surface);
+
+    if (d->videoOutput != &d->surfaceOutput) {
+        if (d->videoOutput)
+            unbind(d->videoOutput);
+
+        d->videoOutput = bind(&d->surfaceOutput) ? &d->surfaceOutput : 0;
+    }
+}
+
+// Enums
+/*!
+    \enum QMediaPlayer::State
+
+    Defines the current state of a media player.
+
+    \value PlayingState The media player is currently playing content.
+    \value PausedState The media player has paused playback, playback of the current track will
+    resume from the position the player was paused at.
+    \value StoppedState The media player is not playing content, playback will begin from the start
+    of the current track.
+*/
+
+/*!
+    \enum QMediaPlayer::MediaStatus
+
+    Defines the status of a media player's current media.
+
+    \value UnknownMediaStatus The status of the media cannot be determined.
+    \value NoMedia The is no current media.  The player is in the StoppedState.
+    \value LoadingMedia The current media is being loaded. The player may be in any state.
+    \value LoadedMedia The current media has been loaded. The player is in the StoppedState.
+    \value StalledMedia Playback of the current media has stalled due to insufficient buffering or
+    some other temporary interruption.  The player is in the PlayingState or PausedState.
+    \value BufferingMedia The player is buffering data but has enough data buffered for playback to
+    continue for the immediate future.  The player is in the PlayingState or PausedState.
+    \value BufferedMedia The player has fully buffered the current media.  The player is in the
+    PlayingState or PausedState.
+    \value EndOfMedia Playback has reached the end of the current media.  The player is in the
+    StoppedState.
+    \value InvalidMedia The current media cannot be played.  The player is in the StoppedState.
+*/
+
+/*!
+    \enum QMediaPlayer::Error
+
+    Defines a media player error condition.
+
+    \value NoError No error has occurred.
+    \value ResourceError A media resource couldn't be resolved.
+    \value FormatError The format of a media resource isn't (fully) supported.  Playback may still
+    be possible, but without an audio or video component.
+    \value NetworkError A network error occurred.
+    \value AccessDeniedError There are not the appropriate permissions to play a media resource.
+    \value ServiceMissingError A valid playback service was not found, playback cannot proceed.
+*/
+
+// Signals
+/*!
+    \fn QMediaPlayer::error(QMediaPlayer::Error error)
+
+    Signals that an \a error condition has occurred.
+
+    \since 1.0
+    \sa errorString()
+*/
+
+/*!
+    \fn void QMediaPlayer::stateChanged(State state)
+
+    \since 1.0
+    Signal the \a state of the Player object has changed.
+*/
+
+/*!
+    \fn QMediaPlayer::mediaStatusChanged(QMediaPlayer::MediaStatus status)
+
+    Signals that the \a status of the current media has changed.
+
+    \since 1.0
+    \sa mediaStatus()
+*/
+
+/*!
+    \fn void QMediaPlayer::mediaChanged(const QMediaContent &media);
+
+    Signals that the current playing content will be obtained from \a media.
+
+    \since 1.0
+    \sa media()
+*/
+
+/*!
+    \fn void QMediaPlayer::playbackRateChanged(qreal rate);
+
+    Signals the playbackRate has changed to \a rate.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlayer::seekableChanged(bool seekable);
+
+    Signals the \a seekable status of the player object has changed.
+    \since 1.0
+*/
+
+// Properties
+/*!
+    \property QMediaPlayer::state
+    \brief the media player's playback state.
+
+    By default this property is QMediaPlayer::Stopped
+
+    \since 1.0
+    \sa mediaStatus(), play(), pause(), stop()
+*/
+
+/*!
+    \property QMediaPlayer::error
+    \brief a string describing the last error condition.
+
+    \since 1.0
+    \sa error()
+*/
+
+/*!
+    \property QMediaPlayer::media
+    \brief the active media source being used by the player object.
+
+    The player object will use the QMediaContent for selection of the content to
+    be played.
+
+    By default this property has a null QMediaContent.
+
+    Setting this property to a null QMediaContent will cause the player to discard all
+    information relating to the current media source and to cease all I/O operations related
+    to that media.
+
+    \since 1.0
+    \sa QMediaContent
+*/
+
+/*!
+    \property QMediaPlayer::playlist
+    \brief the media playlist being used by the player object.
+
+    The player object will use the current playlist item for selection of the content to
+    be played.
+
+    By default this property is set to null.
+
+    If the media playlist is used as a source, QMediaPlayer::media is updated with
+    a current playlist item. The current source should be selected with
+    QMediaPlaylist::setCurrentIndex(int) instead of QMediaPlayer::setMedia(),
+    otherwise the current playlist will be discarded.
+
+    \since 1.0
+    \sa QMediaContent
+*/
+
+
+/*!
+    \property QMediaPlayer::mediaStatus
+    \brief the status of the current media stream.
+
+    The stream status describes how the playback of the current stream is
+    progressing.
+
+    By default this property is QMediaPlayer::NoMedia
+
+    \since 1.0
+    \sa state
+*/
+
+/*!
+    \property QMediaPlayer::duration
+    \brief the duration of the current media.
+
+    The value is the total playback time in milliseconds of the current media.
+    The value may change across the life time of the QMediaPlayer object and
+    may not be available when initial playback begins, connect to the
+    durationChanged() signal to receive status notifications.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaPlayer::position
+    \brief the playback position of the current media.
+
+    The value is the current playback position, expressed in milliseconds since
+    the beginning of the media. Periodically changes in the position will be
+    indicated with the signal positionChanged(), the interval between updates
+    can be set with QMediaObject's method setNotifyInterval().
+    \since 1.0
+*/
+
+/*!
+    \property QMediaPlayer::volume
+    \brief the current playback volume.
+
+    The playback volume is a linear in effect and the value can range from 0 -
+    100, values outside this range will be clamped.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaPlayer::muted
+    \brief the muted state of the current media.
+
+    The value will be true if the playback volume is muted; otherwise false.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaPlayer::bufferStatus
+    \brief the percentage of the temporary buffer filled before playback begins.
+
+    When the player object is buffering; this property holds the percentage of
+    the temporary buffer that is filled. The buffer will need to reach 100%
+    filled before playback can resume, at which time the MediaStatus will be
+    BufferedMedia.
+
+    \since 1.0
+    \sa mediaStatus()
+*/
+
+/*!
+    \property QMediaPlayer::audioAvailable
+    \brief the audio availabilty status for the current media.
+
+    As the life time of QMediaPlayer can be longer than the playback of one
+    QMediaContent, this property may change over time, the
+    audioAvailableChanged signal can be used to monitor it's status.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaPlayer::videoAvailable
+    \brief the video availability status for the current media.
+
+    If available, the QVideoWidget class can be used to view the video. As the
+    life time of QMediaPlayer can be longer than the playback of one
+    QMediaContent, this property may change over time, the
+    videoAvailableChanged signal can be used to monitor it's status.
+
+    \since 1.0
+    \sa QVideoWidget, QMediaContent
+*/
+
+/*!
+    \property QMediaPlayer::seekable
+    \brief the seek-able status of the current media
+
+    If seeking is supported this property will be true; false otherwise. The
+    status of this property may change across the life time of the QMediaPlayer
+    object, use the seekableChanged signal to monitor changes.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaPlayer::playbackRate
+    \brief the playback rate of the current media.
+
+    This value is a multiplier applied to the media's standard play rate. By
+    default this value is 1.0, indicating that the media is playing at the
+    standard pace. Values higher than 1.0 will increase the rate of play.
+    Values less than zero can be set and indicate the media will rewind at the
+    multiplier of the standard pace.
+
+    Not all playback services support change of the playback rate. It is
+    framework defined as to the status and quality of audio and video
+    while fast forwarding or rewinding.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlayer::durationChanged(qint64 duration)
+
+    Signal the duration of the content has changed to \a duration, expressed in milliseconds.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlayer::positionChanged(qint64 position)
+
+    Signal the position of the content has changed to \a position, expressed in
+    milliseconds.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlayer::volumeChanged(int volume)
+
+    Signal the playback volume has changed to \a volume.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlayer::mutedChanged(bool muted)
+
+    Signal the mute state has changed to \a muted.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlayer::videoAvailableChanged(bool videoAvailable)
+
+    Signal the availability of visual content has changed to \a videoAvailable.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlayer::audioAvailableChanged(bool available)
+
+    Signals the availability of audio content has changed to \a available.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlayer::bufferStatusChanged(int percentFilled)
+
+    Signal the amount of the local buffer filled as a percentage by \a percentFilled.
+    \since 1.0
+*/
+
+/*!
+   \fn void QMediaPlayer::networkConfigurationChanged(const QNetworkConfiguration &configuration)
+
+    Signal that the active in use network access point  has been changed to \a configuration and all subsequent network access will use this \a configuration.
+    \since 1.2
+*/
+
+/*!
+    \enum QMediaPlayer::Flag
+
+    \value LowLatency       The player is expected to be used with simple audio formats,
+            but playback should start without significant delay.
+            Such playback service can be used for beeps, ringtones, etc.
+
+    \value StreamPlayback   The player is expected to play QIODevice based streams.
+            If passed to QMediaPlayer constructor, the service supporting
+            streams playback will be chosen.
+
+    \value VideoSurface     The player is expected to be able to render to a
+            QAbstractVideoSurface \l {setVideoOutput()}{output}.
+*/
+
+#include "moc_qmediaplayer.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qmediaplayer.h b/src/multimedia/playback/qmediaplayer.h
new file mode 100644
index 0000000..f53b50c
--- /dev/null
+++ b/src/multimedia/playback/qmediaplayer.h
@@ -0,0 +1,227 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAPLAYER_H
+#define QMEDIAPLAYER_H
+
+
+#include "qmediaserviceprovider.h"
+#include "qmediaobject.h"
+#include "qmediacontent.h"
+#include "qmediaenumdebug.h"
+
+#include <QtNetwork/qnetworkconfiguration.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QAbstractVideoSurface;
+class QMediaPlaylist;
+class QVideoWidget;
+class QGraphicsVideoItem;
+
+class QMediaPlayerPrivate;
+class Q_MULTIMEDIA_EXPORT QMediaPlayer : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QMediaContent media READ media WRITE setMedia NOTIFY mediaChanged)
+    Q_PROPERTY(QMediaPlaylist * playlist READ playlist WRITE setPlaylist)
+    Q_PROPERTY(qint64 duration READ duration NOTIFY durationChanged)
+    Q_PROPERTY(qint64 position READ position WRITE setPosition NOTIFY positionChanged)
+    Q_PROPERTY(int volume READ volume WRITE setVolume NOTIFY volumeChanged)
+    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
+    Q_PROPERTY(int bufferStatus READ bufferStatus NOTIFY bufferStatusChanged)
+    Q_PROPERTY(bool audioAvailable READ isAudioAvailable NOTIFY audioAvailableChanged)
+    Q_PROPERTY(bool videoAvailable READ isVideoAvailable NOTIFY videoAvailableChanged)
+    Q_PROPERTY(bool seekable READ isSeekable NOTIFY seekableChanged)
+    Q_PROPERTY(qreal playbackRate READ playbackRate WRITE setPlaybackRate NOTIFY playbackRateChanged)
+    Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(MediaStatus mediaStatus READ mediaStatus NOTIFY mediaStatusChanged)
+    Q_PROPERTY(QString error READ errorString)
+    Q_ENUMS(State)
+    Q_ENUMS(MediaStatus)
+    Q_ENUMS(Error)
+
+public:
+    enum State
+    {
+        StoppedState,
+        PlayingState,
+        PausedState
+    };
+
+    enum MediaStatus
+    {
+        UnknownMediaStatus,
+        NoMedia,
+        LoadingMedia,
+        LoadedMedia,
+        StalledMedia,
+        BufferingMedia,
+        BufferedMedia,
+        EndOfMedia,
+        InvalidMedia
+    };
+
+    enum Flag
+    {
+        LowLatency = 0x01,
+        StreamPlayback = 0x02,
+        VideoSurface = 0x04
+    };
+    Q_DECLARE_FLAGS(Flags, Flag)
+
+    enum Error
+    {
+        NoError,
+        ResourceError,
+        FormatError,
+        NetworkError,
+        AccessDeniedError,
+        ServiceMissingError
+    };
+
+    QMediaPlayer(QObject *parent = 0, Flags flags = 0, QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider());
+    ~QMediaPlayer();
+
+    static QtMultimedia::SupportEstimate hasSupport(const QString &mimeType,
+                                            const QStringList& codecs = QStringList(),
+                                            Flags flags = 0);
+    static QStringList supportedMimeTypes(Flags flags = 0);
+
+    void setVideoOutput(QVideoWidget *);
+    void setVideoOutput(QGraphicsVideoItem *);
+    void setVideoOutput(QAbstractVideoSurface *surface);
+
+    QMediaContent media() const;
+    const QIODevice *mediaStream() const;
+    QMediaPlaylist *playlist() const;
+
+    State state() const;
+    MediaStatus mediaStatus() const;
+
+    qint64 duration() const;
+    qint64 position() const;
+
+    int volume() const;
+    bool isMuted() const;
+    bool isAudioAvailable() const;
+    bool isVideoAvailable() const;
+
+    int bufferStatus() const;
+
+    bool isSeekable() const;
+    qreal playbackRate() const;   
+
+    Error error() const;
+    QString errorString() const;
+
+    QNetworkConfiguration currentNetworkConfiguration() const;
+
+public Q_SLOTS:
+    void play();
+    void pause();
+    void stop();
+
+    void setPosition(qint64 position);
+    void setVolume(int volume);
+    void setMuted(bool muted);
+
+    void setPlaybackRate(qreal rate);
+
+    void setMedia(const QMediaContent &media, QIODevice *stream = 0);
+    void setPlaylist(QMediaPlaylist *playlist);
+
+    void setNetworkConfigurations(const QList<QNetworkConfiguration> &configurations);
+
+Q_SIGNALS:
+    void mediaChanged(const QMediaContent &media);
+
+    void stateChanged(QMediaPlayer::State newState);
+    void mediaStatusChanged(QMediaPlayer::MediaStatus status);
+
+    void durationChanged(qint64 duration);
+    void positionChanged(qint64 position);
+
+    void volumeChanged(int volume);
+    void mutedChanged(bool muted);
+    void audioAvailableChanged(bool available);
+    void videoAvailableChanged(bool videoAvailable);
+
+    void bufferStatusChanged(int percentFilled);
+
+    void seekableChanged(bool seekable);
+    void playbackRateChanged(qreal rate);
+
+    void error(QMediaPlayer::Error error);
+
+    void networkConfigurationChanged(const QNetworkConfiguration &configuration);
+public:
+    virtual bool bind(QObject *);
+    virtual void unbind(QObject *);
+
+private:
+    Q_DISABLE_COPY(QMediaPlayer)
+    Q_DECLARE_PRIVATE(QMediaPlayer)
+    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QMediaPlayer::State))
+    Q_PRIVATE_SLOT(d_func(), void _q_mediaStatusChanged(QMediaPlayer::MediaStatus))
+    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
+    Q_PRIVATE_SLOT(d_func(), void _q_updateMedia(const QMediaContent&))
+    Q_PRIVATE_SLOT(d_func(), void _q_playlistDestroyed())
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMediaPlayer::State)
+Q_DECLARE_METATYPE(QMediaPlayer::MediaStatus)
+Q_DECLARE_METATYPE(QMediaPlayer::Error)
+
+Q_MEDIA_ENUM_DEBUG(QMediaPlayer, State)
+Q_MEDIA_ENUM_DEBUG(QMediaPlayer, MediaStatus)
+Q_MEDIA_ENUM_DEBUG(QMediaPlayer, Error)
+
+QT_END_HEADER
+
+#endif  // QMEDIAPLAYER_H
diff --git a/src/multimedia/playback/qmediaplaylist.cpp b/src/multimedia/playback/qmediaplaylist.cpp
new file mode 100644
index 0000000..1b6959c
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylist.cpp
@@ -0,0 +1,769 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaplaylist.h"
+#include "qmediaplaylist_p.h"
+#include "qmediaplaylistprovider.h"
+#include "qlocalmediaplaylistprovider.h"
+#include "qmediaplaylistioplugin.h"
+#include "qmediaservice.h"
+#include "qmediaplaylistcontrol.h"
+#include "qmediaplayercontrol.h"
+
+#include <QtCore/qlist.h>
+#include <QtCore/qfile.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qcoreevent.h>
+#include <QtCore/qcoreapplication.h>
+
+#include "qmediapluginloader_p.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_GLOBAL_STATIC_WITH_ARGS(QMediaPluginLoader, playlistIOLoader,
+        (QMediaPlaylistIOInterface_iid, QLatin1String("playlistformats"), Qt::CaseInsensitive))
+
+namespace
+{
+    class QMediaPlaylistPrivateRegisterMetaTypes
+    {
+    public:
+        QMediaPlaylistPrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QMediaPlaylist::Error>();
+            qRegisterMetaType<QMediaPlaylist::PlaybackMode>();
+        }
+    } _registerMetaTypes;
+}
+
+
+/*!
+    \class QMediaPlaylist
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+
+    \brief The QMediaPlaylist class provides a list of media content to play.
+
+    QMediaPlaylist is intended to be used with other media objects,
+    like QMediaPlayer or QMediaImageViewer.
+
+    QMediaPlaylist allows to access the service intrinsic playlist functionality
+    if available, otherwise it provides the the local memory playlist implementation.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Movie playlist
+
+    Depending on playlist source implementation, most of the playlist mutating
+    operations can be asynchronous.
+
+    \sa QMediaContent
+*/
+
+
+/*!
+    \enum QMediaPlaylist::PlaybackMode
+
+    The QMediaPlaylist::PlaybackMode describes the order items in playlist are played.
+
+    \value CurrentItemOnce    The current item is played only once.
+
+    \value CurrentItemInLoop  The current item is played repeatedly in a loop.
+
+    \value Sequential         Playback starts from the current and moves through each successive item until the last is reached and then stops.
+                              The next item is a null item when the last one is currently playing.
+
+    \value Loop               Playback restarts at the first item after the last has finished playing.
+
+    \value Random             Play items in random order.
+*/
+
+
+
+/*!
+  Create a new playlist object for with the given \a parent.
+*/
+
+QMediaPlaylist::QMediaPlaylist(QObject *parent)
+    : QObject(parent)
+    , d_ptr(new QMediaPlaylistPrivate)
+{
+    Q_D(QMediaPlaylist);
+
+    d->q_ptr = this;
+    d->localPlaylistControl = new QLocalMediaPlaylistControl(this);
+
+    setMediaObject(0);
+}
+
+/*!
+  Destroys the playlist.
+  */
+
+QMediaPlaylist::~QMediaPlaylist()
+{
+    Q_D(QMediaPlaylist);
+
+    if (d->mediaObject)
+        d->mediaObject->unbind(this);
+
+    delete d_ptr;
+}
+
+/*!
+  Returns the QMediaObject instance that this QMediaPlaylist is bound too,
+  or 0 otherwise.
+  \since 1.0
+*/
+QMediaObject *QMediaPlaylist::mediaObject() const
+{
+    return d_func()->mediaObject;
+}
+
+/*!
+  \internal
+  If \a mediaObject is null or doesn't have an intrinsic playlist,
+  internal local memory playlist source will be created.
+  \since 1.0
+*/
+bool QMediaPlaylist::setMediaObject(QMediaObject *mediaObject)
+{
+    Q_D(QMediaPlaylist);
+
+    if (mediaObject && mediaObject == d->mediaObject)
+        return true;
+
+    QMediaService *service = mediaObject
+            ? mediaObject->service() : 0;
+
+    QMediaPlaylistControl *newControl = 0;
+
+    if (service)
+        newControl = qobject_cast<QMediaPlaylistControl*>(service->requestControl(QMediaPlaylistControl_iid));
+
+    if (!newControl)
+        newControl = d->localPlaylistControl;
+
+    if (d->control != newControl) {
+        int oldSize = 0;
+        if (d->control) {
+            QMediaPlaylistProvider *playlist = d->control->playlistProvider();
+            oldSize = playlist->mediaCount();
+            disconnect(playlist, SIGNAL(loadFailed(QMediaPlaylist::Error,QString)),
+                    this, SLOT(_q_loadFailed(QMediaPlaylist::Error,QString)));
+
+            disconnect(playlist, SIGNAL(mediaChanged(int,int)), this, SIGNAL(mediaChanged(int,int)));
+            disconnect(playlist, SIGNAL(mediaAboutToBeInserted(int,int)), this, SIGNAL(mediaAboutToBeInserted(int,int)));
+            disconnect(playlist, SIGNAL(mediaInserted(int,int)), this, SIGNAL(mediaInserted(int,int)));
+            disconnect(playlist, SIGNAL(mediaAboutToBeRemoved(int,int)), this, SIGNAL(mediaAboutToBeRemoved(int,int)));
+            disconnect(playlist, SIGNAL(mediaRemoved(int,int)), this, SIGNAL(mediaRemoved(int,int)));
+
+            disconnect(playlist, SIGNAL(loaded()), this, SIGNAL(loaded()));
+
+            disconnect(d->control, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)),
+                    this, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)));
+            disconnect(d->control, SIGNAL(currentIndexChanged(int)),
+                    this, SIGNAL(currentIndexChanged(int)));
+            disconnect(d->control, SIGNAL(currentMediaChanged(QMediaContent)),
+                    this, SIGNAL(currentMediaChanged(QMediaContent)));
+
+            if (d->mediaObject)
+                d->mediaObject->service()->releaseControl(d->control);
+        }
+
+        d->control = newControl;
+        QMediaPlaylistProvider *playlist = d->control->playlistProvider();
+        connect(playlist, SIGNAL(loadFailed(QMediaPlaylist::Error,QString)),
+                this, SLOT(_q_loadFailed(QMediaPlaylist::Error,QString)));
+
+        connect(playlist, SIGNAL(mediaChanged(int,int)), this, SIGNAL(mediaChanged(int,int)));
+        connect(playlist, SIGNAL(mediaAboutToBeInserted(int,int)), this, SIGNAL(mediaAboutToBeInserted(int,int)));
+        connect(playlist, SIGNAL(mediaInserted(int,int)), this, SIGNAL(mediaInserted(int,int)));
+        connect(playlist, SIGNAL(mediaAboutToBeRemoved(int,int)), this, SIGNAL(mediaAboutToBeRemoved(int,int)));
+        connect(playlist, SIGNAL(mediaRemoved(int,int)), this, SIGNAL(mediaRemoved(int,int)));
+
+        connect(playlist, SIGNAL(loaded()), this, SIGNAL(loaded()));
+
+        connect(d->control, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)),
+                this, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)));
+        connect(d->control, SIGNAL(currentIndexChanged(int)),
+                this, SIGNAL(currentIndexChanged(int)));
+        connect(d->control, SIGNAL(currentMediaChanged(QMediaContent)),
+                this, SIGNAL(currentMediaChanged(QMediaContent)));
+
+        if (oldSize)
+            emit mediaRemoved(0, oldSize-1);
+
+        if (playlist->mediaCount()) {
+            emit mediaAboutToBeInserted(0,playlist->mediaCount()-1);
+            emit mediaInserted(0,playlist->mediaCount()-1);
+        }
+    }
+
+    d->mediaObject = mediaObject;
+
+    return true;
+}
+
+/*!
+  \property QMediaPlaylist::playbackMode
+
+  This property defines the order, items in playlist are played.
+
+  \since 1.0
+  \sa QMediaPlaylist::PlaybackMode
+*/
+
+QMediaPlaylist::PlaybackMode QMediaPlaylist::playbackMode() const
+{
+    return d_func()->control->playbackMode();
+}
+
+void QMediaPlaylist::setPlaybackMode(QMediaPlaylist::PlaybackMode mode)
+{
+    Q_D(QMediaPlaylist);
+    d->control->setPlaybackMode(mode);
+}
+
+/*!
+  Returns position of the current media content in the playlist.
+  \since 1.0
+*/
+int QMediaPlaylist::currentIndex() const
+{
+    return d_func()->control->currentIndex();
+}
+
+/*!
+  Returns the current media content.
+  \since 1.0
+*/
+
+QMediaContent QMediaPlaylist::currentMedia() const
+{
+    return d_func()->playlist()->media(currentIndex());
+}
+
+/*!
+  Returns the index of the item, which would be current after calling next()
+  \a steps times.
+
+  Returned value depends on the size of playlist, current position
+  and playback mode.
+
+  \since 1.0
+  \sa QMediaPlaylist::playbackMode
+*/
+int QMediaPlaylist::nextIndex(int steps) const
+{
+    return d_func()->control->nextIndex(steps);
+}
+
+/*!
+  Returns the index of the item, which would be current after calling previous()
+  \a steps times.
+
+  \since 1.0
+  \sa QMediaPlaylist::playbackMode
+*/
+
+int QMediaPlaylist::previousIndex(int steps) const
+{
+    return d_func()->control->previousIndex(steps);
+}
+
+
+/*!
+  Returns the number of items in the playlist.
+
+  \since 1.0
+  \sa isEmpty()
+  */
+int QMediaPlaylist::mediaCount() const
+{
+    return d_func()->playlist()->mediaCount();
+}
+
+/*!
+  Returns true if the playlist contains no items; otherwise returns false.
+
+  \since 1.0
+  \sa mediaCount()
+  */
+bool QMediaPlaylist::isEmpty() const
+{
+    return mediaCount() == 0;
+}
+
+/*!
+  Returns true if the playlist can be modified; otherwise returns false.
+
+  \since 1.0
+  \sa mediaCount()
+  */
+bool QMediaPlaylist::isReadOnly() const
+{
+    return d_func()->playlist()->isReadOnly();
+}
+
+/*!
+  Returns the media content at \a index in the playlist.
+  \since 1.0
+*/
+
+QMediaContent QMediaPlaylist::media(int index) const
+{
+    return d_func()->playlist()->media(index);
+}
+
+/*!
+  Append the media \a content to the playlist.
+
+  Returns true if the operation is successful, otherwise return false.
+  \since 1.0
+  */
+bool QMediaPlaylist::addMedia(const QMediaContent &content)
+{
+    return d_func()->control->playlistProvider()->addMedia(content);
+}
+
+/*!
+  Append multiple media content \a items to the playlist.
+
+  Returns true if the operation is successful, otherwise return false.
+  \since 1.0
+  */
+bool QMediaPlaylist::addMedia(const QList<QMediaContent> &items)
+{
+    return d_func()->control->playlistProvider()->addMedia(items);
+}
+
+/*!
+  Insert the media \a content to the playlist at position \a pos.
+
+  Returns true if the operation is successful, otherwise false.
+  \since 1.0
+*/
+
+bool QMediaPlaylist::insertMedia(int pos, const QMediaContent &content)
+{
+    return d_func()->playlist()->insertMedia(pos, content);
+}
+
+/*!
+  Insert multiple media content \a items to the playlist at position \a pos.
+
+  Returns true if the operation is successful, otherwise false.
+  \since 1.0
+*/
+
+bool QMediaPlaylist::insertMedia(int pos, const QList<QMediaContent> &items)
+{
+    return d_func()->playlist()->insertMedia(pos, items);
+}
+
+/*!
+  Remove the item from the playlist at position \a pos.
+
+  Returns true if the operation is successful, otherwise return false.
+  \since 1.0
+  */
+bool QMediaPlaylist::removeMedia(int pos)
+{
+    Q_D(QMediaPlaylist);
+    return d->playlist()->removeMedia(pos);
+}
+
+/*!
+  Remove items in the playlist from \a start to \a end inclusive.
+
+  Returns true if the operation is successful, otherwise return false.
+  \since 1.0
+  */
+bool QMediaPlaylist::removeMedia(int start, int end)
+{
+    Q_D(QMediaPlaylist);
+    return d->playlist()->removeMedia(start, end);
+}
+
+/*!
+  Remove all the items from the playlist.
+
+  Returns true if the operation is successful, otherwise return false.
+  \since 1.0
+  */
+bool QMediaPlaylist::clear()
+{
+    Q_D(QMediaPlaylist);
+    return d->playlist()->clear();
+}
+
+bool QMediaPlaylistPrivate::readItems(QMediaPlaylistReader *reader)
+{
+    while (!reader->atEnd())
+        playlist()->addMedia(reader->readItem());
+
+    return true;
+}
+
+bool QMediaPlaylistPrivate::writeItems(QMediaPlaylistWriter *writer)
+{
+    for (int i=0; i<playlist()->mediaCount(); i++) {
+        if (!writer->writeItem(playlist()->media(i)))
+            return false;
+    }
+    writer->close();
+    return true;
+}
+
+/*!
+  Load playlist from \a location. If \a format is specified, it is used,
+  otherwise format is guessed from location name and data.
+
+  New items are appended to playlist.
+
+  QMediaPlaylist::loaded() signal is emitted if playlist was loaded successfully,
+  otherwise the playlist emits loadFailed().
+  \since 1.0
+*/
+void QMediaPlaylist::load(const QUrl &location, const char *format)
+{
+    Q_D(QMediaPlaylist);
+
+    d->error = NoError;
+    d->errorString.clear();
+
+    if (d->playlist()->load(location,format))
+        return;
+
+    if (isReadOnly()) {
+        d->error = AccessDeniedError;
+        d->errorString = tr("Could not add items to read only playlist.");
+        emit loadFailed();
+        return;
+    }
+
+    foreach (QString const& key, playlistIOLoader()->keys()) {
+        QMediaPlaylistIOInterface* plugin = qobject_cast<QMediaPlaylistIOInterface*>(playlistIOLoader()->instance(key));
+        if (plugin && plugin->canRead(location,format)) {
+            QMediaPlaylistReader *reader = plugin->createReader(location,QByteArray(format));
+            if (reader && d->readItems(reader)) {
+                delete reader;
+                emit loaded();
+                return;
+            }
+            delete reader;
+        }
+    }
+
+    d->error = FormatNotSupportedError;
+    d->errorString = tr("Playlist format is not supported");
+    emit loadFailed();
+
+    return;
+}
+
+/*!
+  Load playlist from QIODevice \a device. If \a format is specified, it is used,
+  otherwise format is guessed from device data.
+
+  New items are appended to playlist.
+
+  QMediaPlaylist::loaded() signal is emitted if playlist was loaded successfully,
+  otherwise the playlist emits loadFailed().
+  \since 1.0
+*/
+void QMediaPlaylist::load(QIODevice * device, const char *format)
+{
+    Q_D(QMediaPlaylist);
+
+    d->error = NoError;
+    d->errorString.clear();
+
+    if (d->playlist()->load(device,format))
+        return;
+
+    if (isReadOnly()) {
+        d->error = AccessDeniedError;
+        d->errorString = tr("Could not add items to read only playlist.");
+        emit loadFailed();
+        return;
+    }
+
+    foreach (QString const& key, playlistIOLoader()->keys()) {
+        QMediaPlaylistIOInterface* plugin = qobject_cast<QMediaPlaylistIOInterface*>(playlistIOLoader()->instance(key));
+        if (plugin && plugin->canRead(device,format)) {
+            QMediaPlaylistReader *reader = plugin->createReader(device,QByteArray(format));
+            if (reader && d->readItems(reader)) {
+                delete reader;
+                emit loaded();
+                return;
+            }
+            delete reader;
+        }
+    }
+
+    d->error = FormatNotSupportedError;
+    d->errorString = tr("Playlist format is not supported");
+    emit loadFailed();
+
+    return;
+}
+
+/*!
+  Save playlist to \a location. If \a format is specified, it is used,
+  otherwise format is guessed from location name.
+
+  Returns true if playlist was saved successfully, otherwise returns false.
+  \since 1.0
+  */
+bool QMediaPlaylist::save(const QUrl &location, const char *format)
+{
+    Q_D(QMediaPlaylist);
+
+    d->error = NoError;
+    d->errorString.clear();
+
+    if (d->playlist()->save(location,format))
+        return true;
+
+    QFile file(location.toLocalFile());
+
+    if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
+        d->error = AccessDeniedError;
+        d->errorString = tr("The file could not be accessed.");
+        return false;
+    }
+
+    return save(&file, format);
+}
+
+/*!
+  Save playlist to QIODevice \a device using format \a format.
+
+  Returns true if playlist was saved successfully, otherwise returns false.
+  \since 1.0
+*/
+bool QMediaPlaylist::save(QIODevice * device, const char *format)
+{
+    Q_D(QMediaPlaylist);
+
+    d->error = NoError;
+    d->errorString.clear();
+
+    if (d->playlist()->save(device,format))
+        return true;
+
+    foreach (QString const& key, playlistIOLoader()->keys()) {
+        QMediaPlaylistIOInterface* plugin = qobject_cast<QMediaPlaylistIOInterface*>(playlistIOLoader()->instance(key));
+        if (plugin && plugin->canWrite(device,format)) {
+            QMediaPlaylistWriter *writer = plugin->createWriter(device,QByteArray(format));
+            if (writer && d->writeItems(writer)) {
+                delete writer;
+                return true;
+            }
+            delete writer;
+        }
+    }
+
+    d->error = FormatNotSupportedError;
+    d->errorString = tr("Playlist format is not supported.");
+
+    return false;
+}
+
+/*!
+    Returns the last error condition.
+    \since 1.0
+*/
+QMediaPlaylist::Error QMediaPlaylist::error() const
+{
+    return d_func()->error;
+}
+
+/*!
+    Returns the string describing the last error condition.
+    \since 1.0
+*/
+QString QMediaPlaylist::errorString() const
+{
+    return d_func()->errorString;
+}
+
+/*!
+  Shuffle items in the playlist.
+  \since 1.0
+*/
+void QMediaPlaylist::shuffle()
+{
+    d_func()->playlist()->shuffle();
+}
+
+
+/*!
+    Advance to the next media content in playlist.
+    \since 1.0
+*/
+void QMediaPlaylist::next()
+{
+    d_func()->control->next();
+}
+
+/*!
+    Return to the previous media content in playlist.
+    \since 1.0
+*/
+void QMediaPlaylist::previous()
+{
+    d_func()->control->previous();
+}
+
+/*!
+    Activate media content from playlist at position \a playlistPosition.
+    \since 1.0
+*/
+
+void QMediaPlaylist::setCurrentIndex(int playlistPosition)
+{
+    d_func()->control->setCurrentIndex(playlistPosition);
+}
+
+/*!
+    \fn void QMediaPlaylist::mediaInserted(int start, int end)
+
+    This signal is emitted after media has been inserted into the playlist.
+    The new items are those between \a start and \a end inclusive.
+    \since 1.0
+ */
+
+/*!
+    \fn void QMediaPlaylist::mediaRemoved(int start, int end)
+
+    This signal is emitted after media has been removed from the playlist.
+    The removed items are those between \a start and \a end inclusive.
+    \since 1.0
+ */
+
+/*!
+    \fn void QMediaPlaylist::mediaChanged(int start, int end)
+
+    This signal is emitted after media has been changed in the playlist
+    between \a start and \a end positions inclusive.
+    \since 1.0
+ */
+
+/*!
+    \fn void QMediaPlaylist::currentIndexChanged(int position)
+
+    Signal emitted when playlist position changed to \a position.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylist::playbackModeChanged(QMediaPlaylist::PlaybackMode mode)
+
+    Signal emitted when playback mode changed to \a mode.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylist::mediaAboutToBeInserted(int start, int end)
+
+    Signal emitted when items are to be inserted at \a start and ending at \a end.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylist::mediaAboutToBeRemoved(int start, int end)
+
+    Signal emitted when item are to be deleted at \a start and ending at \a end.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylist::currentMediaChanged(const QMediaContent &content)
+
+    Signal emitted when current media changes to \a content.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaPlaylist::currentIndex
+    \brief Current position.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaPlaylist::currentMedia
+    \brief Current media content.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylist::loaded()
+
+    Signal emitted when playlist finished loading.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylist::loadFailed()
+
+    Signal emitted if failed to load playlist.
+    \since 1.0
+*/
+
+/*!
+    \enum QMediaPlaylist::Error
+
+    This enum describes the QMediaPlaylist error codes.
+
+    \value NoError                 No errors.
+    \value FormatError             Format error.
+    \value FormatNotSupportedError Format not supported.
+    \value NetworkError            Network error.
+    \value AccessDeniedError       Access denied error.
+*/
+
+#include "moc_qmediaplaylist.cpp"
+#include "moc_qmediaplaylist_p.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qmediaplaylist.h b/src/multimedia/playback/qmediaplaylist.h
new file mode 100644
index 0000000..7b4b622
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylist.h
@@ -0,0 +1,154 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAPLAYLIST_H
+#define QMEDIAPLAYLIST_H
+
+#include <QtCore/qobject.h>
+
+#include <qmediacontent.h>
+#include <qmediaobject.h>
+#include <qmediabindableinterface.h>
+#include <qmediaenumdebug.h>
+
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QMediaPlaylistProvider;
+
+class QMediaPlaylistPrivate;
+class Q_MULTIMEDIA_EXPORT QMediaPlaylist : public QObject, public QMediaBindableInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaBindableInterface)
+    Q_PROPERTY(QMediaPlaylist::PlaybackMode playbackMode READ playbackMode WRITE setPlaybackMode NOTIFY playbackModeChanged)
+    Q_PROPERTY(QMediaContent currentMedia READ currentMedia NOTIFY currentMediaChanged)
+    Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentIndexChanged)
+    Q_ENUMS(PlaybackMode Error)
+
+public:
+    enum PlaybackMode { CurrentItemOnce, CurrentItemInLoop, Sequential, Loop, Random };
+    enum Error { NoError, FormatError, FormatNotSupportedError, NetworkError, AccessDeniedError };
+
+    QMediaPlaylist(QObject *parent = 0);
+    virtual ~QMediaPlaylist();
+
+    QMediaObject *mediaObject() const;
+
+    PlaybackMode playbackMode() const;
+    void setPlaybackMode(PlaybackMode mode);
+
+    int currentIndex() const;
+    QMediaContent currentMedia() const;
+
+    int nextIndex(int steps = 1) const;
+    int previousIndex(int steps = 1) const;
+
+    QMediaContent media(int index) const;
+
+    int mediaCount() const;
+    bool isEmpty() const;
+    bool isReadOnly() const;
+
+    bool addMedia(const QMediaContent &content);
+    bool addMedia(const QList<QMediaContent> &items);
+    bool insertMedia(int index, const QMediaContent &content);
+    bool insertMedia(int index, const QList<QMediaContent> &items);
+    bool removeMedia(int pos);
+    bool removeMedia(int start, int end);
+    bool clear();
+
+    void load(const QUrl &location, const char *format = 0);
+    void load(QIODevice * device, const char *format = 0);
+
+    bool save(const QUrl &location, const char *format = 0);
+    bool save(QIODevice * device, const char *format);
+
+    Error error() const;
+    QString errorString() const;
+
+public Q_SLOTS:
+    void shuffle();
+
+    void next();
+    void previous();
+
+    void setCurrentIndex(int index);
+
+Q_SIGNALS:
+    void currentIndexChanged(int index);
+    void playbackModeChanged(QMediaPlaylist::PlaybackMode mode);
+    void currentMediaChanged(const QMediaContent&);
+
+    void mediaAboutToBeInserted(int start, int end);
+    void mediaInserted(int start, int end);
+    void mediaAboutToBeRemoved(int start, int end);
+    void mediaRemoved(int start, int end);
+    void mediaChanged(int start, int end);
+
+    void loaded();
+    void loadFailed();
+
+protected:
+    bool setMediaObject(QMediaObject *object);
+    QMediaPlaylistPrivate *d_ptr;
+
+private:
+    Q_DECLARE_PRIVATE(QMediaPlaylist)
+    Q_PRIVATE_SLOT(d_func(), void _q_loadFailed(QMediaPlaylist::Error, const QString &))
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMediaPlaylist::PlaybackMode)
+Q_DECLARE_METATYPE(QMediaPlaylist::Error)
+
+Q_MEDIA_ENUM_DEBUG(QMediaPlaylist, PlaybackMode)
+Q_MEDIA_ENUM_DEBUG(QMediaPlaylist, Error)
+
+QT_END_HEADER
+
+#endif  // QMEDIAPLAYLIST_H
diff --git a/src/multimedia/playback/qmediaplaylist_p.h b/src/multimedia/playback/qmediaplaylist_p.h
new file mode 100644
index 0000000..c04483c
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylist_p.h
@@ -0,0 +1,177 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAPLAYLIST_P_H
+#define QMEDIAPLAYLIST_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qmediaplaylist.h"
+#include "qmediaplaylistcontrol.h"
+#include "qmediaplayer.h"
+#include "qmediaplayercontrol.h"
+#include "qlocalmediaplaylistprovider.h"
+#include "qmediaobject_p.h"
+
+#include <QtCore/qdebug.h>
+
+#ifdef Q_MOC_RUN
+# pragma Q_MOC_EXPAND_MACROS
+#endif
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QMediaPlaylistControl;
+class QMediaPlaylistProvider;
+class QMediaPlaylistReader;
+class QMediaPlaylistWriter;
+class QMediaPlayerControl;
+
+class QMediaPlaylistPrivate
+{
+    Q_DECLARE_PUBLIC(QMediaPlaylist)
+public:
+    QMediaPlaylistPrivate()
+        :mediaObject(0),
+        control(0),
+        localPlaylistControl(0),
+        error(QMediaPlaylist::NoError)
+    {
+    }
+
+    virtual ~QMediaPlaylistPrivate() {}
+
+    void _q_loadFailed(QMediaPlaylist::Error error, const QString &errorString)
+    {
+        this->error = error;
+        this->errorString = errorString;
+
+        emit q_ptr->loadFailed();
+    }
+
+    void _q_mediaObjectDeleted()
+    {
+        Q_Q(QMediaPlaylist);
+        mediaObject = 0;
+        if (control != localPlaylistControl)
+            control = 0;
+        q->setMediaObject(0);
+    }
+
+    QMediaObject *mediaObject;
+
+    QMediaPlaylistControl *control;
+    QMediaPlaylistProvider *playlist() const { return control->playlistProvider(); }
+
+    QMediaPlaylistControl *localPlaylistControl;
+
+    bool readItems(QMediaPlaylistReader *reader);
+    bool writeItems(QMediaPlaylistWriter *writer);
+
+    QMediaPlaylist::Error error;
+    QString errorString;
+
+    QMediaPlaylist *q_ptr;
+};
+
+
+class QLocalMediaPlaylistControl : public QMediaPlaylistControl
+{
+    Q_OBJECT
+public:
+    QLocalMediaPlaylistControl(QObject *parent)
+        :QMediaPlaylistControl(parent)
+    {
+        QMediaPlaylistProvider *playlist = new QLocalMediaPlaylistProvider(this);
+        m_navigator = new QMediaPlaylistNavigator(playlist,this);
+        m_navigator->setPlaybackMode(QMediaPlaylist::Sequential);
+
+        connect(m_navigator, SIGNAL(currentIndexChanged(int)), SIGNAL(currentIndexChanged(int)));
+        connect(m_navigator, SIGNAL(activated(QMediaContent)), SIGNAL(currentMediaChanged(QMediaContent)));
+        connect(m_navigator, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)), SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)));
+    }
+
+    virtual ~QLocalMediaPlaylistControl() {};
+
+    QMediaPlaylistProvider* playlistProvider() const { return m_navigator->playlist(); }
+    bool setPlaylistProvider(QMediaPlaylistProvider *mediaPlaylist)
+    {
+        m_navigator->setPlaylist(mediaPlaylist);
+        emit playlistProviderChanged();
+        return true;
+    }
+
+    int currentIndex() const { return m_navigator->currentIndex(); }
+    void setCurrentIndex(int position) { m_navigator->jump(position); }
+    int nextIndex(int steps) const { return m_navigator->nextIndex(steps); }
+    int previousIndex(int steps) const { return m_navigator->previousIndex(steps); }
+
+    void next() { m_navigator->next(); }
+    void previous() { m_navigator->previous(); }
+
+    QMediaPlaylist::PlaybackMode playbackMode() const { return m_navigator->playbackMode(); }
+    void setPlaybackMode(QMediaPlaylist::PlaybackMode mode) { m_navigator->setPlaybackMode(mode); }
+
+private:
+    QMediaPlaylistNavigator *m_navigator;
+};
+
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QMEDIAPLAYLIST_P_H
diff --git a/src/multimedia/playback/qmediaplaylistioplugin.cpp b/src/multimedia/playback/qmediaplaylistioplugin.cpp
new file mode 100644
index 0000000..80fe0ef
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylistioplugin.cpp
@@ -0,0 +1,204 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaplaylistioplugin.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaPlaylistReader
+
+    \brief The QMediaPlaylistReader class provides an interface for reading a playlist file.
+    \inmodule QtMultimedia
+    \since 1.0
+
+    \sa QMediaPlaylistIOPlugin
+*/
+
+/*!
+    Destroys a media playlist reader.
+*/
+QMediaPlaylistReader::~QMediaPlaylistReader()
+{
+}
+
+/*!
+    \fn QMediaPlaylistReader::atEnd() const
+
+    Identifies if a playlist reader has reached the end of its input.
+
+    Returns true if the reader has reached the end; and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistReader::readItem()
+
+    Reads an item of media from a playlist file.
+
+    Returns the read media, or a null QMediaContent if no more media is available.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistReader::close()
+
+    Closes a playlist reader's input device.
+    \since 1.0
+*/
+
+/*!
+    \class QMediaPlaylistWriter
+
+    \brief The QMediaPlaylistWriter class provides an interface for writing a playlist file.
+
+    \since 1.0
+    \sa QMediaPlaylistIOPlugin
+*/
+
+/*!
+    Destroys a media playlist writer.
+*/
+QMediaPlaylistWriter::~QMediaPlaylistWriter()
+{
+}
+
+/*!
+    \fn QMediaPlaylistWriter::writeItem(const QMediaContent &media)
+
+    Writes an item of \a media to a playlist file.
+
+    Returns true if the media was written successfully; and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistWriter::close()
+
+    Finalizes the writing of a playlist and closes the output device.
+    \since 1.0
+*/
+
+/*!
+    \class QMediaPlaylistIOPlugin
+    \brief The QMediaPlaylistIOPlugin class provides an interface for media playlist I/O plug-ins.
+    \since 1.0
+*/
+
+/*!
+    Constructs a media playlist I/O plug-in with the given \a parent.
+*/
+QMediaPlaylistIOPlugin::QMediaPlaylistIOPlugin(QObject *parent)
+    :QObject(parent)
+{
+}
+
+/*!
+    Destroys a media playlist I/O plug-in.
+*/
+QMediaPlaylistIOPlugin::~QMediaPlaylistIOPlugin()
+{
+}
+
+/*!
+    \fn QMediaPlaylistIOPlugin::canRead(QIODevice *device, const QByteArray &format) const
+
+    Identifies if plug-in can read \a format data from an I/O \a device.
+
+    Returns true if the data can be read; and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistIOPlugin::canRead(const QUrl& location, const QByteArray &format) const
+
+    Identifies if a plug-in can read \a format data from a URL \a location.
+
+    Returns true if the data can be read; and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistIOPlugin::canWrite(QIODevice *device, const QByteArray &format) const
+
+    Identifies if a plug-in can write \a format data to an I/O \a device.
+
+    Returns true if the data can be written; and false otherwise.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistIOPlugin::keys() const
+
+    Returns a list of format keys supported by a plug-in.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistIOPlugin::createReader(QIODevice *device, const QByteArray &format)
+
+    Returns a new QMediaPlaylistReader which reads \a format data from an I/O \a device.
+
+    If the device is invalid or the format is unsupported this will return a null pointer.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistIOPlugin::createReader(const QUrl& location, const QByteArray &format)
+
+    Returns a new QMediaPlaylistReader which reads \a format data from a URL \a location.
+
+    If the location or the format is unsupported this will return a null pointer.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistIOPlugin::createWriter(QIODevice *device, const QByteArray &format)
+
+    Returns a new QMediaPlaylistWriter which writes \a format data to an I/O \a device.
+
+    If the device is invalid or the format is unsupported this will return a null pointer.
+    \since 1.0
+*/
+
+#include "moc_qmediaplaylistioplugin.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qmediaplaylistioplugin.h b/src/multimedia/playback/qmediaplaylistioplugin.h
new file mode 100644
index 0000000..97ded8b
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylistioplugin.h
@@ -0,0 +1,126 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAPLAYLISTIOPLUGIN_H
+#define QMEDIAPLAYLISTIOPLUGIN_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qplugin.h>
+#include <QtCore/qfactoryinterface.h>
+
+#include <qtmultimediadefs.h>
+
+#include "qmediacontent.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QString;
+class QUrl;
+class QByteArray;
+class QIODevice;
+class QStringList;
+
+class Q_MULTIMEDIA_EXPORT QMediaPlaylistReader
+{
+public:
+    virtual ~QMediaPlaylistReader();
+
+    virtual bool atEnd() const = 0;
+    virtual QMediaContent readItem() = 0;
+    virtual void close() = 0;
+};
+
+class Q_MULTIMEDIA_EXPORT QMediaPlaylistWriter
+{
+public:
+    virtual ~QMediaPlaylistWriter();
+
+    virtual bool writeItem(const QMediaContent &content) = 0;
+    virtual void close() = 0;
+};
+
+struct Q_MULTIMEDIA_EXPORT QMediaPlaylistIOInterface : public QFactoryInterface
+{
+    virtual bool canRead(QIODevice *device, const QByteArray &format = QByteArray() ) const = 0;
+    virtual bool canRead(const QUrl& location, const QByteArray &format = QByteArray()) const = 0;
+
+    virtual bool canWrite(QIODevice *device, const QByteArray &format) const = 0;
+
+    virtual QMediaPlaylistReader *createReader(QIODevice *device, const QByteArray &format = QByteArray()) = 0;
+    virtual QMediaPlaylistReader *createReader(const QUrl& location, const QByteArray &format = QByteArray()) = 0;
+
+    virtual QMediaPlaylistWriter *createWriter(QIODevice *device, const QByteArray &format) = 0;
+};
+
+#define QMediaPlaylistIOInterface_iid "com.nokia.Qt.QMediaPlaylistIOInterface"
+Q_DECLARE_INTERFACE(QMediaPlaylistIOInterface, QMediaPlaylistIOInterface_iid);
+
+class Q_MULTIMEDIA_EXPORT QMediaPlaylistIOPlugin : public QObject, public QMediaPlaylistIOInterface
+{
+Q_OBJECT
+Q_INTERFACES(QMediaPlaylistIOInterface:QFactoryInterface)
+public:
+    explicit QMediaPlaylistIOPlugin(QObject *parent = 0);
+    virtual ~QMediaPlaylistIOPlugin();
+
+    virtual bool canRead(QIODevice *device, const QByteArray &format = QByteArray() ) const = 0;
+    virtual bool canRead(const QUrl& location, const QByteArray &format = QByteArray()) const = 0;
+
+    virtual bool canWrite(QIODevice *device, const QByteArray &format) const = 0;
+
+    virtual QStringList keys() const = 0;
+
+    virtual QMediaPlaylistReader *createReader(QIODevice *device, const QByteArray &format = QByteArray()) = 0;
+    virtual QMediaPlaylistReader *createReader(const QUrl& location, const QByteArray &format = QByteArray()) = 0;
+
+    virtual QMediaPlaylistWriter *createWriter(QIODevice *device, const QByteArray &format) = 0;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QMEDIAPLAYLISTIOPLUGIN_H
diff --git a/src/multimedia/playback/qmediaplaylistnavigator.cpp b/src/multimedia/playback/qmediaplaylistnavigator.cpp
new file mode 100644
index 0000000..d78e6ef
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylistnavigator.cpp
@@ -0,0 +1,568 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaplaylistnavigator.h"
+#include "qmediaplaylistprovider.h"
+#include "qmediaplaylist.h"
+#include "qmediaobject_p.h"
+
+#include <QtCore/qdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+class QMediaPlaylistNullProvider : public QMediaPlaylistProvider
+{
+public:
+    QMediaPlaylistNullProvider() :QMediaPlaylistProvider() {}
+    virtual ~QMediaPlaylistNullProvider() {}
+    virtual int mediaCount() const {return 0;}
+    virtual QMediaContent media(int) const { return QMediaContent(); }
+};
+
+Q_GLOBAL_STATIC(QMediaPlaylistNullProvider, _q_nullMediaPlaylist)
+
+class QMediaPlaylistNavigatorPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QMediaPlaylistNavigator)
+public:
+    QMediaPlaylistNavigatorPrivate()
+        :playlist(0),
+        currentPos(-1),
+        lastValidPos(-1),
+        playbackMode(QMediaPlaylist::Sequential),
+        randomPositionsOffset(-1)
+    {
+    }
+
+    QMediaPlaylistProvider *playlist;
+    int currentPos;
+    int lastValidPos; //to be used with CurrentItemOnce playback mode
+    QMediaPlaylist::PlaybackMode playbackMode;
+    QMediaContent currentItem;
+
+    mutable QList<int> randomModePositions;
+    mutable int randomPositionsOffset;
+
+    int nextItemPos(int steps = 1) const;
+    int previousItemPos(int steps = 1) const;
+
+    void _q_mediaInserted(int start, int end);
+    void _q_mediaRemoved(int start, int end);
+    void _q_mediaChanged(int start, int end);
+
+    QMediaPlaylistNavigator *q_ptr;
+};
+
+
+int QMediaPlaylistNavigatorPrivate::nextItemPos(int steps) const
+{
+    if (playlist->mediaCount() == 0)
+        return -1;
+
+    if (steps == 0)
+        return currentPos;
+
+    switch (playbackMode) {
+        case QMediaPlaylist::CurrentItemOnce:
+            return /*currentPos == -1 ? lastValidPos :*/ -1;
+        case QMediaPlaylist::CurrentItemInLoop:
+            return currentPos;
+        case QMediaPlaylist::Sequential:
+            {
+                int nextPos = currentPos+steps;
+                return nextPos < playlist->mediaCount() ? nextPos : -1;
+            }
+        case QMediaPlaylist::Loop:
+            return (currentPos+steps) % playlist->mediaCount();
+        case QMediaPlaylist::Random:
+            {
+                //TODO: limit the history size
+
+                if (randomPositionsOffset == -1) {
+                    randomModePositions.clear();
+                    randomModePositions.append(currentPos);
+                    randomPositionsOffset = 0;
+                }
+
+                while (randomModePositions.size() < randomPositionsOffset+steps+1)
+                    randomModePositions.append(-1);
+                int res = randomModePositions[randomPositionsOffset+steps];
+                if (res<0 || res >= playlist->mediaCount()) {
+                    res = qrand() % playlist->mediaCount();
+                    randomModePositions[randomPositionsOffset+steps] = res;
+                }
+
+                return res;
+            }
+    }
+
+    return -1;
+}
+
+int QMediaPlaylistNavigatorPrivate::previousItemPos(int steps) const
+{
+    if (playlist->mediaCount() == 0)
+        return -1;
+
+    if (steps == 0)
+        return currentPos;
+
+    switch (playbackMode) {
+        case QMediaPlaylist::CurrentItemOnce:
+            return /*currentPos == -1 ? lastValidPos :*/ -1;
+        case QMediaPlaylist::CurrentItemInLoop:
+            return currentPos;
+        case QMediaPlaylist::Sequential:
+            {
+                int prevPos = currentPos == -1 ? playlist->mediaCount() - steps : currentPos - steps;
+                return prevPos>=0 ? prevPos : -1;
+            }
+        case QMediaPlaylist::Loop:
+            {
+                int prevPos = currentPos - steps;
+                while (prevPos<0)
+                    prevPos += playlist->mediaCount();
+                return prevPos;
+            }
+        case QMediaPlaylist::Random:
+            {
+                //TODO: limit the history size
+
+                if (randomPositionsOffset == -1) {
+                    randomModePositions.clear();
+                    randomModePositions.append(currentPos);
+                    randomPositionsOffset = 0;
+                }
+
+                while (randomPositionsOffset-steps < 0) {
+                    randomModePositions.prepend(-1);
+                    randomPositionsOffset++;
+                }
+
+                int res = randomModePositions[randomPositionsOffset-steps];
+                if (res<0 || res >= playlist->mediaCount()) {
+                    res = qrand() % playlist->mediaCount();
+                    randomModePositions[randomPositionsOffset-steps] = res;
+                }
+
+                return res;
+            }
+    }
+
+    return -1;
+}
+
+/*!
+    \class QMediaPlaylistNavigator
+
+    \brief The QMediaPlaylistNavigator class provides navigation for a media playlist.
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+    \sa QMediaPlaylist, QMediaPlaylistProvider
+*/
+
+
+/*!
+    Constructs a media playlist navigator for a \a playlist.
+
+    The \a parent is passed to QObject.
+    \since 1.0
+ */
+QMediaPlaylistNavigator::QMediaPlaylistNavigator(QMediaPlaylistProvider *playlist, QObject *parent)
+    : QObject(parent)
+    , d_ptr(new QMediaPlaylistNavigatorPrivate)
+{
+    d_ptr->q_ptr = this;
+
+    setPlaylist(playlist ? playlist : _q_nullMediaPlaylist());
+}
+
+/*!
+    Destroys a media playlist navigator.
+ */
+
+QMediaPlaylistNavigator::~QMediaPlaylistNavigator()
+{
+    delete d_ptr;
+}
+
+
+/*! \property QMediaPlaylistNavigator::playbackMode
+    Contains the playback mode.
+    \since 1.0
+ */
+QMediaPlaylist::PlaybackMode QMediaPlaylistNavigator::playbackMode() const
+{
+    return d_func()->playbackMode;
+}
+
+/*!
+    Sets the playback \a mode.
+    \since 1.0
+ */
+void QMediaPlaylistNavigator::setPlaybackMode(QMediaPlaylist::PlaybackMode mode)
+{
+    Q_D(QMediaPlaylistNavigator);
+    if (d->playbackMode == mode)
+        return;
+
+    if (mode == QMediaPlaylist::Random) {
+        d->randomPositionsOffset = 0;
+        d->randomModePositions.append(d->currentPos);
+    } else if (d->playbackMode == QMediaPlaylist::Random) {
+        d->randomPositionsOffset = -1;
+        d->randomModePositions.clear();
+    }
+
+    d->playbackMode = mode;
+
+    emit playbackModeChanged(mode);
+    emit surroundingItemsChanged();
+}
+
+/*!
+    Returns the playlist being navigated.
+    \since 1.0
+*/
+
+QMediaPlaylistProvider *QMediaPlaylistNavigator::playlist() const
+{
+    return d_func()->playlist;
+}
+
+/*!
+    Sets the \a playlist to navigate.
+    \since 1.0
+*/
+void QMediaPlaylistNavigator::setPlaylist(QMediaPlaylistProvider *playlist)
+{
+    Q_D(QMediaPlaylistNavigator);
+
+    if (d->playlist == playlist)
+        return;
+
+    if (d->playlist) {
+        d->playlist->disconnect(this);
+    }
+
+    if (playlist) {
+        d->playlist = playlist;
+    } else {
+        //assign to shared readonly null playlist
+        d->playlist = _q_nullMediaPlaylist();
+    }
+
+    connect(d->playlist, SIGNAL(mediaInserted(int,int)), SLOT(_q_mediaInserted(int,int)));
+    connect(d->playlist, SIGNAL(mediaRemoved(int,int)), SLOT(_q_mediaRemoved(int,int)));
+    connect(d->playlist, SIGNAL(mediaChanged(int,int)), SLOT(_q_mediaChanged(int,int)));
+
+    d->randomPositionsOffset = -1;
+    d->randomModePositions.clear();
+
+    if (d->currentPos != -1) {
+        d->currentPos = -1;
+        emit currentIndexChanged(-1);
+    }
+
+    if (!d->currentItem.isNull()) {
+        d->currentItem = QMediaContent();
+        emit activated(d->currentItem); //stop playback
+    }
+}
+
+/*! \property QMediaPlaylistNavigator::currentItem
+
+  Contains the media at the current position in the playlist.
+
+  \since 1.0
+  \sa currentIndex()
+*/
+
+QMediaContent QMediaPlaylistNavigator::currentItem() const
+{
+    return itemAt(d_func()->currentPos);
+}
+
+/*! \fn QMediaContent QMediaPlaylistNavigator::nextItem(int steps) const
+
+  Returns the media that is \a steps positions ahead of the current
+  position in the playlist.
+
+  \since 1.0
+  \sa nextIndex()
+*/
+QMediaContent QMediaPlaylistNavigator::nextItem(int steps) const
+{
+    return itemAt(nextIndex(steps));
+}
+
+/*!
+  Returns the media that is \a steps positions behind the current
+  position in the playlist.
+
+  \since 1.0
+  \sa previousIndex()
+ */
+QMediaContent QMediaPlaylistNavigator::previousItem(int steps) const
+{
+    return itemAt(previousIndex(steps));
+}
+
+/*!
+    Returns the media at a \a position in the playlist.
+    \since 1.0
+ */
+QMediaContent QMediaPlaylistNavigator::itemAt(int position) const
+{
+    return d_func()->playlist->media(position);
+}
+
+/*! \property QMediaPlaylistNavigator::currentIndex
+
+  Contains the position of the current media.
+
+  If no media is current, the property contains -1.
+
+  \since 1.0
+  \sa nextIndex(), previousIndex()
+*/
+
+int QMediaPlaylistNavigator::currentIndex() const
+{
+    return d_func()->currentPos;
+}
+
+/*!
+  Returns a position \a steps ahead of the current position
+  accounting for the playbackMode().
+
+  If the position is beyond the end of the playlist, this value
+  returned is -1.
+
+  \since 1.0
+  \sa currentIndex(), previousIndex(), playbackMode()
+*/
+
+int QMediaPlaylistNavigator::nextIndex(int steps) const
+{
+    return d_func()->nextItemPos(steps);
+}
+
+/*!
+
+  Returns a position \a steps behind the current position accounting
+  for the playbackMode().
+
+  If the position is prior to the beginning of the playlist this will
+  return -1.
+
+  \since 1.0
+  \sa currentIndex(), nextIndex(), playbackMode()
+*/
+int QMediaPlaylistNavigator::previousIndex(int steps) const
+{
+    return d_func()->previousItemPos(steps);
+}
+
+/*!
+  Advances to the next item in the playlist.
+
+  \since 1.0
+  \sa previous(), jump(), playbackMode()
+ */
+void QMediaPlaylistNavigator::next()
+{
+    Q_D(QMediaPlaylistNavigator);
+
+    int nextPos = d->nextItemPos();
+
+    if ( playbackMode() == QMediaPlaylist::Random )
+            d->randomPositionsOffset++;
+
+    jump(nextPos);
+}
+
+/*!
+  Returns to the previous item in the playlist,
+
+  \since 1.0
+  \sa next(), jump(), playbackMode()
+ */
+void QMediaPlaylistNavigator::previous()
+{
+    Q_D(QMediaPlaylistNavigator);
+
+    int prevPos = d->previousItemPos();
+    if ( playbackMode() == QMediaPlaylist::Random )
+        d->randomPositionsOffset--;
+
+    jump(prevPos);
+}
+
+/*!
+  Jumps to a new \a position in the playlist.
+  \since 1.0
+ */
+void QMediaPlaylistNavigator::jump(int position)
+{
+    Q_D(QMediaPlaylistNavigator);
+
+    if (position<-1 || position>=d->playlist->mediaCount()) {
+        qWarning() << "QMediaPlaylistNavigator: Jump outside playlist range";
+        position = -1;
+    }
+
+    if (position != -1)
+        d->lastValidPos = position;
+
+    if (playbackMode() == QMediaPlaylist::Random) {
+        if (d->randomModePositions[d->randomPositionsOffset] != position) {
+            d->randomModePositions.clear();
+            d->randomModePositions.append(position);
+            d->randomPositionsOffset = 0;
+        }
+    }
+
+    if (position != -1)
+        d->currentItem = d->playlist->media(position);
+    else
+        d->currentItem = QMediaContent();
+
+    if (position != d->currentPos) {
+        d->currentPos = position;
+        emit currentIndexChanged(d->currentPos);
+        emit surroundingItemsChanged();
+    }
+
+    emit activated(d->currentItem);
+}
+
+/*!
+    \internal
+  \since 1.0
+*/
+void QMediaPlaylistNavigatorPrivate::_q_mediaInserted(int start, int end)
+{
+    Q_Q(QMediaPlaylistNavigator);
+
+    if (currentPos >= start) {
+        currentPos = end-start+1;
+        q->jump(currentPos);
+    }
+
+    //TODO: check if they really changed
+    emit q->surroundingItemsChanged();
+}
+
+/*!
+    \internal
+    \since 1.0
+*/
+void QMediaPlaylistNavigatorPrivate::_q_mediaRemoved(int start, int end)
+{
+    Q_Q(QMediaPlaylistNavigator);
+
+    if (currentPos > end) {
+        currentPos = currentPos - end-start+1;
+        q->jump(currentPos);
+    } else if (currentPos >= start) {
+        //current item was removed
+        currentPos = qMin(start, playlist->mediaCount()-1);
+        q->jump(currentPos);
+    }
+
+    //TODO: check if they really changed
+    emit q->surroundingItemsChanged();
+}
+
+/*!
+    \internal
+    \since 1.0
+*/
+void QMediaPlaylistNavigatorPrivate::_q_mediaChanged(int start, int end)
+{
+    Q_Q(QMediaPlaylistNavigator);
+
+    if (currentPos >= start && currentPos<=end) {
+        QMediaContent src = playlist->media(currentPos);
+        if (src != currentItem) {
+            currentItem = src;
+            emit q->activated(src);
+        }
+    }
+
+    //TODO: check if they really changed
+    emit q->surroundingItemsChanged();
+}
+
+/*!
+    \fn QMediaPlaylistNavigator::activated(const QMediaContent &media)
+
+    Signals that the current \a media has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistNavigator::currentIndexChanged(int position)
+
+    Signals the \a position of the current media has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistNavigator::playbackModeChanged(QMediaPlaylist::PlaybackMode mode)
+
+    Signals that the playback \a mode has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistNavigator::surroundingItemsChanged()
+
+    Signals that media immediately surrounding the current position has changed.
+    \since 1.0
+*/
+
+#include "moc_qmediaplaylistnavigator.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qmediaplaylistnavigator.h b/src/multimedia/playback/qmediaplaylistnavigator.h
new file mode 100644
index 0000000..72e4520
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylistnavigator.h
@@ -0,0 +1,115 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAPLAYLISTNAVIGATOR_H
+#define QMEDIAPLAYLISTNAVIGATOR_H
+
+#include "qmediaplaylistprovider.h"
+#include "qmediaplaylist.h"
+#include <QtCore/qobject.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QMediaPlaylistNavigatorPrivate;
+class Q_MULTIMEDIA_EXPORT QMediaPlaylistNavigator : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QMediaPlaylist::PlaybackMode playbackMode READ playbackMode WRITE setPlaybackMode NOTIFY playbackModeChanged)
+    Q_PROPERTY(int currentIndex READ currentIndex WRITE jump NOTIFY currentIndexChanged)
+    Q_PROPERTY(QMediaContent currentItem READ currentItem)
+
+public:
+    QMediaPlaylistNavigator(QMediaPlaylistProvider *playlist, QObject *parent = 0);
+    virtual ~QMediaPlaylistNavigator();
+
+    QMediaPlaylistProvider *playlist() const;
+    void setPlaylist(QMediaPlaylistProvider *playlist);
+
+    QMediaPlaylist::PlaybackMode playbackMode() const;
+
+    QMediaContent currentItem() const;
+    QMediaContent nextItem(int steps = 1) const;
+    QMediaContent previousItem(int steps = 1) const;
+
+    QMediaContent itemAt(int position) const;
+
+    int currentIndex() const;
+    int nextIndex(int steps = 1) const;
+    int previousIndex(int steps = 1) const;
+
+public Q_SLOTS:
+    void next();
+    void previous();
+
+    void jump(int);
+
+    void setPlaybackMode(QMediaPlaylist::PlaybackMode mode);
+
+Q_SIGNALS:
+    void activated(const QMediaContent &content);
+    void currentIndexChanged(int);
+    void playbackModeChanged(QMediaPlaylist::PlaybackMode mode);
+
+    void surroundingItemsChanged();
+
+protected:
+    QMediaPlaylistNavigatorPrivate *d_ptr;
+
+private:
+    Q_DISABLE_COPY(QMediaPlaylistNavigator)
+    Q_DECLARE_PRIVATE(QMediaPlaylistNavigator)
+
+    Q_PRIVATE_SLOT(d_func(), void _q_mediaInserted(int start, int end))
+    Q_PRIVATE_SLOT(d_func(), void _q_mediaRemoved(int start, int end))
+    Q_PRIVATE_SLOT(d_func(), void _q_mediaChanged(int start, int end))
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QMEDIAPLAYLISTNAVIGATOR_H
diff --git a/src/multimedia/playback/qmediaplaylistprovider.cpp b/src/multimedia/playback/qmediaplaylistprovider.cpp
new file mode 100644
index 0000000..75e927b
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylistprovider.cpp
@@ -0,0 +1,329 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaplaylistprovider.h"
+#include "qmediaplaylistprovider_p.h"
+
+#include <QtCore/qurl.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaPlaylistProvider
+
+    \brief The QMediaPlaylistProvider class provides an abstract list of media.
+    \inmodule QtMultimedia
+    \since 1.0
+
+    \sa QMediaPlaylist
+*/
+
+/*!
+    Constructs a playlist provider with the given \a parent.
+*/
+QMediaPlaylistProvider::QMediaPlaylistProvider(QObject *parent)
+    :QObject(parent), d_ptr(new QMediaPlaylistProviderPrivate)
+{
+}
+
+/*!
+    \internal
+*/
+QMediaPlaylistProvider::QMediaPlaylistProvider(QMediaPlaylistProviderPrivate &dd, QObject *parent)
+    :QObject(parent), d_ptr(&dd)
+{
+}
+
+/*!
+    Destroys a playlist provider.
+*/
+QMediaPlaylistProvider::~QMediaPlaylistProvider()
+{
+    delete d_ptr;
+}
+
+/*!
+    \fn QMediaPlaylistProvider::mediaCount() const;
+
+    Returns the size of playlist.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaPlaylistProvider::media(int index) const;
+
+    Returns the media at \a index in the playlist.
+
+    If the index is invalid this will return a null media content.
+    \since 1.0
+*/
+
+
+/*!
+    Loads a playlist from from a URL \a location. If no playlist \a format is specified the loader
+    will inspect the URL or probe the headers to guess the format.
+
+    New items are appended to playlist.
+
+    Returns true if the provider supports the format and loading from the locations URL protocol,
+    otherwise this will return false.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::load(const QUrl &location, const char *format)
+{
+    Q_UNUSED(location);
+    Q_UNUSED(format);
+    return false;
+}
+
+/*!
+    Loads a playlist from from an I/O \a device. If no playlist \a format is specified the loader
+    will probe the headers to guess the format.
+
+    New items are appended to playlist.
+
+    Returns true if the provider supports the format and loading from an I/O device, otherwise this
+    will return false.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::load(QIODevice * device, const char *format)
+{
+    Q_UNUSED(device);
+    Q_UNUSED(format);
+    return false;
+}
+
+/*!
+    Saves the contents of a playlist to a URL \a location.  If no playlist \a format is specified
+    the writer will inspect the URL to guess the format.
+
+    Returns true if the playlist was saved successfully; and false otherwise.
+    \since 1.0
+  */
+bool QMediaPlaylistProvider::save(const QUrl &location, const char *format)
+{
+    Q_UNUSED(location);
+    Q_UNUSED(format);
+    return false;
+}
+
+/*!
+    Saves the contents of a playlist to an I/O \a device in the specified \a format.
+
+    Returns true if the playlist was saved successfully; and false otherwise.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::save(QIODevice * device, const char *format)
+{
+    Q_UNUSED(device);
+    Q_UNUSED(format);
+    return false;
+}
+
+/*!
+    Returns true if a playlist is read-only; otherwise returns false.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::isReadOnly() const
+{
+    return true;
+}
+
+/*!
+    Append \a media to a playlist.
+
+    Returns true if the media was appended; and false otherwise.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::addMedia(const QMediaContent &media)
+{
+    Q_UNUSED(media);
+    return false;
+}
+
+/*!
+    Append multiple media \a items to a playlist.
+
+    Returns true if the media items were appended; and false otherwise.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::addMedia(const QList<QMediaContent> &items)
+{
+    foreach(const QMediaContent &item, items) {
+        if (!addMedia(item))
+            return false;
+    }
+
+    return true;
+}
+
+/*!
+    Inserts \a media into a playlist at \a position.
+
+    Returns true if the media was inserted; and false otherwise.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::insertMedia(int position, const QMediaContent &media)
+{
+    Q_UNUSED(position);
+    Q_UNUSED(media);
+    return false;
+}
+
+/*!
+    Inserts multiple media \a items into a playlist at \a position.
+
+    Returns true if the media \a items were inserted; and false otherwise.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::insertMedia(int position, const QList<QMediaContent> &items)
+{
+    for (int i=0; i<items.count(); i++) {
+        if (!insertMedia(position+i,items.at(i)))
+            return false;
+    }
+
+    return true;
+}
+
+
+/*!
+    Removes the media at \a position from a playlist.
+
+    Returns true if the media was removed; and false otherwise.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::removeMedia(int position)
+{
+    Q_UNUSED(position);
+    return false;
+}
+
+/*!
+    Removes the media between the given \a start and \a end positions from a playlist.
+
+    Returns true if the media was removed; and false otherwise.
+    \since 1.0
+  */
+bool QMediaPlaylistProvider::removeMedia(int start, int end)
+{
+    for (int pos=start; pos<=end; pos++) {
+        if (!removeMedia(pos))
+            return false;
+    }
+
+    return true;
+}
+
+/*!
+    Removes all media from a playlist.
+
+    Returns true if the media was removed; and false otherwise.
+    \since 1.0
+*/
+bool QMediaPlaylistProvider::clear()
+{
+    return removeMedia(0, mediaCount()-1);
+}
+
+/*!
+    Shuffles the contents of a playlist.
+    \since 1.0
+*/
+void QMediaPlaylistProvider::shuffle()
+{
+}
+
+/*!
+    \fn void QMediaPlaylistProvider::mediaAboutToBeInserted(int start, int end);
+
+    Signals that new media is about to be inserted into a playlist between the \a start and \a end
+    positions.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylistProvider::mediaInserted(int start, int end);
+
+    Signals that new media has been inserted into a playlist between the \a start and \a end
+    positions.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylistProvider::mediaAboutToBeRemoved(int start, int end);
+
+    Signals that media is about to be removed from a playlist between the \a start and \a end
+    positions.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylistProvider::mediaRemoved(int start, int end);
+
+    Signals that media has been removed from a playlist between the \a start and \a end positions.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylistProvider::mediaChanged(int start, int end);
+
+    Signals that media in playlist between the \a start and \a end positions inclusive has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylistProvider::loaded()
+
+    Signals that a load() finished successfully.
+    \since 1.0
+*/
+
+/*!
+    \fn void QMediaPlaylistProvider::loadFailed(QMediaPlaylist::Error error, const QString& errorMessage)
+
+    Signals that a load failed() due to an \a error.  The \a errorMessage provides more information.
+    \since 1.0
+*/
+
+#include "moc_qmediaplaylistprovider.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qmediaplaylistprovider.h b/src/multimedia/playback/qmediaplaylistprovider.h
new file mode 100644
index 0000000..79167e8
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylistprovider.h
@@ -0,0 +1,115 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAPLAYLISTPROVIDER_H
+#define QMEDIAPLAYLISTPROVIDER_H
+
+#include <QObject>
+
+#include "qmediacontent.h"
+#include "qmediaplaylist.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QString;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class QMediaPlaylistProviderPrivate;
+class Q_MULTIMEDIA_EXPORT QMediaPlaylistProvider : public QObject
+{
+Q_OBJECT
+public:
+    QMediaPlaylistProvider(QObject *parent=0);
+    virtual ~QMediaPlaylistProvider();
+
+    virtual bool load(const QUrl &location, const char *format = 0);
+    virtual bool load(QIODevice * device, const char *format = 0);
+    virtual bool save(const QUrl &location, const char *format = 0);
+    virtual bool save(QIODevice * device, const char *format);
+
+    virtual int mediaCount() const = 0;
+    virtual QMediaContent media(int index) const = 0;
+
+    virtual bool isReadOnly() const;
+
+    virtual bool addMedia(const QMediaContent &content);
+    virtual bool addMedia(const QList<QMediaContent> &contentList);
+    virtual bool insertMedia(int index, const QMediaContent &content);
+    virtual bool insertMedia(int index, const QList<QMediaContent> &content);
+    virtual bool removeMedia(int pos);
+    virtual bool removeMedia(int start, int end);
+    virtual bool clear();
+
+public Q_SLOTS:
+    virtual void shuffle();
+
+Q_SIGNALS:
+    void mediaAboutToBeInserted(int start, int end);
+    void mediaInserted(int start, int end);
+
+    void mediaAboutToBeRemoved(int start, int end);
+    void mediaRemoved(int start, int end);
+
+    void mediaChanged(int start, int end);
+
+    void loaded();
+    void loadFailed(QMediaPlaylist::Error, const QString& errorMessage);
+
+protected:
+    QMediaPlaylistProviderPrivate *d_ptr;
+    QMediaPlaylistProvider(QMediaPlaylistProviderPrivate &dd, QObject *parent);
+
+private:
+    Q_DECLARE_PRIVATE(QMediaPlaylistProvider)
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif // QMEDIAPLAYLISTPROVIDER_H
diff --git a/src/multimedia/playback/qmediaplaylistprovider_p.h b/src/multimedia/playback/qmediaplaylistprovider_p.h
new file mode 100644
index 0000000..71fb86f
--- /dev/null
+++ b/src/multimedia/playback/qmediaplaylistprovider_p.h
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAPLAYLISTPROVIDER_P_H
+#define QMEDIAPLAYLISTPROVIDER_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qmediaplaylist.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QMediaPlaylistProviderPrivate
+{
+public:
+    QMediaPlaylistProviderPrivate()
+    {}
+    virtual ~QMediaPlaylistProviderPrivate()
+    {}
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+
+#endif // QMEDIAPLAYLISTSOURCE_P_H
diff --git a/src/multimedia/playback/qmediaresource.cpp b/src/multimedia/playback/qmediaresource.cpp
new file mode 100644
index 0000000..9bd4887
--- /dev/null
+++ b/src/multimedia/playback/qmediaresource.cpp
@@ -0,0 +1,453 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaresource.h"
+
+#include <QtCore/qsize.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qvariant.h>
+
+QT_BEGIN_NAMESPACE
+
+namespace
+{
+    class QMediaResourcePrivateRegisterMetaTypes
+    {
+    public:
+        QMediaResourcePrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QMediaResource>();
+            qRegisterMetaType<QMediaResourceList>();
+        }
+    } _registerMetaTypes;
+}
+
+/*!
+    \class QMediaResource
+
+    \brief The QMediaResource class provides a description of a media resource.
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+    A media resource is composed of a \l {url()}{URL} containing the
+    location of the resource and a set of properties that describe the
+    format of the resource.  The properties provide a means to assess a
+    resource without first attempting to load it, and in situations where
+    media be represented by multiple alternative representations provide a
+    means to select the appropriate resource.
+
+    Media made available by a remote services can often be available in
+    multiple encodings or quality levels, this allows a client to select
+    an appropriate resource based on considerations such as codecs supported,
+    network bandwidth, and display constraints.  QMediaResource includes
+    information such as the \l {mimeType()}{MIME type}, \l {audioCodec()}{audio}
+    and \l {videoCodec()}{video} codecs, \l {audioBitRate()}{audio} and
+    \l {videoBitRate()}{video} bit rates, and \l {resolution()}{resolution}
+    so these constraints and others can be evaluated.
+
+    The only mandatory property of a QMediaResource is the url().
+
+    \sa QMediaContent
+*/
+
+/*!
+    \typedef QMediaResourceList
+
+    Synonym for \c QList<QMediaResource>
+*/
+
+/*!
+    Constructs a null media resource.
+*/
+QMediaResource::QMediaResource()
+{
+}
+
+/*!
+    Constructs a media resource with the given \a mimeType from a \a url.
+    \since 1.0
+*/
+QMediaResource::QMediaResource(const QUrl &url, const QString &mimeType)
+{
+    values.insert(Url, url);
+    values.insert(MimeType, mimeType);
+}
+
+/*!
+    Constructs a media resource with the given \a mimeType from a network \a request.
+    \since 1.0
+*/
+QMediaResource::QMediaResource(const QNetworkRequest &request, const QString &mimeType)
+{
+    values.insert(Request, QVariant::fromValue(request));
+    values.insert(Url, request.url());
+    values.insert(MimeType, mimeType);
+}
+
+/*!
+    Constructs a copy of a media resource \a other.
+    \since 1.0
+*/
+QMediaResource::QMediaResource(const QMediaResource &other)
+    : values(other.values)
+{
+}
+
+/*!
+    Assigns the value of \a other to a media resource.
+    \since 1.0
+*/
+QMediaResource &QMediaResource::operator =(const QMediaResource &other)
+{
+    values = other.values;
+
+    return *this;
+}
+
+/*!
+    Destroys a media resource.
+*/
+QMediaResource::~QMediaResource()
+{
+}
+
+
+/*!
+    Compares a media resource to \a other.
+
+    Returns true if the resources are identical, and false otherwise.
+    \since 1.0
+*/
+bool QMediaResource::operator ==(const QMediaResource &other) const
+{
+    // Compare requests directly as QNetworkRequests are "custom types".
+    foreach (int key, values.keys()) {
+        switch (key) {
+        case Request:
+            if (request() != other.request())
+                return false;
+        break;
+        default:
+            if (values.value(key) != other.values.value(key))
+                return false;
+        }
+    }
+    return true;
+}
+
+/*!
+    Compares a media resource to \a other.
+
+    Returns true if they are different, and false otherwise.
+    \since 1.0
+*/
+bool QMediaResource::operator !=(const QMediaResource &other) const
+{
+    return !(*this == other);
+}
+
+/*!
+    Identifies if a media resource is null.
+
+    Returns true if the resource is null, and false otherwise.
+    \since 1.0
+*/
+bool QMediaResource::isNull() const
+{
+    return values.isEmpty();
+}
+
+/*!
+    Returns the URL of a media resource.
+    \since 1.0
+*/
+QUrl QMediaResource::url() const
+{
+    return qvariant_cast<QUrl>(values.value(Url));
+}
+
+/*!
+    Returns the network request associated with this media resource.
+    \since 1.0
+*/
+QNetworkRequest QMediaResource::request() const
+{
+    if(values.contains(Request))
+        return qvariant_cast<QNetworkRequest>(values.value(Request));
+
+    return QNetworkRequest(url());
+}
+
+/*!
+    Returns the MIME type of a media resource.
+
+    This may be null if the MIME type is unknown.
+    \since 1.0
+*/
+QString QMediaResource::mimeType() const
+{
+    return qvariant_cast<QString>(values.value(MimeType));
+}
+
+/*!
+    Returns the language of a media resource as an ISO 639-2 code.
+
+    This may be null if the language is unknown.
+    \since 1.0
+*/
+QString QMediaResource::language() const
+{
+    return qvariant_cast<QString>(values.value(Language));
+}
+
+/*!
+    Sets the \a language of a media resource.
+    \since 1.0
+*/
+void QMediaResource::setLanguage(const QString &language)
+{
+    if (!language.isNull())
+        values.insert(Language, language);
+    else
+        values.remove(Language);
+}
+
+/*!
+    Returns the audio codec of a media resource.
+
+    This may be null if the media resource does not contain an audio stream, or the codec is
+    unknown.
+    \since 1.0
+*/
+QString QMediaResource::audioCodec() const
+{
+    return qvariant_cast<QString>(values.value(AudioCodec));
+}
+
+/*!
+    Sets the audio \a codec of a media resource.
+    \since 1.0
+*/
+void QMediaResource::setAudioCodec(const QString &codec)
+{
+    if (!codec.isNull())
+        values.insert(AudioCodec, codec);
+    else
+        values.remove(AudioCodec);
+}
+
+/*!
+    Returns the video codec of a media resource.
+
+    This may be null if the media resource does not contain a video stream, or the codec is
+    unknonwn.
+    \since 1.0
+*/
+QString QMediaResource::videoCodec() const
+{
+    return qvariant_cast<QString>(values.value(VideoCodec));
+}
+
+/*!
+    Sets the video \a codec of media resource.
+    \since 1.0
+*/
+void QMediaResource::setVideoCodec(const QString &codec)
+{
+    if (!codec.isNull())
+        values.insert(VideoCodec, codec);
+    else
+        values.remove(VideoCodec);
+}
+
+/*!
+    Returns the size in bytes of a media resource.
+
+    This may be zero if the size is unknown.
+    \since 1.0
+*/
+qint64 QMediaResource::dataSize() const
+{
+    return qvariant_cast<qint64>(values.value(DataSize));
+}
+
+/*!
+    Sets the \a size in bytes of a media resource.
+    \since 1.0
+*/
+void QMediaResource::setDataSize(const qint64 size)
+{
+    if (size != 0)
+        values.insert(DataSize, size);
+    else
+        values.remove(DataSize);
+}
+
+/*!
+    Returns the bit rate in bits per second of a media resource's audio stream.
+
+    This may be zero if the bit rate is unknown, or the resource contains no audio stream.
+    \since 1.0
+*/
+int QMediaResource::audioBitRate() const
+{
+    return values.value(AudioBitRate).toInt();
+}
+
+/*!
+    Sets the bit \a rate in bits per second of a media resource's video stream.
+    \since 1.0
+*/
+void QMediaResource::setAudioBitRate(int rate)
+{
+    if (rate != 0)
+        values.insert(AudioBitRate, rate);
+    else
+        values.remove(AudioBitRate);
+}
+
+/*!
+    Returns the audio sample rate of a media resource.
+
+    This may be zero if the sample size is unknown, or the resource contains no audio stream.
+    \since 1.0
+*/
+int QMediaResource::sampleRate() const
+{
+    return qvariant_cast<int>(values.value(SampleRate));
+}
+
+/*!
+    Sets the audio \a sampleRate of a media resource.
+    \since 1.0
+*/
+void QMediaResource::setSampleRate(int sampleRate)
+{
+    if (sampleRate != 0)
+        values.insert(SampleRate, sampleRate);
+    else
+        values.remove(SampleRate);
+}
+
+/*!
+    Returns the number of audio channels in a media resource.
+
+    This may be zero if the sample size is unknown, or the resource contains no audio stream.
+    \since 1.0
+*/
+int QMediaResource::channelCount() const
+{
+    return qvariant_cast<int>(values.value(ChannelCount));
+}
+
+/*!
+    Sets the number of audio \a channels in a media resource.
+    \since 1.0
+*/
+void QMediaResource::setChannelCount(int channels)
+{
+    if (channels != 0)
+        values.insert(ChannelCount, channels);
+    else
+        values.remove(ChannelCount);
+}
+
+/*!
+    Returns the bit rate in bits per second of a media resource's video stream.
+
+    This may be zero if the bit rate is unknown, or the resource contains no video stream.
+    \since 1.0
+*/
+int QMediaResource::videoBitRate() const
+{
+    return values.value(VideoBitRate).toInt();
+}
+
+/*!
+    Sets the bit \a rate in bits per second of a media resource's video stream.
+    \since 1.0
+*/
+void QMediaResource::setVideoBitRate(int rate)
+{
+    if (rate != 0)
+        values.insert(VideoBitRate, rate);
+    else
+        values.remove(VideoBitRate);
+}
+
+/*!
+    Returns the resolution in pixels of a media resource.
+
+    This may be null is the resolution is unknown, or the resource contains no pixel data (i.e. the
+    resource is an audio stream.
+    \since 1.0
+*/
+QSize QMediaResource::resolution() const
+{
+    return qvariant_cast<QSize>(values.value(Resolution));
+}
+
+/*!
+    Sets the \a resolution in pixels of a media resource.
+    \since 1.0
+*/
+void QMediaResource::setResolution(const QSize &resolution)
+{
+    if (resolution.width() != -1 || resolution.height() != -1)
+        values.insert(Resolution, resolution);
+    else
+        values.remove(Resolution);
+}
+
+/*!
+    Sets the \a width and \a height in pixels of a media resource.
+    \since 1.0
+*/
+void QMediaResource::setResolution(int width, int height)
+{
+    if (width != -1 || height != -1)
+        values.insert(Resolution, QSize(width, height));
+    else
+        values.remove(Resolution);
+}
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qmediaresource.h b/src/multimedia/playback/qmediaresource.h
new file mode 100644
index 0000000..b06c61d
--- /dev/null
+++ b/src/multimedia/playback/qmediaresource.h
@@ -0,0 +1,134 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIARESOURCE_H
+#define QMEDIARESOURCE_H
+
+#include <QtCore/qmap.h>
+#include <QtCore/qmetatype.h>
+#include <QtNetwork/qnetworkrequest.h>
+
+#include <qtmultimediadefs.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class Q_MULTIMEDIA_EXPORT QMediaResource
+{
+public:
+    QMediaResource();
+    QMediaResource(const QUrl &url, const QString &mimeType = QString());
+    QMediaResource(const QNetworkRequest &request, const QString &mimeType = QString());
+    QMediaResource(const QMediaResource &other);
+    QMediaResource &operator =(const QMediaResource &other);
+    ~QMediaResource();
+
+    bool isNull() const;
+
+    bool operator ==(const QMediaResource &other) const;
+    bool operator !=(const QMediaResource &other) const;
+
+    QUrl url() const;
+    QNetworkRequest request() const;
+    QString mimeType() const;
+
+    QString language() const;
+    void setLanguage(const QString &language);
+
+    QString audioCodec() const;
+    void setAudioCodec(const QString &codec);
+
+    QString videoCodec() const;
+    void setVideoCodec(const QString &codec);
+
+    qint64 dataSize() const;
+    void setDataSize(const qint64 size);
+
+    int audioBitRate() const;
+    void setAudioBitRate(int rate);
+
+    int sampleRate() const;
+    void setSampleRate(int frequency);
+
+    int channelCount() const;
+    void setChannelCount(int channels);
+
+    int videoBitRate() const;
+    void setVideoBitRate(int rate);
+
+    QSize resolution() const;
+    void setResolution(const QSize &resolution);
+    void setResolution(int width, int height);
+
+
+private:
+    enum Property
+    {
+        Url,
+        Request,
+        MimeType,
+        Language,
+        AudioCodec,
+        VideoCodec,
+        DataSize,
+        AudioBitRate,
+        VideoBitRate,
+        SampleRate,
+        ChannelCount,
+        Resolution
+    };
+    QMap<int, QVariant> values;
+};
+
+typedef QList<QMediaResource> QMediaResourceList;
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMediaResource)
+Q_DECLARE_METATYPE(QMediaResourceList)
+
+QT_END_HEADER
+
+#endif
diff --git a/src/multimedia/qaudiocapturesource.cpp b/src/multimedia/qaudiocapturesource.cpp
deleted file mode 100644
index 4696171..0000000
--- a/src/multimedia/qaudiocapturesource.cpp
+++ /dev/null
@@ -1,275 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaobject_p.h"
-#include <qaudiocapturesource.h>
-#include "qaudioendpointselector.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QAudioCaptureSource
-    \brief The QAudioCaptureSource class provides an interface to query and select an audio input endpoint.
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-    QAudioCaptureSource provides access to the audio inputs available on your system.
-
-    You can query these inputs and select one to use.
-
-    A typical implementation example:
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio capture source
-
-    The audiocapturesource interface is then used to:
-
-    - Get and Set the audio input to use.
-
-    The capture interface is then used to:
-
-    - Set the destination using setOutputLocation()
-
-    - Set the format parameters using setAudioCodec(),
-
-    - Control the recording using record(),stop()
-
-    \sa QMediaRecorder
-*/
-
-class QAudioCaptureSourcePrivate : public QMediaObjectPrivate
-{
-public:
-    Q_DECLARE_PUBLIC(QAudioCaptureSource)
-
-    void initControls()
-    {
-        Q_Q(QAudioCaptureSource);
-
-        if (service != 0)
-            audioEndpointSelector = qobject_cast<QAudioEndpointSelector*>(service->requestControl(QAudioEndpointSelector_iid));
-
-        if (audioEndpointSelector) {
-            q->connect(audioEndpointSelector, SIGNAL(activeEndpointChanged(const QString&)),
-                       SIGNAL(activeAudioInputChanged(const QString&)));
-            q->connect(audioEndpointSelector, SIGNAL(availableEndpointsChanged()),
-                       SIGNAL(availableAudioInputsChanged()));
-            q->connect(audioEndpointSelector, SIGNAL(availableEndpointsChanged()),
-                       SLOT(statusChanged()));
-            errorState = QtMultimedia::NoError;
-        }
-    }
-
-    QAudioCaptureSourcePrivate():provider(0), audioEndpointSelector(0), errorState(QtMultimedia::ServiceMissingError) {}
-    QMediaServiceProvider *provider;
-    QAudioEndpointSelector   *audioEndpointSelector;
-    QtMultimedia::AvailabilityError errorState;
-};
-
-/*!
-    Construct a QAudioCaptureSource using the QMediaService from \a provider, with \a parent.
-    \since 1.0
-*/
-
-QAudioCaptureSource::QAudioCaptureSource(QObject *parent, QMediaServiceProvider *provider):
-    QMediaObject(*new QAudioCaptureSourcePrivate, parent, provider->requestService(Q_MEDIASERVICE_AUDIOSOURCE))
-{
-    Q_D(QAudioCaptureSource);
-
-    d->provider = provider;
-    d->initControls();
-}
-
-/*!
-    Destroys the audiocapturesource object.
-*/
-
-QAudioCaptureSource::~QAudioCaptureSource()
-{
-    Q_D(QAudioCaptureSource);
-
-    if (d->service && d->audioEndpointSelector)
-        d->service->releaseControl(d->audioEndpointSelector);
-
-    if (d->provider)
-        d->provider->releaseService(d->service);
-}
-
-/*!
-    Returns the error state of the audio capture service.
-    \since 1.0
-*/
-
-QtMultimedia::AvailabilityError QAudioCaptureSource::availabilityError() const
-{
-    Q_D(const QAudioCaptureSource);
-
-    return d->errorState;
-}
-
-/*!
-    Returns true if the audio capture service is available, otherwise returns false.
-    \since 1.0
-*/
-bool QAudioCaptureSource::isAvailable() const
-{
-    Q_D(const QAudioCaptureSource);
-
-    if (d->service != NULL) {
-        if (d->audioEndpointSelector && d->audioEndpointSelector->availableEndpoints().size() > 0)
-            return true;
-    }
-    return false;
-}
-
-
-/*!
-    Returns a list of available audio inputs
-    \since 1.0
-*/
-
-QList<QString> QAudioCaptureSource::audioInputs() const
-{
-    Q_D(const QAudioCaptureSource);
-
-    QList<QString> list;
-    if (d && d->audioEndpointSelector)
-        list <<d->audioEndpointSelector->availableEndpoints();
-
-    return list;
-}
-
-/*!
-    Returns the description of the audio input device with \a name.
-    \since 1.0
-*/
-
-QString QAudioCaptureSource::audioDescription(const QString& name) const
-{
-    Q_D(const QAudioCaptureSource);
-
-    if(d->audioEndpointSelector)
-        return d->audioEndpointSelector->endpointDescription(name);
-    else
-        return QString();
-}
-
-/*!
-    Returns the default audio input name.
-    \since 1.0
-*/
-
-QString QAudioCaptureSource::defaultAudioInput() const
-{
-    Q_D(const QAudioCaptureSource);
-
-    if(d->audioEndpointSelector)
-        return d->audioEndpointSelector->defaultEndpoint();
-    else
-        return QString();
-}
-
-/*!
-    Returns the active audio input name.
-    \since 1.0
-*/
-
-QString QAudioCaptureSource::activeAudioInput() const
-{
-    Q_D(const QAudioCaptureSource);
-
-    if(d->audioEndpointSelector)
-        return d->audioEndpointSelector->activeEndpoint();
-    else
-        return QString();
-}
-
-/*!
-    Set the active audio input to \a name.
-    \since 1.0
-*/
-
-void QAudioCaptureSource::setAudioInput(const QString& name)
-{
-    Q_D(const QAudioCaptureSource);
-
-    if(d->audioEndpointSelector)
-        return d->audioEndpointSelector->setActiveEndpoint(name);
-}
-
-/*!
-    \fn QAudioCaptureSource::activeAudioInputChanged(const QString& name)
-
-    Signal emitted when active audio input changes to \a name.
-    \since 1.0
-*/
-
-/*!
-    \fn QAudioCaptureSource::availableAudioInputsChanged()
-
-    Signal is emitted when the available audio inputs change.
-    \since 1.0
-*/
-
-/*!
-  \internal
-  \since 1.0
-*/
-void QAudioCaptureSource::statusChanged()
-{
-    Q_D(QAudioCaptureSource);
-
-    if (d->audioEndpointSelector) {
-        if (d->audioEndpointSelector->availableEndpoints().size() > 0) {
-            d->errorState = QtMultimedia::NoError;
-            emit availabilityChanged(true);
-        } else {
-            d->errorState = QtMultimedia::BusyError;
-            emit availabilityChanged(false);
-        }
-    } else {
-        d->errorState = QtMultimedia::ServiceMissingError;
-        emit availabilityChanged(false);
-    }
-}
-
-#include "moc_qaudiocapturesource.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qaudiocapturesource.h b/src/multimedia/qaudiocapturesource.h
deleted file mode 100644
index 1571b4e..0000000
--- a/src/multimedia/qaudiocapturesource.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QAUDIOCAPTURESOURCE_H
-#define QAUDIOCAPTURESOURCE_H
-
-#include <QtCore/qstringlist.h>
-#include <QtCore/qpair.h>
-#include <QtCore/qsize.h>
-
-#include <qaudioformat.h>
-
-#include "qmediarecorder.h"
-#include "qmediacontrol.h"
-#include "qmediaobject.h"
-#include "qmediaservice.h"
-
-#include "qmediaserviceprovider.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QAudioCaptureSourcePrivate;
-
-class Q_MULTIMEDIA_EXPORT QAudioCaptureSource : public QMediaObject
-{
-    Q_OBJECT
-
-public:
-    QAudioCaptureSource(QObject *parent = 0, QMediaServiceProvider *service = QMediaServiceProvider::defaultServiceProvider());
-    ~QAudioCaptureSource();
-
-    bool isAvailable() const;
-    QtMultimedia::AvailabilityError availabilityError() const;
-
-    QList<QString> audioInputs() const;
-
-    QString audioDescription(const QString& name) const;
-    QString defaultAudioInput() const;
-    QString activeAudioInput() const;
-
-public Q_SLOTS:
-    void setAudioInput(const QString& name);
-
-Q_SIGNALS:
-    void activeAudioInputChanged(const QString& name);
-    void availableAudioInputsChanged();
-
-private Q_SLOTS:
-    void statusChanged();
-
-private:
-    Q_DECLARE_PRIVATE(QAudioCaptureSource)
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QAUDIOCAPTURESOURCE_H
diff --git a/src/multimedia/qaudioencodercontrol.cpp b/src/multimedia/qaudioencodercontrol.cpp
deleted file mode 100644
index 62fa893..0000000
--- a/src/multimedia/qaudioencodercontrol.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qaudioencodercontrol.h"
-#include <QtCore/qstringlist.h>
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QAudioEncoderControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-    \brief The QAudioEncoderControl class provides access to the settings of a
-    media service that performs audio encoding.
-
-    If a QMediaService supports encoding audio data it will implement
-    QAudioEncoderControl.  This control provides information about the limits
-    of restricted audio encoder options and allows the selection of a set of
-    audio encoder settings as specified in a QAudioEncoderSettings object.
-
-    The functionality provided by this control is exposed to application code through the
-    QMediaRecorder class.
-
-    The interface name of QAudioEncoderControl is \c com.nokia.Qt.QAudioEncoderControl/1.0 as
-    defined in QAudioEncoderControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaRecorder
-*/
-
-/*!
-    \macro QAudioEncoderControl_iid
-
-    \c com.nokia.Qt.AudioEncoderControl/1.0
-
-    Defines the interface name of the QAudioEncoderControl class.
-
-    \relates QAudioEncoderControl
-*/
-
-/*!
-  Create a new audio encode control object with the given \a parent.
-*/
-QAudioEncoderControl::QAudioEncoderControl(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-  Destroys the audio encode control.
-*/
-QAudioEncoderControl::~QAudioEncoderControl()
-{
-}
-
-/*!
-  \fn QAudioEncoderControl::supportedAudioCodecs() const
-
-  Returns the list of supported audio codec names.
-  \since 1.0
-*/
-
-/*!
-  \fn QAudioEncoderControl::codecDescription(const QString &codec) const
-
-  Returns description of audio \a codec.
-  \since 1.0
-*/
-
-/*!
-  \fn QAudioEncoderControl::supportedSampleRates(const QAudioEncoderSettings &settings = QAudioEncoderSettings(),
-                                                 bool *continuous) const
-
-  Returns the list of supported audio sample rates, if known.
-
-  If non null audio \a settings parameter is passed,
-  the returned list is reduced to sample rates supported with partial settings applied.
-
-  It can be used for example to query the list of sample rates, supported by specific audio codec.
-
-  If the encoder supports arbitrary sample rates within the supported rates range,
-  *\a continuous is set to true, otherwise *\a continuous is set to false.
-  \since 1.0
-*/
-
-/*!
-    \fn QAudioEncoderControl::supportedEncodingOptions(const QString &codec) const
-
-    Returns the list of \a codec specific audio encoding options.
-    \since 1.0
-*/
-
-/*!
-    \fn QAudioEncoderControl::encodingOption(const QString &codec, const QString &option) const
-
-    Returns the value of audio encoding \a option for \a codec.
-    \since 1.0
-*/
-
-/*!
-    \fn QAudioEncoderControl::setEncodingOption(const QString &codec, const QString &option, const QVariant &value)
-
-    Set the \a codec specific \a option to \a value.
-    \since 1.0
-*/
-
-/*!
-    \fn QAudioEncoderControl::audioSettings() const
-
-    Returns the audio encoder settings.
-
-    The returned value may be different tha passed to QAudioEncoderControl::setAudioSettings()
-    if the settings contains the default or undefined parameters.
-    In this case if the undefined parameters are already resolved, they should be returned.
-    \since 1.0
-*/
-
-/*!
-    \fn QAudioEncoderControl::setAudioSettings(const QAudioEncoderSettings &settings)
-
-    Sets the selected audio \a settings.
-    \since 1.0
-*/
-
-#include "moc_qaudioencodercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qaudioencodercontrol.h b/src/multimedia/qaudioencodercontrol.h
deleted file mode 100644
index 2e3a4bf..0000000
--- a/src/multimedia/qaudioencodercontrol.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QAUDIOENCODERCONTROL_H
-#define QAUDIOENCODERCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qmediarecorder.h"
-#include <QtCore/qlist.h>
-#include <QtCore/qpair.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QStringList;
-class QAudioFormat;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class Q_MULTIMEDIA_EXPORT QAudioEncoderControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QAudioEncoderControl();
-
-    virtual QStringList supportedAudioCodecs() const = 0;
-    virtual QString codecDescription(const QString &codecName) const = 0;
-
-    virtual QList<int> supportedSampleRates(const QAudioEncoderSettings &settings,
-                                            bool *continuous = 0) const = 0;
-
-    virtual QAudioEncoderSettings audioSettings() const = 0;
-    virtual void setAudioSettings(const QAudioEncoderSettings&) = 0;
-
-    virtual QStringList supportedEncodingOptions(const QString &codec) const = 0;
-    virtual QVariant encodingOption(const QString &codec, const QString &name) const = 0;
-    virtual void setEncodingOption(
-            const QString &codec, const QString &name, const QVariant &value) = 0;
-
-protected:
-    QAudioEncoderControl(QObject *parent = 0);
-};
-
-#define QAudioEncoderControl_iid "com.nokia.Qt.QAudioEncoderControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QAudioEncoderControl, QAudioEncoderControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QAUDIOCAPTUREPROPERTIESCONTROL_H
diff --git a/src/multimedia/qaudioendpointselector.cpp b/src/multimedia/qaudioendpointselector.cpp
deleted file mode 100644
index ba02c8d..0000000
--- a/src/multimedia/qaudioendpointselector.cpp
+++ /dev/null
@@ -1,140 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qaudioendpointselector.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QAudioEndpointSelector
-
-    \brief The QAudioEndpointSelector class provides an audio endpoint selector media control.
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-    The QAudioEndpointSelector class provides descriptions of the audio
-    endpoints available on a system and allows one to be selected as the audio
-    of a media service.
-
-    The interface name of QAudioEndpointSelector is \c com.nokia.Qt.QAudioEndpointSelector/1.0 as
-    defined in QAudioEndpointSelector_iid.
-
-    \sa QMediaService::requestControl()
-*/
-
-/*!
-    \macro QAudioEndpointSelector_iid
-
-    \c com.nokia.Qt.QAudioEndpointSelector/1.0
-
-    Defines the interface name of the QAudioEndpointSelector class.
-
-    \relates QAudioEndpointSelector
-*/
-
-/*!
-    Constructs a new audio endpoint selector with the given \a parent.
-*/
-QAudioEndpointSelector::QAudioEndpointSelector(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys an audio endpoint selector.
-*/
-QAudioEndpointSelector::~QAudioEndpointSelector()
-{
-}
-
-/*!
-    \fn QList<QString> QAudioEndpointSelector::availableEndpoints() const
-
-    Returns a list of the names of the available audio endpoints.
-    \since 1.0
-*/
-
-/*!
-    \fn QString QAudioEndpointSelector::endpointDescription(const QString& name) const
-
-    Returns the description of the endpoint \a name.
-    \since 1.0
-*/
-
-/*!
-    \fn QString QAudioEndpointSelector::defaultEndpoint() const
-
-    Returns the name of the default audio endpoint.
-    \since 1.0
-*/
-
-/*!
-    \fn QString QAudioEndpointSelector::activeEndpoint() const
-
-    Returns the name of the currently selected audio endpoint.
-    \since 1.0
-*/
-
-/*!
-    \fn QAudioEndpointSelector::setActiveEndpoint(const QString& name)
-
-    Set the active audio endpoint to \a name.
-    \since 1.0
-*/
-
-/*!
-    \fn QAudioEndpointSelector::activeEndpointChanged(const QString& name)
-
-    Signals that the audio endpoint has changed to \a name.
-    \since 1.0
-*/
-
-/*!
-    \fn QAudioEndpointSelector::availableEndpointsChanged()
-
-    Signals that list of available endpoints has changed.
-    \since 1.0
-*/
-
-#include "moc_qaudioendpointselector.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qaudioendpointselector.h b/src/multimedia/qaudioendpointselector.h
deleted file mode 100644
index 00250bc..0000000
--- a/src/multimedia/qaudioendpointselector.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QAUDIOENDPOINTSELECTOR_H
-#define QAUDIOENDPOINTSELECTOR_H
-
-#include <qaudio.h>
-#include <qmediacontrol.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QAudioEndpointSelector : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QAudioEndpointSelector();
-
-    virtual QList<QString> availableEndpoints() const = 0;
-    virtual QString endpointDescription(const QString& name) const = 0;
-    virtual QString defaultEndpoint() const = 0;
-    virtual QString activeEndpoint() const = 0;
-
-public Q_SLOTS:
-    virtual void setActiveEndpoint(const QString& name) = 0;
-
-Q_SIGNALS:
-    void activeEndpointChanged(const QString& name);
-    void availableEndpointsChanged();
-
-protected:
-    QAudioEndpointSelector(QObject *parent = 0);
-};
-
-#define QAudioEndpointSelector_iid "com.nokia.Qt.QAudioEndpointSelector/1.0"
-Q_MEDIA_DECLARE_CONTROL(QAudioEndpointSelector, QAudioEndpointSelector_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QAUDIOENDPOINTSELECTOR_H
diff --git a/src/multimedia/qcamera.cpp b/src/multimedia/qcamera.cpp
deleted file mode 100644
index 8ba3aa6..0000000
--- a/src/multimedia/qcamera.cpp
+++ /dev/null
@@ -1,1035 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qvideosurfaceoutput_p.h"
-#include "qmediaobject_p.h"
-
-#include <qcamera.h>
-#include <qcameracontrol.h>
-#include <qcameralockscontrol.h>
-#include <qcameraexposurecontrol.h>
-#include <qcamerafocuscontrol.h>
-#include <qmediarecordercontrol.h>
-#include <qcameraimageprocessingcontrol.h>
-#include <qcameraimagecapturecontrol.h>
-#include <qvideodevicecontrol.h>
-
-#include <QDebug>
-
-namespace
-{
-class CameraRegisterMetaTypes
-{
-public:
-    CameraRegisterMetaTypes()
-    {
-        qRegisterMetaType<QCamera::Error>("QCamera::Error");
-        qRegisterMetaType<QCamera::State>("QCamera::State");
-        qRegisterMetaType<QCamera::Status>("QCamera::Status");
-        qRegisterMetaType<QCamera::CaptureMode>("QCamera::CaptureMode");
-        qRegisterMetaType<QCamera::LockType>("QCamera::LockType");
-        qRegisterMetaType<QCamera::LockStatus>("QCamera::LockStatus");
-        qRegisterMetaType<QCamera::LockChangeReason>("QCamera::LockChangeReason");
-    }
-} _registerCameraMetaTypes;
-}
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCamera
-
-
-    \brief The QCamera class provides interface for system camera devices.
-
-    \inmodule QtMultimedia
-    \ingroup camera
-    \since 1.1
-
-    QCamera can be used with QVideoWidget for viewfinder display,
-    QMediaRecorder for video recording and QCameraImageCapture for image taking.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Request control
-
-*/
-
-
-class QCameraPrivate : public QMediaObjectPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QCamera)
-public:
-    QCameraPrivate():
-        QMediaObjectPrivate(),
-        provider(0),
-        control(0),
-        deviceControl(0),
-        viewfinder(0),
-        capture(0),
-        state(QCamera::UnloadedState),
-        error(QCamera::NoError),
-        supportedLocks(QCamera::NoLock),
-        requestedLocks(QCamera::NoLock),
-        lockStatus(QCamera::Unlocked),
-        lockChangeReason(QCamera::UserRequest),
-        supressLockChangedSignal(false),
-        restartPending(false)
-    {
-    }
-
-    void initControls();
-
-    QMediaServiceProvider *provider;
-
-    QCameraControl *control;
-    QVideoDeviceControl *deviceControl;
-    QCameraLocksControl *locksControl;
-
-    QCameraExposure *cameraExposure;
-    QCameraFocus *cameraFocus;
-    QCameraImageProcessing *imageProcessing;
-
-    QObject *viewfinder;
-    QObject *capture;
-
-    QCamera::State state;
-
-    QCamera::Error error;
-    QString errorString;
-
-    QCamera::LockTypes supportedLocks;
-    QCamera::LockTypes requestedLocks;
-
-    QCamera::LockStatus lockStatus;
-    QCamera::LockChangeReason lockChangeReason;
-    bool supressLockChangedSignal;
-
-    bool restartPending;
-
-    QVideoSurfaceOutput surfaceViewfinder;
-
-    void _q_error(int error, const QString &errorString);
-    void unsetError() { error = QCamera::NoError; errorString.clear(); }
-
-    void setState(QCamera::State);
-
-    void _q_updateLockStatus(QCamera::LockType, QCamera::LockStatus, QCamera::LockChangeReason);
-    void _q_updateState(QCamera::State newState);
-    void _q_preparePropertyChange(int changeType);
-    void _q_restartCamera();
-    void updateLockStatus();
-};
-
-
-void QCameraPrivate::_q_error(int error, const QString &errorString)
-{
-    Q_Q(QCamera);
-
-    this->error = QCamera::Error(error);
-    this->errorString = errorString;
-
-    qWarning() << "Camera error:" << errorString;
-
-    emit q->error(this->error);
-}
-
-void QCameraPrivate::setState(QCamera::State newState)
-{
-    Q_Q(QCamera);
-
-    unsetError();
-
-    if (!control) {
-        _q_error(QCamera::ServiceMissingError, q_ptr->tr("The camera service is missing"));
-        return;
-    }
-
-    if (state == newState)
-        return;
-
-    restartPending = false;
-    state = newState;
-    control->setState(state);
-    emit q->stateChanged(state);
-}
-
-void QCameraPrivate::_q_updateState(QCamera::State newState)
-{
-    Q_Q(QCamera);
-
-    //omit changins state to Loaded when the camera is temporarily
-    //stopped to apply shanges
-    if (restartPending)
-        return;
-
-    if (newState != state) {
-        qDebug() << "Camera state changed:" << newState;
-        state = newState;
-        emit q->stateChanged(state);
-    }
-}
-
-void QCameraPrivate::_q_preparePropertyChange(int changeType)
-{
-    if (!control)
-        return;
-
-    QCamera::Status status = control->status();
-
-    //all the changes are allowed until the camera is starting
-    if (control->state() != QCamera::ActiveState)
-        return;
-
-    if (control->canChangeProperty(QCameraControl::PropertyChangeType(changeType), status))
-        return;
-
-    restartPending = true;
-    control->setState(QCamera::LoadedState);
-    QMetaObject::invokeMethod(q_ptr, "_q_restartCamera", Qt::QueuedConnection);
-}
-
-void QCameraPrivate::_q_restartCamera()
-{
-    if (restartPending) {
-        restartPending = false;
-        control->setState(QCamera::ActiveState);
-    }
-}
-
-void QCameraPrivate::initControls()
-{
-    Q_Q(QCamera);
-
-    supportedLocks = 0;
-
-    if (service) {
-        control = qobject_cast<QCameraControl *>(service->requestControl(QCameraControl_iid));
-        locksControl = qobject_cast<QCameraLocksControl *>(service->requestControl(QCameraLocksControl_iid));
-        deviceControl = qobject_cast<QVideoDeviceControl*>(service->requestControl(QVideoDeviceControl_iid));
-
-        if (control) {
-            q->connect(control, SIGNAL(stateChanged(QCamera::State)), q, SLOT(_q_updateState(QCamera::State)));
-            q->connect(control, SIGNAL(statusChanged(QCamera::Status)), q, SIGNAL(statusChanged(QCamera::Status)));
-            q->connect(control, SIGNAL(captureModeChanged(QCamera::CaptureMode)),
-                       q, SIGNAL(captureModeChanged(QCamera::CaptureMode)));
-            q->connect(control, SIGNAL(error(int,QString)), q, SLOT(_q_error(int,QString)));
-
-        }
-
-        if (locksControl) {
-            q->connect(locksControl, SIGNAL(lockStatusChanged(QCamera::LockType,QCamera::LockStatus,QCamera::LockChangeReason)),
-                       q, SLOT(_q_updateLockStatus(QCamera::LockType,QCamera::LockStatus,QCamera::LockChangeReason)));
-            supportedLocks = locksControl->supportedLocks();
-        }
-
-        error = QCamera::NoError;
-    } else {
-        control = 0;
-        locksControl = 0;
-        deviceControl = 0;
-
-        error = QCamera::ServiceMissingError;
-        errorString = QCamera::tr("The camera service is missing");
-    }
-}
-
-void QCameraPrivate::updateLockStatus()
-{
-    Q_Q(QCamera);
-
-    QCamera::LockStatus oldStatus = lockStatus;
-
-    QMap<QCamera::LockStatus, int> lockStatusPriority;
-    lockStatusPriority.insert(QCamera::Locked, 1);
-    lockStatusPriority.insert(QCamera::Searching, 2);
-    lockStatusPriority.insert(QCamera::Unlocked, 3);
-
-    lockStatus = requestedLocks ? QCamera::Locked : QCamera::Unlocked;
-    int priority = 0;
-
-    QList<QCamera::LockStatus> lockStatuses;
-
-    if (requestedLocks & QCamera::LockFocus)
-        lockStatuses << q->lockStatus(QCamera::LockFocus);
-
-    if (requestedLocks & QCamera::LockExposure)
-        lockStatuses << q->lockStatus(QCamera::LockExposure);
-
-    if (requestedLocks & QCamera::LockWhiteBalance)
-        lockStatuses << q->lockStatus(QCamera::LockWhiteBalance);
-
-
-    foreach (QCamera::LockStatus currentStatus, lockStatuses) {
-        int currentPriority = lockStatusPriority.value(currentStatus, -1);
-        if (currentPriority > priority) {
-            priority = currentPriority;
-            lockStatus = currentStatus;
-        }
-    }
-
-    if (!supressLockChangedSignal && oldStatus != lockStatus) {
-        emit q->lockStatusChanged(lockStatus, lockChangeReason);
-
-        if (lockStatus == QCamera::Locked)
-            emit q->locked();
-        else if (lockStatus == QCamera::Unlocked && lockChangeReason == QCamera::LockFailed)
-            emit q->lockFailed();
-    }
-/*
-    qDebug() << "Requested locks:" << (requestedLocks & QCamera::LockExposure ? 'e' : ' ')
-            << (requestedLocks & QCamera::LockFocus ? 'f' : ' ')
-            << (requestedLocks & QCamera::LockWhiteBalance ? 'w' : ' ');
-    qDebug() << "Lock status: f:" << q->lockStatus(QCamera::LockFocus)
-             << " e:" << q->lockStatus(QCamera::LockExposure)
-             << " w:" << q->lockStatus(QCamera::LockWhiteBalance)
-             << " composite:" << lockStatus;
-*/
-}
-
-void QCameraPrivate::_q_updateLockStatus(QCamera::LockType type, QCamera::LockStatus status, QCamera::LockChangeReason reason)
-{
-    Q_Q(QCamera);
-    lockChangeReason = reason;
-    updateLockStatus();
-    emit q->lockStatusChanged(type, status, reason);
-}
-
-
-/*!
-    Construct a QCamera from service \a provider and \a parent.
-*/
-
-QCamera::QCamera(QObject *parent, QMediaServiceProvider *provider):
-    QMediaObject(*new QCameraPrivate, parent, provider->requestService(Q_MEDIASERVICE_CAMERA))
-{
-    Q_D(QCamera);
-    d->provider = provider;
-    d->initControls();
-    d->cameraExposure = new QCameraExposure(this);
-    d->cameraFocus = new QCameraFocus(this);
-    d->imageProcessing = new QCameraImageProcessing(this);
-}
-
-/*!
-    Construct a QCamera from device name \a device and \a parent.
-*/
-
-QCamera::QCamera(const QByteArray& device, QObject *parent):
-    QMediaObject(*new QCameraPrivate, parent,
-                  QMediaServiceProvider::defaultServiceProvider()->requestService(Q_MEDIASERVICE_CAMERA, QMediaServiceProviderHint(device)))
-{
-    Q_D(QCamera);
-    d->provider = QMediaServiceProvider::defaultServiceProvider();
-    d->initControls();
-
-    if (d->service != 0) {
-        //pass device name to service
-        if (d->deviceControl) {
-            QString deviceName = QString::fromLatin1(device);
-
-            for (int i=0; i<d->deviceControl->deviceCount(); i++) {
-                if (d->deviceControl->deviceName(i) == deviceName) {
-                    d->deviceControl->setSelectedDevice(i);
-                    break;
-                }
-            }
-        }
-    }
-
-    d->cameraExposure = new QCameraExposure(this);
-    d->cameraFocus = new QCameraFocus(this);
-    d->imageProcessing = new QCameraImageProcessing(this);
-}
-
-/*!
-    Destroys the camera object.
-*/
-
-QCamera::~QCamera()
-{
-    Q_D(QCamera);
-    delete d->cameraExposure;
-    d->cameraExposure = 0;
-    delete d->cameraFocus;
-    d->cameraFocus = 0;
-    delete d->imageProcessing;
-    d->imageProcessing = 0;
-
-    if (d->service) {
-        if (d->control)
-            d->service->releaseControl(d->control);
-        if (d->locksControl)
-            d->service->releaseControl(d->locksControl);
-        if (d->deviceControl)
-            d->service->releaseControl(d->deviceControl);
-
-        d->provider->releaseService(d->service);
-    }
-}
-
-
-/*!
-    Return true if the camera service is ready to use.
-    \since 1.1
-*/
-bool QCamera::isAvailable() const
-{
-    return availabilityError() == QtMultimedia::NoError;
-}
-
-/*!
-    Returns the error state of the camera service.
-    \since 1.1
-*/
-
-QtMultimedia::AvailabilityError QCamera::availabilityError() const
-{
-    Q_D(const QCamera);
-    if (d->control == NULL)
-        return QtMultimedia::ServiceMissingError;
-
-    if (d->deviceControl && d->deviceControl->deviceCount() == 0)
-        return QtMultimedia::ResourceError;
-
-    if (d->error != QCamera::NoError)
-        return QtMultimedia::ResourceError;
-
-    return QtMultimedia::NoError;
-}
-
-
-/*!
-    Returns the camera exposure control object.
-    \since 1.1
-*/
-QCameraExposure *QCamera::exposure() const
-{
-    return d_func()->cameraExposure;
-}
-
-/*!
-    Returns the camera focus control object.
-    \since 1.1
-*/
-QCameraFocus *QCamera::focus() const
-{
-    return d_func()->cameraFocus;
-}
-
-/*!
-    Returns the camera image processing control object.
-    \since 1.1
-*/
-QCameraImageProcessing *QCamera::imageProcessing() const
-{
-    return d_func()->imageProcessing;
-}
-
-/*!
-  Sets the QVideoWidget based camera \a viewfinder.
-  The previously set viewfinder is detached.
-  \since 1.1
-*/
-
-// QVideoWidget is forward declared
-void QCamera::setViewfinder(QVideoWidget *viewfinder)
-{
-    Q_D(QCamera);
-    d->_q_preparePropertyChange(QCameraControl::Viewfinder);
-
-    if (d->viewfinder)
-        unbind(d->viewfinder);
-
-    // We don't know (in this library) that QVideoWidget inherits QObject
-    QObject *viewFinderObject = reinterpret_cast<QObject*>(viewfinder);
-
-    d->viewfinder = viewFinderObject && bind(viewFinderObject) ? viewFinderObject : 0;
-}
-
-/*!
-  Sets the QGraphicsVideoItem based camera \a viewfinder.
-  The previously set viewfinder is detached.
-  \since 1.1
-*/
-// QGraphicsVideoItem is forward declared
-void QCamera::setViewfinder(QGraphicsVideoItem *viewfinder)
-{
-    Q_D(QCamera);
-    d->_q_preparePropertyChange(QCameraControl::Viewfinder);
-
-    if (d->viewfinder)
-        unbind(d->viewfinder);
-
-    // We don't know (in this library) that QGraphicsVideoItem (multiply) inherits QObject
-    // but QObject inheritance depends on QObject coming first, so try this out.
-    QObject *viewFinderObject = reinterpret_cast<QObject*>(viewfinder);
-
-    d->viewfinder = viewFinderObject && bind(viewFinderObject) ? viewFinderObject : 0;
-}
-
-/*!
-    Sets a video \a surface as the viewfinder of a camera.
-
-    If a viewfinder has already been set on the camera the new surface
-    will replace it.
-    \since 1.2
-*/
-
-void QCamera::setViewfinder(QAbstractVideoSurface *surface)
-{
-    Q_D(QCamera);
-
-    d->surfaceViewfinder.setVideoSurface(surface);
-
-    if (d->viewfinder != &d->surfaceViewfinder) {
-        if (d->viewfinder)
-            unbind(d->viewfinder);
-
-        d->viewfinder = bind(&d->surfaceViewfinder) ? &d->surfaceViewfinder : 0;
-    }
-}
-
-/*!
-    Returns the error state of the object.
-    \since 1.1
-*/
-
-QCamera::Error QCamera::error() const
-{
-    return d_func()->error;
-}
-
-/*!
-    Returns a string describing a camera's error state.
-    \since 1.1
-*/
-QString QCamera::errorString() const
-{
-    return d_func()->errorString;
-}
-
-
-/*!
-    Returns true if the capture \a mode is suported.
-    \since 1.1
-*/
-bool QCamera::isCaptureModeSupported(QCamera::CaptureMode mode) const
-{
-    return d_func()->control ? d_func()->control->isCaptureModeSupported(mode) : false;
-}
-
-/*!
-  \property QCamera::captureMode
-
-  The type of media (video or still images),
-  the camera is configured to capture.
-
-  It's allowed to change capture mode in any camera state,
-  but if the camera is currently active,
-  chaging capture mode is likely to lead to camera status
-  chaged to QCamera::LoadedStatus, QCamera::LoadingStatus,
-  and when the camera is ready to QCamera::ActiveStatus.
-  \since 1.1
-*/
-
-QCamera::CaptureMode QCamera::captureMode() const
-{
-    return d_func()->control ? d_func()->control->captureMode() : QCamera::CaptureStillImage;
-}
-
-void QCamera::setCaptureMode(QCamera::CaptureMode mode)
-{
-    Q_D(QCamera);
-
-    if (mode != captureMode()) {
-        if (d->control) {
-            d->_q_preparePropertyChange(QCameraControl::CaptureMode);
-            d->control->setCaptureMode(mode);
-        }
-    }
-}
-
-
-/*!
-    Starts the camera.
-
-    State is changed to QCamera::ActiveState if camera is started
-    successfully, otherwise error() signal is emitted.
-
-    While the camera state is changed to QCamera::ActiveState,
-    starting the camera service can be asynchronous with the actual
-    status reported with QCamera::status property.
-    \since 1.1
-*/
-void QCamera::start()
-{
-    Q_D(QCamera);
-    d->setState(QCamera::ActiveState);
-}
-
-/*!
-    Stops the camera.
-    The camera state is changed from QCamera::ActiveState to QCamera::LoadedState.
-    \since 1.1
-*/
-void QCamera::stop()
-{
-    Q_D(QCamera);
-    d->setState(QCamera::LoadedState);
-}
-
-/*!
-    Open the camera device.
-    The camera state is changed to QCamera::LoadedStatus.
-
-    It's not necessary to explcitly load the camera,
-    unless unless the application have to read the supported camera
-    settings and change the default depending on the camera capabilities.
-
-    In all the other cases it's possible to start the camera directly
-    from unloaded state.
-    \since 1.1
-*/
-void QCamera::load()
-{
-    Q_D(QCamera);
-    d->setState(QCamera::LoadedState);
-}
-
-/*!
-    Close the camera device and deallocate the related resources.
-    The camera state is changed to QCamera::UnloadedStatus.
-    \since 1.1
-*/
-void QCamera::unload()
-{
-    Q_D(QCamera);
-    d->setState(QCamera::UnloadedState);
-}
-
-
-/*!
-    Returns a list of camera device's available from the default service provider.
-    \since 1.1
-*/
-
-QList<QByteArray> QCamera::availableDevices()
-{
-    return QMediaServiceProvider::defaultServiceProvider()->devices(QByteArray(Q_MEDIASERVICE_CAMERA));
-}
-
-/*!
-    Returns the description of the \a device.
-    \since 1.1
-*/
-
-QString QCamera::deviceDescription(const QByteArray &device)
-{
-    return QMediaServiceProvider::defaultServiceProvider()->deviceDescription(QByteArray(Q_MEDIASERVICE_CAMERA), device);
-}
-
-QCamera::State QCamera::state() const
-{
-    return d_func()->state;
-}
-
-QCamera::Status QCamera::status() const
-{
-    if(d_func()->control)
-        return (QCamera::Status)d_func()->control->status();
-
-    return QCamera::UnavailableStatus;
-}
-
-
-/*!
-    Returns the lock types, camera supports.
-    \since 1.1
-*/
-QCamera::LockTypes QCamera::supportedLocks() const
-{
-    return d_func()->supportedLocks;
-}
-
-/*!
-    Returns the requested lock types.
-    \since 1.1
-*/
-QCamera::LockTypes QCamera::requestedLocks() const
-{
-    return d_func()->requestedLocks;
-}
-
-/*!
-    Returns the status of requested camera settings locks.
-    \since 1.1
-*/
-QCamera::LockStatus QCamera::lockStatus() const
-{
-    return d_func()->lockStatus;
-}
-
-/*!
-    Returns the status of camera settings \a lock.
-    \since 1.1
-*/
-QCamera::LockStatus QCamera::lockStatus(QCamera::LockType lockType) const
-{
-    const QCameraPrivate *d = d_func();
-
-    if (!(lockType & d->supportedLocks))
-        return lockType & d->requestedLocks ? QCamera::Locked : QCamera::Unlocked;
-
-    if (!(lockType & d->requestedLocks))
-        return QCamera::Unlocked;
-
-    if (d->locksControl)
-        return d->locksControl->lockStatus(lockType);
-
-    return QCamera::Unlocked;
-}
-
-/*!
-    \fn void QCamera::searchAndLock(QCamera::LockTypes locks)
-
-    Locks the camera settings with the requested \a locks, including focusing in the single autofocus mode,
-    exposure and white balance if the exposure and white balance modes are not manual.
-
-    The camera settings are usually locked before taking one or multiple still images,
-    in responce to the shutter button being half pressed.
-
-    The QCamera::locked() signal is emitted when camera settings are successfully locked,
-    otherwise QCamera::lockFailed() is emitted.
-
-    QCamera also emits lockStatusChanged(QCamera::LockType, QCamera::LockStatus)
-    on individual lock status changes and lockStatusChanged(QCamera::LockStatus) signal on composite status changes.
-
-    Locking serves two roles: it initializes calculation of automatic parameter
-    (focusing, calculating the correct exposure and white balance) and allows
-    to keep some or all of those parameters during number of shots.
-
-    If the camera doesn't support keeping one of parameters between shots, the related
-    lock state changes to QCamera::Unlocked.
-
-    It's also acceptable to relock already locked settings,
-    depending on the lock parameter this initiates new focusing, exposure or white balance calculation.
-    \since 1.1
- */
-void QCamera::searchAndLock(QCamera::LockTypes locks)
-{
-    Q_D(QCamera);
-
-    QCamera::LockStatus oldStatus = d->lockStatus;
-    d->supressLockChangedSignal = true;
-
-    d->requestedLocks |= locks;
-
-    locks &= d->supportedLocks;
-
-    if (d->locksControl)
-        d->locksControl->searchAndLock(locks);
-
-    d->supressLockChangedSignal = false;
-
-    d->lockStatus = oldStatus;
-    d->updateLockStatus();
-}
-
-/*!
-    Lock all the supported camera settings.
-    \since 1.1
- */
-void QCamera::searchAndLock()
-{
-    searchAndLock(LockExposure | LockWhiteBalance | LockFocus);
-}
-
-/*!
-    Unlocks the camera settings specified with \a locks or cancel the current locking if one is active.
-    \since 1.1
- */
-void QCamera::unlock(QCamera::LockTypes locks)
-{
-    Q_D(QCamera);
-
-    QCamera::LockStatus oldStatus = d->lockStatus;
-    d->supressLockChangedSignal = true;
-
-    d->requestedLocks &= ~locks;
-
-    locks &= d->supportedLocks;
-
-    if (d->locksControl)
-        d->locksControl->unlock(locks);
-
-    d->supressLockChangedSignal = false;
-
-    d->lockStatus = oldStatus;
-    d->updateLockStatus();
-}
-
-/*!
-    Unlock all the requested camera locks.
-    \since 1.1
- */
-void QCamera::unlock()
-{
-    unlock(d_func()->requestedLocks);
-}
-
-
-/*!
-    \enum QCamera::State
-    \value UnloadedState
-           The initial camera state, with camera not loaded,
-           the camera capabilities except of supported capture modes
-           are unknown.
-
-           While the supported settings are unknown in this state,
-           it's allowed to set the camera capture settings like codec,
-           resolution, or frame rate.
-
-    \value LoadedState
-           The camera is loaded and ready to be configured.
-
-           In the Idle state it's allowed to query camera capabilities,
-           set capture resolution, codecs, etc.
-
-           The viewfinder is not active in the loaded state.
-
-    \value ActiveState
-           In the active state as soon as camera is started
-           the viewfinder displays video frames and the
-           camera is ready for capture.
-*/
-
-
-/*!
-    \property QCamera::state
-    \brief The current state of the camera object.
-    \since 1.1
-*/
-
-/*!
-    \enum QCamera::Status
-    \value ActiveStatus
-           The camera has been started and can produce data.
-           The viewfinder displays video frames in active state.
-
-           Depending on backend, changing some camera settings like
-           capture mode, codecs or resolution in ActiveState may lead
-           to changing the camera status to LoadedStatus and StartingStatus while
-           the settings are applied and back to ActiveStatus when the camera is ready.
-
-    \value StartingStatus
-           The camera is starting in result of state transition to QCamera::ActiveState.
-           The camera service is not ready to capture yet.
-
-    \value StandbyStatus
-           The camera is in the power saving standby mode.
-           The camera may come to the standby mode after some time of inactivity
-           in the QCamera::LoadedState state.
-
-    \value LoadedStatus
-           The camera is loaded and ready to be configured.
-           This status indicates the camera device is opened and
-           it's possible to query for supported image and video capture settings,
-           like resolution, framerate and codecs.
-
-    \value LoadingStatus
-           The camera device loading in result of state transition from
-           QCamera::UnloadedState to QCamera::LoadedState or QCamera::ActiveState.
-
-    \value UnloadedStatus
-           The initial camera status, with camera not loaded.
-           The camera capabilities including supported capture settings may be unknown.
-
-    \value UnavailableStatus
-           The camera or camera backend is not available.
-*/
-
-
-/*!
-    \property QCamera::status
-    \brief The current status of the camera object.
-    \since 1.1
-*/
-
-
-/*!
-    \enum QCamera::CaptureMode
-    \value CaptureStillImage Camera is configured for still frames capture.
-    \value CaptureVideo  Camera is configured for video capture.
-    \since 1.1
-*/
-
-/*!
-    \enum QCamera::LockType
-
-    \value NoLock
-    \value LockExposure
-        Lock camera exposure.
-    \value LockWhiteBalance
-        Lock the white balance.
-    \value LockFocus
-        Lock camera focus.
-*/
-
-
-/*!
-    \property QCamera::lockStatus
-    \brief The overall status for all the requested camera locks.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCamera::locked()
-
-    Signals all the requested camera settings are locked.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCamera::lockFailed()
-
-    Signals locking of at least one requested camera settings failed.
-    \since 1.1
-*/
-
-/*!
-    \fn QCamera::lockStatusChanged(QCamera::LockStatus status, QCamera::LockChangeReason reason)
-
-    Signals the overall \a status for all the requested camera locks was changed with specified \a reason.
-    \since 1.1
-*/
-
-/*!
-    \fn QCamera::lockStatusChanged(QCamera::LockType lock, QCamera::LockStatus status, QCamera::LockChangeReason reason)
-    Signals the \a lock \a status was changed with specified \a reason.
-    \since 1.1
-*/
-
-/*!
-  \enum QCamera::LockStatus
-    \value Unlocked
-        The application is not interested in camera settings value.
-        The camera may keep this parameter without changes, this is common with camera focus,
-        or adjust exposure and white balance constantly to keep the viewfinder image nice.
-
-    \value Searching
-        The application has requested the camera focus, exposure or white balance lock with
-        QCamera::searchAndLock(). This state indicates the camera is focusing or calculating exposure and white balance.
-
-    \value Locked
-        The camera focus, exposure or white balance is locked.
-        The camera is ready to capture, application may check the exposure parameters.
-
-        The locked state usually means the requested parameter stays the same,
-        except of the cases when the parameter is requested to be constantly updated.
-        For example in continuous focusing mode, the focus is considered locked as long
-        and the object is in focus, even while the actual focusing distance may be constantly changing.
-*/
-
-/*!
-    \enum QCamera::LockChangeReason
-
-    \value UserRequest
-        The lock status changed in result of user request, usually to unlock camera settings.
-    \value LockAcquired
-        The lock status successfuly changed to QCamera::Locked.
-    \value LockFailed
-        The camera failed to acquire the requested lock in result of
-        autofocus failure, exposure out of supported range, etc.
-    \value LockLost
-        The camera is not able to maintain the requested lock any more.
-        Lock status is changed to QCamera::Unlocked.
-    \value LockTemporaryLost
-        The lock is lost, but the camera is working hard to reacquire it.
-        This value may be used in continuous focusing mode,
-        when the camera loses the focus, the focus lock state is changed to Qcamera::Searching
-        with LockTemporaryLost reason.
-*/
-
-/*!
-    \enum QCamera::Error
-
-    \value  NoError      No errors have occurred.
-    \value  CameraError  An error has occurred.
-    \value  InvalidRequestError System resource doesn't support requested functionality.
-    \value  ServiceMissingError No camera service available.
-    \value  NotSupportedFeatureError The feature is not supported.
-*/
-
-/*!
-    \fn void QCamera::error(QCamera::Error value)
-
-    Signal emitted when error state changes to \a value.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCamera::captureModeChanged(QCamera::CaptureMode mode)
-
-    Signals the capture \a mode has changed.
-    \since 1.1
-*/
-
-/*!
-  \fn QCamera::stateChanged(QCamera::State state)
-
-  Signals the camera \a state has changed.
-
-  Usually the state changes is caused by calling
-  load(), unload(), start() and stop(),
-  but the state can also be changed change as a result of camera error.
-    \since 1.1
-*/
-
-/*!
-  \fn QCamera::statusChanged(QCamera::Status status)
-
-  Signals the camera \a status has changed.
-
-  \since 1.1
-*/
-
-QT_END_NAMESPACE
-
-#include "moc_qcamera.cpp"
diff --git a/src/multimedia/qcamera.h b/src/multimedia/qcamera.h
deleted file mode 100644
index da009e1..0000000
--- a/src/multimedia/qcamera.h
+++ /dev/null
@@ -1,238 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERA_H
-#define QCAMERA_H
-
-#include <QtCore/qstringlist.h>
-#include <QtCore/qpair.h>
-#include <QtCore/qsize.h>
-#include <QtCore/qpoint.h>
-#include <QtCore/qrect.h>
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-#include <qmediaservice.h>
-
-#include <qcameraexposure.h>
-#include <qcamerafocus.h>
-#include <qcameraimageprocessing.h>
-
-#include <qmediaserviceprovider.h>
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QAbstractVideoSurface;
-class QVideoWidget;
-class QGraphicsVideoItem;
-
-class QCameraPrivate;
-class Q_MULTIMEDIA_EXPORT QCamera : public QMediaObject
-{
-    Q_OBJECT
-    Q_PROPERTY(QCamera::State state READ state NOTIFY stateChanged)
-    Q_PROPERTY(QCamera::Status status READ status NOTIFY statusChanged)
-    Q_PROPERTY(QCamera::CaptureMode captureMode READ captureMode WRITE setCaptureMode NOTIFY captureModeChanged)
-    Q_PROPERTY(QCamera::LockStatus lockStatus READ lockStatus NOTIFY lockStatusChanged)
-
-    Q_ENUMS(Status)
-    Q_ENUMS(State)
-    Q_ENUMS(CaptureMode)
-    Q_ENUMS(Error)
-    Q_ENUMS(LockStatus)
-    Q_ENUMS(LockChangeReason)
-    Q_ENUMS(LockType)
-public:
-    enum Status {
-        UnavailableStatus,
-        UnloadedStatus,
-        LoadingStatus,
-        LoadedStatus,
-        StandbyStatus,
-        StartingStatus,
-        ActiveStatus
-    };
-
-    enum State {
-        UnloadedState,
-        LoadedState,
-        ActiveState
-    };
-
-    enum CaptureMode
-    {
-        CaptureStillImage,
-        CaptureVideo
-    };
-
-    enum Error
-    {
-        NoError,
-        CameraError,
-        InvalidRequestError,
-        ServiceMissingError,
-        NotSupportedFeatureError
-    };
-
-    enum LockStatus
-    {
-        Unlocked,
-        Searching,
-        Locked
-    };
-
-    enum LockChangeReason {
-        UserRequest,
-        LockAcquired,
-        LockFailed,
-        LockLost,
-        LockTemporaryLost
-    };
-
-    enum LockType
-    {
-        NoLock = 0,
-        LockExposure = 0x01,
-        LockWhiteBalance = 0x02,
-        LockFocus = 0x04
-    };
-    Q_DECLARE_FLAGS(LockTypes, LockType)
-
-    QCamera(QObject *parent = 0, QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider());
-    QCamera(const QByteArray& device, QObject *parent = 0);
-    ~QCamera();
-
-    static QList<QByteArray> availableDevices();
-    static QString deviceDescription(const QByteArray &device);
-
-    bool isAvailable() const;
-    QtMultimedia::AvailabilityError availabilityError() const;
-
-    State state() const;
-    Status status() const;
-
-    CaptureMode captureMode() const;
-    bool isCaptureModeSupported(CaptureMode mode) const;
-
-    QCameraExposure *exposure() const;
-    QCameraFocus *focus() const;
-    QCameraImageProcessing *imageProcessing() const;
-
-    void setViewfinder(QVideoWidget *viewfinder);
-    void setViewfinder(QGraphicsVideoItem *viewfinder);
-    void setViewfinder(QAbstractVideoSurface *surface);
-
-    Error error() const;
-    QString errorString() const;
-
-    QCamera::LockTypes supportedLocks() const;
-    QCamera::LockTypes requestedLocks() const;
-
-    QCamera::LockStatus lockStatus() const;
-    QCamera::LockStatus lockStatus(QCamera::LockType lock) const;
-
-public Q_SLOTS:
-    void setCaptureMode(QCamera::CaptureMode mode);
-
-    void load();
-    void unload();
-
-    void start();
-    void stop();
-
-    void searchAndLock();
-    void unlock();
-
-    void searchAndLock(QCamera::LockTypes locks);
-    void unlock(QCamera::LockTypes locks);
-
-Q_SIGNALS:
-    void stateChanged(QCamera::State);
-    void captureModeChanged(QCamera::CaptureMode);
-    void statusChanged(QCamera::Status);
-
-    void locked();
-    void lockFailed();
-
-    void lockStatusChanged(QCamera::LockStatus, QCamera::LockChangeReason);
-    void lockStatusChanged(QCamera::LockType, QCamera::LockStatus, QCamera::LockChangeReason);
-
-    void error(QCamera::Error);
-
-private:
-    Q_DISABLE_COPY(QCamera)
-    Q_DECLARE_PRIVATE(QCamera)
-    Q_PRIVATE_SLOT(d_func(), void _q_preparePropertyChange(int))
-    Q_PRIVATE_SLOT(d_func(), void _q_restartCamera())
-    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
-    Q_PRIVATE_SLOT(d_func(), void _q_updateLockStatus(QCamera::LockType, QCamera::LockStatus, QCamera::LockChangeReason))
-    Q_PRIVATE_SLOT(d_func(), void _q_updateState(QCamera::State))
-};
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(QCamera::LockTypes)
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QCamera::State)
-Q_DECLARE_METATYPE(QCamera::Status)
-Q_DECLARE_METATYPE(QCamera::Error)
-Q_DECLARE_METATYPE(QCamera::CaptureMode)
-Q_DECLARE_METATYPE(QCamera::LockType)
-Q_DECLARE_METATYPE(QCamera::LockStatus)
-Q_DECLARE_METATYPE(QCamera::LockChangeReason)
-
-Q_MEDIA_ENUM_DEBUG(QCamera, State)
-Q_MEDIA_ENUM_DEBUG(QCamera, Status)
-Q_MEDIA_ENUM_DEBUG(QCamera, Error)
-Q_MEDIA_ENUM_DEBUG(QCamera, CaptureMode)
-Q_MEDIA_ENUM_DEBUG(QCamera, LockType)
-Q_MEDIA_ENUM_DEBUG(QCamera, LockStatus)
-Q_MEDIA_ENUM_DEBUG(QCamera, LockChangeReason)
-
-QT_END_HEADER
-
-#endif  // QCAMERA_H
diff --git a/src/multimedia/qcameracapturebufferformatcontrol.cpp b/src/multimedia/qcameracapturebufferformatcontrol.cpp
deleted file mode 100644
index 536c8b3..0000000
--- a/src/multimedia/qcameracapturebufferformatcontrol.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcameracapturebufferformatcontrol.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraCaptureBufferFormatControl
-
-    \brief The QCameraCaptureBufferFormatControl class provides a control for setting the capture buffer format.
-
-    The format is of type QVideoFrame::PixelFormat.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-
-    The interface name of QCameraCaptureBufferFormatControl is \c com.nokia.Qt.QCameraCaptureBufferFormatControl/1.0 as
-    defined in QCameraCaptureBufferFormatControl_iid.
-
-    \sa QMediaService::requestControl()
-*/
-
-/*!
-    \macro QCameraCaptureBufferFormatControl_iid
-
-    \c com.nokia.Qt.QCameraCaptureBufferFormatControl/1.0
-
-    Defines the interface name of the QCameraCaptureBufferFormatControl class.
-
-    \relates QCameraCaptureBufferFormatControl
-*/
-
-/*!
-    Constructs a new image buffer capture format control object with the given \a parent
-*/
-QCameraCaptureBufferFormatControl::QCameraCaptureBufferFormatControl(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys an image buffer capture format control.
-*/
-QCameraCaptureBufferFormatControl::~QCameraCaptureBufferFormatControl()
-{
-}
-
-/*!
-    \fn QCameraCaptureBufferFormatControl::supportedBufferFormats() const
-
-    Returns the list of the supported buffer capture formats.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraCaptureBufferFormatControl::bufferFormat() const
-
-    Returns the current buffer capture format.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraCaptureBufferFormatControl::setBufferFormat(QVideoFrame::PixelFormat format)
-
-    Sets the buffer capture \a format.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraCaptureBufferFormatControl::bufferFormatChanged(QVideoFrame::PixelFormat format)
-
-    Signals the buffer image capture format changed to \a format.
-    \since 1.2
-*/
-
-#include "moc_qcameracapturebufferformatcontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qcameracapturebufferformatcontrol.h b/src/multimedia/qcameracapturebufferformatcontrol.h
deleted file mode 100644
index 81079a7..0000000
--- a/src/multimedia/qcameracapturebufferformatcontrol.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERACAPTUREBUFFERFORMATCONTROL_H
-#define QCAMERACAPTUREBUFFERFORMATCONTROL_H
-
-#include <qmediacontrol.h>
-#include <qcameraimagecapture.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QCameraCaptureBufferFormatControl : public QMediaControl
-{
-    Q_OBJECT
-public:
-    ~QCameraCaptureBufferFormatControl();
-
-    virtual QList<QVideoFrame::PixelFormat> supportedBufferFormats() const = 0;
-    virtual QVideoFrame::PixelFormat bufferFormat() const = 0;
-    virtual void setBufferFormat(QVideoFrame::PixelFormat format) = 0;
-
-Q_SIGNALS:
-    void bufferFormatChanged(QVideoFrame::PixelFormat);
-
-protected:
-    QCameraCaptureBufferFormatControl(QObject* parent = 0);
-};
-
-#define QCameraCaptureBufferFormatControl_iid "com.nokia.Qt.QCameraCaptureBufferFormatControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraCaptureBufferFormatControl, QCameraCaptureBufferFormatControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
-
diff --git a/src/multimedia/qcameracapturedestinationcontrol.cpp b/src/multimedia/qcameracapturedestinationcontrol.cpp
deleted file mode 100644
index 5072ae7..0000000
--- a/src/multimedia/qcameracapturedestinationcontrol.cpp
+++ /dev/null
@@ -1,121 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcameracapturedestinationcontrol.h>
-#include <QtCore/qstringlist.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraCaptureDestinationControl
-
-    \brief The QCameraCaptureDestinationControl class provides a control for setting capture destination.
-
-    Depending on backend capabilities capture to file, buffer or both can be supported.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-
-
-
-    The interface name of QCameraCaptureDestinationControl is \c com.nokia.Qt.QCameraCaptureDestinationControl/1.0 as
-    defined in QCameraCaptureDestinationControl_iid.
-
-
-    \sa QMediaService::requestControl()
-*/
-
-/*!
-    \macro QCameraCaptureDestinationControl_iid
-
-    \c com.nokia.Qt.QCameraCaptureDestinationControl/1.0
-
-    Defines the interface name of the QCameraCaptureDestinationControl class.
-
-    \relates QCameraCaptureDestinationControl
-*/
-
-/*!
-    Constructs a new image capture destination control object with the given \a parent
-*/
-QCameraCaptureDestinationControl::QCameraCaptureDestinationControl(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys an image capture destination control.
-*/
-QCameraCaptureDestinationControl::~QCameraCaptureDestinationControl()
-{
-}
-
-/*!
-    \fn QCameraCaptureDestinationControl::isCaptureDestinationSupported(QCameraImageCapture::CaptureDestinations destination) const
-
-    Returns true if the capture \a destination is supported; and false if it is not.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraCaptureDestinationControl::captureDestination() const
-
-    Returns the current capture \a destination. The default destination is QCameraImageCapture::CaptureToFile.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraCaptureDestinationControl::setCaptureDestination(QCameraImageCapture::CaptureDestinations destination)
-
-    Sets the capture \a destination.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraCaptureDestinationControl::captureDestinationChanged(QCameraImageCapture::CaptureDestinations destination)
-
-    Signals the image capture \a destination changed.
-    \since 1.2
-*/
-
-#include "moc_qcameracapturedestinationcontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qcameracapturedestinationcontrol.h b/src/multimedia/qcameracapturedestinationcontrol.h
deleted file mode 100644
index cdd769a..0000000
--- a/src/multimedia/qcameracapturedestinationcontrol.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERACAPTUREDESTINATIONCONTROL_H
-#define QCAMERACAPTUREDESTINATIONCONTROL_H
-
-#include <qmediacontrol.h>
-#include <qcameraimagecapture.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QCameraCaptureDestinationControl : public QMediaControl
-{
-    Q_OBJECT
-public:
-    ~QCameraCaptureDestinationControl();
-
-    virtual bool isCaptureDestinationSupported(QCameraImageCapture::CaptureDestinations destination) const = 0;
-    virtual QCameraImageCapture::CaptureDestinations captureDestination() const = 0;
-    virtual void setCaptureDestination(QCameraImageCapture::CaptureDestinations destination) = 0;
-
-Q_SIGNALS:
-    void captureDestinationChanged(QCameraImageCapture::CaptureDestinations);
-
-protected:
-    QCameraCaptureDestinationControl(QObject* parent = 0);
-};
-
-#define QCameraCaptureDestinationControl_iid "com.nokia.Qt.QCameraCaptureDestinationControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraCaptureDestinationControl, QCameraCaptureDestinationControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
-
diff --git a/src/multimedia/qcameracontrol.cpp b/src/multimedia/qcameracontrol.cpp
deleted file mode 100644
index df5c44c..0000000
--- a/src/multimedia/qcameracontrol.cpp
+++ /dev/null
@@ -1,215 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcameracontrol.h>
-#include  "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraControl
-
-
-
-    \brief The QCameraControl class is an abstract base class for
-    classes that control still cameras or video cameras.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.1
-
-    This service is provided by a QMediaService object via
-    QMediaService::control().  It is used by QCamera.
-
-    The interface name of QCameraControl is \c com.nokia.Qt.QCameraControl/1.0 as
-    defined in QCameraControl_iid.
-
-
-
-    \sa QMediaService::requestControl(), QCamera
-*/
-
-/*!
-    \macro QCameraControl_iid
-
-    \c com.nokia.Qt.QCameraControl/1.0
-
-    Defines the interface name of the QCameraControl class.
-
-    \relates QCameraControl
-*/
-
-/*!
-    Constructs a camera control object with \a parent.
-*/
-
-QCameraControl::QCameraControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destruct the camera control object.
-*/
-
-QCameraControl::~QCameraControl()
-{
-}
-
-/*!
-    \fn QCameraControl::state() const
-
-    Returns the state of the camera service.
-
-    \since 1.1
-    \sa QCamera::state
-*/
-
-/*!
-    \fn QCameraControl::setState(QCamera::State state)
-
-    Sets the camera \a state.
-
-    State changes are synchronous and indicate user intention,
-    while camera status is used as a feedback mechanism to inform application about backend status.
-    Status changes are reported asynchronously with QCameraControl::statusChanged() signal.
-
-    \since 1.1
-    \sa QCamera::State
-*/
-
-/*!
-    \fn void QCameraControl::stateChanged(QCamera::State state)
-
-    Signal emitted when the camera \a state changes.
-
-    In most cases the state chage is caused by QCameraControl::setState(),
-    but if critical error has occurred the state changes to QCamera::UnloadedState.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraControl::status() const
-
-    Returns the status of the camera service.
-
-    \since 1.1
-    \sa QCamera::state
-*/
-
-/*!
-    \fn void QCameraControl::statusChanged(QCamera::Status status)
-
-    Signal emitted when the camera \a status changes.
-    \since 1.1
-*/
-
-
-/*!
-    \fn void QCameraControl::error(int error, const QString &errorString)
-
-    Signal emitted when an error occurs with error code \a error and
-    a description of the error \a errorString.
-    \since 1.1
-*/
-
-/*!
-    \fn Camera::CaptureMode QCameraControl::captureMode() const = 0
-
-    Returns the current capture mode.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraControl::setCaptureMode(QCamera::CaptureMode mode) = 0;
-
-    Sets the current capture \a mode.
-
-    The capture mode changes are synchronous and allowed in any camera state.
-
-    If the capture mode is changed while camera is active,
-    it's recommended to change status to QCamera::LoadedStatus
-    and start activating the camera in the next event loop
-    with the status changed to QCamera::StartingStatus.
-    This allows the capture settings to be applied before camera is started.
-    Than change the status to QCamera::StartedStatus when the capture mode change is done.
-    \since 1.1
-*/
-
-/*!
-    \fn bool QCameraControl::isCaptureModeSupported(QCamera::CaptureMode mode) const = 0;
-
-    Returns true if the capture \a mode is suported.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraControl::captureModeChanged(QCamera::CaptureMode mode)
-
-    Signal emitted when the camera capture \a mode changes.
-    \since 1.1
- */
-
-/*!
-    \fn bool QCameraControl::canChangeProperty(PropertyChangeType changeType, QCamera::Status status) const
-
-    Returns true if backend can effectively apply changing camera properties of \a changeType type
-    while the camera state is QCamera::Active and camera status matches \a status parameter.
-
-    If backend doesn't support applying this change in the active state, it will be stopped
-    before the settings are changed and restarted after.
-    Otherwise the backend should apply the change in the current state,
-    with the camera status indicating the progress, if necessary.
-    \since 1.1
-*/
-
-/*!
-  \enum QCameraControl::PropertyChangeType
-
-  \value CaptureMode Indicates the capture mode is changed.
-  \value ImageEncodingSettings Image encoder settings are changed, including resolution.
-  \value VideoEncodingSettings
-        Video encoder settings are changed, including audio, video and container settings.
-  \value Viewfinder Viewfinder is changed.
-*/
-
-#include "moc_qcameracontrol.cpp"
-QT_END_NAMESPACE
diff --git a/src/multimedia/qcameracontrol.h b/src/multimedia/qcameracontrol.h
deleted file mode 100644
index dfc2b37..0000000
--- a/src/multimedia/qcameracontrol.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERACONTROL_H
-#define QCAMERACONTROL_H
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-
-#include <qcamera.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QCameraControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    enum PropertyChangeType {
-        CaptureMode = 1,
-        ImageEncodingSettings = 2,
-        VideoEncodingSettings = 3,
-        Viewfinder = 4
-    };
-
-    ~QCameraControl();
-
-    virtual QCamera::State state() const = 0;
-    virtual void setState(QCamera::State state) = 0;
-
-    virtual QCamera::Status status() const = 0;
-
-    virtual QCamera::CaptureMode captureMode() const = 0;
-    virtual void setCaptureMode(QCamera::CaptureMode) = 0;
-    virtual bool isCaptureModeSupported(QCamera::CaptureMode mode) const = 0;
-
-    virtual bool canChangeProperty(PropertyChangeType changeType, QCamera::Status status) const = 0;
-
-Q_SIGNALS:
-    void stateChanged(QCamera::State);
-    void statusChanged(QCamera::Status);
-    void error(int error, const QString &errorString);
-    void captureModeChanged(QCamera::CaptureMode);
-
-protected:
-    QCameraControl(QObject* parent = 0);
-};
-
-#define QCameraControl_iid "com.nokia.Qt.QCameraControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraControl, QCameraControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QCAMERACONTROL_H
-
diff --git a/src/multimedia/qcameraexposure.cpp b/src/multimedia/qcameraexposure.cpp
deleted file mode 100644
index 5c75ad9..0000000
--- a/src/multimedia/qcameraexposure.cpp
+++ /dev/null
@@ -1,646 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qcameraexposure.h"
-#include "qmediaobject_p.h"
-
-#include <qcamera.h>
-#include <qcameraexposurecontrol.h>
-#include <qcameraflashcontrol.h>
-
-#include <QtCore/QMetaObject>
-#include <QtCore/QDebug>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraExposure
-
-
-    \brief The QCameraExposure class provides interface for exposure related camera settings.
-
-    \inmodule QtMultimedia
-    \ingroup camera
-    \since 1.1
-
-*/
-
-//#define DEBUG_EXPOSURE_CHANGES 1
-
-#ifdef DEBUG_EXPOSURE_CHANGES
-#define ENUM_NAME(c,e,v) (c::staticMetaObject.enumerator(c::staticMetaObject.indexOfEnumerator(e)).valueToKey((v)))
-#endif
-
-namespace
-{
-class CameraExposureRegisterMetaTypes
-{
-public:
-    CameraExposureRegisterMetaTypes()
-    {
-        qRegisterMetaType<QCameraExposure::ExposureMode>("QCameraExposure::ExposureMode");
-        qRegisterMetaType<QCameraExposure::FlashModes>("QCameraExposure::FlashModes");
-        qRegisterMetaType<QCameraExposure::MeteringMode>("QCameraExposure::MeteringMode");
-    }
-} _registerCameraExposureMetaTypes;
-}
-
-
-
-class QCameraExposurePrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QCameraExposure)
-public:
-    void initControls();
-    QCameraExposure *q_ptr;
-
-    QCamera *camera;
-    QCameraExposureControl *exposureControl;
-    QCameraFlashControl *flashControl;
-
-    void _q_exposureParameterChanged(int parameter);
-    void _q_exposureParameterRangeChanged(int parameter);
-};
-
-void QCameraExposurePrivate::initControls()
-{
-    Q_Q(QCameraExposure);
-
-    QMediaService *service = camera->service();
-    exposureControl = 0;
-    flashControl = 0;
-    if (service) {
-        exposureControl = qobject_cast<QCameraExposureControl *>(service->requestControl(QCameraExposureControl_iid));
-        flashControl = qobject_cast<QCameraFlashControl *>(service->requestControl(QCameraFlashControl_iid));
-    }
-    if (exposureControl) {
-        q->connect(exposureControl, SIGNAL(exposureParameterChanged(int)),
-                   q, SLOT(_q_exposureParameterChanged(int)));
-        q->connect(exposureControl, SIGNAL(exposureParameterRangeChanged(int)),
-                   q, SLOT(_q_exposureParameterRangeChanged(int)));
-    }
-
-    if (flashControl)
-        q->connect(flashControl, SIGNAL(flashReady(bool)), q, SIGNAL(flashReady(bool)));
-}
-
-void QCameraExposurePrivate::_q_exposureParameterChanged(int parameter)
-{
-    Q_Q(QCameraExposure);
-
-#if DEBUG_EXPOSURE_CHANGES
-    qDebug() << "Exposure parameter changed:"
-             << ENUM_NAME(QCameraExposureControl, "ExposureParameter", parameter)
-             << exposureControl->exposureParameter(QCameraExposureControl::ExposureParameter(parameter));
-#endif
-
-    switch (parameter) {
-    case QCameraExposureControl::ISO:
-        emit q->isoSensitivityChanged(q->isoSensitivity());
-        break;
-    case QCameraExposureControl::Aperture:
-        emit q->apertureChanged(q->aperture());
-        break;
-    case QCameraExposureControl::ShutterSpeed:
-        emit q->shutterSpeedChanged(q->shutterSpeed());
-        break;
-    case QCameraExposureControl::ExposureCompensation:
-        emit q->exposureCompensationChanged(q->exposureCompensation());
-        break;
-    }
-}
-
-void QCameraExposurePrivate::_q_exposureParameterRangeChanged(int parameter)
-{
-    Q_Q(QCameraExposure);
-
-    switch (parameter) {
-    case QCameraExposureControl::Aperture:
-        emit q->apertureRangeChanged();
-        break;
-    case QCameraExposureControl::ShutterSpeed:
-        emit q->shutterSpeedRangeChanged();
-        break;
-    }
-}
-
-/*!
-    Construct a QCameraExposure from service \a provider and \a parent.
-*/
-
-QCameraExposure::QCameraExposure(QCamera *parent):
-    QObject(parent), d_ptr(new QCameraExposurePrivate)
-{
-    Q_D(QCameraExposure);
-    d->camera = parent;
-    d->q_ptr = this;
-    d->initControls();
-}
-
-
-/*!
-    Destroys the camera exposure object.
-*/
-
-QCameraExposure::~QCameraExposure()
-{
-    Q_D(QCameraExposure);
-    if (d->exposureControl)
-        d->camera->service()->releaseControl(d->exposureControl);
-}
-
-/*!
-    Returns true if exposure settings are supported by this camera.
-    \since 1.1
-*/
-bool QCameraExposure::isAvailable() const
-{
-    return d_func()->exposureControl != 0;
-}
-
-
-/*!
-  \property QCameraExposure::flashMode
-  \brief The flash mode being used.
-
-  Usually the single QCameraExposure::FlashMode flag is used,
-  but some non conflicting flags combination are also allowed,
-  like QCameraExposure::FlashManual | QCameraExposure::FlashSlowSyncRearCurtain.
-
-  \since 1.1
-  \sa QCameraExposure::isFlashModeSupported(), QCameraExposure::isFlashReady()
-*/
-
-QCameraExposure::FlashModes QCameraExposure::flashMode() const
-{
-    return d_func()->flashControl ? d_func()->flashControl->flashMode() : QCameraExposure::FlashOff;
-}
-
-void QCameraExposure::setFlashMode(QCameraExposure::FlashModes mode)
-{
-    if (d_func()->flashControl)
-        d_func()->flashControl->setFlashMode(mode);
-}
-
-/*!
-    Returns true if the flash \a mode is supported.
-    \since 1.1
-*/
-
-bool QCameraExposure::isFlashModeSupported(QCameraExposure::FlashModes mode) const
-{
-    return d_func()->flashControl ? d_func()->flashControl->isFlashModeSupported(mode) : false;
-}
-
-/*!
-    Returns true if flash is charged.
-*/
-
-bool QCameraExposure::isFlashReady() const
-{
-    return d_func()->flashControl ? d_func()->flashControl->isFlashReady() : false;
-}
-
-
-/*!
-  \property QCameraExposure::exposureMode
-  \brief The exposure mode being used.
-
-  \since 1.1
-  \sa QCameraExposure::isExposureModeSupported()
-*/
-
-QCameraExposure::ExposureMode QCameraExposure::exposureMode() const
-{
-    return d_func()->exposureControl ? d_func()->exposureControl->exposureMode() : QCameraExposure::ExposureAuto;
-}
-
-void QCameraExposure::setExposureMode(QCameraExposure::ExposureMode mode)
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setExposureMode(mode);
-}
-
-/*!
-    Returns true if the exposure \a mode is supported.
-    \since 1.1
-*/
-
-bool QCameraExposure::isExposureModeSupported(QCameraExposure::ExposureMode mode) const
-{
-    return d_func()->exposureControl ?
-            d_func()->exposureControl->isExposureModeSupported(mode) : false;
-}
-
-/*!
-  \property QCameraExposure::exposureCompensation
-  \brief Exposure compensation in EV units.
-
-  Exposure compensation property allows to adjust the automatically calculated exposure.
-  \since 1.1
-*/
-
-qreal QCameraExposure::exposureCompensation() const
-{
-    if (d_func()->exposureControl)
-        return d_func()->exposureControl->exposureParameter(QCameraExposureControl::ExposureCompensation).toReal();
-    else
-        return 0;
-}
-
-void QCameraExposure::setExposureCompensation(qreal ev)
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ExposureCompensation, QVariant(ev));
-}
-
-/*!
-  \property QCameraExposure::meteringMode
-  \brief The metering mode being used.
-
-  \since 1.1
-  \sa QCameraExposure::isMeteringModeSupported()
-*/
-
-QCameraExposure::MeteringMode QCameraExposure::meteringMode() const
-{
-    return d_func()->exposureControl ? d_func()->exposureControl->meteringMode() : QCameraExposure::MeteringMatrix;
-}
-
-void QCameraExposure::setMeteringMode(QCameraExposure::MeteringMode mode)
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setMeteringMode(mode);
-}
-
-/*!
-    Returns true if the metering \a mode is supported.
-    \since 1.1
-*/
-bool QCameraExposure::isMeteringModeSupported(QCameraExposure::MeteringMode mode) const
-{
-    return d_func()->exposureControl ? d_func()->exposureControl->isMeteringModeSupported(mode) : false;
-}
-
-int QCameraExposure::isoSensitivity() const
-{
-    if (d_func()->exposureControl)
-        return d_func()->exposureControl->exposureParameter(QCameraExposureControl::ISO).toInt();
-
-    return -1;
-}
-
-/*!
-    Returns the list of ISO senitivities camera supports.
-
-    If the camera supports arbitrary ISO sensitivities within the supported range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-    \since 1.1
-*/
-QList<int> QCameraExposure::supportedIsoSensitivities(bool *continuous) const
-{
-    QList<int> res;
-    QCameraExposureControl *control = d_func()->exposureControl;
-
-    if (!control)
-        return res;
-
-    foreach (const QVariant &value,
-             control->supportedParameterRange(QCameraExposureControl::ISO)) {
-        bool ok = false;
-        int intValue = value.toInt(&ok);
-        if (ok)
-            res.append(intValue);
-        else
-            qWarning() << "Incompatible ISO value type, int is expected";
-    }
-
-    if (continuous)
-        *continuous = control->exposureParameterFlags(QCameraExposureControl::ISO) &
-                      QCameraExposureControl::ContinuousRange;
-
-    return res;
-}
-
-/*!
-    \fn QCameraExposure::setManualIsoSensitivity(int iso)
-    Sets the manual sensitivity to \a iso
-    \since 1.1
-*/
-
-void QCameraExposure::setManualIsoSensitivity(int iso)
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ISO, QVariant(iso));
-}
-
-/*!
-     \fn QCameraExposure::setAutoIsoSensitivity()
-     Turn on auto sensitivity
-    \since 1.1
-*/
-
-void QCameraExposure::setAutoIsoSensitivity()
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ISO, QVariant());
-}
-
-/*!
-    \property QCameraExposure::shutterSpeed
-    \brief Camera's shutter speed in seconds.
-
-    \since 1.1
-    \sa supportedShutterSpeeds(), setAutoShutterSpeed(), setManualShutterSpeed()
-*/
-
-/*!
-    \fn QCameraExposure::shutterSpeedChanged(qreal speed)
-
-    Signals that a camera's shutter \a speed has changed.
-    \since 1.1
-*/
-
-/*!
-    \property QCameraExposure::isoSensitivity
-    \brief The sensor ISO sensitivity.
-
-    \sa supportedIsoSensitivities(), setAutoIsoSensitivity(), setManualIsoSensitivity()
-    \since 1.1
-*/
-
-/*!
-    \property QCameraExposure::aperture
-    \brief Lens aperture is specified as an F number, the ratio of the focal length to effective aperture diameter.
-
-    \since 1.1
-    \sa supportedApertures(), setAutoAperture(), setManualAperture()
-*/
-
-
-qreal QCameraExposure::aperture() const
-{
-    if (d_func()->exposureControl)
-        return d_func()->exposureControl->exposureParameter(QCameraExposureControl::Aperture).toReal();
-
-    return -1.0;
-}
-
-/*!
-    Returns the list of aperture values camera supports.
-    The apertures list can change depending on the focal length,
-    in such a case the apertureRangeChanged() signal is emitted.
-
-    If the camera supports arbitrary aperture values within the supported range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-    \since 1.1
-*/
-QList<qreal> QCameraExposure::supportedApertures(bool * continuous) const
-{
-    QList<qreal> res;
-    QCameraExposureControl *control = d_func()->exposureControl;
-
-    if (!control)
-        return res;
-
-    foreach (const QVariant &value,
-             control->supportedParameterRange(QCameraExposureControl::Aperture)) {
-        bool ok = false;
-        qreal realValue = value.toReal(&ok);
-        if (ok)
-            res.append(realValue);
-        else
-            qWarning() << "Incompatible aperture value type, qreal is expected";
-    }
-
-    if (continuous)
-        *continuous = control->exposureParameterFlags(QCameraExposureControl::Aperture) &
-                      QCameraExposureControl::ContinuousRange;
-
-    return res;
-}
-
-/*!
-    \fn QCameraExposure::setManualAperture(qreal aperture)
-    Sets the manual camera \a aperture value.
-    \since 1.1
-*/
-
-void QCameraExposure::setManualAperture(qreal aperture)
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::Aperture, QVariant(aperture));
-}
-
-/*!
-    \fn QCameraExposure::setAutoAperture()
-    Turn on auto aperture
-    \since 1.1
-*/
-
-void QCameraExposure::setAutoAperture()
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::Aperture, QVariant());
-}
-
-/*!
-    Returns the current shutter speed in seconds.
-    \since 1.1
-*/
-
-qreal QCameraExposure::shutterSpeed() const
-{
-    if (d_func()->exposureControl)
-        return d_func()->exposureControl->exposureParameter(QCameraExposureControl::ShutterSpeed).toReal();
-
-    return -1.0;
-}
-
-/*!
-    Returns the list of shutter speed values in seconds camera supports.
-
-    If the camera supports arbitrary shutter speed values within the supported range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-    \since 1.1
-*/
-QList<qreal> QCameraExposure::supportedShutterSpeeds(bool *continuous) const
-{
-    QList<qreal> res;
-
-    QCameraExposureControl *control = d_func()->exposureControl;
-    if (!control)
-        return res;
-
-    foreach (const QVariant &value,
-             control->supportedParameterRange(QCameraExposureControl::ShutterSpeed)) {
-        bool ok = false;
-        qreal realValue = value.toReal(&ok);
-        if (ok)
-            res.append(realValue);
-        else
-            qWarning() << "Incompatible shutter speed value type, qreal is expected";
-    }
-
-    if (continuous)
-        *continuous = control->exposureParameterFlags(QCameraExposureControl::ShutterSpeed) &
-                      QCameraExposureControl::ContinuousRange;
-
-    return res;
-}
-
-/*!
-    Set the manual shutter speed to \a seconds
-    \since 1.1
-*/
-
-void QCameraExposure::setManualShutterSpeed(qreal seconds)
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ShutterSpeed, QVariant(seconds));
-}
-
-/*!
-    Turn on auto shutter speed
-    \since 1.1
-*/
-
-void QCameraExposure::setAutoShutterSpeed()
-{
-    if (d_func()->exposureControl)
-        d_func()->exposureControl->setExposureParameter(QCameraExposureControl::ShutterSpeed, QVariant());
-}
-
-
-/*!
-    \enum QCameraExposure::FlashMode
-
-    \value FlashOff             Flash is Off.
-    \value FlashOn              Flash is On.
-    \value FlashAuto            Automatic flash.
-    \value FlashRedEyeReduction Red eye reduction flash.
-    \value FlashFill            Use flash to fillin shadows.
-    \value FlashTorch           Constant light source, useful for focusing and video capture.
-    \value FlashSlowSyncFrontCurtain
-                                Use the flash in conjunction with a slow shutter speed.
-                                This mode allows better exposure of distant objects and/or motion blur effect.
-    \value FlashSlowSyncRearCurtain
-                                The similar mode to FlashSlowSyncFrontCurtain but flash is fired at the end of exposure.
-    \value FlashManual          Flash power is manualy set.
-*/
-
-/*!
-    \enum QCameraExposure::ExposureMode
-
-    \value ExposureManual        Manual mode.
-    \value ExposureAuto          Automatic mode.
-    \value ExposureNight         Night mode.
-    \value ExposureBacklight     Backlight exposure mode.
-    \value ExposureSpotlight     Spotlight exposure mode.
-    \value ExposureSports        Spots exposure mode.
-    \value ExposureSnow          Snow exposure mode.
-    \value ExposureBeach         Beach exposure mode.
-    \value ExposureLargeAperture Use larger aperture with small depth of field.
-    \value ExposureSmallAperture Use smaller aperture.
-    \value ExposurePortrait      Portrait exposure mode.
-    \value ExposureModeVendor    The base value for device specific exposure modes.
-*/
-
-/*!
-    \enum QCameraExposure::MeteringMode
-
-    \value MeteringAverage       Center weighted average metering mode.
-    \value MeteringSpot          Spot metering mode.
-    \value MeteringMatrix        Matrix metering mode.
-*/
-
-/*!
-    \property QCameraExposure::flashReady
-    \brief Indicates if the flash is charged and ready to use.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraExposure::flashReady(bool ready)
-
-    Signal the flash \a ready status has changed.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraExposure::apertureChanged(qreal value)
-
-    Signal emitted when aperature changes to \a value.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraExposure::apertureRangeChanged()
-
-    Signal emitted when aperature range has changed.
-    \since 1.1
-*/
-
-
-/*!
-    \fn void QCameraExposure::shutterSpeedRangeChanged()
-
-    Signal emitted when the shutter speed range has changed.
-    \since 1.1
-*/
-
-
-/*!
-    \fn void QCameraExposure::isoSensitivityChanged(int value)
-
-    Signal emitted when sensitivity changes to \a value.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraExposure::exposureCompensationChanged(qreal value)
-
-    Signal emitted when the exposure compensation changes to \a value.
-    \since 1.1
-*/
-
-#include "moc_qcameraexposure.cpp"
-QT_END_NAMESPACE
diff --git a/src/multimedia/qcameraexposure.h b/src/multimedia/qcameraexposure.h
deleted file mode 100644
index 088e7c0..0000000
--- a/src/multimedia/qcameraexposure.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAEXPOSURE_H
-#define QCAMERAEXPOSURE_H
-
-#include <qmediaobject.h>
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QCamera;
-class QCameraExposurePrivate;
-
-class Q_MULTIMEDIA_EXPORT QCameraExposure : public QObject
-{
-    Q_OBJECT
-    Q_PROPERTY(qreal aperture READ aperture NOTIFY apertureChanged)
-    Q_PROPERTY(qreal shutterSpeed READ shutterSpeed NOTIFY shutterSpeedChanged)
-    Q_PROPERTY(int isoSensitivity READ isoSensitivity NOTIFY isoSensitivityChanged)
-    Q_PROPERTY(qreal exposureCompensation READ exposureCompensation WRITE setExposureCompensation NOTIFY exposureCompensationChanged)
-    Q_PROPERTY(bool flashReady READ isFlashReady NOTIFY flashReady)
-    Q_PROPERTY(QCameraExposure::FlashModes flashMode READ flashMode WRITE setFlashMode)
-    Q_PROPERTY(QCameraExposure::ExposureMode exposureMode READ exposureMode WRITE setExposureMode)
-    Q_PROPERTY(QCameraExposure::MeteringMode meteringMode READ meteringMode WRITE setMeteringMode)
-
-    Q_ENUMS(FlashMode)
-    Q_ENUMS(ExposureMode)
-    Q_ENUMS(MeteringMode)
-public:
-    enum FlashMode {
-        FlashAuto = 0x1,
-        FlashOff = 0x2,
-        FlashOn = 0x4,
-        FlashRedEyeReduction  = 0x8,
-        FlashFill = 0x10,
-        FlashTorch = 0x20,
-        FlashSlowSyncFrontCurtain = 0x40,
-        FlashSlowSyncRearCurtain = 0x80,
-        FlashManual = 0x100
-    };
-    Q_DECLARE_FLAGS(FlashModes, FlashMode)
-
-    enum ExposureMode {
-        ExposureAuto = 0,
-        ExposureManual = 1,
-        ExposurePortrait = 2,
-        ExposureNight = 3,
-        ExposureBacklight = 4,
-        ExposureSpotlight = 5,
-        ExposureSports = 6,
-        ExposureSnow = 7,
-        ExposureBeach = 8,
-        ExposureLargeAperture = 9,
-        ExposureSmallAperture = 10,
-        ExposureModeVendor = 1000
-    };
-
-    enum MeteringMode {
-        MeteringMatrix = 1,
-        MeteringAverage = 2,
-        MeteringSpot = 3
-    };
-
-    bool isAvailable() const;
-
-    FlashModes flashMode() const;
-    bool isFlashModeSupported(FlashModes mode) const;
-    bool isFlashReady() const;
-
-    ExposureMode exposureMode() const;
-    bool isExposureModeSupported(ExposureMode mode) const;
-
-    qreal exposureCompensation() const;
-
-    MeteringMode meteringMode() const;
-
-    bool isMeteringModeSupported(MeteringMode mode) const;
-
-    int isoSensitivity() const;
-    QList<int> supportedIsoSensitivities(bool *continuous = 0) const;
-
-    qreal aperture() const;
-    QList<qreal> supportedApertures(bool *continuous = 0) const;
-
-    qreal shutterSpeed() const;
-    QList<qreal> supportedShutterSpeeds(bool *continuous = 0) const;
-
-public Q_SLOTS:
-    void setFlashMode(FlashModes mode);
-    void setExposureMode(ExposureMode mode);
-
-    void setExposureCompensation(qreal ev);
-
-    void setMeteringMode(MeteringMode mode);
-
-    void setManualIsoSensitivity(int iso);
-    void setAutoIsoSensitivity();
-
-    void setManualAperture(qreal aperture);
-    void setAutoAperture();
-
-    void setManualShutterSpeed(qreal seconds);
-    void setAutoShutterSpeed();
-
-Q_SIGNALS:
-    void flashReady(bool);
-
-    void apertureChanged(qreal);
-    void apertureRangeChanged();
-    void shutterSpeedChanged(qreal);
-    void shutterSpeedRangeChanged();
-    void isoSensitivityChanged(int);
-    void exposureCompensationChanged(qreal);
-
-private:
-    friend class QCamera;
-    explicit QCameraExposure(QCamera *parent = 0);
-    virtual ~QCameraExposure();
-
-    Q_DISABLE_COPY(QCameraExposure)
-    Q_DECLARE_PRIVATE(QCameraExposure)
-    Q_PRIVATE_SLOT(d_func(), void _q_exposureParameterChanged(int))
-    Q_PRIVATE_SLOT(d_func(), void _q_exposureParameterRangeChanged(int))
-    QCameraExposurePrivate *d_ptr;
-};
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(QCameraExposure::FlashModes)
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QCameraExposure::ExposureMode)
-Q_DECLARE_METATYPE(QCameraExposure::FlashModes)
-Q_DECLARE_METATYPE(QCameraExposure::MeteringMode)
-
-Q_MEDIA_ENUM_DEBUG(QCameraExposure, ExposureMode)
-Q_MEDIA_ENUM_DEBUG(QCameraExposure, FlashMode)
-Q_MEDIA_ENUM_DEBUG(QCameraExposure, MeteringMode)
-
-QT_END_HEADER
-
-#endif // QCAMERAEXPOSURE_H
diff --git a/src/multimedia/qcameraexposurecontrol.cpp b/src/multimedia/qcameraexposurecontrol.cpp
deleted file mode 100644
index 4a6f655..0000000
--- a/src/multimedia/qcameraexposurecontrol.cpp
+++ /dev/null
@@ -1,252 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcameraexposurecontrol.h>
-#include  "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraExposureControl
-
-    \brief The QCameraExposureControl class allows controlling camera exposure parameters.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.1
-
-    You can adjust a number of parameters that will affect images and video taken with
-    the corresponding QCamera object.
-
-    There are a number of different parameters that can be adjusted, including:
-
-    \table
-    \row
-    \header
-    \
-
-    \endtable
-
-    The interface name of QCameraExposureControl is \c com.nokia.Qt.QCameraExposureControl/1.0 as
-    defined in QCameraExposureControl_iid.
-
-    \sa QCamera
-*/
-
-/*!
-    \macro QCameraExposureControl_iid
-
-    \c com.nokia.Qt.QCameraExposureControl/1.0
-
-    Defines the interface name of the QCameraExposureControl class.
-
-    \relates QCameraExposureControl
-*/
-
-/*!
-    Constructs a camera exposure control object with \a parent.
-*/
-QCameraExposureControl::QCameraExposureControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destroys the camera control object.
-*/
-QCameraExposureControl::~QCameraExposureControl()
-{
-}
-
-/*!
-  \fn QCamera::ExposureMode QCameraExposureControl::exposureMode() const
-
-  Returns the exposure mode.
-  \since 1.1
-*/
-
-
-/*!
-  \fn void QCameraExposureControl::setExposureMode(QCameraExposure::ExposureMode mode)
-
-  Set the exposure mode to \a mode.
-  \since 1.1
-*/
-
-
-/*!
-  \fn bool QCameraExposureControl::isExposureModeSupported(QCameraExposure::ExposureMode mode) const
-
-  Returns true if the exposure \a mode is supported.
-  \since 1.1
-*/
-
-
-/*!
-  \fn QCameraExposure::MeteringMode QCameraExposureControl::meteringMode() const
-  Returns the current metering mode.
-  \since 1.1
-*/
-
-/*!
-  \fn void QCameraExposureControl::setMeteringMode(QCameraExposure::MeteringMode mode)
-
-  Set the metering mode to \a mode.
-  \since 1.1
-*/
-
-
-/*!
-  \fn bool QCameraExposureControl::isMeteringModeSupported(QCameraExposure::MeteringMode mode) const
-    Returns true if the metering \a mode is supported.
-  \since 1.1
-*/
-
-/*!
-  \enum QCameraExposureControl::ExposureParameter
-  \value InvalidParameter
-         Parameter is invalid.
-  \value ISO
-         Camera ISO sensitivity, specified as integer value.
-  \value Aperture
-         Lens aperture is specified as an qreal F number.
-         The supported apertures list can change depending on the focal length,
-         in such a case the exposureParameterRangeChanged() signal is emitted.
-  \value ShutterSpeed
-         Shutter speed in seconds, specified as qreal.
-  \value ExposureCompensation
-         Exposure compensation, specified as qreal EV value.
-  \value FlashPower
-         Manual flash power, specified as qreal value.
-         Accepted power range is [0..1.0],
-         with 0 value means no flash and 1.0 corresponds to full flash power.
-
-         This value is only used in the \l{QCameraExposure::FlashManual}{manual flash mode}.
-  \value FlashCompensation
-         Flash compensation, specified as qreal EV value.
-  \value ExtendedExposureParameter
-         The base value for platform specific extended parameters.
-         For such parameters the sequential values starting from ExtendedExposureParameter shuld be used.
-*/
-
-/*!
-  \enum QCameraExposureControl::ParameterFlag
-  \value AutomaticValue
-         Use the automatic values for parameters.
-  \value ReadOnly
-         Parameters are read only.
-  \value ContinuousRange
-         Parameters are continuous in their range.
-*/
-
-/*!
-  \fn QCameraExposureControl::isParameterSupported(ExposureParameter parameter) const
-
-  Returns true is exposure \a parameter is supported by backend.
-  \since 1.1
-*/
-
-/*!
-  \fn QCameraExposureControl::exposureParameter(ExposureParameter parameter) const
-
-  Returns the exposure \a parameter value, or invalid QVariant() if the value is unknown or not supported.
-  \since 1.1
-*/
-
-/*!
-  \fn QCameraExposureControl::exposureParameterFlags(ExposureParameter parameter) const
-
-  Returns the properties of exposure \a parameter.
-  \since 1.1
-*/
-
-
-/*!
-  \fn QCameraExposureControl::supportedParameterRange(ExposureParameter parameter) const
-
-  Returns the list of supported \a parameter values;
-  \since 1.1
-*/
-
-/*!
-  \fn bool QCameraExposureControl::setExposureParameter(ExposureParameter parameter, const QVariant& value)
-
-  Set the exposure \a parameter to \a value.
-  If a null or invalid QVariant is passed, backend should choose the value automatically,
-  and if possible report the actual value to user with QCameraExposureControl::exposureParameter().
-
-  Returns true if parameter is supported and value is correct.
-  \since 1.1
-*/
-
-/*!
-  \fn QCameraExposureControl::extendedParameterName(ExposureParameter parameter)
-
-  Returns the extended exposure \a parameter name.
-  \since 1.1
-*/
-
-/*!
-    \fn void QCameraExposureControl::flashReady(bool ready)
-
-    Signal emitted when flash state changes, flash is charged \a ready.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraExposureControl::exposureParameterChanged(int parameter)
-
-    Signal emitted when the exposure \a parameter has changed.
-    \since 1.1
-*/
-
-/*!
-
-    \fn void QCameraExposureControl::exposureParameterRangeChanged(int parameter)
-
-    Signal emitted when the exposure \a parameter range has changed.
-    \since 1.1
-*/
-
-
-#include "moc_qcameraexposurecontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qcameraexposurecontrol.h b/src/multimedia/qcameraexposurecontrol.h
deleted file mode 100644
index ff60784..0000000
--- a/src/multimedia/qcameraexposurecontrol.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAEXPOSURECONTROL_H
-#define QCAMERAEXPOSURECONTROL_H
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-
-#include <qcameraexposure.h>
-#include <qcamera.h>
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QCameraExposureControl : public QMediaControl
-{
-    Q_OBJECT
-    Q_ENUMS(ExposureParameter)
-
-public:
-    ~QCameraExposureControl();
-
-    enum ExposureParameter {
-        InvalidParameter = 0,
-        ISO = 1,
-        Aperture = 2,
-        ShutterSpeed = 3,
-        ExposureCompensation = 4,
-        FlashPower = 5,
-        FlashCompensation = 6,
-        ExtendedExposureParameter = 1000
-    };
-
-    enum ParameterFlag {
-        AutomaticValue = 0x01,
-        ReadOnly = 0x02,
-        ContinuousRange = 0x04
-    };
-    Q_DECLARE_FLAGS(ParameterFlags, ParameterFlag)
-
-    virtual QCameraExposure::ExposureMode exposureMode() const = 0;
-    virtual void setExposureMode(QCameraExposure::ExposureMode mode) = 0;
-    virtual bool isExposureModeSupported(QCameraExposure::ExposureMode mode) const = 0;
-
-    virtual QCameraExposure::MeteringMode meteringMode() const = 0;
-    virtual void setMeteringMode(QCameraExposure::MeteringMode mode) = 0;
-    virtual bool isMeteringModeSupported(QCameraExposure::MeteringMode mode) const = 0;
-
-    virtual bool isParameterSupported(ExposureParameter parameter) const = 0;
-    virtual QVariant exposureParameter(ExposureParameter parameter) const = 0;
-    virtual ParameterFlags exposureParameterFlags(ExposureParameter parameter) const = 0;
-    virtual QVariantList supportedParameterRange(ExposureParameter parameter) const = 0;
-    virtual bool setExposureParameter(ExposureParameter parameter, const QVariant& value) = 0;
-
-    virtual QString extendedParameterName(ExposureParameter parameter) = 0;
-
-Q_SIGNALS:
-    void flashReady(bool);
-
-    void exposureParameterChanged(int parameter);
-    void exposureParameterRangeChanged(int parameter);
-
-protected:
-    QCameraExposureControl(QObject* parent = 0);
-};
-
-#define QCameraExposureControl_iid "com.nokia.Qt.QCameraExposureControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraExposureControl, QCameraExposureControl_iid)
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(QCameraExposureControl::ParameterFlags)
-
-Q_MEDIA_ENUM_DEBUG(QCameraExposureControl, ExposureParameter)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QCAMERAEXPOSURECONTROL_H
-
diff --git a/src/multimedia/qcameraflashcontrol.cpp b/src/multimedia/qcameraflashcontrol.cpp
deleted file mode 100644
index 34dcbde..0000000
--- a/src/multimedia/qcameraflashcontrol.cpp
+++ /dev/null
@@ -1,141 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcameraflashcontrol.h>
-#include  "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraFlashControl
-
-    \brief The QCameraFlashControl class allows controlling a camera's flash.
-
-    \ingroup multimedia-serv
-    \inmodule QtMultimedia
-    \since 1.1
-
-    \inmodule QtMultimedia
-
-    You can set the type of flash effect used when an image is captured, and test to see
-    if the flash hardware is ready to fire.
-
-    You can retrieve this control from the camera object in the usual way:
-
-    Some camera devices may not have flash hardware, or may not be configurable.  In that
-    case, there will be no QCameraFlashControl available.
-
-    The interface name of QCameraFlashControl is \c com.nokia.Qt.QCameraFlashControl/1.0 as
-    defined in QCameraFlashControl_iid.
-
-    \sa QCamera
-*/
-
-/*!
-    \macro QCameraFlashControl_iid
-
-    \c com.nokia.Qt.QCameraFlashControl/1.0
-
-    Defines the interface name of the QCameraFlashControl class.
-
-    \relates QCameraFlashControl
-*/
-
-/*!
-    Constructs a camera flash control object with \a parent.
-*/
-QCameraFlashControl::QCameraFlashControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destroys the camera control object.
-*/
-QCameraFlashControl::~QCameraFlashControl()
-{
-}
-
-/*!
-  \fn QCamera::FlashModes QCameraFlashControl::flashMode() const
-
-  Returns the current flash mode.
-  \since 1.1
-*/
-
-/*!
-  \fn void QCameraFlashControl::setFlashMode(QCameraExposure::FlashModes mode)
-
-  Set the current flash \a mode.
-
-  Usually a single QCameraExposure::FlashMode flag is used,
-  but some non conflicting flags combination are also allowed,
-  like QCameraExposure::FlashManual | QCameraExposure::FlashSlowSyncRearCurtain.
-  \since 1.1
-*/
-
-
-/*!
-  \fn QCameraFlashControl::isFlashModeSupported(QCameraExposure::FlashModes mode) const
-
-  Return true if the reqested flash \a mode is supported.
-  Some QCameraExposure::FlashMode values can be combined,
-  for example QCameraExposure::FlashManual | QCameraExposure::FlashSlowSyncRearCurtain
-  \since 1.1
-*/
-
-/*!
-  \fn bool QCameraFlashControl::isFlashReady() const
-
-  Returns true if flash is charged.
-  \since 1.1
-*/
-
-/*!
-    \fn void QCameraFlashControl::flashReady(bool ready)
-
-    Signal emitted when flash state changes to \a ready.
-    \since 1.1
-*/
-
-#include "moc_qcameraflashcontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qcameraflashcontrol.h b/src/multimedia/qcameraflashcontrol.h
deleted file mode 100644
index 89b3b9d..0000000
--- a/src/multimedia/qcameraflashcontrol.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAFLASHCONTROL_H
-#define QCAMERAFLASHCONTROL_H
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-
-#include <qcameraexposure.h>
-#include <qcamera.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QCameraFlashControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    ~QCameraFlashControl();
-    
-    virtual QCameraExposure::FlashModes flashMode() const = 0;
-    virtual void setFlashMode(QCameraExposure::FlashModes mode) = 0;
-    virtual bool isFlashModeSupported(QCameraExposure::FlashModes mode) const = 0;
-
-    virtual bool isFlashReady() const = 0;
-
-Q_SIGNALS:
-    void flashReady(bool);
-
-protected:
-    QCameraFlashControl(QObject* parent = 0);
-};
-
-#define QCameraFlashControl_iid "com.nokia.Qt.QCameraFlashControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraFlashControl, QCameraFlashControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QCAMERAFLASHCONTROL_H
-
diff --git a/src/multimedia/qcamerafocus.cpp b/src/multimedia/qcamerafocus.cpp
deleted file mode 100644
index 9b9caed..0000000
--- a/src/multimedia/qcamerafocus.cpp
+++ /dev/null
@@ -1,478 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qcamerafocus.h"
-#include "qmediaobject_p.h"
-
-#include <qcamera.h>
-#include <qcameracontrol.h>
-#include <qcameraexposurecontrol.h>
-#include <qcamerafocuscontrol.h>
-#include <qmediarecordercontrol.h>
-#include <qcameraimagecapturecontrol.h>
-#include <qvideodevicecontrol.h>
-
-#include <QtCore/QDebug>
-
-QT_BEGIN_NAMESPACE
-
-namespace
-{
-class CameraFocusRegisterMetaTypes
-{
-public:
-    CameraFocusRegisterMetaTypes()
-    {
-        qRegisterMetaType<QCameraFocus::FocusModes>("QCameraFocus::FocusModes");
-        qRegisterMetaType<QCameraFocus::FocusPointMode>("QCameraFocus::FocusPointMode");
-    }
-} _registerCameraFocusMetaTypes;
-}
-
-
-class QCameraFocusZoneData : public QSharedData
-{
-public:
-    QCameraFocusZoneData():
-        status(QCameraFocusZone::Invalid)
-    {
-
-    }
-
-    QCameraFocusZoneData(const QRectF &_area, QCameraFocusZone::FocusZoneStatus _status):
-        area(_area),
-        status(_status)
-    {
-
-    }
-
-
-    QCameraFocusZoneData(const QCameraFocusZoneData &other):
-        QSharedData(other),
-        area(other.area),
-        status(other.status)
-    {
-    }
-
-    QCameraFocusZoneData& operator=(const QCameraFocusZoneData &other)
-    {
-        area = other.area;
-        status = other.status;
-        return *this;
-    }
-
-    QRectF area;
-    QCameraFocusZone::FocusZoneStatus status;
-};
-
-QCameraFocusZone::QCameraFocusZone()
-    :d(new QCameraFocusZoneData)
-{
-
-}
-
-QCameraFocusZone::QCameraFocusZone(const QRectF &area, QCameraFocusZone::FocusZoneStatus status)
-    :d(new QCameraFocusZoneData(area, status))
-{
-}
-
-QCameraFocusZone::QCameraFocusZone(const QCameraFocusZone &other)
-    :d(other.d)
-{
-
-}
-
-QCameraFocusZone::~QCameraFocusZone()
-{
-
-}
-
-QCameraFocusZone& QCameraFocusZone::operator=(const QCameraFocusZone &other)
-{
-    d = other.d;
-    return *this;
-}
-
-bool QCameraFocusZone::operator==(const QCameraFocusZone &other) const
-{
-    return d == other.d ||
-           (d->area == other.d->area && d->status == other.d->status);
-}
-
-bool QCameraFocusZone::operator!=(const QCameraFocusZone &other) const
-{
-    return !(*this == other);
-}
-
-bool QCameraFocusZone::isValid() const
-{
-    return d->status != Invalid && !d->area.isValid();
-}
-
-QRectF QCameraFocusZone::area() const
-{
-    return d->area;
-}
-
-QCameraFocusZone::FocusZoneStatus QCameraFocusZone::status() const
-{
-    return d->status;
-}
-
-void QCameraFocusZone::setStatus(QCameraFocusZone::FocusZoneStatus status)
-{
-    d->status = status;
-}
-
-
-/*!
-    \class QCameraFocus
-
-
-    \brief The QCameraFocus class provides interface for
-    focus and zoom related camera settings.
-
-    \inmodule QtMultimedia
-    \ingroup camera
-    \since 1.1
-
-*/
-
-
-class QCameraFocusPrivate : public QMediaObjectPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QCameraFocus)
-public:
-    void initControls();
-
-    QCameraFocus *q_ptr;
-
-    QCamera *camera;
-    QCameraFocusControl *focusControl;
-};
-
-
-void QCameraFocusPrivate::initControls()
-{
-    Q_Q(QCameraFocus);
-
-    focusControl = 0;
-
-    QMediaService *service = camera->service();
-    if (service)
-        focusControl = qobject_cast<QCameraFocusControl *>(service->requestControl(QCameraFocusControl_iid));
-
-    if (focusControl) {
-        q->connect(focusControl, SIGNAL(opticalZoomChanged(qreal)), q, SIGNAL(opticalZoomChanged(qreal)));
-        q->connect(focusControl, SIGNAL(digitalZoomChanged(qreal)), q, SIGNAL(digitalZoomChanged(qreal)));
-        q->connect(focusControl, SIGNAL(maximumOpticalZoomChanged(qreal)),
-                   q, SIGNAL(maximumOpticalZoomChanged(qreal)));
-        q->connect(focusControl, SIGNAL(maximumDigitalZoomChanged(qreal)),
-                   q, SIGNAL(maximumDigitalZoomChanged(qreal)));
-        q->connect(focusControl, SIGNAL(focusZonesChanged()), q, SIGNAL(focusZonesChanged()));
-    }
-}
-
-/*!
-    Construct a QCameraFocus for \a camera.
-*/
-
-QCameraFocus::QCameraFocus(QCamera *camera):
-    QObject(camera), d_ptr(new QCameraFocusPrivate)
-{
-    Q_D(QCameraFocus);
-    d->camera = camera;
-    d->q_ptr = this;
-    d->initControls();
-}
-
-
-/*!
-    Destroys the camera focus object.
-*/
-
-QCameraFocus::~QCameraFocus()
-{
-}
-
-/*!
-    Returns true if focus related settings are supported by this camera.
-    \since 1.1
-*/
-bool QCameraFocus::isAvailable() const
-{
-    return d_func()->focusControl != 0;
-}
-
-/*!
-  \property QCameraFocus::focusMode
-  \brief The current camera focus mode.
-
-  \since 1.1
-  \sa QCameraFocus::isFocusModeSupported()
-*/
-
-QCameraFocus::FocusMode QCameraFocus::focusMode() const
-{
-    return d_func()->focusControl ? d_func()->focusControl->focusMode() : QCameraFocus::AutoFocus;
-}
-
-void QCameraFocus::setFocusMode(QCameraFocus::FocusMode mode)
-{
-    if (d_func()->focusControl)
-        d_func()->focusControl->setFocusMode(mode);
-}
-
-/*!
-    Returns true if the focus \a mode is supported by camera.
-    \since 1.1
-*/
-
-bool QCameraFocus::isFocusModeSupported(QCameraFocus::FocusMode mode) const
-{
-    return d_func()->focusControl ? d_func()->focusControl->isFocusModeSupported(mode) : false;
-}
-
-/*!
-  \property QCameraFocus::focusPointMode
-  \brief The current camera focus point selection mode.
-
-  \sa QCameraFocus::isFocusPointModeSupported()
-  \since 1.1
-*/
-
-QCameraFocus::FocusPointMode QCameraFocus::focusPointMode() const
-{
-    return d_func()->focusControl ?
-            d_func()->focusControl->focusPointMode() :
-            QCameraFocus::FocusPointAuto;
-}
-
-void QCameraFocus::setFocusPointMode(QCameraFocus::FocusPointMode mode)
-{
-    if (d_func()->focusControl)
-        d_func()->focusControl->setFocusPointMode(mode);
-    else
-        qWarning("Focus points mode selection is not supported");
-}
-
-/*!
-  Returns true if focus point \a mode is supported.
-  \since 1.1
- */
-bool QCameraFocus::isFocusPointModeSupported(QCameraFocus::FocusPointMode mode) const
-{
-    return d_func()->focusControl ?
-            d_func()->focusControl->isFocusPointModeSupported(mode) :
-            false;
-
-}
-
-/*!
-  \property QCameraFocus::customFocusPoint
-
-  Position of custom focus point, in relative frame coordinates:
-  QPointF(0,0) points to the left top frame point, QPointF(0.5,0.5) points to the frame center.
-
-  Custom focus point is used only in FocusPointCustom focus mode.
-  \since 1.1
- */
-
-QPointF QCameraFocus::customFocusPoint() const
-{
-    return d_func()->focusControl ?
-            d_func()->focusControl->customFocusPoint() :
-            QPointF(0.5,0.5);
-}
-
-void QCameraFocus::setCustomFocusPoint(const QPointF &point)
-{
-    if (d_func()->focusControl)
-        d_func()->focusControl->setCustomFocusPoint(point);
-    else
-        qWarning("Focus points selection is not supported");
-
-}
-
-/*!
-  \property QCameraFocus::focusZones
-
-  Returns the list of active focus zones.
-
-  If QCamera::FocusPointAuto or QCamera::FocusPointFaceDetection focus mode is selected
-  this method returns the list of zones the camera is actually focused on.
-
-  The coordinates system is the same as for custom focus points:
-  QPointF(0,0) points to the left top frame point, QPointF(0.5,0.5) points to the frame center.
-  \since 1.1
- */
-QCameraFocusZoneList QCameraFocus::focusZones() const
-{
-    return d_func()->focusControl ?
-            d_func()->focusControl->focusZones() :
-            QCameraFocusZoneList();
-}
-
-/*!
-    Returns the maximum optical zoom
-    \since 1.1
-*/
-
-qreal QCameraFocus::maximumOpticalZoom() const
-{
-    return d_func()->focusControl ? d_func()->focusControl->maximumOpticalZoom() : 1.0;
-}
-
-/*!
-    Returns the maximum digital zoom
-    \since 1.1
-*/
-
-qreal QCameraFocus::maximumDigitalZoom() const
-{
-    return d_func()->focusControl ? d_func()->focusControl->maximumDigitalZoom() : 1.0;
-}
-
-/*!
-  \property QCameraFocus::opticalZoom
-  \brief The current optical zoom value.
-
-  \since 1.1
-  \sa QCameraFocus::digitalZoom
-*/
-
-qreal QCameraFocus::opticalZoom() const
-{
-    return d_func()->focusControl ? d_func()->focusControl->opticalZoom() : 1.0;
-}
-
-/*!
-  \property QCameraFocus::digitalZoom
-  \brief The current digital zoom value.
-
-  \since 1.1
-  \sa QCameraFocus::opticalZoom
-*/
-qreal QCameraFocus::digitalZoom() const
-{
-    return d_func()->focusControl ? d_func()->focusControl->digitalZoom() : 1.0;
-}
-
-
-/*!
-    Set the camera \a optical and \a digital zoom values.
-    \since 1.1
-*/
-void QCameraFocus::zoomTo(qreal optical, qreal digital)
-{
-    if (d_func()->focusControl)
-        d_func()->focusControl->zoomTo(optical, digital);
-    else
-        qWarning("The camera doesn't support zooming.");
-}
-
-/*!
-    \enum QCameraFocus::FocusMode
-
-    \value ManualFocus          Manual or fixed focus mode.
-    \value AutoFocus            One-shot auto focus mode.
-    \value ContinuousFocus      Continuous auto focus mode.
-    \value InfinityFocus        Focus strictly to infinity.
-    \value HyperfocalFocus      Focus to hyperfocal distance, with with the maximum depth of field achieved.
-                                All objects at distances from half of this
-                                distance out to infinity will be acceptably sharp.
-    \value MacroFocus           One shot auto focus to objects close to camera.
-*/
-
-/*!
-    \enum QCameraFocus::FocusPointMode
-
-    \value FocusPointAuto       Automatically select one or multiple focus points.
-    \value FocusPointCenter     Focus to the frame center.
-    \value FocusPointFaceDetection Focus on faces in the frame.
-    \value FocusPointCustom     Focus to the custom point, defined by QCameraFocus::customFocusPoint property.
-*/
-
-/*!
-    \fn void QCameraFocus::opticalZoomChanged(qreal value)
-
-    Signal emitted when optical zoom value changes to new \a value.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraFocus::digitalZoomChanged(qreal value)
-
-    Signal emitted when digital zoom value changes to new \a value.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraFocus::maximumOpticalZoomChanged(qreal zoom)
-
-    Signal emitted when the maximum supported optical \a zoom value changed.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraFocus::maximumDigitalZoomChanged(qreal zoom)
-
-    Signal emitted when the maximum supported digital \a zoom value changed.
-
-    The maximum supported zoom value can depend on other camera settings,
-    like capture mode or resolution.
-    \since 1.1
-*/
-
-
-
-/*!
-  \fn QCameraFocus::focusZonesChanged()
-
-  Signal is emitted when the set of zones, camera focused on is changed.
-
-  Usually the zones list is changed when the camera is focused.
-  \since 1.1
-*/
-
-
-#include "moc_qcamerafocus.cpp"
-QT_END_NAMESPACE
diff --git a/src/multimedia/qcamerafocus.h b/src/multimedia/qcamerafocus.h
deleted file mode 100644
index 064af7a..0000000
--- a/src/multimedia/qcamerafocus.h
+++ /dev/null
@@ -1,183 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAFOCUS_H
-#define QCAMERAFOCUS_H
-
-#include <QtCore/qstringlist.h>
-#include <QtCore/qpair.h>
-#include <QtCore/qsize.h>
-#include <QtCore/qpoint.h>
-#include <QtCore/qrect.h>
-#include <QtCore/qshareddata.h>
-
-#include <qmediaobject.h>
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QCamera;
-
-class QCameraFocusZoneData;
-
-class Q_MULTIMEDIA_EXPORT QCameraFocusZone {
-public:
-    enum FocusZoneStatus {
-        Invalid,
-        Unused,
-        Selected,
-        Focused
-    };
-
-    QCameraFocusZone();
-    QCameraFocusZone(const QRectF &area, FocusZoneStatus status = Selected);
-    QCameraFocusZone(const QCameraFocusZone &other);
-
-    QCameraFocusZone& operator=(const QCameraFocusZone &other);
-    bool operator==(const QCameraFocusZone &other) const;
-    bool operator!=(const QCameraFocusZone &other) const;
-
-    ~QCameraFocusZone();
-
-    bool isValid() const;
-
-    QRectF area() const;
-
-    FocusZoneStatus status() const;
-    void setStatus(FocusZoneStatus status);
-
-private:
-     QSharedDataPointer<QCameraFocusZoneData> d;
-};
-
-typedef QList<QCameraFocusZone> QCameraFocusZoneList;
-
-
-class QCameraFocusPrivate;
-class Q_MULTIMEDIA_EXPORT QCameraFocus : public QObject
-{
-    Q_OBJECT
-
-    Q_PROPERTY(FocusMode focusMode READ focusMode WRITE setFocusMode)
-    Q_PROPERTY(FocusPointMode focusPointMode READ focusPointMode WRITE setFocusPointMode)
-    Q_PROPERTY(QPointF customFocusPoint READ customFocusPoint WRITE setCustomFocusPoint)
-    Q_PROPERTY(QCameraFocusZoneList focusZones READ focusZones NOTIFY focusZonesChanged)
-    Q_PROPERTY(qreal opticalZoom READ opticalZoom NOTIFY opticalZoomChanged)
-    Q_PROPERTY(qreal digitalZoom READ digitalZoom NOTIFY digitalZoomChanged)
-
-    Q_ENUMS(FocusMode)
-    Q_ENUMS(FocusPointMode)
-public:
-    enum FocusMode {
-        ManualFocus = 0x1,
-        HyperfocalFocus = 0x02,
-        InfinityFocus = 0x04,
-        AutoFocus = 0x8,
-        ContinuousFocus = 0x10,
-        MacroFocus = 0x20
-    };
-    Q_DECLARE_FLAGS(FocusModes, FocusMode)
-
-    enum FocusPointMode {
-        FocusPointAuto,
-        FocusPointCenter,
-        FocusPointFaceDetection,
-        FocusPointCustom
-    };
-
-    bool isAvailable() const;
-
-    FocusMode focusMode() const;
-    void setFocusMode(FocusMode mode);
-    bool isFocusModeSupported(FocusMode mode) const;
-
-    FocusPointMode focusPointMode() const;
-    void setFocusPointMode(FocusPointMode mode);
-    bool isFocusPointModeSupported(FocusPointMode) const;
-    QPointF customFocusPoint() const;
-    void setCustomFocusPoint(const QPointF &point);
-
-    QCameraFocusZoneList focusZones() const;
-
-    qreal maximumOpticalZoom() const;
-    qreal maximumDigitalZoom() const;
-    qreal opticalZoom() const;
-    qreal digitalZoom() const;
-
-    void zoomTo(qreal opticalZoom, qreal digitalZoom);
-
-Q_SIGNALS:
-    void opticalZoomChanged(qreal);
-    void digitalZoomChanged(qreal);
-
-    void focusZonesChanged();
-
-    void maximumOpticalZoomChanged(qreal);
-    void maximumDigitalZoomChanged(qreal);
-
-private:
-    friend class QCamera;
-    QCameraFocus(QCamera *camera);
-    ~QCameraFocus();
-
-    Q_DISABLE_COPY(QCameraFocus)
-    Q_DECLARE_PRIVATE(QCameraFocus)
-    QCameraFocusPrivate *d_ptr;
-};
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(QCameraFocus::FocusModes)
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QCameraFocus::FocusModes)
-Q_DECLARE_METATYPE(QCameraFocus::FocusPointMode)
-
-Q_MEDIA_ENUM_DEBUG(QCameraFocus, FocusMode)
-Q_MEDIA_ENUM_DEBUG(QCameraFocus, FocusPointMode)
-
-QT_END_HEADER
-
-#endif  // QCAMERAFOCUS_H
diff --git a/src/multimedia/qcamerafocuscontrol.cpp b/src/multimedia/qcamerafocuscontrol.cpp
deleted file mode 100644
index 93c4668..0000000
--- a/src/multimedia/qcamerafocuscontrol.cpp
+++ /dev/null
@@ -1,253 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcamerafocuscontrol.h>
-#include  "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraFocusControl
-
-
-    \brief The QCameraFocusControl class supplies control for
-    focusing related camera parameters.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.1
-
-    The interface name of QCameraFocusControl is \c com.nokia.Qt.QCameraFocusControl/1.0 as
-    defined in QCameraFocusControl_iid.
-
-
-    \sa QMediaService::requestControl(), QCamera
-*/
-
-/*!
-    \macro QCameraFocusControl_iid
-
-    \c com.nokia.Qt.QCameraFocusControl/1.0
-
-    Defines the interface name of the QCameraFocusControl class.
-
-    \relates QCameraFocusControl
-*/
-
-/*!
-    Constructs a camera control object with \a parent.
-*/
-
-QCameraFocusControl::QCameraFocusControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destruct the camera control object.
-*/
-
-QCameraFocusControl::~QCameraFocusControl()
-{
-}
-
-
-/*!
-  \fn QCameraFocus::FocusMode QCameraFocusControl::focusMode() const
-
-  Returns the focus mode being used.
-  \since 1.1
-*/
-
-
-/*!
-  \fn void QCameraFocusControl::setFocusMode(QCameraFocus::FocusMode mode)
-
-  Set the focus mode to \a mode.
-  \since 1.1
-*/
-
-
-/*!
-  \fn bool QCameraFocusControl::isFocusModeSupported(QCameraFocus::FocusMode mode) const
-
-  Returns true if focus \a mode is supported.
-  \since 1.1
-*/
-
-
-/*!
-  \fn qreal QCameraFocusControl::maximumOpticalZoom() const
-
-  Returns the maximum optical zoom value, or 1.0 if optical zoom is not supported.
-  \since 1.1
-*/
-
-
-/*!
-  \fn qreal QCameraFocusControl::maximumDigitalZoom() const
-
-  Returns the maximum digital zoom value, or 1.0 if digital zoom is not supported.
-  \since 1.1
-*/
-
-
-/*!
-  \fn qreal QCameraFocusControl::opticalZoom() const
-
-  Return the current optical zoom value.
-  \since 1.1
-*/
-
-/*!
-  \fn qreal QCameraFocusControl::digitalZoom() const
-
-  Return the current digital zoom value.
-  \since 1.1
-*/
-
-
-/*!
-  \fn void QCameraFocusControl::zoomTo(qreal optical, qreal digital)
-
-  Sets \a optical and \a digital zoom values.
-  \since 1.1
-*/
-
-/*!
-  \fn QCameraFocusControl::focusPointMode() const
-
-  Returns the camera focus point selection mode.
-  \since 1.1
-*/
-
-/*!
-  \fn QCameraFocusControl::setFocusPointMode(QCameraFocus::FocusPointMode mode)
-
-  Sets the camera focus point selection \a mode.
-  \since 1.1
-*/
-
-/*!
-  \fn QCameraFocusControl::isFocusPointModeSupported(QCameraFocus::FocusPointMode mode) const
-
-  Returns true if the camera focus point \a mode is supported.
-  \since 1.1
-*/
-
-/*!
-  \fn QCameraFocusControl::customFocusPoint() const
-
-  Return the position of custom focus point, in relative frame coordinates:
-  QPointF(0,0) points to the left top frame point, QPointF(0.5,0.5) points to the frame center.
-
-  Custom focus point is used only in FocusPointCustom focus mode.
-  \since 1.1
-*/
-
-/*!
-  \fn QCameraFocusControl::setCustomFocusPoint(const QPointF &point)
-
-  Sets the custom focus \a point.
-
-  If camera supports fixed set of focus points,
-  it should use the nearest supported focus point,
-  and return the actual focus point with QCameraFocusControl::focusZones().
-
-  \since 1.1
-  \sa QCameraFocusControl::customFocusPoint(), QCameraFocusControl::focusZones()
-*/
-
-/*!
-  \fn QCameraFocusControl::focusZones() const
-
-  Returns the list of zones, the camera is using for focusing or focused on.
-  \since 1.1
-*/
-
-/*!
-    \fn void QCameraFocusControl::opticalZoomChanged(qreal zoom)
-
-    Signal emitted when the optical \a zoom value changed.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraFocusControl::digitalZoomChanged(qreal zoom)
-
-    Signal emitted when the digital \a zoom value changed.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraFocusControl::maximumOpticalZoomChanged(qreal zoom)
-
-    Signal emitted when the maximum supported optical \a zoom value changed.
-    \since 1.1
-*/
-
-/*!
-    \fn void QCameraFocusControl::maximumDigitalZoomChanged(qreal zoom)
-
-    Signal emitted when the maximum supported digital \a zoom value changed.
-
-    The maximum supported zoom value can depend on other camera settings,
-    like capture mode or resolution.
-    \since 1.1
-*/
-
-
-/*!
-  \fn QCameraFocusControl::focusZonesChanged()
-
-  Signal is emitted when the set of zones, camera focused on is changed.
-
-  Usually the zones list is changed when the camera is focused.
-
-  \since 1.1
-  \sa QCameraFocusControl::focusZones()
-*/
-
-
-
-#include "moc_qcamerafocuscontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qcamerafocuscontrol.h b/src/multimedia/qcamerafocuscontrol.h
deleted file mode 100644
index 20ffe6a..0000000
--- a/src/multimedia/qcamerafocuscontrol.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAFOCUSCONTROL_H
-#define QCAMERAFOCUSCONTROL_H
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-
-#include <qcamerafocus.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QCameraFocusControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    ~QCameraFocusControl();
-
-    virtual QCameraFocus::FocusMode focusMode() const = 0;
-    virtual void setFocusMode(QCameraFocus::FocusMode mode) = 0;
-    virtual bool isFocusModeSupported(QCameraFocus::FocusMode mode) const = 0;
-
-    virtual qreal maximumOpticalZoom() const = 0;
-    virtual qreal maximumDigitalZoom() const = 0;
-    virtual qreal opticalZoom() const = 0;
-    virtual qreal digitalZoom() const = 0;
-
-    virtual void zoomTo(qreal optical, qreal digital) = 0;
-
-    virtual QCameraFocus::FocusPointMode focusPointMode() const = 0;
-    virtual void setFocusPointMode(QCameraFocus::FocusPointMode mode) = 0;
-    virtual bool isFocusPointModeSupported(QCameraFocus::FocusPointMode mode) const = 0;
-    virtual QPointF customFocusPoint() const = 0;
-    virtual void setCustomFocusPoint(const QPointF &point) = 0;
-
-    virtual QCameraFocusZoneList focusZones() const = 0;
-
-Q_SIGNALS:
-    void opticalZoomChanged(qreal opticalZoom);
-    void digitalZoomChanged(qreal digitalZoom);
-    void focusZonesChanged();
-    void maximumOpticalZoomChanged(qreal);
-    void maximumDigitalZoomChanged(qreal);
-
-protected:
-    QCameraFocusControl(QObject* parent = 0);
-};
-
-#define QCameraFocusControl_iid "com.nokia.Qt.QCameraFocusingControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraFocusControl, QCameraFocusControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QCAMERAFOCUSCONTROL_H
-
diff --git a/src/multimedia/qcameraimagecapture.cpp b/src/multimedia/qcameraimagecapture.cpp
deleted file mode 100644
index f49531e..0000000
--- a/src/multimedia/qcameraimagecapture.cpp
+++ /dev/null
@@ -1,681 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <qcameraimagecapture.h>
-#include <qcameraimagecapturecontrol.h>
-#include <qmediaencodersettings.h>
-#include <qcameracapturedestinationcontrol.h>
-#include <qcameracapturebufferformatcontrol.h>
-
-#include <qimageencodercontrol.h>
-#include "qmediaobject_p.h"
-#include <qmediaservice.h>
-#include <qcamera.h>
-#include <qcameracontrol.h>
-#include <QtCore/qdebug.h>
-#include <QtCore/qurl.h>
-#include <QtCore/qstringlist.h>
-#include <QtCore/qmetaobject.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraImageCapture
-    \inmodule QtMultimedia
-    \ingroup camera
-    \since 1.1
-
-
-    \brief The QCameraImageCapture class is used for the recording of media content.
-
-    The QCameraImageCapture class is a high level images recording class.
-    It's not intended to be used alone but for accessing the media
-    recording functions of other media objects, like QCamera.
-
-    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera
-
-    \snippet doc/src/snippets/multimedia-snippets/camera.cpp Camera keys
-
-    \sa QCamera
-*/
-
-namespace
-{
-class MediaRecorderRegisterMetaTypes
-{
-public:
-    MediaRecorderRegisterMetaTypes()
-    {
-        qRegisterMetaType<QCameraImageCapture::Error>("QCameraImageCapture::Error");
-        qRegisterMetaType<QCameraImageCapture::CaptureDestination>("QCameraImageCapture::CaptureDestination");
-        qRegisterMetaType<QCameraImageCapture::CaptureDestinations>("QCameraImageCapture::CaptureDestinations");
-    }
-} _registerRecorderMetaTypes;
-}
-
-
-class QCameraImageCapturePrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QCameraImageCapture)
-public:
-    QCameraImageCapturePrivate();
-
-    QMediaObject *mediaObject;
-
-    QCameraImageCaptureControl *control;
-    QImageEncoderControl *encoderControl;
-    QCameraCaptureDestinationControl *captureDestinationControl;
-    QCameraCaptureBufferFormatControl *bufferFormatControl;
-
-    QCameraImageCapture::Error error;
-    QString errorString;
-
-    void _q_error(int id, int error, const QString &errorString);
-    void _q_readyChanged(bool);
-    void _q_serviceDestroyed();
-
-    void unsetError() { error = QCameraImageCapture::NoError; errorString.clear(); }
-
-    QCameraImageCapture *q_ptr;
-};
-
-QCameraImageCapturePrivate::QCameraImageCapturePrivate():
-     mediaObject(0),
-     control(0),
-     encoderControl(0),
-     captureDestinationControl(0),
-     bufferFormatControl(0),
-     error(QCameraImageCapture::NoError)
-{
-}
-
-void QCameraImageCapturePrivate::_q_error(int id, int error, const QString &errorString)
-{
-    Q_Q(QCameraImageCapture);
-
-    this->error = QCameraImageCapture::Error(error);
-    this->errorString = errorString;
-
-    emit q->error(id, this->error, errorString);
-}
-
-void QCameraImageCapturePrivate::_q_readyChanged(bool ready)
-{
-    Q_Q(QCameraImageCapture);
-    emit q->readyForCaptureChanged(ready);
-}
-
-void QCameraImageCapturePrivate::_q_serviceDestroyed()
-{
-    mediaObject = 0;
-    control = 0;
-    encoderControl = 0;
-    captureDestinationControl = 0;
-    bufferFormatControl = 0;
-}
-
-/*!
-    Constructs a media recorder which records the media produced by \a mediaObject.
-
-    The \a parent is passed to QMediaObject.
-*/
-
-QCameraImageCapture::QCameraImageCapture(QMediaObject *mediaObject, QObject *parent):
-    QObject(parent), d_ptr(new QCameraImageCapturePrivate)
-{
-    Q_D(QCameraImageCapture);
-
-    d->q_ptr = this;
-
-    if (mediaObject)
-        mediaObject->bind(this);
-}
-
-/*!
-    Destroys images capture object.
-*/
-
-QCameraImageCapture::~QCameraImageCapture()
-{
-    Q_D(QCameraImageCapture);
-
-    if (d->mediaObject)
-        d->mediaObject->unbind(this);
-}
-
-/*!
-  \reimp
-  \since 1.1
-*/
-QMediaObject *QCameraImageCapture::mediaObject() const
-{
-    return d_func()->mediaObject;
-}
-
-/*!
-  \reimp
-  \since 1.1
-*/
-bool QCameraImageCapture::setMediaObject(QMediaObject *mediaObject)
-{
-    Q_D(QCameraImageCapture);
-
-    if (d->mediaObject) {
-        if (d->control) {
-            disconnect(d->control, SIGNAL(imageExposed(int)),
-                       this, SIGNAL(imageExposed(int)));
-            disconnect(d->control, SIGNAL(imageCaptured(int,QImage)),
-                       this, SIGNAL(imageCaptured(int,QImage)));
-            disconnect(d->control, SIGNAL(imageAvailable(int,QVideoFrame)),
-                       this, SIGNAL(imageAvailable(int,QVideoFrame)));
-            disconnect(d->control, SIGNAL(imageMetadataAvailable(int,QtMultimedia::MetaData,QVariant)),
-                       this, SIGNAL(imageMetadataAvailable(int,QtMultimedia::MetaData,QVariant)));
-            disconnect(d->control, SIGNAL(imageMetadataAvailable(int,QString,QVariant)),
-                       this, SIGNAL(imageMetadataAvailable(int,QString,QVariant)));
-            disconnect(d->control, SIGNAL(imageSaved(int,QString)),
-                       this, SIGNAL(imageSaved(int,QString)));
-            disconnect(d->control, SIGNAL(readyForCaptureChanged(bool)),
-                       this, SLOT(_q_readyChanged(bool)));
-            disconnect(d->control, SIGNAL(error(int,int,QString)),
-                       this, SLOT(_q_error(int,int,QString)));
-
-            if (d->captureDestinationControl) {
-                disconnect(d->captureDestinationControl, SIGNAL(captureDestinationChanged(QCameraImageCapture::CaptureDestinations)),
-                           this, SIGNAL(captureDestinationChanged(QCameraImageCapture::CaptureDestinations)));
-            }
-
-            if (d->bufferFormatControl) {
-                disconnect(d->bufferFormatControl, SIGNAL(bufferFormatChanged(QVideoFrame::PixelFormat)),
-                           this, SIGNAL(bufferFormatChanged(QVideoFrame::PixelFormat)));
-            }
-
-            QMediaService *service = d->mediaObject->service();
-            service->releaseControl(d->control);
-            if (d->encoderControl)
-                service->releaseControl(d->encoderControl);
-            if (d->captureDestinationControl)
-                service->releaseControl(d->captureDestinationControl);
-            if (d->bufferFormatControl)
-                service->releaseControl(d->bufferFormatControl);
-
-            disconnect(service, SIGNAL(destroyed()), this, SLOT(_q_serviceDestroyed()));
-        }
-    }
-
-    d->mediaObject = mediaObject;
-
-    if (d->mediaObject) {
-        QMediaService *service = mediaObject->service();
-        if (service) {
-            d->control = qobject_cast<QCameraImageCaptureControl*>(service->requestControl(QCameraImageCaptureControl_iid));
-
-            if (d->control) {
-                d->encoderControl = qobject_cast<QImageEncoderControl *>(service->requestControl(QImageEncoderControl_iid));
-                d->captureDestinationControl = qobject_cast<QCameraCaptureDestinationControl *>(
-                    service->requestControl(QCameraCaptureDestinationControl_iid));
-                d->bufferFormatControl = qobject_cast<QCameraCaptureBufferFormatControl *>(
-                    service->requestControl(QCameraCaptureBufferFormatControl_iid));
-
-                connect(d->control, SIGNAL(imageExposed(int)),
-                        this, SIGNAL(imageExposed(int)));
-                connect(d->control, SIGNAL(imageCaptured(int,QImage)),
-                        this, SIGNAL(imageCaptured(int,QImage)));
-                connect(d->control, SIGNAL(imageMetadataAvailable(int,QtMultimedia::MetaData,QVariant)),
-                        this, SIGNAL(imageMetadataAvailable(int,QtMultimedia::MetaData,QVariant)));
-                connect(d->control, SIGNAL(imageMetadataAvailable(int,QString,QVariant)),
-                        this, SIGNAL(imageMetadataAvailable(int,QString,QVariant)));
-                connect(d->control, SIGNAL(imageAvailable(int,QVideoFrame)),
-                        this, SIGNAL(imageAvailable(int,QVideoFrame)));
-                connect(d->control, SIGNAL(imageSaved(int, QString)),
-                        this, SIGNAL(imageSaved(int, QString)));
-                connect(d->control, SIGNAL(readyForCaptureChanged(bool)),
-                        this, SLOT(_q_readyChanged(bool)));
-                connect(d->control, SIGNAL(error(int,int,QString)),
-                        this, SLOT(_q_error(int,int,QString)));
-
-                if (d->captureDestinationControl) {
-                    connect(d->captureDestinationControl, SIGNAL(captureDestinationChanged(QCameraImageCapture::CaptureDestinations)),
-                            this, SIGNAL(captureDestinationChanged(QCameraImageCapture::CaptureDestinations)));
-                }
-
-                if (d->bufferFormatControl) {
-                    connect(d->bufferFormatControl, SIGNAL(bufferFormatChanged(QVideoFrame::PixelFormat)),
-                            this, SIGNAL(bufferFormatChanged(QVideoFrame::PixelFormat)));
-                }
-
-                connect(service, SIGNAL(destroyed()), this, SLOT(_q_serviceDestroyed()));
-
-                return true;
-            }
-        }
-    }
-
-    // without QCameraImageCaptureControl discard the media object
-    d->mediaObject = 0;
-    d->control = 0;
-    d->encoderControl = 0;
-    d->captureDestinationControl = 0;
-    d->bufferFormatControl = 0;
-
-    return false;
-}
-
-/*!
-    Returns true if the images capture service ready to use.
-    \since 1.1
-*/
-bool QCameraImageCapture::isAvailable() const
-{
-    if (d_func()->control != NULL)
-        return true;
-    else
-        return false;
-}
-
-/*!
-    Returns the availability error code.
-    \since 1.1
-*/
-QtMultimedia::AvailabilityError QCameraImageCapture::availabilityError() const
-{
-    if (d_func()->control != NULL)
-        return QtMultimedia::NoError;
-    else
-        return QtMultimedia::ServiceMissingError;
-}
-
-/*!
-    Returns the current error state.
-
-    \since 1.1
-    \sa errorString()
-*/
-
-QCameraImageCapture::Error QCameraImageCapture::error() const
-{
-    return d_func()->error;
-}
-
-/*!
-    Returns a string describing the current error state.
-
-    \since 1.1
-    \sa error()
-*/
-
-QString QCameraImageCapture::errorString() const
-{
-    return d_func()->errorString;
-}
-
-
-/*!
-    Returns a list of supported image codecs.
-    \since 1.1
-*/
-QStringList QCameraImageCapture::supportedImageCodecs() const
-{
-    return d_func()->encoderControl ?
-           d_func()->encoderControl->supportedImageCodecs() : QStringList();
-}
-
-/*!
-    Returns a description of an image \a codec.
-    \since 1.1
-*/
-QString QCameraImageCapture::imageCodecDescription(const QString &codec) const
-{
-    return d_func()->encoderControl ?
-           d_func()->encoderControl->imageCodecDescription(codec) : QString();
-}
-
-/*!
-    Returns a list of resolutions images can be encoded at.
-
-    If non null image \a settings parameter is passed,
-    the returned list is reduced to resolution supported with partial settings like image codec or quality applied.
-
-    If the encoder supports arbitrary resolutions within the supported range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-
-    \since 1.1
-    \sa QImageEncoderSettings::resolution()
-*/
-QList<QSize> QCameraImageCapture::supportedResolutions(const QImageEncoderSettings &settings, bool *continuous) const
-{
-    if (continuous)
-        *continuous = false;
-
-    return d_func()->encoderControl ?
-           d_func()->encoderControl->supportedResolutions(settings, continuous) : QList<QSize>();
-}
-
-/*!
-    Returns the image encoder settings being used.
-
-    \since 1.1
-    \sa setEncodingSettings()
-*/
-
-QImageEncoderSettings QCameraImageCapture::encodingSettings() const
-{
-    return d_func()->encoderControl ?
-           d_func()->encoderControl->imageSettings() : QImageEncoderSettings();
-}
-
-/*!
-    Sets the image encoding \a settings.
-
-    If some parameters are not specified, or null settings are passed,
-    the encoder choose the default encoding parameters.
-
-    \since 1.1
-    \sa encodingSettings()
-*/
-
-void QCameraImageCapture::setEncodingSettings(const QImageEncoderSettings &settings)
-{
-    Q_D(QCameraImageCapture);
-
-    if (d->encoderControl) {
-        QCamera *camera = qobject_cast<QCamera*>(d->mediaObject);
-        if (camera && camera->captureMode() == QCamera::CaptureStillImage) {
-            QMetaObject::invokeMethod(camera,
-                                      "_q_preparePropertyChange",
-                                      Qt::DirectConnection,
-                                      Q_ARG(int, QCameraControl::ImageEncodingSettings));
-        }
-
-        d->encoderControl->setImageSettings(settings);
-    }
-}
-
-/*!
-    Returns the list of supported buffer image capture formats.
-
-    \since 1.1
-    \sa bufferFormat() setBufferFormat()
-*/
-QList<QVideoFrame::PixelFormat> QCameraImageCapture::supportedBufferFormats() const
-{
-    if (d_func()->bufferFormatControl)
-        return d_func()->bufferFormatControl->supportedBufferFormats();
-    else
-        return QList<QVideoFrame::PixelFormat>();
-}
-
-/*!
-    Returns the buffer image capture format being used.
-
-    \since 1.2
-    \sa supportedBufferCaptureFormats() setBufferCaptureFormat()
-*/
-QVideoFrame::PixelFormat QCameraImageCapture::bufferFormat() const
-{
-    if (d_func()->bufferFormatControl)
-        return d_func()->bufferFormatControl->bufferFormat();
-    else
-        return QVideoFrame::Format_Invalid;
-}
-
-/*!
-    Sets the buffer image capture format to be used.
-
-    \since 1.2
-    \sa bufferCaptureFormat() supportedBufferCaptureFormats() captureDestination()
-*/
-void QCameraImageCapture::setBufferFormat(const QVideoFrame::PixelFormat format)
-{
-    if (d_func()->bufferFormatControl)
-        d_func()->bufferFormatControl->setBufferFormat(format);
-}
-
-/*!
-    Returns true if the image capture \a destination is supported; otherwise returns false.
-
-    \since 1.2
-    \sa captureDestination() setCaptureDestination()
-*/
-bool QCameraImageCapture::isCaptureDestinationSupported(QCameraImageCapture::CaptureDestinations destination) const
-{
-    if (d_func()->captureDestinationControl)
-        return d_func()->captureDestinationControl->isCaptureDestinationSupported(destination);
-    else
-        return destination == CaptureToFile;
-}
-
-/*!
-    Returns the image capture destination being used.
-
-    \since 1.2
-    \sa isCaptureDestinationSupported() setCaptureDestination()
-*/
-QCameraImageCapture::CaptureDestinations QCameraImageCapture::captureDestination() const
-{
-    if (d_func()->captureDestinationControl)
-        return d_func()->captureDestinationControl->captureDestination();
-    else
-        return CaptureToFile;
-}
-
-/*!
-    Sets the capture \a destination to be used.
-
-    \since 1.2
-    \sa isCaptureDestinationSupported() captureDestination()
-*/
-void QCameraImageCapture::setCaptureDestination(QCameraImageCapture::CaptureDestinations destination)
-{
-    Q_D(QCameraImageCapture);
-
-    if (d->captureDestinationControl)
-        d->captureDestinationControl->setCaptureDestination(destination);
-}
-
-/*!
-  \property QCameraImageCapture::readyForCapture
-   Indicates the service is ready to capture a an image immediately.
-  \since 1.1
-*/
-
-bool QCameraImageCapture::isReadyForCapture() const
-{
-    if (d_func()->control)
-        return d_func()->control->isReadyForCapture();
-    else
-        return false;
-}
-
-/*!
-    \fn QCameraImageCapture::readyForCaptureChanged(bool ready)
-
-    Signals that a camera's \a ready for capture state has changed.
-    \since 1.1
-*/
-
-
-/*!
-    Capture the image and save it to \a file.
-    This operation is asynchronous in majority of cases,
-    followed by signals QCameraImageCapture::imageCaptured(), QCameraImageCapture::imageSaved()
-    or QCameraImageCapture::error().
-
-    If an empty \a file is passed, the camera backend choses
-    the default location and naming scheme for photos on the system,
-    if only file name without full path is specified, the image will be saved to
-    the default directory, with a full path reported with imageCaptured() and imageSaved() signals.
-
-    QCameraImageCapture::capture returns the capture Id parameter, used with
-    imageExposed(), imageCaptured() and imageSaved() signals.
-    \since 1.1
-*/
-int QCameraImageCapture::capture(const QString &file)
-{
-    Q_D(QCameraImageCapture);
-
-    d->unsetError();
-
-    if (d->control) {
-        return d->control->capture(file);
-    } else {
-        d->error = NotSupportedFeatureError;
-        d->errorString = tr("Device does not support images capture.");
-
-        emit error(-1, d->error, d->errorString);
-    }
-
-    return -1;
-}
-
-/*!
-    Cancel incomplete capture requests.
-    Already captured and queused for proicessing images may be discarded.
-    \since 1.1
-*/
-void QCameraImageCapture::cancelCapture()
-{
-    Q_D(QCameraImageCapture);
-
-    d->unsetError();
-
-    if (d->control) {
-        d->control->cancelCapture();
-    } else {
-        d->error = NotSupportedFeatureError;
-        d->errorString = tr("Device does not support images capture.");
-
-        emit error(-1, d->error, d->errorString);
-    }
-}
-
-
-/*!
-    \enum QCameraImageCapture::Error
-
-    \value NoError         No Errors.
-    \value NotReadyError   The service is not ready for capture yet.
-    \value ResourceError   Device is not ready or not available.
-    \value NotSupportedFeatureError Device does not support stillimages capture.
-    \value FormatError     Current format is not supported.
-    \value OutOfSpaceError No space left on device.
-*/
-
-/*!
-    \enum QCameraImageCapture::DriveMode
-
-    \value SingleImageCapture Drive mode is capturing a single picture.
-*/
-
-/*!
-    \fn QCameraImageCapture::error(int id, QCameraImageCapture::Error error, const QString &errorString)
-
-    Signals that the capture request \a id has failed with an \a error
-    and \a errorString description.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCapture::bufferFormatChanged(QVideoFrame::PixelFormat format)
-
-    Signal emitted when the buffer \a format for the buffer image capture has changed.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraImageCapture::captureDestinationChanged(CaptureDestinations destination)
-
-    Signal emitted when the capture \a destination has changed.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraImageCapture::imageExposed(int id)
-
-    Signal emitted when the frame with request \a id was exposed.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCapture::imageCaptured(int id, const QImage &preview);
-
-    Signal emitted when the frame with request \a id was captured, but not processed and saved yet.
-    Frame \a preview can be displayed to user.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCapture::imageMetadataAvailable(int id, QtMultimedia::MetaData key, const QVariant &value)
-
-    Signals that a metadata for an image with request \a id is available.
-    This signal is emitted for metadata \a value with a \a key listed in QtMultimedia::MetaData enum.
-
-    This signal is emitted between imageExposed and imageSaved signals.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraImageCapture::imageMetadataAvailable(int id, const QString &key, const QVariant &value)
-
-    Signals that a metadata for an image with request \a id is available.
-    This signal is emitted for extended metadata \a value with a \a key not listed in QtMultimedia::MetaData enum.
-
-    This signal is emitted between imageExposed and imageSaved signals.
-    \since 1.2
-*/
-
-
-/*!
-    \fn QCameraImageCapture::imageAvailable(int id, const QVideoFrame &buffer)
-
-    Signal emitted when the frame with request \a id is available as \a buffer.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraImageCapture::imageSaved(int id, const QString &fileName)
-
-    Signal emitted when the frame with request \a id was saved to \a fileName.
-    \since 1.1
-*/
-
-
-#include "moc_qcameraimagecapture.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qcameraimagecapture.h b/src/multimedia/qcameraimagecapture.h
deleted file mode 100644
index bc41622..0000000
--- a/src/multimedia/qcameraimagecapture.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAIMAGECAPTURE_H
-#define QCAMERAIMAGECAPTURE_H
-
-#include <qmediaobject.h>
-#include <qmediaencodersettings.h>
-#include <qmediabindableinterface.h>
-#include <qvideoframe.h>
-
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QSize;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class QImageEncoderSettings;
-
-class QCameraImageCapturePrivate;
-class Q_MULTIMEDIA_EXPORT QCameraImageCapture : public QObject, public QMediaBindableInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(QMediaBindableInterface)
-    Q_ENUMS(Error)
-    Q_ENUMS(CaptureDestination)
-    Q_PROPERTY(bool readyForCapture READ isReadyForCapture NOTIFY readyForCaptureChanged)
-public:
-    enum Error
-    {
-        NoError,
-        NotReadyError,
-        ResourceError,
-        OutOfSpaceError,
-        NotSupportedFeatureError,
-        FormatError
-    };
-
-    enum DriveMode
-    {
-        SingleImageCapture
-    };
-
-    enum CaptureDestination
-    {
-        CaptureToFile = 0x01,
-        CaptureToBuffer = 0x02
-    };
-    Q_DECLARE_FLAGS(CaptureDestinations, CaptureDestination)
-
-    QCameraImageCapture(QMediaObject *mediaObject, QObject *parent = 0);
-    ~QCameraImageCapture();
-
-    bool isAvailable() const;
-    QtMultimedia::AvailabilityError availabilityError() const;
-
-    QMediaObject *mediaObject() const;
-
-    Error error() const;
-    QString errorString() const;
-
-    bool isReadyForCapture() const;
-
-    QStringList supportedImageCodecs() const;
-    QString imageCodecDescription(const QString &codecName) const;
-
-    QList<QSize> supportedResolutions(const QImageEncoderSettings &settings = QImageEncoderSettings(),
-                                      bool *continuous = 0) const;
-
-    QImageEncoderSettings encodingSettings() const;
-    void setEncodingSettings(const QImageEncoderSettings& settings);
-
-    QList<QVideoFrame::PixelFormat> supportedBufferFormats() const;
-    QVideoFrame::PixelFormat bufferFormat() const;
-    void setBufferFormat(QVideoFrame::PixelFormat format);
-
-    bool isCaptureDestinationSupported(CaptureDestinations destination) const;
-    CaptureDestinations captureDestination() const;
-    void setCaptureDestination(CaptureDestinations destination);
-
-public Q_SLOTS:
-    int capture(const QString &location = QString());
-    void cancelCapture();
-
-Q_SIGNALS:
-    void error(int id, QCameraImageCapture::Error error, const QString &errorString);
-
-    void readyForCaptureChanged(bool);
-    void bufferFormatChanged(QVideoFrame::PixelFormat);
-    void captureDestinationChanged(QCameraImageCapture::CaptureDestinations);
-
-    void imageExposed(int id);
-    void imageCaptured(int id, const QImage &preview);
-    void imageMetadataAvailable(int id, QtMultimedia::MetaData key, const QVariant &value);
-    void imageMetadataAvailable(int id, const QString &key, const QVariant &value);
-    void imageAvailable(int id, const QVideoFrame &image);
-    void imageSaved(int id, const QString &fileName);
-
-protected:
-    bool setMediaObject(QMediaObject *);
-
-    QCameraImageCapturePrivate *d_ptr;
-private:
-    Q_DISABLE_COPY(QCameraImageCapture)
-    Q_DECLARE_PRIVATE(QCameraImageCapture)
-    Q_PRIVATE_SLOT(d_func(), void _q_error(int, int, const QString &))
-    Q_PRIVATE_SLOT(d_func(), void _q_readyChanged(bool))
-    Q_PRIVATE_SLOT(d_func(), void _q_serviceDestroyed())
-};
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(QCameraImageCapture::CaptureDestinations)
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QCameraImageCapture::Error)
-Q_DECLARE_METATYPE(QCameraImageCapture::CaptureDestination)
-Q_DECLARE_METATYPE(QCameraImageCapture::CaptureDestinations)
-
-Q_MEDIA_ENUM_DEBUG(QCameraImageCapture, Error)
-Q_MEDIA_ENUM_DEBUG(QCameraImageCapture, CaptureDestination)
-
-QT_END_HEADER
-
-#endif
-
diff --git a/src/multimedia/qcameraimagecapturecontrol.cpp b/src/multimedia/qcameraimagecapturecontrol.cpp
deleted file mode 100644
index ad4c55e..0000000
--- a/src/multimedia/qcameraimagecapturecontrol.cpp
+++ /dev/null
@@ -1,208 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcameraimagecapturecontrol.h>
-#include <QtCore/qstringlist.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraImageCaptureControl
-
-    \brief The QCameraImageCaptureControl class provides a control interface
-    for image capture services.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.1
-
-
-
-    The interface name of QCameraImageCaptureControl is \c com.nokia.Qt.QCameraImageCaptureControl/1.0 as
-    defined in QCameraImageCaptureControl_iid.
-
-
-    \sa QMediaService::requestControl()
-*/
-
-/*!
-    \macro QCameraImageCaptureControl_iid
-
-    \c com.nokia.Qt.QCameraImageCaptureControl/1.0
-
-    Defines the interface name of the QCameraImageCaptureControl class.
-
-    \relates QCameraImageCaptureControl
-*/
-
-/*!
-    Constructs a new image capture control object with the given \a parent
-*/
-QCameraImageCaptureControl::QCameraImageCaptureControl(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys an image capture control.
-*/
-QCameraImageCaptureControl::~QCameraImageCaptureControl()
-{
-}
-
-/*!
-    \fn QCameraImageCaptureControl::isReadyForCapture() const
-
-    Identifies if a capture control is ready to perform a capture
-    immediately (all the resources necessary for image capture are allocated,
-    hardware initialized, flash is charged, etc).
-
-    Returns true if the camera is ready for capture; and false if it is not.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::readyForCaptureChanged(bool ready)
-
-    Signals that a capture control's \a ready state has changed.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::capture(const QString &fileName)
-
-    Initiates the capture of an image to \a fileName.
-    The \a fileName can be relative or empty,
-    in this case the service should use the system specific place
-    and file naming scheme.
-
-    Returns the capture request id number, which is used later
-    with imageExposed(), imageCaptured() and imageSaved() signals.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::cancelCapture()
-
-    Cancel pending capture requests.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::imageExposed(int requestId)
-
-    Signals that an image with it \a requestId
-    has just been exposed.
-    This signal can be used for the shutter sound or other indicaton.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::imageCaptured(int requestId, const QImage &preview)
-
-    Signals that an image with it \a requestId
-    has been captured and a \a preview is available.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::imageMetadataAvailable(int id, QtMultimedia::MetaData key, const QVariant &value)
-
-    Signals that a metadata for an image with request \a id is available.
-    This signal is emitted for metadata \a value with a \a key listed in QtMultimedia::MetaData enum.
-
-    This signal should be emitted between imageExposed and imageSaved signals.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::imageMetadataAvailable(int id, const QString &key, const QVariant &value)
-
-    Signals that a metadata for an image with request \a id is available.
-    This signal is emitted for extended metadata \a value with a \a key not listed in QtMultimedia::MetaData enum.
-
-    This signal should be emitted between imageExposed and imageSaved signals.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::imageAvailable(int requestId, const QVideoFrame &buffer)
-
-    Signals that a captured \a buffer with a \a requestId is available.
-    \since 1.2
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::imageSaved(int requestId, const QString &fileName)
-
-    Signals that a captured image with a \a requestId has been saved
-    to \a fileName.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::driveMode() const
-
-    Returns the current camera drive mode.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageCaptureControl::setDriveMode(QCameraImageCapture::DriveMode mode)
-
-    Sets the current camera drive \a mode.
-    \since 1.1
-*/
-
-
-/*!
-    \fn QCameraImageCaptureControl::error(int id, int error, const QString &errorString)
-
-    Signals the capture request \a id failed with \a error code and message \a errorString.
-
-    \since 1.1
-    \sa QCameraImageCapture::Error
-*/
-
-
-#include "moc_qcameraimagecapturecontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qcameraimagecapturecontrol.h b/src/multimedia/qcameraimagecapturecontrol.h
deleted file mode 100644
index 0459c14..0000000
--- a/src/multimedia/qcameraimagecapturecontrol.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAIMAGECAPTURECONTROL_H
-#define QCAMERAIMAGECAPTURECONTROL_H
-
-#include <qmediacontrol.h>
-#include <qcameraimagecapture.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QImage;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class Q_MULTIMEDIA_EXPORT QCameraImageCaptureControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    ~QCameraImageCaptureControl();
-
-    virtual bool isReadyForCapture() const = 0;
-
-    virtual QCameraImageCapture::DriveMode driveMode() const = 0;
-    virtual void setDriveMode(QCameraImageCapture::DriveMode mode) = 0;
-
-    virtual int capture(const QString &fileName) = 0;
-    virtual void cancelCapture() = 0;
-
-Q_SIGNALS:
-    void readyForCaptureChanged(bool);
-
-    void imageExposed(int id);
-    void imageCaptured(int id, const QImage &preview);
-    void imageMetadataAvailable(int id, QtMultimedia::MetaData key, const QVariant &value);
-    void imageMetadataAvailable(int id, const QString &key, const QVariant &value);
-    void imageAvailable(int id, const QVideoFrame &buffer);
-    void imageSaved(int id, const QString &fileName);
-
-    void error(int id, int error, const QString &errorString);
-
-protected:
-    QCameraImageCaptureControl(QObject* parent = 0);
-};
-
-#define QCameraImageCaptureControl_iid "com.nokia.Qt.QCameraImageCaptureControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraImageCaptureControl, QCameraImageCaptureControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QCAMERAIMAGECAPTURECONTROL_H
-
diff --git a/src/multimedia/qcameraimageprocessing.cpp b/src/multimedia/qcameraimageprocessing.cpp
deleted file mode 100644
index 8506067..0000000
--- a/src/multimedia/qcameraimageprocessing.cpp
+++ /dev/null
@@ -1,365 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qcameraimageprocessing.h"
-#include "qmediaobject_p.h"
-
-#include <qcameracontrol.h>
-#include <qcameraexposurecontrol.h>
-#include <qcamerafocuscontrol.h>
-#include <qmediarecordercontrol.h>
-#include <qcameraimageprocessingcontrol.h>
-#include <qcameraimagecapturecontrol.h>
-#include <qvideodevicecontrol.h>
-
-#include <QtCore/QDebug>
-
-namespace
-{
-    class QCameraImageProcessingPrivateRegisterMetaTypes
-    {
-    public:
-        QCameraImageProcessingPrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QCameraImageProcessing::WhiteBalanceMode>();
-        }
-    } _registerMetaTypes;
-}
-
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraImageProcessing
-
-
-    \brief The QCameraImageProcessing class provides interface for
-    focus and zoom related camera settings.
-
-    \inmodule QtMultimedia
-    \ingroup camera
-    \since 1.1
-
-*/
-
-
-class QCameraImageProcessingPrivate : public QMediaObjectPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QCameraImageProcessing)
-public:
-    void initControls();
-
-    QCameraImageProcessing *q_ptr;
-
-    QCamera *camera;
-    QCameraImageProcessingControl *imageControl;
-};
-
-
-void QCameraImageProcessingPrivate::initControls()
-{
-    imageControl = 0;
-
-    QMediaService *service = camera->service();
-    if (service)
-        imageControl = qobject_cast<QCameraImageProcessingControl *>(service->requestControl(QCameraImageProcessingControl_iid));
-}
-
-/*!
-    Construct a QCameraImageProcessing for \a camera.
-*/
-
-QCameraImageProcessing::QCameraImageProcessing(QCamera *camera):
-    QObject(camera), d_ptr(new QCameraImageProcessingPrivate)
-{
-    Q_D(QCameraImageProcessing);
-    d->camera = camera;
-    d->q_ptr = this;
-    d->initControls();
-}
-
-
-/*!
-    Destroys the camera focus object.
-*/
-
-QCameraImageProcessing::~QCameraImageProcessing()
-{
-}
-
-
-/*!
-    Returns true if image processing related settings are supported by this camera.
-    \since 1.1
-*/
-bool QCameraImageProcessing::isAvailable() const
-{
-    return d_func()->imageControl != 0;
-}
-
-
-/*!
-    Returns the white balance mode being used.
-    \since 1.1
-*/
-
-QCameraImageProcessing::WhiteBalanceMode QCameraImageProcessing::whiteBalanceMode() const
-{
-    return d_func()->imageControl ? d_func()->imageControl->whiteBalanceMode() : QCameraImageProcessing::WhiteBalanceAuto;
-}
-
-/*!
-    Sets the white balance to \a mode.
-    \since 1.1
-*/
-
-void QCameraImageProcessing::setWhiteBalanceMode(QCameraImageProcessing::WhiteBalanceMode mode)
-{
-    if (d_func()->imageControl)
-        d_func()->imageControl->setWhiteBalanceMode(mode);
-}
-
-/*!
-    Returns true if the white balance \a mode is supported.
-    \since 1.1
-*/
-
-bool QCameraImageProcessing::isWhiteBalanceModeSupported(QCameraImageProcessing::WhiteBalanceMode mode) const
-{
-    return d_func()->imageControl ? d_func()->imageControl->isWhiteBalanceModeSupported(mode) : false;
-}
-
-/*!
-    Returns the current color temperature if the
-    manual white balance is active, otherwise the
-    return value is undefined.
-    \since 1.1
-*/
-
-int QCameraImageProcessing::manualWhiteBalance() const
-{
-    QVariant value;
-
-    if (d_func()->imageControl)
-        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::ColorTemperature);
-
-    return value.toInt();
-}
-
-/*!
-    Sets manual white balance to \a colorTemperature
-    \since 1.1
-*/
-
-void QCameraImageProcessing::setManualWhiteBalance(int colorTemperature)
-{
-    if (d_func()->imageControl) {
-        d_func()->imageControl->setProcessingParameter(
-                    QCameraImageProcessingControl::ColorTemperature,
-                    QVariant(colorTemperature));
-    }
-}
-
-/*!
-    Return the contrast.
-    \since 1.1
-*/
-int QCameraImageProcessing::contrast() const
-{
-    QVariant value;
-
-    if (d_func()->imageControl)
-        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::Contrast);
-
-    return value.toInt();
-}
-
-/*!
-    Set the contrast to \a value.
-
-    Valid contrast values range between -100 and 100, the default is 0.
-    \since 1.1
-*/
-void QCameraImageProcessing::setContrast(int value)
-{
-    if (d_func()->imageControl)
-        d_func()->imageControl->setProcessingParameter(QCameraImageProcessingControl::Contrast,
-                                                       QVariant(value));
-}
-
-/*!
-    Returns the saturation value.
-    \since 1.1
-*/
-int QCameraImageProcessing::saturation() const
-{
-    QVariant value;
-
-    if (d_func()->imageControl)
-        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::Saturation);
-
-    return value.toInt();
-}
-
-/*!
-    Sets the saturation value to \a value.
-
-    Valid saturation values range between -100 and 100, the default is 0.
-    \since 1.1
-*/
-
-void QCameraImageProcessing::setSaturation(int value)
-{
-    if (d_func()->imageControl)
-        d_func()->imageControl->setProcessingParameter(QCameraImageProcessingControl::Saturation,
-                                                       QVariant(value));
-}
-
-/*!
-    Identifies if sharpening is supported.
-
-    Returns true if sharpening is supported; and false if it is not.
-    \since 1.1
-*/
-bool QCameraImageProcessing::isSharpeningSupported() const
-{
-    if (d_func()->imageControl)
-        return d_func()->imageControl->isProcessingParameterSupported(QCameraImageProcessingControl::Sharpening);
-    else
-        return false;
-}
-
-/*!
-    Returns the sharpening level.
-    \since 1.1
-*/
-int QCameraImageProcessing::sharpeningLevel() const
-{
-    QVariant value;
-
-    if (d_func()->imageControl)
-        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::Sharpening);
-
-    if (value.isNull())
-        return -1;
-    else
-        return value.toInt();
-}
-
-/*!
-    Sets the sharpening \a level.
-
-    Valid sharpening level values range between -1 for default sharpening level,
-    0 for sharpening disabled and 100 for maximum sharpening applied.
-    \since 1.1
-*/
-
-void QCameraImageProcessing::setSharpeningLevel(int level)
-{
-    Q_D(QCameraImageProcessing);
-    if (d->imageControl)
-        d->imageControl->setProcessingParameter(QCameraImageProcessingControl::Sharpening,
-                                                level == -1 ? QVariant() : QVariant(level));
-}
-
-/*!
-    Returns true if denoising is supported.
-    \since 1.1
-*/
-bool QCameraImageProcessing::isDenoisingSupported() const
-{
-    if (d_func()->imageControl)
-        return d_func()->imageControl->isProcessingParameterSupported(QCameraImageProcessingControl::Denoising);
-    else
-        return false;
-}
-
-/*!
-    Returns the denoising level.
-    \since 1.1
-*/
-int QCameraImageProcessing::denoisingLevel() const
-{
-    QVariant value;
-
-    if (d_func()->imageControl)
-        value = d_func()->imageControl->processingParameter(QCameraImageProcessingControl::Denoising);
-
-    if (value.isNull())
-        return -1;
-    else
-        return value.toInt();
-}
-
-/*!
-    Sets the denoising \a level.
-
-    Valid denoising level values range between -1 for default denoising level,
-    0 for denoising disabled and 100 for maximum denoising applied.
-    \since 1.1
-*/
-void QCameraImageProcessing::setDenoisingLevel(int level)
-{
-    Q_D(QCameraImageProcessing);
-    if (d->imageControl)
-        d->imageControl->setProcessingParameter(QCameraImageProcessingControl::Denoising,
-                                                level == -1 ? QVariant() : QVariant(level));
-}
-
-
-/*!
-    \enum QCameraImageProcessing::WhiteBalanceMode
-
-    \value WhiteBalanceManual       Manual white balance. In this mode the white balance should be set with
-                                    setManualWhiteBalance()
-    \value WhiteBalanceAuto         Auto white balance mode.
-    \value WhiteBalanceSunlight     Sunlight white balance mode.
-    \value WhiteBalanceCloudy       Cloudy white balance mode.
-    \value WhiteBalanceShade        Shade white balance mode.
-    \value WhiteBalanceTungsten     Tungsten white balance mode.
-    \value WhiteBalanceFluorescent  Fluorescent white balance mode.
-    \value WhiteBalanceFlash        Flash white balance mode.
-    \value WhiteBalanceSunset       Sunset white balance mode.
-    \value WhiteBalanceVendor       Vendor defined white balance mode.
-*/
-
-#include "moc_qcameraimageprocessing.cpp"
-QT_END_NAMESPACE
diff --git a/src/multimedia/qcameraimageprocessing.h b/src/multimedia/qcameraimageprocessing.h
deleted file mode 100644
index 42a7eb5..0000000
--- a/src/multimedia/qcameraimageprocessing.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAIMAGEPROCESSING_H
-#define QCAMERAIMAGEPROCESSING_H
-
-#include <QtCore/qstringlist.h>
-#include <QtCore/qpair.h>
-#include <QtCore/qsize.h>
-#include <QtCore/qpoint.h>
-#include <QtCore/qrect.h>
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-#include <qmediaservice.h>
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QCamera;
-
-class QCameraImageProcessingPrivate;
-class Q_MULTIMEDIA_EXPORT QCameraImageProcessing : public QObject
-{
-    Q_OBJECT
-    Q_ENUMS(WhiteBalanceMode)
-public:
-    enum WhiteBalanceMode {
-        WhiteBalanceAuto = 0,
-        WhiteBalanceManual = 1,
-        WhiteBalanceSunlight = 2,
-        WhiteBalanceCloudy = 3,
-        WhiteBalanceShade = 4,
-        WhiteBalanceTungsten = 5,
-        WhiteBalanceFluorescent = 6,
-        WhiteBalanceFlash = 7,
-        WhiteBalanceSunset = 8,
-        WhiteBalanceVendor = 1000
-    };
-
-    bool isAvailable() const;
-
-    WhiteBalanceMode whiteBalanceMode() const;
-    void setWhiteBalanceMode(WhiteBalanceMode mode);
-    bool isWhiteBalanceModeSupported(WhiteBalanceMode mode) const;
-    int manualWhiteBalance() const;
-    void setManualWhiteBalance(int colorTemperature);
-
-    int contrast() const;
-    void setContrast(int value);
-
-    int saturation() const;
-    void setSaturation(int value);
-
-    bool isSharpeningSupported() const;
-    int sharpeningLevel() const;
-    void setSharpeningLevel(int value);
-
-    bool isDenoisingSupported() const;
-    int denoisingLevel() const;
-    void setDenoisingLevel(int value);
-
-private:
-    friend class QCamera;
-    QCameraImageProcessing(QCamera *camera);
-    ~QCameraImageProcessing();
-
-    Q_DISABLE_COPY(QCameraImageProcessing)
-    Q_DECLARE_PRIVATE(QCameraImageProcessing)
-    QCameraImageProcessingPrivate *d_ptr;
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QCameraImageProcessing::WhiteBalanceMode)
-
-Q_MEDIA_ENUM_DEBUG(QCameraImageProcessing, WhiteBalanceMode)
-
-QT_END_HEADER
-
-#endif  // QCAMERAIMAGEPROCESSING_H
diff --git a/src/multimedia/qcameraimageprocessingcontrol.cpp b/src/multimedia/qcameraimageprocessingcontrol.cpp
deleted file mode 100644
index fb72a16..0000000
--- a/src/multimedia/qcameraimageprocessingcontrol.cpp
+++ /dev/null
@@ -1,181 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcameraimageprocessingcontrol.h>
-#include  "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace
-{
-    class QCameraImageProcessingControlPrivateRegisterMetaTypes
-    {
-    public:
-        QCameraImageProcessingControlPrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QCameraImageProcessingControl::ProcessingParameter>();
-        }
-    } _registerMetaTypes;
-}
-
-/*!
-    \class QCameraImageProcessingControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.1
-
-
-    \brief The QCameraImageProcessingControl class provides an abstract class
-    for controlling image processing parameters, like white balance,
-    contrast, saturation, sharpening and denoising.
-
-    The interface name of QCameraImageProcessingControl is \c com.nokia.Qt.QCameraImageProcessingControl/1.0 as
-    defined in QCameraImageProcessingControl_iid.
-
-
-
-    \sa QMediaService::requestControl(), QCamera
-*/
-
-/*!
-    \macro QCameraImageProcessingControl_iid
-
-    \c com.nokia.Qt.QCameraImageProcessingControl/1.0
-
-    Defines the interface name of the QCameraImageProcessingControl class.
-
-    \relates QCameraImageProcessingControl
-*/
-
-/*!
-    Constructs an image processing control object with \a parent.
-*/
-
-QCameraImageProcessingControl::QCameraImageProcessingControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destruct the image processing control object.
-*/
-
-QCameraImageProcessingControl::~QCameraImageProcessingControl()
-{
-}
-
-
-/*!
-    \fn QCameraImageProcessingControl::whiteBalanceMode() const
-    Return the white balance mode being used.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageProcessingControl::setWhiteBalanceMode(QCameraImageProcessing::WhiteBalanceMode mode)
-    Set the white balance mode to \a mode
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageProcessingControl::isWhiteBalanceModeSupported(QCameraImageProcessing::WhiteBalanceMode mode) const
-    Returns true if the white balance \a mode is supported.
-    The backend should support at least QCameraImageProcessing::WhiteBalanceAuto mode.
-    \since 1.1
-*/
-
-/*!
-    \fn bool QCameraImageProcessingControl::isProcessingParameterSupported(ProcessingParameter parameter) const
-
-    Returns true if the camera supports adjusting image processing \a parameter.
-
-    Usually the the supported settings is static,
-    but some parameter may not be available depending on other
-    camera settings, like presets.
-    In such case the currently supported parameters should be returned.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageProcessingControl::processingParameter(ProcessingParameter parameter) const
-    Returns the image processing \a parameter value.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraImageProcessingControl::setProcessingParameter(ProcessingParameter parameter, QVariant value)
-
-    Sets the image processing \a parameter \a value.
-    Passing the null or invalid QVariant value allows
-    backend to choose the suitable parameter value.
-
-    The valid values range depends on the parameter type,
-    for contrast, saturation and brightness value should be
-    between -100 and 100, the default is 0,
-
-    For sharpening and denoising the range is 0..100,
-    0 for sharpening or denoising disabled
-    and 100 for maximum sharpening/denoising applied.
-    \since 1.1
-*/
-
-/*!
-  \enum QCameraImageProcessingControl::ProcessingParameter
-
-  \value Contrast
-    Image contrast.
-  \value Saturation
-    Image saturation.
-  \value Brightness
-    Image brightness.
-  \value Sharpening
-    Amount of sharpening applied.
-  \value Denoising
-    Amount of denoising applied.
-  \value ColorTemperature
-    Color temperature in K. This value is used when the manual white balance mode is selected.
-  \value ExtendedParameter
-    The base value for platform specific extended parameters.
- */
-
-#include "moc_qcameraimageprocessingcontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qcameraimageprocessingcontrol.h b/src/multimedia/qcameraimageprocessingcontrol.h
deleted file mode 100644
index 8c73928..0000000
--- a/src/multimedia/qcameraimageprocessingcontrol.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERAIMAGEPROCESSINGCONTROL_H
-#define QCAMERAIMAGEPROCESSINGCONTROL_H
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-
-#include <qcamera.h>
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QCameraImageProcessingControl : public QMediaControl
-{
-    Q_OBJECT
-    Q_ENUMS(ProcessingParameter)
-
-public:
-    ~QCameraImageProcessingControl();
-
-    enum ProcessingParameter {
-        Contrast = 0,
-        Saturation = 1,
-        Brightness = 2,
-        Sharpening = 3,
-        Denoising = 4,
-        ColorTemperature = 5,
-        ExtendedParameter = 1000
-    };
-
-    virtual QCameraImageProcessing::WhiteBalanceMode whiteBalanceMode() const = 0;
-    virtual void setWhiteBalanceMode(QCameraImageProcessing::WhiteBalanceMode mode) = 0;
-    virtual bool isWhiteBalanceModeSupported(QCameraImageProcessing::WhiteBalanceMode) const = 0;
-
-    virtual bool isProcessingParameterSupported(ProcessingParameter) const = 0;
-    virtual QVariant processingParameter(ProcessingParameter parameter) const = 0;
-    virtual void setProcessingParameter(ProcessingParameter parameter, QVariant value) = 0;
-
-protected:
-    QCameraImageProcessingControl(QObject* parent = 0);
-};
-
-#define QCameraImageProcessingControl_iid "com.nokia.Qt.QCameraImageProcessingControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraImageProcessingControl, QCameraImageProcessingControl_iid)
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QCameraImageProcessingControl::ProcessingParameter)
-
-Q_MEDIA_ENUM_DEBUG(QCameraImageProcessingControl, ProcessingParameter)
-
-QT_END_HEADER
-
-#endif
-
diff --git a/src/multimedia/qcameralockscontrol.cpp b/src/multimedia/qcameralockscontrol.cpp
deleted file mode 100644
index 289a07b..0000000
--- a/src/multimedia/qcameralockscontrol.cpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qcameralockscontrol.h>
-#include  "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCameraLocksControl
-
-
-
-    \brief The QCameraLocksControl class is an abstract base class for
-    classes that control still cameras or video cameras.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.1
-
-    This service is provided by a QMediaService object via
-    QMediaService::control().  It is used by QCamera.
-
-    The interface name of QCameraLocksControl is \c com.nokia.Qt.QCameraLocksControl/1.0 as
-    defined in QCameraLocksControl_iid.
-
-
-    \sa QMediaService::requestControl(), QCamera
-*/
-
-/*!
-    \macro QCameraLocksControl_iid
-
-    \c com.nokia.Qt.QCameraLocksControl/1.0
-
-    Defines the interface name of the QCameraLocksControl class.
-
-    \relates QCameraLocksControl
-*/
-
-/*!
-    Constructs a camera locks control object with \a parent.
-*/
-
-QCameraLocksControl::QCameraLocksControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destruct the camera locks control object.
-*/
-
-QCameraLocksControl::~QCameraLocksControl()
-{
-}
-
-/*!
-    \fn QCameraLocksControl::supportedLocks() const
-
-    Returns the lock types, the camera supports.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraLocksControl::lockStatus(QCamera::LockType lock) const
-
-    Returns the camera \a lock status.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraLocksControl::searchAndLock(QCamera::LockTypes locks)
-
-    Request camera \a locks.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraLocksControl::unlock(QCamera::LockTypes locks)
-
-    Unlock camera \a locks.
-    \since 1.1
-*/
-
-/*!
-    \fn QCameraLocksControl::lockStatusChanged(QCamera::LockType lock, QCamera::LockStatus status, QCamera::LockChangeReason reason)
-
-    Signals the \a lock \a status was changed with a specified \a reason.
-    \since 1.1
-*/
-
-
-
-#include "moc_qcameralockscontrol.cpp"
-QT_END_NAMESPACE
diff --git a/src/multimedia/qcameralockscontrol.h b/src/multimedia/qcameralockscontrol.h
deleted file mode 100644
index 93120ee..0000000
--- a/src/multimedia/qcameralockscontrol.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCAMERALOCKSCONTROL_H
-#define QCAMERALOCKSCONTROL_H
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-
-#include <qcamera.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QCameraLocksControl : public QMediaControl
-{
-    Q_OBJECT
-public:
-    ~QCameraLocksControl();
-    
-    virtual QCamera::LockTypes supportedLocks() const = 0;
-
-    virtual QCamera::LockStatus lockStatus(QCamera::LockType lock) const = 0;
-
-    virtual void searchAndLock(QCamera::LockTypes locks) = 0;
-    virtual void unlock(QCamera::LockTypes locks) = 0;
-
-Q_SIGNALS:
-    void lockStatusChanged(QCamera::LockType type, QCamera::LockStatus status, QCamera::LockChangeReason reason);
-
-protected:
-    QCameraLocksControl(QObject* parent = 0);
-};
-
-#define QCameraLocksControl_iid "com.nokia.Qt.QCameraLocksControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QCameraLocksControl, QCameraLocksControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QCAMERALOCKSCONTROL_H
-
diff --git a/src/multimedia/qimageencodercontrol.cpp b/src/multimedia/qimageencodercontrol.cpp
deleted file mode 100644
index ee62a50..0000000
--- a/src/multimedia/qimageencodercontrol.cpp
+++ /dev/null
@@ -1,142 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qimageencodercontrol.h"
-#include <QtCore/qstringlist.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QImageEncoderControl
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-    \brief The QImageEncoderControl class provides access to the settings of a media service that
-    performs image encoding.
-
-    If a QMediaService supports encoding image data it will implement QImageEncoderControl.
-    This control allows to \l {setImageSettings()}{set image encoding settings} and
-    provides functions for quering supported image \l {supportedImageCodecs()}{codecs} and
-    \l {supportedResolutions()}{resolutions}.
-
-    The interface name of QImageEncoderControl is \c com.nokia.Qt.QImageEncoderControl/1.0 as
-    defined in QImageEncoderControl_iid.
-
-    \sa QImageEncoderSettings, QMediaService::requestControl()
-*/
-
-/*!
-    \macro QImageEncoderControl_iid
-
-    \c com.nokia.Qt.QImageEncoderControl/1.0
-
-    Defines the interface name of the QImageEncoderControl class.
-
-    \relates QImageEncoderControl
-*/
-
-/*!
-    Constructs a new image encoder control object with the given \a parent
-*/
-QImageEncoderControl::QImageEncoderControl(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys the image encoder control.
-*/
-QImageEncoderControl::~QImageEncoderControl()
-{
-}
-
-/*!
-    \fn QImageEncoderControl::supportedResolutions(const QImageEncoderSettings &settings = QImageEncoderSettings(),
-                                                   bool *continuous = 0) const
-
-    Returns a list of supported resolutions.
-
-    If non null image \a settings parameter is passed,
-    the returned list is reduced to resolutions supported with partial settings applied.
-    It can be used to query the list of resolutions, supported by specific image codec.
-
-    If the encoder supports arbitrary resolutions within the supported resolutions range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-    \since 1.0
-*/
-
-/*!
-    \fn QImageEncoderControl::supportedImageCodecs() const
-
-    Returns a list of supported image codecs.
-    \since 1.0
-*/
-
-/*!
-    \fn QImageEncoderControl::imageCodecDescription(const QString &codec) const
-
-    Returns a description of an image \a codec.
-    \since 1.0
-*/
-
-/*!
-    \fn QImageEncoderControl::imageSettings() const
-
-    Returns the currently used image encoder settings.
-
-    The returned value may be different tha passed to QImageEncoderControl::setImageSettings()
-    if the settings contains the default or undefined parameters.
-    In this case if the undefined parameters are already resolved, they should be returned.
-    \since 1.0
-*/
-
-/*!
-    \fn QImageEncoderControl::setImageSettings(const QImageEncoderSettings &settings)
-
-    Sets the selected image encoder \a settings.
-    \since 1.0
-*/
-
-#include "moc_qimageencodercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qimageencodercontrol.h b/src/multimedia/qimageencodercontrol.h
deleted file mode 100644
index c8a8261..0000000
--- a/src/multimedia/qimageencodercontrol.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QIMAGEENCODERCONTROL_H
-#define QIMAGEENCODERCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qmediarecorder.h"
-#include "qmediaencodersettings.h"
-
-#include <QtCore/qsize.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QByteArray;
-class QStringList;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class Q_MULTIMEDIA_EXPORT QImageEncoderControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QImageEncoderControl();    
-
-    virtual QStringList supportedImageCodecs() const = 0;
-    virtual QString imageCodecDescription(const QString &codecName) const = 0;
-
-    virtual QList<QSize> supportedResolutions(const QImageEncoderSettings &settings,
-                                              bool *continuous = 0) const = 0;
-
-    virtual QImageEncoderSettings imageSettings() const = 0;
-    virtual void setImageSettings(const QImageEncoderSettings &settings) = 0;
-
-protected:
-    QImageEncoderControl(QObject *parent = 0);
-};
-
-#define QImageEncoderControl_iid "com.nokia.Qt.QImageEncoderControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QImageEncoderControl, QImageEncoderControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
diff --git a/src/multimedia/qlocalmediaplaylistprovider.cpp b/src/multimedia/qlocalmediaplaylistprovider.cpp
deleted file mode 100644
index 84d54ec..0000000
--- a/src/multimedia/qlocalmediaplaylistprovider.cpp
+++ /dev/null
@@ -1,194 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qlocalmediaplaylistprovider.h"
-#include "qmediaplaylistprovider_p.h"
-#include "qmediacontent.h"
-
-QT_BEGIN_NAMESPACE
-
-class QLocalMediaPlaylistProviderPrivate: public QMediaPlaylistProviderPrivate
-{
-public:
-    QList<QMediaContent> resources;
-};
-
-QLocalMediaPlaylistProvider::QLocalMediaPlaylistProvider(QObject *parent)
-    :QMediaPlaylistProvider(*new QLocalMediaPlaylistProviderPrivate, parent)
-{
-}
-
-QLocalMediaPlaylistProvider::~QLocalMediaPlaylistProvider()
-{
-}
-
-bool QLocalMediaPlaylistProvider::isReadOnly() const
-{
-    return false;
-}
-
-int QLocalMediaPlaylistProvider::mediaCount() const
-{
-    return d_func()->resources.size();
-}
-
-QMediaContent QLocalMediaPlaylistProvider::media(int pos) const
-{
-    return d_func()->resources.value(pos);
-}
-
-bool QLocalMediaPlaylistProvider::addMedia(const QMediaContent &content)
-{
-    Q_D(QLocalMediaPlaylistProvider);
-
-    int pos = d->resources.count();
-
-    emit mediaAboutToBeInserted(pos, pos);
-    d->resources.append(content);
-    emit mediaInserted(pos, pos);
-
-    return true;
-}
-
-bool QLocalMediaPlaylistProvider::addMedia(const QList<QMediaContent> &items)
-{
-    Q_D(QLocalMediaPlaylistProvider);
-
-    if (items.isEmpty())
-        return true;
-
-    int pos = d->resources.count();
-    int end = pos+items.count()-1;
-
-    emit mediaAboutToBeInserted(pos, end);
-    d->resources.append(items);
-    emit mediaInserted(pos, end);
-
-    return true;
-}
-
-
-bool QLocalMediaPlaylistProvider::insertMedia(int pos, const QMediaContent &content)
-{
-    Q_D(QLocalMediaPlaylistProvider);
-
-    emit mediaAboutToBeInserted(pos, pos);
-    d->resources.insert(pos, content);
-    emit mediaInserted(pos,pos);
-
-    return true;
-}
-
-bool QLocalMediaPlaylistProvider::insertMedia(int pos, const QList<QMediaContent> &items)
-{
-    Q_D(QLocalMediaPlaylistProvider);
-
-    if (items.isEmpty())
-        return true;
-
-    const int last = pos+items.count()-1;
-
-    emit mediaAboutToBeInserted(pos, last);
-    for (int i=0; i<items.count(); i++)
-        d->resources.insert(pos+i, items.at(i));
-    emit mediaInserted(pos, last);
-
-    return true;
-}
-
-bool QLocalMediaPlaylistProvider::removeMedia(int fromPos, int toPos)
-{
-    Q_D(QLocalMediaPlaylistProvider);
-
-    Q_ASSERT(fromPos >= 0);
-    Q_ASSERT(fromPos <= toPos);
-    Q_ASSERT(toPos < mediaCount());
-
-    emit mediaAboutToBeRemoved(fromPos, toPos);
-    d->resources.erase(d->resources.begin()+fromPos, d->resources.begin()+toPos+1);
-    emit mediaRemoved(fromPos, toPos);
-
-    return true;
-}
-
-bool QLocalMediaPlaylistProvider::removeMedia(int pos)
-{
-    Q_D(QLocalMediaPlaylistProvider);
-
-    emit mediaAboutToBeRemoved(pos, pos);
-    d->resources.removeAt(pos);
-    emit mediaRemoved(pos, pos);
-
-    return true;
-}
-
-bool QLocalMediaPlaylistProvider::clear()
-{
-    Q_D(QLocalMediaPlaylistProvider);
-    if (!d->resources.isEmpty()) {
-        int lastPos = mediaCount()-1;
-        emit mediaAboutToBeRemoved(0, lastPos);
-        d->resources.clear();
-        emit mediaRemoved(0, lastPos);
-    }
-
-    return true;
-}
-
-void QLocalMediaPlaylistProvider::shuffle()
-{
-    Q_D(QLocalMediaPlaylistProvider);
-    if (!d->resources.isEmpty()) {
-        QList<QMediaContent> resources;
-
-        while (!d->resources.isEmpty()) {
-            resources.append(d->resources.takeAt(qrand() % d->resources.size()));
-        }
-
-        d->resources = resources;
-        emit mediaChanged(0, mediaCount()-1);
-    }
-
-}
-
-#include "moc_qlocalmediaplaylistprovider.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qlocalmediaplaylistprovider.h b/src/multimedia/qlocalmediaplaylistprovider.h
deleted file mode 100644
index e712a3f..0000000
--- a/src/multimedia/qlocalmediaplaylistprovider.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QLOCALMEDIAPAYLISTPROVIDER_H
-#define QLOCALMEDIAPAYLISTPROVIDER_H
-
-#include "qmediaplaylistprovider.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QLocalMediaPlaylistProviderPrivate;
-class Q_MULTIMEDIA_EXPORT QLocalMediaPlaylistProvider : public QMediaPlaylistProvider
-{
-    Q_OBJECT
-public:
-    QLocalMediaPlaylistProvider(QObject *parent=0);
-    virtual ~QLocalMediaPlaylistProvider();
-
-    virtual int mediaCount() const;
-    virtual QMediaContent media(int pos) const;
-
-    virtual bool isReadOnly() const;
-
-    virtual bool addMedia(const QMediaContent &content);
-    virtual bool addMedia(const QList<QMediaContent> &items);
-    virtual bool insertMedia(int pos, const QMediaContent &content);
-    virtual bool insertMedia(int pos, const QList<QMediaContent> &items);
-    virtual bool removeMedia(int pos);
-    virtual bool removeMedia(int start, int end);
-    virtual bool clear();
-
-public Q_SLOTS:
-    virtual void shuffle();
-
-private:
-    Q_DECLARE_PRIVATE(QLocalMediaPlaylistProvider)
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QLOCALMEDIAPAYLISTSOURCE_H
diff --git a/src/multimedia/qmediabackgroundplaybackcontrol.cpp b/src/multimedia/qmediabackgroundplaybackcontrol.cpp
deleted file mode 100644
index d7cbd38..0000000
--- a/src/multimedia/qmediabackgroundplaybackcontrol.cpp
+++ /dev/null
@@ -1,149 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediabackgroundplaybackcontrol.h"
-#include "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QMediaBackgroundPlaybackControl
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 5.0
-
-
-    \brief The QMediaBackgroundPlaybackControl class provides access to the background playback
-    related control of a QMediaService.
-
-    If a QMediaService can play media in background, it should implement QMediaBackgroundPlaybackControl.
-    This control provides a means to set the \l {setContextId()}{contextId} for application,
-    \l {acquire()}{acquire the resource for playback} and \l {release()} {release the playback resource}.
-
-    The interface name of QMediaBackgroundPlaybackControl is \c com.nokia.Qt.QMediaBackgroundPlaybackControl/1.0 as
-    defined in QMediaBackgroundPlaybackControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaPlayer
-*/
-
-/*!
-    \macro QMediaBackgroundPlaybackControl_iid
-
-    \c com.nokia.Qt.QMediaBackgroundPlaybackControl/1.0
-
-    Defines the interface name of the QMediaBackgroundPlaybackControl class.
-
-    \relates QMediaBackgroundPlaybackControl
-*/
-
-/*!
-    Destroys a media background playback control.
-*/
-QMediaBackgroundPlaybackControl::~QMediaBackgroundPlaybackControl()
-{
-}
-
-/*!
-    Constructs a new media background playback control with the given \a parent.
-*/
-QMediaBackgroundPlaybackControl::QMediaBackgroundPlaybackControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    \fn QMediaBackgroundPlaybackControl::setContextId(const QString& contextId)
-
-    Sets the contextId for the application, the last contextId will be released if previously set.
-    \l {acquire()}{acquire method} will be automatically invoked after setting a new contextId.
-
-    contextId is an unique string set by the application and is used by the background daemon to
-    distinguish and manage different context for different application.
-
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaBackgroundPlaybackControl::acquire()
-
-    Try to acquire the playback resource for current application
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaBackgroundPlaybackControl::release()
-
-    Give up the playback resource if current applicaiton holds it.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaBackgroundPlaybackControl::isAcquired()
-    \brief indicate whether the background playback resource is granted or not
-
-    It may take sometime for the backend to actually update this value before the first use.
-
-    By default this property is false
-
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaBackgroundPlaybackControl::acquired()
-
-    Signals that the playback resource is acquired
-
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaBackgroundPlaybackControl::lost()
-
-    Signals that the playback resource is lost
-
-    \since 1.0
-*/
-
-#include "moc_qmediabackgroundplaybackcontrol.cpp"
-QT_END_NAMESPACE
-
-
diff --git a/src/multimedia/qmediabackgroundplaybackcontrol.h b/src/multimedia/qmediabackgroundplaybackcontrol.h
deleted file mode 100644
index 2cf8d19..0000000
--- a/src/multimedia/qmediabackgroundplaybackcontrol.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIABACKGROUNDPLAYBACKCONTROL_H
-#define QMEDIABACKGROUNDPLAYBACKCONTROL_H
-
-#include "qmediacontrol.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QMediaBackgroundPlaybackControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QMediaBackgroundPlaybackControl();
-
-    virtual void setContextId(const QString& contextId) = 0;
-    virtual void acquire() = 0;
-    virtual void release() = 0;
-
-    virtual bool isAcquired() const = 0;
-
-Q_SIGNALS:
-    void acquired();
-    void lost();
-
-protected:
-    QMediaBackgroundPlaybackControl(QObject* parent = 0);
-};
-
-#define QMediaBackgroundPlaybackControl_iid "com.nokia.Qt.QMediaBackgroundPlaybackControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaBackgroundPlaybackControl, QMediaBackgroundPlaybackControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QMEDIABACKGROUNDPLAYBACKCONTROL_H
diff --git a/src/multimedia/qmediacontainercontrol.cpp b/src/multimedia/qmediacontainercontrol.cpp
deleted file mode 100644
index 5a4e618..0000000
--- a/src/multimedia/qmediacontainercontrol.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include "qmediacontainercontrol.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QMediaContainerControl
-
-    \brief The QMediaContainerControl class provides access to the output container format of a QMediaService
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-    If a QMediaService supports writing encoded data it will implement
-    QMediaContainerControl.  This control provides information about the output
-    containers supported by a media service and allows one to be selected as
-    the current output containers.
-
-    The functionality provided by this control is exposed to application code
-    through the QMediaRecorder class.
-
-    The interface name of QMediaContainerControl is \c com.nokia.Qt.QMediaContainerControl/1.0 as
-    defined in QMediaContainerControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaRecorder
-*/
-
-/*!
-    \macro QMediaContainerControl_iid
-
-    \c com.nokia.Qt.QMediaContainerControl/1.0
-
-    Defines the interface name of the QMediaContainerControl class.
-
-    \relates QMediaContainerControl
-*/
-
-/*!
-    Constructs a new media container control with the given \a parent.
-*/
-QMediaContainerControl::QMediaContainerControl(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys a media container control.
-*/
-QMediaContainerControl::~QMediaContainerControl()
-{
-}
-
-
-/*!
-    \fn QMediaContainerControl::supportedContainers() const
-
-    Returns a list of MIME types of supported container formats.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaContainerControl::containerMimeType() const
-
-    Returns the MIME type of the selected container format.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaContainerControl::setContainerMimeType(const QString &mimeType)
-
-    Sets the current container format to the format identified by the given \a mimeType.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaContainerControl::containerDescription(const QString &mimeType) const
-
-    Returns a description of the container format identified by the given \a mimeType.
-    \since 1.0
-*/
-
-#include "moc_qmediacontainercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediacontainercontrol.h b/src/multimedia/qmediacontainercontrol.h
deleted file mode 100644
index af48605..0000000
--- a/src/multimedia/qmediacontainercontrol.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef QMEDIACONTAINERCONTROL_H
-#define QMEDIACONTAINERCONTROL_H
-
-#include "qmediacontrol.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QMediaContainerControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QMediaContainerControl();
-
-    virtual QStringList supportedContainers() const = 0;
-    virtual QString containerMimeType() const = 0;
-    virtual void setContainerMimeType(const QString &formatMimeType) = 0;
-
-    virtual QString containerDescription(const QString &formatMimeType) const = 0;
-
-protected:
-    QMediaContainerControl(QObject *parent = 0);
-};
-
-#define QMediaContainerControl_iid "com.nokia.Qt.QMediaContainerControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaContainerControl, QMediaContainerControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QMEDIACONTAINERCONTROL_H
diff --git a/src/multimedia/qmediacontent.cpp b/src/multimedia/qmediacontent.cpp
deleted file mode 100644
index 373710c..0000000
--- a/src/multimedia/qmediacontent.cpp
+++ /dev/null
@@ -1,266 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QtCore/qurl.h>
-#include <QtCore/qvariant.h>
-
-#include "qmediacontent.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace
-{
-    class QMediaContentPrivateRegisterMetaTypes
-    {
-    public:
-        QMediaContentPrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QMediaContent>();
-        }
-    } _registerMetaTypes;
-}
-
-
-class QMediaContentPrivate : public QSharedData
-{
-public:
-    QMediaContentPrivate() {}
-    QMediaContentPrivate(const QMediaResourceList &r):
-        resources(r) {}
-
-    QMediaContentPrivate(const QMediaContentPrivate &other):
-        QSharedData(other),
-        resources(other.resources)
-    {}
-
-    bool operator ==(const QMediaContentPrivate &other) const
-    {
-        return resources == other.resources;
-    }
-
-    QMediaResourceList  resources;
-private:
-    QMediaContentPrivate& operator=(const QMediaContentPrivate &other);
-};
-
-
-/*!
-    \class QMediaContent
-
-    \brief The QMediaContent class provides access to the resources relating to a media content.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-    QMediaContent is used within the multimedia framework as the logical handle
-    to media content.  A QMediaContent object is composed of one or more
-    \l {QMediaResource}s where each resource provides the URL and format
-    information of a different encoding of the content.
-
-    A non-null QMediaContent will always have a primary or canonical reference to
-    the content available through the canonicalUrl() or canonicalResource()
-    methods, any additional resources are optional.
-*/
-
-
-/*!
-    Constructs a null QMediaContent.
-*/
-
-QMediaContent::QMediaContent()
-{
-}
-
-/*!
-    Constructs a media content with \a url providing a reference to the content.
-    \since 1.0
-*/
-
-QMediaContent::QMediaContent(const QUrl &url):
-    d(new QMediaContentPrivate)
-{
-    d->resources << QMediaResource(url);
-}
-
-/*!
-    Constructs a media content with \a request providing a reference to the content.
-
-    This constructor can be used to reference media content via network protocols such as HTTP.
-    This may include additional information required to obtain the resource, such as Cookies or HTTP headers.
-    \since 1.0
-*/
-
-QMediaContent::QMediaContent(const QNetworkRequest &request):
-    d(new QMediaContentPrivate)
-{
-    d->resources << QMediaResource(request);
-}
-
-/*!
-    Constructs a media content with \a resource providing a reference to the content.
-    \since 1.0
-*/
-
-QMediaContent::QMediaContent(const QMediaResource &resource):
-    d(new QMediaContentPrivate)
-{
-    d->resources << resource;
-}
-
-/*!
-    Constructs a media content with \a resources providing a reference to the content.
-    \since 1.0
-*/
-
-QMediaContent::QMediaContent(const QMediaResourceList &resources):
-    d(new QMediaContentPrivate(resources))
-{
-}
-
-/*!
-    Constructs a copy of the media content \a other.
-    \since 1.0
-*/
-
-QMediaContent::QMediaContent(const QMediaContent &other):
-    d(other.d)
-{
-}
-
-/*!
-    Destroys the media content object.
-*/
-
-QMediaContent::~QMediaContent()
-{
-}
-
-/*!
-    Assigns the value of \a other to this media content.
-    \since 1.0
-*/
-
-QMediaContent& QMediaContent::operator=(const QMediaContent &other)
-{
-    d = other.d;
-    return *this;
-}
-
-/*!
-    Returns true if \a other is equivalent to this media content; false otherwise.
-    \since 1.0
-*/
-
-bool QMediaContent::operator==(const QMediaContent &other) const
-{
-    return (d.constData() == 0 && other.d.constData() == 0) ||
-            (d.constData() != 0 && other.d.constData() != 0 &&
-             *d.constData() == *other.d.constData());
-}
-
-/*!
-    Returns true if \a other is not equivalent to this media content; false otherwise.
-    \since 1.0
-*/
-
-bool QMediaContent::operator!=(const QMediaContent &other) const
-{
-    return !(*this == other);
-}
-
-/*!
-    Returns true if this media content is null (uninitialized); false otherwise.
-    \since 1.0
-*/
-
-bool QMediaContent::isNull() const
-{
-    return d.constData() == 0;
-}
-
-/*!
-    Returns a QUrl that represents that canonical resource for this media content.
-    \since 1.0
-*/
-
-QUrl QMediaContent::canonicalUrl() const
-{
-    return canonicalResource().url();
-}
-
-/*!
-    Returns a QNetworkRequest that represents that canonical resource for this media content.
-    \since 1.0
-*/
-
-QNetworkRequest QMediaContent::canonicalRequest() const
-{
-    return canonicalResource().request();
-}
-
-/*!
-    Returns a QMediaResource that represents that canonical resource for this media content.
-    \since 1.0
-*/
-
-QMediaResource QMediaContent::canonicalResource() const
-{
-    return d.constData() != 0
-            ?  d->resources.value(0)
-            : QMediaResource();
-}
-
-/*!
-    Returns a list of alternative resources for this media content.  The first item in this list
-    is always the canonical resource.
-    \since 1.0
-*/
-
-QMediaResourceList QMediaContent::resources() const
-{
-    return d.constData() != 0
-            ? d->resources
-            : QMediaResourceList();
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediacontent.h b/src/multimedia/qmediacontent.h
deleted file mode 100644
index cfd109d..0000000
--- a/src/multimedia/qmediacontent.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIACONTENT_H
-#define QMEDIACONTENT_H
-
-#include <QtCore/qmetatype.h>
-#include <QtCore/qshareddata.h>
-
-#include "qmediaresource.h"
-
-#include <qtmultimediadefs.h>
-
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QMediaContentPrivate;
-class Q_MULTIMEDIA_EXPORT QMediaContent
-{
-public:
-    QMediaContent();
-    QMediaContent(const QUrl &contentUrl);
-    QMediaContent(const QNetworkRequest &contentRequest);
-    QMediaContent(const QMediaResource &contentResource);
-    QMediaContent(const QMediaResourceList &resources);
-    QMediaContent(const QMediaContent &other);
-    ~QMediaContent();
-
-    QMediaContent& operator=(const QMediaContent &other);
-
-    bool operator==(const QMediaContent &other) const;
-    bool operator!=(const QMediaContent &other) const;
-
-    bool isNull() const;
-
-    QUrl canonicalUrl() const;
-    QNetworkRequest canonicalRequest() const;
-    QMediaResource canonicalResource() const;
-
-    QMediaResourceList resources() const;
-
-private:
-    QSharedDataPointer<QMediaContentPrivate> d;
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QMediaContent)
-
-QT_END_HEADER
-
-#endif  // QMEDIACONTENT_H
diff --git a/src/multimedia/qmediaencodersettings.cpp b/src/multimedia/qmediaencodersettings.cpp
deleted file mode 100644
index 5f85eec..0000000
--- a/src/multimedia/qmediaencodersettings.cpp
+++ /dev/null
@@ -1,822 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaencodersettings.h"
-
-QT_BEGIN_NAMESPACE
-
-class QAudioEncoderSettingsPrivate  : public QSharedData
-{
-public:
-    QAudioEncoderSettingsPrivate() :
-        isNull(true),
-        encodingMode(QtMultimedia::ConstantQualityEncoding),
-        bitrate(-1),
-        sampleRate(-1),
-        channels(-1),
-        quality(QtMultimedia::NormalQuality)
-    {
-    }
-
-    QAudioEncoderSettingsPrivate(const QAudioEncoderSettingsPrivate &other):
-        QSharedData(other),
-        isNull(other.isNull),
-        encodingMode(other.encodingMode),
-        codec(other.codec),
-        bitrate(other.bitrate),
-        sampleRate(other.sampleRate),
-        channels(other.channels),
-        quality(other.quality)
-    {
-    }
-
-    bool isNull;
-    QtMultimedia::EncodingMode encodingMode;
-    QString codec;
-    int bitrate;
-    int sampleRate;
-    int channels;
-    QtMultimedia::EncodingQuality quality;
-
-private:
-    QAudioEncoderSettingsPrivate& operator=(const QAudioEncoderSettingsPrivate &other);
-};
-
-/*!
-    \class QAudioEncoderSettings
-
-    \brief The QAudioEncoderSettings class provides a set of audio encoder settings.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-    A audio encoder settings object is used to specify the audio encoder
-    settings used by QMediaRecorder.  Audio encoder settings are selected by
-    constructing a QAudioEncoderSettings object, setting the desired properties
-    and then passing it to a QMediaRecorder instance using the
-    QMediaRecorder::setEncodingSettings() function.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio encoder settings
-
-    \sa QMediaRecorder, QAudioEncoderControl
-*/
-
-/*!
-    Construct a null audio encoder settings object.
-*/
-QAudioEncoderSettings::QAudioEncoderSettings()
-    :d(new QAudioEncoderSettingsPrivate)
-{
-}
-
-/*!
-    Constructs a copy of the audio encoder settings object \a other.
-    \since 1.0
-*/
-
-QAudioEncoderSettings::QAudioEncoderSettings(const QAudioEncoderSettings& other)
-    :d(other.d)
-{
-}
-
-/*!
-    Destroys an audio encoder settings object.
-*/
-
-QAudioEncoderSettings::~QAudioEncoderSettings()
-{
-}
-
-/*!
-    Assigns the value of \a other to an audio encoder settings object.
-    \since 1.0
-*/
-
-QAudioEncoderSettings& QAudioEncoderSettings::operator=(const QAudioEncoderSettings &other)
-{
-    d = other.d;
-    return *this;
-}
-
-/*!
-    Determines if \a other is of equal value to an audio encoder settings
-    object.
-
-    Returns true if the settings objects are of equal value, and false if they
-    are not of equal value.
-    \since 1.0
-*/
-
-bool QAudioEncoderSettings::operator==(const QAudioEncoderSettings &other) const
-{
-    return (d == other.d) ||
-           (d->isNull == other.d->isNull &&
-            d->encodingMode == other.d->encodingMode &&
-            d->bitrate == other.d->bitrate &&
-            d->sampleRate == other.d->sampleRate &&
-            d->channels == other.d->channels &&
-            d->quality == other.d->quality &&
-            d->codec == other.d->codec);
-}
-
-/*!
-    Determines if \a other is of equal value to an audio encoder settings
-    object.
-
-    Returns true if the settings objects are not of equal value, and true if
-    they are of equal value.
-    \since 1.0
-*/
-
-bool QAudioEncoderSettings::operator!=(const QAudioEncoderSettings &other) const
-{
-    return !(*this == other);
-}
-
-/*!
-    Identifies if an audio settings object is initialized.
-
-    Returns true if the settings object is null, and false if it is not.
-    \since 1.0
-*/
-
-bool QAudioEncoderSettings::isNull() const
-{
-    return d->isNull;
-}
-
-/*!
-    Returns the audio encoding mode.
-
-    \since 1.0
-    \sa QtMultimedia::EncodingMode
-*/
-QtMultimedia::EncodingMode QAudioEncoderSettings::encodingMode() const
-{
-    return d->encodingMode;
-}
-
-/*!
-    Sets the audio encoding \a mode setting.
-
-    If QtMultimedia::ConstantQualityEncoding is set, the quality
-    encoding parameter is used and bit rate is ignored,
-    otherwise the bitrate is used.
-
-    The audio codec, channels count and sample rate settings are used in all
-    the encoding modes.
-
-    \since 1.0
-    \sa encodingMode(), QtMultimedia::EncodingMode
-*/
-void QAudioEncoderSettings::setEncodingMode(QtMultimedia::EncodingMode mode)
-{
-    d->encodingMode = mode;
-}
-
-/*!
-    Returns the audio codec.
-    \since 1.0
-*/
-QString QAudioEncoderSettings::codec() const
-{
-    return d->codec;
-}
-
-/*!
-    Sets the audio \a codec.
-    \since 1.0
-*/
-void QAudioEncoderSettings::setCodec(const QString& codec)
-{
-    d->isNull = false;
-    d->codec = codec;
-}
-
-/*!
-    Returns the bit rate of the compressed audio stream in bits per second.
-    \since 1.0
-*/
-int QAudioEncoderSettings::bitRate() const
-{
-    return d->bitrate;
-}
-
-/*!
-    Returns the number of audio channels.
-    \since 1.0
-*/
-int QAudioEncoderSettings::channelCount() const
-{
-    return d->channels;
-}
-
-/*!
-    Sets the number of audio \a channels.
-
-    A value of -1 indicates the encoder should make an optimal choice based on
-    what is available from the audio source and the limitations of the codec.
-    \since 1.0
-*/
-void QAudioEncoderSettings::setChannelCount(int channels)
-{
-    d->isNull = false;
-    d->channels = channels;
-}
-
-/*!
-    Sets the audio bit \a rate in bits per second.
-    \since 1.0
-*/
-void QAudioEncoderSettings::setBitRate(int rate)
-{
-    d->isNull = false;
-    d->bitrate = rate;
-}
-
-/*!
-    Returns the audio sample rate in Hz.
-    \since 1.0
-*/
-int QAudioEncoderSettings::sampleRate() const
-{
-    return d->sampleRate;
-}
-
-/*!
-    Sets the audio sample \a rate in Hz.
-
-    A value of -1 indicates the encoder should make an optimal choice based on what is avaialbe
-    from the audio source and the limitations of the codec.
-    \since 1.0
-  */
-void QAudioEncoderSettings::setSampleRate(int rate)
-{
-    d->isNull = false;
-    d->sampleRate = rate;
-}
-
-/*!
-    Returns the audio encoding quality.
-    \since 1.0
-*/
-
-QtMultimedia::EncodingQuality QAudioEncoderSettings::quality() const
-{
-    return d->quality;
-}
-
-/*!
-    Set the audio encoding \a quality.
-
-    Setting the audio quality parameter allows backend to choose the balanced
-    set of encoding parameters to achieve the desired quality level.
-
-    The \a quality settings parameter is only used in the
-    \l {QtMultimedia::ConstantQualityEncoding}{constant quality} \l{encodingMode()}{encoding mode}.
-    \since 1.0
-*/
-void QAudioEncoderSettings::setQuality(QtMultimedia::EncodingQuality quality)
-{
-    d->isNull = false;
-    d->quality = quality;
-}
-
-class QVideoEncoderSettingsPrivate  : public QSharedData
-{
-public:
-    QVideoEncoderSettingsPrivate() :
-        isNull(true),
-        encodingMode(QtMultimedia::ConstantQualityEncoding),
-        bitrate(-1),
-        frameRate(0),
-        quality(QtMultimedia::NormalQuality)
-    {
-    }
-
-    QVideoEncoderSettingsPrivate(const QVideoEncoderSettingsPrivate &other):
-        QSharedData(other),
-        isNull(other.isNull),
-        encodingMode(other.encodingMode),
-        codec(other.codec),
-        bitrate(other.bitrate),
-        resolution(other.resolution),
-        frameRate(other.frameRate),
-        quality(other.quality)
-    {
-    }
-
-    bool isNull;
-    QtMultimedia::EncodingMode encodingMode;
-    QString codec;
-    int bitrate;
-    QSize resolution;
-    qreal frameRate;
-    QtMultimedia::EncodingQuality quality;
-
-private:
-    QVideoEncoderSettingsPrivate& operator=(const QVideoEncoderSettingsPrivate &other);
-};
-
-/*!
-    \class QVideoEncoderSettings
-
-    \brief The QVideoEncoderSettings class provides a set of video encoder settings.
-    \since 1.0
-
-    A video encoder settings object is used to specify the video encoder
-    settings used by QMediaRecorder.  Video encoder settings are selected by
-    constructing a QVideoEncoderSettings object, setting the desired properties
-    and then passing it to a QMediaRecorder instance using the
-    QMediaRecorder::setEncodingSettings() function.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Video encoder settings
-
-    \sa QMediaRecorder, QVideoEncoderControl
-*/
-
-/*!
-    Constructs a null video encoder settings object.
-*/
-
-QVideoEncoderSettings::QVideoEncoderSettings()
-    :d(new QVideoEncoderSettingsPrivate)
-{
-}
-
-/*!
-    Constructs a copy of the video encoder settings object \a other.
-    \since 1.0
-*/
-
-QVideoEncoderSettings::QVideoEncoderSettings(const QVideoEncoderSettings& other)
-    :d(other.d)
-{
-}
-
-/*!
-    Destroys a video encoder settings object.
-*/
-
-QVideoEncoderSettings::~QVideoEncoderSettings()
-{
-}
-
-/*!
-    Assigns the value of \a other to a video encoder settings object.
-    \since 1.0
-*/
-QVideoEncoderSettings &QVideoEncoderSettings::operator=(const QVideoEncoderSettings &other)
-{
-    d = other.d;
-    return *this;
-}
-
-/*!
-    Determines if \a other is of equal value to a video encoder settings object.
-
-    Returns true if the settings objects are of equal value, and false if they
-    are not of equal value.
-    \since 1.0
-*/
-bool QVideoEncoderSettings::operator==(const QVideoEncoderSettings &other) const
-{
-    return (d == other.d) ||
-           (d->isNull == other.d->isNull &&
-            d->encodingMode == other.d->encodingMode &&
-            d->bitrate == other.d->bitrate &&
-            d->quality == other.d->quality &&
-            d->codec == other.d->codec &&
-            d->resolution == other.d->resolution &&
-            qFuzzyCompare(d->frameRate, other.d->frameRate));
-}
-
-/*!
-    Determines if \a other is of equal value to a video encoder settings object.
-
-    Returns true if the settings objects are not of equal value, and false if
-    they are of equal value.
-    \since 1.0
-*/
-bool QVideoEncoderSettings::operator!=(const QVideoEncoderSettings &other) const
-{
-    return !(*this == other);
-}
-
-/*!
-    Identifies if a video encoder settings object is uninitalized.
-
-    Returns true if the settings are null, and false if they are not.
-    \since 1.0
-*/
-bool QVideoEncoderSettings::isNull() const
-{
-    return d->isNull;
-}
-
-/*!
-    Returns the video encoding mode.
-
-    \since 1.0
-    \sa QtMultimedia::EncodingMode
-*/
-QtMultimedia::EncodingMode QVideoEncoderSettings::encodingMode() const
-{
-    return d->encodingMode;
-}
-
-/*!
-    Sets the video encoding \a mode.
-
-    If QtMultimedia::ConstantQualityEncoding is set,
-    the quality encoding parameter is used and bit rate is ignored,
-    otherwise the bitrate is used.
-
-    The rest of encoding settings are respected regardless of encoding mode.
-
-    \since 1.0
-    \sa QtMultimedia::EncodingMode
-*/
-void QVideoEncoderSettings::setEncodingMode(QtMultimedia::EncodingMode mode)
-{
-    d->isNull = false;
-    d->encodingMode = mode;
-}
-
-/*!
-    Returns the video codec.
-    \since 1.0
-*/
-
-QString QVideoEncoderSettings::codec() const
-{
-    return d->codec;
-}
-
-/*!
-    Sets the video \a codec.
-    \since 1.0
-*/
-void QVideoEncoderSettings::setCodec(const QString& codec)
-{
-    d->isNull = false;
-    d->codec = codec;
-}
-
-/*!
-    Returns bit rate of the encoded video stream in bits per second.
-    \since 1.0
-*/
-int QVideoEncoderSettings::bitRate() const
-{
-    return d->bitrate;
-}
-
-/*!
-    Sets the bit rate of the encoded video stream to \a value.
-    \since 1.0
-*/
-
-void QVideoEncoderSettings::setBitRate(int value)
-{
-    d->isNull = false;
-    d->bitrate = value;
-}
-
-/*!
-    Returns the video frame rate.
-    \since 1.0
-*/
-qreal QVideoEncoderSettings::frameRate() const
-{
-    return d->frameRate;
-}
-
-/*!
-    \fn QVideoEncoderSettings::setFrameRate(qreal rate)
-
-    Sets the video frame \a rate.
-
-    A value of 0 indicates the encoder should make an optimal choice based on what is available
-    from the video source and the limitations of the codec.
-    \since 1.0
-*/
-
-void QVideoEncoderSettings::setFrameRate(qreal rate)
-{
-    d->isNull = false;
-    d->frameRate = rate;
-}
-
-/*!
-    Returns the resolution of the encoded video.
-    \since 1.0
-*/
-
-QSize QVideoEncoderSettings::resolution() const
-{
-    return d->resolution;
-}
-
-/*!
-    Sets the \a resolution of the encoded video.
-
-    An empty QSize indicates the encoder should make an optimal choice based on
-    what is available from the video source and the limitations of the codec.
-    \since 1.0
-*/
-
-void QVideoEncoderSettings::setResolution(const QSize &resolution)
-{
-    d->isNull = false;
-    d->resolution = resolution;
-}
-
-/*!
-    Sets the \a width and \a height of the resolution of the encoded video.
-
-    \overload
-    \since 1.0
-*/
-
-void QVideoEncoderSettings::setResolution(int width, int height)
-{
-    d->isNull = false;
-    d->resolution = QSize(width, height);
-}
-
-/*!
-    Returns the video encoding quality.
-    \since 1.0
-*/
-
-QtMultimedia::EncodingQuality QVideoEncoderSettings::quality() const
-{
-    return d->quality;
-}
-
-/*!
-    Sets the video encoding \a quality.
-
-    Setting the video quality parameter allows backend to choose the balanced
-    set of encoding parameters to achieve the desired quality level.
-
-    The \a quality settings parameter is only used in the
-    \l {QtMultimedia::ConstantQualityEncoding}{constant quality} \l{encodingMode()}{encoding mode}.
-    The \a quality settings parameter is only used in the \l
-    {QtMultimedia::ConstantQualityEncoding}{constant quality}
-    \l{encodingMode()}{encoding mode}.
-    \since 1.0
-*/
-
-void QVideoEncoderSettings::setQuality(QtMultimedia::EncodingQuality quality)
-{
-    d->isNull = false;
-    d->quality = quality;
-}
-
-
-
-class QImageEncoderSettingsPrivate  : public QSharedData
-{
-public:
-    QImageEncoderSettingsPrivate() :
-        isNull(true),
-        quality(QtMultimedia::NormalQuality)
-    {
-    }
-
-    QImageEncoderSettingsPrivate(const QImageEncoderSettingsPrivate &other):
-        QSharedData(other),
-        isNull(other.isNull),
-        codec(other.codec),
-        resolution(other.resolution),
-        quality(other.quality)
-    {
-    }
-
-    bool isNull;
-    QString codec;
-    QSize resolution;
-    QtMultimedia::EncodingQuality quality;
-
-private:
-    QImageEncoderSettingsPrivate& operator=(const QImageEncoderSettingsPrivate &other);
-};
-
-/*!
-    \class QImageEncoderSettings
-
-
-    \brief The QImageEncoderSettings class provides a set of image encoder
-    settings.
-    \since 1.0
-
-    A image encoder settings object is used to specify the image encoder
-    settings used by QCameraImageCapture.  Image encoder settings are selected
-    by constructing a QImageEncoderSettings object, setting the desired
-    properties and then passing it to a QCameraImageCapture instance using the
-    QCameraImageCapture::setImageSettings() function.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Image encoder settings
-
-    \sa QImageEncoderControl
-*/
-
-/*!
-    Constructs a null image encoder settings object.
-*/
-
-QImageEncoderSettings::QImageEncoderSettings()
-    :d(new QImageEncoderSettingsPrivate)
-{
-}
-
-/*!
-    Constructs a copy of the image encoder settings object \a other.
-    \since 1.0
-*/
-
-QImageEncoderSettings::QImageEncoderSettings(const QImageEncoderSettings& other)
-    :d(other.d)
-{
-}
-
-/*!
-    Destroys a image encoder settings object.
-*/
-
-QImageEncoderSettings::~QImageEncoderSettings()
-{
-}
-
-/*!
-    Assigns the value of \a other to a image encoder settings object.
-    \since 1.0
-*/
-QImageEncoderSettings &QImageEncoderSettings::operator=(const QImageEncoderSettings &other)
-{
-    d = other.d;
-    return *this;
-}
-
-/*!
-    Determines if \a other is of equal value to a image encoder settings
-    object.
-
-    Returns true if the settings objects are of equal value, and false if they
-    are not of equal value.
-    \since 1.0
-*/
-bool QImageEncoderSettings::operator==(const QImageEncoderSettings &other) const
-{
-    return (d == other.d) ||
-           (d->isNull == other.d->isNull &&
-            d->quality == other.d->quality &&
-            d->codec == other.d->codec &&
-            d->resolution == other.d->resolution);
-
-}
-
-/*!
-    Determines if \a other is of equal value to a image encoder settings
-    object.
-
-    Returns true if the settings objects are not of equal value, and false if
-    they are of equal value.
-    \since 1.0
-*/
-bool QImageEncoderSettings::operator!=(const QImageEncoderSettings &other) const
-{
-    return !(*this == other);
-}
-
-/*!
-    Identifies if a image encoder settings object is uninitalized.
-
-    Returns true if the settings are null, and false if they are not.
-    \since 1.0
-*/
-bool QImageEncoderSettings::isNull() const
-{
-    return d->isNull;
-}
-
-/*!
-    Returns the image codec.
-    \since 1.0
-*/
-
-QString QImageEncoderSettings::codec() const
-{
-    return d->codec;
-}
-
-/*!
-    Sets the image \a codec.
-    \since 1.0
-*/
-void QImageEncoderSettings::setCodec(const QString& codec)
-{
-    d->isNull = false;
-    d->codec = codec;
-}
-
-/*!
-    Returns the resolution of the encoded image.
-    \since 1.0
-*/
-
-QSize QImageEncoderSettings::resolution() const
-{
-    return d->resolution;
-}
-
-/*!
-    Sets the \a resolution of the encoded image.
-
-    An empty QSize indicates the encoder should make an optimal choice based on
-    what is available from the image source and the limitations of the codec.
-    \since 1.0
-*/
-
-void QImageEncoderSettings::setResolution(const QSize &resolution)
-{
-    d->isNull = false;
-    d->resolution = resolution;
-}
-
-/*!
-    Sets the \a width and \a height of the resolution of the encoded image.
-
-    \overload
-    \since 1.0
-*/
-
-void QImageEncoderSettings::setResolution(int width, int height)
-{
-    d->isNull = false;
-    d->resolution = QSize(width, height);
-}
-
-/*!
-    Returns the image encoding quality.
-    \since 1.0
-*/
-
-QtMultimedia::EncodingQuality QImageEncoderSettings::quality() const
-{
-    return d->quality;
-}
-
-/*!
-    Sets the image encoding \a quality.
-    \since 1.0
-*/
-
-void QImageEncoderSettings::setQuality(QtMultimedia::EncodingQuality quality)
-{
-    d->isNull = false;
-    d->quality = quality;
-}
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaencodersettings.h b/src/multimedia/qmediaencodersettings.h
deleted file mode 100644
index 28bf6d6..0000000
--- a/src/multimedia/qmediaencodersettings.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAENCODERSETTINGS_H
-#define QMEDIAENCODERSETTINGS_H
-
-#include <QtCore/qsharedpointer.h>
-#include <QtCore/qstring.h>
-#include <QtCore/qsize.h>
-#include <qtmultimediadefs.h>
-#include "qtmedianamespace.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-
-class QAudioEncoderSettingsPrivate;
-class Q_MULTIMEDIA_EXPORT QAudioEncoderSettings
-{
-public:
-    QAudioEncoderSettings();
-    QAudioEncoderSettings(const QAudioEncoderSettings& other);
-
-    ~QAudioEncoderSettings();
-
-    QAudioEncoderSettings& operator=(const QAudioEncoderSettings &other);
-    bool operator==(const QAudioEncoderSettings &other) const;
-    bool operator!=(const QAudioEncoderSettings &other) const;
-
-    bool isNull() const;
-
-    QtMultimedia::EncodingMode encodingMode() const;
-    void setEncodingMode(QtMultimedia::EncodingMode);
-
-    QString codec() const;
-    void setCodec(const QString& codec);
-
-    int bitRate() const;
-    void setBitRate(int bitrate);
-
-    int channelCount() const;
-    void setChannelCount(int channels);
-
-    int sampleRate() const;
-    void setSampleRate(int rate);
-
-    QtMultimedia::EncodingQuality quality() const;
-    void setQuality(QtMultimedia::EncodingQuality quality);
-
-private:
-    QSharedDataPointer<QAudioEncoderSettingsPrivate> d;
-};
-
-class QVideoEncoderSettingsPrivate;
-class Q_MULTIMEDIA_EXPORT QVideoEncoderSettings
-{
-public:
-    QVideoEncoderSettings();
-    QVideoEncoderSettings(const QVideoEncoderSettings& other);
-
-    ~QVideoEncoderSettings();
-
-    QVideoEncoderSettings& operator=(const QVideoEncoderSettings &other);
-    bool operator==(const QVideoEncoderSettings &other) const;
-    bool operator!=(const QVideoEncoderSettings &other) const;
-
-    bool isNull() const;
-
-    QtMultimedia::EncodingMode encodingMode() const;
-    void setEncodingMode(QtMultimedia::EncodingMode);
-
-    QString codec() const;
-    void setCodec(const QString &);
-
-    QSize resolution() const;
-    void setResolution(const QSize &);
-    void setResolution(int width, int height);
-
-    qreal frameRate() const;
-    void setFrameRate(qreal rate);
-
-    int bitRate() const;
-    void setBitRate(int bitrate);
-
-    QtMultimedia::EncodingQuality quality() const;
-    void setQuality(QtMultimedia::EncodingQuality quality);
-
-private:
-    QSharedDataPointer<QVideoEncoderSettingsPrivate> d;
-};
-
-class QImageEncoderSettingsPrivate;
-class Q_MULTIMEDIA_EXPORT QImageEncoderSettings
-{
-public:
-    QImageEncoderSettings();
-    QImageEncoderSettings(const QImageEncoderSettings& other);
-
-    ~QImageEncoderSettings();
-
-    QImageEncoderSettings& operator=(const QImageEncoderSettings &other);
-    bool operator==(const QImageEncoderSettings &other) const;
-    bool operator!=(const QImageEncoderSettings &other) const;
-
-    bool isNull() const;
-
-    QString codec() const;
-    void setCodec(const QString &);
-
-    QSize resolution() const;
-    void setResolution(const QSize &);
-    void setResolution(int width, int height);
-
-    QtMultimedia::EncodingQuality quality() const;
-    void setQuality(QtMultimedia::EncodingQuality quality);
-
-private:
-    QSharedDataPointer<QImageEncoderSettingsPrivate> d;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
diff --git a/src/multimedia/qmediagaplessplaybackcontrol.cpp b/src/multimedia/qmediagaplessplaybackcontrol.cpp
deleted file mode 100644
index 84363e0..0000000
--- a/src/multimedia/qmediagaplessplaybackcontrol.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediagaplessplaybackcontrol.h"
-#include "qmediacontrol_p.h"
-
-/*!
-    \class QMediaGaplessPlaybackControl
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 5.0
-
-    \brief The QMediaGaplessPlaybackControl class provides access to the gapless playback
-    related control of a QMediaService.
-
-    If a QMediaService supports gapless playback it will implement QMediaGaplessPlaybackControl.
-    This control provides a means to set the \l {setNextMedia()}{next media} or
-    \l {setCrossfadeTime()}{crossfade time} for smooth transitions between tracks.
-
-    The functionality provided by this control is exposed to application
-    code through the QMediaPlayer class.
-
-    The interface name of QMediaGaplessPlaybackControl is
-    \c com.nokia.Qt.QMediaGaplessPlaybackControl/1.0 as defined in QMediaGaplessPlaybackControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaPlayer
-*/
-
-/*!
-    \macro QMediaGaplessPlaybackControl_iid
-
-    \c com.nokia.Qt.QMediaGaplessPlaybackControl/1.0
-
-    Defines the interface name of the QMediaGaplessPlaybackControl class.
-
-    \relates QMediaGaplessPlaybackControl
-*/
-
-/*!
-    Destroys a gapless playback control.
-*/
-QMediaGaplessPlaybackControl::~QMediaGaplessPlaybackControl()
-{
-}
-
-/*!
-    Constructs a new gapless playback control with the given \a parent.
-*/
-QMediaGaplessPlaybackControl::QMediaGaplessPlaybackControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    \fn QMediaGaplessPlaybackControl::nextMedia() const
-
-    Returns the content of the next media
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaGaplessPlaybackControl::setNextMedia(const QMediaContent& media)
-
-    Sets the next media for smooth transition.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaGaplessPlaybackControl::nextMediaChanged(const QMediaContent& media)
-
-    Signals that the next media has changed (either explicitly via \l setNextMedia() or when the
-    player clears the next media while advancing to it).
-
-    \since 1.0
-    \sa nextMedia()
-*/
-
-/*!
-    \fn QMediaGaplessPlaybackControl::advancedToNextMedia()
-
-    Signals when the player advances to the next media (the content of next media will be cleared).
-
-    \since 1.0
-    \sa nextMedia()
-*/
-
-/*!
-    \fn QMediaGaplessPlaybackControl::isCrossfadeSupported() const
-
-    Indicates whether crossfading is supported or not.
-    If crossfading is not supported, \l setCrossfadTime() will be ignored and \l crossfadeTime() will
-    always return 0.
-
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaGaplessPlaybackControl::setCrossfadeTime(qreal crossfadeTime)
-
-    Sets the crossfade time in seconds for smooth transition.
-
-    Positive value means how much time it will take for the next media to transit from silent to
-    full volume and vice versa for current one. So both current and the next one will be playing
-    during this period of time.
-
-    A crossfade time of zero or negative will result in gapless playback (suitable for some
-    continuous media).
-
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaGaplessPlaybackControl::crossfadeTime() const
-
-    Returns current crossfade time in seconds.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaGaplessPlaybackControl::crossfadeTimeChanged(qreal crossfadeTime)
-
-    Signals that the crossfade time has changed.
-
-    \since 1.0
-    \sa crossfadeTime()
-*/
-
diff --git a/src/multimedia/qmediagaplessplaybackcontrol.h b/src/multimedia/qmediagaplessplaybackcontrol.h
deleted file mode 100644
index 1ee548d..0000000
--- a/src/multimedia/qmediagaplessplaybackcontrol.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#ifndef QMEDIAGAPLESSPLAYBACKCONTROL_H
-#define QMEDIAGAPLESSPLAYBACKCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qmediacontent.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class Q_MULTIMEDIA_EXPORT QMediaGaplessPlaybackControl : public QMediaControl
-{
-    Q_OBJECT
-public:
-    virtual ~QMediaGaplessPlaybackControl();
-
-    virtual QMediaContent nextMedia() const = 0;
-    virtual void setNextMedia(const QMediaContent &media) = 0;
-
-    virtual bool isCrossfadeSupported() const = 0;
-    virtual qreal crossfadeTime() const = 0;
-    virtual void setCrossfadeTime(qreal crossfadeTime) = 0;
-
-Q_SIGNALS:
-    void crossfadeTimeChanged(qreal crossfadeTime);
-    void nextMediaChanged(const QMediaContent& media);
-    void advancedToNextMedia();
-
-protected:
-    QMediaGaplessPlaybackControl(QObject* parent = 0);
-};
-
-#define QMediaGaplessPlaybackControl_iid "com.nokia.Qt.QMediaGaplessPlaybackControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaGaplessPlaybackControl, QMediaGaplessPlaybackControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QMEDIAGAPLESSPLAYBACKCONTROL_H
diff --git a/src/multimedia/qmediaimageviewer.cpp b/src/multimedia/qmediaimageviewer.cpp
deleted file mode 100644
index 562aad4..0000000
--- a/src/multimedia/qmediaimageviewer.cpp
+++ /dev/null
@@ -1,617 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaimageviewer.h"
-
-#include "qmediaobject_p.h"
-#include "qmediaimageviewerservice_p.h"
-
-#include <qmediaplaylist.h>
-#include <qmediaplaylistsourcecontrol.h>
-#include <qmediacontent.h>
-#include <qmediaresource.h>
-#include "qvideosurfaceoutput_p.h"
-
-#include <QtCore/qcoreevent.h>
-#include <QtCore/qdatetime.h>
-#include <QtCore/qpointer.h>
-#include <QtCore/qtextstream.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace
-{
-    class QMediaImageViewerPrivateRegisterMetaTypes
-    {
-    public:
-        QMediaImageViewerPrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QMediaImageViewer::MediaStatus>();
-            qRegisterMetaType<QMediaImageViewer::State>();
-        }
-    } _registerMetaTypes;
-}
-
-class QMediaImageViewerPrivate : public QMediaObjectPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QMediaImageViewer)
-public:
-    QMediaImageViewerPrivate():
-        viewerControl(0), playlist(0),
-        state(QMediaImageViewer::StoppedState), timeout(3000), pauseTime(0)
-    {
-    }
-
-    void _q_mediaStatusChanged(QMediaImageViewer::MediaStatus status);
-    void _q_playlistMediaChanged(const QMediaContent &content);
-    void _q_playlistDestroyed();
-
-    QMediaImageViewerControl *viewerControl;
-    QMediaPlaylist *playlist;
-    QPointer<QObject> videoOutput;
-    QVideoSurfaceOutput surfaceOutput;
-    QMediaImageViewer::State state;
-    int timeout;
-    int pauseTime;
-    QTime time;
-    QBasicTimer timer;
-    QMediaContent media;
-};
-
-void QMediaImageViewerPrivate::_q_mediaStatusChanged(QMediaImageViewer::MediaStatus status)
-{
-    switch (status) {
-    case QMediaImageViewer::NoMedia:
-    case QMediaImageViewer::LoadingMedia:
-        emit q_func()->mediaStatusChanged(status);
-        break;
-    case QMediaImageViewer::LoadedMedia:
-        if (state == QMediaImageViewer::PlayingState) {
-            time.start();
-            timer.start(qMax(0, timeout), q_func());
-            q_func()->addPropertyWatch("elapsedTime");
-        }
-        emit q_func()->mediaStatusChanged(status);
-        emit q_func()->elapsedTimeChanged(0);
-        break;
-    case QMediaImageViewer::InvalidMedia:
-        emit q_func()->mediaStatusChanged(status);
-
-        if (state == QMediaImageViewer::PlayingState) {
-            playlist->next();
-            if (playlist->currentIndex() < 0)
-                emit q_func()->stateChanged(state = QMediaImageViewer::StoppedState);
-        }
-        break;
-    }
-}
-
-void QMediaImageViewerPrivate::_q_playlistMediaChanged(const QMediaContent &content)
-{
-    media = content;
-    pauseTime = 0;
-
-    viewerControl->showMedia(media);
-
-    emit q_func()->mediaChanged(media);
-}
-
-void QMediaImageViewerPrivate::_q_playlistDestroyed()
-{
-    playlist = 0;
-    timer.stop();
-
-    if (state != QMediaImageViewer::StoppedState)
-        emit q_func()->stateChanged(state = QMediaImageViewer::StoppedState);
-
-    q_func()->setMedia(QMediaContent());
-}
-
-/*!
-    \class QMediaImageViewer
-    \brief The QMediaImageViewer class provides a means of viewing image media.
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-
-    QMediaImageViewer is used together with a media display object such as
-    QVideoWidget to present an image.  A display object is attached to the
-    image viewer by means of the bind function.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Binding
-
-    QMediaImageViewer can be paired with a QMediaPlaylist to create a slide
-    show of images. Constructing a QMediaPlaylist with a pointer to an
-    instance of QMediaImageViewer will attach it to the image viewer;
-    changing the playlist's selection will then change the media displayed
-    by the image viewer.  With a playlist attached QMediaImageViewer's
-    play(), pause(), and stop() slots can be control the progression of the
-    playlist.  The \l timeout property determines how long an image is
-    displayed for before progressing to the next in the playlist, and the
-    \l elapsedTime property holds how the duration the current image has
-    been displayed for.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Playlist
-*/
-
-/*!
-    \enum QMediaImageViewer::State
-
-    Enumerates the possible control states an image viewer may be in.  The
-    control state of an image viewer determines whether the image viewer is
-    automatically progressing through images in an attached playlist.
-
-    \value StoppedState The image viewer is stopped, and will not automatically move to the next
-    image.  The \l elapsedTime is fixed at 0.
-    \value PlayingState The slide show is playing, and will move to the next image when the
-    \l elapsedTime reaches the \l timeout.  The \l elapsedTime is being incremented.
-    \value PausedState The image viewer is paused, and will not automatically move the to next
-    image.  The \l elapsedTime is fixed at the time the image viewer was paused.
-*/
-
-/*!
-    \enum QMediaImageViewer::MediaStatus
-
-    Enumerates the status of an image viewer's current media.
-
-    \value NoMedia  There is no current media.
-    \value LoadingMedia The image viewer is loading the current media.
-    \value LoadedMedia The image viewer has loaded the current media.
-    \value InvalidMedia The current media cannot be loaded.
-*/
-
-/*!
-    Constructs a new image viewer with the given \a parent.
-*/
-QMediaImageViewer::QMediaImageViewer(QObject *parent)
-    : QMediaObject(*new QMediaImageViewerPrivate, parent, new QMediaImageViewerService)
-{
-    Q_D(QMediaImageViewer);
-
-    d->viewerControl = qobject_cast<QMediaImageViewerControl*>(
-            d->service->requestControl(QMediaImageViewerControl_iid));
-
-    connect(d->viewerControl, SIGNAL(mediaStatusChanged(QMediaImageViewer::MediaStatus)),
-            this, SLOT(_q_mediaStatusChanged(QMediaImageViewer::MediaStatus)));
-}
-
-/*!
-    Destroys an image viewer.
-*/
-QMediaImageViewer::~QMediaImageViewer()
-{
-    Q_D(QMediaImageViewer);
-
-    delete d->service;
-}
-
-/*!
-    \property QMediaImageViewer::state
-    \brief the playlist control state of a slide show.
-    \since 1.0
-*/
-
-QMediaImageViewer::State QMediaImageViewer::state() const
-{
-    return d_func()->state;
-}
-
-/*!
-    \fn QMediaImageViewer::stateChanged(QMediaImageViewer::State state)
-
-    Signals that the playlist control \a state of an image viewer has changed.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaImageViewer::mediaStatus
-    \brief the status of the current media.
-    \since 1.0
-*/
-
-QMediaImageViewer::MediaStatus QMediaImageViewer::mediaStatus() const
-{
-    return d_func()->viewerControl->mediaStatus();
-}
-
-/*!
-    \fn QMediaImageViewer::mediaStatusChanged(QMediaImageViewer::MediaStatus status)
-
-    Signals the the \a status of the current media has changed.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaImageViewer::media
-    \brief the media an image viewer is presenting.
-    \since 1.0
-*/
-
-QMediaContent QMediaImageViewer::media() const
-{
-    Q_D(const QMediaImageViewer);
-
-    return d->media;
-}
-
-void QMediaImageViewer::setMedia(const QMediaContent &media)
-{
-    Q_D(QMediaImageViewer);
-
-    if (d->playlist && d->playlist->currentMedia() != media) {
-        disconnect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
-                   this, SLOT(_q_playlistMediaChanged(QMediaContent)));
-        disconnect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
-
-        d->playlist = 0;
-    }
-
-    d->media = media;
-
-    if (d->timer.isActive()) {
-        d->pauseTime = 0;
-        d->timer.stop();
-        removePropertyWatch("elapsedTime");
-        emit elapsedTimeChanged(0);
-    }
-
-    if (d->state != QMediaImageViewer::StoppedState)
-        emit stateChanged(d->state = QMediaImageViewer::StoppedState);
-
-    d->viewerControl->showMedia(d->media);
-
-    emit mediaChanged(d->media);
-}
-
-/*!
-  Use \a playlist as the source of images to be displayed in the viewer.
-  \since 1.0
-*/
-void QMediaImageViewer::setPlaylist(QMediaPlaylist *playlist)
-{
-    Q_D(QMediaImageViewer);
-
-    if (d->playlist) {
-        disconnect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
-                   this, SLOT(_q_playlistMediaChanged(QMediaContent)));
-        disconnect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
-
-        QMediaObject::unbind(d->playlist);
-    }
-
-    d->playlist = playlist;
-
-    if (d->playlist) {
-        connect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
-                this, SLOT(_q_playlistMediaChanged(QMediaContent)));
-        connect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
-
-        QMediaObject::bind(d->playlist);
-
-        setMedia(d->playlist->currentMedia());
-    } else {
-        setMedia(QMediaContent());
-    }
-}
-
-/*!
-  Returns the current playlist, or 0 if none.
-  \since 1.0
-*/
-QMediaPlaylist *QMediaImageViewer::playlist() const
-{
-    return d_func()->playlist;
-}
-
-/*!
-    \fn QMediaImageViewer::mediaChanged(const QMediaContent &media)
-
-    Signals that the \a media an image viewer is presenting has changed.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaImageViewer::timeout
-    \brief the amount of time in milliseconds an image is displayed for before moving to the next
-    image.
-
-    The timeout only applies if the image viewer has a playlist attached and is in the PlayingState.
-    \since 1.0
-*/
-
-int QMediaImageViewer::timeout() const
-{
-    return d_func()->timeout;
-}
-
-void QMediaImageViewer::setTimeout(int timeout)
-{
-    Q_D(QMediaImageViewer);
-
-    d->timeout = qMax(0, timeout);
-
-    if (d->timer.isActive())
-        d->timer.start(qMax(0, d->timeout - d->pauseTime - d->time.elapsed()), this);
-}
-
-/*!
-    \property QMediaImageViewer::elapsedTime
-    \brief the amount of time in milliseconds that has elapsed since the current image was loaded.
-
-    The elapsed time only increases while the image viewer is in the PlayingState.  If stopped the
-    elapsed time will be reset to 0.
-    \since 1.0
-*/
-
-int QMediaImageViewer::elapsedTime() const
-{
-    Q_D(const QMediaImageViewer);
-
-    int elapsedTime = d->pauseTime;
-
-    if (d->timer.isActive())
-        elapsedTime += d->time.elapsed();
-
-    return elapsedTime;
-}
-
-/*!
-    \fn QMediaImageViewer::elapsedTimeChanged(int time)
-
-    Signals that the amount of \a time in milliseconds since the current
-    image was loaded has changed.
-
-    This signal is emitted at a regular interval when the image viewer is
-    in the PlayingState and an image is loaded.  The notification interval
-    is controlled by the QMediaObject::notifyInterval property.
-
-    \since 1.0
-    \sa timeout, QMediaObject::notifyInterval
-*/
-
-/*!
-    Sets a video \a widget as the current video output.
-
-    This will unbind any previous video output bound with setVideoOutput().
-    \since 1.1
-*/
-
-void QMediaImageViewer::setVideoOutput(QVideoWidget *widget)
-{
-    Q_D(QMediaImageViewer);
-
-    if (d->videoOutput)
-        unbind(d->videoOutput);
-
-    // We don't know (in this library) that QVideoWidget inherits QObject
-    QObject *widgetObject = reinterpret_cast<QObject*>(widget);
-
-    d->videoOutput = widgetObject && bind(widgetObject) ? widgetObject : 0;
-}
-
-/*!
-    Sets a video \a item as the current video output.
-
-    This will unbind any previous video output bound with setVideoOutput().
-    \since 1.1
-*/
-
-void QMediaImageViewer::setVideoOutput(QGraphicsVideoItem *item)
-{
-    Q_D(QMediaImageViewer);
-
-    if (d->videoOutput)
-        unbind(d->videoOutput);
-
-    // We don't know (in this library) that QGraphicsVideoItem (multiply) inherits QObject
-    // but QObject inheritance depends on QObject coming first, so try this out.
-    QObject *itemObject = reinterpret_cast<QObject*>(item);
-
-    d->videoOutput = itemObject && bind(itemObject) ? itemObject : 0;
-}
-
-/*!
-    Sets a video \a surface as the video output of a image viewer.
-
-    If a video output has already been set on the image viewer the new surface
-    will replace it.
-    \since 1.2
-*/
-
-void QMediaImageViewer::setVideoOutput(QAbstractVideoSurface *surface)
-{
-    Q_D(QMediaImageViewer);
-
-    d->surfaceOutput.setVideoSurface(surface);
-
-    if (d->videoOutput != &d->surfaceOutput) {
-        if (d->videoOutput)
-            unbind(d->videoOutput);
-
-        d->videoOutput = bind(&d->surfaceOutput) ? &d->surfaceOutput : 0;
-    }
-}
-
-/*!
-    \internal
-    \since 1.0
-*/
-bool QMediaImageViewer::bind(QObject *object)
-{
-    if (QMediaPlaylist *playlist = qobject_cast<QMediaPlaylist *>(object)) {
-        setPlaylist(playlist);
-
-        return true;
-    } else {
-        return QMediaObject::bind(object);
-    }
-}
-
-/*!
-     \internal
-     \since 1.0
- */
-void QMediaImageViewer::unbind(QObject *object)
-{
-    if (object == d_func()->playlist)
-        setPlaylist(0);
-    else
-        QMediaObject::unbind(object);
-}
-
-/*!
-    Starts a slide show.
-
-    If the playlist has no current media this will start at the beginning of the playlist, otherwise
-    it will resume from the current media.
-
-    If no playlist is attached to an image viewer this will do nothing.
-    \since 1.0
-*/
-void QMediaImageViewer::play()
-{
-    Q_D(QMediaImageViewer);
-
-    if (d->playlist && d->playlist->mediaCount() > 0 && d->state != PlayingState) {
-        d->state = PlayingState;
-
-        switch (d->viewerControl->mediaStatus()) {
-        case NoMedia:
-        case InvalidMedia:
-            d->playlist->next();
-            if (d->playlist->currentIndex() < 0)
-                d->state = StoppedState;
-            break;
-        case LoadingMedia:
-            break;
-        case LoadedMedia:
-            d->time.start();
-            d->timer.start(qMax(0, d->timeout - d->pauseTime), this);
-            break;
-        }
-
-        if (d->state == PlayingState)
-            emit stateChanged(d->state);
-    }
-}
-
-/*!
-    Pauses a slide show.
-
-    The current media and elapsed time are retained.  If resumed, the current image will be
-    displayed for the remainder of the time out period before the next image is loaded.
-    \since 1.0
-*/
-void QMediaImageViewer::pause()
-{
-    Q_D(QMediaImageViewer);
-
-    if (d->state == PlayingState) {
-        if (d->viewerControl->mediaStatus() == LoadedMedia) {
-            d->pauseTime += d->timeout - d->time.elapsed();
-            d->timer.stop();
-            removePropertyWatch("elapsedTime");
-        }
-
-        emit stateChanged(d->state = PausedState);
-        emit elapsedTimeChanged(d->pauseTime);
-    }
-}
-
-/*!
-    Stops a slide show.
-
-    The current media is retained, but the elapsed time is discarded.  If resumed, the current
-    image will be displayed for the full time out period before the next image is loaded.
-    \since 1.0
-*/
-void QMediaImageViewer::stop()
-{
-    Q_D(QMediaImageViewer);
-
-    switch (d->state) {
-    case PlayingState:
-        d->timer.stop();
-        removePropertyWatch("elapsedTime");
-        // fall through.
-    case PausedState:
-        d->pauseTime = 0;
-        d->state = QMediaImageViewer::StoppedState;
-
-        emit stateChanged(d->state);
-        emit elapsedTimeChanged(0);
-        break;
-    case StoppedState:
-        break;
-    }
-}
-
-/*!
-    \reimp
-
-    \internal
-    \since 1.0
-*/
-void QMediaImageViewer::timerEvent(QTimerEvent *event)
-{
-    Q_D(QMediaImageViewer);
-
-    if (event->timerId() == d->timer.timerId()) {
-        d->timer.stop();
-        removePropertyWatch("elapsedTime");
-        emit elapsedTimeChanged(d->pauseTime = d->timeout);
-
-        d->playlist->next();
-
-        if (d->playlist->currentIndex() < 0) {
-            d->pauseTime = 0;
-            emit stateChanged(d->state = StoppedState);
-            emit elapsedTimeChanged(0);
-        }
-    } else {
-        QMediaObject::timerEvent(event);
-    }
-}
-
-#include "moc_qmediaimageviewer.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaimageviewer.h b/src/multimedia/qmediaimageviewer.h
deleted file mode 100644
index 7010fad..0000000
--- a/src/multimedia/qmediaimageviewer.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAIMAGEVIEWER_H
-#define QMEDIAIMAGEVIEWER_H
-
-#include "qmediaobject.h"
-#include "qmediacontent.h"
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QAbstractVideoSurface;
-class QGraphicsVideoItem;
-class QMediaPlaylist;
-class QVideoWidget;
-
-class QMediaImageViewerPrivate;
-class Q_MULTIMEDIA_EXPORT QMediaImageViewer : public QMediaObject
-{
-    Q_OBJECT
-    Q_PROPERTY(State state READ state NOTIFY stateChanged)
-    Q_PROPERTY(MediaStatus mediaStatus READ mediaStatus NOTIFY mediaStatusChanged)
-    Q_PROPERTY(QMediaContent media READ media WRITE setMedia NOTIFY mediaChanged)
-    Q_PROPERTY(int timeout READ timeout WRITE setTimeout)
-    Q_PROPERTY(int elapsedTime READ elapsedTime NOTIFY elapsedTimeChanged)
-    Q_ENUMS(State MediaStatus)
-
-public:
-    enum State
-    {
-        StoppedState,
-        PlayingState,
-        PausedState
-    };
-
-    enum MediaStatus
-    {
-        NoMedia,
-        LoadingMedia,
-        LoadedMedia,
-        InvalidMedia
-    };
-
-    explicit QMediaImageViewer(QObject *parent = 0);
-    ~QMediaImageViewer();
-
-    State state() const;
-    MediaStatus mediaStatus() const;
-
-    QMediaContent media() const;
-    QMediaPlaylist *playlist() const;
-
-    int timeout() const;
-    int elapsedTime() const;
-
-    void setVideoOutput(QVideoWidget *widget);
-    void setVideoOutput(QGraphicsVideoItem *item);
-    void setVideoOutput(QAbstractVideoSurface *surface);
-
-    bool bind(QObject *);
-    void unbind(QObject *);
-
-public Q_SLOTS:
-    void setMedia(const QMediaContent &media);
-    void setPlaylist(QMediaPlaylist *playlist);
-
-    void play();
-    void pause();
-    void stop();
-
-    void setTimeout(int timeout);
-
-Q_SIGNALS:
-    void stateChanged(QMediaImageViewer::State state);
-    void mediaStatusChanged(QMediaImageViewer::MediaStatus status);
-    void mediaChanged(const QMediaContent &media);
-    void elapsedTimeChanged(int time);
-protected:
-    void timerEvent(QTimerEvent *event);
-
-private:
-    Q_DECLARE_PRIVATE(QMediaImageViewer)
-    Q_PRIVATE_SLOT(d_func(), void _q_mediaStatusChanged(QMediaImageViewer::MediaStatus))
-    Q_PRIVATE_SLOT(d_func(), void _q_playlistMediaChanged(const QMediaContent &))
-    Q_PRIVATE_SLOT(d_func(), void _q_playlistDestroyed())
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QMediaImageViewer::State)
-Q_DECLARE_METATYPE(QMediaImageViewer::MediaStatus)
-
-Q_MEDIA_ENUM_DEBUG(QMediaImageViewer, State)
-Q_MEDIA_ENUM_DEBUG(QMediaImageViewer, MediaStatus)
-
-QT_END_HEADER
-
-#endif
diff --git a/src/multimedia/qmediaimageviewerservice.cpp b/src/multimedia/qmediaimageviewerservice.cpp
deleted file mode 100644
index 94c6d2e..0000000
--- a/src/multimedia/qmediaimageviewerservice.cpp
+++ /dev/null
@@ -1,463 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaimageviewerservice_p.h"
-
-#include "qmediacontrol_p.h"
-#include "qmediaservice_p.h"
-
-#include <qmediacontent.h>
-#include <qmediaresource.h>
-#include "qmediaobject_p.h"
-#include <qvideorenderercontrol.h>
-
-#include <QtCore/qdebug.h>
-
-#include <QtCore/qurl.h>
-#include <QtGui/qimagereader.h>
-
-#include <QtNetwork/qnetworkaccessmanager.h>
-#include <QtNetwork/qnetworkreply.h>
-#include <QtNetwork/qnetworkrequest.h>
-
-#include <qabstractvideosurface.h>
-#include <qvideosurfaceformat.h>
-
-QT_BEGIN_NAMESPACE
-
-class QMediaImageViewerServicePrivate : public QMediaServicePrivate
-{
-public:
-    QMediaImageViewerServicePrivate()
-        : viewerControl(0)
-        , rendererControl(0)
-        , network(0)
-        , internalNetwork(0)
-    {
-    }
-
-    bool load(QIODevice *device);
-    void clear();
-
-    QMediaImageViewerControl *viewerControl;
-    QMediaImageViewerRenderer *rendererControl;
-    QNetworkAccessManager *network;
-    QNetworkAccessManager *internalNetwork;
-    QImage m_image;
-};
-
-
-QMediaImageViewerRenderer::QMediaImageViewerRenderer(QObject *parent)
-    : QVideoRendererControl(parent)
-    , m_surface(0)
-{
-}
-
-QMediaImageViewerRenderer::~QMediaImageViewerRenderer()
-{
-    if (m_surface)
-        m_surface->stop();
-}
-
-QAbstractVideoSurface *QMediaImageViewerRenderer::surface() const
-{
-    return m_surface;
-}
-
-void QMediaImageViewerRenderer::setSurface(QAbstractVideoSurface *surface)
-{
-    if (m_surface)
-        m_surface->stop();
-
-    m_surface = surface;
-
-    if (m_surface && !m_image.isNull())
-        showImage(m_image);
-}
-
-void QMediaImageViewerRenderer::showImage(const QImage &image)
-{
-    m_image = image;
-
-    if (m_surface) {
-        if (m_image.isNull()) {
-            m_surface->stop();
-        } else {
-            QVideoSurfaceFormat format(
-                    image.size(), QVideoFrame::pixelFormatFromImageFormat(image.format()));
-
-            if (!m_surface->isFormatSupported(format)) {
-                foreach (QVideoFrame::PixelFormat pixelFormat, m_surface->supportedPixelFormats()) {
-                    const QImage::Format imageFormat
-                            = QVideoFrame::imageFormatFromPixelFormat(pixelFormat);
-
-                    if (imageFormat != QImage::Format_Invalid) {
-                        format = QVideoSurfaceFormat(image.size(), pixelFormat);
-
-                        if (m_surface->isFormatSupported(format) && m_surface->start(format)) {
-                            m_image = image.convertToFormat(imageFormat);
-
-                            m_surface->present(QVideoFrame(m_image));
-
-                            return;
-                        }
-                    }
-                }
-            } else if (m_surface->start(format)) {
-                m_surface->present(QVideoFrame(image));
-            }
-        }
-    }
-}
-
-bool QMediaImageViewerServicePrivate::load(QIODevice *device)
-{
-    QImageReader reader(device);
-
-    if (!reader.canRead()) {
-        m_image = QImage();
-    } else {
-        m_image = reader.read();
-    }
-
-    if (rendererControl)
-        rendererControl->showImage(m_image);
-
-    return !m_image.isNull();
-}
-
-void QMediaImageViewerServicePrivate::clear()
-{
-    m_image = QImage();
-
-    if (rendererControl)
-        rendererControl->showImage(m_image);
-}
-
-/*!
-    \class QMediaImageViewerService
-    \since 1.0
-    \internal
-*/
-
-/*!
-*/
-QMediaImageViewerService::QMediaImageViewerService(QObject *parent)
-    : QMediaService(*new QMediaImageViewerServicePrivate, parent)
-{
-    Q_D(QMediaImageViewerService);
-
-    d->viewerControl = new QMediaImageViewerControl(this);
-}
-
-/*!
-*/
-QMediaImageViewerService::~QMediaImageViewerService()
-{
-    Q_D(QMediaImageViewerService);
-
-    delete d->rendererControl;
-    delete d->viewerControl;
-}
-
-/*!
-*/
-QMediaControl *QMediaImageViewerService::requestControl(const char *name)
-{
-    Q_D(QMediaImageViewerService);
-
-    if (qstrcmp(name, QMediaImageViewerControl_iid) == 0) {
-        return d->viewerControl;
-    } else if (qstrcmp(name, QVideoRendererControl_iid) == 0) {
-        if (!d->rendererControl) {
-            d->rendererControl = new QMediaImageViewerRenderer;
-            d->rendererControl->showImage(d->m_image);
-
-            return d->rendererControl;
-        }
-    }
-    return 0;
-}
-
-void QMediaImageViewerService::releaseControl(QMediaControl *control)
-{
-    Q_D(QMediaImageViewerService);
-
-    if (!control) {
-        qWarning("QMediaService::releaseControl():"
-                " Attempted release of null control");
-    } else if (control == d->rendererControl) {
-        delete d->rendererControl;
-
-        d->rendererControl = 0;
-    }
-}
-
-/*!
-*/
-QNetworkAccessManager *QMediaImageViewerService::networkManager() const
-{
-    Q_D(const QMediaImageViewerService);
-
-    if (!d->network) {
-        QMediaImageViewerServicePrivate *_d = const_cast<QMediaImageViewerServicePrivate *>(d);
-
-        if (!_d->internalNetwork)
-            _d->internalNetwork = new QNetworkAccessManager(
-                    const_cast<QMediaImageViewerService *>(this));
-
-        _d->network = d->internalNetwork;
-    }
-
-    return d->network;
-}
-
-
-void QMediaImageViewerService::setNetworkManager(QNetworkAccessManager *manager)
-{
-    d_func()->network = manager;
-}
-
-class QMediaImageViewerControlPrivate : public QMediaControlPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QMediaImageViewerControl)
-public:
-    QMediaImageViewerControlPrivate()
-        : service(0)
-        , getReply(0)
-        , headReply(0)
-        , status(QMediaImageViewer::NoMedia)
-    {
-        foreach (const QByteArray &format, QImageReader::supportedImageFormats()) {
-            supportedExtensions.append(
-                    QLatin1Char('.') + QString::fromLatin1(format.data(), format.size()));
-        }
-    }
-
-    bool isImageType(const QUrl &url, const QString &mimeType) const;
-
-    void loadImage();
-    void cancelRequests();
-
-    void _q_getFinished();
-    void _q_headFinished();
-
-    QMediaImageViewerService *service;
-    QNetworkReply *getReply;
-    QNetworkReply *headReply;
-    QMediaImageViewer::MediaStatus status;
-    QMediaContent media;
-    QMediaResource currentMedia;
-    QList<QMediaResource> possibleResources;
-    QStringList supportedExtensions;
-};
-
-bool QMediaImageViewerControlPrivate::isImageType(const QUrl &url, const QString &mimeType) const
-{
-    if (!mimeType.isEmpty()) {
-        return mimeType.startsWith(QLatin1String("image/"))
-                || mimeType == QLatin1String("application/xml+svg");
-    } else if (url.scheme() == QLatin1String("file")) {
-        QString path = url.path();
-
-        foreach (const QString &extension, supportedExtensions) {
-            if (path.endsWith(extension, Qt::CaseInsensitive))
-                return true;
-        }
-    }
-    return false;
-}
-
-void QMediaImageViewerControlPrivate::loadImage()
-{
-    cancelRequests();
-
-    QMediaImageViewer::MediaStatus currentStatus = status;
-    status = QMediaImageViewer::InvalidMedia;
-
-    QNetworkAccessManager *network = service->networkManager();
-
-    while (!possibleResources.isEmpty() && !headReply && !getReply) {
-        currentMedia = possibleResources.takeFirst();
-
-        QUrl url = currentMedia.url();
-        QString mimeType = currentMedia.mimeType();
-
-        if (isImageType(url, mimeType)) {
-            getReply = network->get(QNetworkRequest(url));
-            QObject::connect(getReply, SIGNAL(finished()), q_func(), SLOT(_q_getFinished()));
-
-            status = QMediaImageViewer::LoadingMedia;
-        } else if (mimeType.isEmpty() && url.scheme() != QLatin1String("file")) {
-            headReply = network->head(QNetworkRequest(currentMedia.url()));
-            QObject::connect(headReply, SIGNAL(finished()), q_func(), SLOT(_q_headFinished()));
-
-            status = QMediaImageViewer::LoadingMedia;
-        }
-    }
-
-    if (status == QMediaImageViewer::InvalidMedia)
-        currentMedia = QMediaResource();
-
-    if (status != currentStatus)
-        emit q_func()->mediaStatusChanged(status);
-}
-
-void QMediaImageViewerControlPrivate::cancelRequests()
-{
-    if (getReply) {
-        getReply->abort();
-        getReply->deleteLater();
-        getReply = 0;
-    }
-
-    if (headReply) {
-        headReply->abort();
-        headReply->deleteLater();
-        headReply = 0;
-    }
-}
-
-void QMediaImageViewerControlPrivate::_q_getFinished()
-{
-    if (getReply != q_func()->sender())
-        return;
-
-    QImage image;
-
-    if (service->d_func()->load(getReply)) {
-        possibleResources.clear();
-
-        status = QMediaImageViewer::LoadedMedia;
-
-        emit q_func()->mediaStatusChanged(status);
-    } else {
-        loadImage();
-    }
-}
-
-void QMediaImageViewerControlPrivate::_q_headFinished()
-{
-    if (headReply != q_func()->sender())
-        return;
-
-    QString mimeType = headReply->header(QNetworkRequest::ContentTypeHeader)
-            .toString().section(QLatin1Char(';'), 0, 0);
-    QUrl url = headReply->url();
-    if (url.isEmpty())
-        url = headReply->request().url();
-
-    headReply->deleteLater();
-    headReply = 0;
-
-    if (isImageType(url, mimeType) || mimeType.isEmpty()) {
-        QNetworkAccessManager *network = service->networkManager();
-
-        getReply = network->get(QNetworkRequest(url));
-
-        QObject::connect(getReply, SIGNAL(finished()), q_func(), SLOT(_q_getFinished()));
-    } else {
-        loadImage();
-    }
-}
-
-/*!
-    \class QMediaImageViewerControl
-    \internal
-    \since 1.1
-*/
-QMediaImageViewerControl::QMediaImageViewerControl(QMediaImageViewerService *parent)
-    : QMediaControl(*new QMediaImageViewerControlPrivate, parent)
-{
-    Q_D(QMediaImageViewerControl);
-
-    d->service = parent;
-}
-
-/*!
-*/
-QMediaImageViewerControl::~QMediaImageViewerControl()
-{
-    Q_D(QMediaImageViewerControl);
-
-    delete d->getReply;
-}
-
-/*!
-    \since 1.1
-*/
-QMediaImageViewer::MediaStatus QMediaImageViewerControl::mediaStatus() const
-{
-    return d_func()->status;
-}
-
-/*!
-    \fn QMediaImageViewerControl::mediaStatusChanged(QMediaImageViewer::MediaStatus status);
-    \since 1.1
-*/
-
-/*!
-    \since 1.1
-*/
-void QMediaImageViewerControl::showMedia(const QMediaContent &media)
-{
-    Q_D(QMediaImageViewerControl);
-
-    d->media = media;
-    d->currentMedia = QMediaResource();
-    d->cancelRequests();
-
-    if (media.isNull()) {
-        d->service->d_func()->clear();
-        if (d->status != QMediaImageViewer::NoMedia) {
-            d->status = QMediaImageViewer::NoMedia;
-            emit mediaStatusChanged(d->status);
-        }
-    } else {
-        d->possibleResources = media.resources();
-        d->loadImage();
-    }
-}
-
-
-#include "moc_qmediaimageviewerservice_p.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaimageviewerservice_p.h b/src/multimedia/qmediaimageviewerservice_p.h
deleted file mode 100644
index d1b6956..0000000
--- a/src/multimedia/qmediaimageviewerservice_p.h
+++ /dev/null
@@ -1,147 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIASLIDESHOWSERVICE_P_H
-#define QMEDIASLIDESHOWSERVICE_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <qtmultimediadefs.h>
-#include <qmediaservice.h>
-#include <qmediaimageviewer.h>
-#include <qvideorenderercontrol.h>
-
-#include <QtCore/qpointer.h>
-#include <QtGui/qimage.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QAbstractVideoSurface;
-class QNetworkAccessManager;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class QMediaImageViewerServicePrivate;
-
-class Q_AUTOTEST_EXPORT QMediaImageViewerService : public QMediaService
-{
-    Q_OBJECT
-public:
-    explicit QMediaImageViewerService(QObject *parent = 0);
-    ~QMediaImageViewerService();
-
-    QMediaControl *requestControl(const char *name);
-    void releaseControl(QMediaControl *);
-
-    QNetworkAccessManager *networkManager() const;
-    void setNetworkManager(QNetworkAccessManager *manager);
-
-private:
-    Q_DECLARE_PRIVATE(QMediaImageViewerService)
-    friend class QMediaImageViewerControl;
-    friend class QMediaImageViewerControlPrivate;
-};
-
-class QMediaImageViewerControlPrivate;
-
-class QMediaImageViewerControl : public QMediaControl
-{
-    Q_OBJECT
-public:
-    explicit QMediaImageViewerControl(QMediaImageViewerService *parent);
-    ~QMediaImageViewerControl();
-
-    QMediaImageViewer::MediaStatus mediaStatus() const;
-
-    void showMedia(const QMediaContent &media);
-
-Q_SIGNALS:
-    void mediaStatusChanged(QMediaImageViewer::MediaStatus status);
-
-private:
-    Q_DECLARE_PRIVATE(QMediaImageViewerControl)
-    Q_PRIVATE_SLOT(d_func(), void _q_headFinished())
-    Q_PRIVATE_SLOT(d_func(), void _q_getFinished())
-};
-
-#define QMediaImageViewerControl_iid "com.nokia.Qt.QMediaImageViewerControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaImageViewerControl, QMediaImageViewerControl_iid)
-
-class QMediaImageViewerRenderer : public QVideoRendererControl
-{
-    Q_OBJECT
-public:
-    QMediaImageViewerRenderer(QObject *parent = 0);
-    ~QMediaImageViewerRenderer();
-
-    QAbstractVideoSurface *surface() const;
-    void setSurface(QAbstractVideoSurface *surface);
-
-    void showImage(const QImage &image);
-
-Q_SIGNALS:
-    void surfaceChanged(QAbstractVideoSurface *surface);
-
-private:
-    QPointer<QAbstractVideoSurface> m_surface;
-    QImage m_image;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
diff --git a/src/multimedia/qmedianetworkaccesscontrol.cpp b/src/multimedia/qmedianetworkaccesscontrol.cpp
deleted file mode 100644
index a976859..0000000
--- a/src/multimedia/qmedianetworkaccesscontrol.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmedianetworkaccesscontrol.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QMediaNetworkAccessControl
-    \preliminary
-    \brief The QMediaNetworkAccessControl class allows the setting of the Network Access Point for media related activities.
-    \ingroup multimedia-serv
-    \inmodule QtMultimedia
-    \since 1.2
-
-    The functionality provided by this control allows the
-    setting of a Network Access Point.
-
-    This control can be used to set a network access for various
-    network related activities. the exact nature in dependant on the underlying
-    usage by the supported QMediaObject
-*/
-
-QMediaNetworkAccessControl::QMediaNetworkAccessControl(QObject *parent) :
-    QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys a network access control.
-*/
-QMediaNetworkAccessControl::~QMediaNetworkAccessControl()
-{
-}
-
-/*!
-    \fn void QMediaNetworkAccessControl::setConfigurations(const QList<QNetworkConfiguration> &configurations);
-
-    \a configurations contains a list of network configurations to be used for network access.
-
-    It is assumed the list is given in highest to lowest preference order.
-    By calling this function all previous configurations will be invalidated
-    and replaced with the new list.
-    \since 1.2
-*/
-
-/*
-    \fn QNetworkConfiguration QMediaNetworkAccessControl::currentConfiguration() const
-
-    Returns the current active configuration in use.
-    A default constructed QNetworkConfigration is returned if no user supplied configuration are in use.
-*/
-
-
-/*!
-    \fn QMediaNetworkAccessControl::configurationChanged(const QNetworkConfiguration &configuration)
-    This signal is emitted when the current active network configuration changes
-    to \a configuration.
-    \since 1.2
-*/
-
-
-
-#include "moc_qmedianetworkaccesscontrol.cpp"
-QT_END_NAMESPACE
diff --git a/src/multimedia/qmedianetworkaccesscontrol.h b/src/multimedia/qmedianetworkaccesscontrol.h
deleted file mode 100644
index 22ee957..0000000
--- a/src/multimedia/qmedianetworkaccesscontrol.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef QMEDIANETWORKACCESSCONTROL_H
-#define QMEDIANETWORKACCESSCONTROL_H
-
-#include "qmediacontrol.h"
-
-#include <QtCore/qlist.h>
-#include <QtNetwork/qnetworkconfiguration.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QMediaNetworkAccessControl : public QMediaControl
-{
-    Q_OBJECT
-public:
-
-    virtual ~QMediaNetworkAccessControl();
-
-    virtual void setConfigurations(const QList<QNetworkConfiguration> &configuration) = 0;
-    virtual QNetworkConfiguration currentConfiguration() const = 0;
-
-Q_SIGNALS:
-    void configurationChanged(const QNetworkConfiguration& configuration);
-
-protected:
-    QMediaNetworkAccessControl(QObject *parent = 0);
-};
-
-#define QMediaNetworkAccessControl_iid "com.nokia.Qt.QMediaNetworkAccessControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaNetworkAccessControl, QMediaNetworkAccessControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
diff --git a/src/multimedia/qmediaplayer.cpp b/src/multimedia/qmediaplayer.cpp
deleted file mode 100644
index 312122d..0000000
--- a/src/multimedia/qmediaplayer.cpp
+++ /dev/null
@@ -1,1139 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaplayer.h"
-#include "qvideosurfaceoutput_p.h"
-
-#include "qmediaobject_p.h"
-#include <qmediaservice.h>
-#include <qmediaplayercontrol.h>
-#include <qmediaserviceprovider.h>
-#include <qmediaplaylist.h>
-#include <qmediaplaylistcontrol.h>
-#include <qmediaplaylistsourcecontrol.h>
-
-#include <qmedianetworkaccesscontrol.h>
-
-#include <QtCore/qcoreevent.h>
-#include <QtCore/qmetaobject.h>
-#include <QtCore/qtimer.h>
-#include <QtCore/qdebug.h>
-#include <QtCore/qpointer.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QMediaPlayer
-    \brief The QMediaPlayer class allows the playing of a media source.
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-
-
-    The QMediaPlayer class is a high level media playback class. It can be used
-    to playback such content as songs, movies and internet radio. The content
-    to playback is specified as a QMediaContent, which can be thought of as a
-    main or canonical URL with addition information attached. When provided
-    with a QMediaContent playback may be able to commence.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Player
-
-    QVideoWidget can be used with QMediaPlayer for video rendering and QMediaPlaylist
-    for accessing playlist functionality.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Movie playlist
-
-    \sa QMediaObject, QMediaService, QVideoWidget, QMediaPlaylist
-*/
-
-namespace
-{
-class MediaPlayerRegisterMetaTypes
-{
-public:
-    MediaPlayerRegisterMetaTypes()
-    {
-        qRegisterMetaType<QMediaPlayer::State>("QMediaPlayer::State");
-        qRegisterMetaType<QMediaPlayer::MediaStatus>("QMediaPlayer::MediaStatus");
-        qRegisterMetaType<QMediaPlayer::Error>("QMediaPlayer::Error");
-    }
-} _registerPlayerMetaTypes;
-}
-
-class QMediaPlayerPrivate : public QMediaObjectPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QMediaPlayer)
-
-public:
-    QMediaPlayerPrivate()
-        : provider(0)
-        , control(0)
-        , playlistSourceControl(0)
-        , state(QMediaPlayer::StoppedState)
-        , error(QMediaPlayer::NoError)
-        , filterStates(false)
-        , playlist(0)
-    {}
-
-    QMediaServiceProvider *provider;
-    QMediaPlayerControl* control;
-    QMediaPlaylistSourceControl* playlistSourceControl;
-    QMediaPlayer::State state;
-    QMediaPlayer::Error error;
-    QString errorString;
-    bool filterStates;
-
-    QPointer<QObject> videoOutput;
-    QMediaPlaylist *playlist;
-    QMediaNetworkAccessControl *networkAccessControl;
-    QVideoSurfaceOutput surfaceOutput;
-
-    void _q_stateChanged(QMediaPlayer::State state);
-    void _q_mediaStatusChanged(QMediaPlayer::MediaStatus status);
-    void _q_error(int error, const QString &errorString);
-    void _q_updateMedia(const QMediaContent&);
-    void _q_playlistDestroyed();
-};
-
-void QMediaPlayerPrivate::_q_stateChanged(QMediaPlayer::State ps)
-{
-    Q_Q(QMediaPlayer);
-
-    if (filterStates)
-        return;
-
-    if (playlist
-            && ps != state && ps == QMediaPlayer::StoppedState
-            && (control->mediaStatus() == QMediaPlayer::EndOfMedia ||
-                control->mediaStatus() == QMediaPlayer::InvalidMedia)) {
-        playlist->next();
-        ps = control->state();
-    }
-
-    if (ps != state) {
-        state = ps;
-
-        if (ps == QMediaPlayer::PlayingState)
-            q->addPropertyWatch("position");
-        else
-            q->removePropertyWatch("position");
-
-        emit q->stateChanged(ps);
-    }
-}
-
-void QMediaPlayerPrivate::_q_mediaStatusChanged(QMediaPlayer::MediaStatus status)
-{
-    Q_Q(QMediaPlayer);
-
-    switch (status) {
-    case QMediaPlayer::StalledMedia:
-    case QMediaPlayer::BufferingMedia:
-        q->addPropertyWatch("bufferStatus");
-        emit q->mediaStatusChanged(status);
-        break;
-    default:
-        q->removePropertyWatch("bufferStatus");
-        emit q->mediaStatusChanged(status);
-        break;
-    }
-
-}
-
-void QMediaPlayerPrivate::_q_error(int error, const QString &errorString)
-{
-    Q_Q(QMediaPlayer);
-
-    this->error = QMediaPlayer::Error(error);
-    this->errorString = errorString;
-
-    emit q->error(this->error);
-}
-
-void QMediaPlayerPrivate::_q_updateMedia(const QMediaContent &media)
-{
-    Q_Q(QMediaPlayer);
-
-    if (!control)
-        return;
-
-    const QMediaPlayer::State currentState = state;
-
-    filterStates = true;
-    control->setMedia(media, 0);
-
-    if (!media.isNull()) {
-        switch (currentState) {
-        case QMediaPlayer::PlayingState:
-            control->play();
-            break;
-        case QMediaPlayer::PausedState:
-            control->pause();
-            break;
-        default:
-            break;
-        }
-    }
-    filterStates = false;
-
-    state = control->state();
-
-    if (state != currentState) {
-        if (state == QMediaPlayer::PlayingState)
-            q->addPropertyWatch("position");
-        else
-            q->removePropertyWatch("position");
-
-        emit q->stateChanged(state);
-    }
-}
-
-void QMediaPlayerPrivate::_q_playlistDestroyed()
-{
-    playlist = 0;
-
-    if (!control)
-        return;
-
-    if (playlistSourceControl)
-        playlistSourceControl->setPlaylist(0);
-
-    control->setMedia(QMediaContent(), 0);
-}
-
-static QMediaService *playerService(QMediaPlayer::Flags flags, QMediaServiceProvider *provider)
-{
-    if (flags) {
-        QMediaServiceProviderHint::Features features = 0;
-        if (flags & QMediaPlayer::LowLatency)
-            features |= QMediaServiceProviderHint::LowLatencyPlayback;
-
-        if (flags & QMediaPlayer::StreamPlayback)
-            features |= QMediaServiceProviderHint::StreamPlayback;
-
-        if (flags & QMediaPlayer::VideoSurface)
-            features |= QMediaServiceProviderHint::VideoSurface;
-
-        return provider->requestService(Q_MEDIASERVICE_MEDIAPLAYER,
-                                        QMediaServiceProviderHint(features));
-    } else
-        return provider->requestService(Q_MEDIASERVICE_MEDIAPLAYER);
-}
-
-
-/*!
-    Construct a QMediaPlayer that uses the playback service from \a provider,
-    parented to \a parent and with \a flags.
-
-    If a playback service is not specified the system default will be used.
-    \since 1.0
-*/
-
-QMediaPlayer::QMediaPlayer(QObject *parent, QMediaPlayer::Flags flags, QMediaServiceProvider *provider):
-    QMediaObject(*new QMediaPlayerPrivate,
-                 parent,
-                 playerService(flags,provider))
-{
-    Q_D(QMediaPlayer);
-
-    d->provider = provider;
-
-    if (d->service == 0) {
-        d->error = ServiceMissingError;
-    } else {
-        d->control = qobject_cast<QMediaPlayerControl*>(d->service->requestControl(QMediaPlayerControl_iid));
-        d->playlistSourceControl = qobject_cast<QMediaPlaylistSourceControl*>(d->service->requestControl(QMediaPlaylistSourceControl_iid));
-        d->networkAccessControl = qobject_cast<QMediaNetworkAccessControl*>(d->service->requestControl(QMediaNetworkAccessControl_iid));
-        if (d->control != 0) {
-            connect(d->control, SIGNAL(mediaChanged(QMediaContent)), SIGNAL(mediaChanged(QMediaContent)));
-            connect(d->control, SIGNAL(stateChanged(QMediaPlayer::State)), SLOT(_q_stateChanged(QMediaPlayer::State)));
-            connect(d->control, SIGNAL(mediaStatusChanged(QMediaPlayer::MediaStatus)),
-                    SLOT(_q_mediaStatusChanged(QMediaPlayer::MediaStatus)));
-            connect(d->control, SIGNAL(error(int,QString)), SLOT(_q_error(int,QString)));
-
-            connect(d->control, SIGNAL(durationChanged(qint64)), SIGNAL(durationChanged(qint64)));
-            connect(d->control, SIGNAL(positionChanged(qint64)), SIGNAL(positionChanged(qint64)));
-            connect(d->control, SIGNAL(audioAvailableChanged(bool)), SIGNAL(audioAvailableChanged(bool)));
-            connect(d->control, SIGNAL(videoAvailableChanged(bool)), SIGNAL(videoAvailableChanged(bool)));
-            connect(d->control, SIGNAL(volumeChanged(int)), SIGNAL(volumeChanged(int)));
-            connect(d->control, SIGNAL(mutedChanged(bool)), SIGNAL(mutedChanged(bool)));
-            connect(d->control, SIGNAL(seekableChanged(bool)), SIGNAL(seekableChanged(bool)));
-            connect(d->control, SIGNAL(playbackRateChanged(qreal)), SIGNAL(playbackRateChanged(qreal)));
-            connect(d->control, SIGNAL(bufferStatusChanged(int)), SIGNAL(bufferStatusChanged(int)));
-
-            if (d->control->state() == PlayingState)
-                addPropertyWatch("position");
-
-            if (d->control->mediaStatus() == StalledMedia || d->control->mediaStatus() == BufferingMedia)
-                addPropertyWatch("bufferStatus");
-        }
-        if (d->networkAccessControl != 0) {
-            connect(d->networkAccessControl, SIGNAL(configurationChanged(QNetworkConfiguration)),
-            this, SIGNAL(networkConfigurationChanged(QNetworkConfiguration)));
-        }
-    }
-}
-
-
-/*!
-    Destroys the player object.
-*/
-
-QMediaPlayer::~QMediaPlayer()
-{
-    Q_D(QMediaPlayer);
-
-    if (d->service) {
-        if (d->control)
-            d->service->releaseControl(d->control);
-    }
-
-    d->provider->releaseService(d->service);
-}
-
-QMediaContent QMediaPlayer::media() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->media();
-
-    return QMediaContent();
-}
-
-/*!
-    Returns the stream source of media data.
-
-    This is only valid if a stream was passed to setMedia().
-
-    \since 1.0
-    \sa setMedia()
-*/
-
-const QIODevice *QMediaPlayer::mediaStream() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->mediaStream();
-
-    return 0;
-}
-
-QMediaPlaylist *QMediaPlayer::playlist() const
-{
-    return d_func()->playlistSourceControl ?
-            d_func()->playlistSourceControl->playlist() :
-            d_func()->playlist;
-}
-
-void QMediaPlayer::setPlaylist(QMediaPlaylist *playlist)
-{
-    Q_D(QMediaPlayer);
-
-    if (d->playlistSourceControl) {
-        if (d->playlistSourceControl->playlist())
-            disconnect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
-
-        d->playlistSourceControl->setPlaylist(playlist);
-
-        if (playlist)
-            connect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
-    } else {
-        if (d->playlist) {
-            disconnect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
-                    this, SLOT(_q_updateMedia(QMediaContent)));
-            disconnect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
-        }
-
-        d->playlist = playlist;
-
-        if (d->playlist) {
-            connect(d->playlist, SIGNAL(currentMediaChanged(QMediaContent)),
-                    this, SLOT(_q_updateMedia(QMediaContent)));
-            connect(d->playlist, SIGNAL(destroyed()), this, SLOT(_q_playlistDestroyed()));
-
-            if (d->control != 0)
-                d->control->setMedia(playlist->currentMedia(), 0);
-        } else {
-            setMedia(QMediaContent(), 0);
-        }
-
-    }
-}
-
-/*!
-    Sets the network access points for remote media playback.
-    \a configurations contains, in ascending preferential order, a list of
-    configuration  that can be used for network access.
-
-    This will invalidate the choice of previous configurations.
-    \since 1.2
-*/
-void QMediaPlayer::setNetworkConfigurations(const QList<QNetworkConfiguration> &configurations)
-{
-    Q_D(QMediaPlayer);
-
-    if (d->networkAccessControl)
-        d->networkAccessControl->setConfigurations(configurations);
-}
-
-QMediaPlayer::State QMediaPlayer::state() const
-{
-    return d_func()->state;
-}
-
-QMediaPlayer::MediaStatus QMediaPlayer::mediaStatus() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->mediaStatus();
-
-    return QMediaPlayer::UnknownMediaStatus;
-}
-
-qint64 QMediaPlayer::duration() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->duration();
-
-    return -1;
-}
-
-qint64 QMediaPlayer::position() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->position();
-
-    return 0;
-}
-
-int QMediaPlayer::volume() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->volume();
-
-    return 0;
-}
-
-bool QMediaPlayer::isMuted() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->isMuted();
-
-    return false;
-}
-
-int QMediaPlayer::bufferStatus() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->bufferStatus();
-
-    return 0;
-}
-
-bool QMediaPlayer::isAudioAvailable() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->isAudioAvailable();
-
-    return false;
-}
-
-bool QMediaPlayer::isVideoAvailable() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->isVideoAvailable();
-
-    return false;
-}
-
-bool QMediaPlayer::isSeekable() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->isSeekable();
-
-    return false;
-}
-
-qreal QMediaPlayer::playbackRate() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->control != 0)
-        return d->control->playbackRate();
-
-    return 0.0;
-}
-
-/*!
-    Returns the current error state.
-    \since 1.0
-*/
-
-QMediaPlayer::Error QMediaPlayer::error() const
-{
-    return d_func()->error;
-}
-
-QString QMediaPlayer::errorString() const
-{
-    return d_func()->errorString;
-}
-
-/*!
-    Returns the current network access point  in use.
-    If a default contructed QNetworkConfiguration is returned
-    this feature is not available or that none of the
-    current supplied configurations are in use.
-    \since 1.2
-*/
-QNetworkConfiguration QMediaPlayer::currentNetworkConfiguration() const
-{
-    Q_D(const QMediaPlayer);
-
-    if (d->networkAccessControl)
-        return d_func()->networkAccessControl->currentConfiguration();
-
-    return QNetworkConfiguration();
-}
-
-//public Q_SLOTS:
-/*!
-    Start or resume playing the current source.
-    \since 1.0
-*/
-
-void QMediaPlayer::play()
-{
-    Q_D(QMediaPlayer);
-
-    if (d->control == 0) {
-        QMetaObject::invokeMethod(this, "_q_error", Qt::QueuedConnection,
-                                    Q_ARG(int, QMediaPlayer::ServiceMissingError),
-                                    Q_ARG(QString, tr("The QMediaPlayer object does not have a valid service")));
-        return;
-    }
-
-    //if playlist control is available, the service should advance itself
-    if (d->playlist && d->playlist->currentIndex() == -1 && !d->playlist->isEmpty())
-        d->playlist->setCurrentIndex(0);
-
-    // Reset error conditions
-    d->error = NoError;
-    d->errorString = QString();
-
-    d->control->play();
-}
-
-/*!
-    Pause playing the current source.
-    \since 1.0
-*/
-
-void QMediaPlayer::pause()
-{
-    Q_D(QMediaPlayer);
-
-    if (d->control != 0)
-        d->control->pause();
-}
-
-/*!
-    Stop playing, and reset the play position to the beginning.
-    \since 1.0
-*/
-
-void QMediaPlayer::stop()
-{
-    Q_D(QMediaPlayer);
-
-    if (d->control != 0)
-        d->control->stop();
-}
-
-void QMediaPlayer::setPosition(qint64 position)
-{
-    Q_D(QMediaPlayer);
-
-    if (d->control == 0 || !isSeekable())
-        return;
-
-    d->control->setPosition(qBound(qint64(0), position, duration()));
-}
-
-void QMediaPlayer::setVolume(int v)
-{
-    Q_D(QMediaPlayer);
-
-    if (d->control == 0)
-        return;
-
-    int clamped = qBound(0, v, 100);
-    if (clamped == volume())
-        return;
-
-    d->control->setVolume(clamped);
-}
-
-void QMediaPlayer::setMuted(bool muted)
-{
-    Q_D(QMediaPlayer);
-
-    if (d->control == 0 || muted == isMuted())
-        return;
-
-    d->control->setMuted(muted);
-}
-
-void QMediaPlayer::setPlaybackRate(qreal rate)
-{
-    Q_D(QMediaPlayer);
-
-    if (d->control != 0)
-        d->control->setPlaybackRate(rate);
-}
-
-/*!
-    Sets the current \a media source.
-
-    If a \a stream is supplied; media data will be read from it instead of resolving the media
-    source.  In this case the media source may still be used to resolve additional information
-    about the media such as mime type.
-
-    Setting the media to a null QMediaContent will cause the player to discard all
-    information relating to the current media source and to cease all I/O operations related
-    to that media.
-    \since 1.0
-*/
-
-void QMediaPlayer::setMedia(const QMediaContent &media, QIODevice *stream)
-{
-    Q_D(QMediaPlayer);
-
-    if (playlist() && playlist()->currentMedia() != media)
-        setPlaylist(0);
-
-    if (d->control != 0)
-        d_func()->control->setMedia(media, stream);
-}
-
-/*!
-    \internal
-    \since 1.0
-*/
-
-bool QMediaPlayer::bind(QObject *obj)
-{
-    return QMediaObject::bind(obj);
-}
-
-/*!
-    \internal
-    \since 1.0
-*/
-
-void QMediaPlayer::unbind(QObject *obj)
-{
-    QMediaObject::unbind(obj);
-}
-
-/*!
-    Returns the level of support a media player has for a \a mimeType and a set of \a codecs.
-
-    The \a flags argument allows additional requirements such as performance indicators to be
-    specified.
-    \since 1.0
-*/
-QtMultimedia::SupportEstimate QMediaPlayer::hasSupport(const QString &mimeType,
-                                               const QStringList& codecs,
-                                               Flags flags)
-{
-    return QMediaServiceProvider::defaultServiceProvider()->hasSupport(QByteArray(Q_MEDIASERVICE_MEDIAPLAYER),
-                                                                    mimeType,
-                                                                    codecs,
-                                                                    flags);
-}
-
-/*!
-    \deprecated
-    Returns a list of MIME types supported by the media player.
-
-    The \a flags argument causes the resultant list to be restricted to MIME types which can be supported
-    given additional requirements, such as performance indicators.
-
-    This function may not return useful results on some platforms, and support for a specific file of a
-    given mime type is not guaranteed even if the mime type is in general supported.  In addition, in some
-    cases this function will need to load all available media plugins and query them for their support, which
-    may take some time.
-    \since 1.0
-*/
-QStringList QMediaPlayer::supportedMimeTypes(Flags flags)
-{
-    return QMediaServiceProvider::defaultServiceProvider()->supportedMimeTypes(QByteArray(Q_MEDIASERVICE_MEDIAPLAYER),
-                                                                               flags);
-}
-
-/*!
-    \fn void QMediaPlayer::setVideoOutput(QVideoWidget* output)
-
-    Attach a QVideoWidget video \a output to the media player.
-
-    If the media player has already video output attached,
-    it will be replaced with a new one.
-    \since 1.0
-*/
-void QMediaPlayer::setVideoOutput(QVideoWidget *output)
-{
-    Q_D(QMediaPlayer);
-
-    if (d->videoOutput)
-        unbind(d->videoOutput);
-
-    // We don't know (in this library) that QVideoWidget inherits QObject
-    QObject *outputObject = reinterpret_cast<QObject*>(output);
-
-    d->videoOutput = outputObject && bind(outputObject) ? outputObject : 0;
-}
-
-/*!
-    \fn void QMediaPlayer::setVideoOutput(QGraphicsVideoItem* output)
-
-    Attach a QGraphicsVideoItem video \a output to the media player.
-
-    If the media player has already video output attached,
-    it will be replaced with a new one.
-    \since 1.0
-*/
-void QMediaPlayer::setVideoOutput(QGraphicsVideoItem *output)
-{
-    Q_D(QMediaPlayer);
-
-    if (d->videoOutput)
-        unbind(d->videoOutput);
-
-    // We don't know (in this library) that QGraphicsVideoItem (multiply) inherits QObject
-    // but QObject inheritance depends on QObject coming first, so try this out.
-    QObject *outputObject = reinterpret_cast<QObject*>(output);
-
-    d->videoOutput = outputObject && bind(outputObject) ? outputObject : 0;
-}
-
-/*!
-    Sets a video \a surface as the video output of a media player.
-
-    If a video output has already been set on the media player the new surface
-    will replace it.
-    \since 1.2
-*/
-
-void QMediaPlayer::setVideoOutput(QAbstractVideoSurface *surface)
-{
-    Q_D(QMediaPlayer);
-
-    d->surfaceOutput.setVideoSurface(surface);
-
-    if (d->videoOutput != &d->surfaceOutput) {
-        if (d->videoOutput)
-            unbind(d->videoOutput);
-
-        d->videoOutput = bind(&d->surfaceOutput) ? &d->surfaceOutput : 0;
-    }
-}
-
-// Enums
-/*!
-    \enum QMediaPlayer::State
-
-    Defines the current state of a media player.
-
-    \value PlayingState The media player is currently playing content.
-    \value PausedState The media player has paused playback, playback of the current track will
-    resume from the position the player was paused at.
-    \value StoppedState The media player is not playing content, playback will begin from the start
-    of the current track.
-*/
-
-/*!
-    \enum QMediaPlayer::MediaStatus
-
-    Defines the status of a media player's current media.
-
-    \value UnknownMediaStatus The status of the media cannot be determined.
-    \value NoMedia The is no current media.  The player is in the StoppedState.
-    \value LoadingMedia The current media is being loaded. The player may be in any state.
-    \value LoadedMedia The current media has been loaded. The player is in the StoppedState.
-    \value StalledMedia Playback of the current media has stalled due to insufficient buffering or
-    some other temporary interruption.  The player is in the PlayingState or PausedState.
-    \value BufferingMedia The player is buffering data but has enough data buffered for playback to
-    continue for the immediate future.  The player is in the PlayingState or PausedState.
-    \value BufferedMedia The player has fully buffered the current media.  The player is in the
-    PlayingState or PausedState.
-    \value EndOfMedia Playback has reached the end of the current media.  The player is in the
-    StoppedState.
-    \value InvalidMedia The current media cannot be played.  The player is in the StoppedState.
-*/
-
-/*!
-    \enum QMediaPlayer::Error
-
-    Defines a media player error condition.
-
-    \value NoError No error has occurred.
-    \value ResourceError A media resource couldn't be resolved.
-    \value FormatError The format of a media resource isn't (fully) supported.  Playback may still
-    be possible, but without an audio or video component.
-    \value NetworkError A network error occurred.
-    \value AccessDeniedError There are not the appropriate permissions to play a media resource.
-    \value ServiceMissingError A valid playback service was not found, playback cannot proceed.
-*/
-
-// Signals
-/*!
-    \fn QMediaPlayer::error(QMediaPlayer::Error error)
-
-    Signals that an \a error condition has occurred.
-
-    \since 1.0
-    \sa errorString()
-*/
-
-/*!
-    \fn void QMediaPlayer::stateChanged(State state)
-
-    \since 1.0
-    Signal the \a state of the Player object has changed.
-*/
-
-/*!
-    \fn QMediaPlayer::mediaStatusChanged(QMediaPlayer::MediaStatus status)
-
-    Signals that the \a status of the current media has changed.
-
-    \since 1.0
-    \sa mediaStatus()
-*/
-
-/*!
-    \fn void QMediaPlayer::mediaChanged(const QMediaContent &media);
-
-    Signals that the current playing content will be obtained from \a media.
-
-    \since 1.0
-    \sa media()
-*/
-
-/*!
-    \fn void QMediaPlayer::playbackRateChanged(qreal rate);
-
-    Signals the playbackRate has changed to \a rate.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlayer::seekableChanged(bool seekable);
-
-    Signals the \a seekable status of the player object has changed.
-    \since 1.0
-*/
-
-// Properties
-/*!
-    \property QMediaPlayer::state
-    \brief the media player's playback state.
-
-    By default this property is QMediaPlayer::Stopped
-
-    \since 1.0
-    \sa mediaStatus(), play(), pause(), stop()
-*/
-
-/*!
-    \property QMediaPlayer::error
-    \brief a string describing the last error condition.
-
-    \since 1.0
-    \sa error()
-*/
-
-/*!
-    \property QMediaPlayer::media
-    \brief the active media source being used by the player object.
-
-    The player object will use the QMediaContent for selection of the content to
-    be played.
-
-    By default this property has a null QMediaContent.
-
-    Setting this property to a null QMediaContent will cause the player to discard all
-    information relating to the current media source and to cease all I/O operations related
-    to that media.
-
-    \since 1.0
-    \sa QMediaContent
-*/
-
-/*!
-    \property QMediaPlayer::playlist
-    \brief the media playlist being used by the player object.
-
-    The player object will use the current playlist item for selection of the content to
-    be played.
-
-    By default this property is set to null.
-
-    If the media playlist is used as a source, QMediaPlayer::media is updated with
-    a current playlist item. The current source should be selected with
-    QMediaPlaylist::setCurrentIndex(int) instead of QMediaPlayer::setMedia(),
-    otherwise the current playlist will be discarded.
-
-    \since 1.0
-    \sa QMediaContent
-*/
-
-
-/*!
-    \property QMediaPlayer::mediaStatus
-    \brief the status of the current media stream.
-
-    The stream status describes how the playback of the current stream is
-    progressing.
-
-    By default this property is QMediaPlayer::NoMedia
-
-    \since 1.0
-    \sa state
-*/
-
-/*!
-    \property QMediaPlayer::duration
-    \brief the duration of the current media.
-
-    The value is the total playback time in milliseconds of the current media.
-    The value may change across the life time of the QMediaPlayer object and
-    may not be available when initial playback begins, connect to the
-    durationChanged() signal to receive status notifications.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaPlayer::position
-    \brief the playback position of the current media.
-
-    The value is the current playback position, expressed in milliseconds since
-    the beginning of the media. Periodically changes in the position will be
-    indicated with the signal positionChanged(), the interval between updates
-    can be set with QMediaObject's method setNotifyInterval().
-    \since 1.0
-*/
-
-/*!
-    \property QMediaPlayer::volume
-    \brief the current playback volume.
-
-    The playback volume is a linear in effect and the value can range from 0 -
-    100, values outside this range will be clamped.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaPlayer::muted
-    \brief the muted state of the current media.
-
-    The value will be true if the playback volume is muted; otherwise false.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaPlayer::bufferStatus
-    \brief the percentage of the temporary buffer filled before playback begins.
-
-    When the player object is buffering; this property holds the percentage of
-    the temporary buffer that is filled. The buffer will need to reach 100%
-    filled before playback can resume, at which time the MediaStatus will be
-    BufferedMedia.
-
-    \since 1.0
-    \sa mediaStatus()
-*/
-
-/*!
-    \property QMediaPlayer::audioAvailable
-    \brief the audio availabilty status for the current media.
-
-    As the life time of QMediaPlayer can be longer than the playback of one
-    QMediaContent, this property may change over time, the
-    audioAvailableChanged signal can be used to monitor it's status.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaPlayer::videoAvailable
-    \brief the video availability status for the current media.
-
-    If available, the QVideoWidget class can be used to view the video. As the
-    life time of QMediaPlayer can be longer than the playback of one
-    QMediaContent, this property may change over time, the
-    videoAvailableChanged signal can be used to monitor it's status.
-
-    \since 1.0
-    \sa QVideoWidget, QMediaContent
-*/
-
-/*!
-    \property QMediaPlayer::seekable
-    \brief the seek-able status of the current media
-
-    If seeking is supported this property will be true; false otherwise. The
-    status of this property may change across the life time of the QMediaPlayer
-    object, use the seekableChanged signal to monitor changes.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaPlayer::playbackRate
-    \brief the playback rate of the current media.
-
-    This value is a multiplier applied to the media's standard play rate. By
-    default this value is 1.0, indicating that the media is playing at the
-    standard pace. Values higher than 1.0 will increase the rate of play.
-    Values less than zero can be set and indicate the media will rewind at the
-    multiplier of the standard pace.
-
-    Not all playback services support change of the playback rate. It is
-    framework defined as to the status and quality of audio and video
-    while fast forwarding or rewinding.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlayer::durationChanged(qint64 duration)
-
-    Signal the duration of the content has changed to \a duration, expressed in milliseconds.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlayer::positionChanged(qint64 position)
-
-    Signal the position of the content has changed to \a position, expressed in
-    milliseconds.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlayer::volumeChanged(int volume)
-
-    Signal the playback volume has changed to \a volume.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlayer::mutedChanged(bool muted)
-
-    Signal the mute state has changed to \a muted.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlayer::videoAvailableChanged(bool videoAvailable)
-
-    Signal the availability of visual content has changed to \a videoAvailable.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlayer::audioAvailableChanged(bool available)
-
-    Signals the availability of audio content has changed to \a available.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlayer::bufferStatusChanged(int percentFilled)
-
-    Signal the amount of the local buffer filled as a percentage by \a percentFilled.
-    \since 1.0
-*/
-
-/*!
-   \fn void QMediaPlayer::networkConfigurationChanged(const QNetworkConfiguration &configuration)
-
-    Signal that the active in use network access point  has been changed to \a configuration and all subsequent network access will use this \a configuration.
-    \since 1.2
-*/
-
-/*!
-    \enum QMediaPlayer::Flag
-
-    \value LowLatency       The player is expected to be used with simple audio formats,
-            but playback should start without significant delay.
-            Such playback service can be used for beeps, ringtones, etc.
-
-    \value StreamPlayback   The player is expected to play QIODevice based streams.
-            If passed to QMediaPlayer constructor, the service supporting
-            streams playback will be chosen.
-
-    \value VideoSurface     The player is expected to be able to render to a
-            QAbstractVideoSurface \l {setVideoOutput()}{output}.
-*/
-
-#include "moc_qmediaplayer.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaplayer.h b/src/multimedia/qmediaplayer.h
deleted file mode 100644
index f53b50c..0000000
--- a/src/multimedia/qmediaplayer.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAPLAYER_H
-#define QMEDIAPLAYER_H
-
-
-#include "qmediaserviceprovider.h"
-#include "qmediaobject.h"
-#include "qmediacontent.h"
-#include "qmediaenumdebug.h"
-
-#include <QtNetwork/qnetworkconfiguration.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QAbstractVideoSurface;
-class QMediaPlaylist;
-class QVideoWidget;
-class QGraphicsVideoItem;
-
-class QMediaPlayerPrivate;
-class Q_MULTIMEDIA_EXPORT QMediaPlayer : public QMediaObject
-{
-    Q_OBJECT
-    Q_PROPERTY(QMediaContent media READ media WRITE setMedia NOTIFY mediaChanged)
-    Q_PROPERTY(QMediaPlaylist * playlist READ playlist WRITE setPlaylist)
-    Q_PROPERTY(qint64 duration READ duration NOTIFY durationChanged)
-    Q_PROPERTY(qint64 position READ position WRITE setPosition NOTIFY positionChanged)
-    Q_PROPERTY(int volume READ volume WRITE setVolume NOTIFY volumeChanged)
-    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
-    Q_PROPERTY(int bufferStatus READ bufferStatus NOTIFY bufferStatusChanged)
-    Q_PROPERTY(bool audioAvailable READ isAudioAvailable NOTIFY audioAvailableChanged)
-    Q_PROPERTY(bool videoAvailable READ isVideoAvailable NOTIFY videoAvailableChanged)
-    Q_PROPERTY(bool seekable READ isSeekable NOTIFY seekableChanged)
-    Q_PROPERTY(qreal playbackRate READ playbackRate WRITE setPlaybackRate NOTIFY playbackRateChanged)
-    Q_PROPERTY(State state READ state NOTIFY stateChanged)
-    Q_PROPERTY(MediaStatus mediaStatus READ mediaStatus NOTIFY mediaStatusChanged)
-    Q_PROPERTY(QString error READ errorString)
-    Q_ENUMS(State)
-    Q_ENUMS(MediaStatus)
-    Q_ENUMS(Error)
-
-public:
-    enum State
-    {
-        StoppedState,
-        PlayingState,
-        PausedState
-    };
-
-    enum MediaStatus
-    {
-        UnknownMediaStatus,
-        NoMedia,
-        LoadingMedia,
-        LoadedMedia,
-        StalledMedia,
-        BufferingMedia,
-        BufferedMedia,
-        EndOfMedia,
-        InvalidMedia
-    };
-
-    enum Flag
-    {
-        LowLatency = 0x01,
-        StreamPlayback = 0x02,
-        VideoSurface = 0x04
-    };
-    Q_DECLARE_FLAGS(Flags, Flag)
-
-    enum Error
-    {
-        NoError,
-        ResourceError,
-        FormatError,
-        NetworkError,
-        AccessDeniedError,
-        ServiceMissingError
-    };
-
-    QMediaPlayer(QObject *parent = 0, Flags flags = 0, QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider());
-    ~QMediaPlayer();
-
-    static QtMultimedia::SupportEstimate hasSupport(const QString &mimeType,
-                                            const QStringList& codecs = QStringList(),
-                                            Flags flags = 0);
-    static QStringList supportedMimeTypes(Flags flags = 0);
-
-    void setVideoOutput(QVideoWidget *);
-    void setVideoOutput(QGraphicsVideoItem *);
-    void setVideoOutput(QAbstractVideoSurface *surface);
-
-    QMediaContent media() const;
-    const QIODevice *mediaStream() const;
-    QMediaPlaylist *playlist() const;
-
-    State state() const;
-    MediaStatus mediaStatus() const;
-
-    qint64 duration() const;
-    qint64 position() const;
-
-    int volume() const;
-    bool isMuted() const;
-    bool isAudioAvailable() const;
-    bool isVideoAvailable() const;
-
-    int bufferStatus() const;
-
-    bool isSeekable() const;
-    qreal playbackRate() const;   
-
-    Error error() const;
-    QString errorString() const;
-
-    QNetworkConfiguration currentNetworkConfiguration() const;
-
-public Q_SLOTS:
-    void play();
-    void pause();
-    void stop();
-
-    void setPosition(qint64 position);
-    void setVolume(int volume);
-    void setMuted(bool muted);
-
-    void setPlaybackRate(qreal rate);
-
-    void setMedia(const QMediaContent &media, QIODevice *stream = 0);
-    void setPlaylist(QMediaPlaylist *playlist);
-
-    void setNetworkConfigurations(const QList<QNetworkConfiguration> &configurations);
-
-Q_SIGNALS:
-    void mediaChanged(const QMediaContent &media);
-
-    void stateChanged(QMediaPlayer::State newState);
-    void mediaStatusChanged(QMediaPlayer::MediaStatus status);
-
-    void durationChanged(qint64 duration);
-    void positionChanged(qint64 position);
-
-    void volumeChanged(int volume);
-    void mutedChanged(bool muted);
-    void audioAvailableChanged(bool available);
-    void videoAvailableChanged(bool videoAvailable);
-
-    void bufferStatusChanged(int percentFilled);
-
-    void seekableChanged(bool seekable);
-    void playbackRateChanged(qreal rate);
-
-    void error(QMediaPlayer::Error error);
-
-    void networkConfigurationChanged(const QNetworkConfiguration &configuration);
-public:
-    virtual bool bind(QObject *);
-    virtual void unbind(QObject *);
-
-private:
-    Q_DISABLE_COPY(QMediaPlayer)
-    Q_DECLARE_PRIVATE(QMediaPlayer)
-    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QMediaPlayer::State))
-    Q_PRIVATE_SLOT(d_func(), void _q_mediaStatusChanged(QMediaPlayer::MediaStatus))
-    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
-    Q_PRIVATE_SLOT(d_func(), void _q_updateMedia(const QMediaContent&))
-    Q_PRIVATE_SLOT(d_func(), void _q_playlistDestroyed())
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QMediaPlayer::State)
-Q_DECLARE_METATYPE(QMediaPlayer::MediaStatus)
-Q_DECLARE_METATYPE(QMediaPlayer::Error)
-
-Q_MEDIA_ENUM_DEBUG(QMediaPlayer, State)
-Q_MEDIA_ENUM_DEBUG(QMediaPlayer, MediaStatus)
-Q_MEDIA_ENUM_DEBUG(QMediaPlayer, Error)
-
-QT_END_HEADER
-
-#endif  // QMEDIAPLAYER_H
diff --git a/src/multimedia/qmediaplayercontrol.cpp b/src/multimedia/qmediaplayercontrol.cpp
deleted file mode 100644
index 2585b04..0000000
--- a/src/multimedia/qmediaplayercontrol.cpp
+++ /dev/null
@@ -1,414 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaplayercontrol.h"
-#include "qmediacontrol_p.h"
-#include "qmediaplayer.h"
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QMediaPlayerControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-
-    \brief The QMediaPlayerControl class provides access to the media playing
-    functionality of a QMediaService.
-
-    If a QMediaService can play media is will implement QMediaPlayerControl.
-    This control provides a means to set the \l {setMedia()}{media} to play,
-    \l {play()}{start}, \l {pause()} {pause} and \l {stop()}{stop} playback,
-    \l {setPosition()}{seek}, and control the \l {setVolume()}{volume}.
-    It also provides feedback on the \l {duration()}{duration} of the media,
-    the current \l {position()}{position}, and \l {bufferStatus()}{buffering}
-    progress.
-
-    The functionality provided by this control is exposed to application
-    code through the QMediaPlayer class.
-
-    The interface name of QMediaPlayerControl is \c com.nokia.Qt.QMediaPlayerControl/1.0 as
-    defined in QMediaPlayerControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaPlayer
-*/
-
-/*!
-    \macro QMediaPlayerControl_iid
-
-    \c com.nokia.Qt.QMediaPlayerControl/1.0
-
-    Defines the interface name of the QMediaPlayerControl class.
-
-    \relates QMediaPlayerControl
-*/
-
-/*!
-    Destroys a media player control.
-*/
-QMediaPlayerControl::~QMediaPlayerControl()
-{
-}
-
-/*!
-    Constructs a new media player control with the given \a parent.
-*/
-QMediaPlayerControl::QMediaPlayerControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    \fn QMediaPlayerControl::state() const
-
-    Returns the state of a player control.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::stateChanged(QMediaPlayer::State state)
-
-    Signals that the \a state of a player control has changed.
-
-    \since 1.0
-    \sa state()
-*/
-
-/*!
-    \fn QMediaPlayerControl::mediaStatus() const
-
-    Returns the status of the current media.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::mediaStatusChanged(QMediaPlayer::MediaStatus status)
-
-    Signals that the \a status of the current media has changed.
-
-    \since 1.0
-    \sa mediaStatus()
-*/
-
-
-/*!
-    \fn QMediaPlayerControl::duration() const
-
-    Returns the duration of the current media in milliseconds.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::durationChanged(qint64 duration)
-
-    Signals that the \a duration of the current media has changed.
-
-    \since 1.0
-    \sa duration()
-*/
-
-/*!
-    \fn QMediaPlayerControl::position() const
-
-    Returns the current playback position in milliseconds.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::setPosition(qint64 position)
-
-    Sets the playback \a position of the current media.  This will initiate a seek and it may take
-    some time for playback to reach the position set.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::positionChanged(qint64 position)
-
-    Signals the playback \a position has changed.
-
-    This is only emitted in when there has been a discontinous change in the playback postion, such
-    as a seek or the position being reset.
-
-    \since 1.0
-    \sa position()
-*/
-
-/*!
-    \fn QMediaPlayerControl::volume() const
-
-    Returns the audio volume of a player control.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::setVolume(int volume)
-
-    Sets the audio \a volume of a player control.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::volumeChanged(int volume)
-
-    Signals the audio \a volume of a player control has changed.
-
-    \since 1.0
-    \sa volume()
-*/
-
-/*!
-    \fn QMediaPlayerControl::isMuted() const
-
-    Returns the mute state of a player control.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::setMuted(bool mute)
-
-    Sets the \a mute state of a player control.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::mutedChanged(bool mute)
-
-    Signals a change in the \a mute status of a player control.
-
-    \since 1.0
-    \sa isMuted()
-*/
-
-/*!
-    \fn QMediaPlayerControl::bufferStatus() const
-
-    Returns the buffering progress of the current media.  Progress is measured in the percentage
-    of the buffer filled.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::bufferStatusChanged(int progress)
-
-    Signals that buffering \a progress has changed.
-
-    \since 1.0
-    \sa bufferStatus()
-*/
-
-/*!
-    \fn QMediaPlayerControl::isAudioAvailable() const
-
-    Identifies if there is audio output available for the current media.
-
-    Returns true if audio output is available and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::audioAvailableChanged(bool audio)
-
-    Signals that there has been a change in the availability of \a audio output.
-
-    \since 1.0
-    \sa isAudioAvailable()
-*/
-
-/*!
-    \fn QMediaPlayerControl::isVideoAvailable() const
-
-    Identifies if there is video output available for the current media.
-
-    Returns true if video output is available and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::videoAvailableChanged(bool video)
-
-    Signals that there has been a change in the availability of \a video output.
-
-    \since 1.0
-    \sa isVideoAvailable()
-*/
-
-/*!
-    \fn QMediaPlayerControl::isSeekable() const
-
-    Identifies if the current media is seekable.
-
-    Returns true if it possible to seek within the current media, and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::seekableChanged(bool seekable)
-
-    Signals that the \a seekable state of a player control has changed.
-
-    \since 1.0
-    \sa isSeekable()
-*/
-
-/*!
-    \fn QMediaPlayerControl::availablePlaybackRanges() const
-
-    Returns a range of times in milliseconds that can be played back.
-
-    Usually for local files this is a continuous interval equal to [0..duration()]
-    or an empty time range if seeking is not supported, but for network sources
-    it refers to the buffered parts of the media.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::availablePlaybackRangesChanged(const QMediaTimeRange &ranges)
-
-    Signals that the available media playback \a ranges have changed.
-
-    \since 1.0
-    \sa QMediaPlayerControl::availablePlaybackRanges()
-*/
-
-/*!
-    \fn qreal QMediaPlayerControl::playbackRate() const
-
-    Returns the rate of playback.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::setPlaybackRate(qreal rate)
-
-    Sets the \a rate of playback.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::media() const
-
-    Returns the current media source.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::mediaStream() const
-
-    Returns the current media stream. This is only a valid if a stream was passed to setMedia().
-
-    \since 1.0
-    \sa setMedia()
-*/
-
-/*!
-    \fn QMediaPlayerControl::setMedia(const QMediaContent &media, QIODevice *stream)
-
-    Sets the current \a media source.  If a \a stream is supplied; data will be read from that
-    instead of attempting to resolve the media source.  The media source may still be used to
-    supply media information such as mime type.
-
-    Setting the media to a null QMediaContent will cause the control to discard all
-    information relating to the current media source and to cease all I/O operations related
-    to that media.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::mediaChanged(const QMediaContent& content)
-
-    Signals that the current media \a content has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::play()
-
-    Starts playback of the current media.
-
-    If successful the player control will immediately enter the \l {QMediaPlayer::PlayingState}
-    {playing} state.
-
-    \since 1.0
-    \sa state()
-*/
-
-/*!
-    \fn QMediaPlayerControl::pause()
-
-    Pauses playback of the current media.
-
-    If sucessful the player control will immediately enter the \l {QMediaPlayer::PausedState}
-    {paused} state.
-
-    \since 1.0
-    \sa state(), play(), stop()
-*/
-
-/*!
-    \fn QMediaPlayerControl::stop()
-
-    Stops playback of the current media.
-
-    If successful the player control will immediately enter the \l {QMediaPlayer::StoppedState}
-    {stopped} state.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::error(int error, const QString &errorString)
-
-    Signals that an \a error has occurred.  The \a errorString provides a more detailed explanation.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlayerControl::playbackRateChanged(qreal rate)
-
-    Signal emitted when playback rate changes to \a rate.
-    \since 1.0
-*/
-
-#include "moc_qmediaplayercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaplayercontrol.h b/src/multimedia/qmediaplayercontrol.h
deleted file mode 100644
index a6e02ee..0000000
--- a/src/multimedia/qmediaplayercontrol.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAPLAYERCONTROL_H
-#define QMEDIAPLAYERCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qmediaplayer.h"
-#include "qmediatimerange.h"
-
-#include <QtCore/qpair.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QMediaPlaylist;
-
-class Q_MULTIMEDIA_EXPORT QMediaPlayerControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    ~QMediaPlayerControl();
-
-    virtual QMediaPlayer::State state() const = 0;
-
-    virtual QMediaPlayer::MediaStatus mediaStatus() const = 0;
-
-    virtual qint64 duration() const = 0;
-
-    virtual qint64 position() const = 0;
-    virtual void setPosition(qint64 position) = 0;
-
-    virtual int volume() const = 0;
-    virtual void setVolume(int volume) = 0;
-
-    virtual bool isMuted() const = 0;
-    virtual void setMuted(bool muted) = 0;
-
-    virtual int bufferStatus() const = 0;
-
-    virtual bool isAudioAvailable() const = 0;
-    virtual bool isVideoAvailable() const = 0;
-
-    virtual bool isSeekable() const = 0;
-
-    virtual QMediaTimeRange availablePlaybackRanges() const = 0;
-
-    virtual qreal playbackRate() const = 0;
-    virtual void setPlaybackRate(qreal rate) = 0;
-
-    virtual QMediaContent media() const = 0;
-    virtual const QIODevice *mediaStream() const = 0;
-    virtual void setMedia(const QMediaContent &media, QIODevice *stream) = 0;
-
-    virtual void play() = 0;
-    virtual void pause() = 0;
-    virtual void stop() = 0;
-
-Q_SIGNALS:
-    void mediaChanged(const QMediaContent& content);
-    void durationChanged(qint64 duration);
-    void positionChanged(qint64 position);
-    void stateChanged(QMediaPlayer::State newState);
-    void mediaStatusChanged(QMediaPlayer::MediaStatus status);
-    void volumeChanged(int volume);
-    void mutedChanged(bool muted);
-    void audioAvailableChanged(bool audioAvailable);
-    void videoAvailableChanged(bool videoAvailable);
-    void bufferStatusChanged(int percentFilled);
-    void seekableChanged(bool);
-    void availablePlaybackRangesChanged(const QMediaTimeRange&);
-    void playbackRateChanged(qreal rate);
-    void error(int error, const QString &errorString);
-
-protected:
-    QMediaPlayerControl(QObject* parent = 0);
-};
-
-#define QMediaPlayerControl_iid "com.nokia.Qt.QMediaPlayerControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaPlayerControl, QMediaPlayerControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QMEDIAPLAYERCONTROL_H
-
diff --git a/src/multimedia/qmediaplaylist.cpp b/src/multimedia/qmediaplaylist.cpp
deleted file mode 100644
index 1b6959c..0000000
--- a/src/multimedia/qmediaplaylist.cpp
+++ /dev/null
@@ -1,769 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaplaylist.h"
-#include "qmediaplaylist_p.h"
-#include "qmediaplaylistprovider.h"
-#include "qlocalmediaplaylistprovider.h"
-#include "qmediaplaylistioplugin.h"
-#include "qmediaservice.h"
-#include "qmediaplaylistcontrol.h"
-#include "qmediaplayercontrol.h"
-
-#include <QtCore/qlist.h>
-#include <QtCore/qfile.h>
-#include <QtCore/qurl.h>
-#include <QtCore/qcoreevent.h>
-#include <QtCore/qcoreapplication.h>
-
-#include "qmediapluginloader_p.h"
-
-QT_BEGIN_NAMESPACE
-
-Q_GLOBAL_STATIC_WITH_ARGS(QMediaPluginLoader, playlistIOLoader,
-        (QMediaPlaylistIOInterface_iid, QLatin1String("playlistformats"), Qt::CaseInsensitive))
-
-namespace
-{
-    class QMediaPlaylistPrivateRegisterMetaTypes
-    {
-    public:
-        QMediaPlaylistPrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QMediaPlaylist::Error>();
-            qRegisterMetaType<QMediaPlaylist::PlaybackMode>();
-        }
-    } _registerMetaTypes;
-}
-
-
-/*!
-    \class QMediaPlaylist
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-
-    \brief The QMediaPlaylist class provides a list of media content to play.
-
-    QMediaPlaylist is intended to be used with other media objects,
-    like QMediaPlayer or QMediaImageViewer.
-
-    QMediaPlaylist allows to access the service intrinsic playlist functionality
-    if available, otherwise it provides the the local memory playlist implementation.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Movie playlist
-
-    Depending on playlist source implementation, most of the playlist mutating
-    operations can be asynchronous.
-
-    \sa QMediaContent
-*/
-
-
-/*!
-    \enum QMediaPlaylist::PlaybackMode
-
-    The QMediaPlaylist::PlaybackMode describes the order items in playlist are played.
-
-    \value CurrentItemOnce    The current item is played only once.
-
-    \value CurrentItemInLoop  The current item is played repeatedly in a loop.
-
-    \value Sequential         Playback starts from the current and moves through each successive item until the last is reached and then stops.
-                              The next item is a null item when the last one is currently playing.
-
-    \value Loop               Playback restarts at the first item after the last has finished playing.
-
-    \value Random             Play items in random order.
-*/
-
-
-
-/*!
-  Create a new playlist object for with the given \a parent.
-*/
-
-QMediaPlaylist::QMediaPlaylist(QObject *parent)
-    : QObject(parent)
-    , d_ptr(new QMediaPlaylistPrivate)
-{
-    Q_D(QMediaPlaylist);
-
-    d->q_ptr = this;
-    d->localPlaylistControl = new QLocalMediaPlaylistControl(this);
-
-    setMediaObject(0);
-}
-
-/*!
-  Destroys the playlist.
-  */
-
-QMediaPlaylist::~QMediaPlaylist()
-{
-    Q_D(QMediaPlaylist);
-
-    if (d->mediaObject)
-        d->mediaObject->unbind(this);
-
-    delete d_ptr;
-}
-
-/*!
-  Returns the QMediaObject instance that this QMediaPlaylist is bound too,
-  or 0 otherwise.
-  \since 1.0
-*/
-QMediaObject *QMediaPlaylist::mediaObject() const
-{
-    return d_func()->mediaObject;
-}
-
-/*!
-  \internal
-  If \a mediaObject is null or doesn't have an intrinsic playlist,
-  internal local memory playlist source will be created.
-  \since 1.0
-*/
-bool QMediaPlaylist::setMediaObject(QMediaObject *mediaObject)
-{
-    Q_D(QMediaPlaylist);
-
-    if (mediaObject && mediaObject == d->mediaObject)
-        return true;
-
-    QMediaService *service = mediaObject
-            ? mediaObject->service() : 0;
-
-    QMediaPlaylistControl *newControl = 0;
-
-    if (service)
-        newControl = qobject_cast<QMediaPlaylistControl*>(service->requestControl(QMediaPlaylistControl_iid));
-
-    if (!newControl)
-        newControl = d->localPlaylistControl;
-
-    if (d->control != newControl) {
-        int oldSize = 0;
-        if (d->control) {
-            QMediaPlaylistProvider *playlist = d->control->playlistProvider();
-            oldSize = playlist->mediaCount();
-            disconnect(playlist, SIGNAL(loadFailed(QMediaPlaylist::Error,QString)),
-                    this, SLOT(_q_loadFailed(QMediaPlaylist::Error,QString)));
-
-            disconnect(playlist, SIGNAL(mediaChanged(int,int)), this, SIGNAL(mediaChanged(int,int)));
-            disconnect(playlist, SIGNAL(mediaAboutToBeInserted(int,int)), this, SIGNAL(mediaAboutToBeInserted(int,int)));
-            disconnect(playlist, SIGNAL(mediaInserted(int,int)), this, SIGNAL(mediaInserted(int,int)));
-            disconnect(playlist, SIGNAL(mediaAboutToBeRemoved(int,int)), this, SIGNAL(mediaAboutToBeRemoved(int,int)));
-            disconnect(playlist, SIGNAL(mediaRemoved(int,int)), this, SIGNAL(mediaRemoved(int,int)));
-
-            disconnect(playlist, SIGNAL(loaded()), this, SIGNAL(loaded()));
-
-            disconnect(d->control, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)),
-                    this, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)));
-            disconnect(d->control, SIGNAL(currentIndexChanged(int)),
-                    this, SIGNAL(currentIndexChanged(int)));
-            disconnect(d->control, SIGNAL(currentMediaChanged(QMediaContent)),
-                    this, SIGNAL(currentMediaChanged(QMediaContent)));
-
-            if (d->mediaObject)
-                d->mediaObject->service()->releaseControl(d->control);
-        }
-
-        d->control = newControl;
-        QMediaPlaylistProvider *playlist = d->control->playlistProvider();
-        connect(playlist, SIGNAL(loadFailed(QMediaPlaylist::Error,QString)),
-                this, SLOT(_q_loadFailed(QMediaPlaylist::Error,QString)));
-
-        connect(playlist, SIGNAL(mediaChanged(int,int)), this, SIGNAL(mediaChanged(int,int)));
-        connect(playlist, SIGNAL(mediaAboutToBeInserted(int,int)), this, SIGNAL(mediaAboutToBeInserted(int,int)));
-        connect(playlist, SIGNAL(mediaInserted(int,int)), this, SIGNAL(mediaInserted(int,int)));
-        connect(playlist, SIGNAL(mediaAboutToBeRemoved(int,int)), this, SIGNAL(mediaAboutToBeRemoved(int,int)));
-        connect(playlist, SIGNAL(mediaRemoved(int,int)), this, SIGNAL(mediaRemoved(int,int)));
-
-        connect(playlist, SIGNAL(loaded()), this, SIGNAL(loaded()));
-
-        connect(d->control, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)),
-                this, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)));
-        connect(d->control, SIGNAL(currentIndexChanged(int)),
-                this, SIGNAL(currentIndexChanged(int)));
-        connect(d->control, SIGNAL(currentMediaChanged(QMediaContent)),
-                this, SIGNAL(currentMediaChanged(QMediaContent)));
-
-        if (oldSize)
-            emit mediaRemoved(0, oldSize-1);
-
-        if (playlist->mediaCount()) {
-            emit mediaAboutToBeInserted(0,playlist->mediaCount()-1);
-            emit mediaInserted(0,playlist->mediaCount()-1);
-        }
-    }
-
-    d->mediaObject = mediaObject;
-
-    return true;
-}
-
-/*!
-  \property QMediaPlaylist::playbackMode
-
-  This property defines the order, items in playlist are played.
-
-  \since 1.0
-  \sa QMediaPlaylist::PlaybackMode
-*/
-
-QMediaPlaylist::PlaybackMode QMediaPlaylist::playbackMode() const
-{
-    return d_func()->control->playbackMode();
-}
-
-void QMediaPlaylist::setPlaybackMode(QMediaPlaylist::PlaybackMode mode)
-{
-    Q_D(QMediaPlaylist);
-    d->control->setPlaybackMode(mode);
-}
-
-/*!
-  Returns position of the current media content in the playlist.
-  \since 1.0
-*/
-int QMediaPlaylist::currentIndex() const
-{
-    return d_func()->control->currentIndex();
-}
-
-/*!
-  Returns the current media content.
-  \since 1.0
-*/
-
-QMediaContent QMediaPlaylist::currentMedia() const
-{
-    return d_func()->playlist()->media(currentIndex());
-}
-
-/*!
-  Returns the index of the item, which would be current after calling next()
-  \a steps times.
-
-  Returned value depends on the size of playlist, current position
-  and playback mode.
-
-  \since 1.0
-  \sa QMediaPlaylist::playbackMode
-*/
-int QMediaPlaylist::nextIndex(int steps) const
-{
-    return d_func()->control->nextIndex(steps);
-}
-
-/*!
-  Returns the index of the item, which would be current after calling previous()
-  \a steps times.
-
-  \since 1.0
-  \sa QMediaPlaylist::playbackMode
-*/
-
-int QMediaPlaylist::previousIndex(int steps) const
-{
-    return d_func()->control->previousIndex(steps);
-}
-
-
-/*!
-  Returns the number of items in the playlist.
-
-  \since 1.0
-  \sa isEmpty()
-  */
-int QMediaPlaylist::mediaCount() const
-{
-    return d_func()->playlist()->mediaCount();
-}
-
-/*!
-  Returns true if the playlist contains no items; otherwise returns false.
-
-  \since 1.0
-  \sa mediaCount()
-  */
-bool QMediaPlaylist::isEmpty() const
-{
-    return mediaCount() == 0;
-}
-
-/*!
-  Returns true if the playlist can be modified; otherwise returns false.
-
-  \since 1.0
-  \sa mediaCount()
-  */
-bool QMediaPlaylist::isReadOnly() const
-{
-    return d_func()->playlist()->isReadOnly();
-}
-
-/*!
-  Returns the media content at \a index in the playlist.
-  \since 1.0
-*/
-
-QMediaContent QMediaPlaylist::media(int index) const
-{
-    return d_func()->playlist()->media(index);
-}
-
-/*!
-  Append the media \a content to the playlist.
-
-  Returns true if the operation is successful, otherwise return false.
-  \since 1.0
-  */
-bool QMediaPlaylist::addMedia(const QMediaContent &content)
-{
-    return d_func()->control->playlistProvider()->addMedia(content);
-}
-
-/*!
-  Append multiple media content \a items to the playlist.
-
-  Returns true if the operation is successful, otherwise return false.
-  \since 1.0
-  */
-bool QMediaPlaylist::addMedia(const QList<QMediaContent> &items)
-{
-    return d_func()->control->playlistProvider()->addMedia(items);
-}
-
-/*!
-  Insert the media \a content to the playlist at position \a pos.
-
-  Returns true if the operation is successful, otherwise false.
-  \since 1.0
-*/
-
-bool QMediaPlaylist::insertMedia(int pos, const QMediaContent &content)
-{
-    return d_func()->playlist()->insertMedia(pos, content);
-}
-
-/*!
-  Insert multiple media content \a items to the playlist at position \a pos.
-
-  Returns true if the operation is successful, otherwise false.
-  \since 1.0
-*/
-
-bool QMediaPlaylist::insertMedia(int pos, const QList<QMediaContent> &items)
-{
-    return d_func()->playlist()->insertMedia(pos, items);
-}
-
-/*!
-  Remove the item from the playlist at position \a pos.
-
-  Returns true if the operation is successful, otherwise return false.
-  \since 1.0
-  */
-bool QMediaPlaylist::removeMedia(int pos)
-{
-    Q_D(QMediaPlaylist);
-    return d->playlist()->removeMedia(pos);
-}
-
-/*!
-  Remove items in the playlist from \a start to \a end inclusive.
-
-  Returns true if the operation is successful, otherwise return false.
-  \since 1.0
-  */
-bool QMediaPlaylist::removeMedia(int start, int end)
-{
-    Q_D(QMediaPlaylist);
-    return d->playlist()->removeMedia(start, end);
-}
-
-/*!
-  Remove all the items from the playlist.
-
-  Returns true if the operation is successful, otherwise return false.
-  \since 1.0
-  */
-bool QMediaPlaylist::clear()
-{
-    Q_D(QMediaPlaylist);
-    return d->playlist()->clear();
-}
-
-bool QMediaPlaylistPrivate::readItems(QMediaPlaylistReader *reader)
-{
-    while (!reader->atEnd())
-        playlist()->addMedia(reader->readItem());
-
-    return true;
-}
-
-bool QMediaPlaylistPrivate::writeItems(QMediaPlaylistWriter *writer)
-{
-    for (int i=0; i<playlist()->mediaCount(); i++) {
-        if (!writer->writeItem(playlist()->media(i)))
-            return false;
-    }
-    writer->close();
-    return true;
-}
-
-/*!
-  Load playlist from \a location. If \a format is specified, it is used,
-  otherwise format is guessed from location name and data.
-
-  New items are appended to playlist.
-
-  QMediaPlaylist::loaded() signal is emitted if playlist was loaded successfully,
-  otherwise the playlist emits loadFailed().
-  \since 1.0
-*/
-void QMediaPlaylist::load(const QUrl &location, const char *format)
-{
-    Q_D(QMediaPlaylist);
-
-    d->error = NoError;
-    d->errorString.clear();
-
-    if (d->playlist()->load(location,format))
-        return;
-
-    if (isReadOnly()) {
-        d->error = AccessDeniedError;
-        d->errorString = tr("Could not add items to read only playlist.");
-        emit loadFailed();
-        return;
-    }
-
-    foreach (QString const& key, playlistIOLoader()->keys()) {
-        QMediaPlaylistIOInterface* plugin = qobject_cast<QMediaPlaylistIOInterface*>(playlistIOLoader()->instance(key));
-        if (plugin && plugin->canRead(location,format)) {
-            QMediaPlaylistReader *reader = plugin->createReader(location,QByteArray(format));
-            if (reader && d->readItems(reader)) {
-                delete reader;
-                emit loaded();
-                return;
-            }
-            delete reader;
-        }
-    }
-
-    d->error = FormatNotSupportedError;
-    d->errorString = tr("Playlist format is not supported");
-    emit loadFailed();
-
-    return;
-}
-
-/*!
-  Load playlist from QIODevice \a device. If \a format is specified, it is used,
-  otherwise format is guessed from device data.
-
-  New items are appended to playlist.
-
-  QMediaPlaylist::loaded() signal is emitted if playlist was loaded successfully,
-  otherwise the playlist emits loadFailed().
-  \since 1.0
-*/
-void QMediaPlaylist::load(QIODevice * device, const char *format)
-{
-    Q_D(QMediaPlaylist);
-
-    d->error = NoError;
-    d->errorString.clear();
-
-    if (d->playlist()->load(device,format))
-        return;
-
-    if (isReadOnly()) {
-        d->error = AccessDeniedError;
-        d->errorString = tr("Could not add items to read only playlist.");
-        emit loadFailed();
-        return;
-    }
-
-    foreach (QString const& key, playlistIOLoader()->keys()) {
-        QMediaPlaylistIOInterface* plugin = qobject_cast<QMediaPlaylistIOInterface*>(playlistIOLoader()->instance(key));
-        if (plugin && plugin->canRead(device,format)) {
-            QMediaPlaylistReader *reader = plugin->createReader(device,QByteArray(format));
-            if (reader && d->readItems(reader)) {
-                delete reader;
-                emit loaded();
-                return;
-            }
-            delete reader;
-        }
-    }
-
-    d->error = FormatNotSupportedError;
-    d->errorString = tr("Playlist format is not supported");
-    emit loadFailed();
-
-    return;
-}
-
-/*!
-  Save playlist to \a location. If \a format is specified, it is used,
-  otherwise format is guessed from location name.
-
-  Returns true if playlist was saved successfully, otherwise returns false.
-  \since 1.0
-  */
-bool QMediaPlaylist::save(const QUrl &location, const char *format)
-{
-    Q_D(QMediaPlaylist);
-
-    d->error = NoError;
-    d->errorString.clear();
-
-    if (d->playlist()->save(location,format))
-        return true;
-
-    QFile file(location.toLocalFile());
-
-    if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
-        d->error = AccessDeniedError;
-        d->errorString = tr("The file could not be accessed.");
-        return false;
-    }
-
-    return save(&file, format);
-}
-
-/*!
-  Save playlist to QIODevice \a device using format \a format.
-
-  Returns true if playlist was saved successfully, otherwise returns false.
-  \since 1.0
-*/
-bool QMediaPlaylist::save(QIODevice * device, const char *format)
-{
-    Q_D(QMediaPlaylist);
-
-    d->error = NoError;
-    d->errorString.clear();
-
-    if (d->playlist()->save(device,format))
-        return true;
-
-    foreach (QString const& key, playlistIOLoader()->keys()) {
-        QMediaPlaylistIOInterface* plugin = qobject_cast<QMediaPlaylistIOInterface*>(playlistIOLoader()->instance(key));
-        if (plugin && plugin->canWrite(device,format)) {
-            QMediaPlaylistWriter *writer = plugin->createWriter(device,QByteArray(format));
-            if (writer && d->writeItems(writer)) {
-                delete writer;
-                return true;
-            }
-            delete writer;
-        }
-    }
-
-    d->error = FormatNotSupportedError;
-    d->errorString = tr("Playlist format is not supported.");
-
-    return false;
-}
-
-/*!
-    Returns the last error condition.
-    \since 1.0
-*/
-QMediaPlaylist::Error QMediaPlaylist::error() const
-{
-    return d_func()->error;
-}
-
-/*!
-    Returns the string describing the last error condition.
-    \since 1.0
-*/
-QString QMediaPlaylist::errorString() const
-{
-    return d_func()->errorString;
-}
-
-/*!
-  Shuffle items in the playlist.
-  \since 1.0
-*/
-void QMediaPlaylist::shuffle()
-{
-    d_func()->playlist()->shuffle();
-}
-
-
-/*!
-    Advance to the next media content in playlist.
-    \since 1.0
-*/
-void QMediaPlaylist::next()
-{
-    d_func()->control->next();
-}
-
-/*!
-    Return to the previous media content in playlist.
-    \since 1.0
-*/
-void QMediaPlaylist::previous()
-{
-    d_func()->control->previous();
-}
-
-/*!
-    Activate media content from playlist at position \a playlistPosition.
-    \since 1.0
-*/
-
-void QMediaPlaylist::setCurrentIndex(int playlistPosition)
-{
-    d_func()->control->setCurrentIndex(playlistPosition);
-}
-
-/*!
-    \fn void QMediaPlaylist::mediaInserted(int start, int end)
-
-    This signal is emitted after media has been inserted into the playlist.
-    The new items are those between \a start and \a end inclusive.
-    \since 1.0
- */
-
-/*!
-    \fn void QMediaPlaylist::mediaRemoved(int start, int end)
-
-    This signal is emitted after media has been removed from the playlist.
-    The removed items are those between \a start and \a end inclusive.
-    \since 1.0
- */
-
-/*!
-    \fn void QMediaPlaylist::mediaChanged(int start, int end)
-
-    This signal is emitted after media has been changed in the playlist
-    between \a start and \a end positions inclusive.
-    \since 1.0
- */
-
-/*!
-    \fn void QMediaPlaylist::currentIndexChanged(int position)
-
-    Signal emitted when playlist position changed to \a position.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylist::playbackModeChanged(QMediaPlaylist::PlaybackMode mode)
-
-    Signal emitted when playback mode changed to \a mode.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylist::mediaAboutToBeInserted(int start, int end)
-
-    Signal emitted when items are to be inserted at \a start and ending at \a end.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylist::mediaAboutToBeRemoved(int start, int end)
-
-    Signal emitted when item are to be deleted at \a start and ending at \a end.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylist::currentMediaChanged(const QMediaContent &content)
-
-    Signal emitted when current media changes to \a content.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaPlaylist::currentIndex
-    \brief Current position.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaPlaylist::currentMedia
-    \brief Current media content.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylist::loaded()
-
-    Signal emitted when playlist finished loading.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylist::loadFailed()
-
-    Signal emitted if failed to load playlist.
-    \since 1.0
-*/
-
-/*!
-    \enum QMediaPlaylist::Error
-
-    This enum describes the QMediaPlaylist error codes.
-
-    \value NoError                 No errors.
-    \value FormatError             Format error.
-    \value FormatNotSupportedError Format not supported.
-    \value NetworkError            Network error.
-    \value AccessDeniedError       Access denied error.
-*/
-
-#include "moc_qmediaplaylist.cpp"
-#include "moc_qmediaplaylist_p.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaplaylist.h b/src/multimedia/qmediaplaylist.h
deleted file mode 100644
index 7b4b622..0000000
--- a/src/multimedia/qmediaplaylist.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAPLAYLIST_H
-#define QMEDIAPLAYLIST_H
-
-#include <QtCore/qobject.h>
-
-#include <qmediacontent.h>
-#include <qmediaobject.h>
-#include <qmediabindableinterface.h>
-#include <qmediaenumdebug.h>
-
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QMediaPlaylistProvider;
-
-class QMediaPlaylistPrivate;
-class Q_MULTIMEDIA_EXPORT QMediaPlaylist : public QObject, public QMediaBindableInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(QMediaBindableInterface)
-    Q_PROPERTY(QMediaPlaylist::PlaybackMode playbackMode READ playbackMode WRITE setPlaybackMode NOTIFY playbackModeChanged)
-    Q_PROPERTY(QMediaContent currentMedia READ currentMedia NOTIFY currentMediaChanged)
-    Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentIndexChanged)
-    Q_ENUMS(PlaybackMode Error)
-
-public:
-    enum PlaybackMode { CurrentItemOnce, CurrentItemInLoop, Sequential, Loop, Random };
-    enum Error { NoError, FormatError, FormatNotSupportedError, NetworkError, AccessDeniedError };
-
-    QMediaPlaylist(QObject *parent = 0);
-    virtual ~QMediaPlaylist();
-
-    QMediaObject *mediaObject() const;
-
-    PlaybackMode playbackMode() const;
-    void setPlaybackMode(PlaybackMode mode);
-
-    int currentIndex() const;
-    QMediaContent currentMedia() const;
-
-    int nextIndex(int steps = 1) const;
-    int previousIndex(int steps = 1) const;
-
-    QMediaContent media(int index) const;
-
-    int mediaCount() const;
-    bool isEmpty() const;
-    bool isReadOnly() const;
-
-    bool addMedia(const QMediaContent &content);
-    bool addMedia(const QList<QMediaContent> &items);
-    bool insertMedia(int index, const QMediaContent &content);
-    bool insertMedia(int index, const QList<QMediaContent> &items);
-    bool removeMedia(int pos);
-    bool removeMedia(int start, int end);
-    bool clear();
-
-    void load(const QUrl &location, const char *format = 0);
-    void load(QIODevice * device, const char *format = 0);
-
-    bool save(const QUrl &location, const char *format = 0);
-    bool save(QIODevice * device, const char *format);
-
-    Error error() const;
-    QString errorString() const;
-
-public Q_SLOTS:
-    void shuffle();
-
-    void next();
-    void previous();
-
-    void setCurrentIndex(int index);
-
-Q_SIGNALS:
-    void currentIndexChanged(int index);
-    void playbackModeChanged(QMediaPlaylist::PlaybackMode mode);
-    void currentMediaChanged(const QMediaContent&);
-
-    void mediaAboutToBeInserted(int start, int end);
-    void mediaInserted(int start, int end);
-    void mediaAboutToBeRemoved(int start, int end);
-    void mediaRemoved(int start, int end);
-    void mediaChanged(int start, int end);
-
-    void loaded();
-    void loadFailed();
-
-protected:
-    bool setMediaObject(QMediaObject *object);
-    QMediaPlaylistPrivate *d_ptr;
-
-private:
-    Q_DECLARE_PRIVATE(QMediaPlaylist)
-    Q_PRIVATE_SLOT(d_func(), void _q_loadFailed(QMediaPlaylist::Error, const QString &))
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QMediaPlaylist::PlaybackMode)
-Q_DECLARE_METATYPE(QMediaPlaylist::Error)
-
-Q_MEDIA_ENUM_DEBUG(QMediaPlaylist, PlaybackMode)
-Q_MEDIA_ENUM_DEBUG(QMediaPlaylist, Error)
-
-QT_END_HEADER
-
-#endif  // QMEDIAPLAYLIST_H
diff --git a/src/multimedia/qmediaplaylist_p.h b/src/multimedia/qmediaplaylist_p.h
deleted file mode 100644
index c04483c..0000000
--- a/src/multimedia/qmediaplaylist_p.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAPLAYLIST_P_H
-#define QMEDIAPLAYLIST_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "qmediaplaylist.h"
-#include "qmediaplaylistcontrol.h"
-#include "qmediaplayer.h"
-#include "qmediaplayercontrol.h"
-#include "qlocalmediaplaylistprovider.h"
-#include "qmediaobject_p.h"
-
-#include <QtCore/qdebug.h>
-
-#ifdef Q_MOC_RUN
-# pragma Q_MOC_EXPAND_MACROS
-#endif
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QMediaPlaylistControl;
-class QMediaPlaylistProvider;
-class QMediaPlaylistReader;
-class QMediaPlaylistWriter;
-class QMediaPlayerControl;
-
-class QMediaPlaylistPrivate
-{
-    Q_DECLARE_PUBLIC(QMediaPlaylist)
-public:
-    QMediaPlaylistPrivate()
-        :mediaObject(0),
-        control(0),
-        localPlaylistControl(0),
-        error(QMediaPlaylist::NoError)
-    {
-    }
-
-    virtual ~QMediaPlaylistPrivate() {}
-
-    void _q_loadFailed(QMediaPlaylist::Error error, const QString &errorString)
-    {
-        this->error = error;
-        this->errorString = errorString;
-
-        emit q_ptr->loadFailed();
-    }
-
-    void _q_mediaObjectDeleted()
-    {
-        Q_Q(QMediaPlaylist);
-        mediaObject = 0;
-        if (control != localPlaylistControl)
-            control = 0;
-        q->setMediaObject(0);
-    }
-
-    QMediaObject *mediaObject;
-
-    QMediaPlaylistControl *control;
-    QMediaPlaylistProvider *playlist() const { return control->playlistProvider(); }
-
-    QMediaPlaylistControl *localPlaylistControl;
-
-    bool readItems(QMediaPlaylistReader *reader);
-    bool writeItems(QMediaPlaylistWriter *writer);
-
-    QMediaPlaylist::Error error;
-    QString errorString;
-
-    QMediaPlaylist *q_ptr;
-};
-
-
-class QLocalMediaPlaylistControl : public QMediaPlaylistControl
-{
-    Q_OBJECT
-public:
-    QLocalMediaPlaylistControl(QObject *parent)
-        :QMediaPlaylistControl(parent)
-    {
-        QMediaPlaylistProvider *playlist = new QLocalMediaPlaylistProvider(this);
-        m_navigator = new QMediaPlaylistNavigator(playlist,this);
-        m_navigator->setPlaybackMode(QMediaPlaylist::Sequential);
-
-        connect(m_navigator, SIGNAL(currentIndexChanged(int)), SIGNAL(currentIndexChanged(int)));
-        connect(m_navigator, SIGNAL(activated(QMediaContent)), SIGNAL(currentMediaChanged(QMediaContent)));
-        connect(m_navigator, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)), SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)));
-    }
-
-    virtual ~QLocalMediaPlaylistControl() {};
-
-    QMediaPlaylistProvider* playlistProvider() const { return m_navigator->playlist(); }
-    bool setPlaylistProvider(QMediaPlaylistProvider *mediaPlaylist)
-    {
-        m_navigator->setPlaylist(mediaPlaylist);
-        emit playlistProviderChanged();
-        return true;
-    }
-
-    int currentIndex() const { return m_navigator->currentIndex(); }
-    void setCurrentIndex(int position) { m_navigator->jump(position); }
-    int nextIndex(int steps) const { return m_navigator->nextIndex(steps); }
-    int previousIndex(int steps) const { return m_navigator->previousIndex(steps); }
-
-    void next() { m_navigator->next(); }
-    void previous() { m_navigator->previous(); }
-
-    QMediaPlaylist::PlaybackMode playbackMode() const { return m_navigator->playbackMode(); }
-    void setPlaybackMode(QMediaPlaylist::PlaybackMode mode) { m_navigator->setPlaybackMode(mode); }
-
-private:
-    QMediaPlaylistNavigator *m_navigator;
-};
-
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QMEDIAPLAYLIST_P_H
diff --git a/src/multimedia/qmediaplaylistcontrol.cpp b/src/multimedia/qmediaplaylistcontrol.cpp
deleted file mode 100644
index dc23489..0000000
--- a/src/multimedia/qmediaplaylistcontrol.cpp
+++ /dev/null
@@ -1,219 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include "qmediaplaylistcontrol.h"
-#include "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QMediaPlaylistControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-
-    \brief The QMediaPlaylistControl class provides access to the playlist
-    functionality of a QMediaService.
-
-    If a QMediaService contains an internal playlist it will implement
-    QMediaPlaylistControl.  This control provides access to the contents of the
-    \l {playlistProvider()}{playlist}, as well as the \l
-    {currentIndex()}{position} of the current media, and a means of navigating
-    to the \l {next()}{next} and \l {previous()}{previous} media.
-
-    The functionality provided by the control is exposed to application code
-    through the QMediaPlaylist class.
-
-    The interface name of QMediaPlaylistControl is \c com.nokia.Qt.QMediaPlaylistControl/1.0 as
-    defined in QMediaPlaylistControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaPlayer
-*/
-
-/*!
-    \macro QMediaPlaylistControl_iid
-
-    \c com.nokia.Qt.QMediaPlaylistControl/1.0
-
-    Defines the interface name of the QMediaPlaylistControl class.
-
-    \relates QMediaPlaylistControl
-*/
-
-/*!
-  Create a new playlist control object with the given \a parent.
-*/
-QMediaPlaylistControl::QMediaPlaylistControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-  Destroys the playlist control.
-*/
-QMediaPlaylistControl::~QMediaPlaylistControl()
-{
-}
-
-
-/*!
-  \fn QMediaPlaylistControl::playlistProvider() const
-
-  Returns the playlist used by this media player.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::setPlaylistProvider(QMediaPlaylistProvider *playlist)
-
-  Set the playlist of this media player to \a playlist.
-
-  In many cases it is possible just to use the playlist
-  constructed by player, but sometimes replacing the whole
-  playlist allows to avoid copyting of all the items bettween playlists.
-
-  Returns true if player can use this passed playlist; otherwise returns false.
-
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::currentIndex() const
-
-  Returns position of the current media source in the playlist.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::setCurrentIndex(int position)
-
-  Jump to the item at the given \a position.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::nextIndex(int step) const
-
-  Returns the index of item, which were current after calling next()
-  \a step times.
-
-  Returned value depends on the size of playlist, current position
-  and playback mode.
-
-  \since 1.0
-  \sa QMediaPlaylist::playbackMode
-*/
-
-/*!
-  \fn QMediaPlaylistControl::previousIndex(int step) const
-
-  Returns the index of item, which were current after calling previous()
-  \a step times.
-
-  \since 1.0
-  \sa QMediaPlaylist::playbackMode
-*/
-
-/*!
-  \fn QMediaPlaylistControl::next()
-
-  Moves to the next item in playlist.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::previous()
-
-  Returns to the previous item in playlist.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::playbackMode() const
-
-  Returns the playlist navigation mode.
-
-  \since 1.0
-  \sa QMediaPlaylist::PlaybackMode
-*/
-
-/*!
-  \fn QMediaPlaylistControl::setPlaybackMode(QMediaPlaylist::PlaybackMode mode)
-
-  Sets the playback \a mode.
-
-  \since 1.0
-  \sa QMediaPlaylist::PlaybackMode
-*/
-
-/*!
-  \fn QMediaPlaylistControl::playlistProviderChanged()
-
-  Signal emitted when the playlist provider has changed.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::currentIndexChanged(int position)
-
-  Signal emitted when the playlist \a position is changed.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::playbackModeChanged(QMediaPlaylist::PlaybackMode mode)
-
-  Signal emitted when the playback \a mode is changed.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistControl::currentMediaChanged(const QMediaContent& content)
-
-  Signal emitted when current media changes to \a content.
-  \since 1.0
-*/
-
-#include "moc_qmediaplaylistcontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaplaylistcontrol.h b/src/multimedia/qmediaplaylistcontrol.h
deleted file mode 100644
index 2cce448..0000000
--- a/src/multimedia/qmediaplaylistcontrol.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef QMEDIAPLAYLISTCONTROL_H
-#define QMEDIAPLAYLISTCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qmediaplaylistnavigator.h"
-
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QMediaPlaylistProvider;
-
-class Q_MULTIMEDIA_EXPORT QMediaPlaylistControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QMediaPlaylistControl();
-
-    virtual QMediaPlaylistProvider* playlistProvider() const = 0;
-    virtual bool setPlaylistProvider(QMediaPlaylistProvider *playlist) = 0;
-
-    virtual int currentIndex() const = 0;
-    virtual void setCurrentIndex(int position) = 0;
-    virtual int nextIndex(int steps) const = 0;
-    virtual int previousIndex(int steps) const = 0;
-
-    virtual void next() = 0;
-    virtual void previous() = 0;
-
-    virtual QMediaPlaylist::PlaybackMode playbackMode() const = 0;
-    virtual void setPlaybackMode(QMediaPlaylist::PlaybackMode mode) = 0;
-
-Q_SIGNALS:
-    void playlistProviderChanged();
-    void currentIndexChanged(int position);
-    void currentMediaChanged(const QMediaContent&);
-    void playbackModeChanged(QMediaPlaylist::PlaybackMode mode);
-
-protected:
-    QMediaPlaylistControl(QObject* parent = 0);
-};
-
-#define QMediaPlaylistControl_iid "com.nokia.Qt.QMediaPlaylistControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaPlaylistControl, QMediaPlaylistControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QMEDIAPLAYLISTCONTROL_H
diff --git a/src/multimedia/qmediaplaylistioplugin.cpp b/src/multimedia/qmediaplaylistioplugin.cpp
deleted file mode 100644
index 80fe0ef..0000000
--- a/src/multimedia/qmediaplaylistioplugin.cpp
+++ /dev/null
@@ -1,204 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaplaylistioplugin.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QMediaPlaylistReader
-
-    \brief The QMediaPlaylistReader class provides an interface for reading a playlist file.
-    \inmodule QtMultimedia
-    \since 1.0
-
-    \sa QMediaPlaylistIOPlugin
-*/
-
-/*!
-    Destroys a media playlist reader.
-*/
-QMediaPlaylistReader::~QMediaPlaylistReader()
-{
-}
-
-/*!
-    \fn QMediaPlaylistReader::atEnd() const
-
-    Identifies if a playlist reader has reached the end of its input.
-
-    Returns true if the reader has reached the end; and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistReader::readItem()
-
-    Reads an item of media from a playlist file.
-
-    Returns the read media, or a null QMediaContent if no more media is available.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistReader::close()
-
-    Closes a playlist reader's input device.
-    \since 1.0
-*/
-
-/*!
-    \class QMediaPlaylistWriter
-
-    \brief The QMediaPlaylistWriter class provides an interface for writing a playlist file.
-
-    \since 1.0
-    \sa QMediaPlaylistIOPlugin
-*/
-
-/*!
-    Destroys a media playlist writer.
-*/
-QMediaPlaylistWriter::~QMediaPlaylistWriter()
-{
-}
-
-/*!
-    \fn QMediaPlaylistWriter::writeItem(const QMediaContent &media)
-
-    Writes an item of \a media to a playlist file.
-
-    Returns true if the media was written successfully; and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistWriter::close()
-
-    Finalizes the writing of a playlist and closes the output device.
-    \since 1.0
-*/
-
-/*!
-    \class QMediaPlaylistIOPlugin
-    \brief The QMediaPlaylistIOPlugin class provides an interface for media playlist I/O plug-ins.
-    \since 1.0
-*/
-
-/*!
-    Constructs a media playlist I/O plug-in with the given \a parent.
-*/
-QMediaPlaylistIOPlugin::QMediaPlaylistIOPlugin(QObject *parent)
-    :QObject(parent)
-{
-}
-
-/*!
-    Destroys a media playlist I/O plug-in.
-*/
-QMediaPlaylistIOPlugin::~QMediaPlaylistIOPlugin()
-{
-}
-
-/*!
-    \fn QMediaPlaylistIOPlugin::canRead(QIODevice *device, const QByteArray &format) const
-
-    Identifies if plug-in can read \a format data from an I/O \a device.
-
-    Returns true if the data can be read; and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistIOPlugin::canRead(const QUrl& location, const QByteArray &format) const
-
-    Identifies if a plug-in can read \a format data from a URL \a location.
-
-    Returns true if the data can be read; and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistIOPlugin::canWrite(QIODevice *device, const QByteArray &format) const
-
-    Identifies if a plug-in can write \a format data to an I/O \a device.
-
-    Returns true if the data can be written; and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistIOPlugin::keys() const
-
-    Returns a list of format keys supported by a plug-in.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistIOPlugin::createReader(QIODevice *device, const QByteArray &format)
-
-    Returns a new QMediaPlaylistReader which reads \a format data from an I/O \a device.
-
-    If the device is invalid or the format is unsupported this will return a null pointer.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistIOPlugin::createReader(const QUrl& location, const QByteArray &format)
-
-    Returns a new QMediaPlaylistReader which reads \a format data from a URL \a location.
-
-    If the location or the format is unsupported this will return a null pointer.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistIOPlugin::createWriter(QIODevice *device, const QByteArray &format)
-
-    Returns a new QMediaPlaylistWriter which writes \a format data to an I/O \a device.
-
-    If the device is invalid or the format is unsupported this will return a null pointer.
-    \since 1.0
-*/
-
-#include "moc_qmediaplaylistioplugin.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaplaylistioplugin.h b/src/multimedia/qmediaplaylistioplugin.h
deleted file mode 100644
index 97ded8b..0000000
--- a/src/multimedia/qmediaplaylistioplugin.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAPLAYLISTIOPLUGIN_H
-#define QMEDIAPLAYLISTIOPLUGIN_H
-
-#include <QtCore/qobject.h>
-#include <QtCore/qplugin.h>
-#include <QtCore/qfactoryinterface.h>
-
-#include <qtmultimediadefs.h>
-
-#include "qmediacontent.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QString;
-class QUrl;
-class QByteArray;
-class QIODevice;
-class QStringList;
-
-class Q_MULTIMEDIA_EXPORT QMediaPlaylistReader
-{
-public:
-    virtual ~QMediaPlaylistReader();
-
-    virtual bool atEnd() const = 0;
-    virtual QMediaContent readItem() = 0;
-    virtual void close() = 0;
-};
-
-class Q_MULTIMEDIA_EXPORT QMediaPlaylistWriter
-{
-public:
-    virtual ~QMediaPlaylistWriter();
-
-    virtual bool writeItem(const QMediaContent &content) = 0;
-    virtual void close() = 0;
-};
-
-struct Q_MULTIMEDIA_EXPORT QMediaPlaylistIOInterface : public QFactoryInterface
-{
-    virtual bool canRead(QIODevice *device, const QByteArray &format = QByteArray() ) const = 0;
-    virtual bool canRead(const QUrl& location, const QByteArray &format = QByteArray()) const = 0;
-
-    virtual bool canWrite(QIODevice *device, const QByteArray &format) const = 0;
-
-    virtual QMediaPlaylistReader *createReader(QIODevice *device, const QByteArray &format = QByteArray()) = 0;
-    virtual QMediaPlaylistReader *createReader(const QUrl& location, const QByteArray &format = QByteArray()) = 0;
-
-    virtual QMediaPlaylistWriter *createWriter(QIODevice *device, const QByteArray &format) = 0;
-};
-
-#define QMediaPlaylistIOInterface_iid "com.nokia.Qt.QMediaPlaylistIOInterface"
-Q_DECLARE_INTERFACE(QMediaPlaylistIOInterface, QMediaPlaylistIOInterface_iid);
-
-class Q_MULTIMEDIA_EXPORT QMediaPlaylistIOPlugin : public QObject, public QMediaPlaylistIOInterface
-{
-Q_OBJECT
-Q_INTERFACES(QMediaPlaylistIOInterface:QFactoryInterface)
-public:
-    explicit QMediaPlaylistIOPlugin(QObject *parent = 0);
-    virtual ~QMediaPlaylistIOPlugin();
-
-    virtual bool canRead(QIODevice *device, const QByteArray &format = QByteArray() ) const = 0;
-    virtual bool canRead(const QUrl& location, const QByteArray &format = QByteArray()) const = 0;
-
-    virtual bool canWrite(QIODevice *device, const QByteArray &format) const = 0;
-
-    virtual QStringList keys() const = 0;
-
-    virtual QMediaPlaylistReader *createReader(QIODevice *device, const QByteArray &format = QByteArray()) = 0;
-    virtual QMediaPlaylistReader *createReader(const QUrl& location, const QByteArray &format = QByteArray()) = 0;
-
-    virtual QMediaPlaylistWriter *createWriter(QIODevice *device, const QByteArray &format) = 0;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QMEDIAPLAYLISTIOPLUGIN_H
diff --git a/src/multimedia/qmediaplaylistnavigator.cpp b/src/multimedia/qmediaplaylistnavigator.cpp
deleted file mode 100644
index d78e6ef..0000000
--- a/src/multimedia/qmediaplaylistnavigator.cpp
+++ /dev/null
@@ -1,568 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaplaylistnavigator.h"
-#include "qmediaplaylistprovider.h"
-#include "qmediaplaylist.h"
-#include "qmediaobject_p.h"
-
-#include <QtCore/qdebug.h>
-
-QT_BEGIN_NAMESPACE
-
-class QMediaPlaylistNullProvider : public QMediaPlaylistProvider
-{
-public:
-    QMediaPlaylistNullProvider() :QMediaPlaylistProvider() {}
-    virtual ~QMediaPlaylistNullProvider() {}
-    virtual int mediaCount() const {return 0;}
-    virtual QMediaContent media(int) const { return QMediaContent(); }
-};
-
-Q_GLOBAL_STATIC(QMediaPlaylistNullProvider, _q_nullMediaPlaylist)
-
-class QMediaPlaylistNavigatorPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QMediaPlaylistNavigator)
-public:
-    QMediaPlaylistNavigatorPrivate()
-        :playlist(0),
-        currentPos(-1),
-        lastValidPos(-1),
-        playbackMode(QMediaPlaylist::Sequential),
-        randomPositionsOffset(-1)
-    {
-    }
-
-    QMediaPlaylistProvider *playlist;
-    int currentPos;
-    int lastValidPos; //to be used with CurrentItemOnce playback mode
-    QMediaPlaylist::PlaybackMode playbackMode;
-    QMediaContent currentItem;
-
-    mutable QList<int> randomModePositions;
-    mutable int randomPositionsOffset;
-
-    int nextItemPos(int steps = 1) const;
-    int previousItemPos(int steps = 1) const;
-
-    void _q_mediaInserted(int start, int end);
-    void _q_mediaRemoved(int start, int end);
-    void _q_mediaChanged(int start, int end);
-
-    QMediaPlaylistNavigator *q_ptr;
-};
-
-
-int QMediaPlaylistNavigatorPrivate::nextItemPos(int steps) const
-{
-    if (playlist->mediaCount() == 0)
-        return -1;
-
-    if (steps == 0)
-        return currentPos;
-
-    switch (playbackMode) {
-        case QMediaPlaylist::CurrentItemOnce:
-            return /*currentPos == -1 ? lastValidPos :*/ -1;
-        case QMediaPlaylist::CurrentItemInLoop:
-            return currentPos;
-        case QMediaPlaylist::Sequential:
-            {
-                int nextPos = currentPos+steps;
-                return nextPos < playlist->mediaCount() ? nextPos : -1;
-            }
-        case QMediaPlaylist::Loop:
-            return (currentPos+steps) % playlist->mediaCount();
-        case QMediaPlaylist::Random:
-            {
-                //TODO: limit the history size
-
-                if (randomPositionsOffset == -1) {
-                    randomModePositions.clear();
-                    randomModePositions.append(currentPos);
-                    randomPositionsOffset = 0;
-                }
-
-                while (randomModePositions.size() < randomPositionsOffset+steps+1)
-                    randomModePositions.append(-1);
-                int res = randomModePositions[randomPositionsOffset+steps];
-                if (res<0 || res >= playlist->mediaCount()) {
-                    res = qrand() % playlist->mediaCount();
-                    randomModePositions[randomPositionsOffset+steps] = res;
-                }
-
-                return res;
-            }
-    }
-
-    return -1;
-}
-
-int QMediaPlaylistNavigatorPrivate::previousItemPos(int steps) const
-{
-    if (playlist->mediaCount() == 0)
-        return -1;
-
-    if (steps == 0)
-        return currentPos;
-
-    switch (playbackMode) {
-        case QMediaPlaylist::CurrentItemOnce:
-            return /*currentPos == -1 ? lastValidPos :*/ -1;
-        case QMediaPlaylist::CurrentItemInLoop:
-            return currentPos;
-        case QMediaPlaylist::Sequential:
-            {
-                int prevPos = currentPos == -1 ? playlist->mediaCount() - steps : currentPos - steps;
-                return prevPos>=0 ? prevPos : -1;
-            }
-        case QMediaPlaylist::Loop:
-            {
-                int prevPos = currentPos - steps;
-                while (prevPos<0)
-                    prevPos += playlist->mediaCount();
-                return prevPos;
-            }
-        case QMediaPlaylist::Random:
-            {
-                //TODO: limit the history size
-
-                if (randomPositionsOffset == -1) {
-                    randomModePositions.clear();
-                    randomModePositions.append(currentPos);
-                    randomPositionsOffset = 0;
-                }
-
-                while (randomPositionsOffset-steps < 0) {
-                    randomModePositions.prepend(-1);
-                    randomPositionsOffset++;
-                }
-
-                int res = randomModePositions[randomPositionsOffset-steps];
-                if (res<0 || res >= playlist->mediaCount()) {
-                    res = qrand() % playlist->mediaCount();
-                    randomModePositions[randomPositionsOffset-steps] = res;
-                }
-
-                return res;
-            }
-    }
-
-    return -1;
-}
-
-/*!
-    \class QMediaPlaylistNavigator
-
-    \brief The QMediaPlaylistNavigator class provides navigation for a media playlist.
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-    \sa QMediaPlaylist, QMediaPlaylistProvider
-*/
-
-
-/*!
-    Constructs a media playlist navigator for a \a playlist.
-
-    The \a parent is passed to QObject.
-    \since 1.0
- */
-QMediaPlaylistNavigator::QMediaPlaylistNavigator(QMediaPlaylistProvider *playlist, QObject *parent)
-    : QObject(parent)
-    , d_ptr(new QMediaPlaylistNavigatorPrivate)
-{
-    d_ptr->q_ptr = this;
-
-    setPlaylist(playlist ? playlist : _q_nullMediaPlaylist());
-}
-
-/*!
-    Destroys a media playlist navigator.
- */
-
-QMediaPlaylistNavigator::~QMediaPlaylistNavigator()
-{
-    delete d_ptr;
-}
-
-
-/*! \property QMediaPlaylistNavigator::playbackMode
-    Contains the playback mode.
-    \since 1.0
- */
-QMediaPlaylist::PlaybackMode QMediaPlaylistNavigator::playbackMode() const
-{
-    return d_func()->playbackMode;
-}
-
-/*!
-    Sets the playback \a mode.
-    \since 1.0
- */
-void QMediaPlaylistNavigator::setPlaybackMode(QMediaPlaylist::PlaybackMode mode)
-{
-    Q_D(QMediaPlaylistNavigator);
-    if (d->playbackMode == mode)
-        return;
-
-    if (mode == QMediaPlaylist::Random) {
-        d->randomPositionsOffset = 0;
-        d->randomModePositions.append(d->currentPos);
-    } else if (d->playbackMode == QMediaPlaylist::Random) {
-        d->randomPositionsOffset = -1;
-        d->randomModePositions.clear();
-    }
-
-    d->playbackMode = mode;
-
-    emit playbackModeChanged(mode);
-    emit surroundingItemsChanged();
-}
-
-/*!
-    Returns the playlist being navigated.
-    \since 1.0
-*/
-
-QMediaPlaylistProvider *QMediaPlaylistNavigator::playlist() const
-{
-    return d_func()->playlist;
-}
-
-/*!
-    Sets the \a playlist to navigate.
-    \since 1.0
-*/
-void QMediaPlaylistNavigator::setPlaylist(QMediaPlaylistProvider *playlist)
-{
-    Q_D(QMediaPlaylistNavigator);
-
-    if (d->playlist == playlist)
-        return;
-
-    if (d->playlist) {
-        d->playlist->disconnect(this);
-    }
-
-    if (playlist) {
-        d->playlist = playlist;
-    } else {
-        //assign to shared readonly null playlist
-        d->playlist = _q_nullMediaPlaylist();
-    }
-
-    connect(d->playlist, SIGNAL(mediaInserted(int,int)), SLOT(_q_mediaInserted(int,int)));
-    connect(d->playlist, SIGNAL(mediaRemoved(int,int)), SLOT(_q_mediaRemoved(int,int)));
-    connect(d->playlist, SIGNAL(mediaChanged(int,int)), SLOT(_q_mediaChanged(int,int)));
-
-    d->randomPositionsOffset = -1;
-    d->randomModePositions.clear();
-
-    if (d->currentPos != -1) {
-        d->currentPos = -1;
-        emit currentIndexChanged(-1);
-    }
-
-    if (!d->currentItem.isNull()) {
-        d->currentItem = QMediaContent();
-        emit activated(d->currentItem); //stop playback
-    }
-}
-
-/*! \property QMediaPlaylistNavigator::currentItem
-
-  Contains the media at the current position in the playlist.
-
-  \since 1.0
-  \sa currentIndex()
-*/
-
-QMediaContent QMediaPlaylistNavigator::currentItem() const
-{
-    return itemAt(d_func()->currentPos);
-}
-
-/*! \fn QMediaContent QMediaPlaylistNavigator::nextItem(int steps) const
-
-  Returns the media that is \a steps positions ahead of the current
-  position in the playlist.
-
-  \since 1.0
-  \sa nextIndex()
-*/
-QMediaContent QMediaPlaylistNavigator::nextItem(int steps) const
-{
-    return itemAt(nextIndex(steps));
-}
-
-/*!
-  Returns the media that is \a steps positions behind the current
-  position in the playlist.
-
-  \since 1.0
-  \sa previousIndex()
- */
-QMediaContent QMediaPlaylistNavigator::previousItem(int steps) const
-{
-    return itemAt(previousIndex(steps));
-}
-
-/*!
-    Returns the media at a \a position in the playlist.
-    \since 1.0
- */
-QMediaContent QMediaPlaylistNavigator::itemAt(int position) const
-{
-    return d_func()->playlist->media(position);
-}
-
-/*! \property QMediaPlaylistNavigator::currentIndex
-
-  Contains the position of the current media.
-
-  If no media is current, the property contains -1.
-
-  \since 1.0
-  \sa nextIndex(), previousIndex()
-*/
-
-int QMediaPlaylistNavigator::currentIndex() const
-{
-    return d_func()->currentPos;
-}
-
-/*!
-  Returns a position \a steps ahead of the current position
-  accounting for the playbackMode().
-
-  If the position is beyond the end of the playlist, this value
-  returned is -1.
-
-  \since 1.0
-  \sa currentIndex(), previousIndex(), playbackMode()
-*/
-
-int QMediaPlaylistNavigator::nextIndex(int steps) const
-{
-    return d_func()->nextItemPos(steps);
-}
-
-/*!
-
-  Returns a position \a steps behind the current position accounting
-  for the playbackMode().
-
-  If the position is prior to the beginning of the playlist this will
-  return -1.
-
-  \since 1.0
-  \sa currentIndex(), nextIndex(), playbackMode()
-*/
-int QMediaPlaylistNavigator::previousIndex(int steps) const
-{
-    return d_func()->previousItemPos(steps);
-}
-
-/*!
-  Advances to the next item in the playlist.
-
-  \since 1.0
-  \sa previous(), jump(), playbackMode()
- */
-void QMediaPlaylistNavigator::next()
-{
-    Q_D(QMediaPlaylistNavigator);
-
-    int nextPos = d->nextItemPos();
-
-    if ( playbackMode() == QMediaPlaylist::Random )
-            d->randomPositionsOffset++;
-
-    jump(nextPos);
-}
-
-/*!
-  Returns to the previous item in the playlist,
-
-  \since 1.0
-  \sa next(), jump(), playbackMode()
- */
-void QMediaPlaylistNavigator::previous()
-{
-    Q_D(QMediaPlaylistNavigator);
-
-    int prevPos = d->previousItemPos();
-    if ( playbackMode() == QMediaPlaylist::Random )
-        d->randomPositionsOffset--;
-
-    jump(prevPos);
-}
-
-/*!
-  Jumps to a new \a position in the playlist.
-  \since 1.0
- */
-void QMediaPlaylistNavigator::jump(int position)
-{
-    Q_D(QMediaPlaylistNavigator);
-
-    if (position<-1 || position>=d->playlist->mediaCount()) {
-        qWarning() << "QMediaPlaylistNavigator: Jump outside playlist range";
-        position = -1;
-    }
-
-    if (position != -1)
-        d->lastValidPos = position;
-
-    if (playbackMode() == QMediaPlaylist::Random) {
-        if (d->randomModePositions[d->randomPositionsOffset] != position) {
-            d->randomModePositions.clear();
-            d->randomModePositions.append(position);
-            d->randomPositionsOffset = 0;
-        }
-    }
-
-    if (position != -1)
-        d->currentItem = d->playlist->media(position);
-    else
-        d->currentItem = QMediaContent();
-
-    if (position != d->currentPos) {
-        d->currentPos = position;
-        emit currentIndexChanged(d->currentPos);
-        emit surroundingItemsChanged();
-    }
-
-    emit activated(d->currentItem);
-}
-
-/*!
-    \internal
-  \since 1.0
-*/
-void QMediaPlaylistNavigatorPrivate::_q_mediaInserted(int start, int end)
-{
-    Q_Q(QMediaPlaylistNavigator);
-
-    if (currentPos >= start) {
-        currentPos = end-start+1;
-        q->jump(currentPos);
-    }
-
-    //TODO: check if they really changed
-    emit q->surroundingItemsChanged();
-}
-
-/*!
-    \internal
-    \since 1.0
-*/
-void QMediaPlaylistNavigatorPrivate::_q_mediaRemoved(int start, int end)
-{
-    Q_Q(QMediaPlaylistNavigator);
-
-    if (currentPos > end) {
-        currentPos = currentPos - end-start+1;
-        q->jump(currentPos);
-    } else if (currentPos >= start) {
-        //current item was removed
-        currentPos = qMin(start, playlist->mediaCount()-1);
-        q->jump(currentPos);
-    }
-
-    //TODO: check if they really changed
-    emit q->surroundingItemsChanged();
-}
-
-/*!
-    \internal
-    \since 1.0
-*/
-void QMediaPlaylistNavigatorPrivate::_q_mediaChanged(int start, int end)
-{
-    Q_Q(QMediaPlaylistNavigator);
-
-    if (currentPos >= start && currentPos<=end) {
-        QMediaContent src = playlist->media(currentPos);
-        if (src != currentItem) {
-            currentItem = src;
-            emit q->activated(src);
-        }
-    }
-
-    //TODO: check if they really changed
-    emit q->surroundingItemsChanged();
-}
-
-/*!
-    \fn QMediaPlaylistNavigator::activated(const QMediaContent &media)
-
-    Signals that the current \a media has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistNavigator::currentIndexChanged(int position)
-
-    Signals the \a position of the current media has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistNavigator::playbackModeChanged(QMediaPlaylist::PlaybackMode mode)
-
-    Signals that the playback \a mode has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistNavigator::surroundingItemsChanged()
-
-    Signals that media immediately surrounding the current position has changed.
-    \since 1.0
-*/
-
-#include "moc_qmediaplaylistnavigator.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaplaylistnavigator.h b/src/multimedia/qmediaplaylistnavigator.h
deleted file mode 100644
index 72e4520..0000000
--- a/src/multimedia/qmediaplaylistnavigator.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAPLAYLISTNAVIGATOR_H
-#define QMEDIAPLAYLISTNAVIGATOR_H
-
-#include "qmediaplaylistprovider.h"
-#include "qmediaplaylist.h"
-#include <QtCore/qobject.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QMediaPlaylistNavigatorPrivate;
-class Q_MULTIMEDIA_EXPORT QMediaPlaylistNavigator : public QObject
-{
-    Q_OBJECT
-    Q_PROPERTY(QMediaPlaylist::PlaybackMode playbackMode READ playbackMode WRITE setPlaybackMode NOTIFY playbackModeChanged)
-    Q_PROPERTY(int currentIndex READ currentIndex WRITE jump NOTIFY currentIndexChanged)
-    Q_PROPERTY(QMediaContent currentItem READ currentItem)
-
-public:
-    QMediaPlaylistNavigator(QMediaPlaylistProvider *playlist, QObject *parent = 0);
-    virtual ~QMediaPlaylistNavigator();
-
-    QMediaPlaylistProvider *playlist() const;
-    void setPlaylist(QMediaPlaylistProvider *playlist);
-
-    QMediaPlaylist::PlaybackMode playbackMode() const;
-
-    QMediaContent currentItem() const;
-    QMediaContent nextItem(int steps = 1) const;
-    QMediaContent previousItem(int steps = 1) const;
-
-    QMediaContent itemAt(int position) const;
-
-    int currentIndex() const;
-    int nextIndex(int steps = 1) const;
-    int previousIndex(int steps = 1) const;
-
-public Q_SLOTS:
-    void next();
-    void previous();
-
-    void jump(int);
-
-    void setPlaybackMode(QMediaPlaylist::PlaybackMode mode);
-
-Q_SIGNALS:
-    void activated(const QMediaContent &content);
-    void currentIndexChanged(int);
-    void playbackModeChanged(QMediaPlaylist::PlaybackMode mode);
-
-    void surroundingItemsChanged();
-
-protected:
-    QMediaPlaylistNavigatorPrivate *d_ptr;
-
-private:
-    Q_DISABLE_COPY(QMediaPlaylistNavigator)
-    Q_DECLARE_PRIVATE(QMediaPlaylistNavigator)
-
-    Q_PRIVATE_SLOT(d_func(), void _q_mediaInserted(int start, int end))
-    Q_PRIVATE_SLOT(d_func(), void _q_mediaRemoved(int start, int end))
-    Q_PRIVATE_SLOT(d_func(), void _q_mediaChanged(int start, int end))
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QMEDIAPLAYLISTNAVIGATOR_H
diff --git a/src/multimedia/qmediaplaylistprovider.cpp b/src/multimedia/qmediaplaylistprovider.cpp
deleted file mode 100644
index 75e927b..0000000
--- a/src/multimedia/qmediaplaylistprovider.cpp
+++ /dev/null
@@ -1,329 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaplaylistprovider.h"
-#include "qmediaplaylistprovider_p.h"
-
-#include <QtCore/qurl.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QMediaPlaylistProvider
-
-    \brief The QMediaPlaylistProvider class provides an abstract list of media.
-    \inmodule QtMultimedia
-    \since 1.0
-
-    \sa QMediaPlaylist
-*/
-
-/*!
-    Constructs a playlist provider with the given \a parent.
-*/
-QMediaPlaylistProvider::QMediaPlaylistProvider(QObject *parent)
-    :QObject(parent), d_ptr(new QMediaPlaylistProviderPrivate)
-{
-}
-
-/*!
-    \internal
-*/
-QMediaPlaylistProvider::QMediaPlaylistProvider(QMediaPlaylistProviderPrivate &dd, QObject *parent)
-    :QObject(parent), d_ptr(&dd)
-{
-}
-
-/*!
-    Destroys a playlist provider.
-*/
-QMediaPlaylistProvider::~QMediaPlaylistProvider()
-{
-    delete d_ptr;
-}
-
-/*!
-    \fn QMediaPlaylistProvider::mediaCount() const;
-
-    Returns the size of playlist.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaPlaylistProvider::media(int index) const;
-
-    Returns the media at \a index in the playlist.
-
-    If the index is invalid this will return a null media content.
-    \since 1.0
-*/
-
-
-/*!
-    Loads a playlist from from a URL \a location. If no playlist \a format is specified the loader
-    will inspect the URL or probe the headers to guess the format.
-
-    New items are appended to playlist.
-
-    Returns true if the provider supports the format and loading from the locations URL protocol,
-    otherwise this will return false.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::load(const QUrl &location, const char *format)
-{
-    Q_UNUSED(location);
-    Q_UNUSED(format);
-    return false;
-}
-
-/*!
-    Loads a playlist from from an I/O \a device. If no playlist \a format is specified the loader
-    will probe the headers to guess the format.
-
-    New items are appended to playlist.
-
-    Returns true if the provider supports the format and loading from an I/O device, otherwise this
-    will return false.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::load(QIODevice * device, const char *format)
-{
-    Q_UNUSED(device);
-    Q_UNUSED(format);
-    return false;
-}
-
-/*!
-    Saves the contents of a playlist to a URL \a location.  If no playlist \a format is specified
-    the writer will inspect the URL to guess the format.
-
-    Returns true if the playlist was saved successfully; and false otherwise.
-    \since 1.0
-  */
-bool QMediaPlaylistProvider::save(const QUrl &location, const char *format)
-{
-    Q_UNUSED(location);
-    Q_UNUSED(format);
-    return false;
-}
-
-/*!
-    Saves the contents of a playlist to an I/O \a device in the specified \a format.
-
-    Returns true if the playlist was saved successfully; and false otherwise.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::save(QIODevice * device, const char *format)
-{
-    Q_UNUSED(device);
-    Q_UNUSED(format);
-    return false;
-}
-
-/*!
-    Returns true if a playlist is read-only; otherwise returns false.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::isReadOnly() const
-{
-    return true;
-}
-
-/*!
-    Append \a media to a playlist.
-
-    Returns true if the media was appended; and false otherwise.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::addMedia(const QMediaContent &media)
-{
-    Q_UNUSED(media);
-    return false;
-}
-
-/*!
-    Append multiple media \a items to a playlist.
-
-    Returns true if the media items were appended; and false otherwise.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::addMedia(const QList<QMediaContent> &items)
-{
-    foreach(const QMediaContent &item, items) {
-        if (!addMedia(item))
-            return false;
-    }
-
-    return true;
-}
-
-/*!
-    Inserts \a media into a playlist at \a position.
-
-    Returns true if the media was inserted; and false otherwise.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::insertMedia(int position, const QMediaContent &media)
-{
-    Q_UNUSED(position);
-    Q_UNUSED(media);
-    return false;
-}
-
-/*!
-    Inserts multiple media \a items into a playlist at \a position.
-
-    Returns true if the media \a items were inserted; and false otherwise.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::insertMedia(int position, const QList<QMediaContent> &items)
-{
-    for (int i=0; i<items.count(); i++) {
-        if (!insertMedia(position+i,items.at(i)))
-            return false;
-    }
-
-    return true;
-}
-
-
-/*!
-    Removes the media at \a position from a playlist.
-
-    Returns true if the media was removed; and false otherwise.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::removeMedia(int position)
-{
-    Q_UNUSED(position);
-    return false;
-}
-
-/*!
-    Removes the media between the given \a start and \a end positions from a playlist.
-
-    Returns true if the media was removed; and false otherwise.
-    \since 1.0
-  */
-bool QMediaPlaylistProvider::removeMedia(int start, int end)
-{
-    for (int pos=start; pos<=end; pos++) {
-        if (!removeMedia(pos))
-            return false;
-    }
-
-    return true;
-}
-
-/*!
-    Removes all media from a playlist.
-
-    Returns true if the media was removed; and false otherwise.
-    \since 1.0
-*/
-bool QMediaPlaylistProvider::clear()
-{
-    return removeMedia(0, mediaCount()-1);
-}
-
-/*!
-    Shuffles the contents of a playlist.
-    \since 1.0
-*/
-void QMediaPlaylistProvider::shuffle()
-{
-}
-
-/*!
-    \fn void QMediaPlaylistProvider::mediaAboutToBeInserted(int start, int end);
-
-    Signals that new media is about to be inserted into a playlist between the \a start and \a end
-    positions.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylistProvider::mediaInserted(int start, int end);
-
-    Signals that new media has been inserted into a playlist between the \a start and \a end
-    positions.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylistProvider::mediaAboutToBeRemoved(int start, int end);
-
-    Signals that media is about to be removed from a playlist between the \a start and \a end
-    positions.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylistProvider::mediaRemoved(int start, int end);
-
-    Signals that media has been removed from a playlist between the \a start and \a end positions.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylistProvider::mediaChanged(int start, int end);
-
-    Signals that media in playlist between the \a start and \a end positions inclusive has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylistProvider::loaded()
-
-    Signals that a load() finished successfully.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaPlaylistProvider::loadFailed(QMediaPlaylist::Error error, const QString& errorMessage)
-
-    Signals that a load failed() due to an \a error.  The \a errorMessage provides more information.
-    \since 1.0
-*/
-
-#include "moc_qmediaplaylistprovider.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaplaylistprovider.h b/src/multimedia/qmediaplaylistprovider.h
deleted file mode 100644
index 79167e8..0000000
--- a/src/multimedia/qmediaplaylistprovider.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAPLAYLISTPROVIDER_H
-#define QMEDIAPLAYLISTPROVIDER_H
-
-#include <QObject>
-
-#include "qmediacontent.h"
-#include "qmediaplaylist.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QString;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class QMediaPlaylistProviderPrivate;
-class Q_MULTIMEDIA_EXPORT QMediaPlaylistProvider : public QObject
-{
-Q_OBJECT
-public:
-    QMediaPlaylistProvider(QObject *parent=0);
-    virtual ~QMediaPlaylistProvider();
-
-    virtual bool load(const QUrl &location, const char *format = 0);
-    virtual bool load(QIODevice * device, const char *format = 0);
-    virtual bool save(const QUrl &location, const char *format = 0);
-    virtual bool save(QIODevice * device, const char *format);
-
-    virtual int mediaCount() const = 0;
-    virtual QMediaContent media(int index) const = 0;
-
-    virtual bool isReadOnly() const;
-
-    virtual bool addMedia(const QMediaContent &content);
-    virtual bool addMedia(const QList<QMediaContent> &contentList);
-    virtual bool insertMedia(int index, const QMediaContent &content);
-    virtual bool insertMedia(int index, const QList<QMediaContent> &content);
-    virtual bool removeMedia(int pos);
-    virtual bool removeMedia(int start, int end);
-    virtual bool clear();
-
-public Q_SLOTS:
-    virtual void shuffle();
-
-Q_SIGNALS:
-    void mediaAboutToBeInserted(int start, int end);
-    void mediaInserted(int start, int end);
-
-    void mediaAboutToBeRemoved(int start, int end);
-    void mediaRemoved(int start, int end);
-
-    void mediaChanged(int start, int end);
-
-    void loaded();
-    void loadFailed(QMediaPlaylist::Error, const QString& errorMessage);
-
-protected:
-    QMediaPlaylistProviderPrivate *d_ptr;
-    QMediaPlaylistProvider(QMediaPlaylistProviderPrivate &dd, QObject *parent);
-
-private:
-    Q_DECLARE_PRIVATE(QMediaPlaylistProvider)
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QMEDIAPLAYLISTPROVIDER_H
diff --git a/src/multimedia/qmediaplaylistprovider_p.h b/src/multimedia/qmediaplaylistprovider_p.h
deleted file mode 100644
index 71fb86f..0000000
--- a/src/multimedia/qmediaplaylistprovider_p.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIAPLAYLISTPROVIDER_P_H
-#define QMEDIAPLAYLISTPROVIDER_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "qmediaplaylist.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QMediaPlaylistProviderPrivate
-{
-public:
-    QMediaPlaylistProviderPrivate()
-    {}
-    virtual ~QMediaPlaylistProviderPrivate()
-    {}
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-
-#endif // QMEDIAPLAYLISTSOURCE_P_H
diff --git a/src/multimedia/qmediaplaylistsourcecontrol.cpp b/src/multimedia/qmediaplaylistsourcecontrol.cpp
deleted file mode 100644
index 2ab8aee..0000000
--- a/src/multimedia/qmediaplaylistsourcecontrol.cpp
+++ /dev/null
@@ -1,128 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include "qmediaplaylistsourcecontrol.h"
-#include "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QMediaPlaylistSourceControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-
-    \brief The QMediaPlaylistSourceControl class provides access to the playlist playback
-    functionality of a QMediaService.
-
-    This control allows QMediaPlaylist to be passed directly to the service
-    instead of playing media sources one by one.  This control should be
-    implemented if backend benefits from knowing the next media source to be
-    played, for example for preloading, cross fading or gap-less playback.
-
-    If QMediaPlaylistSourceControl is provided, the backend must listen for
-    current playlist item changes to load corresponding media source and
-    advance the playlist  with QMediaPlaylist::next() when playback of the
-    current media is finished.
-
-    The interface name of QMediaPlaylistSourceControl is \c com.nokia.Qt.QMediaPlaylistSourceControl/1.0 as
-    defined in QMediaPlaylistSourceControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaPlayer
-*/
-
-/*!
-    \macro QMediaPlaylistSourceControl_iid
-
-    \c com.nokia.Qt.QMediaPlaylistSourceControl/1.0
-
-    Defines the interface name of the QMediaPlaylistSourceControl class.
-
-    \relates QMediaPlaylistSourceControl
-*/
-
-/*!
-  Create a new playlist source control object with the given \a parent.
-*/
-QMediaPlaylistSourceControl::QMediaPlaylistSourceControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-  Destroys the playlist control.
-*/
-QMediaPlaylistSourceControl::~QMediaPlaylistSourceControl()
-{
-}
-
-
-/*!
-  \fn QMediaPlaylistSourceControl::playlist() const
-
-  Returns the current playlist.
-  Should return a null pointer if no playlist is assigned.
-  \since 1.0
-*/
-
-/*!
-  \fn QMediaPlaylistSourceControl::setPlaylist(QMediaPlaylist *playlist)
-
-  Set the playlist of this media player to \a playlist.
-  If a null pointer is passed, the playlist source should be disabled.
-
-  The current media should be replaced with the current item of the media playlist.
-  \since 1.0
-*/
-
-
-/*!
-  \fn QMediaPlaylistSourceControl::playlistChanged(QMediaPlaylist* playlist)
-
-  Signal emitted when the playlist has changed to \a playlist.
-  \since 1.0
-*/
-
-#include "moc_qmediaplaylistsourcecontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaplaylistsourcecontrol.h b/src/multimedia/qmediaplaylistsourcecontrol.h
deleted file mode 100644
index 040bb64..0000000
--- a/src/multimedia/qmediaplaylistsourcecontrol.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef QMEDIAPLAYLISTSOURCECONTROL_H
-#define QMEDIAPLAYLISTSOURCECONTROL_H
-
-#include <qmediacontrol.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QMediaPlaylist;
-
-class Q_MULTIMEDIA_EXPORT QMediaPlaylistSourceControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QMediaPlaylistSourceControl();
-
-    virtual QMediaPlaylist *playlist() const = 0;
-    virtual void setPlaylist(QMediaPlaylist *) = 0;
-
-Q_SIGNALS:
-    void playlistChanged(QMediaPlaylist* playlist);
-
-protected:
-    QMediaPlaylistSourceControl(QObject* parent = 0);
-};
-
-#define QMediaPlaylistSourceControl_iid "com.nokia.Qt.QMediaPlaylistSourceControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaPlaylistSourceControl, QMediaPlaylistSourceControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QMEDIAPLAYLISTCONTROL_H
diff --git a/src/multimedia/qmediarecorder.cpp b/src/multimedia/qmediarecorder.cpp
deleted file mode 100644
index 6be462d..0000000
--- a/src/multimedia/qmediarecorder.cpp
+++ /dev/null
@@ -1,904 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediarecorder.h"
-
-#include <qmediarecordercontrol.h>
-#include "qmediaobject_p.h"
-#include <qmediaservice.h>
-#include <qmediaserviceprovider.h>
-#include <qmetadatawritercontrol.h>
-#include <qaudioencodercontrol.h>
-#include <qvideoencodercontrol.h>
-#include <qmediacontainercontrol.h>
-#include <qcamera.h>
-#include <qcameracontrol.h>
-
-#include <QtCore/qdebug.h>
-#include <QtCore/qurl.h>
-#include <QtCore/qstringlist.h>
-#include <QtCore/qmetaobject.h>
-
-#include <qaudioformat.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QMediaRecorder
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-
-    \brief The QMediaRecorder class is used for the recording of media content.
-
-    The QMediaRecorder class is a high level media recording class.  It's not
-    intended to be used alone but for accessing the media recording functions
-    of other media objects, like QRadioTuner, or QAudioCaptureSource.
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Media recorder
-
-    \sa QAudioCaptureSource
-*/
-
-namespace
-{
-class MediaRecorderRegisterMetaTypes
-{
-public:
-    MediaRecorderRegisterMetaTypes()
-    {
-        qRegisterMetaType<QMediaRecorder::State>("QMediaRecorder::State");
-        qRegisterMetaType<QMediaRecorder::Error>("QMediaRecorder::Error");
-    }
-} _registerRecorderMetaTypes;
-}
-
-
-class QMediaRecorderPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QMediaRecorder)
-
-public:
-    QMediaRecorderPrivate();
-
-    QMediaObject *mediaObject;
-
-    QMediaRecorderControl *control;
-    QMediaContainerControl *formatControl;
-    QAudioEncoderControl *audioControl;
-    QVideoEncoderControl *videoControl;
-    QMetaDataWriterControl *metaDataControl;
-
-    QTimer* notifyTimer;
-
-    QMediaRecorder::State state;
-    QMediaRecorder::Error error;
-    QString errorString;
-
-    void _q_stateChanged(QMediaRecorder::State state);
-    void _q_error(int error, const QString &errorString);
-    void _q_serviceDestroyed();
-    void _q_notify();
-    void _q_updateNotifyInterval(int ms);
-
-    QMediaRecorder *q_ptr;
-};
-
-QMediaRecorderPrivate::QMediaRecorderPrivate():
-     mediaObject(0),
-     control(0),
-     formatControl(0),
-     audioControl(0),
-     videoControl(0),
-     metaDataControl(0),
-     notifyTimer(0),
-     state(QMediaRecorder::StoppedState),
-     error(QMediaRecorder::NoError)
-{
-}
-
-#define ENUM_NAME(c,e,v) (c::staticMetaObject.enumerator(c::staticMetaObject.indexOfEnumerator(e)).valueToKey((v)))
-
-void QMediaRecorderPrivate::_q_stateChanged(QMediaRecorder::State ps)
-{
-    Q_Q(QMediaRecorder);
-
-    if (ps == QMediaRecorder::RecordingState)
-        notifyTimer->start();
-    else
-        notifyTimer->stop();
-
-//    qDebug() << "Recorder state changed:" << ENUM_NAME(QMediaRecorder,"State",ps);
-    if (state != ps) {
-        emit q->stateChanged(ps);
-    }
-
-    state = ps;
-}
-
-
-void QMediaRecorderPrivate::_q_error(int error, const QString &errorString)
-{
-    Q_Q(QMediaRecorder);
-
-    this->error = QMediaRecorder::Error(error);
-    this->errorString = errorString;
-
-    emit q->error(this->error);
-}
-
-void QMediaRecorderPrivate::_q_serviceDestroyed()
-{
-    mediaObject = 0;
-    control = 0;
-    formatControl = 0;
-    audioControl = 0;
-    videoControl = 0;
-    metaDataControl = 0;
-}
-
-void QMediaRecorderPrivate::_q_notify()
-{
-    emit q_func()->durationChanged(q_func()->duration());
-}
-
-void QMediaRecorderPrivate::_q_updateNotifyInterval(int ms)
-{
-    notifyTimer->setInterval(ms);
-}
-
-
-/*!
-    Constructs a media recorder which records the media produced by \a mediaObject.
-
-    The \a parent is passed to QMediaObject.
-    \since 1.0
-*/
-
-QMediaRecorder::QMediaRecorder(QMediaObject *mediaObject, QObject *parent):
-    QObject(parent),
-    d_ptr(new QMediaRecorderPrivate)
-{
-    Q_D(QMediaRecorder);
-    d->q_ptr = this;
-    setMediaObject(mediaObject);
-
-    d->notifyTimer = new QTimer(this);
-    d->notifyTimer->setInterval(mediaObject->notifyInterval());
-    connect(d->notifyTimer, SIGNAL(timeout()), SLOT(_q_notify()));
-    connect(mediaObject, SIGNAL(notifyIntervalChanged(int)), SLOT(_q_updateNotifyInterval(int)));
-}
-
-/*!
-    Destroys a media recorder object.
-*/
-
-QMediaRecorder::~QMediaRecorder()
-{
-}
-
-/*!
-    Returns the QMediaObject instance that this QMediaRecorder is bound too,
-    or 0 otherwise.
-    \since 1.0
-*/
-QMediaObject *QMediaRecorder::mediaObject() const
-{
-    return d_func()->mediaObject;
-}
-
-/*!
-    \internal
-    \since 1.0
-*/
-bool QMediaRecorder::setMediaObject(QMediaObject *object)
-{
-    Q_D(QMediaRecorder);
-
-    if (object == d->mediaObject)
-        return true;
-
-    if (d->mediaObject) {
-        if (d->control) {
-            disconnect(d->control, SIGNAL(stateChanged(QMediaRecorder::State)),
-                       this, SLOT(_q_stateChanged(QMediaRecorder::State)));
-
-            disconnect(d->control, SIGNAL(mutedChanged(bool)),
-                       this, SIGNAL(mutedChanged(bool)));
-
-            disconnect(d->control, SIGNAL(durationChanged(qint64)),
-                       this, SIGNAL(durationChanged(qint64)));
-
-            disconnect(d->control, SIGNAL(error(int,QString)),
-                       this, SLOT(_q_error(int,QString)));
-        }
-
-        QMediaService *service = d->mediaObject->service();
-
-        if (service) {
-            disconnect(service, SIGNAL(destroyed()), this, SLOT(_q_serviceDestroyed()));
-
-            if (d->control)
-                service->releaseControl(d->control);
-            if (d->formatControl)
-                service->releaseControl(d->formatControl);
-            if (d->audioControl)
-                service->releaseControl(d->audioControl);
-            if (d->videoControl)
-                service->releaseControl(d->videoControl);
-            if (d->metaDataControl) {
-                disconnect(d->metaDataControl, SIGNAL(metaDataChanged()),
-                        this, SIGNAL(metaDataChanged()));
-                disconnect(d->metaDataControl, SIGNAL(metaDataAvailableChanged(bool)),
-                        this, SIGNAL(metaDataAvailableChanged(bool)));
-                disconnect(d->metaDataControl, SIGNAL(writableChanged(bool)),
-                        this, SIGNAL(metaDataWritableChanged(bool)));
-
-                service->releaseControl(d->metaDataControl);
-            }
-        }
-    }
-
-    d->control = 0;
-    d->formatControl = 0;
-    d->audioControl = 0;
-    d->videoControl = 0;
-    d->metaDataControl = 0;
-
-    d->mediaObject = object;
-
-    if (d->mediaObject) {
-        QMediaService *service = d->mediaObject->service();
-
-        if (service) {
-            d->control = qobject_cast<QMediaRecorderControl*>(service->requestControl(QMediaRecorderControl_iid));
-
-            if (d->control) {
-                d->formatControl = qobject_cast<QMediaContainerControl *>(service->requestControl(QMediaContainerControl_iid));
-                d->audioControl = qobject_cast<QAudioEncoderControl *>(service->requestControl(QAudioEncoderControl_iid));
-                d->videoControl = qobject_cast<QVideoEncoderControl *>(service->requestControl(QVideoEncoderControl_iid));
-
-                QMediaControl *control = service->requestControl(QMetaDataWriterControl_iid);
-                if (control) {
-                    d->metaDataControl = qobject_cast<QMetaDataWriterControl *>(control);
-                    if (!d->metaDataControl) {
-                        service->releaseControl(control);
-                    } else {
-                        connect(d->metaDataControl,
-                                SIGNAL(metaDataChanged()),
-                                SIGNAL(metaDataChanged()));
-                        connect(d->metaDataControl,
-                                SIGNAL(metaDataAvailableChanged(bool)),
-                                SIGNAL(metaDataAvailableChanged(bool)));
-                        connect(d->metaDataControl,
-                                SIGNAL(writableChanged(bool)),
-                                SIGNAL(metaDataWritableChanged(bool)));
-                    }
-                }
-
-                connect(d->control, SIGNAL(stateChanged(QMediaRecorder::State)),
-                        this, SLOT(_q_stateChanged(QMediaRecorder::State)));
-
-                connect(d->control, SIGNAL(mutedChanged(bool)),
-                        this, SIGNAL(mutedChanged(bool)));
-
-                connect(d->control, SIGNAL(durationChanged(qint64)),
-                        this, SIGNAL(durationChanged(qint64)));
-
-                connect(d->control, SIGNAL(error(int,QString)),
-                        this, SLOT(_q_error(int,QString)));
-
-                connect(service, SIGNAL(destroyed()), this, SLOT(_q_serviceDestroyed()));
-
-
-                return true;
-            }
-        }
-
-        d->mediaObject = 0;
-        return false;
-    }
-
-    return true;
-}
-
-/*!
-    \property QMediaRecorder::outputLocation
-    \brief the destination location of media content.
-
-    Setting the location can fail, for example when the service supports only
-    local file system locations but a network URL was passed. If the service
-    does not support media recording this setting the output location will
-    always fail.
-
-    The \a location can be relative or empty;
-    in this case the recorder uses the system specific place and file naming scheme.
-    After recording has stated, QMediaRecorder::outputLocation() returns the actual output location.
-    \since 1.0
-*/
-
-/*!
-    Returns true if media recorder service ready to use.
-    \since 1.0
-*/
-bool QMediaRecorder::isAvailable() const
-{
-    if (d_func()->control != NULL)
-        return true;
-    else
-        return false;
-}
-
-/*!
-    Returns the availability error code.
-    \since 1.0
-*/
-QtMultimedia::AvailabilityError QMediaRecorder::availabilityError() const
-{
-    if (d_func()->control != NULL)
-        return QtMultimedia::NoError;
-    else
-        return QtMultimedia::ServiceMissingError;
-}
-
-QUrl QMediaRecorder::outputLocation() const
-{
-    return d_func()->control ? d_func()->control->outputLocation() : QUrl();
-}
-
-bool QMediaRecorder::setOutputLocation(const QUrl &location)
-{
-    Q_D(QMediaRecorder);
-    return d->control ? d->control->setOutputLocation(location) : false;
-}
-
-/*!
-    Returns the current media recorder state.
-
-    \since 1.0
-    \sa QMediaRecorder::State
-*/
-
-QMediaRecorder::State QMediaRecorder::state() const
-{
-    return d_func()->control ? QMediaRecorder::State(d_func()->control->state()) : StoppedState;
-}
-
-/*!
-    Returns the current error state.
-
-    \since 1.0
-    \sa errorString()
-*/
-
-QMediaRecorder::Error QMediaRecorder::error() const
-{
-    return d_func()->error;
-}
-
-/*!
-    Returns a string describing the current error state.
-
-    \since 1.0
-    \sa error()
-*/
-
-QString QMediaRecorder::errorString() const
-{
-    return d_func()->errorString;
-}
-
-/*!
-    \property QMediaRecorder::duration
-
-    \brief the recorded media duration in milliseconds.
-    \since 1.0
-*/
-
-qint64 QMediaRecorder::duration() const
-{
-    return d_func()->control ? d_func()->control->duration() : 0;
-}
-
-/*!
-    \property QMediaRecorder::muted
-
-    \brief whether a recording audio stream is muted.
-    \since 1.0
-*/
-
-bool QMediaRecorder::isMuted() const
-{
-    return d_func()->control ? d_func()->control->isMuted() : 0;
-}
-
-void QMediaRecorder::setMuted(bool muted)
-{
-    Q_D(QMediaRecorder);
-
-    if (d->control)
-        d->control->setMuted(muted);
-}
-
-/*!
-    Returns a list of MIME types of supported container formats.
-    \since 1.0
-*/
-QStringList QMediaRecorder::supportedContainers() const
-{
-    return d_func()->formatControl ?
-           d_func()->formatControl->supportedContainers() : QStringList();
-}
-
-/*!
-    Returns a description of a container format \a mimeType.
-    \since 1.0
-*/
-QString QMediaRecorder::containerDescription(const QString &mimeType) const
-{
-    return d_func()->formatControl ?
-           d_func()->formatControl->containerDescription(mimeType) : QString();
-}
-
-/*!
-    Returns the MIME type of the selected container format.
-    \since 1.0
-*/
-
-QString QMediaRecorder::containerMimeType() const
-{
-    return d_func()->formatControl ?
-           d_func()->formatControl->containerMimeType() : QString();
-}
-
-/*!
-    Returns a list of supported audio codecs.
-    \since 1.0
-*/
-QStringList QMediaRecorder::supportedAudioCodecs() const
-{
-    return d_func()->audioControl ?
-           d_func()->audioControl->supportedAudioCodecs() : QStringList();
-}
-
-/*!
-    Returns a description of an audio \a codec.
-    \since 1.0
-*/
-QString QMediaRecorder::audioCodecDescription(const QString &codec) const
-{
-    return d_func()->audioControl ?
-           d_func()->audioControl->codecDescription(codec) : QString();
-}
-
-/*!
-    Returns a list of supported audio sample rates.
-
-    If non null audio \a settings parameter is passed, the returned list is
-    reduced to sample rates supported with partial settings applied.
-
-    This can be used to query the list of sample rates, supported by specific
-    audio codec.
-
-    If the encoder supports arbitrary sample rates within the supported rates
-    range, *\a continuous is set to true, otherwise *\a continuous is set to
-    false.
-    \since 1.0
-*/
-
-QList<int> QMediaRecorder::supportedAudioSampleRates(const QAudioEncoderSettings &settings, bool *continuous) const
-{
-    if (continuous)
-        *continuous = false;
-
-    return d_func()->audioControl ?
-           d_func()->audioControl->supportedSampleRates(settings, continuous) : QList<int>();
-}
-
-/*!
-    Returns a list of resolutions video can be encoded at.
-
-    If non null video \a settings parameter is passed, the returned list is
-    reduced to resolution supported with partial settings like video codec or
-    framerate applied.
-
-    If the encoder supports arbitrary resolutions within the supported range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-
-    \since 1.0
-    \sa QVideoEncoderSettings::resolution()
-*/
-QList<QSize> QMediaRecorder::supportedResolutions(const QVideoEncoderSettings &settings, bool *continuous) const
-{
-    if (continuous)
-        *continuous = false;
-
-    return d_func()->videoControl ?
-           d_func()->videoControl->supportedResolutions(settings, continuous) : QList<QSize>();
-}
-
-/*!
-    Returns a list of frame rates video can be encoded at.
-
-    If non null video \a settings parameter is passed, the returned list is
-    reduced to frame rates supported with partial settings like video codec or
-    resolution applied.
-
-    If the encoder supports arbitrary frame rates within the supported range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-
-    \since 1.0
-    \sa QVideoEncoderSettings::frameRate()
-*/
-QList<qreal> QMediaRecorder::supportedFrameRates(const QVideoEncoderSettings &settings, bool *continuous) const
-{
-    if (continuous)
-        *continuous = false;
-
-    return d_func()->videoControl ?
-           d_func()->videoControl->supportedFrameRates(settings, continuous) : QList<qreal>();
-}
-
-/*!
-    Returns a list of supported video codecs.
-    \since 1.0
-*/
-QStringList QMediaRecorder::supportedVideoCodecs() const
-{
-    return d_func()->videoControl ?
-           d_func()->videoControl->supportedVideoCodecs() : QStringList();
-}
-
-/*!
-    Returns a description of a video \a codec.
-
-    \since 1.0
-    \sa setEncodingSettings()
-*/
-QString QMediaRecorder::videoCodecDescription(const QString &codec) const
-{
-    return d_func()->videoControl ?
-           d_func()->videoControl->videoCodecDescription(codec) : QString();
-}
-
-/*!
-    Returns the audio encoder settings being used.
-
-    \since 1.0
-    \sa setEncodingSettings()
-*/
-
-QAudioEncoderSettings QMediaRecorder::audioSettings() const
-{
-    return d_func()->audioControl ?
-           d_func()->audioControl->audioSettings() : QAudioEncoderSettings();
-}
-
-/*!
-    Returns the video encoder settings being used.
-
-    \since 1.0
-    \sa setEncodingSettings()
-*/
-
-QVideoEncoderSettings QMediaRecorder::videoSettings() const
-{
-    return d_func()->videoControl ?
-           d_func()->videoControl->videoSettings() : QVideoEncoderSettings();
-}
-
-/*!
-    Sets the \a audio and \a video encoder settings and \a container format MIME type.
-
-    If some parameters are not specified, or null settings are passed, the
-    encoder will choose default encoding parameters, depending on media
-    source properties.
-    While setEncodingSettings is optional, the backend can preload
-    encoding pipeline to improve recording startup time.
-
-    It's only possible to change settings when the encoder is in the
-    QMediaEncoder::StoppedState state.
-
-    \since 1.0
-    \sa audioSettings(), videoSettings(), containerMimeType()
-*/
-
-void QMediaRecorder::setEncodingSettings(const QAudioEncoderSettings &audio,
-                                         const QVideoEncoderSettings &video,
-                                         const QString &container)
-{
-    Q_D(QMediaRecorder);
-
-    QCamera *camera = qobject_cast<QCamera*>(d->mediaObject);
-    if (camera && camera->captureMode() == QCamera::CaptureVideo) {
-        QMetaObject::invokeMethod(camera,
-                                  "_q_preparePropertyChange",
-                                  Qt::DirectConnection,
-                                  Q_ARG(int, QCameraControl::VideoEncodingSettings));
-    }
-
-    if (d->audioControl)
-        d->audioControl->setAudioSettings(audio);
-
-    if (d->videoControl)
-        d->videoControl->setVideoSettings(video);
-
-    if (d->formatControl)
-        d->formatControl->setContainerMimeType(container);
-
-    if (d->control)
-        d->control->applySettings();
-}
-
-
-/*!
-    Start recording.
-
-    This is an asynchronous call, with signal
-    stateCahnged(QMediaRecorder::RecordingState) being emitted when recording
-    started, otherwise the error() signal is emitted.
-    \since 1.0
-*/
-
-void QMediaRecorder::record()
-{
-    Q_D(QMediaRecorder);
-
-    // reset error
-    d->error = NoError;
-    d->errorString = QString();
-
-    if (d->control)
-        d->control->record();
-}
-
-/*!
-    Pause recording.
-    \since 1.0
-*/
-
-void QMediaRecorder::pause()
-{
-    Q_D(QMediaRecorder);
-    if (d->control)
-        d->control->pause();
-}
-
-/*!
-    Stop recording.
-    \since 1.0
-*/
-
-void QMediaRecorder::stop()
-{
-    Q_D(QMediaRecorder);
-    if (d->control)
-        d->control->stop();
-}
-
-/*!
-    \enum QMediaRecorder::State
-
-    \value StoppedState    The recorder is not active.
-    \value RecordingState  The recorder is currently active and producing data.
-    \value PausedState     The recorder is paused.
-*/
-
-/*!
-    \enum QMediaRecorder::Error
-
-    \value NoError         No Errors.
-    \value ResourceError   Device is not ready or not available.
-    \value FormatError     Current format is not supported.
-*/
-
-/*!
-    \fn QMediaRecorder::stateChanged(State state)
-
-    Signals that a media recorder's \a state has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaRecorder::durationChanged(qint64 duration)
-
-    Signals that the \a duration of the recorded media has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaRecorder::error(QMediaRecorder::Error error)
-
-    Signals that an \a error has occurred.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaRecorder::mutedChanged(bool muted)
-
-    Signals that the \a muted state has changed. If true the recording is being muted.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaRecorder::metaDataAvailable
-    \brief whether access to a media object's meta-data is available.
-
-    If this is true there is meta-data available, otherwise there is no meta-data available.
-    \since 1.0
-*/
-
-bool QMediaRecorder::isMetaDataAvailable() const
-{
-    Q_D(const QMediaRecorder);
-
-    return d->metaDataControl
-            ? d->metaDataControl->isMetaDataAvailable()
-            : false;
-}
-
-/*!
-    \fn QMediaRecorder::metaDataAvailableChanged(bool available)
-
-    Signals that the \a available state of a media object's meta-data has changed.
-    \since 1.0
-*/
-
-/*!
-    \property QMediaRecorder::metaDataWritable
-    \brief whether a media object's meta-data is writable.
-
-    If this is true the meta-data is writable, otherwise the meta-data is read-only.
-    \since 1.0
-*/
-
-bool QMediaRecorder::isMetaDataWritable() const
-{
-    Q_D(const QMediaRecorder);
-
-    return d->metaDataControl
-            ? d->metaDataControl->isWritable()
-            : false;
-}
-
-/*!
-    \fn QMediaRecorder::metaDataWritableChanged(bool writable)
-
-    Signals that the \a writable state of a media object's meta-data has changed.
-    \since 1.0
-*/
-
-/*!
-    Returns the value associated with a meta-data \a key.
-    \since 1.0
-*/
-QVariant QMediaRecorder::metaData(QtMultimedia::MetaData key) const
-{
-    Q_D(const QMediaRecorder);
-
-    return d->metaDataControl
-            ? d->metaDataControl->metaData(key)
-            : QVariant();
-}
-
-/*!
-    Sets a \a value for a meta-data \a key.
-
-    \note To ensure that meta data is set corretly, it should be set before starting the recording.
-    Once the recording is stopped, any meta data set will be attached to the next recording.
-    \since 1.0
-*/
-void QMediaRecorder::setMetaData(QtMultimedia::MetaData key, const QVariant &value)
-{
-    Q_D(QMediaRecorder);
-
-    if (d->metaDataControl)
-        d->metaDataControl->setMetaData(key, value);
-}
-
-/*!
-    Returns a list of keys there is meta-data available for.
-    \since 1.0
-*/
-QList<QtMultimedia::MetaData> QMediaRecorder::availableMetaData() const
-{
-    Q_D(const QMediaRecorder);
-
-    return d->metaDataControl
-            ? d->metaDataControl->availableMetaData()
-            : QList<QtMultimedia::MetaData>();
-}
-
-/*!
-    \fn QMediaRecorder::metaDataChanged()
-
-    Signals that a media object's meta-data has changed.
-    \since 1.0
-*/
-
-/*!
-    Returns the value associated with a meta-data \a key.
-
-    The naming and type of extended meta-data is not standardized, so the values and meaning
-    of keys may vary between backends.
-    \since 1.0
-*/
-QVariant QMediaRecorder::extendedMetaData(const QString &key) const
-{
-    Q_D(const QMediaRecorder);
-
-    return d->metaDataControl
-            ? d->metaDataControl->extendedMetaData(key)
-            : QVariant();
-}
-
-/*!
-    Sets a \a value for a meta-data \a key.
-
-    The naming and type of extended meta-data is not standardized, so the values and meaning
-    of keys may vary between backends.
-    \since 1.0
-*/
-void QMediaRecorder::setExtendedMetaData(const QString &key, const QVariant &value)
-{
-    Q_D(QMediaRecorder);
-
-    if (d->metaDataControl)
-        d->metaDataControl->setExtendedMetaData(key, value);
-}
-
-/*!
-    Returns a list of keys there is extended meta-data available for.
-    \since 1.0
-*/
-QStringList QMediaRecorder::availableExtendedMetaData() const
-{
-    Q_D(const QMediaRecorder);
-
-    return d->metaDataControl
-            ? d->metaDataControl->availableExtendedMetaData()
-            : QStringList();
-}
-
-#include "moc_qmediarecorder.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediarecorder.h b/src/multimedia/qmediarecorder.h
deleted file mode 100644
index fbd47dd..0000000
--- a/src/multimedia/qmediarecorder.h
+++ /dev/null
@@ -1,197 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIARECORDER_H
-#define QMEDIARECORDER_H
-
-#include <qmediaobject.h>
-#include <qmediaserviceprovider.h>
-#include <qmediaencodersettings.h>
-#include <qmediabindableinterface.h>
-#include <qmediaenumdebug.h>
-
-#include <QtCore/qpair.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QUrl;
-class QSize;
-class QAudioFormat;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class QMediaRecorderService;
-class QAudioEncoderSettings;
-class QVideoEncoderSettings;
-
-class QMediaRecorderPrivate;
-class Q_MULTIMEDIA_EXPORT QMediaRecorder : public QObject, public QMediaBindableInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(QMediaBindableInterface)
-    Q_ENUMS(State)
-    Q_ENUMS(Error)
-    Q_PROPERTY(qint64 duration READ duration NOTIFY durationChanged)
-    Q_PROPERTY(QUrl outputLocation READ outputLocation WRITE setOutputLocation)
-    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
-    Q_PROPERTY(bool metaDataAvailable READ isMetaDataAvailable NOTIFY metaDataAvailableChanged)
-    Q_PROPERTY(bool metaDataWritable READ isMetaDataWritable NOTIFY metaDataWritableChanged)
-public:
-
-    enum State
-    {
-        StoppedState,
-        RecordingState,
-        PausedState
-    };
-
-    enum Error
-    {
-        NoError,
-        ResourceError,
-        FormatError
-    };
-
-    QMediaRecorder(QMediaObject *mediaObject, QObject *parent = 0);
-    ~QMediaRecorder();
-
-    QMediaObject *mediaObject() const;
-
-    bool isAvailable() const;
-    QtMultimedia::AvailabilityError availabilityError() const;
-
-    QUrl outputLocation() const;
-    bool setOutputLocation(const QUrl &location);
-
-    State state() const;
-
-    Error error() const;
-    QString errorString() const;
-
-    qint64 duration() const;
-
-    bool isMuted() const;
-
-    QStringList supportedContainers() const;
-    QString containerDescription(const QString &containerMimeType) const;
-
-    QStringList supportedAudioCodecs() const;
-    QString audioCodecDescription(const QString &codecName) const;
-
-    QList<int> supportedAudioSampleRates(const QAudioEncoderSettings &settings = QAudioEncoderSettings(),
-                                         bool *continuous = 0) const;
-
-    QStringList supportedVideoCodecs() const;
-    QString videoCodecDescription(const QString &codecName) const;
-
-    QList<QSize> supportedResolutions(const QVideoEncoderSettings &settings = QVideoEncoderSettings(),
-                                      bool *continuous = 0) const;
-
-    QList<qreal> supportedFrameRates(const QVideoEncoderSettings &settings = QVideoEncoderSettings(),
-                                     bool *continuous = 0) const;
-
-    QAudioEncoderSettings audioSettings() const;
-    QVideoEncoderSettings videoSettings() const;
-    QString containerMimeType() const;
-
-    void setEncodingSettings(const QAudioEncoderSettings &audioSettings,
-                             const QVideoEncoderSettings &videoSettings = QVideoEncoderSettings(),
-                             const QString &containerMimeType = QString());
-
-
-    bool isMetaDataAvailable() const;
-    bool isMetaDataWritable() const;
-
-    QVariant metaData(QtMultimedia::MetaData key) const;
-    void setMetaData(QtMultimedia::MetaData key, const QVariant &value);
-    QList<QtMultimedia::MetaData> availableMetaData() const;
-
-    QVariant extendedMetaData(const QString &key) const;
-    void setExtendedMetaData(const QString &key, const QVariant &value);
-    QStringList availableExtendedMetaData() const;
-
-public Q_SLOTS:
-    void record();
-    void pause();
-    void stop();
-    void setMuted(bool muted);
-
-Q_SIGNALS:
-    void stateChanged(QMediaRecorder::State state);
-    void durationChanged(qint64 duration);
-    void mutedChanged(bool muted);
-
-    void error(QMediaRecorder::Error error);
-
-    void metaDataAvailableChanged(bool available);
-    void metaDataWritableChanged(bool writable);
-    void metaDataChanged();
-
-protected:
-    bool setMediaObject(QMediaObject *object);
-
-private:
-    QMediaRecorderPrivate *d_ptr;
-    Q_DISABLE_COPY(QMediaRecorder)
-    Q_DECLARE_PRIVATE(QMediaRecorder)
-    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QMediaRecorder::State))
-    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
-    Q_PRIVATE_SLOT(d_func(), void _q_serviceDestroyed())
-    Q_PRIVATE_SLOT(d_func(), void _q_notify())
-    Q_PRIVATE_SLOT(d_func(), void _q_updateNotifyInterval(int))
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QMediaRecorder::State)
-Q_DECLARE_METATYPE(QMediaRecorder::Error)
-
-Q_MEDIA_ENUM_DEBUG(QMediaRecorder, State)
-Q_MEDIA_ENUM_DEBUG(QMediaRecorder, Error)
-
-QT_END_HEADER
-
-#endif  // QMEDIARECORDER_H
diff --git a/src/multimedia/qmediarecordercontrol.cpp b/src/multimedia/qmediarecordercontrol.cpp
deleted file mode 100644
index ffc5102..0000000
--- a/src/multimedia/qmediarecordercontrol.cpp
+++ /dev/null
@@ -1,209 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediarecordercontrol.h"
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QMediaRecorderControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-
-    \brief The QMediaRecorderControl class provides access to the recording
-    functionality of a QMediaService.
-
-    If a QMediaService can record media it will implement QMediaRecorderControl.
-    This control provides a means to set the \l {outputLocation()}{output location},
-    and \l {record()}{start}, \l {pause()}{pause} and \l {stop()}{stop}
-    recording.  It also provides feedback on the \l {duration()}{duration}
-    of the recording.
-
-    The functionality provided by this control is exposed to application
-    code through the QMediaRecorder class.
-
-    The interface name of QMediaRecorderControl is \c com.nokia.Qt.QMediaRecorderControl/1.0 as
-    defined in QMediaRecorderControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaRecorder
-
-*/
-
-/*!
-    \macro QMediaRecorderControl_iid
-
-    \c com.nokia.Qt.QMediaRecorderControl/1.0
-
-    Defines the interface name of the QMediaRecorderControl class.
-
-    \relates QMediaRecorderControl
-*/
-
-/*!
-    Constructs a media recorder control with the given \a parent.
-*/
-
-QMediaRecorderControl::QMediaRecorderControl(QObject* parent)
-    : QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys a media recorder control.
-*/
-
-QMediaRecorderControl::~QMediaRecorderControl()
-{
-}
-
-/*!
-    \fn QUrl QMediaRecorderControl::outputLocation() const
-
-    Returns the current output location being used.
-    \since 1.0
-*/
-
-/*!
-    \fn bool QMediaRecorderControl::setOutputLocation(const QUrl &location)
-
-    Sets the output \a location and returns if this operation is successful.
-    If file at the output location already exists, it should be overwritten.
-
-    The \a location can be relative or empty;
-    in this case the service should use the system specific place and file naming scheme.
-    After recording has stated, QMediaRecorderControl::outputLocation() should return the actual output location.
-    \since 1.0
-*/
-
-/*!
-    \fn int QMediaRecorderControl::state() const
-
-    Return the current recording state.
-    \since 1.0
-*/
-
-/*!
-    \fn qint64 QMediaRecorderControl::duration() const
-
-    Return the current duration in milliseconds.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaRecorderControl::record()
-
-    Start recording.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaRecorderControl::pause()
-
-    Pause recording.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaRecorderControl::stop()
-
-    Stop recording.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaRecorderControl::applySettings()
-
-    Commits the encoder settings and performs pre-initialization to reduce delays when recording
-    is started.
-    \since 1.0
-*/
-
-/*!
-    \fn bool QMediaRecorderControl::isMuted() const
-
-    Returns true if the recorder is muted, and false if it is not.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaRecorderControl::setMuted(bool muted)
-
-    Sets the \a muted state of a media recorder.
-    \since 1.0
-*/
-
-
-/*!
-    \fn void QMediaRecorderControl::stateChanged(QMediaRecorder::State state)
-
-    Signals that the \a state of a media recorder has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaRecorderControl::durationChanged(qint64 duration)
-
-    Signals that the \a duration of the recorded media has changed.
-
-    This only emitted when there is a discontinuous change in the duration such as being reset to 0.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaRecorderControl::mutedChanged(bool muted)
-
-    Signals that the \a muted state of a media recorder has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMediaRecorderControl::error(int error, const QString &errorString)
-
-    Signals that an \a error has occurred.  The \a errorString describes the error.
-    \since 1.0
-*/
-
-#include "moc_qmediarecordercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediarecordercontrol.h b/src/multimedia/qmediarecordercontrol.h
deleted file mode 100644
index 26f244c..0000000
--- a/src/multimedia/qmediarecordercontrol.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIARECORDERCONTROL_H
-#define QMEDIARECORDERCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qmediarecorder.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QUrl;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class Q_MULTIMEDIA_EXPORT QMediaRecorderControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QMediaRecorderControl();
-
-    virtual QUrl outputLocation() const = 0;
-    virtual bool setOutputLocation(const QUrl &location) = 0;
-
-    virtual QMediaRecorder::State state() const = 0;
-
-    virtual qint64 duration() const = 0;
-
-    virtual bool isMuted() const = 0;
-
-    virtual void applySettings() = 0;
-
-Q_SIGNALS:
-    void stateChanged(QMediaRecorder::State state);
-    void durationChanged(qint64 position);
-    void mutedChanged(bool muted);
-    void error(int error, const QString &errorString);
-
-public Q_SLOTS:
-    virtual void record() = 0;
-    virtual void pause() = 0;
-    virtual void stop() = 0;
-    virtual void setMuted(bool muted) = 0;
-
-protected:
-    QMediaRecorderControl(QObject* parent = 0);
-};
-
-#define QMediaRecorderControl_iid "com.nokia.Qt.QMediaRecorderControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaRecorderControl, QMediaRecorderControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
diff --git a/src/multimedia/qmediaresource.cpp b/src/multimedia/qmediaresource.cpp
deleted file mode 100644
index 9bd4887..0000000
--- a/src/multimedia/qmediaresource.cpp
+++ /dev/null
@@ -1,453 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediaresource.h"
-
-#include <QtCore/qsize.h>
-#include <QtCore/qurl.h>
-#include <QtCore/qvariant.h>
-
-QT_BEGIN_NAMESPACE
-
-namespace
-{
-    class QMediaResourcePrivateRegisterMetaTypes
-    {
-    public:
-        QMediaResourcePrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QMediaResource>();
-            qRegisterMetaType<QMediaResourceList>();
-        }
-    } _registerMetaTypes;
-}
-
-/*!
-    \class QMediaResource
-
-    \brief The QMediaResource class provides a description of a media resource.
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-    A media resource is composed of a \l {url()}{URL} containing the
-    location of the resource and a set of properties that describe the
-    format of the resource.  The properties provide a means to assess a
-    resource without first attempting to load it, and in situations where
-    media be represented by multiple alternative representations provide a
-    means to select the appropriate resource.
-
-    Media made available by a remote services can often be available in
-    multiple encodings or quality levels, this allows a client to select
-    an appropriate resource based on considerations such as codecs supported,
-    network bandwidth, and display constraints.  QMediaResource includes
-    information such as the \l {mimeType()}{MIME type}, \l {audioCodec()}{audio}
-    and \l {videoCodec()}{video} codecs, \l {audioBitRate()}{audio} and
-    \l {videoBitRate()}{video} bit rates, and \l {resolution()}{resolution}
-    so these constraints and others can be evaluated.
-
-    The only mandatory property of a QMediaResource is the url().
-
-    \sa QMediaContent
-*/
-
-/*!
-    \typedef QMediaResourceList
-
-    Synonym for \c QList<QMediaResource>
-*/
-
-/*!
-    Constructs a null media resource.
-*/
-QMediaResource::QMediaResource()
-{
-}
-
-/*!
-    Constructs a media resource with the given \a mimeType from a \a url.
-    \since 1.0
-*/
-QMediaResource::QMediaResource(const QUrl &url, const QString &mimeType)
-{
-    values.insert(Url, url);
-    values.insert(MimeType, mimeType);
-}
-
-/*!
-    Constructs a media resource with the given \a mimeType from a network \a request.
-    \since 1.0
-*/
-QMediaResource::QMediaResource(const QNetworkRequest &request, const QString &mimeType)
-{
-    values.insert(Request, QVariant::fromValue(request));
-    values.insert(Url, request.url());
-    values.insert(MimeType, mimeType);
-}
-
-/*!
-    Constructs a copy of a media resource \a other.
-    \since 1.0
-*/
-QMediaResource::QMediaResource(const QMediaResource &other)
-    : values(other.values)
-{
-}
-
-/*!
-    Assigns the value of \a other to a media resource.
-    \since 1.0
-*/
-QMediaResource &QMediaResource::operator =(const QMediaResource &other)
-{
-    values = other.values;
-
-    return *this;
-}
-
-/*!
-    Destroys a media resource.
-*/
-QMediaResource::~QMediaResource()
-{
-}
-
-
-/*!
-    Compares a media resource to \a other.
-
-    Returns true if the resources are identical, and false otherwise.
-    \since 1.0
-*/
-bool QMediaResource::operator ==(const QMediaResource &other) const
-{
-    // Compare requests directly as QNetworkRequests are "custom types".
-    foreach (int key, values.keys()) {
-        switch (key) {
-        case Request:
-            if (request() != other.request())
-                return false;
-        break;
-        default:
-            if (values.value(key) != other.values.value(key))
-                return false;
-        }
-    }
-    return true;
-}
-
-/*!
-    Compares a media resource to \a other.
-
-    Returns true if they are different, and false otherwise.
-    \since 1.0
-*/
-bool QMediaResource::operator !=(const QMediaResource &other) const
-{
-    return !(*this == other);
-}
-
-/*!
-    Identifies if a media resource is null.
-
-    Returns true if the resource is null, and false otherwise.
-    \since 1.0
-*/
-bool QMediaResource::isNull() const
-{
-    return values.isEmpty();
-}
-
-/*!
-    Returns the URL of a media resource.
-    \since 1.0
-*/
-QUrl QMediaResource::url() const
-{
-    return qvariant_cast<QUrl>(values.value(Url));
-}
-
-/*!
-    Returns the network request associated with this media resource.
-    \since 1.0
-*/
-QNetworkRequest QMediaResource::request() const
-{
-    if(values.contains(Request))
-        return qvariant_cast<QNetworkRequest>(values.value(Request));
-
-    return QNetworkRequest(url());
-}
-
-/*!
-    Returns the MIME type of a media resource.
-
-    This may be null if the MIME type is unknown.
-    \since 1.0
-*/
-QString QMediaResource::mimeType() const
-{
-    return qvariant_cast<QString>(values.value(MimeType));
-}
-
-/*!
-    Returns the language of a media resource as an ISO 639-2 code.
-
-    This may be null if the language is unknown.
-    \since 1.0
-*/
-QString QMediaResource::language() const
-{
-    return qvariant_cast<QString>(values.value(Language));
-}
-
-/*!
-    Sets the \a language of a media resource.
-    \since 1.0
-*/
-void QMediaResource::setLanguage(const QString &language)
-{
-    if (!language.isNull())
-        values.insert(Language, language);
-    else
-        values.remove(Language);
-}
-
-/*!
-    Returns the audio codec of a media resource.
-
-    This may be null if the media resource does not contain an audio stream, or the codec is
-    unknown.
-    \since 1.0
-*/
-QString QMediaResource::audioCodec() const
-{
-    return qvariant_cast<QString>(values.value(AudioCodec));
-}
-
-/*!
-    Sets the audio \a codec of a media resource.
-    \since 1.0
-*/
-void QMediaResource::setAudioCodec(const QString &codec)
-{
-    if (!codec.isNull())
-        values.insert(AudioCodec, codec);
-    else
-        values.remove(AudioCodec);
-}
-
-/*!
-    Returns the video codec of a media resource.
-
-    This may be null if the media resource does not contain a video stream, or the codec is
-    unknonwn.
-    \since 1.0
-*/
-QString QMediaResource::videoCodec() const
-{
-    return qvariant_cast<QString>(values.value(VideoCodec));
-}
-
-/*!
-    Sets the video \a codec of media resource.
-    \since 1.0
-*/
-void QMediaResource::setVideoCodec(const QString &codec)
-{
-    if (!codec.isNull())
-        values.insert(VideoCodec, codec);
-    else
-        values.remove(VideoCodec);
-}
-
-/*!
-    Returns the size in bytes of a media resource.
-
-    This may be zero if the size is unknown.
-    \since 1.0
-*/
-qint64 QMediaResource::dataSize() const
-{
-    return qvariant_cast<qint64>(values.value(DataSize));
-}
-
-/*!
-    Sets the \a size in bytes of a media resource.
-    \since 1.0
-*/
-void QMediaResource::setDataSize(const qint64 size)
-{
-    if (size != 0)
-        values.insert(DataSize, size);
-    else
-        values.remove(DataSize);
-}
-
-/*!
-    Returns the bit rate in bits per second of a media resource's audio stream.
-
-    This may be zero if the bit rate is unknown, or the resource contains no audio stream.
-    \since 1.0
-*/
-int QMediaResource::audioBitRate() const
-{
-    return values.value(AudioBitRate).toInt();
-}
-
-/*!
-    Sets the bit \a rate in bits per second of a media resource's video stream.
-    \since 1.0
-*/
-void QMediaResource::setAudioBitRate(int rate)
-{
-    if (rate != 0)
-        values.insert(AudioBitRate, rate);
-    else
-        values.remove(AudioBitRate);
-}
-
-/*!
-    Returns the audio sample rate of a media resource.
-
-    This may be zero if the sample size is unknown, or the resource contains no audio stream.
-    \since 1.0
-*/
-int QMediaResource::sampleRate() const
-{
-    return qvariant_cast<int>(values.value(SampleRate));
-}
-
-/*!
-    Sets the audio \a sampleRate of a media resource.
-    \since 1.0
-*/
-void QMediaResource::setSampleRate(int sampleRate)
-{
-    if (sampleRate != 0)
-        values.insert(SampleRate, sampleRate);
-    else
-        values.remove(SampleRate);
-}
-
-/*!
-    Returns the number of audio channels in a media resource.
-
-    This may be zero if the sample size is unknown, or the resource contains no audio stream.
-    \since 1.0
-*/
-int QMediaResource::channelCount() const
-{
-    return qvariant_cast<int>(values.value(ChannelCount));
-}
-
-/*!
-    Sets the number of audio \a channels in a media resource.
-    \since 1.0
-*/
-void QMediaResource::setChannelCount(int channels)
-{
-    if (channels != 0)
-        values.insert(ChannelCount, channels);
-    else
-        values.remove(ChannelCount);
-}
-
-/*!
-    Returns the bit rate in bits per second of a media resource's video stream.
-
-    This may be zero if the bit rate is unknown, or the resource contains no video stream.
-    \since 1.0
-*/
-int QMediaResource::videoBitRate() const
-{
-    return values.value(VideoBitRate).toInt();
-}
-
-/*!
-    Sets the bit \a rate in bits per second of a media resource's video stream.
-    \since 1.0
-*/
-void QMediaResource::setVideoBitRate(int rate)
-{
-    if (rate != 0)
-        values.insert(VideoBitRate, rate);
-    else
-        values.remove(VideoBitRate);
-}
-
-/*!
-    Returns the resolution in pixels of a media resource.
-
-    This may be null is the resolution is unknown, or the resource contains no pixel data (i.e. the
-    resource is an audio stream.
-    \since 1.0
-*/
-QSize QMediaResource::resolution() const
-{
-    return qvariant_cast<QSize>(values.value(Resolution));
-}
-
-/*!
-    Sets the \a resolution in pixels of a media resource.
-    \since 1.0
-*/
-void QMediaResource::setResolution(const QSize &resolution)
-{
-    if (resolution.width() != -1 || resolution.height() != -1)
-        values.insert(Resolution, resolution);
-    else
-        values.remove(Resolution);
-}
-
-/*!
-    Sets the \a width and \a height in pixels of a media resource.
-    \since 1.0
-*/
-void QMediaResource::setResolution(int width, int height)
-{
-    if (width != -1 || height != -1)
-        values.insert(Resolution, QSize(width, height));
-    else
-        values.remove(Resolution);
-}
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediaresource.h b/src/multimedia/qmediaresource.h
deleted file mode 100644
index b06c61d..0000000
--- a/src/multimedia/qmediaresource.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMEDIARESOURCE_H
-#define QMEDIARESOURCE_H
-
-#include <QtCore/qmap.h>
-#include <QtCore/qmetatype.h>
-#include <QtNetwork/qnetworkrequest.h>
-
-#include <qtmultimediadefs.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QMediaResource
-{
-public:
-    QMediaResource();
-    QMediaResource(const QUrl &url, const QString &mimeType = QString());
-    QMediaResource(const QNetworkRequest &request, const QString &mimeType = QString());
-    QMediaResource(const QMediaResource &other);
-    QMediaResource &operator =(const QMediaResource &other);
-    ~QMediaResource();
-
-    bool isNull() const;
-
-    bool operator ==(const QMediaResource &other) const;
-    bool operator !=(const QMediaResource &other) const;
-
-    QUrl url() const;
-    QNetworkRequest request() const;
-    QString mimeType() const;
-
-    QString language() const;
-    void setLanguage(const QString &language);
-
-    QString audioCodec() const;
-    void setAudioCodec(const QString &codec);
-
-    QString videoCodec() const;
-    void setVideoCodec(const QString &codec);
-
-    qint64 dataSize() const;
-    void setDataSize(const qint64 size);
-
-    int audioBitRate() const;
-    void setAudioBitRate(int rate);
-
-    int sampleRate() const;
-    void setSampleRate(int frequency);
-
-    int channelCount() const;
-    void setChannelCount(int channels);
-
-    int videoBitRate() const;
-    void setVideoBitRate(int rate);
-
-    QSize resolution() const;
-    void setResolution(const QSize &resolution);
-    void setResolution(int width, int height);
-
-
-private:
-    enum Property
-    {
-        Url,
-        Request,
-        MimeType,
-        Language,
-        AudioCodec,
-        VideoCodec,
-        DataSize,
-        AudioBitRate,
-        VideoBitRate,
-        SampleRate,
-        ChannelCount,
-        Resolution
-    };
-    QMap<int, QVariant> values;
-};
-
-typedef QList<QMediaResource> QMediaResourceList;
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QMediaResource)
-Q_DECLARE_METATYPE(QMediaResourceList)
-
-QT_END_HEADER
-
-#endif
diff --git a/src/multimedia/qmediastreamscontrol.cpp b/src/multimedia/qmediastreamscontrol.cpp
deleted file mode 100644
index fb624c6..0000000
--- a/src/multimedia/qmediastreamscontrol.cpp
+++ /dev/null
@@ -1,173 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediastreamscontrol.h"
-#include "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace
-{
-    class QMediaStreamsControlPrivateRegisterMetaTypes
-    {
-    public:
-        QMediaStreamsControlPrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QMediaStreamsControl::StreamType>();
-        }
-    } _registerMetaTypes;
-}
-
-/*!
-    \class QMediaStreamsControl
-    \preliminary
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \brief The QMediaStreamsControl class provides a media stream selection control.
-
-    \since 1.0
-
-    The QMediaStreamsControl class provides descriptions of the available media streams
-    and allows individual streams to be activated and deactivated.
-
-    The interface name of QMediaStreamsControl is \c com.nokia.Qt.MediaStreamsControl as
-    defined in QMediaStreamsControl_iid.
-
-    \sa QMediaService::requestControl()
-*/
-
-/*!
-    \macro QMediaStreamsControl_iid
-
-    \c com.nokia.Qt.MediaStreamsControl
-
-    Defines the interface name of the QMediaStreamsControl class.
-
-    \relates QMediaStreamsControl
-    \since 1.0
-*/
-
-/*!
-    Constructs a new media streams control with the given \a parent.
-*/
-QMediaStreamsControl::QMediaStreamsControl(QObject *parent)
-    :QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destroys a media streams control.
-*/
-QMediaStreamsControl::~QMediaStreamsControl()
-{
-}
-
-/*!
-  \enum QMediaStreamsControl::StreamType
-
-  Media stream type.
-
-  \value AudioStream Audio stream.
-  \value VideoStream Video stream.
-  \value SubPictureStream Subpicture or teletext stream.
-  \value UnknownStream The stream type is unknown.
-  \value DataStream
-*/
-
-/*!
-    \fn QMediaStreamsControl::streamCount()
-
-    Returns the number of media streams.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaStreamsControl::streamType(int stream)
-
-    Return the type of a media \a stream.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaStreamsControl::metaData(int stream, QtMultimedia::MetaData key)
-
-    Returns the meta-data value of \a key for a given \a stream.
-
-    Useful metadata keya are QtMultimedia::Title, QtMultimedia::Description and QtMultimedia::Language.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaStreamsControl::isActive(int stream)
-
-    Returns true if the media \a stream is active.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaStreamsControl::setActive(int stream, bool state)
-
-    Sets the active \a state of a media \a stream.
-
-    Setting the active state of a media stream to true will activate it.  If any other stream
-    of the same type was previously active it will be deactivated. Setting the active state fo a
-    media stream to false will deactivate it.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaStreamsControl::streamsChanged()
-
-    The signal is emitted when the available streams list is changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QMediaStreamsControl::activeStreamsChanged()
-
-    The signal is emitted when the active streams list is changed.
-    \since 1.0
-*/
-
-#include "moc_qmediastreamscontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmediastreamscontrol.h b/src/multimedia/qmediastreamscontrol.h
deleted file mode 100644
index bbd8a2a..0000000
--- a/src/multimedia/qmediastreamscontrol.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef QMEDIASTREAMSCONTROL_H
-#define QMEDIASTREAMSCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qtmedianamespace.h"
-#include "qtmultimediadefs.h"
-#include <qmediaenumdebug.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QMediaStreamsControl : public QMediaControl
-{
-    Q_OBJECT
-    Q_ENUMS(SteamType)
-public:
-    enum StreamType { UnknownStream, VideoStream, AudioStream, SubPictureStream, DataStream };
-
-    virtual ~QMediaStreamsControl();
-
-    virtual int streamCount() = 0;
-    virtual StreamType streamType(int streamNumber) = 0;
-
-    virtual QVariant metaData(int streamNumber, QtMultimedia::MetaData key) = 0;
-
-    virtual bool isActive(int streamNumber) = 0;
-    virtual void setActive(int streamNumber, bool state) = 0;
-
-Q_SIGNALS:
-    void streamsChanged();
-    void activeStreamsChanged();
-
-protected:
-    QMediaStreamsControl(QObject *parent = 0);
-};
-
-#define QMediaStreamsControl_iid "com.nokia.Qt.QMediaStreamsControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMediaStreamsControl, QMediaStreamsControl_iid)
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QMediaStreamsControl::StreamType)
-
-Q_MEDIA_ENUM_DEBUG(QMediaStreamsControl, StreamType)
-
-QT_END_HEADER
-
-#endif // QMEDIASTREAMSCONTROL_H
-
diff --git a/src/multimedia/qmetadatareadercontrol.cpp b/src/multimedia/qmetadatareadercontrol.cpp
deleted file mode 100644
index 63dd375..0000000
--- a/src/multimedia/qmetadatareadercontrol.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediacontrol_p.h"
-#include <qmetadatareadercontrol.h>
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QMetaDataReaderControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-
-    \brief The QMetaDataReaderControl class provides read access to the
-    meta-data of a QMediaService's media.
-
-    If a QMediaService can provide read or write access to the meta-data of
-    its current media it will implement QMetaDataReaderControl.  This control
-    provides functions for both retrieving and setting meta-data values.
-    Meta-data may be addressed by the well defined keys in the
-    QtMultimedia::MetaData enumeration using the metaData() functions, or by
-    string keys using the extendedMetaData() functions.
-
-    The functionality provided by this control is exposed to application
-    code by the meta-data members of QMediaObject, and so meta-data access
-    is potentially available in any of the media object classes.  Any media
-    service may implement QMetaDataReaderControl.
-
-    The interface name of QMetaDataReaderControl is
-    \c com.nokia.Qt.QMetaDataReaderControl/1.0 as defined in
-    QMetaDataReaderControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaObject
-*/
-
-/*!
-    \macro QMetaDataReaderControl_iid
-
-    \c com.nokia.Qt.QMetaDataReaderControl/1.0
-
-    Defines the interface name of the QMetaDataReaderControl class.
-
-    \relates QMetaDataReaderControl
-*/
-
-/*!
-    Construct a QMetaDataReaderControl with \a parent. This class is meant as a base class
-    for service specific meta data providers so this constructor is protected.
-*/
-
-QMetaDataReaderControl::QMetaDataReaderControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destroy the meta-data object.
-*/
-
-QMetaDataReaderControl::~QMetaDataReaderControl()
-{
-}
-
-/*!
-    \fn bool QMetaDataReaderControl::isMetaDataAvailable() const
-
-    Identifies if meta-data is available from a media service.
-
-    Returns true if the meta-data is available and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QVariant QMetaDataReaderControl::metaData(QtMultimedia::MetaData key) const
-
-    Returns the meta-data for the given \a key.
-    \since 1.0
-*/
-
-/*!
-    \fn QMetaDataReaderControl::availableMetaData() const
-
-    Returns a list of keys there is meta-data available for.
-    \since 1.0
-*/
-
-/*!
-    \fn QMetaDataReaderControl::extendedMetaData(const QString &key) const
-
-    Returns the metaData for an abitrary string \a key.
-
-    The valid selection of keys for extended meta-data is determined by the provider and the meaning
-    and type may differ between providers.
-    \since 1.0
-*/
-
-/*!
-    \fn QMetaDataReaderControl::availableExtendedMetaData() const
-
-    Returns a list of keys there is extended meta-data available for.
-    \since 1.0
-*/
-
-
-/*!
-    \fn void QMetaDataReaderControl::metaDataChanged()
-
-    Signal the changes of meta-data.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMetaDataReaderControl::metaDataAvailableChanged(bool available)
-
-    Signal the availability of meta-data has changed, \a available will
-    be true if the multimedia object has meta-data.
-    \since 1.0
-*/
-
-#include "moc_qmetadatareadercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmetadatareadercontrol.h b/src/multimedia/qmetadatareadercontrol.h
deleted file mode 100644
index 0d370b5..0000000
--- a/src/multimedia/qmetadatareadercontrol.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMETADATAREADERCONTROL_H
-#define QMETADATAREADERCONTROL_H
-
-#include <qmediacontrol.h>
-#include <qmediaobject.h>
-
-#include <qmediaresource.h>
-
-#include <qtmultimediadefs.h>
-#include "qtmedianamespace.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-
-class Q_MULTIMEDIA_EXPORT QMetaDataReaderControl : public QMediaControl
-{
-    Q_OBJECT
-public:
-    ~QMetaDataReaderControl();
-
-    virtual bool isMetaDataAvailable() const = 0;
-
-    virtual QVariant metaData(QtMultimedia::MetaData key) const = 0;
-    virtual QList<QtMultimedia::MetaData> availableMetaData() const = 0;
-
-    virtual QVariant extendedMetaData(const QString &key) const = 0;
-    virtual QStringList availableExtendedMetaData() const = 0;
-
-Q_SIGNALS:
-    void metaDataChanged();
-
-    void metaDataAvailableChanged(bool available);
-
-protected:
-    QMetaDataReaderControl(QObject *parent = 0);
-};
-
-#define QMetaDataReaderControl_iid "com.nokia.Qt.QMetaDataReaderControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMetaDataReaderControl, QMetaDataReaderControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QMETADATAPROVIDER_H
diff --git a/src/multimedia/qmetadatawritercontrol.cpp b/src/multimedia/qmetadatawritercontrol.cpp
deleted file mode 100644
index 9d01662..0000000
--- a/src/multimedia/qmetadatawritercontrol.cpp
+++ /dev/null
@@ -1,195 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediacontrol_p.h"
-#include <qmetadatawritercontrol.h>
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QMetaDataWriterControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-
-    \brief The QMetaDataWriterControl class provides write access to the
-    meta-data of a QMediaService's media.
-
-    If a QMediaService can provide write access to the meta-data of its
-    current media it will implement QMetaDataWriterControl.  This control
-    provides functions for both retrieving and setting meta-data values.
-    Meta-data may be addressed by the well defined keys in the
-    QtMultimedia::MetaData enumeration using the metaData() functions, or
-    by string keys using the extendedMetaData() functions.
-
-    The functionality provided by this control is exposed to application code
-    by the meta-data members of QMediaObject, and so meta-data access is
-    potentially available in any of the media object classes.  Any media
-    service may implement QMetaDataControl.
-
-    The interface name of QMetaDataWriterControl is \c com.nokia.Qt.QMetaDataWriterControl/1.0 as
-    defined in QMetaDataWriterControl_iid.
-
-    \sa QMediaService::requestControl(), QMediaObject
-*/
-
-/*!
-    \macro QMetaDataWriterControl_iid
-
-    \c com.nokia.Qt.QMetaDataWriterControl/1.0
-
-    Defines the interface name of the QMetaDataWriterControl class.
-
-    \relates QMetaDataWriterControl
-*/
-
-/*!
-    Construct a QMetaDataWriterControl with \a parent. This class is meant as a base class
-    for service specific meta data providers so this constructor is protected.
-*/
-
-QMetaDataWriterControl::QMetaDataWriterControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destroy the meta-data writer control.
-*/
-
-QMetaDataWriterControl::~QMetaDataWriterControl()
-{
-}
-
-/*!
-    \fn bool QMetaDataWriterControl::isMetaDataAvailable() const
-
-    Identifies if meta-data is available from a media service.
-
-    Returns true if the meta-data is available and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn bool QMetaDataWriterControl::isWritable() const
-
-    Identifies if a media service's meta-data can be edited.
-
-    Returns true if the meta-data is writable and false otherwise.
-    \since 1.0
-*/
-
-/*!
-    \fn QVariant QMetaDataWriterControl::metaData(QtMultimedia::MetaData key) const
-
-    Returns the meta-data for the given \a key.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMetaDataWriterControl::setMetaData(QtMultimedia::MetaData key, const QVariant &value)
-
-    Sets the \a value of the meta-data element with the given \a key.
-    \since 1.0
-*/
-
-/*!
-    \fn QMetaDataWriterControl::availableMetaData() const
-
-    Returns a list of keys there is meta-data available for.
-*/
-
-/*!
-    \fn QMetaDataWriterControl::extendedMetaData(const QString &key) const
-
-    Returns the meta-data for an abitrary string \a key.
-
-    The valid selection of keys for extended meta-data is determined by the provider and the meaning
-    and type may differ between providers.
-    \since 1.0
-*/
-
-/*!
-    \fn QMetaDataWriterControl::setExtendedMetaData(const QString &key, const QVariant &value)
-
-    Change the value of the meta-data element with an abitrary string \a key to \a value.
-
-    The valid selection of keys for extended meta-data is determined by the provider and the meaning
-    and type may differ between providers.
-    \since 1.0
-*/
-
-/*!
-    \fn QMetaDataWriterControl::availableExtendedMetaData() const
-
-    Returns a list of keys there is extended meta-data available for.
-    \since 1.0
-*/
-
-
-/*!
-    \fn void QMetaDataWriterControl::metaDataChanged()
-
-    Signal the changes of meta-data.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMetaDataWriterControl::metaDataAvailableChanged(bool available)
-
-    Signal the availability of meta-data has changed, \a available will
-    be true if the multimedia object has meta-data.
-    \since 1.0
-*/
-
-/*!
-    \fn void QMetaDataWriterControl::writableChanged(bool writable)
-
-    Signal a change in the writable status of meta-data, \a writable will be
-    true if meta-data elements can be added or adjusted.
-    \since 1.0
-*/
-
-#include "moc_qmetadatawritercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qmetadatawritercontrol.h b/src/multimedia/qmetadatawritercontrol.h
deleted file mode 100644
index 3f8b8c3..0000000
--- a/src/multimedia/qmetadatawritercontrol.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMETADATAWRITERCONTROL_H
-#define QMETADATAWRITERCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qmediaobject.h"
-
-#include "qmediaresource.h"
-
-#include <qtmultimediadefs.h>
-#include "qtmedianamespace.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-
-class Q_MULTIMEDIA_EXPORT QMetaDataWriterControl : public QMediaControl
-{
-    Q_OBJECT
-public:
-    ~QMetaDataWriterControl();
-
-    virtual bool isWritable() const = 0;
-    virtual bool isMetaDataAvailable() const = 0;
-
-    virtual QVariant metaData(QtMultimedia::MetaData key) const = 0;
-    virtual void setMetaData(QtMultimedia::MetaData key, const QVariant &value) = 0;
-    virtual QList<QtMultimedia::MetaData> availableMetaData() const = 0;
-
-    virtual QVariant extendedMetaData(const QString &key) const = 0;
-    virtual void setExtendedMetaData(const QString &key, const QVariant &value) = 0;
-    virtual QStringList availableExtendedMetaData() const = 0;
-
-
-Q_SIGNALS:
-    void metaDataChanged();
-
-    void writableChanged(bool writable);
-    void metaDataAvailableChanged(bool available);
-
-protected:
-    QMetaDataWriterControl(QObject *parent = 0);
-};
-
-#define QMetaDataWriterControl_iid "com.nokia.Qt.QMetaDataWriterControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QMetaDataWriterControl, QMetaDataWriterControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
diff --git a/src/multimedia/qradiodata.cpp b/src/multimedia/qradiodata.cpp
deleted file mode 100644
index bb9032f..0000000
--- a/src/multimedia/qradiodata.cpp
+++ /dev/null
@@ -1,355 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qradiodata.h"
-#include "qmediaservice.h"
-#include "qmediaobject_p.h"
-#include "qradiodatacontrol.h"
-
-#include <QPair>
-
-
-QT_BEGIN_NAMESPACE
-
-
-namespace
-{
-    class QRadioDataPrivateRegisterMetaTypes
-    {
-    public:
-        QRadioDataPrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QRadioData::Error>();
-            qRegisterMetaType<QRadioData::ProgramType>();
-        }
-    } _registerMetaTypes;
-}
-
-/*!
-    \class QRadioData
-    \brief The QRadioData class provides interfaces to the RDS functionality of the system radio.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 5.0
-
-    The radio data object will emit signals for any changes in radio data. You can enable or disable
-    alternative frequency with setAlternativeFrequenciesEnabled().
-
-*/
-
-
-class QRadioDataPrivate : public QMediaObjectPrivate
-{
-public:
-    QRadioDataPrivate():provider(0), control(0) {}
-    QMediaServiceProvider *provider;
-    QRadioDataControl* control;
-};
-
-/*!
-    Constructs a radio data based on a media service allocated by a media service \a provider.
-
-    The \a parent is passed to QMediaObject.
-    \since 5.0
-*/
-
-QRadioData::QRadioData(QObject *parent, QMediaServiceProvider* provider):
-    QMediaObject(*new QRadioDataPrivate, parent, provider->requestService(Q_MEDIASERVICE_RADIO))
-{
-    Q_D(QRadioData);
-
-    d->provider = provider;
-
-    if (d->service != 0) {
-        d->control = qobject_cast<QRadioDataControl*>(d->service->requestControl(QRadioDataControl_iid));
-        if (d->control != 0) {
-            connect(d->control, SIGNAL(stationIdChanged(QString)), SIGNAL(stationIdChanged(QString)));
-            connect(d->control, SIGNAL(programTypeChanged(QRadioData::ProgramType)),
-                                SIGNAL(programTypeChanged(QRadioData::ProgramType)));
-            connect(d->control, SIGNAL(programTypeNameChanged(QString)), SIGNAL(programTypeNameChanged(QString)));
-            connect(d->control, SIGNAL(stationNameChanged(QString)), SIGNAL(stationNameChanged(QString)));
-            connect(d->control, SIGNAL(radioTextChanged(QString)), SIGNAL(radioTextChanged(QString)));
-            connect(d->control, SIGNAL(alternativeFrequenciesEnabledChanged(bool)), SIGNAL(alternativeFrequenciesEnabledChanged(bool)));
-            connect(d->control, SIGNAL(error(QRadioData::Error)), SIGNAL(error(QRadioData::Error)));
-        }
-    }
-}
-
-/*!
-    Destroys a radio data.
-*/
-
-QRadioData::~QRadioData()
-{
-    Q_D(QRadioData);
-
-    if (d->service && d->control)
-        d->service->releaseControl(d->control);
-
-    d->provider->releaseService(d->service);
-}
-
-/*!
-    Returns true if the radio data service is ready to use.
-    \since 5.0
-*/
-bool QRadioData::isAvailable() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d_func()->control->isAvailable();
-    else
-        return false;
-}
-
-/*!
-    Returns the availability error state.
-    \since 5.0
-*/
-QtMultimedia::AvailabilityError QRadioData::availabilityError() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d_func()->control->availabilityError();
-    else
-        return QtMultimedia::ServiceMissingError;
-}
-
-/*!
-    \property QRadioData::stationId
-    \brief Current Program Identification
-
-    \since 5.0
-*/
-
-QString QRadioData::stationId() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->stationId();
-    return QString();
-}
-
-/*!
-    \property QRadioData::programType
-    \brief Current Program Type
-
-    \since 5.0
-*/
-
-QRadioData::ProgramType QRadioData::programType() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->programType();
-
-    return QRadioData::Undefined;
-}
-
-/*!
-    \property QRadioData::programTypeName
-    \brief Current Program Type Name
-
-    \since 5.0
-*/
-
-QString QRadioData::programTypeName() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->programTypeName();
-    return QString();
-}
-
-/*!
-    \property QRadioData::stationName
-    \brief Current Program Service
-
-    \since 5.0
-*/
-
-QString QRadioData::stationName() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->stationName();
-    return QString();
-}
-
-/*!
-    \property QRadioData::radioText
-    \brief Current Radio Text
-
-    \since 5.0
-*/
-
-QString QRadioData::radioText() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->radioText();
-    return QString();
-}
-
-/*!
-    \property QRadioData::alternativeFrequenciesEnabled
-    \brief Is Alternative Frequency currently enabled
-
-    \since 5.0
-*/
-
-bool QRadioData::isAlternativeFrequenciesEnabled() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->isAlternativeFrequenciesEnabled();
-    return false;
-}
-
-void QRadioData::setAlternativeFrequenciesEnabled( bool enabled )
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->setAlternativeFrequenciesEnabled(enabled);
-}
-
-/*!
-    Returns the error state of a radio data.
-
-    \since 5.0
-    \sa errorString()
-*/
-
-QRadioData::Error QRadioData::error() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->error();
-    return QRadioData::ResourceError;
-}
-
-/*!
-    Returns a description of a radio data's error state.
-
-    \since 5.0
-    \sa error()
-*/
-QString QRadioData::errorString() const
-{
-    Q_D(const QRadioData);
-
-    if (d->control != 0)
-        return d->control->errorString();
-    return QString();
-}
-
-/*!
-    \fn void QRadioData::stationIdChanged(QString stationId)
-
-    Signals that the Program Identification code has changed to \a stationId
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioData::programTypeChanged(QRadioData::ProgramType programType)
-
-    Signals that the Program Type code has changed to \a programType
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioData::programTypeNameChanged(QString programTypeName)
-
-    Signals that the Program Type Name has changed to \a programTypeName
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioData::stationNameChanged(int stationName)
-
-    Signals that the Program Service has changed to \a stationName
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioData::alternativeFrequenciesEnabledChanged(bool enabled)
-
-    Signals that the AF has been enabled or disabled
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioData::error(QRadioData::Error error)
-
-    Signals that an \a error occurred.
-    \since 5.0
-*/
-
-/*!
-    \enum QRadioData::Error
-
-    Enumerates radio data error conditions.
-
-    \value NoError         No errors have occurred.
-    \value ResourceError   There is no radio service available.
-    \value OpenError       Unable to open radio device.
-    \value OutOfRangeError An attempt to set a frequency or band that is not supported by radio device.
-*/
-
-/*! \fn void QRadioData::stateChanged(QRadioData::State state)
-  This signal is emitted when the state changes to \a state.
-  \since 5.0
- */
-
-#include "moc_qradiodata.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qradiodata.h b/src/multimedia/qradiodata.h
deleted file mode 100644
index 71ae222..0000000
--- a/src/multimedia/qradiodata.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QRADIODATA_H
-#define QRADIODATA_H
-
-#include <QtCore/qobject.h>
-
-#include "qmediaobject.h"
-#include "qmediaserviceprovider.h"
-#include <qmediaenumdebug.h>
-
-#include <QPair>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QRadioDataPrivate;
-class Q_MULTIMEDIA_EXPORT QRadioData : public QMediaObject
-{
-    Q_OBJECT
-    Q_PROPERTY(QString stationId READ stationId NOTIFY stationIdChanged)
-    Q_PROPERTY(ProgramType programType READ programType NOTIFY programTypeChanged)
-    Q_PROPERTY(QString programTypeName READ programTypeName NOTIFY programTypeNameChanged)
-    Q_PROPERTY(QString stationName READ stationName NOTIFY stationNameChanged)
-    Q_PROPERTY(QString radioText READ radioText NOTIFY radioTextChanged)
-    Q_PROPERTY(bool alternativeFrequenciesEnabled READ isAlternativeFrequenciesEnabled
-               WRITE setAlternativeFrequenciesEnabled NOTIFY alternativeFrequenciesEnabledChanged)
-    Q_ENUMS(Error)
-    Q_ENUMS(ProgramType)
-
-public:
-    enum Error { NoError, ResourceError, OpenError, OutOfRangeError };
-
-    enum ProgramType { Undefined = 0, News, CurrentAffairs, Information,
-        Sport, Education, Drama, Culture, Science, Varied,
-        PopMusic, RockMusic, EasyListening, LightClassical,
-        SeriousClassical, OtherMusic, Weather, Finance,
-        ChildrensProgrammes, SocialAffairs, Religion,
-        PhoneIn, Travel, Leisure, JazzMusic, CountryMusic,
-        NationalMusic, OldiesMusic, FolkMusic, Documentary,
-        AlarmTest, Alarm, Talk, ClassicRock, AdultHits,
-        SoftRock, Top40, Soft, Nostalgia, Classical,
-        RhythmAndBlues, SoftRhythmAndBlues, Language,
-        ReligiousMusic, ReligiousTalk, Personality, Public,
-        College
-    };
-
-    QRadioData(QObject *parent = 0, QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider());
-    ~QRadioData();
-
-    bool isAvailable() const;
-    QtMultimedia::AvailabilityError availabilityError() const;
-
-    QString stationId() const;
-    ProgramType programType() const;
-    QString programTypeName() const;
-    QString stationName() const;
-    QString radioText() const;
-    bool isAlternativeFrequenciesEnabled() const;
-
-    Error error() const;
-    QString errorString() const;
-
-public Q_SLOTS:
-    void setAlternativeFrequenciesEnabled(bool enabled);
-
-Q_SIGNALS:
-    void stationIdChanged(QString stationId);
-    void programTypeChanged(QRadioData::ProgramType programType);
-    void programTypeNameChanged(QString programTypeName);
-    void stationNameChanged(QString stationName);
-    void radioTextChanged(QString radioText);
-    void alternativeFrequenciesEnabledChanged(bool enabled);
-
-    void error(QRadioData::Error error);
-
-private:
-
-    Q_DISABLE_COPY(QRadioData)
-    Q_DECLARE_PRIVATE(QRadioData)
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QRadioData::Error)
-Q_DECLARE_METATYPE(QRadioData::ProgramType)
-
-Q_MEDIA_ENUM_DEBUG(QRadioData, Error)
-Q_MEDIA_ENUM_DEBUG(QRadioData, ProgramType)
-
-QT_END_HEADER
-
-#endif  // QRADIOPLAYER_H
diff --git a/src/multimedia/qradiodatacontrol.cpp b/src/multimedia/qradiodatacontrol.cpp
deleted file mode 100644
index 28b9a99..0000000
--- a/src/multimedia/qradiodatacontrol.cpp
+++ /dev/null
@@ -1,216 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qtmultimediadefs.h>
-#include "qradiodatacontrol.h"
-#include "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QRadioDataControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 5.0
-
-
-    \brief The QRadioDataControl class provides access to the RDS functionality of the
-    radio in the QMediaService.
-
-    The functionality provided by this control is exposed to application code
-    through the QRadioData class.
-
-    The interface name of QRadioDataControl is \c com.nokia.Qt.QRadioDataControl/5.0 as
-    defined in QRadioDataControl_iid.
-
-    \sa QMediaService::requestControl(), QRadioData
-*/
-
-/*!
-    \macro QRadioDataControl_iid
-
-    \c com.nokia.Qt.QRadioDataControl/5.0
-
-    Defines the interface name of the QRadioDataControl class.
-
-    \relates QRadioDataControl
-*/
-
-/*!
-    Constructs a radio data control with the given \a parent.
-*/
-
-QRadioDataControl::QRadioDataControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destroys a radio data control.
-*/
-
-QRadioDataControl::~QRadioDataControl()
-{
-}
-
-/*!
-    \fn bool QRadioDataControl::isAvailable() const
-
-    Returns true if the radio service is ready to use.
-    \since 5.0
-*/
-
-/*!
-    \fn QtMultimedia::AvailabilityError QRadioDataControl::availabilityError() const
-
-    Returns the error state of the radio service.
-    \since 5.0
-*/
-
-/*!
-    \fn QRadioData::Error QRadioDataControl::error() const
-
-    Returns the error state of a radio data.
-    \since 5.0
-*/
-
-/*!
-    \fn QString QRadioDataControl::errorString() const
-
-    Returns a string describing a radio data's error state.
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioDataControl::error(QRadioData::Error error)
-
-    Signals that an \a error has occurred.
-    \since 5.0
-*/
-
-/*!
-    \fn int QRadioDataControl::stationId()
-
-    Returns the current Program Identification
-    \since 5.0
-*/
-
-/*!
-    \fn QRadioData::ProgramType QRadioDataControl::programType()
-
-    Returns the current Program Type
-    \since 5.0
-*/
-
-/*!
-    \fn QString QRadioDataControl::programTypeName()
-
-    Returns the current Program Type Name
-    \since 5.0
-*/
-
-/*!
-    \fn QString QRadioDataControl::stationName()
-
-    Returns the current Program Service
-    \since 5.0
-*/
-
-/*!
-    \fn QString QRadioDataControl::radioText()
-
-    Returns the current Radio Text
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioDataControl::setAlternativeFrequenciesEnabled(bool enabled)
-
-    Sets the Alternative Frequency to \a enabled
-    \since 5.0
-*/
-
-/*!
-    \fn bool QRadioDataControl::isAlternativeFrequenciesEnabled()
-
-    Returns true if Alternative Frequency is currently enabled
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioDataControl::stationIdChanged(QString stationId)
-
-    Signals that the Program Identification \a stationId has changed
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioDataControl::programTypeChanged(QRadioData::ProgramType programType)
-
-    Signals that the Program Type \a programType has changed
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioDataControl::programTypeNameChanged(QString programTypeName)
-
-    Signals that the Program Type Name \a programTypeName has changed
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioDataControl::stationNameChanged(QString stationName)
-
-    Signals that the Program Service \a stationName has changed
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioDataControl::radioTextChanged(QString radioText)
-
-    Signals that the Radio Text \a radioText has changed
-    \since 5.0
-*/
-
-#include "moc_qradiodatacontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qradiodatacontrol.h b/src/multimedia/qradiodatacontrol.h
deleted file mode 100644
index 487236c..0000000
--- a/src/multimedia/qradiodatacontrol.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QRADIODATACONTROL_H
-#define QRADIODATACONTROL_H
-
-#include "qmediacontrol.h"
-#include "qradiodata.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QRadioDataControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    ~QRadioDataControl();
-
-    virtual bool isAvailable() const = 0;
-    virtual QtMultimedia::AvailabilityError availabilityError() const = 0;
-
-    virtual QString stationId() const = 0;
-    virtual QRadioData::ProgramType programType() const = 0;
-    virtual QString programTypeName() const = 0;
-    virtual QString stationName() const = 0;
-    virtual QString radioText() const = 0;
-    virtual void setAlternativeFrequenciesEnabled(bool enabled) = 0;
-    virtual bool isAlternativeFrequenciesEnabled() const = 0;
-
-    virtual QRadioData::Error error() const = 0;
-    virtual QString errorString() const = 0;
-
-Q_SIGNALS:
-    void stationIdChanged(QString stationId);
-    void programTypeChanged(QRadioData::ProgramType programType);
-    void programTypeNameChanged(QString programTypeName);
-    void stationNameChanged(QString stationName);
-    void radioTextChanged(QString radioText);
-    void alternativeFrequenciesEnabledChanged(bool enabled);
-    void error(QRadioData::Error err);
-
-protected:
-    QRadioDataControl(QObject *parent = 0);
-};
-
-#define QRadioDataControl_iid "com.nokia.Qt.QRadioDataControl/5.0"
-Q_MEDIA_DECLARE_CONTROL(QRadioDataControl, QRadioDataControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QRADIODATACONTROL_H
diff --git a/src/multimedia/qradiotuner.cpp b/src/multimedia/qradiotuner.cpp
deleted file mode 100644
index 66b0c70..0000000
--- a/src/multimedia/qradiotuner.cpp
+++ /dev/null
@@ -1,661 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qradiotuner.h"
-#include "qmediaservice.h"
-#include "qmediaobject_p.h"
-#include "qradiotunercontrol.h"
-
-#include <QPair>
-
-
-QT_BEGIN_NAMESPACE
-
-
-namespace
-{
-    class QRadioTunerPrivateRegisterMetaTypes
-    {
-    public:
-        QRadioTunerPrivateRegisterMetaTypes()
-        {
-            qRegisterMetaType<QRadioTuner::Band>();
-            qRegisterMetaType<QRadioTuner::Error>();
-            qRegisterMetaType<QRadioTuner::SearchMode>();
-            qRegisterMetaType<QRadioTuner::State>();
-            qRegisterMetaType<QRadioTuner::StereoMode>();
-        }
-    } _registerMetaTypes;
-}
-
-
-/*!
-    \class QRadioTuner
-    \brief The QRadioTuner class provides an interface to the systems analog radio device.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \since 1.0
-
-    You can control the systems analog radio device using this interface, for example:
-
-    \snippet doc/src/snippets/multimedia-snippets/media.cpp Radio tuner
-
-    The radio object will emit signals for any changes in state such as:
-    bandChanged(), frequencyChanged(), stereoStatusChanged(), searchingChanged(),
-    signalStrengthChanged(), volumeChanged(), mutedChanged().
-
-    You can change between the frequency bands using setBand() however it is recommended
-    that you check to make sure the band is available first using isBandSupported().
-
-*/
-
-
-class QRadioTunerPrivate : public QMediaObjectPrivate
-{
-public:
-    QRadioTunerPrivate():provider(0), control(0) {}
-    QMediaServiceProvider *provider;
-    QRadioTunerControl* control;
-};
-
-
-
-/*!
-    Constructs a radio tuner based on a media service allocated by a media service \a provider.
-
-    The \a parent is passed to QMediaObject.
-    \since 1.0
-*/
-
-QRadioTuner::QRadioTuner(QObject *parent, QMediaServiceProvider* provider):
-    QMediaObject(*new QRadioTunerPrivate, parent, provider->requestService(Q_MEDIASERVICE_RADIO))
-{
-    Q_D(QRadioTuner);
-
-    d->provider = provider;
-
-    if (d->service != 0) {
-        d->control = qobject_cast<QRadioTunerControl*>(d->service->requestControl(QRadioTunerControl_iid));
-        if (d->control != 0) {
-            connect(d->control, SIGNAL(stateChanged(QRadioTuner::State)), SIGNAL(stateChanged(QRadioTuner::State)));
-            connect(d->control, SIGNAL(bandChanged(QRadioTuner::Band)), SIGNAL(bandChanged(QRadioTuner::Band)));
-            connect(d->control, SIGNAL(frequencyChanged(int)), SIGNAL(frequencyChanged(int)));
-            connect(d->control, SIGNAL(stereoStatusChanged(bool)), SIGNAL(stereoStatusChanged(bool)));
-            connect(d->control, SIGNAL(searchingChanged(bool)), SIGNAL(searchingChanged(bool)));
-            connect(d->control, SIGNAL(signalStrengthChanged(int)), SIGNAL(signalStrengthChanged(int)));
-            connect(d->control, SIGNAL(volumeChanged(int)), SIGNAL(volumeChanged(int)));
-            connect(d->control, SIGNAL(mutedChanged(bool)), SIGNAL(mutedChanged(bool)));
-            connect(d->control, SIGNAL(stationFound(int,QString)), SIGNAL(stationFound(int,QString)));
-            connect(d->control, SIGNAL(error(QRadioTuner::Error)), SIGNAL(error(QRadioTuner::Error)));
-        }
-    }
-}
-
-/*!
-    Destroys a radio tuner.
-*/
-
-QRadioTuner::~QRadioTuner()
-{
-    Q_D(QRadioTuner);
-
-    if (d->service && d->control)
-        d->service->releaseControl(d->control);
-
-    d->provider->releaseService(d->service);
-}
-
-/*!
-    Returns true if the radio tuner service is ready to use.
-    \since 1.0
-*/
-bool QRadioTuner::isAvailable() const
-{
-    if (d_func()->control != NULL)
-        return d_func()->control->isAvailable();
-    else
-        return false;
-}
-
-/*!
-    Returns the availability error state.
-    \since 1.0
-*/
-QtMultimedia::AvailabilityError QRadioTuner::availabilityError() const
-{
-    if (d_func()->control != NULL)
-        return d_func()->control->availabilityError();
-    else
-        return QtMultimedia::ServiceMissingError;
-}
-
-/*!
-    \property QRadioTuner::state
-    Return the current radio tuner state.
-
-    \since 1.0
-    \sa QRadioTuner::State
-*/
-
-QRadioTuner::State QRadioTuner::state() const
-{
-    return d_func()->control ?
-            d_func()->control->state() : QRadioTuner::StoppedState;
-}
-
-/*!
-    \property QRadioTuner::band
-    \brief the frequency band a radio tuner is tuned to.
-
-    \since 1.0
-    \sa QRadioTuner::Band
-*/
-
-QRadioTuner::Band QRadioTuner::band() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->band();
-
-    return QRadioTuner::FM;
-}
-
-/*!
-    \property QRadioTuner::frequency
-    \brief the frequency in Hertz a radio tuner is tuned to.
-    \since 1.0
-*/
-
-int QRadioTuner::frequency() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->frequency();
-
-    return 0;
-}
-
-/*!
-    Returns the number of Hertz to increment the frequency by when stepping through frequencies
-    within a given \a band.
-    \since 1.0
-*/
-
-int QRadioTuner::frequencyStep(QRadioTuner::Band band) const
-{
-    Q_D(const QRadioTuner);
-
-    if(d->control != 0)
-        return d->control->frequencyStep(band);
-
-    return 0;
-}
-
-/*!
-    Returns a frequency \a band's minimum and maximum frequency.
-    \since 1.0
-*/
-
-QPair<int,int> QRadioTuner::frequencyRange(QRadioTuner::Band band) const
-{
-    Q_D(const QRadioTuner);
-
-    if(d->control != 0)
-        return d->control->frequencyRange(band);
-
-    return qMakePair<int,int>(0,0);
-}
-
-/*!
-    \property QRadioTuner::stereo
-    \brief whether a radio tuner is receiving a stereo signal.
-    \since 1.0
-*/
-
-bool QRadioTuner::isStereo() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->isStereo();
-
-    return false;
-}
-
-
-/*!
-    \property QRadioTuner::stereoMode
-    \brief the stereo mode of a radio tuner.
-    \since 1.0
-*/
-
-QRadioTuner::StereoMode QRadioTuner::stereoMode() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->stereoMode();
-
-    return QRadioTuner::Auto;
-}
-
-void QRadioTuner::setStereoMode(QRadioTuner::StereoMode mode)
-{
-    Q_D(QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->setStereoMode(mode);
-}
-
-/*!
-    Identifies if a frequency \a band is supported by a radio tuner.
-
-    Returns true if the band is supported, and false if it is not.
-    \since 1.0
-*/
-
-bool QRadioTuner::isBandSupported(QRadioTuner::Band band) const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->isBandSupported(band);
-
-    return false;
-}
-
-/*!
-    Activate the radio device.
-    \since 1.0
-*/
-
-void QRadioTuner::start()
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        d->control->start();
-}
-
-/*!
-    Deactivate the radio device.
-    \since 1.0
-*/
-
-void QRadioTuner::stop()
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        d->control->stop();
-}
-
-/*!
-    \property QRadioTuner::signalStrength
-    \brief the strength of the current radio signal as a percentage.
-    \since 1.0
-*/
-
-int QRadioTuner::signalStrength() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->signalStrength();
-
-    return 0;
-}
-
-/*!
-    \property QRadioTuner::volume
-    \brief the volume of a radio tuner's audio output as a percentage.
-    \since 1.0
-*/
-
-
-int QRadioTuner::volume() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->volume();
-
-    return 0;
-}
-
-/*!
-    \property QRadioTuner::muted
-    \brief whether a radio tuner's audio output is muted.
-    \since 1.0
-*/
-
-bool QRadioTuner::isMuted() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->isMuted();
-
-    return false;
-}
-
-/*!
-    Sets a radio tuner's frequency \a band.
-
-    Changing the band will reset the \l frequency to the new band's minimum frequency.
-    \since 1.0
-*/
-
-void QRadioTuner::setBand(QRadioTuner::Band band)
-{
-    Q_D(QRadioTuner);
-
-    if (d->control != 0)
-        d->control->setBand(band);
-}
-
-/*!
-    Sets a radio tuner's \a frequency.
-
-    If the tuner is set to a frequency outside the current \l band, the band will be changed to
-    one occupied by the new frequency.
-    \since 1.0
-*/
-
-void QRadioTuner::setFrequency(int frequency)
-{
-    Q_D(QRadioTuner);
-
-    if (d->control != 0)
-        d->control->setFrequency(frequency);
-}
-
-void QRadioTuner::setVolume(int volume)
-{
-    Q_D(QRadioTuner);
-
-    if (d->control != 0)
-        d->control->setVolume(volume);
-}
-
-void QRadioTuner::setMuted(bool muted)
-{
-    Q_D(QRadioTuner);
-
-    if (d->control != 0)
-        d->control->setMuted(muted);
-}
-
-/*!
-    \property QRadioTuner::searching
-    \brief whether a radio tuner is currently scanning for a signal.
-
-    \sa searchForward(), searchBackward(), cancelSearch()
-    \since 1.0
-*/
-
-bool QRadioTuner::isSearching() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->isSearching();
-
-    return false;
-}
-
-/*!
-    Starts a forward scan for a signal, starting from the current \l frequency.
-
-    \since 1.0
-    \sa searchBackward(), cancelSearch(), searching
-*/
-
-void QRadioTuner::searchForward()
-{
-    Q_D(QRadioTuner);
-
-    if (d->control != 0)
-        d->control->searchForward();
-}
-
-/*!
-    Starts a backwards scan for a signal, starting from the current \l frequency.
-
-    \since 1.0
-    \sa searchForward(), cancelSearch(), searching
-*/
-
-void QRadioTuner::searchBackward()
-{
-    Q_D(QRadioTuner);
-
-    if (d->control != 0)
-        d->control->searchBackward();
-}
-
-/*!
-    Search all stations in current band
-
-    Emits QRadioTuner::stationFound(int, QString) for every found station.
-    After searching is completed, QRadioTuner::searchingChanged(bool) is
-    emitted (false). If \a searchMode is set to SearchGetStationId, searching
-    waits for station id (PI) on each frequency.
-
-    \since 5.0
-    \sa searchForward(), searchBackward(), searching
-*/
-
-void QRadioTuner::searchAllStations(QRadioTuner::SearchMode searchMode)
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        d->control->searchAllStations(searchMode);
-}
-
-/*!
-    Stops scanning for a signal.
-
-    \since 1.0
-    \sa searchForward(), searchBackward(), searching
-*/
-
-void QRadioTuner::cancelSearch()
-{
-    Q_D(QRadioTuner);
-
-    if (d->control != 0)
-        d->control->cancelSearch();
-}
-
-/*!
-    Returns the error state of a radio tuner.
-
-    \since 1.0
-    \sa errorString()
-*/
-
-QRadioTuner::Error QRadioTuner::error() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->error();
-
-    return QRadioTuner::ResourceError;
-}
-
-/*!
-    Returns a description of a radio tuner's error state.
-
-    \since 1.0
-    \sa error()
-*/
-
-QString QRadioTuner::errorString() const
-{
-    Q_D(const QRadioTuner);
-
-    if (d->control != 0)
-        return d->control->errorString();
-
-    return QString();
-}
-
-/*!
-    \fn void QRadioTuner::bandChanged(QRadioTuner::Band band)
-
-    Signals a radio tuner's \a band has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTuner::frequencyChanged(int frequency)
-
-    Signals that the \a frequency a radio tuner is tuned to has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTuner::mutedChanged(bool muted)
-
-    Signals that the \a muted state of a radio tuner's audio output has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTuner::volumeChanged(int volume)
-
-    Signals that the \a volume of a radio tuner's audio output has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTuner::searchingChanged(bool searching)
-
-    Signals that the \a searching state of a radio tuner has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTuner::stereoStatusChanged(bool stereo)
-
-    Signals that the \a stereo state of a radio tuner has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTuner::signalStrengthChanged(int strength)
-
-    Signals that the \a strength of the signal received by a radio tuner has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTuner::stationFound(int frequency, QString stationId)
-
-    Signals that a station was found in \a frequency with \a stationId Program
-    Identification code.
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioTuner::error(QRadioTuner::Error error)
-
-    Signals that an \a error occurred.
-    \since 1.0
-*/
-
-/*!
-    \enum QRadioTuner::State
-
-    Enumerates radio tuner states.
-
-    \value ActiveState The tuner is started and active.
-    \value StoppedState The tuner device is stopped.
-*/
-
-
-/*!
-    \enum QRadioTuner::Band
-
-    Enumerates radio frequency bands.
-
-    \value AM 520 to 1610 kHz, 9 or 10kHz channel spacing, extended 1610 to 1710 kHz
-    \value FM 87.5 to 108.0 MHz, except Japan 76-90 MHz
-    \value SW 1.711 to 30.0 MHz, divided into 15 bands. 5kHz channel spacing
-    \value LW 148.5 to 283.5 kHz, 9kHz channel spacing (Europe, Africa, Asia)
-    \value FM2 range not defined, used when area supports more than one FM range.
-*/
-
-/*!
-    \enum QRadioTuner::Error
-
-    Enumerates radio tuner error conditions.
-
-    \value NoError         No errors have occurred.
-    \value ResourceError   There is no radio service available.
-    \value OpenError       Unable to open radio device.
-    \value OutOfRangeError An attempt to set a frequency or band that is not supported by radio device.
-*/
-
-/*!
-    \enum QRadioTuner::StereoMode
-
-    Enumerates radio tuner policy for receiving stereo signals.
-
-    \value Auto        Uses the stereo mode matching the station.
-    \value ForceStereo Provide stereo mode, converting if required.
-    \value ForceMono   Provide mono mode, converting if required.
-*/
-
-/*! \fn void QRadioTuner::stateChanged(QRadioTuner::State state)
-  This signal is emitted when the state changes to \a state.
-  \since 1.0
- */
-
-#include "moc_qradiotuner.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qradiotuner.h b/src/multimedia/qradiotuner.h
deleted file mode 100644
index 21497f4..0000000
--- a/src/multimedia/qradiotuner.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QRADIOTUNER_H
-#define QRADIOTUNER_H
-
-#include <QtCore/qobject.h>
-
-#include "qmediaobject.h"
-#include "qmediaserviceprovider.h"
-#include <qmediaenumdebug.h>
-
-#include <QPair>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QRadioTunerPrivate;
-class Q_MULTIMEDIA_EXPORT QRadioTuner : public QMediaObject
-{
-    Q_OBJECT
-    Q_PROPERTY(State state READ state NOTIFY stateChanged)
-    Q_PROPERTY(Band band READ band WRITE setBand NOTIFY bandChanged)
-    Q_PROPERTY(int frequency READ frequency WRITE setFrequency NOTIFY frequencyChanged)
-    Q_PROPERTY(bool stereo READ isStereo NOTIFY stereoStatusChanged)
-    Q_PROPERTY(StereoMode stereoMode READ stereoMode WRITE setStereoMode)
-    Q_PROPERTY(int signalStrength READ signalStrength NOTIFY signalStrengthChanged)
-    Q_PROPERTY(int volume READ volume WRITE setVolume NOTIFY volumeChanged)
-    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
-    Q_PROPERTY(bool searching READ isSearching NOTIFY searchingChanged)
-    Q_ENUMS(State)
-    Q_ENUMS(Band)
-    Q_ENUMS(Error)
-    Q_ENUMS(StereoMode)
-    Q_ENUMS(SearchMode)
-
-public:
-    enum State { ActiveState, StoppedState };
-    enum Band { AM, FM, SW, LW, FM2 };
-    enum Error { NoError, ResourceError, OpenError, OutOfRangeError };
-    enum StereoMode { ForceStereo, ForceMono, Auto };
-    enum SearchMode { SearchFast, SearchGetStationId };
-
-    QRadioTuner(QObject *parent = 0, QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider());
-    ~QRadioTuner();
-
-    bool isAvailable() const;
-    QtMultimedia::AvailabilityError availabilityError() const;
-
-    State state() const;
-
-    Band band() const;
-
-    bool isBandSupported(Band b) const;
-
-    int frequency() const;
-    int frequencyStep(Band band) const;
-    QPair<int,int> frequencyRange(Band band) const;
-
-    bool isStereo() const;
-    void setStereoMode(QRadioTuner::StereoMode mode);
-    StereoMode stereoMode() const;
-
-    int signalStrength() const;
-
-    int volume() const;
-    bool isMuted() const;
-
-    bool isSearching() const;
-
-    Error error() const;
-    QString errorString() const;
-
-public Q_SLOTS:
-    void searchForward();
-    void searchBackward();
-    void searchAllStations(QRadioTuner::SearchMode searchMode = QRadioTuner::SearchFast);
-    void cancelSearch();
-
-    void setBand(Band band);
-    void setFrequency(int frequency);
-
-    void setVolume(int volume);
-    void setMuted(bool muted);
-
-    void start();
-    void stop();
-
-Q_SIGNALS:
-    void stateChanged(QRadioTuner::State state);
-    void bandChanged(QRadioTuner::Band band);
-    void frequencyChanged(int frequency);
-    void stereoStatusChanged(bool stereo);
-    void searchingChanged(bool searching);
-    void signalStrengthChanged(int signalStrength);
-    void volumeChanged(int volume);
-    void mutedChanged(bool muted);
-    void stationFound(int frequency, QString stationId);
-
-    void error(QRadioTuner::Error error);
-
-private:
-    Q_DISABLE_COPY(QRadioTuner)
-    Q_DECLARE_PRIVATE(QRadioTuner)
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QRadioTuner::State)
-Q_DECLARE_METATYPE(QRadioTuner::Band)
-Q_DECLARE_METATYPE(QRadioTuner::Error)
-Q_DECLARE_METATYPE(QRadioTuner::StereoMode)
-Q_DECLARE_METATYPE(QRadioTuner::SearchMode)
-
-Q_MEDIA_ENUM_DEBUG(QRadioTuner, State)
-Q_MEDIA_ENUM_DEBUG(QRadioTuner, Band)
-Q_MEDIA_ENUM_DEBUG(QRadioTuner, Error)
-Q_MEDIA_ENUM_DEBUG(QRadioTuner, StereoMode)
-Q_MEDIA_ENUM_DEBUG(QRadioTuner, SearchMode)
-
-QT_END_HEADER
-
-#endif  // QRADIOPLAYER_H
diff --git a/src/multimedia/qradiotunercontrol.cpp b/src/multimedia/qradiotunercontrol.cpp
deleted file mode 100644
index 6e2b488..0000000
--- a/src/multimedia/qradiotunercontrol.cpp
+++ /dev/null
@@ -1,378 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qtmultimediadefs.h>
-#include "qradiotunercontrol.h"
-#include "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QRadioTunerControl
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-
-    \brief The QRadioTunerControl class provides access to the radio tuning
-    functionality of a QMediaService.
-
-    If a QMediaService can tune an analog radio device it will implement
-    QRadioTunerControl.  This control provides a means to tune a radio device
-    to a specific \l {setFrequency()}{frequency} as well as search \l
-    {searchForward()}{forwards} and \l {searchBackward()}{backwards} for a
-    signal.
-
-    The functionality provided by this control is exposed to application code
-    through the QRadioTuner class.
-
-    The interface name of QRadioTunerControl is \c com.nokia.Qt.QRadioTunerControl/1.0 as
-    defined in QRadioTunerControl_iid.
-
-    \sa QMediaService::requestControl(), QRadioTuner
-*/
-
-/*!
-    \macro QRadioTunerControl_iid
-
-    \c com.nokia.Qt.QRadioTunerControl/1.0
-
-    Defines the interface name of the QRadioTunerControl class.
-
-    \relates QRadioTunerControl
-*/
-
-/*!
-    Constructs a radio tuner control with the given \a parent.
-*/
-
-QRadioTunerControl::QRadioTunerControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    Destroys a radio tuner control.
-*/
-
-QRadioTunerControl::~QRadioTunerControl()
-{
-}
-
-/*!
-    \fn bool QRadioTunerControl::isAvailable() const
-
-    Returns true if the radio service is ready to use.
-    \since 1.0
-*/
-
-/*!
-    \fn QtMultimedia::AvailabilityError QRadioTunerControl::availabilityError() const
-
-    Returns the error state of the radio service.
-    \since 1.0
-*/
-
-/*!
-    \fn QRadioTuner::State QRadioTunerControl::state() const
-
-    Returns the current radio tuner state.
-    \since 1.0
-*/
-
-/*!
-    \fn QRadioTuner::Band QRadioTunerControl::band() const
-
-    Returns the frequency band a radio tuner is tuned to.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::bandChanged(QRadioTuner::Band band)
-
-    Signals that the frequency \a band a radio tuner is tuned to has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::setBand(QRadioTuner::Band band)
-
-    Sets the frequecy \a band a radio tuner is tuned to.
-
-    Changing the frequency band will reset the frequency to the minimum frequency of the new band.
-    \since 1.0
-*/
-
-/*!
-    \fn bool QRadioTunerControl::isBandSupported(QRadioTuner::Band band) const
-
-    Identifies if a frequency \a band is supported.
-
-    Returns true if the band is supported, and false if it is not.
-    \since 1.0
-*/
-
-/*!
-    \fn int QRadioTunerControl::frequency() const
-
-    Returns the frequency a radio tuner is tuned to.
-    \since 1.0
-*/
-
-/*!
-    \fn int QRadioTunerControl::frequencyStep(QRadioTuner::Band band) const
-
-    Returns the number of Hertz to increment the frequency by when stepping through frequencies
-    within a given \a band.
-    \since 1.0
-*/
-
-/*!
-    \fn QPair<int,int> QRadioTunerControl::frequencyRange(QRadioTuner::Band band) const
-
-    Returns a frequency \a band's minimum and maximum frequency.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::setFrequency(int frequency)
-
-    Sets the \a frequency a radio tuner is tuned to.
-    \since 1.0
-*/
-
-/*!
-    \fn bool QRadioTunerControl::isStereo() const
-
-    Identifies if a radio tuner is receiving a stereo signal.
-
-    Returns true if the tuner is receiving a stereo signal, and false if it is not.
-    \since 1.0
-*/
-
-/*!
-    \fn QRadioTuner::StereoMode QRadioTunerControl::stereoMode() const
-
-    Returns a radio tuner's stereo mode.
-
-    \since 1.0
-    \sa QRadioTuner::StereoMode
-*/
-
-/*!
-    \fn void QRadioTunerControl::setStereoMode(QRadioTuner::StereoMode mode)
-
-    Sets a radio tuner's stereo \a mode.
-
-    \since 1.0
-    \sa QRadioTuner::StereoMode
-*/
-
-/*!
-    \fn int QRadioTunerControl::signalStrength() const
-
-    Return a radio tuner's current signal strength as a percentage.
-    \since 1.0
-*/
-
-/*!
-    \fn int QRadioTunerControl::volume() const
-
-    Returns the volume of a radio tuner's audio output as a percentage.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::setVolume(int volume)
-
-    Sets the percentage \a volume of a radio tuner's audio output.
-    \since 1.0
-*/
-
-/*!
-    \fn bool QRadioTunerControl::isMuted() const
-
-    Identifies if a radio tuner's audio output is muted.
-
-    Returns true if the audio is muted, and false if it is not.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::setMuted(bool muted)
-
-    Sets the \a muted state of a radio tuner's audio output.
-    \since 1.0
-*/
-
-/*!
-    \fn bool QRadioTunerControl::isSearching() const
-
-    Identifies if a radio tuner is currently scanning for signal.
-
-    Returns true if the tuner is scanning, and false if it is not.
-    \since 1.0
-*/
-
-/*!
-    \fn  void QRadioTunerControl::searchForward()
-
-    Starts a forward scan for a signal, starting from the current \l frequency().
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::searchBackward()
-
-    Starts a backwards scan for a signal, starting from the current \l frequency().
-    \since 1.0
-*/
-
-/*!
-    \fn  void QRadioTunerControl::searchAllStations()
-
-    Starts a scan through the whole frequency band searching all stations
-    \since 5.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::cancelSearch()
-
-    Stops scanning for a signal.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::start()
-
-    Activate the radio device.
-    \since 1.0
-*/
-
-/*!
-    \fn QRadioTunerControl::stop()
-
-    Deactivate the radio device.
-    \since 1.0
-*/
-
-/*!
-    \fn QRadioTuner::Error QRadioTunerControl::error() const
-
-    Returns the error state of a radio tuner.
-    \since 1.0
-*/
-
-/*!
-    \fn QString QRadioTunerControl::errorString() const
-
-    Returns a string describing a radio tuner's error state.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::stateChanged(QRadioTuner::State state)
-
-    Signals that the \a state of a radio tuner has changed.
-    \since 1.0
-*/
-
-
-/*!
-    \fn void QRadioTunerControl::frequencyChanged(int frequency)
-
-    Signals that the \a frequency a radio tuner is tuned to has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::stereoStatusChanged(bool stereo)
-
-    Signals that the \a stereo state of a radio tuner has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::searchingChanged(bool searching)
-
-    Signals that the \a searching state of a radio tuner has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::signalStrengthChanged(int strength)
-
-    Signals that the percentage \a strength of the signal received by a radio tuner has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::volumeChanged(int volume)
-
-    Signals that the percentage \a volume of radio tuner's audio output has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::mutedChanged(bool muted)
-
-    Signals that the \a muted state of a radio tuner's audio output has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::error(QRadioTuner::Error error)
-
-    Signals that an \a error has occurred.
-    \since 1.0
-*/
-
-/*!
-    \fn void QRadioTunerControl::stationFound(int frequency)
-
-    Signals that new station with \a frequency was found when scanning
-    \since 5.0
-*/
-
-#include "moc_qradiotunercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qradiotunercontrol.h b/src/multimedia/qradiotunercontrol.h
deleted file mode 100644
index b0ea542..0000000
--- a/src/multimedia/qradiotunercontrol.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QRADIOTUNERCONTROL_H
-#define QRADIOTUNERCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qradiotuner.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class Q_MULTIMEDIA_EXPORT QRadioTunerControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    ~QRadioTunerControl();
-
-    virtual bool isAvailable() const = 0;
-    virtual QtMultimedia::AvailabilityError availabilityError() const = 0;
-
-    virtual QRadioTuner::State state() const = 0;
-
-    virtual QRadioTuner::Band band() const = 0;
-    virtual void setBand(QRadioTuner::Band b) = 0;
-    virtual bool isBandSupported(QRadioTuner::Band b) const = 0;
-
-    virtual int frequency() const = 0;
-    virtual int frequencyStep(QRadioTuner::Band b) const = 0;
-    virtual QPair<int,int> frequencyRange(QRadioTuner::Band b) const = 0;
-    virtual void setFrequency(int frequency) = 0;
-
-    virtual bool isStereo() const = 0;
-    virtual QRadioTuner::StereoMode stereoMode() const = 0;
-    virtual void setStereoMode(QRadioTuner::StereoMode mode) = 0;
-
-    virtual int signalStrength() const = 0;
-
-    virtual int volume() const = 0;
-    virtual void setVolume(int volume) = 0;
-
-    virtual bool isMuted() const = 0;
-    virtual void setMuted(bool muted) = 0;
-
-    virtual bool isSearching() const = 0;
-
-    virtual void searchForward() = 0;
-    virtual void searchBackward() = 0;
-    virtual void searchAllStations(QRadioTuner::SearchMode searchMode = QRadioTuner::SearchFast) = 0;
-    virtual void cancelSearch() = 0;
-
-    virtual void start() = 0;
-    virtual void stop() = 0;
-
-    virtual QRadioTuner::Error error() const = 0;
-    virtual QString errorString() const = 0;
-
-Q_SIGNALS:
-    void stateChanged(QRadioTuner::State state);
-    void bandChanged(QRadioTuner::Band band);
-    void frequencyChanged(int frequency);
-    void stereoStatusChanged(bool stereo);
-    void searchingChanged(bool searching);
-    void signalStrengthChanged(int signalStrength);
-    void volumeChanged(int volume);
-    void mutedChanged(bool muted);
-    void error(QRadioTuner::Error err);
-    void stationFound(int frequency, QString stationId);
-
-protected:
-    QRadioTunerControl(QObject *parent = 0);
-};
-
-#define QRadioTunerControl_iid "com.nokia.Qt.QRadioTunerControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QRadioTunerControl, QRadioTunerControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif  // QRADIOTUNERCONTROL_H
diff --git a/src/multimedia/qvideodevicecontrol.cpp b/src/multimedia/qvideodevicecontrol.cpp
deleted file mode 100644
index a864fd5..0000000
--- a/src/multimedia/qvideodevicecontrol.cpp
+++ /dev/null
@@ -1,159 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qvideodevicecontrol.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QVideoDeviceControl
-
-    \brief The QVideoDeviceControl class provides an video device selector media control.
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-    The QVideoDeviceControl class provides descriptions of the video devices
-    available on a system and allows one to be selected as the  endpoint of a
-    media service.
-
-    The interface name of QVideoDeviceControl is \c com.nokia.Qt.VideoDeviceControl as
-    defined in QVideoDeviceControl_iid.
-*/
-
-/*!
-    \macro QVideoDeviceControl_iid
-
-    \c com.nokia.Qt.VideoDeviceControl
-
-    Defines the interface name of the QVideoDeviceControl class.
-
-    \relates QVideoDeviceControl
-*/
-
-/*!
-    Constructs a video device control with the given \a parent.
-*/
-QVideoDeviceControl::QVideoDeviceControl(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys a video device control.
-*/
-QVideoDeviceControl::~QVideoDeviceControl()
-{
-}
-
-/*!
-    \fn QVideoDeviceControl::deviceCount() const
-
-    Returns the number of available video devices;
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::deviceName(int index) const
-
-    Returns the name of the video device at \a index.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::deviceDescription(int index) const
-
-    Returns a description of the video device at \a index.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::deviceIcon(int index) const
-
-    Returns an icon for the video device at \a index.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::defaultDevice() const
-
-    Returns the index of the default video device.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::selectedDevice() const
-
-    Returns the index of the selected video device.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::setSelectedDevice(int index)
-
-    Sets the selected video device \a index.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::devicesChanged()
-
-    Signals that the list of available video devices has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::selectedDeviceChanged(int index)
-
-    Signals that the selected video device \a index has changed.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoDeviceControl::selectedDeviceChanged(const QString &name)
-
-    Signals that the selected video device \a name has changed.
-    \since 1.0
-*/
-
-#include "moc_qvideodevicecontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qvideodevicecontrol.h b/src/multimedia/qvideodevicecontrol.h
deleted file mode 100644
index 6f44c46..0000000
--- a/src/multimedia/qvideodevicecontrol.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QVIDEODEVICECONTROL_H
-#define QVIDEODEVICECONTROL_H
-
-#include "qmediacontrol.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class Q_MULTIMEDIA_EXPORT QVideoDeviceControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QVideoDeviceControl();
-
-    virtual int deviceCount() const = 0;
-
-    virtual QString deviceName(int index) const = 0;
-    virtual QString deviceDescription(int index) const = 0;
-    virtual QIcon deviceIcon(int index) const = 0;
-
-    virtual int defaultDevice() const = 0;
-    virtual int selectedDevice() const = 0;
-
-public Q_SLOTS:
-    virtual void setSelectedDevice(int index) = 0;
-
-Q_SIGNALS:
-    void selectedDeviceChanged(int index);
-    void selectedDeviceChanged(const QString &deviceName);
-    void devicesChanged();
-
-protected:
-    QVideoDeviceControl(QObject *parent = 0);
-};
-
-#define QVideoDeviceControl_iid "com.nokia.Qt.QVideoDeviceControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QVideoDeviceControl, QVideoDeviceControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QVIDEODEVICECONTROL_H
diff --git a/src/multimedia/qvideoencodercontrol.cpp b/src/multimedia/qvideoencodercontrol.cpp
deleted file mode 100644
index 1551f2c..0000000
--- a/src/multimedia/qvideoencodercontrol.cpp
+++ /dev/null
@@ -1,190 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qvideoencodercontrol.h"
-#include <QtCore/qstringlist.h>
-#include <QtCore/qvariant.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QVideoEncoderControl
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-    \brief The QVideoEncoderControl class provides access to the settings
-    of a media service that performs video encoding.
-
-    If a QMediaService supports encoding video data it will implement
-    QVideoEncoderControl.  This control provides information about the limits
-    of restricted video encoder options and allows the selection of a set of
-    video encoder settings as specified in a QVideoEncoderSettings object.
-
-    The functionality provided by this control is exposed to application code
-    through the QMediaRecorder class.
-
-    The interface name of QVideoEncoderControl is \c com.nokia.Qt.QVideoEncoderControl/1.0 as
-    defined in QVideoEncoderControl_iid.
-
-    \sa QMediaRecorder, QVideoEncoderSettings, QMediaService::requestControl()
-*/
-
-/*!
-    \macro QVideoEncoderControl_iid
-
-    \c com.nokia.Qt.QVideoEncoderControl/1.0
-
-    Defines the interface name of the QVideoEncoderControl class.
-
-    \relates QVideoEncoderControl
-*/
-
-/*!
-    Create a new video encoder control object with the given \a parent.
-*/
-QVideoEncoderControl::QVideoEncoderControl(QObject *parent)
-    :QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys a video encoder control.
-*/
-QVideoEncoderControl::~QVideoEncoderControl()
-{
-}
-
-/*!
-    \fn QVideoEncoderControl::supportedVideoCodecs() const
-
-    Returns the list of supported video codecs.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoEncoderControl::videoCodecDescription(const QString &codec) const
-
-    Returns a description of a video \a codec.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoEncoderControl::supportedEncodingOptions(const QString &codec) const
-
-    Returns a list of supported encoding options for a video \a codec.
-
-    The names and types of the options in the list is system dependent.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoEncoderControl::encodingOption(const QString &codec, const QString &option) const
-
-    Returns the value of a video \a codec \a option.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoEncoderControl::setEncodingOption(const QString &codec, const QString &option, const QVariant &value)
-
-    Sets the \a value of a \a codec specific \a option.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoEncoderControl::supportedResolutions(const QVideoEncoderSettings &settings = QVideoEncoderSettings(),
-                                                   bool *continuous = 0) const
-
-    Returns a list of supported resolutions.
-
-    If non null video \a settings parameter is passed,
-    the returned list is reduced to resolution supported with partial settings like
-    \l {QVideoEncoderSettings::setCodec()}{video codec} or
-    \l {QVideoEncoderSettings::setFrameRate()}{frame rate} applied.
-
-    If the encoder supports arbitrary resolutions within the supported resolutions range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-
-    \since 1.0
-    \sa QVideoEncoderSettings::resolution()
-*/
-
-/*!
-    \fn QVideoEncoderControl::supportedFrameRates(const QVideoEncoderSettings &settings = QVideoEncoderSettings(),
-                                                  bool *continuous = 0) const
-
-    Returns a list of supported frame rates.
-
-    If non null video \a settings parameter is passed,
-    the returned list is reduced to frame rates supported with partial settings like
-    \l {QVideoEncoderSettings::setCodec()}{video codec} or
-    \l {QVideoEncoderSettings::setResolution()}{video resolution} applied.
-
-    If the encoder supports arbitrary frame rates within the supported range,
-    *\a continuous is set to true, otherwise *\a continuous is set to false.
-
-    \since 1.0
-    \sa QVideoEncoderSettings::frameRate()
-*/
-
-/*!
-    \fn QVideoEncoderControl::videoSettings() const
-
-    Returns the video encoder settings.
-
-    The returned value may be different tha passed to QVideoEncoderControl::setVideoSettings()
-    if the settings contains the default or undefined parameters.
-    In this case if the undefined parameters are already resolved, they should be returned.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoEncoderControl::setVideoSettings(const QVideoEncoderSettings &settings)
-
-    Sets the selected video encoder \a settings.
-    \since 1.0
-*/
-
-#include "moc_qvideoencodercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qvideoencodercontrol.h b/src/multimedia/qvideoencodercontrol.h
deleted file mode 100644
index 343af80..0000000
--- a/src/multimedia/qvideoencodercontrol.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QVIDEOENCODERCONTROL_H
-#define QVIDEOENCODERCONTROL_H
-
-#include "qmediacontrol.h"
-#include "qmediarecorder.h"
-
-#include <QtCore/qpair.h>
-#include <QtCore/qsize.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QByteArray;
-class QStringList;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-class Q_MULTIMEDIA_EXPORT QVideoEncoderControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    virtual ~QVideoEncoderControl();
-
-    virtual QList<QSize> supportedResolutions(const QVideoEncoderSettings &settings,
-                                              bool *continuous = 0) const = 0;
-
-    virtual QList<qreal> supportedFrameRates(const QVideoEncoderSettings &settings,
-                                             bool *continuous = 0) const = 0;
-
-    virtual QStringList supportedVideoCodecs() const = 0;
-    virtual QString videoCodecDescription(const QString &codecName) const = 0;
-
-    virtual QVideoEncoderSettings videoSettings() const = 0;
-    virtual void setVideoSettings(const QVideoEncoderSettings &settings) = 0;
-
-    virtual QStringList supportedEncodingOptions(const QString &codec) const = 0;
-    virtual QVariant encodingOption(const QString &codec, const QString &name) const = 0;
-    virtual void setEncodingOption(const QString &codec, const QString &name, const QVariant &value) = 0;
-
-protected:
-    QVideoEncoderControl(QObject *parent = 0);
-};
-
-#define QVideoEncoderControl_iid "com.nokia.Qt.QVideoEncoderControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QVideoEncoderControl, QVideoEncoderControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
diff --git a/src/multimedia/qvideorenderercontrol.cpp b/src/multimedia/qvideorenderercontrol.cpp
deleted file mode 100644
index 9914226..0000000
--- a/src/multimedia/qvideorenderercontrol.cpp
+++ /dev/null
@@ -1,114 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qvideorenderercontrol.h"
-
-#include "qmediacontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QVideoRendererControl
-
-
-    \brief The QVideoRendererControl class provides a control for rendering
-    to a video surface.
-
-    \inmodule QtMultimedia
-    \ingroup multimedia-serv
-    \since 1.0
-
-    Using the surface() property of QVideoRendererControl a
-    QAbstractVideoSurface may be set as the video render target of a
-    QMediaService.
-
-    \snippet doc/src/snippets/multimedia-snippets/video.cpp Video renderer control
-
-    QVideoRendererControl is one of a number of possible video output controls.
-
-    The interface name of QVideoRendererControl is \c com.nokia.Qt.QVideoRendererControl/1.0 as
-    defined in QVideoRendererControl_iid.
-
-    \sa QMediaService::requestControl(), QVideoWidget
-*/
-
-/*!
-    \macro QVideoRendererControl_iid
-
-    \c com.nokia.Qt.QVideoRendererControl/1.0
-
-    Defines the interface name of the QVideoRendererControl class.
-
-    \relates QVideoRendererControl
-*/
-
-/*!
-    Constructs a new video renderer media end point with the given \a parent.
-*/
-QVideoRendererControl::QVideoRendererControl(QObject *parent)
-    : QMediaControl(parent)
-{
-}
-
-/*!
-    Destroys a video renderer media end point.
-*/
-QVideoRendererControl::~QVideoRendererControl()
-{
-}
-
-/*!
-    \fn QVideoRendererControl::surface() const
-
-    Returns the surface a video producer renders to.
-    \since 1.0
-*/
-
-/*!
-    \fn QVideoRendererControl::setSurface(QAbstractVideoSurface *surface)
-
-    Sets the \a surface a video producer renders to.
-    \since 1.0
-*/
-
-#include "moc_qvideorenderercontrol.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/qvideorenderercontrol.h b/src/multimedia/qvideorenderercontrol.h
deleted file mode 100644
index b3a7083..0000000
--- a/src/multimedia/qvideorenderercontrol.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QVIDEORENDERERCONTROL_H
-#define QVIDEORENDERERCONTROL_H
-
-#include "qmediacontrol.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QAbstractVideoSurface;
-QT_END_NAMESPACE
-
-QT_BEGIN_NAMESPACE
-
-
-class Q_MULTIMEDIA_EXPORT QVideoRendererControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    ~QVideoRendererControl();
-
-    virtual QAbstractVideoSurface *surface() const = 0;
-    virtual void setSurface(QAbstractVideoSurface *surface) = 0;
-
-protected:
-    QVideoRendererControl(QObject *parent = 0);
-};
-
-#define QVideoRendererControl_iid "com.nokia.Qt.QVideoRendererControl/1.0"
-Q_MEDIA_DECLARE_CONTROL(QVideoRendererControl, QVideoRendererControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif // QVIDEORENDERERCONTROL_H
diff --git a/src/multimedia/qvideosurfaceoutput.cpp b/src/multimedia/qvideosurfaceoutput.cpp
deleted file mode 100644
index cdbec55..0000000
--- a/src/multimedia/qvideosurfaceoutput.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qvideosurfaceoutput_p.h"
-
-#include <qabstractvideosurface.h>
-#include <qmediaservice.h>
-#include <qvideorenderercontrol.h>
-
-
-QVideoSurfaceOutput::QVideoSurfaceOutput(QObject*parent)
-    :  QObject(parent)
-{
-}
-
-QVideoSurfaceOutput::~QVideoSurfaceOutput()
-{
-    if (m_control) {
-        m_control.data()->setSurface(0);
-        m_service.data()->releaseControl(m_control.data());
-    }
-}
-
-QMediaObject *QVideoSurfaceOutput::mediaObject() const
-{
-    return m_object.data();
-}
-
-void QVideoSurfaceOutput::setVideoSurface(QAbstractVideoSurface *surface)
-{
-    m_surface = surface;
-
-    if (m_control)
-        m_control.data()->setSurface(surface);
-}
-
-bool QVideoSurfaceOutput::setMediaObject(QMediaObject *object)
-{
-    if (m_control) {
-        m_control.data()->setSurface(0);
-        m_service.data()->releaseControl(m_control.data());
-    }
-    m_control.clear();
-    m_service.clear();
-    m_object.clear();
-
-    if (object) {
-        if (QMediaService *service = object->service()) {
-            if (QMediaControl *control = service->requestControl(QVideoRendererControl_iid)) {
-                if ((m_control = qobject_cast<QVideoRendererControl *>(control))) {
-                    m_service = service;
-                    m_object = object;
-                    m_control.data()->setSurface(m_surface.data());
-
-                    return true;
-                }
-                service->releaseControl(control);
-            }
-        }
-    }
-    return false;
-}
diff --git a/src/multimedia/qvideosurfaceoutput_p.h b/src/multimedia/qvideosurfaceoutput_p.h
deleted file mode 100644
index 76ec5e8..0000000
--- a/src/multimedia/qvideosurfaceoutput_p.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QVIDEOSURFACEOUTPUT_P_H
-#define QVIDEOSURFACEOUTPUT_P_H
-
-#include <qmediabindableinterface.h>
-
-#include <QtCore/qsharedpointer.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-
-class QAbstractVideoSurface;
-class QVideoRendererControl;
-
-class QVideoSurfaceOutput : public QObject, public QMediaBindableInterface
-{
-    Q_OBJECT
-    Q_INTERFACES(QMediaBindableInterface)
-public:
-    QVideoSurfaceOutput(QObject*parent = 0);
-    ~QVideoSurfaceOutput();
-
-    QMediaObject *mediaObject() const;
-
-    void setVideoSurface(QAbstractVideoSurface *surface);
-
-protected:
-    bool setMediaObject(QMediaObject *object);
-
-private:
-    QWeakPointer<QAbstractVideoSurface> m_surface;
-    QWeakPointer<QVideoRendererControl> m_control;
-    QWeakPointer<QMediaService> m_service;
-    QWeakPointer<QMediaObject> m_object;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-
-#endif
diff --git a/src/multimedia/radio/qradiodata.cpp b/src/multimedia/radio/qradiodata.cpp
new file mode 100644
index 0000000..bb9032f
--- /dev/null
+++ b/src/multimedia/radio/qradiodata.cpp
@@ -0,0 +1,355 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qradiodata.h"
+#include "qmediaservice.h"
+#include "qmediaobject_p.h"
+#include "qradiodatacontrol.h"
+
+#include <QPair>
+
+
+QT_BEGIN_NAMESPACE
+
+
+namespace
+{
+    class QRadioDataPrivateRegisterMetaTypes
+    {
+    public:
+        QRadioDataPrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QRadioData::Error>();
+            qRegisterMetaType<QRadioData::ProgramType>();
+        }
+    } _registerMetaTypes;
+}
+
+/*!
+    \class QRadioData
+    \brief The QRadioData class provides interfaces to the RDS functionality of the system radio.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 5.0
+
+    The radio data object will emit signals for any changes in radio data. You can enable or disable
+    alternative frequency with setAlternativeFrequenciesEnabled().
+
+*/
+
+
+class QRadioDataPrivate : public QMediaObjectPrivate
+{
+public:
+    QRadioDataPrivate():provider(0), control(0) {}
+    QMediaServiceProvider *provider;
+    QRadioDataControl* control;
+};
+
+/*!
+    Constructs a radio data based on a media service allocated by a media service \a provider.
+
+    The \a parent is passed to QMediaObject.
+    \since 5.0
+*/
+
+QRadioData::QRadioData(QObject *parent, QMediaServiceProvider* provider):
+    QMediaObject(*new QRadioDataPrivate, parent, provider->requestService(Q_MEDIASERVICE_RADIO))
+{
+    Q_D(QRadioData);
+
+    d->provider = provider;
+
+    if (d->service != 0) {
+        d->control = qobject_cast<QRadioDataControl*>(d->service->requestControl(QRadioDataControl_iid));
+        if (d->control != 0) {
+            connect(d->control, SIGNAL(stationIdChanged(QString)), SIGNAL(stationIdChanged(QString)));
+            connect(d->control, SIGNAL(programTypeChanged(QRadioData::ProgramType)),
+                                SIGNAL(programTypeChanged(QRadioData::ProgramType)));
+            connect(d->control, SIGNAL(programTypeNameChanged(QString)), SIGNAL(programTypeNameChanged(QString)));
+            connect(d->control, SIGNAL(stationNameChanged(QString)), SIGNAL(stationNameChanged(QString)));
+            connect(d->control, SIGNAL(radioTextChanged(QString)), SIGNAL(radioTextChanged(QString)));
+            connect(d->control, SIGNAL(alternativeFrequenciesEnabledChanged(bool)), SIGNAL(alternativeFrequenciesEnabledChanged(bool)));
+            connect(d->control, SIGNAL(error(QRadioData::Error)), SIGNAL(error(QRadioData::Error)));
+        }
+    }
+}
+
+/*!
+    Destroys a radio data.
+*/
+
+QRadioData::~QRadioData()
+{
+    Q_D(QRadioData);
+
+    if (d->service && d->control)
+        d->service->releaseControl(d->control);
+
+    d->provider->releaseService(d->service);
+}
+
+/*!
+    Returns true if the radio data service is ready to use.
+    \since 5.0
+*/
+bool QRadioData::isAvailable() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d_func()->control->isAvailable();
+    else
+        return false;
+}
+
+/*!
+    Returns the availability error state.
+    \since 5.0
+*/
+QtMultimedia::AvailabilityError QRadioData::availabilityError() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d_func()->control->availabilityError();
+    else
+        return QtMultimedia::ServiceMissingError;
+}
+
+/*!
+    \property QRadioData::stationId
+    \brief Current Program Identification
+
+    \since 5.0
+*/
+
+QString QRadioData::stationId() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->stationId();
+    return QString();
+}
+
+/*!
+    \property QRadioData::programType
+    \brief Current Program Type
+
+    \since 5.0
+*/
+
+QRadioData::ProgramType QRadioData::programType() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->programType();
+
+    return QRadioData::Undefined;
+}
+
+/*!
+    \property QRadioData::programTypeName
+    \brief Current Program Type Name
+
+    \since 5.0
+*/
+
+QString QRadioData::programTypeName() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->programTypeName();
+    return QString();
+}
+
+/*!
+    \property QRadioData::stationName
+    \brief Current Program Service
+
+    \since 5.0
+*/
+
+QString QRadioData::stationName() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->stationName();
+    return QString();
+}
+
+/*!
+    \property QRadioData::radioText
+    \brief Current Radio Text
+
+    \since 5.0
+*/
+
+QString QRadioData::radioText() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->radioText();
+    return QString();
+}
+
+/*!
+    \property QRadioData::alternativeFrequenciesEnabled
+    \brief Is Alternative Frequency currently enabled
+
+    \since 5.0
+*/
+
+bool QRadioData::isAlternativeFrequenciesEnabled() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->isAlternativeFrequenciesEnabled();
+    return false;
+}
+
+void QRadioData::setAlternativeFrequenciesEnabled( bool enabled )
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->setAlternativeFrequenciesEnabled(enabled);
+}
+
+/*!
+    Returns the error state of a radio data.
+
+    \since 5.0
+    \sa errorString()
+*/
+
+QRadioData::Error QRadioData::error() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->error();
+    return QRadioData::ResourceError;
+}
+
+/*!
+    Returns a description of a radio data's error state.
+
+    \since 5.0
+    \sa error()
+*/
+QString QRadioData::errorString() const
+{
+    Q_D(const QRadioData);
+
+    if (d->control != 0)
+        return d->control->errorString();
+    return QString();
+}
+
+/*!
+    \fn void QRadioData::stationIdChanged(QString stationId)
+
+    Signals that the Program Identification code has changed to \a stationId
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioData::programTypeChanged(QRadioData::ProgramType programType)
+
+    Signals that the Program Type code has changed to \a programType
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioData::programTypeNameChanged(QString programTypeName)
+
+    Signals that the Program Type Name has changed to \a programTypeName
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioData::stationNameChanged(int stationName)
+
+    Signals that the Program Service has changed to \a stationName
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioData::alternativeFrequenciesEnabledChanged(bool enabled)
+
+    Signals that the AF has been enabled or disabled
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioData::error(QRadioData::Error error)
+
+    Signals that an \a error occurred.
+    \since 5.0
+*/
+
+/*!
+    \enum QRadioData::Error
+
+    Enumerates radio data error conditions.
+
+    \value NoError         No errors have occurred.
+    \value ResourceError   There is no radio service available.
+    \value OpenError       Unable to open radio device.
+    \value OutOfRangeError An attempt to set a frequency or band that is not supported by radio device.
+*/
+
+/*! \fn void QRadioData::stateChanged(QRadioData::State state)
+  This signal is emitted when the state changes to \a state.
+  \since 5.0
+ */
+
+#include "moc_qradiodata.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/radio/qradiodata.h b/src/multimedia/radio/qradiodata.h
new file mode 100644
index 0000000..71ae222
--- /dev/null
+++ b/src/multimedia/radio/qradiodata.h
@@ -0,0 +1,136 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QRADIODATA_H
+#define QRADIODATA_H
+
+#include <QtCore/qobject.h>
+
+#include "qmediaobject.h"
+#include "qmediaserviceprovider.h"
+#include <qmediaenumdebug.h>
+
+#include <QPair>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QRadioDataPrivate;
+class Q_MULTIMEDIA_EXPORT QRadioData : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QString stationId READ stationId NOTIFY stationIdChanged)
+    Q_PROPERTY(ProgramType programType READ programType NOTIFY programTypeChanged)
+    Q_PROPERTY(QString programTypeName READ programTypeName NOTIFY programTypeNameChanged)
+    Q_PROPERTY(QString stationName READ stationName NOTIFY stationNameChanged)
+    Q_PROPERTY(QString radioText READ radioText NOTIFY radioTextChanged)
+    Q_PROPERTY(bool alternativeFrequenciesEnabled READ isAlternativeFrequenciesEnabled
+               WRITE setAlternativeFrequenciesEnabled NOTIFY alternativeFrequenciesEnabledChanged)
+    Q_ENUMS(Error)
+    Q_ENUMS(ProgramType)
+
+public:
+    enum Error { NoError, ResourceError, OpenError, OutOfRangeError };
+
+    enum ProgramType { Undefined = 0, News, CurrentAffairs, Information,
+        Sport, Education, Drama, Culture, Science, Varied,
+        PopMusic, RockMusic, EasyListening, LightClassical,
+        SeriousClassical, OtherMusic, Weather, Finance,
+        ChildrensProgrammes, SocialAffairs, Religion,
+        PhoneIn, Travel, Leisure, JazzMusic, CountryMusic,
+        NationalMusic, OldiesMusic, FolkMusic, Documentary,
+        AlarmTest, Alarm, Talk, ClassicRock, AdultHits,
+        SoftRock, Top40, Soft, Nostalgia, Classical,
+        RhythmAndBlues, SoftRhythmAndBlues, Language,
+        ReligiousMusic, ReligiousTalk, Personality, Public,
+        College
+    };
+
+    QRadioData(QObject *parent = 0, QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider());
+    ~QRadioData();
+
+    bool isAvailable() const;
+    QtMultimedia::AvailabilityError availabilityError() const;
+
+    QString stationId() const;
+    ProgramType programType() const;
+    QString programTypeName() const;
+    QString stationName() const;
+    QString radioText() const;
+    bool isAlternativeFrequenciesEnabled() const;
+
+    Error error() const;
+    QString errorString() const;
+
+public Q_SLOTS:
+    void setAlternativeFrequenciesEnabled(bool enabled);
+
+Q_SIGNALS:
+    void stationIdChanged(QString stationId);
+    void programTypeChanged(QRadioData::ProgramType programType);
+    void programTypeNameChanged(QString programTypeName);
+    void stationNameChanged(QString stationName);
+    void radioTextChanged(QString radioText);
+    void alternativeFrequenciesEnabledChanged(bool enabled);
+
+    void error(QRadioData::Error error);
+
+private:
+
+    Q_DISABLE_COPY(QRadioData)
+    Q_DECLARE_PRIVATE(QRadioData)
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QRadioData::Error)
+Q_DECLARE_METATYPE(QRadioData::ProgramType)
+
+Q_MEDIA_ENUM_DEBUG(QRadioData, Error)
+Q_MEDIA_ENUM_DEBUG(QRadioData, ProgramType)
+
+QT_END_HEADER
+
+#endif  // QRADIOPLAYER_H
diff --git a/src/multimedia/radio/qradiotuner.cpp b/src/multimedia/radio/qradiotuner.cpp
new file mode 100644
index 0000000..66b0c70
--- /dev/null
+++ b/src/multimedia/radio/qradiotuner.cpp
@@ -0,0 +1,661 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qradiotuner.h"
+#include "qmediaservice.h"
+#include "qmediaobject_p.h"
+#include "qradiotunercontrol.h"
+
+#include <QPair>
+
+
+QT_BEGIN_NAMESPACE
+
+
+namespace
+{
+    class QRadioTunerPrivateRegisterMetaTypes
+    {
+    public:
+        QRadioTunerPrivateRegisterMetaTypes()
+        {
+            qRegisterMetaType<QRadioTuner::Band>();
+            qRegisterMetaType<QRadioTuner::Error>();
+            qRegisterMetaType<QRadioTuner::SearchMode>();
+            qRegisterMetaType<QRadioTuner::State>();
+            qRegisterMetaType<QRadioTuner::StereoMode>();
+        }
+    } _registerMetaTypes;
+}
+
+
+/*!
+    \class QRadioTuner
+    \brief The QRadioTuner class provides an interface to the systems analog radio device.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+    You can control the systems analog radio device using this interface, for example:
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Radio tuner
+
+    The radio object will emit signals for any changes in state such as:
+    bandChanged(), frequencyChanged(), stereoStatusChanged(), searchingChanged(),
+    signalStrengthChanged(), volumeChanged(), mutedChanged().
+
+    You can change between the frequency bands using setBand() however it is recommended
+    that you check to make sure the band is available first using isBandSupported().
+
+*/
+
+
+class QRadioTunerPrivate : public QMediaObjectPrivate
+{
+public:
+    QRadioTunerPrivate():provider(0), control(0) {}
+    QMediaServiceProvider *provider;
+    QRadioTunerControl* control;
+};
+
+
+
+/*!
+    Constructs a radio tuner based on a media service allocated by a media service \a provider.
+
+    The \a parent is passed to QMediaObject.
+    \since 1.0
+*/
+
+QRadioTuner::QRadioTuner(QObject *parent, QMediaServiceProvider* provider):
+    QMediaObject(*new QRadioTunerPrivate, parent, provider->requestService(Q_MEDIASERVICE_RADIO))
+{
+    Q_D(QRadioTuner);
+
+    d->provider = provider;
+
+    if (d->service != 0) {
+        d->control = qobject_cast<QRadioTunerControl*>(d->service->requestControl(QRadioTunerControl_iid));
+        if (d->control != 0) {
+            connect(d->control, SIGNAL(stateChanged(QRadioTuner::State)), SIGNAL(stateChanged(QRadioTuner::State)));
+            connect(d->control, SIGNAL(bandChanged(QRadioTuner::Band)), SIGNAL(bandChanged(QRadioTuner::Band)));
+            connect(d->control, SIGNAL(frequencyChanged(int)), SIGNAL(frequencyChanged(int)));
+            connect(d->control, SIGNAL(stereoStatusChanged(bool)), SIGNAL(stereoStatusChanged(bool)));
+            connect(d->control, SIGNAL(searchingChanged(bool)), SIGNAL(searchingChanged(bool)));
+            connect(d->control, SIGNAL(signalStrengthChanged(int)), SIGNAL(signalStrengthChanged(int)));
+            connect(d->control, SIGNAL(volumeChanged(int)), SIGNAL(volumeChanged(int)));
+            connect(d->control, SIGNAL(mutedChanged(bool)), SIGNAL(mutedChanged(bool)));
+            connect(d->control, SIGNAL(stationFound(int,QString)), SIGNAL(stationFound(int,QString)));
+            connect(d->control, SIGNAL(error(QRadioTuner::Error)), SIGNAL(error(QRadioTuner::Error)));
+        }
+    }
+}
+
+/*!
+    Destroys a radio tuner.
+*/
+
+QRadioTuner::~QRadioTuner()
+{
+    Q_D(QRadioTuner);
+
+    if (d->service && d->control)
+        d->service->releaseControl(d->control);
+
+    d->provider->releaseService(d->service);
+}
+
+/*!
+    Returns true if the radio tuner service is ready to use.
+    \since 1.0
+*/
+bool QRadioTuner::isAvailable() const
+{
+    if (d_func()->control != NULL)
+        return d_func()->control->isAvailable();
+    else
+        return false;
+}
+
+/*!
+    Returns the availability error state.
+    \since 1.0
+*/
+QtMultimedia::AvailabilityError QRadioTuner::availabilityError() const
+{
+    if (d_func()->control != NULL)
+        return d_func()->control->availabilityError();
+    else
+        return QtMultimedia::ServiceMissingError;
+}
+
+/*!
+    \property QRadioTuner::state
+    Return the current radio tuner state.
+
+    \since 1.0
+    \sa QRadioTuner::State
+*/
+
+QRadioTuner::State QRadioTuner::state() const
+{
+    return d_func()->control ?
+            d_func()->control->state() : QRadioTuner::StoppedState;
+}
+
+/*!
+    \property QRadioTuner::band
+    \brief the frequency band a radio tuner is tuned to.
+
+    \since 1.0
+    \sa QRadioTuner::Band
+*/
+
+QRadioTuner::Band QRadioTuner::band() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->band();
+
+    return QRadioTuner::FM;
+}
+
+/*!
+    \property QRadioTuner::frequency
+    \brief the frequency in Hertz a radio tuner is tuned to.
+    \since 1.0
+*/
+
+int QRadioTuner::frequency() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->frequency();
+
+    return 0;
+}
+
+/*!
+    Returns the number of Hertz to increment the frequency by when stepping through frequencies
+    within a given \a band.
+    \since 1.0
+*/
+
+int QRadioTuner::frequencyStep(QRadioTuner::Band band) const
+{
+    Q_D(const QRadioTuner);
+
+    if(d->control != 0)
+        return d->control->frequencyStep(band);
+
+    return 0;
+}
+
+/*!
+    Returns a frequency \a band's minimum and maximum frequency.
+    \since 1.0
+*/
+
+QPair<int,int> QRadioTuner::frequencyRange(QRadioTuner::Band band) const
+{
+    Q_D(const QRadioTuner);
+
+    if(d->control != 0)
+        return d->control->frequencyRange(band);
+
+    return qMakePair<int,int>(0,0);
+}
+
+/*!
+    \property QRadioTuner::stereo
+    \brief whether a radio tuner is receiving a stereo signal.
+    \since 1.0
+*/
+
+bool QRadioTuner::isStereo() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->isStereo();
+
+    return false;
+}
+
+
+/*!
+    \property QRadioTuner::stereoMode
+    \brief the stereo mode of a radio tuner.
+    \since 1.0
+*/
+
+QRadioTuner::StereoMode QRadioTuner::stereoMode() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->stereoMode();
+
+    return QRadioTuner::Auto;
+}
+
+void QRadioTuner::setStereoMode(QRadioTuner::StereoMode mode)
+{
+    Q_D(QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->setStereoMode(mode);
+}
+
+/*!
+    Identifies if a frequency \a band is supported by a radio tuner.
+
+    Returns true if the band is supported, and false if it is not.
+    \since 1.0
+*/
+
+bool QRadioTuner::isBandSupported(QRadioTuner::Band band) const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->isBandSupported(band);
+
+    return false;
+}
+
+/*!
+    Activate the radio device.
+    \since 1.0
+*/
+
+void QRadioTuner::start()
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        d->control->start();
+}
+
+/*!
+    Deactivate the radio device.
+    \since 1.0
+*/
+
+void QRadioTuner::stop()
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        d->control->stop();
+}
+
+/*!
+    \property QRadioTuner::signalStrength
+    \brief the strength of the current radio signal as a percentage.
+    \since 1.0
+*/
+
+int QRadioTuner::signalStrength() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->signalStrength();
+
+    return 0;
+}
+
+/*!
+    \property QRadioTuner::volume
+    \brief the volume of a radio tuner's audio output as a percentage.
+    \since 1.0
+*/
+
+
+int QRadioTuner::volume() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->volume();
+
+    return 0;
+}
+
+/*!
+    \property QRadioTuner::muted
+    \brief whether a radio tuner's audio output is muted.
+    \since 1.0
+*/
+
+bool QRadioTuner::isMuted() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->isMuted();
+
+    return false;
+}
+
+/*!
+    Sets a radio tuner's frequency \a band.
+
+    Changing the band will reset the \l frequency to the new band's minimum frequency.
+    \since 1.0
+*/
+
+void QRadioTuner::setBand(QRadioTuner::Band band)
+{
+    Q_D(QRadioTuner);
+
+    if (d->control != 0)
+        d->control->setBand(band);
+}
+
+/*!
+    Sets a radio tuner's \a frequency.
+
+    If the tuner is set to a frequency outside the current \l band, the band will be changed to
+    one occupied by the new frequency.
+    \since 1.0
+*/
+
+void QRadioTuner::setFrequency(int frequency)
+{
+    Q_D(QRadioTuner);
+
+    if (d->control != 0)
+        d->control->setFrequency(frequency);
+}
+
+void QRadioTuner::setVolume(int volume)
+{
+    Q_D(QRadioTuner);
+
+    if (d->control != 0)
+        d->control->setVolume(volume);
+}
+
+void QRadioTuner::setMuted(bool muted)
+{
+    Q_D(QRadioTuner);
+
+    if (d->control != 0)
+        d->control->setMuted(muted);
+}
+
+/*!
+    \property QRadioTuner::searching
+    \brief whether a radio tuner is currently scanning for a signal.
+
+    \sa searchForward(), searchBackward(), cancelSearch()
+    \since 1.0
+*/
+
+bool QRadioTuner::isSearching() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->isSearching();
+
+    return false;
+}
+
+/*!
+    Starts a forward scan for a signal, starting from the current \l frequency.
+
+    \since 1.0
+    \sa searchBackward(), cancelSearch(), searching
+*/
+
+void QRadioTuner::searchForward()
+{
+    Q_D(QRadioTuner);
+
+    if (d->control != 0)
+        d->control->searchForward();
+}
+
+/*!
+    Starts a backwards scan for a signal, starting from the current \l frequency.
+
+    \since 1.0
+    \sa searchForward(), cancelSearch(), searching
+*/
+
+void QRadioTuner::searchBackward()
+{
+    Q_D(QRadioTuner);
+
+    if (d->control != 0)
+        d->control->searchBackward();
+}
+
+/*!
+    Search all stations in current band
+
+    Emits QRadioTuner::stationFound(int, QString) for every found station.
+    After searching is completed, QRadioTuner::searchingChanged(bool) is
+    emitted (false). If \a searchMode is set to SearchGetStationId, searching
+    waits for station id (PI) on each frequency.
+
+    \since 5.0
+    \sa searchForward(), searchBackward(), searching
+*/
+
+void QRadioTuner::searchAllStations(QRadioTuner::SearchMode searchMode)
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        d->control->searchAllStations(searchMode);
+}
+
+/*!
+    Stops scanning for a signal.
+
+    \since 1.0
+    \sa searchForward(), searchBackward(), searching
+*/
+
+void QRadioTuner::cancelSearch()
+{
+    Q_D(QRadioTuner);
+
+    if (d->control != 0)
+        d->control->cancelSearch();
+}
+
+/*!
+    Returns the error state of a radio tuner.
+
+    \since 1.0
+    \sa errorString()
+*/
+
+QRadioTuner::Error QRadioTuner::error() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->error();
+
+    return QRadioTuner::ResourceError;
+}
+
+/*!
+    Returns a description of a radio tuner's error state.
+
+    \since 1.0
+    \sa error()
+*/
+
+QString QRadioTuner::errorString() const
+{
+    Q_D(const QRadioTuner);
+
+    if (d->control != 0)
+        return d->control->errorString();
+
+    return QString();
+}
+
+/*!
+    \fn void QRadioTuner::bandChanged(QRadioTuner::Band band)
+
+    Signals a radio tuner's \a band has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTuner::frequencyChanged(int frequency)
+
+    Signals that the \a frequency a radio tuner is tuned to has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTuner::mutedChanged(bool muted)
+
+    Signals that the \a muted state of a radio tuner's audio output has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTuner::volumeChanged(int volume)
+
+    Signals that the \a volume of a radio tuner's audio output has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTuner::searchingChanged(bool searching)
+
+    Signals that the \a searching state of a radio tuner has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTuner::stereoStatusChanged(bool stereo)
+
+    Signals that the \a stereo state of a radio tuner has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTuner::signalStrengthChanged(int strength)
+
+    Signals that the \a strength of the signal received by a radio tuner has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn void QRadioTuner::stationFound(int frequency, QString stationId)
+
+    Signals that a station was found in \a frequency with \a stationId Program
+    Identification code.
+    \since 5.0
+*/
+
+/*!
+    \fn void QRadioTuner::error(QRadioTuner::Error error)
+
+    Signals that an \a error occurred.
+    \since 1.0
+*/
+
+/*!
+    \enum QRadioTuner::State
+
+    Enumerates radio tuner states.
+
+    \value ActiveState The tuner is started and active.
+    \value StoppedState The tuner device is stopped.
+*/
+
+
+/*!
+    \enum QRadioTuner::Band
+
+    Enumerates radio frequency bands.
+
+    \value AM 520 to 1610 kHz, 9 or 10kHz channel spacing, extended 1610 to 1710 kHz
+    \value FM 87.5 to 108.0 MHz, except Japan 76-90 MHz
+    \value SW 1.711 to 30.0 MHz, divided into 15 bands. 5kHz channel spacing
+    \value LW 148.5 to 283.5 kHz, 9kHz channel spacing (Europe, Africa, Asia)
+    \value FM2 range not defined, used when area supports more than one FM range.
+*/
+
+/*!
+    \enum QRadioTuner::Error
+
+    Enumerates radio tuner error conditions.
+
+    \value NoError         No errors have occurred.
+    \value ResourceError   There is no radio service available.
+    \value OpenError       Unable to open radio device.
+    \value OutOfRangeError An attempt to set a frequency or band that is not supported by radio device.
+*/
+
+/*!
+    \enum QRadioTuner::StereoMode
+
+    Enumerates radio tuner policy for receiving stereo signals.
+
+    \value Auto        Uses the stereo mode matching the station.
+    \value ForceStereo Provide stereo mode, converting if required.
+    \value ForceMono   Provide mono mode, converting if required.
+*/
+
+/*! \fn void QRadioTuner::stateChanged(QRadioTuner::State state)
+  This signal is emitted when the state changes to \a state.
+  \since 1.0
+ */
+
+#include "moc_qradiotuner.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/radio/qradiotuner.h b/src/multimedia/radio/qradiotuner.h
new file mode 100644
index 0000000..21497f4
--- /dev/null
+++ b/src/multimedia/radio/qradiotuner.h
@@ -0,0 +1,165 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QRADIOTUNER_H
+#define QRADIOTUNER_H
+
+#include <QtCore/qobject.h>
+
+#include "qmediaobject.h"
+#include "qmediaserviceprovider.h"
+#include <qmediaenumdebug.h>
+
+#include <QPair>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QRadioTunerPrivate;
+class Q_MULTIMEDIA_EXPORT QRadioTuner : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(Band band READ band WRITE setBand NOTIFY bandChanged)
+    Q_PROPERTY(int frequency READ frequency WRITE setFrequency NOTIFY frequencyChanged)
+    Q_PROPERTY(bool stereo READ isStereo NOTIFY stereoStatusChanged)
+    Q_PROPERTY(StereoMode stereoMode READ stereoMode WRITE setStereoMode)
+    Q_PROPERTY(int signalStrength READ signalStrength NOTIFY signalStrengthChanged)
+    Q_PROPERTY(int volume READ volume WRITE setVolume NOTIFY volumeChanged)
+    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
+    Q_PROPERTY(bool searching READ isSearching NOTIFY searchingChanged)
+    Q_ENUMS(State)
+    Q_ENUMS(Band)
+    Q_ENUMS(Error)
+    Q_ENUMS(StereoMode)
+    Q_ENUMS(SearchMode)
+
+public:
+    enum State { ActiveState, StoppedState };
+    enum Band { AM, FM, SW, LW, FM2 };
+    enum Error { NoError, ResourceError, OpenError, OutOfRangeError };
+    enum StereoMode { ForceStereo, ForceMono, Auto };
+    enum SearchMode { SearchFast, SearchGetStationId };
+
+    QRadioTuner(QObject *parent = 0, QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider());
+    ~QRadioTuner();
+
+    bool isAvailable() const;
+    QtMultimedia::AvailabilityError availabilityError() const;
+
+    State state() const;
+
+    Band band() const;
+
+    bool isBandSupported(Band b) const;
+
+    int frequency() const;
+    int frequencyStep(Band band) const;
+    QPair<int,int> frequencyRange(Band band) const;
+
+    bool isStereo() const;
+    void setStereoMode(QRadioTuner::StereoMode mode);
+    StereoMode stereoMode() const;
+
+    int signalStrength() const;
+
+    int volume() const;
+    bool isMuted() const;
+
+    bool isSearching() const;
+
+    Error error() const;
+    QString errorString() const;
+
+public Q_SLOTS:
+    void searchForward();
+    void searchBackward();
+    void searchAllStations(QRadioTuner::SearchMode searchMode = QRadioTuner::SearchFast);
+    void cancelSearch();
+
+    void setBand(Band band);
+    void setFrequency(int frequency);
+
+    void setVolume(int volume);
+    void setMuted(bool muted);
+
+    void start();
+    void stop();
+
+Q_SIGNALS:
+    void stateChanged(QRadioTuner::State state);
+    void bandChanged(QRadioTuner::Band band);
+    void frequencyChanged(int frequency);
+    void stereoStatusChanged(bool stereo);
+    void searchingChanged(bool searching);
+    void signalStrengthChanged(int signalStrength);
+    void volumeChanged(int volume);
+    void mutedChanged(bool muted);
+    void stationFound(int frequency, QString stationId);
+
+    void error(QRadioTuner::Error error);
+
+private:
+    Q_DISABLE_COPY(QRadioTuner)
+    Q_DECLARE_PRIVATE(QRadioTuner)
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QRadioTuner::State)
+Q_DECLARE_METATYPE(QRadioTuner::Band)
+Q_DECLARE_METATYPE(QRadioTuner::Error)
+Q_DECLARE_METATYPE(QRadioTuner::StereoMode)
+Q_DECLARE_METATYPE(QRadioTuner::SearchMode)
+
+Q_MEDIA_ENUM_DEBUG(QRadioTuner, State)
+Q_MEDIA_ENUM_DEBUG(QRadioTuner, Band)
+Q_MEDIA_ENUM_DEBUG(QRadioTuner, Error)
+Q_MEDIA_ENUM_DEBUG(QRadioTuner, StereoMode)
+Q_MEDIA_ENUM_DEBUG(QRadioTuner, SearchMode)
+
+QT_END_HEADER
+
+#endif  // QRADIOPLAYER_H
diff --git a/src/multimedia/radio/radio.pri b/src/multimedia/radio/radio.pri
new file mode 100644
index 0000000..41e43fa
--- /dev/null
+++ b/src/multimedia/radio/radio.pri
@@ -0,0 +1,9 @@
+INCLUDEPATH += radio
+
+PUBLIC_HEADERS += \
+    radio/qradiodata.h \
+    radio/qradiotuner.h
+
+SOURCES += \
+    radio/qradiodata.cpp \
+    radio/qradiotuner.cpp
diff --git a/src/multimedia/recording/qaudiocapturesource.cpp b/src/multimedia/recording/qaudiocapturesource.cpp
new file mode 100644
index 0000000..4696171
--- /dev/null
+++ b/src/multimedia/recording/qaudiocapturesource.cpp
@@ -0,0 +1,275 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaobject_p.h"
+#include <qaudiocapturesource.h>
+#include "qaudioendpointselector.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QAudioCaptureSource
+    \brief The QAudioCaptureSource class provides an interface to query and select an audio input endpoint.
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+    QAudioCaptureSource provides access to the audio inputs available on your system.
+
+    You can query these inputs and select one to use.
+
+    A typical implementation example:
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio capture source
+
+    The audiocapturesource interface is then used to:
+
+    - Get and Set the audio input to use.
+
+    The capture interface is then used to:
+
+    - Set the destination using setOutputLocation()
+
+    - Set the format parameters using setAudioCodec(),
+
+    - Control the recording using record(),stop()
+
+    \sa QMediaRecorder
+*/
+
+class QAudioCaptureSourcePrivate : public QMediaObjectPrivate
+{
+public:
+    Q_DECLARE_PUBLIC(QAudioCaptureSource)
+
+    void initControls()
+    {
+        Q_Q(QAudioCaptureSource);
+
+        if (service != 0)
+            audioEndpointSelector = qobject_cast<QAudioEndpointSelector*>(service->requestControl(QAudioEndpointSelector_iid));
+
+        if (audioEndpointSelector) {
+            q->connect(audioEndpointSelector, SIGNAL(activeEndpointChanged(const QString&)),
+                       SIGNAL(activeAudioInputChanged(const QString&)));
+            q->connect(audioEndpointSelector, SIGNAL(availableEndpointsChanged()),
+                       SIGNAL(availableAudioInputsChanged()));
+            q->connect(audioEndpointSelector, SIGNAL(availableEndpointsChanged()),
+                       SLOT(statusChanged()));
+            errorState = QtMultimedia::NoError;
+        }
+    }
+
+    QAudioCaptureSourcePrivate():provider(0), audioEndpointSelector(0), errorState(QtMultimedia::ServiceMissingError) {}
+    QMediaServiceProvider *provider;
+    QAudioEndpointSelector   *audioEndpointSelector;
+    QtMultimedia::AvailabilityError errorState;
+};
+
+/*!
+    Construct a QAudioCaptureSource using the QMediaService from \a provider, with \a parent.
+    \since 1.0
+*/
+
+QAudioCaptureSource::QAudioCaptureSource(QObject *parent, QMediaServiceProvider *provider):
+    QMediaObject(*new QAudioCaptureSourcePrivate, parent, provider->requestService(Q_MEDIASERVICE_AUDIOSOURCE))
+{
+    Q_D(QAudioCaptureSource);
+
+    d->provider = provider;
+    d->initControls();
+}
+
+/*!
+    Destroys the audiocapturesource object.
+*/
+
+QAudioCaptureSource::~QAudioCaptureSource()
+{
+    Q_D(QAudioCaptureSource);
+
+    if (d->service && d->audioEndpointSelector)
+        d->service->releaseControl(d->audioEndpointSelector);
+
+    if (d->provider)
+        d->provider->releaseService(d->service);
+}
+
+/*!
+    Returns the error state of the audio capture service.
+    \since 1.0
+*/
+
+QtMultimedia::AvailabilityError QAudioCaptureSource::availabilityError() const
+{
+    Q_D(const QAudioCaptureSource);
+
+    return d->errorState;
+}
+
+/*!
+    Returns true if the audio capture service is available, otherwise returns false.
+    \since 1.0
+*/
+bool QAudioCaptureSource::isAvailable() const
+{
+    Q_D(const QAudioCaptureSource);
+
+    if (d->service != NULL) {
+        if (d->audioEndpointSelector && d->audioEndpointSelector->availableEndpoints().size() > 0)
+            return true;
+    }
+    return false;
+}
+
+
+/*!
+    Returns a list of available audio inputs
+    \since 1.0
+*/
+
+QList<QString> QAudioCaptureSource::audioInputs() const
+{
+    Q_D(const QAudioCaptureSource);
+
+    QList<QString> list;
+    if (d && d->audioEndpointSelector)
+        list <<d->audioEndpointSelector->availableEndpoints();
+
+    return list;
+}
+
+/*!
+    Returns the description of the audio input device with \a name.
+    \since 1.0
+*/
+
+QString QAudioCaptureSource::audioDescription(const QString& name) const
+{
+    Q_D(const QAudioCaptureSource);
+
+    if(d->audioEndpointSelector)
+        return d->audioEndpointSelector->endpointDescription(name);
+    else
+        return QString();
+}
+
+/*!
+    Returns the default audio input name.
+    \since 1.0
+*/
+
+QString QAudioCaptureSource::defaultAudioInput() const
+{
+    Q_D(const QAudioCaptureSource);
+
+    if(d->audioEndpointSelector)
+        return d->audioEndpointSelector->defaultEndpoint();
+    else
+        return QString();
+}
+
+/*!
+    Returns the active audio input name.
+    \since 1.0
+*/
+
+QString QAudioCaptureSource::activeAudioInput() const
+{
+    Q_D(const QAudioCaptureSource);
+
+    if(d->audioEndpointSelector)
+        return d->audioEndpointSelector->activeEndpoint();
+    else
+        return QString();
+}
+
+/*!
+    Set the active audio input to \a name.
+    \since 1.0
+*/
+
+void QAudioCaptureSource::setAudioInput(const QString& name)
+{
+    Q_D(const QAudioCaptureSource);
+
+    if(d->audioEndpointSelector)
+        return d->audioEndpointSelector->setActiveEndpoint(name);
+}
+
+/*!
+    \fn QAudioCaptureSource::activeAudioInputChanged(const QString& name)
+
+    Signal emitted when active audio input changes to \a name.
+    \since 1.0
+*/
+
+/*!
+    \fn QAudioCaptureSource::availableAudioInputsChanged()
+
+    Signal is emitted when the available audio inputs change.
+    \since 1.0
+*/
+
+/*!
+  \internal
+  \since 1.0
+*/
+void QAudioCaptureSource::statusChanged()
+{
+    Q_D(QAudioCaptureSource);
+
+    if (d->audioEndpointSelector) {
+        if (d->audioEndpointSelector->availableEndpoints().size() > 0) {
+            d->errorState = QtMultimedia::NoError;
+            emit availabilityChanged(true);
+        } else {
+            d->errorState = QtMultimedia::BusyError;
+            emit availabilityChanged(false);
+        }
+    } else {
+        d->errorState = QtMultimedia::ServiceMissingError;
+        emit availabilityChanged(false);
+    }
+}
+
+#include "moc_qaudiocapturesource.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/recording/qaudiocapturesource.h b/src/multimedia/recording/qaudiocapturesource.h
new file mode 100644
index 0000000..1571b4e
--- /dev/null
+++ b/src/multimedia/recording/qaudiocapturesource.h
@@ -0,0 +1,103 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAUDIOCAPTURESOURCE_H
+#define QAUDIOCAPTURESOURCE_H
+
+#include <QtCore/qstringlist.h>
+#include <QtCore/qpair.h>
+#include <QtCore/qsize.h>
+
+#include <qaudioformat.h>
+
+#include "qmediarecorder.h"
+#include "qmediacontrol.h"
+#include "qmediaobject.h"
+#include "qmediaservice.h"
+
+#include "qmediaserviceprovider.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QAudioCaptureSourcePrivate;
+
+class Q_MULTIMEDIA_EXPORT QAudioCaptureSource : public QMediaObject
+{
+    Q_OBJECT
+
+public:
+    QAudioCaptureSource(QObject *parent = 0, QMediaServiceProvider *service = QMediaServiceProvider::defaultServiceProvider());
+    ~QAudioCaptureSource();
+
+    bool isAvailable() const;
+    QtMultimedia::AvailabilityError availabilityError() const;
+
+    QList<QString> audioInputs() const;
+
+    QString audioDescription(const QString& name) const;
+    QString defaultAudioInput() const;
+    QString activeAudioInput() const;
+
+public Q_SLOTS:
+    void setAudioInput(const QString& name);
+
+Q_SIGNALS:
+    void activeAudioInputChanged(const QString& name);
+    void availableAudioInputsChanged();
+
+private Q_SLOTS:
+    void statusChanged();
+
+private:
+    Q_DECLARE_PRIVATE(QAudioCaptureSource)
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif  // QAUDIOCAPTURESOURCE_H
diff --git a/src/multimedia/recording/qmediaencodersettings.cpp b/src/multimedia/recording/qmediaencodersettings.cpp
new file mode 100644
index 0000000..5f85eec
--- /dev/null
+++ b/src/multimedia/recording/qmediaencodersettings.cpp
@@ -0,0 +1,822 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediaencodersettings.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAudioEncoderSettingsPrivate  : public QSharedData
+{
+public:
+    QAudioEncoderSettingsPrivate() :
+        isNull(true),
+        encodingMode(QtMultimedia::ConstantQualityEncoding),
+        bitrate(-1),
+        sampleRate(-1),
+        channels(-1),
+        quality(QtMultimedia::NormalQuality)
+    {
+    }
+
+    QAudioEncoderSettingsPrivate(const QAudioEncoderSettingsPrivate &other):
+        QSharedData(other),
+        isNull(other.isNull),
+        encodingMode(other.encodingMode),
+        codec(other.codec),
+        bitrate(other.bitrate),
+        sampleRate(other.sampleRate),
+        channels(other.channels),
+        quality(other.quality)
+    {
+    }
+
+    bool isNull;
+    QtMultimedia::EncodingMode encodingMode;
+    QString codec;
+    int bitrate;
+    int sampleRate;
+    int channels;
+    QtMultimedia::EncodingQuality quality;
+
+private:
+    QAudioEncoderSettingsPrivate& operator=(const QAudioEncoderSettingsPrivate &other);
+};
+
+/*!
+    \class QAudioEncoderSettings
+
+    \brief The QAudioEncoderSettings class provides a set of audio encoder settings.
+
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+    A audio encoder settings object is used to specify the audio encoder
+    settings used by QMediaRecorder.  Audio encoder settings are selected by
+    constructing a QAudioEncoderSettings object, setting the desired properties
+    and then passing it to a QMediaRecorder instance using the
+    QMediaRecorder::setEncodingSettings() function.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Audio encoder settings
+
+    \sa QMediaRecorder, QAudioEncoderControl
+*/
+
+/*!
+    Construct a null audio encoder settings object.
+*/
+QAudioEncoderSettings::QAudioEncoderSettings()
+    :d(new QAudioEncoderSettingsPrivate)
+{
+}
+
+/*!
+    Constructs a copy of the audio encoder settings object \a other.
+    \since 1.0
+*/
+
+QAudioEncoderSettings::QAudioEncoderSettings(const QAudioEncoderSettings& other)
+    :d(other.d)
+{
+}
+
+/*!
+    Destroys an audio encoder settings object.
+*/
+
+QAudioEncoderSettings::~QAudioEncoderSettings()
+{
+}
+
+/*!
+    Assigns the value of \a other to an audio encoder settings object.
+    \since 1.0
+*/
+
+QAudioEncoderSettings& QAudioEncoderSettings::operator=(const QAudioEncoderSettings &other)
+{
+    d = other.d;
+    return *this;
+}
+
+/*!
+    Determines if \a other is of equal value to an audio encoder settings
+    object.
+
+    Returns true if the settings objects are of equal value, and false if they
+    are not of equal value.
+    \since 1.0
+*/
+
+bool QAudioEncoderSettings::operator==(const QAudioEncoderSettings &other) const
+{
+    return (d == other.d) ||
+           (d->isNull == other.d->isNull &&
+            d->encodingMode == other.d->encodingMode &&
+            d->bitrate == other.d->bitrate &&
+            d->sampleRate == other.d->sampleRate &&
+            d->channels == other.d->channels &&
+            d->quality == other.d->quality &&
+            d->codec == other.d->codec);
+}
+
+/*!
+    Determines if \a other is of equal value to an audio encoder settings
+    object.
+
+    Returns true if the settings objects are not of equal value, and true if
+    they are of equal value.
+    \since 1.0
+*/
+
+bool QAudioEncoderSettings::operator!=(const QAudioEncoderSettings &other) const
+{
+    return !(*this == other);
+}
+
+/*!
+    Identifies if an audio settings object is initialized.
+
+    Returns true if the settings object is null, and false if it is not.
+    \since 1.0
+*/
+
+bool QAudioEncoderSettings::isNull() const
+{
+    return d->isNull;
+}
+
+/*!
+    Returns the audio encoding mode.
+
+    \since 1.0
+    \sa QtMultimedia::EncodingMode
+*/
+QtMultimedia::EncodingMode QAudioEncoderSettings::encodingMode() const
+{
+    return d->encodingMode;
+}
+
+/*!
+    Sets the audio encoding \a mode setting.
+
+    If QtMultimedia::ConstantQualityEncoding is set, the quality
+    encoding parameter is used and bit rate is ignored,
+    otherwise the bitrate is used.
+
+    The audio codec, channels count and sample rate settings are used in all
+    the encoding modes.
+
+    \since 1.0
+    \sa encodingMode(), QtMultimedia::EncodingMode
+*/
+void QAudioEncoderSettings::setEncodingMode(QtMultimedia::EncodingMode mode)
+{
+    d->encodingMode = mode;
+}
+
+/*!
+    Returns the audio codec.
+    \since 1.0
+*/
+QString QAudioEncoderSettings::codec() const
+{
+    return d->codec;
+}
+
+/*!
+    Sets the audio \a codec.
+    \since 1.0
+*/
+void QAudioEncoderSettings::setCodec(const QString& codec)
+{
+    d->isNull = false;
+    d->codec = codec;
+}
+
+/*!
+    Returns the bit rate of the compressed audio stream in bits per second.
+    \since 1.0
+*/
+int QAudioEncoderSettings::bitRate() const
+{
+    return d->bitrate;
+}
+
+/*!
+    Returns the number of audio channels.
+    \since 1.0
+*/
+int QAudioEncoderSettings::channelCount() const
+{
+    return d->channels;
+}
+
+/*!
+    Sets the number of audio \a channels.
+
+    A value of -1 indicates the encoder should make an optimal choice based on
+    what is available from the audio source and the limitations of the codec.
+    \since 1.0
+*/
+void QAudioEncoderSettings::setChannelCount(int channels)
+{
+    d->isNull = false;
+    d->channels = channels;
+}
+
+/*!
+    Sets the audio bit \a rate in bits per second.
+    \since 1.0
+*/
+void QAudioEncoderSettings::setBitRate(int rate)
+{
+    d->isNull = false;
+    d->bitrate = rate;
+}
+
+/*!
+    Returns the audio sample rate in Hz.
+    \since 1.0
+*/
+int QAudioEncoderSettings::sampleRate() const
+{
+    return d->sampleRate;
+}
+
+/*!
+    Sets the audio sample \a rate in Hz.
+
+    A value of -1 indicates the encoder should make an optimal choice based on what is avaialbe
+    from the audio source and the limitations of the codec.
+    \since 1.0
+  */
+void QAudioEncoderSettings::setSampleRate(int rate)
+{
+    d->isNull = false;
+    d->sampleRate = rate;
+}
+
+/*!
+    Returns the audio encoding quality.
+    \since 1.0
+*/
+
+QtMultimedia::EncodingQuality QAudioEncoderSettings::quality() const
+{
+    return d->quality;
+}
+
+/*!
+    Set the audio encoding \a quality.
+
+    Setting the audio quality parameter allows backend to choose the balanced
+    set of encoding parameters to achieve the desired quality level.
+
+    The \a quality settings parameter is only used in the
+    \l {QtMultimedia::ConstantQualityEncoding}{constant quality} \l{encodingMode()}{encoding mode}.
+    \since 1.0
+*/
+void QAudioEncoderSettings::setQuality(QtMultimedia::EncodingQuality quality)
+{
+    d->isNull = false;
+    d->quality = quality;
+}
+
+class QVideoEncoderSettingsPrivate  : public QSharedData
+{
+public:
+    QVideoEncoderSettingsPrivate() :
+        isNull(true),
+        encodingMode(QtMultimedia::ConstantQualityEncoding),
+        bitrate(-1),
+        frameRate(0),
+        quality(QtMultimedia::NormalQuality)
+    {
+    }
+
+    QVideoEncoderSettingsPrivate(const QVideoEncoderSettingsPrivate &other):
+        QSharedData(other),
+        isNull(other.isNull),
+        encodingMode(other.encodingMode),
+        codec(other.codec),
+        bitrate(other.bitrate),
+        resolution(other.resolution),
+        frameRate(other.frameRate),
+        quality(other.quality)
+    {
+    }
+
+    bool isNull;
+    QtMultimedia::EncodingMode encodingMode;
+    QString codec;
+    int bitrate;
+    QSize resolution;
+    qreal frameRate;
+    QtMultimedia::EncodingQuality quality;
+
+private:
+    QVideoEncoderSettingsPrivate& operator=(const QVideoEncoderSettingsPrivate &other);
+};
+
+/*!
+    \class QVideoEncoderSettings
+
+    \brief The QVideoEncoderSettings class provides a set of video encoder settings.
+    \since 1.0
+
+    A video encoder settings object is used to specify the video encoder
+    settings used by QMediaRecorder.  Video encoder settings are selected by
+    constructing a QVideoEncoderSettings object, setting the desired properties
+    and then passing it to a QMediaRecorder instance using the
+    QMediaRecorder::setEncodingSettings() function.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Video encoder settings
+
+    \sa QMediaRecorder, QVideoEncoderControl
+*/
+
+/*!
+    Constructs a null video encoder settings object.
+*/
+
+QVideoEncoderSettings::QVideoEncoderSettings()
+    :d(new QVideoEncoderSettingsPrivate)
+{
+}
+
+/*!
+    Constructs a copy of the video encoder settings object \a other.
+    \since 1.0
+*/
+
+QVideoEncoderSettings::QVideoEncoderSettings(const QVideoEncoderSettings& other)
+    :d(other.d)
+{
+}
+
+/*!
+    Destroys a video encoder settings object.
+*/
+
+QVideoEncoderSettings::~QVideoEncoderSettings()
+{
+}
+
+/*!
+    Assigns the value of \a other to a video encoder settings object.
+    \since 1.0
+*/
+QVideoEncoderSettings &QVideoEncoderSettings::operator=(const QVideoEncoderSettings &other)
+{
+    d = other.d;
+    return *this;
+}
+
+/*!
+    Determines if \a other is of equal value to a video encoder settings object.
+
+    Returns true if the settings objects are of equal value, and false if they
+    are not of equal value.
+    \since 1.0
+*/
+bool QVideoEncoderSettings::operator==(const QVideoEncoderSettings &other) const
+{
+    return (d == other.d) ||
+           (d->isNull == other.d->isNull &&
+            d->encodingMode == other.d->encodingMode &&
+            d->bitrate == other.d->bitrate &&
+            d->quality == other.d->quality &&
+            d->codec == other.d->codec &&
+            d->resolution == other.d->resolution &&
+            qFuzzyCompare(d->frameRate, other.d->frameRate));
+}
+
+/*!
+    Determines if \a other is of equal value to a video encoder settings object.
+
+    Returns true if the settings objects are not of equal value, and false if
+    they are of equal value.
+    \since 1.0
+*/
+bool QVideoEncoderSettings::operator!=(const QVideoEncoderSettings &other) const
+{
+    return !(*this == other);
+}
+
+/*!
+    Identifies if a video encoder settings object is uninitalized.
+
+    Returns true if the settings are null, and false if they are not.
+    \since 1.0
+*/
+bool QVideoEncoderSettings::isNull() const
+{
+    return d->isNull;
+}
+
+/*!
+    Returns the video encoding mode.
+
+    \since 1.0
+    \sa QtMultimedia::EncodingMode
+*/
+QtMultimedia::EncodingMode QVideoEncoderSettings::encodingMode() const
+{
+    return d->encodingMode;
+}
+
+/*!
+    Sets the video encoding \a mode.
+
+    If QtMultimedia::ConstantQualityEncoding is set,
+    the quality encoding parameter is used and bit rate is ignored,
+    otherwise the bitrate is used.
+
+    The rest of encoding settings are respected regardless of encoding mode.
+
+    \since 1.0
+    \sa QtMultimedia::EncodingMode
+*/
+void QVideoEncoderSettings::setEncodingMode(QtMultimedia::EncodingMode mode)
+{
+    d->isNull = false;
+    d->encodingMode = mode;
+}
+
+/*!
+    Returns the video codec.
+    \since 1.0
+*/
+
+QString QVideoEncoderSettings::codec() const
+{
+    return d->codec;
+}
+
+/*!
+    Sets the video \a codec.
+    \since 1.0
+*/
+void QVideoEncoderSettings::setCodec(const QString& codec)
+{
+    d->isNull = false;
+    d->codec = codec;
+}
+
+/*!
+    Returns bit rate of the encoded video stream in bits per second.
+    \since 1.0
+*/
+int QVideoEncoderSettings::bitRate() const
+{
+    return d->bitrate;
+}
+
+/*!
+    Sets the bit rate of the encoded video stream to \a value.
+    \since 1.0
+*/
+
+void QVideoEncoderSettings::setBitRate(int value)
+{
+    d->isNull = false;
+    d->bitrate = value;
+}
+
+/*!
+    Returns the video frame rate.
+    \since 1.0
+*/
+qreal QVideoEncoderSettings::frameRate() const
+{
+    return d->frameRate;
+}
+
+/*!
+    \fn QVideoEncoderSettings::setFrameRate(qreal rate)
+
+    Sets the video frame \a rate.
+
+    A value of 0 indicates the encoder should make an optimal choice based on what is available
+    from the video source and the limitations of the codec.
+    \since 1.0
+*/
+
+void QVideoEncoderSettings::setFrameRate(qreal rate)
+{
+    d->isNull = false;
+    d->frameRate = rate;
+}
+
+/*!
+    Returns the resolution of the encoded video.
+    \since 1.0
+*/
+
+QSize QVideoEncoderSettings::resolution() const
+{
+    return d->resolution;
+}
+
+/*!
+    Sets the \a resolution of the encoded video.
+
+    An empty QSize indicates the encoder should make an optimal choice based on
+    what is available from the video source and the limitations of the codec.
+    \since 1.0
+*/
+
+void QVideoEncoderSettings::setResolution(const QSize &resolution)
+{
+    d->isNull = false;
+    d->resolution = resolution;
+}
+
+/*!
+    Sets the \a width and \a height of the resolution of the encoded video.
+
+    \overload
+    \since 1.0
+*/
+
+void QVideoEncoderSettings::setResolution(int width, int height)
+{
+    d->isNull = false;
+    d->resolution = QSize(width, height);
+}
+
+/*!
+    Returns the video encoding quality.
+    \since 1.0
+*/
+
+QtMultimedia::EncodingQuality QVideoEncoderSettings::quality() const
+{
+    return d->quality;
+}
+
+/*!
+    Sets the video encoding \a quality.
+
+    Setting the video quality parameter allows backend to choose the balanced
+    set of encoding parameters to achieve the desired quality level.
+
+    The \a quality settings parameter is only used in the
+    \l {QtMultimedia::ConstantQualityEncoding}{constant quality} \l{encodingMode()}{encoding mode}.
+    The \a quality settings parameter is only used in the \l
+    {QtMultimedia::ConstantQualityEncoding}{constant quality}
+    \l{encodingMode()}{encoding mode}.
+    \since 1.0
+*/
+
+void QVideoEncoderSettings::setQuality(QtMultimedia::EncodingQuality quality)
+{
+    d->isNull = false;
+    d->quality = quality;
+}
+
+
+
+class QImageEncoderSettingsPrivate  : public QSharedData
+{
+public:
+    QImageEncoderSettingsPrivate() :
+        isNull(true),
+        quality(QtMultimedia::NormalQuality)
+    {
+    }
+
+    QImageEncoderSettingsPrivate(const QImageEncoderSettingsPrivate &other):
+        QSharedData(other),
+        isNull(other.isNull),
+        codec(other.codec),
+        resolution(other.resolution),
+        quality(other.quality)
+    {
+    }
+
+    bool isNull;
+    QString codec;
+    QSize resolution;
+    QtMultimedia::EncodingQuality quality;
+
+private:
+    QImageEncoderSettingsPrivate& operator=(const QImageEncoderSettingsPrivate &other);
+};
+
+/*!
+    \class QImageEncoderSettings
+
+
+    \brief The QImageEncoderSettings class provides a set of image encoder
+    settings.
+    \since 1.0
+
+    A image encoder settings object is used to specify the image encoder
+    settings used by QCameraImageCapture.  Image encoder settings are selected
+    by constructing a QImageEncoderSettings object, setting the desired
+    properties and then passing it to a QCameraImageCapture instance using the
+    QCameraImageCapture::setImageSettings() function.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Image encoder settings
+
+    \sa QImageEncoderControl
+*/
+
+/*!
+    Constructs a null image encoder settings object.
+*/
+
+QImageEncoderSettings::QImageEncoderSettings()
+    :d(new QImageEncoderSettingsPrivate)
+{
+}
+
+/*!
+    Constructs a copy of the image encoder settings object \a other.
+    \since 1.0
+*/
+
+QImageEncoderSettings::QImageEncoderSettings(const QImageEncoderSettings& other)
+    :d(other.d)
+{
+}
+
+/*!
+    Destroys a image encoder settings object.
+*/
+
+QImageEncoderSettings::~QImageEncoderSettings()
+{
+}
+
+/*!
+    Assigns the value of \a other to a image encoder settings object.
+    \since 1.0
+*/
+QImageEncoderSettings &QImageEncoderSettings::operator=(const QImageEncoderSettings &other)
+{
+    d = other.d;
+    return *this;
+}
+
+/*!
+    Determines if \a other is of equal value to a image encoder settings
+    object.
+
+    Returns true if the settings objects are of equal value, and false if they
+    are not of equal value.
+    \since 1.0
+*/
+bool QImageEncoderSettings::operator==(const QImageEncoderSettings &other) const
+{
+    return (d == other.d) ||
+           (d->isNull == other.d->isNull &&
+            d->quality == other.d->quality &&
+            d->codec == other.d->codec &&
+            d->resolution == other.d->resolution);
+
+}
+
+/*!
+    Determines if \a other is of equal value to a image encoder settings
+    object.
+
+    Returns true if the settings objects are not of equal value, and false if
+    they are of equal value.
+    \since 1.0
+*/
+bool QImageEncoderSettings::operator!=(const QImageEncoderSettings &other) const
+{
+    return !(*this == other);
+}
+
+/*!
+    Identifies if a image encoder settings object is uninitalized.
+
+    Returns true if the settings are null, and false if they are not.
+    \since 1.0
+*/
+bool QImageEncoderSettings::isNull() const
+{
+    return d->isNull;
+}
+
+/*!
+    Returns the image codec.
+    \since 1.0
+*/
+
+QString QImageEncoderSettings::codec() const
+{
+    return d->codec;
+}
+
+/*!
+    Sets the image \a codec.
+    \since 1.0
+*/
+void QImageEncoderSettings::setCodec(const QString& codec)
+{
+    d->isNull = false;
+    d->codec = codec;
+}
+
+/*!
+    Returns the resolution of the encoded image.
+    \since 1.0
+*/
+
+QSize QImageEncoderSettings::resolution() const
+{
+    return d->resolution;
+}
+
+/*!
+    Sets the \a resolution of the encoded image.
+
+    An empty QSize indicates the encoder should make an optimal choice based on
+    what is available from the image source and the limitations of the codec.
+    \since 1.0
+*/
+
+void QImageEncoderSettings::setResolution(const QSize &resolution)
+{
+    d->isNull = false;
+    d->resolution = resolution;
+}
+
+/*!
+    Sets the \a width and \a height of the resolution of the encoded image.
+
+    \overload
+    \since 1.0
+*/
+
+void QImageEncoderSettings::setResolution(int width, int height)
+{
+    d->isNull = false;
+    d->resolution = QSize(width, height);
+}
+
+/*!
+    Returns the image encoding quality.
+    \since 1.0
+*/
+
+QtMultimedia::EncodingQuality QImageEncoderSettings::quality() const
+{
+    return d->quality;
+}
+
+/*!
+    Sets the image encoding \a quality.
+    \since 1.0
+*/
+
+void QImageEncoderSettings::setQuality(QtMultimedia::EncodingQuality quality)
+{
+    d->isNull = false;
+    d->quality = quality;
+}
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/recording/qmediaencodersettings.h b/src/multimedia/recording/qmediaencodersettings.h
new file mode 100644
index 0000000..28bf6d6
--- /dev/null
+++ b/src/multimedia/recording/qmediaencodersettings.h
@@ -0,0 +1,168 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIAENCODERSETTINGS_H
+#define QMEDIAENCODERSETTINGS_H
+
+#include <QtCore/qsharedpointer.h>
+#include <QtCore/qstring.h>
+#include <QtCore/qsize.h>
+#include <qtmultimediadefs.h>
+#include "qtmedianamespace.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+
+class QAudioEncoderSettingsPrivate;
+class Q_MULTIMEDIA_EXPORT QAudioEncoderSettings
+{
+public:
+    QAudioEncoderSettings();
+    QAudioEncoderSettings(const QAudioEncoderSettings& other);
+
+    ~QAudioEncoderSettings();
+
+    QAudioEncoderSettings& operator=(const QAudioEncoderSettings &other);
+    bool operator==(const QAudioEncoderSettings &other) const;
+    bool operator!=(const QAudioEncoderSettings &other) const;
+
+    bool isNull() const;
+
+    QtMultimedia::EncodingMode encodingMode() const;
+    void setEncodingMode(QtMultimedia::EncodingMode);
+
+    QString codec() const;
+    void setCodec(const QString& codec);
+
+    int bitRate() const;
+    void setBitRate(int bitrate);
+
+    int channelCount() const;
+    void setChannelCount(int channels);
+
+    int sampleRate() const;
+    void setSampleRate(int rate);
+
+    QtMultimedia::EncodingQuality quality() const;
+    void setQuality(QtMultimedia::EncodingQuality quality);
+
+private:
+    QSharedDataPointer<QAudioEncoderSettingsPrivate> d;
+};
+
+class QVideoEncoderSettingsPrivate;
+class Q_MULTIMEDIA_EXPORT QVideoEncoderSettings
+{
+public:
+    QVideoEncoderSettings();
+    QVideoEncoderSettings(const QVideoEncoderSettings& other);
+
+    ~QVideoEncoderSettings();
+
+    QVideoEncoderSettings& operator=(const QVideoEncoderSettings &other);
+    bool operator==(const QVideoEncoderSettings &other) const;
+    bool operator!=(const QVideoEncoderSettings &other) const;
+
+    bool isNull() const;
+
+    QtMultimedia::EncodingMode encodingMode() const;
+    void setEncodingMode(QtMultimedia::EncodingMode);
+
+    QString codec() const;
+    void setCodec(const QString &);
+
+    QSize resolution() const;
+    void setResolution(const QSize &);
+    void setResolution(int width, int height);
+
+    qreal frameRate() const;
+    void setFrameRate(qreal rate);
+
+    int bitRate() const;
+    void setBitRate(int bitrate);
+
+    QtMultimedia::EncodingQuality quality() const;
+    void setQuality(QtMultimedia::EncodingQuality quality);
+
+private:
+    QSharedDataPointer<QVideoEncoderSettingsPrivate> d;
+};
+
+class QImageEncoderSettingsPrivate;
+class Q_MULTIMEDIA_EXPORT QImageEncoderSettings
+{
+public:
+    QImageEncoderSettings();
+    QImageEncoderSettings(const QImageEncoderSettings& other);
+
+    ~QImageEncoderSettings();
+
+    QImageEncoderSettings& operator=(const QImageEncoderSettings &other);
+    bool operator==(const QImageEncoderSettings &other) const;
+    bool operator!=(const QImageEncoderSettings &other) const;
+
+    bool isNull() const;
+
+    QString codec() const;
+    void setCodec(const QString &);
+
+    QSize resolution() const;
+    void setResolution(const QSize &);
+    void setResolution(int width, int height);
+
+    QtMultimedia::EncodingQuality quality() const;
+    void setQuality(QtMultimedia::EncodingQuality quality);
+
+private:
+    QSharedDataPointer<QImageEncoderSettingsPrivate> d;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
diff --git a/src/multimedia/recording/qmediarecorder.cpp b/src/multimedia/recording/qmediarecorder.cpp
new file mode 100644
index 0000000..6be462d
--- /dev/null
+++ b/src/multimedia/recording/qmediarecorder.cpp
@@ -0,0 +1,904 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediarecorder.h"
+
+#include <qmediarecordercontrol.h>
+#include "qmediaobject_p.h"
+#include <qmediaservice.h>
+#include <qmediaserviceprovider.h>
+#include <qmetadatawritercontrol.h>
+#include <qaudioencodercontrol.h>
+#include <qvideoencodercontrol.h>
+#include <qmediacontainercontrol.h>
+#include <qcamera.h>
+#include <qcameracontrol.h>
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qstringlist.h>
+#include <QtCore/qmetaobject.h>
+
+#include <qaudioformat.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaRecorder
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \since 1.0
+
+
+    \brief The QMediaRecorder class is used for the recording of media content.
+
+    The QMediaRecorder class is a high level media recording class.  It's not
+    intended to be used alone but for accessing the media recording functions
+    of other media objects, like QRadioTuner, or QAudioCaptureSource.
+
+    \snippet doc/src/snippets/multimedia-snippets/media.cpp Media recorder
+
+    \sa QAudioCaptureSource
+*/
+
+namespace
+{
+class MediaRecorderRegisterMetaTypes
+{
+public:
+    MediaRecorderRegisterMetaTypes()
+    {
+        qRegisterMetaType<QMediaRecorder::State>("QMediaRecorder::State");
+        qRegisterMetaType<QMediaRecorder::Error>("QMediaRecorder::Error");
+    }
+} _registerRecorderMetaTypes;
+}
+
+
+class QMediaRecorderPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QMediaRecorder)
+
+public:
+    QMediaRecorderPrivate();
+
+    QMediaObject *mediaObject;
+
+    QMediaRecorderControl *control;
+    QMediaContainerControl *formatControl;
+    QAudioEncoderControl *audioControl;
+    QVideoEncoderControl *videoControl;
+    QMetaDataWriterControl *metaDataControl;
+
+    QTimer* notifyTimer;
+
+    QMediaRecorder::State state;
+    QMediaRecorder::Error error;
+    QString errorString;
+
+    void _q_stateChanged(QMediaRecorder::State state);
+    void _q_error(int error, const QString &errorString);
+    void _q_serviceDestroyed();
+    void _q_notify();
+    void _q_updateNotifyInterval(int ms);
+
+    QMediaRecorder *q_ptr;
+};
+
+QMediaRecorderPrivate::QMediaRecorderPrivate():
+     mediaObject(0),
+     control(0),
+     formatControl(0),
+     audioControl(0),
+     videoControl(0),
+     metaDataControl(0),
+     notifyTimer(0),
+     state(QMediaRecorder::StoppedState),
+     error(QMediaRecorder::NoError)
+{
+}
+
+#define ENUM_NAME(c,e,v) (c::staticMetaObject.enumerator(c::staticMetaObject.indexOfEnumerator(e)).valueToKey((v)))
+
+void QMediaRecorderPrivate::_q_stateChanged(QMediaRecorder::State ps)
+{
+    Q_Q(QMediaRecorder);
+
+    if (ps == QMediaRecorder::RecordingState)
+        notifyTimer->start();
+    else
+        notifyTimer->stop();
+
+//    qDebug() << "Recorder state changed:" << ENUM_NAME(QMediaRecorder,"State",ps);
+    if (state != ps) {
+        emit q->stateChanged(ps);
+    }
+
+    state = ps;
+}
+
+
+void QMediaRecorderPrivate::_q_error(int error, const QString &errorString)
+{
+    Q_Q(QMediaRecorder);
+
+    this->error = QMediaRecorder::Error(error);
+    this->errorString = errorString;
+
+    emit q->error(this->error);
+}
+
+void QMediaRecorderPrivate::_q_serviceDestroyed()
+{
+    mediaObject = 0;
+    control = 0;
+    formatControl = 0;
+    audioControl = 0;
+    videoControl = 0;
+    metaDataControl = 0;
+}
+
+void QMediaRecorderPrivate::_q_notify()
+{
+    emit q_func()->durationChanged(q_func()->duration());
+}
+
+void QMediaRecorderPrivate::_q_updateNotifyInterval(int ms)
+{
+    notifyTimer->setInterval(ms);
+}
+
+
+/*!
+    Constructs a media recorder which records the media produced by \a mediaObject.
+
+    The \a parent is passed to QMediaObject.
+    \since 1.0
+*/
+
+QMediaRecorder::QMediaRecorder(QMediaObject *mediaObject, QObject *parent):
+    QObject(parent),
+    d_ptr(new QMediaRecorderPrivate)
+{
+    Q_D(QMediaRecorder);
+    d->q_ptr = this;
+    setMediaObject(mediaObject);
+
+    d->notifyTimer = new QTimer(this);
+    d->notifyTimer->setInterval(mediaObject->notifyInterval());
+    connect(d->notifyTimer, SIGNAL(timeout()), SLOT(_q_notify()));
+    connect(mediaObject, SIGNAL(notifyIntervalChanged(int)), SLOT(_q_updateNotifyInterval(int)));
+}
+
+/*!
+    Destroys a media recorder object.
+*/
+
+QMediaRecorder::~QMediaRecorder()
+{
+}
+
+/*!
+    Returns the QMediaObject instance that this QMediaRecorder is bound too,
+    or 0 otherwise.
+    \since 1.0
+*/
+QMediaObject *QMediaRecorder::mediaObject() const
+{
+    return d_func()->mediaObject;
+}
+
+/*!
+    \internal
+    \since 1.0
+*/
+bool QMediaRecorder::setMediaObject(QMediaObject *object)
+{
+    Q_D(QMediaRecorder);
+
+    if (object == d->mediaObject)
+        return true;
+
+    if (d->mediaObject) {
+        if (d->control) {
+            disconnect(d->control, SIGNAL(stateChanged(QMediaRecorder::State)),
+                       this, SLOT(_q_stateChanged(QMediaRecorder::State)));
+
+            disconnect(d->control, SIGNAL(mutedChanged(bool)),
+                       this, SIGNAL(mutedChanged(bool)));
+
+            disconnect(d->control, SIGNAL(durationChanged(qint64)),
+                       this, SIGNAL(durationChanged(qint64)));
+
+            disconnect(d->control, SIGNAL(error(int,QString)),
+                       this, SLOT(_q_error(int,QString)));
+        }
+
+        QMediaService *service = d->mediaObject->service();
+
+        if (service) {
+            disconnect(service, SIGNAL(destroyed()), this, SLOT(_q_serviceDestroyed()));
+
+            if (d->control)
+                service->releaseControl(d->control);
+            if (d->formatControl)
+                service->releaseControl(d->formatControl);
+            if (d->audioControl)
+                service->releaseControl(d->audioControl);
+            if (d->videoControl)
+                service->releaseControl(d->videoControl);
+            if (d->metaDataControl) {
+                disconnect(d->metaDataControl, SIGNAL(metaDataChanged()),
+                        this, SIGNAL(metaDataChanged()));
+                disconnect(d->metaDataControl, SIGNAL(metaDataAvailableChanged(bool)),
+                        this, SIGNAL(metaDataAvailableChanged(bool)));
+                disconnect(d->metaDataControl, SIGNAL(writableChanged(bool)),
+                        this, SIGNAL(metaDataWritableChanged(bool)));
+
+                service->releaseControl(d->metaDataControl);
+            }
+        }
+    }
+
+    d->control = 0;
+    d->formatControl = 0;
+    d->audioControl = 0;
+    d->videoControl = 0;
+    d->metaDataControl = 0;
+
+    d->mediaObject = object;
+
+    if (d->mediaObject) {
+        QMediaService *service = d->mediaObject->service();
+
+        if (service) {
+            d->control = qobject_cast<QMediaRecorderControl*>(service->requestControl(QMediaRecorderControl_iid));
+
+            if (d->control) {
+                d->formatControl = qobject_cast<QMediaContainerControl *>(service->requestControl(QMediaContainerControl_iid));
+                d->audioControl = qobject_cast<QAudioEncoderControl *>(service->requestControl(QAudioEncoderControl_iid));
+                d->videoControl = qobject_cast<QVideoEncoderControl *>(service->requestControl(QVideoEncoderControl_iid));
+
+                QMediaControl *control = service->requestControl(QMetaDataWriterControl_iid);
+                if (control) {
+                    d->metaDataControl = qobject_cast<QMetaDataWriterControl *>(control);
+                    if (!d->metaDataControl) {
+                        service->releaseControl(control);
+                    } else {
+                        connect(d->metaDataControl,
+                                SIGNAL(metaDataChanged()),
+                                SIGNAL(metaDataChanged()));
+                        connect(d->metaDataControl,
+                                SIGNAL(metaDataAvailableChanged(bool)),
+                                SIGNAL(metaDataAvailableChanged(bool)));
+                        connect(d->metaDataControl,
+                                SIGNAL(writableChanged(bool)),
+                                SIGNAL(metaDataWritableChanged(bool)));
+                    }
+                }
+
+                connect(d->control, SIGNAL(stateChanged(QMediaRecorder::State)),
+                        this, SLOT(_q_stateChanged(QMediaRecorder::State)));
+
+                connect(d->control, SIGNAL(mutedChanged(bool)),
+                        this, SIGNAL(mutedChanged(bool)));
+
+                connect(d->control, SIGNAL(durationChanged(qint64)),
+                        this, SIGNAL(durationChanged(qint64)));
+
+                connect(d->control, SIGNAL(error(int,QString)),
+                        this, SLOT(_q_error(int,QString)));
+
+                connect(service, SIGNAL(destroyed()), this, SLOT(_q_serviceDestroyed()));
+
+
+                return true;
+            }
+        }
+
+        d->mediaObject = 0;
+        return false;
+    }
+
+    return true;
+}
+
+/*!
+    \property QMediaRecorder::outputLocation
+    \brief the destination location of media content.
+
+    Setting the location can fail, for example when the service supports only
+    local file system locations but a network URL was passed. If the service
+    does not support media recording this setting the output location will
+    always fail.
+
+    The \a location can be relative or empty;
+    in this case the recorder uses the system specific place and file naming scheme.
+    After recording has stated, QMediaRecorder::outputLocation() returns the actual output location.
+    \since 1.0
+*/
+
+/*!
+    Returns true if media recorder service ready to use.
+    \since 1.0
+*/
+bool QMediaRecorder::isAvailable() const
+{
+    if (d_func()->control != NULL)
+        return true;
+    else
+        return false;
+}
+
+/*!
+    Returns the availability error code.
+    \since 1.0
+*/
+QtMultimedia::AvailabilityError QMediaRecorder::availabilityError() const
+{
+    if (d_func()->control != NULL)
+        return QtMultimedia::NoError;
+    else
+        return QtMultimedia::ServiceMissingError;
+}
+
+QUrl QMediaRecorder::outputLocation() const
+{
+    return d_func()->control ? d_func()->control->outputLocation() : QUrl();
+}
+
+bool QMediaRecorder::setOutputLocation(const QUrl &location)
+{
+    Q_D(QMediaRecorder);
+    return d->control ? d->control->setOutputLocation(location) : false;
+}
+
+/*!
+    Returns the current media recorder state.
+
+    \since 1.0
+    \sa QMediaRecorder::State
+*/
+
+QMediaRecorder::State QMediaRecorder::state() const
+{
+    return d_func()->control ? QMediaRecorder::State(d_func()->control->state()) : StoppedState;
+}
+
+/*!
+    Returns the current error state.
+
+    \since 1.0
+    \sa errorString()
+*/
+
+QMediaRecorder::Error QMediaRecorder::error() const
+{
+    return d_func()->error;
+}
+
+/*!
+    Returns a string describing the current error state.
+
+    \since 1.0
+    \sa error()
+*/
+
+QString QMediaRecorder::errorString() const
+{
+    return d_func()->errorString;
+}
+
+/*!
+    \property QMediaRecorder::duration
+
+    \brief the recorded media duration in milliseconds.
+    \since 1.0
+*/
+
+qint64 QMediaRecorder::duration() const
+{
+    return d_func()->control ? d_func()->control->duration() : 0;
+}
+
+/*!
+    \property QMediaRecorder::muted
+
+    \brief whether a recording audio stream is muted.
+    \since 1.0
+*/
+
+bool QMediaRecorder::isMuted() const
+{
+    return d_func()->control ? d_func()->control->isMuted() : 0;
+}
+
+void QMediaRecorder::setMuted(bool muted)
+{
+    Q_D(QMediaRecorder);
+
+    if (d->control)
+        d->control->setMuted(muted);
+}
+
+/*!
+    Returns a list of MIME types of supported container formats.
+    \since 1.0
+*/
+QStringList QMediaRecorder::supportedContainers() const
+{
+    return d_func()->formatControl ?
+           d_func()->formatControl->supportedContainers() : QStringList();
+}
+
+/*!
+    Returns a description of a container format \a mimeType.
+    \since 1.0
+*/
+QString QMediaRecorder::containerDescription(const QString &mimeType) const
+{
+    return d_func()->formatControl ?
+           d_func()->formatControl->containerDescription(mimeType) : QString();
+}
+
+/*!
+    Returns the MIME type of the selected container format.
+    \since 1.0
+*/
+
+QString QMediaRecorder::containerMimeType() const
+{
+    return d_func()->formatControl ?
+           d_func()->formatControl->containerMimeType() : QString();
+}
+
+/*!
+    Returns a list of supported audio codecs.
+    \since 1.0
+*/
+QStringList QMediaRecorder::supportedAudioCodecs() const
+{
+    return d_func()->audioControl ?
+           d_func()->audioControl->supportedAudioCodecs() : QStringList();
+}
+
+/*!
+    Returns a description of an audio \a codec.
+    \since 1.0
+*/
+QString QMediaRecorder::audioCodecDescription(const QString &codec) const
+{
+    return d_func()->audioControl ?
+           d_func()->audioControl->codecDescription(codec) : QString();
+}
+
+/*!
+    Returns a list of supported audio sample rates.
+
+    If non null audio \a settings parameter is passed, the returned list is
+    reduced to sample rates supported with partial settings applied.
+
+    This can be used to query the list of sample rates, supported by specific
+    audio codec.
+
+    If the encoder supports arbitrary sample rates within the supported rates
+    range, *\a continuous is set to true, otherwise *\a continuous is set to
+    false.
+    \since 1.0
+*/
+
+QList<int> QMediaRecorder::supportedAudioSampleRates(const QAudioEncoderSettings &settings, bool *continuous) const
+{
+    if (continuous)
+        *continuous = false;
+
+    return d_func()->audioControl ?
+           d_func()->audioControl->supportedSampleRates(settings, continuous) : QList<int>();
+}
+
+/*!
+    Returns a list of resolutions video can be encoded at.
+
+    If non null video \a settings parameter is passed, the returned list is
+    reduced to resolution supported with partial settings like video codec or
+    framerate applied.
+
+    If the encoder supports arbitrary resolutions within the supported range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+
+    \since 1.0
+    \sa QVideoEncoderSettings::resolution()
+*/
+QList<QSize> QMediaRecorder::supportedResolutions(const QVideoEncoderSettings &settings, bool *continuous) const
+{
+    if (continuous)
+        *continuous = false;
+
+    return d_func()->videoControl ?
+           d_func()->videoControl->supportedResolutions(settings, continuous) : QList<QSize>();
+}
+
+/*!
+    Returns a list of frame rates video can be encoded at.
+
+    If non null video \a settings parameter is passed, the returned list is
+    reduced to frame rates supported with partial settings like video codec or
+    resolution applied.
+
+    If the encoder supports arbitrary frame rates within the supported range,
+    *\a continuous is set to true, otherwise *\a continuous is set to false.
+
+    \since 1.0
+    \sa QVideoEncoderSettings::frameRate()
+*/
+QList<qreal> QMediaRecorder::supportedFrameRates(const QVideoEncoderSettings &settings, bool *continuous) const
+{
+    if (continuous)
+        *continuous = false;
+
+    return d_func()->videoControl ?
+           d_func()->videoControl->supportedFrameRates(settings, continuous) : QList<qreal>();
+}
+
+/*!
+    Returns a list of supported video codecs.
+    \since 1.0
+*/
+QStringList QMediaRecorder::supportedVideoCodecs() const
+{
+    return d_func()->videoControl ?
+           d_func()->videoControl->supportedVideoCodecs() : QStringList();
+}
+
+/*!
+    Returns a description of a video \a codec.
+
+    \since 1.0
+    \sa setEncodingSettings()
+*/
+QString QMediaRecorder::videoCodecDescription(const QString &codec) const
+{
+    return d_func()->videoControl ?
+           d_func()->videoControl->videoCodecDescription(codec) : QString();
+}
+
+/*!
+    Returns the audio encoder settings being used.
+
+    \since 1.0
+    \sa setEncodingSettings()
+*/
+
+QAudioEncoderSettings QMediaRecorder::audioSettings() const
+{
+    return d_func()->audioControl ?
+           d_func()->audioControl->audioSettings() : QAudioEncoderSettings();
+}
+
+/*!
+    Returns the video encoder settings being used.
+
+    \since 1.0
+    \sa setEncodingSettings()
+*/
+
+QVideoEncoderSettings QMediaRecorder::videoSettings() const
+{
+    return d_func()->videoControl ?
+           d_func()->videoControl->videoSettings() : QVideoEncoderSettings();
+}
+
+/*!
+    Sets the \a audio and \a video encoder settings and \a container format MIME type.
+
+    If some parameters are not specified, or null settings are passed, the
+    encoder will choose default encoding parameters, depending on media
+    source properties.
+    While setEncodingSettings is optional, the backend can preload
+    encoding pipeline to improve recording startup time.
+
+    It's only possible to change settings when the encoder is in the
+    QMediaEncoder::StoppedState state.
+
+    \since 1.0
+    \sa audioSettings(), videoSettings(), containerMimeType()
+*/
+
+void QMediaRecorder::setEncodingSettings(const QAudioEncoderSettings &audio,
+                                         const QVideoEncoderSettings &video,
+                                         const QString &container)
+{
+    Q_D(QMediaRecorder);
+
+    QCamera *camera = qobject_cast<QCamera*>(d->mediaObject);
+    if (camera && camera->captureMode() == QCamera::CaptureVideo) {
+        QMetaObject::invokeMethod(camera,
+                                  "_q_preparePropertyChange",
+                                  Qt::DirectConnection,
+                                  Q_ARG(int, QCameraControl::VideoEncodingSettings));
+    }
+
+    if (d->audioControl)
+        d->audioControl->setAudioSettings(audio);
+
+    if (d->videoControl)
+        d->videoControl->setVideoSettings(video);
+
+    if (d->formatControl)
+        d->formatControl->setContainerMimeType(container);
+
+    if (d->control)
+        d->control->applySettings();
+}
+
+
+/*!
+    Start recording.
+
+    This is an asynchronous call, with signal
+    stateCahnged(QMediaRecorder::RecordingState) being emitted when recording
+    started, otherwise the error() signal is emitted.
+    \since 1.0
+*/
+
+void QMediaRecorder::record()
+{
+    Q_D(QMediaRecorder);
+
+    // reset error
+    d->error = NoError;
+    d->errorString = QString();
+
+    if (d->control)
+        d->control->record();
+}
+
+/*!
+    Pause recording.
+    \since 1.0
+*/
+
+void QMediaRecorder::pause()
+{
+    Q_D(QMediaRecorder);
+    if (d->control)
+        d->control->pause();
+}
+
+/*!
+    Stop recording.
+    \since 1.0
+*/
+
+void QMediaRecorder::stop()
+{
+    Q_D(QMediaRecorder);
+    if (d->control)
+        d->control->stop();
+}
+
+/*!
+    \enum QMediaRecorder::State
+
+    \value StoppedState    The recorder is not active.
+    \value RecordingState  The recorder is currently active and producing data.
+    \value PausedState     The recorder is paused.
+*/
+
+/*!
+    \enum QMediaRecorder::Error
+
+    \value NoError         No Errors.
+    \value ResourceError   Device is not ready or not available.
+    \value FormatError     Current format is not supported.
+*/
+
+/*!
+    \fn QMediaRecorder::stateChanged(State state)
+
+    Signals that a media recorder's \a state has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaRecorder::durationChanged(qint64 duration)
+
+    Signals that the \a duration of the recorded media has changed.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaRecorder::error(QMediaRecorder::Error error)
+
+    Signals that an \a error has occurred.
+    \since 1.0
+*/
+
+/*!
+    \fn QMediaRecorder::mutedChanged(bool muted)
+
+    Signals that the \a muted state has changed. If true the recording is being muted.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaRecorder::metaDataAvailable
+    \brief whether access to a media object's meta-data is available.
+
+    If this is true there is meta-data available, otherwise there is no meta-data available.
+    \since 1.0
+*/
+
+bool QMediaRecorder::isMetaDataAvailable() const
+{
+    Q_D(const QMediaRecorder);
+
+    return d->metaDataControl
+            ? d->metaDataControl->isMetaDataAvailable()
+            : false;
+}
+
+/*!
+    \fn QMediaRecorder::metaDataAvailableChanged(bool available)
+
+    Signals that the \a available state of a media object's meta-data has changed.
+    \since 1.0
+*/
+
+/*!
+    \property QMediaRecorder::metaDataWritable
+    \brief whether a media object's meta-data is writable.
+
+    If this is true the meta-data is writable, otherwise the meta-data is read-only.
+    \since 1.0
+*/
+
+bool QMediaRecorder::isMetaDataWritable() const
+{
+    Q_D(const QMediaRecorder);
+
+    return d->metaDataControl
+            ? d->metaDataControl->isWritable()
+            : false;
+}
+
+/*!
+    \fn QMediaRecorder::metaDataWritableChanged(bool writable)
+
+    Signals that the \a writable state of a media object's meta-data has changed.
+    \since 1.0
+*/
+
+/*!
+    Returns the value associated with a meta-data \a key.
+    \since 1.0
+*/
+QVariant QMediaRecorder::metaData(QtMultimedia::MetaData key) const
+{
+    Q_D(const QMediaRecorder);
+
+    return d->metaDataControl
+            ? d->metaDataControl->metaData(key)
+            : QVariant();
+}
+
+/*!
+    Sets a \a value for a meta-data \a key.
+
+    \note To ensure that meta data is set corretly, it should be set before starting the recording.
+    Once the recording is stopped, any meta data set will be attached to the next recording.
+    \since 1.0
+*/
+void QMediaRecorder::setMetaData(QtMultimedia::MetaData key, const QVariant &value)
+{
+    Q_D(QMediaRecorder);
+
+    if (d->metaDataControl)
+        d->metaDataControl->setMetaData(key, value);
+}
+
+/*!
+    Returns a list of keys there is meta-data available for.
+    \since 1.0
+*/
+QList<QtMultimedia::MetaData> QMediaRecorder::availableMetaData() const
+{
+    Q_D(const QMediaRecorder);
+
+    return d->metaDataControl
+            ? d->metaDataControl->availableMetaData()
+            : QList<QtMultimedia::MetaData>();
+}
+
+/*!
+    \fn QMediaRecorder::metaDataChanged()
+
+    Signals that a media object's meta-data has changed.
+    \since 1.0
+*/
+
+/*!
+    Returns the value associated with a meta-data \a key.
+
+    The naming and type of extended meta-data is not standardized, so the values and meaning
+    of keys may vary between backends.
+    \since 1.0
+*/
+QVariant QMediaRecorder::extendedMetaData(const QString &key) const
+{
+    Q_D(const QMediaRecorder);
+
+    return d->metaDataControl
+            ? d->metaDataControl->extendedMetaData(key)
+            : QVariant();
+}
+
+/*!
+    Sets a \a value for a meta-data \a key.
+
+    The naming and type of extended meta-data is not standardized, so the values and meaning
+    of keys may vary between backends.
+    \since 1.0
+*/
+void QMediaRecorder::setExtendedMetaData(const QString &key, const QVariant &value)
+{
+    Q_D(QMediaRecorder);
+
+    if (d->metaDataControl)
+        d->metaDataControl->setExtendedMetaData(key, value);
+}
+
+/*!
+    Returns a list of keys there is extended meta-data available for.
+    \since 1.0
+*/
+QStringList QMediaRecorder::availableExtendedMetaData() const
+{
+    Q_D(const QMediaRecorder);
+
+    return d->metaDataControl
+            ? d->metaDataControl->availableExtendedMetaData()
+            : QStringList();
+}
+
+#include "moc_qmediarecorder.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/recording/qmediarecorder.h b/src/multimedia/recording/qmediarecorder.h
new file mode 100644
index 0000000..fbd47dd
--- /dev/null
+++ b/src/multimedia/recording/qmediarecorder.h
@@ -0,0 +1,197 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMEDIARECORDER_H
+#define QMEDIARECORDER_H
+
+#include <qmediaobject.h>
+#include <qmediaserviceprovider.h>
+#include <qmediaencodersettings.h>
+#include <qmediabindableinterface.h>
+#include <qmediaenumdebug.h>
+
+#include <QtCore/qpair.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QUrl;
+class QSize;
+class QAudioFormat;
+QT_END_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class QMediaRecorderService;
+class QAudioEncoderSettings;
+class QVideoEncoderSettings;
+
+class QMediaRecorderPrivate;
+class Q_MULTIMEDIA_EXPORT QMediaRecorder : public QObject, public QMediaBindableInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaBindableInterface)
+    Q_ENUMS(State)
+    Q_ENUMS(Error)
+    Q_PROPERTY(qint64 duration READ duration NOTIFY durationChanged)
+    Q_PROPERTY(QUrl outputLocation READ outputLocation WRITE setOutputLocation)
+    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
+    Q_PROPERTY(bool metaDataAvailable READ isMetaDataAvailable NOTIFY metaDataAvailableChanged)
+    Q_PROPERTY(bool metaDataWritable READ isMetaDataWritable NOTIFY metaDataWritableChanged)
+public:
+
+    enum State
+    {
+        StoppedState,
+        RecordingState,
+        PausedState
+    };
+
+    enum Error
+    {
+        NoError,
+        ResourceError,
+        FormatError
+    };
+
+    QMediaRecorder(QMediaObject *mediaObject, QObject *parent = 0);
+    ~QMediaRecorder();
+
+    QMediaObject *mediaObject() const;
+
+    bool isAvailable() const;
+    QtMultimedia::AvailabilityError availabilityError() const;
+
+    QUrl outputLocation() const;
+    bool setOutputLocation(const QUrl &location);
+
+    State state() const;
+
+    Error error() const;
+    QString errorString() const;
+
+    qint64 duration() const;
+
+    bool isMuted() const;
+
+    QStringList supportedContainers() const;
+    QString containerDescription(const QString &containerMimeType) const;
+
+    QStringList supportedAudioCodecs() const;
+    QString audioCodecDescription(const QString &codecName) const;
+
+    QList<int> supportedAudioSampleRates(const QAudioEncoderSettings &settings = QAudioEncoderSettings(),
+                                         bool *continuous = 0) const;
+
+    QStringList supportedVideoCodecs() const;
+    QString videoCodecDescription(const QString &codecName) const;
+
+    QList<QSize> supportedResolutions(const QVideoEncoderSettings &settings = QVideoEncoderSettings(),
+                                      bool *continuous = 0) const;
+
+    QList<qreal> supportedFrameRates(const QVideoEncoderSettings &settings = QVideoEncoderSettings(),
+                                     bool *continuous = 0) const;
+
+    QAudioEncoderSettings audioSettings() const;
+    QVideoEncoderSettings videoSettings() const;
+    QString containerMimeType() const;
+
+    void setEncodingSettings(const QAudioEncoderSettings &audioSettings,
+                             const QVideoEncoderSettings &videoSettings = QVideoEncoderSettings(),
+                             const QString &containerMimeType = QString());
+
+
+    bool isMetaDataAvailable() const;
+    bool isMetaDataWritable() const;
+
+    QVariant metaData(QtMultimedia::MetaData key) const;
+    void setMetaData(QtMultimedia::MetaData key, const QVariant &value);
+    QList<QtMultimedia::MetaData> availableMetaData() const;
+
+    QVariant extendedMetaData(const QString &key) const;
+    void setExtendedMetaData(const QString &key, const QVariant &value);
+    QStringList availableExtendedMetaData() const;
+
+public Q_SLOTS:
+    void record();
+    void pause();
+    void stop();
+    void setMuted(bool muted);
+
+Q_SIGNALS:
+    void stateChanged(QMediaRecorder::State state);
+    void durationChanged(qint64 duration);
+    void mutedChanged(bool muted);
+
+    void error(QMediaRecorder::Error error);
+
+    void metaDataAvailableChanged(bool available);
+    void metaDataWritableChanged(bool writable);
+    void metaDataChanged();
+
+protected:
+    bool setMediaObject(QMediaObject *object);
+
+private:
+    QMediaRecorderPrivate *d_ptr;
+    Q_DISABLE_COPY(QMediaRecorder)
+    Q_DECLARE_PRIVATE(QMediaRecorder)
+    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QMediaRecorder::State))
+    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
+    Q_PRIVATE_SLOT(d_func(), void _q_serviceDestroyed())
+    Q_PRIVATE_SLOT(d_func(), void _q_notify())
+    Q_PRIVATE_SLOT(d_func(), void _q_updateNotifyInterval(int))
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMediaRecorder::State)
+Q_DECLARE_METATYPE(QMediaRecorder::Error)
+
+Q_MEDIA_ENUM_DEBUG(QMediaRecorder, State)
+Q_MEDIA_ENUM_DEBUG(QMediaRecorder, Error)
+
+QT_END_HEADER
+
+#endif  // QMEDIARECORDER_H
diff --git a/src/multimedia/recording/recording.pri b/src/multimedia/recording/recording.pri
new file mode 100644
index 0000000..b55999a
--- /dev/null
+++ b/src/multimedia/recording/recording.pri
@@ -0,0 +1,11 @@
+INCLUDEPATH += recording
+
+PUBLIC_HEADERS += \
+    recording/qaudiocapturesource.h \
+    recording/qmediaencodersettings.h \
+    recording/qmediarecorder.h \
+
+SOURCES += \
+    recording/qaudiocapturesource.cpp \
+    recording/qmediaencodersettings.cpp \
+    recording/qmediarecorder.cpp
diff --git a/src/multimedia/video/qvideosurfaceoutput.cpp b/src/multimedia/video/qvideosurfaceoutput.cpp
new file mode 100644
index 0000000..cdbec55
--- /dev/null
+++ b/src/multimedia/video/qvideosurfaceoutput.cpp
@@ -0,0 +1,100 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qvideosurfaceoutput_p.h"
+
+#include <qabstractvideosurface.h>
+#include <qmediaservice.h>
+#include <qvideorenderercontrol.h>
+
+
+QVideoSurfaceOutput::QVideoSurfaceOutput(QObject*parent)
+    :  QObject(parent)
+{
+}
+
+QVideoSurfaceOutput::~QVideoSurfaceOutput()
+{
+    if (m_control) {
+        m_control.data()->setSurface(0);
+        m_service.data()->releaseControl(m_control.data());
+    }
+}
+
+QMediaObject *QVideoSurfaceOutput::mediaObject() const
+{
+    return m_object.data();
+}
+
+void QVideoSurfaceOutput::setVideoSurface(QAbstractVideoSurface *surface)
+{
+    m_surface = surface;
+
+    if (m_control)
+        m_control.data()->setSurface(surface);
+}
+
+bool QVideoSurfaceOutput::setMediaObject(QMediaObject *object)
+{
+    if (m_control) {
+        m_control.data()->setSurface(0);
+        m_service.data()->releaseControl(m_control.data());
+    }
+    m_control.clear();
+    m_service.clear();
+    m_object.clear();
+
+    if (object) {
+        if (QMediaService *service = object->service()) {
+            if (QMediaControl *control = service->requestControl(QVideoRendererControl_iid)) {
+                if ((m_control = qobject_cast<QVideoRendererControl *>(control))) {
+                    m_service = service;
+                    m_object = object;
+                    m_control.data()->setSurface(m_surface.data());
+
+                    return true;
+                }
+                service->releaseControl(control);
+            }
+        }
+    }
+    return false;
+}
diff --git a/src/multimedia/video/qvideosurfaceoutput_p.h b/src/multimedia/video/qvideosurfaceoutput_p.h
new file mode 100644
index 0000000..76ec5e8
--- /dev/null
+++ b/src/multimedia/video/qvideosurfaceoutput_p.h
@@ -0,0 +1,86 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QVIDEOSURFACEOUTPUT_P_H
+#define QVIDEOSURFACEOUTPUT_P_H
+
+#include <qmediabindableinterface.h>
+
+#include <QtCore/qsharedpointer.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+
+class QAbstractVideoSurface;
+class QVideoRendererControl;
+
+class QVideoSurfaceOutput : public QObject, public QMediaBindableInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaBindableInterface)
+public:
+    QVideoSurfaceOutput(QObject*parent = 0);
+    ~QVideoSurfaceOutput();
+
+    QMediaObject *mediaObject() const;
+
+    void setVideoSurface(QAbstractVideoSurface *surface);
+
+protected:
+    bool setMediaObject(QMediaObject *object);
+
+private:
+    QWeakPointer<QAbstractVideoSurface> m_surface;
+    QWeakPointer<QVideoRendererControl> m_control;
+    QWeakPointer<QMediaService> m_service;
+    QWeakPointer<QMediaObject> m_object;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+
+#endif
diff --git a/src/multimedia/video/video.pri b/src/multimedia/video/video.pri
index accaa33..01550a8 100644
--- a/src/multimedia/video/video.pri
+++ b/src/multimedia/video/video.pri
@@ -10,7 +10,8 @@ PUBLIC_HEADERS += \
 PRIVATE_HEADERS += \
     video/qabstractvideobuffer_p.h \
     video/qimagevideobuffer_p.h \
-    video/qmemoryvideobuffer_p.h
+    video/qmemoryvideobuffer_p.h \
+    video/qvideosurfaceoutput_p.h
 
 SOURCES += \
     video/qabstractvideobuffer.cpp \
@@ -18,5 +19,6 @@ SOURCES += \
     video/qimagevideobuffer.cpp \
     video/qmemoryvideobuffer.cpp \
     video/qvideoframe.cpp \
-    video/qvideosurfaceformat.cpp
+    video/qvideosurfaceformat.cpp \
+    video/qvideosurfaceoutput.cpp
 
diff --git a/tests/auto/unit/qwavedecoder/qwavedecoder.pro b/tests/auto/unit/qwavedecoder/qwavedecoder.pro
index 7428c5c..172a6de 100644
--- a/tests/auto/unit/qwavedecoder/qwavedecoder.pro
+++ b/tests/auto/unit/qwavedecoder/qwavedecoder.pro
@@ -1,7 +1,7 @@
 TARGET = tst_qwavedecoder
-HEADERS += $$QT.multimedia.sources/effects/qwavedecoder_p.h
+HEADERS += $$QT.multimedia.sources/audio/qwavedecoder_p.h
 SOURCES += tst_qwavedecoder.cpp \
-           $$QT.multimedia.sources/effects/qwavedecoder_p.cpp
+           $$QT.multimedia.sources/audio/qwavedecoder_p.cpp
 
 QT += multimedia-private testlib network
 CONFIG += no_private_qt_headers_warning testcase