diff --git a/src/serialport.cpp b/src/serialport.cpp
index ab089b3..1cbb18a 100755
--- a/src/serialport.cpp
+++ b/src/serialport.cpp
@@ -44,273 +44,45 @@
 
 #include "serialport.h"
 #include "serialportinfo.h"
-#include "serialport_p.h"
-#include "serialportengine_p.h"
 
-#if QT_VERSION >= 0x040700
-#  include <QtCore/qelapsedtimer.h>
+#ifdef Q_OS_WIN
+#include "serialport_win_p.h"
+#elif defined (Q_OS_SYMBIAN)
+#include "serialport_symbian_p.h"
+#elif defined (Q_OS_UNIX)
+#include "serialport_unix_p.h"
 #else
-#  include <QtCore/qdatetime.h>
+#error Unsupported OS
 #endif
 
 #ifndef SERIALPORT_BUFFERSIZE
 #  define SERIALPORT_BUFFERSIZE 16384
 #endif
 
-#ifndef SERIALPORT_READ_CHUNKSIZE
-#  define SERIALPORT_READ_CHUNKSIZE 256
-#endif
-
 QT_BEGIN_NAMESPACE_SERIALPORT
 
-/*! \internal
-
-    Constructs a SerialPortPrivate. Initializes all members.
-*/
-SerialPortPrivate::SerialPortPrivate(SerialPort *parent)
+SerialPortPrivateData::SerialPortPrivateData(SerialPort *q)
     : readBufferMaxSize(0)
     , readBuffer(SERIALPORT_BUFFERSIZE)
     , writeBuffer(SERIALPORT_BUFFERSIZE)
-    , isBuffered(true)
-    , readSerialNotifierCalled(false)
-    , readSerialNotifierState(false)
-    , readSerialNotifierStateSet(false)
-    , emittedReadyRead(false)
-    , emittedBytesWritten(false)
     , portError(SerialPort::NoError)
-    , engine(0)
-    , q_ptr(parent)
-
-{
-    engine = SerialPortEngine::create(this);
-    Q_ASSERT(engine);
-}
-
-/*! \internal
-
-    Destructs the SerialPort. Also, if the native engine exists, that gets
-    deleted.
-*/
-SerialPortPrivate::~SerialPortPrivate()
+    , inputRate(0)
+    , outputRate(0)
+    , dataBits(SerialPort::UnknownDataBits)
+    , parity(SerialPort::UnknownParity)
+    , stopBits(SerialPort::UnknownStopBits)
+    , flow(SerialPort::UnknownFlowControl)
+    , restoreSettingsOnClose(true)
+    , q_ptr(q)
 {
-    if (engine)
-        delete engine;
 }
 
-/*! \internal
-
-    Writes the pending data in the write buffers to the serial port.
-    The function writes out as much as it can without blocking.
-
-    This method is usually invoked by the write notification after one
-    or more calls to write().
-
-    Emits bytesWritten().
-*/
-bool SerialPortPrivate::flush()
-{
-    Q_Q(SerialPort);
-
-    if (writeBuffer.isEmpty())
-        return false;
-
-    const int nextSize = writeBuffer.nextDataBlockSize();
-    const char *ptr = writeBuffer.readPointer();
-
-    // Attempt to write it all in one chunk.
-    const qint64 written = engine->write(ptr, nextSize);
-    if (written < 0) {
-        setError(SerialPort::IoError);
-        writeBuffer.clear();
-        return false;
-    }
-
-    // Remove what we wrote so far.
-    writeBuffer.free(written);
-    if (written > 0) {
-        // Don't emit bytesWritten() recursively.
-        if (!emittedBytesWritten) {
-            emittedBytesWritten = true;
-            emit q->bytesWritten(written);
-            emittedBytesWritten = false;
-        }
-    }
-
-    if (writeBuffer.isEmpty() && engine->isWriteNotificationEnabled())
-        engine->setWriteNotificationEnabled(false);
-
-    return true;
-}
-
-/*! \internal
-
-    Sets the error code \a error in the corresponding internal variable.
-*/
-void SerialPortPrivate::setError(SerialPort::PortError error)
-{
-    portError = error;
-}
-
-/*! \internal
-
-    Clears the internal read and write buffers.
-*/
-void SerialPortPrivate::clearBuffers()
-{
-    writeBuffer.clear();
-    readBuffer.clear();
-}
-
-/*! \internal
-
-    Reads the data from the serial port into the read buffer. Returns
-    true on success; otherwise returns false. This operation takes place
-    automatically when the driver (UART) has at least one byte in the input
-    buffer, for instance after an event.
-*/
-bool SerialPortPrivate::readFromPort()
-{
-    qint64 bytesToRead = options.policy == SerialPort::IgnorePolicy ?
-                SERIALPORT_READ_CHUNKSIZE : 1;
-
-    if (readBufferMaxSize && bytesToRead > (readBufferMaxSize - readBuffer.size()))
-        bytesToRead = readBufferMaxSize - readBuffer.size();
-
-    char *ptr = readBuffer.reserve(bytesToRead);
-    const qint64 readBytes = engine->read(ptr, bytesToRead);
-
-    if (readBytes == -2) {
-        // No bytes currently available for reading.
-        // Note: only in *nix
-        readBuffer.chop(bytesToRead);
-        return true;
-    }
-
-    readBuffer.chop(bytesToRead - qMax(readBytes, qint64(0)));
-
-    if (readBytes < 0) {
-        setError(SerialPort::IoError);
-        return false;
-    }
-
-    return true;
-}
-
-/*! \internal
-
-    This method is called from the native engine when there is new data
-    available for reading, for instance after the handler read notification.
-    Handles recursive calls.
-*/
-bool SerialPortPrivate::canReadNotification()
-{
-    Q_Q(SerialPort);
-
-#ifdef Q_OS_WINCE
-    engine->lockNotification(SerialPortEngine::CanReadLocker, true);
-#endif
-    // Prevent recursive calls.
-    if (readSerialNotifierCalled) {
-        if (!readSerialNotifierStateSet) {
-            readSerialNotifierStateSet = true;
-            readSerialNotifierState = engine->isReadNotificationEnabled();
-            engine->setReadNotificationEnabled(false);
-        }
-    }
-    readSerialNotifierCalled = true;
-
-    //if (!isBuffered)
-    //    this->serialEngine->setReadNotificationEnabled(false);
-
-    // If buffered, read data from the serial into the read buffer.
-    qint64 newBytes = 0;
-    if (isBuffered) {
-        // Return if there is no space in the buffer.
-        if (readBufferMaxSize && readBuffer.size() >= readBufferMaxSize) {
-            readSerialNotifierCalled = false;
-            return false;
-        }
-
-        newBytes = readBuffer.size();
-
-        if (!readFromPort()) {
-            readSerialNotifierCalled = false;
-            return false;
-        }
-        newBytes = readBuffer.size() - newBytes;
-
-        // If read buffer is full, disable the read serial notifier.
-        if (readBufferMaxSize && readBuffer.size() == readBufferMaxSize) {
-            engine->setReadNotificationEnabled(false);
-        }
-    }
-
-    // Only emit readyRead() when not recursing,
-    // and only if there is data available.
-    const bool hasData = isBuffered ? (newBytes > 0) : true;
-
-    if (!emittedReadyRead && hasData) {
-        emittedReadyRead = true;
-        emit q->readyRead();
-        emittedReadyRead = false;
-    }
-
-    if (!hasData && engine->isReadNotificationEnabled())
-        engine->setReadNotificationEnabled(true);
-
-    // Reset the read serial notifier state if we reentered inside the
-    // readyRead() connected slot.
-    if (readSerialNotifierStateSet
-            && readSerialNotifierState != engine->isReadNotificationEnabled()) {
-        engine->setReadNotificationEnabled(readSerialNotifierState);
-        readSerialNotifierStateSet = false;
-    }
-    readSerialNotifierCalled = false;
-    return true;
-}
-
-/*! \internal
-
-    This method is called from the native engine when the serial port is ready
-    for writing, for instance after the handler write notification. Handles
-    recursive calls.
-*/
-bool SerialPortPrivate::canWriteNotification()
+int SerialPortPrivateData::timeoutValue(int msecs, int elapsed)
 {
-#ifdef Q_OS_WINCE
-    engine->lockNotification(SerialPortEngine::CanWriteLocker, true);
-#endif
-
-#ifdef Q_OS_WIN
-    if (engine->isWriteNotificationEnabled())
-        engine->setWriteNotificationEnabled(false);
-#endif
-
-    const int tmp = writeBuffer.size();
-    flush();
-
-#ifdef Q_OS_WIN
-    if (!writeBuffer.isEmpty())
-        engine->setWriteNotificationEnabled(true);
-#else
-    if (writeBuffer.isEmpty())
-        engine->setWriteNotificationEnabled(false);
-#endif
-    return writeBuffer.size() < tmp;
-}
-
-/*! \internal
-
-    This method is called from the native engine when the serial
-    port hardware detects an I/O error. Typical examples are parity, frame
-    errors and so forth. Handles recursive calls.
-*/
-bool SerialPortPrivate::canErrorNotification()
-{
-#ifdef Q_OS_WINCE
-    engine->lockNotification(SerialPortEngine::CanErrorLocker, true);
-#endif
-    return engine->processIOErrors();
+    if (msecs == -1)
+        return msecs;
+    msecs -= elapsed;
+    return qMax(msecs, 0);
 }
 
 /*!
@@ -657,7 +429,7 @@ SerialPort::~SerialPort()
 void SerialPort::setPort(const QString &name)
 {
     Q_D(SerialPort);
-    d->options.systemLocation = SerialPortPrivate::portNameToSystemLocation(name);
+    d->systemLocation = SerialPortPrivate::portNameToSystemLocation(name);
 }
 
 /*!
@@ -668,7 +440,7 @@ void SerialPort::setPort(const QString &name)
 void SerialPort::setPort(const SerialPortInfo &info)
 {
     Q_D(SerialPort);
-    d->options.systemLocation = SerialPortPrivate::portNameToSystemLocation(info.systemLocation());
+    d->systemLocation = SerialPortPrivate::portNameToSystemLocation(info.systemLocation());
 }
 
 /*!
@@ -710,7 +482,7 @@ void SerialPort::setPort(const SerialPortInfo &info)
 QString SerialPort::portName() const
 {
     Q_D(const SerialPort);
-    return SerialPortPrivate::portNameFromSystemLocation(d->options.systemLocation);
+    return SerialPortPrivate::portNameFromSystemLocation(d->systemLocation);
 }
 
 /*! \reimp
@@ -729,30 +501,20 @@ bool SerialPort::open(OpenMode mode)
     Q_D(SerialPort);
 
     if (isOpen()) {
-        d->setError(SerialPort::DeviceAlreadyOpenedError);
+        d->portError = SerialPort::DeviceAlreadyOpenedError;
         return false;
     }
 
     // Define while not supported modes.
-    static const OpenMode unsupportedModes = Append | Truncate | Text;
+    static const OpenMode unsupportedModes = Append | Truncate | Text | Unbuffered;
     if ((mode & unsupportedModes) || mode == NotOpen) {
-        d->setError(SerialPort::UnsupportedPortOperationError);
+        d->portError = SerialPort::UnsupportedPortOperationError;
         return false;
     }
 
     unsetError();
-    if (d->engine->open(d->options.systemLocation, mode)) {
+    if (d->open(mode)) {
         QIODevice::open(mode);
-        d->clearBuffers();
-
-        if (mode & ReadOnly)
-            d->engine->setReadNotificationEnabled(true);
-        if (mode & WriteOnly)
-            d->engine->setWriteNotificationEnabled(true);
-
-        d->engine->setErrorNotificationEnabled(true);
-
-        d->isBuffered = (mode & Unbuffered) == 0;
         return true;
     }
     return false;
@@ -768,17 +530,12 @@ void SerialPort::close()
 {
     Q_D(SerialPort);
     if (!isOpen()) {
-        d->setError(SerialPort::DeviceIsNotOpenedError);
+        d->portError = SerialPort::DeviceIsNotOpenedError;
         return;
     }
 
-    flush();
     QIODevice::close();
-    d->engine->setReadNotificationEnabled(false);
-    d->engine->setWriteNotificationEnabled(false);
-    d->engine->setErrorNotificationEnabled(false);
-    d->clearBuffers();
-    d->engine->close(d->options.systemLocation);
+    d->close();
 }
 
 /*!
@@ -793,7 +550,7 @@ void SerialPort::close()
 void SerialPort::setRestoreSettingsOnClose(bool restore)
 {
     Q_D( SerialPort);
-    d->options.restoreSettingsOnClose = restore;
+    d->restoreSettingsOnClose = restore;
 }
 
 /*!
@@ -806,7 +563,7 @@ void SerialPort::setRestoreSettingsOnClose(bool restore)
 bool SerialPort::restoreSettingsOnClose() const
 {
     Q_D(const SerialPort);
-    return d->options.restoreSettingsOnClose;
+    return d->restoreSettingsOnClose;
 }
 
 /*!
@@ -823,11 +580,11 @@ bool SerialPort::restoreSettingsOnClose() const
 bool SerialPort::setRate(qint32 rate, Directions dir)
 {
     Q_D(SerialPort);
-    if (d->engine->setRate(rate, dir)) {
+    if (d->setRate(rate, dir)) {
         if (dir & SerialPort::Input)
-            d->options.inputRate = rate;
+            d->inputRate = rate;
         if (dir & SerialPort::Output)
-            d->options.outputRate = rate;
+            d->outputRate = rate;
         return true;
     }
     return false;
@@ -845,9 +602,9 @@ qint32 SerialPort::rate(Directions dir) const
 {
     Q_D(const SerialPort);
     if (dir == SerialPort::AllDirections)
-        return d->options.inputRate == d->options.outputRate ?
-                    d->options.inputRate : SerialPort::UnknownRate;
-    return dir & SerialPort::Input ? d->options.inputRate : d->options.outputRate;
+        return d->inputRate == d->outputRate ?
+                    d->inputRate : SerialPort::UnknownRate;
+    return dir & SerialPort::Input ? d->inputRate : d->outputRate;
 }
 
 /*!
@@ -860,8 +617,8 @@ qint32 SerialPort::rate(Directions dir) const
 bool SerialPort::setDataBits(DataBits dataBits)
 {
     Q_D(SerialPort);
-    if (d->engine->setDataBits(dataBits)) {
-        d->options.dataBits = dataBits;
+    if (d->setDataBits(dataBits)) {
+        d->dataBits = dataBits;
         return true;
     }
     return false;
@@ -875,7 +632,7 @@ bool SerialPort::setDataBits(DataBits dataBits)
 SerialPort::DataBits SerialPort::dataBits() const
 {
     Q_D(const SerialPort);
-    return d->options.dataBits;
+    return d->dataBits;
 }
 
 /*!
@@ -888,8 +645,8 @@ SerialPort::DataBits SerialPort::dataBits() const
 bool SerialPort::setParity(Parity parity)
 {
     Q_D(SerialPort);
-    if (d->engine->setParity(parity)) {
-        d->options.parity = parity;
+    if (d->setParity(parity)) {
+        d->parity = parity;
         return true;
     }
     return false;
@@ -903,7 +660,7 @@ bool SerialPort::setParity(Parity parity)
 SerialPort::Parity SerialPort::parity() const
 {
     Q_D(const SerialPort);
-    return d->options.parity;
+    return d->parity;
 }
 
 /*!
@@ -916,8 +673,8 @@ SerialPort::Parity SerialPort::parity() const
 bool SerialPort::setStopBits(StopBits stopBits)
 {
     Q_D(SerialPort);
-    if (d->engine->setStopBits(stopBits)) {
-        d->options.stopBits = stopBits;
+    if (d->setStopBits(stopBits)) {
+        d->stopBits = stopBits;
         return true;
     }
     return false;
@@ -931,7 +688,7 @@ bool SerialPort::setStopBits(StopBits stopBits)
 SerialPort::StopBits SerialPort::stopBits() const
 {
     Q_D(const SerialPort);
-    return d->options.stopBits;
+    return d->stopBits;
 }
 
 /*!
@@ -944,8 +701,8 @@ SerialPort::StopBits SerialPort::stopBits() const
 bool SerialPort::setFlowControl(FlowControl flow)
 {
     Q_D(SerialPort);
-    if (d->engine->setFlowControl(flow)) {
-        d->options.flow = flow;
+    if (d->setFlowControl(flow)) {
+        d->flow = flow;
         return true;
     }
     return false;
@@ -959,7 +716,7 @@ bool SerialPort::setFlowControl(FlowControl flow)
 SerialPort::FlowControl SerialPort::flowControl() const
 {
     Q_D(const SerialPort);
-    return d->options.flow;
+    return d->flow;
 }
 
 /*!
@@ -971,7 +728,7 @@ SerialPort::FlowControl SerialPort::flowControl() const
 bool SerialPort::dtr() const
 {
     Q_D(const SerialPort);
-    return d->engine->lines() & SerialPort::Dtr;
+    return d->lines() & SerialPort::Dtr;
 }
 
 /*!
@@ -983,7 +740,7 @@ bool SerialPort::dtr() const
 bool SerialPort::rts() const
 {
     Q_D(const SerialPort);
-    return d->engine->lines() & SerialPort::Rts;
+    return d->lines() & SerialPort::Rts;
 }
 
 /*!
@@ -997,7 +754,7 @@ bool SerialPort::rts() const
 SerialPort::Lines SerialPort::lines() const
 {
     Q_D(const SerialPort);
-    return d->engine->lines();
+    return d->lines();
 }
 
 /*!
@@ -1017,7 +774,7 @@ SerialPort::Lines SerialPort::lines() const
 bool SerialPort::flush()
 {
     Q_D(SerialPort);
-    return d->flush() || d->engine->flush();
+    return d->flush();
 }
 
 /*! \reimp
@@ -1028,8 +785,9 @@ bool SerialPort::flush()
 bool SerialPort::reset()
 {
     Q_D(SerialPort);
-    d->clearBuffers();
-    return d->engine->reset();
+    d->readBuffer.clear();
+    d->writeBuffer.clear();
+    return d->reset();
 }
 
 /*! \reimp
@@ -1069,9 +827,9 @@ bool SerialPort::atEnd() const
 bool SerialPort::setDataErrorPolicy(DataErrorPolicy policy)
 {
     Q_D(SerialPort);
-    const bool ret = d->options.policy == policy || d->engine->setDataErrorPolicy(policy);
+    const bool ret = d->policy == policy || d->setDataErrorPolicy(policy);
     if (ret)
-        d->options.policy = policy;
+        d->policy = policy;
     return ret;
 }
 
@@ -1083,7 +841,7 @@ bool SerialPort::setDataErrorPolicy(DataErrorPolicy policy)
 SerialPort::DataErrorPolicy SerialPort::dataErrorPolicy() const
 {
     Q_D(const SerialPort);
-    return d->options.policy;
+    return d->policy;
 }
 
 /*!
@@ -1151,14 +909,6 @@ void SerialPort::setReadBufferSize(qint64 size)
     if (d->readBufferMaxSize == size)
         return;
     d->readBufferMaxSize = size;
-    if (!d->readSerialNotifierCalled && d->engine) {
-        // Ensure that the read notification is enabled if we've now got
-        // room in the read buffer.
-        // But only if we're not inside canReadNotification --
-        // that will take care on its own.
-        if (size == 0 || d->readBuffer.size() < size)
-            d->engine->setReadNotificationEnabled(true);
-    }
 }
 
 /*! \reimp
@@ -1177,12 +927,7 @@ bool SerialPort::isSequential() const
 qint64 SerialPort::bytesAvailable() const
 {
     Q_D(const SerialPort);
-    qint64 ret;
-    if (d->isBuffered)
-        ret = d->readBuffer.size();
-    else
-        ret = d->engine->bytesAvailable();
-    return ret + QIODevice::bytesAvailable();
+    return d->readBuffer.size() + QIODevice::bytesAvailable();
 }
 
 /*! \reimp
@@ -1195,12 +940,7 @@ qint64 SerialPort::bytesAvailable() const
 qint64 SerialPort::bytesToWrite() const
 {
     Q_D(const SerialPort);
-    qint64 ret;
-    if (d->isBuffered)
-        ret = d->writeBuffer.size();
-    else
-        ret = d->engine->bytesToWrite();
-    return ret + QIODevice::bytesToWrite();
+    return d->writeBuffer.size() + QIODevice::bytesToWrite();
 }
 
 /*! \reimp
@@ -1216,16 +956,6 @@ bool SerialPort::canReadLine() const
     return hasLine || QIODevice::canReadLine();
 }
 
-// Returns the difference between msecs and elapsed. If msecs is -1,
-// however, -1 is returned.
-static int qt_timeout_value(int msecs, int elapsed)
-{
-    if (msecs == -1)
-        return msecs;
-    msecs -= elapsed;
-    return qMax(msecs, 0);
-}
-
 /*! \reimp
     This function blocks until new data is available for reading and the
     \l{QIODevice::}{readyRead()} signal has been emitted. The function
@@ -1240,37 +970,7 @@ static int qt_timeout_value(int msecs, int elapsed)
 bool SerialPort::waitForReadyRead(int msecs)
 {
     Q_D(SerialPort);
-
-    if (d->isBuffered && !d->readBuffer.isEmpty())
-        return true;
-
-    if (d->engine->isReadNotificationEnabled())
-        d->engine->setReadNotificationEnabled(false);
-
-#if QT_VERSION >= 0x040700
-    QElapsedTimer stopWatch;
-#else
-    QTime stopWatch;
-#endif
-
-    stopWatch.start();
-
-    forever {
-        bool readyToRead = false;
-        bool readyToWrite = false;
-        if (!d->engine->select(qt_timeout_value(msecs, stopWatch.elapsed()),
-                               true, !d->writeBuffer.isEmpty(),
-                               &readyToRead, &readyToWrite)) {
-            return false;
-        }
-        if (readyToRead) {
-            if (d->canReadNotification())
-                return true;
-        }
-        if (readyToWrite)
-            d->canWriteNotification();
-    }
-    return false;
+    return d->waitForReadyRead(msecs);
 }
 
 /*! \reimp
@@ -1278,40 +978,9 @@ bool SerialPort::waitForReadyRead(int msecs)
 bool SerialPort::waitForBytesWritten(int msecs)
 {
     Q_D(SerialPort);
-
-    if (d->isBuffered && d->writeBuffer.isEmpty())
-        return false;
-
-#if QT_VERSION >= 0x040700
-    QElapsedTimer stopWatch;
-#else
-    QTime stopWatch;
-#endif
-
-    stopWatch.start();
-
-    forever {
-        bool readyToRead = false;
-        bool readyToWrite = false;
-        if (!d->engine->select(qt_timeout_value(msecs, stopWatch.elapsed()),
-                               true, !d->writeBuffer.isEmpty(),
-                               &readyToRead, &readyToWrite)) {
-            return false;
-        }
-        if (readyToRead) {
-            if (!d->canReadNotification())
-                return false;
-        }
-        if (readyToWrite) {
-            if (d->canWriteNotification())
-                return true;
-        }
-    }
-    return false;
+    return d->waitForBytesWritten(msecs);
 }
 
-/* Public slots */
-
 /*!
     Sets the desired state of the line signal DTR,
     depending on the flag \a set. If successful, returns true;
@@ -1324,7 +993,7 @@ bool SerialPort::waitForBytesWritten(int msecs)
 bool SerialPort::setDtr(bool set)
 {
     Q_D(SerialPort);
-    return d->engine->setDtr(set);
+    return d->setDtr(set);
 }
 
 /*!
@@ -1339,7 +1008,7 @@ bool SerialPort::setDtr(bool set)
 bool SerialPort::setRts(bool set)
 {
     Q_D(SerialPort);
-    return d->engine->setRts(set);
+    return d->setRts(set);
 }
 
 /*!
@@ -1358,7 +1027,7 @@ bool SerialPort::setRts(bool set)
 bool SerialPort::sendBreak(int duration)
 {
     Q_D(SerialPort);
-    return d->engine->sendBreak(duration);
+    return d->sendBreak(duration);
 }
 
 /*!
@@ -1372,83 +1041,15 @@ bool SerialPort::sendBreak(int duration)
 bool SerialPort::setBreak(bool set)
 {
     Q_D(SerialPort);
-    return d->engine->setBreak(set);
+    return d->setBreak(set);
 }
 
-/* Protected methods */
-
 /*! \reimp
 */
 qint64 SerialPort::readData(char *data, qint64 maxSize)
 {
     Q_D(SerialPort);
-
-    // This is for a buffered SerialPort
-    if (d->isBuffered && d->readBuffer.isEmpty())
-        return 0;
-
-    // short cut for a char read if we have something in the buffer
-    if (maxSize == 1 && !d->readBuffer.isEmpty()) {
-        *data = d->readBuffer.getChar();
-        return 1;
-    }
-
-    // Special case for an Unbuffered SerialPort
-    // Re-filling the buffer.
-    if (!d->isBuffered
-            && d->readBuffer.size() < maxSize
-            && d->readBufferMaxSize > 0
-            && maxSize < d->readBufferMaxSize) {
-        // Our buffer is empty and a read() was requested for a byte amount that is smaller
-        // than the readBufferMaxSize. This means that we should fill our buffer since we want
-        // such small reads come from the buffer and not always go to the costly serial engine read()
-        const qint64 bytesToRead = SERIALPORT_READ_CHUNKSIZE;
-        if (bytesToRead > 0) {
-            char *ptr = d->readBuffer.reserve(bytesToRead);
-            const qint64 readBytes = d->engine->read(ptr, bytesToRead);
-            if (readBytes == -2)
-                d->readBuffer.chop(bytesToRead); // No bytes currently available for reading.
-            else
-                d->readBuffer.chop(bytesToRead - qMax(readBytes, qint64(0)));
-        }
-    }
-
-    // First try to satisfy the read from the buffer
-    const qint64 bytesToRead = qMin(qint64(d->readBuffer.size()), maxSize);
-    qint64 readSoFar = 0;
-    while (readSoFar < bytesToRead) {
-        const char *ptr = d->readBuffer.readPointer();
-        const int bytesToReadFromThisBlock = qMin(int(bytesToRead - readSoFar),
-                                                  d->readBuffer.nextDataBlockSize());
-        memcpy(data + readSoFar, ptr, bytesToReadFromThisBlock);
-        readSoFar += bytesToReadFromThisBlock;
-        d->readBuffer.free(bytesToReadFromThisBlock);
-    }
-
-    if (!d->engine->isReadNotificationEnabled())
-        d->engine->setReadNotificationEnabled(true);
-
-    if (readSoFar > 0)
-        return readSoFar;
-
-    // This code path is for Unbuffered SerialPort
-    if (!d->isBuffered) {
-        const qint64 readBytes = d->engine->read(data, maxSize);
-
-        // -2 from the engine means no bytes available (EAGAIN) so read more later
-        // Note: only in *nix
-        if (readBytes == -2)
-            return 0;
-
-        if (readBytes < 0)
-            d->setError(SerialPort::IoError);
-        else if (!d->engine->isReadNotificationEnabled())
-            d->engine->setReadNotificationEnabled(true); // Only do this when there was no error
-
-        return readBytes;
-    }
-
-    return readSoFar;
+    return d->readFromBuffer(data, maxSize);
 }
 
 /*! \reimp
@@ -1463,31 +1064,7 @@ qint64 SerialPort::readLineData(char *data, qint64 maxSize)
 qint64 SerialPort::writeData(const char *data, qint64 maxSize)
 {
     Q_D(SerialPort);
-
-    if (!d->isBuffered) {
-        const qint64 written = d->engine->write(data, maxSize);
-
-        if (written < 0)
-            d->setError(SerialPort::IoError);
-        else if (!d->writeBuffer.isEmpty())
-            d->engine->setWriteNotificationEnabled(true);
-
-        if (written >= 0)
-            emit bytesWritten(written);
-
-        return written;
-    }
-
-    char *ptr = d->writeBuffer.reserve(maxSize);
-    if (maxSize == 1)
-        *ptr = *data;
-    else
-        memcpy(ptr, data, maxSize);
-
-    if (!d->writeBuffer.isEmpty())
-        d->engine->setWriteNotificationEnabled(true);
-
-    return maxSize;
+    return d->writeToBuffer(data, maxSize);
 }
 
 /*!
diff --git a/src/serialport_p.h b/src/serialport_p.h
index bf004ee..852e7f5 100755
--- a/src/serialport_p.h
+++ b/src/serialport_p.h
@@ -54,23 +54,22 @@
 
 QT_BEGIN_NAMESPACE_SERIALPORT
 
-class SerialPortEngine;
-
-// General port parameters (for any OS).
-class SerialPortOptions
+class SerialPortPrivateData
 {
+    Q_DECLARE_PUBLIC(SerialPort)
 public:
-    SerialPortOptions()
-        : inputRate(SerialPort::UnknownRate)
-        , outputRate(SerialPort::UnknownRate)
-        , dataBits(SerialPort::UnknownDataBits)
-        , parity(SerialPort::UnknownParity)
-        , stopBits(SerialPort::UnknownStopBits)
-        , flow(SerialPort::UnknownFlowControl)
-        , policy(SerialPort::IgnorePolicy)
-        , restoreSettingsOnClose(true)
-    {}
+    enum IoConstants {
+        ReadChunkSize = 512,
+        WriteChunkSize = 512
+    };
 
+    SerialPortPrivateData(SerialPort *q);
+    int timeoutValue(int msecs, int elapsed);
+
+    qint64 readBufferMaxSize;
+    QRingBuffer readBuffer;
+    QRingBuffer writeBuffer;
+    SerialPort::PortError portError;
     QString systemLocation;
     qint32 inputRate;
     qint32 outputRate;
@@ -80,54 +79,6 @@ public:
     SerialPort::FlowControl flow;
     SerialPort::DataErrorPolicy policy;
     bool restoreSettingsOnClose;
-};
-
-class SerialPortPrivate
-{
-    Q_DECLARE_PUBLIC(SerialPort)
-public:
-    SerialPortPrivate(SerialPort *parent);
-    virtual ~SerialPortPrivate();
-
-    bool flush();
-
-    void setError(SerialPort::PortError error);
-
-    void clearBuffers();
-    bool readFromPort();
-
-    bool canReadNotification();
-    bool canWriteNotification();
-    bool canErrorNotification();
-
-public:
-    static QString portNameToSystemLocation(const QString &port);
-    static QString portNameFromSystemLocation(const QString &location);
-
-    static qint32 rateFromSetting(qint32 setting);
-    static qint32 settingFromRate(qint32 rate);
-
-    static QList<qint32> standardRates();
-
-public:
-    qint64 readBufferMaxSize;
-    QRingBuffer readBuffer;
-    QRingBuffer writeBuffer;
-    bool isBuffered;
-
-    bool readSerialNotifierCalled;
-    bool readSerialNotifierState;
-    bool readSerialNotifierStateSet;
-    bool emittedReadyRead;
-    bool emittedBytesWritten;
-
-    SerialPort::PortError portError;
-
-    SerialPortEngine *engine;
-
-    SerialPortOptions options;
-
-private:
     SerialPort * const q_ptr;
 };
 
diff --git a/src/serialport_symbian.cpp b/src/serialport_symbian.cpp
new file mode 100644
index 0000000..c29ecc8
--- /dev/null
+++ b/src/serialport_symbian.cpp
@@ -0,0 +1,640 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "serialport_symbian_p.h"
+
+#include <e32base.h>
+//#include <e32test.h>
+#include <f32file.h>
+
+#include <QtCore/qregexp.h>
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+// Physical device driver.
+#ifdef __WINS__
+_LIT(KPddName, "ECDRV");
+#else // defined (__EPOC32__)
+_LIT(KPddName, "EUART");
+#endif
+
+// Logical  device driver.
+_LIT(KLddName,"ECOMM");
+
+// Modules names.
+_LIT(KRS232ModuleName, "ECUART");
+_LIT(KBluetoothModuleName, "BTCOMM");
+_LIT(KInfraRedModuleName, "IRCOMM");
+_LIT(KACMModuleName, "ECACM");
+
+// Return false on error load.
+static bool loadDevices()
+{
+    TInt r = KErrNone;
+#ifdef __WINS__
+    RFs fileServer;
+    r = User::LeaveIfError(fileServer.Connect());
+    if (r != KErrNone)
+        return false;
+    fileServer.Close ();
+#endif
+
+    r = User::LoadPhysicalDevice(KPddName);
+    if (r != KErrNone && r != KErrAlreadyExists)
+        return false; //User::Leave(r);
+
+    r = User::LoadLogicalDevice(KLddName);
+    if (r != KErrNone && r != KErrAlreadyExists)
+        return false; //User::Leave(r);
+
+#ifndef __WINS__
+    r = StartC32();
+    if (r != KErrNone && r != KErrAlreadyExists)
+        return false; //User::Leave(r);
+#endif
+
+    return true;
+}
+
+SerialPortPrivate::SerialPortPrivate(SerialPort *q)
+    : SerialPortPrivateData(q)
+    , errnum(KErrNone)
+{
+}
+
+bool SerialPortPrivate::open(QIODevice::OpenMode mode)
+{
+    // FIXME: Maybe need added check an ReadWrite open mode?
+    Q_UNUSED(mode)
+
+    if (!loadDevices()) {
+        portError = SerialPort::UnknownPortError;
+        return false;
+    }
+
+    RCommServ server;
+    errnum = server.Connect();
+    if (errnum != KErrNone) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    if (systemLocation.contains("BTCOMM"))
+        errnum = server.LoadCommModule(KBluetoothModuleName);
+    else if (systemLocation.contains("IRCOMM"))
+        errnum = server.LoadCommModule(KInfraRedModuleName);
+    else if (systemLocation.contains("ACM"))
+        errnum = server.LoadCommModule(KACMModuleName);
+    else
+        errnum = server.LoadCommModule(KRS232ModuleName);
+
+    if (errnum != KErrNone) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    // In Symbian OS port opening only in R/W mode?
+    TPtrC portName(static_cast<const TUint16*>(systemLocation.utf16()), systemLocation.length());
+    errnum = descriptor.Open(server, portName, ECommExclusive);
+
+    if (errnum != KErrNone) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    // Save current port settings.
+    errnum = descriptor.Config(restoredSettings);
+    if (errnum != KErrNone) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    detectDefaultSettings();
+    return true;
+}
+
+void SerialPortPrivate::close()
+{
+    if (restoreSettingsOnClose)
+        descriptor.SetConfig(restoredSettings);
+    descriptor.Close();
+}
+
+SerialPort::Lines SerialPortPrivate::lines() const
+{
+    SerialPort::Lines ret = 0;
+
+    TUint signalMask = 0;
+    descriptor.Signals(signalMask);
+
+    if (signalMask & KSignalCTS)
+        ret |= SerialPort::Cts;
+    if (signalMask & KSignalDSR)
+        ret |= SerialPort::Dsr;
+    if (signalMask & KSignalDCD)
+        ret |= SerialPort::Dcd;
+    if (signalMask & KSignalRNG)
+        ret |= SerialPort::Ri;
+    if (signalMask & KSignalRTS)
+        ret |= SerialPort::Rts;
+    if (signalMask & KSignalDTR)
+        ret |= SerialPort::Dtr;
+
+    //if (signalMask & KSignalBreak)
+    //  ret |=
+    return ret;
+}
+
+bool SerialPortPrivate::setDtr(bool set)
+{
+    TInt r;
+    if (set)
+        r = descriptor.SetSignalsToMark(KSignalDTR);
+    else
+        r = descriptor.SetSignalsToSpace(KSignalDTR);
+
+    return r == KErrNone;
+}
+
+bool SerialPortPrivate::setRts(bool set)
+{
+    TInt r;
+    if (set)
+        r = descriptor.SetSignalsToMark(KSignalRTS);
+    else
+        r = descriptor.SetSignalsToSpace(KSignalRTS);
+
+    return r == KErrNone;
+}
+
+bool SerialPortPrivate::flush()
+{
+    // TODO: Implement me
+    return false;
+}
+
+bool SerialPortPrivate::reset()
+{
+    TInt r = descriptor.ResetBuffers(KCommResetRx | KCommResetTx);
+    return r == KErrNone;
+}
+
+bool SerialPortPrivate::sendBreak(int duration)
+{
+    TRequestStatus status;
+    descriptor.Break(status, TTimeIntervalMicroSeconds32(duration * 1000));
+    return false;
+}
+
+bool SerialPortPrivate::setBreak(bool set)
+{
+    // TODO: Implement me
+    return false;
+}
+
+qint64 SerialPortPrivate::bytesAvailable() const
+{
+    return descriptor.QueryReceiveBuffer();
+}
+
+qint64 SerialPortPrivate::bytesToWrite() const
+{
+    // TODO: Implement me
+    return 0;
+}
+
+qint64 SerialPortPrivate::readFromBuffer(char *data, qint64 maxSize)
+{
+    // TODO: Implement me
+    return -1;
+}
+
+qint64 SerialPortPrivate::writeToBuffer(const char *data, qint64 maxSize)
+{
+    // TODO: Implement me
+    return -1;
+}
+
+bool SerialPortPrivate::waitForReadyRead(int msec)
+{
+    // TODO: Implement me
+    return false;
+}
+
+bool SerialPortPrivate::waitForBytesWritten(int msec)
+{
+    // TODO: Implement me
+    return false;
+}
+
+bool SerialPortPrivate::setRate(qint32 rate, SerialPort::Directions dir)
+{
+    if (dir != SerialPort::AllDirections) {
+        portError = SerialPort::UnsupportedPortOperationError;
+        return false;
+    }
+
+    rate = settingFromRate(rate);
+    if (rate)
+        currentSettings().iRate = static_cast<TBps>(rate);
+    else {
+        portError = SerialPort::UnsupportedPortOperationError;
+        return false;
+    }
+
+    return updateCommConfig();
+}
+
+bool SerialPortPrivate::setDataBits(SerialPort::DataBits dataBits)
+{
+    switch (dataBits) {
+    case SerialPort::Data5:
+        currentSettings().iDataBits = EData5;
+        break;
+    case SerialPort::Data6:
+        currentSettings().iDataBits = EData6;
+        break;
+    case SerialPort::Data7:
+        currentSettings().iDataBits = EData7;
+        break;
+    case SerialPort::Data8:
+        currentSettings().iDataBits = EData8;
+        break;
+    default:
+        currentSettings().iDataBits = EData8;
+        break;
+    }
+
+    return updateCommConfig();
+}
+
+bool SerialPortPrivate::setParity(SerialPort::Parity parity)
+{
+    switch (parity) {
+    case SerialPort::NoParity:
+        currentSettings().iParity = EParityNone;
+        break;
+    case SerialPort::EvenParity:
+        currentSettings().iParity = EParityEven;
+        break;
+    case SerialPort::OddParity:
+        currentSettings().iParity = EParityOdd;
+        break;
+    case SerialPort::MarkParity:
+        currentSettings().iParity = EParityMark;
+        break;
+    case SerialPort::SpaceParity:
+        currentSettings().iParity = EParitySpace;
+        break;
+    default:
+        currentSettings().iParity = EParityNone;
+        break;
+    }
+
+    return updateCommConfig();
+}
+
+bool SerialPortPrivate::setStopBits(SerialPort::StopBits stopBits)
+{
+    switch (stopBits) {
+    case SerialPort::OneStop:
+        currentSettings().iStopBits = EStop1;
+        break;
+    case SerialPort::TwoStop:
+        currentSettings().iStopBits = EStop2;
+        break;
+    default:
+        currentSettings().iStopBits = EStop1;
+        break;
+    }
+
+    return updateCommConfig();
+}
+
+bool SerialPortPrivate::setFlowControl(SerialPort::FlowControl flow)
+{
+    switch (flow) {
+    case SerialPort::NoFlowControl:
+        currentSettings().iHandshake = KConfigFailDSR;
+        break;
+    case SerialPort::HardwareControl:
+        currentSettings().iHandshake = KConfigObeyCTS | KConfigFreeRTS;
+        break;
+    case SerialPort::SoftwareControl:
+        currentSettings().iHandshake = KConfigObeyXoff | KConfigSendXoff;
+        break;
+    default:
+        currentSettings().iHandshake = KConfigFailDSR;
+        break;
+    }
+
+    return updateCommConfig();
+}
+
+bool SerialPortPrivate::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
+{
+    // TODO: Implement me
+    return false;
+}
+
+bool SerialPortPrivate::notifyRead()
+{
+    // TODO: Implement me
+    return false;
+}
+
+bool SerialPortPrivate::notifyWrite()
+{
+    // TODO: Implement me
+    return false;
+}
+
+bool SerialPortPrivate::updateCommConfig()
+{
+    if (descriptor.SetConfig(currentSettings) != KErrNone) {
+        portError = SerialPort::UnsupportedPortOperationError;
+        return false;
+    }
+    return true;
+}
+
+void SerialPortPrivate::detectDefaultSettings()
+{
+    // Detect rate.
+    inputRate = rateFromSetting(currentSettings().iRate);
+    outputRate = inputRate;
+
+    // Detect databits.
+    switch (currentSettings().iDataBits) {
+    case EData5:
+        dataBits = SerialPort::Data5;
+        break;
+    case EData6:
+        dataBits = SerialPort::Data6;
+        break;
+    case EData7:
+        dataBits = SerialPort::Data7;
+        break;
+    case EData8:
+        dataBits = SerialPort::Data8;
+        break;
+    default:
+        dataBits = SerialPort::UnknownDataBits;
+        break;
+    }
+
+    // Detect parity.
+    switch (currentSettings().iParity) {
+    case EParityNone:
+        parity = SerialPort::NoParity;
+        break;
+    case EParityEven:
+        parity = SerialPort::EvenParity;
+        break;
+    case EParityOdd:
+        parity = SerialPort::OddParity;
+        break;
+    case EParityMark:
+        parity = SerialPort::MarkParity;
+        break;
+    case EParitySpace:
+        parity = SerialPort::SpaceParity;
+        break;
+    default:
+        parity = SerialPort::UnknownParity;
+        break;
+    }
+
+    // Detect stopbits.
+    switch (currentSettings().iStopBits) {
+    case EStop1:
+        stopBits = SerialPort::OneStop;
+        break;
+    case EStop2:
+        stopBits = SerialPort::TwoStop;
+        break;
+    default:
+        stopBits = SerialPort::UnknownStopBits;
+        break;
+    }
+
+    // Detect flow control.
+    if ((currentSettings().iHandshake & (KConfigObeyXoff | KConfigSendXoff))
+            == (KConfigObeyXoff | KConfigSendXoff))
+        flow = SerialPort::SoftwareControl;
+    else if ((currentSettings().iHandshake & (KConfigObeyCTS | KConfigFreeRTS))
+             == (KConfigObeyCTS | KConfigFreeRTS))
+        flow = SerialPort::HardwareControl;
+    else if (currentSettings().iHandshake & KConfigFailDSR)
+        flow = SerialPort::NoFlowControl;
+    else
+        flow = SerialPort::UnknownFlowControl;
+}
+
+SerialPort::PortError SerialPortPrivate::decodeSystemError() const
+{
+    SerialPort::PortError error;
+    switch (errnum) {
+    case KErrPermissionDenied:
+        error = SerialPort::NoSuchDeviceError;
+        break;
+    case KErrLocked:
+        error = SerialPort::PermissionDeniedError;
+        break;
+    case KErrAccessDenied:
+        error = SerialPort::PermissionDeniedError;
+        break;
+    default:
+        error = SerialPort::UnknownPortError;
+        break;
+    }
+    return error;
+}
+
+bool SerialPortPrivate::waitForReadOrWrite(bool *selectForRead, bool *selectForWrite,
+                                           bool checkRead, bool checkWrite,
+                                           int msecs, bool *timedOut)
+{
+
+    // FIXME: I'm not sure in implementation this method.
+    // Someone needs to check and correct.
+
+    TRequestStatus timerStatus;
+    TRequestStatus readStatus;
+    TRequestStatus writeStatus;
+
+    if (msecs > 0)  {
+        if (!selectTimer.Handle()) {
+            if (selectTimer.CreateLocal() != KErrNone)
+                return false;
+        }
+        selectTimer.HighRes(timerStatus, msecs * 1000);
+    }
+
+    if (checkRead)
+        descriptor.NotifyDataAvailable(readStatus);
+
+    if (checkWrite)
+        descriptor.NotifyOutputEmpty(writeStatus);
+
+    enum { STATUSES_COUNT = 3 };
+    TRequestStatus *statuses[STATUSES_COUNT];
+    TInt num = 0;
+    statuses[num++] = &timerStatus;
+    statuses[num++] = &readStatus;
+    statuses[num++] = &writeStatus;
+
+    User::WaitForNRequest(statuses, num);
+
+    bool result = false;
+
+    // By timeout?
+    if (timerStatus != KRequestPending) {
+        Q_ASSERT(selectForRead);
+        *selectForRead = false;
+        Q_ASSERT(selectForWrite);
+        *selectForWrite = false;
+    } else {
+        selectTimer.Cancel();
+        User::WaitForRequest(timerStatus);
+
+        // By read?
+        if (readStatus != KRequestPending) {
+            Q_ASSERT(selectForRead);
+            *selectForRead = true;
+        }
+
+        // By write?
+        if (writeStatus != KRequestPending) {
+            Q_ASSERT(selectForWrite);
+            *selectForWrite = true;
+        }
+
+        if (checkRead)
+            descriptor.NotifyDataAvailableCancel();
+        if (checkWrite)
+            descriptor.NotifyOutputEmptyCancel();
+
+        result = true;
+    }
+    return result;
+}
+
+QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
+{
+    // Port name is equval to port systemLocation.
+    return port;
+}
+
+QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
+{
+    // Port name is equval to port systemLocation.
+    return location;
+}
+
+struct RatePair
+{
+    qint32 rate;    // The numerical value of baud rate.
+    qint32 setting; // The OS-specific code of baud rate.
+    bool operator<(const RatePair &other) const { return rate < other.rate; }
+    bool operator==(const RatePair &other) const { return setting == other.setting; }
+};
+
+// This table contains correspondences standard pairs values of
+// baud rates that are defined in files
+// - d32comm.h for Symbian^3
+// - d32public.h for Symbian SR1
+static const RatePair standardRatesTable[] =
+{
+    { 50, EBps50 },
+    { 75, EBps75 },
+    { 110, EBps110},
+    { 134, EBps134 },
+    { 150, EBps150 },
+    { 300, EBps300 },
+    { 600, EBps600 },
+    { 1200, EBps1200 },
+    { 1800, EBps1800 },
+    { 2000, EBps2000 },
+    { 2400, EBps2400 },
+    { 3600, EBps3600 },
+    { 4800, EBps4800 },
+    { 7200, EBps7200 },
+    { 9600, EBps9600 },
+    { 19200, EBps19200 },
+    { 38400, EBps38400 },
+    { 57600, EBps57600 },
+    { 115200, EBps115200 },
+    { 230400, EBps230400 },
+    { 460800, EBps460800 },
+    { 576000, EBps576000 },
+    { 921600, EBps921600 },
+    { 1152000, EBps1152000 },
+    //{ 1843200, EBps1843200 }, only for Symbian SR1
+    { 4000000, EBps4000000 }
+};
+
+static const RatePair *standardRatesTable_end =
+        standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
+
+qint32 SerialPortPrivate::rateFromSetting(qint32 setting)
+{
+    const RatePair rp = { 0, setting };
+    const RatePair *ret = qFind(standardRatesTable, standardRatesTable_end, rp);
+    return ret != standardRatesTable_end ? ret->rate : 0;
+}
+
+qint32 SerialPortPrivate::settingFromRate(qint32 rate)
+{
+    const RatePair rp = { rate, 0 };
+    const RatePair *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rp);
+    return ret != standardRatesTable_end ? ret->setting : 0;
+}
+
+QList<qint32> SerialPortPrivate::standardRates()
+{
+    QList<qint32> ret;
+    for (const RatePair *it = standardRatesTable; it != standardRatesTable_end; ++it)
+        ret.append(it->rate);
+    return ret;
+}
+
+QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialport_symbian_p.h b/src/serialport_symbian_p.h
new file mode 100644
index 0000000..d6f1709
--- /dev/null
+++ b/src/serialport_symbian_p.h
@@ -0,0 +1,116 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig2@yandex.ru>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SERIALPORT_SYMBIAN_P_H
+#define SERIALPORT_SYMBIAN_P_H
+
+#include "serialport_p.h"
+
+#include <c32comm.h>
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+class SerialPortPrivate : public SerialPortPrivateData
+{
+public:
+    SerialPortPrivate(SerialPort *q);
+
+    bool open(QIODevice::OpenMode mode);
+    void close();
+
+    SerialPort::Lines lines() const;
+
+    bool setDtr(bool set);
+    bool setRts(bool set);
+
+    bool flush();
+    bool reset();
+
+    bool sendBreak(int duration);
+    bool setBreak(bool set);
+
+    qint64 bytesAvailable() const;
+    qint64 bytesToWrite() const;
+
+    qint64 readFromBuffer(char *data, qint64 maxSize);
+    qint64 writeToBuffer(const char *data, qint64 maxSize);
+
+    bool waitForReadyRead(int msec);
+    bool waitForBytesWritten(int msec);
+
+    bool setRate(qint32 rate, SerialPort::Directions dir);
+    bool setDataBits(SerialPort::DataBits dataBits);
+    bool setParity(SerialPort::Parity parity);
+    bool setStopBits(SerialPort::StopBits stopBits);
+    bool setFlowControl(SerialPort::FlowControl flowControl);
+    bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy);
+
+    bool notifyRead();
+    bool notifyWrite();
+
+    static QString portNameToSystemLocation(const QString &port);
+    static QString portNameFromSystemLocation(const QString &location);
+
+    static qint32 rateFromSetting(qint32 setting);
+    static qint32 settingFromRate(qint32 rate);
+
+    static QList<qint32> standardRates();
+
+    TCommConfig currentSettings;
+    TCommConfig restoredSettings;
+    RComm descriptor;
+    mutable RTimer selectTimer;
+    TInt errnum;
+
+private:
+    bool updateCommConfig();
+
+    void detectDefaultSettings();
+    SerialPort::PortError decodeSystemError() const;
+
+    bool waitForReadOrWrite(bool *selectForRead, bool *selectForWrite,
+                            bool checkRead, bool checkWrite,
+                            int msecs, bool *timedOut);
+};
+
+QT_END_NAMESPACE_SERIALPORT
+
+#endif // SERIALPORT_SYMBIAN_P_H
diff --git a/src/serialport_unix.cpp b/src/serialport_unix.cpp
new file mode 100644
index 0000000..ef9377b
--- /dev/null
+++ b/src/serialport_unix.cpp
@@ -0,0 +1,1354 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
+** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
+** Copyright (C) 2012 Andre Hartmann <aha_1980@gmx.de>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "serialport_unix_p.h"
+#include "ttylocker_unix_p.h"
+
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#ifdef Q_OS_MAC
+#if defined (MAC_OS_X_VERSION_10_4) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4)
+#include <IOKit/serial/ioss.h>
+#endif
+#endif
+
+#if (QT_VERSION >= 0x040700)
+#include <QtCore/qelapsedtimer.h>
+#else
+#include <QtCore/qtime.h>
+#endif
+
+#include <QtCore/qsocketnotifier.h>
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+class ReadNotifier : public QSocketNotifier
+{
+public:
+    ReadNotifier(SerialPortPrivate *d, QObject *parent)
+        : QSocketNotifier(d->descriptor, QSocketNotifier::Read, parent)
+        , dptr(d)
+    {}
+
+protected:
+    virtual bool event(QEvent *e) {
+        bool ret = QSocketNotifier::event(e);
+        if (ret)
+            dptr->readNotification();
+        return ret;
+    }
+
+private:
+    SerialPortPrivate *dptr;
+};
+
+class WriteNotifier : public QSocketNotifier
+{
+public:
+    WriteNotifier(SerialPortPrivate *d, QObject *parent)
+        : QSocketNotifier(d->descriptor, QSocketNotifier::Write, parent)
+        , dptr(d)
+    {}
+
+protected:
+    virtual bool event(QEvent *e) {
+        bool ret = QSocketNotifier::event(e);
+        if (ret)
+            dptr->writeNotification();
+        return ret;
+    }
+
+private:
+    SerialPortPrivate *dptr;
+};
+
+class ExceptionNotifier : public QSocketNotifier
+{
+public:
+    ExceptionNotifier(SerialPortPrivate *d, QObject *parent)
+        : QSocketNotifier(d->descriptor, QSocketNotifier::Exception, parent)
+        , dptr(d)
+    {}
+
+protected:
+    virtual bool event(QEvent *e) {
+        bool ret = QSocketNotifier::event(e);
+        if (ret)
+            dptr->exceptionNotification();
+        return ret;
+    }
+
+private:
+    SerialPortPrivate *dptr;
+};
+
+SerialPortPrivate::SerialPortPrivate(SerialPort *q)
+    : SerialPortPrivateData(q)
+    , descriptor(-1)
+    , isCustomRateSupported(false)
+    , readNotifier(0)
+    , writeNotifier(0)
+    , exceptionNotifier(0)
+    , readPortNotifierCalled(false)
+    , readPortNotifierState(false)
+    , readPortNotifierStateSet(false)
+    , emittedReadyRead(false)
+    , emittedBytesWritten(false)
+{
+}
+
+bool SerialPortPrivate::open(QIODevice::OpenMode mode)
+{
+    QByteArray portName = portNameFromSystemLocation(systemLocation).toLocal8Bit();
+    const char *ptr = portName.constData();
+
+    bool byCurrPid = false;
+    if (TtyLocker::isLocked(ptr, &byCurrPid)) {
+        portError = SerialPort::PermissionDeniedError;
+        return false;
+    }
+
+    int flags = O_NOCTTY | O_NONBLOCK;
+
+    switch (mode & QIODevice::ReadWrite) {
+    case QIODevice::WriteOnly:
+        flags |= O_WRONLY;
+        break;
+    case QIODevice::ReadWrite:
+        flags |= O_RDWR;
+        break;
+    default:
+        flags |= O_RDONLY;
+        break;
+    }
+
+    descriptor = ::open(systemLocation.toLocal8Bit().constData(), flags);
+
+    if (descriptor == -1) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    ::fcntl(descriptor, F_SETFL, FNDELAY);
+
+    TtyLocker::lock(ptr);
+    if (!TtyLocker::isLocked(ptr, &byCurrPid)) {
+        portError = SerialPort::PermissionDeniedError;
+        return false;
+    }
+
+#ifdef TIOCEXCL
+    ::ioctl(descriptor, TIOCEXCL);
+#endif
+
+    if (::tcgetattr(descriptor, &restoredTermios) == -1) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    ::memset(&currentTermios, 0, sizeof(currentTermios));
+    ::cfmakeraw(&currentTermios);
+    currentTermios.c_cflag |= CREAD | CLOCAL;
+    currentTermios.c_cc[VTIME] = 0;
+    currentTermios.c_cc[VMIN] = 0;
+
+    if (!updateTermios())
+        return false;
+
+    setExceptionNotificationEnabled(true);
+
+    if ((flags & O_WRONLY) == 0)
+        setReadNotificationEnabled(true);
+
+    detectDefaultSettings();
+    return true;
+}
+
+void SerialPortPrivate::close()
+{
+    if (restoreSettingsOnClose) {
+        ::tcsetattr(descriptor, TCSANOW, &restoredTermios);
+#ifdef Q_OS_LINUX
+        if (isCustomRateSupported)
+            ::ioctl(descriptor, TIOCSSERIAL, &restoredSerialInfo);
+#endif
+    }
+
+#ifdef TIOCNXCL
+    ::ioctl(descriptor, TIOCNXCL);
+#endif
+
+    if (readNotifier) {
+        readNotifier->setEnabled(false);
+        readNotifier->deleteLater();
+        readNotifier = 0;
+    }
+
+    if (writeNotifier) {
+        writeNotifier->setEnabled(false);
+        writeNotifier->deleteLater();
+        writeNotifier = 0;
+    }
+
+    if (exceptionNotifier) {
+        exceptionNotifier->setEnabled(false);
+        exceptionNotifier->deleteLater();
+        exceptionNotifier = 0;
+    }
+
+    ::close(descriptor);
+
+    QByteArray portName = portNameFromSystemLocation(systemLocation).toLocal8Bit();
+    const char *ptr = portName.constData();
+
+    bool byCurrPid = false;
+    if (TtyLocker::isLocked(ptr, &byCurrPid) && byCurrPid)
+        TtyLocker::unlock(ptr);
+
+    descriptor = -1;
+    isCustomRateSupported = false;
+}
+
+SerialPort::Lines SerialPortPrivate::lines() const
+{
+    int arg = 0;
+    SerialPort::Lines ret = 0;
+
+    if (::ioctl(descriptor, TIOCMGET, &arg) == -1)
+        return ret;
+
+#ifdef TIOCLE
+    if (arg & TIOCLE)
+        ret |= SerialPort::Le;
+#endif
+#ifdef TIOCDTR
+    if (arg & TIOCDTR)
+        ret |= SerialPort::Dtr;
+#endif
+#ifdef TIOCRTS
+    if (arg & TIOCRTS)
+        ret |= SerialPort::Rts;
+#endif
+#ifdef TIOCST
+    if (arg & TIOCST)
+        ret |= SerialPort::St;
+#endif
+#ifdef TIOCSR
+    if (arg & TIOCSR)
+        ret |= SerialPort::Sr;
+#endif
+#ifdef TIOCCTS
+    if (arg & TIOCCTS)
+        ret |= SerialPort::Cts;
+#endif
+#ifdef TIOCCAR
+    if (arg & TIOCCAR)
+        ret |= SerialPort::Dcd;
+#elif defined TIOCCD
+    if (arg & TIOCCD)
+        ret |= SerialPort::Dcd;
+#endif
+#ifdef TIOCRNG
+    if (arg & TIOCRNG)
+        ret |= SerialPort::Ri;
+#elif defined TIOCRI
+    if (arg & TIOCRI)
+        ret |= SerialPort::Ri;
+#endif
+#ifdef TIOCDSR
+    if (arg & TIOCDSR)
+        ret |= SerialPort::Dsr;
+#endif
+
+    return ret;
+}
+
+static bool trigger_out_line(int fd, int bit, bool set)
+{
+    int arg = 0;
+    bool ret = ::ioctl(fd, TIOCMGET, &arg) != -1;
+
+    if (ret) {
+        int tmp = arg & bit;
+
+        // If line already installed, then it no need change.
+        if ((tmp && set) || (!(tmp || set)))
+            return true;
+
+        if (set)
+            arg |= bit;
+        else
+            arg &= ~bit;
+
+        ret = ::ioctl(fd, TIOCMSET, &arg) != -1;
+    }
+    return ret;
+}
+
+bool SerialPortPrivate::setDtr(bool set)
+{
+    return trigger_out_line(descriptor, TIOCM_DTR, set);
+}
+
+bool SerialPortPrivate::setRts(bool set)
+{
+    return trigger_out_line(descriptor, TIOCM_RTS, set);
+}
+
+bool SerialPortPrivate::flush()
+{
+    return ::tcdrain(descriptor) != -1;
+}
+
+bool SerialPortPrivate::reset()
+{
+    return ::tcflush(descriptor, TCIOFLUSH) != -1;
+}
+
+bool SerialPortPrivate::sendBreak(int duration)
+{
+    return ::tcsendbreak(descriptor, duration) != -1;
+}
+
+bool SerialPortPrivate::setBreak(bool set)
+{
+    return ::ioctl(descriptor, set ? TIOCSBRK : TIOCCBRK) != -1;
+}
+
+qint64 SerialPortPrivate::bytesAvailable() const
+{
+    int nbytes = 0;
+#ifdef TIOCINQ
+    if (::ioctl(descriptor, TIOCINQ, &nbytes) == -1)
+        return -1;
+#endif
+    return nbytes;
+}
+
+qint64 SerialPortPrivate::bytesToWrite() const
+{
+    int nbytes = 0;
+#ifdef TIOCOUTQ
+    if (::ioctl(descriptor, TIOCOUTQ, &nbytes) == -1)
+        return -1;
+#endif
+    return nbytes;
+}
+
+qint64 SerialPortPrivate::readFromBuffer(char *data, qint64 maxSize)
+{
+    if (readBuffer.isEmpty())
+        return 0;
+
+    if (maxSize == 1) {
+        *data = readBuffer.getChar();
+        if (readBuffer.isEmpty())
+            setReadNotificationEnabled(true);
+        return 1;
+    }
+
+    const qint64 bytesToRead = qMin(qint64(readBuffer.size()), maxSize);
+    qint64 readSoFar = 0;
+    while (readSoFar < bytesToRead) {
+        const char *ptr = readBuffer.readPointer();
+        const int bytesToReadFromThisBlock = qMin(int(bytesToRead - readSoFar),
+                                                  readBuffer.nextDataBlockSize());
+        ::memcpy(data + readSoFar, ptr, bytesToReadFromThisBlock);
+        readSoFar += bytesToReadFromThisBlock;
+        readBuffer.free(bytesToReadFromThisBlock);
+    }
+
+    if (!isReadNotificationEnabled())
+        setReadNotificationEnabled(true);
+
+    if (readSoFar > 0) {
+        if (readBuffer.isEmpty())
+            setReadNotificationEnabled(true);
+        return readSoFar;
+    }
+
+    return readSoFar;
+}
+
+qint64 SerialPortPrivate::writeToBuffer(const char *data, qint64 maxSize)
+{
+    char *ptr = writeBuffer.reserve(maxSize);
+    if (maxSize == 1)
+        *ptr = *data;
+    else
+        ::memcpy(ptr, data, maxSize);
+
+    const qint64 written = maxSize;
+
+    if (!writeBuffer.isEmpty())
+        setWriteNotificationEnabled(true);
+
+    return written;
+}
+
+bool SerialPortPrivate::waitForReadyRead(int msecs)
+{
+#if QT_VERSION >= 0x040700
+    QElapsedTimer stopWatch;
+#else
+    QTime stopWatch;
+#endif
+
+    stopWatch.start();
+
+    do {
+        bool readyToRead = false;
+        bool readyToWrite = false;
+        bool timedOut = false;
+        if (!waitForReadOrWrite(&readyToRead, &readyToWrite, true, !writeBuffer.isEmpty(),
+                                timeoutValue(msecs, stopWatch.elapsed()), &timedOut)) {
+            // TODO: set error ?
+            return false;
+        }
+
+        if (readyToRead) {
+            if (readNotification())
+                return true;
+        }
+
+        if (readyToWrite)
+            writeNotification();
+
+    } while (msecs == -1 || timeoutValue(msecs, stopWatch.elapsed()) > 0);
+    return false;
+}
+
+bool SerialPortPrivate::waitForBytesWritten(int msecs)
+{
+    if (writeBuffer.isEmpty())
+        return false;
+
+#if QT_VERSION >= 0x040700
+    QElapsedTimer stopWatch;
+#else
+    QTime stopWatch;
+#endif
+
+    stopWatch.start();
+
+    forever {
+        bool readyToRead = false;
+        bool readyToWrite = false;
+        bool timedOut = false;
+        if (!waitForReadOrWrite(&readyToRead, &readyToWrite, true, !writeBuffer.isEmpty(),
+                                timeoutValue(msecs, stopWatch.elapsed()), &timedOut)) {
+            // TODO: set error ?
+            return false;
+        }
+
+        if (readyToRead && !readNotification())
+            return false;
+
+        if (readyToWrite && writeNotification())
+            return true;
+    }
+    return false;
+}
+
+bool SerialPortPrivate::setRate(qint32 rate, SerialPort::Directions dir)
+{
+    bool ret = rate > 0;
+
+    // prepare section
+
+    if (ret) {
+        const qint32 unixRate = SerialPortPrivate::settingFromRate(rate);
+        if (unixRate > 0) {
+            // try prepate to set standard baud rate
+#ifdef Q_OS_LINUX
+            // prepare to forcefully reset the custom mode
+            if (isCustomRateSupported) {
+                //currentSerialInfo.flags |= ASYNC_SPD_MASK;
+                currentSerialInfo.flags &= ~(ASYNC_SPD_CUST /* | ASYNC_LOW_LATENCY*/);
+                currentSerialInfo.custom_divisor = 0;
+            }
+#endif
+            // prepare to set standard rate
+            ret = !(((dir & SerialPort::Input) && ::cfsetispeed(&currentTermios, unixRate) < 0)
+                    || ((dir & SerialPort::Output) && ::cfsetospeed(&currentTermios, unixRate) < 0));
+        } else {
+            // try prepate to set custom baud rate
+#ifdef Q_OS_LINUX
+            // prepare to forcefully set the custom mode
+            if (isCustomRateSupported) {
+                currentSerialInfo.flags &= ~ASYNC_SPD_MASK;
+                currentSerialInfo.flags |= (ASYNC_SPD_CUST /* | ASYNC_LOW_LATENCY*/);
+                currentSerialInfo.custom_divisor = currentSerialInfo.baud_base / rate;
+                if (currentSerialInfo.custom_divisor == 0)
+                    currentSerialInfo.custom_divisor = 1;
+                // for custom mode needed prepare to set B38400 rate
+                ret = (::cfsetspeed(&currentTermios, B38400) != -1);
+            } else {
+                ret = false;
+            }
+#elif Q_OS_MAC
+
+#  ifdef MAC_OS_X_VERSION_10_4 && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4)
+            // Starting with Tiger, the IOSSIOSPEED ioctl can be used to set arbitrary baud rates
+            // other than those specified by POSIX. The driver for the underlying serial hardware
+            // ultimately determines which baud rates can be used. This ioctl sets both the input
+            // and output speed.
+            ret = ::ioctl(descriptor, IOSSIOSPEED, &rate) != -1;
+#  else
+            // others MacOSX version, can't prepare to set custom rate
+            ret = false;
+#  endif
+
+#else
+            // others *nix OS, can't prepare to set custom rate
+            ret = false;
+#endif
+        }
+    }
+
+    // finally section
+
+#ifdef Q_OS_LINUX
+    if (ret && isCustomRateSupported) // finally, set or reset the custom mode
+        ret = ::ioctl(descriptor, TIOCSSERIAL, &currentSerialInfo) != -1;
+#endif
+
+    if (ret) // finally, set rate
+        ret = updateTermios();
+    else
+        portError = decodeSystemError();
+    return ret;
+}
+
+bool SerialPortPrivate::setDataBits(SerialPort::DataBits dataBits)
+{
+    currentTermios.c_cflag &= ~CSIZE;
+    switch (dataBits) {
+    case SerialPort::Data5:
+        currentTermios.c_cflag |= CS5;
+        break;
+    case SerialPort::Data6:
+        currentTermios.c_cflag |= CS6;
+        break;
+    case SerialPort::Data7:
+        currentTermios.c_cflag |= CS7;
+        break;
+    case SerialPort::Data8:
+        currentTermios.c_cflag |= CS8;
+        break;
+    default:
+        currentTermios.c_cflag |= CS8;
+        break;
+    }
+    return updateTermios();
+}
+
+bool SerialPortPrivate::setParity(SerialPort::Parity parity)
+{
+    currentTermios.c_iflag &= ~(PARMRK | INPCK);
+    currentTermios.c_iflag |= IGNPAR;
+
+    switch (parity) {
+
+#ifdef CMSPAR
+    // Here Installation parity only for GNU/Linux where the macro CMSPAR.
+    case SerialPort::SpaceParity:
+        currentTermios.c_cflag &= ~PARODD;
+        currentTermios.c_cflag |= PARENB | CMSPAR;
+        break;
+    case SerialPort::MarkParity:
+        currentTermios.c_cflag |= PARENB | CMSPAR | PARODD;
+        break;
+#endif
+    case SerialPort::NoParity:
+        currentTermios.c_cflag &= ~PARENB;
+        break;
+    case SerialPort::EvenParity:
+        currentTermios.c_cflag &= ~PARODD;
+        currentTermios.c_cflag |= PARENB;
+        break;
+    case SerialPort::OddParity:
+        currentTermios.c_cflag |= PARENB | PARODD;
+        break;
+    default:
+        currentTermios.c_cflag |= PARENB;
+        currentTermios.c_iflag |= PARMRK | INPCK;
+        currentTermios.c_iflag &= ~IGNPAR;
+        break;
+    }
+
+    return updateTermios();
+}
+
+bool SerialPortPrivate::setStopBits(SerialPort::StopBits stopBits)
+{
+    switch (stopBits) {
+    case SerialPort::OneStop:
+        currentTermios.c_cflag &= ~CSTOPB;
+        break;
+    case SerialPort::TwoStop:
+        currentTermios.c_cflag |= CSTOPB;
+        break;
+    default:
+        currentTermios.c_cflag &= ~CSTOPB;
+        break;
+    }
+    return updateTermios();
+}
+
+bool SerialPortPrivate::setFlowControl(SerialPort::FlowControl flow)
+{
+    switch (flow) {
+    case SerialPort::NoFlowControl:
+        currentTermios.c_cflag &= ~CRTSCTS;
+        currentTermios.c_iflag &= ~(IXON | IXOFF | IXANY);
+        break;
+    case SerialPort::HardwareControl:
+        currentTermios.c_cflag |= CRTSCTS;
+        currentTermios.c_iflag &= ~(IXON | IXOFF | IXANY);
+        break;
+    case SerialPort::SoftwareControl:
+        currentTermios.c_cflag &= ~CRTSCTS;
+        currentTermios.c_iflag |= IXON | IXOFF | IXANY;
+        break;
+    default:
+        currentTermios.c_cflag &= ~CRTSCTS;
+        currentTermios.c_iflag &= ~(IXON | IXOFF | IXANY);
+        break;
+    }
+    return updateTermios();
+}
+
+bool SerialPortPrivate::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
+{
+    tcflag_t parmrkMask = PARMRK;
+#ifndef CMSPAR
+    // in space/mark parity emulation also used PARMRK flag
+    if (parity == SerialPort::SpaceParity
+            || parity == SerialPort::MarkParity) {
+        parmrkMask = 0;
+    }
+#endif //CMSPAR
+    switch (policy) {
+    case SerialPort::SkipPolicy:
+        currentTermios.c_iflag &= ~parmrkMask;
+        currentTermios.c_iflag |= IGNPAR | INPCK;
+        break;
+    case SerialPort::PassZeroPolicy:
+        currentTermios.c_iflag &= ~(IGNPAR | parmrkMask);
+        currentTermios.c_iflag |= INPCK;
+        break;
+    case SerialPort::IgnorePolicy:
+        currentTermios.c_iflag &= ~INPCK;
+        break;
+    case SerialPort::StopReceivingPolicy:
+        currentTermios.c_iflag &= ~IGNPAR;
+        currentTermios.c_iflag |= parmrkMask | INPCK;
+        break;
+    default:
+        currentTermios.c_iflag &= ~INPCK;
+        break;
+    }
+    return updateTermios();
+}
+
+bool SerialPortPrivate::readNotification()
+{
+    // Prevent recursive calls
+    if (readPortNotifierCalled) {
+        if (!readPortNotifierStateSet) {
+            readPortNotifierStateSet = true;
+            readPortNotifierState = isReadNotificationEnabled();
+            setReadNotificationEnabled(false);
+        }
+    }
+
+    readPortNotifierCalled = true;
+
+    // Always buffered, read data from the port into the read buffer
+    qint64 newBytes = readBuffer.size();
+    qint64 bytesToRead = policy == SerialPort::IgnorePolicy ? ReadChunkSize : 1;
+
+    if (readBufferMaxSize && bytesToRead > (readBufferMaxSize - readBuffer.size())) {
+        bytesToRead = readBufferMaxSize - readBuffer.size();
+        if (bytesToRead == 0) {
+            // Buffer is full. User must read data from the buffer
+            // before we can read more from the port.
+            return false;
+        }
+    }
+
+    char *ptr = readBuffer.reserve(bytesToRead);
+    const qint64 readBytes = readFromPort(ptr, bytesToRead);
+    if (readBytes == -2) {
+        // No bytes currently available for reading.
+        readBuffer.chop(bytesToRead);
+        return true;
+    }
+    readBuffer.chop(bytesToRead - qMax(readBytes, qint64(0)));
+
+    newBytes = readBuffer.size() - newBytes;
+
+    // If read buffer is full, disable the read port notifier.
+    if (readBufferMaxSize && readBuffer.size() == readBufferMaxSize)
+        setReadNotificationEnabled(false);
+
+    // only emit readyRead() when not recursing, and only if there is data available
+    const bool hasData = newBytes > 0;
+
+    if (!emittedReadyRead && hasData) {
+        emittedReadyRead = true;
+        emit q_ptr->readyRead();
+        emittedReadyRead = false;
+    }
+
+    if (!hasData)
+        setReadNotificationEnabled(true);
+
+    // reset the read port notifier state if we reentered inside the
+    // readyRead() connected slot.
+    if (readPortNotifierStateSet
+            && readPortNotifierState != isReadNotificationEnabled()) {
+        setReadNotificationEnabled(readPortNotifierState);
+        readPortNotifierStateSet = false;
+    }
+    return true;
+}
+
+bool SerialPortPrivate::writeNotification()
+{
+    const int tmp = writeBuffer.size();
+
+    if (writeBuffer.isEmpty() && bytesToWrite() == 0) {
+        setWriteNotificationEnabled(false);
+        return false;
+    }
+
+    const int nextSize = qMin(writeBuffer.nextDataBlockSize(), int(WriteChunkSize));
+    const char *ptr = writeBuffer.readPointer();
+
+    // Attempt to write it chunk.
+    qint64 written = writeToPort(ptr, nextSize);
+    if (written < 0) {
+        // TODO: set error?
+        return false;
+    }
+
+    // Remove what we wrote so far.
+    writeBuffer.free(written);
+    if (written > 0) {
+        // Don't emit bytesWritten() recursively.
+        if (!emittedBytesWritten) {
+            emittedBytesWritten = true;
+            emit q_ptr->bytesWritten(written);
+            emittedBytesWritten = false;
+        }
+    }
+
+    if (writeBuffer.isEmpty() && bytesToWrite() == 0)
+        setWriteNotificationEnabled(false);
+
+    return (writeBuffer.size() < tmp);
+}
+
+bool SerialPortPrivate::exceptionNotification()
+{
+    // FIXME:
+    return false;
+}
+
+bool SerialPortPrivate::updateTermios()
+{
+    if (::tcsetattr(descriptor, TCSANOW, &currentTermios) == -1) {
+        portError = decodeSystemError();
+        return false;
+    }
+    return true;
+}
+
+void SerialPortPrivate::detectDefaultSettings()
+{
+    // Detect rate.
+    const speed_t inputUnixRate = ::cfgetispeed(&currentTermios);
+    const speed_t outputUnixRate = ::cfgetospeed(&currentTermios);
+    bool isCustomRateCurrentSet = false;
+
+#ifdef Q_OS_LINUX
+    // try detect the ability to support custom rate
+    isCustomRateSupported = ::ioctl(descriptor, TIOCGSERIAL, &currentSerialInfo) != -1
+            && ::ioctl(descriptor, TIOCSSERIAL, &currentSerialInfo) != -1;
+
+    if (isCustomRateSupported) {
+        restoredSerialInfo = currentSerialInfo;
+
+        // assume that the baud rate is a custom
+        isCustomRateCurrentSet = inputUnixRate == B38400 && outputUnixRate == B38400;
+
+        if (isCustomRateCurrentSet) {
+            if ((currentSerialInfo.flags & ASYNC_SPD_CUST)
+                    && currentSerialInfo.custom_divisor > 0) {
+
+                // yes, speed is really custom
+                inputRate = currentSerialInfo.baud_base / currentSerialInfo.custom_divisor;
+                outputRate = inputRate;
+            } else {
+                // no, we were wrong and the speed is a standard 38400 baud
+                isCustomRateCurrentSet = false;
+            }
+        }
+    }
+#else
+    // other *nix
+#endif
+    if (!isCustomRateSupported || !isCustomRateCurrentSet) {
+        inputRate = SerialPortPrivate::rateFromSetting(inputUnixRate);
+        outputRate = SerialPortPrivate::rateFromSetting(outputUnixRate);
+    }
+
+    // Detect databits.
+    switch (currentTermios.c_cflag & CSIZE) {
+    case CS5:
+        dataBits = SerialPort::Data5;
+        break;
+    case CS6:
+        dataBits = SerialPort::Data6;
+        break;
+    case CS7:
+        dataBits = SerialPort::Data7;
+        break;
+    case CS8:
+        dataBits = SerialPort::Data8;
+        break;
+    default:
+        dataBits = SerialPort::UnknownDataBits;
+        break;
+    }
+
+    // Detect parity.
+#ifdef CMSPAR
+    if (currentTermios.c_cflag & CMSPAR) {
+        parity = currentTermios.c_cflag & PARODD ?
+                    SerialPort::MarkParity : SerialPort::SpaceParity;
+    } else {
+#endif
+        if (currentTermios.c_cflag & PARENB) {
+            parity = currentTermios.c_cflag & PARODD ?
+                        SerialPort::OddParity : SerialPort::EvenParity;
+        } else {
+            parity = SerialPort::NoParity;
+        }
+#ifdef CMSPAR
+    }
+#endif
+
+    // Detect stopbits.
+    stopBits = currentTermios.c_cflag & CSTOPB ?
+                SerialPort::TwoStop : SerialPort::OneStop;
+
+    // Detect flow control.
+    if ((!(currentTermios.c_cflag & CRTSCTS)) && (!(currentTermios.c_iflag & (IXON | IXOFF | IXANY))))
+        flow = SerialPort::NoFlowControl;
+    else if ((!(currentTermios.c_cflag & CRTSCTS)) && (currentTermios.c_iflag & (IXON | IXOFF | IXANY)))
+        flow = SerialPort::SoftwareControl;
+    else if ((currentTermios.c_cflag & CRTSCTS) && (!(currentTermios.c_iflag & (IXON | IXOFF | IXANY))))
+        flow = SerialPort::HardwareControl;
+    else
+        flow = SerialPort::UnknownFlowControl;
+}
+
+SerialPort::PortError SerialPortPrivate::decodeSystemError() const
+{
+    SerialPort::PortError error;
+    switch (errno) {
+    case ENODEV:
+        error = SerialPort::NoSuchDeviceError;
+        break;
+    case EACCES:
+        error = SerialPort::PermissionDeniedError;
+        break;
+    case EBUSY:
+        error = SerialPort::PermissionDeniedError;
+        break;
+    case ENOTTY:
+        error = SerialPort::IoError;
+        break;
+    default:
+        error = SerialPort::UnknownPortError;
+        break;
+    }
+    return error;
+}
+
+bool SerialPortPrivate::isReadNotificationEnabled() const
+{
+    return readNotifier && readNotifier->isEnabled();
+}
+
+void SerialPortPrivate::setReadNotificationEnabled(bool enable)
+{
+    if (readNotifier) {
+        readNotifier->setEnabled(enable);
+    } else if (enable) {
+        readNotifier = new ReadNotifier(this, q_ptr);
+        readNotifier->setEnabled(true);
+    }
+}
+
+bool SerialPortPrivate::isWriteNotificationEnabled() const
+{
+    return writeNotifier && writeNotifier->isEnabled();
+}
+
+void SerialPortPrivate::setWriteNotificationEnabled(bool enable)
+{
+    if (writeNotifier) {
+        writeNotifier->setEnabled(enable);
+    } else if (enable) {
+        writeNotifier = new WriteNotifier(this, q_ptr);
+        writeNotifier->setEnabled(true);
+    }
+}
+
+bool SerialPortPrivate::isExceptionNotificationEnabled() const
+{
+    return exceptionNotifier && exceptionNotifier->isEnabled();
+}
+
+void SerialPortPrivate::setExceptionNotificationEnabled(bool enable)
+{
+    if (exceptionNotifier) {
+        exceptionNotifier->setEnabled(enable);
+    } else if (enable) {
+        exceptionNotifier = new ExceptionNotifier(this, q_ptr);
+        exceptionNotifier->setEnabled(true);
+    }
+}
+
+bool SerialPortPrivate::waitForReadOrWrite(bool *selectForRead, bool *selectForWrite,
+                                           bool checkRead, bool checkWrite,
+                                           int msecs, bool *timedOut)
+{
+    Q_ASSERT(selectForRead);
+    Q_ASSERT(selectForWrite);
+    Q_ASSERT(timedOut);
+
+    fd_set fdread;
+    FD_ZERO(&fdread);
+    if (checkRead)
+        FD_SET(descriptor, &fdread);
+
+    fd_set fdwrite;
+    FD_ZERO(&fdwrite);
+    if (checkWrite)
+        FD_SET(descriptor, &fdwrite);
+
+    struct timeval tv;
+    tv.tv_sec = msecs / 1000;
+    tv.tv_usec = (msecs % 1000) * 1000;
+
+    int ret = ::select(descriptor + 1, &fdread, &fdwrite, 0, msecs < 0 ? 0 : &tv);
+    if (ret < 0)
+        return false;
+    if (ret == 0) {
+        *timedOut = true;
+        return false;
+    }
+
+    *selectForRead = FD_ISSET(descriptor, &fdread);
+    *selectForWrite = FD_ISSET(descriptor, &fdwrite);
+
+    return ret;
+}
+
+qint64 SerialPortPrivate::readFromPort(char *data, qint64 maxSize)
+{
+    qint64 bytesRead = 0;
+#if defined (CMSPAR)
+    if (parity == SerialPort::NoParity
+            || policy != SerialPort::StopReceivingPolicy) {
+#else
+    if (parity != SerialPort::MarkParity
+            && parity != SerialPort::SpaceParity) {
+#endif
+        bytesRead = ::read(descriptor, data, maxSize);
+    } else {// Perform parity emulation.
+        bytesRead = readPerChar(data, maxSize);
+    }
+
+    // FIXME: Here 'errno' codes for sockets.
+    // You need to replace the codes for the serial port.
+    if (bytesRead < 0) {
+        bytesRead = -1;
+        switch (errno) {
+#if EWOULDBLOCK-0 && EWOULDBLOCK != EAGAIN
+        case EWOULDBLOCK:
+#endif
+        case EAGAIN:
+            // No data was available for reading.
+            bytesRead = -2;
+            break;
+        case EBADF:
+        case EINVAL:
+        case EIO:
+            break;
+        case ECONNRESET:
+            bytesRead = 0;
+            break;
+        default:
+            break;
+        }
+    }
+    return bytesRead;
+}
+
+qint64 SerialPortPrivate::writeToPort(const char *data, qint64 maxSize)
+{
+    qint64 bytesWritten = 0;
+#if defined (CMSPAR)
+    bytesWritten = ::write(descriptor, data, maxSize);
+#else
+    if (parity != SerialPort::MarkParity
+            && parity != SerialPort::SpaceParity) {
+        bytesWritten = ::write(descriptor, data, maxSize);
+    } else {// Perform parity emulation.
+        bytesWritten = writePerChar(data, maxSize);
+    }
+#endif
+
+    // FIXME: Here 'errno' codes for sockets.
+    // You need to replace the codes for the serial port.
+    if (bytesWritten < 0) {
+        switch (errno) {
+        case EPIPE:
+        case ECONNRESET:
+            bytesWritten = -1;
+            break;
+        case EAGAIN:
+            bytesWritten = 0;
+            break;
+        case EMSGSIZE:
+            break;
+        default:
+            break;
+        }
+    }
+    return bytesWritten;
+}
+
+static inline bool evenParity(quint8 c)
+{
+    c ^= c >> 4;        //(c7 ^ c3)(c6 ^ c2)(c5 ^ c1)(c4 ^ c0)
+    c ^= c >> 2;        //[(c7 ^ c3)(c5 ^ c1)][(c6 ^ c2)(c4 ^ c0)]
+    c ^= c >> 1;
+    return c & 1;       //(c7 ^ c3)(c5 ^ c1)(c6 ^ c2)(c4 ^ c0)
+}
+
+#ifndef CMSPAR
+
+qint64 SerialPortPrivate::writePerChar(const char *data, qint64 maxSize)
+{
+    qint64 ret = 0;
+    quint8 const charMask = (0xFF >> (8 - dataBits));
+
+    while (ret < maxSize) {
+
+        bool par = evenParity(*data & charMask);
+        // False if need EVEN, true if need ODD.
+        par ^= parity == SerialPort::MarkParity;
+        if (par ^ (currentTermios.c_cflag & PARODD)) { // Need switch parity mode?
+            currentTermios.c_cflag ^= PARODD;
+            flush(); //force sending already buffered data, because updateTermios() cleares buffers
+            //todo: add receiving buffered data!!!
+            if (!updateTermios())
+                break;
+        }
+
+        int r = ::write(descriptor, data, 1);
+        if (r < 0)
+            return -1;
+        if (r > 0) {
+            data += r;
+            ret += r;
+        }
+    }
+    return ret;
+}
+
+#endif //CMSPAR
+
+qint64 SerialPortPrivate::readPerChar(char *data, qint64 maxSize)
+{
+    qint64 ret = 0;
+    quint8 const charMask = (0xFF >> (8 - dataBits));
+
+    // 0 - prefix not started,
+    // 1 - received 0xFF,
+    // 2 - received 0xFF and 0x00
+    int prefix = 0;
+    while (ret < maxSize) {
+
+        qint64 r = ::read(descriptor, data, 1);
+        if (r < 0) {
+            if (errno == EAGAIN) // It is ok for nonblocking mode.
+                break;
+            return -1;
+        }
+        if (r == 0)
+            break;
+
+        bool par = true;
+        switch (prefix) {
+        case 2: // Previously received both 0377 and 0.
+            par = false;
+            prefix = 0;
+            break;
+        case 1: // Previously received 0377.
+            if (*data == '\0') {
+                ++prefix;
+                continue;
+            }
+            prefix = 0;
+            break;
+        default:
+            if (*data == '\377') {
+                prefix = 1;
+                continue;
+            }
+            break;
+        }
+        // Now: par contains parity ok or error, *data contains received character
+        par ^= evenParity(*data & charMask); //par contains parity bit value for EVEN mode
+        par ^= (currentTermios.c_cflag & PARODD); //par contains parity bit value for current mode
+        if (par ^ (parity == SerialPort::SpaceParity)) { //if parity error
+            switch (policy) {
+            case SerialPort::SkipPolicy:
+                continue;       //ignore received character
+            case SerialPort::StopReceivingPolicy:
+                if (parity != SerialPort::NoParity)
+                    portError = SerialPort::ParityError;
+                else
+                    portError = *data == '\0' ?
+                                SerialPort::BreakConditionError : SerialPort::FramingError;
+                return ++ret;   //abort receiving
+                break;
+            case SerialPort::UnknownPolicy:
+                // Unknown error policy is used! Falling back to PassZeroPolicy
+            case SerialPort::PassZeroPolicy:
+                *data = '\0';   //replace received character by zero
+                break;
+            case SerialPort::IgnorePolicy:
+                break;          //ignore error and pass received character
+            }
+        }
+        ++data;
+        ++ret;
+    }
+    return ret;
+}
+
+#ifdef Q_OS_MAC
+static const QLatin1String defaultPathPrefix("/dev/cu.");
+static const QLatin1String notUsedPathPrefix("/dev/tty.");
+#else
+static const QLatin1String defaultPathPrefix("/dev/");
+#endif
+
+QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
+{
+    QString ret = port;
+
+#ifdef Q_OS_MAC
+    ret.remove(notUsedPathPrefix);
+#endif
+
+    if (!ret.contains(defaultPathPrefix))
+        ret.prepend(defaultPathPrefix);
+    return ret;
+}
+
+QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
+{
+    QString ret = location;
+
+#ifdef Q_OS_MAC
+    ret.remove(notUsedPathPrefix);
+#endif
+
+    ret.remove(defaultPathPrefix);
+    return ret;
+}
+
+struct RatePair
+{
+    qint32 rate;    // The numerical value of baud rate.
+    qint32 setting; // The OS-specific code of baud rate.
+    bool operator<(const RatePair &other) const { return rate < other.rate; }
+    bool operator==(const RatePair &other) const { return setting == other.setting; }
+};
+
+// This table contains correspondences standard pairs values of
+// baud rates that are defined in file termios.h
+static const RatePair standardRatesTable[] =
+{
+    #ifdef B50
+    { 50, B50 },
+    #endif
+    #ifdef B75
+    { 75, B75 },
+    #endif
+    #ifdef B110
+    { 110, B110 },
+    #endif
+    #ifdef B134
+    { 134, B134 },
+    #endif
+    #ifdef B150
+    { 150, B150 },
+    #endif
+    #ifdef B200
+    { 200, B200 },
+    #endif
+    #ifdef B300
+    { 300, B300 },
+    #endif
+    #ifdef B600
+    { 600, B600 },
+    #endif
+    #ifdef B1200
+    { 1200, B1200 },
+    #endif
+    #ifdef B1800
+    { 1800, B1800 },
+    #endif
+    #ifdef B2400
+    { 2400, B2400 },
+    #endif
+    #ifdef B4800
+    { 4800, B4800 },
+    #endif
+    #ifdef B9600
+    { 9600, B9600 },
+    #endif
+    #ifdef B19200
+    { 19200, B19200 },
+    #endif
+    #ifdef B38400
+    { 38400, B38400 },
+    #endif
+    #ifdef B57600
+    { 57600, B57600 },
+    #endif
+    #ifdef B115200
+    { 115200, B115200 },
+    #endif
+    #ifdef B230400
+    { 230400, B230400 },
+    #endif
+    #ifdef B460800
+    { 460800, B460800 },
+    #endif
+    #ifdef B500000
+    { 500000, B500000 },
+    #endif
+    #ifdef B576000
+    { 576000, B576000 },
+    #endif
+    #ifdef B921600
+    { 921600, B921600 },
+    #endif
+    #ifdef B1000000
+    { 1000000, B1000000 },
+    #endif
+    #ifdef B1152000
+    { 1152000, B1152000 },
+    #endif
+    #ifdef B1500000
+    { 1500000, B1500000 },
+    #endif
+    #ifdef B2000000
+    { 2000000, B2000000},
+    #endif
+    #ifdef B2500000
+    { 2500000, B2500000 },
+    #endif
+    #ifdef B3000000
+    { 3000000, B3000000 },
+    #endif
+    #ifdef B3500000
+    { 3500000, B3500000 },
+    #endif
+    #ifdef B4000000
+    { 4000000, B4000000 }
+    #endif
+};
+
+static const RatePair *standardRatesTable_end =
+        standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
+
+qint32 SerialPortPrivate::rateFromSetting(qint32 setting)
+{
+    const RatePair rp = { 0, setting };
+    const RatePair *ret = qFind(standardRatesTable, standardRatesTable_end, rp);
+    return ret != standardRatesTable_end ? ret->rate : 0;
+}
+
+qint32 SerialPortPrivate::settingFromRate(qint32 rate)
+{
+    const RatePair rp = { rate, 0 };
+    const RatePair *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rp);
+    return ret != standardRatesTable_end ? ret->setting : 0;
+}
+
+QList<qint32> SerialPortPrivate::standardRates()
+{
+    QList<qint32> ret;
+    for (const RatePair *it = standardRatesTable; it != standardRatesTable_end; ++it)
+        ret.append(it->rate);
+    return ret;
+}
+
+QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialport_unix_p.h b/src/serialport_unix_p.h
new file mode 100644
index 0000000..246ff6f
--- /dev/null
+++ b/src/serialport_unix_p.h
@@ -0,0 +1,153 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
+** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SERIALPORT_UNIX_P_H
+#define SERIALPORT_UNIX_P_H
+
+#include "serialport_p.h"
+
+#include <termios.h>
+#ifdef Q_OS_LINUX
+#  include <linux/serial.h>
+#endif
+
+class QSocketNotifier;
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+class SerialPortPrivate : public SerialPortPrivateData
+{
+public:
+    SerialPortPrivate(SerialPort *q);
+
+    bool open(QIODevice::OpenMode mode);
+    void close();
+
+    SerialPort::Lines lines() const;
+
+    bool setDtr(bool set);
+    bool setRts(bool set);
+
+    bool flush();
+    bool reset();
+
+    bool sendBreak(int duration);
+    bool setBreak(bool set);
+
+    qint64 bytesAvailable() const;
+    qint64 bytesToWrite() const;
+
+    qint64 readFromBuffer(char *data, qint64 maxSize);
+    qint64 writeToBuffer(const char *data, qint64 maxSize);
+
+    bool waitForReadyRead(int msecs);
+    bool waitForBytesWritten(int msecs);
+
+    bool setRate(qint32 rate, SerialPort::Directions dir);
+    bool setDataBits(SerialPort::DataBits dataBits);
+    bool setParity(SerialPort::Parity parity);
+    bool setStopBits(SerialPort::StopBits stopBits);
+    bool setFlowControl(SerialPort::FlowControl flow);
+    bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy);
+
+    bool readNotification();
+    bool writeNotification();
+    bool exceptionNotification();
+
+    static QString portNameToSystemLocation(const QString &port);
+    static QString portNameFromSystemLocation(const QString &location);
+
+    static qint32 rateFromSetting(qint32 setting);
+    static qint32 settingFromRate(qint32 rate);
+
+    static QList<qint32> standardRates();
+
+    struct termios currentTermios;
+    struct termios restoredTermios;
+#ifdef Q_OS_LINUX
+    struct serial_struct currentSerialInfo;
+    struct serial_struct restoredSerialInfo;
+#endif
+    int descriptor;
+    bool isCustomRateSupported;
+
+    QSocketNotifier *readNotifier;
+    QSocketNotifier *writeNotifier;
+    QSocketNotifier *exceptionNotifier;
+
+    bool readPortNotifierCalled;
+    bool readPortNotifierState;
+    bool readPortNotifierStateSet;
+
+    bool emittedReadyRead;
+    bool emittedBytesWritten;
+
+private:
+    bool updateTermios();
+
+    void detectDefaultSettings();
+    SerialPort::PortError decodeSystemError() const;
+
+    bool isReadNotificationEnabled() const;
+    void setReadNotificationEnabled(bool enable);
+    bool isWriteNotificationEnabled() const;
+    void setWriteNotificationEnabled(bool enable);
+    bool isExceptionNotificationEnabled() const;
+    void setExceptionNotificationEnabled(bool enable);
+
+    bool waitForReadOrWrite(bool *selectForRead, bool *selectForWrite,
+                            bool checkRead, bool checkWrite,
+                            int msecs, bool *timedOut);
+
+    qint64 readFromPort(char *data, qint64 maxSize);
+    qint64 writeToPort(const char *data, qint64 maxSize);
+
+#ifndef CMSPAR
+    qint64 writePerChar(const char *data, qint64 maxSize);
+#endif
+    qint64 readPerChar(char *data, qint64 maxSize);
+
+};
+
+QT_END_NAMESPACE_SERIALPORT
+
+#endif // SERIALPORT_UNIX_P_H
diff --git a/src/serialport_win.cpp b/src/serialport_win.cpp
new file mode 100644
index 0000000..bada6b6
--- /dev/null
+++ b/src/serialport_win.cpp
@@ -0,0 +1,1089 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
+** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
+** Copyright (C) 2012 Andre Hartmann <aha_1980@gmx.de>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "serialport_win_p.h"
+
+#if (QT_VERSION >= 0x040700)
+#include <QtCore/qelapsedtimer.h>
+#else
+#include <QtCore/qtime.h>
+#endif
+
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 0, 0))
+#include <QtCore/qwineventnotifier.h>
+#else
+#include "qt4support/qwineventnotifier_p.h"
+#endif
+
+#include <QDebug>
+
+#ifndef CTL_CODE
+#  define CTL_CODE(DeviceType, Function, Method, Access) ( \
+    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
+    )
+#endif
+
+#ifndef FILE_DEVICE_SERIAL_PORT
+#  define FILE_DEVICE_SERIAL_PORT  27
+#endif
+
+#ifndef METHOD_BUFFERED
+#  define METHOD_BUFFERED  0
+#endif
+
+#ifndef FILE_ANY_ACCESS
+#  define FILE_ANY_ACCESS  0x00000000
+#endif
+
+#ifndef IOCTL_SERIAL_GET_DTRRTS
+#  define IOCTL_SERIAL_GET_DTRRTS \
+    CTL_CODE(FILE_DEVICE_SERIAL_PORT, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
+#endif
+
+#ifndef SERIAL_DTR_STATE
+#  define SERIAL_DTR_STATE  0x00000001
+#endif
+
+#ifndef SERIAL_RTS_STATE
+#  define SERIAL_RTS_STATE  0x00000002
+#endif
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+#ifndef Q_OS_WINCE
+
+class CommEventNotifier : public QWinEventNotifier
+{
+public:
+    CommEventNotifier(SerialPortPrivate *d, QObject *parent)
+        : QWinEventNotifier(d->eventOverlapped.hEvent, parent)
+        , dptr(d)
+    {
+    }
+
+protected:
+    virtual bool event(QEvent *e) {
+        const bool ret = QWinEventNotifier::event(e);
+        if (ret) {
+            if (EV_ERR & dptr->eventMask)
+                dptr->processIoErrors();
+            if (EV_RXCHAR & dptr->eventMask) {
+                if (!dptr->readSequenceStarted)
+                    dptr->startAsyncRead();
+            }
+            if (EV_TXEMPTY & dptr->eventMask)
+                dptr->startAsyncWrite();
+            ::WaitCommEvent(dptr->descriptor, &dptr->eventMask, &dptr->eventOverlapped);
+        }
+        return ret;
+    }
+
+private:
+    SerialPortPrivate *dptr;
+};
+
+class ReadCompletionNotifier : public QWinEventNotifier
+{
+public:
+    ReadCompletionNotifier(SerialPortPrivate *d, QObject *parent)
+        : QWinEventNotifier(d->readOverlapped.hEvent, parent)
+        , dptr(d)
+    {}
+
+protected:
+    virtual bool event(QEvent *e) {
+        bool ret = QWinEventNotifier::event(e);
+        if (ret) {
+            DWORD numberOfBytesTransferred = 0;
+            bool success = ::GetOverlappedResult(dptr->descriptor,
+                                                 &dptr->readOverlapped,
+                                                 &numberOfBytesTransferred,
+                                                 false);
+            if (success)
+                dptr->completeAsyncRead(numberOfBytesTransferred);
+        }
+        return ret;
+    }
+
+private:
+    SerialPortPrivate *dptr;
+};
+
+class WriteCompletionNotifier : public QWinEventNotifier
+{
+public:
+    WriteCompletionNotifier(SerialPortPrivate *d, QObject *parent)
+        : QWinEventNotifier(d->writeOverlapped.hEvent, parent)
+        , dptr(d)
+    {}
+
+protected:
+    virtual bool event(QEvent *e) {
+        bool ret = QWinEventNotifier::event(e);
+        if (ret) {
+            DWORD numberOfBytesTransferred = 0;
+            bool success = ::GetOverlappedResult(dptr->descriptor,
+                                                 &dptr->writeOverlapped,
+                                                 &numberOfBytesTransferred,
+                                                 false);
+            if (success)
+                dptr->completeAsyncWrite(numberOfBytesTransferred);
+        }
+        return ret;
+    }
+
+private:
+    SerialPortPrivate *dptr;
+};
+
+SerialPortPrivate::SerialPortPrivate(SerialPort *q)
+    : SerialPortPrivateData(q)
+    , descriptor(INVALID_HANDLE_VALUE)
+    , flagErrorFromCommEvent(false)
+    , eventMask(EV_ERR)
+    , eventNotifier(0)
+    , readCompletionNotifier(0)
+    , writeCompletionNotifier(0)
+    , actualReadBufferSize(0)
+    , actualWriteBufferSize(0)
+    , readyReadEmitted(0)
+    , readSequenceStarted(false)
+    , writeSequenceStarted(false)
+{
+}
+
+bool SerialPortPrivate::open(QIODevice::OpenMode mode)
+{
+    DWORD desiredAccess = 0;
+    eventMask = EV_ERR;
+
+    if (mode & QIODevice::ReadOnly) {
+        desiredAccess |= GENERIC_READ;
+        eventMask |= EV_RXCHAR;
+    }
+    if (mode & QIODevice::WriteOnly) {
+        desiredAccess |= GENERIC_WRITE;
+        eventMask |= EV_TXEMPTY;
+    }
+
+    descriptor = ::CreateFile(reinterpret_cast<const wchar_t*>(systemLocation.utf16()),
+                              desiredAccess, 0, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
+
+    if (descriptor == INVALID_HANDLE_VALUE) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    if (::GetCommState(descriptor, &restoredDcb) == 0) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    currentDcb = restoredDcb;
+    currentDcb.fBinary = true;
+    currentDcb.fInX = false;
+    currentDcb.fOutX = false;
+    currentDcb.fAbortOnError = false;
+    currentDcb.fNull = false;
+    currentDcb.fErrorChar = false;
+
+    if (!updateDcb())
+        return false;
+
+    if (::GetCommTimeouts(descriptor, &restoredCommTimeouts) == 0) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    ::memset(&currentCommTimeouts, 0, sizeof(currentCommTimeouts));
+    currentCommTimeouts.ReadIntervalTimeout = MAXDWORD;
+
+    if (!updateCommTimeouts())
+        return false;
+
+    ::memset(&selectOverlapped, 0, sizeof(selectOverlapped));
+    selectOverlapped.hEvent = ::CreateEvent(0, true, false, 0);
+
+    if (eventMask & EV_RXCHAR) {
+        ::memset(&readOverlapped, 0, sizeof(readOverlapped));
+        readOverlapped.hEvent = ::CreateEvent(0, false, false, 0);
+        readCompletionNotifier = new ReadCompletionNotifier(this, q_ptr);
+        readCompletionNotifier->setEnabled(true);
+    }
+
+    if (eventMask & EV_TXEMPTY) {
+        ::memset(&writeOverlapped, 0, sizeof(writeOverlapped));
+        writeOverlapped.hEvent = ::CreateEvent(0, false, false, 0);
+        writeCompletionNotifier = new WriteCompletionNotifier(this, q_ptr);
+        writeCompletionNotifier->setEnabled(true);
+    }
+
+    ::SetCommMask(descriptor, eventMask);
+    ::memset(&eventOverlapped, 0, sizeof(eventOverlapped));
+    eventOverlapped.hEvent = ::CreateEvent(0, true, false, 0);
+    eventNotifier = new CommEventNotifier(this, q_ptr);
+    eventNotifier->setEnabled(true);
+    ::WaitCommEvent(descriptor, &eventMask, &eventOverlapped);
+
+    detectDefaultSettings();
+    return true;
+}
+
+void SerialPortPrivate::close()
+{
+    ::CancelIo(descriptor);
+
+    if (eventNotifier) {
+        eventNotifier->setEnabled(false);
+        ::CancelIo(eventOverlapped.hEvent);
+        ::CloseHandle(eventOverlapped.hEvent);
+        eventNotifier->deleteLater();
+        eventNotifier = 0;
+    }
+
+    if (readCompletionNotifier) {
+        readCompletionNotifier->setEnabled(false);
+        ::CancelIo(readOverlapped.hEvent);
+        ::CloseHandle(readOverlapped.hEvent);
+        readCompletionNotifier->deleteLater();
+        readCompletionNotifier = 0;
+    }
+
+    if (readSequenceStarted)
+        readSequenceStarted = false;
+
+    readBuffer.clear();
+    actualReadBufferSize = 0;
+
+    if (writeCompletionNotifier) {
+        writeCompletionNotifier->setEnabled(false);
+        ::CancelIo(writeOverlapped.hEvent);
+        ::CloseHandle(writeOverlapped.hEvent);
+        writeCompletionNotifier->deleteLater();
+        writeCompletionNotifier = 0;
+    }
+
+    if (writeSequenceStarted)
+        writeSequenceStarted = false;
+
+    writeBuffer.clear();
+    actualWriteBufferSize = 0;
+
+    readyReadEmitted = false;
+    flagErrorFromCommEvent = false;
+
+    if (restoreSettingsOnClose) {
+        ::SetCommState(descriptor, &restoredDcb);
+        ::SetCommTimeouts(descriptor, &restoredCommTimeouts);
+    }
+
+    ::CloseHandle(descriptor);
+    descriptor = INVALID_HANDLE_VALUE;
+}
+
+#endif // #ifndef Q_OS_WINCE
+
+SerialPort::Lines SerialPortPrivate::lines() const
+{
+    DWORD modemStat = 0;
+    SerialPort::Lines ret = 0;
+
+    if (::GetCommModemStatus(descriptor, &modemStat) == 0)
+        return ret;
+
+    if (modemStat & MS_CTS_ON)
+        ret |= SerialPort::Cts;
+    if (modemStat & MS_DSR_ON)
+        ret |= SerialPort::Dsr;
+    if (modemStat & MS_RING_ON)
+        ret |= SerialPort::Ri;
+    if (modemStat & MS_RLSD_ON)
+        ret |= SerialPort::Dcd;
+
+    DWORD bytesReturned = 0;
+    if (::DeviceIoControl(descriptor, IOCTL_SERIAL_GET_DTRRTS, 0, 0,
+                          &modemStat, sizeof(modemStat),
+                          &bytesReturned, 0)) {
+
+        if (modemStat & SERIAL_DTR_STATE)
+            ret |= SerialPort::Dtr;
+        if (modemStat & SERIAL_RTS_STATE)
+            ret |= SerialPort::Rts;
+    }
+
+    return ret;
+}
+
+bool SerialPortPrivate::setDtr(bool set)
+{
+    return ::EscapeCommFunction(descriptor, set ? SETDTR : CLRDTR);
+}
+
+bool SerialPortPrivate::setRts(bool set)
+{
+    return ::EscapeCommFunction(descriptor, set ? SETRTS : CLRRTS);
+}
+
+bool SerialPortPrivate::flush()
+{
+    return ::FlushFileBuffers(descriptor);
+}
+
+bool SerialPortPrivate::reset()
+{
+    static const DWORD flags = PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR;
+    return ::PurgeComm(descriptor, flags);
+}
+
+bool SerialPortPrivate::sendBreak(int duration)
+{
+    // FIXME:
+    if (setBreak(true)) {
+        ::Sleep(duration);
+        if (setBreak(false))
+            return true;
+    }
+    return false;
+}
+
+bool SerialPortPrivate::setBreak(bool set)
+{
+    if (set)
+        return ::SetCommBreak(descriptor);
+    return ::ClearCommBreak(descriptor);
+}
+
+qint64 SerialPortPrivate::bytesAvailable() const
+{
+    COMSTAT cs;
+    ::memset(&cs, 0, sizeof(cs));
+    if (::ClearCommError(descriptor, 0, &cs) == 0)
+        return -1;
+    return cs.cbInQue;
+}
+
+qint64 SerialPortPrivate::bytesToWrite() const
+{
+    COMSTAT cs;
+    ::memset(&cs, 0, sizeof(cs));
+    if (::ClearCommError(descriptor, 0, &cs) == 0)
+        return -1;
+    return cs.cbOutQue;
+}
+
+#ifndef Q_OS_WINCE
+
+qint64 SerialPortPrivate::readFromBuffer(char *data, qint64 maxSize)
+{
+    if (actualReadBufferSize == 0)
+        return 0;
+
+    qint64 readSoFar = -1;
+    if (maxSize == 1 && actualReadBufferSize > 0) {
+        *data = readBuffer.getChar();
+        actualReadBufferSize--;
+        readSoFar = 1;
+    } else {
+        const qint64 bytesToRead = qMin(qint64(actualReadBufferSize), maxSize);
+        readSoFar = 0;
+        while (readSoFar < bytesToRead) {
+            const char *ptr = readBuffer.readPointer();
+            const int bytesToReadFromThisBlock = qMin(bytesToRead - readSoFar,
+                                                      qint64(readBuffer.nextDataBlockSize()));
+            ::memcpy(data + readSoFar, ptr, bytesToReadFromThisBlock);
+            readSoFar += bytesToReadFromThisBlock;
+            readBuffer.free(bytesToReadFromThisBlock);
+            actualReadBufferSize -= bytesToReadFromThisBlock;
+        }
+    }
+
+    if (!readSequenceStarted)
+        startAsyncRead();
+
+    return readSoFar;
+}
+
+qint64 SerialPortPrivate::writeToBuffer(const char *data, qint64 maxSize)
+{
+    char *ptr = writeBuffer.reserve(maxSize);
+    if (maxSize == 1) {
+        *ptr = *data;
+        actualWriteBufferSize++;
+    } else {
+        ::memcpy(ptr, data, maxSize);
+        actualWriteBufferSize += maxSize;
+    }
+
+    if (!writeSequenceStarted)
+        startAsyncWrite();
+
+    return maxSize;
+}
+
+bool SerialPortPrivate::waitForReadyRead(int msecs)
+{
+#if QT_VERSION >= 0x040700
+    QElapsedTimer stopWatch;
+#else
+    QTime stopWatch;
+#endif
+
+    stopWatch.start();
+
+    do {
+        bool readyToStartRead = false;
+        bool readyToStartWrite = false;
+        bool readyToCompleteRead = false;
+        bool readyToCompleteWrite = false;
+        bool timedOut = false;
+        if (!waitForReadOrWrite(&readyToStartRead, &readyToStartWrite,
+                                &readyToCompleteRead, &readyToCompleteWrite,
+                                true, !writeBuffer.isEmpty(),
+                                timeoutValue(msecs, stopWatch.elapsed()), &timedOut)) {
+            // This is occur timeout or another error
+            // TODO: set error ?
+            return false;
+        }
+
+        if (readyToStartRead) {
+            if (!startAsyncRead())
+                return false;
+        }
+
+        if (readyToStartWrite) {
+            if (!startAsyncWrite())
+                return false;
+        }
+
+        DWORD bytesTransferred = 0;
+
+        if (readyToCompleteRead) {
+            if (!::GetOverlappedResult(descriptor, &readOverlapped,
+                                       &bytesTransferred, false)) {
+                return false;
+            }
+            return completeAsyncRead(bytesTransferred);
+        }
+
+        if (readyToCompleteWrite) {
+            if (::GetOverlappedResult(descriptor, &readOverlapped,
+                                      &bytesTransferred, false)) {
+                completeAsyncWrite(bytesTransferred);
+            }
+        }
+
+    } while (msecs == -1 || timeoutValue(msecs, stopWatch.elapsed()) > 0);
+    return false;
+}
+
+bool SerialPortPrivate::waitForBytesWritten(int msecs)
+{
+    if (writeBuffer.isEmpty())
+        return false;
+
+#if QT_VERSION >= 0x040700
+    QElapsedTimer stopWatch;
+#else
+    QTime stopWatch;
+#endif
+
+    stopWatch.start();
+
+    forever {
+        bool readyToStartRead = false;
+        bool readyToStartWrite = false;
+        bool readyToCompleteRead = false;
+        bool readyToCompleteWrite = false;
+        bool timedOut = false;
+        if (!waitForReadOrWrite(&readyToStartRead, &readyToStartWrite,
+                                &readyToCompleteRead, &readyToCompleteWrite,
+                                true, !writeBuffer.isEmpty(),
+                                timeoutValue(msecs, stopWatch.elapsed()), &timedOut)) {
+            // This is occur timeout or another error
+            // TODO: set error ?
+            return false;
+        }
+
+        if (readyToStartRead) {
+            if (!startAsyncRead())
+                return false;
+        }
+
+        if (readyToStartWrite) {
+            startAsyncWrite();
+        }
+
+        DWORD bytesTransferred = 0;
+
+        if (readyToCompleteRead) {
+            if (!::GetOverlappedResult(descriptor, &readOverlapped,
+                                       &bytesTransferred, false)) {
+                return false;
+            }
+            if (!completeAsyncRead(bytesTransferred))
+                return false;
+        }
+
+        if (readyToCompleteWrite) {
+            if (::GetOverlappedResult(descriptor, &readOverlapped,
+                                      &bytesTransferred, false)) {
+                if (completeAsyncWrite(bytesTransferred))
+                    return true;
+            }
+        }
+
+    }
+    return false;
+}
+
+#endif // #ifndef Q_OS_WINCE
+
+bool SerialPortPrivate::setRate(qint32 rate, SerialPort::Directions dir)
+{
+    if (dir != SerialPort::AllDirections) {
+        portError = SerialPort::UnsupportedPortOperationError;
+        return false;
+    }
+    currentDcb.BaudRate = rate;
+    return updateDcb();
+}
+
+bool SerialPortPrivate::setDataBits(SerialPort::DataBits dataBits)
+{
+    currentDcb.ByteSize = dataBits;
+    return updateDcb();
+}
+
+bool SerialPortPrivate::setParity(SerialPort::Parity parity)
+{
+    currentDcb.fParity = true;
+    switch (parity) {
+    case SerialPort::NoParity:
+        currentDcb.Parity = NOPARITY;
+        currentDcb.fParity = false;
+        break;
+    case SerialPort::OddParity:
+        currentDcb.Parity = ODDPARITY;
+        break;
+    case SerialPort::EvenParity:
+        currentDcb.Parity = EVENPARITY;
+        break;
+    case SerialPort::MarkParity:
+        currentDcb.Parity = MARKPARITY;
+        break;
+    case SerialPort::SpaceParity:
+        currentDcb.Parity = SPACEPARITY;
+        break;
+    default:
+        currentDcb.Parity = NOPARITY;
+        currentDcb.fParity = false;
+        break;
+    }
+    return updateDcb();
+}
+
+bool SerialPortPrivate::setStopBits(SerialPort::StopBits stopBits)
+{
+    switch (stopBits) {
+    case SerialPort::OneStop:
+        currentDcb.StopBits = ONESTOPBIT;
+        break;
+    case SerialPort::OneAndHalfStop:
+        currentDcb.StopBits = ONE5STOPBITS;
+        break;
+    case SerialPort::TwoStop:
+        currentDcb.StopBits = TWOSTOPBITS;
+        break;
+    default:
+        currentDcb.StopBits = ONESTOPBIT;
+        break;
+    }
+    return updateDcb();
+}
+
+bool SerialPortPrivate::setFlowControl(SerialPort::FlowControl flow)
+{
+    currentDcb.fInX = false;
+    currentDcb.fOutX = false;
+    currentDcb.fOutxCtsFlow = false;
+    currentDcb.fRtsControl = RTS_CONTROL_DISABLE;
+    switch (flow) {
+    case SerialPort::NoFlowControl:
+        break;
+    case SerialPort::SoftwareControl:
+        currentDcb.fInX = true;
+        currentDcb.fOutX = true;
+        break;
+    case SerialPort::HardwareControl:
+        currentDcb.fOutxCtsFlow = true;
+        currentDcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
+        break;
+    default:
+        break;
+    }
+    return updateDcb();
+}
+
+bool SerialPortPrivate::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
+{
+    policy = policy;
+    return true;
+}
+
+#ifndef Q_OS_WINCE
+
+bool SerialPortPrivate::startAsyncRead()
+{
+    DWORD bytesToRead = policy == SerialPort::IgnorePolicy ? ReadChunkSize : 1;
+
+    if (readBufferMaxSize && bytesToRead > (readBufferMaxSize - readBuffer.size())) {
+        bytesToRead = readBufferMaxSize - readBuffer.size();
+        if (bytesToRead == 0) {
+            // Buffer is full. User must read data from the buffer
+            // before we can read more from the port.
+            return false;
+        }
+    }
+
+    char *ptr = readBuffer.reserve(bytesToRead);
+
+    readSequenceStarted = true;
+    if (::ReadFile(descriptor, ptr, bytesToRead, 0, &readOverlapped))
+        return true;
+
+    switch (::GetLastError()) {
+    case ERROR_IO_PENDING:
+        // This is not an error. We're getting notified, when data arrives.
+        return true;
+    case ERROR_MORE_DATA:
+        // This is not an error. The synchronous read succeeded.
+        break;
+    default:
+        // error
+        readSequenceStarted = false;
+        return false;
+    }
+
+    return true;
+}
+
+bool SerialPortPrivate::startAsyncWrite()
+{
+    writeSequenceStarted = true;
+
+    const DWORD nextSize = qMin(writeBuffer.nextDataBlockSize(), int(WriteChunkSize));
+    const char *ptr = writeBuffer.readPointer();
+
+    if (::WriteFile(descriptor, ptr, nextSize, 0, &writeOverlapped))
+        return true;
+
+    switch (::GetLastError()) {
+    case ERROR_IO_PENDING:
+        // This is not an error. We're getting notified, when data arrives.
+        return true;
+    case ERROR_MORE_DATA:
+        // This is not an error. The synchronous read succeeded.
+        break;
+    default:
+        // error
+        writeSequenceStarted = false;
+        return false;
+    }
+    return true;
+}
+
+#endif // #ifndef Q_OS_WINCE
+
+bool SerialPortPrivate::processIoErrors()
+{
+    DWORD error = 0;
+    const bool ret = ::ClearCommError(descriptor, &error, 0) != 0;
+    if (ret && error) {
+        if (error & CE_FRAME)
+            portError = SerialPort::FramingError;
+        else if (error & CE_RXPARITY)
+            portError = SerialPort::ParityError;
+        else if (error & CE_BREAK)
+            portError = SerialPort::BreakConditionError;
+        else
+            portError = SerialPort::UnknownPortError;
+
+        flagErrorFromCommEvent = true;
+    }
+    return ret;
+}
+
+#ifndef Q_OS_WINCE
+
+bool SerialPortPrivate::completeAsyncRead(DWORD numberOfBytes)
+{
+    actualReadBufferSize += qint64(numberOfBytes);
+    readBuffer.truncate(actualReadBufferSize);
+
+    if (numberOfBytes > 0) {
+
+        // Process emulate policy.
+        if (flagErrorFromCommEvent) {
+
+            flagErrorFromCommEvent = false;
+
+            // Ignore received character, remove it from buffer
+            if (policy == SerialPort::SkipPolicy) {
+                readSequenceStarted = false;
+                readBuffer.getChar();
+                startAsyncRead();
+                return true;
+            }
+
+            // Abort receiving
+            if (policy == SerialPort::StopReceivingPolicy) {
+                readSequenceStarted = false;
+                readyReadEmitted = true;
+                emit q_ptr->readyRead();
+                return true;
+            }
+
+            // Replace received character by zero
+            if (policy == SerialPort::PassZeroPolicy) {
+                readBuffer.getChar();
+                readBuffer.putChar('\0');
+            }
+
+        }
+
+        readyReadEmitted = true;
+        emit q_ptr->readyRead();
+        startAsyncRead();
+    } else {
+        readSequenceStarted = false;
+    }
+    return true;
+}
+
+bool SerialPortPrivate::completeAsyncWrite(DWORD numberOfBytes)
+{
+    writeBuffer.free(numberOfBytes);
+    actualWriteBufferSize -= qint64(numberOfBytes);
+
+    if (numberOfBytes > 0)
+        emit q_ptr->bytesWritten(numberOfBytes);
+    else
+        writeSequenceStarted = false;
+
+    return true;
+}
+
+bool SerialPortPrivate::updateDcb()
+{
+    if (::SetCommState(descriptor, &currentDcb) == 0) {
+        portError = decodeSystemError();
+        return false;
+    }
+    return true;
+}
+
+bool SerialPortPrivate::updateCommTimeouts()
+{
+    if (::SetCommTimeouts(descriptor, &currentCommTimeouts) == 0) {
+        portError = decodeSystemError();
+        return false;
+    }
+    return true;
+}
+
+#endif // #ifndef Q_OS_WINCE
+
+void SerialPortPrivate::detectDefaultSettings()
+{
+    // Detect rate.
+    inputRate = quint32(currentDcb.BaudRate);
+    outputRate = inputRate;
+
+    // Detect databits.
+    switch (currentDcb.ByteSize) {
+    case 5:
+        dataBits = SerialPort::Data5;
+        break;
+    case 6:
+        dataBits = SerialPort::Data6;
+        break;
+    case 7:
+        dataBits = SerialPort::Data7;
+        break;
+    case 8:
+        dataBits = SerialPort::Data8;
+        break;
+    default:
+        dataBits = SerialPort::UnknownDataBits;
+        break;
+    }
+
+    // Detect parity.
+    if ((currentDcb.Parity == NOPARITY) && !currentDcb.fParity)
+        parity = SerialPort::NoParity;
+    else if ((currentDcb.Parity == SPACEPARITY) && currentDcb.fParity)
+        parity = SerialPort::SpaceParity;
+    else if ((currentDcb.Parity == MARKPARITY) && currentDcb.fParity)
+        parity = SerialPort::MarkParity;
+    else if ((currentDcb.Parity == EVENPARITY) && currentDcb.fParity)
+        parity = SerialPort::EvenParity;
+    else if ((currentDcb.Parity == ODDPARITY) && currentDcb.fParity)
+        parity = SerialPort::OddParity;
+    else
+        parity = SerialPort::UnknownParity;
+
+    // Detect stopbits.
+    switch (currentDcb.StopBits) {
+    case ONESTOPBIT:
+        stopBits = SerialPort::OneStop;
+        break;
+    case ONE5STOPBITS:
+        stopBits = SerialPort::OneAndHalfStop;
+        break;
+    case TWOSTOPBITS:
+        stopBits = SerialPort::TwoStop;
+        break;
+    default:
+        stopBits = SerialPort::UnknownStopBits;
+        break;
+    }
+
+    // Detect flow control.
+    if (!currentDcb.fOutxCtsFlow && (currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
+            && !currentDcb.fInX && !currentDcb.fOutX) {
+        flow = SerialPort::NoFlowControl;
+    } else if (!currentDcb.fOutxCtsFlow && (currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
+               && currentDcb.fInX && currentDcb.fOutX) {
+        flow = SerialPort::SoftwareControl;
+    } else if (currentDcb.fOutxCtsFlow && (currentDcb.fRtsControl == RTS_CONTROL_HANDSHAKE)
+               && !currentDcb.fInX && !currentDcb.fOutX) {
+        flow = SerialPort::HardwareControl;
+    } else
+        flow = SerialPort::UnknownFlowControl;
+}
+
+SerialPort::PortError SerialPortPrivate::decodeSystemError() const
+{
+    SerialPort::PortError error;
+    switch (::GetLastError()) {
+    case ERROR_FILE_NOT_FOUND:
+        error = SerialPort::NoSuchDeviceError;
+        break;
+    case ERROR_ACCESS_DENIED:
+        error = SerialPort::PermissionDeniedError;
+        break;
+    case ERROR_INVALID_HANDLE:
+        error = SerialPort::DeviceIsNotOpenedError;
+        break;
+    case ERROR_INVALID_PARAMETER:
+        error = SerialPort::UnsupportedPortOperationError;
+        break;
+    default:
+        error = SerialPort::UnknownPortError;
+        break;
+    }
+    return error;
+}
+
+#ifndef Q_OS_WINCE
+
+bool SerialPortPrivate::waitForReadOrWrite(bool *selectForStartRead, bool *selectForStartWrite,
+                                           bool *selectForCompleteRead, bool *selectForCompleteWrite,
+                                           bool checkRead, bool checkWrite,
+                                           int msecs, bool *timedOut)
+{
+    Q_ASSERT(selectForStartRead);
+    Q_ASSERT(selectForStartWrite);
+    Q_ASSERT(selectForCompleteRead);
+    Q_ASSERT(selectForCompleteWrite);
+
+    DWORD eventMask = 0;
+
+    if (::WaitCommEvent(descriptor, &eventMask, &selectOverlapped) == 0
+            && ::GetLastError() != ERROR_IO_PENDING) {
+        return false;
+    }
+
+    enum {
+        SelectEventIndex = 0,
+        ReadEventIndex = 1,
+        WriteEventIndex = 2,
+        NumberOfEvents = 3
+    };
+
+    HANDLE events[NumberOfEvents] = {
+        selectOverlapped.hEvent,
+        readOverlapped.hEvent,
+        writeOverlapped.hEvent
+    };
+
+    DWORD waitResult = ::WaitForMultipleObjects(NumberOfEvents,
+                                                events,
+                                                false, // wait any event
+                                                qMax(msecs, 0));
+
+    switch (waitResult) {
+    case WAIT_OBJECT_0 + SelectEventIndex: {
+        if (checkRead && (eventMask == EV_RXCHAR))
+            *selectForStartRead = true;
+        if (checkWrite && (eventMask == EV_TXEMPTY))
+            *selectForStartWrite = true;
+    }
+        break;
+    case WAIT_OBJECT_0 + ReadEventIndex: {
+        if (checkRead)
+            *selectForCompleteRead = true;
+    }
+        break;
+    case WAIT_OBJECT_0 + WriteEventIndex: {
+        if (checkWrite)
+            *selectForCompleteWrite = true;
+    }
+        break;
+    case WAIT_OBJECT_0 + WAIT_TIMEOUT: {
+        *timedOut = true;
+        return false;
+    }
+        break;
+    default:
+        return false;
+    }
+
+    return true;
+}
+
+static const QLatin1String defaultPathPrefix("\\\\.\\");
+
+QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
+{
+    QString ret = port;
+    if (!ret.contains(defaultPathPrefix))
+        ret.prepend(defaultPathPrefix);
+    return ret;
+}
+
+QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
+{
+    QString ret = location;
+    if (ret.contains(defaultPathPrefix))
+        ret.remove(defaultPathPrefix);
+    return ret;
+}
+
+#endif // #ifndef Q_OS_WINCE
+
+// This table contains standard values of baud rates that
+// are defined in MSDN and/or in Win SDK file winbase.h
+static const qint32 standardRatesTable[] =
+{
+    #ifdef CBR_110
+    CBR_110,
+    #endif
+    #ifdef CBR_300
+    CBR_300,
+    #endif
+    #ifdef CBR_600
+    CBR_600,
+    #endif
+    #ifdef CBR_1200
+    CBR_1200,
+    #endif
+    #ifdef CBR_2400
+    CBR_2400,
+    #endif
+    #ifdef CBR_4800
+    CBR_4800,
+    #endif
+    #ifdef CBR_9600
+    CBR_9600,
+    #endif
+    #ifdef CBR_14400
+    CBR_14400,
+    #endif
+    #ifdef CBR_19200
+    CBR_19200,
+    #endif
+    #ifdef CBR_38400
+    CBR_38400,
+    #endif
+    #ifdef CBR_56000
+    CBR_56000,
+    #endif
+    #ifdef CBR_57600
+    CBR_57600,
+    #endif
+    #ifdef CBR_115200
+    CBR_115200,
+    #endif
+    #ifdef CBR_128000
+    CBR_128000,
+    #endif
+    #ifdef CBR_256000
+    CBR_256000
+    #endif
+};
+
+static const qint32 *standardRatesTable_end =
+        standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
+
+qint32 SerialPortPrivate::rateFromSetting(qint32 setting)
+{
+    const qint32 *ret = qFind(standardRatesTable, standardRatesTable_end, setting);
+    return ret != standardRatesTable_end ? *ret : 0;
+}
+
+qint32 SerialPortPrivate::settingFromRate(qint32 rate)
+{
+    const qint32 *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rate);
+    return ret != standardRatesTable_end ? *ret : 0;
+}
+
+QList<qint32> SerialPortPrivate::standardRates()
+{
+    QList<qint32> l;
+    for (const qint32 *it = standardRatesTable; it != standardRatesTable_end; ++it)
+        l.append(*it);
+    return l;
+}
+
+QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialport_win_p.h b/src/serialport_win_p.h
new file mode 100644
index 0000000..0c717df
--- /dev/null
+++ b/src/serialport_win_p.h
@@ -0,0 +1,163 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
+** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SERIALPORT_WIN_P_H
+#define SERIALPORT_WIN_P_H
+
+#include "serialport_p.h"
+
+#include <qt_windows.h>
+
+#ifndef Q_OS_WINCE
+class QWinEventNotifier;
+#else
+class QThread;
+#include <QtCore/qmutex.h>
+#endif
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+class SerialPortPrivate : public SerialPortPrivateData
+{
+public:
+    SerialPortPrivate(SerialPort *q);
+
+    bool open(QIODevice::OpenMode mode);
+    void close();
+
+    SerialPort::Lines lines() const;
+
+    bool setDtr(bool set);
+    bool setRts(bool set);
+
+    bool flush();
+    bool reset();
+
+    bool sendBreak(int duration);
+    bool setBreak(bool set);
+
+    qint64 bytesAvailable() const;
+    qint64 bytesToWrite() const;
+
+    qint64 readFromBuffer(char *data, qint64 maxSize);
+    qint64 writeToBuffer(const char *data, qint64 maxSize);
+
+    bool waitForReadyRead(int msec);
+    bool waitForBytesWritten(int msec);
+
+    bool setRate(qint32 rate, SerialPort::Directions dir);
+    bool setDataBits(SerialPort::DataBits dataBits);
+    bool setParity(SerialPort::Parity parity);
+    bool setStopBits(SerialPort::StopBits stopBits);
+    bool setFlowControl(SerialPort::FlowControl flowControl);
+    bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy);
+
+    bool processIoErrors();
+#ifndef Q_OS_WINCE
+    bool startAsyncRead();
+    bool startAsyncWrite();
+    bool completeAsyncRead(DWORD numberOfBytes);
+    bool completeAsyncWrite(DWORD numberOfBytes);
+#else
+    bool notifyRead();
+    bool notifyWrite();
+#endif
+
+    static QString portNameToSystemLocation(const QString &port);
+    static QString portNameFromSystemLocation(const QString &location);
+
+    static qint32 rateFromSetting(qint32 setting);
+    static qint32 settingFromRate(qint32 rate);
+
+    static QList<qint32> standardRates();
+
+    DCB currentDcb;
+    DCB restoredDcb;
+    COMMTIMEOUTS currentCommTimeouts;
+    COMMTIMEOUTS restoredCommTimeouts;
+    HANDLE descriptor;
+    bool flagErrorFromCommEvent;
+    DWORD eventMask;
+
+#ifndef Q_OS_WINCE
+    OVERLAPPED eventOverlapped;
+    OVERLAPPED readOverlapped;
+    OVERLAPPED writeOverlapped;
+    OVERLAPPED selectOverlapped;
+
+    QWinEventNotifier *eventNotifier;
+    QWinEventNotifier *readCompletionNotifier;
+    QWinEventNotifier *writeCompletionNotifier;
+
+    qint64 actualReadBufferSize;
+    qint64 actualWriteBufferSize;
+    bool readyReadEmitted;
+    bool readSequenceStarted;
+    bool writeSequenceStarted;
+#else
+    QThread *eventNotifier;
+    QMutex settingsChangeMutex;
+#endif
+
+private:
+    bool updateDcb();
+    bool updateCommTimeouts();
+
+    void detectDefaultSettings();
+    SerialPort::PortError decodeSystemError() const;
+
+#ifndef Q_OS_WINCE
+    bool waitForReadOrWrite(bool *selectForStartRead, bool *selectForStartWrite,
+                            bool *selectForCompleteRead, bool *selectForCompleteWrite,
+                            bool checkRead, bool checkWrite,
+                            int msecs, bool *timedOut);
+#else
+    bool waitForReadOrWrite(bool *selectForRead, bool *selectForWrite,
+                            bool checkRead, bool checkWrite,
+                            int msecs, bool *timedOut);
+#endif
+
+};
+
+QT_END_NAMESPACE_SERIALPORT
+
+#endif // SERIALPORT_WIN_P_H
diff --git a/src/serialport_wince.cpp b/src/serialport_wince.cpp
new file mode 100644
index 0000000..7dac2e7
--- /dev/null
+++ b/src/serialport_wince.cpp
@@ -0,0 +1,483 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
+** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
+** Copyright (C) 2012 Andre Hartmann <aha_1980@gmx.de>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "serialport_win_p.h"
+
+#if (QT_VERSION >= 0x040700)
+#include <QtCore/qelapsedtimer.h>
+#else
+#include <QtCore/qtime.h>
+#endif
+
+#include <QtCore/qthread.h>
+#include <QtCore/qtimer.h>
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+class SerialPortPrivate;
+
+class CommEventNotifier : public QThread
+{
+    Q_OBJECT
+signals:
+    void eventMask(quint32 mask);
+
+public:
+    CommEventNotifier(DWORD mask, SerialPortPrivate *d, QObject *parent)
+        : QThread(parent), dptr(d), running(true) {
+        connect(this, SIGNAL(eventMask(quint32)), this, SLOT(processNotification(quint32)));
+        ::SetCommMask(dptr->descriptor, mask);
+    }
+
+    virtual ~CommEventNotifier() {
+        running = false;
+        ::SetCommMask(dptr->descriptor, 0);
+        wait();
+    }
+
+protected:
+    virtual void run() {
+        DWORD mask = 0;
+        while (running) {
+            if (::WaitCommEvent(dptr->descriptor, &mask, 0) != 0) {
+                // Wait until complete the operation changes the port settings,
+                // see updateDcb().
+                dptr->settingsChangeMutex.lock();
+                dptr->settingsChangeMutex.unlock();
+                emit eventMask(quint32(mask));
+            }
+        }
+    }
+
+private slots:
+    void processNotification(quint32 eventMask) {
+        if (EV_ERR & eventMask)
+            dptr->processIoErrors();
+        if (EV_RXCHAR &eventMask)
+            dptr->notifyRead();
+        if (EV_TXEMPTY & eventMask)
+            dptr->notifyWrite();
+    }
+
+private:
+    SerialPortPrivate *dptr;
+    mutable bool running;
+};
+
+class WaitCommEventBreaker : public QThread
+{
+    Q_OBJECT
+public:
+    WaitCommEventBreaker(HANDLE descriptor, int timeout, QObject *parent = 0)
+        : QThread(parent), descriptor(descriptor), timeout(timeout), worked(false) {
+        start();
+    }
+
+    virtual ~WaitCommEventBreaker() {
+        stop();
+        wait();
+    }
+
+    void stop() {
+        exit(0);
+    }
+
+    bool isWorked() const {
+        return worked;
+    }
+
+protected:
+    void run() {
+        QTimer timer;
+        QObject::connect(&timer, SIGNAL(timeout()), this, SLOT(processTimeout()), Qt::DirectConnection);
+        timer.start(timeout);
+        exec();
+        worked = true;
+    }
+
+private slots:
+    void processTimeout() {
+        ::SetCommMask(descriptor, 0);
+        stop();
+    }
+
+private:
+    HANDLE descriptor;
+    int timeout;
+    mutable bool worked;
+};
+
+SerialPortPrivate::SerialPortPrivate(SerialPort *q)
+    : SerialPortPrivateData(q)
+    , descriptor(INVALID_HANDLE_VALUE)
+    , flagErrorFromCommEvent(0)
+    , eventNotifier(0)
+{
+}
+
+bool SerialPortPrivate::open(QIODevice::OpenMode mode)
+{
+    DWORD desiredAccess = 0;
+    DWORD eventMask = EV_ERR;
+
+    if (mode & QIODevice::ReadOnly) {
+        desiredAccess |= GENERIC_READ;
+        eventMask |= EV_RXCHAR;
+    }
+    if (mode & QIODevice::WriteOnly) {
+        desiredAccess |= GENERIC_WRITE;
+        eventMask |= EV_TXEMPTY;
+    }
+
+    descriptor = ::CreateFile(reinterpret_cast<const wchar_t*>(systemLocation.utf16()),
+                              desiredAccess, 0, 0, OPEN_EXISTING, 0, 0);
+
+    if (descriptor == INVALID_HANDLE_VALUE) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    if (::GetCommState(descriptor, &restoredDcb) == 0) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    currentDcb = restoredDcb;
+    currentDcb.fBinary = true;
+    currentDcb.fInX = false;
+    currentDcb.fOutX = false;
+    currentDcb.fAbortOnError = false;
+    currentDcb.fNull = false;
+    currentDcb.fErrorChar = false;
+
+    if (!updateDcb())
+        return false;
+
+    if (::GetCommTimeouts(descriptor, &restoredCommTimeouts) == 0) {
+        portError = decodeSystemError();
+        return false;
+    }
+
+    ::memset(&currentCommTimeouts, 0, sizeof(currentCommTimeouts));
+    currentCommTimeouts.ReadIntervalTimeout = MAXDWORD;
+
+    if (!updateCommTimeouts())
+        return false;
+
+    eventNotifier = new QtAddOn::SerialPort::CommEventNotifier(eventMask, this, q_ptr);
+    eventNotifier->start();
+
+    detectDefaultSettings();
+    return true;
+}
+
+void SerialPortPrivate::close()
+{
+    if (eventNotifier) {
+        eventNotifier->deleteLater();
+        eventNotifier = 0;
+    }
+
+    if (restoreSettingsOnClose) {
+        ::SetCommState(descriptor, &restoredDcb);
+        ::SetCommTimeouts(descriptor, &restoredCommTimeouts);
+    }
+
+    ::CloseHandle(descriptor);
+    descriptor = INVALID_HANDLE_VALUE;
+}
+
+qint64 SerialPortPrivate::readFromBuffer(char *data, qint64 maxSize)
+{
+    if (readBuffer.isEmpty())
+        return 0;
+
+    if (maxSize == 1) {
+        *data = readBuffer.getChar();
+        return 1;
+    }
+
+    const qint64 bytesToRead = qMin(qint64(readBuffer.size()), maxSize);
+    qint64 readSoFar = 0;
+    while (readSoFar < bytesToRead) {
+        const char *ptr = readBuffer.readPointer();
+        const int bytesToReadFromThisBlock = qMin(int(bytesToRead - readSoFar),
+                                                  readBuffer.nextDataBlockSize());
+        ::memcpy(data + readSoFar, ptr, bytesToReadFromThisBlock);
+        readSoFar += bytesToReadFromThisBlock;
+        readBuffer.free(bytesToReadFromThisBlock);
+    }
+
+    return readSoFar;
+}
+
+qint64 SerialPortPrivate::writeToBuffer(const char *data, qint64 maxSize)
+{
+    char *ptr = writeBuffer.reserve(maxSize);
+    if (maxSize == 1)
+        *ptr = *data;
+    else
+        ::memcpy(ptr, data, maxSize);
+
+    return maxSize;
+}
+
+bool SerialPortPrivate::waitForReadyRead(int msec)
+{
+    if (!readBuffer.isEmpty())
+        return true;
+
+#if QT_VERSION >= 0x040700
+    QElapsedTimer stopWatch;
+#else
+    QTime stopWatch;
+#endif
+
+    stopWatch.start();
+
+    forever {
+        bool readyToRead = false;
+        bool readyToWrite = false;
+        bool timedOut = false;
+        if (!waitForReadOrWrite(&readyToRead, &readyToWrite,
+                                true, !writeBuffer.isEmpty(),
+                                timeoutValue(msec, stopWatch.elapsed()),
+                                &timedOut)) {
+            return false;
+        }
+        if (readyToRead) {
+            if (notifyRead())
+                return true;
+        }
+        if (readyToWrite)
+            notifyWrite();
+    }
+    return false;
+}
+
+bool SerialPortPrivate::waitForBytesWritten(int msec)
+{
+    if (writeBuffer.isEmpty())
+        return false;
+
+#if QT_VERSION >= 0x040700
+    QElapsedTimer stopWatch;
+#else
+    QTime stopWatch;
+#endif
+
+    stopWatch.start();
+
+    forever {
+        bool readyToRead = false;
+        bool readyToWrite = false;
+        bool timedOut = false;
+        if (!waitForReadOrWrite(&readyToRead, &readyToWrite,
+                                true, !writeBuffer.isEmpty(),
+                                timeoutValue(msec, stopWatch.elapsed()),
+                                &timedOut)) {
+            return false;
+        }
+        if (readyToRead) {
+            if (!notifyRead())
+                return false;
+        }
+        if (readyToWrite) {
+            if (notifyWrite())
+                return true;
+        }
+    }
+    return false;
+}
+
+bool SerialPortPrivate::notifyRead()
+{
+    DWORD bytesToRead = (policy == SerialPort::IgnorePolicy) ? ReadChunkSize : 1;
+
+    if (readBufferMaxSize && bytesToRead > (readBufferMaxSize - readBuffer.size())) {
+        bytesToRead = readBufferMaxSize - readBuffer.size();
+        if (bytesToRead == 0) {
+            // Buffer is full. User must read data from the buffer
+            // before we can read more from the port.
+            return false;
+        }
+    }
+
+    char *ptr = readBuffer.reserve(bytesToRead);
+
+    DWORD readBytes = 0;
+    bool sucessResult = ::ReadFile(descriptor, ptr, bytesToRead, &readBytes, 0);
+
+    if (!sucessResult) {
+        readBuffer.truncate(bytesToRead);
+        return false;
+    }
+
+    readBuffer.truncate(readBytes);
+
+    // Process emulate policy.
+    if (flagErrorFromCommEvent) {
+        flagErrorFromCommEvent = false;
+
+        switch (policy) {
+        case SerialPort::SkipPolicy:
+            readBuffer.getChar();
+            return true;
+        case SerialPort::PassZeroPolicy:
+            readBuffer.getChar();
+            readBuffer.putChar('\0');
+            break;
+        case SerialPort::StopReceivingPolicy:
+            // FIXME: Maybe need disable read notifier?
+            break;
+        default:
+            break;
+        }
+    }
+
+    if (readBytes > 0)
+        emit q_ptr->readyRead();
+
+    return true;
+}
+
+bool SerialPortPrivate::notifyWrite()
+{
+    const DWORD nextSize = qMin(writeBuffer.nextDataBlockSize(), int(WriteChunkSize));
+    const char *ptr = writeBuffer.readPointer();
+
+    DWORD bytesWritten = 0;
+    bool sucessResult = ::WriteFile(descriptor, ptr, nextSize, &bytesWritten, 0);
+    if (!sucessResult)
+        return false;
+
+    if (sucessResult)
+        writeBuffer.free(bytesWritten);
+
+    if (bytesWritten > 0)
+        emit q_ptr->bytesWritten(bytesWritten);
+
+    return true;
+}
+
+bool SerialPortPrivate::waitForReadOrWrite(bool *selectForRead, bool *selectForWrite,
+                                           bool checkRead, bool checkWrite,
+                                           int msecs, bool *timedOut)
+{
+    // FIXME: Here the situation is not properly handled with zero timeout:
+    // breaker can work out before you call a method WaitCommEvent()
+    // and so it will loop forever!
+    WaitCommEventBreaker breaker(descriptor, qMax(msecs, 0));
+    ::WaitCommEvent(descriptor, &eventMask, 0);
+    breaker.stop();
+
+    if (breaker.isWorked())
+        *timedOut = true;
+
+    if (!breaker.isWorked()) {
+        if (checkRead) {
+            Q_ASSERT(selectForRead);
+            *selectForRead = eventMask & EV_RXCHAR;
+        }
+        if (checkWrite) {
+            Q_ASSERT(selectForWrite);
+            *selectForWrite = eventMask & EV_TXEMPTY;
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+bool SerialPortPrivate::updateDcb()
+{
+    QMutexLocker locker(&settingsChangeMutex);
+
+    DWORD eventMask = 0;
+    // Save the event mask
+    if (::GetCommMask(descriptor, &eventMask) == 0)
+        return false;
+
+    // Break event notifier from WaitCommEvent
+    ::SetCommMask(descriptor, 0);
+    // Change parameters
+    bool ret = (::SetCommState(descriptor, &currentDcb) != 0);
+    if (!ret)
+        portError = decodeSystemError();
+    // Restore the event mask
+    ::SetCommMask(descriptor, eventMask);
+
+    return ret;
+}
+
+bool SerialPortPrivate::updateCommTimeouts()
+{
+    if (::SetCommTimeouts(descriptor, &currentCommTimeouts) == 0) {
+        portError = decodeSystemError();
+        return false;
+    }
+    return true;
+}
+
+static const QLatin1String defaultPathPostfix(":");
+
+QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
+{
+    QString ret = port;
+    if (!ret.contains(defaultPathPostfix))
+        ret.append(defaultPathPostfix);
+    return ret;
+}
+
+QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
+{
+    QString ret = location;
+    if (ret.contains(defaultPathPostfix))
+        ret.remove(defaultPathPostfix);
+    return ret;
+}
+
+#include "serialport_wince.moc"
+
+QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialportengine_p.h b/src/serialportengine_p.h
deleted file mode 100755
index 32cbb08..0000000
--- a/src/serialportengine_p.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig2@yandex.ru>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef SERIALPORTENGINE_P_H
-#define SERIALPORTENGINE_P_H
-
-#include "serialport.h"
-#include "serialport_p.h"
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-class SerialPortEngine
-{
-public:
-
-#ifdef Q_OS_WINCE
-    // FIXME
-    // Only for WinCE.
-    enum NotificationLockerType {
-        CanReadLocker,
-        CanWriteLocker,
-        CanErrorLocker
-    };
-#endif
-
-    virtual ~SerialPortEngine() {}
-
-    static SerialPortEngine *create(SerialPortPrivate *d);
-
-    virtual bool open(const QString &location, QIODevice::OpenMode mode) = 0;
-    virtual void close(const QString &location) = 0;
-
-    virtual SerialPort::Lines lines() const = 0;
-
-    virtual bool setDtr(bool set) = 0;
-    virtual bool setRts(bool set) = 0;
-
-    virtual bool flush() = 0;
-    virtual bool reset() = 0;
-
-    virtual bool sendBreak(int duration) = 0;
-    virtual bool setBreak(bool set) = 0;
-
-    virtual qint64 bytesAvailable() const = 0;
-    virtual qint64 bytesToWrite() const = 0;
-
-    virtual qint64 read(char *data, qint64 len) = 0;
-    virtual qint64 write(const char *data, qint64 len) = 0;
-    virtual bool select(int timeout,
-                        bool checkRead, bool checkWrite,
-                        bool *selectForRead, bool *selectForWrite) = 0;
-
-    virtual bool setRate(qint32 rate, SerialPort::Directions dir) = 0;
-    virtual bool setDataBits(SerialPort::DataBits dataBits) = 0;
-    virtual bool setParity(SerialPort::Parity parity) = 0;
-    virtual bool setStopBits(SerialPort::StopBits stopBits) = 0;
-    virtual bool setFlowControl(SerialPort::FlowControl flowControl) = 0;
-
-    virtual bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy) = 0;
-
-    virtual bool isReadNotificationEnabled() const = 0;
-    virtual void setReadNotificationEnabled(bool enable) = 0;
-    virtual bool isWriteNotificationEnabled() const = 0;
-    virtual void setWriteNotificationEnabled(bool enable) = 0;
-    virtual bool isErrorNotificationEnabled() const = 0;
-    virtual void setErrorNotificationEnabled(bool enable) = 0;
-
-    virtual bool processIOErrors() = 0;
-
-#ifdef Q_OS_WINCE
-    // FIXME
-    virtual void lockNotification(NotificationLockerType type, bool uselocker) = 0;
-    virtual void unlockNotification(NotificationLockerType type) = 0;
-#endif
-
-protected:
-    virtual void detectDefaultSettings() = 0;
-    virtual SerialPort::PortError decodeSystemError() const = 0;
-
-protected:
-    SerialPortPrivate *dptr;
-};
-
-QT_END_NAMESPACE_SERIALPORT
-
-#endif // SERIALPORTENGINE_P_H
diff --git a/src/serialportengine_symbian.cpp b/src/serialportengine_symbian.cpp
deleted file mode 100755
index 8a17391..0000000
--- a/src/serialportengine_symbian.cpp
+++ /dev/null
@@ -1,968 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-    \class SymbianSerialPortEngine
-    \internal
-
-    \brief The SymbianSerialPortEngine class provides Symbian OS
-    platform-specific low level access to a serial port.
-
-    \reentrant
-    \ingroup serialport-main
-    \inmodule QtSerialPort
-
-    Currently the class supports Symbian3 and Symbian SR1 version of Symbian OS.
-
-    SymbianSerialPortEngine (as well as other platform-dependent engines)
-    is a class with multiple inheritance, which on the one hand,
-    derives from a general abstract class interface SerialPortEngine,
-    on the other hand from QObject.
-
-    From the abstract class SerialPortEngine, this class inherits all virtual
-    interface methods that are common to all serial ports on any platform.
-    The class SymbianSerialPortEngine implements these methods using the
-    Symbian API.
-*/
-
-#include "serialportengine_symbian_p.h"
-
-#include <e32base.h>
-//#include <e32test.h>
-#include <f32file.h>
-
-#include <QtCore/qregexp.h>
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-// Physical device driver.
-#ifdef __WINS__
-_LIT(KPddName, "ECDRV");
-#else // defined (__EPOC32__)
-_LIT(KPddName, "EUART");
-#endif
-
-// Logical  device driver.
-_LIT(KLddName,"ECOMM");
-
-// Modules names.
-_LIT(KRS232ModuleName, "ECUART");
-_LIT(KBluetoothModuleName, "BTCOMM");
-_LIT(KInfraRedModuleName, "IRCOMM");
-_LIT(KACMModuleName, "ECACM");
-
-
-// Return false on error load.
-static bool loadDevices()
-{
-    TInt r = KErrNone;
-#ifdef __WINS__
-    RFs fileServer;
-    r = User::LeaveIfError(fileServer.Connect());
-    if (r != KErrNone)
-        return false;
-    fileServer.Close ();
-#endif
-
-    r = User::LoadPhysicalDevice(KPddName);
-    if (r != KErrNone && r != KErrAlreadyExists)
-        return false; //User::Leave(r);
-
-    r = User::LoadLogicalDevice(KLddName);
-    if (r != KErrNone && r != KErrAlreadyExists)
-        return false; //User::Leave(r);
-
-#ifndef __WINS__
-    r = StartC32();
-    if (r != KErrNone && r != KErrAlreadyExists)
-        return false; //User::Leave(r);
-#endif
-
-    return true;
-}
-
-/*!
-    Constructs a SymbianSerialPortEngine and initializes all internal variables
-    to their initial values. The pointer \a d to the private object of class
-    SerialPortPrivate is used to call some common methods.
-*/
-SymbianSerialPortEngine::SymbianSerialPortEngine(SerialPortPrivate *d)
-    : m_errno(KErrNone)
-{
-    Q_ASSERT(d);
-    // Impl me
-    dptr = d;
-}
-
-/*!
-    Destructs a SymbianSerialPortEngine,
-*/
-SymbianSerialPortEngine::~SymbianSerialPortEngine()
-{
-
-}
-
-/*!
-    Attempts to open the desired serial port by \a location
-    in the given open \a mode. In the Symbian API there is no flag
-    to open the port in r/o, w/o or r/w. The port most likely always
-    opens as r/w.
-
-    Since Symbian OS allows to open the port in any access mode, this
-    method forces the port in exclusive mode access.
-    In the process of discovery, always sets the serial port in non-blocking
-    mode (where the read operation returns immediately) and tries to determine
-    and install the current configuration to the serial port.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool SymbianSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode)
-{
-    // Maybe need added check an ReadWrite open mode?
-    Q_UNUSED(mode)
-
-    if (!loadDevices()) {
-        dptr->setError(SerialPort::UnknownPortError);
-        return false;
-    }
-
-    RCommServ server;
-    m_errno = server.Connect();
-    if (m_errno != KErrNone) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-
-    if (location.contains("BTCOMM"))
-        m_errno = server.LoadCommModule(KBluetoothModuleName);
-    else if (location.contains("IRCOMM"))
-        m_errno = server.LoadCommModule(KInfraRedModuleName);
-    else if (location.contains("ACM"))
-        m_errno = server.LoadCommModule(KACMModuleName);
-    else
-        m_errno = server.LoadCommModule(KRS232ModuleName);
-
-    if (m_errno != KErrNone) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-
-    // In Symbian OS port opening only in R/W mode !?
-    TPtrC portName(static_cast<const TUint16*>(location.utf16()), location.length());
-    m_errno = m_descriptor.Open(server, portName, ECommExclusive);
-
-    if (m_errno != KErrNone) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-
-    // Save current port settings.
-    m_errno = m_descriptor.Config(m_restoredSettings);
-    if (m_errno != KErrNone) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-
-    detectDefaultSettings();
-    return true;
-}
-
-/*!
-    Closes a serial port. Before closing, restores previous
-    serial port settings if necessary.
-*/
-void SymbianSerialPortEngine::close(const QString &location)
-{
-    Q_UNUSED(location);
-
-    if (dptr->options.restoreSettingsOnClose)
-        m_descriptor.SetConfig(m_restoredSettings);
-
-    m_descriptor.Close();
-}
-
-/*!
-    Returns a bitmap state of the RS-232 line signals. On error,
-    the bitmap will be empty (equal zero).
-
-    The Symbian API only provides the state of the following signals:
-    CTS, DSR, DCD, RING, RTS, and DTR. Other signals are not available.
-*/
-SerialPort::Lines SymbianSerialPortEngine::lines() const
-{
-    SerialPort::Lines ret = 0;
-
-    TUint signalMask = 0;
-    m_descriptor.Signals(signalMask);
-
-    if (signalMask & KSignalCTS)
-        ret |= SerialPort::Cts;
-    if (signalMask & KSignalDSR)
-        ret |= SerialPort::Dsr;
-    if (signalMask & KSignalDCD)
-        ret |= SerialPort::Dcd;
-    if (signalMask & KSignalRNG)
-        ret |= SerialPort::Ri;
-    if (signalMask & KSignalRTS)
-        ret |= SerialPort::Rts;
-    if (signalMask & KSignalDTR)
-        ret |= SerialPort::Dtr;
-
-    //if (signalMask & KSignalBreak)
-    //  ret |=
-    return ret;
-}
-
-/*!
-    Set DTR signal to state \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool SymbianSerialPortEngine::setDtr(bool set)
-{
-    TInt r;
-    if (set)
-        r = m_descriptor.SetSignalsToMark(KSignalDTR);
-    else
-        r = m_descriptor.SetSignalsToSpace(KSignalDTR);
-
-    return r == KErrNone;
-}
-
-/*!
-    Set RTS signal to state \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool SymbianSerialPortEngine::setRts(bool set)
-{
-    TInt r;
-    if (set)
-        r = m_descriptor.SetSignalsToMark(KSignalRTS);
-    else
-        r = m_descriptor.SetSignalsToSpace(KSignalRTS);
-
-    return r == KErrNone;
-}
-
-/*!
-
-*/
-bool SymbianSerialPortEngine::flush()
-{
-    // Impl me
-    return false;
-}
-
-/*!
-    Resets the transmit and receive serial port buffers
-    independently.
-*/
-bool SymbianSerialPortEngine::reset()
-{
-    TInt r = m_descriptor.ResetBuffers(KCommResetRx | KCommResetTx);
-    return r == KErrNone;
-}
-
-/*!
-    Sets a break condition for a specified time \a duration
-    in milliseconds.
-
-    A break condition on a line is when a data line is held
-    permanently high for an indeterminate period which must be
-    greater than the time normally taken to transmit two characters.
-    It is sometimes used as an error signal between computers and
-    other devices attached to them over RS232 lines.
-
-    Setting breaks is not supported on the integral ARM
-    serial hardware. EPOC has no support for detecting received
-    breaks. There is no way to detect whether setting a break is
-    supported using Caps().
-*/
-bool SymbianSerialPortEngine::sendBreak(int duration)
-{
-    TRequestStatus status;
-    m_descriptor.Break(status, TTimeIntervalMicroSeconds32(duration * 1000));
-    return false;
-}
-
-/*!
-
-*/
-bool SymbianSerialPortEngine::setBreak(bool set)
-{
-    // Impl me
-    return false;
-}
-
-/*!
-    Returns the number of bytes currently waiting in the
-    driver's input buffer. A return value of zero means
-    the buffer is empty.
-*/
-qint64 SymbianSerialPortEngine::bytesAvailable() const
-{
-    return m_descriptor.QueryReceiveBuffer();
-}
-
-/*!
-
-    It is not possible to find out exactly how many bytes are
-    currently in the driver's output buffer waiting to be
-    transmitted. However, this is not an issue since it is easy
-    to ensure that the output buffer is empty. If the
-    KConfigWriteBufferedComplete bit (set via the TCommConfigV01
-    structure's iHandshake field) is clear, then all write
-    requests will delay completion until the data has completely
-    cleared the driver's output buffer.
-    If the KConfigWriteBufferedComplete bit is set, a write of zero
-    bytes to a port which has data in the output buffer is guaranteed
-    to delay completion until the buffer has been fully drained.
-
-*/
-qint64 SymbianSerialPortEngine::bytesToWrite() const
-{
-    // Impl me
-    return 0;
-}
-
-/*!
-
-    Reads data from the serial port only if it arrives before a
-    specified time-out (zero). All reads from the serial device
-    use 8-bit descriptors as data buffers, even on a Unicode system.
-
-    The length of the TDes8 is set to zero on entry, which means that
-    buffers can be reused without having to be zeroed first.
-
-    The number of bytes to read is set to the maximum length of the
-    descriptor.
-
-    If a read is issued with a data length of zero the Read() completes
-    immediately but with the side effect that the serial hardware is
-    powered up.
-
-    When a Read() terminates with KErrTimedOut, different protocol
-    modules can show different behaviours. Some may write any data
-    received into the aDes buffer, while others may return just an
-    empty descriptor. In the case of a returned empty descriptor use
-    ReadOneOrMore() to read any data left in the buffer.
-
-    The behaviour of this API after a call to NotifyDataAvailable() is
-    not prescribed and so different CSY's behave differently. IrComm
-    will allow a successful completion of this API after a call to
-    NotifyDataAvailable(), while ECUART and ECACM will complete the
-    request with KErrInUse.
-
-*/
-qint64 SymbianSerialPortEngine::read(char *data, qint64 len)
-{
-    TPtr8 buffer((TUint8 *)data, (int)len);
-    TRequestStatus status;
-    m_descriptor.Read(status, TTimeIntervalMicroSeconds32(0), buffer);
-    User::WaitForRequest(status);
-    TInt r = status.Int();
-
-    if (r != KErrNone)
-        return -1;
-
-    return buffer.Length();
-}
-
-/*!
-
-    Writes data to the serial port. All writes to the serial device
-    use 8-bit descriptors as data buffers, even on a Unicode system.
-
-    The number of bytes to write is set to the maximum length of
-    the descriptor.
-
-    When a Write() is issued with a data length of zero it cannot
-    complete until the current handshaking configuration and the
-    state of input control lines indicate that it is possible for
-    data to be immediately written to the serial line, even though no
-    data is to be written. This functionality is useful when
-    determining when serial devices come on line, and checking that
-    the output buffer is empty (if the KConfigWriteBufferedComplete
-    bit is set).
-
-*/
-qint64 SymbianSerialPortEngine::write(const char *data, qint64 len)
-{
-    TPtrC8 buffer((TUint8*)data, (int)len);
-    TRequestStatus status;
-    m_descriptor.Write(status, buffer);
-    User::WaitForRequest(status);
-    TInt r = status.Int();
-
-    if (r != KErrNone)
-        return -1;
-
-    // FIXME: How to get the actual number of bytes written?
-    return len;
-}
-
-/*!
-
-*/
-bool SymbianSerialPortEngine::select(int timeout,
-                                     bool checkRead, bool checkWrite,
-                                     bool *selectForRead, bool *selectForWrite)
-{
-
-    // FIXME: I'm not sure in implementation this method.
-    // Someone needs to check and correct.
-
-    TRequestStatus timerStatus;
-    TRequestStatus readStatus;
-    TRequestStatus writeStatus;
-
-    if (timeout > 0)  {
-        if (!m_selectTimer.Handle()) {
-            if (m_selectTimer.CreateLocal() != KErrNone)
-                return false;
-        }
-        m_selectTimer.HighRes(timerStatus, timeout * 1000);
-    }
-
-    if (checkRead)
-        m_descriptor.NotifyDataAvailable(readStatus);
-
-    if (checkWrite)
-        m_descriptor.NotifyOutputEmpty(writeStatus);
-
-    enum { STATUSES_COUNT = 3 };
-    TRequestStatus *statuses[STATUSES_COUNT];
-    TInt num = 0;
-    statuses[num++] = &timerStatus;
-    statuses[num++] = &readStatus;
-    statuses[num++] = &writeStatus;
-
-    User::WaitForNRequest(statuses, num);
-
-    bool result = false;
-
-    // By timeout?
-    if (timerStatus != KRequestPending) {
-        Q_ASSERT(selectForRead);
-        *selectForRead = false;
-        Q_ASSERT(selectForWrite);
-        *selectForWrite = false;
-    } else {
-        m_selectTimer.Cancel();
-        User::WaitForRequest(timerStatus);
-
-        // By read?
-        if (readStatus != KRequestPending) {
-            Q_ASSERT(selectForRead);
-            *selectForRead = true;
-        }
-
-        // By write?
-        if (writeStatus != KRequestPending) {
-            Q_ASSERT(selectForWrite);
-            *selectForWrite = true;
-        }
-
-        if (checkRead)
-            m_descriptor.NotifyDataAvailableCancel();
-        if (checkWrite)
-            m_descriptor.NotifyOutputEmptyCancel();
-
-        result = true;
-    }
-    return result;
-}
-
-/*!
-    Sets the desired baud \a rate for the given direction \a dir.
-    As Symbian does not support separate directions, the only valid value for
-    \dir is SerialPort::AllDirections.
-
-    On Symbian, this method only supports the standard baud rate set.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool SymbianSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
-{
-    if (dir != SerialPort::AllDirections) {
-        dptr->setError(SerialPort::UnsupportedPortOperationError);
-        return false;
-    }
-
-    rate = settingFromRate(rate);
-    if (rate)
-        m_currentSettings().iRate = static_cast<TBps>(rate);
-    else {
-        dptr->setError(SerialPort::UnsupportedPortOperationError);
-        return false;
-    }
-
-    return updateCommConfig();
-}
-
-/*!
-    Sets the desired number of data bits \a dataBits in a frame. Symbian
-    supports all present number of data bits: 5, 6, 7, and 8.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool SymbianSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
-{
-    switch (dataBits) {
-    case SerialPort::Data5:
-        m_currentSettings().iDataBits = EData5;
-        break;
-    case SerialPort::Data6:
-        m_currentSettings().iDataBits = EData6;
-        break;
-    case SerialPort::Data7:
-        m_currentSettings().iDataBits = EData7;
-        break;
-    case SerialPort::Data8:
-        m_currentSettings().iDataBits = EData8;
-        break;
-    default:
-        m_currentSettings().iDataBits = EData8;
-        break;
-    }
-
-    return updateCommConfig();
-}
-
-/*!
-    Sets the desired \a parity control mode. Symbian supports
-    all present parity types: no parity, space, mark, even, and odd parity.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool SymbianSerialPortEngine::setParity(SerialPort::Parity parity)
-{
-    switch (parity) {
-    case SerialPort::NoParity:
-        m_currentSettings().iParity = EParityNone;
-        break;
-    case SerialPort::EvenParity:
-        m_currentSettings().iParity = EParityEven;
-        break;
-    case SerialPort::OddParity:
-        m_currentSettings().iParity = EParityOdd;
-        break;
-    case SerialPort::MarkParity:
-        m_currentSettings().iParity = EParityMark;
-        break;
-    case SerialPort::SpaceParity:
-        m_currentSettings().iParity = EParitySpace;
-        break;
-    default:
-        m_currentSettings().iParity = EParityNone;
-        break;
-    }
-
-    return updateCommConfig();
-}
-
-/*!
-    Sets the desired number of stop bits \a stopBits in a frame. Symbian
-    only supports 1 or 2 stop bits.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool SymbianSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
-{
-    switch (stopBits) {
-    case SerialPort::OneStop:
-        m_currentSettings().iStopBits = EStop1;
-        break;
-    case SerialPort::TwoStop:
-        m_currentSettings().iStopBits = EStop2;
-        break;
-    default:
-        m_currentSettings().iStopBits = EStop1;
-        break;
-    }
-
-    return updateCommConfig();
-}
-
-/*!
-    Sets the desired \a flow control mode. Symbian supports all
-    present flow control modes: no control, hardware (RTS/CTS),
-    and software (XON/XOFF).
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool SymbianSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
-{
-    switch (flow) {
-    case SerialPort::NoFlowControl:
-        m_currentSettings().iHandshake = KConfigFailDSR;
-        break;
-    case SerialPort::HardwareControl:
-        m_currentSettings().iHandshake = KConfigObeyCTS | KConfigFreeRTS;
-        break;
-    case SerialPort::SoftwareControl:
-        m_currentSettings().iHandshake = KConfigObeyXoff | KConfigSendXoff;
-        break;
-    default:
-        m_currentSettings().iHandshake = KConfigFailDSR;
-        break;
-    }
-
-    return updateCommConfig();
-}
-
-/*!
-
-*/
-bool SymbianSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
-{
-    Q_UNUSED(policy)
-    // Impl me
-    return true;
-}
-
-/*!
-
-*/
-bool SymbianSerialPortEngine::isReadNotificationEnabled() const
-{
-    // Impl me
-    return false;
-}
-
-/*!
-
-*/
-void SymbianSerialPortEngine::setReadNotificationEnabled(bool enable)
-{
-    Q_UNUSED(enable)
-    // Impl me
-}
-
-/*!
-
-*/
-bool SymbianSerialPortEngine::isWriteNotificationEnabled() const
-{
-    // Impl me
-    return false;
-}
-
-/*!
-
-*/
-void SymbianSerialPortEngine::setWriteNotificationEnabled(bool enable)
-{
-    Q_UNUSED(enable)
-    // Impl me
-}
-
-/*!
-
-*/
-bool SymbianSerialPortEngine::isErrorNotificationEnabled() const
-{
-    // Impl me
-    return false;
-}
-
-/*!
-
-*/
-void SymbianSerialPortEngine::setErrorNotificationEnabled(bool enable)
-{
-    Q_UNUSED(enable)
-    // Impl me
-}
-
-/*!
-
-*/
-bool SymbianSerialPortEngine::processIOErrors()
-{
-    // Impl me
-    return false;
-}
-
-/* Protected methods */
-
-/*!
-    Attempts to determine the current serial port settings,
-    when the port is opened. Used only in the method open().
-*/
-void SymbianSerialPortEngine::detectDefaultSettings()
-{
-    // Detect rate.
-    dptr->options.inputRate = rateFromSetting(m_currentSettings().iRate);
-    dptr->options.outputRate = dptr->options.inputRate;
-
-    // Detect databits.
-    switch (m_currentSettings().iDataBits) {
-    case EData5:
-        dptr->options.dataBits = SerialPort::Data5;
-        break;
-    case EData6:
-        dptr->options.dataBits = SerialPort::Data6;
-        break;
-    case EData7:
-        dptr->options.dataBits = SerialPort::Data7;
-        break;
-    case EData8:
-        dptr->options.dataBits = SerialPort::Data8;
-        break;
-    default:
-        dptr->options.dataBits = SerialPort::UnknownDataBits;
-        break;
-    }
-
-    // Detect parity.
-    switch (m_currentSettings().iParity) {
-    case EParityNone:
-        dptr->options.parity = SerialPort::NoParity;
-        break;
-    case EParityEven:
-        dptr->options.parity = SerialPort::EvenParity;
-        break;
-    case EParityOdd:
-        dptr->options.parity = SerialPort::OddParity;
-        break;
-    case EParityMark:
-        dptr->options.parity = SerialPort::MarkParity;
-        break;
-    case EParitySpace:
-        dptr->options.parity = SerialPort::SpaceParity;
-        break;
-    default:
-        dptr->options.parity = SerialPort::UnknownParity;
-        break;
-    }
-
-    // Detect stopbits.
-    switch (m_currentSettings().iStopBits) {
-    case EStop1:
-        dptr->options.stopBits = SerialPort::OneStop;
-        break;
-    case EStop2:
-        dptr->options.stopBits = SerialPort::TwoStop;
-        break;
-    default:
-        dptr->options.stopBits = SerialPort::UnknownStopBits;
-        break;
-    }
-
-    // Detect flow control.
-    if ((m_currentSettings().iHandshake & (KConfigObeyXoff | KConfigSendXoff))
-            == (KConfigObeyXoff | KConfigSendXoff))
-        dptr->options.flow = SerialPort::SoftwareControl;
-    else if ((m_currentSettings().iHandshake & (KConfigObeyCTS | KConfigFreeRTS))
-             == (KConfigObeyCTS | KConfigFreeRTS))
-        dptr->options.flow = SerialPort::HardwareControl;
-    else if (m_currentSettings().iHandshake & KConfigFailDSR)
-        dptr->options.flow = SerialPort::NoFlowControl;
-    else
-        dptr->options.flow = SerialPort::UnknownFlowControl;
-}
-
-/*!
-    Converts the platform-depend code of system error to the
-    corresponding value a SerialPort::PortError.
-*/
-SerialPort::PortError SymbianSerialPortEngine::decodeSystemError() const
-{
-    SerialPort::PortError error;
-    switch (m_errno) {
-    case KErrPermissionDenied:
-        error = SerialPort::NoSuchDeviceError;
-        break;
-    case KErrLocked:
-        error = SerialPort::PermissionDeniedError;
-        break;
-    case KErrAccessDenied:
-        error = SerialPort::PermissionDeniedError;
-        break;
-    default:
-        error = SerialPort::UnknownPortError;
-        break;
-    }
-    return error;
-}
-
-/*!
-    Updates the TCommConfig structure when changing any serial port parameter.
-
-    If successful, returns true; otherwise returns false and sets an error code.
-*/
-bool SymbianSerialPortEngine::updateCommConfig()
-{
-    if (m_descriptor.SetConfig(m_currentSettings) != KErrNone) {
-        dptr->setError(SerialPort::UnsupportedPortOperationError);
-        return false;
-    }
-    return true;
-}
-
-// From <serialportengine_p.h>
-SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
-{
-    return new SymbianSerialPortEngine(d);
-}
-
-/* Public static the SerialPortPrivate methods */
-
-/*!
-    Converts a platform specific \a port name to a system location
-    and returns the value.
-
-    Does not convert anything because on Symbian both are equal.
-*/
-QString SerialPortPrivate::portNameToSystemLocation(const QString &port) const
-{
-    // Port name is equval to port location.
-    return port;
-}
-
-/*!
-    Converts a platform specific system \a location to a port name
-    and returns the value.
-
-    Does not convert anything because on Symbian both are equal.
-*/
-QString SerialPortPrivate::portNameFromSystemLocation(const QString &location) const
-{
-    // Port name is equval to port location.
-    return location;
-}
-
-struct RatePair
-{
-   qint32 rate;    // The numerical value of baud rate.
-   qint32 setting; // The OS-specific code of baud rate.
-   bool operator<(const RatePair &other) const { return rate < other.rate; }
-   bool operator==(const RatePair &other) const { return setting == other.setting; }
-};
-
-// This table contains correspondences standard pairs values of
-// baud rates that are defined in files
-// - d32comm.h for Symbian^3
-// - d32public.h for Symbian SR1
-static
-const RatePair standardRatesTable[] =
-{
-    { 50, EBps50 },
-    { 75, EBps75 },
-    { 110, EBps110},
-    { 134, EBps134 },
-    { 150, EBps150 },
-    { 300, EBps300 },
-    { 600, EBps600 },
-    { 1200, EBps1200 },
-    { 1800, EBps1800 },
-    { 2000, EBps2000 },
-    { 2400, EBps2400 },
-    { 3600, EBps3600 },
-    { 4800, EBps4800 },
-    { 7200, EBps7200 },
-    { 9600, EBps9600 },
-    { 19200, EBps19200 },
-    { 38400, EBps38400 },
-    { 57600, EBps57600 },
-    { 115200, EBps115200 },
-    { 230400, EBps230400 },
-    { 460800, EBps460800 },
-    { 576000, EBps576000 },
-    { 921600, EBps921600 },
-    { 1152000, EBps1152000 },
-    //{ 1843200, EBps1843200 }, only for Symbian SR1
-    { 4000000, EBps4000000 }
-};
-
-static const RatePair *standardRatesTable_end =
-        standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
-
-/*!
-    Converts the symbian-specific baud rate enum to a numeric value.
-    If the desired item is not found, returns 0.
-*/
-qint32 SerialPortPrivate::rateFromSetting(qint32 setting)
-{
-    const RatePair rp = { 0, setting };
-    const RatePair *ret = qFind(standardRatesTable, standardRatesTable_end, rp);
-    return ret != standardRatesTable_end ? ret->rate : 0;
-}
-
-/*!
-    Converts a numeric baud rate value to a symbian-specific enum.
-    If the desired item is not found, returns 0.
-*/
-qint32 SerialPortPrivate::settingFromRate(qint32 rate)
-{
-    const RatePair rp = { rate, 0 };
-    const RatePair *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rp);
-    return ret != standardRatesTable_end ? ret->setting : 0;
-}
-
-/*!
-    Returns a list of standard baud rate values.
-
-    Enums are defined in:
-   - d32comm.h for Symbian^3
-   - d32public.h for Symbian SR1.
-*/
-QList<qint32> SerialPortPrivate::standardRates()
-{
-    QList<qint32> ret;
-    for (const RatePair *it = standardRatesTable; it != standardRatesTable_end; ++it)
-       ret.append(it->rate);
-    return ret;
-}
-
-#include "moc_serialportengine_symbian_p.cpp"
-
-QT_END_NAMESPACE_SERIALPORT
-
-
diff --git a/src/serialportengine_symbian_p.h b/src/serialportengine_symbian_p.h
deleted file mode 100755
index 36b42f8..0000000
--- a/src/serialportengine_symbian_p.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig2@yandex.ru>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef SERIALPORTENGINE_SYMBIAN_P_H
-#define SERIALPORTENGINE_SYMBIAN_P_H
-
-#include "serialport.h"
-#include "serialportengine_p.h"
-
-#include <c32comm.h>
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-class SymbianSerialPortEngine : public QObject, public SerialPortEngine
-{
-    Q_OBJECT
-public:
-    SymbianSerialPortEngine(SerialPortPrivate *d);
-    virtual ~SymbianSerialPortEngine();
-
-    virtual bool open(const QString &location, QIODevice::OpenMode mode);
-    virtual void close(const QString &location);
-
-    virtual SerialPort::Lines lines() const;
-
-    virtual bool setDtr(bool set);
-    virtual bool setRts(bool set);
-
-    virtual bool flush();
-    virtual bool reset();
-
-    virtual bool sendBreak(int duration);
-    virtual bool setBreak(bool set);
-
-    virtual qint64 bytesAvailable() const;
-    virtual qint64 bytesToWrite() const;
-
-    virtual qint64 read(char *data, qint64 len);
-    virtual qint64 write(const char *data, qint64 len);
-    virtual bool select(int timeout,
-                        bool checkRead, bool checkWrite,
-                        bool *selectForRead, bool *selectForWrite);
-
-    virtual bool setRate(qint32 rate, SerialPort::Directions dir);
-    virtual bool setDataBits(SerialPort::DataBits dataBits);
-    virtual bool setParity(SerialPort::Parity parity);
-    virtual bool setStopBits(SerialPort::StopBits stopBits);
-    virtual bool setFlowControl(SerialPort::FlowControl flowControl);
-
-    virtual bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy);
-
-    virtual bool isReadNotificationEnabled() const;
-    virtual void setReadNotificationEnabled(bool enable);
-    virtual bool isWriteNotificationEnabled() const;
-    virtual void setWriteNotificationEnabled(bool enable);
-    virtual bool isErrorNotificationEnabled() const;
-    virtual void setErrorNotificationEnabled(bool enable);
-
-    virtual bool processIOErrors();
-
-protected:
-    virtual void detectDefaultSettings();
-    virtual SerialPort::PortError decodeSystemError() const;
-    //virtual bool eventFilter(QObject *obj, QEvent *e);
-
-private:
-    bool updateCommConfig();
-
-private:
-    TCommConfig m_currentSettings;
-    TCommConfig m_restoredSettings;
-    RComm m_descriptor;
-    mutable RTimer m_selectTimer;
-    TInt m_errno;
-};
-
-QT_END_NAMESPACE_SERIALPORT
-
-#endif // SERIALPORTENGINE_SYMBIAN_P_H
diff --git a/src/serialportengine_unix.cpp b/src/serialportengine_unix.cpp
deleted file mode 100755
index e3e522d..0000000
--- a/src/serialportengine_unix.cpp
+++ /dev/null
@@ -1,1413 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
-** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
-** Copyright (C) 2012 Andre Hartmann <aha_1980@gmx.de>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-    \class UnixSerialPortEngine
-    \internal
-
-    \brief The UnixSerialPortEngine class provides *nix OS
-    platform-specific low level access to a serial port.
-
-    \reentrant
-    \ingroup serialport-main
-    \inmodule QtSerialPort
-
-    Currently the class supports all POSIX-compatible OS (GNU/Linux, *BSD,
-    Mac OSX and so forth).
-
-    UnixSerialPortEngine (as well as other platform-dependent engines)
-    is a class with multiple inheritance, which on the one hand,
-    derives from a general abstract class interface SerialPortEngine,
-    on the other hand from QObject.
-
-    From the abstract class SerialPortEngine, this class inherits all virtual
-    interface methods that are common to all serial ports on any platform. The
-    class UnixSerialPortEngine implements these methods using the POSIX API.
-
-    From QObject, this class inherits system specific Qt features. For example,
-    to track serial port events, this class uses the virtual QObject method
-    eventFilter(), which analyses the events from the type class
-    QSocketNotifier.
-*/
-
-#include "serialportengine_unix_p.h"
-#include "ttylocker_unix_p.h"
-
-#include <errno.h>
-#include <sys/time.h>
-#include <sys/ioctl.h>
-#include <fcntl.h>
-#include <unistd.h>
-
-#ifdef Q_OS_MAC
-#  if defined (MAC_OS_X_VERSION_10_4) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4)
-#    include <IOKit/serial/ioss.h>
-#  endif
-#endif
-
-#include <QtCore/qdebug.h>
-#include <QtCore/qsocketnotifier.h>
-#include <QtCore/qcoreevent.h>
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-/*!
-    Constructs a UnixSerialPortEngine and initializes all internal variables
-    to their initial values. The pointer \a d to the private object of class
-    SerialPortPrivate is used to call some common methods.
-*/
-UnixSerialPortEngine::UnixSerialPortEngine(SerialPortPrivate *d)
-    : m_descriptor(-1)
-    , m_isCustomRateSupported(false)
-    , m_readNotifier(0)
-    , m_writeNotifier(0)
-    , m_exceptionNotifier(0)
-{
-    Q_ASSERT(d);
-    dptr = d;
-    ::memset(&m_currentTermios, 0, sizeof(m_currentTermios));
-    ::memset(&m_restoredTermios, 0, sizeof(m_restoredTermios));
-}
-
-/*!
-    Destructs a UnixSerialPortEngine.
-*/
-UnixSerialPortEngine::~UnixSerialPortEngine()
-{
-}
-
-/*!
-    Attempts to open the desired serial port by \a location in the given
-    open \a mode.
-
-    Before opening the serial port, open() checks if the appropriate lock file
-    exists. If the lock file is present and contains valid information, the
-    current serial port is already occupied and thus cannot be opened.
-
-    In the process of discovery, always sets the serial port in non-blocking
-    mode (where the read operation returns immediately) and tries to determine
-    and install the current configuration to the serial port.
-
-    Since the POSIX API by default opens the port in shared mode,
-    this method forces the port in exclusive access mode.
-    This is done simultaneously in two ways:
-    - the flag TIOCEXCL is set to the pre-opened m_descriptor
-    - a lock file is created, which contains the PID of the process, that
-      opened the port and other information
-
-    Two methods need to be used due to the fact that some platforms doesn't
-    support the constant TIOCEXCL. In this case, only the lock file is used.
-    Lock file creation and analysis is done by the helper class TtyLocker.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode)
-{
-    // First, here need check locked device or not.
-    bool byCurrPid = false;
-    QByteArray portName = SerialPortPrivate::portNameFromSystemLocation(location).toLocal8Bit();
-    const char *ptr = portName.constData();
-    if (TtyLocker::isLocked(ptr, &byCurrPid)) {
-        dptr->setError(SerialPort::PermissionDeniedError);
-        return false;
-    }
-
-    int flags = (O_NOCTTY | O_NDELAY);
-
-    switch (mode & QIODevice::ReadWrite) {
-    case QIODevice::WriteOnly:
-        flags |= O_WRONLY;
-        break;
-    case QIODevice::ReadWrite:
-        flags |= O_RDWR;
-        break;
-    default:
-        flags |= O_RDONLY;
-        break;
-    }
-
-    // Try opened serial device.
-    m_descriptor = ::open(location.toLocal8Bit().constData(), flags);
-
-    if (m_descriptor == -1) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-
-    // Try lock device by location and check it state is locked.
-    TtyLocker::lock(ptr);
-    if (!TtyLocker::isLocked(ptr, &byCurrPid)) {
-        dptr->setError(SerialPort::PermissionDeniedError);
-        return false;
-    }
-
-    // Try set exclusive mode.
-#ifdef TIOCEXCL
-    ::ioctl(m_descriptor, TIOCEXCL);
-#endif
-
-    // Save current port settings.
-    if (::tcgetattr(m_descriptor, &m_restoredTermios) == -1) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    m_currentTermios = m_restoredTermios;
-
-    // Set other options.
-    ::cfmakeraw(&m_currentTermios);
-    m_currentTermios.c_cflag |= CREAD | CLOCAL;
-    m_currentTermios.c_cc[VTIME] = 0;
-
-    // Apply new init settings.
-    if (!updateTermios())
-        return false;
-
-    detectDefaultSettings();
-    return true;
-}
-
-/*!
-    Closes a serial port. Before closing, clears the exclusive access flag,
-    removes the lock file, and restores the previous serial port settings
-    if necessary.
-*/
-void UnixSerialPortEngine::close(const QString &location)
-{
-    // Restore saved port settings.
-    if (dptr->options.restoreSettingsOnClose) {
-        ::tcsetattr(m_descriptor, TCSANOW, &m_restoredTermios);
-#ifdef Q_OS_LINUX
-        if (m_isCustomRateSupported)
-            ::ioctl(m_descriptor, TIOCSSERIAL, &m_restoredSerialInfo);
-#endif
-    }
-
-    // Try clean exclusive mode.
-#ifdef TIOCNXCL
-    ::ioctl(m_descriptor, TIOCNXCL);
-#endif
-
-    // Delete all notifiers
-    if (m_readNotifier) {
-        delete m_readNotifier;
-        m_readNotifier = 0;
-    }
-
-    if (m_writeNotifier) {
-        delete m_writeNotifier;
-        m_writeNotifier = 0;
-    }
-
-    if (m_exceptionNotifier) {
-        delete m_exceptionNotifier;
-        m_exceptionNotifier = 0;
-    }
-
-    ::close(m_descriptor);
-
-    // Try unlock device by location.
-    bool byCurrPid = false;
-    QByteArray portName = SerialPortPrivate::portNameFromSystemLocation(location).toLocal8Bit();
-    const char *ptr = portName.constData();
-    if (TtyLocker::isLocked(ptr, &byCurrPid) && byCurrPid)
-        TtyLocker::unlock(ptr);
-
-    m_descriptor = -1;
-    m_isCustomRateSupported = false;
-}
-
-/*!
-    Returns a bitmap state of the RS-232 line signals. On error,
-    the bitmap will be empty (equal zero).
-
-    The POSIX API provides the state of all signals:
-    LE, DTR, RTS, ST, SR, CTS, DCD, RING, and DSR. Of course, if the
-    corresponding constants are defined on the particular platform.
-*/
-SerialPort::Lines UnixSerialPortEngine::lines() const
-{
-    int arg = 0;
-    SerialPort::Lines ret = 0;
-
-    if (::ioctl(m_descriptor, TIOCMGET, &arg) == -1)
-        return ret;
-
-#ifdef TIOCLE
-    if (arg & TIOCLE)
-        ret |= SerialPort::Le;
-#endif
-#ifdef TIOCDTR
-    if (arg & TIOCDTR)
-        ret |= SerialPort::Dtr;
-#endif
-#ifdef TIOCRTS
-    if (arg & TIOCRTS)
-        ret |= SerialPort::Rts;
-#endif
-#ifdef TIOCST
-    if (arg & TIOCST)
-        ret |= SerialPort::St;
-#endif
-#ifdef TIOCSR
-    if (arg & TIOCSR)
-        ret |= SerialPort::Sr;
-#endif
-#ifdef TIOCCTS
-    if (arg & TIOCCTS)
-        ret |= SerialPort::Cts;
-#endif
-#ifdef TIOCCAR
-    if (arg & TIOCCAR)
-        ret |= SerialPort::Dcd;
-#elif defined (TIOCCD)
-    if (arg & TIOCCD)
-        ret |= SerialPort::Dcd;
-#endif
-#ifdef TIOCRNG
-    if (arg & TIOCRNG)
-        ret |= SerialPort::Ri;
-#elif defined (TIOCRI)
-    if (arg & TIOCRI)
-        ret |= SerialPort::Ri;
-#endif
-#ifdef TIOCDSR
-    if (arg & TIOCDSR)
-        ret |= SerialPort::Dsr;
-#endif
-
-    return ret;
-}
-
-//
-static bool trigger_out_line(int fd, int bit, bool set)
-{
-    int arg = 0;
-    bool ret = ::ioctl(fd, TIOCMGET, &arg) != -1;
-
-    if (ret) {
-        int tmp = arg & bit;
-
-        // If line already installed, then it no need change.
-        if ((tmp && set) || (!(tmp || set)))
-            return true;
-
-        if (set)
-            arg |= bit;
-        else
-            arg &= ~bit;
-
-        ret = ::ioctl(fd, TIOCMSET, &arg) != -1;
-    }
-    return ret;
-}
-
-/*!
-    Set DTR signal to state \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool UnixSerialPortEngine::setDtr(bool set)
-{
-    return trigger_out_line(m_descriptor, TIOCM_DTR, set);
-}
-
-/*!
-    Set RTS signal to state \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool UnixSerialPortEngine::setRts(bool set)
-{
-    return trigger_out_line(m_descriptor, TIOCM_RTS, set);
-}
-
-/*!
-    The shall block until all data output written to the serial
-    port is transmitted.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool UnixSerialPortEngine::flush()
-{
-    return ::tcdrain(m_descriptor) != -1;
-}
-
-/*!
-    Flushes both data received but not read and data written
-    but not transmitted.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool UnixSerialPortEngine::reset()
-{
-    return ::tcflush(m_descriptor, TCIOFLUSH) != -1;
-}
-
-/*!
-    Send a break for a specific \a duration.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool UnixSerialPortEngine::sendBreak(int duration)
-{
-    return ::tcsendbreak(m_descriptor, duration) != -1;
-}
-
-/*!
-    Turn break on or off, that is, start or stop sending zero
-    bits, depending on the parameter \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool UnixSerialPortEngine::setBreak(bool set)
-{
-    return ::ioctl(m_descriptor, set ? TIOCSBRK : TIOCCBRK) != -1;
-}
-
-/*!
-    If successful, returns the number of bytes in
-    the input buffer; otherwise -1.
-*/
-qint64 UnixSerialPortEngine::bytesAvailable() const
-{
-    int nbytes = 0;
-#ifdef TIOCINQ
-    if (::ioctl(m_descriptor, TIOCINQ, &nbytes) == -1)
-        return -1;
-#endif
-    return nbytes;
-}
-
-/*!
-    If successful, returns the number of bytes in
-    the output buffer; otherwise -1.
-*/
-qint64 UnixSerialPortEngine::bytesToWrite() const
-{
-    int nbytes = 0;
-#ifdef TIOCOUTQ
-    if (::ioctl(m_descriptor, TIOCOUTQ, &nbytes) == -1)
-        return -1;
-#endif
-    return nbytes;
-}
-
-/*!
-    Reads at most \a len bytes from the serial port into \a data, and returns
-    the number of bytes read. If an error occurs, this function returns -1
-    and sets an error code. This function returns immediately.
-
-    Some platforms does not support the mark or space parity, so
-    a software emulation of these modes is done while reading.
-
-    Also, this method processed the policy of operating with the
-    received symbol, in which the parity or frame error is detected.
-*/
-qint64 UnixSerialPortEngine::read(char *data, qint64 len)
-{
-    qint64 bytesRead = 0;
-#ifdef CMSPAR
-    if (dptr->options.parity == SerialPort::NoParity
-            || dptr->options.policy != SerialPort::StopReceivingPolicy) {
-#else
-    if (dptr->options.parity != SerialPort::MarkParity
-            && dptr->options.parity != SerialPort::SpaceParity) {
-#endif
-        bytesRead = ::read(m_descriptor, data, len);
-    } else {// Perform parity emulation.
-        bytesRead = readPerChar(data, len);
-    }
-
-    // FIXME: Here 'errno' codes for sockets.
-    // You need to replace the codes for the serial port.
-    if (bytesRead < 0) {
-        bytesRead = -1;
-        switch (errno) {
-#if EWOULDBLOCK-0 && EWOULDBLOCK != EAGAIN
-        case EWOULDBLOCK:
-#endif
-        case EAGAIN:
-            // No data was available for reading.
-            bytesRead = -2;
-            break;
-        case EBADF:
-        case EINVAL:
-        case EIO:
-            break;
-        case ECONNRESET:
-            bytesRead = 0;
-            break;
-        default:
-            break;
-        }
-    }
-    return bytesRead;
-}
-
-/*!
-    Writes at most \a len bytes of data from \a data to the serial port.
-    If successful, returns the number of bytes that were actually written;
-    otherwise returns -1 and sets an error code.
-
-    Some platforms does not support the mark or space parity, so
-    running software emulation of these modes while writing.
-*/
-qint64 UnixSerialPortEngine::write(const char *data, qint64 len)
-{
-    qint64 bytesWritten = 0;
-#ifdef CMSPAR
-    bytesWritten = ::write(m_descriptor, data, len);
-#else
-    if (dptr->options.parity != SerialPort::MarkParity
-            && dptr->options.parity != SerialPort::SpaceParity) {
-        bytesWritten = ::write(m_descriptor, data, len);
-    } else {// Perform parity emulation.
-        bytesWritten = writePerChar(data, len);
-    }
-#endif
-
-    // FIXME: Here 'errno' codes for sockets.
-    // You need to replace the codes for the serial port.
-    if (bytesWritten < 0) {
-        switch (errno) {
-        case EPIPE:
-        case ECONNRESET:
-            bytesWritten = -1;
-            break;
-        case EAGAIN:
-            bytesWritten = 0;
-            break;
-        case EMSGSIZE:
-            break;
-        default:
-            break;
-        }
-    }
-    return bytesWritten;
-}
-
-/*!
-    Implements a function blocking for waiting of events on the
-    \a timeout in millisecond, those listed in fdread will be watched
-    to see if characters become available for reading (more precisely,
-    to see if a read will not block; in particular, a file m_descriptor
-    is also ready on end-of-file), those in fdwrite will be watched
-    to see if a write will not block.
-
-    Event fdread controlled, if the flag \a checkRead is set on true,
-    and fdwrite wehn flag \a checkWrite is set on true. The result
-    of catch in each of the events, save to the corresponding
-    variables \a selectForRead and \a selectForWrite.
-
-    Returns true if the occurrence of any event before the timeout;
-    otherwise returns false.
-*/
-bool UnixSerialPortEngine::select(int timeout,
-                                  bool checkRead, bool checkWrite,
-                                  bool *selectForRead, bool *selectForWrite)
-{
-    fd_set fdread;
-    FD_ZERO(&fdread);
-    if (checkRead)
-        FD_SET(m_descriptor, &fdread);
-
-    fd_set fdwrite;
-    FD_ZERO(&fdwrite);
-    if (checkWrite)
-        FD_SET(m_descriptor, &fdwrite);
-
-    struct timeval tv;
-    tv.tv_sec = timeout / 1000;
-    tv.tv_usec = (timeout % 1000) * 1000;
-
-    if (::select(m_descriptor + 1, &fdread, &fdwrite, 0, timeout < 0 ? 0 : &tv) <= 0) {
-        Q_ASSERT(selectForRead);
-        *selectForRead = false;
-        Q_ASSERT(selectForWrite);
-        *selectForWrite = false;
-        return false;
-    }
-
-    if (checkRead) {
-        Q_ASSERT(selectForRead);
-        *selectForRead = FD_ISSET(m_descriptor, &fdread);
-    }
-
-    if (checkWrite) {
-        Q_ASSERT(selectForWrite);
-        *selectForWrite = FD_ISSET(m_descriptor, &fdwrite);
-    }
-    return true;
-}
-
-/*!
-    Sets the desired baud \a rate for the given direction \a dir,
-    where \a rate is expressed by any positive integer type qint32.
-    Also the method makes attempts to analyze the type of the desired
-    standard or custom speed and sets the value.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
-{
-    bool ret = rate > 0;
-
-    // prepare section
-
-    if (ret) {
-        const qint32 unixRate = SerialPortPrivate::settingFromRate(rate);
-        if (unixRate > 0) {
-            // try prepate to set standard baud rate
-#ifdef Q_OS_LINUX
-            // prepare to forcefully reset the custom mode
-            if (m_isCustomRateSupported) {
-                //m_currentSerialInfo.flags |= ASYNC_SPD_MASK;
-                m_currentSerialInfo.flags &= ~(ASYNC_SPD_CUST /* | ASYNC_LOW_LATENCY*/);
-                m_currentSerialInfo.custom_divisor = 0;
-            }
-#endif
-            // prepare to set standard rate
-            ret = !(((dir & SerialPort::Input) && ::cfsetispeed(&m_currentTermios, unixRate) < 0)
-                    || ((dir & SerialPort::Output) && ::cfsetospeed(&m_currentTermios, unixRate) < 0));
-        } else {
-            // try prepate to set custom baud rate
-#ifdef Q_OS_LINUX
-            // prepare to forcefully set the custom mode
-            if (m_isCustomRateSupported) {
-                m_currentSerialInfo.flags &= ~ASYNC_SPD_MASK;
-                m_currentSerialInfo.flags |= (ASYNC_SPD_CUST /* | ASYNC_LOW_LATENCY*/);
-                m_currentSerialInfo.custom_divisor = m_currentSerialInfo.baud_base / rate;
-                if (m_currentSerialInfo.custom_divisor == 0)
-                    m_currentSerialInfo.custom_divisor = 1;
-                // for custom mode needed prepare to set B38400 rate
-                ret = (::cfsetspeed(&m_currentTermios, B38400) != -1);
-            } else {
-                ret = false;
-            }
-#elif defined (Q_OS_MAC)
-
-#  if defined (MAC_OS_X_VERSION_10_4) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_4)
-            // Starting with Tiger, the IOSSIOSPEED ioctl can be used to set arbitrary baud rates
-            // other than those specified by POSIX. The driver for the underlying serial hardware
-            // ultimately determines which baud rates can be used. This ioctl sets both the input
-            // and output speed.
-            ret = ::ioctl(m_descriptor, IOSSIOSPEED, &rate) != -1;
-#  else
-            // others MacOSX version, can't prepare to set custom rate
-            ret = false;
-#  endif
-
-#else
-            // others *nix OS, can't prepare to set custom rate
-            ret = false;
-#endif
-        }
-    }
-
-    // finally section
-
-#ifdef Q_OS_LINUX
-    if (ret && m_isCustomRateSupported) // finally, set or reset the custom mode
-        ret = ::ioctl(m_descriptor, TIOCSSERIAL, &m_currentSerialInfo) != -1;
-#endif
-
-    if (ret) // finally, set rate
-        ret = updateTermios();
-    else
-        dptr->setError(decodeSystemError());
-    return ret;
-}
-
-/*!
-    Sets the desired number of data bits \a dataBits in a frame. POSIX
-    supports all present number of data bits 5, 6, 7, and 8.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool UnixSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
-{
-    m_currentTermios.c_cflag &= ~CSIZE;
-    switch (dataBits) {
-    case SerialPort::Data5:
-        m_currentTermios.c_cflag |= CS5;
-        break;
-    case SerialPort::Data6:
-        m_currentTermios.c_cflag |= CS6;
-        break;
-    case SerialPort::Data7:
-        m_currentTermios.c_cflag |= CS7;
-        break;
-    case SerialPort::Data8:
-        m_currentTermios.c_cflag |= CS8;
-        break;
-    default:
-        m_currentTermios.c_cflag |= CS8;
-        break;
-    }
-    return updateTermios();
-}
-
-/*!
-    Sets the desired \a parity control mode. POSIX does not support
-    the modes mark and space, so they are software emulated in the
-    methods read() and write(). Some GNU/Linux variants have hardware
-    support for these modes and don't need an emulation.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool UnixSerialPortEngine::setParity(SerialPort::Parity parity)
-{
-    m_currentTermios.c_iflag &= ~(PARMRK | INPCK);
-    m_currentTermios.c_iflag |= IGNPAR;
-
-    switch (parity) {
-
-#ifdef CMSPAR
-    // Here Installation parity only for GNU/Linux where the macro CMSPAR.
-    case SerialPort::SpaceParity:
-        m_currentTermios.c_cflag &= ~PARODD;
-        m_currentTermios.c_cflag |= PARENB | CMSPAR;
-        break;
-    case SerialPort::MarkParity:
-        m_currentTermios.c_cflag |= PARENB | CMSPAR | PARODD;
-        break;
-#endif
-    case SerialPort::NoParity:
-        m_currentTermios.c_cflag &= ~PARENB;
-        break;
-    case SerialPort::EvenParity:
-        m_currentTermios.c_cflag &= ~PARODD;
-        m_currentTermios.c_cflag |= PARENB;
-        break;
-    case SerialPort::OddParity:
-        m_currentTermios.c_cflag |= PARENB | PARODD;
-        break;
-    default:
-        m_currentTermios.c_cflag |= PARENB;
-        m_currentTermios.c_iflag |= PARMRK | INPCK;
-        m_currentTermios.c_iflag &= ~IGNPAR;
-        break;
-    }
-
-    return updateTermios();
-}
-
-/*!
-    Sets the desired number of stop bits \a stopBits in a frame. POSIX
-    only supports 1 or 2 stop bits.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool UnixSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
-{
-    switch (stopBits) {
-    case SerialPort::OneStop:
-        m_currentTermios.c_cflag &= ~CSTOPB;
-        break;
-    case SerialPort::TwoStop:
-        m_currentTermios.c_cflag |= CSTOPB;
-        break;
-    default:
-        m_currentTermios.c_cflag &= ~CSTOPB;
-        break;
-    }
-    return updateTermios();
-}
-
-/*!
-    Sets the desired \a flow control mode. POSIX supports all
-    present flow control modes: no control, hardware (RTS/CTS),
-    and software (XON/XOFF).
-
-    If successful, returns true; otherwise returns false, and sets an
-    error code.
-*/
-bool UnixSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
-{
-    switch (flow) {
-    case SerialPort::NoFlowControl:
-        m_currentTermios.c_cflag &= ~CRTSCTS;
-        m_currentTermios.c_iflag &= ~(IXON | IXOFF | IXANY);
-        break;
-    case SerialPort::HardwareControl:
-        m_currentTermios.c_cflag |= CRTSCTS;
-        m_currentTermios.c_iflag &= ~(IXON | IXOFF | IXANY);
-        break;
-    case SerialPort::SoftwareControl:
-        m_currentTermios.c_cflag &= ~CRTSCTS;
-        m_currentTermios.c_iflag |= IXON | IXOFF | IXANY;
-        break;
-    default:
-        m_currentTermios.c_cflag &= ~CRTSCTS;
-        m_currentTermios.c_iflag &= ~(IXON | IXOFF | IXANY);
-        break;
-    }
-    return updateTermios();
-}
-
-/*!
-    Sets the desired char error \a policy when frame or parity errors are
-    detected.
-*/
-bool UnixSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
-{
-    tcflag_t parmrkMask = PARMRK;
-#ifndef CMSPAR
-    //in space/mark parity emulation also used PARMRK flag
-    if (dptr->options.parity == SerialPort::SpaceParity
-            || dptr->options.parity == SerialPort::MarkParity) {
-        parmrkMask = 0;
-    }
-#endif //CMSPAR
-    switch (policy) {
-    case SerialPort::SkipPolicy:
-        m_currentTermios.c_iflag &= ~parmrkMask;
-        m_currentTermios.c_iflag |= IGNPAR | INPCK;
-        break;
-    case SerialPort::PassZeroPolicy:
-        m_currentTermios.c_iflag &= ~(IGNPAR | parmrkMask);
-        m_currentTermios.c_iflag |= INPCK;
-        break;
-    case SerialPort::IgnorePolicy:
-        m_currentTermios.c_iflag &= ~INPCK;
-        break;
-    case SerialPort::StopReceivingPolicy:
-        m_currentTermios.c_iflag &= ~IGNPAR;
-        m_currentTermios.c_iflag |= parmrkMask | INPCK;
-        break;
-    default:
-        m_currentTermios.c_iflag &= ~INPCK;
-        break;
-    }
-    return updateTermios();
-}
-
-/*!
-    Returns the current read notification subsystem status.
-*/
-bool UnixSerialPortEngine::isReadNotificationEnabled() const
-{
-    return m_readNotifier && m_readNotifier->isEnabled();
-}
-
-/*!
-    Enables or disables the read notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of the event fdread.
-    Thereby, SerialPort can emit the signal readyRead() and automatically
-    fill the internal receive buffer with new data that was received from
-    the serial port in the event loop.
-*/
-void UnixSerialPortEngine::setReadNotificationEnabled(bool enable)
-{
-    if (m_readNotifier)
-        m_readNotifier->setEnabled(enable);
-    else if (enable) {
-        m_readNotifier =
-                new QSocketNotifier(m_descriptor, QSocketNotifier::Read, this);
-
-        m_readNotifier->installEventFilter(this);
-        m_readNotifier->setEnabled(true);
-    }
-}
-
-/*!
-    Returns the current write notification subsystem status.
-*/
-bool UnixSerialPortEngine::isWriteNotificationEnabled() const
-{
-    return m_writeNotifier && m_writeNotifier->isEnabled();
-}
-
-/*!
-    Enables or disables the write notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of the event fdwrite.
-    Thereby, SerialPort can automatically write data from the
-    internal transfer buffer to the serial port in the event loop.
-*/
-void UnixSerialPortEngine::setWriteNotificationEnabled(bool enable)
-{
-    if (m_writeNotifier)
-        m_writeNotifier->setEnabled(enable);
-    else if (enable) {
-        m_writeNotifier =
-                new QSocketNotifier(m_descriptor, QSocketNotifier::Write, this);
-
-        m_writeNotifier->installEventFilter(this);
-        m_writeNotifier->setEnabled(true);
-    }
-}
-
-/*!
-    Returns the current error notification subsystem status.
-*/
-bool UnixSerialPortEngine::isErrorNotificationEnabled() const
-{
-    return m_exceptionNotifier && m_exceptionNotifier->isEnabled();
-}
-
-/*!
-    Enables or disables the error notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of the event fderror.
-*/
-void UnixSerialPortEngine::setErrorNotificationEnabled(bool enable)
-{
-    if (m_exceptionNotifier)
-        m_exceptionNotifier->setEnabled(enable);
-    else if (enable) {
-        m_exceptionNotifier =
-                new QSocketNotifier(m_descriptor, QSocketNotifier::Exception, this);
-
-        m_exceptionNotifier->installEventFilter(this);
-        m_exceptionNotifier->setEnabled(true);
-    }
-}
-
-/*!
-    Not used in POSIX implementation, error handling is carried
-    out in other ways.
-
-    Always returns false.
-*/
-bool UnixSerialPortEngine::processIOErrors()
-{
-    // No need impl.
-    return false;
-}
-
-/* Protected methods */
-
-/*!
-    Attempts to determine the current serial port settings,
-    when the port is opened. Used only in the method open().
-*/
-void UnixSerialPortEngine::detectDefaultSettings()
-{
-    // Detect rate.
-    const speed_t inputUnixRate = ::cfgetispeed(&m_currentTermios);
-    const speed_t outputUnixRate = ::cfgetospeed(&m_currentTermios);
-    bool isCustomRateCurrentSet = false;
-
-#ifdef Q_OS_LINUX
-    // try detect the ability to support custom rate
-    m_isCustomRateSupported = ::ioctl(m_descriptor, TIOCGSERIAL, &m_currentSerialInfo) != -1
-            && ::ioctl(m_descriptor, TIOCSSERIAL, &m_currentSerialInfo) != -1;
-
-    if (m_isCustomRateSupported) {
-
-        m_restoredSerialInfo = m_currentSerialInfo;
-
-        // assume that the baud rate is a custom
-        isCustomRateCurrentSet = inputUnixRate == B38400 && outputUnixRate == B38400;
-
-        if (isCustomRateCurrentSet) {
-            if ((m_currentSerialInfo.flags & ASYNC_SPD_CUST)
-                    && m_currentSerialInfo.custom_divisor > 0) {
-
-                // yes, speed is really custom
-                dptr->options.inputRate = m_currentSerialInfo.baud_base / m_currentSerialInfo.custom_divisor;
-                dptr->options.outputRate = dptr->options.inputRate;
-            } else {
-                // no, we were wrong and the speed is a standard 38400 baud
-                isCustomRateCurrentSet = false;
-            }
-        }
-    }
-#else
-    // other *nix
-#endif
-    if (!m_isCustomRateSupported || !isCustomRateCurrentSet) {
-        dptr->options.inputRate = SerialPortPrivate::rateFromSetting(inputUnixRate);
-        dptr->options.outputRate = SerialPortPrivate::rateFromSetting(outputUnixRate);
-    }
-
-    // Detect databits.
-    switch (m_currentTermios.c_cflag & CSIZE) {
-    case CS5:
-        dptr->options.dataBits = SerialPort::Data5;
-        break;
-    case CS6:
-        dptr->options.dataBits = SerialPort::Data6;
-        break;
-    case CS7:
-        dptr->options.dataBits = SerialPort::Data7;
-        break;
-    case CS8:
-        dptr->options.dataBits = SerialPort::Data8;
-        break;
-    default:
-        dptr->options.dataBits = SerialPort::UnknownDataBits;
-        break;
-    }
-
-    // Detect parity.
-#ifdef CMSPAR
-    if (m_currentTermios.c_cflag & CMSPAR) {
-        dptr->options.parity = m_currentTermios.c_cflag & PARODD ?
-                    SerialPort::MarkParity : SerialPort::SpaceParity;
-    } else {
-#endif
-        if (m_currentTermios.c_cflag & PARENB) {
-            dptr->options.parity = m_currentTermios.c_cflag & PARODD ?
-                        SerialPort::OddParity : SerialPort::EvenParity;
-        } else {
-            dptr->options.parity = SerialPort::NoParity;
-        }
-#ifdef CMSPAR
-    }
-#endif
-
-    // Detect stopbits.
-    dptr->options.stopBits = m_currentTermios.c_cflag & CSTOPB ?
-                SerialPort::TwoStop : SerialPort::OneStop;
-
-    // Detect flow control.
-    if ((!(m_currentTermios.c_cflag & CRTSCTS)) && (!(m_currentTermios.c_iflag & (IXON | IXOFF | IXANY))))
-        dptr->options.flow = SerialPort::NoFlowControl;
-    else if ((!(m_currentTermios.c_cflag & CRTSCTS)) && (m_currentTermios.c_iflag & (IXON | IXOFF | IXANY)))
-        dptr->options.flow = SerialPort::SoftwareControl;
-    else if ((m_currentTermios.c_cflag & CRTSCTS) && (!(m_currentTermios.c_iflag & (IXON | IXOFF | IXANY))))
-        dptr->options.flow = SerialPort::HardwareControl;
-    else
-        dptr->options.flow = SerialPort::UnknownFlowControl;
-
-    //detect error policy
-    if (m_currentTermios.c_iflag & INPCK) {
-        if (m_currentTermios.c_iflag & IGNPAR)
-            dptr->options.policy = SerialPort::SkipPolicy;
-        else if (m_currentTermios.c_iflag & PARMRK)
-            dptr->options.policy = SerialPort::StopReceivingPolicy;
-        else
-            dptr->options.policy = SerialPort::PassZeroPolicy;
-    } else {
-        dptr->options.policy = SerialPort::IgnorePolicy;
-    }
-}
-
-/*!
-    Converts the platform-depend code of system error to the
-    corresponding value a SerialPort::PortError.
-*/
-SerialPort::PortError UnixSerialPortEngine::decodeSystemError() const
-{
-    SerialPort::PortError error;
-    switch (errno) {
-    case ENODEV:
-        error = SerialPort::NoSuchDeviceError;
-        break;
-    case EACCES:
-        error = SerialPort::PermissionDeniedError;
-        break;
-    case EBUSY:
-        error = SerialPort::PermissionDeniedError;
-        break;
-    case ENOTTY:
-        error = SerialPort::IoError;
-        break;
-    default:
-        error = SerialPort::UnknownPortError;
-        break;
-    }
-    return error;
-}
-
-/*!
-    POSIX event loop for notification subsystem.
-    Asynchronously in event loop continuous mode tracking the
-    events from the serial port, as: fderror, fdread, and fdwrite.
-    Calls the handler from the parent class SerialPortPrivate
-    when a relevant event occurs.
-*/
-bool UnixSerialPortEngine::eventFilter(QObject *obj, QEvent *e)
-{
-    if (e->type() == QEvent::SockAct) {
-        if (obj == m_readNotifier) {
-            dptr->canReadNotification();
-            return true;
-        }
-        if (obj == m_writeNotifier) {
-            dptr->canWriteNotification();
-            return true;
-        }
-        if (obj == m_exceptionNotifier) {
-            dptr->canErrorNotification();
-            return true;
-        }
-    }
-    return QObject::eventFilter(obj, e);
-}
-
-/*!
-    Updates the termios structure when changing any serial port parameter.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool UnixSerialPortEngine::updateTermios()
-{
-    if (::tcsetattr(m_descriptor, TCSANOW, &m_currentTermios) == -1) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    return true;
-}
-
-/* */
-static inline bool evenParity(quint8 c)
-{
-    c ^= c >> 4;        //(c7 ^ c3)(c6 ^ c2)(c5 ^ c1)(c4 ^ c0)
-    c ^= c >> 2;        //[(c7 ^ c3)(c5 ^ c1)][(c6 ^ c2)(c4 ^ c0)]
-    c ^= c >> 1;
-    return c & 1;       //(c7 ^ c3)(c5 ^ c1)(c6 ^ c2)(c4 ^ c0)
-}
-
-#ifndef CMSPAR
-
-/*!
-    For platforms that do not have the support of parities mark and space
-    performed character by character emulation data transmitted, that
-    one by one character is written to the port.
-*/
-qint64 UnixSerialPortEngine::writePerChar(const char *data, qint64 maxSize)
-{
-    qint64 ret = 0;
-    quint8 const charMask = (0xFF >> (8 - dptr->options.dataBits));
-
-    while (ret < maxSize) {
-
-        bool par = evenParity(*data & charMask);
-        // False if need EVEN, true if need ODD.
-        par ^= dptr->options.parity == SerialPort::MarkParity;
-        if (par ^ (m_currentTermios.c_cflag & PARODD)) { // Need switch parity mode?
-            m_currentTermios.c_cflag ^= PARODD;
-            flush(); //force sending already buffered data, because updateTermios() cleares buffers
-            //todo: add receiving buffered data!!!
-            if (!updateTermios())
-                break;
-        }
-
-        int r = ::write(m_descriptor, data, 1);
-        if (r < 0)
-            return -1;
-        if (r > 0) {
-            data += r;
-            ret += r;
-        }
-    }
-    return ret;
-}
-
-#endif //CMSPAR
-
-/*!
-    Platforms which does not have the support for mark and space parity checking
-    requires emulation using character by character data receiving.
-*/
-qint64 UnixSerialPortEngine::readPerChar(char *data, qint64 maxSize)
-{
-    qint64 ret = 0;
-    quint8 const charMask = (0xFF >> (8 - dptr->options.dataBits));
-
-    // 0 - prefix not started,
-    // 1 - received 0xFF,
-    // 2 - received 0xFF and 0x00
-    int prefix = 0;
-    while (ret < maxSize) {
-
-        qint64 r = ::read(m_descriptor, data, 1);
-        if (r < 0) {
-            if (errno == EAGAIN) // It is ok for nonblocking mode.
-                break;
-            return -1;
-        }
-        if (r == 0)
-            break;
-
-        bool par = true;
-        switch (prefix) {
-        case 2: // Previously received both 0377 and 0.
-            par = false;
-            prefix = 0;
-            break;
-        case 1: // Previously received 0377.
-            if (*data == '\0') {
-                ++prefix;
-                continue;
-            }
-            prefix = 0;
-            break;
-        default:
-            if (*data == '\377') {
-                prefix = 1;
-                continue;
-            }
-            break;
-        }
-        // Now: par contains parity ok or error, *data contains received character
-        par ^= evenParity(*data & charMask); //par contains parity bit value for EVEN mode
-        par ^= (m_currentTermios.c_cflag & PARODD); //par contains parity bit value for current mode
-        if (par ^ (dptr->options.parity == SerialPort::SpaceParity)) { //if parity error
-            switch (dptr->options.policy) {
-            case SerialPort::SkipPolicy:
-                continue;       //ignore received character
-            case SerialPort::StopReceivingPolicy:
-                if (dptr->options.parity != SerialPort::NoParity)
-                    dptr->portError = SerialPort::ParityError;
-                else
-                    dptr->portError = *data == '\0' ?
-                                SerialPort::BreakConditionError : SerialPort::FramingError;
-                return ++ret;   //abort receiving
-                break;
-            case SerialPort::UnknownPolicy:
-                qWarning() << "Unknown error policy is used! Falling back to PassZeroPolicy";
-            case SerialPort::PassZeroPolicy:
-                *data = '\0';   //replace received character by zero
-                break;
-            case SerialPort::IgnorePolicy:
-                break;          //ignore error and pass received character
-            }
-        }
-        ++data;
-        ++ret;
-    }
-    return ret;
-}
-
-// From <serialportengine_p.h>
-SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
-{
-    return new UnixSerialPortEngine(d);
-}
-
-/* Public static the SerialPortPrivate methods */
-
-#ifdef Q_OS_MAC
-static const QLatin1String defaultPathPrefix("/dev/cu.");
-static const QLatin1String notUsedPathPrefix("/dev/tty.");
-#else
-static const QLatin1String defaultPathPrefix("/dev/");
-#endif
-
-/*!
-    Converts a platform specific \a port name to a system location
-    and returns the value.
-*/
-QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
-{
-    QString ret = port;
-
-#ifdef Q_OS_MAC
-    ret.remove(notUsedPathPrefix);
-#endif
-
-    if (!ret.contains(defaultPathPrefix))
-        ret.prepend(defaultPathPrefix);
-    return ret;
-}
-
-/*!
-    Converts a platform specific system \a location to a port name
-    and returns the value.
-*/
-QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
-{
-    QString ret = location;
-
-#ifdef Q_OS_MAC
-    ret.remove(notUsedPathPrefix);
-#endif
-
-    ret.remove(defaultPathPrefix);
-    return ret;
-}
-
-struct RatePair
-{
-   qint32 rate;    // The numerical value of baud rate.
-   qint32 setting; // The OS-specific code of baud rate.
-   bool operator<(const RatePair &other) const { return rate < other.rate; }
-   bool operator==(const RatePair &other) const { return setting == other.setting; }
-};
-
-// This table contains correspondences standard pairs values of
-// baud rates that are defined in file termios.h
-static
-const RatePair standardRatesTable[] =
-{
-    #ifdef B50
-    { 50, B50 },
-    #endif
-    #ifdef B75
-    { 75, B75 },
-    #endif
-    #ifdef B110
-    { 110, B110 },
-    #endif
-    #ifdef B134
-    { 134, B134 },
-    #endif
-    #ifdef B150
-    { 150, B150 },
-    #endif
-    #ifdef B200
-    { 200, B200 },
-    #endif
-    #ifdef B300
-    { 300, B300 },
-    #endif
-    #ifdef B600
-    { 600, B600 },
-    #endif
-    #ifdef B1200
-    { 1200, B1200 },
-    #endif
-    #ifdef B1800
-    { 1800, B1800 },
-    #endif
-    #ifdef B2400
-    { 2400, B2400 },
-    #endif
-    #ifdef B4800
-    { 4800, B4800 },
-    #endif
-    #ifdef B9600
-    { 9600, B9600 },
-    #endif
-    #ifdef B19200
-    { 19200, B19200 },
-    #endif
-    #ifdef B38400
-    { 38400, B38400 },
-    #endif
-    #ifdef B57600
-    { 57600, B57600 },
-    #endif
-    #ifdef B115200
-    { 115200, B115200 },
-    #endif
-    #ifdef B230400
-    { 230400, B230400 },
-    #endif
-    #ifdef B460800
-    { 460800, B460800 },
-    #endif
-    #ifdef B500000
-    { 500000, B500000 },
-    #endif
-    #ifdef B576000
-    { 576000, B576000 },
-    #endif
-    #ifdef B921600
-    { 921600, B921600 },
-    #endif
-    #ifdef B1000000
-    { 1000000, B1000000 },
-    #endif
-    #ifdef B1152000
-    { 1152000, B1152000 },
-    #endif
-    #ifdef B1500000
-    { 1500000, B1500000 },
-    #endif
-    #ifdef B2000000
-    { 2000000, B2000000},
-    #endif
-    #ifdef B2500000
-    { 2500000, B2500000 },
-    #endif
-    #ifdef B3000000
-    { 3000000, B3000000 },
-    #endif
-    #ifdef B3500000
-    { 3500000, B3500000 },
-    #endif
-    #ifdef B4000000
-    { 4000000, B4000000 }
-    #endif
-};
-
-static const RatePair *standardRatesTable_end =
-        standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
-
-/*!
-    Converts the *nix-specific baud rate code \a setting to a numeric value.
-    If the desired item is not found, returns 0.
-*/
-qint32 SerialPortPrivate::rateFromSetting(qint32 setting)
-{
-    const RatePair rp = { 0, setting };
-    const RatePair *ret = qFind(standardRatesTable, standardRatesTable_end, rp);
-    return ret != standardRatesTable_end ? ret->rate : 0;
-}
-
-/*!
-    Converts a numeric baud \a rate value to the *nix-specific code.
-    If the desired item is not found, returns 0.
-*/
-qint32 SerialPortPrivate::settingFromRate(qint32 rate)
-{
-    const RatePair rp = { rate, 0 };
-    const RatePair *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rp);
-    return ret != standardRatesTable_end ? ret->setting : 0;
-}
-
-/*!
-    Returns a list of standard baud rate values, codes are defined in termios.h.
-*/
-QList<qint32> SerialPortPrivate::standardRates()
-{
-    QList<qint32> ret;
-    for (const RatePair *it = standardRatesTable; it != standardRatesTable_end; ++it)
-       ret.append(it->rate);
-    return ret;
-}
-
-#include "moc_serialportengine_unix_p.cpp"
-
-QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialportengine_unix_p.h b/src/serialportengine_unix_p.h
deleted file mode 100755
index f180ba8..0000000
--- a/src/serialportengine_unix_p.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef SERIALPORTENGINE_UNIX_P_H
-#define SERIALPORTENGINE_UNIX_P_H
-
-#include "serialport.h"
-#include "serialportengine_p.h"
-
-#include <termios.h>
-#ifdef Q_OS_LINUX
-#  include <linux/serial.h>
-#endif
-
-class QSocketNotifier;
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-class UnixSerialPortEngine : public QObject, public SerialPortEngine
-{
-    Q_OBJECT
-public:
-    UnixSerialPortEngine(SerialPortPrivate *d);
-    virtual ~UnixSerialPortEngine();
-
-    virtual bool open(const QString &location, QIODevice::OpenMode mode);
-    virtual void close(const QString &location);
-
-    virtual SerialPort::Lines lines() const;
-
-    virtual bool setDtr(bool set);
-    virtual bool setRts(bool set);
-
-    virtual bool flush();
-    virtual bool reset();
-
-    virtual bool sendBreak(int duration);
-    virtual bool setBreak(bool set);
-
-    virtual qint64 bytesAvailable() const;
-    virtual qint64 bytesToWrite() const;
-
-    virtual qint64 read(char *data, qint64 len);
-    virtual qint64 write(const char *data, qint64 len);
-    virtual bool select(int timeout,
-                        bool checkRead, bool checkWrite,
-                        bool *selectForRead, bool *selectForWrite);
-
-    virtual bool setRate(qint32 rate, SerialPort::Directions dir);
-    virtual bool setDataBits(SerialPort::DataBits dataBits);
-    virtual bool setParity(SerialPort::Parity parity);
-    virtual bool setStopBits(SerialPort::StopBits stopBits);
-    virtual bool setFlowControl(SerialPort::FlowControl flowControl);
-
-    virtual bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy);
-
-    virtual bool isReadNotificationEnabled() const;
-    virtual void setReadNotificationEnabled(bool enable);
-    virtual bool isWriteNotificationEnabled() const;
-    virtual void setWriteNotificationEnabled(bool enable);
-    virtual bool isErrorNotificationEnabled() const;
-    virtual void setErrorNotificationEnabled(bool enable);
-
-    virtual bool processIOErrors();
-
-protected:
-    virtual void detectDefaultSettings();
-    virtual SerialPort::PortError decodeSystemError() const;
-    virtual bool eventFilter(QObject *obj, QEvent *e);
-
-private:
-    bool updateTermios();
-
-#ifndef CMSPAR
-    qint64 writePerChar(const char *data, qint64 maxSize);
-#endif
-    qint64 readPerChar(char *data, qint64 maxSize);
-
-private:
-    struct termios m_currentTermios;
-    struct termios m_restoredTermios;
-#ifdef Q_OS_LINUX
-    struct serial_struct m_currentSerialInfo;
-    struct serial_struct m_restoredSerialInfo;
-#endif
-    int m_descriptor;
-    bool m_isCustomRateSupported;
-
-    QSocketNotifier *m_readNotifier;
-    QSocketNotifier *m_writeNotifier;
-    QSocketNotifier *m_exceptionNotifier;
-};
-
-QT_END_NAMESPACE_SERIALPORT
-
-#endif // SERIALPORTENGINE_UNIX_P_H
diff --git a/src/serialportengine_win.cpp b/src/serialportengine_win.cpp
deleted file mode 100755
index 71c2c41..0000000
--- a/src/serialportengine_win.cpp
+++ /dev/null
@@ -1,1186 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
-** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
-** Copyright (C) 2012 Andre Hartmann <aha_1980@gmx.de>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-    \class WinSerialPortEngine
-    \internal
-
-    \brief The WinSerialPortEngine class provides Windows OS
-    platform-specific low level access to a serial port.
-
-    \reentrant
-    \ingroup serialport-main
-    \inmodule QtSerialPort
-
-    Currently the class supports all Windows NT-based OS (Win 2K/XP/Vista/7).
-
-    WinSerialPortEngine (as well as other platform-dependent engines)
-    is a class with multiple inheritance, which on the one hand,
-    derives from a general abstract class interface SerialPortEngine,
-    on the other hand from QObject.
-
-    From the abstract class SerialPortEngine, this class inherits all virtual
-    interface methods that are common to all serial ports on any platform.
-    The class WinSerialPortEngine implements these methods using the
-    Windows API.
-
-    From QObject, this class inherits system specific Qt features.
-    For NT-based platforms, WinSerialPortEngine uses the private Qt class
-    QWinEventNotifier. This class allows to asynchronously track events
-    from the serial port, such as the appearance of a character in the
-    receive buffer, error I/O, and so forth. All events are handled in the
-    Qt core event loop, so no additional threads are needed to perform these
-    operations.
-*/
-
-#include "serialportengine_win_p.h"
-
-#include <QtCore/qregexp.h>
-#include <QtCore/qcoreevent.h>
-
-#ifndef CTL_CODE
-#  define CTL_CODE(DeviceType, Function, Method, Access) ( \
-    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
-    )
-#endif
-
-#ifndef FILE_DEVICE_SERIAL_PORT
-#  define FILE_DEVICE_SERIAL_PORT  27
-#endif
-
-#ifndef METHOD_BUFFERED
-#  define METHOD_BUFFERED  0
-#endif
-
-#ifndef FILE_ANY_ACCESS
-#  define FILE_ANY_ACCESS  0x00000000
-#endif
-
-#ifndef IOCTL_SERIAL_GET_DTRRTS
-#  define IOCTL_SERIAL_GET_DTRRTS \
-    CTL_CODE(FILE_DEVICE_SERIAL_PORT, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#endif
-
-#ifndef SERIAL_DTR_STATE
-#  define SERIAL_DTR_STATE  0x00000001
-#endif
-
-#ifndef SERIAL_RTS_STATE
-#  define SERIAL_RTS_STATE  0x00000002
-#endif
-
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-/*!
-    Constructs a WinSerialPortEngine and initializes all internal variables
-    to their initial values. The pointer \a d to the private object of class
-    SerialPortPrivate is used to call some common methods.
-*/
-WinSerialPortEngine::WinSerialPortEngine(SerialPortPrivate *d)
-    : m_descriptor(INVALID_HANDLE_VALUE)
-    , m_flagErrorFromCommEvent(false)
-    , m_currentMask(0)
-    , m_desiredMask(0)
-{
-    Q_ASSERT(d);
-    dptr = d;
-    ::memset(&m_currentDcb, 0, sizeof(m_currentDcb));
-    ::memset(&m_restoredDcb, 0, sizeof(m_restoredDcb));
-    ::memset(&m_currentCommTimeouts, 0, sizeof(m_currentCommTimeouts));
-    ::memset(&m_restoredCommTimeouts, 0, sizeof(m_restoredCommTimeouts));
-
-    ::memset(&m_readOverlapped, 0, sizeof(m_readOverlapped));
-    ::memset(&m_writeOverlapped, 0, sizeof(m_writeOverlapped));
-    ::memset(&m_selectOverlapped, 0, sizeof(m_selectOverlapped));
-    ::memset(&m_notifyOverlapped, 0, sizeof(m_notifyOverlapped));
-}
-
-/*!
-    Stops the serial port event tracking and destructs a WinSerialPortEngine.
-*/
-WinSerialPortEngine::~WinSerialPortEngine()
-{
-    setEnabled(false);
-}
-
-/*!
-    Attempts to open the desired serial port by \a location in the given open
-    \a mode. In the process of discovery, always sets the serial port in
-    non-blocking mode (where the read operation returns immediately) and tries
-    to determine and install the current configuration to the serial port.
-
-    It should be noted, that Windows has the following limitations when using
-    the serial port:
-    - support only binary transfers mode
-    - always open in exclusive mode
-
-    For Windows NT-based platforms, the serial port is opened in the overlapped
-    mode, with the flag FILE_FLAG_OVERLAPPED.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode)
-{
-    DWORD desiredAccess = 0;
-    DWORD shareMode = 0;
-    DWORD flagsAndAttributes = FILE_FLAG_OVERLAPPED;
-    bool rxflag = false;
-    bool txflag = false;
-
-    if (mode & QIODevice::ReadOnly) {
-        desiredAccess |= GENERIC_READ;
-        //shareMode = FILE_SHARE_READ;
-        rxflag = true;
-    }
-    if (mode & QIODevice::WriteOnly) {
-        desiredAccess |= GENERIC_WRITE;
-        //shareMode = FILE_SHARE_WRITE;
-        txflag = true;
-    }
-
-    // Try opened serial device.
-    m_descriptor = ::CreateFile(reinterpret_cast<const wchar_t*>(location.utf16()),
-                                desiredAccess, shareMode, 0, OPEN_EXISTING, flagsAndAttributes, 0);
-
-    if (m_descriptor == INVALID_HANDLE_VALUE) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-
-    // Save current DCB port settings.
-    if (::GetCommState(m_descriptor, &m_restoredDcb) == 0) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    m_currentDcb = m_restoredDcb;
-
-    // Set other DCB port options.
-    m_currentDcb.fBinary = true;
-    m_currentDcb.fInX = false;
-    m_currentDcb.fOutX = false;
-    m_currentDcb.fAbortOnError = false;
-    m_currentDcb.fNull = false;
-    m_currentDcb.fErrorChar = false;
-
-    // Apply new DCB init settings.
-    if (!updateDcb())
-        return false;
-
-    // Save current port timeouts.
-    if (::GetCommTimeouts(m_descriptor, &m_restoredCommTimeouts) == 0) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    m_currentCommTimeouts = m_restoredCommTimeouts;
-
-    // Set new port timeouts.
-    ::memset(&m_currentCommTimeouts, 0, sizeof(m_currentCommTimeouts));
-    m_currentCommTimeouts.ReadIntervalTimeout = MAXDWORD;
-
-    // Apply new port timeouts.
-    if (!updateCommTimeouts())
-        return false;
-
-    if (!createEvents(rxflag, txflag)) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-
-    detectDefaultSettings();
-    return true;
-}
-
-/*!
-    Closes a serial port. Before closing, restores the previous serial port
-    settings if necessary.
-*/
-void WinSerialPortEngine::close(const QString &location)
-{
-    Q_UNUSED(location);
-
-    ::CancelIo(m_descriptor);
-
-    if (dptr->options.restoreSettingsOnClose) {
-        ::SetCommState(m_descriptor, &m_restoredDcb);
-        ::SetCommTimeouts(m_descriptor, &m_restoredCommTimeouts);
-    }
-
-    ::CloseHandle(m_descriptor);
-
-    closeEvents();
-    m_descriptor = INVALID_HANDLE_VALUE;
-}
-
-/*!
-    Returns a bitmap state of the RS-232 line signals. On error,
-    the bitmap will be empty (equal zero).
-
-    The Windows API only provides the state of the following signals:
-    CTS, DSR, RING, DCD, DTR, and RTS. Other signals are not available.
-*/
-SerialPort::Lines WinSerialPortEngine::lines() const
-{
-    DWORD modemStat = 0;
-    SerialPort::Lines ret = 0;
-
-    if (::GetCommModemStatus(m_descriptor, &modemStat) == 0)
-        return ret;
-
-    if (modemStat & MS_CTS_ON)
-        ret |= SerialPort::Cts;
-    if (modemStat & MS_DSR_ON)
-        ret |= SerialPort::Dsr;
-    if (modemStat & MS_RING_ON)
-        ret |= SerialPort::Ri;
-    if (modemStat & MS_RLSD_ON)
-        ret |= SerialPort::Dcd;
-
-    DWORD bytesReturned = 0;
-    if (::DeviceIoControl(m_descriptor, IOCTL_SERIAL_GET_DTRRTS, 0, 0,
-                          &modemStat, sizeof(bytesReturned),
-                          &bytesReturned, 0)) {
-
-        if (modemStat & SERIAL_DTR_STATE)
-            ret |= SerialPort::Dtr;
-        if (modemStat & SERIAL_RTS_STATE)
-            ret |= SerialPort::Rts;
-    }
-
-    return ret;
-}
-
-/*!
-    Set DTR signal to state \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::setDtr(bool set)
-{
-    return ::EscapeCommFunction(m_descriptor, set ? SETDTR : CLRDTR);
-}
-
-/*!
-    Set RTS signal to state \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::setRts(bool set)
-{
-    return ::EscapeCommFunction(m_descriptor, set ? SETRTS : CLRRTS);
-}
-
-/*!
-    Flushes the serial port's buffers and causes all buffered data to be written
-    to the serial port.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::flush()
-{
-    return ::FlushFileBuffers(m_descriptor);
-}
-
-/*!
-    Discards all characters from the serial port's output or input buffer.
-    This can also terminate pending read or write operations.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::reset()
-{
-    const DWORD flags = PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR;
-    return ::PurgeComm(m_descriptor, flags);
-}
-
-/*!
-    Sends a continuous stream of zero bits during a specified
-    period of time \a duration in msec.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::sendBreak(int duration)
-{
-    // FIXME:
-    if (setBreak(true)) {
-        ::Sleep(duration);
-        if (setBreak(false))
-            return true;
-    }
-    return false;
-}
-
-/*!
-    Restores or suspend character transmission and places the
-    transmission line in a nonbreak or break state,
-    depending on the parameter \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::setBreak(bool set)
-{
-    if (set)
-        return ::SetCommBreak(m_descriptor);
-    return ::ClearCommBreak(m_descriptor);
-}
-
-/*!
-    Returns the number of bytes received by the serial provider
-    but not yet read by a read() operation. Also clears the
-    device's error flag to enable additional input and output
-    (I/O) operations.
-
-    If successful, returns true; otherwise returns false.
-*/
-qint64 WinSerialPortEngine::bytesAvailable() const
-{
-    COMSTAT cs;
-    ::memset(&cs, 0, sizeof(cs));
-    if (::ClearCommError(m_descriptor, 0, &cs) == 0)
-        return -1;
-    return cs.cbInQue;
-}
-
-/*!
-    Returns the number of bytes of user data remaining to be
-    transmitted for all write operations. This value will be zero
-    for a nonoverlapped write (for embedded platform as WinCE).
-    Also clears the device's error flag to enable additional
-    input and output (I/O) operations.
-
-    If successful, returns true; otherwise returns false.
-*/
-qint64 WinSerialPortEngine::bytesToWrite() const
-{
-    COMSTAT cs;
-    ::memset(&cs, 0, sizeof(cs));
-    if (::ClearCommError(m_descriptor, 0, &cs) == 0)
-        return -1;
-    return cs.cbOutQue;
-}
-
-// Clear overlapped structure, but does not affect the event.
-static void clear_overlapped(OVERLAPPED *overlapped)
-{
-    overlapped->Internal = 0;
-    overlapped->InternalHigh = 0;
-    overlapped->Offset = 0;
-    overlapped->OffsetHigh = 0;
-}
-
-/*!
-    Reads at most \a len bytes from the serial port into \a data, and returns
-    the number of bytes read. If an error occurs, this function returns -1
-    and sets an error code. This function returns immediately.
-
-    Also, this method processed the policy of operating with the
-    received symbol, in which the parity or frame error is detected.
-    This analysis and processing is executed by software-way in
-    this method. Parity or frame error flag determines subsystem
-    notification when it receives an event type EV_ERR. Since the
-    EV_ERR event appears before the event EV_RXCHAR, therefore,
-    we are able to handle errors by ordered, for each bad charachter
-    in this read method. This is true only when enabled the internal
-    read buffer of class SerialPort, ie when it is automatically
-    filled when the notification mode of reading is enabled. In
-    other cases, policy processing bad char is not guaranteed.
-*/
-qint64 WinSerialPortEngine::read(char *data, qint64 len)
-{
-    clear_overlapped(&m_readOverlapped);
-
-    DWORD readBytes = 0;
-    bool sucessResult = false;
-
-    // FIXME:
-    if (dptr->options.policy != SerialPort::IgnorePolicy)
-        len = 1;
-
-    if (::ReadFile(m_descriptor, data, len, &readBytes, &m_readOverlapped)) {
-        sucessResult = true;
-    } else if (::GetLastError() == ERROR_IO_PENDING
-             // Here have to wait for completion of pending transactions
-             // to get the number of actually readed bytes.
-             && ::GetOverlappedResult(m_descriptor, &m_readOverlapped, &readBytes, true)) {
-        sucessResult = true;
-    }
-
-    if (!sucessResult)
-        return -1;
-
-    // FIXME: Process emulate policy.
-    if (m_flagErrorFromCommEvent) {
-        m_flagErrorFromCommEvent = false;
-
-        switch (dptr->options.policy) {
-        case SerialPort::SkipPolicy:
-            return 0;
-        case SerialPort::PassZeroPolicy:
-            *data = '\0';
-            break;
-        case SerialPort::StopReceivingPolicy:
-            break;
-        default:
-            break;
-        }
-    }
-    return readBytes;
-}
-
-/*!
-    Writes at most \a len bytes of data from \a data to the serial port.
-    If successful, returns the number of bytes that were actually written;
-    otherwise returns -1 and sets an error code.
-*/
-qint64 WinSerialPortEngine::write(const char *data, qint64 len)
-{
-    clear_overlapped(&m_writeOverlapped);
-
-    DWORD writeBytes = 0;
-    bool sucessResult = false;
-
-    if (::WriteFile(m_descriptor, data, len, &writeBytes, &m_writeOverlapped)) {
-        sucessResult = true;
-    } else if (::GetLastError() == ERROR_IO_PENDING) {
-        // This is not an error. In this case, the number of bytes actually
-        // transmitted can be received only after the completion of pending
-        // transactions, but it will freeze the event loop. The solution is
-        // to fake return results without waiting. Such a maneuver is possible
-        // due to the peculiarities of the serial port driver for Windows.
-        sucessResult = true;
-        writeBytes = len;
-    }
-
-    if (!sucessResult)
-        return -1;
-
-    return writeBytes;
-}
-
-/*!
-    Implements a function blocking for waiting of events EV_RXCHAR or
-    EV_TXEMPTY, on the \a timeout in millisecond. Event EV_RXCHAR
-    controlled, if the flag \a checkRead is set on true, and
-    EV_TXEMPTY wehn flag \a checkWrite is set on true. The result
-    of catch in each of the events, save to the corresponding
-    variables \a selectForRead and \a selectForWrite.
-
-    For NT-based OS and Windows CE, this method have different
-    implementation. WinCE has no mechanism to exit out of a timeout,
-    therefore for this feature special class is used
-    WinCeWaitCommEventBreaker, without which it is locked to wait
-    forever in the absence of events EV_RXCHAR or EV_TXEMPTY. For
-    satisfactory operation of the breaker, the timeout should be
-    guaranteed a great, to the timer in the breaker does not trip
-    happen sooner than a function call WaitCommEvent(); otherwise it
-    will block forever (in the absence of events EV_RXCHAR or EV_TXEMPTY).
-
-    Returns true if the occurrence of any event before the timeout;
-    otherwise returns false.
-*/
-bool WinSerialPortEngine::select(int timeout,
-                                 bool checkRead, bool checkWrite,
-                                 bool *selectForRead, bool *selectForWrite)
-{
-    // FIXME: Forward checking available data for read.
-    // This is a bad decision, because call bytesAvailable() automatically
-    // clears the error parity, frame, etc. That is, then in the future,
-    // it is impossible to identify them in the process of reading the data.
-    if (checkRead && (bytesAvailable() > 0)) {
-        Q_ASSERT(selectForRead);
-        *selectForRead = true;
-        return true;
-    }
-
-    clear_overlapped(&m_selectOverlapped);
-
-    DWORD oldEventMask = 0;
-    DWORD currEventMask = 0;
-
-    if (checkRead)
-        currEventMask |= EV_RXCHAR;
-    if (checkWrite)
-        currEventMask |= EV_TXEMPTY;
-
-    // Save old mask.
-    if (::GetCommMask(m_descriptor, &oldEventMask) == 0)
-        return false;
-
-    // Checking the old mask bits as in the current mask.
-    // And if these bits are not exists, then add them and set the reting mask.
-    if (currEventMask != (oldEventMask & currEventMask)) {
-        currEventMask |= oldEventMask;
-        if (::SetCommMask(m_descriptor, currEventMask) == 0)
-            return false;
-    }
-
-    currEventMask = 0;
-    bool sucessResult = false;
-
-    if (::WaitCommEvent(m_descriptor, &currEventMask, &m_selectOverlapped)) {
-        sucessResult = true;
-    } else if (::GetLastError() == ERROR_IO_PENDING) {
-        DWORD bytesTransferred = 0;
-        if (::WaitForSingleObject(m_selectOverlapped.hEvent, qMax(timeout, 0)) == WAIT_OBJECT_0
-                && ::GetOverlappedResult(m_descriptor, &m_selectOverlapped, &bytesTransferred, false)) {
-            sucessResult = true;
-        } else {
-            // Here there was a timeout or other error.
-        }
-    }
-
-    if (sucessResult) {
-        // FIXME: Here call the bytesAvailable() to protect against false positives
-        // WaitForSingleObject(), for example, when manually pulling USB/Serial
-        // converter from system, ie when devices are in fact not.
-        // While it may be possible to make additional checks - to catch an event EV_ERR,
-        // adding (in the code above) extra bits in the mask currEventMask.
-        if (checkRead) {
-            Q_ASSERT(selectForRead);
-            *selectForRead = (currEventMask & EV_RXCHAR) && bytesAvailable() > 0;
-        }
-        if (checkWrite) {
-            Q_ASSERT(selectForWrite);
-            *selectForWrite =  currEventMask & EV_TXEMPTY;
-        }
-    }
-
-    // Rerair old mask.
-    ::SetCommMask(m_descriptor, oldEventMask);
-    return sucessResult;
-}
-
-/*!
-    Sets the desired baud \a rate for the given direction \a dir.
-    As Windows does not support separate directions, the only valid value for
-    \dir is SerialPort::AllDirections.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
-{
-    if (dir != SerialPort::AllDirections) {
-        dptr->setError(SerialPort::UnsupportedPortOperationError);
-        return false;
-    }
-    m_currentDcb.BaudRate = rate;
-    return updateDcb();
-}
-
-/*!
-    Sets the desired number of data bits \a dataBits in a frame. Windows
-    supports all present number of data bits 5, 6, 7, and 8.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
-{
-    m_currentDcb.ByteSize = dataBits;
-    return updateDcb();
-}
-
-/*!
-    Sets the desired \a parity control mode. Windows supports
-    all present parity types: no parity, space, mark, even, and odd parity.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinSerialPortEngine::setParity(SerialPort::Parity parity)
-{
-    m_currentDcb.fParity = true;
-    switch (parity) {
-    case SerialPort::NoParity:
-        m_currentDcb.Parity = NOPARITY;
-        m_currentDcb.fParity = false;
-        break;
-    case SerialPort::OddParity:
-        m_currentDcb.Parity = ODDPARITY;
-        break;
-    case SerialPort::EvenParity:
-        m_currentDcb.Parity = EVENPARITY;
-        break;
-    case SerialPort::MarkParity:
-        m_currentDcb.Parity = MARKPARITY;
-        break;
-    case SerialPort::SpaceParity:
-        m_currentDcb.Parity = SPACEPARITY;
-        break;
-    default:
-        m_currentDcb.Parity = NOPARITY;
-        m_currentDcb.fParity = false;
-        break;
-    }
-    return updateDcb();
-}
-
-/*!
-    Sets the desired number of stop bits \a stopBits in a frame.
-    Windows supports 1, 1.5, or 2 stop bits.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
-{
-    switch (stopBits) {
-    case SerialPort::OneStop:
-        m_currentDcb.StopBits = ONESTOPBIT;
-        break;
-    case SerialPort::OneAndHalfStop:
-        m_currentDcb.StopBits = ONE5STOPBITS;
-        break;
-    case SerialPort::TwoStop:
-        m_currentDcb.StopBits = TWOSTOPBITS;
-        break;
-    default:
-        m_currentDcb.StopBits = ONESTOPBIT;
-        break;
-    }
-    return updateDcb();
-}
-
-/*!
-    Set desired \a flow control mode. Windows native supported all
-    present flow control modes: no control, hardware (RTS/CTS),
-    and software (XON/XOFF).
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
-{
-    m_currentDcb.fInX = false;
-    m_currentDcb.fOutX = false;
-    m_currentDcb.fOutxCtsFlow = false;
-    m_currentDcb.fRtsControl = RTS_CONTROL_DISABLE;
-    switch (flow) {
-    case SerialPort::NoFlowControl:
-        break;
-    case SerialPort::SoftwareControl:
-        m_currentDcb.fInX = true;
-        m_currentDcb.fOutX = true;
-        break;
-    case SerialPort::HardwareControl:
-        m_currentDcb.fOutxCtsFlow = true;
-        m_currentDcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
-        break;
-    default:
-        break;
-    }
-    return updateDcb();
-}
-
-/*!
-    Empty stub. Setting a variable is carried out methods in a
-    private class SerialPortPrivate.
-*/
-bool WinSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
-{
-    Q_UNUSED(policy)
-    return true;
-}
-
-/*!
-    Returns the current read notification subsystem status.
-*/
-bool WinSerialPortEngine::isReadNotificationEnabled() const
-{
-    return isNotificationEnabled(EV_RXCHAR);
-}
-
-/*!
-    Enables or disables the read notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of the event EV_RXCHAR.
-    Thereby, SerialPort can emit the signal readyRead() and automatically
-    fill the internal receive buffer with new data, that was received from
-    the serial port in the event loop.
-*/
-void WinSerialPortEngine::setReadNotificationEnabled(bool enable)
-{
-    setNotificationEnabled(enable, EV_RXCHAR);
-}
-
-/*!
-    Returns the current write notification subsystem status.
-*/
-bool WinSerialPortEngine::isWriteNotificationEnabled() const
-{
-    return isNotificationEnabled(EV_TXEMPTY);
-}
-
-/*!
-    Enables or disables the write notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of the event EV_TXEMPTY.
-    Thereby, SerialPort can automatically write data from the
-    internal transfer buffer to the serial port in the event loop.
-*/
-void WinSerialPortEngine::setWriteNotificationEnabled(bool enable)
-{
-    setNotificationEnabled(enable, EV_TXEMPTY);
-
-    // This only for OS Windows, as EV_TXEMPTY event is triggered only
-    // after the last byte of data.
-    // Therefore, we are forced to run writeNotification(), as EV_TXEMPTY does not work.
-    if (enable)
-        dptr->canWriteNotification();
-}
-
-/*!
-    Returns the current error notification subsystem status.
-*/
-bool WinSerialPortEngine::isErrorNotificationEnabled() const
-{
-    return isNotificationEnabled(EV_ERR);
-}
-
-/*!
-    Enables or disables the error notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of an event EV_ERR.
-*/
-void WinSerialPortEngine::setErrorNotificationEnabled(bool enable)
-{
-    setNotificationEnabled(enable, EV_ERR);
-}
-
-/*!
-    Defines the type of parity or frame error when an event EV_ERR occurs.
-
-    This method is automatically called from the error handler in the
-    parent class SerialPortPrivate, which is called by the error notification
-    subsystem when an event EV_ERR occurs.
-*/
-bool WinSerialPortEngine::processIOErrors()
-{
-    DWORD err = 0;
-    const bool ret = ::ClearCommError(m_descriptor, &err, 0) != 0;
-    if (ret && err) {
-        if (err & CE_FRAME)
-            dptr->setError(SerialPort::FramingError);
-        else if (err & CE_RXPARITY)
-            dptr->setError(SerialPort::ParityError);
-        else if (err & CE_BREAK)
-            dptr->setError(SerialPort::BreakConditionError);
-        else
-            dptr->setError(SerialPort::UnknownPortError);
-
-        m_flagErrorFromCommEvent = true;
-    }
-    return ret;
-}
-
-/* Protected methods */
-
-/*!
-    Attempts to determine the current serial port settings,
-    when the port is opened. Used only in the method open().
-*/
-void WinSerialPortEngine::detectDefaultSettings()
-{
-    // Detect rate.
-    dptr->options.inputRate = quint32(m_currentDcb.BaudRate);
-    dptr->options.outputRate = dptr->options.inputRate;
-
-    // Detect databits.
-    switch (m_currentDcb.ByteSize) {
-    case 5:
-        dptr->options.dataBits = SerialPort::Data5;
-        break;
-    case 6:
-        dptr->options.dataBits = SerialPort::Data6;
-        break;
-    case 7:
-        dptr->options.dataBits = SerialPort::Data7;
-        break;
-    case 8:
-        dptr->options.dataBits = SerialPort::Data8;
-        break;
-    default:
-        dptr->options.dataBits = SerialPort::UnknownDataBits;
-        break;
-    }
-
-    // Detect parity.
-    if ((m_currentDcb.Parity == NOPARITY) && !m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::NoParity;
-    else if ((m_currentDcb.Parity == SPACEPARITY) && m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::SpaceParity;
-    else if ((m_currentDcb.Parity == MARKPARITY) && m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::MarkParity;
-    else if ((m_currentDcb.Parity == EVENPARITY) && m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::EvenParity;
-    else if ((m_currentDcb.Parity == ODDPARITY) && m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::OddParity;
-    else
-        dptr->options.parity = SerialPort::UnknownParity;
-
-    // Detect stopbits.
-    switch (m_currentDcb.StopBits) {
-    case ONESTOPBIT:
-        dptr->options.stopBits = SerialPort::OneStop;
-        break;
-    case ONE5STOPBITS:
-        dptr->options.stopBits = SerialPort::OneAndHalfStop;
-        break;
-    case TWOSTOPBITS:
-        dptr->options.stopBits = SerialPort::TwoStop;
-        break;
-    default:
-        dptr->options.stopBits = SerialPort::UnknownStopBits;
-        break;
-    }
-
-    // Detect flow control.
-    if (!m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
-            && !m_currentDcb.fInX && !m_currentDcb.fOutX) {
-        dptr->options.flow = SerialPort::NoFlowControl;
-    } else if (!m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
-               && m_currentDcb.fInX && m_currentDcb.fOutX) {
-        dptr->options.flow = SerialPort::SoftwareControl;
-    } else if (m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_HANDSHAKE)
-               && !m_currentDcb.fInX && !m_currentDcb.fOutX) {
-        dptr->options.flow = SerialPort::HardwareControl;
-    } else
-        dptr->options.flow = SerialPort::UnknownFlowControl;
-}
-
-/*!
-    Converts the platform-depend code of system error to the
-    corresponding value a SerialPort::PortError.
-*/
-SerialPort::PortError WinSerialPortEngine::decodeSystemError() const
-{
-    SerialPort::PortError error;
-    switch (::GetLastError()) {
-    case ERROR_FILE_NOT_FOUND:
-        error = SerialPort::NoSuchDeviceError;
-        break;
-    case ERROR_ACCESS_DENIED:
-        error = SerialPort::PermissionDeniedError;
-        break;
-    case ERROR_INVALID_HANDLE:
-        error = SerialPort::DeviceIsNotOpenedError;
-        break;
-    case ERROR_INVALID_PARAMETER:
-        error = SerialPort::UnsupportedPortOperationError;
-        break;
-    default:
-        error = SerialPort::UnknownPortError;
-        break;
-    }
-    return error;
-}
-
-/*!
-    Windows NT-based event loop for the notification subsystem.
-    The serial port events EV_ERR, EV_RXCHAR, and EV_TXEMPTY are tracked
-    asynchronously in the event loop. When a relevant event occurs, the
-    appropriate handler from the parent class SerialPortPrivate is called.
-*/
-bool WinSerialPortEngine::event(QEvent *e)
-{
-    bool ret = false;
-    if (e->type() == QEvent::WinEventAct) {
-        if (EV_ERR & m_currentMask & m_desiredMask) {
-            dptr->canErrorNotification();
-            ret = true;
-        }
-        if (EV_RXCHAR & m_currentMask & m_desiredMask) {
-            dptr->canReadNotification();
-            ret = true;
-        }
-        //FIXME: This is why it does not work?
-        if (EV_TXEMPTY & m_currentMask & m_desiredMask) {
-            dptr->canWriteNotification();
-            ret = true;
-        }
-    } else {
-        ret = QWinEventNotifier::event(e);
-    }
-
-    ::WaitCommEvent(m_descriptor, &m_currentMask, &m_notifyOverlapped);
-    return ret;
-}
-
-/*!
-    For Windows NT-based OS, creates event handles for OVERLAPPED
-    structures, that are used in the reading method (if \a rx is true),
-    writing method (if \a tx is true), and waiting for data from the serial port.
-    This method is only used in the method open().
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::createEvents(bool rx, bool tx)
-{
-    if (rx) {
-        m_readOverlapped.hEvent = ::CreateEvent(0, false, false, 0);
-        Q_ASSERT(m_readOverlapped.hEvent);
-    }
-    if (tx) {
-        m_writeOverlapped.hEvent = ::CreateEvent(0, false, false, 0);
-        Q_ASSERT(m_writeOverlapped.hEvent);
-    }
-    m_selectOverlapped.hEvent = ::CreateEvent(0, false, false, 0);
-    Q_ASSERT(m_selectOverlapped.hEvent);
-    m_notifyOverlapped.hEvent = ::CreateEvent(0, false, false, 0);
-    Q_ASSERT(m_notifyOverlapped.hEvent);
-
-    setHandle(m_notifyOverlapped.hEvent);
-    return true;
-}
-
-/*!
-    For Windows NT-based OS, releases and closes event handles for
-    OVERLAPPED structures.
-*/
-void WinSerialPortEngine::closeEvents()
-{
-    if (m_readOverlapped.hEvent)
-        ::CloseHandle(m_readOverlapped.hEvent);
-    if (m_writeOverlapped.hEvent)
-        ::CloseHandle(m_writeOverlapped.hEvent);
-    if (m_selectOverlapped.hEvent)
-        ::CloseHandle(m_selectOverlapped.hEvent);
-    if (m_notifyOverlapped.hEvent)
-        ::CloseHandle(m_notifyOverlapped.hEvent);
-
-    ::memset(&m_readOverlapped, 0, sizeof(m_readOverlapped));
-    ::memset(&m_writeOverlapped, 0, sizeof(m_writeOverlapped));
-    ::memset(&m_selectOverlapped, 0, sizeof(m_selectOverlapped));
-    ::memset(&m_notifyOverlapped, 0, sizeof(m_notifyOverlapped));
-}
-
-/*!
-*/
-bool WinSerialPortEngine::isNotificationEnabled(DWORD mask) const
-{
-    bool enabled = isEnabled();
-    return enabled && (m_desiredMask & mask);
-}
-
-/*!
-*/
-void WinSerialPortEngine::setNotificationEnabled(bool enable, DWORD mask)
-{
-    // Mask only the desired bits without affecting others.
-    if (enable)
-        m_desiredMask |= mask;
-    else
-        m_desiredMask &= ~mask;
-
-    ::SetCommMask(m_descriptor, m_desiredMask);
-
-    enable = isEnabled();
-
-    // If the desired mask is zero then no needed to restart
-    // the monitoring events and needed disable notification;
-    // otherwise needed start the notification if it was stopped.
-    if (m_desiredMask) {
-        ::WaitCommEvent(m_descriptor, &m_currentMask, &m_notifyOverlapped);
-        if (!enable)
-            setEnabled(true);
-    } else if (enable) {
-        setEnabled(false);
-    }
-}
-
-/*!
-    Updates the DCB structure when changing any serial port parameter.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::updateDcb()
-{
-    if (::SetCommState(m_descriptor, &m_currentDcb) == 0) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    return true;
-}
-
-/*!
-    Updates the COMMTIMEOUTS structure when changing any serial port
-    timeout parameter.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinSerialPortEngine::updateCommTimeouts()
-{
-    if (::SetCommTimeouts(m_descriptor, &m_currentCommTimeouts) == 0) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    return true;
-}
-
-// From <serialportengine_p.h>
-SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
-{
-    return new WinSerialPortEngine(d);
-}
-
-/* Public static the SerialPortPrivate methods */
-
-static const QLatin1String defaultPathPrefix("\\\\.\\");
-
-/*!
-    Converts a platform specific \a port name to a system location
-    and returns the value.
-*/
-QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
-{
-    QString ret = port;
-    if (!ret.contains(defaultPathPrefix))
-        ret.prepend(defaultPathPrefix);
-    return ret;
-}
-
-/*!
-    Converts a platform specific system \a location to a port name
-    and returns the value.
-*/
-QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
-{
-    QString ret = location;
-    if (ret.contains(defaultPathPrefix))
-        ret.remove(defaultPathPrefix);
-    return ret;
-}
-
-// This table contains standard values of baud rates that
-// are defined in MSDN and/or in Win SDK file winbase.h
-static
-const qint32 standardRatesTable[] =
-{
-    #ifdef CBR_110
-    CBR_110,
-    #endif
-    #ifdef CBR_300
-    CBR_300,
-    #endif
-    #ifdef CBR_600
-    CBR_600,
-    #endif
-    #ifdef CBR_1200
-    CBR_1200,
-    #endif
-    #ifdef CBR_2400
-    CBR_2400,
-    #endif
-    #ifdef CBR_4800
-    CBR_4800,
-    #endif
-    #ifdef CBR_9600
-    CBR_9600,
-    #endif
-    #ifdef CBR_14400
-    CBR_14400,
-    #endif
-    #ifdef CBR_19200
-    CBR_19200,
-    #endif
-    #ifdef CBR_38400
-    CBR_38400,
-    #endif
-    #ifdef CBR_56000
-    CBR_56000,
-    #endif
-    #ifdef CBR_57600
-    CBR_57600,
-    #endif
-    #ifdef CBR_115200
-    CBR_115200,
-    #endif
-    #ifdef CBR_128000
-    CBR_128000,
-    #endif
-    #ifdef CBR_256000
-    CBR_256000
-    #endif
-};
-
-static const qint32 *standardRatesTable_end =
-        standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
-
-/*!
-    Converts the windows-specific baud rate code \a setting to a numeric value.
-    If the desired item is not found, returns 0.
-*/
-qint32 SerialPortPrivate::rateFromSetting(qint32 setting)
-{
-    const qint32 *ret = qFind(standardRatesTable, standardRatesTable_end, setting);
-    return ret != standardRatesTable_end ? *ret : 0;
-}
-
-/*!
-    Converts a numeric baud \a rate value to the windows-specific code.
-    If the desired item is not found, returns 0.
-*/
-qint32 SerialPortPrivate::settingFromRate(qint32 rate)
-{
-    const qint32 *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rate);
-    return ret != standardRatesTable_end ? *ret : 0;
-}
-
-/*!
-   Returns a list of standard baud rates that
-   are defined in MSDN and/or in Win SDK file winbase.h.
-*/
-QList<qint32> SerialPortPrivate::standardRates()
-{
-   QList<qint32> l;
-   for (const qint32 *it = standardRatesTable; it != standardRatesTable_end; ++it)
-      l.append(*it);
-   return l;
-}
-
-#include "moc_serialportengine_win_p.cpp"
-
-QT_END_NAMESPACE_SERIALPORT
-
diff --git a/src/serialportengine_win_p.h b/src/serialportengine_win_p.h
deleted file mode 100755
index 7451390..0000000
--- a/src/serialportengine_win_p.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
-** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef SERIALPORTENGINE_WIN_P_H
-#define SERIALPORTENGINE_WIN_P_H
-
-#include "serialport.h"
-#include "serialportengine_p.h"
-
-#include <qt_windows.h>
-#if (QT_VERSION >= QT_VERSION_CHECK(5, 0, 0))
-#include <QtCore/qwineventnotifier.h>
-#else
-#include "qt4support/qwineventnotifier_p.h"
-#endif
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-class WinSerialPortEngine : public QWinEventNotifier, public SerialPortEngine
-{
-    Q_OBJECT
-public:
-    WinSerialPortEngine(SerialPortPrivate *d);
-    virtual ~WinSerialPortEngine();
-
-    virtual bool open(const QString &location, QIODevice::OpenMode mode);
-    virtual void close(const QString &location);
-
-    virtual SerialPort::Lines lines() const;
-
-    virtual bool setDtr(bool set);
-    virtual bool setRts(bool set);
-
-    virtual bool flush();
-    virtual bool reset();
-
-    virtual bool sendBreak(int duration);
-    virtual bool setBreak(bool set);
-
-    virtual qint64 bytesAvailable() const;
-    virtual qint64 bytesToWrite() const;
-
-    virtual qint64 read(char *data, qint64 len);
-    virtual qint64 write(const char *data, qint64 len);
-    virtual bool select(int timeout,
-                        bool checkRead, bool checkWrite,
-                        bool *selectForRead, bool *selectForWrite);
-
-    virtual bool setRate(qint32 rate, SerialPort::Directions dir);
-    virtual bool setDataBits(SerialPort::DataBits dataBits);
-    virtual bool setParity(SerialPort::Parity parity);
-    virtual bool setStopBits(SerialPort::StopBits stopBits);
-    virtual bool setFlowControl(SerialPort::FlowControl flowControl);
-
-    virtual bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy);
-
-    virtual bool isReadNotificationEnabled() const;
-    virtual void setReadNotificationEnabled(bool enable);
-    virtual bool isWriteNotificationEnabled() const;
-    virtual void setWriteNotificationEnabled(bool enable);
-    virtual bool isErrorNotificationEnabled() const;
-    virtual void setErrorNotificationEnabled(bool enable);
-
-    virtual bool processIOErrors();
-
-protected:
-    virtual void detectDefaultSettings();
-    virtual SerialPort::PortError decodeSystemError() const;
-    virtual bool event(QEvent *e);
-
-private:
-    bool createEvents(bool rx, bool tx);
-    void closeEvents();
-
-    bool isNotificationEnabled(DWORD mask) const;
-    void setNotificationEnabled(bool enable, DWORD mask);
-
-    bool updateDcb();
-    bool updateCommTimeouts();
-
-private:
-    DCB m_currentDcb;
-    DCB m_restoredDcb;
-    COMMTIMEOUTS m_currentCommTimeouts;
-    COMMTIMEOUTS m_restoredCommTimeouts;
-    HANDLE m_descriptor;
-    bool m_flagErrorFromCommEvent;
-    DWORD m_currentMask;
-    DWORD m_desiredMask;
-
-    OVERLAPPED m_readOverlapped;
-    OVERLAPPED m_writeOverlapped;
-    OVERLAPPED m_selectOverlapped;
-    OVERLAPPED m_notifyOverlapped;
-};
-
-QT_END_NAMESPACE_SERIALPORT
-
-#endif // SERIALPORTENGINE_WIN_P_H
diff --git a/src/serialportengine_wince.cpp b/src/serialportengine_wince.cpp
deleted file mode 100644
index 673b1fa..0000000
--- a/src/serialportengine_wince.cpp
+++ /dev/null
@@ -1,1133 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
-** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
-** Copyright (C) 2012 Andre Hartmann <aha_1980@gmx.de>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/*!
-    \class WinCESerialPortEngine
-    \internal
-
-    \brief The WinCESerialPortEngine class provides WindowsCE OS
-    platform-specific low level access to a serial port.
-
-    \reentrant
-    \ingroup serialport-main
-    \inmodule QtSerialPort
-
-    Currently the class supports various versionf of embedded Windows CE.
-
-    WinCESerialPortEngine (as well as other platform-dependent engines)
-    is a class with multiple inheritance, which on the one hand,
-    derives from a general abstract class interface SerialPortEngine,
-    on the other hand from QObject.
-
-    From the abstract class SerialPortEngine, this class inherits all virtual
-    interface methods that are common to all serial ports on any platform.
-    The class WinCESerialPortEngine implements these methods using the
-    Windows CE API.
-
-    For Windows CE systems WinCESerialPortEngine is derived
-    from QThread and creates an additional thread to track the events.
-*/
-
-#include "serialportengine_wince_p.h"
-
-#include <QtCore/qregexp.h>
-
-#ifndef CTL_CODE
-#  define CTL_CODE(DeviceType, Function, Method, Access) ( \
-    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
-    )
-#endif
-
-#ifndef FILE_DEVICE_SERIAL_PORT
-#  define FILE_DEVICE_SERIAL_PORT  27
-#endif
-
-#ifndef METHOD_BUFFERED
-#  define METHOD_BUFFERED  0
-#endif
-
-#ifndef FILE_ANY_ACCESS
-#  define FILE_ANY_ACCESS  0x00000000
-#endif
-
-#ifndef IOCTL_SERIAL_GET_DTRRTS
-#  define IOCTL_SERIAL_GET_DTRRTS \
-    CTL_CODE(FILE_DEVICE_SERIAL_PORT, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#endif
-
-#ifndef SERIAL_DTR_STATE
-#  define SERIAL_DTR_STATE  0x00000001
-#endif
-
-#ifndef SERIAL_RTS_STATE
-#  define SERIAL_RTS_STATE  0x00000002
-#endif
-
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-/*!
-    Constructs a WinCESerialPortEngine and initializes all internal variables
-    to their initial values. The pointer \a d to the private object of class
-    SerialPortPrivate is used to call some common methods.
-*/
-WinCESerialPortEngine::WinCESerialPortEngine(SerialPortPrivate *d)
-    : m_descriptor(INVALID_HANDLE_VALUE)
-    , m_flagErrorFromCommEvent(false)
-    , m_currentMask(0)
-    , m_desiredMask(0)
-    , m_running(true)
-{
-    Q_ASSERT(d);
-    dptr = d;
-    ::memset(&m_currentDcb, 0, sizeof(m_currentDcb));
-    ::memset(&m_restoredDcb, 0, sizeof(m_restoredDcb));
-    ::memset(&m_currentCommTimeouts, 0, sizeof(m_currentCommTimeouts));
-    ::memset(&m_restoredCommTimeouts, 0, sizeof(m_restoredCommTimeouts));
-}
-
-/*!
-    Stops the serial port event tracking and destructs a WinCESerialPortEngine.
-*/
-WinCESerialPortEngine::~WinCESerialPortEngine()
-{
-    m_running = false;
-    ::SetCommMask(m_descriptor, 0);
-    //terminate();
-    wait();
-}
-
-/*!
-    Attempts to open the desired serial port by \a location in the given open
-    \a mode. In the process of discovery, always sets the serial port in
-    non-blocking mode (where the read operation returns immediately) and tries
-    to determine and install the current configuration to the serial port.
-
-    It should be noted, that Windows has the following limitations when using
-    the serial port:
-    - support only binary transfers mode
-    - always open in exclusive mode
-
-    For Windows NT-based platforms, the serial port is opened in the overlapped
-    mode, with the flag FILE_FLAG_OVERLAPPED.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinCESerialPortEngine::open(const QString &location, QIODevice::OpenMode mode)
-{
-    DWORD desiredAccess = 0;
-    DWORD shareMode = 0;
-    DWORD flagsAndAttributes = 0;
-    bool rxflag = false;
-    bool txflag = false;
-
-    if (mode & QIODevice::ReadOnly) {
-        desiredAccess |= GENERIC_READ;
-        //shareMode = FILE_SHARE_READ;
-        rxflag = true;
-    }
-    if (mode & QIODevice::WriteOnly) {
-        desiredAccess |= GENERIC_WRITE;
-        //shareMode = FILE_SHARE_WRITE;
-        txflag = true;
-    }
-
-    // Try opened serial device.
-    m_descriptor = ::CreateFile(reinterpret_cast<const wchar_t*>(location.utf16()),
-                                desiredAccess, shareMode, 0, OPEN_EXISTING, flagsAndAttributes, 0);
-
-    if (m_descriptor == INVALID_HANDLE_VALUE) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-
-    // Save current DCB port settings.
-    if (::GetCommState(m_descriptor, &m_restoredDcb) == 0) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    m_currentDcb = m_restoredDcb;
-
-    // Set other DCB port options.
-    m_currentDcb.fBinary = true;
-    m_currentDcb.fInX = false;
-    m_currentDcb.fOutX = false;
-    m_currentDcb.fAbortOnError = false;
-    m_currentDcb.fNull = false;
-    m_currentDcb.fErrorChar = false;
-
-    // Apply new DCB init settings.
-    if (!updateDcb())
-        return false;
-
-    // Save current port timeouts.
-    if (::GetCommTimeouts(m_descriptor, &m_restoredCommTimeouts) == 0) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    m_currentCommTimeouts = m_restoredCommTimeouts;
-
-    // Set new port timeouts.
-    ::memset(&m_currentCommTimeouts, 0, sizeof(m_currentCommTimeouts));
-    m_currentCommTimeouts.ReadIntervalTimeout = MAXDWORD;
-
-    // Apply new port timeouts.
-    if (!updateCommTimeouts())
-        return false;
-
-    detectDefaultSettings();
-    return true;
-}
-
-/*!
-    Closes a serial port. Before closing, restores the previous serial port
-    settings if necessary.
-*/
-void WinCESerialPortEngine::close(const QString &location)
-{
-    Q_UNUSED(location);
-
-    if (dptr->options.restoreSettingsOnClose) {
-        ::SetCommState(m_descriptor, &m_restoredDcb);
-        ::SetCommTimeouts(m_descriptor, &m_restoredCommTimeouts);
-    }
-
-    ::CloseHandle(m_descriptor);
-
-    m_descriptor = INVALID_HANDLE_VALUE;
-}
-
-/*!
-    Returns a bitmap state of the RS-232 line signals. On error,
-    the bitmap will be empty (equal zero).
-
-    The Windows API only provides the state of the following signals:
-    CTS, DSR, RING, DCD, DTR, and RTS. Other signals are not available.
-*/
-SerialPort::Lines WinCESerialPortEngine::lines() const
-{
-    DWORD modemStat = 0;
-    SerialPort::Lines ret = 0;
-
-    if (::GetCommModemStatus(m_descriptor, &modemStat) == 0)
-        return ret;
-
-    if (modemStat & MS_CTS_ON)
-        ret |= SerialPort::Cts;
-    if (modemStat & MS_DSR_ON)
-        ret |= SerialPort::Dsr;
-    if (modemStat & MS_RING_ON)
-        ret |= SerialPort::Ri;
-    if (modemStat & MS_RLSD_ON)
-        ret |= SerialPort::Dcd;
-
-    DWORD bytesReturned = 0;
-    if (::DeviceIoControl(m_descriptor, IOCTL_SERIAL_GET_DTRRTS, 0, 0,
-                          &modemStat, sizeof(bytesReturned),
-                          &bytesReturned, 0)) {
-
-        if (modemStat & SERIAL_DTR_STATE)
-            ret |= SerialPort::Dtr;
-        if (modemStat & SERIAL_RTS_STATE)
-            ret |= SerialPort::Rts;
-    }
-
-    return ret;
-}
-
-/*!
-    Set DTR signal to state \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinCESerialPortEngine::setDtr(bool set)
-{
-    return ::EscapeCommFunction(m_descriptor, set ? SETDTR : CLRDTR);
-}
-
-/*!
-    Set RTS signal to state \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinCESerialPortEngine::setRts(bool set)
-{
-    return ::EscapeCommFunction(m_descriptor, set ? SETRTS : CLRRTS);
-}
-
-/*!
-    Flushes the serial port's buffers and causes all buffered data to be written
-    to the serial port.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinCESerialPortEngine::flush()
-{
-    return ::FlushFileBuffers(m_descriptor);
-}
-
-/*!
-    Discards all characters from the serial port's output or input buffer.
-    This can also terminate pending read or write operations.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinCESerialPortEngine::reset()
-{
-    const DWORD flags = PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR;
-    return ::PurgeComm(m_descriptor, flags);
-}
-
-/*!
-    Sends a continuous stream of zero bits during a specified
-    period of time \a duration in msec.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinCESerialPortEngine::sendBreak(int duration)
-{
-    // FIXME:
-    if (setBreak(true)) {
-        ::Sleep(duration);
-        if (setBreak(false))
-            return true;
-    }
-    return false;
-}
-
-/*!
-    Restores or suspend character transmission and places the
-    transmission line in a nonbreak or break state,
-    depending on the parameter \a set.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinCESerialPortEngine::setBreak(bool set)
-{
-    if (set)
-        return ::SetCommBreak(m_descriptor);
-    return ::ClearCommBreak(m_descriptor);
-}
-
-/*!
-    Returns the number of bytes received by the serial provider
-    but not yet read by a read() operation. Also clears the
-    device's error flag to enable additional input and output
-    (I/O) operations.
-
-    If successful, returns true; otherwise returns false.
-*/
-qint64 WinCESerialPortEngine::bytesAvailable() const
-{
-    COMSTAT cs;
-    ::memset(&cs, 0, sizeof(cs));
-    if (::ClearCommError(m_descriptor, 0, &cs) == 0)
-        return -1;
-    return cs.cbInQue;
-}
-
-/*!
-    Returns the number of bytes of user data remaining to be
-    transmitted for all write operations. This value will be zero
-    for a nonoverlapped write (for embedded platform as WinCE).
-    Also clears the device's error flag to enable additional
-    input and output (I/O) operations.
-
-    If successful, returns true; otherwise returns false.
-*/
-qint64 WinCESerialPortEngine::bytesToWrite() const
-{
-    COMSTAT cs;
-    ::memset(&cs, 0, sizeof(cs));
-    if (::ClearCommError(m_descriptor, 0, &cs) == 0)
-        return -1;
-    return cs.cbOutQue;
-}
-
-/*!
-    Reads at most \a len bytes from the serial port into \a data, and returns
-    the number of bytes read. If an error occurs, this function returns -1
-    and sets an error code. This function returns immediately.
-
-    Also, this method processed the policy of operating with the
-    received symbol, in which the parity or frame error is detected.
-    This analysis and processing is executed by software-way in
-    this method. Parity or frame error flag determines subsystem
-    notification when it receives an event type EV_ERR. Since the
-    EV_ERR event appears before the event EV_RXCHAR, therefore,
-    we are able to handle errors by ordered, for each bad charachter
-    in this read method. This is true only when enabled the internal
-    read buffer of class SerialPort, ie when it is automatically
-    filled when the notification mode of reading is enabled. In
-    other cases, policy processing bad char is not guaranteed.
-*/
-qint64 WinCESerialPortEngine::read(char *data, qint64 len)
-{
-    DWORD readBytes = 0;
-    bool sucessResult = false;
-
-    // FIXME:
-    if (dptr->options.policy != SerialPort::IgnorePolicy)
-        len = 1;
-
-    sucessResult = ::ReadFile(m_descriptor, data, len, &readBytes, 0);
-    if (!sucessResult)
-        return -1;
-
-    // FIXME: Process emulate policy.
-    if (m_flagErrorFromCommEvent) {
-        m_flagErrorFromCommEvent = false;
-
-        switch (dptr->options.policy) {
-        case SerialPort::SkipPolicy:
-            return 0;
-        case SerialPort::PassZeroPolicy:
-            *data = '\0';
-            break;
-        case SerialPort::StopReceivingPolicy:
-            break;
-        default:
-            break;
-        }
-    }
-    return readBytes;
-}
-
-/*!
-    Writes at most \a len bytes of data from \a data to the serial port.
-    If successful, returns the number of bytes that were actually written;
-    otherwise returns -1 and sets an error code.
-*/
-qint64 WinCESerialPortEngine::write(const char *data, qint64 len)
-{
-    DWORD writeBytes = 0;
-    bool sucessResult = false;
-
-    sucessResult = ::WriteFile(m_descriptor, data, len, &writeBytes, 0);
-    if (!sucessResult)
-        return -1;
-
-    return writeBytes;
-}
-
-/*!
-    Implements a function blocking for waiting of events EV_RXCHAR or
-    EV_TXEMPTY, on the \a timeout in millisecond. Event EV_RXCHAR
-    controlled, if the flag \a checkRead is set on true, and
-    EV_TXEMPTY wehn flag \a checkWrite is set on true. The result
-    of catch in each of the events, save to the corresponding
-    variables \a selectForRead and \a selectForWrite.
-
-    For NT-based OS and Windows CE, this method have different
-    implementation. WinCE has no mechanism to exit out of a timeout,
-    therefore for this feature special class is used
-    WinCeWaitCommEventBreaker, without which it is locked to wait
-    forever in the absence of events EV_RXCHAR or EV_TXEMPTY. For
-    satisfactory operation of the breaker, the timeout should be
-    guaranteed a great, to the timer in the breaker does not trip
-    happen sooner than a function call WaitCommEvent(); otherwise it
-    will block forever (in the absence of events EV_RXCHAR or EV_TXEMPTY).
-
-    Returns true if the occurrence of any event before the timeout;
-    otherwise returns false.
-*/
-bool WinCESerialPortEngine::select(int timeout,
-                                 bool checkRead, bool checkWrite,
-                                 bool *selectForRead, bool *selectForWrite)
-{
-    // FIXME: Forward checking available data for read.
-    // This is a bad decision, because call bytesAvailable() automatically
-    // clears the error parity, frame, etc. That is, then in the future,
-    // it is impossible to identify them in the process of reading the data.
-    if (checkRead && (bytesAvailable() > 0)) {
-        Q_ASSERT(selectForRead);
-        *selectForRead = true;
-        return true;
-    }
-
-    DWORD oldEventMask = 0;
-    DWORD currEventMask = 0;
-
-    if (checkRead)
-        currEventMask |= EV_RXCHAR;
-    if (checkWrite)
-        currEventMask |= EV_TXEMPTY;
-
-    // Save old mask.
-    if (::GetCommMask(m_descriptor, &oldEventMask) == 0)
-        return false;
-
-    // Checking the old mask bits as in the current mask.
-    // And if these bits are not exists, then add them and set the reting mask.
-    if (currEventMask != (oldEventMask & currEventMask)) {
-        currEventMask |= oldEventMask;
-        if (::SetCommMask(m_descriptor, currEventMask) == 0)
-            return false;
-    }
-
-    currEventMask = 0;
-    bool sucessResult = false;
-
-    // FIXME: Here the situation is not properly handled with zero timeout:
-    // breaker can work out before you call a method WaitCommEvent()
-    // and so it will loop forever!
-    WinCeWaitCommEventBreaker breaker(m_descriptor, qMax(timeout, 0));
-    ::WaitCommEvent(m_descriptor, &currEventMask, 0);
-    breaker.stop();
-    sucessResult = !breaker.isWorked();
-
-    if (sucessResult) {
-        // FIXME: Here call the bytesAvailable() to protect against false positives
-        // WaitForSingleObject(), for example, when manually pulling USB/Serial
-        // converter from system, ie when devices are in fact not.
-        // While it may be possible to make additional checks - to catch an event EV_ERR,
-        // adding (in the code above) extra bits in the mask currEventMask.
-        if (checkRead) {
-            Q_ASSERT(selectForRead);
-            *selectForRead = (currEventMask & EV_RXCHAR) && bytesAvailable() > 0;
-        }
-        if (checkWrite) {
-            Q_ASSERT(selectForWrite);
-            *selectForWrite =  currEventMask & EV_TXEMPTY;
-        }
-    }
-
-    // Rerair old mask.
-    ::SetCommMask(m_descriptor, oldEventMask);
-    return sucessResult;
-}
-
-/*!
-    Sets the desired baud \a rate for the given direction \a dir.
-    As Windows does not support separate directions, the only valid value for
-    \dir is SerialPort::AllDirections.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinCESerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
-{
-    if (dir != SerialPort::AllDirections) {
-        dptr->setError(SerialPort::UnsupportedPortOperationError);
-        return false;
-    }
-    m_currentDcb.BaudRate = rate;
-    return updateDcb();
-}
-
-/*!
-    Sets the desired number of data bits \a dataBits in a frame. Windows
-    supports all present number of data bits 5, 6, 7, and 8.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinCESerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
-{
-    m_currentDcb.ByteSize = dataBits;
-    return updateDcb();
-}
-
-/*!
-    Sets the desired \a parity control mode. Windows supports
-    all present parity types: no parity, space, mark, even, and odd parity.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinCESerialPortEngine::setParity(SerialPort::Parity parity)
-{
-    m_currentDcb.fParity = true;
-    switch (parity) {
-    case SerialPort::NoParity:
-        m_currentDcb.Parity = NOPARITY;
-        m_currentDcb.fParity = false;
-        break;
-    case SerialPort::OddParity:
-        m_currentDcb.Parity = ODDPARITY;
-        break;
-    case SerialPort::EvenParity:
-        m_currentDcb.Parity = EVENPARITY;
-        break;
-    case SerialPort::MarkParity:
-        m_currentDcb.Parity = MARKPARITY;
-        break;
-    case SerialPort::SpaceParity:
-        m_currentDcb.Parity = SPACEPARITY;
-        break;
-    default:
-        m_currentDcb.Parity = NOPARITY;
-        m_currentDcb.fParity = false;
-        break;
-    }
-    return updateDcb();
-}
-
-/*!
-    Sets the desired number of stop bits \a stopBits in a frame.
-    Windows supports 1, 1.5, or 2 stop bits.
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinCESerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
-{
-    switch (stopBits) {
-    case SerialPort::OneStop:
-        m_currentDcb.StopBits = ONESTOPBIT;
-        break;
-    case SerialPort::OneAndHalfStop:
-        m_currentDcb.StopBits = ONE5STOPBITS;
-        break;
-    case SerialPort::TwoStop:
-        m_currentDcb.StopBits = TWOSTOPBITS;
-        break;
-    default:
-        m_currentDcb.StopBits = ONESTOPBIT;
-        break;
-    }
-    return updateDcb();
-}
-
-/*!
-    Set desired \a flow control mode. Windows native supported all
-    present flow control modes: no control, hardware (RTS/CTS),
-    and software (XON/XOFF).
-
-    If successful, returns true; otherwise returns false and sets an
-    error code.
-*/
-bool WinCESerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
-{
-    m_currentDcb.fInX = false;
-    m_currentDcb.fOutX = false;
-    m_currentDcb.fOutxCtsFlow = false;
-    m_currentDcb.fRtsControl = RTS_CONTROL_DISABLE;
-    switch (flow) {
-    case SerialPort::NoFlowControl:
-        break;
-    case SerialPort::SoftwareControl:
-        m_currentDcb.fInX = true;
-        m_currentDcb.fOutX = true;
-        break;
-    case SerialPort::HardwareControl:
-        m_currentDcb.fOutxCtsFlow = true;
-        m_currentDcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
-        break;
-    default:
-        break;
-    }
-    return updateDcb();
-}
-
-/*!
-    Empty stub. Setting a variable is carried out methods in a
-    private class SerialPortPrivate.
-*/
-bool WinCESerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
-{
-    Q_UNUSED(policy)
-    return true;
-}
-
-/*!
-    Returns the current read notification subsystem status.
-*/
-bool WinCESerialPortEngine::isReadNotificationEnabled() const
-{
-    return isNotificationEnabled(EV_RXCHAR);
-}
-
-/*!
-    Enables or disables the read notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of the event EV_RXCHAR.
-    Thereby, SerialPort can emit the signal readyRead() and automatically
-    fill the internal receive buffer with new data, that was received from
-    the serial port in the event loop.
-*/
-void WinCESerialPortEngine::setReadNotificationEnabled(bool enable)
-{
-    setNotificationEnabled(enable, EV_RXCHAR);
-}
-
-/*!
-    Returns the current write notification subsystem status.
-*/
-bool WinCESerialPortEngine::isWriteNotificationEnabled() const
-{
-    return isNotificationEnabled(EV_TXEMPTY);
-}
-
-/*!
-    Enables or disables the write notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of the event EV_TXEMPTY.
-    Thereby, SerialPort can automatically write data from the
-    internal transfer buffer to the serial port in the event loop.
-*/
-void WinCESerialPortEngine::setWriteNotificationEnabled(bool enable)
-{
-    setNotificationEnabled(enable, EV_TXEMPTY);
-
-    // This only for OS Windows, as EV_TXEMPTY event is triggered only
-    // after the last byte of data.
-    // Therefore, we are forced to run writeNotification(), as EV_TXEMPTY does not work.
-    if (enable)
-        dptr->canWriteNotification();
-}
-
-/*!
-    Returns the current error notification subsystem status.
-*/
-bool WinCESerialPortEngine::isErrorNotificationEnabled() const
-{
-    return isNotificationEnabled(EV_ERR);
-}
-
-/*!
-    Enables or disables the error notification subsystem, depending on
-    the \a enable parameter. The enabled subsystem will asynchronously
-    track the occurrence of an event EV_ERR.
-*/
-void WinCESerialPortEngine::setErrorNotificationEnabled(bool enable)
-{
-    setNotificationEnabled(enable, EV_ERR);
-}
-
-/*!
-    Defines the type of parity or frame error when an event EV_ERR occurs.
-
-    This method is automatically called from the error handler in the
-    parent class SerialPortPrivate, which is called by the error notification
-    subsystem when an event EV_ERR occurs.
-*/
-bool WinCESerialPortEngine::processIOErrors()
-{
-    DWORD err = 0;
-    const bool ret = ::ClearCommError(m_descriptor, &err, 0) != 0;
-    if (ret && err) {
-        if (err & CE_FRAME)
-            dptr->setError(SerialPort::FramingError);
-        else if (err & CE_RXPARITY)
-            dptr->setError(SerialPort::ParityError);
-        else if (err & CE_BREAK)
-            dptr->setError(SerialPort::BreakConditionError);
-        else
-            dptr->setError(SerialPort::UnknownPortError);
-
-        m_flagErrorFromCommEvent = true;
-    }
-    return ret;
-}
-
-void WinCESerialPortEngine::lockNotification(NotificationLockerType type, bool uselocker)
-{
-    QMutex *mutex = 0;
-    switch (type) {
-    case CanReadLocker:
-        mutex = &m_readNotificationMutex;
-        break;
-    case CanWriteLocker:
-        mutex = &m_writeNotificationMutex;
-        break;
-    case CanErrorLocker:
-        mutex = &m_errorNotificationMutex;
-        break;
-    default:
-        break;
-    }
-
-    if (uselocker)
-        QMutexLocker locker(mutex);
-    else
-        mutex->lock();
-}
-
-void WinCESerialPortEngine::unlockNotification(NotificationLockerType type)
-{
-    switch (type) {
-    case CanReadLocker:
-        m_readNotificationMutex.unlock();
-        break;
-    case CanWriteLocker:
-        m_writeNotificationMutex.unlock();
-        break;
-    case CanErrorLocker:
-        m_errorNotificationMutex.unlock();
-        break;
-    default:
-        break;
-    }
-}
-
-/* Protected methods */
-
-/*!
-    Attempts to determine the current serial port settings,
-    when the port is opened. Used only in the method open().
-*/
-void WinCESerialPortEngine::detectDefaultSettings()
-{
-    // Detect rate.
-    dptr->options.inputRate = quint32(m_currentDcb.BaudRate);
-    dptr->options.outputRate = dptr->options.inputRate;
-
-    // Detect databits.
-    switch (m_currentDcb.ByteSize) {
-    case 5:
-        dptr->options.dataBits = SerialPort::Data5;
-        break;
-    case 6:
-        dptr->options.dataBits = SerialPort::Data6;
-        break;
-    case 7:
-        dptr->options.dataBits = SerialPort::Data7;
-        break;
-    case 8:
-        dptr->options.dataBits = SerialPort::Data8;
-        break;
-    default:
-        dptr->options.dataBits = SerialPort::UnknownDataBits;
-        break;
-    }
-
-    // Detect parity.
-    if ((m_currentDcb.Parity == NOPARITY) && !m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::NoParity;
-    else if ((m_currentDcb.Parity == SPACEPARITY) && m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::SpaceParity;
-    else if ((m_currentDcb.Parity == MARKPARITY) && m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::MarkParity;
-    else if ((m_currentDcb.Parity == EVENPARITY) && m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::EvenParity;
-    else if ((m_currentDcb.Parity == ODDPARITY) && m_currentDcb.fParity)
-        dptr->options.parity = SerialPort::OddParity;
-    else
-        dptr->options.parity = SerialPort::UnknownParity;
-
-    // Detect stopbits.
-    switch (m_currentDcb.StopBits) {
-    case ONESTOPBIT:
-        dptr->options.stopBits = SerialPort::OneStop;
-        break;
-    case ONE5STOPBITS:
-        dptr->options.stopBits = SerialPort::OneAndHalfStop;
-        break;
-    case TWOSTOPBITS:
-        dptr->options.stopBits = SerialPort::TwoStop;
-        break;
-    default:
-        dptr->options.stopBits = SerialPort::UnknownStopBits;
-        break;
-    }
-
-    // Detect flow control.
-    if (!m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
-            && !m_currentDcb.fInX && !m_currentDcb.fOutX) {
-        dptr->options.flow = SerialPort::NoFlowControl;
-    } else if (!m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
-               && m_currentDcb.fInX && m_currentDcb.fOutX) {
-        dptr->options.flow = SerialPort::SoftwareControl;
-    } else if (m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_HANDSHAKE)
-               && !m_currentDcb.fInX && !m_currentDcb.fOutX) {
-        dptr->options.flow = SerialPort::HardwareControl;
-    } else
-        dptr->options.flow = SerialPort::UnknownFlowControl;
-}
-
-/*!
-    Converts the platform-depend code of system error to the
-    corresponding value a SerialPort::PortError.
-*/
-SerialPort::PortError WinCESerialPortEngine::decodeSystemError() const
-{
-    SerialPort::PortError error;
-    switch (::GetLastError()) {
-    case ERROR_FILE_NOT_FOUND:
-        error = SerialPort::NoSuchDeviceError;
-        break;
-    case ERROR_ACCESS_DENIED:
-        error = SerialPort::PermissionDeniedError;
-        break;
-    case ERROR_INVALID_HANDLE:
-        error = SerialPort::DeviceIsNotOpenedError;
-        break;
-    case ERROR_INVALID_PARAMETER:
-        error = SerialPort::UnsupportedPortOperationError;
-        break;
-    default:
-        error = SerialPort::UnknownPortError;
-        break;
-    }
-    return error;
-}
-
-/*!
-    Embedded-based (WinCE) event loop for the notification subsystem.
-    The serial port events EV_ERR, EV_RXCHAR, and EV_TXEMPTY are tracked
-    in a separate thread. When a relevant event occurs, the appropriate
-    handler from the parent class SerialPortPrivate is called.
-    At the same time in handlers to capture/release the mutex
-    (see handlers implementation).
-*/
-void WinCESerialPortEngine::run()
-{
-    while (m_running) {
-
-        m_setCommMaskMutex.lock();
-        ::SetCommMask(m_descriptor, m_desiredMask);
-        m_setCommMaskMutex.unlock();
-
-        if (::WaitCommEvent(m_descriptor, &m_currentMask, 0) != 0) {
-
-            // Wait until complete the operation changes the port settings,
-            // see updateDcb().
-            m_settingsChangeMutex.lock();
-            m_settingsChangeMutex.unlock();
-
-            if (EV_ERR & m_currentMask & m_desiredMask) {
-                dptr->canErrorNotification();
-            }
-            if (EV_RXCHAR & m_currentMask & m_desiredMask) {
-                dptr->canReadNotification();
-            }
-            //FIXME: This is why it does not work?
-            if (EV_TXEMPTY & m_currentMask & m_desiredMask) {
-                dptr->canWriteNotification();
-            }
-        }
-    }
-}
-
-/*!
-*/
-bool WinCESerialPortEngine::isNotificationEnabled(DWORD mask) const
-{
-    bool enabled = isRunning();
-    return enabled && (m_desiredMask & mask);
-}
-
-/*!
-*/
-void WinCESerialPortEngine::setNotificationEnabled(bool enable, DWORD mask)
-{
-    m_setCommMaskMutex.lock();
-    ::GetCommMask(m_descriptor, &m_currentMask);
-
-    // Mask only the desired bits without affecting others.
-    if (enable)
-        m_desiredMask |= mask;
-    else
-        m_desiredMask &= ~mask;
-
-    ::SetCommMask(m_descriptor, m_desiredMask);
-
-    m_setCommMaskMutex.unlock();
-
-    if (enable && !isRunning())
-        start();
-}
-
-/*!
-    Updates the DCB structure when changing any serial port parameter.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinCESerialPortEngine::updateDcb()
-{
-    // Grab a mutex, in order after exit WaitCommEvent
-    // block the flow of run() notifier until there is a change DCB.
-    QMutexLocker locker(&m_settingsChangeMutex);
-    // This way, we reset in class WaitCommEvent to
-    // be able to change the DCB.
-    // Otherwise WaitCommEvent blocking any change!
-    ::SetCommMask(m_descriptor, 0);
-    if (::SetCommState(m_descriptor, &m_currentDcb) == 0) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    return true;
-}
-
-/*!
-    Updates the COMMTIMEOUTS structure when changing any serial port
-    timeout parameter.
-
-    If successful, returns true; otherwise returns false.
-*/
-bool WinCESerialPortEngine::updateCommTimeouts()
-{
-    if (::SetCommTimeouts(m_descriptor, &m_currentCommTimeouts) == 0) {
-        dptr->setError(decodeSystemError());
-        return false;
-    }
-    return true;
-}
-
-// From <serialportengine_p.h>
-SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
-{
-    return new WinCESerialPortEngine(d);
-}
-
-/* Public static the SerialPortPrivate methods */
-
-static const QLatin1String defaultPathPostfix(":");
-
-/*!
-    Converts a platform specific \a port name to a system location
-    and returns the value.
-*/
-QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
-{
-    QString ret = port;
-    if (!ret.contains(defaultPathPostfix))
-        ret.append(defaultPathPostfix);
-    return ret;
-}
-
-/*!
-    Converts a platform specific system \a location to a port name
-    and returns the value.
-*/
-QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
-{
-    QString ret = location;
-    if (ret.contains(defaultPathPostfix))
-        ret.remove(defaultPathPostfix);
-    return ret;
-}
-
-// This table contains standard values of baud rates that
-// are defined in MSDN and/or in Win SDK file winbase.h
-static
-const qint32 standardRatesTable[] =
-{
-    #ifdef CBR_110
-    CBR_110,
-    #endif
-    #ifdef CBR_300
-    CBR_300,
-    #endif
-    #ifdef CBR_600
-    CBR_600,
-    #endif
-    #ifdef CBR_1200
-    CBR_1200,
-    #endif
-    #ifdef CBR_2400
-    CBR_2400,
-    #endif
-    #ifdef CBR_4800
-    CBR_4800,
-    #endif
-    #ifdef CBR_9600
-    CBR_9600,
-    #endif
-    #ifdef CBR_14400
-    CBR_14400,
-    #endif
-    #ifdef CBR_19200
-    CBR_19200,
-    #endif
-    #ifdef CBR_38400
-    CBR_38400,
-    #endif
-    #ifdef CBR_56000
-    CBR_56000,
-    #endif
-    #ifdef CBR_57600
-    CBR_57600,
-    #endif
-    #ifdef CBR_115200
-    CBR_115200,
-    #endif
-    #ifdef CBR_128000
-    CBR_128000,
-    #endif
-    #ifdef CBR_256000
-    CBR_256000
-    #endif
-};
-
-static const qint32 *standardRatesTable_end =
-        standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
-
-/*!
-    Converts the windows-specific baud rate code \a setting to a numeric value.
-    If the desired item is not found, returns 0.
-*/
-qint32 SerialPortPrivate::rateFromSetting(qint32 setting)
-{
-    const qint32 *ret = qFind(standardRatesTable, standardRatesTable_end, setting);
-    return ret != standardRatesTable_end ? *ret : 0;
-}
-
-/*!
-    Converts a numeric baud \a rate value to the windows-specific code.
-    If the desired item is not found, returns 0.
-*/
-qint32 SerialPortPrivate::settingFromRate(qint32 rate)
-{
-    const qint32 *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rate);
-    return ret != standardRatesTable_end ? *ret : 0;
-}
-
-/*!
-   Returns a list of standard baud rates that
-   are defined in MSDN and/or in Win SDK file winbase.h.
-*/
-QList<qint32> SerialPortPrivate::standardRates()
-{
-   QList<qint32> l;
-   for (const qint32 *it = standardRatesTable; it != standardRatesTable_end; ++it)
-      l.append(*it);
-   return l;
-}
-
-#include "moc_serialportengine_wince_p.cpp"
-
-QT_END_NAMESPACE_SERIALPORT
-
diff --git a/src/serialportengine_wince_p.h b/src/serialportengine_wince_p.h
deleted file mode 100644
index 23eba83..0000000
--- a/src/serialportengine_wince_p.h
+++ /dev/null
@@ -1,181 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
-** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtSerialPort module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef SERIALPORTENGINE_WINCE_P_H
-#define SERIALPORTENGINE_WINCE_P_H
-
-#include "serialport.h"
-#include "serialportengine_p.h"
-
-#include <qt_windows.h>
-#include <QtCore/qmutex.h>
-#include <QtCore/qthread.h>
-#include <QtCore/qtimer.h>
-
-
-QT_BEGIN_NAMESPACE_SERIALPORT
-
-class WinCEWaitCommEventBreaker : public QThread
-{
-    Q_OBJECT
-public:
-    WinCEWaitCommEventBreaker(HANDLE descriptor, int timeout, QObject *parent = 0)
-        : QThread(parent)
-        , m_descriptor(descriptor)
-        , m_timeout(timeout)
-        , m_worked(false) {
-        start();
-    }
-    virtual ~WinCEWaitCommEventBreaker() {
-        stop();
-        wait();
-    }
-    void stop() { exit(0); }
-    bool isWorked() const { return m_worked; }
-
-protected:
-    void run() {
-        QTimer timer;
-        QObject::connect(&timer, SIGNAL(timeout()), this, SLOT(procTimeout()), Qt::DirectConnection);
-        timer.start(m_timeout);
-        exec();
-        m_worked = true;
-    }
-
-private slots:
-    void procTimeout() {
-        ::SetCommMask(m_descriptor, 0);
-        stop();
-    }
-
-private:
-    HANDLE m_descriptor;
-    int m_timeout;
-    volatile bool m_worked;
-};
-
-class WinCESerialPortEngine : public QThread, public SerialPortEngine
-{
-    Q_OBJECT
-public:
-    WinCESerialPortEngine(SerialPortPrivate *d);
-    virtual ~WinCESerialPortEngine();
-
-    virtual bool open(const QString &location, QIODevice::OpenMode mode);
-    virtual void close(const QString &location);
-
-    virtual SerialPort::Lines lines() const;
-
-    virtual bool setDtr(bool set);
-    virtual bool setRts(bool set);
-
-    virtual bool flush();
-    virtual bool reset();
-
-    virtual bool sendBreak(int duration);
-    virtual bool setBreak(bool set);
-
-    virtual qint64 bytesAvailable() const;
-    virtual qint64 bytesToWrite() const;
-
-    virtual qint64 read(char *data, qint64 len);
-    virtual qint64 write(const char *data, qint64 len);
-    virtual bool select(int timeout,
-                        bool checkRead, bool checkWrite,
-                        bool *selectForRead, bool *selectForWrite);
-
-    virtual bool setRate(qint32 rate, SerialPort::Directions dir);
-    virtual bool setDataBits(SerialPort::DataBits dataBits);
-    virtual bool setParity(SerialPort::Parity parity);
-    virtual bool setStopBits(SerialPort::StopBits stopBits);
-    virtual bool setFlowControl(SerialPort::FlowControl flowControl);
-
-    virtual bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy);
-
-    virtual bool isReadNotificationEnabled() const;
-    virtual void setReadNotificationEnabled(bool enable);
-    virtual bool isWriteNotificationEnabled() const;
-    virtual void setWriteNotificationEnabled(bool enable);
-    virtual bool isErrorNotificationEnabled() const;
-    virtual void setErrorNotificationEnabled(bool enable);
-
-    virtual bool processIOErrors();
-
-    // FIXME
-    virtual void lockNotification(NotificationLockerType type, bool uselocker);
-    virtual void unlockNotification(NotificationLockerType type);
-
-protected:
-    virtual void detectDefaultSettings();
-    virtual SerialPort::PortError decodeSystemError() const;
-
-    virtual void run();
-
-private:
-
-    bool isNotificationEnabled(DWORD mask) const;
-    void setNotificationEnabled(bool enable, DWORD mask);
-
-    bool updateDcb();
-    bool updateCommTimeouts();
-
-private:
-    DCB m_currentDcb;
-    DCB m_restoredDcb;
-    COMMTIMEOUTS m_currentCommTimeouts;
-    COMMTIMEOUTS m_restoredCommTimeouts;
-    HANDLE m_descriptor;
-    bool m_flagErrorFromCommEvent;
-    DWORD m_currentMask;
-    DWORD m_desiredMask;
-
-    QMutex m_readNotificationMutex;
-    QMutex m_writeNotificationMutex;
-    QMutex m_errorNotificationMutex;
-    QMutex m_settingsChangeMutex;
-    QMutex m_setCommMaskMutex;
-    volatile bool m_running;
-};
-
-QT_END_NAMESPACE_SERIALPORT
-
-#endif // SERIALPORTENGINE_WINCE_P_H
diff --git a/src/serialportinfo_symbian.cpp b/src/serialportinfo_symbian.cpp
index c2f3fcc..057c760 100755
--- a/src/serialportinfo_symbian.cpp
+++ b/src/serialportinfo_symbian.cpp
@@ -43,7 +43,7 @@
 
 #include "serialportinfo.h"
 #include "serialportinfo_p.h"
-#include "serialportengine_symbian_p.h"
+#include "serialport_symbian_p.h"
 
 #include <e32base.h>
 //#include <e32test.h>
diff --git a/src/serialportinfo_unix.cpp b/src/serialportinfo_unix.cpp
index 5ab2bce..56d453f 100755
--- a/src/serialportinfo_unix.cpp
+++ b/src/serialportinfo_unix.cpp
@@ -44,7 +44,7 @@
 #include "serialportinfo.h"
 #include "serialportinfo_p.h"
 #include "ttylocker_unix_p.h"
-#include "serialportengine_unix_p.h"
+#include "serialport_unix_p.h"
 #include <QtCore/qfile.h>
 
 #ifndef Q_OS_MAC
diff --git a/src/serialportinfo_win.cpp b/src/serialportinfo_win.cpp
index 5df25ec..82dfb9a 100755
--- a/src/serialportinfo_win.cpp
+++ b/src/serialportinfo_win.cpp
@@ -43,12 +43,15 @@
 
 #include "serialportinfo.h"
 #include "serialportinfo_p.h"
-#include "serialportengine_win_p.h"
+#include "serialport_win_p.h"
 
 #include <qt_windows.h>
+
+#ifndef Q_OS_WINCE
 #include <objbase.h>
 #include <initguid.h>
 #include <setupapi.h>
+#endif
 
 #include <QtCore/qvariant.h>
 #include <QtCore/qstringlist.h>
diff --git a/src/serialportinfo_wince.cpp b/src/serialportinfo_wince.cpp
index 00ce6e1..e0d1fae 100644
--- a/src/serialportinfo_wince.cpp
+++ b/src/serialportinfo_wince.cpp
@@ -43,6 +43,7 @@
 
 #include "serialportinfo.h"
 #include "serialportinfo_p.h"
+#include "serialport_win_p.h"
 
 #include <qt_windows.h>
 
diff --git a/src/src-lib.pri b/src/src-lib.pri
index 73fc5ba..87bb7f6 100644
--- a/src/src-lib.pri
+++ b/src/src-lib.pri
@@ -13,7 +13,6 @@ PUBLIC_HEADERS += \
 
 PRIVATE_HEADERS += \
     $$PWD/serialport_p.h \
-    $$PWD/serialportengine_p.h \
     $$PWD/serialportinfo_p.h
 
 SOURCES += \
@@ -21,22 +20,18 @@ SOURCES += \
     $$PWD/serialportinfo.cpp
 
 win32 {
-    SOURCES += $$PWD/serialportinfo_win.cpp
-
-    !wince*: {
-        PRIVATE_HEADERS += \
-            $$PWD/serialportengine_win_p.h
+    PRIVATE_HEADERS += \
+        $$PWD/serialport_win_p.h
 
-        SOURCES += \
-            $$PWD/serialportengine_win.cpp
+    SOURCES += \
+        $$PWD/serialport_win.cpp \
+        $$PWD/serialportinfo_win.cpp
 
+    !wince*: {
         LIBS += -lsetupapi -luuid -ladvapi32
     } else {
-        PRIVATE_HEADERS += \
-            $$PWD/serialportengine_wince_p.h
-
         SOURCES += \
-            $$PWD/serialportengine_wince.cpp \
+            $$PWD/serialport_wince.cpp \
             $$PWD/serialportinfo_wince.cpp
     }
 }
@@ -56,24 +51,28 @@ symbian {
     INCLUDEPATH += c:/QtSDK/Symbian/SDKs/Symbian3Qt473/epoc32/include/platform
 
     PRIVATE_HEADERS += \
-        $$PWD/serialportengine_symbian_p.h
+        $$PWD/serialport_symbian_p.h
+
     SOURCES += \
-        $$PWD/serialportengine_symbian.cpp \
+        $$PWD/serialport_symbian.cpp \
         $$PWD/serialportinfo_symbian.cpp
+
     LIBS += -leuser -lefsrv -lc32
 }
 
 unix:!symbian {
     PRIVATE_HEADERS += \
         $$PWD/ttylocker_unix_p.h \
-        $$PWD/serialportengine_unix_p.h
+        $$PWD/serialport_unix_p.h
+
     SOURCES += \
         $$PWD/ttylocker_unix.cpp \
-        $$PWD/serialportengine_unix.cpp \
+        $$PWD/serialport_unix.cpp \
         $$PWD/serialportinfo_unix.cpp
 
     macx {
         SOURCES += $$PWD/serialportinfo_mac.cpp
+
         LIBS += -framework IOKit -framework CoreFoundation
     } else {
         linux*:contains( DEFINES, HAVE_LIBUDEV ) {