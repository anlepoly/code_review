diff --git a/src/3rdparty/libpng/ANNOUNCE b/src/3rdparty/libpng/ANNOUNCE
index 4a3b018..dbc2ed1 100644
--- a/src/3rdparty/libpng/ANNOUNCE
+++ b/src/3rdparty/libpng/ANNOUNCE
@@ -1,5 +1,5 @@
 
-Libpng 1.5.1 - February 3, 2011
+Libpng 1.5.10 - March 29, 2012
 
 This is a public release of libpng, intended for use in production codes.
 
@@ -8,89 +8,57 @@ Files available for download:
 Source files with LF line endings (for Unix/Linux) and with a
 "configure" script
 
-   libpng-1.5.1.tar.xz (LZMA-compressed, recommended)
-   libpng-1.5.1.tar.gz
-   libpng-1.5.1.tar.bz2
+   libpng-1.5.10.tar.xz (LZMA-compressed, recommended)
+   libpng-1.5.10.tar.gz
+   libpng-1.5.10.tar.bz2
 
 Source files with CRLF line endings (for Windows), without the
 "configure" script
 
-   lpng151.7z  (LZMA-compressed, recommended)
-   lpng151.zip
+   lpng1510.7z  (LZMA-compressed, recommended)
+   lpng1510.zip
 
 Other information:
 
-   libpng-1.5.1-README.txt
-   libpng-1.5.1-LICENSE.txt
+   libpng-1.5.10-README.txt
+   libpng-1.5.10-LICENSE.txt
 
-Changes since the last public release (1.5.0):
+Changes since the last public release (1.5.9):
 
-  Added description of png_set_crc_action() to the manual.
-  Added a note in the manual that the type of the iCCP profile was changed
-    from png_charpp to png_bytepp in png_get_iCCP().  Similarly,
-    it was changed from png_charpp to png_const_bytepp in png_set_iCCP().
-  Ensure that png_rgb_to_gray ignores palette mapped images, if libpng
-    internally happens to call it with one.
-  Fixed the failure to handle palette mapped images correctly.
-  Fixed a bug in handling of interlaced images (bero at arklinux.org).
-  Updated CMakeLists.txt (Clifford Yapp)
-  Fixed typecasting of some png_debug() statements (Cosmin)
-  Updated documentation of png_set|get_tRNS() (Thomas Klausner).
-  Mentioned in the documentation that applications must #include "zlib.h"
-    if they need access to anything in zlib.h, and that a number of
-    macros such as png_memset() are no longer accessible by applications.
-  Corrected pngvalid gamma test "sample" function to access all of the color
-    samples of each pixel, instead of sampling the red channel three times.
-  Changed variable names index, div, exp, and gamma to char_index, divisor,
-    exp_b10, and gamma_val, respectively, to avoid "shadow" warnings.
-  Prevent png_push_crc_skip() from hanging while reading an unknown chunk
-    or an over-large compressed zTXt chunk with the progressive reader.
-  Eliminated more GCC "shadow" warnings.
-  Revised png_fixed() in png.c to avoid compiler warning about reaching the
-    end without returning anything.
-  In the manual, describe the png_get_IHDR() arguments in the correct order.
-  Added const_png_structp and const_png_infop types, and used them in
-    prototypes for most png_get_*() functions.
-  Added png_get_io_chunk_type() and deprecated png_get_io_chunk_name()
-  Added synopses for the IO_STATE functions and other missing synopses
-    to the manual. Removed the synopses from libpngpf.3 because they
-    were out of date and no longer useful.  Better information can be
-    obtained by reading the prototypes and comments in pngpriv.h
-  Attempted to fix cpp on Solaris with S. Studio 12 cc, fix build
-    Added a make macro DFNCPP that is a CPP that will accept the tokens in
-    a .dfn file and adds configure stuff to test for such a CPP.  ./configure
-    should fail if one is not available.
-  Corrected const_png_ in png.h to png_const_ to avoid polluting the namespace.
-  Added png_get_current_row_number and png_get_current_pass_number for the
-    benefit of the user transform callback.
-  Added png_process_data_pause and png_process_data_skip for the benefit of
-    progressive readers that need to stop data processing or want to optimize
-    skipping of unread data (e.g. if the reader marks a chunk to be skipped.)
-  Enhanced pngvalid, corrected an error in gray_to_rgb, corrected doc error.
-    pngvalid contains tests of transforms, which tests are currently disabled
-    because they are incompletely tested.  gray_to_rgb was failing to expand
-    the bit depth for smaller bit depth images; this seems to be a long
-    standing error and resulted, apparently, in invalid output.  The
-    documentation did not accurately describe what libpng really does when
-    converting RGB to gray.
-  Fixed incorrect examples of callback prototypes in the manual, that were
-    introduced in libpng-1.0.0.
-  In addition the order of the png_get_uint macros with respect to the
-    relevant function definitions has been reversed.  This helps the
-    preprocessing of the symbol files be more robust.  Furthermore, the
-    symbol file preprocessing now uses -DPNG_NO_USE_READ_MACROS even when
-    the library may actually be built with PNG_USE_READ_MACROS; this stops
-    the read macros interfering with the symbol file format.
-  Made the manual, synopses, and function prototypes use the function
-    argument names file_gamma, int_file_gamma, and srgb_intent consistently.
-  Changed PNG_UNUSED from "param=param;" to "(void)param;".
-  Added transform tests to pngvalid and simplified the arguments.
-  Added a request in the manual that applications do not use "png_" or
-    "PNG_" to begin any of their own symbols.
+  Removed two useless #ifdef directives from pngread.c and one from pngrutil.c
+  Always put the CMAKE_LIBRARY in "lib" (removed special WIN32 case).
+  Removed empty vstudio/pngstest directory (Clifford Yapp).
+  Eliminated redundant png_push_read_tEXt|zTXt|iTXt|unknown code from
+    pngpread.c and use the sequential png_handle_tEXt, etc., in pngrutil.c;
+    now that png_ptr->buffer is inaccessible to applications, the special
+    handling is no longer useful.
+  Fixed bug with png_handle_hIST with odd chunk length (Frank Busse).
+  Added PNG_SAFE_LIMITS feature to pnglibconf.dfa and code in pngconf.h
+    to reset the user limits to safe ones if PNG_SAFE_LIMITS is defined.
+    To enable, use "CPPFLAGS=-DPNG_SAFE_LIMITS_SUPPORTED" on the configure
+    command or put "#define PNG_SAFE_LIMITS_SUPPORTED" in pnglibconf.h.
+  Revised the SAFE_LIMITS feature to be the same as the feature in libpng16.
+  Added information about the new limits in the manual.
+  Updated Makefile.in
+  Removed unused "current_text" members of png_struct and the png_free()
+    of png_ptr->current_text from pngread.c
+  Fixed PNG_LIBPNG_BUILD_BASE_TYPE definition.
+  Fixed CMF optimization of non-IDAT compressed chunks, which was added at
+    libpng-1.5.4.  It sometimes produced too small of a window.
+  Reject all iCCP chunks after the first, even if the first one is invalid.
+  Added palette-index checking. Issue a png_benign_error() if an invalid
+    index is found.
+  Revised example.c to put text strings in a temporary character array
+    instead of directly assigning string constants to png_textp members.
+    This avoids compiler warnings when -Wwrite-strings is enabled.
+  Prevent PNG_EXPAND+PNG_SHIFT doing the shift twice.
+  Revised png_set_text_2() to avoid potential memory corruption (fixes
+    CVE-2011-3048).
 
 Send comments/corrections/commendations to png-mng-implement at lists.sf.net
 (subscription required; visit
 https://lists.sourceforge.net/lists/listinfo/png-mng-implement
-to subscribe) or to glennrp at users.sourceforge.net
+to subscribe)
+or to glennrp at users.sourceforge.net
 
 Glenn R-P
diff --git a/src/3rdparty/libpng/CHANGES b/src/3rdparty/libpng/CHANGES
index fa5f2aa..70af827 100644
--- a/src/3rdparty/libpng/CHANGES
+++ b/src/3rdparty/libpng/CHANGES
@@ -1,5 +1,4 @@
 #if 0
-libpng_changes(){ /*
 CHANGES - changes for libpng
 
 Version 0.2
@@ -15,7 +14,7 @@ Version 0.3
   fixed some bugs in writer
   interfaced with zlib 0.5
   added K&R support
-  added check for 64 KB blocks for 16 bit machines
+  added check for 64 KB blocks for 16-bit machines
 
 Version 0.4
   cleaned up code and commented code
@@ -74,7 +73,7 @@ Version 0.82 [September, 1995]
 Version 0.85 [December, 1995]
   added more medium model code (almost everything's a far)
   added i/o, error, and memory callback functions
-  fixed some bugs (16 bit, 4 bit interlaced, etc.)
+  fixed some bugs (16-bit, 4-bit interlaced, etc.)
   added first run progressive reader (barely tested)
 
 Version 0.86 [January, 1996]
@@ -180,7 +179,7 @@ Version 0.96 [May, 1997]
   Fixed serious bug with < 8bpp images introduced in 0.95
   Fixed 256-color transparency bug (Greg Roelofs)
   Fixed up documentation (Greg Roelofs, Laszlo Nyul)
-  Fixed "error" in pngconf.h for Linux setjmp() behaviour
+  Fixed "error" in pngconf.h for Linux setjmp() behavior
   Fixed DOS medium model support (Tim Wegner)
   Fixed png_check_keyword() for case with error in static string text
   Added read of CRC after IEND chunk for embedded PNGs (Laszlo Nyul)
@@ -197,18 +196,20 @@ Version 0.97 [January, 1998]
   Added more typecasts. 65536L becomes (png_uint_32)65536L, etc. (Glenn R-P)
   Minor corrections in libpng.txt
   Added simple sRGB support (Glenn R-P)
-  Easier conditional compiling, e.g. define PNG_READ/WRITE_NOT_FULLY_SUPPORTED;
+  Easier conditional compiling, e.g.,
+    define PNG_READ/WRITE_NOT_FULLY_SUPPORTED;
     all configurable options can be selected from command-line instead
     of having to edit pngconf.h (Glenn R-P)
   Fixed memory leak in pngwrite.c (free info_ptr->text) (Glenn R-P)
   Added more conditions for png_do_background, to avoid changing
     black pixels to background when a background is supplied and
     no pixels are transparent
-  Repaired PNG_NO_STDIO behaviour
-  Tested NODIV support and made it default behaviour (Greg Roelofs)
+  Repaired PNG_NO_STDIO behavior
+  Tested NODIV support and made it default behavior (Greg Roelofs)
   Added "-m" option and PNGTEST_DEBUG_MEMORY to pngtest (John Bowler)
   Regularized version numbering scheme and bumped shared-library major
-     version number to 2 to avoid problems with libpng 0.89 apps (Greg Roelofs)
+    version number to 2 to avoid problems with libpng 0.89 apps
+    (Greg Roelofs)
 
 Version 0.98 [January, 1998]
   Cleaned up some typos in libpng.txt and in code documentation
@@ -1778,7 +1779,7 @@ Version 1.2.13beta1 [October 2, 2006]
   Removed AC_FUNC_MALLOC from configure.ac
   Work around Intel-Mac compiler bug by setting PNG_NO_MMX_CODE in pngconf.h
   Change "logical" to "bitwise" throughout documentation.
-  Detect and fix attempt to write wrong iCCP profile length.
+  Detect and fix attempt to write wrong iCCP profile length (CVE-2006-7244)
 
 Version 1.0.21, 1.2.13 [November 14, 2006]
   Fix potential buffer overflow in sPLT chunk handler.
@@ -2361,7 +2362,7 @@ Version 1.4.0beta72 [August 1, 2009]
 
 Version 1.4.0beta73 [August 1, 2009]
   Reject attempt to write iCCP chunk with negative embedded profile length
-    (JD Chen)
+    (JD Chen) (CVE-2009-5063).
 
 Version 1.4.0beta74 [August 8, 2009]
   Changed png_ptr and info_ptr member "trans" to "trans_alpha".
@@ -2935,7 +2936,7 @@ Version 1.5.0beta36 [July 29, 2010]
     PNG_INTERLACE transform and to get the number of rows in the current
     pass.
   A new test program, pngvalid.c, validates the gamma code.
-  Errors in the 16 bit gamma correction (overflows) have been corrected.
+  Errors in the 16-bit gamma correction (overflows) have been corrected.
   cHRM chunk testing is done consistently (previously the floating point
     API bypassed it, because the test really didn't work on FP, now the test
     is performed on the actual values to be stored in the PNG file so it
@@ -3149,8 +3150,8 @@ version 1.5.1beta01 [January 8, 2011]
     in version 1.5.0beta36 but is not noted in the CHANGES.  Similarly,
     it was changed from png_charpp to png_const_bytepp in png_set_iCCP().
   Ensure that png_rgb_to_gray ignores palette mapped images, if libpng
-    internally happens to call it with one.
-  Fixed a failure to handle palette mapped images correctly.
+    internally happens to call it with one, and fixed a failure to handle
+    palette mapped images correctly.  This fixes CVE-2690.
 
 Version 1.5.1beta02 [January 14, 2011]
   Fixed a bug in handling of interlaced images (bero at arklinux.org).
@@ -3208,9 +3209,9 @@ Version 1.5.1beta09 [January 24, 2011]
     pngvalid contains tests of transforms, which tests are currently disabled
     because they are incompletely tested.  gray_to_rgb was failing to expand
     the bit depth for smaller bit depth images; this seems to be a long
-    standing error and resulted, apparently, in invalid output.  The
-    documentation did not accurately describe what libpng really does when
-    converting RGB to gray.
+    standing error and resulted, apparently, in invalid output
+    (CVE-2011-0408, CERT VU#643140).  The documentation did not accurately
+    describe what libpng really does when converting RGB to gray.
 
 Version 1.5.1beta10 [January 27, 2010]
   Fixed incorrect examples of callback prototypes in the manual, that were
@@ -3227,7 +3228,7 @@ Version 1.5.1beta10 [January 27, 2010]
 Version 1.5.1beta11 [January 28, 2011]
   Changed PNG_UNUSED from "param=param;" to "{if(param){}}".
   Corrected local variable type in new API png_process_data_skip()
-    The type was self-evidently incorrect but only causes problems on 64 bit
+    The type was self-evidently incorrect but only causes problems on 64-bit
     architectures.
   Added transform tests to pngvalid and simplified the arguments.
 
@@ -3242,6 +3243,617 @@ Version 1.5.1rc02 [January 31, 2011]
 Version 1.5.1 [February 3, 2011]
   No changes.
 
+Version 1.5.2beta01 [February 13, 2011]
+  More -Wshadow fixes for older gcc compilers.  Older gcc versions apparently
+    check formal parameters names in function declarations (as well as
+    definitions) to see if they match a name in the global namespace.
+  Revised PNG_EXPORTA macro to not use an empty parameter, to accommodate the
+    old VisualC++ preprocessor.
+  Turned on interlace handling in png_read_png().
+  Fixed gcc pendantic warnings.
+  Handle longjmp in Cygwin.
+  Fixed png_get_current_row_number() in the interlaced case.
+  Cleaned up ALPHA flags and transformations.
+  Implemented expansion to 16 bits.
+
+Version 1.5.2beta02 [February 19, 2011]
+  Fixed mistake in the descriptions of user read_transform and write_transform
+    function prototypes in the manual.  The row_info struct is png_row_infop.
+  Reverted png_get_current_row_number() to previous (1.5.2beta01) behavior.
+  Corrected png_get_current_row_number documentation
+  Fixed the read/write row callback documentation.
+    This documents the current behavior, where the callback is called after
+    every row with information pertaining to the next row.
+
+Version 1.5.2beta03 [March 3, 2011]
+  Fixed scripts/makefile.vcwin32
+  Updated contrib/pngsuite/README to add the word "modify".
+  Define PNG_ALLOCATED to blank when _MSC_VER<1300.
+
+Version 1.5.2rc01 [March 19, 2011]
+  Define remaining attributes to blank when MSC_VER<1300.
+  ifdef out mask arrays in pngread.c when interlacing is not supported.
+
+Version 1.5.2rc02 [March 22, 2011]
+  Added a hint to try CPP=/bin/cpp if "cpp -E" fails in scripts/pnglibconf.mak
+    and in contrib/pngminim/*/makefile, eg., on SunOS 5.10, and removed "strip"
+    from the makefiles.
+  Fixed a bug (present since libpng-1.0.7) that makes png_handle_sPLT() fail
+    to compile when PNG_NO_POINTER_INDEXING is defined (Chubanov Kirill)
+
+Version 1.5.2rc03 [March 24, 2011]
+  Don't include standard header files in png.h while building the symbol table,
+    to avoid cpp failure on SunOS (introduced PNG_BUILDING_SYMBOL_TABLE macro).
+
+Version 1.5.2 [March 31, 2011]
+  No changes.
+
+Version 1.5.3beta01 [April 1, 2011]
+  Re-initialize the zlib compressor before compressing non-IDAT chunks.
+  Added API functions (png_set_text_compression_level() and four others) to
+    set parameters for zlib compression of non-IDAT chunks.
+
+Version 1.5.3beta02 [April 3, 2011]
+  Updated scripts/symbols.def with new API functions.
+  Only compile the new zlib re-initializing code when text or iCCP is
+    supported, using PNG_WRITE_COMPRESSED_TEXT_SUPPORTED macro.
+  Improved the optimization of the zlib CMF byte (see libpng-1.2.6beta03).
+  Optimize the zlib CMF byte in non-IDAT compressed chunks
+
+Version 1.5.3beta03 [April 16, 2011]
+  Fixed gcc -ansi -pedantic compile. A strict ANSI system does not have
+    snprintf, and the "__STRICT_ANSI__" detects that condition more reliably
+    than __STDC__ (John Bowler).
+  Removed the PNG_PTR_NORETURN attribute because it too dangerous. It tells
+    the compiler that a user supplied callback (the error handler) does not
+    return, yet there is no guarantee in practice that the application code
+    will correctly implement the error handler because the compiler only
+    issues a warning if there is a mistake (John Bowler).
+  Removed the no-longer-used PNG_DEPSTRUCT macro.
+  Updated the zlib version to 1.2.5 in the VStudio project.
+  Fixed 64-bit builds where png_uint_32 is smaller than png_size_t in
+    pngwutil.c (John Bowler).
+  Fixed bug with stripping the filler or alpha channel when writing, that
+    was introduced in libpng-1.5.2beta01 (bug report by Andrew Church).
+
+Version 1.5.3beta04 [April 27, 2011]
+  Updated pngtest.png with the new zlib CMF optimization.
+  Cleaned up conditional compilation code and of background/gamma handling
+    Internal changes only except a new option to avoid compiling the
+    png_build_grayscale_palette API (which is not used at all internally.)
+    The main change is to move the transform tests (READ_TRANSFORMS,
+    WRITE_TRANSFORMS) up one level to the caller of the APIs.  This avoids
+    calls to spurious functions if all transforms are disabled and slightly
+    simplifies those functions.  Pngvalid modified to handle this.
+    A minor change is to stop the strip_16 and expand_16 interfaces from
+    disabling each other; this allows the future alpha premultiplication
+    code to use 16-bit intermediate values while still producing 8-bit output.
+    png_do_background and png_do_gamma have been simplified to take a single
+    pointer to the png_struct rather than pointers to every item required
+    from the png_struct. This makes no practical difference to the internal
+    code.
+  A serious bug in the pngvalid internal routine 'standard_display_init' has
+    been fixed - this failed to initialize the red channel and accidentally
+    initialized the alpha channel twice.
+  Changed png_struct jmp_buf member name from png_jmpbuf to tmp_jmpbuf to
+    avoid a possible clash with the png_jmpbuf macro on some platforms.
+
+Version 1.5.3beta05 [May 6, 2011]
+  Added the "_POSIX_SOURCE" feature test macro to ensure libpng sees the
+    correct API. _POSIX_SOURCE is defined in pngpriv.h, pngtest.c and
+    pngvalid.c to ensure that POSIX conformant systems disable non-POSIX APIs.
+  Removed png_snprintf and added formatted warning messages.  This change adds
+    internal APIs to allow png_warning messages to have parameters without
+    requiring the host OS to implement snprintf.  As a side effect the
+    dependency of the tIME-supporting RFC1132 code on stdio is removed and
+    PNG_NO_WARNINGS does actually work now.
+  Pass "" instead of '\0' to png_default_error() in png_err().  This mistake
+    was introduced in libpng-1.2.20beta01.  This fixes CVE-2011-2691.
+  Added PNG_WRITE_OPTIMIZE_CMF_SUPPORTED macro to make the zlib "CMF" byte
+    optimization configureable.
+  IDAT compression failed if preceded by a compressed text chunk (bug
+    introduced in libpng-1.5.3beta01-02).  This was because the attempt to
+    reset the zlib stream in png_write_IDAT happened after the first IDAT
+    chunk had been deflated - much too late.  In this change internal
+    functions were added to claim/release the z_stream and, hopefully, make
+    the code more robust.  Also deflateEnd checking is added - previously
+    libpng would ignore an error at the end of the stream.
+
+Version 1.5.3beta06 [May 8, 2011]
+  Removed the -D_ALL_SOURCE from definitions for AIX in CMakeLists.txt
+  Implemented premultiplied alpha support: png_set_alpha_mode API
+
+Version 1.5.3beta07 [May 11, 2011]
+  Added expand_16 support to the high level interface.
+  Added named value and 'flag' gamma support to png_set_gamma.  Made a minor
+    change from the previous (unreleased) ABI/API to hide the exact value used
+    for Macs - it's not a good idea to embed this in the ABI!
+  Moved macro definitions for PNG_HAVE_IHDR, PNG_HAVE_PLTE, and PNG_AFTER_IDAT
+    from pngpriv.h to png.h because they must be visible to applications
+    that call png_set_unknown_chunks().
+  Check for up->location !PNG_AFTER_IDAT when writing unknown chunks
+    before IDAT.
+
+Version 1.5.3beta08 [May 16, 2011]
+  Improved "pngvalid --speed" to exclude more of pngvalid from the time.
+  Documented png_set_alpha_mode(), other changes in libpng.3/libpng-manual.txt
+  The cHRM chunk now sets the defaults for png_set_rgb_to_gray() (when negative
+    parameters are supplied by the caller), while in the absence of cHRM
+    sRGB/Rec 709 values are still used.  This introduced a divide-by-zero
+    bug in png_handle_cHRM().
+  The bKGD chunk no longer overwrites the background value set by
+    png_set_background(), allowing the latter to be used before the file
+    header is read. It never performed any useful function to override
+    the default anyway.
+  Added memory overwrite and palette image checks to pngvalid.c
+    Previously palette image code was poorly checked. Since the transformation
+    code has a special palette path in most cases this was a severe weakness.
+  Minor cleanup and some extra checking in pngrutil.c and pngrtran.c. When
+    expanding an indexed image, always expand to RGBA if transparency is
+    present.
+
+Version 1.5.3beta09 [May 17, 2011]
+  Reversed earlier 1.5.3 change of transformation order; move png_expand_16
+    back where it was.  The change doesn't work because it requires 16-bit
+    gamma tables when the code only generates 8-bit ones.  This fails
+    silently; the libpng code just doesn't do any gamma correction.  Moving
+    the tests back leaves the old, inaccurate, 8-bit gamma calculations, but
+    these are clearly better than none!
+
+Version 1.5.3beta10 [May 20, 2011]
+
+  png_set_background() and png_expand_16() did not work together correctly.
+    This problem is present in 1.5.2; if png_set_background is called with
+    need_expand false and the matching 16 bit color libpng erroneously just
+    treats it as an 8-bit color because of where png_do_expand_16 is in the
+    transform list.  This simple fix reduces the supplied colour to 8-bits,
+    so it gets smashed, but this is better than the current behavior.
+  Added tests for expand16, more fixes for palette image tests to pngvalid.
+    Corrects the code for palette image tests and disables attempts to
+    validate palette colors.
+
+Version 1.5.3rc01 [June 3, 2011]
+  No changes.
+
+Version 1.5.3rc02 [June 8, 2011]
+  Fixed uninitialized memory read in png_format_buffer() (Bug report by
+    Frank Busse, CVE-2011-2501, related to CVE-2004-0421).
+
+Version 1.5.3beta11 [June 11, 2011]
+  Fixed png_handle_sCAL which is broken in 1.5. This fixes CVE 2011-2692.
+  Added sCAL to pngtest.png
+  Revised documentation about png_set_user_limits() to say that it also affects
+    png writing.
+  Revised handling of png_set_user_limits() so that it can increase the
+    limit beyond the PNG_USER_WIDTH|HEIGHT_MAX; previously it could only
+    reduce it.
+  Make the 16-to-8 scaling accurate. Dividing by 256 with no rounding is
+    wrong (high by one) 25% of the time. Dividing by 257 with rounding is
+    wrong in 128 out of 65536 cases. Getting the right answer all the time
+    without division is easy.
+  Added "_SUPPORTED" to the PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION macro.
+  Added projects/owatcom, an IDE project for OpenWatcom to replace
+    scripts/makefile.watcom.  This project works with OpenWatcom 1.9. The
+    IDE autogenerates appropriate makefiles (libpng.mk) for batch processing.
+    The project is configurable, unlike the Visual Studio project, so long
+    as the developer has an awk.
+  Changed png_set_gAMA to limit the gamma value range so that the inverse
+    of the stored value cannot overflow the fixed point representation,
+    and changed other things OpenWatcom warns about.
+  Revised pngvalid.c to test PNG_ALPHA_MODE_SUPPORTED correctly. This allows
+    pngvalid to build when ALPHA_MODE is not supported, which is required if
+    it is to build on libpng 1.4.
+  Removed string/memory macros that are no longer used and are not
+    necessarily fully supportable, particularly png_strncpy and png_snprintf.
+  Added log option to pngvalid.c and attempted to improve gamma messages.
+
+Version 1.5.3 [omitted]
+  People found the presence of a beta release following an rc release
+    to be confusing; therefore we bump the version to libpng-1.5.4beta01
+    and there will be no libpng-1.5.3 release.
+
+Version 1.5.4beta01 [June 14, 2011]
+  Made it possible to undefine PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
+    to get the same (inaccurate) output as libpng-1.5.2 and earlier.
+  Moved definitions of PNG_HAVE_IHDR, PNG_AFTER_IDAT, and PNG_HAVE_PLTE
+    outside of an unknown-chunk block in png.h because they are also
+    needed for other uses.
+
+Version 1.5.4beta02 [June 14, 2011]
+  Fixed and clarified LEGACY 16-to-8 scaling code.
+  Added png_set_chop_16() API, to match inaccurate results from previous
+    libpng versions.
+  Removed the ACCURATE and LEGACY options (they are no longer useable)
+  Use the old scaling method for background if png_set_chop_16() was
+    called.
+  Made png_set_chop_16() API removeable by disabling PNG_CHOP_16_TO_8_SUPPORTED
+
+Version 1.5.4beta03 [June 15, 2011]
+  Fixed a problem in png_do_expand_palette() exposed by optimization in
+    1.5.3beta06
+  Also removed a spurious and confusing "trans" member ("trans") from png_info.
+  The palette expand optimization prevented expansion to an intermediate RGBA
+    form if tRNS was present but alpha was marked to be stripped; this exposed
+    a check for tRNS in png_do_expand_palette() which is inconsistent with the
+    code elsewhere in libpng.
+  Correction to the expand_16 code; removed extra instance of
+    png_set_scale_16_to_8 from pngpriv.h
+
+Version 1.5.4beta04 [June 16, 2011]
+  Added a missing "#ifdef PNG_READ_BACKGROUND_SUPPORTED/#endif" in pngrtran.c
+  Added PNG_TRANSFORM_CHOP_16 to the high-level read transforms.
+  Made PNG_READ_16_TO_8_ACCURATE_SCALE configurable again.  If this is
+    not enabled, png_set_strip_16() and png_do_scale_16_to_8() aren't built.
+  Revised contrib/visupng, gregbook, and pngminim to demonstrate chop_16_to_8
+
+Version 1.5.4beta05 [June 16, 2011]
+  Renamed png_set_strip_16() to png_set_scale_16() and renamed
+    png_set_chop_16() to png_set_strip(16) in an attempt to minimize the
+    behavior changes between libpng14 and libpng15.
+
+Version 1.5.4beta06 [June 18, 2011]
+  Fixed new bug that was causing both strip_16 and scale_16 to be applied.
+
+Version 1.5.4beta07 [June 19, 2011]
+  Fixed pngvalid, simplified macros, added checking for 0 in sCAL.
+    The ACCURATE scale macro is no longer defined in 1.5 - call the
+    png_scale_16_to_8 API.  Made sure that PNG_READ_16_TO_8 is still defined
+    if the png_strip_16_to_8 API is present.  png_check_fp_number now
+    maintains some state so that positive, negative and zero values are
+    identified.  sCAL uses these to be strictly spec conformant.
+
+Version 1.5.4beta08 [June 23, 2011]
+  Fixed pngvalid if ACCURATE_SCALE is defined.
+  Updated scripts/pnglibconf.h.prebuilt.
+
+Version 1.5.4rc01 [June 30, 2011]
+  Define PNG_ALLOCATED to "restrict" only if MSC_VER >= 1400.
+
+Version 1.5.4 [July 7, 2011]
+  No changes.
+
+Version 1.5.5beta01 [July 13, 2011]
+  Fixed some typos and made other minor changes in the manual.
+  Updated contrib/pngminus/makefile.std (Samuli Souminen)
+
+Version 1.5.5beta02 [July 14, 2011]
+  Revised Makefile.am and Makefile.in to look in the right directory for
+    pnglibconf.h.prebuilt
+
+Version 1.5.5beta03 [July 27, 2011]
+  Enabled compilation with g++ compiler.  This compiler does not recognize
+    the file extension, so it always compiles with C++ rules.  Made minor
+    changes to pngrutil.c to cast results where C++ expects it but C does not.
+  Minor editing of libpng.3 and libpng-manual.txt.
+
+Version 1.5.5beta04 [July 29, 2011]
+  Revised CMakeLists.txt (Clifford Yapp)
+  Updated commentary about the png_rgb_to_gray() default coefficients
+    in the manual and in pngrtran.c
+
+Version 1.5.5beta05 [August 17, 2011]
+  Prevent unexpected API exports from non-libpng DLLs on Windows.  The "_DLL"
+    is removed from the test of whether a DLL is being built (this erroneously
+    caused the libpng APIs to be marked as DLL exports in static builds under
+    Microsoft Visual Studio).  Almost all of the libpng building configuration
+    is moved from pngconf.h to pngpriv.h, but PNG_DLL_EXPORT remains in
+    pngconf.h, though, so that it is colocated with the import definition (it
+    is no longer used anywhere in the installed headers).  The VStudio project
+    definitions have been cleaned up: "_USRDLL" has been removed from the
+    static library builds (this was incorrect), and PNG_USE_DLL has been added
+    to pngvalid to test the functionality (pngtest does not supply it,
+    deliberately).  The spurious "_EXPORTS" has been removed from the
+    libpng build (all these errors were a result of copy/paste between project
+    configurations.)
+  Added new types and internal functions for CIE RGB end point handling to
+    pngpriv.h (functions yet to be implemented).
+
+Version 1.5.5beta06 [August 26, 2011]
+  Ensure the CMAKE_LIBRARY_OUTPUT_DIRECTORY is set in CMakeLists.txt
+    (Clifford Yap)
+  Fixes to rgb_to_gray and cHRM XYZ APIs (John Bowler):
+    The rgb_to_gray code had errors when combined with gamma correction.
+    Some pixels were treated as true grey when they weren't and such pixels
+    and true grey ones were not gamma corrected (the original value of the
+    red component was used instead).  APIs to get and set cHRM using color
+    space end points have been added and the rgb_to_gray code that defaults
+    based on cHRM, and the divide-by-zero bug in png_handle_cHRM (CERT
+    VU#477046, CVE-2011-3328, introduced in 1.5.4) have been corrected.
+  A considerable number of tests has been added to pngvalid for the
+    rgb_to_gray transform.
+  Arithmetic errors in rgb_to_gray whereby the calculated gray value was
+    truncated to the bit depth rather than rounded have been fixed except in
+    the 8-bit non-gamma-corrected case (where consistency seems more important
+    than correctness.)  The code still has considerable inaccuracies in the
+    8-bit case because 8-bit linear arithmetic is used.
+
+Version 1.5.5beta07 [September 7, 2011]
+  Added "$(ARCH)" option to makefile.darwin
+  Added SunOS support to configure.ac and Makefile.am
+  Changed png_chunk_benign_error() to png_warning() in png.c, in
+    png_XYZ_from_xy_checked().
+
+Version 1.5.5beta08 [September 10, 2011]
+  Fixed 64-bit compilation errors (gcc). The errors fixed relate
+    to conditions where types that are 32 bits in the GCC 32-bit
+    world (uLong and png_size_t) become 64 bits in the 64-bit
+    world.  This produces potential truncation errors which the
+    compiler correctly flags.
+  Relocated new HAVE_SOLARIS_LD definition in configure.ac
+  Constant changes for 64-bit compatibility (removal of L suffixes). The
+    16-bit cases still use "L" as we don't have a 16-bit test system.
+
+Version 1.5.5rc01 [September 15, 2011]
+  Removed "L" suffixes in pngpriv.h
+
+Version 1.5.5 [September 22, 2011]
+  No changes.
+
+Version 1.5.6beta01 [September 22, 2011]
+  Fixed some 64-bit type conversion warnings in pngrtran.c
+  Moved row_info from png_struct to a local variable.
+  The various interlace mask arrays have been made into arrays of
+    bytes and made PNG_CONST and static (previously some arrays were
+    marked PNG_CONST and some weren't).
+  Additional checks have been added to the transform code to validate the
+    pixel depths after the transforms on both read and write.
+  Removed some redundant code from pngwrite.c, in png_destroy_write_struct().
+  Changed chunk reading/writing code to use png_uint_32 instead of png_byte[4].
+    This removes the need to allocate temporary strings for chunk names on
+    the stack in the read/write code.  Unknown chunk handling still uses the
+    string form because this is exposed in the API.
+
+Version 1.5.6beta02 [September 26, 2011]
+  Added a note in the manual the png_read_update_info() must be called only
+    once with a particular info_ptr.
+  Fixed a typo in the definition of the new PNG_STRING_FROM_CHUNK(s,c) macro.
+
+Version 1.5.6beta03 [September 28, 2011]
+  Revised test-pngtest.sh to report FAIL when pngtest fails.
+  Added "--strict" option to pngtest, to report FAIL when the failure is
+    only because the resulting valid files are different.
+  Revised CMakeLists.txt to work with mingw and removed some material from
+    CMakeLists.txt that is no longer useful in libpng-1.5.
+
+Version 1.5.6beta04 [October 5, 2011]
+  Fixed typo in Makefile.in and Makefile.am ("-M Wl" should be "-M -Wl")."
+
+Version 1.5.6beta05 [October 12, 2011]
+  Speed up png_combine_row() for interlaced images. This reduces the generality
+    of the code, allowing it to be optimized for Adam7 interlace.  The masks
+    passed to png_combine_row() are now generated internally, avoiding
+    some code duplication and localizing the interlace handling somewhat.
+  Align png_struct::row_buf - previously it was always unaligned, caused by
+    a bug in the code that attempted to align it; the code needs to subtract
+    one from the pointer to take account of the filter byte prepended to
+    each row.
+  Optimized png_combine_row() when rows are aligned. This gains a small
+    percentage for 16-bit and 32-bit pixels in the typical case where the
+    output row buffers are appropriately aligned. The optimization was not
+    previously possible because the png_struct buffer was always misaligned.
+  Fixed bug in png_write_chunk_header() debug print, introduced in 1.5.6beta01.
+
+Version 1.5.6beta06 [October 17, 2011]
+  Removed two redundant tests for unitialized row.
+  Fixed a relatively harmless memory overwrite in compressed text writing
+    with a 1 byte zlib buffer.
+  Add ability to call png_read_update_info multiple times to pngvalid.c.
+  Fixes for multiple calls to png_read_update_info. These fixes attend to
+    most of the errors revealed in pngvalid, however doing the gamma work
+    twice results in inaccuracies that can't be easily fixed.  There is now
+    a warning in the code if this is going to happen.
+  Turned on multiple png_read_update_info in pngvalid transform tests.
+  Prevent libpng from overwriting unused bits at the end of the image when
+    it is not byte aligned, while reading. Prior to libpng-1.5.6 libpng would
+    overwrite the partial byte at the end of each row if the row width was not
+    an exact multiple of 8 bits and the image is not interlaced.
+
+Version 1.5.6beta07 [October 21, 2011]
+  Made png_ptr->prev_row an aligned pointer into png_ptr->big_prev_row
+    (Mans Rullgard).
+
+Version 1.5.6rc01 [October 26, 2011]
+  Changed misleading "Missing PLTE before cHRM" warning to "Out of place cHRM"
+
+Version 1.5.6rc02 [October 27, 2011]
+  Added LSR() macro to defend against buggy compilers that evaluate non-taken
+    code branches and complain about out-of-range shifts.
+
+Version 1.5.6rc03 [October 28, 2011]
+  Renamed the LSR() macro to PNG_LSR() and added PNG_LSL() macro.
+  Fixed compiler warnings with Intel and MSYS compilers. The logical shift
+    fix for Microsoft Visual C is required by other compilers, so this
+    enables that fix for all compilers when using compile-time constants.
+    Under MSYS 'byte' is a name declared in a system header file, so we
+    changed the name of a local variable to avoid the warnings that result.
+  Added #define PNG_ALIGN_TYPE PNG_ALIGN_NONE to contrib/pngminim/*/pngusr.h
+
+Version 1.5.6 [November 3, 2011]
+  No changes.
+
+Version 1.5.7beta01 [November 4, 2011]
+  Added support for ARM processor (Mans Rullgard)
+  Fixed bug in pngvalid on early allocation failure; fixed type cast in
+    pngmem.c; pngvalid would attempt to call png_error() if the allocation
+    of a png_struct or png_info failed. This would probably have led to a
+    crash.  The pngmem.c implementation of png_malloc() included a cast
+    to png_size_t which would fail on large allocations on 16-bit systems.
+  Fix for the preprocessor of the Intel C compiler. The preprocessor
+    splits adjacent @ signs with a space; this changes the concatentation
+    token from @-@-@ to PNG_JOIN; that should work with all compiler
+    preprocessors.
+  Paeth filter speed improvements from work by Siarhei Siamashka. This
+    changes the 'Paeth' reconstruction function to improve the GCC code
+    generation on x86. The changes are only part of the suggested ones;
+    just the changes that definitely improve speed and remain simple.
+    The changes also slightly increase the clarity of the code.
+
+Version 1.5.7beta02 [November 11, 2011]
+  Check compression_type parameter in png_get_iCCP and remove spurious
+    casts. The compression_type parameter is always assigned to, so must
+    be non-NULL. The cast of the profile length potentially truncated the
+    value unnecessarily on a 16-bit int system, so the cast of the (byte)
+    compression type to (int) is specified by ANSI-C anyway.
+  Fixed FP division by zero in pngvalid.c; the 'test_pixel' code left
+    the sBIT fields in the test pixel as 0, which resulted in a floating
+    point division by zero which was irrelevant but causes systems where
+    FP exceptions cause a crash. Added code to pngvalid to turn on FP
+    exceptions if the appropriate glibc support is there to ensure this is
+    tested in the future.
+  Updated scripts/pnglibconf.mak and scripts/makefile.std to handle the
+    new PNG_JOIN macro.
+  Added versioning to pnglibconf.h comments.
+  Simplified read/write API initial version; basic read/write tested on
+    a variety of images, limited documentation (in the header file.)
+  Installed more accurate linear to sRGB conversion tables. The slightly
+    modified tables reduce the number of 16-bit values that
+    convert to an off-by-one 8-bit value.  The "makesRGB.c" code that was used
+    to generate the tables is now in a contrib/sRGBtables sub-directory.
+
+Version 1.5.7beta03 [November 17, 2011]
+  Removed PNG_CONST from the sRGB table declarations in pngpriv.h and png.c
+  Added run-time detection of NEON support.
+  Added contrib/libtests; includes simplified API test and timing test and
+    a color conversion utility for rapid checking of failed 'pngstest' results.
+  Multiple transform bug fixes plus a work-round for double gamma correction.
+    libpng does not support more than one transform that requires linear data
+    at once - if this is tried typically the results is double gamma
+    correction. Since the simplified APIs can need rgb to gray combined with
+    a compose operation it is necessary to do one of these outside the main
+    libpng transform code. This check-in also contains fixes to various bugs
+    in the simplified APIs themselves and to some bugs in compose and rgb to
+    gray (on palette) itself.
+  Fixes for C++ compilation using g++ When libpng source is compiled
+    using g++. The compiler imposes C++ rules on the C source; thus it
+    is desireable to make the source work with either C or C++ rules
+    without throwing away useful error information.  This change adds
+    png_voidcast to allow C semantic (void*) cases or the corresponding
+    C++ static_cast operation, as appropriate.
+  Added --noexecstack to assembler file compilation. GCC does not set
+    this on assembler compilation, even though it does on C compilation.
+    This creates security issues if assembler code is enabled; the
+    work-around is to set it by default in the flags for $(CCAS)
+  Work around compilers that don't support declaration of const data. Some
+    compilers fault 'extern const' data declarations (because the data is
+    not initialized); this turns on const-ness only for compilers where
+    this is known to work.
+
+Version 1.5.7beta04 [November 17, 2011]
+  Since the gcc driver does not recognize the --noexecstack flag, we must
+    use the -Wa prefix to have it passed through to the assembler.
+    Also removed a duplicate setting of this flag.
+  Added files that were omitted from the libpng-1.5.7beta03 zip distribution.
+
+Version 1.5.7beta05 [November 25, 2011]
+  Removed "zTXt" from warning in generic chunk decompression function.
+  Validate time settings passed to pngset() and png_convert_to_rfc1123()
+    (Frank Busse).
+  Added MINGW support to CMakeLists.txt
+  Reject invalid compression flag or method when reading the iTXt chunk.
+  Backed out 'simplified' API changes. The API seems too complex and there
+    is a lack of consensus or enthusiasm for the proposals.  The API also
+    reveals significant bugs inside libpng (double gamma correction and the
+    known bug of being unable to retrieve a corrected palette). It seems
+    better to wait until the bugs, at least, are corrected.
+  Moved pngvalid.c into contrib/libtests
+  Rebuilt Makefile.in, configure, etc., with autoconf-2.68
+
+Version 1.5.7rc01 [December 1, 2011]
+  Replaced an "#if" with "#ifdef" in pngrtran.c
+  Revised #if PNG_DO_BC block in png.c (use #ifdef and add #else)
+
+Version 1.5.7rc02 [December 5, 2011]
+  Revised project files and contrib/pngvalid/pngvalid.c to account for
+    the relocation of pngvalid into contrib/libtests.
+  Revised pngconf.h to use " __declspec(restrict)" only when MSC_VER >= 1400,
+    as in libpng-1.5.4.
+  Put CRLF line endings in the owatcom project files.
+
+Version 1.5.7rc03 [December 7, 2011]
+  Updated CMakeLists.txt to account for the relocation of pngvalid.c
+
+Version 1.5.7 [December 15, 2011]
+  Minor fixes to pngvalid.c for gcc 4.6.2 compatibility to remove warnings
+    reported by earlier versions.
+
+Version 1.5.8beta01 [January 15, 2011]
+  Removed '#include config.h"' from contrib/libtests/pngvalid.c.  It's not
+    needed and causes trouble for VPATH building.
+  Moved AC_MSG_CHECKING([if libraries can be versioned]) later to the proper
+    location in configure.ac (Gilles Espinasse).
+  Fix bug in pngerror.c: some long warnings were being improperly truncated
+    (CVE-2011-3464, bug introduced in libpng-1.5.3beta05).
+
+Version 1.5.8rc01 [January 21, 2012]
+  No changes.
+
+Version 1.5.8rc02 [January 25, 2012]
+  Fixed Min/GW uninstall to remove libpng.dll.a
+  Conditionalize the install rules for MINGW and CYGWIN in CMakeLists.txt
+
+Version 1.5.8 [February 1, 2012]
+  No changes.
+
+Version 1.5.9beta01 [February 3, 2012]
+  Rebuilt configure scripts in the tar distributions.
+
+Version 1.5.9beta02 [February 16, 2012]
+  Removed two unused definitions from scripts/pnglibconf.h.prebuilt
+  Removed some unused arrays (with #ifdef) from png_read_push_finish_row().
+  Removed tests for no-longer-used *_EMPTY_PLTE_SUPPORTED from pngstruct.h
+
+Version 1.5.9rc01 [February 17, 2012]
+  Fixed CVE-2011-3026 buffer overrun bug.  This bug was introduced when
+    iCCP chunk support was added at libpng-1.0.6. Deal more correctly with the
+    test on iCCP chunk length. Also removed spurious casts that may hide
+    problems on 16-bit systems.
+
+Version 1.5.9 [February 18, 2012]
+  No changes.
+
+Version 1.5.10beta01 [February 24, 2012]
+  Removed two useless #ifdef directives from pngread.c and one from pngrutil.c
+  Always put the CMAKE_LIBRARY in "lib" (removed special WIN32 case).
+  Removed empty vstudio/pngstest directory (Clifford Yapp).
+  Eliminated redundant png_push_read_tEXt|zTXt|iTXt|unknown code from
+    pngpread.c and use the sequential png_handle_tEXt, etc., in pngrutil.c;
+    now that png_ptr->buffer is inaccessible to applications, the special
+    handling is no longer useful.
+  Fixed bug with png_handle_hIST with odd chunk length (Frank Busse).
+  Added PNG_SAFE_LIMITS feature to pnglibconf.dfa and code in pngconf.h
+    to reset the user limits to safe ones if PNG_SAFE_LIMITS is defined.
+    To enable, use "CPPFLAGS=-DPNG_SAFE_LIMITS_SUPPORTED" on the configure
+    command or put "#define PNG_SAFE_LIMITS_SUPPORTED" in pnglibconf.h.
+  Revised the SAFE_LIMITS feature to be the same as the feature in libpng16.
+  Added information about the new limits in the manual.
+
+Version 1.5.10beta02 [February 27, 2012]
+  Updated Makefile.in
+
+Version 1.5.10beta03 [March 6, 2012]
+  Removed unused "current_text" members of png_struct and the png_free()
+    of png_ptr->current_text from pngread.c
+  Added palette-index checking. Issue a png_warning() if an invalid index is
+    found.
+
+Version 1.5.10beta04 [March 10, 2012]
+  Fixed PNG_LIBPNG_BUILD_BASE_TYPE definition.
+  Fixed CMF optimization of non-IDAT compressed chunks, which was added at
+    libpng-1.5.4.  It sometimes produced too small of a window.
+
+Version 1.5.10beta05 [March 10, 2012]
+  Reject all iCCP chunks after the first, even if the first one is invalid.
+  Issue a png_benign_error() instead of png_warning() about bad palette index.
+  Fixed an off-by-one error in the palette index checking function.
+  Revised example.c to put text strings in a temporary character array
+    instead of directly assigning string constants to png_textp members.
+    This avoids compiler warnings when -Wwrite-strings is enabled.
+
+Version 1.5.10 [March 29, 2012]
+  Prevent PNG_EXPAND+PNG_SHIFT doing the shift twice.
+  Revised png_set_text_2() to avoid potential memory corruption (fixes
+    CVE-2011-3048).
+
 Send comments/corrections/commendations to png-mng-implement at lists.sf.net
 (subscription required; visit
 https://lists.sourceforge.net/lists/listinfo/png-mng-implement
@@ -3249,5 +3861,4 @@ to subscribe)
 or to glennrp at users.sourceforge.net
 
 Glenn R-P
-*/ }
 #endif
diff --git a/src/3rdparty/libpng/CMakeLists.txt b/src/3rdparty/libpng/CMakeLists.txt
deleted file mode 100644
index 2ee5bf3..0000000
--- a/src/3rdparty/libpng/CMakeLists.txt
+++ /dev/null
@@ -1,406 +0,0 @@
-cmake_minimum_required(VERSION 2.4.4)
-set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS true)
-
-if(UNIX AND NOT DEFINED CMAKE_BUILD_TYPE)
-  if(CMAKE_MAJOR_VERSION EQUAL 2 AND CMAKE_MINOR_VERSION EQUAL 4)
-    # workaround CMake 2.4.x bug
-    set(CMAKE_BUILD_TYPE "RelWithDebInfo" CACHE STRING
-        "Choose the type of build, options are:
-           None(CMAKE_CXX_FLAGS or CMAKE_C_FLAGS used)
-           Debug
-           Release
-           RelWithDebInfo
-           MinSizeRel.")
-  else()
-    set(CMAKE_BUILD_TYPE "RelWithDebInfo" CACHE STRING
-        "Choose the type of build, options are:
-           None(CMAKE_CXX_FLAGS or CMAKE_C_FLAGS used)
-           Debug
-           Release
-           RelWithDebInfo
-           MinSizeRel.")
-  endif()
-endif()
-
-project(libpng C)
-enable_testing()
-
-# Copyright (C) 2007-2011 Glenn Randers-Pehrson
-
-# This code is released under the libpng license.
-# For conditions of distribution and use, see the disclaimer
-# and license in png.h
-
-set(PNGLIB_MAJOR 1)
-set(PNGLIB_MINOR 5)
-set(PNGLIB_RELEASE 1)
-set(PNGLIB_NAME libpng${PNGLIB_MAJOR}${PNGLIB_MINOR})
-set(PNGLIB_VERSION ${PNGLIB_MAJOR}.${PNGLIB_MINOR}.${PNGLIB_RELEASE})
-
-# needed packages
-find_package(ZLIB REQUIRED)
-include_directories(${ZLIB_INCLUDE_DIR})
-
-if(NOT WIN32)
-  find_library(M_LIBRARY
-    NAMES m
-    PATHS /usr/lib /usr/local/lib
-  )
-  if(NOT M_LIBRARY)
-    message(STATUS
-      "math library 'libm' not found - floating point support disabled")
-  endif()
-else()
-  # not needed on windows
-  set(M_LIBRARY "")
-endif()
-
-# COMMAND LINE OPTIONS
-if(DEFINED PNG_SHARED)
-  option(PNG_SHARED "Build shared lib" ${PNG_SHARED})
-else()
-  option(PNG_SHARED "Build shared lib" ON)
-endif()
-if(DEFINED PNG_STATIC)
-  option(PNG_STATIC "Build static lib" ${PNG_STATIC})
-else()
-  option(PNG_STATIC "Build static lib" ON)
-endif()
-
-if(MINGW)
-  option(PNG_TESTS  "Build pngtest" NO)
-else()
-  option(PNG_TESTS  "Build pngtest" YES)
-endif()
-
-option(PNG_NO_CONSOLE_IO "FIXME" YES)
-option(PNG_NO_STDIO      "FIXME" YES)
-option(PNG_DEBUG         "Build with debug output" NO)
-option(PNGARG            "FIXME" YES)
-#TODO:
-# PNG_CONSOLE_IO_SUPPORTED
-
-# maybe needs improving, but currently I don't know when we can enable what :)
-set(png_asm_tmp "OFF")
-if(NOT WIN32)
-  find_program(uname_executable NAMES uname PATHS /bin /usr/bin /usr/local/bin)
-  if(uname_executable)
-    exec_program(${uname_executable}
-                 ARGS --machine OUTPUT_VARIABLE uname_output)
-    if("uname_output" MATCHES "^.*i[1-9]86.*$")
-      set(png_asm_tmp "ON")
-    else("uname_output" MATCHES "^.*i[1-9]86.*$")
-      set(png_asm_tmp "OFF")
-    endif("uname_output" MATCHES "^.*i[1-9]86.*$")
-  endif(uname_executable)
-else()
-  # this env var is normally only set on win64
-  set(TEXT "ProgramFiles(x86)")
-  if("$ENV{${TEXT}}" STREQUAL "")
-    set(png_asm_tmp "ON")
-  endif("$ENV{${TEXT}}" STREQUAL "")
-endif()
-
-# SET LIBNAME
-set(PNG_LIB_NAME png${PNGLIB_MAJOR}${PNGLIB_MINOR})
-
-# to distinguish between debug and release lib
-set(CMAKE_DEBUG_POSTFIX "d")
-
-# Use the prebuilt pnglibconf.h file from the scripts folder
-configure_file(${CMAKE_CURRENT_SOURCE_DIR}/scripts/pnglibconf.h.prebuilt
-               ${CMAKE_CURRENT_BINARY_DIR}/pnglibconf.h)
-include_directories(${CMAKE_CURRENT_BINARY_DIR})
-
-# OUR SOURCES
-set(libpng_public_hdrs
-  png.h
-  pngconf.h
-  ${CMAKE_CURRENT_BINARY_DIR}/pnglibconf.h
-)
-set(libpng_sources
-  ${libpng_public_hdrs}
-  pngdebug.h
-  pnginfo.h
-  pngpriv.h
-  pngstruct.h
-  png.c
-  pngerror.c
-  pngget.c
-  pngmem.c
-  pngpread.c
-  pngread.c
-  pngrio.c
-  pngrtran.c
-  pngrutil.c
-  pngset.c
-  pngtrans.c
-  pngwio.c
-  pngwrite.c
-  pngwtran.c
-  pngwutil.c
-)
-set(pngtest_sources
-  pngtest.c
-)
-# SOME NEEDED DEFINITIONS
-
-add_definitions(-DPNG_CONFIGURE_LIBPNG)
-
-if(_AIX)
-  add_definitions(-D_ALL_SOURCE)
-endif(_AIX)
-
-if(MSVC)
-  add_definitions(-DPNG_NO_MODULEDEF -D_CRT_SECURE_NO_DEPRECATE)
-endif(MSVC)
-
-if(PNG_SHARED OR  NOT MSVC)
-  #if building msvc static this has NOT to be defined
-  add_definitions(-DZLIB_DLL)
-endif()
-
-
-if(PNG_CONSOLE_IO_SUPPORTED)
-  add_definitions(-DPNG_CONSOLE_IO_SUPPORTED)
-endif()
-
-if(PNG_NO_CONSOLE_IO)
-  add_definitions(-DPNG_NO_CONSOLE_IO)
-endif()
-
-if(PNG_NO_STDIO)
-  add_definitions(-DPNG_NO_STDIO)
-endif()
-
-if(PNG_DEBUG)
-  add_definitions(-DPNG_DEBUG)
-endif()
-
-if(NOT M_LIBRARY AND NOT WIN32)
-  add_definitions(-DPNG_NO_FLOATING_POINT_SUPPORTED)
-endif()
-
-# NOW BUILD OUR TARGET
-include_directories(${CMAKE_CURRENT_SOURCE_DIR} ${ZLIB_INCLUDE_DIR})
-
-if(PNG_SHARED)
-  add_library(${PNG_LIB_NAME} SHARED ${libpng_sources})
-  if(MSVC)
-    # msvc does not append 'lib' - do it here to have consistent name
-    set_target_properties(${PNG_LIB_NAME} PROPERTIES PREFIX "lib")
-    set_target_properties(${PNG_LIB_NAME} PROPERTIES IMPORT_PREFIX "lib")
-  endif()
-  target_link_libraries(${PNG_LIB_NAME} ${ZLIB_LIBRARY} ${M_LIBRARY})
-endif()
-
-if(PNG_STATIC)
-# does not work without changing name
-  set(PNG_LIB_NAME_STATIC ${PNG_LIB_NAME}_static)
-  add_library(${PNG_LIB_NAME_STATIC} STATIC ${libpng_sources})
-  if(MSVC)
-    # msvc does not append 'lib' - do it here to have consistent name
-    set_target_properties(${PNG_LIB_NAME_STATIC} PROPERTIES PREFIX "lib")
-  endif()
-  target_link_libraries(${PNG_LIB_NAME_STATIC} ${ZLIB_LIBRARY} ${M_LIBRARY})
-endif()
-
-
-if(PNG_SHARED AND WIN32)
-  set_target_properties(${PNG_LIB_NAME} PROPERTIES DEFINE_SYMBOL PNG_BUILD_DLL)
-endif()
-
-if(PNG_TESTS AND PNG_SHARED)
-  # does not work with msvc due to png_lib_ver issue
-  add_executable(pngtest ${pngtest_sources})
-  target_link_libraries(pngtest ${PNG_LIB_NAME})
-  add_test(pngtest ./pngtest ${CMAKE_CURRENT_SOURCE_DIR}/pngtest.png)
-endif()
-
-#
-# Set a variable with CMake code which:
-# Creates a symlink from src to dest (if possible) or alternatively
-# copies if different.
-macro(_png_generate_symlink_code CODE SRC DEST)
-  if(WIN32 AND NOT CYGWIN)
-    set(_png_gsc_message "Copying ${SRC} to ${DEST} if needed")
-    set(_png_gsc_operation "copy_if_different")
-  else()
-    set(_png_gsc_message "Symlinking ${SRC} to ${DEST}")
-    set(_png_gsc_operation "create_symlink")
-  endif()
-
-  set(${CODE} "
-    message(STATUS \"${_png_gsc_message}\")
-    execute_process(COMMAND \${CMAKE_COMMAND} -E ${_png_gsc_operation}
-      \"${SRC}\" \"${DEST}\")
-    ")
-endmacro()
-
-# CREATE PKGCONFIG FILES
-# we use the same files like ./configure, so we have to set its vars
-if(NOT DEFINED CMAKE_INSTALL_LIBDIR)
-  set(CMAKE_INSTALL_LIBDIR lib)
-endif(NOT DEFINED CMAKE_INSTALL_LIBDIR)
-set(prefix      ${CMAKE_INSTALL_PREFIX})
-set(exec_prefix ${CMAKE_INSTALL_PREFIX})
-set(libdir      ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR})
-set(includedir  ${CMAKE_INSTALL_PREFIX}/include)
-set(LIBS        "-lz -lm")
-configure_file(${CMAKE_CURRENT_SOURCE_DIR}/libpng.pc.in
-  ${CMAKE_CURRENT_BINARY_DIR}/${PNGLIB_NAME}.pc @ONLY)
-_png_generate_symlink_code(PNG_PC_INSTALL_CODE
-  ${CMAKE_CURRENT_BINARY_DIR}/${PNGLIB_NAME}.pc
-  ${CMAKE_CURRENT_BINARY_DIR}/libpng.pc)
-install(CODE ${PNG_PC_INSTALL_CODE})
-
-configure_file(${CMAKE_CURRENT_SOURCE_DIR}/libpng-config.in
-  ${CMAKE_CURRENT_BINARY_DIR}/${PNGLIB_NAME}-config @ONLY)
-_png_generate_symlink_code(PNG_CONFIG_INSTALL_CODE
-  ${CMAKE_CURRENT_BINARY_DIR}/${PNGLIB_NAME}-config
-  ${CMAKE_CURRENT_BINARY_DIR}/libpng-config)
-install(CODE ${PNG_CONFIG_INSTALL_CODE})
-
-# SET UP LINKS
-if(PNG_SHARED)
-  set_target_properties(${PNG_LIB_NAME} PROPERTIES
-#   VERSION 15.${PNGLIB_RELEASE}.1.5.1
-    VERSION 15.${PNGLIB_RELEASE}.0
-    SOVERSION 15
-    CLEAN_DIRECT_OUTPUT 1)
-endif()
-if(PNG_STATIC)
-  # MSVC doesn't use a different file extension for shared vs. static
-  # libs.  We are able to change OUTPUT_NAME to remove the _static
-  # for all other platforms.
-  if(NOT MSVC)
-    set_target_properties(${PNG_LIB_NAME_STATIC} PROPERTIES
-      OUTPUT_NAME ${PNG_LIB_NAME}
-      CLEAN_DIRECT_OUTPUT 1)
-  endif()
-endif()
-
-# If CMake > 2.4.x, we set a variable used below to export
-# targets to an export file.
-# TODO: Use VERSION_GREATER after our cmake_minimum_required >= 2.6.2
-if(CMAKE_MAJOR_VERSION GREATER 1 AND CMAKE_MINOR_VERSION GREATER 4)
-  set(PNG_EXPORT_RULE EXPORT libpng)
-elseif(CMAKE_MAJOR_VERSION GREATER 2) # future proof
-  set(PNG_EXPORT_RULE EXPORT libpng)
-endif()
-
-# INSTALL
-if(NOT SKIP_INSTALL_LIBRARIES AND NOT SKIP_INSTALL_ALL )
-  if(PNG_SHARED)
-    install(TARGETS ${PNG_LIB_NAME}
-        ${PNG_EXPORT_RULE}
-        RUNTIME DESTINATION bin
-        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
-
-    # Create a symlink for libpng.dll.a => libpng15.dll.a on Cygwin
-    if(CYGWIN)
-      _png_generate_symlink_code(PNG_SHARED_IMPLIB_INSTALL_CODE
-        ${PNGLIB_NAME}${CMAKE_IMPORT_LIBRARY_SUFFIX}
-        libpng${CMAKE_IMPORT_LIBRARY_SUFFIX})
-      install(CODE ${PNG_SHARED_IMPLIB_INSTALL_CODE})
-      install(FILES
-        ${CMAKE_CURRENT_BINARY_DIR}/libpng${CMAKE_IMPORT_LIBRARY_SUFFIX}
-        DESTINATION ${CMAKE_INSTALL_LIBDIR})
-    endif()
-
-    if(NOT WIN32)
-      IF(CMAKE_LIBRARY_OUTPUT_DIRECTORY)
-        _png_generate_symlink_code(PNG_SHARED_INSTALL_CODE
- ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/${PNGLIB_NAME}${CMAKE_SHARED_LIBRARY_SUFFIX}
- ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng${CMAKE_SHARED_LIBRARY_SUFFIX})
-                install(CODE ${PNG_SHARED_INSTALL_CODE})
-                install(FILES
- ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng${CMAKE_SHARED_LIBRARY_SUFFIX}
-                DESTINATION ${CMAKE_INSTALL_LIBDIR})
-      ELSE(CMAKE_LIBRARY_OUTPUT_DIRECTORY)
-        _png_generate_symlink_code(PNG_SHARED_INSTALL_CODE
-           ${PNGLIB_NAME}${CMAKE_SHARED_LIBRARY_SUFFIX}
-           libpng${CMAKE_SHARED_LIBRARY_SUFFIX})
-        install(CODE ${PNG_SHARED_INSTALL_CODE})
-        install(FILES
-           ${CMAKE_CURRENT_BINARY_DIR}/libpng${CMAKE_SHARED_LIBRARY_SUFFIX}
-                DESTINATION ${CMAKE_INSTALL_LIBDIR})
-      ENDIF(CMAKE_LIBRARY_OUTPUT_DIRECTORY)
-    endif()
-  endif()
-
-  if(PNG_STATIC)
-    install(TARGETS ${PNG_LIB_NAME_STATIC}
-        ${PNG_EXPORT_RULE}
-            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
-    if(NOT WIN32 OR CYGWIN)
-      IF(CMAKE_ARCHIVE_OUTPUT_DIRECTORY)
-         _png_generate_symlink_code(PNG_STATIC_INSTALL_CODE
-${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/${PNGLIB_NAME}${CMAKE_STATIC_LIBRARY_SUFFIX}
-        ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libpng${CMAKE_STATIC_LIBRARY_SUFFIX})
-        install(CODE ${PNG_STATIC_INSTALL_CODE})
-        install(FILES
-          ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/libpng${CMAKE_STATIC_LIBRARY_SUFFIX}
-             DESTINATION ${CMAKE_INSTALL_LIBDIR})
-      ELSE(CMAKE_ARCHIVE_OUTPUT_DIRECTORY)
-        _png_generate_symlink_code(PNG_STATIC_INSTALL_CODE
-           ${PNGLIB_NAME}${CMAKE_STATIC_LIBRARY_SUFFIX}
-           libpng${CMAKE_STATIC_LIBRARY_SUFFIX})
-        install(CODE ${PNG_STATIC_INSTALL_CODE})
-        install(FILES
-          ${CMAKE_CURRENT_BINARY_DIR}/libpng${CMAKE_STATIC_LIBRARY_SUFFIX}
-                     DESTINATION ${CMAKE_INSTALL_LIBDIR})
-      ENDIF(CMAKE_ARCHIVE_OUTPUT_DIRECTORY)
-    endif()
-  endif()
-endif()
-
-if(NOT SKIP_INSTALL_HEADERS AND NOT SKIP_INSTALL_ALL )
-  install(FILES ${libpng_public_hdrs}   DESTINATION include)
-  install(FILES ${libpng_public_hdrs}   DESTINATION include/${PNGLIB_NAME})
-endif()
-if(NOT SKIP_INSTALL_EXECUTABLES AND NOT SKIP_INSTALL_ALL )
-  install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/libpng-config DESTINATION bin)
-  install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/${PNGLIB_NAME}-config
-          DESTINATION bin)
-endif()
-if(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL )
-  # Install man pages
-  if(NOT PNG_MAN_DIR)
-    set(PNG_MAN_DIR "share/man")
-  endif()
-  install(FILES libpng.3 libpngpf.3      DESTINATION ${PNG_MAN_DIR}/man3)
-  install(FILES png.5                    DESTINATION ${PNG_MAN_DIR}/man5)
-  # Install pkg-config files
-  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libpng.pc
-          DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
-  install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/libpng-config
-          DESTINATION bin)
-  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PNGLIB_NAME}.pc
-          DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
-  install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/${PNGLIB_NAME}-config
-          DESTINATION bin)
-endif()
-
-# On versions of CMake that support it, create an export file CMake
-# users can include() to import our targets
-if(PNG_EXPORT_RULE AND NOT SKIP_INSTALL_EXPORT AND NOT SKIP_INSTALL_ALL )
-  install(EXPORT libpng DESTINATION lib/libpng FILE lib${PNG_LIB_NAME}.cmake)
-endif()
-
-# what's with libpng-$VER%.txt and all the extra files?
-
-
-# UNINSTALL
-# do we need this?
-
-
-# DIST
-# do we need this?
-
-# to create msvc import lib for mingw compiled shared lib
-# pexports libpng.dll > libpng.def
-# lib /def:libpng.def /machine:x86
-
diff --git a/src/3rdparty/libpng/INSTALL b/src/3rdparty/libpng/INSTALL
index 353bfff..e6979c6 100644
--- a/src/3rdparty/libpng/INSTALL
+++ b/src/3rdparty/libpng/INSTALL
@@ -133,3 +133,23 @@ run "make install".
 Further information can be found in the README and libpng-manual.txt
 files, in the individual makefiles, in png.h, and the manual pages
 libpng.3 and png.5.
+
+Using the ./configure script -- 16 December 2002.
+=================================================
+
+The ./configure script should work compatibly with what scripts/makefile.*
+did, however there are some options you might need to add to configure
+explicitly, which previously was done semi-automatically (if you didn't edit
+scripts/makefile.* yourself, that is)
+
+CFLAGS="-Wall -O -funroll-loops \
+-malign-loops=2 -malign-functions=2" ./configure --prefix=/usr/include \
+--with-pkgconfigdir=/usr/lib/pkgconfig --includedir=/usr/include
+
+You can alternatively specify --includedir=/usr/include, /usr/local/include,
+/usr/include/libpng%NN%, or whatever.
+
+If you find that the configure script is out-of-date or is not supporting
+your platform properly, try running autogen.sh to regenerate "configure",
+"Makefile.in", and the other configuration files. Then try configure again.
+
diff --git a/src/3rdparty/libpng/LICENSE b/src/3rdparty/libpng/LICENSE
index b28f15c..b72d125 100644
--- a/src/3rdparty/libpng/LICENSE
+++ b/src/3rdparty/libpng/LICENSE
@@ -10,7 +10,7 @@ this sentence.
 
 This code is released under the libpng license.
 
-libpng versions 1.2.6, August 15, 2004, through 1.5.1, February 3, 2011, are
+libpng versions 1.2.6, August 15, 2004, through 1.5.10, March 29, 2012, are
 Copyright (c) 2004, 2006-2011 Glenn Randers-Pehrson, and are
 distributed according to the same disclaimer and license as libpng-1.2.5
 with the following individual added to the list of Contributing Authors
@@ -108,4 +108,4 @@ certification mark of the Open Source Initiative.
 
 Glenn Randers-Pehrson
 glennrp at users.sourceforge.net
-February 3, 2011
+March 29, 2012
diff --git a/src/3rdparty/libpng/README b/src/3rdparty/libpng/README
index 9dd6745..e821ee4 100644
--- a/src/3rdparty/libpng/README
+++ b/src/3rdparty/libpng/README
@@ -1,4 +1,4 @@
-README for libpng version 1.5.1 - February 3, 2011 (shared library 15.0)
+README for libpng version 1.5.10 - March 29, 2012 (shared library 15.0)
 See the note about version numbers near the top of png.h
 
 See INSTALL for instructions on how to install libpng.
@@ -114,19 +114,16 @@ given in previous versions of this document.  He and Andreas will
 read mail addressed to the png-implement list, however.
 
 Please do not send general questions about PNG.  Send them to
-the (png-list at ccrc.wustl.edu, subscription required, write to
-majordomo at ccrc.wustl.edu with "subscribe png-list" in your message).
-On the other hand,
-please do not send libpng questions to that address, send them to me
-or to the png-implement list.  I'll
-get them in the end anyway.  If you have a question about something
+png-mng-misc at lists.sf.net (subscription required; visit
+https://lists.sourceforge.net/lists/listinfo/png-mng-misc to
+subscribe).  If you have a question about something
 in the PNG specification that is related to using libpng, send it
 to me.  Send me any questions that start with "I was using libpng,
 and ...".  If in doubt, send questions to me.  I'll bounce them
 to others, if necessary.
 
 Please do not send suggestions on how to change PNG.  We have
-been discussing PNG for nine years now, and it is official and
+been discussing PNG for sixteen years now, and it is official and
 finished.  If you have suggestions for libpng, however, I'll
 gladly listen.  Even if your suggestion is not used immediately,
 it may be used later.
diff --git a/src/3rdparty/libpng/TODO b/src/3rdparty/libpng/TODO
deleted file mode 100644
index 6e1f028..0000000
--- a/src/3rdparty/libpng/TODO
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
-TODO - list of things to do for libpng:
-
-Final bug fixes.
-Better C++ wrapper/full C++ implementation?
-Fix problem with C++ and EXTERN "C".
-cHRM transformation.
-Remove setjmp/longjmp usage in favor of returning error codes.
-Add "grayscale->palette" transformation and "palette->grayscale" detection.
-Improved dithering.
-Multi-lingual error and warning message support.
-Complete sRGB transformation (presently it simply uses gamma=0.45455).
-Man pages for function calls.
-Better documentation.
-Better filter selection
-   (counting huffman bits/precompression?  filter inertia?  filter costs?).
-Histogram creation.
-Text conversion between different code pages (Latin-1 -> Mac and DOS).
-Avoid building gamma tables whenever possible.
-Use greater precision when changing to linear gamma for compositing against
-  background and doing rgb-to-gray transformation.
-Investigate pre-incremented loop counters and other loop constructions.
-Add interpolated method of handling interlacing.
-Switch to the simpler zlib (zlib/libpng) license if legally possible.
-Extend pngvalid.c to validate more of the libpng transformations.
-
-*/
diff --git a/src/3rdparty/libpng/config.guess b/src/3rdparty/libpng/config.guess
deleted file mode 100644
index dc84c68..0000000
--- a/src/3rdparty/libpng/config.guess
+++ /dev/null
@@ -1,1501 +0,0 @@
-#! /bin/sh
-# Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-#   Free Software Foundation, Inc.
-
-timestamp='2009-11-20'
-
-# This file is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner.  Please send patches (context
-# diff format) to <config-patches@gnu.org> and include a ChangeLog
-# entry.
-#
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
-#
-# You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
-
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION]
-
-Output the configuration name of the system \`$me' is run on.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to <config-patches@gnu.org>."
-
-version="\
-GNU config.guess ($timestamp)
-
-Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit ;;
-    --version | -v )
-       echo "$version" ; exit ;;
-    --help | --h* | -h )
-       echo "$usage"; exit ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo "$me: invalid option $1$help" >&2
-       exit 1 ;;
-    * )
-       break ;;
-  esac
-done
-
-if test $# != 0; then
-  echo "$me: too many arguments$help" >&2
-  exit 1
-fi
-
-trap 'exit 1' 1 2 15
-
-# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
-# compiler to aid in system detection is discouraged as it requires
-# temporary files to be created and, as you can see below, it is a
-# headache to deal with in a portable fashion.
-
-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
-# use `HOST_CC' if defined, but it is deprecated.
-
-# Portable tmp directory creation inspired by the Autoconf team.
-
-set_cc_for_build='
-trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
-trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
-: ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
- { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
- { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
-dummy=$tmp/dummy ;
-tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
-case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int x;" > $dummy.c ;
-	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
-	     CC_FOR_BUILD="$c"; break ;
-	  fi ;
-	done ;
-	if test x"$CC_FOR_BUILD" = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ; set_cc_for_build= ;'
-
-# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
-# (ghazi@noc.rutgers.edu 1994-08-24)
-if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
-	PATH=$PATH:/.attbin ; export PATH
-fi
-
-UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
-UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
-UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
-
-# Note: order is significant - the case branches are not exclusive.
-
-case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
-    *:NetBSD:*:*)
-	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
-	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
-	# switched to ELF, *-*-netbsd* would select the old
-	# object file format.  This provides both forward
-	# compatibility and a consistent mechanism for selecting the
-	# object file format.
-	#
-	# Note: NetBSD doesn't particularly care about the vendor
-	# portion of the name.  We always set it to "unknown".
-	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
-	case "${UNAME_MACHINE_ARCH}" in
-	    armeb) machine=armeb-unknown ;;
-	    arm*) machine=arm-unknown ;;
-	    sh3el) machine=shl-unknown ;;
-	    sh3eb) machine=sh-unknown ;;
-	    sh5el) machine=sh5le-unknown ;;
-	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
-	esac
-	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
-	case "${UNAME_MACHINE_ARCH}" in
-	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval $set_cc_for_build
-		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep -q __ELF__
-		then
-		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
-		    # Return netbsd for either.  FIX?
-		    os=netbsd
-		else
-		    os=netbsdelf
-		fi
-		;;
-	    *)
-	        os=netbsd
-		;;
-	esac
-	# The OS release
-	# Debian GNU/NetBSD machines have a different userland, and
-	# thus, need a distinct triplet. However, they do not need
-	# kernel version information, so it can be replaced with a
-	# suitable tag, in the style of linux-gnu.
-	case "${UNAME_VERSION}" in
-	    Debian*)
-		release='-gnu'
-		;;
-	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-		;;
-	esac
-	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
-	# contains redundant information, the shorter form:
-	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
-	exit ;;
-    *:OpenBSD:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
-	exit ;;
-    *:ekkoBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
-	exit ;;
-    *:SolidBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
-	exit ;;
-    macppc:MirBSD:*:*)
-	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
-    *:MirBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
-    alpha:OSF1:*:*)
-	case $UNAME_RELEASE in
-	*4.0)
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-		;;
-	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
-		;;
-	esac
-	# According to Compaq, /usr/sbin/psrinfo has been available on
-	# OSF/1 and Tru64 systems produced since 1995.  I hope that
-	# covers most systems running today.  This code pipes the CPU
-	# types through head -n 1, so we only detect the type of CPU 0.
-	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
-	case "$ALPHA_CPU_TYPE" in
-	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
-	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
-	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
-	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
-	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
-	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
-	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
-	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
-	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
-	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
-	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
-	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
-	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
-	esac
-	# A Pn.n version is a patched version.
-	# A Vn.n version is a released version.
-	# A Tn.n version is a released field test version.
-	# A Xn.n version is an unreleased experimental baselevel.
-	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit ;;
-    Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit ;;
-    21064:Windows_NT:50:3)
-	echo alpha-dec-winnt3.5
-	exit ;;
-    Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
-	exit ;;
-    *:[Aa]miga[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit ;;
-    *:[Mm]orph[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-morphos
-	exit ;;
-    *:OS/390:*:*)
-	echo i370-ibm-openedition
-	exit ;;
-    *:z/VM:*:*)
-	echo s390-ibm-zvmoe
-	exit ;;
-    *:OS400:*:*)
-        echo powerpc-ibm-os400
-	exit ;;
-    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
-	echo arm-unknown-riscos
-	exit ;;
-    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
-	echo hppa1.1-hitachi-hiuxmpp
-	exit ;;
-    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
-	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
-		echo pyramid-pyramid-sysv3
-	else
-		echo pyramid-pyramid-bsd
-	fi
-	exit ;;
-    NILE*:*:*:dcosx)
-	echo pyramid-pyramid-svr4
-	exit ;;
-    DRS?6000:unix:4.0:6*)
-	echo sparc-icl-nx6
-	exit ;;
-    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
-	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7; exit ;;
-	esac ;;
-    s390x:SunOS:*:*)
-	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
-	echo i386-pc-auroraux${UNAME_RELEASE}
-	exit ;;
-    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
-	eval $set_cc_for_build
-	SUN_ARCH="i386"
-	# If there is a compiler, see if it is configured for 64-bit objects.
-	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
-	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		grep IS_64BIT_ARCH >/dev/null
-	    then
-		SUN_ARCH="x86_64"
-	    fi
-	fi
-	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:6*:*)
-	# According to config.sub, this is the proper way to canonicalize
-	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
-	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    sun4*:SunOS:*:*)
-	case "`/usr/bin/arch -k`" in
-	    Series*|S4*)
-		UNAME_RELEASE=`uname -v`
-		;;
-	esac
-	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit ;;
-    sun3*:SunOS:*:*)
-	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit ;;
-    sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
-	case "`/bin/arch`" in
-	    sun3)
-		echo m68k-sun-sunos${UNAME_RELEASE}
-		;;
-	    sun4)
-		echo sparc-sun-sunos${UNAME_RELEASE}
-		;;
-	esac
-	exit ;;
-    aushp:SunOS:*:*)
-	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit ;;
-    # The situation for MiNT is a little confusing.  The machine name
-    # can be virtually everything (everything which is not
-    # "atarist" or "atariste" at least should have a processor
-    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
-    # to the lowercase version "mint" (or "freemint").  Finally
-    # the system name "TOS" denotes a system which is actually not
-    # MiNT.  But MiNT is downward compatible to TOS, so this should
-    # be no problem.
-    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
-    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
-        exit ;;
-    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
-    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit ;;
-    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit ;;
-    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit ;;
-    m68k:machten:*:*)
-	echo m68k-apple-machten${UNAME_RELEASE}
-	exit ;;
-    powerpc:machten:*:*)
-	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit ;;
-    RISC*:Mach:*:*)
-	echo mips-dec-mach_bsd4.3
-	exit ;;
-    RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit ;;
-    VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit ;;
-    2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit ;;
-    mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-#ifdef __cplusplus
-#include <stdio.h>  /* for printf() prototype */
-	int main (int argc, char *argv[]) {
-#else
-	int main (argc, argv) int argc; char *argv[]; {
-#endif
-	#if defined (host_mips) && defined (MIPSEB)
-	#if defined (SYSTYPE_SYSV)
-	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_SVR4)
-	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
-	#endif
-	#endif
-	  exit (-1);
-	}
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c &&
-	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`$dummy $dummyarg` &&
-	    { echo "$SYSTEM_NAME"; exit; }
-	echo mips-mips-riscos${UNAME_RELEASE}
-	exit ;;
-    Motorola:PowerMAX_OS:*:*)
-	echo powerpc-motorola-powermax
-	exit ;;
-    Motorola:*:4.3:PL8-*)
-	echo powerpc-harris-powermax
-	exit ;;
-    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
-	echo powerpc-harris-powermax
-	exit ;;
-    Night_Hawk:Power_UNIX:*:*)
-	echo powerpc-harris-powerunix
-	exit ;;
-    m88k:CX/UX:7*:*)
-	echo m88k-harris-cxux7
-	exit ;;
-    m88k:*:4*:R4*)
-	echo m88k-motorola-sysv4
-	exit ;;
-    m88k:*:3*:R3*)
-	echo m88k-motorola-sysv3
-	exit ;;
-    AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
-	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
-	    then
-		echo m88k-dg-dgux${UNAME_RELEASE}
-	    else
-		echo m88k-dg-dguxbcs${UNAME_RELEASE}
-	    fi
-	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
-	fi
- 	exit ;;
-    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
-	echo m88k-dolphin-sysv3
-	exit ;;
-    M88*:*:R3*:*)
-	# Delta 88k system running SVR3
-	echo m88k-motorola-sysv3
-	exit ;;
-    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
-	echo m88k-tektronix-sysv3
-	exit ;;
-    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
-	echo m68k-tektronix-bsd
-	exit ;;
-    *:IRIX*:*:*)
-	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit ;;
-    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
-    i*86:AIX:*:*)
-	echo i386-ibm-aix
-	exit ;;
-    ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit ;;
-    *:AIX:2:3)
-	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval $set_cc_for_build
-		sed 's/^		//' << EOF >$dummy.c
-		#include <sys/systemcfg.h>
-
-		main()
-			{
-			if (!__power_pc())
-				exit(1);
-			puts("powerpc-ibm-aix3.2.5");
-			exit(0);
-			}
-EOF
-		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
-		then
-			echo "$SYSTEM_NAME"
-		else
-			echo rs6000-ibm-aix3.2.5
-		fi
-	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
-		echo rs6000-ibm-aix3.2.4
-	else
-		echo rs6000-ibm-aix3.2
-	fi
-	exit ;;
-    *:AIX:*:[456])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
-		IBM_ARCH=rs6000
-	else
-		IBM_ARCH=powerpc
-	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit ;;
-    *:AIX:*:*)
-	echo rs6000-ibm-aix
-	exit ;;
-    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
-	echo romp-ibm-bsd4.4
-	exit ;;
-    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit ;;                             # report: romp-ibm BSD 4.3
-    *:BOSX:*:*)
-	echo rs6000-bull-bosx
-	exit ;;
-    DPX/2?00:B.O.S.:*:*)
-	echo m68k-bull-sysv3
-	exit ;;
-    9000/[34]??:4.3bsd:1.*:*)
-	echo m68k-hp-bsd
-	exit ;;
-    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
-	echo m68k-hp-bsd4.4
-	exit ;;
-    9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	case "${UNAME_MACHINE}" in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
-	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
-		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-                    case "${sc_cpu_version}" in
-                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case "${sc_kernel_bits}" in
-                          32) HP_ARCH="hppa2.0n" ;;
-                          64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
-		fi
-		if [ "${HP_ARCH}" = "" ]; then
-		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
-
-              #define _HPUX_SOURCE
-              #include <stdlib.h>
-              #include <unistd.h>
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
-
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
-              	}
-                  exit (0);
-              }
-EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
-		    test -z "$HP_ARCH" && HP_ARCH=hppa
-		fi ;;
-	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
-	then
-	    eval $set_cc_for_build
-
-	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
-	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
-	    # generating 64-bit code.  GNU and HP use different nomenclature:
-	    #
-	    # $ CC_FOR_BUILD=cc ./config.guess
-	    # => hppa2.0w-hp-hpux11.23
-	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
-	    # => hppa64-hp-hpux11.23
-
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
-		grep -q __LP64__
-	    then
-		HP_ARCH="hppa2.0w"
-	    else
-		HP_ARCH="hppa64"
-	    fi
-	fi
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit ;;
-    ia64:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux${HPUX_REV}
-	exit ;;
-    3050*:HI-UX:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <unistd.h>
-	int
-	main ()
-	{
-	  long cpu = sysconf (_SC_CPU_VERSION);
-	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
-	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
-	     results, however.  */
-	  if (CPU_IS_PA_RISC (cpu))
-	    {
-	      switch (cpu)
-		{
-		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
-		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
-		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
-		  default: puts ("hppa-hitachi-hiuxwe2"); break;
-		}
-	    }
-	  else if (CPU_IS_HP_MC68K (cpu))
-	    puts ("m68k-hitachi-hiuxwe2");
-	  else puts ("unknown-hitachi-hiuxwe2");
-	  exit (0);
-	}
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
-		{ echo "$SYSTEM_NAME"; exit; }
-	echo unknown-hitachi-hiuxwe2
-	exit ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
-	echo hppa1.1-hp-bsd
-	exit ;;
-    9000/8??:4.3bsd:*:*)
-	echo hppa1.0-hp-bsd
-	exit ;;
-    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
-	exit ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
-	echo hppa1.1-hp-osf
-	exit ;;
-    hp8??:OSF1:*:*)
-	echo hppa1.0-hp-osf
-	exit ;;
-    i*86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
-	    echo ${UNAME_MACHINE}-unknown-osf1mk
-	else
-	    echo ${UNAME_MACHINE}-unknown-osf1
-	fi
-	exit ;;
-    parisc*:Lites*:*:*)
-	echo hppa1.1-hp-lites
-	exit ;;
-    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
-	echo c1-convex-bsd
-        exit ;;
-    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-        exit ;;
-    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
-	echo c34-convex-bsd
-        exit ;;
-    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
-	echo c38-convex-bsd
-        exit ;;
-    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
-	echo c4-convex-bsd
-        exit ;;
-    CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*[A-Z]90:*:*:*)
-	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
-	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
-	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
-	      -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
-    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit ;;
-    5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit ;;
-    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit ;;
-    sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
-    *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
-    *:FreeBSD:*:*)
-	case ${UNAME_MACHINE} in
-	    pc98)
-		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	    amd64)
-		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	    *)
-		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	esac
-	exit ;;
-    i*:CYGWIN*:*)
-	echo ${UNAME_MACHINE}-pc-cygwin
-	exit ;;
-    *:MINGW*:*)
-	echo ${UNAME_MACHINE}-pc-mingw32
-	exit ;;
-    i*:windows32*:*)
-    	# uname -m includes "-pc" on this system.
-    	echo ${UNAME_MACHINE}-mingw32
-	exit ;;
-    i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
-	exit ;;
-    *:Interix*:*)
-    	case ${UNAME_MACHINE} in
-	    x86)
-		echo i586-pc-interix${UNAME_RELEASE}
-		exit ;;
-	    authenticamd | genuineintel | EM64T)
-		echo x86_64-unknown-interix${UNAME_RELEASE}
-		exit ;;
-	    IA64)
-		echo ia64-unknown-interix${UNAME_RELEASE}
-		exit ;;
-	esac ;;
-    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
-	echo i${UNAME_MACHINE}-pc-mks
-	exit ;;
-    8664:Windows_NT:*)
-	echo x86_64-pc-mks
-	exit ;;
-    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i586-pc-interix
-	exit ;;
-    i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
-	exit ;;
-    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-unknown-cygwin
-	exit ;;
-    p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin
-	exit ;;
-    prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
-    *:GNU:*:*)
-	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit ;;
-    *:GNU/*:*:*)
-	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
-	exit ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
-	exit ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit ;;
-    arm*:Linux:*:*)
-	eval $set_cc_for_build
-	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
-	    | grep -q __ARM_EABI__
-	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
-	else
-	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
-	fi
-	exit ;;
-    avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    cris:Linux:*:*)
-	echo cris-axis-linux-gnu
-	exit ;;
-    crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
-	exit ;;
-    frv:Linux:*:*)
-    	echo frv-unknown-linux-gnu
-	exit ;;
-    i*86:Linux:*:*)
-	LIBC=gnu
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
-	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
-	exit ;;
-    ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    mips:Linux:*:* | mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef ${UNAME_MACHINE}
-	#undef ${UNAME_MACHINE}el
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=${UNAME_MACHINE}el
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=${UNAME_MACHINE}
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
-	;;
-    or32:Linux:*:*)
-	echo or32-unknown-linux-gnu
-	exit ;;
-    padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
-	exit ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
-	exit ;;
-    parisc:Linux:*:* | hppa:Linux:*:*)
-	# Look for CPU level
-	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
-	esac
-	exit ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit ;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit ;;
-    s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
-	exit ;;
-    sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
-	exit ;;
-    x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
-	exit ;;
-    xtensa*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    i*86:DYNIX/ptx:4*:*)
-	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
-	# earlier versions are messed up and put the nodename in both
-	# sysname and nodename.
-	echo i386-sequent-sysv4
-	exit ;;
-    i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
-	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
-	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit ;;
-    i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
-	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit ;;
-    i*86:XTS-300:*:STOP)
-	echo ${UNAME_MACHINE}-unknown-stop
-	exit ;;
-    i*86:atheos:*:*)
-	echo ${UNAME_MACHINE}-unknown-atheos
-	exit ;;
-    i*86:syllable:*:*)
-	echo ${UNAME_MACHINE}-pc-syllable
-	exit ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit ;;
-    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
-	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
-	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
-	fi
-	exit ;;
-    i*86:*:5:[678]*)
-    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
-	case `/bin/uname -X | grep "^Machine"` in
-	    *486*)	     UNAME_MACHINE=i486 ;;
-	    *Pentium)	     UNAME_MACHINE=i586 ;;
-	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
-	esac
-	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit ;;
-    i*86:*:3.2:*)
-	if test -f /usr/options/cb.name; then
-		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
-	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
-		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
-		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
-			&& UNAME_MACHINE=i586
-		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
-			&& UNAME_MACHINE=i686
-		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
-			&& UNAME_MACHINE=i686
-		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
-	else
-		echo ${UNAME_MACHINE}-pc-sysv32
-	fi
-	exit ;;
-    pc:*:*:*)
-	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i586.
-	# Note: whatever this is, it MUST be the same as what config.sub
-	# prints for the "djgpp" host, or else GDB configury will decide that
-	# this is a cross-build.
-	echo i586-pc-msdosdjgpp
-        exit ;;
-    Intel:Mach:3*:*)
-	echo i386-pc-mach3
-	exit ;;
-    paragon:*:*:*)
-	echo i860-intel-osf1
-	exit ;;
-    i860:*:4.*:*) # i860-SVR4
-	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
-	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
-	fi
-	exit ;;
-    mini*:CTIX:SYS*5:*)
-	# "miniframe"
-	echo m68010-convergent-sysv
-	exit ;;
-    mc68k:UNIX:SYSTEM5:3.51m)
-	echo m68k-convergent-sysv
-	exit ;;
-    M680?0:D-NIX:5.3:*)
-	echo m68k-diab-dnix
-	exit ;;
-    M68*:*:R3V[5678]*:*)
-	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
-    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
-	OS_REL=''
-	test -r /etc/.relid \
-	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
-	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
-	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
-    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && { echo i486-ncr-sysv4; exit; } ;;
-    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
-	OS_REL='.3'
-	test -r /etc/.relid \
-	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
-	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
-	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
-	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
-	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
-    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit ;;
-    TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
-	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv${UNAME_RELEASE}
-	exit ;;
-    RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
-    RM*:SINIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
-    *:SINIX-*:*:*)
-	if uname -p 2>/dev/null >/dev/null ; then
-		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo ${UNAME_MACHINE}-sni-sysv4
-	else
-		echo ns32k-sni-sysv
-	fi
-	exit ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel@ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit ;;
-    *:UNIX_System_V:4*:FTX*)
-	# From Gerald Hewes <hewes@openmarket.com>.
-	# How about differentiating between stratus architectures? -djm
-	echo hppa1.1-stratus-sysv4
-	exit ;;
-    *:*:*:FTX*)
-	# From seanf@swdc.stratus.com.
-	echo i860-stratus-sysv4
-	exit ;;
-    i*86:VOS:*:*)
-	# From Paul.Green@stratus.com.
-	echo ${UNAME_MACHINE}-stratus-vos
-	exit ;;
-    *:VOS:*:*)
-	# From Paul.Green@stratus.com.
-	echo hppa1.1-stratus-vos
-	exit ;;
-    mc68*:A/UX:*:*)
-	echo m68k-apple-aux${UNAME_RELEASE}
-	exit ;;
-    news*:NEWS-OS:6*:*)
-	echo mips-sony-newsos6
-	exit ;;
-    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
-	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
-	fi
-        exit ;;
-    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
-	exit ;;
-    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
-	echo powerpc-apple-beos
-	exit ;;
-    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
-	echo i586-pc-beos
-	exit ;;
-    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
-	echo i586-pc-haiku
-	exit ;;
-    SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-7:SUPER-UX:*:*)
-	echo sx7-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-8:SUPER-UX:*:*)
-	echo sx8-nec-superux${UNAME_RELEASE}
-	exit ;;
-    SX-8R:SUPER-UX:*:*)
-	echo sx8r-nec-superux${UNAME_RELEASE}
-	exit ;;
-    Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
-    *:Rhapsody:*:*)
-	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
-    *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
-	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit ;;
-    *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
-		UNAME_PROCESSOR=i386
-		UNAME_MACHINE=pc
-	fi
-	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit ;;
-    *:QNX:*:4*)
-	echo i386-pc-qnx
-	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk${UNAME_RELEASE}
-	exit ;;
-    NSR-?:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit ;;
-    *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit ;;
-    BS2000:POSIX*:*:*)
-	echo bs2000-siemens-sysv
-	exit ;;
-    DS/*:UNIX_System_V:*:*)
-	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit ;;
-    *:Plan9:*:*)
-	# "uname -m" is not consistent, so use $cputype instead. 386
-	# is converted to i386 for consistency with other x86
-	# operating systems.
-	if test "$cputype" = "386"; then
-	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE="$cputype"
-	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
-	exit ;;
-    *:TOPS-10:*:*)
-	echo pdp10-unknown-tops10
-	exit ;;
-    *:TENEX:*:*)
-	echo pdp10-unknown-tenex
-	exit ;;
-    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
-	echo pdp10-dec-tops20
-	exit ;;
-    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
-	echo pdp10-xkl-tops20
-	exit ;;
-    *:TOPS-20:*:*)
-	echo pdp10-unknown-tops20
-	exit ;;
-    *:ITS:*:*)
-	echo pdp10-unknown-its
-	exit ;;
-    SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
-	exit ;;
-    *:DragonFly:*:*)
-	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit ;;
-    *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "${UNAME_MACHINE}" in
-	    A*) echo alpha-dec-vms ; exit ;;
-	    I*) echo ia64-dec-vms ; exit ;;
-	    V*) echo vax-dec-vms ; exit ;;
-	esac ;;
-    *:XENIX:*:SysV)
-	echo i386-pc-xenix
-	exit ;;
-    i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
-	exit ;;
-    i*86:rdos:*:*)
-	echo ${UNAME_MACHINE}-pc-rdos
-	exit ;;
-    i*86:AROS:*:*)
-	echo ${UNAME_MACHINE}-pc-aros
-	exit ;;
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-          "4"
-#else
-	  ""
-#endif
-         ); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
-
-cat >&2 <<EOF
-$0: unable to guess system type
-
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
-
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
-and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
-
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
-
-config.guess timestamp = $timestamp
-
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
-
-hostinfo               = `(hostinfo) 2>/dev/null`
-/bin/universe          = `(/bin/universe) 2>/dev/null`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
-/bin/arch              = `(/bin/arch) 2>/dev/null`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
-
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
-EOF
-
-exit 1
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "timestamp='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:
diff --git a/src/3rdparty/libpng/config.h.in b/src/3rdparty/libpng/config.h.in
deleted file mode 100644
index fb23495..0000000
--- a/src/3rdparty/libpng/config.h.in
+++ /dev/null
@@ -1,86 +0,0 @@
-/* config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#undef HAVE_DLFCN_H
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
-/* Define to 1 if you have the `m' library (-lm). */
-#undef HAVE_LIBM
-
-/* Define to 1 if you have the `z' library (-lz). */
-#undef HAVE_LIBZ
-
-/* Define to 1 if you have the <malloc.h> header file. */
-#undef HAVE_MALLOC_H
-
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
-/* Define to 1 if you have the `memset' function. */
-#undef HAVE_MEMSET
-
-/* Define to 1 if you have the `pow' function. */
-#undef HAVE_POW
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
-#undef LT_OBJDIR
-
-/* Name of package */
-#undef PACKAGE
-
-/* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
-
-/* Define to the full name of this package. */
-#undef PACKAGE_NAME
-
-/* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
-
-/* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
-
-/* Define to the home page for this package. */
-#undef PACKAGE_URL
-
-/* Define to the version of this package. */
-#undef PACKAGE_VERSION
-
-/* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
-
-/* Define to 1 if your <sys/time.h> declares `struct tm'. */
-#undef TM_IN_SYS_TIME
-
-/* Version number of package */
-#undef VERSION
-
-/* Define to empty if `const' does not conform to ANSI C. */
-#undef const
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-#undef size_t
diff --git a/src/3rdparty/libpng/config.sub b/src/3rdparty/libpng/config.sub
deleted file mode 100644
index 2a55a50..0000000
--- a/src/3rdparty/libpng/config.sub
+++ /dev/null
@@ -1,1705 +0,0 @@
-#! /bin/sh
-# Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-#   Free Software Foundation, Inc.
-
-timestamp='2009-11-20'
-
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted GNU ChangeLog entry.
-#
-# Configuration subroutine to validate and canonicalize a configuration type.
-# Supply the specified configuration type as an argument.
-# If it is invalid, we print an error message on stderr and exit with code 1.
-# Otherwise, we print the canonical config type on stdout and succeed.
-
-# You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
-
-# This file is supposed to be the same for all GNU packages
-# and recognize all the CPU types, system types and aliases
-# that are meaningful with *any* GNU software.
-# Each package is responsible for reporting which valid configurations
-# it does not support.  The user should be able to distinguish
-# a failure to support a valid configuration from a meaningless
-# configuration.
-
-# The goal of this file is to map all the various variations of a given
-# machine specification into a single specification in the form:
-#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
-# or in some cases, the newer four-part form:
-#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
-# It is wrong to echo any other type of specification.
-
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
-
-Canonicalize a configuration name.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to <config-patches@gnu.org>."
-
-version="\
-GNU config.sub ($timestamp)
-
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit ;;
-    --version | -v )
-       echo "$version" ; exit ;;
-    --help | --h* | -h )
-       echo "$usage"; exit ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo "$me: invalid option $1$help"
-       exit 1 ;;
-
-    *local*)
-       # First pass through any local machine types.
-       echo $1
-       exit ;;
-
-    * )
-       break ;;
-  esac
-done
-
-case $# in
- 0) echo "$me: missing argument$help" >&2
-    exit 1;;
- 1) ;;
- *) echo "$me: too many arguments$help" >&2
-    exit 1;;
-esac
-
-# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
-# Here we must recognize all the valid KERNEL-OS combinations.
-maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
-case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
-  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
-  kopensolaris*-gnu* | \
-  storm-chaos* | os2-emx* | rtmk-nova*)
-    os=-$maybe_os
-    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
-    ;;
-  *)
-    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
-    if [ $basic_machine != $1 ]
-    then os=`echo $1 | sed 's/.*-/-/'`
-    else os=; fi
-    ;;
-esac
-
-### Let's recognize common machines as not being operating systems so
-### that things like config.sub decstation-3100 work.  We also
-### recognize some manufacturers as not being operating systems, so we
-### can provide default operating systems below.
-case $os in
-	-sun*os*)
-		# Prevent following clause from handling this invalid input.
-		;;
-	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
-	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
-	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
-	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
-	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
-	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray | -microblaze)
-		os=
-		basic_machine=$1
-		;;
-        -bluegene*)
-	        os=-cnk
-		;;
-	-sim | -cisco | -oki | -wec | -winbond)
-		os=
-		basic_machine=$1
-		;;
-	-scout)
-		;;
-	-wrs)
-		os=-vxworks
-		basic_machine=$1
-		;;
-	-chorusos*)
-		os=-chorusos
-		basic_machine=$1
-		;;
- 	-chorusrdb)
- 		os=-chorusrdb
-		basic_machine=$1
- 		;;
-	-hiux*)
-		os=-hiuxwe2
-		;;
-	-sco6)
-		os=-sco5v6
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco5)
-		os=-sco3.2v5
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco4)
-		os=-sco3.2v4
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2v[4-9]*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco5v6*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco*)
-		os=-sco3.2v2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-udk*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-isc)
-		os=-isc2.2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-clix*)
-		basic_machine=clipper-intergraph
-		;;
-	-isc*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-lynx*)
-		os=-lynxos
-		;;
-	-ptx*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
-		;;
-	-windowsnt*)
-		os=`echo $os | sed -e 's/windowsnt/winnt/'`
-		;;
-	-psos*)
-		os=-psos
-		;;
-	-mint | -mint[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-esac
-
-# Decode aliases for certain CPU-COMPANY combinations.
-case $basic_machine in
-	# Recognize the basic CPU types without company name.
-	# Some are omitted here because they have special meanings below.
-	1750a | 580 \
-	| a29k \
-	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
-	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
-	| bfin \
-	| c4x | clipper \
-	| d10v | d30v | dlx | dsp16xx \
-	| fido | fr30 | frv \
-	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
-	| i370 | i860 | i960 | ia64 \
-	| ip2k | iq2000 \
-	| lm32 \
-	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
-	| mips | mipsbe | mipseb | mipsel | mipsle \
-	| mips16 \
-	| mips64 | mips64el \
-	| mips64octeon | mips64octeonel \
-	| mips64orion | mips64orionel \
-	| mips64r5900 | mips64r5900el \
-	| mips64vr | mips64vrel \
-	| mips64vr4100 | mips64vr4100el \
-	| mips64vr4300 | mips64vr4300el \
-	| mips64vr5000 | mips64vr5000el \
-	| mips64vr5900 | mips64vr5900el \
-	| mipsisa32 | mipsisa32el \
-	| mipsisa32r2 | mipsisa32r2el \
-	| mipsisa64 | mipsisa64el \
-	| mipsisa64r2 | mipsisa64r2el \
-	| mipsisa64sb1 | mipsisa64sb1el \
-	| mipsisa64sr71k | mipsisa64sr71kel \
-	| mipstx39 | mipstx39el \
-	| mn10200 | mn10300 \
-	| moxie \
-	| mt \
-	| msp430 \
-	| nios | nios2 \
-	| ns16k | ns32k \
-	| or32 \
-	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
-	| pyramid \
-	| rx \
-	| score \
-	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
-	| sh64 | sh64le \
-	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
-	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
-	| spu | strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
-	| ubicom32 \
-	| v850 | v850e \
-	| we32k \
-	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
-	| z8k | z80)
-		basic_machine=$basic_machine-unknown
-		;;
-	m6811 | m68hc11 | m6812 | m68hc12 | picochip)
-		# Motorola 68HC11/12.
-		basic_machine=$basic_machine-unknown
-		os=-none
-		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
-		;;
-	ms1)
-		basic_machine=mt-unknown
-		;;
-
-	# We use `pc' rather than `unknown'
-	# because (1) that's what they normally are, and
-	# (2) the word "unknown" tends to confuse beginning users.
-	i*86 | x86_64)
-	  basic_machine=$basic_machine-pc
-	  ;;
-	# Object if more than one company name word.
-	*-*-*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
-		;;
-	# Recognize the basic CPU types with company name.
-	580-* \
-	| a29k-* \
-	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
-	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
-	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* | avr32-* \
-	| bfin-* | bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | craynv-* | cydra-* \
-	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
-	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
-	| h8300-* | h8500-* \
-	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
-	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* | iq2000-* \
-	| lm32-* \
-	| m32c-* | m32r-* | m32rle-* \
-	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
-	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
-	| mips16-* \
-	| mips64-* | mips64el-* \
-	| mips64octeon-* | mips64octeonel-* \
-	| mips64orion-* | mips64orionel-* \
-	| mips64r5900-* | mips64r5900el-* \
-	| mips64vr-* | mips64vrel-* \
-	| mips64vr4100-* | mips64vr4100el-* \
-	| mips64vr4300-* | mips64vr4300el-* \
-	| mips64vr5000-* | mips64vr5000el-* \
-	| mips64vr5900-* | mips64vr5900el-* \
-	| mipsisa32-* | mipsisa32el-* \
-	| mipsisa32r2-* | mipsisa32r2el-* \
-	| mipsisa64-* | mipsisa64el-* \
-	| mipsisa64r2-* | mipsisa64r2el-* \
-	| mipsisa64sb1-* | mipsisa64sb1el-* \
-	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
-	| mipstx39-* | mipstx39el-* \
-	| mmix-* \
-	| mt-* \
-	| msp430-* \
-	| nios-* | nios2-* \
-	| none-* | np1-* | ns16k-* | ns32k-* \
-	| orion-* \
-	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
-	| pyramid-* \
-	| romp-* | rs6000-* | rx-* \
-	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
-	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
-	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* \
-	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* | tile-* \
-	| tron-* \
-	| ubicom32-* \
-	| v850-* | v850e-* | vax-* \
-	| we32k-* \
-	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
-	| xstormy16-* | xtensa*-* \
-	| ymp-* \
-	| z8k-* | z80-*)
-		;;
-	# Recognize the basic CPU types without company name, with glob match.
-	xtensa*)
-		basic_machine=$basic_machine-unknown
-		;;
-	# Recognize the various machine names and aliases which stand
-	# for a CPU type and a company and sometimes even an OS.
-	386bsd)
-		basic_machine=i386-unknown
-		os=-bsd
-		;;
-	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
-		basic_machine=m68000-att
-		;;
-	3b*)
-		basic_machine=we32k-att
-		;;
-	a29khif)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-    	abacus)
-		basic_machine=abacus-unknown
-		;;
-	adobe68k)
-		basic_machine=m68010-adobe
-		os=-scout
-		;;
-	alliant | fx80)
-		basic_machine=fx80-alliant
-		;;
-	altos | altos3068)
-		basic_machine=m68k-altos
-		;;
-	am29k)
-		basic_machine=a29k-none
-		os=-bsd
-		;;
-	amd64)
-		basic_machine=x86_64-pc
-		;;
-	amd64-*)
-		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	amdahl)
-		basic_machine=580-amdahl
-		os=-sysv
-		;;
-	amiga | amiga-*)
-		basic_machine=m68k-unknown
-		;;
-	amigaos | amigados)
-		basic_machine=m68k-unknown
-		os=-amigaos
-		;;
-	amigaunix | amix)
-		basic_machine=m68k-unknown
-		os=-sysv4
-		;;
-	apollo68)
-		basic_machine=m68k-apollo
-		os=-sysv
-		;;
-	apollo68bsd)
-		basic_machine=m68k-apollo
-		os=-bsd
-		;;
-	aros)
-		basic_machine=i386-pc
-		os=-aros
-		;;
-	aux)
-		basic_machine=m68k-apple
-		os=-aux
-		;;
-	balance)
-		basic_machine=ns32k-sequent
-		os=-dynix
-		;;
-	blackfin)
-		basic_machine=bfin-unknown
-		os=-linux
-		;;
-	blackfin-*)
-		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
-		;;
-	bluegene*)
-		basic_machine=powerpc-ibm
-		os=-cnk
-		;;
-	c90)
-		basic_machine=c90-cray
-		os=-unicos
-		;;
-        cegcc)
-		basic_machine=arm-unknown
-		os=-cegcc
-		;;
-	convex-c1)
-		basic_machine=c1-convex
-		os=-bsd
-		;;
-	convex-c2)
-		basic_machine=c2-convex
-		os=-bsd
-		;;
-	convex-c32)
-		basic_machine=c32-convex
-		os=-bsd
-		;;
-	convex-c34)
-		basic_machine=c34-convex
-		os=-bsd
-		;;
-	convex-c38)
-		basic_machine=c38-convex
-		os=-bsd
-		;;
-	cray | j90)
-		basic_machine=j90-cray
-		os=-unicos
-		;;
-	craynv)
-		basic_machine=craynv-cray
-		os=-unicosmp
-		;;
-	cr16)
-		basic_machine=cr16-unknown
-		os=-elf
-		;;
-	crds | unos)
-		basic_machine=m68k-crds
-		;;
-	crisv32 | crisv32-* | etraxfs*)
-		basic_machine=crisv32-axis
-		;;
-	cris | cris-* | etrax*)
-		basic_machine=cris-axis
-		;;
-	crx)
-		basic_machine=crx-unknown
-		os=-elf
-		;;
-	da30 | da30-*)
-		basic_machine=m68k-da30
-		;;
-	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
-		basic_machine=mips-dec
-		;;
-	decsystem10* | dec10*)
-		basic_machine=pdp10-dec
-		os=-tops10
-		;;
-	decsystem20* | dec20*)
-		basic_machine=pdp10-dec
-		os=-tops20
-		;;
-	delta | 3300 | motorola-3300 | motorola-delta \
-	      | 3300-motorola | delta-motorola)
-		basic_machine=m68k-motorola
-		;;
-	delta88)
-		basic_machine=m88k-motorola
-		os=-sysv3
-		;;
-	dicos)
-		basic_machine=i686-pc
-		os=-dicos
-		;;
-	djgpp)
-		basic_machine=i586-pc
-		os=-msdosdjgpp
-		;;
-	dpx20 | dpx20-*)
-		basic_machine=rs6000-bull
-		os=-bosx
-		;;
-	dpx2* | dpx2*-bull)
-		basic_machine=m68k-bull
-		os=-sysv3
-		;;
-	ebmon29k)
-		basic_machine=a29k-amd
-		os=-ebmon
-		;;
-	elxsi)
-		basic_machine=elxsi-elxsi
-		os=-bsd
-		;;
-	encore | umax | mmax)
-		basic_machine=ns32k-encore
-		;;
-	es1800 | OSE68k | ose68k | ose | OSE)
-		basic_machine=m68k-ericsson
-		os=-ose
-		;;
-	fx2800)
-		basic_machine=i860-alliant
-		;;
-	genix)
-		basic_machine=ns32k-ns
-		;;
-	gmicro)
-		basic_machine=tron-gmicro
-		os=-sysv
-		;;
-	go32)
-		basic_machine=i386-pc
-		os=-go32
-		;;
-	h3050r* | hiux*)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	h8300hms)
-		basic_machine=h8300-hitachi
-		os=-hms
-		;;
-	h8300xray)
-		basic_machine=h8300-hitachi
-		os=-xray
-		;;
-	h8500hms)
-		basic_machine=h8500-hitachi
-		os=-hms
-		;;
-	harris)
-		basic_machine=m88k-harris
-		os=-sysv3
-		;;
-	hp300-*)
-		basic_machine=m68k-hp
-		;;
-	hp300bsd)
-		basic_machine=m68k-hp
-		os=-bsd
-		;;
-	hp300hpux)
-		basic_machine=m68k-hp
-		os=-hpux
-		;;
-	hp3k9[0-9][0-9] | hp9[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k2[0-9][0-9] | hp9k31[0-9])
-		basic_machine=m68000-hp
-		;;
-	hp9k3[2-9][0-9])
-		basic_machine=m68k-hp
-		;;
-	hp9k6[0-9][0-9] | hp6[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k7[0-79][0-9] | hp7[0-79][0-9])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k78[0-9] | hp78[0-9])
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][13679] | hp8[0-9][13679])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][0-9] | hp8[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hppa-next)
-		os=-nextstep3
-		;;
-	hppaosf)
-		basic_machine=hppa1.1-hp
-		os=-osf
-		;;
-	hppro)
-		basic_machine=hppa1.1-hp
-		os=-proelf
-		;;
-	i370-ibm* | ibm*)
-		basic_machine=i370-ibm
-		;;
-# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
-	i*86v32)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv32
-		;;
-	i*86v4*)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv4
-		;;
-	i*86v)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv
-		;;
-	i*86sol2)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-solaris2
-		;;
-	i386mach)
-		basic_machine=i386-mach
-		os=-mach
-		;;
-	i386-vsta | vsta)
-		basic_machine=i386-unknown
-		os=-vsta
-		;;
-	iris | iris4d)
-		basic_machine=mips-sgi
-		case $os in
-		    -irix*)
-			;;
-		    *)
-			os=-irix4
-			;;
-		esac
-		;;
-	isi68 | isi)
-		basic_machine=m68k-isi
-		os=-sysv
-		;;
-	m68knommu)
-		basic_machine=m68k-unknown
-		os=-linux
-		;;
-	m68knommu-*)
-		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
-		;;
-	m88k-omron*)
-		basic_machine=m88k-omron
-		;;
-	magnum | m3230)
-		basic_machine=mips-mips
-		os=-sysv
-		;;
-	merlin)
-		basic_machine=ns32k-utek
-		os=-sysv
-		;;
-        microblaze)
-		basic_machine=microblaze-xilinx
-		;;
-	mingw32)
-		basic_machine=i386-pc
-		os=-mingw32
-		;;
-	mingw32ce)
-		basic_machine=arm-unknown
-		os=-mingw32ce
-		;;
-	miniframe)
-		basic_machine=m68000-convergent
-		;;
-	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-	mips3*-*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
-		;;
-	mips3*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
-		;;
-	monitor)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	morphos)
-		basic_machine=powerpc-unknown
-		os=-morphos
-		;;
-	msdos)
-		basic_machine=i386-pc
-		os=-msdos
-		;;
-	ms1-*)
-		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
-		;;
-	mvs)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
-	ncr3000)
-		basic_machine=i486-ncr
-		os=-sysv4
-		;;
-	netbsd386)
-		basic_machine=i386-unknown
-		os=-netbsd
-		;;
-	netwinder)
-		basic_machine=armv4l-rebel
-		os=-linux
-		;;
-	news | news700 | news800 | news900)
-		basic_machine=m68k-sony
-		os=-newsos
-		;;
-	news1000)
-		basic_machine=m68030-sony
-		os=-newsos
-		;;
-	news-3600 | risc-news)
-		basic_machine=mips-sony
-		os=-newsos
-		;;
-	necv70)
-		basic_machine=v70-nec
-		os=-sysv
-		;;
-	next | m*-next )
-		basic_machine=m68k-next
-		case $os in
-		    -nextstep* )
-			;;
-		    -ns2*)
-		      os=-nextstep2
-			;;
-		    *)
-		      os=-nextstep3
-			;;
-		esac
-		;;
-	nh3000)
-		basic_machine=m68k-harris
-		os=-cxux
-		;;
-	nh[45]000)
-		basic_machine=m88k-harris
-		os=-cxux
-		;;
-	nindy960)
-		basic_machine=i960-intel
-		os=-nindy
-		;;
-	mon960)
-		basic_machine=i960-intel
-		os=-mon960
-		;;
-	nonstopux)
-		basic_machine=mips-compaq
-		os=-nonstopux
-		;;
-	np1)
-		basic_machine=np1-gould
-		;;
-	nsr-tandem)
-		basic_machine=nsr-tandem
-		;;
-	op50n-* | op60c-*)
-		basic_machine=hppa1.1-oki
-		os=-proelf
-		;;
-	openrisc | openrisc-*)
-		basic_machine=or32-unknown
-		;;
-	os400)
-		basic_machine=powerpc-ibm
-		os=-os400
-		;;
-	OSE68000 | ose68000)
-		basic_machine=m68000-ericsson
-		os=-ose
-		;;
-	os68k)
-		basic_machine=m68k-none
-		os=-os68k
-		;;
-	pa-hitachi)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	paragon)
-		basic_machine=i860-intel
-		os=-osf
-		;;
-	parisc)
-		basic_machine=hppa-unknown
-		os=-linux
-		;;
-	parisc-*)
-		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
-		;;
-	pbd)
-		basic_machine=sparc-tti
-		;;
-	pbb)
-		basic_machine=m68k-tti
-		;;
-	pc532 | pc532-*)
-		basic_machine=ns32k-pc532
-		;;
-	pc98)
-		basic_machine=i386-pc
-		;;
-	pc98-*)
-		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentium | p5 | k5 | k6 | nexgen | viac3)
-		basic_machine=i586-pc
-		;;
-	pentiumpro | p6 | 6x86 | athlon | athlon_*)
-		basic_machine=i686-pc
-		;;
-	pentiumii | pentium2 | pentiumiii | pentium3)
-		basic_machine=i686-pc
-		;;
-	pentium4)
-		basic_machine=i786-pc
-		;;
-	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
-		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentium4-*)
-		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pn)
-		basic_machine=pn-gould
-		;;
-	power)	basic_machine=power-ibm
-		;;
-	ppc)	basic_machine=powerpc-unknown
-		;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
-		basic_machine=powerpcle-unknown
-		;;
-	ppcle-* | powerpclittle-*)
-		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64)	basic_machine=powerpc64-unknown
-		;;
-	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
-		basic_machine=powerpc64le-unknown
-		;;
-	ppc64le-* | powerpc64little-*)
-		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ps2)
-		basic_machine=i386-ibm
-		;;
-	pw32)
-		basic_machine=i586-unknown
-		os=-pw32
-		;;
-	rdos)
-		basic_machine=i386-pc
-		os=-rdos
-		;;
-	rom68k)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	rm[46]00)
-		basic_machine=mips-siemens
-		;;
-	rtpc | rtpc-*)
-		basic_machine=romp-ibm
-		;;
-	s390 | s390-*)
-		basic_machine=s390-ibm
-		;;
-	s390x | s390x-*)
-		basic_machine=s390x-ibm
-		;;
-	sa29200)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	sb1)
-		basic_machine=mipsisa64sb1-unknown
-		;;
-	sb1el)
-		basic_machine=mipsisa64sb1el-unknown
-		;;
-	sde)
-		basic_machine=mipsisa32-sde
-		os=-elf
-		;;
-	sei)
-		basic_machine=mips-sei
-		os=-seiux
-		;;
-	sequent)
-		basic_machine=i386-sequent
-		;;
-	sh)
-		basic_machine=sh-hitachi
-		os=-hms
-		;;
-	sh5el)
-		basic_machine=sh5le-unknown
-		;;
-	sh64)
-		basic_machine=sh64-unknown
-		;;
-	sparclite-wrs | simso-wrs)
-		basic_machine=sparclite-wrs
-		os=-vxworks
-		;;
-	sps7)
-		basic_machine=m68k-bull
-		os=-sysv2
-		;;
-	spur)
-		basic_machine=spur-unknown
-		;;
-	st2000)
-		basic_machine=m68k-tandem
-		;;
-	stratus)
-		basic_machine=i860-stratus
-		os=-sysv4
-		;;
-	sun2)
-		basic_machine=m68000-sun
-		;;
-	sun2os3)
-		basic_machine=m68000-sun
-		os=-sunos3
-		;;
-	sun2os4)
-		basic_machine=m68000-sun
-		os=-sunos4
-		;;
-	sun3os3)
-		basic_machine=m68k-sun
-		os=-sunos3
-		;;
-	sun3os4)
-		basic_machine=m68k-sun
-		os=-sunos4
-		;;
-	sun4os3)
-		basic_machine=sparc-sun
-		os=-sunos3
-		;;
-	sun4os4)
-		basic_machine=sparc-sun
-		os=-sunos4
-		;;
-	sun4sol2)
-		basic_machine=sparc-sun
-		os=-solaris2
-		;;
-	sun3 | sun3-*)
-		basic_machine=m68k-sun
-		;;
-	sun4)
-		basic_machine=sparc-sun
-		;;
-	sun386 | sun386i | roadrunner)
-		basic_machine=i386-sun
-		;;
-	sv1)
-		basic_machine=sv1-cray
-		os=-unicos
-		;;
-	symmetry)
-		basic_machine=i386-sequent
-		os=-dynix
-		;;
-	t3e)
-		basic_machine=alphaev5-cray
-		os=-unicos
-		;;
-	t90)
-		basic_machine=t90-cray
-		os=-unicos
-		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
-	tic55x | c55x*)
-		basic_machine=tic55x-unknown
-		os=-coff
-		;;
-	tic6x | c6x*)
-		basic_machine=tic6x-unknown
-		os=-coff
-		;;
-	tile*)
-		basic_machine=tile-unknown
-		os=-linux-gnu
-		;;
-	tx39)
-		basic_machine=mipstx39-unknown
-		;;
-	tx39el)
-		basic_machine=mipstx39el-unknown
-		;;
-	toad1)
-		basic_machine=pdp10-xkl
-		os=-tops20
-		;;
-	tower | tower-32)
-		basic_machine=m68k-ncr
-		;;
-	tpf)
-		basic_machine=s390x-ibm
-		os=-tpf
-		;;
-	udi29k)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	ultra3)
-		basic_machine=a29k-nyu
-		os=-sym1
-		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
-		;;
-	vaxv)
-		basic_machine=vax-dec
-		os=-sysv
-		;;
-	vms)
-		basic_machine=vax-dec
-		os=-vms
-		;;
-	vpp*|vx|vx-*)
-		basic_machine=f301-fujitsu
-		;;
-	vxworks960)
-		basic_machine=i960-wrs
-		os=-vxworks
-		;;
-	vxworks68)
-		basic_machine=m68k-wrs
-		os=-vxworks
-		;;
-	vxworks29k)
-		basic_machine=a29k-wrs
-		os=-vxworks
-		;;
-	w65*)
-		basic_machine=w65-wdc
-		os=-none
-		;;
-	w89k-*)
-		basic_machine=hppa1.1-winbond
-		os=-proelf
-		;;
-	xbox)
-		basic_machine=i686-pc
-		os=-mingw32
-		;;
-	xps | xps100)
-		basic_machine=xps100-honeywell
-		;;
-	ymp)
-		basic_machine=ymp-cray
-		os=-unicos
-		;;
-	z8k-*-coff)
-		basic_machine=z8k-unknown
-		os=-sim
-		;;
-	z80-*-coff)
-		basic_machine=z80-unknown
-		os=-sim
-		;;
-	none)
-		basic_machine=none-none
-		os=-none
-		;;
-
-# Here we handle the default manufacturer of certain CPU types.  It is in
-# some cases the only manufacturer, in others, it is the most popular.
-	w89k)
-		basic_machine=hppa1.1-winbond
-		;;
-	op50n)
-		basic_machine=hppa1.1-oki
-		;;
-	op60c)
-		basic_machine=hppa1.1-oki
-		;;
-	romp)
-		basic_machine=romp-ibm
-		;;
-	mmix)
-		basic_machine=mmix-knuth
-		;;
-	rs6000)
-		basic_machine=rs6000-ibm
-		;;
-	vax)
-		basic_machine=vax-dec
-		;;
-	pdp10)
-		# there are many clones, so DEC is not a safe bet
-		basic_machine=pdp10-unknown
-		;;
-	pdp11)
-		basic_machine=pdp11-dec
-		;;
-	we32k)
-		basic_machine=we32k-att
-		;;
-	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
-		basic_machine=sh-unknown
-		;;
-	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
-		basic_machine=sparc-sun
-		;;
-	cydra)
-		basic_machine=cydra-cydrome
-		;;
-	orion)
-		basic_machine=orion-highlevel
-		;;
-	orion105)
-		basic_machine=clipper-highlevel
-		;;
-	mac | mpw | mac-mpw)
-		basic_machine=m68k-apple
-		;;
-	pmac | pmac-mpw)
-		basic_machine=powerpc-apple
-		;;
-	*-unknown)
-		# Make sure to match an already-canonicalized machine name.
-		;;
-	*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
-		;;
-esac
-
-# Here we canonicalize certain aliases for manufacturers.
-case $basic_machine in
-	*-digital*)
-		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
-		;;
-	*-commodore*)
-		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
-		;;
-	*)
-		;;
-esac
-
-# Decode manufacturer-specific aliases for certain operating systems.
-
-if [ x"$os" != x"" ]
-then
-case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
-	# -solaris* is a basic system type, with this one exception.
-        -auroraux)
-	        os=-auroraux
-		;;
-	-solaris1 | -solaris1.*)
-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
-		;;
-	-solaris)
-		os=-solaris2
-		;;
-	-svr4*)
-		os=-sysv4
-		;;
-	-unixware*)
-		os=-sysv4.2uw
-		;;
-	-gnu/linux*)
-		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
-		;;
-	# First accept the basic system types.
-	# The portable systems comes first.
-	# Each alternative MUST END IN A *, to match a version number.
-	# -sysv* is not here because it comes later, after sysvr4.
-	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
-	      | -sym* | -kopensolaris* \
-	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* | -aros* \
-	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
-	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -openbsd* | -solidbsd* \
-	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
-	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
-	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
-	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* | -cegcc* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
-	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
-	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
-	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
-	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
-	# Remember, each alternative MUST END IN *, to match a version number.
-		;;
-	-qnx*)
-		case $basic_machine in
-		    x86-* | i*86-*)
-			;;
-		    *)
-			os=-nto$os
-			;;
-		esac
-		;;
-	-nto-qnx*)
-		;;
-	-nto*)
-		os=`echo $os | sed -e 's|nto|nto-qnx|'`
-		;;
-	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
-	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
-		;;
-	-mac*)
-		os=`echo $os | sed -e 's|mac|macos|'`
-		;;
-	-linux-dietlibc)
-		os=-linux-dietlibc
-		;;
-	-linux*)
-		os=`echo $os | sed -e 's|linux|linux-gnu|'`
-		;;
-	-sunos5*)
-		os=`echo $os | sed -e 's|sunos5|solaris2|'`
-		;;
-	-sunos6*)
-		os=`echo $os | sed -e 's|sunos6|solaris3|'`
-		;;
-	-opened*)
-		os=-openedition
-		;;
-        -os400*)
-		os=-os400
-		;;
-	-wince*)
-		os=-wince
-		;;
-	-osfrose*)
-		os=-osfrose
-		;;
-	-osf*)
-		os=-osf
-		;;
-	-utek*)
-		os=-bsd
-		;;
-	-dynix*)
-		os=-bsd
-		;;
-	-acis*)
-		os=-aos
-		;;
-	-atheos*)
-		os=-atheos
-		;;
-	-syllable*)
-		os=-syllable
-		;;
-	-386bsd)
-		os=-bsd
-		;;
-	-ctix* | -uts*)
-		os=-sysv
-		;;
-	-nova*)
-		os=-rtmk-nova
-		;;
-	-ns2 )
-		os=-nextstep2
-		;;
-	-nsk*)
-		os=-nsk
-		;;
-	# Preserve the version number of sinix5.
-	-sinix5.*)
-		os=`echo $os | sed -e 's|sinix|sysv|'`
-		;;
-	-sinix*)
-		os=-sysv4
-		;;
-        -tpf*)
-		os=-tpf
-		;;
-	-triton*)
-		os=-sysv3
-		;;
-	-oss*)
-		os=-sysv3
-		;;
-	-svr4)
-		os=-sysv4
-		;;
-	-svr3)
-		os=-sysv3
-		;;
-	-sysvr4)
-		os=-sysv4
-		;;
-	# This must come after -sysvr4.
-	-sysv*)
-		;;
-	-ose*)
-		os=-ose
-		;;
-	-es1800*)
-		os=-ose
-		;;
-	-xenix)
-		os=-xenix
-		;;
-	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-		os=-mint
-		;;
-	-aros*)
-		os=-aros
-		;;
-	-kaos*)
-		os=-kaos
-		;;
-	-zvmoe)
-		os=-zvmoe
-		;;
-	-dicos*)
-		os=-dicos
-		;;
-	-none)
-		;;
-	*)
-		# Get rid of the `-' at the beginning of $os.
-		os=`echo $os | sed 's/[^-]*-//'`
-		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
-		exit 1
-		;;
-esac
-else
-
-# Here we handle the default operating systems that come with various machines.
-# The value should be what the vendor currently ships out the door with their
-# machine or put another way, the most popular os provided with the machine.
-
-# Note that if you're going to try to match "-MANUFACTURER" here (say,
-# "-sun"), then you have to tell the case statement up towards the top
-# that MANUFACTURER isn't an operating system.  Otherwise, code above
-# will signal an error saying that MANUFACTURER isn't an operating
-# system, and we'll never get to this point.
-
-case $basic_machine in
-        score-*)
-		os=-elf
-		;;
-        spu-*)
-		os=-elf
-		;;
-	*-acorn)
-		os=-riscix1.2
-		;;
-	arm*-rebel)
-		os=-linux
-		;;
-	arm*-semi)
-		os=-aout
-		;;
-        c4x-* | tic4x-*)
-        	os=-coff
-		;;
-	# This must come before the *-dec entry.
-	pdp10-*)
-		os=-tops20
-		;;
-	pdp11-*)
-		os=-none
-		;;
-	*-dec | vax-*)
-		os=-ultrix4.2
-		;;
-	m68*-apollo)
-		os=-domain
-		;;
-	i386-sun)
-		os=-sunos4.0.2
-		;;
-	m68000-sun)
-		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
-		;;
-	m68*-cisco)
-		os=-aout
-		;;
-        mep-*)
-		os=-elf
-		;;
-	mips*-cisco)
-		os=-elf
-		;;
-	mips*-*)
-		os=-elf
-		;;
-	or32-*)
-		os=-coff
-		;;
-	*-tti)	# must be before sparc entry or we get the wrong os.
-		os=-sysv3
-		;;
-	sparc-* | *-sun)
-		os=-sunos4.1.1
-		;;
-	*-be)
-		os=-beos
-		;;
-	*-haiku)
-		os=-haiku
-		;;
-	*-ibm)
-		os=-aix
-		;;
-    	*-knuth)
-		os=-mmixware
-		;;
-	*-wec)
-		os=-proelf
-		;;
-	*-winbond)
-		os=-proelf
-		;;
-	*-oki)
-		os=-proelf
-		;;
-	*-hp)
-		os=-hpux
-		;;
-	*-hitachi)
-		os=-hiux
-		;;
-	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
-		os=-sysv
-		;;
-	*-cbm)
-		os=-amigaos
-		;;
-	*-dg)
-		os=-dgux
-		;;
-	*-dolphin)
-		os=-sysv3
-		;;
-	m68k-ccur)
-		os=-rtu
-		;;
-	m88k-omron*)
-		os=-luna
-		;;
-	*-next )
-		os=-nextstep
-		;;
-	*-sequent)
-		os=-ptx
-		;;
-	*-crds)
-		os=-unos
-		;;
-	*-ns)
-		os=-genix
-		;;
-	i370-*)
-		os=-mvs
-		;;
-	*-next)
-		os=-nextstep3
-		;;
-	*-gould)
-		os=-sysv
-		;;
-	*-highlevel)
-		os=-bsd
-		;;
-	*-encore)
-		os=-bsd
-		;;
-	*-sgi)
-		os=-irix
-		;;
-	*-siemens)
-		os=-sysv4
-		;;
-	*-masscomp)
-		os=-rtu
-		;;
-	f30[01]-fujitsu | f700-fujitsu)
-		os=-uxpv
-		;;
-	*-rom68k)
-		os=-coff
-		;;
-	*-*bug)
-		os=-coff
-		;;
-	*-apple)
-		os=-macos
-		;;
-	*-atari*)
-		os=-mint
-		;;
-	*)
-		os=-none
-		;;
-esac
-fi
-
-# Here we handle the case where we know the os, and the CPU type, but not the
-# manufacturer.  We pick the logical manufacturer.
-vendor=unknown
-case $basic_machine in
-	*-unknown)
-		case $os in
-			-riscix*)
-				vendor=acorn
-				;;
-			-sunos*)
-				vendor=sun
-				;;
-			-cnk*|-aix*)
-				vendor=ibm
-				;;
-			-beos*)
-				vendor=be
-				;;
-			-hpux*)
-				vendor=hp
-				;;
-			-mpeix*)
-				vendor=hp
-				;;
-			-hiux*)
-				vendor=hitachi
-				;;
-			-unos*)
-				vendor=crds
-				;;
-			-dgux*)
-				vendor=dg
-				;;
-			-luna*)
-				vendor=omron
-				;;
-			-genix*)
-				vendor=ns
-				;;
-			-mvs* | -opened*)
-				vendor=ibm
-				;;
-			-os400*)
-				vendor=ibm
-				;;
-			-ptx*)
-				vendor=sequent
-				;;
-			-tpf*)
-				vendor=ibm
-				;;
-			-vxsim* | -vxworks* | -windiss*)
-				vendor=wrs
-				;;
-			-aux*)
-				vendor=apple
-				;;
-			-hms*)
-				vendor=hitachi
-				;;
-			-mpw* | -macos*)
-				vendor=apple
-				;;
-			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-				vendor=atari
-				;;
-			-vos*)
-				vendor=stratus
-				;;
-		esac
-		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
-		;;
-esac
-
-echo $basic_machine$os
-exit
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "timestamp='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:
diff --git a/src/3rdparty/libpng/configure.ac b/src/3rdparty/libpng/configure.ac
deleted file mode 100644
index ff277a4..0000000
--- a/src/3rdparty/libpng/configure.ac
+++ /dev/null
@@ -1,167 +0,0 @@
-# configure.ac
-
-dnl Process this file with autoconf to produce a configure script.
-dnl
-dnl Minor upgrades (compatible ABI): increment the package version
-dnl (third field in two places below) and set the PNGLIB_RELEASE
-dnl variable.
-dnl
-dnl Major upgrades (incompatible ABI): increment the package major
-dnl version (second field, or first if desired), set the minor
-dnl to 0, set PNGLIB_MAJOR below *and* follow the instructions in
-dnl Makefile.am to upgrade the package name.
-
-dnl This is here to prevent earlier autoconf from being used, it
-dnl should not be necessary to regenerate configure if the time
-dnl stamps are correct
-AC_PREREQ(2.59)
-
-dnl Version number stuff here:
-
-AC_INIT([libpng], [1.5.1], [png-mng-implement@lists.sourceforge.net])
-AM_INIT_AUTOMAKE
-dnl stop configure from automagically running automake
-AM_MAINTAINER_MODE
-
-PNGLIB_VERSION=1.5.1
-PNGLIB_MAJOR=1
-PNGLIB_MINOR=5
-PNGLIB_RELEASE=1
-
-dnl End of version number stuff
-
-AC_CONFIG_SRCDIR([pngget.c])
-AM_CONFIG_HEADER(config.h)
-
-# Checks for programs.
-AC_LANG([C])
-AC_PROG_CC
-AC_PROG_LD
-AC_PROG_CPP
-AC_CHECK_TOOL(SED, sed, :)
-AC_CHECK_TOOL(AWK, awk, :)
-AC_PROG_INSTALL
-AC_PROG_LN_S
-AC_PROG_MAKE_SET
-LT_INIT([win32-dll])
-
-# On Solaris 10 and 12 CPP gets set to cc -E, however this still
-# does some input parsing.  We need strict ANSI-C style tokenization,
-# check this:
-AC_REQUIRE_CPP
-AC_MSG_CHECKING([for a C preprocessor that does not parse its input])
-AC_TRY_CPP([1.5.0 16BIT],
-   [DFNCPP="$CPP"],
-   [DFNCPP=""
-   sav_CPP="$CPP"
-   for CPP in "${CC-cc} -E" "${CC-cc} -E -traditional-cpp" "/lib/cpp" "cpp"; do
-      AC_TRY_CPP([1.5.0 16BIT],
-         [DFNCPP="$CPP"]
-         [break],,)
-   done
-   CPP="$sav_CPP"])
-if test -n "$DFNCPP"; then
-   AC_MSG_RESULT([$DFNCPP])
-   AC_SUBST(DFNCPP)
-else
-   AC_MSG_FAILURE([not found], 1)
-fi
-
-# Checks for header files.
-AC_HEADER_STDC
-AC_CHECK_HEADERS([malloc.h stdlib.h string.h strings.h])
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_C_CONST
-AC_TYPE_SIZE_T
-AC_STRUCT_TM
-
-# Checks for library functions.
-AC_FUNC_STRTOD
-AC_CHECK_FUNCS([memset], , AC_ERROR([memset not found in libc]))
-AC_CHECK_FUNCS([pow], , AC_CHECK_LIB(m, pow, , AC_ERROR([cannot find pow])) )
-AC_ARG_WITH(zlib-prefix,
-   AC_HELP_STRING([--with-zlib-prefix],
-                  [prefix that may have been used in installed zlib]),
-                  [ZPREFIX=${withval}],
-                  [ZPREFIX='z_'])
-AC_CHECK_LIB(z, zlibVersion, ,
-    AC_CHECK_LIB(z, ${ZPREFIX}zlibVersion, ,
-                 AC_ERROR([zlib not installed])))
-
-
-LIBPNG_DEFINES=-DPNG_CONFIGURE_LIBPNG
-LIBPNG_DEFINES=$LIBPNG_DEFINES
-AC_SUBST(LIBPNG_DEFINES)
-
-AC_MSG_CHECKING([if libraries can be versioned])
-# Special case for PE/COFF platforms: ld reports
-# support for version-script, but doesn't actually
-# DO anything with it.
-case $host in
-*cygwin* | *mingw32* | *interix* )
-    have_ld_version_script=no
-    AC_MSG_RESULT(no)
-;;
-* )
-GLD=`$LD --help < /dev/null 2>/dev/null | grep version-script`
-if test "$GLD"; then
-    have_ld_version_script=yes
-    AC_MSG_RESULT(yes)
-else
-    have_ld_version_script=no
-    AC_MSG_RESULT(no)
-    AC_MSG_WARN(*** You have not enabled versioned symbols.)
-fi
-;;
-esac
-
-AM_CONDITIONAL(HAVE_LD_VERSION_SCRIPT, test "$have_ld_version_script" = "yes")
-
-if test "$have_ld_version_script" = "yes"; then
-    AC_MSG_CHECKING([for symbol prefix])
-    SYMBOL_PREFIX=`echo "PREFIX=__USER_LABEL_PREFIX__" \
-                   | ${CPP-${CC-gcc} -E} - 2>&1 \
-                   | ${EGREP-grep} "^PREFIX=" \
-                   | ${SED-sed} "s:^PREFIX=::"`
-    AC_SUBST(SYMBOL_PREFIX)
-    AC_MSG_RESULT($SYMBOL_PREFIX)
-fi
-
-# Substitutions for .in files
-AC_SUBST(PNGLIB_VERSION)
-AC_SUBST(PNGLIB_MAJOR)
-AC_SUBST(PNGLIB_MINOR)
-AC_SUBST(PNGLIB_RELEASE)
-
-# Additional arguments (and substitutions)
-# Allow the pkg-config directory to be set
-AC_ARG_WITH(pkgconfigdir,
-	AC_HELP_STRING([--with-pkgconfigdir],
-	[Use the specified pkgconfig dir (default is libdir/pkgconfig)]),
-	[pkgconfigdir=${withval}],
-	[pkgconfigdir='${libdir}/pkgconfig'])
-
-AC_SUBST([pkgconfigdir])
-AC_MSG_NOTICE([pkgconfig directory is ${pkgconfigdir}])
-
-# Make the *-config binary config scripts optional
-AC_ARG_WITH(binconfigs,
-	AC_HELP_STRING([--with-binconfigs],
-		[Generate shell libpng-config scripts as well as pkg-config data]
-		[@<:@default=yes@:>@]),
-	[if test "${withval}" = no; then
-		binconfigs=
-		AC_MSG_NOTICE([libpng-config scripts will not be built])
-	else
-		binconfigs='${binconfigs}'
-	fi],
-	[binconfigs='${binconfigs}'])
-AC_SUBST([binconfigs])
-
-# Config files, substituting as above
-AC_CONFIG_FILES([Makefile libpng.pc:libpng.pc.in])
-AC_CONFIG_FILES([libpng-config:libpng-config.in],
-		[chmod +x libpng-config])
-
-AC_OUTPUT
diff --git a/src/3rdparty/libpng/example.c b/src/3rdparty/libpng/example.c
deleted file mode 100644
index cd3682f..0000000
--- a/src/3rdparty/libpng/example.c
+++ /dev/null
@@ -1,843 +0,0 @@
-
-#if 0 /* in case someone actually tries to compile this */
-
-/* example.c - an example of using libpng
- * Last changed in libpng 1.5.0 [January 6, 2011]
- * This file has been placed in the public domain by the authors.
- * Maintained 1998-2011 Glenn Randers-Pehrson
- * Maintained 1996, 1997 Andreas Dilger)
- * Written 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- */
-
-/* This is an example of how to use libpng to read and write PNG files.
- * The file libpng-manual.txt is much more verbose then this.  If you have not
- * read it, do so first.  This was designed to be a starting point of an
- * implementation.  This is not officially part of libpng, is hereby placed
- * in the public domain, and therefore does not require a copyright notice.
- *
- * This file does not currently compile, because it is missing certain
- * parts, like allocating memory to hold an image.  You will have to
- * supply these parts to get it to compile.  For an example of a minimal
- * working PNG reader/writer, see pngtest.c, included in this distribution;
- * see also the programs in the contrib directory.
- */
-
-#include "png.h"
-
- /* The png_jmpbuf() macro, used in error handling, became available in
-  * libpng version 1.0.6.  If you want to be able to run your code with older
-  * versions of libpng, you must define the macro yourself (but only if it
-  * is not already defined by libpng!).
-  */
-
-#ifndef png_jmpbuf
-#  define png_jmpbuf(png_ptr) ((png_ptr)->png_jmpbuf)
-#endif
-
-/* Check to see if a file is a PNG file using png_sig_cmp().  png_sig_cmp()
- * returns zero if the image is a PNG and nonzero if it isn't a PNG.
- *
- * The function check_if_png() shown here, but not used, returns nonzero (true)
- * if the file can be opened and is a PNG, 0 (false) otherwise.
- *
- * If this call is successful, and you are going to keep the file open,
- * you should call png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK); once
- * you have created the png_ptr, so that libpng knows your application
- * has read that many bytes from the start of the file.  Make sure you
- * don't call png_set_sig_bytes() with more than 8 bytes read or give it
- * an incorrect number of bytes read, or you will either have read too
- * many bytes (your fault), or you are telling libpng to read the wrong
- * number of magic bytes (also your fault).
- *
- * Many applications already read the first 2 or 4 bytes from the start
- * of the image to determine the file type, so it would be easiest just
- * to pass the bytes to png_sig_cmp() or even skip that if you know
- * you have a PNG file, and call png_set_sig_bytes().
- */
-#define PNG_BYTES_TO_CHECK 4
-int check_if_png(char *file_name, FILE **fp)
-{
-   char buf[PNG_BYTES_TO_CHECK];
-
-   /* Open the prospective PNG file. */
-   if ((*fp = fopen(file_name, "rb")) == NULL)
-      return 0;
-
-   /* Read in some of the signature bytes */
-   if (fread(buf, 1, PNG_BYTES_TO_CHECK, *fp) != PNG_BYTES_TO_CHECK)
-      return 0;
-
-   /* Compare the first PNG_BYTES_TO_CHECK bytes of the signature.
-      Return nonzero (true) if they match */
-
-   return(!png_sig_cmp(buf, (png_size_t)0, PNG_BYTES_TO_CHECK));
-}
-
-/* Read a PNG file.  You may want to return an error code if the read
- * fails (depending upon the failure).  There are two "prototypes" given
- * here - one where we are given the filename, and we need to open the
- * file, and the other where we are given an open file (possibly with
- * some or all of the magic bytes read - see comments above).
- */
-#ifdef open_file /* prototype 1 */
-void read_png(char *file_name)  /* We need to open the file */
-{
-   png_structp png_ptr;
-   png_infop info_ptr;
-   unsigned int sig_read = 0;
-   png_uint_32 width, height;
-   int bit_depth, color_type, interlace_type;
-   FILE *fp;
-
-   if ((fp = fopen(file_name, "rb")) == NULL)
-      return (ERROR);
-
-#else no_open_file /* prototype 2 */
-void read_png(FILE *fp, unsigned int sig_read)  /* File is already open */
-{
-   png_structp png_ptr;
-   png_infop info_ptr;
-   png_uint_32 width, height;
-   int bit_depth, color_type, interlace_type;
-#endif no_open_file /* Only use one prototype! */
-
-   /* Create and initialize the png_struct with the desired error handler
-    * functions.  If you want to use the default stderr and longjump method,
-    * you can supply NULL for the last three parameters.  We also supply the
-    * the compiler header file version, so that we know if the application
-    * was compiled with a compatible version of the library.  REQUIRED
-    */
-   png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,
-      png_voidp user_error_ptr, user_error_fn, user_warning_fn);
-
-   if (png_ptr == NULL)
-   {
-      fclose(fp);
-      return (ERROR);
-   }
-
-   /* Allocate/initialize the memory for image information.  REQUIRED. */
-   info_ptr = png_create_info_struct(png_ptr);
-   if (info_ptr == NULL)
-   {
-      fclose(fp);
-      png_destroy_read_struct(&png_ptr, NULL, NULL);
-      return (ERROR);
-   }
-
-   /* Set error handling if you are using the setjmp/longjmp method (this is
-    * the normal method of doing things with libpng).  REQUIRED unless you
-    * set up your own error handlers in the png_create_read_struct() earlier.
-    */
-
-   if (setjmp(png_jmpbuf(png_ptr)))
-   {
-      /* Free all of the memory associated with the png_ptr and info_ptr */
-      png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-      fclose(fp);
-      /* If we get here, we had a problem reading the file */
-      return (ERROR);
-   }
-
-   /* One of the following I/O initialization methods is REQUIRED */
-#ifdef streams /* PNG file I/O method 1 */
-   /* Set up the input control if you are using standard C streams */
-   png_init_io(png_ptr, fp);
-
-#else no_streams /* PNG file I/O method 2 */
-   /* If you are using replacement read functions, instead of calling
-    * png_init_io() here you would call:
-    */
-   png_set_read_fn(png_ptr, (void *)user_io_ptr, user_read_fn);
-   /* where user_io_ptr is a structure you want available to the callbacks */
-#endif no_streams /* Use only one I/O method! */
-
-   /* If we have already read some of the signature */
-   png_set_sig_bytes(png_ptr, sig_read);
-
-#ifdef hilevel
-   /*
-    * If you have enough memory to read in the entire image at once,
-    * and you need to specify only transforms that can be controlled
-    * with one of the PNG_TRANSFORM_* bits (this presently excludes
-    * quantizing, filling, setting background, and doing gamma
-    * adjustment), then you can read the entire image (including
-    * pixels) into the info structure with this call:
-    */
-   png_read_png(png_ptr, info_ptr, png_transforms, NULL);
-
-#else
-   /* OK, you're doing it the hard way, with the lower-level functions */
-
-   /* The call to png_read_info() gives us all of the information from the
-    * PNG file before the first IDAT (image data chunk).  REQUIRED
-    */
-   png_read_info(png_ptr, info_ptr);
-
-   png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
-       &interlace_type, NULL, NULL);
-
-   /* Set up the data transformations you want.  Note that these are all
-    * optional.  Only call them if you want/need them.  Many of the
-    * transformations only work on specific types of images, and many
-    * are mutually exclusive.
-    */
-
-   /* Tell libpng to strip 16 bit/color files down to 8 bits/color */
-   png_set_strip_16(png_ptr);
-
-   /* Strip alpha bytes from the input data without combining with the
-    * background (not recommended).
-    */
-   png_set_strip_alpha(png_ptr);
-
-   /* Extract multiple pixels with bit depths of 1, 2, and 4 from a single
-    * byte into separate bytes (useful for paletted and grayscale images).
-    */
-   png_set_packing(png_ptr);
-
-   /* Change the order of packed pixels to least significant bit first
-    * (not useful if you are using png_set_packing). */
-   png_set_packswap(png_ptr);
-
-   /* Expand paletted colors into true RGB triplets */
-   if (color_type == PNG_COLOR_TYPE_PALETTE)
-      png_set_palette_to_rgb(png_ptr);
-
-   /* Expand grayscale images to the full 8 bits from 1, 2, or 4 bits/pixel */
-   if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
-      png_set_expand_gray_1_2_4_to_8(png_ptr);
-
-   /* Expand paletted or RGB images with transparency to full alpha channels
-    * so the data will be available as RGBA quartets.
-    */
-   if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
-      png_set_tRNS_to_alpha(png_ptr);
-
-   /* Set the background color to draw transparent and alpha images over.
-    * It is possible to set the red, green, and blue components directly
-    * for paletted images instead of supplying a palette index.  Note that
-    * even if the PNG file supplies a background, you are not required to
-    * use it - you should use the (solid) application background if it has one.
-    */
-
-   png_color_16 my_background, *image_background;
-
-   if (png_get_bKGD(png_ptr, info_ptr, &image_background))
-      png_set_background(png_ptr, image_background,
-                         PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
-   else
-      png_set_background(png_ptr, &my_background,
-                         PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
-
-   /* Some suggestions as to how to get a screen gamma value
-    *
-    * Note that screen gamma is the display_exponent, which includes
-    * the CRT_exponent and any correction for viewing conditions
-    */
-   if (/* We have a user-defined screen gamma value */)
-   {
-      screen_gamma = user-defined screen_gamma;
-   }
-   /* This is one way that applications share the same screen gamma value */
-   else if ((gamma_str = getenv("SCREEN_GAMMA")) != NULL)
-   {
-      screen_gamma = atof(gamma_str);
-   }
-   /* If we don't have another value */
-   else
-   {
-      screen_gamma = 2.2;  /* A good guess for a PC monitor in a dimly
-                              lit room */
-      screen_gamma = 1.7 or 1.0;  /* A good guess for Mac systems */
-   }
-
-   /* Tell libpng to handle the gamma conversion for you.  The final call
-    * is a good guess for PC generated images, but it should be configurable
-    * by the user at run time by the user.  It is strongly suggested that
-    * your application support gamma correction.
-    */
-
-   int intent;
-
-   if (png_get_sRGB(png_ptr, info_ptr, &intent))
-      png_set_gamma(png_ptr, screen_gamma, 0.45455);
-   else
-   {
-      double image_gamma;
-      if (png_get_gAMA(png_ptr, info_ptr, &image_gamma))
-         png_set_gamma(png_ptr, screen_gamma, image_gamma);
-      else
-         png_set_gamma(png_ptr, screen_gamma, 0.45455);
-   }
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-   /* Quantize RGB files down to 8 bit palette or reduce palettes
-    * to the number of colors available on your screen.
-    */
-   if (color_type & PNG_COLOR_MASK_COLOR)
-   {
-      int num_palette;
-      png_colorp palette;
-
-      /* This reduces the image to the application supplied palette */
-      if (/* We have our own palette */)
-      {
-         /* An array of colors to which the image should be quantized */
-         png_color std_color_cube[MAX_SCREEN_COLORS];
-
-         png_set_quantize(png_ptr, std_color_cube, MAX_SCREEN_COLORS,
-            MAX_SCREEN_COLORS, NULL, 0);
-      }
-      /* This reduces the image to the palette supplied in the file */
-      else if (png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette))
-      {
-         png_uint_16p histogram = NULL;
-
-         png_get_hIST(png_ptr, info_ptr, &histogram);
-
-         png_set_quantize(png_ptr, palette, num_palette,
-                        max_screen_colors, histogram, 0);
-      }
-   }
-#endif /* PNG_READ_QUANTIZE_SUPPORTED */
-
-   /* Invert monochrome files to have 0 as white and 1 as black */
-   png_set_invert_mono(png_ptr);
-
-   /* If you want to shift the pixel values from the range [0,255] or
-    * [0,65535] to the original [0,7] or [0,31], or whatever range the
-    * colors were originally in:
-    */
-   if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))
-   {
-      png_color_8p sig_bit_p;
-
-      png_get_sBIT(png_ptr, info_ptr, &sig_bit_p);
-      png_set_shift(png_ptr, sig_bit_p);
-   }
-
-   /* Flip the RGB pixels to BGR (or RGBA to BGRA) */
-   if (color_type & PNG_COLOR_MASK_COLOR)
-      png_set_bgr(png_ptr);
-
-   /* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */
-   png_set_swap_alpha(png_ptr);
-
-   /* Swap bytes of 16 bit files to least significant byte first */
-   png_set_swap(png_ptr);
-
-   /* Add filler (or alpha) byte (before/after each RGB triplet) */
-   png_set_filler(png_ptr, 0xff, PNG_FILLER_AFTER);
-
-   /* Turn on interlace handling.  REQUIRED if you are not using
-    * png_read_image().  To see how to handle interlacing passes,
-    * see the png_read_row() method below:
-    */
-   number_passes = png_set_interlace_handling(png_ptr);
-
-   /* Optional call to gamma correct and add the background to the palette
-    * and update info structure.  REQUIRED if you are expecting libpng to
-    * update the palette for you (ie you selected such a transform above).
-    */
-   png_read_update_info(png_ptr, info_ptr);
-
-   /* Allocate the memory to hold the image using the fields of info_ptr. */
-
-   /* The easiest way to read the image: */
-   png_bytep row_pointers[height];
-
-   /* Clear the pointer array */
-   for (row = 0; row < height; row++)
-      row_pointers[row] = NULL;
-
-   for (row = 0; row < height; row++)
-      row_pointers[row] = png_malloc(png_ptr, png_get_rowbytes(png_ptr,
-         info_ptr));
-
-   /* Now it's time to read the image.  One of these methods is REQUIRED */
-#ifdef entire /* Read the entire image in one go */
-   png_read_image(png_ptr, row_pointers);
-
-#else no_entire /* Read the image one or more scanlines at a time */
-   /* The other way to read images - deal with interlacing: */
-
-   for (pass = 0; pass < number_passes; pass++)
-   {
-#ifdef single /* Read the image a single row at a time */
-      for (y = 0; y < height; y++)
-      {
-         png_read_rows(png_ptr, &row_pointers[y], NULL, 1);
-      }
-
-#else no_single /* Read the image several rows at a time */
-      for (y = 0; y < height; y += number_of_rows)
-      {
-#ifdef sparkle /* Read the image using the "sparkle" effect. */
-         png_read_rows(png_ptr, &row_pointers[y], NULL,
-            number_of_rows);
-#else no_sparkle /* Read the image using the "rectangle" effect */
-         png_read_rows(png_ptr, NULL, &row_pointers[y],
-            number_of_rows);
-#endif no_sparkle /* Use only one of these two methods */
-      }
-
-      /* If you want to display the image after every pass, do so here */
-#endif no_single /* Use only one of these two methods */
-   }
-#endif no_entire /* Use only one of these two methods */
-
-   /* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
-   png_read_end(png_ptr, info_ptr);
-#endif hilevel
-
-   /* At this point you have read the entire image */
-
-   /* Clean up after the read, and free any memory allocated - REQUIRED */
-   png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-
-   /* Close the file */
-   fclose(fp);
-
-   /* That's it */
-   return (OK);
-}
-
-/* Progressively read a file */
-
-int
-initialize_png_reader(png_structp *png_ptr, png_infop *info_ptr)
-{
-   /* Create and initialize the png_struct with the desired error handler
-    * functions.  If you want to use the default stderr and longjump method,
-    * you can supply NULL for the last three parameters.  We also check that
-    * the library version is compatible in case we are using dynamically
-    * linked libraries.
-    */
-   *png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,
-       png_voidp user_error_ptr, user_error_fn, user_warning_fn);
-
-   if (*png_ptr == NULL)
-   {
-      *info_ptr = NULL;
-      return (ERROR);
-   }
-
-   *info_ptr = png_create_info_struct(png_ptr);
-
-   if (*info_ptr == NULL)
-   {
-      png_destroy_read_struct(png_ptr, info_ptr, NULL);
-      return (ERROR);
-   }
-
-   if (setjmp(png_jmpbuf((*png_ptr))))
-   {
-      png_destroy_read_struct(png_ptr, info_ptr, NULL);
-      return (ERROR);
-   }
-
-   /* This one's new.  You will need to provide all three
-    * function callbacks, even if you aren't using them all.
-    * If you aren't using all functions, you can specify NULL
-    * parameters.  Even when all three functions are NULL,
-    * you need to call png_set_progressive_read_fn().
-    * These functions shouldn't be dependent on global or
-    * static variables if you are decoding several images
-    * simultaneously.  You should store stream specific data
-    * in a separate struct, given as the second parameter,
-    * and retrieve the pointer from inside the callbacks using
-    * the function png_get_progressive_ptr(png_ptr).
-    */
-   png_set_progressive_read_fn(*png_ptr, (void *)stream_data,
-      info_callback, row_callback, end_callback);
-
-   return (OK);
-}
-
-int
-process_data(png_structp *png_ptr, png_infop *info_ptr,
-   png_bytep buffer, png_uint_32 length)
-{
-   if (setjmp(png_jmpbuf((*png_ptr))))
-   {
-      /* Free the png_ptr and info_ptr memory on error */
-      png_destroy_read_struct(png_ptr, info_ptr, NULL);
-      return (ERROR);
-   }
-
-   /* This one's new also.  Simply give it chunks of data as
-    * they arrive from the data stream (in order, of course).
-    * On segmented machines, don't give it any more than 64K.
-    * The library seems to run fine with sizes of 4K, although
-    * you can give it much less if necessary (I assume you can
-    * give it chunks of 1 byte, but I haven't tried with less
-    * than 256 bytes yet).  When this function returns, you may
-    * want to display any rows that were generated in the row
-    * callback, if you aren't already displaying them there.
-    */
-   png_process_data(*png_ptr, *info_ptr, buffer, length);
-   return (OK);
-}
-
-info_callback(png_structp png_ptr, png_infop info)
-{
-   /* Do any setup here, including setting any of the transformations
-    * mentioned in the Reading PNG files section.  For now, you _must_
-    * call either png_start_read_image() or png_read_update_info()
-    * after all the transformations are set (even if you don't set
-    * any).  You may start getting rows before png_process_data()
-    * returns, so this is your last chance to prepare for that.
-    */
-}
-
-row_callback(png_structp png_ptr, png_bytep new_row,
-   png_uint_32 row_num, int pass)
-{
-   /*
-    * This function is called for every row in the image.  If the
-    * image is interlaced, and you turned on the interlace handler,
-    * this function will be called for every row in every pass.
-    *
-    * In this function you will receive a pointer to new row data from
-    * libpng called new_row that is to replace a corresponding row (of
-    * the same data format) in a buffer allocated by your application.
-    *
-    * The new row data pointer "new_row" may be NULL, indicating there is
-    * no new data to be replaced (in cases of interlace loading).
-    *
-    * If new_row is not NULL then you need to call
-    * png_progressive_combine_row() to replace the corresponding row as
-    * shown below:
-    */
-
-   /* Get pointer to corresponding row in our
-    * PNG read buffer.
-    */
-   png_bytep old_row = ((png_bytep *)our_data)[row_num];
-
-   /* If both rows are allocated then copy the new row
-    * data to the corresponding row data.
-    */
-   if ((old_row != NULL) && (new_row != NULL))
-   png_progressive_combine_row(png_ptr, old_row, new_row);
-
-   /*
-    * The rows and passes are called in order, so you don't really
-    * need the row_num and pass, but I'm supplying them because it
-    * may make your life easier.
-    *
-    * For the non-NULL rows of interlaced images, you must call
-    * png_progressive_combine_row() passing in the new row and the
-    * old row, as demonstrated above.  You can call this function for
-    * NULL rows (it will just return) and for non-interlaced images
-    * (it just does the png_memcpy for you) if it will make the code
-    * easier.  Thus, you can just do this for all cases:
-    */
-
-   png_progressive_combine_row(png_ptr, old_row, new_row);
-
-   /* where old_row is what was displayed for previous rows.  Note
-    * that the first pass (pass == 0 really) will completely cover
-    * the old row, so the rows do not have to be initialized.  After
-    * the first pass (and only for interlaced images), you will have
-    * to pass the current row as new_row, and the function will combine
-    * the old row and the new row.
-    */
-}
-
-end_callback(png_structp png_ptr, png_infop info)
-{
-   /* This function is called when the whole image has been read,
-    * including any chunks after the image (up to and including
-    * the IEND).  You will usually have the same info chunk as you
-    * had in the header, although some data may have been added
-    * to the comments and time fields.
-    *
-    * Most people won't do much here, perhaps setting a flag that
-    * marks the image as finished.
-    */
-}
-
-/* Write a png file */
-void write_png(char *file_name /* , ... other image information ... */)
-{
-   FILE *fp;
-   png_structp png_ptr;
-   png_infop info_ptr;
-   png_colorp palette;
-
-   /* Open the file */
-   fp = fopen(file_name, "wb");
-   if (fp == NULL)
-      return (ERROR);
-
-   /* Create and initialize the png_struct with the desired error handler
-    * functions.  If you want to use the default stderr and longjump method,
-    * you can supply NULL for the last three parameters.  We also check that
-    * the library version is compatible with the one used at compile time,
-    * in case we are using dynamically linked libraries.  REQUIRED.
-    */
-   png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,
-      png_voidp user_error_ptr, user_error_fn, user_warning_fn);
-
-   if (png_ptr == NULL)
-   {
-      fclose(fp);
-      return (ERROR);
-   }
-
-   /* Allocate/initialize the image information data.  REQUIRED */
-   info_ptr = png_create_info_struct(png_ptr);
-   if (info_ptr == NULL)
-   {
-      fclose(fp);
-      png_destroy_write_struct(&png_ptr,  NULL);
-      return (ERROR);
-   }
-
-   /* Set error handling.  REQUIRED if you aren't supplying your own
-    * error handling functions in the png_create_write_struct() call.
-    */
-   if (setjmp(png_jmpbuf(png_ptr)))
-   {
-      /* If we get here, we had a problem writing the file */
-      fclose(fp);
-      png_destroy_write_struct(&png_ptr, &info_ptr);
-      return (ERROR);
-   }
-
-   /* One of the following I/O initialization functions is REQUIRED */
-
-#ifdef streams /* I/O initialization method 1 */
-   /* Set up the output control if you are using standard C streams */
-   png_init_io(png_ptr, fp);
-
-#else no_streams /* I/O initialization method 2 */
-   /* If you are using replacement write functions, instead of calling
-    * png_init_io() here you would call
-    */
-   png_set_write_fn(png_ptr, (void *)user_io_ptr, user_write_fn,
-      user_IO_flush_function);
-   /* where user_io_ptr is a structure you want available to the callbacks */
-#endif no_streams /* Only use one initialization method */
-
-#ifdef hilevel
-   /* This is the easy way.  Use it if you already have all the
-    * image info living in the structure.  You could "|" many
-    * PNG_TRANSFORM flags into the png_transforms integer here.
-    */
-   png_write_png(png_ptr, info_ptr, png_transforms, NULL);
-
-#else
-   /* This is the hard way */
-
-   /* Set the image information here.  Width and height are up to 2^31,
-    * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
-    * the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
-    * PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB,
-    * or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or
-    * PNG_INTERLACE_ADAM7, and the compression_type and filter_type MUST
-    * currently be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE. REQUIRED
-    */
-   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, PNG_COLOR_TYPE_???,
-      PNG_INTERLACE_????, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-
-   /* Set the palette if there is one.  REQUIRED for indexed-color images */
-   palette = (png_colorp)png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH
-             * png_sizeof(png_color));
-   /* ... Set palette colors ... */
-   png_set_PLTE(png_ptr, info_ptr, palette, PNG_MAX_PALETTE_LENGTH);
-   /* You must not free palette here, because png_set_PLTE only makes a link to
-    * the palette that you malloced.  Wait until you are about to destroy
-    * the png structure.
-    */
-
-   /* Optional significant bit (sBIT) chunk */
-   png_color_8 sig_bit;
-
-   /* If we are dealing with a grayscale image then */
-   sig_bit.gray = true_bit_depth;
-
-   /* Otherwise, if we are dealing with a color image then */
-   sig_bit.red = true_red_bit_depth;
-   sig_bit.green = true_green_bit_depth;
-   sig_bit.blue = true_blue_bit_depth;
-
-   /* If the image has an alpha channel then */
-   sig_bit.alpha = true_alpha_bit_depth;
-
-   png_set_sBIT(png_ptr, info_ptr, &sig_bit);
-
-
-   /* Optional gamma chunk is strongly suggested if you have any guess
-    * as to the correct gamma of the image.
-    */
-   png_set_gAMA(png_ptr, info_ptr, gamma);
-
-   /* Optionally write comments into the image */
-   text_ptr[0].key = "Title";
-   text_ptr[0].text = "Mona Lisa";
-   text_ptr[0].compression = PNG_TEXT_COMPRESSION_NONE;
-   text_ptr[0].itxt_length = 0;
-   text_ptr[0].lang = NULL;
-   text_ptr[0].lang_key = NULL;
-   text_ptr[1].key = "Author";
-   text_ptr[1].text = "Leonardo DaVinci";
-   text_ptr[1].compression = PNG_TEXT_COMPRESSION_NONE;
-   text_ptr[1].itxt_length = 0;
-   text_ptr[1].lang = NULL;
-   text_ptr[1].lang_key = NULL;
-   text_ptr[2].key = "Description";
-   text_ptr[2].text = "<long text>";
-   text_ptr[2].compression = PNG_TEXT_COMPRESSION_zTXt;
-   text_ptr[2].itxt_length = 0;
-   text_ptr[2].lang = NULL;
-   text_ptr[2].lang_key = NULL;
-   png_set_text(png_ptr, info_ptr, text_ptr, 3);
-
-   /* Other optional chunks like cHRM, bKGD, tRNS, tIME, oFFs, pHYs */
-
-   /* Note that if sRGB is present the gAMA and cHRM chunks must be ignored
-    * on read and, if your application chooses to write them, they must
-    * be written in accordance with the sRGB profile
-    */
-
-   /* Write the file header information.  REQUIRED */
-   png_write_info(png_ptr, info_ptr);
-
-   /* If you want, you can write the info in two steps, in case you need to
-    * write your private chunk ahead of PLTE:
-    *
-    *   png_write_info_before_PLTE(write_ptr, write_info_ptr);
-    *   write_my_chunk();
-    *   png_write_info(png_ptr, info_ptr);
-    *
-    * However, given the level of known- and unknown-chunk support in 1.2.0
-    * and up, this should no longer be necessary.
-    */
-
-   /* Once we write out the header, the compression type on the text
-    * chunks gets changed to PNG_TEXT_COMPRESSION_NONE_WR or
-    * PNG_TEXT_COMPRESSION_zTXt_WR, so it doesn't get written out again
-    * at the end.
-    */
-
-   /* Set up the transformations you want.  Note that these are
-    * all optional.  Only call them if you want them.
-    */
-
-   /* Invert monochrome pixels */
-   png_set_invert_mono(png_ptr);
-
-   /* Shift the pixels up to a legal bit depth and fill in
-    * as appropriate to correctly scale the image.
-    */
-   png_set_shift(png_ptr, &sig_bit);
-
-   /* Pack pixels into bytes */
-   png_set_packing(png_ptr);
-
-   /* Swap location of alpha bytes from ARGB to RGBA */
-   png_set_swap_alpha(png_ptr);
-
-   /* Get rid of filler (OR ALPHA) bytes, pack XRGB/RGBX/ARGB/RGBA into
-    * RGB (4 channels -> 3 channels). The second parameter is not used.
-    */
-   png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
-
-   /* Flip BGR pixels to RGB */
-   png_set_bgr(png_ptr);
-
-   /* Swap bytes of 16-bit files to most significant byte first */
-   png_set_swap(png_ptr);
-
-   /* Swap bits of 1, 2, 4 bit packed pixel formats */
-   png_set_packswap(png_ptr);
-
-   /* Turn on interlace handling if you are not using png_write_image() */
-   if (interlacing)
-      number_passes = png_set_interlace_handling(png_ptr);
-
-   else
-      number_passes = 1;
-
-   /* The easiest way to write the image (you may have a different memory
-    * layout, however, so choose what fits your needs best).  You need to
-    * use the first method if you aren't handling interlacing yourself.
-    */
-   png_uint_32 k, height, width;
-   png_byte image[height][width*bytes_per_pixel];
-   png_bytep row_pointers[height];
-
-   if (height > PNG_UINT_32_MAX/png_sizeof(png_bytep))
-     png_error (png_ptr, "Image is too tall to process in memory");
-
-   for (k = 0; k < height; k++)
-     row_pointers[k] = image + k*width*bytes_per_pixel;
-
-   /* One of the following output methods is REQUIRED */
-
-#ifdef entire /* Write out the entire image data in one call */
-   png_write_image(png_ptr, row_pointers);
-
-   /* The other way to write the image - deal with interlacing */
-
-#else no_entire /* Write out the image data by one or more scanlines */
-
-   /* The number of passes is either 1 for non-interlaced images,
-    * or 7 for interlaced images.
-    */
-   for (pass = 0; pass < number_passes; pass++)
-   {
-      /* Write a few rows at a time. */
-      png_write_rows(png_ptr, &row_pointers[first_row], number_of_rows);
-
-      /* If you are only writing one row at a time, this works */
-      for (y = 0; y < height; y++)
-         png_write_rows(png_ptr, &row_pointers[y], 1);
-   }
-#endif no_entire /* Use only one output method */
-
-   /* You can write optional chunks like tEXt, zTXt, and tIME at the end
-    * as well.  Shouldn't be necessary in 1.2.0 and up as all the public
-    * chunks are supported and you can use png_set_unknown_chunks() to
-    * register unknown chunks into the info structure to be written out.
-    */
-
-   /* It is REQUIRED to call this to finish writing the rest of the file */
-   png_write_end(png_ptr, info_ptr);
-#endif hilevel
-
-   /* If you png_malloced a palette, free it here (don't free info_ptr->palette,
-    * as recommended in versions 1.0.5m and earlier of this example; if
-    * libpng mallocs info_ptr->palette, libpng will free it).  If you
-    * allocated it with malloc() instead of png_malloc(), use free() instead
-    * of png_free().
-    */
-   png_free(png_ptr, palette);
-   palette = NULL;
-
-   /* Similarly, if you png_malloced any data that you passed in with
-    * png_set_something(), such as a hist or trans array, free it here,
-    * when you can be sure that libpng is through with it.
-    */
-   png_free(png_ptr, trans);
-   trans = NULL;
-   /* Whenever you use png_free() it is a good idea to set the pointer to
-    * NULL in case your application inadvertently tries to png_free() it
-    * again.  When png_free() sees a NULL it returns without action, thus
-    * avoiding the double-free security problem.
-    */
-
-   /* Clean up after the write, and free any memory allocated */
-   png_destroy_write_struct(&png_ptr, &info_ptr);
-
-   /* Close the file */
-   fclose(fp);
-
-   /* That's it */
-   return (OK);
-}
-
-#endif /* if 0 */
diff --git a/src/3rdparty/libpng/libpng-manual.txt b/src/3rdparty/libpng/libpng-manual.txt
index 77adf7a..d55e80a 100644
--- a/src/3rdparty/libpng/libpng-manual.txt
+++ b/src/3rdparty/libpng/libpng-manual.txt
@@ -1,6 +1,6 @@
 libpng-manual.txt - A description on how to use and modify libpng
 
- libpng version 1.5.1 - February 3, 2011
+ libpng version 1.5.10 - March 29, 2012
  Updated and distributed by Glenn Randers-Pehrson
  <glennrp at users.sourceforge.net>
  Copyright (c) 1998-2011 Glenn Randers-Pehrson
@@ -11,7 +11,7 @@ libpng-manual.txt - A description on how to use and modify libpng
 
  Based on:
 
- libpng versions 0.97, January 1998, through 1.5.1 - February 3, 2011
+ libpng versions 0.97, January 1998, through 1.5.10 - March 29, 2012
  Updated and distributed by Glenn Randers-Pehrson
  Copyright (c) 1998-2011 Glenn Randers-Pehrson
 
@@ -107,7 +107,8 @@ PNG file.  At one time, the fields of png_info were intended to be
 directly accessible to the user.  However, this tended to cause problems
 with applications using dynamically loaded libraries, and as a result
 a set of interface functions for png_info (the png_get_*() and png_set_*()
-functions) was developed.
+functions) was developed, and direct access to the png_info fields was
+deprecated..
 
 The png_struct structure is the object used by the library to decode a
 single image.  As of 1.5.0 this structure is also not exposed.
@@ -116,14 +117,23 @@ Almost all libpng APIs require a pointer to a png_struct as the first argument.
 Many (in particular the png_set and png_get APIs) also require a pointer
 to png_info as the second argument.  Some application visible macros
 defined in png.h designed for basic data access (reading and writing
-integers in the PNG format) break this rule, but it's almost always safe
-to assume that a (png_struct*) has to be passed to call an API function.
+integers in the PNG format) don't take a png_info pointer, but it's almost
+always safe to assume that a (png_struct*) has to be passed to call an API
+function.
+
+You can have more than one png_info structure associated with an image,
+as illustrated in pngtest.c, one for information valid prior to the
+IDAT chunks and another (called "end_info" below) for things after them.
 
 The png.h header file is an invaluable reference for programming with libpng.
 And while I'm on the topic, make sure you include the libpng header file:
 
 #include <png.h>
 
+and also (as of libpng-1.5.0) the zlib header file, if you need it:
+
+#include <zlib.h>
+
 Types
 
 The png.h header file defines a number of integral types used by the
@@ -137,9 +147,9 @@ the value by multiplying by 100,000.  As of libpng 1.5.0 a convenience
 macro PNG_FP_1 is defined in png.h along with a type (png_fixed_point)
 which is simply (png_int_32).
 
-All APIs that take (double) arguments also have an matching API that
+All APIs that take (double) arguments also have a matching API that
 takes the corresponding fixed point integer arguments.  The fixed point
-API has the same name as the floating point one with _fixed appended.
+API has the same name as the floating point one with "_fixed" appended.
 The actual range of values permitted in the APIs is frequently less than
 the full range of (png_fixed_point) (-21474 to +21474).  When APIs require
 a non-negative argument the type is recorded as png_uint_32 above.  Consult
@@ -157,6 +167,10 @@ preprocessing directives of the form:
     #ifdef PNG_feature_SUPPORTED
     declare-function
     #endif
+    ...
+    #ifdef PNG_feature_SUPPORTED
+    use-function
+    #endif
 
 The library can be built without support for these APIs, although a
 standard build will have all implemented APIs.  Application programs
@@ -165,7 +179,7 @@ portability.  From libpng 1.5.0 the feature macros set during the build
 of libpng are recorded in the header file "pnglibconf.h" and this file
 is always included by png.h.
 
-If you don't need to change the library configuration from the default skip to
+If you don't need to change the library configuration from the default, skip to
 the next section ("Reading").
 
 Notice that some of the makefiles in the 'scripts' directory and (in 1.5.0) all
@@ -197,24 +211,25 @@ A variety of methods exist to build libpng.  Not all of these support
 reconfiguration of pnglibconf.h.  To reconfigure pnglibconf.h it must either be
 rebuilt from scripts/pnglibconf.dfa using awk or it must be edited by hand.
 
-Hand editing is achieved by copying scripts/pnglibconf.h.prebuilt and changing
-the lines defining the supported features, paying very close attention to the
-'option' information in scripts/pnglibconf.dfa that describes those features and
-their requirements.  This is easy to get wrong.
+Hand editing is achieved by copying scripts/pnglibconf.h.prebuilt to
+pnglibconf.h and changing the lines defining the supported features, paying
+very close attention to the 'option' information in scripts/pnglibconf.dfa
+that describes those features and their requirements.  This is easy to get
+wrong.
 
 B. Configuration using DFA_XTRA
 
 Rebuilding from pnglibconf.dfa is easy if a functioning 'awk', or a later
 variant such as 'nawk' or 'gawk', is available.  The configure build will
 automatically find an appropriate awk and build pnglibconf.h.
-scripts/pnglibconf.mak contains a set of make rules for doing the same thing if
-configure is not used, and many of the makefiles in the scripts directory use
-this approach.
+The scripts/pnglibconf.mak file contains a set of make rules for doing the
+same thing if configure is not used, and many of the makefiles in the scripts
+directory use this approach.
 
-When rebuilding simply write new file containing changed options and set
+When rebuilding simply write a new file containing changed options and set
 DFA_XTRA to the name of this file.  This causes the build to append the new file
-to the end of scripts/pnglibconf.dfa.  pngusr.dfa should contain lines of the
-following forms:
+to the end of scripts/pnglibconf.dfa.  The pngusr.dfa file should contain lines
+of the following forms:
 
 everything = off
 
@@ -238,12 +253,16 @@ source code.  Most of these values have performance implications for the library
 but most of them have no visible effect on the API.  Some can also be overridden
 from the API.
 
+This method of building a customized pnglibconf.h is illustrated in
+contrib/pngminim/*.  See the "$(PNGCONF):" target in the makefile and
+pngusr.dfa in these directories.
+
 C. Configuration using PNG_USR_CONFIG
 
 If -DPNG_USR_CONFIG is added to the CFLAGS when pnglibconf.h is built the file
 pngusr.h will automatically be included before the options in
-scripts/pnglibconf.dfa are processed.  pngusr.h should contain only macro
-definitions turning features on or off or setting settings.
+scripts/pnglibconf.dfa are processed.  Your pngusr.h file should contain only
+macro definitions turning features on or off or setting settings.
 
 Apart from the global setting "everything = off" all the options listed above
 can be set using macros in pngusr.h:
@@ -274,6 +293,9 @@ examine the intermediate file pnglibconf.dfn to find the full set of
 dependency information for each setting and option.  Simply locate the
 feature in the file and read the C comments that precede it.
 
+This method is also illustrated in the contrib/pngminim/* makefiles and
+pngusr.h.
+
 III. Reading
 
 We'll now walk you through the possible functions to call when reading
@@ -348,21 +370,12 @@ create the structure, so your application should check for that.
        return (ERROR);
     }
 
-    png_infop end_info = png_create_info_struct(png_ptr);
-
-    if (!end_info)
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-          (png_infopp)NULL);
-       return (ERROR);
-    }
-
 If you want to use your own memory allocation routines,
 use a libpng that was built with PNG_USER_MEM_SUPPORTED defined, and use
 png_create_read_struct_2() instead of png_create_read_struct():
 
     png_structp png_ptr = png_create_read_struct_2
-       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
+        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
         user_error_fn, user_warning_fn, (png_voidp)
         user_mem_ptr, user_malloc_fn, user_free_fn);
 
@@ -374,7 +387,7 @@ handling and memory alloc/free functions.
 When libpng encounters an error, it expects to longjmp back
 to your routine.  Therefore, you will need to call setjmp and pass
 your png_jmpbuf(png_ptr).  If you read the file from different
-routines, you will need to update the jmpbuf field every time you enter
+routines, you will need to update the longjmp buffer every time you enter
 a new routine that will call a png_*() function.
 
 See your documentation of setjmp/longjmp for your compiler for more
@@ -392,6 +405,9 @@ free any memory.
        return (ERROR);
     }
 
+Pass (png_infopp)NULL instead of &end_info if you didn't create
+an end_info structure.
+
 If you would rather avoid the complexity of setjmp/longjmp issues,
 you can compile libpng with PNG_NO_SETJMP, in which case
 errors will result in a call to PNG_ABORT() which defaults to abort().
@@ -513,6 +529,19 @@ To inform libpng about your function, use
 
     png_set_read_status_fn(png_ptr, read_row_callback);
 
+When this function is called the row has already been completely processed and
+the 'row' and 'pass' refer to the next row to be handled.  For the
+non-interlaced case the row that was just handled is simply one less than the
+passed in row number, and pass will always be 0.  For the interlaced case the
+same applies unless the row value is 0, in which case the row just handled was
+the last one from one of the preceding passes.  Because interlacing may skip a
+pass you cannot be sure that the preceding pass is just 'pass-1', if you really
+need to know what the last pass is record (row,pass) from the callback and use
+the last recorded value each time.
+
+As with the user transform you can find the output row using the
+PNG_ROW_FROM_PASS_ROW macro.
+
 Unknown-chunk handling
 
 Now you get to set the way the library processes unknown chunks in the
@@ -550,6 +579,8 @@ according to the "keep" directive.  If a chunk is named in successive
 instances of png_set_keep_unknown_chunks(), the final instance will
 take precedence.  The IHDR and IEND chunks should not be named in
 chunk_list; if they are, libpng will process them normally anyway.
+If you know that your application will never make use of some particular
+chunks, use PNG_HANDLE_CHUNK_NEVER (or 1) as demonstrated below.
 
 Here is an example of the usage of png_set_keep_unknown_chunks(),
 where the private "vpAg" chunk will later be processed by a user chunk
@@ -590,7 +621,7 @@ large as 2^31-1 (0x7fffffff), or about 2.147 billion rows and columns.
 Since very few applications really need to process such large images,
 we have imposed an arbitrary 1-million limit on rows and columns.
 Larger images will be rejected immediately with a png_error() call. If
-you wish to override this limit, you can use
+you wish to change this limit, you can use
 
    png_set_user_limits(png_ptr, width_max, height_max);
 
@@ -600,6 +631,10 @@ anyway because of potential buffer overflow conditions).
 
 You should put this statement after you create the PNG structure and
 before calling png_read_info(), png_read_png(), or png_process_data().
+
+When writing a PNG datastream, put this statement before calling
+png_write_info() or png_write_png().
+
 If you need to retrieve the limits that are being applied, use
 
    width_max = png_get_user_width_max(png_ptr);
@@ -630,6 +665,242 @@ and you can retrieve the limit with
 Any chunks that would cause either of these limits to be exceeded will
 be ignored.
 
+Information about your system
+
+If you intend to display the PNG or to incorporate it in other image data you
+need to tell libpng information about your display or drawing surface so that
+libpng can convert the values in the image to match the display.
+
+From libpng-1.5.4 this information can be set before reading the PNG file
+header.  In earlier versions png_set_gamma() existed but behaved incorrectly if
+called before the PNG file header had been read and png_set_alpha_mode() did not
+exist.
+
+If you need to support versions prior to libpng-1.5.4 test the version number
+as illustrated below using "PNG_LIBPNG_VER >= 10504" and follow the procedures
+described in the appropriate manual page.
+
+You give libpng the encoding expected by your system expressed as a 'gamma'
+value.  You can also specify a default encoding for the PNG file in
+case the required information is missing from the file.  By default libpng
+assumes that the PNG data matches your system, to keep this default call:
+
+   png_set_gamma(png_ptr, screen_gamma, 1/screen_gamma/*file gamma*/);
+
+or you can use the fixed point equivalent:
+
+   png_set_gamma_fixed(png_ptr, PNG_FP_1*screen_gamma, PNG_FP_1/screen_gamma);
+
+If you don't know the gamma for your system it is probably 2.2 - a good
+approximation to the IEC standard for display systems (sRGB).  If images are
+too contrasty or washed out you got the value wrong - check your system
+documentation!
+
+Many systems permit the system gamma to be changed via a lookup table in the
+display driver, a few systems, including older Macs, change the response by
+default.  As of 1.5.4 three special values are available to handle common
+situations:
+
+   PNG_DEFAULT_sRGB: Indicates that the system conforms to the IEC 61966-2-1
+                     standard.  This matches almost all systems.
+   PNG_GAMMA_MAC_18: Indicates that the system is an older (pre Mac OS 10.6)
+                     Apple Macintosh system with the default settings.
+   PNG_GAMMA_LINEAR: Just the fixed point value for 1.0 - indicates that the
+                     system expects data with no gamma encoding.
+
+You would use the linear (unencoded) value if you need to process the pixel
+values further because this avoids the need to decode and reencode each
+component value whenever arithmetic is performed.  A lot of graphics software
+uses linear values for this reason, often with higher precision component values
+to preserve overall accuracy.
+
+The second thing you may need to tell libpng about is how your system handles
+alpha channel information.  Some, but not all, PNG files contain an alpha
+channel.  To display these files correctly you need to compose the data onto a
+suitable background, as described in the PNG specification.
+
+Libpng only supports composing onto a single color (using png_set_background;
+see below).  Otherwise you must do the composition yourself and, in this case,
+you may need to call png_set_alpha_mode:
+
+#if PNG_LIBPNG_VER >= 10504
+   png_set_alpha_mode(png_ptr, mode, screen_gamma);
+#else
+   png_set_gamma(png_ptr, screen_gamma, 1.0/screen_gamma);
+#endif
+
+The screen_gamma value is the same as the argument to png_set_gamma; however,
+how it affects the output depends on the mode.  png_set_alpha_mode() sets the
+file gamma default to 1/screen_gamma, so normally you don't need to call
+png_set_gamma.  If you need different defaults call png_set_gamma() before
+png_set_alpha_mode() - if you call it after it will override the settings made
+by png_set_alpha_mode().
+
+The mode is as follows:
+
+    PNG_ALPHA_PNG: The data is encoded according to the PNG specification.  Red,
+green and blue, or gray, components are gamma encoded color
+values and are not premultiplied by the alpha value.  The
+alpha value is a linear measure of the contribution of the
+pixel to the corresponding final output pixel.
+
+You should normally use this format if you intend to perform
+color correction on the color values; most, maybe all, color
+correction software has no handling for the alpha channel and,
+anyway, the math to handle pre-multiplied component values is
+unnecessarily complex.
+
+Before you do any arithmetic on the component values you need
+to remove the gamma encoding and multiply out the alpha
+channel.  See the PNG specification for more detail.  It is
+important to note that when an image with an alpha channel is
+scaled, linear encoded, pre-multiplied component values must
+be used!
+
+The remaining modes assume you don't need to do any further color correction or
+that if you do, your color correction software knows all about alpha (it
+probably doesn't!)
+
+    PNG_ALPHA_STANDARD:  The data libpng produces
+is encoded in the standard way
+assumed by most correctly written graphics software.
+The gamma encoding will be removed by libpng and the
+linear component values will be pre-multiplied by the
+alpha channel.
+
+With this format the final image must be re-encoded to
+match the display gamma before the image is displayed.
+If your system doesn't do that, yet still seems to
+perform arithmetic on the pixels without decoding them,
+it is broken - check out the modes below.
+
+With PNG_ALPHA_STANDARD libpng always produces linear
+component values, whatever screen_gamma you supply.  The
+screen_gamma value is, however, used as a default for
+the file gamma if the PNG file has no gamma information.
+
+If you call png_set_gamma() after png_set_alpha_mode() you
+will override the linear encoding.  Instead the
+pre-multiplied pixel values will be gamma encoded but
+the alpha channel will still be linear.  This may
+actually match the requirements of some broken software,
+but it is unlikely.
+
+While linear 8-bit data is often used it has
+insufficient precision for any image with a reasonable
+dynamic range.  To avoid problems, and if your software
+supports it, use png_set_expand_16() to force all
+components to 16 bits.
+
+    PNG_ALPHA_OPTIMIZED: This mode is the same
+as PNG_ALPHA_STANDARD except that
+completely opaque pixels are gamma encoded according to
+the screen_gamma value.  Pixels with alpha less than 1.0
+will still have linear components.
+
+Use this format if you have control over your
+compositing software and do don't do other arithmetic
+(such as scaling) on the data you get from libpng.  Your
+compositing software can simply copy opaque pixels to
+the output but still has linear values for the
+non-opaque pixels.
+
+In normal compositing, where the alpha channel encodes
+partial pixel coverage (as opposed to broad area
+translucency), the inaccuracies of the 8-bit
+representation of non-opaque pixels are irrelevant.
+
+You can also try this format if your software is broken;
+it might look better.
+
+    PNG_ALPHA_BROKEN: This is PNG_ALPHA_STANDARD;
+however, all component values,
+including the alpha channel are gamma encoded.  This is
+an appropriate format to try if your software, or more
+likely hardware, is totally broken, i.e., if it performs
+linear arithmetic directly on gamma encoded values.
+
+In most cases of broken software or hardware the bug in the final display
+manifests as a subtle halo around composited parts of the image.  You may not
+even perceive this as a halo; the composited part of the image may simply appear
+separate from the background, as though it had been cut out of paper and pasted
+on afterward.
+
+If you don't have to deal with bugs in software or hardware, or if you can fix
+them, there are three recommended ways of using png_set_alpha_mode():
+
+   png_set_alpha_mode(png_ptr, PNG_ALPHA_PNG,
+       screen_gamma);
+
+You can do color correction on the result (libpng does not currently
+support color correction internally).  When you handle the alpha channel
+you need to undo the gamma encoding and multiply out the alpha.
+
+   png_set_alpha_mode(png_ptr, PNG_ALPHA_STANDARD,
+       screen_gamma);
+   png_set_expand_16(png_ptr);
+
+If you are using the high level interface, don't call png_set_expand_16();
+instead pass PNG_TRANSFORM_EXPAND_16 to the interface.
+
+With this mode you can't do color correction, but you can do arithmetic,
+including composition and scaling, on the data without further processing.
+
+   png_set_alpha_mode(png_ptr, PNG_ALPHA_OPTIMIZED,
+       screen_gamma);
+
+You can avoid the expansion to 16-bit components with this mode, but you
+lose the ability to scale the image or perform other linear arithmetic.
+All you can do is compose the result onto a matching output.  Since this
+mode is libpng-specific you also need to write your own composition
+software.
+
+If you don't need, or can't handle, the alpha channel you can call
+png_set_background() to remove it by compositing against a fixed color.  Don't
+call png_set_strip_alpha() to do this - it will leave spurious pixel values in
+transparent parts of this image.
+
+   png_set_background(png_ptr, &background_color,
+       PNG_BACKGROUND_GAMMA_SCREEN, 0, 1);
+
+The background_color is an RGB or grayscale value according to the data format
+libpng will produce for you.  Because you don't yet know the format of the PNG
+file, if you call png_set_background at this point you must arrange for the
+format produced by libpng to always have 8-bit or 16-bit components and then
+store the color as an 8-bit or 16-bit color as appropriate.  The color contains
+separate gray and RGB component values, so you can let libpng produce gray or
+RGB output according to the input format, but low bit depth grayscale images
+must always be converted to at least 8-bit format.  (Even though low bit depth
+grayscale images can't have an alpha channel they can have a transparent
+color!)
+
+You set the transforms you need later, either as flags to the high level
+interface or libpng API calls for the low level interface.  For reference the
+settings and API calls required are:
+
+8-bit values:
+   PNG_TRANSFORM_SCALE_16 | PNG_EXPAND
+   png_set_expand(png_ptr); png_set_scale_16(png_ptr);
+
+   If you must get exactly the same inaccurate results
+   produced by default in versions prior to libpng-1.5.4,
+   use PNG_TRANSFORM_STRIP_16 and png_set_strip_16(png_ptr)
+   instead.
+
+16-bit values:
+   PNG_TRANSFORM_EXPAND_16
+   png_set_expand_16(png_ptr);
+
+In either case palette image data will be expanded to RGB.  If you just want
+color data you can add PNG_TRANSFORM_GRAY_TO_RGB or png_set_gray_to_rgb(png_ptr)
+to the list.
+
+Calling png_set_background before the PNG file header is read will not work
+prior to libpng-1.5.4.  Because the failure may result in unexpected warnings or
+errors it is therefore much safer to call png_set_background after the head has
+been read.  Unfortunately this means that prior to libpng-1.5.4 it cannot be
+used with the high level interface.
+
 The high-level read interface
 
 At this point there are two ways to proceed; through the high-level
@@ -639,8 +910,10 @@ the entire image into memory, and (b) the input transformations
 you want to do are limited to the following set:
 
     PNG_TRANSFORM_IDENTITY      No transformation
-    PNG_TRANSFORM_STRIP_16      Strip 16-bit samples to
-                                8 bits
+    PNG_TRANSFORM_SCALE_16      Strip 16-bit samples to
+                                8-bit accurately
+    PNG_TRANSFORM_STRIP_16      Chop 16-bit samples to
+                                8-bit less accurately
     PNG_TRANSFORM_STRIP_ALPHA   Discard the alpha channel
     PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit
                                 samples to bytes
@@ -659,6 +932,7 @@ you want to do are limited to the following set:
     PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
     PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples
                                 to RGB (or GA to RGBA)
+    PNG_TRANSFORM_EXPAND_16     Expand samples to 16 bits
 
 (This excludes setting a background color, doing gamma transformation,
 quantizing, and setting filler.)  If this is the case, simply do this:
@@ -727,6 +1001,22 @@ call to png_read_info().
 
 This will process all chunks up to but not including the image data.
 
+This also copies some of the data from the PNG file into the decode structure
+for use in later transformations.  Important information copied in is:
+
+1) The PNG file gamma from the gAMA chunk.  This overwrites the default value
+provided by an earlier call to png_set_gamma or png_set_alpha_mode.
+
+2) Prior to libpng-1.5.4 the background color from a bKGd chunk.  This
+damages the information provided by an earlier call to png_set_background
+resulting in unexpected behavior.  Libpng-1.5.4 no longer does this.
+
+3) The number of significant bits in each component value.  Libpng uses this to
+optimize gamma handling by reducing the internal lookup table sizes.
+
+4) The transparent color information from a tRNS chunk.  This can be modified by
+a later call to png_set_tRNS.
+
 Querying the info structure
 
 Functions are used to get the information from the info_ptr once it
@@ -857,6 +1147,28 @@ pointer into the info_ptr is returned for any complex types.
     int_file_gamma - 100,000 times the gamma at which the
                      file is written
 
+    png_get_cHRM(png_ptr, info_ptr,  &white_x, &white_y, &red_x, &red_y,
+                     &green_x, &green_y, &blue_x, &blue_y)
+    png_get_cHRM_XYZ(png_ptr, info_ptr, &red_X, &red_Y, &red_Z, &green_X,
+                     &green_Y, &green_Z, &blue_X, &blue_Y, &blue_Z)
+    png_get_cHRM_fixed(png_ptr, info_ptr, &int_white_x, &int_white_y,
+                     &int_red_x, &int_red_y, &int_green_x, &int_green_y,
+                     &int_blue_x, &int_blue_y)
+    png_get_cHRM_XYZ_fixed(png_ptr, info_ptr, &int_red_X, &int_red_Y,
+                     &int_red_Z, &int_green_X, &int_green_Y, &int_green_Z,
+                     &int_blue_X, &int_blue_Y, &int_blue_Z)
+
+    {white,red,green,blue}_{x,y}
+                     A color space encoding specified using the chromaticities
+                     of the end points and the white point. (PNG_INFO_cHRM)
+
+    {red,green,blue}_{X,Y,Z}
+                     A color space encoding specified using the encoding end
+                     points - the CIE tristimulus specification of the intended
+                     color of the red, green and blue channels in the PNG RGB
+                     data.  The white point is simply the sum of the three end
+                     points. (PNG_INFO_cHRM)
+
     png_get_sRGB(png_ptr, info_ptr, &srgb_intent);
 
     file_srgb_intent - the rendering intent (PNG_INFO_sRGB)
@@ -915,7 +1227,8 @@ pointer into the info_ptr is returned for any complex types.
 
     png_get_bKGD(png_ptr, info_ptr, &background);
 
-    background     - background color (PNG_VALID_bKGD)
+    background     - background color (of type
+                     png_color_16p) (PNG_VALID_bKGD)
                      valid 16-bit red, green and blue
                      values, regardless of color_type
 
@@ -952,8 +1265,13 @@ pointer into the info_ptr is returned for any complex types.
                          (empty string for unknown).
 
     Note that the itxt_length, lang, and lang_key
-    members of the text_ptr structure only exist
-    when the library is built with iTXt chunk support.
+    members of the text_ptr structure only exist when the
+    library is built with iTXt chunk support.  Prior to
+    libpng-1.4.0 the library was built by default without
+    iTXt support. Also note that when iTXt is supported,
+    they contain NULL pointers when the "compression"
+    field contains PNG_TEXT_COMPRESSION_NONE or
+    PNG_TEXT_COMPRESSION_zTXt.
 
     num_text       - number of comments (same as
                      num_comments; you can put NULL here
@@ -978,10 +1296,10 @@ pointer into the info_ptr is returned for any complex types.
        &unit_type);
 
     offset_x       - positive offset from the left edge
-                     of the screen
+                     of the screen (can be negative)
 
     offset_y       - positive offset from the top edge
-                     of the screen
+                     of the screen (can be negative)
 
     unit_type      - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
 
@@ -1013,6 +1331,7 @@ pointer into the info_ptr is returned for any complex types.
     unit        - physical scale units (an integer)
 
     width       - width of a pixel in physical scale units
+                  (expressed as a string)
 
     height      - height of a pixel in physical scale units
                  (width and height are strings like "2.54")
@@ -1035,6 +1354,12 @@ pointer into the info_ptr is returned for any complex types.
     chunks were read from the PNG file or inserted with the
     png_set_unknown_chunks() function.
 
+    The value of "location" is a bitwise "or" of
+
+         PNG_HAVE_IHDR  (0x01)
+         PNG_HAVE_PLTE  (0x02)
+         PNG_AFTER_IDAT (0x08)
+
 The data from the pHYs chunk can be retrieved in several convenient
 forms:
 
@@ -1069,7 +1394,7 @@ forms:
        72 dpi is stored as 0.28346 pixels/meter, and
        when this is retrieved it is 71.9988 dpi, so
        be sure to round the returned value appropriately
-       if you want to display a reasonable-looking result. 
+       if you want to display a reasonable-looking result.
 
 The data from the oFFs chunk can be retrieved in several convenient
 forms:
@@ -1090,7 +1415,7 @@ forms:
        converted to microns and back without some loss
        of precision.
 
-For more information, see the png_info definition in png.h and the
+For more information, see the
 PNG specification for chunk contents.  Be careful with trusting
 rowbytes, as some of the transformations could increase the space
 needed to hold a row (expand, filler, gray_to_rgb, etc.).
@@ -1125,17 +1450,20 @@ to handle any special transformations of the image data.  The various
 ways to transform the data will be described in the order that they
 should occur.  This is important, as some of these change the color
 type and/or bit depth of the data, and some others only work on
-certain color types and bit depths.  Even though each transformation
-checks to see if it has data that it can do something with, you should
-make sure to only enable a transformation if it will be valid for the
-data.  For example, don't swap red and blue on grayscale data.
+certain color types and bit depths.
+
+Transformations you request are ignored if they don't have any meaning for a
+particular input data format.  However some transformations can have an effect
+as a result of a previous transformation.  If you specify a contradictory set of
+transformations, for example both adding and removing the alpha channel, you
+cannot predict the final result.
 
-The colors used for the background and transparency values should be
-supplied in the same format/depth as the current image data.  They
-are stored in the same format/depth as the image data in a bKGD or tRNS
-chunk, so this is what libpng expects for this data.  The colors are
-transformed to keep in sync with the image data when an application
-calls the png_read_update_info() routine (see below).
+The color used for the transparency values should be supplied in the same
+format/depth as the current image data.  It is stored in the same format/depth
+as the image data in a tRNS chunk, so this is what libpng expects for this data.
+
+The color used for the background value depends on the need_expand argument as
+described below.
 
 Data will be decoded into the supplied row buffers packed into bytes
 unless the library has been told to transform it into another format.
@@ -1145,12 +1473,12 @@ byte, unless png_set_packing() is called.  8-bit RGB data will be stored
 in RGB RGB RGB format unless png_set_filler() or png_set_add_alpha()
 is called to insert filler bytes, either before or after each RGB triplet.
 16-bit RGB data will be returned RRGGBB RRGGBB, with the most significant
-byte of the color value first, unless png_set_strip_16() is called to
+byte of the color value first, unless png_set_scale_16() is called to
 transform it to regular RGB RGB triplets, or png_set_filler() or
 png_set_add alpha() is called to insert filler bytes, either before or
 after each RRGGBB triplet.  Similarly, 8-bit or 16-bit grayscale data can
-be modified with
-png_set_filler(), png_set_add_alpha(), or png_set_strip_16().
+be modified with png_set_filler(), png_set_add_alpha(), png_set_strip_16(),
+or png_set_scale_16().
 
 The following code transforms grayscale images of less than 8 to 8 bits,
 changes paletted images to RGB, and adds a full alpha channel if there is
@@ -1161,13 +1489,13 @@ viewing application that wishes to treat all images in the same way.
     if (color_type == PNG_COLOR_TYPE_PALETTE)
         png_set_palette_to_rgb(png_ptr);
 
-    if (color_type == PNG_COLOR_TYPE_GRAY &&
-        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);
-
     if (png_get_valid(png_ptr, info_ptr,
         PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png_ptr);
 
-These three functions are actually aliases for png_set_expand(), added
+    if (color_type == PNG_COLOR_TYPE_GRAY &&
+        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);
+
+The first two functions are actually aliases for png_set_expand(), added
 in libpng version 1.0.4, with the function names expanded to improve code
 readability.  In some future version they may actually do different
 things.
@@ -1175,56 +1503,91 @@ things.
 As of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was
 added.  It expands the sample depth without changing tRNS to alpha.
 
-As of libpng version 1.5.1, not all possible expansions are supported.
+As of libpng version 1.5.2, png_set_expand_16() was added.  It behaves as
+png_set_expand(); however, the resultant channels have 16 bits rather than 8.
+Use this when the output color or gray channels are made linear to avoid fairly
+severe accuracy loss.
+
+   if (bit_depth < 16)
+      png_set_expand_16(png_ptr);
+
+PNG can have files with 16 bits per channel.  If you only can handle
+8 bits per channel, this will strip the pixels down to 8-bit.
+
+    if (bit_depth == 16)
+#if PNG_LIBPNG_VER >= 10504
+       png_set_scale_16(png_ptr);
+#else
+       png_set_strip_16(png_ptr);
+#endif
+
+(The more accurate "png_set_scale_16()" API became available in libpng version
+1.5.4).
+
+If you need to process the alpha channel on the image separately from the image
+data (for example if you convert it to a bitmap mask) it is possible to have
+libpng strip the channel leaving just RGB or gray data:
+
+    if (color_type & PNG_COLOR_MASK_ALPHA)
+       png_set_strip_alpha(png_ptr);
+
+If you strip the alpha channel you need to find some other way of dealing with
+the information.  If, instead, you want to convert the image to an opaque
+version with no alpha channel use png_set_background; see below.
+
+As of libpng version 1.5.2, almost all useful expansions are supported, the
+major ommissions are conversion of grayscale to indexed images (which can be
+done trivially in the application) and conversion of indexed to grayscale (which
+can be done by a trivial manipulation of the palette.)
 
 In the following table, the 01 means grayscale with depth<8, 31 means
 indexed with depth<8, other numerals represent the color type, "T" means
 the tRNS chunk is present, A means an alpha channel is present, and O
 means tRNS or alpha is present but all pixels in the image are opaque.
 
-  FROM  01  31   0  0T  0O   2  2T  2O   3  3T  3O  4A  4O  6A  6O 
+  FROM  01  31   0  0T  0O   2  2T  2O   3  3T  3O  4A  4O  6A  6O
    TO
-   01    -                   
-   31        -
-    0    1       -           
-   0T                -
-   0O                    -
-    2           GX           -
-   2T                            -
-   2O                                -
-    3        1                           -
-   3T                                        -
-   3O                                            -
-   4A                T                               -
-   4O                                                    -
-   6A               GX         TX           TX               -
-   6O                   GX                      TX               -
+   01    -  [G]  -   -   -   -   -   -   -   -   -   -   -   -   -
+   31   [Q]  Q  [Q] [Q] [Q]  Q   Q   Q   Q   Q   Q  [Q] [Q]  Q   Q
+    0    1   G   +   .   .   G   G   G   G   G   G   B   B  GB  GB
+   0T    lt  Gt  t   +   .   Gt  G   G   Gt  G   G   Bt  Bt GBt GBt
+   0O    lt  Gt  t   .   +   Gt  Gt  G   Gt  Gt  G   Bt  Bt GBt GBt
+    2    C   P   C   C   C   +   .   .   C   -   -  CB  CB   B   B
+   2T    Ct  -   Ct  C   C   t   +   t   -   -   -  CBt CBt  Bt  Bt
+   2O    Ct  -   Ct  C   C   t   t   +   -   -   -  CBt CBt  Bt  Bt
+    3   [Q]  p  [Q] [Q] [Q]  Q   Q   Q   +   .   .  [Q] [Q]  Q   Q
+   3T   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   +   t  [Qt][Qt] Qt  Qt
+   3O   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   t   +  [Qt][Qt] Qt  Qt
+   4A    lA  G   A   T   T   GA  GT  GT  GA  GT  GT  +   BA  G  GBA
+   4O    lA GBA  A   T   T   GA  GT  GT  GA  GT  GT  BA  +  GBA  G
+   6A    CA  PA  CA  C   C   A   T  tT   PA  P   P   C  CBA  +   BA
+   6O    CA PBA  CA  C   C   A  tT   T   PA  P   P  CBA  C   BA  +
 
 Within the matrix,
+     "+" identifies entries where 'from' and 'to' are the same.
      "-" means the transformation is not supported.
+     "." means nothing is necessary (a tRNS chunk can just be ignored).
+     "t" means the transformation is obtained by png_set_tRNS.
+     "A" means the transformation is obtained by png_set_add_alpha().
      "X" means the transformation is obtained by png_set_expand().
      "1" means the transformation is obtained by
-         png_set_expand_gray_1_2_4_to_8
-     "G" means the transformation is obtained by
-         png_set_gray_to_rgb().
+         png_set_expand_gray_1_2_4_to_8() (and by png_set_expand() if there
+         is no transparency in the original or the final format).
+     "C" means the transformation is obtained by png_set_gray_to_rgb().
+     "G" means the transformation is obtained by png_set_rgb_to_gray().
      "P" means the transformation is obtained by
          png_set_expand_palette_to_rgb().
-     "T" means the transformation is obtained by
-         png_set_tRNS_to_alpha().
-
-PNG can have files with 16 bits per channel.  If you only can handle
-8 bits per channel, this will strip the pixels down to 8 bit.
-
-    if (bit_depth == 16)
-       png_set_strip_16(png_ptr);
-
-If, for some reason, you don't need the alpha channel on an image,
-and you want to remove it rather than combining it with the background
-(but the image author certainly had in mind that you *would* combine
-it with the background, so that's what you should probably do):
-
-    if (color_type & PNG_COLOR_MASK_ALPHA)
-       png_set_strip_alpha(png_ptr);
+     "p" means the transformation is obtained by png_set_packing().
+     "Q" means the transformation is obtained by png_set_quantize().
+     "T" means the transformation is obtained by png_set_tRNS_to_alpha().
+     "B" means the transformation is obtained by png_set_background(), or
+         png_strip_alpha().
+
+When an entry has multiple transforms listed all are required to cause the
+right overall transformation.  When two transforms are separated by a comma
+either will do the job.  When transforms are enclosed in [] the transform should
+do the job but this is currently unimplemented - a different format will result
+if the suggested transformations are used.
 
 In PNG files, the alpha channel in an image
 is the level of opacity.  If you need the alpha channel in an image to
@@ -1303,8 +1666,8 @@ with alpha.
 
     if (color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-       png_set_rgb_to_gray_fixed(png_ptr, error_action,
-           int red_weight, int green_weight);
+       png_set_rgb_to_gray(png_ptr, error_action, double red_weight,
+          double green_weight);
 
     error_action = 1: silently do the conversion
 
@@ -1317,122 +1680,98 @@ with alpha.
                       image has any pixel where
                       red != green or red != blue
 
-    red_weight:       weight of red component times 100000
+    red_weight:       weight of red component
 
-    green_weight:     weight of green component times 100000
+    green_weight:     weight of green component
                       If either weight is negative, default
-                      weights (21268, 71514) are used.
+                      weights are used.
+
+In the corresponding fixed point API the red_weight and green_weight values are
+simply scaled by 100,000:
+
+    png_set_rgb_to_gray(png_ptr, error_action, png_fixed_point red_weight,
+       png_fixed_point green_weight);
 
 If you have set error_action = 1 or 2, you can
 later check whether the image really was gray, after processing
 the image rows, with the png_get_rgb_to_gray_status(png_ptr) function.
 It will return a png_byte that is zero if the image was gray or
-1 if there were any non-gray pixels.  bKGD and sBIT data
+1 if there were any non-gray pixels.  Background and sBIT data
 will be silently converted to grayscale, using the green channel
-data, regardless of the error_action setting.
+data for sBIT, regardless of the error_action setting.
 
-With red_weight+green_weight<=100000,
-the normalized graylevel is computed:
+The default values come from the PNG file cHRM chunk if present; otherwise, the
+defaults correspond to the ITU-R recommendation 709, and also the sRGB color
+space, as recommended in the Charles Poynton's Colour FAQ,
+<http://www.poynton.com/>, in section 9:
 
-    int rw = red_weight * 65536;
-    int gw = green_weight * 65536;
-    int bw = 65536 - (rw + gw);
-    gray = (rw*red + gw*green + bw*blue)/65536;
+   <http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9>
 
-The default values approximate those recommended in the Charles
-Poynton's Color FAQ, <http://www.inforamp.net/~poynton/>
-Copyright (c) 1998-01-04 Charles Poynton <poynton at inforamp.net>
+    Y = 0.2126 * R + 0.7152 * G + 0.0722 * B
+
+Previous versions of this document, 1998 through 2002, recommended a slightly
+different formula:
 
     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
 
-Libpng approximates this with integers scaled by 32768:
+Libpng uses an integer approximation:
 
     Y = (6968 * R + 23434 * G + 2366 * B)/32768
 
 The calculation is done in a linear colorspace, if the image gamma
 can be determined.
 
-If you have a grayscale and you are using png_set_expand_depth(),
-png_set_expand(), or png_set_gray_to_rgb to change to truecolor or to
-a higher bit-depth, you must either supply the background color as a gray
-value at the original file bit-depth (need_expand = 1) or else supply the
-background color as an RGB triplet at the final, expanded bit depth
-(need_expand = 0).  Similarly, if you are reading a paletted image, you
-must either supply the background color as a palette index (need_expand = 1)
-or as an RGB triplet that may or may not be in the palette (need_expand = 0).
+The png_set_background() function has been described already; it tells libpng to
+composite images with alpha or simple transparency against the supplied
+background color.  For compatibility with versions of libpng earlier than
+libpng-1.5.4 it is recommended that you call the function after reading the file
+header, even if you don't want to use the color in a bKGD chunk, if one exists.
+
+If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
+you may use this color, or supply another color more suitable for
+the current display (e.g., the background color from a web page).  You
+need to tell libpng how the color is represented, both the format of the
+component values in the color (the number of bits) and the gamma encoding of the
+color.  The function takes two arguments, background_gamma_mode and need_expand
+to convey this information, however only two combinations are likely to be
+useful:
 
     png_color_16 my_background;
     png_color_16p image_background;
 
     if (png_get_bKGD(png_ptr, info_ptr, &image_background))
        png_set_background(png_ptr, image_background,
-           PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
+           PNG_BACKGROUND_GAMMA_FILE, 1/*needs to be expanded*/, 1);
     else
        png_set_background(png_ptr, &my_background,
-           PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
-
-The png_set_background() function tells libpng to composite images
-with alpha or simple transparency against the supplied background
-color.  If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
-you may use this color, or supply another color more suitable for
-the current display (e.g., the background color from a web page).  You
-need to tell libpng whether the color is in the gamma space of the
-display (PNG_BACKGROUND_GAMMA_SCREEN for colors you supply), the file
-(PNG_BACKGROUND_GAMMA_FILE for colors from the bKGD chunk), or one
-that is neither of these gammas (PNG_BACKGROUND_GAMMA_UNIQUE - I don't
-know why anyone would use this, but it's here).
-
-To properly display PNG images on any kind of system, the application needs
-to know what the display gamma is.  Ideally, the user will know this, and
-the application will allow them to set it.  One method of allowing the user
-to set the display gamma separately for each system is to check for a
-SCREEN_GAMMA or DISPLAY_GAMMA environment variable, which will hopefully be
-correctly set.
-
-Note that display_gamma is the overall gamma correction required to produce
-pleasing results, which depends on the lighting conditions in the surrounding
-environment.  In a dim or brightly lit room, no compensation other than
-the physical gamma exponent of the monitor is needed, while in a dark room
-a slightly smaller exponent is better.
-
-   double gamma, screen_gamma;
-
-   if (/* We have a user-defined screen
-       gamma value */)
-   {
-      screen_gamma = user_defined_screen_gamma;
-   }
-
-   /* One way that applications can share the same
-      screen gamma value */
-   else if ((gamma_str = getenv("SCREEN_GAMMA"))
-      != NULL)
-   {
-      screen_gamma = (double)atof(gamma_str);
-   }
-
-   /* If we don't have another value */
-   else
-   {
-      screen_gamma = 2.2; /* A good guess for a
-           PC monitor in a bright office or a dim room */
-
-      screen_gamma = 2.0; /* A good guess for a
-           PC monitor in a dark room */
-
-      screen_gamma = 1.7 or 1.0;  /* A good
-           guess for Mac systems */
-   }
-
-The functions png_set_gamma() and its fixed point equivalent
-png_set_gamma_fixed() handle gamma transformations of the data.
-Pass both the file gamma and the current screen_gamma.  If the file does
-not have a gamma value, you can pass one anyway if you have an idea what
-it is (usually 0.45455 is a good guess for GIF images on PCs).  Note
-that file gammas are inverted from screen gammas.  See the discussions
-on gamma in the PNG specification for an excellent description of what
-gamma is, and why all applications should support it.  It is strongly
-recommended that PNG viewers support gamma correction.
+           PNG_BACKGROUND_GAMMA_SCREEN, 0/*do not expand*/, 1);
+
+The second call was described above - my_background is in the format of the
+final, display, output produced by libpng.  Because you now know the format of
+the PNG it is possible to avoid the need to choose either 8-bit or 16-bit
+output and to retain palette images (the palette colors will be modified
+appropriately and the tRNS chunk removed.)  However, if you are doing this,
+take great care not to ask for transformations without checking first that
+they apply!
+
+In the first call the background color has the original bit depth and color type
+of the PNG file.  So, for palette images the color is supplied as a palette
+index and for low bit greyscale images the color is a reduced bit value in
+image_background->gray.
+
+If you didn't call png_set_gamma() before reading the file header, for example
+if you need your code to remain compatible with older versions of libpng prior
+to libpng-1.5.4, this is the place to call it.
+
+Do not call it if you called png_set_alpha_mode(); doing so will damage the
+settings put in place by png_set_alpha_mode().  (If png_set_alpha_mode() is
+supported then you can certainly do png_set_gamma() before reading the PNG
+header.)
+
+This API unconditionally sets the screen and file gamma values, so it will
+override the value in the PNG file unless it is called before the PNG file
+reading starts.  For this reason you must always call it with the PNG file
+value when you call it in this position:
 
    if (png_get_gAMA(png_ptr, info_ptr, &file_gamma))
       png_set_gamma(png_ptr, screen_gamma, file_gamma);
@@ -1445,9 +1784,9 @@ file has more entries then will fit on your screen, png_set_quantize()
 will do that.  Note that this is a simple match quantization that merely
 finds the closest color available.  This should work fairly well with
 optimized palettes, but fairly badly with linear color cubes.  If you
-pass a palette that is larger then maximum_colors, the file will
+pass a palette that is larger than maximum_colors, the file will
 reduce the number of colors in the palette so it will fit into
-maximum_colors.  If there is a histogram, it will use it to make
+maximum_colors.  If there is a histogram, libpng will use it to make
 more intelligent choices when reducing the palette.  If there is no
 histogram, it may not do as good a job.
 
@@ -1488,7 +1827,7 @@ This function can also be used to invert grayscale and gray-alpha images:
        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
       png_set_invert_mono(png_ptr);
 
-PNG files store 16 bit pixels in network byte order (big-endian,
+PNG files store 16-bit pixels in network byte order (big-endian,
 ie. most significant bits first).  This code changes the storage to the
 other way (little-endian, i.e. least significant bits first, the
 way PCs store them):
@@ -1511,7 +1850,7 @@ with
 
 You must supply the function
 
-    void read_transform_fn(png_structp png_ptr, row_info_ptr
+    void read_transform_fn(png_structp png_ptr, png_row_infop
         row_info, png_bytep data)
 
 See pngtest.c for a working example.  Your function will be called
@@ -1519,7 +1858,7 @@ after all of the other transformations have been processed.  Take care with
 interlaced images if you do the interlace yourself - the width of the row is the
 width in 'row_info', not the overall image width.
 
-If supported libpng provides two information routines that you can use to find
+If supported, libpng provides two information routines that you can use to find
 where you are in processing the image:
 
    png_get_current_pass_number(png_structp png_ptr);
@@ -1530,6 +1869,14 @@ supported if user transforms are supported, secondly they may well return
 unexpected results unless the row is actually being processed at the moment they
 are called.
 
+With interlaced
+images the value returned is the row in the input sub-image image.  Use
+PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
+find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
+
+The discussion of interlace handling above contains more information on how to
+use these values.
+
 You can also set up a pointer to a user structure for use by your
 callback function, and you can inform libpng that your transform
 function will change the number of channels or bit depth with the
@@ -1555,13 +1902,16 @@ of the interlaced image.
 
 After setting the transformations, libpng can update your png_info
 structure to reflect any transformations you've requested with this
-call.  This is most useful to update the info structure's rowbytes
-field so you can use it to allocate your image memory.  This function
-will also update your palette with the correct screen_gamma and
-background if these have been given with the calls above.
+call.
 
     png_read_update_info(png_ptr, info_ptr);
 
+This is most useful to update the info structure's rowbytes
+field so you can use it to allocate your image memory.  This function
+will also update your palette with the correct screen_gamma and
+background if these have been given with the calls above.  You may
+only call png_read_update_info() once with a particular info_ptr.
+
 After you call png_read_update_info(), you can allocate any
 memory you need to hold the image.  The row data is simply
 raw byte data for all forms of images.  As the actual allocation
@@ -1570,7 +1920,7 @@ are allocating one large chunk, you will need to build an
 array of pointers to each row, as it will be needed for some
 of the functions below.
 
-Remember: Before you call png_read_update_info(), the png_get_
+Remember: Before you call png_read_update_info(), the png_get_*()
 functions return the values corresponding to the original PNG image.
 After you call png_read_update_info the values refer to the image
 that libpng will output.  Consequently you must call all the png_set_
@@ -1762,7 +2112,7 @@ to load the whole file into memory when it is interlaced.
 
 libpng includes a test program, pngvalid, that illustrates reading and
 writing of interlaced images.  If you can't get interlacing to work in your
-code and don't want to leave it to libpng (the recommended approach) see
+code and don't want to leave it to libpng (the recommended approach), see
 how pngvalid.c does it.
 
 Finishing a sequential read
@@ -1772,15 +2122,39 @@ low-level interface, you can finish reading the file.  If you are
 interested in comments or time, which may be stored either before or
 after the image data, you should pass the separate png_info struct if
 you want to keep the comments from before and after the image
-separate.  If you are not interested, you can pass NULL.
+separate.
+
+    png_infop end_info = png_create_info_struct(png_ptr);
+
+    if (!end_info)
+    {
+       png_destroy_read_struct(&png_ptr, &info_ptr,
+           (png_infopp)NULL);
+       return (ERROR);
+    }
 
    png_read_end(png_ptr, end_info);
 
+If you are not interested, you should still call png_read_end()
+but you can pass NULL, avoiding the need to create an end_info structure.
+
+   png_read_end(png_ptr, (png_infop)NULL);
+
+If you don't call png_read_end(), then your file pointer will be
+left pointing to the first chunk after the last IDAT, which is probably
+not what you want if you expect to read something beyond the end of
+the PNG datastream.
+
 When you are done, you can free all memory allocated by libpng like this:
 
    png_destroy_read_struct(&png_ptr, &info_ptr,
        &end_info);
 
+or, if you didn't create an end_info structure,
+
+   png_destroy_read_struct(&png_ptr, &info_ptr,
+       (png_infopp)NULL);
+
 It is also possible to individually free the info_ptr members that
 point to libpng-allocated storage with the following function:
 
@@ -2183,6 +2557,20 @@ To inform libpng about your function, use
 
     png_set_write_status_fn(png_ptr, write_row_callback);
 
+When this function is called the row has already been completely processed and
+it has also been written out.  The 'row' and 'pass' refer to the next row to be
+handled.  For the
+non-interlaced case the row that was just handled is simply one less than the
+passed in row number, and pass will always be 0.  For the interlaced case the
+same applies unless the row value is 0, in which case the row just handled was
+the last one from one of the preceding passes.  Because interlacing may skip a
+pass you cannot be sure that the preceding pass is just 'pass-1', if you really
+need to know what the last pass is record (row,pass) from the callback and use
+the last recorded value each time.
+
+As with the user transform you can find the output row using the
+PNG_ROW_FROM_PASS_ROW macro.
+
 You now have the option of modifying how the compression library will
 run.  The following functions are mainly for testing, but may be useful
 in some cases, like if you need to write PNG files extremely fast and
@@ -2227,11 +2615,13 @@ which changes how much time zlib spends on trying to compress the image
 data.  See the Compression Library (zlib.h and algorithm.txt, distributed
 with zlib) for details on the compression levels.
 
-    /* set the zlib compression level */
+    #include zlib.h
+
+    /* Set the zlib compression level */
     png_set_compression_level(png_ptr,
         Z_BEST_COMPRESSION);
 
-    /* set other zlib parameters */
+    /* Set other zlib parameters for compressing IDAT */
     png_set_compression_mem_level(png_ptr, 8);
     png_set_compression_strategy(png_ptr,
         Z_DEFAULT_STRATEGY);
@@ -2239,7 +2629,15 @@ with zlib) for details on the compression levels.
     png_set_compression_method(png_ptr, 8);
     png_set_compression_buffer_size(png_ptr, 8192)
 
-extern PNG_EXPORT(void,png_set_zbuf_size)
+    /* Set zlib parameters for text compression
+     * If you don't call these, the parameters
+     * fall back on those defined for IDAT chunks
+     */
+    png_set_text_compression_mem_level(png_ptr, 8);
+    png_set_text_compression_strategy(png_ptr,
+        Z_DEFAULT_STRATEGY);
+    png_set_text_compression_window_bits(png_ptr, 15);
+    png_set_text_compression_method(png_ptr, 8);
 
 Setting the contents of info for output
 
@@ -2327,6 +2725,28 @@ width, height, bit_depth, and color_type must be the same in each call.
     int_file_gamma - 100,000 times the gamma at which
                      the image was created
 
+    png_set_cHRM(png_ptr, info_ptr,  white_x, white_y, red_x, red_y,
+                     green_x, green_y, blue_x, blue_y)
+    png_set_cHRM_XYZ(png_ptr, info_ptr, red_X, red_Y, red_Z, green_X,
+                     green_Y, green_Z, blue_X, blue_Y, blue_Z)
+    png_set_cHRM_fixed(png_ptr, info_ptr, int_white_x, int_white_y,
+                     int_red_x, int_red_y, int_green_x, int_green_y,
+                     int_blue_x, int_blue_y)
+    png_set_cHRM_XYZ_fixed(png_ptr, info_ptr, int_red_X, int_red_Y,
+                     int_red_Z, int_green_X, int_green_Y, int_green_Z,
+                     int_blue_X, int_blue_Y, int_blue_Z)
+
+    {white,red,green,blue}_{x,y}
+                     A color space encoding specified using the chromaticities
+                     of the end points and the white point.
+
+    {red,green,blue}_{X,Y,Z}
+                     A color space encoding specified using the encoding end
+                     points - the CIE tristimulus specification of the intended
+                     color of the red, green and blue channels in the PNG RGB
+                     data.  The white point is simply the sum of the three end
+                     points.
+
     png_set_sRGB(png_ptr, info_ptr, srgb_intent);
 
     srgb_intent    - the rendering intent
@@ -2387,14 +2807,14 @@ width, height, bit_depth, and color_type must be the same in each call.
     trans_alpha    - array of alpha (transparency)
                      entries for palette (PNG_INFO_tRNS)
 
+    num_trans      - number of transparent entries
+                     (PNG_INFO_tRNS)
+
     trans_color    - graylevel or color sample values
                      (in order red, green, blue) of the
                      single transparent color for
                      non-paletted images (PNG_INFO_tRNS)
 
-    num_trans      - number of transparent entries
-                     (PNG_INFO_tRNS)
-
     png_set_hIST(png_ptr, info_ptr, hist);
 
     hist           - histogram of palette (array of
@@ -2407,7 +2827,8 @@ width, height, bit_depth, and color_type must be the same in each call.
 
     png_set_bKGD(png_ptr, info_ptr, background);
 
-    background     - background color (PNG_VALID_bKGD)
+    background     - background color (of type
+                     png_color_16p) (PNG_VALID_bKGD)
 
     png_set_text(png_ptr, info_ptr, text_ptr, num_text);
 
@@ -2431,9 +2852,15 @@ width, height, bit_depth, and color_type must be the same in each call.
                          empty for unknown).
     text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL
                          or empty for unknown).
+
     Note that the itxt_length, lang, and lang_key
-    members of the text_ptr structure only exist
-    when the library is built with iTXt chunk support.
+    members of the text_ptr structure only exist when the
+    library is built with iTXt chunk support.  Prior to
+    libpng-1.4.0 the library was built by default without
+    iTXt support. Also note that when iTXt is supported,
+    they contain NULL pointers when the "compression"
+    field contains PNG_TEXT_COMPRESSION_NONE or
+    PNG_TEXT_COMPRESSION_zTXt.
 
     num_text       - number of comments
 
@@ -2483,6 +2910,7 @@ width, height, bit_depth, and color_type must be the same in each call.
     unit        - physical scale units (an integer)
 
     width       - width of a pixel in physical scale units
+                  expressed as a string
 
     height      - height of a pixel in physical scale units
                  (width and height are strings like "2.54")
@@ -2524,7 +2952,7 @@ Because tEXt and zTXt chunks don't have a language field, if you
 specify PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt
 any language code or translated keyword will not be written out.
 
-Until text gets around 1000 bytes, it is not worth compressing it.
+Until text gets around a few hundred bytes, it is not worth compressing it.
 After the text has been written out to the file, the compression type
 is set to PNG_TEXT_COMPRESSION_NONE_WR or PNG_TEXT_COMPRESSION_zTXt_WR,
 so that it isn't written out again at the end (in case you are calling
@@ -2745,7 +3173,7 @@ is required by PNG.
 
     png_set_shift(png_ptr, &sig_bit);
 
-PNG files store 16 bit pixels in network byte order (big-endian,
+PNG files store 16-bit pixels in network byte order (big-endian,
 ie. most significant bits first).  This code would be used if they are
 supplied the other way (little-endian, i.e. least significant bits
 first, the way PCs store them):
@@ -2779,8 +3207,8 @@ with
 
 You must supply the function
 
-    void write_transform_fn(png_structp png_ptr ptr,
-       row_info_ptr row_info, png_bytep data)
+    void write_transform_fn(png_structp png_ptr, png_row_infop
+       row_info, png_bytep data)
 
 See pngtest.c for a working example.  Your function will be called
 before any of the other transformations are processed.  If supported
@@ -2788,9 +3216,15 @@ libpng also supplies an information routine that may be called from
 your callback:
 
    png_get_current_row_number(png_ptr);
+   png_get_current_pass_number(png_ptr);
 
-This returns the current row passed to the transform.  Even with interlaced
-images the value returned is the row in the final output image.
+This returns the current row passed to the transform.  With interlaced
+images the value returned is the row in the input sub-image image.  Use
+PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
+find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
+
+The discussion of interlace handling above contains more information on how to
+use these values.
 
 You can also set up a pointer to a user structure for use by your
 callback function.
@@ -3128,7 +3562,8 @@ However, there are some uncertainties about the status of local variables
 after a longjmp, so the user may want to be careful about doing anything
 after setjmp returns non-zero besides returning itself.  Consult your
 compiler documentation for more details.  For an alternative approach, you
-may wish to use the "cexcept" facility (see http://cexcept.sourceforge.net).
+may wish to use the "cexcept" facility (see http://cexcept.sourceforge.net),
+which is illustrated in pngvalid.c and in contrib/visupng.
 
 Custom chunks
 
@@ -3146,8 +3581,11 @@ and look at how other chunks were designed, so you can do things
 similarly.  Second, check out the sections of libpng that read and
 write chunks.  Try to find a chunk that is similar to yours and use
 it as a template.  More details can be found in the comments inside
-the code.  It is best to handle unknown chunks in a generic method,
-via callback functions, instead of by modifying libpng functions.
+the code.  It is best to handle private or unknown chunks in a generic method,
+via callback functions, instead of by modifying libpng functions. This
+is illustrated in pngtest.c, which uses a callback function to handle a
+private "vpAg" chunk and the new "sTER" chunk, which are both unknown to
+libpng.
 
 If you wish to write your own transformation for the data, look through
 the part of the code that does the transformations, and check out some of
@@ -3155,7 +3593,7 @@ the simpler ones to get an idea of how they work.  Try to find a similar
 transformation to the one you want to add and copy off of it.  More details
 can be found in the comments inside the code itself.
 
-Configuring for 16 bit platforms
+Configuring for 16-bit platforms
 
 You will want to look into zconf.h to tell zlib (and thus libpng) that
 it cannot allocate more then 64K at a time.  Even if you can, the memory
@@ -3175,8 +3613,8 @@ defined, and FAR gets defined to far in pngconf.h, and you should be
 all set.  Everything in the library (except for zlib's structure) is
 expecting far data.  You must use the typedefs with the p or pp on
 the end for pointers (or at least look at them and be careful).  Make
-note that the rows of data are defined as png_bytepp, which is an
-unsigned char far * far *.
+note that the rows of data are defined as png_bytepp, which is
+an "unsigned char far * far *".
 
 Configuring for gui/windowing platforms:
 
@@ -3194,7 +3632,10 @@ or delete an include, this is the place to do it.
 The includes that are not needed outside libpng are placed in pngpriv.h,
 which is only used by the routines inside libpng itself.
 The files in libpng proper only include pngpriv.h and png.h, which
-in turn includes pngconf.h.
+in turn includes pngconf.h and, as of libpng-1.5.0, pnglibconf.h.
+As of libpng-1.5.0, pngpriv.h also includes three other private header
+files, pngstruct.h, pnginfo.h, and pngdebug.h, which contain material
+that previously appeared in the public headers.
 
 Configuring zlib:
 
@@ -3210,6 +3651,7 @@ specify no compression (Z_NO_COMPRESSION = 0), but this would create
 files larger than just storing the raw bitmap.  You can specify the
 compression level by calling:
 
+    #include zlib.h
     png_set_compression_level(png_ptr, level);
 
 Another useful one is to reduce the memory level used by the library.
@@ -3220,12 +3662,14 @@ other things, lower levels will result in sections of incompressible
 data being emitted in smaller stored blocks, with a correspondingly
 larger relative overhead of up to 15% in the worst case.
 
+    #include zlib.h
     png_set_compression_mem_level(png_ptr, level);
 
 The other functions are for configuring zlib.  They are not recommended
 for normal use and may result in writing an invalid PNG file.  See
 zlib.h for more information on what these mean.
 
+    #include zlib.h
     png_set_compression_strategy(png_ptr,
         strategy);
 
@@ -3233,8 +3677,28 @@ zlib.h for more information on what these mean.
         window_bits);
 
     png_set_compression_method(png_ptr, method);
+
     png_set_compression_buffer_size(png_ptr, size);
 
+As of libpng version 1.5.4, additional APIs became
+available to set these separately for non-IDAT
+compressed chunks such as zTXt, iTXt, and iCCP:
+
+    #include zlib.h
+    #if PNG_LIBPNG_VER <= 10504
+    png_set_text_compression_level(png_ptr, level);
+
+    png_set_text_compression_mem_level(png_ptr, level);
+
+    png_set_text_compression_strategy(png_ptr,
+        strategy);
+
+    png_set_text_compression_window_bits(png_ptr,
+        window_bits);
+
+    png_set_text_compression_method(png_ptr, method);
+    #endif
+
 Controlling row filtering
 
 If you want to control whether libpng uses filtering or not, which
@@ -3340,8 +3804,8 @@ capability, which you'll still have).
 All the reading and writing specific code are in separate files, so the
 linker should only grab the files it needs.  However, if you want to
 make sure, or if you are building a stand alone library, all the
-reading files start with pngr and all the writing files start with
-pngw.  The files that don't match either (like png.c, pngtrans.c, etc.)
+reading files start with "pngr" and all the writing files start with "pngw".
+The files that don't match either (like png.c, pngtrans.c, etc.)
 are used for both reading and writing, and always need to be included.
 The progressive reader is in pngpread.c
 
@@ -3460,6 +3924,9 @@ The number libpng_vn is constructed from the major version, minor
 version with leading zero, and release number with leading zero,
 (e.g., libpng_vn for version 1.0.7 is 10007).
 
+Note that this function does not take a png_ptr, so you can call it
+before you've created one.
+
 You can also check which version of png.h you used when compiling your
 application:
 
@@ -3623,12 +4090,12 @@ and memset(), respectively.
 The function png_set_gray_1_2_4_to_8() was removed. It has been
 deprecated since libpng-1.0.18 and 1.2.9, when it was replaced with
 png_set_expand_gray_1_2_4_to_8() because the former function also
-expanded palette images.
+expanded any tRNS chunk to an alpha channel.
 
 Macros for png_get_uint_16, png_get_uint_32, and png_get_int_32
 were added and are used by default instead of the corresponding
 functions. Unfortunately,
-from libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the  
+from libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
 function) incorrectly returned a value of type png_uint_32.
 
 We changed the prototype for png_malloc() from
@@ -3658,7 +4125,8 @@ The png_zalloc() function no longer zeroes out the memory that it
 allocates.
 
 Support for dithering was disabled by default in libpng-1.4.0, because
-been well tested and doesn't actually "dither".  The code was not
+it has not been well tested and doesn't actually "dither".
+The code was not
 removed, however, and could be enabled by building libpng with
 PNG_READ_DITHER_SUPPORTED defined.  In libpng-1.4.2, this support
 was reenabled, but the function was renamed png_set_quantize() to
@@ -3671,9 +4139,19 @@ We removed the trailing '.' from the warning and error messages.
 
 X.  Changes to Libpng from version 1.4.x to 1.5.x
 
-From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the  
+From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
 function) incorrectly returned a value of type png_uint_32.
 
+Checking for invalid palette index on read or write was added at libpng
+1.5.10.  When an invalid index is found, libpng issues a benign error.
+This is enabled by default but can be disabled in each png_ptr with
+
+   png_set_check_for_invalid_index(png_ptr, allowed);
+
+      allowed  - one of
+                 0: disable
+                 1: enable
+
 A. Changes that affect users of libpng
 
 There are no substantial API changes between the non-deprecated parts of
@@ -3695,10 +4173,9 @@ In png_get_iCCP, the type of "profile" was changed from png_charpp
 to png_bytepp, and in png_set_iCCP, from png_charp to png_const_bytep.
 
 There are changes of form in png.h, including new and changed macros to
-declare
-parts of the API.  Some API functions with arguments that are pointers to
-data not modified within the function have been corrected to declare
-these arguments with PNG_CONST.
+declare parts of the API.  Some API functions with arguments that are
+pointers to data not modified within the function have been corrected to
+declare these arguments with PNG_CONST.
 
 Much of the internal use of C macros to control the library build has also
 changed and some of this is visible in the exported header files, in
@@ -3708,7 +4185,8 @@ application code.  (It is extremely rare for an application to do this.)
 
 Any program that compiled against libpng 1.4 and did not use deprecated
 features or access internal library structures should compile and work
-against libpng 1.5.
+against libpng 1.5, except for the change in the prototype for
+png_get_iCCP() and png_set_iCCP() API functions mentioned above.
 
 libpng 1.5.0 adds PNG_ PASS macros to help in the reading and writing of
 interlaced images.  The macros return the number of rows and columns in
@@ -3716,10 +4194,10 @@ each pass and information that can be used to de-interlace and (if
 absolutely necessary) interlace an image.
 
 libpng 1.5.0 adds an API png_longjmp(png_ptr, value).  This API calls
-the application provided png_longjmp_ptr on the internal, but application
-initialized, jmpbuf.  It is provided as a convenience to avoid the need
-to use the png_jmpbuf macro, which had the unnecessary side effect of
-resetting the internal png_longjmp_ptr value.
+the application-provided png_longjmp_ptr on the internal, but application
+initialized, longjmp buffer.  It is provided as a convenience to avoid
+the need to use the png_jmpbuf macro, which had the unnecessary side
+effect of resetting the internal png_longjmp_ptr value.
 
 libpng 1.5.0 includes a complete fixed point API.  By default this is
 present along with the corresponding floating point API.  In general the
@@ -3762,7 +4240,7 @@ reset by pngusr.h or by explicit settings on the compiler command line.
 These settings may produce compiler warnings or errors in 1.5.0 because
 of macro redefinition.
 
-From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the  
+From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
 function) incorrectly returned a value of type png_uint_32.  libpng 1.5.0
 is consistent with the implementation in 1.4.5 and 1.2.x (where the macro
 did not exist.)
@@ -3771,14 +4249,47 @@ Applications can now choose whether to use these macros or to call the
 corresponding function by defining PNG_USE_READ_MACROS or
 PNG_NO_USE_READ_MACROS before including png.h.  Notice that this is
 only supported from 1.5.0 -defining PNG_NO_USE_READ_MACROS prior to 1.5.0
- will lead to a link failure.
+will lead to a link failure.
+
+Prior to libpng-1.5.4, the zlib compressor used the same set of parameters
+when compressing the IDAT data and textual data such as zTXt and iCCP.
+In libpng-1.5.4 we reinitialized the zlib stream for each type of data.
+We added five png_set_text_*() functions for setting the parameters to
+use with textual data.
+
+Prior to libpng-1.5.4, the PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
+option was off by default, and slightly inaccurate scaling occurred.
+This option can no longer be turned off, and the choice of accurate
+or inaccurate 16-to-8 scaling is by using the new png_set_scale_16_to_8()
+API for accurate scaling or the old png_set_strip_16_to_8() API for simple
+chopping.
+
+Prior to libpng-1.5.4, the png_set_user_limits() function could only be
+used to reduce the width and height limits from the value of
+PNG_USER_WIDTH_MAX and PNG_USER_HEIGHT_MAX, although this document said
+that it could be used to override them.  Now this function will reduce or
+increase the limits.
+
+Starting in libpng-1.5.10, the user limits can be set en masse with the
+configuration option PNG_SAFE_LIMITS_SUPPORTED.  If this option is enabled,
+a set of "safe" limits is applied in pngpriv.h.  These can be overridden by
+application calls to png_set_user_limits(), png_set_user_chunk_cache_max(),
+and/or png_set_user_malloc_max() that increase or decrease the limits.  Also,
+in libpng-1.5.10 the default width and height limits were increased
+from 1,000,000 to 0x7ffffff (i.e., made unlimited).  Therefore, the
+limits are now
+                               default      safe
+   png_user_width_max        0x7fffffff    1,000,000
+   png_user_height_max       0x7fffffff    1,000,000
+   png_user_chunk_cache_max  0 (unlimited)   128
+   png_user_chunk_malloc_max 0 (unlimited) 8,000,000
 
 B. Changes to the build and configuration of libpng
 
 Details of internal changes to the library code can be found in the CHANGES
-file.  These will be of no concern to the vast majority of library users or
-builders, however the few who configure libpng to a non-default feature
-set may need to change how this is done.
+file and in the GIT repository logs.  These will be of no concern to the vast
+majority of library users or builders, however the few who configure libpng
+to a non-default feature set may need to change how this is done.
 
 There should be no need for library builders to alter build scripts if
 these use the distributed build support - configure or the makefiles -
@@ -3787,14 +4298,14 @@ to build pnglibconf.h where the corresponding makefile does not do so.
 
 Building libpng with a non-default configuration has changed completely.
 The old method using pngusr.h should still work correctly even though the
-way pngusr.h is used in the build has been changed, however library
+way pngusr.h is used in the build has been changed; however, library
 builders will probably want to examine the changes to take advantage of
 new capabilities and to simplify their build system.
 
 B.1 Specific changes to library configuration capabilities
 
 The library now supports a complete fixed point implementation and can
-thus be used on systems which have no floating point support or very
+thus be used on systems that have no floating point support or very
 limited or slow support.  Previously gamma correction, an essential part
 of complete PNG support, required reasonably fast floating point.
 
@@ -3810,14 +4321,14 @@ pnglibconf.h
 As part of this the mechanism used to choose procedure call standards on
 those systems that allow a choice has been changed.  At present this only
 affects certain Microsoft (DOS, Windows) and IBM (OS/2) operating systems
-running on Intel processors.  As before PNGAPI is defined where required
+running on Intel processors.  As before, PNGAPI is defined where required
 to control the exported API functions; however, two new macros, PNGCBAPI
 and PNGCAPI, are used instead for callback functions (PNGCBAPI) and
 (PNGCAPI) for functions that must match a C library prototype (currently
 only png_longjmp_ptr, which must match the C longjmp function.)  The new
 approach is documented in pngconf.h
 
-Despite these changes libpng 1.5.0 only supports the native C function
+Despite these changes, libpng 1.5.0 only supports the native C function
 calling standard on those platforms tested so far (__cdecl on Microsoft
 Windows).  This is because the support requirements for alternative
 calling conventions seem to no longer exist.  Developers who find it
@@ -3850,8 +4361,10 @@ if the feature is supported or:
 /*#undef PNG_feature_SUPPORTED*/
 
 if it is not.  Library code consistently checks for the 'SUPPORTED' macro.
-It does not, and should not, check for the 'NO' macro which will not
-normally be defined even if the feature is not supported.
+It does not, and libpng applications should not, check for the 'NO' macro
+which will not normally be defined even if the feature is not supported.
+The 'NO' macros are only used internally for setting or not setting the
+corresponding 'SUPPORTED' macros.
 
 Compatibility with the old names is provided as follows:
 
@@ -3908,10 +4421,10 @@ application built without PNG_USER_CONFIG defined would see the
 unmodified, default, libpng API and thus would probably fail to link.
 
 These mechanisms still work in the configure build and in any makefile
-build that builds pnglibconf.h although the feature selection macros
+build that builds pnglibconf.h, although the feature selection macros
 have changed somewhat as described above.  In 1.5.0, however, pngusr.h is
 processed only once, when the exported header file pnglibconf.h is built.
-pngconf.h no longer includes pngusr.h, therefore it is ignored after the
+pngconf.h no longer includes pngusr.h, therefore pngusr.h is ignored after the
 build of pnglibconf.h and it is never included in an application build.
 
 The rarely used alternative of adding a list of feature macros to the
@@ -3925,7 +4438,7 @@ scripts/pnglibconf.dfa.  This requires the program awk.  Brian Kernighan
 and all known later implementations (often called by subtly different
 names - nawk and gawk for example) are adequate to build pnglibconf.h.
 The Sun Microsystems (now Oracle) program 'awk' is an earlier version
-and does not work, this may also apply to other systems that have a
+and does not work; this may also apply to other systems that have a
 functioning awk called 'nawk'.
 
 Configuration options are now documented in scripts/pnglibconf.dfa.  This
@@ -3967,8 +4480,8 @@ the libpng bug tracker at
 
 We also accept patches built from the tar or zip distributions, and
 simple verbal discriptions of bug fixes, reported either to the
-SourceForge bug tracker or to the png-mng-implement at lists.sf.net
-mailing list.
+SourceForge bug tracker, to the png-mng-implement at lists.sf.net
+mailing list, or directly to glennrp.
 
 XIII. Coding style
 
@@ -4056,8 +4569,8 @@ above the comment that says
   /* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */
 
 To avoid polluting the global namespace, the names of all exported
-functions and variables begin with  "png_", and all publicly visible C
-preprocessor macros begin with "PNG_".  We request that applications that
+functions and variables begin with "png_", and all publicly visible C
+preprocessor macros begin with "PNG".  We request that applications that
 use libpng *not* begin any of their own symbols with either of these strings.
 
 We put a space after each comma and after each semicolon
@@ -4073,6 +4586,9 @@ left parenthesis that follows it:
 We prefer #ifdef and #ifndef to #if defined() and if !defined()
 when there is only one macro being tested.
 
+We prefer to express integers that are used as bit masks in hex format,
+with an even number of lower-case hex digits (e.g., 0x00, 0xff, 0x0100).
+
 We do not use the TAB character for indentation in the C sources.
 
 Lines do not exceed 80 characters.
@@ -4081,13 +4597,13 @@ Other rules can be inferred by inspecting the libpng source.
 
 XIV. Y2K Compliance in libpng
 
-February 3, 2011
+March 29, 2012
 
 Since the PNG Development group is an ad-hoc body, we can't make
 an official declaration.
 
 This is your unofficial assurance that libpng from version 0.71 and
-upward through 1.5.1 are Y2K compliant.  It is my belief that earlier
+upward through 1.5.10 are Y2K compliant.  It is my belief that earlier
 versions were also Y2K compliant.
 
 Libpng only has three year fields.  One is a 2-byte unsigned integer that
diff --git a/src/3rdparty/libpng/libpng.3 b/src/3rdparty/libpng/libpng.3
deleted file mode 100644
index ecc4277..0000000
--- a/src/3rdparty/libpng/libpng.3
+++ /dev/null
@@ -1,5376 +0,0 @@
-.TH LIBPNG 3 "February 3, 2011"
-.SH NAME
-libpng \- Portable Network Graphics (PNG) Reference Library 1.5.1
-.SH SYNOPSIS
-\fI\fB
-
-\fB#include <png.h>\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_access_version_number \fI(void\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_benign_error (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fIerror\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_build_grayscale_palette (int \fP\fIbit_depth\fP\fB, png_colorp \fIpalette\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_calloc (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIsize\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_chunk_benign_error (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fIerror\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_chunk_error (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fIerror\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_chunk_warning (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fImessage\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_convert_from_struct_tm (png_timep \fP\fIptime\fP\fB, struct tm FAR * \fIttime\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_convert_from_time_t (png_timep \fP\fIptime\fP\fB, time_t \fIttime\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_charp png_convert_to_rfc1123 (png_structp \fP\fIpng_ptr\fP\fB, png_timep \fIptime\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_infop png_create_info_struct (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_structp png_create_read_struct (png_const_charp \fP\fIuser_png_ver\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fIwarn_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_structp png_create_read_struct_2 (png_const_charp \fP\fIuser_png_ver\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fP\fIwarn_fn\fP\fB, png_voidp \fP\fImem_ptr\fP\fB, png_malloc_ptr \fP\fImalloc_fn\fP\fB, png_free_ptr \fIfree_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_structp png_create_write_struct (png_const_charp \fP\fIuser_png_ver\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fIwarn_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_structp png_create_write_struct_2 (png_const_charp \fP\fIuser_png_ver\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fP\fIwarn_fn\fP\fB, png_voidp \fP\fImem_ptr\fP\fB, png_malloc_ptr \fP\fImalloc_fn\fP\fB, png_free_ptr \fIfree_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_data_freer (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIfreer\fP\fB, png_uint_32 \fImask)\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_destroy_info_struct (png_structp \fP\fIpng_ptr\fP\fB, png_infopp \fIinfo_ptr_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_destroy_read_struct (png_structpp \fP\fIpng_ptr_ptr\fP\fB, png_infopp \fP\fIinfo_ptr_ptr\fP\fB, png_infopp \fIend_info_ptr_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_destroy_write_struct (png_structpp \fP\fIpng_ptr_ptr\fP\fB, png_infopp \fIinfo_ptr_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_err (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_error (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fIerror\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_free (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fIptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_free_chunk_list (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_free_default (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fIptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_free_data (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fInum\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_bit_depth (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_bKGD (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_color_16p \fI*background\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_channels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_cHRM (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, double \fP\fI*white_x\fP\fB, double \fP\fI*white_y\fP\fB, double \fP\fI*red_x\fP\fB, double \fP\fI*red_y\fP\fB, double \fP\fI*green_x\fP\fB, double \fP\fI*green_y\fP\fB, double \fP\fI*blue_x\fP\fB, double \fI*blue_y\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_cHRM_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*white_x\fP\fB, png_uint_32 \fP\fI*white_y\fP\fB, png_uint_32 \fP\fI*red_x\fP\fB, png_uint_32 \fP\fI*red_y\fP\fB, png_uint_32 \fP\fI*green_x\fP\fB, png_uint_32 \fP\fI*green_y\fP\fB, png_uint_32 \fP\fI*blue_x\fP\fB, png_uint_32 \fI*blue_y\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_chunk_cache_max (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fI\fB
-
-\fBpng_alloc_size_t png_get_chunk_malloc_max (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_color_type (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_compression_buffer_size (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_compression_type (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_copyright (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_current_row_number \fI(png_const_structp\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_current_pass_number \fI(png_const_structp\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_get_error_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_filter_type (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_gAMA (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, double \fI*file_gamma\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_gAMA_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fI*int_file_gamma\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_header_ver (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_header_version (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_hIST (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_16p \fI*hist\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_iCCP (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_charpp \fP\fIname\fP\fB, int \fP\fI*compression_type\fP\fB, png_bytepp \fP\fIprofile\fP\fB, png_uint_32 \fI*proflen\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_IHDR (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*width\fP\fB, png_uint_32 \fP\fI*height\fP\fB, int \fP\fI*bit_depth\fP\fB, int \fP\fI*color_type\fP\fB, int \fP\fI*interlace_type\fP\fB, int \fP\fI*compression_type\fP\fB, int \fI*filter_type\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_image_height (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_image_width (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_int_32 png_get_int_32 (png_bytep \fIbuf\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_interlace_type (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_const_bytep png_get_io_chunk_name (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_io_chunk_type (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_get_io_ptr (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_io_state (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_libpng_ver (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_get_mem_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_oFFs (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*offset_x\fP\fB, png_uint_32 \fP\fI*offset_y\fP\fB, int \fI*unit_type\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_pCAL (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_charp \fP\fI*purpose\fP\fB, png_int_32 \fP\fI*X0\fP\fB, png_int_32 \fP\fI*X1\fP\fB, int \fP\fI*type\fP\fB, int \fP\fI*nparams\fP\fB, png_charp \fP\fI*units\fP\fB, png_charpp \fI*params\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_pHYs (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*res_x\fP\fB, png_uint_32 \fP\fI*res_y\fP\fB, int \fI*unit_type\fP\fB);\fP
-
-\fI\fB
-
-\fBfloat png_get_pixel_aspect_ratio (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_pHYs_dpi (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*res_x\fP\fB, png_uint_32 \fP\fI*res_y\fP\fB, int \fI*unit_type\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_fixed_point png_get_pixel_aspect_ratio_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_get_progressive_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_PLTE (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_colorp \fP\fI*palette\fP\fB, int \fI*num_palette\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_byte png_get_rgb_to_gray_status (png_const_structp \fIpng_ptr)
-
-\fBpng_uint_32 png_get_rowbytes (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_bytepp png_get_rows (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_sBIT (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_color_8p \fI*sig_bit\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_get_sCAL (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int* \fP\fIunit\fP\fB, double* \fP\fIwidth\fP\fB, double* \fIheight\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_get_sCAL_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int* \fP\fIunit\fP\fB, png_fixed_pointp \fP\fIwidth\fP\fB, png_fixed_pointp \fIheight\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_get_sCAL_s (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int* \fP\fIunit\fP\fB, png_charpp \fP\fIwidth\fP\fB, png_charpp \fIheight\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_bytep png_get_signature (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_sPLT (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_spalette_p \fI*splt_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_sRGB (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int \fI*file_srgb_intent\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_text (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_textp \fP\fI*text_ptr\fP\fB, int \fI*num_text\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_tIME (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_timep \fI*mod_time\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_tRNS (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_bytep \fP\fI*trans_alpha\fP\fB, int \fP\fI*num_trans\fP\fB, png_color_16p \fI*trans_color\fP\fB);\fP
-
-\fI\fB
-
-\fB/* This function is really an inline macro. \fI*/
-
-\fBpng_uint_16 png_get_uint_16 (png_bytep \fIbuf\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_uint_31 (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fIbuf\fP\fB);\fP
-
-\fI\fB
-
-\fB/* This function is really an inline macro. \fI*/
-
-\fBpng_uint_32 png_get_uint_32 (png_bytep \fIbuf\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_unknown_chunks (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_unknown_chunkpp \fIunknowns\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_get_user_chunk_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_user_height_max (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_get_user_transform_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_user_width_max (png_const_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_valid (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fIflag\fP\fB);\fP
-
-\fI\fB
-
-\fBfloat png_get_x_offset_inches (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_fixed_point png_get_x_offset_inches_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_int_32 png_get_x_offset_microns (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_int_32 png_get_x_offset_pixels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_x_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_x_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBfloat png_get_y_offset_inches (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_fixed_point png_get_y_offset_inches_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_int_32 png_get_y_offset_microns (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_int_32 png_get_y_offset_pixels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_y_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_get_y_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBint png_handle_as_unknown (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fIchunk_name\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_info_init_3 (png_infopp \fP\fIinfo_ptr\fP\fB, png_size_t \fIpng_info_struct_size\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_init_io (png_structp \fP\fIpng_ptr\fP\fB, FILE \fI*fp\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_longjmp (png_structp \fP\fIpng_ptr\fP\fB, int \fIval\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_malloc (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIsize\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_malloc_default (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIsize\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_voidp png_malloc_warn (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIsize\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_permit_mng_features (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fImng_features_permitted\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_process_data (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_bytep \fP\fIbuffer\fP\fB, png_size_t \fIbuffer_size\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_size_t png_process_data_pause \fP\fI(png_structp\fP\fB, int \fIsave\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_process_data_skip \fI(png_structp\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_progressive_combine_row (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIold_row\fP\fB, png_bytep \fInew_row\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_read_end (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_read_image (png_structp \fP\fIpng_ptr\fP\fB, png_bytepp \fIimage\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_read_info (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_read_png (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fItransforms\fP\fB, png_voidp \fIparams\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_read_row (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIrow\fP\fB, png_bytep \fIdisplay_row\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_read_rows (png_structp \fP\fIpng_ptr\fP\fB, png_bytepp \fP\fIrow\fP\fB, png_bytepp \fP\fIdisplay_row\fP\fB, png_uint_32 \fInum_rows\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_read_update_info (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBint png_reset_zstream (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_save_int_32 (png_bytep \fP\fIbuf\fP\fB, png_int_32 \fIi\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_save_uint_16 (png_bytep \fP\fIbuf\fP\fB, unsigned int \fIi\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_save_uint_32 (png_bytep \fP\fIbuf\fP\fB, png_uint_32 \fIi\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_add_alpha (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIfiller\fP\fB, int \fIflags\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_background (png_structp \fP\fIpng_ptr\fP\fB, png_color_16p \fP\fIbackground_color\fP\fB, int \fP\fIbackground_gamma_code\fP\fB, int \fP\fIneed_expand\fP\fB, double \fIbackground_gamma\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_background_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_color_16p \fP\fIbackground_color\fP\fB, int \fP\fIbackground_gamma_code\fP\fB, int \fP\fIneed_expand\fP\fB, png_uint_32 \fIbackground_gamma\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_benign_errors (png_structp \fP\fIpng_ptr\fP\fB, int \fIallowed\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_bgr (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_bKGD (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_color_16p \fIbackground\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_cHRM (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, double \fP\fIwhite_x\fP\fB, double \fP\fIwhite_y\fP\fB, double \fP\fIred_x\fP\fB, double \fP\fIred_y\fP\fB, double \fP\fIgreen_x\fP\fB, double \fP\fIgreen_y\fP\fB, double \fP\fIblue_x\fP\fB, double \fIblue_y\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_cHRM_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIwhite_x\fP\fB, png_uint_32 \fP\fIwhite_y\fP\fB, png_uint_32 \fP\fIred_x\fP\fB, png_uint_32 \fP\fIred_y\fP\fB, png_uint_32 \fP\fIgreen_x\fP\fB, png_uint_32 \fP\fIgreen_y\fP\fB, png_uint_32 \fP\fIblue_x\fP\fB, png_uint_32 \fIblue_y\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_chunk_cache_max (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fIuser_chunk_cache_max\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_compression_level (png_structp \fP\fIpng_ptr\fP\fB, int \fIlevel\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_compression_mem_level (png_structp \fP\fIpng_ptr\fP\fB, int \fImem_level\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_compression_method (png_structp \fP\fIpng_ptr\fP\fB, int \fImethod\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_compression_strategy (png_structp \fP\fIpng_ptr\fP\fB, int \fIstrategy\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_compression_window_bits (png_structp \fP\fIpng_ptr\fP\fB, int \fIwindow_bits\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_crc_action (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIcrit_action\fP\fB, int \fIancil_action\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_error_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fIwarning_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_expand (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_expand_gray_1_2_4_to_8 (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_filler (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIfiller\fP\fB, int \fIflags\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_filter (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fImethod\fP\fB, int \fIfilters\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_filter_heuristics (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIheuristic_method\fP\fB, int \fP\fInum_weights\fP\fB, png_doublep \fP\fIfilter_weights\fP\fB, png_doublep \fIfilter_costs\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_filter_heuristics_fixed (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIheuristic_method\fP\fB, int \fP\fInum_weights\fP\fB, png_fixed_point_p \fP\fIfilter_weights\fP\fB, png_fixed_point_p \fIfilter_costs\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_flush (png_structp \fP\fIpng_ptr\fP\fB, int \fInrows\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_gamma (png_structp \fP\fIpng_ptr\fP\fB, double \fP\fIscreen_gamma\fP\fB, double \fIdefault_file_gamma\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_gamma_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIscreen_gamma\fP\fB, png_uint_32 \fIdefault_file_gamma\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_gAMA (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, double \fIfile_gamma\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_gAMA_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fIfile_gamma\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_gray_1_2_4_to_8 (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_gray_to_rgb (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_hIST (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_16p \fIhist\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_iCCP (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_const_charp \fP\fIname\fP\fB, int \fP\fIcompression_type\fP\fB, png_const_bytep \fP\fIprofile\fP\fB, png_uint_32 \fIproflen\fP\fB);\fP
-
-\fI\fB
-
-\fBint png_set_interlace_handling (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_invalid (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fImask\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_invert_alpha (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_invert_mono (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_IHDR (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIwidth\fP\fB, png_uint_32 \fP\fIheight\fP\fB, int \fP\fIbit_depth\fP\fB, int \fP\fIcolor_type\fP\fB, int \fP\fIinterlace_type\fP\fB, int \fP\fIcompression_type\fP\fB, int \fIfilter_type\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_keep_unknown_chunks (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIkeep\fP\fB, png_bytep \fP\fIchunk_list\fP\fB, int \fInum_chunks\fP\fB);\fP
-
-\fI\fB
-
-\fBjmp_buf* png_set_longjmp_fn (png_structp \fP\fIpng_ptr\fP\fB, png_longjmp_ptr \fP\fIlongjmp_fn\fP\fB, size_t \fIjmp_buf_size\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_chunk_malloc_max (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIuser_chunk_cache_max\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_compression_buffer_size (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fIsize\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_mem_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fImem_ptr\fP\fB, png_malloc_ptr \fP\fImalloc_fn\fP\fB, png_free_ptr \fIfree_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_oFFs (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIoffset_x\fP\fB, png_uint_32 \fP\fIoffset_y\fP\fB, int \fIunit_type\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_packing (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_packswap (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_palette_to_rgb (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_pCAL (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_charp \fP\fIpurpose\fP\fB, png_int_32 \fP\fIX0\fP\fB, png_int_32 \fP\fIX1\fP\fB, int \fP\fItype\fP\fB, int \fP\fInparams\fP\fB, png_charp \fP\fIunits\fP\fB, png_charpp \fIparams\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_pHYs (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIres_x\fP\fB, png_uint_32 \fP\fIres_y\fP\fB, int \fIunit_type\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_progressive_read_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIprogressive_ptr\fP\fB, png_progressive_info_ptr \fP\fIinfo_fn\fP\fB, png_progressive_row_ptr \fP\fIrow_fn\fP\fB, png_progressive_end_ptr \fIend_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_PLTE (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_colorp \fP\fIpalette\fP\fB, int \fInum_palette\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_quantize (png_structp \fP\fIpng_ptr\fP\fB, png_colorp \fP\fIpalette\fP\fB, int \fP\fInum_palette\fP\fB, int \fP\fImaximum_colors\fP\fB, png_uint_16p \fP\fIhistogram\fP\fB, int \fIfull_quantize\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_read_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIio_ptr\fP\fB, png_rw_ptr \fIread_data_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_read_status_fn (png_structp \fP\fIpng_ptr\fP\fB, png_read_status_ptr \fIread_row_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_read_user_chunk_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIuser_chunk_ptr\fP\fB, png_user_chunk_ptr \fIread_user_chunk_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_read_user_transform_fn (png_structp \fP\fIpng_ptr\fP\fB, png_user_transform_ptr \fIread_user_transform_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_rgb_to_gray (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIerror_action\fP\fB, double \fP\fIred\fP\fB, double \fIgreen\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_rgb_to_gray_fixed (png_structp \fP\fIpng_ptr\fP\fB, int error_action png_uint_32 \fP\fIred\fP\fB, png_uint_32 \fIgreen\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_rows (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_bytepp \fIrow_pointers\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_sBIT (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_color_8p \fIsig_bit\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_sCAL (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIunit\fP\fB, double \fP\fIwidth\fP\fB, double \fIheight\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_sCAL_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIunit\fP\fB, png_fixed_point \fP\fIwidth\fP\fB, png_fixed_point \fIheight\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_sCAL_s (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIunit\fP\fB, png_charp \fP\fIwidth\fP\fB, png_charp \fIheight\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_shift (png_structp \fP\fIpng_ptr\fP\fB, png_color_8p \fItrue_bits\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_sig_bytes (png_structp \fP\fIpng_ptr\fP\fB, int \fInum_bytes\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_sPLT (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_spalette_p \fP\fIsplt_ptr\fP\fB, int \fInum_spalettes\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_sRGB (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fIsrgb_intent\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_sRGB_gAMA_and_cHRM (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fIsrgb_intent\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_strip_16 (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_strip_alpha (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_strip_error_numbers (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fIstrip_mode\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_swap (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_swap_alpha (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_text (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_textp \fP\fItext_ptr\fP\fB, int \fInum_text\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_tIME (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_timep \fImod_time\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_tRNS (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_bytep \fP\fItrans_alpha\fP\fB, int \fP\fInum_trans\fP\fB, png_color_16p \fItrans_color\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_tRNS_to_alpha (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBpng_uint_32 png_set_unknown_chunks (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_unknown_chunkp \fP\fIunknowns\fP\fB, int \fP\fInum\fP\fB, int \fIlocation\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_unknown_chunk_location (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIchunk\fP\fB, int \fIlocation\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_user_limits (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIuser_width_max\fP\fB, png_uint_32 \fIuser_height_max\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_user_transform_info (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIuser_transform_ptr\fP\fB, int \fP\fIuser_transform_depth\fP\fB, int \fIuser_transform_channels\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_write_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIio_ptr\fP\fB, png_rw_ptr \fP\fIwrite_data_fn\fP\fB, png_flush_ptr \fIoutput_flush_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_write_status_fn (png_structp \fP\fIpng_ptr\fP\fB, png_write_status_ptr \fIwrite_row_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_set_write_user_transform_fn (png_structp \fP\fIpng_ptr\fP\fB, png_user_transform_ptr \fIwrite_user_transform_fn\fP\fB);\fP
-
-\fI\fB
-
-\fBint png_sig_cmp (png_bytep \fP\fIsig\fP\fB, png_size_t \fP\fIstart\fP\fB, png_size_t \fInum_to_check\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_start_read_image (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_warning (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fImessage\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_chunk (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIchunk_name\fP\fB, png_bytep \fP\fIdata\fP\fB, png_size_t \fIlength\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_chunk_data (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIdata\fP\fB, png_size_t \fIlength\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_chunk_end (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_chunk_start (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIchunk_name\fP\fB, png_uint_32 \fIlength\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_end (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_flush (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_image (png_structp \fP\fIpng_ptr\fP\fB, png_bytepp \fIimage\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_info (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_info_before_PLTE (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_png (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fItransforms\fP\fB, png_voidp \fIparams\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_row (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fIrow\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_rows (png_structp \fP\fIpng_ptr\fP\fB, png_bytepp \fP\fIrow\fP\fB, png_uint_32 \fInum_rows\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_write_sig (png_structp \fIpng_ptr\fP\fB);\fP
-
-\fI\fB
-
-\fBvoidpf png_zalloc (voidpf \fP\fIpng_ptr\fP\fB, uInt \fP\fIitems\fP\fB, uInt \fIsize\fP\fB);\fP
-
-\fI\fB
-
-\fBvoid png_zfree (voidpf \fP\fIpng_ptr\fP\fB, voidpf \fIptr\fP\fB);\fP
-
-\fI\fB
-
-.SH DESCRIPTION
-The
-.I libpng
-library supports encoding, decoding, and various manipulations of
-the Portable Network Graphics (PNG) format image files.  It uses the
-.IR zlib(3)
-compression library.
-Following is a copy of the libpng-manual.txt file that accompanies libpng.
-.SH LIBPNG.TXT
-libpng-manual.txt - A description on how to use and modify libpng
-
- libpng version 1.5.1 - February 3, 2011
- Updated and distributed by Glenn Randers-Pehrson
- <glennrp at users.sourceforge.net>
- Copyright (c) 1998-2011 Glenn Randers-Pehrson
-
- This document is released under the libpng license.
- For conditions of distribution and use, see the disclaimer
- and license in png.h
-
- Based on:
-
- libpng versions 0.97, January 1998, through 1.5.1 - February 3, 2011
- Updated and distributed by Glenn Randers-Pehrson
- Copyright (c) 1998-2011 Glenn Randers-Pehrson
-
- libpng 1.0 beta 6  version 0.96 May 28, 1997
- Updated and distributed by Andreas Dilger
- Copyright (c) 1996, 1997 Andreas Dilger
-
- libpng 1.0 beta 2 - version 0.88  January 26, 1996
- For conditions of distribution and use, see copyright
- notice in png.h. Copyright (c) 1995, 1996 Guy Eric
- Schalnat, Group 42, Inc.
-
- Updated/rewritten per request in the libpng FAQ
- Copyright (c) 1995, 1996 Frank J. T. Wojcik
- December 18, 1995 & January 20, 1996
-
-.SH I. Introduction
-
-This file describes how to use and modify the PNG reference library
-(known as libpng) for your own use.  There are five sections to this
-file: introduction, structures, reading, writing, and modification and
-configuration notes for various special platforms.  In addition to this
-file, example.c is a good starting point for using the library, as
-it is heavily commented and should include everything most people
-will need.  We assume that libpng is already installed; see the
-INSTALL file for instructions on how to install libpng.
-
-For examples of libpng usage, see the files "example.c", "pngtest.c",
-and the files in the "contrib" directory, all of which are included in
-the libpng distribution.
-
-Libpng was written as a companion to the PNG specification, as a way
-of reducing the amount of time and effort it takes to support the PNG
-file format in application programs.
-
-The PNG specification (second edition), November 2003, is available as
-a W3C Recommendation and as an ISO Standard (ISO/IEC 15948:2003 (E)) at
-<http://www.w3.org/TR/2003/REC-PNG-20031110/
-The W3C and ISO documents have identical technical content.
-
-The PNG-1.2 specification is available at
-<http://www.libpng.org/pub/png/documents/>.  It is technically equivalent
-to the PNG specification (second edition) but has some additional material.
-
-The PNG-1.0 specification is available
-as RFC 2083 <http://www.libpng.org/pub/png/documents/> and as a
-W3C Recommendation <http://www.w3.org/TR/REC.png.html>.
-
-Some additional chunks are described in the special-purpose public chunks
-documents at <http://www.libpng.org/pub/png/documents/>.
-
-Other information
-about PNG, and the latest version of libpng, can be found at the PNG home
-page, <http://www.libpng.org/pub/png/>.
-
-Most users will not have to modify the library significantly; advanced
-users may want to modify it more.  All attempts were made to make it as
-complete as possible, while keeping the code easy to understand.
-Currently, this library only supports C.  Support for other languages
-is being considered.
-
-Libpng has been designed to handle multiple sessions at one time,
-to be easily modifiable, to be portable to the vast majority of
-machines (ANSI, K&R, 16-, 32-, and 64-bit) available, and to be easy
-to use.  The ultimate goal of libpng is to promote the acceptance of
-the PNG file format in whatever way possible.  While there is still
-work to be done (see the TODO file), libpng should cover the
-majority of the needs of its users.
-
-Libpng uses zlib for its compression and decompression of PNG files.
-Further information about zlib, and the latest version of zlib, can
-be found at the zlib home page, <http://www.info-zip.org/pub/infozip/zlib/>.
-The zlib compression utility is a general purpose utility that is
-useful for more than PNG files, and can be used without libpng.
-See the documentation delivered with zlib for more details.
-You can usually find the source files for the zlib utility wherever you
-find the libpng source files.
-
-Libpng is thread safe, provided the threads are using different
-instances of the structures.  Each thread should have its own
-png_struct and png_info instances, and thus its own image.
-Libpng does not protect itself against two threads using the
-same instance of a structure.
-
-.SH II. Structures
-
-There are two main structures that are important to libpng, png_struct
-and png_info.  Both are internal structures that are no longer exposed
-in the libpng interface (as of libpng 1.5.0).
-
-The png_info structure is designed to provide information about the
-PNG file.  At one time, the fields of png_info were intended to be
-directly accessible to the user.  However, this tended to cause problems
-with applications using dynamically loaded libraries, and as a result
-a set of interface functions for png_info (the png_get_*() and png_set_*()
-functions) was developed.
-
-The png_struct structure is the object used by the library to decode a
-single image.  As of 1.5.0 this structure is also not exposed.
-
-Almost all libpng APIs require a pointer to a png_struct as the first argument.
-Many (in particular the png_set and png_get APIs) also require a pointer
-to png_info as the second argument.  Some application visible macros
-defined in png.h designed for basic data access (reading and writing
-integers in the PNG format) break this rule, but it's almost always safe
-to assume that a (png_struct*) has to be passed to call an API function.
-
-The png.h header file is an invaluable reference for programming with libpng.
-And while I'm on the topic, make sure you include the libpng header file:
-
-#include <png.h>
-
-.SS Types
-
-The png.h header file defines a number of integral types used by the
-APIs.  Most of these are fairly obvious; for example types corresponding
-to integers of particular sizes and types for passing color values.
-
-One exception is how non-integral numbers are handled.  For application
-convenience most APIs that take such numbers have C (double) arguments,
-however internally PNG, and libpng, use 32 bit signed integers and encode
-the value by multiplying by 100,000.  As of libpng 1.5.0 a convenience
-macro PNG_FP_1 is defined in png.h along with a type (png_fixed_point)
-which is simply (png_int_32).
-
-All APIs that take (double) arguments also have an matching API that
-takes the corresponding fixed point integer arguments.  The fixed point
-API has the same name as the floating point one with _fixed appended.
-The actual range of values permitted in the APIs is frequently less than
-the full range of (png_fixed_point) (-21474 to +21474).  When APIs require
-a non-negative argument the type is recorded as png_uint_32 above.  Consult
-the header file and the text below for more information.
-
-Special care must be take with sCAL chunk handling because the chunk itself
-uses non-integral values encoded as strings containing decimal floating point
-numbers.  See the comments in the header file.
-
-.SS Configuration
-
-The main header file function declarations are frequently protected by C
-preprocessing directives of the form:
-
-    #ifdef PNG_feature_SUPPORTED
-    declare-function
-    #endif
-
-The library can be built without support for these APIs, although a
-standard build will have all implemented APIs.  Application programs
-should check the feature macros before using an API for maximum
-portability.  From libpng 1.5.0 the feature macros set during the build
-of libpng are recorded in the header file "pnglibconf.h" and this file
-is always included by png.h.
-
-If you don't need to change the library configuration from the default skip to
-the next section ("Reading").
-
-Notice that some of the makefiles in the 'scripts' directory and (in 1.5.0) all
-of the build project files in the 'projects' directory simply copy
-scripts/pnglibconf.h.prebuilt to pnglibconf.h.  This means that these build
-systems do not permit easy auto-configuration of the library - they only
-support the default configuration.
-
-The easiest way to make minor changes to the libpng configuration when
-auto-configuration is supported is to add definitions to the command line
-using (typically) CPPFLAGS.  For example:
-
-CPPFLAGS=-DPNG_NO_FLOATING_ARITHMETIC
-
-will change the internal libpng math implementation for gamma correction and
-other arithmetic calculations to fixed point, avoiding the need for fast
-floating point support.  The result can be seen in the generated pnglibconf.h -
-make sure it contains the changed feature macro setting.
-
-If you need to make more extensive configuration changes - more than one or two
-feature macro settings - you can either add -DPNG_USER_CONFIG to the build
-command line and put a list of feature macro settings in pngusr.h or you can set
-DFA_XTRA (a makefile variable) to a file containing the same information in the
-form of 'option' settings.
-
-A. Changing pnglibconf.h
-
-A variety of methods exist to build libpng.  Not all of these support
-reconfiguration of pnglibconf.h.  To reconfigure pnglibconf.h it must either be
-rebuilt from scripts/pnglibconf.dfa using awk or it must be edited by hand.
-
-Hand editing is achieved by copying scripts/pnglibconf.h.prebuilt and changing
-the lines defining the supported features, paying very close attention to the
-'option' information in scripts/pnglibconf.dfa that describes those features and
-their requirements.  This is easy to get wrong.
-
-B. Configuration using DFA_XTRA
-
-Rebuilding from pnglibconf.dfa is easy if a functioning 'awk', or a later
-variant such as 'nawk' or 'gawk', is available.  The configure build will
-automatically find an appropriate awk and build pnglibconf.h.
-scripts/pnglibconf.mak contains a set of make rules for doing the same thing if
-configure is not used, and many of the makefiles in the scripts directory use
-this approach.
-
-When rebuilding simply write new file containing changed options and set
-DFA_XTRA to the name of this file.  This causes the build to append the new file
-to the end of scripts/pnglibconf.dfa.  pngusr.dfa should contain lines of the
-following forms:
-
-everything = off
-
-This turns all optional features off.  Include it at the start of pngusr.dfa to
-make it easier to build a minimal configuration.  You will need to turn at least
-some features on afterward to enable either reading or writing code, or both.
-
-option feature on
-option feature off
-
-Enable or disable a single feature.  This will automatically enable other
-features required by a feature that is turned on or disable other features that
-require a feature which is turned off.  Conflicting settings will cause an error
-message to be emitted by awk.
-
-setting feature default value
-
-Changes the default value of setting 'feature' to 'value'.  There are a small
-number of settings listed at the top of pnglibconf.h, they are documented in the
-source code.  Most of these values have performance implications for the library
-but most of them have no visible effect on the API.  Some can also be overridden
-from the API.
-
-C. Configuration using PNG_USR_CONFIG
-
-If -DPNG_USR_CONFIG is added to the CFLAGS when pnglibconf.h is built the file
-pngusr.h will automatically be included before the options in
-scripts/pnglibconf.dfa are processed.  pngusr.h should contain only macro
-definitions turning features on or off or setting settings.
-
-Apart from the global setting "everything = off" all the options listed above
-can be set using macros in pngusr.h:
-
-#define PNG_feature_SUPPORTED
-
-is equivalent to:
-
-option feature on
-
-#define PNG_NO_feature
-
-is equivalent to:
-
-option feature off
-
-#define PNG_feature value
-
-is equivalent to:
-
-setting feature default value
-
-Notice that in both cases, pngusr.dfa and pngusr.h, the contents of the
-pngusr file you supply override the contents of scripts/pnglibconf.dfa
-
-If confusing or incomprehensible behavior results it is possible to
-examine the intermediate file pnglibconf.dfn to find the full set of
-dependency information for each setting and option.  Simply locate the
-feature in the file and read the C comments that precede it.
-
-.SH III. Reading
-
-We'll now walk you through the possible functions to call when reading
-in a PNG file sequentially, briefly explaining the syntax and purpose
-of each one.  See example.c and png.h for more detail.  While
-progressive reading is covered in the next section, you will still
-need some of the functions discussed in this section to read a PNG
-file.
-
-.SS Setup
-
-You will want to do the I/O initialization(*) before you get into libpng,
-so if it doesn't work, you don't have much to undo.  Of course, you
-will also want to insure that you are, in fact, dealing with a PNG
-file.  Libpng provides a simple check to see if a file is a PNG file.
-To use it, pass in the first 1 to 8 bytes of the file to the function
-png_sig_cmp(), and it will return 0 (false) if the bytes match the
-corresponding bytes of the PNG signature, or nonzero (true) otherwise.
-Of course, the more bytes you pass in, the greater the accuracy of the
-prediction.
-
-If you are intending to keep the file pointer open for use in libpng,
-you must ensure you don't read more than 8 bytes from the beginning
-of the file, and you also have to make a call to png_set_sig_bytes_read()
-with the number of bytes you read from the beginning.  Libpng will
-then only check the bytes (if any) that your program didn't read.
-
-(*): If you are not using the standard I/O functions, you will need
-to replace them with custom functions.  See the discussion under
-Customizing libpng.
-
-
-    FILE *fp = fopen(file_name, "rb");
-    if (!fp)
-    {
-       return (ERROR);
-    }
-
-    fread(header, 1, number, fp);
-    is_png = !png_sig_cmp(header, 0, number);
-
-    if (!is_png)
-    {
-       return (NOT_PNG);
-    }
-
-
-Next, png_struct and png_info need to be allocated and initialized.  In
-order to ensure that the size of these structures is correct even with a
-dynamically linked libpng, there are functions to initialize and
-allocate the structures.  We also pass the library version, optional
-pointers to error handling functions, and a pointer to a data struct for
-use by the error functions, if necessary (the pointer and functions can
-be NULL if the default error handlers are to be used).  See the section
-on Changes to Libpng below regarding the old initialization functions.
-The structure allocation functions quietly return NULL if they fail to
-create the structure, so your application should check for that.
-
-    png_structp png_ptr = png_create_read_struct
-        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-        user_error_fn, user_warning_fn);
-
-    if (!png_ptr)
-       return (ERROR);
-
-    png_infop info_ptr = png_create_info_struct(png_ptr);
-
-    if (!info_ptr)
-    {
-       png_destroy_read_struct(&png_ptr,
-           (png_infopp)NULL, (png_infopp)NULL);
-       return (ERROR);
-    }
-
-    png_infop end_info = png_create_info_struct(png_ptr);
-
-    if (!end_info)
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-          (png_infopp)NULL);
-       return (ERROR);
-    }
-
-If you want to use your own memory allocation routines,
-use a libpng that was built with PNG_USER_MEM_SUPPORTED defined, and use
-png_create_read_struct_2() instead of png_create_read_struct():
-
-    png_structp png_ptr = png_create_read_struct_2
-       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-        user_error_fn, user_warning_fn, (png_voidp)
-        user_mem_ptr, user_malloc_fn, user_free_fn);
-
-The error handling routines passed to png_create_read_struct()
-and the memory alloc/free routines passed to png_create_struct_2()
-are only necessary if you are not using the libpng supplied error
-handling and memory alloc/free functions.
-
-When libpng encounters an error, it expects to longjmp back
-to your routine.  Therefore, you will need to call setjmp and pass
-your png_jmpbuf(png_ptr).  If you read the file from different
-routines, you will need to update the jmpbuf field every time you enter
-a new routine that will call a png_*() function.
-
-See your documentation of setjmp/longjmp for your compiler for more
-information on setjmp/longjmp.  See the discussion on libpng error
-handling in the Customizing Libpng section below for more information
-on the libpng error handling.  If an error occurs, and libpng longjmp's
-back to your setjmp, you will want to call png_destroy_read_struct() to
-free any memory.
-
-    if (setjmp(png_jmpbuf(png_ptr)))
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-           &end_info);
-       fclose(fp);
-       return (ERROR);
-    }
-
-If you would rather avoid the complexity of setjmp/longjmp issues,
-you can compile libpng with PNG_NO_SETJMP, in which case
-errors will result in a call to PNG_ABORT() which defaults to abort().
-
-You can #define PNG_ABORT() to a function that does something
-more useful than abort(), as long as your function does not
-return.
-
-Now you need to set up the input code.  The default for libpng is to
-use the C function fread().  If you use this, you will need to pass a
-valid FILE * in the function png_init_io().  Be sure that the file is
-opened in binary mode.  If you wish to handle reading data in another
-way, you need not call the png_init_io() function, but you must then
-implement the libpng I/O methods discussed in the Customizing Libpng
-section below.
-
-    png_init_io(png_ptr, fp);
-
-If you had previously opened the file and read any of the signature from
-the beginning in order to see if this was a PNG file, you need to let
-libpng know that there are some bytes missing from the start of the file.
-
-    png_set_sig_bytes(png_ptr, number);
-
-You can change the zlib compression buffer size to be used while
-reading compressed data with
-
-    png_set_compression_buffer_size(png_ptr, buffer_size);
-
-where the default size is 8192 bytes.  Note that the buffer size
-is changed immediately and the buffer is reallocated immediately,
-instead of setting a flag to be acted upon later.
-
-If you want CRC errors to be handled in a different manner than
-the default, use
-
-    png_set_crc_action(png_ptr, crit_action, ancil_action);
-
-The values for png_set_crc_action() say how libpng is to handle CRC errors in
-ancillary and critical chunks, and whether to use the data contained
-therein.  Note that it is impossible to "discard" data in a critical
-chunk.
-
-Choices for (int) crit_action are
-   PNG_CRC_DEFAULT      0  error/quit
-   PNG_CRC_ERROR_QUIT   1  error/quit
-   PNG_CRC_WARN_USE     3  warn/use data
-   PNG_CRC_QUIET_USE    4  quiet/use data
-   PNG_CRC_NO_CHANGE    5  use the current value
-
-Choices for (int) ancil_action are
-   PNG_CRC_DEFAULT      0  error/quit
-   PNG_CRC_ERROR_QUIT   1  error/quit
-   PNG_CRC_WARN_DISCARD 2  warn/discard data
-   PNG_CRC_WARN_USE     3  warn/use data
-   PNG_CRC_QUIET_USE    4  quiet/use data
-   PNG_CRC_NO_CHANGE    5  use the current value
-
-.SS Setting up callback code
-
-You can set up a callback function to handle any unknown chunks in the
-input stream. You must supply the function
-
-    read_chunk_callback(png_structp png_ptr,
-         png_unknown_chunkp chunk);
-    {
-       /* The unknown chunk structure contains your
-          chunk data, along with similar data for any other
-          unknown chunks: */
-
-           png_byte name[5];
-           png_byte *data;
-           png_size_t size;
-
-       /* Note that libpng has already taken care of
-          the CRC handling */
-
-       /* put your code here.  Search for your chunk in the
-          unknown chunk structure, process it, and return one
-          of the following: */
-
-       return (-n); /* chunk had an error */
-       return (0); /* did not recognize */
-       return (n); /* success */
-    }
-
-(You can give your function another name that you like instead of
-"read_chunk_callback")
-
-To inform libpng about your function, use
-
-    png_set_read_user_chunk_fn(png_ptr, user_chunk_ptr,
-        read_chunk_callback);
-
-This names not only the callback function, but also a user pointer that
-you can retrieve with
-
-    png_get_user_chunk_ptr(png_ptr);
-
-If you call the png_set_read_user_chunk_fn() function, then all unknown
-chunks will be saved when read, in case your callback function will need
-one or more of them.  This behavior can be changed with the
-png_set_keep_unknown_chunks() function, described below.
-
-At this point, you can set up a callback function that will be
-called after each row has been read, which you can use to control
-a progress meter or the like.  It's demonstrated in pngtest.c.
-You must supply a function
-
-    void read_row_callback(png_structp png_ptr,
-       png_uint_32 row, int pass);
-    {
-      /* put your code here */
-    }
-
-(You can give it another name that you like instead of "read_row_callback")
-
-To inform libpng about your function, use
-
-    png_set_read_status_fn(png_ptr, read_row_callback);
-
-.SS Unknown-chunk handling
-
-Now you get to set the way the library processes unknown chunks in the
-input PNG stream. Both known and unknown chunks will be read.  Normal
-behavior is that known chunks will be parsed into information in
-various info_ptr members while unknown chunks will be discarded. This
-behavior can be wasteful if your application will never use some known
-chunk types. To change this, you can call:
-
-    png_set_keep_unknown_chunks(png_ptr, keep,
-        chunk_list, num_chunks);
-    keep       - 0: default unknown chunk handling
-                 1: ignore; do not keep
-                 2: keep only if safe-to-copy
-                 3: keep even if unsafe-to-copy
-
-               You can use these definitions:
-                 PNG_HANDLE_CHUNK_AS_DEFAULT   0
-                 PNG_HANDLE_CHUNK_NEVER        1
-                 PNG_HANDLE_CHUNK_IF_SAFE      2
-                 PNG_HANDLE_CHUNK_ALWAYS       3
-
-    chunk_list - list of chunks affected (a byte string,
-                 five bytes per chunk, NULL or '\0' if
-                 num_chunks is 0)
-
-    num_chunks - number of chunks affected; if 0, all
-                 unknown chunks are affected.  If nonzero,
-                 only the chunks in the list are affected
-
-Unknown chunks declared in this way will be saved as raw data onto a
-list of png_unknown_chunk structures.  If a chunk that is normally
-known to libpng is named in the list, it will be handled as unknown,
-according to the "keep" directive.  If a chunk is named in successive
-instances of png_set_keep_unknown_chunks(), the final instance will
-take precedence.  The IHDR and IEND chunks should not be named in
-chunk_list; if they are, libpng will process them normally anyway.
-
-Here is an example of the usage of png_set_keep_unknown_chunks(),
-where the private "vpAg" chunk will later be processed by a user chunk
-callback function:
-
-    png_byte vpAg[5]={118, 112,  65, 103, (png_byte) '\0'};
-
-    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-      png_byte unused_chunks[]=
-      {
-        104,  73,  83,  84, (png_byte) '\0',   /* hIST */
-        105,  84,  88, 116, (png_byte) '\0',   /* iTXt */
-        112,  67,  65,  76, (png_byte) '\0',   /* pCAL */
-        115,  67,  65,  76, (png_byte) '\0',   /* sCAL */
-        115,  80,  76,  84, (png_byte) '\0',   /* sPLT */
-        116,  73,  77,  69, (png_byte) '\0',   /* tIME */
-      };
-    #endif
-
-    ...
-
-    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-      /* ignore all unknown chunks: */
-      png_set_keep_unknown_chunks(read_ptr, 1, NULL, 0);
-
-      /* except for vpAg: */
-      png_set_keep_unknown_chunks(read_ptr, 2, vpAg, 1);
-
-      /* also ignore unused known chunks: */
-      png_set_keep_unknown_chunks(read_ptr, 1, unused_chunks,
-         (int)sizeof(unused_chunks)/5);
-    #endif
-
-.SS User limits
-
-The PNG specification allows the width and height of an image to be as
-large as 2^31-1 (0x7fffffff), or about 2.147 billion rows and columns.
-Since very few applications really need to process such large images,
-we have imposed an arbitrary 1-million limit on rows and columns.
-Larger images will be rejected immediately with a png_error() call. If
-you wish to override this limit, you can use
-
-   png_set_user_limits(png_ptr, width_max, height_max);
-
-to set your own limits, or use width_max = height_max = 0x7fffffffL
-to allow all valid dimensions (libpng may reject some very large images
-anyway because of potential buffer overflow conditions).
-
-You should put this statement after you create the PNG structure and
-before calling png_read_info(), png_read_png(), or png_process_data().
-If you need to retrieve the limits that are being applied, use
-
-   width_max = png_get_user_width_max(png_ptr);
-   height_max = png_get_user_height_max(png_ptr);
-
-The PNG specification sets no limit on the number of ancillary chunks
-allowed in a PNG datastream.  You can impose a limit on the total number
-of sPLT, tEXt, iTXt, zTXt, and unknown chunks that will be stored, with
-
-   png_set_chunk_cache_max(png_ptr, user_chunk_cache_max);
-
-where 0x7fffffffL means unlimited.  You can retrieve this limit with
-
-   chunk_cache_max = png_get_chunk_cache_max(png_ptr);
-
-This limit also applies to the number of buffers that can be allocated
-by png_decompress_chunk() while decompressing iTXt, zTXt, and iCCP chunks.
-
-You can also set a limit on the amount of memory that a compressed chunk
-other than IDAT can occupy, with
-
-   png_set_chunk_malloc_max(png_ptr, user_chunk_malloc_max);
-
-and you can retrieve the limit with
-
-   chunk_malloc_max = png_get_chunk_malloc_max(png_ptr);
-
-Any chunks that would cause either of these limits to be exceeded will
-be ignored.
-
-.SS The high-level read interface
-
-At this point there are two ways to proceed; through the high-level
-read interface, or through a sequence of low-level read operations.
-You can use the high-level interface if (a) you are willing to read
-the entire image into memory, and (b) the input transformations
-you want to do are limited to the following set:
-
-    PNG_TRANSFORM_IDENTITY      No transformation
-    PNG_TRANSFORM_STRIP_16      Strip 16-bit samples to
-                                8 bits
-    PNG_TRANSFORM_STRIP_ALPHA   Discard the alpha channel
-    PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit
-                                samples to bytes
-    PNG_TRANSFORM_PACKSWAP      Change order of packed
-                                pixels to LSB first
-    PNG_TRANSFORM_EXPAND        Perform set_expand()
-    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
-    PNG_TRANSFORM_SHIFT         Normalize pixels to the
-                                sBIT depth
-    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA
-                                to BGRA
-    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA
-                                to AG
-    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity
-                                to transparency
-    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
-    PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples
-                                to RGB (or GA to RGBA)
-
-(This excludes setting a background color, doing gamma transformation,
-quantizing, and setting filler.)  If this is the case, simply do this:
-
-    png_read_png(png_ptr, info_ptr, png_transforms, NULL)
-
-where png_transforms is an integer containing the bitwise OR of some
-set of transformation flags.  This call is equivalent to png_read_info(),
-followed the set of transformations indicated by the transform mask,
-then png_read_image(), and finally png_read_end().
-
-(The final parameter of this call is not yet used.  Someday it might point
-to transformation parameters required by some future input transform.)
-
-You must use png_transforms and not call any png_set_transform() functions
-when you use png_read_png().
-
-After you have called png_read_png(), you can retrieve the image data
-with
-
-   row_pointers = png_get_rows(png_ptr, info_ptr);
-
-where row_pointers is an array of pointers to the pixel data for each row:
-
-   png_bytep row_pointers[height];
-
-If you know your image size and pixel size ahead of time, you can allocate
-row_pointers prior to calling png_read_png() with
-
-   if (height > PNG_UINT_32_MAX/png_sizeof(png_byte))
-      png_error (png_ptr,
-          "Image is too tall to process in memory");
-
-   if (width > PNG_UINT_32_MAX/pixel_size)
-      png_error (png_ptr,
-          "Image is too wide to process in memory");
-
-   row_pointers = png_malloc(png_ptr,
-       height*png_sizeof(png_bytep));
-
-   for (int i=0; i<height, i++)
-      row_pointers[i]=NULL;  /* security precaution */
-
-   for (int i=0; i<height, i++)
-      row_pointers[i]=png_malloc(png_ptr,
-          width*pixel_size);
-
-   png_set_rows(png_ptr, info_ptr, &row_pointers);
-
-Alternatively you could allocate your image in one big block and define
-row_pointers[i] to point into the proper places in your block.
-
-If you use png_set_rows(), the application is responsible for freeing
-row_pointers (and row_pointers[i], if they were separately allocated).
-
-If you don't allocate row_pointers ahead of time, png_read_png() will
-do it, and it'll be free'ed by libpng when you call png_destroy_*().
-
-.SS The low-level read interface
-
-If you are going the low-level route, you are now ready to read all
-the file information up to the actual image data.  You do this with a
-call to png_read_info().
-
-    png_read_info(png_ptr, info_ptr);
-
-This will process all chunks up to but not including the image data.
-
-.SS Querying the info structure
-
-Functions are used to get the information from the info_ptr once it
-has been read.  Note that these fields may not be completely filled
-in until png_read_end() has read the chunk data following the image.
-
-    png_get_IHDR(png_ptr, info_ptr, &width, &height,
-       &bit_depth, &color_type, &interlace_type,
-       &compression_type, &filter_method);
-
-    width          - holds the width of the image
-                     in pixels (up to 2^31).
-
-    height         - holds the height of the image
-                     in pixels (up to 2^31).
-
-    bit_depth      - holds the bit depth of one of the
-                     image channels.  (valid values are
-                     1, 2, 4, 8, 16 and depend also on
-                     the color_type.  See also
-                     significant bits (sBIT) below).
-
-    color_type     - describes which color/alpha channels
-                         are present.
-                     PNG_COLOR_TYPE_GRAY
-                        (bit depths 1, 2, 4, 8, 16)
-                     PNG_COLOR_TYPE_GRAY_ALPHA
-                        (bit depths 8, 16)
-                     PNG_COLOR_TYPE_PALETTE
-                        (bit depths 1, 2, 4, 8)
-                     PNG_COLOR_TYPE_RGB
-                        (bit_depths 8, 16)
-                     PNG_COLOR_TYPE_RGB_ALPHA
-                        (bit_depths 8, 16)
-
-                     PNG_COLOR_MASK_PALETTE
-                     PNG_COLOR_MASK_COLOR
-                     PNG_COLOR_MASK_ALPHA
-
-    interlace_type - (PNG_INTERLACE_NONE or
-                     PNG_INTERLACE_ADAM7)
-
-    compression_type - (must be PNG_COMPRESSION_TYPE_BASE
-                     for PNG 1.0)
-
-    filter_method  - (must be PNG_FILTER_TYPE_BASE
-                     for PNG 1.0, and can also be
-                     PNG_INTRAPIXEL_DIFFERENCING if
-                     the PNG datastream is embedded in
-                     a MNG-1.0 datastream)
-
-    Any or all of interlace_type, compression_type, or
-    filter_method can be NULL if you are
-    not interested in their values.
-
-    Note that png_get_IHDR() returns 32-bit data into
-    the application's width and height variables.
-    This is an unsafe situation if these are 16-bit
-    variables.  In such situations, the
-    png_get_image_width() and png_get_image_height()
-    functions described below are safer.
-
-    width            = png_get_image_width(png_ptr,
-                         info_ptr);
-
-    height           = png_get_image_height(png_ptr,
-                         info_ptr);
-
-    bit_depth        = png_get_bit_depth(png_ptr,
-                         info_ptr);
-
-    color_type       = png_get_color_type(png_ptr,
-                         info_ptr);
-
-    interlace_type   = png_get_interlace_type(png_ptr,
-                         info_ptr);
-
-    compression_type = png_get_compression_type(png_ptr,
-                         info_ptr);
-
-    filter_method    = png_get_filter_type(png_ptr,
-                         info_ptr);
-
-    channels = png_get_channels(png_ptr, info_ptr);
-
-    channels       - number of channels of info for the
-                     color type (valid values are 1 (GRAY,
-                     PALETTE), 2 (GRAY_ALPHA), 3 (RGB),
-                     4 (RGB_ALPHA or RGB + filler byte))
-
-    rowbytes = png_get_rowbytes(png_ptr, info_ptr);
-
-    rowbytes       - number of bytes needed to hold a row
-
-    signature = png_get_signature(png_ptr, info_ptr);
-
-    signature      - holds the signature read from the
-                     file (if any).  The data is kept in
-                     the same offset it would be if the
-                     whole signature were read (i.e. if an
-                     application had already read in 4
-                     bytes of signature before starting
-                     libpng, the remaining 4 bytes would
-                     be in signature[4] through signature[7]
-                     (see png_set_sig_bytes())).
-
-These are also important, but their validity depends on whether the chunk
-has been read.  The png_get_valid(png_ptr, info_ptr, PNG_INFO_<chunk>) and
-png_get_<chunk>(png_ptr, info_ptr, ...) functions return non-zero if the
-data has been read, or zero if it is missing.  The parameters to the
-png_get_<chunk> are set directly if they are simple data types, or a
-pointer into the info_ptr is returned for any complex types.
-
-    png_get_PLTE(png_ptr, info_ptr, &palette,
-                     &num_palette);
-
-    palette        - the palette for the file
-                     (array of png_color)
-
-    num_palette    - number of entries in the palette
-
-    png_get_gAMA(png_ptr, info_ptr, &file_gamma);
-    png_get_gAMA_fixed(png_ptr, info_ptr, &int_file_gamma);
-
-    file_gamma     - the gamma at which the file is
-                     written (PNG_INFO_gAMA)
-
-    int_file_gamma - 100,000 times the gamma at which the
-                     file is written
-
-    png_get_sRGB(png_ptr, info_ptr, &srgb_intent);
-
-    file_srgb_intent - the rendering intent (PNG_INFO_sRGB)
-                     The presence of the sRGB chunk
-                     means that the pixel data is in the
-                     sRGB color space.  This chunk also
-                     implies specific values of gAMA and
-                     cHRM.
-
-    png_get_iCCP(png_ptr, info_ptr, &name,
-       &compression_type, &profile, &proflen);
-
-    name             - The profile name.
-
-    compression_type - The compression type; always
-                       PNG_COMPRESSION_TYPE_BASE for PNG 1.0.
-                       You may give NULL to this argument to
-                       ignore it.
-
-    profile          - International Color Consortium color
-                       profile data. May contain NULs.
-
-    proflen          - length of profile data in bytes.
-
-    png_get_sBIT(png_ptr, info_ptr, &sig_bit);
-
-    sig_bit        - the number of significant bits for
-                     (PNG_INFO_sBIT) each of the gray,
-                     red, green, and blue channels,
-                     whichever are appropriate for the
-                     given color type (png_color_16)
-
-    png_get_tRNS(png_ptr, info_ptr, &trans_alpha,
-                     &num_trans, &trans_color);
-
-    trans_alpha    - array of alpha (transparency)
-                     entries for palette (PNG_INFO_tRNS)
-
-    num_trans      - number of transparent entries
-                     (PNG_INFO_tRNS)
-
-    trans_color    - graylevel or color sample values of
-                     the single transparent color for
-                     non-paletted images (PNG_INFO_tRNS)
-
-    png_get_hIST(png_ptr, info_ptr, &hist);
-                     (PNG_INFO_hIST)
-
-    hist           - histogram of palette (array of
-                     png_uint_16)
-
-    png_get_tIME(png_ptr, info_ptr, &mod_time);
-
-    mod_time       - time image was last modified
-                    (PNG_VALID_tIME)
-
-    png_get_bKGD(png_ptr, info_ptr, &background);
-
-    background     - background color (PNG_VALID_bKGD)
-                     valid 16-bit red, green and blue
-                     values, regardless of color_type
-
-    num_comments   = png_get_text(png_ptr, info_ptr,
-                     &text_ptr, &num_text);
-
-    num_comments   - number of comments
-
-    text_ptr       - array of png_text holding image
-                     comments
-
-    text_ptr[i].compression - type of compression used
-                 on "text" PNG_TEXT_COMPRESSION_NONE
-                           PNG_TEXT_COMPRESSION_zTXt
-                           PNG_ITXT_COMPRESSION_NONE
-                           PNG_ITXT_COMPRESSION_zTXt
-
-    text_ptr[i].key   - keyword for comment.  Must contain
-                         1-79 characters.
-
-    text_ptr[i].text  - text comments for current
-                         keyword.  Can be empty.
-
-    text_ptr[i].text_length - length of text string,
-                 after decompression, 0 for iTXt
-
-    text_ptr[i].itxt_length - length of itxt string,
-                 after decompression, 0 for tEXt/zTXt
-
-    text_ptr[i].lang  - language of comment (empty
-                         string for unknown).
-
-    text_ptr[i].lang_key  - keyword in UTF-8
-                         (empty string for unknown).
-
-    Note that the itxt_length, lang, and lang_key
-    members of the text_ptr structure only exist
-    when the library is built with iTXt chunk support.
-
-    num_text       - number of comments (same as
-                     num_comments; you can put NULL here
-                     to avoid the duplication)
-
-    Note while png_set_text() will accept text, language,
-    and translated keywords that can be NULL pointers, the
-    structure returned by png_get_text will always contain
-    regular zero-terminated C strings.  They might be
-    empty strings but they will never be NULL pointers.
-
-    num_spalettes = png_get_sPLT(png_ptr, info_ptr,
-       &palette_ptr);
-
-    num_spalettes  - number of sPLT chunks read.
-
-    palette_ptr    - array of palette structures holding
-                     contents of one or more sPLT chunks
-                     read.
-
-    png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y,
-       &unit_type);
-
-    offset_x       - positive offset from the left edge
-                     of the screen
-
-    offset_y       - positive offset from the top edge
-                     of the screen
-
-    unit_type      - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
-
-    png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y,
-       &unit_type);
-
-    res_x          - pixels/unit physical resolution in
-                     x direction
-
-    res_y          - pixels/unit physical resolution in
-                     x direction
-
-    unit_type      - PNG_RESOLUTION_UNKNOWN,
-                     PNG_RESOLUTION_METER
-
-    png_get_sCAL(png_ptr, info_ptr, &unit, &width,
-       &height)
-
-    unit        - physical scale units (an integer)
-
-    width       - width of a pixel in physical scale units
-
-    height      - height of a pixel in physical scale units
-                 (width and height are doubles)
-
-    png_get_sCAL_s(png_ptr, info_ptr, &unit, &width,
-       &height)
-
-    unit        - physical scale units (an integer)
-
-    width       - width of a pixel in physical scale units
-
-    height      - height of a pixel in physical scale units
-                 (width and height are strings like "2.54")
-
-    num_unknown_chunks = png_get_unknown_chunks(png_ptr,
-       info_ptr, &unknowns)
-
-    unknowns          - array of png_unknown_chunk
-                        structures holding unknown chunks
-
-    unknowns[i].name  - name of unknown chunk
-
-    unknowns[i].data  - data of unknown chunk
-
-    unknowns[i].size  - size of unknown chunk's data
-
-    unknowns[i].location - position of chunk in file
-
-    The value of "i" corresponds to the order in which the
-    chunks were read from the PNG file or inserted with the
-    png_set_unknown_chunks() function.
-
-The data from the pHYs chunk can be retrieved in several convenient
-forms:
-
-    res_x = png_get_x_pixels_per_meter(png_ptr,
-       info_ptr)
-
-    res_y = png_get_y_pixels_per_meter(png_ptr,
-       info_ptr)
-
-    res_x_and_y = png_get_pixels_per_meter(png_ptr,
-       info_ptr)
-
-    res_x = png_get_x_pixels_per_inch(png_ptr,
-       info_ptr)
-
-    res_y = png_get_y_pixels_per_inch(png_ptr,
-       info_ptr)
-
-    res_x_and_y = png_get_pixels_per_inch(png_ptr,
-       info_ptr)
-
-    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
-       info_ptr)
-
-    Each of these returns 0 [signifying "unknown"] if
-       the data is not present or if res_x is 0;
-       res_x_and_y is 0 if res_x != res_y
-
-    Note that because of the way the resolutions are
-       stored internally, the inch conversions won't
-       come out to exactly even number.  For example,
-       72 dpi is stored as 0.28346 pixels/meter, and
-       when this is retrieved it is 71.9988 dpi, so
-       be sure to round the returned value appropriately
-       if you want to display a reasonable-looking result. 
-
-The data from the oFFs chunk can be retrieved in several convenient
-forms:
-
-    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);
-
-    y_offset = png_get_y_offset_microns(png_ptr, info_ptr);
-
-    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);
-
-    y_offset = png_get_y_offset_inches(png_ptr, info_ptr);
-
-    Each of these returns 0 [signifying "unknown" if both
-       x and y are 0] if the data is not present or if the
-       chunk is present but the unit is the pixel.  The
-       remark about inexact inch conversions applies here
-       as well, because a value in inches can't always be
-       converted to microns and back without some loss
-       of precision.
-
-For more information, see the png_info definition in png.h and the
-PNG specification for chunk contents.  Be careful with trusting
-rowbytes, as some of the transformations could increase the space
-needed to hold a row (expand, filler, gray_to_rgb, etc.).
-See png_read_update_info(), below.
-
-A quick word about text_ptr and num_text.  PNG stores comments in
-keyword/text pairs, one pair per chunk, with no limit on the number
-of text chunks, and a 2^31 byte limit on their size.  While there are
-suggested keywords, there is no requirement to restrict the use to these
-strings.  It is strongly suggested that keywords and text be sensible
-to humans (that's the point), so don't use abbreviations.  Non-printing
-symbols are not allowed.  See the PNG specification for more details.
-There is also no requirement to have text after the keyword.
-
-Keywords should be limited to 79 Latin-1 characters without leading or
-trailing spaces, but non-consecutive spaces are allowed within the
-keyword.  It is possible to have the same keyword any number of times.
-The text_ptr is an array of png_text structures, each holding a
-pointer to a language string, a pointer to a keyword and a pointer to
-a text string.  The text string, language code, and translated
-keyword may be empty or NULL pointers.  The keyword/text
-pairs are put into the array in the order that they are received.
-However, some or all of the text chunks may be after the image, so, to
-make sure you have read all the text chunks, don't mess with these
-until after you read the stuff after the image.  This will be
-mentioned again below in the discussion that goes with png_read_end().
-
-.SS Input transformations
-
-After you've read the header information, you can set up the library
-to handle any special transformations of the image data.  The various
-ways to transform the data will be described in the order that they
-should occur.  This is important, as some of these change the color
-type and/or bit depth of the data, and some others only work on
-certain color types and bit depths.  Even though each transformation
-checks to see if it has data that it can do something with, you should
-make sure to only enable a transformation if it will be valid for the
-data.  For example, don't swap red and blue on grayscale data.
-
-The colors used for the background and transparency values should be
-supplied in the same format/depth as the current image data.  They
-are stored in the same format/depth as the image data in a bKGD or tRNS
-chunk, so this is what libpng expects for this data.  The colors are
-transformed to keep in sync with the image data when an application
-calls the png_read_update_info() routine (see below).
-
-Data will be decoded into the supplied row buffers packed into bytes
-unless the library has been told to transform it into another format.
-For example, 4 bit/pixel paletted or grayscale data will be returned
-2 pixels/byte with the leftmost pixel in the high-order bits of the
-byte, unless png_set_packing() is called.  8-bit RGB data will be stored
-in RGB RGB RGB format unless png_set_filler() or png_set_add_alpha()
-is called to insert filler bytes, either before or after each RGB triplet.
-16-bit RGB data will be returned RRGGBB RRGGBB, with the most significant
-byte of the color value first, unless png_set_strip_16() is called to
-transform it to regular RGB RGB triplets, or png_set_filler() or
-png_set_add alpha() is called to insert filler bytes, either before or
-after each RRGGBB triplet.  Similarly, 8-bit or 16-bit grayscale data can
-be modified with
-png_set_filler(), png_set_add_alpha(), or png_set_strip_16().
-
-The following code transforms grayscale images of less than 8 to 8 bits,
-changes paletted images to RGB, and adds a full alpha channel if there is
-transparency information in a tRNS chunk.  This is most useful on
-grayscale images with bit depths of 2 or 4 or if there is a multiple-image
-viewing application that wishes to treat all images in the same way.
-
-    if (color_type == PNG_COLOR_TYPE_PALETTE)
-        png_set_palette_to_rgb(png_ptr);
-
-    if (color_type == PNG_COLOR_TYPE_GRAY &&
-        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);
-
-    if (png_get_valid(png_ptr, info_ptr,
-        PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png_ptr);
-
-These three functions are actually aliases for png_set_expand(), added
-in libpng version 1.0.4, with the function names expanded to improve code
-readability.  In some future version they may actually do different
-things.
-
-As of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was
-added.  It expands the sample depth without changing tRNS to alpha.
-
-As of libpng version 1.5.1, not all possible expansions are supported.
-
-In the following table, the 01 means grayscale with depth<8, 31 means
-indexed with depth<8, other numerals represent the color type, "T" means
-the tRNS chunk is present, A means an alpha channel is present, and O
-means tRNS or alpha is present but all pixels in the image are opaque.
-
-  FROM  01  31   0  0T  0O   2  2T  2O   3  3T  3O  4A  4O  6A  6O 
-   TO
-   01    -                   
-   31        -
-    0    1       -           
-   0T                -
-   0O                    -
-    2           GX           -
-   2T                            -
-   2O                                -
-    3        1                           -
-   3T                                        -
-   3O                                            -
-   4A                T                               -
-   4O                                                    -
-   6A               GX         TX           TX               -
-   6O                   GX                      TX               -
-
-Within the matrix,
-     "-" means the transformation is not supported.
-     "X" means the transformation is obtained by png_set_expand().
-     "1" means the transformation is obtained by
-         png_set_expand_gray_1_2_4_to_8
-     "G" means the transformation is obtained by
-         png_set_gray_to_rgb().
-     "P" means the transformation is obtained by
-         png_set_expand_palette_to_rgb().
-     "T" means the transformation is obtained by
-         png_set_tRNS_to_alpha().
-
-PNG can have files with 16 bits per channel.  If you only can handle
-8 bits per channel, this will strip the pixels down to 8 bit.
-
-    if (bit_depth == 16)
-       png_set_strip_16(png_ptr);
-
-If, for some reason, you don't need the alpha channel on an image,
-and you want to remove it rather than combining it with the background
-(but the image author certainly had in mind that you *would* combine
-it with the background, so that's what you should probably do):
-
-    if (color_type & PNG_COLOR_MASK_ALPHA)
-       png_set_strip_alpha(png_ptr);
-
-In PNG files, the alpha channel in an image
-is the level of opacity.  If you need the alpha channel in an image to
-be the level of transparency instead of opacity, you can invert the
-alpha channel (or the tRNS chunk data) after it's read, so that 0 is
-fully opaque and 255 (in 8-bit or paletted images) or 65535 (in 16-bit
-images) is fully transparent, with
-
-    png_set_invert_alpha(png_ptr);
-
-PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
-they can, resulting in, for example, 8 pixels per byte for 1 bit
-files.  This code expands to 1 pixel per byte without changing the
-values of the pixels:
-
-    if (bit_depth < 8)
-       png_set_packing(png_ptr);
-
-PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels
-stored in a PNG image have been "scaled" or "shifted" up to the next
-higher possible bit depth (e.g. from 5 bits/sample in the range [0,31]
-to 8 bits/sample in the range [0, 255]).  However, it is also possible
-to convert the PNG pixel data back to the original bit depth of the
-image.  This call reduces the pixels back down to the original bit depth:
-
-    png_color_8p sig_bit;
-
-    if (png_get_sBIT(png_ptr, info_ptr, &sig_bit))
-       png_set_shift(png_ptr, sig_bit);
-
-PNG files store 3-color pixels in red, green, blue order.  This code
-changes the storage of the pixels to blue, green, red:
-
-    if (color_type == PNG_COLOR_TYPE_RGB ||
-        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-       png_set_bgr(png_ptr);
-
-PNG files store RGB pixels packed into 3 or 6 bytes. This code expands them
-into 4 or 8 bytes for windowing systems that need them in this format:
-
-    if (color_type == PNG_COLOR_TYPE_RGB)
-       png_set_filler(png_ptr, filler, PNG_FILLER_BEFORE);
-
-where "filler" is the 8 or 16-bit number to fill with, and the location is
-either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether
-you want the filler before the RGB or after.  This transformation
-does not affect images that already have full alpha channels.  To add an
-opaque alpha channel, use filler=0xff or 0xffff and PNG_FILLER_AFTER which
-will generate RGBA pixels.
-
-Note that png_set_filler() does not change the color type.  If you want
-to do that, you can add a true alpha channel with
-
-    if (color_type == PNG_COLOR_TYPE_RGB ||
-       color_type == PNG_COLOR_TYPE_GRAY)
-       png_set_add_alpha(png_ptr, filler, PNG_FILLER_AFTER);
-
-where "filler" contains the alpha value to assign to each pixel.
-This function was added in libpng-1.2.7.
-
-If you are reading an image with an alpha channel, and you need the
-data as ARGB instead of the normal PNG format RGBA:
-
-    if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-       png_set_swap_alpha(png_ptr);
-
-For some uses, you may want a grayscale image to be represented as
-RGB.  This code will do that conversion:
-
-    if (color_type == PNG_COLOR_TYPE_GRAY ||
-        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-       png_set_gray_to_rgb(png_ptr);
-
-Conversely, you can convert an RGB or RGBA image to grayscale or grayscale
-with alpha.
-
-    if (color_type == PNG_COLOR_TYPE_RGB ||
-        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-       png_set_rgb_to_gray_fixed(png_ptr, error_action,
-           int red_weight, int green_weight);
-
-    error_action = 1: silently do the conversion
-
-    error_action = 2: issue a warning if the original
-                      image has any pixel where
-                      red != green or red != blue
-
-    error_action = 3: issue an error and abort the
-                      conversion if the original
-                      image has any pixel where
-                      red != green or red != blue
-
-    red_weight:       weight of red component times 100000
-
-    green_weight:     weight of green component times 100000
-                      If either weight is negative, default
-                      weights (21268, 71514) are used.
-
-If you have set error_action = 1 or 2, you can
-later check whether the image really was gray, after processing
-the image rows, with the png_get_rgb_to_gray_status(png_ptr) function.
-It will return a png_byte that is zero if the image was gray or
-1 if there were any non-gray pixels.  bKGD and sBIT data
-will be silently converted to grayscale, using the green channel
-data, regardless of the error_action setting.
-
-With red_weight+green_weight<=100000,
-the normalized graylevel is computed:
-
-    int rw = red_weight * 65536;
-    int gw = green_weight * 65536;
-    int bw = 65536 - (rw + gw);
-    gray = (rw*red + gw*green + bw*blue)/65536;
-
-The default values approximate those recommended in the Charles
-Poynton's Color FAQ, <http://www.inforamp.net/~poynton/>
-Copyright (c) 1998-01-04 Charles Poynton <poynton at inforamp.net>
-
-    Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
-
-Libpng approximates this with integers scaled by 32768:
-
-    Y = (6968 * R + 23434 * G + 2366 * B)/32768
-
-The calculation is done in a linear colorspace, if the image gamma
-can be determined.
-
-If you have a grayscale and you are using png_set_expand_depth(),
-png_set_expand(), or png_set_gray_to_rgb to change to truecolor or to
-a higher bit-depth, you must either supply the background color as a gray
-value at the original file bit-depth (need_expand = 1) or else supply the
-background color as an RGB triplet at the final, expanded bit depth
-(need_expand = 0).  Similarly, if you are reading a paletted image, you
-must either supply the background color as a palette index (need_expand = 1)
-or as an RGB triplet that may or may not be in the palette (need_expand = 0).
-
-    png_color_16 my_background;
-    png_color_16p image_background;
-
-    if (png_get_bKGD(png_ptr, info_ptr, &image_background))
-       png_set_background(png_ptr, image_background,
-           PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
-    else
-       png_set_background(png_ptr, &my_background,
-           PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
-
-The png_set_background() function tells libpng to composite images
-with alpha or simple transparency against the supplied background
-color.  If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
-you may use this color, or supply another color more suitable for
-the current display (e.g., the background color from a web page).  You
-need to tell libpng whether the color is in the gamma space of the
-display (PNG_BACKGROUND_GAMMA_SCREEN for colors you supply), the file
-(PNG_BACKGROUND_GAMMA_FILE for colors from the bKGD chunk), or one
-that is neither of these gammas (PNG_BACKGROUND_GAMMA_UNIQUE - I don't
-know why anyone would use this, but it's here).
-
-To properly display PNG images on any kind of system, the application needs
-to know what the display gamma is.  Ideally, the user will know this, and
-the application will allow them to set it.  One method of allowing the user
-to set the display gamma separately for each system is to check for a
-SCREEN_GAMMA or DISPLAY_GAMMA environment variable, which will hopefully be
-correctly set.
-
-Note that display_gamma is the overall gamma correction required to produce
-pleasing results, which depends on the lighting conditions in the surrounding
-environment.  In a dim or brightly lit room, no compensation other than
-the physical gamma exponent of the monitor is needed, while in a dark room
-a slightly smaller exponent is better.
-
-   double gamma, screen_gamma;
-
-   if (/* We have a user-defined screen
-       gamma value */)
-   {
-      screen_gamma = user_defined_screen_gamma;
-   }
-
-   /* One way that applications can share the same
-      screen gamma value */
-   else if ((gamma_str = getenv("SCREEN_GAMMA"))
-      != NULL)
-   {
-      screen_gamma = (double)atof(gamma_str);
-   }
-
-   /* If we don't have another value */
-   else
-   {
-      screen_gamma = 2.2; /* A good guess for a
-           PC monitor in a bright office or a dim room */
-
-      screen_gamma = 2.0; /* A good guess for a
-           PC monitor in a dark room */
-
-      screen_gamma = 1.7 or 1.0;  /* A good
-           guess for Mac systems */
-   }
-
-The functions png_set_gamma() and its fixed point equivalent
-png_set_gamma_fixed() handle gamma transformations of the data.
-Pass both the file gamma and the current screen_gamma.  If the file does
-not have a gamma value, you can pass one anyway if you have an idea what
-it is (usually 0.45455 is a good guess for GIF images on PCs).  Note
-that file gammas are inverted from screen gammas.  See the discussions
-on gamma in the PNG specification for an excellent description of what
-gamma is, and why all applications should support it.  It is strongly
-recommended that PNG viewers support gamma correction.
-
-   if (png_get_gAMA(png_ptr, info_ptr, &file_gamma))
-      png_set_gamma(png_ptr, screen_gamma, file_gamma);
-
-   else
-      png_set_gamma(png_ptr, screen_gamma, 0.45455);
-
-If you need to reduce an RGB file to a paletted file, or if a paletted
-file has more entries then will fit on your screen, png_set_quantize()
-will do that.  Note that this is a simple match quantization that merely
-finds the closest color available.  This should work fairly well with
-optimized palettes, but fairly badly with linear color cubes.  If you
-pass a palette that is larger then maximum_colors, the file will
-reduce the number of colors in the palette so it will fit into
-maximum_colors.  If there is a histogram, it will use it to make
-more intelligent choices when reducing the palette.  If there is no
-histogram, it may not do as good a job.
-
-   if (color_type & PNG_COLOR_MASK_COLOR)
-   {
-      if (png_get_valid(png_ptr, info_ptr,
-          PNG_INFO_PLTE))
-      {
-         png_uint_16p histogram = NULL;
-
-         png_get_hIST(png_ptr, info_ptr,
-             &histogram);
-         png_set_quantize(png_ptr, palette, num_palette,
-            max_screen_colors, histogram, 1);
-      }
-
-      else
-      {
-         png_color std_color_cube[MAX_SCREEN_COLORS] =
-            { ... colors ... };
-
-         png_set_quantize(png_ptr, std_color_cube,
-            MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,
-            NULL,0);
-      }
-   }
-
-PNG files describe monochrome as black being zero and white being one.
-The following code will reverse this (make black be one and white be
-zero):
-
-   if (bit_depth == 1 && color_type == PNG_COLOR_TYPE_GRAY)
-      png_set_invert_mono(png_ptr);
-
-This function can also be used to invert grayscale and gray-alpha images:
-
-   if (color_type == PNG_COLOR_TYPE_GRAY ||
-       color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      png_set_invert_mono(png_ptr);
-
-PNG files store 16 bit pixels in network byte order (big-endian,
-ie. most significant bits first).  This code changes the storage to the
-other way (little-endian, i.e. least significant bits first, the
-way PCs store them):
-
-    if (bit_depth == 16)
-       png_set_swap(png_ptr);
-
-If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
-need to change the order the pixels are packed into bytes, you can use:
-
-    if (bit_depth < 8)
-       png_set_packswap(png_ptr);
-
-Finally, you can write your own transformation function if none of
-the existing ones meets your needs.  This is done by setting a callback
-with
-
-    png_set_read_user_transform_fn(png_ptr,
-        read_transform_fn);
-
-You must supply the function
-
-    void read_transform_fn(png_structp png_ptr, row_info_ptr
-        row_info, png_bytep data)
-
-See pngtest.c for a working example.  Your function will be called
-after all of the other transformations have been processed.  Take care with
-interlaced images if you do the interlace yourself - the width of the row is the
-width in 'row_info', not the overall image width.
-
-If supported libpng provides two information routines that you can use to find
-where you are in processing the image:
-
-   png_get_current_pass_number(png_structp png_ptr);
-   png_get_current_row_number(png_structp png_ptr);
-
-Don't try using these outside a transform callback - firstly they are only
-supported if user transforms are supported, secondly they may well return
-unexpected results unless the row is actually being processed at the moment they
-are called.
-
-You can also set up a pointer to a user structure for use by your
-callback function, and you can inform libpng that your transform
-function will change the number of channels or bit depth with the
-function
-
-    png_set_user_transform_info(png_ptr, user_ptr,
-        user_depth, user_channels);
-
-The user's application, not libpng, is responsible for allocating and
-freeing any memory required for the user structure.
-
-You can retrieve the pointer via the function
-png_get_user_transform_ptr().  For example:
-
-    voidp read_user_transform_ptr =
-        png_get_user_transform_ptr(png_ptr);
-
-The last thing to handle is interlacing; this is covered in detail below,
-but you must call the function here if you want libpng to handle expansion
-of the interlaced image.
-
-    number_of_passes = png_set_interlace_handling(png_ptr);
-
-After setting the transformations, libpng can update your png_info
-structure to reflect any transformations you've requested with this
-call.  This is most useful to update the info structure's rowbytes
-field so you can use it to allocate your image memory.  This function
-will also update your palette with the correct screen_gamma and
-background if these have been given with the calls above.
-
-    png_read_update_info(png_ptr, info_ptr);
-
-After you call png_read_update_info(), you can allocate any
-memory you need to hold the image.  The row data is simply
-raw byte data for all forms of images.  As the actual allocation
-varies among applications, no example will be given.  If you
-are allocating one large chunk, you will need to build an
-array of pointers to each row, as it will be needed for some
-of the functions below.
-
-Remember: Before you call png_read_update_info(), the png_get_
-functions return the values corresponding to the original PNG image.
-After you call png_read_update_info the values refer to the image
-that libpng will output.  Consequently you must call all the png_set_
-functions before you call png_read_update_info().  This is particularly
-important for png_set_interlace_handling() - if you are going to call
-png_read_update_info() you must call png_set_interlace_handling() before
-it unless you want to receive interlaced output.
-
-.SS Reading image data
-
-After you've allocated memory, you can read the image data.
-The simplest way to do this is in one function call.  If you are
-allocating enough memory to hold the whole image, you can just
-call png_read_image() and libpng will read in all the image data
-and put it in the memory area supplied.  You will need to pass in
-an array of pointers to each row.
-
-This function automatically handles interlacing, so you don't
-need to call png_set_interlace_handling() (unless you call
-png_read_update_info()) or call this function multiple times, or any
-of that other stuff necessary with png_read_rows().
-
-   png_read_image(png_ptr, row_pointers);
-
-where row_pointers is:
-
-   png_bytep row_pointers[height];
-
-You can point to void or char or whatever you use for pixels.
-
-If you don't want to read in the whole image at once, you can
-use png_read_rows() instead.  If there is no interlacing (check
-interlace_type == PNG_INTERLACE_NONE), this is simple:
-
-    png_read_rows(png_ptr, row_pointers, NULL,
-        number_of_rows);
-
-where row_pointers is the same as in the png_read_image() call.
-
-If you are doing this just one row at a time, you can do this with
-a single row_pointer instead of an array of row_pointers:
-
-    png_bytep row_pointer = row;
-    png_read_row(png_ptr, row_pointer, NULL);
-
-If the file is interlaced (interlace_type != 0 in the IHDR chunk), things
-get somewhat harder.  The only current (PNG Specification version 1.2)
-interlacing type for PNG is (interlace_type == PNG_INTERLACE_ADAM7);
-a somewhat complicated 2D interlace scheme, known as Adam7, that
-breaks down an image into seven smaller images of varying size, based
-on an 8x8 grid.  This number is defined (from libpng 1.5) as
-PNG_INTERLACE_ADAM7_PASSES in png.h
-
-libpng can fill out those images or it can give them to you "as is".
-It is almost always better to have libpng handle the interlacing for you.
-If you want the images filled out, there are two ways to do that.  The one
-mentioned in the PNG specification is to expand each pixel to cover
-those pixels that have not been read yet (the "rectangle" method).
-This results in a blocky image for the first pass, which gradually
-smooths out as more pixels are read.  The other method is the "sparkle"
-method, where pixels are drawn only in their final locations, with the
-rest of the image remaining whatever colors they were initialized to
-before the start of the read.  The first method usually looks better,
-but tends to be slower, as there are more pixels to put in the rows.
-
-If, as is likely, you want libpng to expand the images, call this before
-calling png_start_read_image() or png_read_update_info():
-
-    if (interlace_type == PNG_INTERLACE_ADAM7)
-       number_of_passes
-           = png_set_interlace_handling(png_ptr);
-
-This will return the number of passes needed.  Currently, this is seven,
-but may change if another interlace type is added.  This function can be
-called even if the file is not interlaced, where it will return one pass.
-You then need to read the whole image 'number_of_passes' times.  Each time
-will distribute the pixels from the current pass to the correct place in
-the output image, so you need to supply the same rows to png_read_rows in
-each pass.
-
-If you are not going to display the image after each pass, but are
-going to wait until the entire image is read in, use the sparkle
-effect.  This effect is faster and the end result of either method
-is exactly the same.  If you are planning on displaying the image
-after each pass, the "rectangle" effect is generally considered the
-better looking one.
-
-If you only want the "sparkle" effect, just call png_read_rows() as
-normal, with the third parameter NULL.  Make sure you make pass over
-the image number_of_passes times, and you don't change the data in the
-rows between calls.  You can change the locations of the data, just
-not the data.  Each pass only writes the pixels appropriate for that
-pass, and assumes the data from previous passes is still valid.
-
-    png_read_rows(png_ptr, row_pointers, NULL,
-        number_of_rows);
-
-If you only want the first effect (the rectangles), do the same as
-before except pass the row buffer in the third parameter, and leave
-the second parameter NULL.
-
-    png_read_rows(png_ptr, NULL, row_pointers,
-        number_of_rows);
-
-If you don't want libpng to handle the interlacing details, just call
-png_read_rows() PNG_INTERLACE_ADAM7_PASSES times to read in all the images.
-Each of the images is a valid image by itself, however you will almost
-certainly need to distribute the pixels from each sub-image to the
-correct place.  This is where everything gets very tricky.
-
-If you want to retrieve the separate images you must pass the correct
-number of rows to each successive call of png_read_rows().  The calculation
-gets pretty complicated for small images, where some sub-images may
-not even exist because either their width or height ends up zero.
-libpng provides two macros to help you in 1.5 and later versions:
-
-   png_uint_32 width = PNG_PASS_COLS(image_width, pass_number);
-   png_uint_32 height = PNG_PASS_ROWS(image_height, pass_number);
-
-Respectively these tell you the width and height of the sub-image
-corresponding to the numbered pass.  'pass' is in in the range 0 to 6 -
-this can be confusing because the specification refers to the same passes
-as 1 to 7!  Be careful, you must check both the width and height before
-calling png_read_rows() and not call it for that pass if either is zero.
-
-You can, of course, read each sub-image row by row.  If you want to
-produce optimal code to make a pixel-by-pixel transformation of an
-interlaced image this is the best approach; read each row of each pass,
-transform it, and write it out to a new interlaced image.
-
-If you want to de-interlace the image yourself libpng provides further
-macros to help that tell you where to place the pixels in the output image.
-Because the interlacing scheme is rectangular - sub-image pixels are always
-arranged on a rectangular grid - all you need to know for each pass is the
-starting column and row in the output image of the first pixel plus the
-spacing between each pixel.  As of libpng 1.5 there are four macros to
-retrieve this information:
-
-   png_uint_32 x = PNG_PASS_START_COL(pass);
-   png_uint_32 y = PNG_PASS_START_ROW(pass);
-   png_uint_32 xStep = 1U << PNG_PASS_COL_SHIFT(pass);
-   png_uint_32 yStep = 1U << PNG_PASS_ROW_SHIFT(pass);
-
-These allow you to write the obvious loop:
-
-   png_uint_32 input_y = 0;
-   png_uint_32 output_y = PNG_PASS_START_ROW(pass);
-
-   while (output_y < output_image_height)
-   {
-      png_uint_32 input_x = 0;
-      png_uint_32 output_x = PNG_PASS_START_COL(pass);
-
-      while (output_x < output_image_width)
-      {
-         image[output_y][output_x] =
-             subimage[pass][input_y][input_x++];
-
-         output_x += xStep;
-      }
-
-      ++input_y;
-      output_y += yStep;
-   }
-
-Notice that the steps between successive output rows and columns are
-returned as shifts.  This is possible because the pixels in the subimages
-are always a power of 2 apart - 1, 2, 4 or 8 pixels - in the original
-image.  In practice you may need to directly calculate the output coordinate
-given an input coordinate.  libpng provides two further macros for this
-purpose:
-
-   png_uint_32 output_x = PNG_COL_FROM_PASS_COL(input_x, pass);
-   png_uint_32 output_y = PNG_ROW_FROM_PASS_ROW(input_y, pass);
-
-Finally a pair of macros are provided to tell you if a particular image
-row or column appears in a given pass:
-
-   int col_in_pass = PNG_COL_IN_INTERLACE_PASS(output_x, pass);
-   int row_in_pass = PNG_ROW_IN_INTERLACE_PASS(output_y, pass);
-
-Bear in mind that you will probably also need to check the width and height
-of the pass in addition to the above to be sure the pass even exists!
-
-With any luck you are convinced by now that you don't want to do your own
-interlace handling.  In reality normally the only good reason for doing this
-is if you are processing PNG files on a pixel-by-pixel basis and don't want
-to load the whole file into memory when it is interlaced.
-
-libpng includes a test program, pngvalid, that illustrates reading and
-writing of interlaced images.  If you can't get interlacing to work in your
-code and don't want to leave it to libpng (the recommended approach) see
-how pngvalid.c does it.
-
-.SS Finishing a sequential read
-
-After you are finished reading the image through the
-low-level interface, you can finish reading the file.  If you are
-interested in comments or time, which may be stored either before or
-after the image data, you should pass the separate png_info struct if
-you want to keep the comments from before and after the image
-separate.  If you are not interested, you can pass NULL.
-
-   png_read_end(png_ptr, end_info);
-
-When you are done, you can free all memory allocated by libpng like this:
-
-   png_destroy_read_struct(&png_ptr, &info_ptr,
-       &end_info);
-
-It is also possible to individually free the info_ptr members that
-point to libpng-allocated storage with the following function:
-
-    png_free_data(png_ptr, info_ptr, mask, seq)
-
-    mask - identifies data to be freed, a mask
-           containing the bitwise OR of one or
-           more of
-             PNG_FREE_PLTE, PNG_FREE_TRNS,
-             PNG_FREE_HIST, PNG_FREE_ICCP,
-             PNG_FREE_PCAL, PNG_FREE_ROWS,
-             PNG_FREE_SCAL, PNG_FREE_SPLT,
-             PNG_FREE_TEXT, PNG_FREE_UNKN,
-           or simply PNG_FREE_ALL
-
-    seq  - sequence number of item to be freed
-           (-1 for all items)
-
-This function may be safely called when the relevant storage has
-already been freed, or has not yet been allocated, or was allocated
-by the user and not by libpng,  and will in those cases do nothing.
-The "seq" parameter is ignored if only one item of the selected data
-type, such as PLTE, is allowed.  If "seq" is not -1, and multiple items
-are allowed for the data type identified in the mask, such as text or
-sPLT, only the n'th item in the structure is freed, where n is "seq".
-
-The default behavior is only to free data that was allocated internally
-by libpng.  This can be changed, so that libpng will not free the data,
-or so that it will free data that was allocated by the user with png_malloc()
-or png_zalloc() and passed in via a png_set_*() function, with
-
-    png_data_freer(png_ptr, info_ptr, freer, mask)
-
-    freer  - one of
-               PNG_DESTROY_WILL_FREE_DATA
-               PNG_SET_WILL_FREE_DATA
-               PNG_USER_WILL_FREE_DATA
-
-    mask   - which data elements are affected
-             same choices as in png_free_data()
-
-This function only affects data that has already been allocated.
-You can call this function after reading the PNG data but before calling
-any png_set_*() functions, to control whether the user or the png_set_*()
-function is responsible for freeing any existing data that might be present,
-and again after the png_set_*() functions to control whether the user
-or png_destroy_*() is supposed to free the data.  When the user assumes
-responsibility for libpng-allocated data, the application must use
-png_free() to free it, and when the user transfers responsibility to libpng
-for data that the user has allocated, the user must have used png_malloc()
-or png_zalloc() to allocate it.
-
-If you allocated your row_pointers in a single block, as suggested above in
-the description of the high level read interface, you must not transfer
-responsibility for freeing it to the png_set_rows or png_read_destroy function,
-because they would also try to free the individual row_pointers[i].
-
-If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
-separately, do not transfer responsibility for freeing text_ptr to libpng,
-because when libpng fills a png_text structure it combines these members with
-the key member, and png_free_data() will free only text_ptr.key.  Similarly,
-if you transfer responsibility for free'ing text_ptr from libpng to your
-application, your application must not separately free those members.
-
-The png_free_data() function will turn off the "valid" flag for anything
-it frees.  If you need to turn the flag off for a chunk that was freed by
-your application instead of by libpng, you can use
-
-    png_set_invalid(png_ptr, info_ptr, mask);
-
-    mask - identifies the chunks to be made invalid,
-           containing the bitwise OR of one or
-           more of
-             PNG_INFO_gAMA, PNG_INFO_sBIT,
-             PNG_INFO_cHRM, PNG_INFO_PLTE,
-             PNG_INFO_tRNS, PNG_INFO_bKGD,
-             PNG_INFO_hIST, PNG_INFO_pHYs,
-             PNG_INFO_oFFs, PNG_INFO_tIME,
-             PNG_INFO_pCAL, PNG_INFO_sRGB,
-             PNG_INFO_iCCP, PNG_INFO_sPLT,
-             PNG_INFO_sCAL, PNG_INFO_IDAT
-
-For a more compact example of reading a PNG image, see the file example.c.
-
-.SS Reading PNG files progressively
-
-The progressive reader is slightly different then the non-progressive
-reader.  Instead of calling png_read_info(), png_read_rows(), and
-png_read_end(), you make one call to png_process_data(), which calls
-callbacks when it has the info, a row, or the end of the image.  You
-set up these callbacks with png_set_progressive_read_fn().  You don't
-have to worry about the input/output functions of libpng, as you are
-giving the library the data directly in png_process_data().  I will
-assume that you have read the section on reading PNG files above,
-so I will only highlight the differences (although I will show
-all of the code).
-
-png_structp png_ptr;
-png_infop info_ptr;
-
- /*  An example code fragment of how you would
-     initialize the progressive reader in your
-     application. */
- int
- initialize_png_reader()
- {
-    png_ptr = png_create_read_struct
-        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-         user_error_fn, user_warning_fn);
-
-    if (!png_ptr)
-        return (ERROR);
-
-    info_ptr = png_create_info_struct(png_ptr);
-
-    if (!info_ptr)
-    {
-       png_destroy_read_struct(&png_ptr,
-          (png_infopp)NULL, (png_infopp)NULL);
-       return (ERROR);
-    }
-
-    if (setjmp(png_jmpbuf(png_ptr)))
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-          (png_infopp)NULL);
-       return (ERROR);
-    }
-
-    /* This one's new.  You can provide functions
-       to be called when the header info is valid,
-       when each row is completed, and when the image
-       is finished.  If you aren't using all functions,
-       you can specify NULL parameters.  Even when all
-       three functions are NULL, you need to call
-       png_set_progressive_read_fn().  You can use
-       any struct as the user_ptr (cast to a void pointer
-       for the function call), and retrieve the pointer
-       from inside the callbacks using the function
-
-          png_get_progressive_ptr(png_ptr);
-
-       which will return a void pointer, which you have
-       to cast appropriately.
-     */
-    png_set_progressive_read_fn(png_ptr, (void *)user_ptr,
-        info_callback, row_callback, end_callback);
-
-    return 0;
- }
-
- /* A code fragment that you call as you receive blocks
-   of data */
- int
- process_data(png_bytep buffer, png_uint_32 length)
- {
-    if (setjmp(png_jmpbuf(png_ptr)))
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-           (png_infopp)NULL);
-       return (ERROR);
-    }
-
-    /* This one's new also.  Simply give it a chunk
-       of data from the file stream (in order, of
-       course).  On machines with segmented memory
-       models machines, don't give it any more than
-       64K.  The library seems to run fine with sizes
-       of 4K. Although you can give it much less if
-       necessary (I assume you can give it chunks of
-       1 byte, I haven't tried less then 256 bytes
-       yet).  When this function returns, you may
-       want to display any rows that were generated
-       in the row callback if you don't already do
-       so there.
-     */
-    png_process_data(png_ptr, info_ptr, buffer, length);
-
-    /* At this point you can call png_process_data_skip if
-       you want to handle data the library will skip yourself;
-       it simply returns the number of bytes to skip (and stops
-       libpng skipping that number of bytes on the next
-       png_process_data call).
-    return 0;
- }
-
- /* This function is called (as set by
-    png_set_progressive_read_fn() above) when enough data
-    has been supplied so all of the header has been
-    read.
- */
- void
- info_callback(png_structp png_ptr, png_infop info)
- {
-    /* Do any setup here, including setting any of
-       the transformations mentioned in the Reading
-       PNG files section.  For now, you _must_ call
-       either png_start_read_image() or
-       png_read_update_info() after all the
-       transformations are set (even if you don't set
-       any).  You may start getting rows before
-       png_process_data() returns, so this is your
-       last chance to prepare for that.
-
-       This is where you turn on interlace handling,
-       assuming you don't want to do it yourself.
-
-       If you need to you can stop the processing of
-       your original input data at this point by calling
-       png_process_data_pause.  This returns the number
-       of unprocessed bytes from the last png_process_data
-       call - it is up to you to ensure that the next call
-       sees these bytes again.  If you don't want to bother
-       with this you can get libpng to cache the unread
-       bytes by setting the 'save' parameter (see png.h) but
-       then libpng will have to copy the data internally.
-     */
- }
-
- /* This function is called when each row of image
-    data is complete */
- void
- row_callback(png_structp png_ptr, png_bytep new_row,
-    png_uint_32 row_num, int pass)
- {
-    /* If the image is interlaced, and you turned
-       on the interlace handler, this function will
-       be called for every row in every pass.  Some
-       of these rows will not be changed from the
-       previous pass.  When the row is not changed,
-       the new_row variable will be NULL.  The rows
-       and passes are called in order, so you don't
-       really need the row_num and pass, but I'm
-       supplying them because it may make your life
-       easier.
-
-       If you did not turn on interlace handling then
-       the callback is called for each row of each
-       sub-image when the image is interlaced.  In this
-       case 'row_num' is the row in the sub-image, not
-       the row in the output image as it is in all other
-       cases.
-
-       For the non-NULL rows of interlaced images when
-       you have switched on libpng interlace handling,
-       you must call png_progressive_combine_row()
-       passing in the row and the old row.  You can
-       call this function for NULL rows (it will just
-       return) and for non-interlaced images (it just
-       does the memcpy for you) if it will make the
-       code easier.  Thus, you can just do this for
-       all cases if you switch on interlace handling;
-     */
-
-        png_progressive_combine_row(png_ptr, old_row,
-          new_row);
-
-    /* where old_row is what was displayed for
-       previously for the row.  Note that the first
-       pass (pass == 0, really) will completely cover
-       the old row, so the rows do not have to be
-       initialized.  After the first pass (and only
-       for interlaced images), you will have to pass
-       the current row, and the function will combine
-       the old row and the new row.
-
-       You can also call png_process_data_pause in this
-       callback - see above.
-    */
- }
-
- void
- end_callback(png_structp png_ptr, png_infop info)
- {
-    /* This function is called after the whole image
-       has been read, including any chunks after the
-       image (up to and including the IEND).  You
-       will usually have the same info chunk as you
-       had in the header, although some data may have
-       been added to the comments and time fields.
-
-       Most people won't do much here, perhaps setting
-       a flag that marks the image as finished.
-     */
- }
-
-
-
-.SH IV. Writing
-
-Much of this is very similar to reading.  However, everything of
-importance is repeated here, so you won't have to constantly look
-back up in the reading section to understand writing.
-
-.SS Setup
-
-You will want to do the I/O initialization before you get into libpng,
-so if it doesn't work, you don't have anything to undo. If you are not
-using the standard I/O functions, you will need to replace them with
-custom writing functions.  See the discussion under Customizing libpng.
-
-    FILE *fp = fopen(file_name, "wb");
-
-    if (!fp)
-       return (ERROR);
-
-Next, png_struct and png_info need to be allocated and initialized.
-As these can be both relatively large, you may not want to store these
-on the stack, unless you have stack space to spare.  Of course, you
-will want to check if they return NULL.  If you are also reading,
-you won't want to name your read structure and your write structure
-both "png_ptr"; you can call them anything you like, such as
-"read_ptr" and "write_ptr".  Look at pngtest.c, for example.
-
-    png_structp png_ptr = png_create_write_struct
-       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-        user_error_fn, user_warning_fn);
-
-    if (!png_ptr)
-       return (ERROR);
-
-    png_infop info_ptr = png_create_info_struct(png_ptr);
-    if (!info_ptr)
-    {
-       png_destroy_write_struct(&png_ptr,
-           (png_infopp)NULL);
-       return (ERROR);
-    }
-
-If you want to use your own memory allocation routines,
-define PNG_USER_MEM_SUPPORTED and use
-png_create_write_struct_2() instead of png_create_write_struct():
-
-    png_structp png_ptr = png_create_write_struct_2
-       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-        user_error_fn, user_warning_fn, (png_voidp)
-        user_mem_ptr, user_malloc_fn, user_free_fn);
-
-After you have these structures, you will need to set up the
-error handling.  When libpng encounters an error, it expects to
-longjmp() back to your routine.  Therefore, you will need to call
-setjmp() and pass the png_jmpbuf(png_ptr).  If you
-write the file from different routines, you will need to update
-the png_jmpbuf(png_ptr) every time you enter a new routine that will
-call a png_*() function.  See your documentation of setjmp/longjmp
-for your compiler for more information on setjmp/longjmp.  See
-the discussion on libpng error handling in the Customizing Libpng
-section below for more information on the libpng error handling.
-
-    if (setjmp(png_jmpbuf(png_ptr)))
-    {
-    png_destroy_write_struct(&png_ptr, &info_ptr);
-       fclose(fp);
-       return (ERROR);
-    }
-    ...
-    return;
-
-If you would rather avoid the complexity of setjmp/longjmp issues,
-you can compile libpng with PNG_NO_SETJMP, in which case
-errors will result in a call to PNG_ABORT() which defaults to abort().
-
-You can #define PNG_ABORT() to a function that does something
-more useful than abort(), as long as your function does not
-return.
-
-Now you need to set up the output code.  The default for libpng is to
-use the C function fwrite().  If you use this, you will need to pass a
-valid FILE * in the function png_init_io().  Be sure that the file is
-opened in binary mode.  Again, if you wish to handle writing data in
-another way, see the discussion on libpng I/O handling in the Customizing
-Libpng section below.
-
-    png_init_io(png_ptr, fp);
-
-If you are embedding your PNG into a datastream such as MNG, and don't
-want libpng to write the 8-byte signature, or if you have already
-written the signature in your application, use
-
-    png_set_sig_bytes(png_ptr, 8);
-
-to inform libpng that it should not write a signature.
-
-.SS Write callbacks
-
-At this point, you can set up a callback function that will be
-called after each row has been written, which you can use to control
-a progress meter or the like.  It's demonstrated in pngtest.c.
-You must supply a function
-
-    void write_row_callback(png_structp png_ptr, png_uint_32 row,
-       int pass);
-    {
-      /* put your code here */
-    }
-
-(You can give it another name that you like instead of "write_row_callback")
-
-To inform libpng about your function, use
-
-    png_set_write_status_fn(png_ptr, write_row_callback);
-
-You now have the option of modifying how the compression library will
-run.  The following functions are mainly for testing, but may be useful
-in some cases, like if you need to write PNG files extremely fast and
-are willing to give up some compression, or if you want to get the
-maximum possible compression at the expense of slower writing.  If you
-have no special needs in this area, let the library do what it wants by
-not calling this function at all, as it has been tuned to deliver a good
-speed/compression ratio. The second parameter to png_set_filter() is
-the filter method, for which the only valid values are 0 (as of the
-July 1999 PNG specification, version 1.2) or 64 (if you are writing
-a PNG datastream that is to be embedded in a MNG datastream).  The third
-parameter is a flag that indicates which filter type(s) are to be tested
-for each scanline.  See the PNG specification for details on the specific
-filter types.
-
-
-    /* turn on or off filtering, and/or choose
-       specific filters.  You can use either a single
-       PNG_FILTER_VALUE_NAME or the bitwise OR of one
-       or more PNG_FILTER_NAME masks.
-     */
-    png_set_filter(png_ptr, 0,
-       PNG_FILTER_NONE  | PNG_FILTER_VALUE_NONE |
-       PNG_FILTER_SUB   | PNG_FILTER_VALUE_SUB  |
-       PNG_FILTER_UP    | PNG_FILTER_VALUE_UP   |
-       PNG_FILTER_AVG   | PNG_FILTER_VALUE_AVG  |
-       PNG_FILTER_PAETH | PNG_FILTER_VALUE_PAETH|
-       PNG_ALL_FILTERS);
-
-If an application wants to start and stop using particular filters during
-compression, it should start out with all of the filters (to ensure that
-the previous row of pixels will be stored in case it's needed later),
-and then add and remove them after the start of compression.
-
-If you are writing a PNG datastream that is to be embedded in a MNG
-datastream, the second parameter can be either 0 or 64.
-
-The png_set_compression_*() functions interface to the zlib compression
-library, and should mostly be ignored unless you really know what you are
-doing.  The only generally useful call is png_set_compression_level()
-which changes how much time zlib spends on trying to compress the image
-data.  See the Compression Library (zlib.h and algorithm.txt, distributed
-with zlib) for details on the compression levels.
-
-    /* set the zlib compression level */
-    png_set_compression_level(png_ptr,
-        Z_BEST_COMPRESSION);
-
-    /* set other zlib parameters */
-    png_set_compression_mem_level(png_ptr, 8);
-    png_set_compression_strategy(png_ptr,
-        Z_DEFAULT_STRATEGY);
-    png_set_compression_window_bits(png_ptr, 15);
-    png_set_compression_method(png_ptr, 8);
-    png_set_compression_buffer_size(png_ptr, 8192)
-
-extern PNG_EXPORT(void,png_set_zbuf_size)
-
-.SS Setting the contents of info for output
-
-You now need to fill in the png_info structure with all the data you
-wish to write before the actual image.  Note that the only thing you
-are allowed to write after the image is the text chunks and the time
-chunk (as of PNG Specification 1.2, anyway).  See png_write_end() and
-the latest PNG specification for more information on that.  If you
-wish to write them before the image, fill them in now, and flag that
-data as being valid.  If you want to wait until after the data, don't
-fill them until png_write_end().  For all the fields in png_info and
-their data types, see png.h.  For explanations of what the fields
-contain, see the PNG specification.
-
-Some of the more important parts of the png_info are:
-
-    png_set_IHDR(png_ptr, info_ptr, width, height,
-       bit_depth, color_type, interlace_type,
-       compression_type, filter_method)
-
-    width          - holds the width of the image
-                     in pixels (up to 2^31).
-
-    height         - holds the height of the image
-                     in pixels (up to 2^31).
-
-    bit_depth      - holds the bit depth of one of the
-                     image channels.
-                     (valid values are 1, 2, 4, 8, 16
-                     and depend also on the
-                     color_type.  See also significant
-                     bits (sBIT) below).
-
-    color_type     - describes which color/alpha
-                     channels are present.
-                     PNG_COLOR_TYPE_GRAY
-                        (bit depths 1, 2, 4, 8, 16)
-                     PNG_COLOR_TYPE_GRAY_ALPHA
-                        (bit depths 8, 16)
-                     PNG_COLOR_TYPE_PALETTE
-                        (bit depths 1, 2, 4, 8)
-                     PNG_COLOR_TYPE_RGB
-                        (bit_depths 8, 16)
-                     PNG_COLOR_TYPE_RGB_ALPHA
-                        (bit_depths 8, 16)
-
-                     PNG_COLOR_MASK_PALETTE
-                     PNG_COLOR_MASK_COLOR
-                     PNG_COLOR_MASK_ALPHA
-
-    interlace_type - PNG_INTERLACE_NONE or
-                     PNG_INTERLACE_ADAM7
-
-    compression_type - (must be
-                     PNG_COMPRESSION_TYPE_DEFAULT)
-
-    filter_method  - (must be PNG_FILTER_TYPE_DEFAULT
-                     or, if you are writing a PNG to
-                     be embedded in a MNG datastream,
-                     can also be
-                     PNG_INTRAPIXEL_DIFFERENCING)
-
-If you call png_set_IHDR(), the call must appear before any of the
-other png_set_*() functions, because they might require access to some of
-the IHDR settings.  The remaining png_set_*() functions can be called
-in any order.
-
-If you wish, you can reset the compression_type, interlace_type, or
-filter_method later by calling png_set_IHDR() again; if you do this, the
-width, height, bit_depth, and color_type must be the same in each call.
-
-    png_set_PLTE(png_ptr, info_ptr, palette,
-       num_palette);
-
-    palette        - the palette for the file
-                     (array of png_color)
-    num_palette    - number of entries in the palette
-
-    png_set_gAMA(png_ptr, info_ptr, file_gamma);
-    png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
-
-    file_gamma     - the gamma at which the image was
-                     created (PNG_INFO_gAMA)
-
-    int_file_gamma - 100,000 times the gamma at which
-                     the image was created
-
-    png_set_sRGB(png_ptr, info_ptr, srgb_intent);
-
-    srgb_intent    - the rendering intent
-                     (PNG_INFO_sRGB) The presence of
-                     the sRGB chunk means that the pixel
-                     data is in the sRGB color space.
-                     This chunk also implies specific
-                     values of gAMA and cHRM.  Rendering
-                     intent is the CSS-1 property that
-                     has been defined by the International
-                     Color Consortium
-                     (http://www.color.org).
-                     It can be one of
-                     PNG_sRGB_INTENT_SATURATION,
-                     PNG_sRGB_INTENT_PERCEPTUAL,
-                     PNG_sRGB_INTENT_ABSOLUTE, or
-                     PNG_sRGB_INTENT_RELATIVE.
-
-
-    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr,
-       srgb_intent);
-
-    srgb_intent    - the rendering intent
-                     (PNG_INFO_sRGB) The presence of the
-                     sRGB chunk means that the pixel
-                     data is in the sRGB color space.
-                     This function also causes gAMA and
-                     cHRM chunks with the specific values
-                     that are consistent with sRGB to be
-                     written.
-
-    png_set_iCCP(png_ptr, info_ptr, name, compression_type,
-                       profile, proflen);
-
-    name             - The profile name.
-
-    compression_type - The compression type; always
-                       PNG_COMPRESSION_TYPE_BASE for PNG 1.0.
-                       You may give NULL to this argument to
-                       ignore it.
-
-    profile          - International Color Consortium color
-                       profile data. May contain NULs.
-
-    proflen          - length of profile data in bytes.
-
-    png_set_sBIT(png_ptr, info_ptr, sig_bit);
-
-    sig_bit        - the number of significant bits for
-                     (PNG_INFO_sBIT) each of the gray, red,
-                     green, and blue channels, whichever are
-                     appropriate for the given color type
-                     (png_color_16)
-
-    png_set_tRNS(png_ptr, info_ptr, trans_alpha,
-       num_trans, trans_color);
-
-    trans_alpha    - array of alpha (transparency)
-                     entries for palette (PNG_INFO_tRNS)
-
-    trans_color    - graylevel or color sample values
-                     (in order red, green, blue) of the
-                     single transparent color for
-                     non-paletted images (PNG_INFO_tRNS)
-
-    num_trans      - number of transparent entries
-                     (PNG_INFO_tRNS)
-
-    png_set_hIST(png_ptr, info_ptr, hist);
-
-    hist           - histogram of palette (array of
-                     png_uint_16) (PNG_INFO_hIST)
-
-    png_set_tIME(png_ptr, info_ptr, mod_time);
-
-    mod_time       - time image was last modified
-                     (PNG_VALID_tIME)
-
-    png_set_bKGD(png_ptr, info_ptr, background);
-
-    background     - background color (PNG_VALID_bKGD)
-
-    png_set_text(png_ptr, info_ptr, text_ptr, num_text);
-
-    text_ptr       - array of png_text holding image
-                     comments
-
-    text_ptr[i].compression - type of compression used
-                 on "text" PNG_TEXT_COMPRESSION_NONE
-                           PNG_TEXT_COMPRESSION_zTXt
-                           PNG_ITXT_COMPRESSION_NONE
-                           PNG_ITXT_COMPRESSION_zTXt
-    text_ptr[i].key   - keyword for comment.  Must contain
-                 1-79 characters.
-    text_ptr[i].text  - text comments for current
-                         keyword.  Can be NULL or empty.
-    text_ptr[i].text_length - length of text string,
-                 after decompression, 0 for iTXt
-    text_ptr[i].itxt_length - length of itxt string,
-                 after decompression, 0 for tEXt/zTXt
-    text_ptr[i].lang  - language of comment (NULL or
-                         empty for unknown).
-    text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL
-                         or empty for unknown).
-    Note that the itxt_length, lang, and lang_key
-    members of the text_ptr structure only exist
-    when the library is built with iTXt chunk support.
-
-    num_text       - number of comments
-
-    png_set_sPLT(png_ptr, info_ptr, &palette_ptr,
-       num_spalettes);
-
-    palette_ptr    - array of png_sPLT_struct structures
-                     to be added to the list of palettes
-                     in the info structure.
-    num_spalettes  - number of palette structures to be
-                     added.
-
-    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
-        unit_type);
-
-    offset_x  - positive offset from the left
-                     edge of the screen
-
-    offset_y  - positive offset from the top
-                     edge of the screen
-
-    unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
-
-    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
-        unit_type);
-
-    res_x       - pixels/unit physical resolution
-                  in x direction
-
-    res_y       - pixels/unit physical resolution
-                  in y direction
-
-    unit_type   - PNG_RESOLUTION_UNKNOWN,
-                  PNG_RESOLUTION_METER
-
-    png_set_sCAL(png_ptr, info_ptr, unit, width, height)
-
-    unit        - physical scale units (an integer)
-
-    width       - width of a pixel in physical scale units
-
-    height      - height of a pixel in physical scale units
-                  (width and height are doubles)
-
-    png_set_sCAL_s(png_ptr, info_ptr, unit, width, height)
-
-    unit        - physical scale units (an integer)
-
-    width       - width of a pixel in physical scale units
-
-    height      - height of a pixel in physical scale units
-                 (width and height are strings like "2.54")
-
-    png_set_unknown_chunks(png_ptr, info_ptr, &unknowns,
-       num_unknowns)
-
-    unknowns          - array of png_unknown_chunk
-                        structures holding unknown chunks
-    unknowns[i].name  - name of unknown chunk
-    unknowns[i].data  - data of unknown chunk
-    unknowns[i].size  - size of unknown chunk's data
-    unknowns[i].location - position to write chunk in file
-                           0: do not write chunk
-                           PNG_HAVE_IHDR: before PLTE
-                           PNG_HAVE_PLTE: before IDAT
-                           PNG_AFTER_IDAT: after IDAT
-
-The "location" member is set automatically according to
-what part of the output file has already been written.
-You can change its value after calling png_set_unknown_chunks()
-as demonstrated in pngtest.c.  Within each of the "locations",
-the chunks are sequenced according to their position in the
-structure (that is, the value of "i", which is the order in which
-the chunk was either read from the input file or defined with
-png_set_unknown_chunks).
-
-A quick word about text and num_text.  text is an array of png_text
-structures.  num_text is the number of valid structures in the array.
-Each png_text structure holds a language code, a keyword, a text value,
-and a compression type.
-
-The compression types have the same valid numbers as the compression
-types of the image data.  Currently, the only valid number is zero.
-However, you can store text either compressed or uncompressed, unlike
-images, which always have to be compressed.  So if you don't want the
-text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE.
-Because tEXt and zTXt chunks don't have a language field, if you
-specify PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt
-any language code or translated keyword will not be written out.
-
-Until text gets around 1000 bytes, it is not worth compressing it.
-After the text has been written out to the file, the compression type
-is set to PNG_TEXT_COMPRESSION_NONE_WR or PNG_TEXT_COMPRESSION_zTXt_WR,
-so that it isn't written out again at the end (in case you are calling
-png_write_end() with the same struct).
-
-The keywords that are given in the PNG Specification are:
-
-    Title            Short (one line) title or
-                     caption for image
-
-    Author           Name of image's creator
-
-    Description      Description of image (possibly long)
-
-    Copyright        Copyright notice
-
-    Creation Time    Time of original image creation
-                     (usually RFC 1123 format, see below)
-
-    Software         Software used to create the image
-
-    Disclaimer       Legal disclaimer
-
-    Warning          Warning of nature of content
-
-    Source           Device used to create the image
-
-    Comment          Miscellaneous comment; conversion
-                     from other image format
-
-The keyword-text pairs work like this.  Keywords should be short
-simple descriptions of what the comment is about.  Some typical
-keywords are found in the PNG specification, as is some recommendations
-on keywords.  You can repeat keywords in a file.  You can even write
-some text before the image and some after.  For example, you may want
-to put a description of the image before the image, but leave the
-disclaimer until after, so viewers working over modem connections
-don't have to wait for the disclaimer to go over the modem before
-they start seeing the image.  Finally, keywords should be full
-words, not abbreviations.  Keywords and text are in the ISO 8859-1
-(Latin-1) character set (a superset of regular ASCII) and can not
-contain NUL characters, and should not contain control or other
-unprintable characters.  To make the comments widely readable, stick
-with basic ASCII, and avoid machine specific character set extensions
-like the IBM-PC character set.  The keyword must be present, but
-you can leave off the text string on non-compressed pairs.
-Compressed pairs must have a text string, as only the text string
-is compressed anyway, so the compression would be meaningless.
-
-PNG supports modification time via the png_time structure.  Two
-conversion routines are provided, png_convert_from_time_t() for
-time_t and png_convert_from_struct_tm() for struct tm.  The
-time_t routine uses gmtime().  You don't have to use either of
-these, but if you wish to fill in the png_time structure directly,
-you should provide the time in universal time (GMT) if possible
-instead of your local time.  Note that the year number is the full
-year (e.g. 1998, rather than 98 - PNG is year 2000 compliant!), and
-that months start with 1.
-
-If you want to store the time of the original image creation, you should
-use a plain tEXt chunk with the "Creation Time" keyword.  This is
-necessary because the "creation time" of a PNG image is somewhat vague,
-depending on whether you mean the PNG file, the time the image was
-created in a non-PNG format, a still photo from which the image was
-scanned, or possibly the subject matter itself.  In order to facilitate
-machine-readable dates, it is recommended that the "Creation Time"
-tEXt chunk use RFC 1123 format dates (e.g. "22 May 1997 18:07:10 GMT"),
-although this isn't a requirement.  Unlike the tIME chunk, the
-"Creation Time" tEXt chunk is not expected to be automatically changed
-by the software.  To facilitate the use of RFC 1123 dates, a function
-png_convert_to_rfc1123(png_timep) is provided to convert from PNG
-time to an RFC 1123 format string.
-
-.SS Writing unknown chunks
-
-You can use the png_set_unknown_chunks function to queue up chunks
-for writing.  You give it a chunk name, raw data, and a size; that's
-all there is to it.  The chunks will be written by the next following
-png_write_info_before_PLTE, png_write_info, or png_write_end function.
-Any chunks previously read into the info structure's unknown-chunk
-list will also be written out in a sequence that satisfies the PNG
-specification's ordering rules.
-
-.SS The high-level write interface
-
-At this point there are two ways to proceed; through the high-level
-write interface, or through a sequence of low-level write operations.
-You can use the high-level interface if your image data is present
-in the info structure.  All defined output
-transformations are permitted, enabled by the following masks.
-
-    PNG_TRANSFORM_IDENTITY      No transformation
-    PNG_TRANSFORM_PACKING       Pack 1, 2 and 4-bit samples
-    PNG_TRANSFORM_PACKSWAP      Change order of packed
-                                pixels to LSB first
-    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
-    PNG_TRANSFORM_SHIFT         Normalize pixels to the
-                                sBIT depth
-    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA
-                                to BGRA
-    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA
-                                to AG
-    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity
-                                to transparency
-    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
-    PNG_TRANSFORM_STRIP_FILLER        Strip out filler
-                                      bytes (deprecated).
-    PNG_TRANSFORM_STRIP_FILLER_BEFORE Strip out leading
-                                      filler bytes
-    PNG_TRANSFORM_STRIP_FILLER_AFTER  Strip out trailing
-                                      filler bytes
-
-If you have valid image data in the info structure (you can use
-png_set_rows() to put image data in the info structure), simply do this:
-
-    png_write_png(png_ptr, info_ptr, png_transforms, NULL)
-
-where png_transforms is an integer containing the bitwise OR of some set of
-transformation flags.  This call is equivalent to png_write_info(),
-followed the set of transformations indicated by the transform mask,
-then png_write_image(), and finally png_write_end().
-
-(The final parameter of this call is not yet used.  Someday it might point
-to transformation parameters required by some future output transform.)
-
-You must use png_transforms and not call any png_set_transform() functions
-when you use png_write_png().
-
-.SS The low-level write interface
-
-If you are going the low-level route instead, you are now ready to
-write all the file information up to the actual image data.  You do
-this with a call to png_write_info().
-
-    png_write_info(png_ptr, info_ptr);
-
-Note that there is one transformation you may need to do before
-png_write_info().  In PNG files, the alpha channel in an image is the
-level of opacity.  If your data is supplied as a level of transparency,
-you can invert the alpha channel before you write it, so that 0 is
-fully transparent and 255 (in 8-bit or paletted images) or 65535
-(in 16-bit images) is fully opaque, with
-
-    png_set_invert_alpha(png_ptr);
-
-This must appear before png_write_info() instead of later with the
-other transformations because in the case of paletted images the tRNS
-chunk data has to be inverted before the tRNS chunk is written.  If
-your image is not a paletted image, the tRNS data (which in such cases
-represents a single color to be rendered as transparent) won't need to
-be changed, and you can safely do this transformation after your
-png_write_info() call.
-
-If you need to write a private chunk that you want to appear before
-the PLTE chunk when PLTE is present, you can write the PNG info in
-two steps, and insert code to write your own chunk between them:
-
-    png_write_info_before_PLTE(png_ptr, info_ptr);
-    png_set_unknown_chunks(png_ptr, info_ptr, ...);
-    png_write_info(png_ptr, info_ptr);
-
-After you've written the file information, you can set up the library
-to handle any special transformations of the image data.  The various
-ways to transform the data will be described in the order that they
-should occur.  This is important, as some of these change the color
-type and/or bit depth of the data, and some others only work on
-certain color types and bit depths.  Even though each transformation
-checks to see if it has data that it can do something with, you should
-make sure to only enable a transformation if it will be valid for the
-data.  For example, don't swap red and blue on grayscale data.
-
-PNG files store RGB pixels packed into 3 or 6 bytes.  This code tells
-the library to strip input data that has 4 or 8 bytes per pixel down
-to 3 or 6 bytes (or strip 2 or 4-byte grayscale+filler data to 1 or 2
-bytes per pixel).
-
-    png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
-
-where the 0 is unused, and the location is either PNG_FILLER_BEFORE or
-PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel
-is stored XRGB or RGBX.
-
-PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
-they can, resulting in, for example, 8 pixels per byte for 1 bit files.
-If the data is supplied at 1 pixel per byte, use this code, which will
-correctly pack the pixels into a single byte:
-
-    png_set_packing(png_ptr);
-
-PNG files reduce possible bit depths to 1, 2, 4, 8, and 16.  If your
-data is of another bit depth, you can write an sBIT chunk into the
-file so that decoders can recover the original data if desired.
-
-    /* Set the true bit depth of the image data */
-    if (color_type & PNG_COLOR_MASK_COLOR)
-    {
-       sig_bit.red = true_bit_depth;
-       sig_bit.green = true_bit_depth;
-       sig_bit.blue = true_bit_depth;
-    }
-
-    else
-    {
-       sig_bit.gray = true_bit_depth;
-    }
-
-    if (color_type & PNG_COLOR_MASK_ALPHA)
-    {
-       sig_bit.alpha = true_bit_depth;
-    }
-
-    png_set_sBIT(png_ptr, info_ptr, &sig_bit);
-
-If the data is stored in the row buffer in a bit depth other than
-one supported by PNG (e.g. 3 bit data in the range 0-7 for a 4-bit PNG),
-this will scale the values to appear to be the correct bit depth as
-is required by PNG.
-
-    png_set_shift(png_ptr, &sig_bit);
-
-PNG files store 16 bit pixels in network byte order (big-endian,
-ie. most significant bits first).  This code would be used if they are
-supplied the other way (little-endian, i.e. least significant bits
-first, the way PCs store them):
-
-    if (bit_depth > 8)
-       png_set_swap(png_ptr);
-
-If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
-need to change the order the pixels are packed into bytes, you can use:
-
-    if (bit_depth < 8)
-       png_set_packswap(png_ptr);
-
-PNG files store 3 color pixels in red, green, blue order.  This code
-would be used if they are supplied as blue, green, red:
-
-    png_set_bgr(png_ptr);
-
-PNG files describe monochrome as black being zero and white being
-one. This code would be used if the pixels are supplied with this reversed
-(black being one and white being zero):
-
-    png_set_invert_mono(png_ptr);
-
-Finally, you can write your own transformation function if none of
-the existing ones meets your needs.  This is done by setting a callback
-with
-
-    png_set_write_user_transform_fn(png_ptr,
-       write_transform_fn);
-
-You must supply the function
-
-    void write_transform_fn(png_structp png_ptr ptr,
-       row_info_ptr row_info, png_bytep data)
-
-See pngtest.c for a working example.  Your function will be called
-before any of the other transformations are processed.  If supported
-libpng also supplies an information routine that may be called from
-your callback:
-
-   png_get_current_row_number(png_ptr);
-
-This returns the current row passed to the transform.  Even with interlaced
-images the value returned is the row in the final output image.
-
-You can also set up a pointer to a user structure for use by your
-callback function.
-
-    png_set_user_transform_info(png_ptr, user_ptr, 0, 0);
-
-The user_channels and user_depth parameters of this function are ignored
-when writing; you can set them to zero as shown.
-
-You can retrieve the pointer via the function png_get_user_transform_ptr().
-For example:
-
-    voidp write_user_transform_ptr =
-       png_get_user_transform_ptr(png_ptr);
-
-It is possible to have libpng flush any pending output, either manually,
-or automatically after a certain number of lines have been written.  To
-flush the output stream a single time call:
-
-    png_write_flush(png_ptr);
-
-and to have libpng flush the output stream periodically after a certain
-number of scanlines have been written, call:
-
-    png_set_flush(png_ptr, nrows);
-
-Note that the distance between rows is from the last time png_write_flush()
-was called, or the first row of the image if it has never been called.
-So if you write 50 lines, and then png_set_flush 25, it will flush the
-output on the next scanline, and every 25 lines thereafter, unless
-png_write_flush() is called before 25 more lines have been written.
-If nrows is too small (less than about 10 lines for a 640 pixel wide
-RGB image) the image compression may decrease noticeably (although this
-may be acceptable for real-time applications).  Infrequent flushing will
-only degrade the compression performance by a few percent over images
-that do not use flushing.
-
-.SS Writing the image data
-
-That's it for the transformations.  Now you can write the image data.
-The simplest way to do this is in one function call.  If you have the
-whole image in memory, you can just call png_write_image() and libpng
-will write the image.  You will need to pass in an array of pointers to
-each row.  This function automatically handles interlacing, so you don't
-need to call png_set_interlace_handling() or call this function multiple
-times, or any of that other stuff necessary with png_write_rows().
-
-    png_write_image(png_ptr, row_pointers);
-
-where row_pointers is:
-
-    png_byte *row_pointers[height];
-
-You can point to void or char or whatever you use for pixels.
-
-If you don't want to write the whole image at once, you can
-use png_write_rows() instead.  If the file is not interlaced,
-this is simple:
-
-    png_write_rows(png_ptr, row_pointers,
-       number_of_rows);
-
-row_pointers is the same as in the png_write_image() call.
-
-If you are just writing one row at a time, you can do this with
-a single row_pointer instead of an array of row_pointers:
-
-    png_bytep row_pointer = row;
-
-    png_write_row(png_ptr, row_pointer);
-
-When the file is interlaced, things can get a good deal more complicated.
-The only currently (as of the PNG Specification version 1.2, dated July
-1999) defined interlacing scheme for PNG files is the "Adam7" interlace
-scheme, that breaks down an image into seven smaller images of varying
-size.  libpng will build these images for you, or you can do them
-yourself.  If you want to build them yourself, see the PNG specification
-for details of which pixels to write when.
-
-If you don't want libpng to handle the interlacing details, just
-use png_set_interlace_handling() and call png_write_rows() the
-correct number of times to write all the sub-images
-(png_set_interlace_handling() returns the number of sub-images.)
-
-If you want libpng to build the sub-images, call this before you start
-writing any rows:
-
-    number_of_passes = png_set_interlace_handling(png_ptr);
-
-This will return the number of passes needed.  Currently, this is seven,
-but may change if another interlace type is added.
-
-Then write the complete image number_of_passes times.
-
-    png_write_rows(png_ptr, row_pointers, number_of_rows);
-
-Think carefully before you write an interlaced image.  Typically code that
-reads such images reads all the image data into memory, uncompressed, before
-doing any processing.  Only code that can display an image on the fly can
-take advantage of the interlacing and even then the image has to be exactly
-the correct size for the output device, because scaling an image requires
-adjacent pixels and these are not available until all the passes have been
-read.
-
-If you do write an interlaced image you will hardly ever need to handle
-the interlacing yourself.  Call png_set_interlace_handling() and use the
-approach described above.
-
-The only time it is conceivable that you will really need to write an
-interlaced image pass-by-pass is when you have read one pass by pass and
-made some pixel-by-pixel transformation to it, as described in the read
-code above.  In this case use the PNG_PASS_ROWS and PNG_PASS_COLS macros
-to determine the size of each sub-image in turn and simply write the rows
-you obtained from the read code.
-
-.SS Finishing a sequential write
-
-After you are finished writing the image, you should finish writing
-the file.  If you are interested in writing comments or time, you should
-pass an appropriately filled png_info pointer.  If you are not interested,
-you can pass NULL.
-
-    png_write_end(png_ptr, info_ptr);
-
-When you are done, you can free all memory used by libpng like this:
-
-    png_destroy_write_struct(&png_ptr, &info_ptr);
-
-It is also possible to individually free the info_ptr members that
-point to libpng-allocated storage with the following function:
-
-    png_free_data(png_ptr, info_ptr, mask, seq)
-
-    mask  - identifies data to be freed, a mask
-            containing the bitwise OR of one or
-            more of
-              PNG_FREE_PLTE, PNG_FREE_TRNS,
-              PNG_FREE_HIST, PNG_FREE_ICCP,
-              PNG_FREE_PCAL, PNG_FREE_ROWS,
-              PNG_FREE_SCAL, PNG_FREE_SPLT,
-              PNG_FREE_TEXT, PNG_FREE_UNKN,
-            or simply PNG_FREE_ALL
-
-    seq   - sequence number of item to be freed
-            (-1 for all items)
-
-This function may be safely called when the relevant storage has
-already been freed, or has not yet been allocated, or was allocated
-by the user  and not by libpng,  and will in those cases do nothing.
-The "seq" parameter is ignored if only one item of the selected data
-type, such as PLTE, is allowed.  If "seq" is not -1, and multiple items
-are allowed for the data type identified in the mask, such as text or
-sPLT, only the n'th item in the structure is freed, where n is "seq".
-
-If you allocated data such as a palette that you passed in to libpng
-with png_set_*, you must not free it until just before the call to
-png_destroy_write_struct().
-
-The default behavior is only to free data that was allocated internally
-by libpng.  This can be changed, so that libpng will not free the data,
-or so that it will free data that was allocated by the user with png_malloc()
-or png_zalloc() and passed in via a png_set_*() function, with
-
-    png_data_freer(png_ptr, info_ptr, freer, mask)
-
-    freer  - one of
-               PNG_DESTROY_WILL_FREE_DATA
-               PNG_SET_WILL_FREE_DATA
-               PNG_USER_WILL_FREE_DATA
-
-    mask   - which data elements are affected
-             same choices as in png_free_data()
-
-For example, to transfer responsibility for some data from a read structure
-to a write structure, you could use
-
-    png_data_freer(read_ptr, read_info_ptr,
-       PNG_USER_WILL_FREE_DATA,
-       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
-
-    png_data_freer(write_ptr, write_info_ptr,
-       PNG_DESTROY_WILL_FREE_DATA,
-       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
-
-thereby briefly reassigning responsibility for freeing to the user but
-immediately afterwards reassigning it once more to the write_destroy
-function.  Having done this, it would then be safe to destroy the read
-structure and continue to use the PLTE, tRNS, and hIST data in the write
-structure.
-
-This function only affects data that has already been allocated.
-You can call this function before calling after the png_set_*() functions
-to control whether the user or png_destroy_*() is supposed to free the data.
-When the user assumes responsibility for libpng-allocated data, the
-application must use
-png_free() to free it, and when the user transfers responsibility to libpng
-for data that the user has allocated, the user must have used png_malloc()
-or png_zalloc() to allocate it.
-
-If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
-separately, do not transfer responsibility for freeing text_ptr to libpng,
-because when libpng fills a png_text structure it combines these members with
-the key member, and png_free_data() will free only text_ptr.key.  Similarly,
-if you transfer responsibility for free'ing text_ptr from libpng to your
-application, your application must not separately free those members.
-For a more compact example of writing a PNG image, see the file example.c.
-
-.SH V. Modifying/Customizing libpng:
-
-There are two issues here.  The first is changing how libpng does
-standard things like memory allocation, input/output, and error handling.
-The second deals with more complicated things like adding new chunks,
-adding new transformations, and generally changing how libpng works.
-Both of those are compile-time issues; that is, they are generally
-determined at the time the code is written, and there is rarely a need
-to provide the user with a means of changing them.
-
-Memory allocation, input/output, and error handling
-
-All of the memory allocation, input/output, and error handling in libpng
-goes through callbacks that are user-settable.  The default routines are
-in pngmem.c, pngrio.c, pngwio.c, and pngerror.c, respectively.  To change
-these functions, call the appropriate png_set_*_fn() function.
-
-Memory allocation is done through the functions png_malloc(), png_calloc(),
-and png_free().  These currently just call the standard C functions.
-png_calloc() calls png_malloc() and then clears the newly
-allocated memory to zero.  There is limited support for certain systems
-with segmented memory architectures and the types of pointers declared by
-png.h match this; you will have to use appropriate pointers in your
-application.  Since it is
-unlikely that the method of handling memory allocation on a platform
-will change between applications, these functions must be modified in
-the library at compile time.  If you prefer to use a different method
-of allocating and freeing data, you can use png_create_read_struct_2() or
-png_create_write_struct_2() to register your own functions as described
-above.  These functions also provide a void pointer that can be retrieved
-via
-
-    mem_ptr=png_get_mem_ptr(png_ptr);
-
-Your replacement memory functions must have prototypes as follows:
-
-    png_voidp malloc_fn(png_structp png_ptr,
-       png_alloc_size_t size);
-
-    void free_fn(png_structp png_ptr, png_voidp ptr);
-
-Your malloc_fn() must return NULL in case of failure.  The png_malloc()
-function will normally call png_error() if it receives a NULL from the
-system memory allocator or from your replacement malloc_fn().
-
-Your free_fn() will never be called with a NULL ptr, since libpng's
-png_free() checks for NULL before calling free_fn().
-
-Input/Output in libpng is done through png_read() and png_write(),
-which currently just call fread() and fwrite().  The FILE * is stored in
-png_struct and is initialized via png_init_io().  If you wish to change
-the method of I/O, the library supplies callbacks that you can set
-through the function png_set_read_fn() and png_set_write_fn() at run
-time, instead of calling the png_init_io() function.  These functions
-also provide a void pointer that can be retrieved via the function
-png_get_io_ptr().  For example:
-
-    png_set_read_fn(png_structp read_ptr,
-        voidp read_io_ptr, png_rw_ptr read_data_fn)
-
-    png_set_write_fn(png_structp write_ptr,
-        voidp write_io_ptr, png_rw_ptr write_data_fn,
-        png_flush_ptr output_flush_fn);
-
-    voidp read_io_ptr = png_get_io_ptr(read_ptr);
-    voidp write_io_ptr = png_get_io_ptr(write_ptr);
-
-The replacement I/O functions must have prototypes as follows:
-
-    void user_read_data(png_structp png_ptr,
-        png_bytep data, png_size_t length);
-
-    void user_write_data(png_structp png_ptr,
-        png_bytep data, png_size_t length);
-
-    void user_flush_data(png_structp png_ptr);
-
-The user_read_data() function is responsible for detecting and
-handling end-of-data errors.
-
-Supplying NULL for the read, write, or flush functions sets them back
-to using the default C stream functions, which expect the io_ptr to
-point to a standard *FILE structure.  It is probably a mistake
-to use NULL for one of write_data_fn and output_flush_fn but not both
-of them, unless you have built libpng with PNG_NO_WRITE_FLUSH defined.
-It is an error to read from a write stream, and vice versa.
-
-Error handling in libpng is done through png_error() and png_warning().
-Errors handled through png_error() are fatal, meaning that png_error()
-should never return to its caller.  Currently, this is handled via
-setjmp() and longjmp() (unless you have compiled libpng with
-PNG_NO_SETJMP, in which case it is handled via PNG_ABORT()),
-but you could change this to do things like exit() if you should wish,
-as long as your function does not return.
-
-On non-fatal errors, png_warning() is called
-to print a warning message, and then control returns to the calling code.
-By default png_error() and png_warning() print a message on stderr via
-fprintf() unless the library is compiled with PNG_NO_CONSOLE_IO defined
-(because you don't want the messages) or PNG_NO_STDIO defined (because
-fprintf() isn't available).  If you wish to change the behavior of the error
-functions, you will need to set up your own message callbacks.  These
-functions are normally supplied at the time that the png_struct is created.
-It is also possible to redirect errors and warnings to your own replacement
-functions after png_create_*_struct() has been called by calling:
-
-    png_set_error_fn(png_structp png_ptr,
-        png_voidp error_ptr, png_error_ptr error_fn,
-        png_error_ptr warning_fn);
-
-    png_voidp error_ptr = png_get_error_ptr(png_ptr);
-
-If NULL is supplied for either error_fn or warning_fn, then the libpng
-default function will be used, calling fprintf() and/or longjmp() if a
-problem is encountered.  The replacement error functions should have
-parameters as follows:
-
-    void user_error_fn(png_structp png_ptr,
-        png_const_charp error_msg);
-
-    void user_warning_fn(png_structp png_ptr,
-        png_const_charp warning_msg);
-
-The motivation behind using setjmp() and longjmp() is the C++ throw and
-catch exception handling methods.  This makes the code much easier to write,
-as there is no need to check every return code of every function call.
-However, there are some uncertainties about the status of local variables
-after a longjmp, so the user may want to be careful about doing anything
-after setjmp returns non-zero besides returning itself.  Consult your
-compiler documentation for more details.  For an alternative approach, you
-may wish to use the "cexcept" facility (see http://cexcept.sourceforge.net).
-
-.SS Custom chunks
-
-If you need to read or write custom chunks, you may need to get deeper
-into the libpng code.  The library now has mechanisms for storing
-and writing chunks of unknown type; you can even declare callbacks
-for custom chunks.  However, this may not be good enough if the
-library code itself needs to know about interactions between your
-chunk and existing `intrinsic' chunks.
-
-If you need to write a new intrinsic chunk, first read the PNG
-specification. Acquire a first level of understanding of how it works.
-Pay particular attention to the sections that describe chunk names,
-and look at how other chunks were designed, so you can do things
-similarly.  Second, check out the sections of libpng that read and
-write chunks.  Try to find a chunk that is similar to yours and use
-it as a template.  More details can be found in the comments inside
-the code.  It is best to handle unknown chunks in a generic method,
-via callback functions, instead of by modifying libpng functions.
-
-If you wish to write your own transformation for the data, look through
-the part of the code that does the transformations, and check out some of
-the simpler ones to get an idea of how they work.  Try to find a similar
-transformation to the one you want to add and copy off of it.  More details
-can be found in the comments inside the code itself.
-
-.SS Configuring for 16 bit platforms
-
-You will want to look into zconf.h to tell zlib (and thus libpng) that
-it cannot allocate more then 64K at a time.  Even if you can, the memory
-won't be accessible.  So limit zlib and libpng to 64K by defining MAXSEG_64K.
-
-.SS Configuring for DOS
-
-For DOS users who only have access to the lower 640K, you will
-have to limit zlib's memory usage via a png_set_compression_mem_level()
-call.  See zlib.h or zconf.h in the zlib library for more information.
-
-.SS Configuring for Medium Model
-
-Libpng's support for medium model has been tested on most of the popular
-compilers.  Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
-defined, and FAR gets defined to far in pngconf.h, and you should be
-all set.  Everything in the library (except for zlib's structure) is
-expecting far data.  You must use the typedefs with the p or pp on
-the end for pointers (or at least look at them and be careful).  Make
-note that the rows of data are defined as png_bytepp, which is an
-unsigned char far * far *.
-
-.SS Configuring for gui/windowing platforms:
-
-You will need to write new error and warning functions that use the GUI
-interface, as described previously, and set them to be the error and
-warning functions at the time that png_create_*_struct() is called,
-in order to have them available during the structure initialization.
-They can be changed later via png_set_error_fn().  On some compilers,
-you may also have to change the memory allocators (png_malloc, etc.).
-
-.SS Configuring for compiler xxx:
-
-All includes for libpng are in pngconf.h.  If you need to add, change
-or delete an include, this is the place to do it.
-The includes that are not needed outside libpng are placed in pngpriv.h,
-which is only used by the routines inside libpng itself.
-The files in libpng proper only include pngpriv.h and png.h, which
-in turn includes pngconf.h.
-
-.SS Configuring zlib:
-
-There are special functions to configure the compression.  Perhaps the
-most useful one changes the compression level, which currently uses
-input compression values in the range 0 - 9.  The library normally
-uses the default compression level (Z_DEFAULT_COMPRESSION = 6).  Tests
-have shown that for a large majority of images, compression values in
-the range 3-6 compress nearly as well as higher levels, and do so much
-faster.  For online applications it may be desirable to have maximum speed
-(Z_BEST_SPEED = 1).  With versions of zlib after v0.99, you can also
-specify no compression (Z_NO_COMPRESSION = 0), but this would create
-files larger than just storing the raw bitmap.  You can specify the
-compression level by calling:
-
-    png_set_compression_level(png_ptr, level);
-
-Another useful one is to reduce the memory level used by the library.
-The memory level defaults to 8, but it can be lowered if you are
-short on memory (running DOS, for example, where you only have 640K).
-Note that the memory level does have an effect on compression; among
-other things, lower levels will result in sections of incompressible
-data being emitted in smaller stored blocks, with a correspondingly
-larger relative overhead of up to 15% in the worst case.
-
-    png_set_compression_mem_level(png_ptr, level);
-
-The other functions are for configuring zlib.  They are not recommended
-for normal use and may result in writing an invalid PNG file.  See
-zlib.h for more information on what these mean.
-
-    png_set_compression_strategy(png_ptr,
-        strategy);
-
-    png_set_compression_window_bits(png_ptr,
-        window_bits);
-
-    png_set_compression_method(png_ptr, method);
-    png_set_compression_buffer_size(png_ptr, size);
-
-.SS Controlling row filtering
-
-If you want to control whether libpng uses filtering or not, which
-filters are used, and how it goes about picking row filters, you
-can call one of these functions.  The selection and configuration
-of row filters can have a significant impact on the size and
-encoding speed and a somewhat lesser impact on the decoding speed
-of an image.  Filtering is enabled by default for RGB and grayscale
-images (with and without alpha), but not for paletted images nor
-for any images with bit depths less than 8 bits/pixel.
-
-The 'method' parameter sets the main filtering method, which is
-currently only '0' in the PNG 1.2 specification.  The 'filters'
-parameter sets which filter(s), if any, should be used for each
-scanline.  Possible values are PNG_ALL_FILTERS and PNG_NO_FILTERS
-to turn filtering on and off, respectively.
-
-Individual filter types are PNG_FILTER_NONE, PNG_FILTER_SUB,
-PNG_FILTER_UP, PNG_FILTER_AVG, PNG_FILTER_PAETH, which can be bitwise
-ORed together with '|' to specify one or more filters to use.
-These filters are described in more detail in the PNG specification.
-If you intend to change the filter type during the course of writing
-the image, you should start with flags set for all of the filters
-you intend to use so that libpng can initialize its internal
-structures appropriately for all of the filter types.  (Note that this
-means the first row must always be adaptively filtered, because libpng
-currently does not allocate the filter buffers until png_write_row()
-is called for the first time.)
-
-    filters = PNG_FILTER_NONE | PNG_FILTER_SUB
-              PNG_FILTER_UP | PNG_FILTER_AVG |
-              PNG_FILTER_PAETH | PNG_ALL_FILTERS;
-
-    png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE,
-       filters);
-              The second parameter can also be
-              PNG_INTRAPIXEL_DIFFERENCING if you are
-              writing a PNG to be embedded in a MNG
-              datastream.  This parameter must be the
-              same as the value of filter_method used
-              in png_set_IHDR().
-
-It is also possible to influence how libpng chooses from among the
-available filters.  This is done in one or both of two ways - by
-telling it how important it is to keep the same filter for successive
-rows, and by telling it the relative computational costs of the filters.
-
-    double weights[3] = {1.5, 1.3, 1.1},
-       costs[PNG_FILTER_VALUE_LAST] =
-       {1.0, 1.3, 1.3, 1.5, 1.7};
-
-    png_set_filter_heuristics(png_ptr,
-       PNG_FILTER_HEURISTIC_WEIGHTED, 3,
-       weights, costs);
-
-The weights are multiplying factors that indicate to libpng that the
-row filter should be the same for successive rows unless another row filter
-is that many times better than the previous filter.  In the above example,
-if the previous 3 filters were SUB, SUB, NONE, the SUB filter could have a
-"sum of absolute differences" 1.5 x 1.3 times higher than other filters
-and still be chosen, while the NONE filter could have a sum 1.1 times
-higher than other filters and still be chosen.  Unspecified weights are
-taken to be 1.0, and the specified weights should probably be declining
-like those above in order to emphasize recent filters over older filters.
-
-The filter costs specify for each filter type a relative decoding cost
-to be considered when selecting row filters.  This means that filters
-with higher costs are less likely to be chosen over filters with lower
-costs, unless their "sum of absolute differences" is that much smaller.
-The costs do not necessarily reflect the exact computational speeds of
-the various filters, since this would unduly influence the final image
-size.
-
-Note that the numbers above were invented purely for this example and
-are given only to help explain the function usage.  Little testing has
-been done to find optimum values for either the costs or the weights.
-
-.SS Removing unwanted object code
-
-There are a bunch of #define's in pngconf.h that control what parts of
-libpng are compiled.  All the defines end in _SUPPORTED.  If you are
-never going to use a capability, you can change the #define to #undef
-before recompiling libpng and save yourself code and data space, or
-you can turn off individual capabilities with defines that begin with
-PNG_NO_.
-
-In libpng-1.5.0 and later, the #define's are in pnglibconf.h instead.
-
-You can also turn all of the transforms and ancillary chunk capabilities
-off en masse with compiler directives that define
-PNG_NO_READ[or WRITE]_TRANSFORMS, or PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS,
-or all four,
-along with directives to turn on any of the capabilities that you do
-want.  The PNG_NO_READ[or WRITE]_TRANSFORMS directives disable the extra
-transformations but still leave the library fully capable of reading
-and writing PNG files with all known public chunks. Use of the
-PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS directive produces a library
-that is incapable of reading or writing ancillary chunks.  If you are
-not using the progressive reading capability, you can turn that off
-with PNG_NO_PROGRESSIVE_READ (don't confuse this with the INTERLACING
-capability, which you'll still have).
-
-All the reading and writing specific code are in separate files, so the
-linker should only grab the files it needs.  However, if you want to
-make sure, or if you are building a stand alone library, all the
-reading files start with pngr and all the writing files start with
-pngw.  The files that don't match either (like png.c, pngtrans.c, etc.)
-are used for both reading and writing, and always need to be included.
-The progressive reader is in pngpread.c
-
-If you are creating or distributing a dynamically linked library (a .so
-or DLL file), you should not remove or disable any parts of the library,
-as this will cause applications linked with different versions of the
-library to fail if they call functions not available in your library.
-The size of the library itself should not be an issue, because only
-those sections that are actually used will be loaded into memory.
-
-.SS Requesting debug printout
-
-The macro definition PNG_DEBUG can be used to request debugging
-printout.  Set it to an integer value in the range 0 to 3.  Higher
-numbers result in increasing amounts of debugging information.  The
-information is printed to the "stderr" file, unless another file
-name is specified in the PNG_DEBUG_FILE macro definition.
-
-When PNG_DEBUG > 0, the following functions (macros) become available:
-
-   png_debug(level, message)
-   png_debug1(level, message, p1)
-   png_debug2(level, message, p1, p2)
-
-in which "level" is compared to PNG_DEBUG to decide whether to print
-the message, "message" is the formatted string to be printed,
-and p1 and p2 are parameters that are to be embedded in the string
-according to printf-style formatting directives.  For example,
-
-   png_debug1(2, "foo=%d\n", foo);
-
-is expanded to
-
-   if (PNG_DEBUG > 2)
-      fprintf(PNG_DEBUG_FILE, "foo=%d\n", foo);
-
-When PNG_DEBUG is defined but is zero, the macros aren't defined, but you
-can still use PNG_DEBUG to control your own debugging:
-
-   #ifdef PNG_DEBUG
-       fprintf(stderr, ...
-   #endif
-
-When PNG_DEBUG = 1, the macros are defined, but only png_debug statements
-having level = 0 will be printed.  There aren't any such statements in
-this version of libpng, but if you insert some they will be printed.
-
-.SH VI.  MNG support
-
-The MNG specification (available at http://www.libpng.org/pub/mng) allows
-certain extensions to PNG for PNG images that are embedded in MNG datastreams.
-Libpng can support some of these extensions.  To enable them, use the
-png_permit_mng_features() function:
-
-   feature_set = png_permit_mng_features(png_ptr, mask)
-
-   mask is a png_uint_32 containing the bitwise OR of the
-        features you want to enable.  These include
-        PNG_FLAG_MNG_EMPTY_PLTE
-        PNG_FLAG_MNG_FILTER_64
-        PNG_ALL_MNG_FEATURES
-
-   feature_set is a png_uint_32 that is the bitwise AND of
-      your mask with the set of MNG features that is
-      supported by the version of libpng that you are using.
-
-It is an error to use this function when reading or writing a standalone
-PNG file with the PNG 8-byte signature.  The PNG datastream must be wrapped
-in a MNG datastream.  As a minimum, it must have the MNG 8-byte signature
-and the MHDR and MEND chunks.  Libpng does not provide support for these
-or any other MNG chunks; your application must provide its own support for
-them.  You may wish to consider using libmng (available at
-http://www.libmng.com) instead.
-
-.SH VII.  Changes to Libpng from version 0.88
-
-It should be noted that versions of libpng later than 0.96 are not
-distributed by the original libpng author, Guy Schalnat, nor by
-Andreas Dilger, who had taken over from Guy during 1996 and 1997, and
-distributed versions 0.89 through 0.96, but rather by another member
-of the original PNG Group, Glenn Randers-Pehrson.  Guy and Andreas are
-still alive and well, but they have moved on to other things.
-
-The old libpng functions png_read_init(), png_write_init(),
-png_info_init(), png_read_destroy(), and png_write_destroy() have been
-moved to PNG_INTERNAL in version 0.95 to discourage their use.  These
-functions will be removed from libpng version 1.4.0.
-
-The preferred method of creating and initializing the libpng structures is
-via the png_create_read_struct(), png_create_write_struct(), and
-png_create_info_struct() because they isolate the size of the structures
-from the application, allow version error checking, and also allow the
-use of custom error handling routines during the initialization, which
-the old functions do not.  The functions png_read_destroy() and
-png_write_destroy() do not actually free the memory that libpng
-allocated for these structs, but just reset the data structures, so they
-can be used instead of png_destroy_read_struct() and
-png_destroy_write_struct() if you feel there is too much system overhead
-allocating and freeing the png_struct for each image read.
-
-Setting the error callbacks via png_set_message_fn() before
-png_read_init() as was suggested in libpng-0.88 is no longer supported
-because this caused applications that do not use custom error functions
-to fail if the png_ptr was not initialized to zero.  It is still possible
-to set the error callbacks AFTER png_read_init(), or to change them with
-png_set_error_fn(), which is essentially the same function, but with a new
-name to force compilation errors with applications that try to use the old
-method.
-
-Starting with version 1.0.7, you can find out which version of the library
-you are using at run-time:
-
-   png_uint_32 libpng_vn = png_access_version_number();
-
-The number libpng_vn is constructed from the major version, minor
-version with leading zero, and release number with leading zero,
-(e.g., libpng_vn for version 1.0.7 is 10007).
-
-You can also check which version of png.h you used when compiling your
-application:
-
-   png_uint_32 application_vn = PNG_LIBPNG_VER;
-
-.SH VIII.  Changes to Libpng from version 1.0.x to 1.2.x
-
-Support for user memory management was enabled by default.  To
-accomplish this, the functions png_create_read_struct_2(),
-png_create_write_struct_2(), png_set_mem_fn(), png_get_mem_ptr(),
-png_malloc_default(), and png_free_default() were added.
-
-Support for the iTXt chunk has been enabled by default as of
-version 1.2.41.
-
-Support for certain MNG features was enabled.
-
-Support for numbered error messages was added.  However, we never got
-around to actually numbering the error messages.  The function
-png_set_strip_error_numbers() was added (Note: the prototype for this
-function was inadvertently removed from png.h in PNG_NO_ASSEMBLER_CODE
-builds of libpng-1.2.15.  It was restored in libpng-1.2.36).
-
-The png_malloc_warn() function was added at libpng-1.2.3.  This issues
-a png_warning and returns NULL instead of aborting when it fails to
-acquire the requested memory allocation.
-
-Support for setting user limits on image width and height was enabled
-by default.  The functions png_set_user_limits(), png_get_user_width_max(),
-and png_get_user_height_max() were added at libpng-1.2.6.
-
-The png_set_add_alpha() function was added at libpng-1.2.7.
-
-The function png_set_expand_gray_1_2_4_to_8() was added at libpng-1.2.9.
-Unlike png_set_gray_1_2_4_to_8(), the new function does not expand the
-tRNS chunk to alpha. The png_set_gray_1_2_4_to_8() function is
-deprecated.
-
-A number of macro definitions in support of runtime selection of
-assembler code features (especially Intel MMX code support) were
-added at libpng-1.2.0:
-
-    PNG_ASM_FLAG_MMX_SUPPORT_COMPILED
-    PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
-    PNG_ASM_FLAG_MMX_READ_COMBINE_ROW
-    PNG_ASM_FLAG_MMX_READ_INTERLACE
-    PNG_ASM_FLAG_MMX_READ_FILTER_SUB
-    PNG_ASM_FLAG_MMX_READ_FILTER_UP
-    PNG_ASM_FLAG_MMX_READ_FILTER_AVG
-    PNG_ASM_FLAG_MMX_READ_FILTER_PAETH
-    PNG_ASM_FLAGS_INITIALIZED
-    PNG_MMX_READ_FLAGS
-    PNG_MMX_FLAGS
-    PNG_MMX_WRITE_FLAGS
-    PNG_MMX_FLAGS
-
-We added the following functions in support of runtime
-selection of assembler code features:
-
-    png_get_mmx_flagmask()
-    png_set_mmx_thresholds()
-    png_get_asm_flags()
-    png_get_mmx_bitdepth_threshold()
-    png_get_mmx_rowbytes_threshold()
-    png_set_asm_flags()
-
-We replaced all of these functions with simple stubs in libpng-1.2.20,
-when the Intel assembler code was removed due to a licensing issue.
-
-These macros are deprecated:
-
-    PNG_READ_TRANSFORMS_NOT_SUPPORTED
-    PNG_PROGRESSIVE_READ_NOT_SUPPORTED
-    PNG_NO_SEQUENTIAL_READ_SUPPORTED
-    PNG_WRITE_TRANSFORMS_NOT_SUPPORTED
-    PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED
-    PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED
-
-They have been replaced, respectively, by:
-
-    PNG_NO_READ_TRANSFORMS
-    PNG_NO_PROGRESSIVE_READ
-    PNG_NO_SEQUENTIAL_READ
-    PNG_NO_WRITE_TRANSFORMS
-    PNG_NO_READ_ANCILLARY_CHUNKS
-    PNG_NO_WRITE_ANCILLARY_CHUNKS
-
-PNG_MAX_UINT was replaced with PNG_UINT_31_MAX.  It has been
-deprecated since libpng-1.0.16 and libpng-1.2.6.
-
-The function
-    png_check_sig(sig, num)
-was replaced with
-    !png_sig_cmp(sig, 0, num)
-It has been deprecated since libpng-0.90.
-
-The function
-    png_set_gray_1_2_4_to_8()
-which also expands tRNS to alpha was replaced with
-    png_set_expand_gray_1_2_4_to_8()
-which does not. It has been deprecated since libpng-1.0.18 and 1.2.9.
-
-.SH IX.  Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
-
-Private libpng prototypes and macro definitions were moved from
-png.h and pngconf.h into a new pngpriv.h header file.
-
-Functions png_set_benign_errors(), png_benign_error(), and
-png_chunk_benign_error() were added.
-
-Support for setting the maximum amount of memory that the application
-will allocate for reading chunks was added, as a security measure.
-The functions png_set_chunk_cache_max() and png_get_chunk_cache_max()
-were added to the library.
-
-We implemented support for I/O states by adding png_ptr member io_state
-and functions png_get_io_chunk_name() and png_get_io_state() in pngget.c
-
-We added PNG_TRANSFORM_GRAY_TO_RGB to the available high-level
-input transforms.
-
-Checking for and reporting of errors in the IHDR chunk is more thorough.
-
-Support for global arrays was removed, to improve thread safety.
-
-Some obsolete/deprecated macros and functions have been removed.
-
-Typecasted NULL definitions such as
-   #define png_voidp_NULL            (png_voidp)NULL
-were eliminated.  If you used these in your application, just use
-NULL instead.
-
-The png_struct and info_struct members "trans" and "trans_values" were
-changed to "trans_alpha" and "trans_color", respectively.
-
-The obsolete, unused pnggccrd.c and pngvcrd.c files and related makefiles
-were removed.
-
-The PNG_1_0_X and PNG_1_2_X macros were eliminated.
-
-The PNG_LEGACY_SUPPORTED macro was eliminated.
-
-Many WIN32_WCE #ifdefs were removed.
-
-The functions png_read_init(info_ptr), png_write_init(info_ptr),
-png_info_init(info_ptr), png_read_destroy(), and png_write_destroy()
-have been removed.  They have been deprecated since libpng-0.95.
-
-The png_permit_empty_plte() was removed. It has been deprecated
-since libpng-1.0.9.  Use png_permit_mng_features() instead.
-
-We removed the obsolete stub functions png_get_mmx_flagmask(),
-png_set_mmx_thresholds(), png_get_asm_flags(),
-png_get_mmx_bitdepth_threshold(), png_get_mmx_rowbytes_threshold(),
-png_set_asm_flags(), and png_mmx_supported()
-
-We removed the obsolete png_check_sig(), png_memcpy_check(), and
-png_memset_check() functions.  Instead use !png_sig_cmp(), memcpy(),
-and memset(), respectively.
-
-The function png_set_gray_1_2_4_to_8() was removed. It has been
-deprecated since libpng-1.0.18 and 1.2.9, when it was replaced with
-png_set_expand_gray_1_2_4_to_8() because the former function also
-expanded palette images.
-
-Macros for png_get_uint_16, png_get_uint_32, and png_get_int_32
-were added and are used by default instead of the corresponding
-functions. Unfortunately,
-from libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the  
-function) incorrectly returned a value of type png_uint_32.
-
-We changed the prototype for png_malloc() from
-    png_malloc(png_structp png_ptr, png_uint_32 size)
-to
-    png_malloc(png_structp png_ptr, png_alloc_size_t size)
-
-This also applies to the prototype for the user replacement malloc_fn().
-
-The png_calloc() function was added and is used in place of
-of "png_malloc(); memset();" except in the case in png_read_png()
-where the array consists of pointers; in this case a "for" loop is used
-after the png_malloc() to set the pointers to NULL, to give robust.
-behavior in case the application runs out of memory part-way through
-the process.
-
-We changed the prototypes of png_get_compression_buffer_size() and
-png_set_compression_buffer_size() to work with png_size_t instead of
-png_uint_32.
-
-Support for numbered error messages was removed by default, since we
-never got around to actually numbering the error messages. The function
-png_set_strip_error_numbers() was removed from the library by default.
-
-The png_zalloc() and png_zfree() functions are no longer exported.
-The png_zalloc() function no longer zeroes out the memory that it
-allocates.
-
-Support for dithering was disabled by default in libpng-1.4.0, because
-been well tested and doesn't actually "dither".  The code was not
-removed, however, and could be enabled by building libpng with
-PNG_READ_DITHER_SUPPORTED defined.  In libpng-1.4.2, this support
-was reenabled, but the function was renamed png_set_quantize() to
-reflect more accurately what it actually does.  At the same time,
-the PNG_DITHER_[RED,GREEN_BLUE]_BITS macros were also renamed to
-PNG_QUANTIZE_[RED,GREEN,BLUE]_BITS, and PNG_READ_DITHER_SUPPORTED
-was renamed to PNG_READ_QUANTIZE_SUPPORTED.
-
-We removed the trailing '.' from the warning and error messages.
-
-.SH X.  Changes to Libpng from version 1.4.x to 1.5.x
-
-From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the  
-function) incorrectly returned a value of type png_uint_32.
-
-A. Changes that affect users of libpng
-
-There are no substantial API changes between the non-deprecated parts of
-the 1.4.5 API and the 1.5.0 API, however the ability to directly access
-the main libpng control structures, png_struct and png_info, deprecated
-in earlier versions of libpng, has been completely removed from
-libpng 1.5.
-
-We no longer include zlib.h in png.h.  Applications that need access
-to information in zlib.h will need to add the '#include "zlib.h"'
-directive.  It does not matter whether it is placed prior to or after
-the '"#include png.h"' directive.
-
-We moved the png_strcpy(), png_strncpy(), png_strlen(), png_memcpy(),
-png_memcmp(), png_sprintf, and png_memcpy() macros into a private
-header file (pngpriv.h) that is not accessible to applications.
-
-In png_get_iCCP, the type of "profile" was changed from png_charpp
-to png_bytepp, and in png_set_iCCP, from png_charp to png_const_bytep.
-
-There are changes of form in png.h, including new and changed macros to
-declare
-parts of the API.  Some API functions with arguments that are pointers to
-data not modified within the function have been corrected to declare
-these arguments with PNG_CONST.
-
-Much of the internal use of C macros to control the library build has also
-changed and some of this is visible in the exported header files, in
-particular the use of macros to control data and API elements visible
-during application compilation may require significant revision to
-application code.  (It is extremely rare for an application to do this.)
-
-Any program that compiled against libpng 1.4 and did not use deprecated
-features or access internal library structures should compile and work
-against libpng 1.5.
-
-libpng 1.5.0 adds PNG_ PASS macros to help in the reading and writing of
-interlaced images.  The macros return the number of rows and columns in
-each pass and information that can be used to de-interlace and (if
-absolutely necessary) interlace an image.
-
-libpng 1.5.0 adds an API png_longjmp(png_ptr, value).  This API calls
-the application provided png_longjmp_ptr on the internal, but application
-initialized, jmpbuf.  It is provided as a convenience to avoid the need
-to use the png_jmpbuf macro, which had the unnecessary side effect of
-resetting the internal png_longjmp_ptr value.
-
-libpng 1.5.0 includes a complete fixed point API.  By default this is
-present along with the corresponding floating point API.  In general the
-fixed point API is faster and smaller than the floating point one because
-the PNG file format used fixed point, not floating point.  This applies
-even if the library uses floating point in internal calculations.  A new
-macro, PNG_FLOATING_ARITHMETIC_SUPPORTED, reveals whether the library
-uses floating point arithmetic (the default) or fixed point arithmetic
-internally for performance critical calculations such as gamma correction.
-In some cases, the gamma calculations may produce slightly different
-results.  This has changed the results in png_rgb_to_gray and in alpha
-composition (png_set_background for example). This applies even if the
-original image was already linear (gamma == 1.0) and, therefore, it is
-not necessary to linearize the image.  This is because libpng has *not*
-been changed to optimize that case correctly, yet.
-
-Fixed point support for the sCAL chunk comes with an important caveat;
-the sCAL specification uses a decimal encoding of floating point values
-and the accuracy of PNG fixed point values is insufficient for
-representation of these values. Consequently a "string" API
-(png_get_sCAL_s and png_set_sCAL_s) is the only reliable way of reading
-arbitrary sCAL chunks in the absence of either the floating point API or
-internal floating point calculations.
-
-Applications no longer need to include the optional distribution header
-file pngusr.h or define the corresponding macros during application
-build in order to see the correct variant of the libpng API.  From 1.5.0
-application code can check for the corresponding _SUPPORTED macro:
-
-#ifdef PNG_INCH_CONVERSIONS_SUPPORTED
-   /* code that uses the inch conversion APIs. */
-#endif
-
-This macro will only be defined if the inch conversion functions have been
-compiled into libpng.  The full set of macros, and whether or not support
-has been compiled in, are available in the header file pnglibconf.h.
-This header file is specific to the libpng build.  Notice that prior to
-1.5.0 the _SUPPORTED macros would always have the default definition unless
-reset by pngusr.h or by explicit settings on the compiler command line.
-These settings may produce compiler warnings or errors in 1.5.0 because
-of macro redefinition.
-
-From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the  
-function) incorrectly returned a value of type png_uint_32.  libpng 1.5.0
-is consistent with the implementation in 1.4.5 and 1.2.x (where the macro
-did not exist.)
-
-Applications can now choose whether to use these macros or to call the
-corresponding function by defining PNG_USE_READ_MACROS or
-PNG_NO_USE_READ_MACROS before including png.h.  Notice that this is
-only supported from 1.5.0 -defining PNG_NO_USE_READ_MACROS prior to 1.5.0
- will lead to a link failure.
-
-B. Changes to the build and configuration of libpng
-
-Details of internal changes to the library code can be found in the CHANGES
-file.  These will be of no concern to the vast majority of library users or
-builders, however the few who configure libpng to a non-default feature
-set may need to change how this is done.
-
-There should be no need for library builders to alter build scripts if
-these use the distributed build support - configure or the makefiles -
-however users of the makefiles may care to update their build scripts
-to build pnglibconf.h where the corresponding makefile does not do so.
-
-Building libpng with a non-default configuration has changed completely.
-The old method using pngusr.h should still work correctly even though the
-way pngusr.h is used in the build has been changed, however library
-builders will probably want to examine the changes to take advantage of
-new capabilities and to simplify their build system.
-
-B.1 Specific changes to library configuration capabilities
-
-The library now supports a complete fixed point implementation and can
-thus be used on systems which have no floating point support or very
-limited or slow support.  Previously gamma correction, an essential part
-of complete PNG support, required reasonably fast floating point.
-
-As part of this the choice of internal implementation has been made
-independent of the choice of fixed versus floating point APIs and all the
-missing fixed point APIs have been implemented.
-
-The exact mechanism used to control attributes of API functions has
-changed.  A single set of operating system independent macro definitions
-is used and operating system specific directives are defined in
-pnglibconf.h
-
-As part of this the mechanism used to choose procedure call standards on
-those systems that allow a choice has been changed.  At present this only
-affects certain Microsoft (DOS, Windows) and IBM (OS/2) operating systems
-running on Intel processors.  As before PNGAPI is defined where required
-to control the exported API functions; however, two new macros, PNGCBAPI
-and PNGCAPI, are used instead for callback functions (PNGCBAPI) and
-(PNGCAPI) for functions that must match a C library prototype (currently
-only png_longjmp_ptr, which must match the C longjmp function.)  The new
-approach is documented in pngconf.h
-
-Despite these changes libpng 1.5.0 only supports the native C function
-calling standard on those platforms tested so far (__cdecl on Microsoft
-Windows).  This is because the support requirements for alternative
-calling conventions seem to no longer exist.  Developers who find it
-necessary to set PNG_API_RULE to 1 should advise the mailing list
-(png-mng-implement) of this and library builders who use Openwatcom and
-therefore set PNG_API_RULE to 2 should also contact the mailing list.
-
-A new test program, pngvalid, is provided in addition to pngtest.
-pngvalid validates the arithmetic accuracy of the gamma correction
-calculations and includes a number of validations of the file format.
-A subset of the full range of tests is run when "make check" is done
-(in the 'configure' build.)  pngvalid also allows total allocated memory
-usage to be evaluated and performs additional memory overwrite validation.
-
-Many changes to individual feature macros have been made. The following
-are the changes most likely to be noticed by library builders who
-configure libpng:
-
-1) All feature macros now have consistent naming:
-
-#define PNG_NO_feature turns the feature off
-#define PNG_feature_SUPPORTED turns the feature on
-
-pnglibconf.h contains one line for each feature macro which is either:
-
-#define PNG_feature_SUPPORTED
-
-if the feature is supported or:
-
-/*#undef PNG_feature_SUPPORTED*/
-
-if it is not.  Library code consistently checks for the 'SUPPORTED' macro.
-It does not, and should not, check for the 'NO' macro which will not
-normally be defined even if the feature is not supported.
-
-Compatibility with the old names is provided as follows:
-
-PNG_INCH_CONVERSIONS turns on PNG_INCH_CONVERSIONS_SUPPORTED
-
-And the following definitions disable the corresponding feature:
-
-PNG_SETJMP_NOT_SUPPORTED disables SETJMP
-PNG_READ_TRANSFORMS_NOT_SUPPORTED disables READ_TRANSFORMS
-PNG_NO_READ_COMPOSITED_NODIV disables READ_COMPOSITE_NODIV
-PNG_WRITE_TRANSFORMS_NOT_SUPPORTED disables WRITE_TRANSFORMS
-PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED disables READ_ANCILLARY_CHUNKS
-PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED disables WRITE_ANCILLARY_CHUNKS
-
-Library builders should remove use of the above, inconsistent, names.
-
-2) Warning and error message formatting was previously conditional on
-the STDIO feature. The library has been changed to use the
-CONSOLE_IO feature instead. This means that if CONSOLE_IO is disabled
-the library no longer uses the printf(3) functions, even though the
-default read/write implementations use (FILE) style stdio.h functions.
-
-3) Three feature macros now control the fixed/floating point decisions:
-
-PNG_FLOATING_POINT_SUPPORTED enables the floating point APIs
-
-PNG_FIXED_POINT_SUPPORTED enables the fixed point APIs; however, in
-practice these are normally required internally anyway (because the PNG
-file format is fixed point), therefore in most cases PNG_NO_FIXED_POINT
-merely stops the function from being exported.
-
-PNG_FLOATING_ARITHMETIC_SUPPORTED chooses between the internal floating
-point implementation or the fixed point one.  Typically the fixed point
-implementation is larger and slower than the floating point implementation
-on a system that supports floating point, however it may be faster on a
-system which lacks floating point hardware and therefore uses a software
-emulation.
-
-4) Added PNG_{READ,WRITE}_INT_FUNCTIONS_SUPPORTED.  This allows the
-functions to read and write ints to be disabled independently of
-PNG_USE_READ_MACROS, which allows libpng to be built with the functions
-even though the default is to use the macros - this allows applications
-to choose at app buildtime whether or not to use macros (previously
-impossible because the functions weren't in the default build.)
-
-B.2 Changes to the configuration mechanism
-
-Prior to libpng-1.5.0 library builders who needed to configure libpng
-had either to modify the exported pngconf.h header file to add system
-specific configuration or had to write feature selection macros into
-pngusr.h and cause this to be included into pngconf.h by defining
-PNG_USER_CONFIG. The latter mechanism had the disadvantage that an
-application built without PNG_USER_CONFIG defined would see the
-unmodified, default, libpng API and thus would probably fail to link.
-
-These mechanisms still work in the configure build and in any makefile
-build that builds pnglibconf.h although the feature selection macros
-have changed somewhat as described above.  In 1.5.0, however, pngusr.h is
-processed only once, when the exported header file pnglibconf.h is built.
-pngconf.h no longer includes pngusr.h, therefore it is ignored after the
-build of pnglibconf.h and it is never included in an application build.
-
-The rarely used alternative of adding a list of feature macros to the
-CFLAGS setting in the build also still works, however the macros will be
-copied to pnglibconf.h and this may produce macro redefinition warnings
-when the individual C files are compiled.
-
-All configuration now only works if pnglibconf.h is built from
-scripts/pnglibconf.dfa.  This requires the program awk.  Brian Kernighan
-(the original author of awk) maintains C source code of that awk and this
-and all known later implementations (often called by subtly different
-names - nawk and gawk for example) are adequate to build pnglibconf.h.
-The Sun Microsystems (now Oracle) program 'awk' is an earlier version
-and does not work, this may also apply to other systems that have a
-functioning awk called 'nawk'.
-
-Configuration options are now documented in scripts/pnglibconf.dfa.  This
-file also includes dependency information that ensures a configuration is
-consistent; that is, if a feature is switched off dependent features are
-also removed.  As a recommended alternative to using feature macros in
-pngusr.h a system builder may also define equivalent options in pngusr.dfa
-(or, indeed, any file) and add that to the configuration by setting
-DFA_XTRA to the file name.  The makefiles in contrib/pngminim illustrate
-how to do this, and a case where pngusr.h is still required.
-
-.SH XI. Detecting libpng
-
-The png_get_io_ptr() function has been present since libpng-0.88, has never
-changed, and is unaffected by conditional compilation macros.  It is the
-best choice for use in configure scripts for detecting the presence of any
-libpng version since 0.88.  In an autoconf "configure.in" you could use
-
-    AC_CHECK_LIB(png, png_get_io_ptr, ...
-
-.SH XII. Source code repository
-
-Since about February 2009, version 1.2.34, libpng has been under "git" source
-control.  The git repository was built from old libpng-x.y.z.tar.gz files
-going back to version 0.70.  You can access the git repository (read only)
-at
-
-    git://libpng.git.sourceforge.net/gitroot/libpng
-
-or you can browse it via "gitweb" at
-
-    http://libpng.git.sourceforge.net/git/gitweb.cgi?p=libpng
-
-Patches can be sent to glennrp at users.sourceforge.net or to
-png-mng-implement at lists.sourceforge.net or you can upload them to
-the libpng bug tracker at
-
-    http://libpng.sourceforge.net
-
-We also accept patches built from the tar or zip distributions, and
-simple verbal discriptions of bug fixes, reported either to the
-SourceForge bug tracker or to the png-mng-implement at lists.sf.net
-mailing list.
-
-.SH XIII. Coding style
-
-Our coding style is similar to the "Allman" style, with curly
-braces on separate lines:
-
-    if (condition)
-    {
-       action;
-    }
-
-    else if (another condition)
-    {
-       another action;
-    }
-
-The braces can be omitted from simple one-line actions:
-
-    if (condition)
-       return (0);
-
-We use 3-space indentation, except for continued statements which
-are usually indented the same as the first line of the statement
-plus four more spaces.
-
-For macro definitions we use 2-space indentation, always leaving the "#"
-in the first column.
-
-    #ifndef PNG_NO_FEATURE
-    #  ifndef PNG_FEATURE_SUPPORTED
-    #    define PNG_FEATURE_SUPPORTED
-    #  endif
-    #endif
-
-Comments appear with the leading "/*" at the same indentation as
-the statement that follows the comment:
-
-    /* Single-line comment */
-    statement;
-
-    /* This is a multiple-line
-     * comment.
-     */
-    statement;
-
-Very short comments can be placed after the end of the statement
-to which they pertain:
-
-    statement;    /* comment */
-
-We don't use C++ style ("//") comments. We have, however,
-used them in the past in some now-abandoned MMX assembler
-code.
-
-Functions and their curly braces are not indented, and
-exported functions are marked with PNGAPI:
-
- /* This is a public function that is visible to
-  * application programmers. It does thus-and-so.
-  */
- void PNGAPI
- png_exported_function(png_ptr, png_info, foo)
- {
-    body;
- }
-
-The prototypes for all exported functions appear in png.h,
-above the comment that says
-
-    /* Maintainer: Put new public prototypes here ... */
-
-We mark all non-exported functions with "/* PRIVATE */"":
-
- void /* PRIVATE */
- png_non_exported_function(png_ptr, png_info, foo)
- {
-    body;
- }
-
-The prototypes for non-exported functions (except for those in
-pngtest) appear in
-pngpriv.h
-above the comment that says
-
-  /* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */
-
-To avoid polluting the global namespace, the names of all exported
-functions and variables begin with  "png_", and all publicly visible C
-preprocessor macros begin with "PNG_".  We request that applications that
-use libpng *not* begin any of their own symbols with either of these strings.
-
-We put a space after each comma and after each semicolon
-in "for" statements, and we put spaces before and after each
-C binary operator and after "for" or "while", and before
-"?".  We don't put a space between a typecast and the expression
-being cast, nor do we put one between a function name and the
-left parenthesis that follows it:
-
-    for (i = 2; i > 0; --i)
-       y[i] = a(x) + (int)b;
-
-We prefer #ifdef and #ifndef to #if defined() and if !defined()
-when there is only one macro being tested.
-
-We do not use the TAB character for indentation in the C sources.
-
-Lines do not exceed 80 characters.
-
-Other rules can be inferred by inspecting the libpng source.
-
-.SH XIV. Y2K Compliance in libpng
-
-February 3, 2011
-
-Since the PNG Development group is an ad-hoc body, we can't make
-an official declaration.
-
-This is your unofficial assurance that libpng from version 0.71 and
-upward through 1.5.1 are Y2K compliant.  It is my belief that earlier
-versions were also Y2K compliant.
-
-Libpng only has three year fields.  One is a 2-byte unsigned integer that
-will hold years up to 65535.  The other two hold the date in text
-format, and will hold years up to 9999.
-
-The integer is
-    "png_uint_16 year" in png_time_struct.
-
-The strings are
-    "png_charp time_buffer" in png_struct and
-    "near_time_buffer", which is a local character string in png.c.
-
-There are seven time-related functions:
-
-    png_convert_to_rfc_1123() in png.c
-      (formerly png_convert_to_rfc_1152() in error)
-    png_convert_from_struct_tm() in pngwrite.c, called
-      in pngwrite.c
-    png_convert_from_time_t() in pngwrite.c
-    png_get_tIME() in pngget.c
-    png_handle_tIME() in pngrutil.c, called in pngread.c
-    png_set_tIME() in pngset.c
-    png_write_tIME() in pngwutil.c, called in pngwrite.c
-
-All appear to handle dates properly in a Y2K environment.  The
-png_convert_from_time_t() function calls gmtime() to convert from system
-clock time, which returns (year - 1900), which we properly convert to
-the full 4-digit year.  There is a possibility that applications using
-libpng are not passing 4-digit years into the png_convert_to_rfc_1123()
-function, or that they are incorrectly passing only a 2-digit year
-instead of "year - 1900" into the png_convert_from_struct_tm() function,
-but this is not under our control.  The libpng documentation has always
-stated that it works with 4-digit years, and the APIs have been
-documented as such.
-
-The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
-integer to hold the year, and can hold years as large as 65535.
-
-zlib, upon which libpng depends, is also Y2K compliant.  It contains
-no date-related code.
-
-
-   Glenn Randers-Pehrson
-   libpng maintainer
-   PNG Development Group
-
-.SH NOTE
-
-Note about libpng version numbers:
-
-Due to various miscommunications, unforeseen code incompatibilities
-and occasional factors outside the authors' control, version numbering
-on the library has not always been consistent and straightforward.
-The following table summarizes matters since version 0.89c, which was
-the first widely used release:
-
- source             png.h  png.h  shared-lib
- version            string   int  version
- -------            ------  ----- ----------
- 0.89c ("beta 3")  0.89       89  1.0.89
- 0.90  ("beta 4")  0.90       90  0.90
- 0.95  ("beta 5")  0.95       95  0.95
- 0.96  ("beta 6")  0.96       96  0.96
- 0.97b ("beta 7")  1.00.97    97  1.0.1
- 0.97c             0.97       97  2.0.97
- 0.98              0.98       98  2.0.98
- 0.99              0.99       98  2.0.99
- 0.99a-m           0.99       99  2.0.99
- 1.00              1.00      100  2.1.0
- 1.0.0             1.0.0     100  2.1.0
- 1.0.0   (from here on, the  100  2.1.0
- 1.0.1    png.h string is  10001  2.1.0
- 1.0.1a-e identical to the 10002  from here on, the
- 1.0.2    source version)  10002  shared library is 2.V
- 1.0.2a-b                  10003  where V is the source
- 1.0.1                     10001  code version except as
- 1.0.1a-e                  10002  2.1.0.1a-e   noted.
- 1.0.2                     10002  2.1.0.2
- 1.0.2a-b                  10003  2.1.0.2a-b
- 1.0.3                     10003  2.1.0.3
- 1.0.3a-d                  10004  2.1.0.3a-d
- 1.0.4                     10004  2.1.0.4
- 1.0.4a-f                  10005  2.1.0.4a-f
- 1.0.5 (+ 2 patches)       10005  2.1.0.5
- 1.0.5a-d                  10006  2.1.0.5a-d
- 1.0.5e-r                  10100  2.1.0.5e-r
- 1.0.5s-v                  10006  2.1.0.5s-v
- 1.0.6 (+ 3 patches)       10006  2.1.0.6
- 1.0.6d-g                  10007  2.1.0.6d-g
- 1.0.6h                    10007  10.6h
- 1.0.6i                    10007  10.6i
- 1.0.6j                    10007  2.1.0.6j
- 1.0.7beta11-14    DLLNUM  10007  2.1.0.7beta11-14
- 1.0.7beta15-18       1    10007  2.1.0.7beta15-18
- 1.0.7rc1-2           1    10007  2.1.0.7rc1-2
- 1.0.7                1    10007  2.1.0.7
- 1.0.8beta1-4         1    10008  2.1.0.8beta1-4
- 1.0.8rc1             1    10008  2.1.0.8rc1
- 1.0.8                1    10008  2.1.0.8
- 1.0.9beta1-6         1    10009  2.1.0.9beta1-6
- 1.0.9rc1             1    10009  2.1.0.9rc1
- 1.0.9beta7-10        1    10009  2.1.0.9beta7-10
- 1.0.9rc2             1    10009  2.1.0.9rc2
- 1.0.9                1    10009  2.1.0.9
- 1.0.10beta1          1    10010  2.1.0.10beta1
- 1.0.10rc1            1    10010  2.1.0.10rc1
- 1.0.10               1    10010  2.1.0.10
- 1.0.11beta1-3        1    10011  2.1.0.11beta1-3
- 1.0.11rc1            1    10011  2.1.0.11rc1
- 1.0.11               1    10011  2.1.0.11
- 1.0.12beta1-2        2    10012  2.1.0.12beta1-2
- 1.0.12rc1            2    10012  2.1.0.12rc1
- 1.0.12               2    10012  2.1.0.12
- 1.1.0a-f             -    10100  2.1.1.0a-f abandoned
- 1.2.0beta1-2         2    10200  2.1.2.0beta1-2
- 1.2.0beta3-5         3    10200  3.1.2.0beta3-5
- 1.2.0rc1             3    10200  3.1.2.0rc1
- 1.2.0                3    10200  3.1.2.0
- 1.2.1beta-4          3    10201  3.1.2.1beta1-4
- 1.2.1rc1-2           3    10201  3.1.2.1rc1-2
- 1.2.1                3    10201  3.1.2.1
- 1.2.2beta1-6        12    10202  12.so.0.1.2.2beta1-6
- 1.0.13beta1         10    10013  10.so.0.1.0.13beta1
- 1.0.13rc1           10    10013  10.so.0.1.0.13rc1
- 1.2.2rc1            12    10202  12.so.0.1.2.2rc1
- 1.0.13              10    10013  10.so.0.1.0.13
- 1.2.2               12    10202  12.so.0.1.2.2
- 1.2.3rc1-6          12    10203  12.so.0.1.2.3rc1-6
- 1.2.3               12    10203  12.so.0.1.2.3
- 1.2.4beta1-3        13    10204  12.so.0.1.2.4beta1-3
- 1.2.4rc1            13    10204  12.so.0.1.2.4rc1
- 1.0.14              10    10014  10.so.0.1.0.14
- 1.2.4               13    10204  12.so.0.1.2.4
- 1.2.5beta1-2        13    10205  12.so.0.1.2.5beta1-2
- 1.0.15rc1           10    10015  10.so.0.1.0.15rc1
- 1.0.15              10    10015  10.so.0.1.0.15
- 1.2.5               13    10205  12.so.0.1.2.5
- 1.2.6beta1-4        13    10206  12.so.0.1.2.6beta1-4
- 1.2.6rc1-5          13    10206  12.so.0.1.2.6rc1-5
- 1.0.16              10    10016  10.so.0.1.0.16
- 1.2.6               13    10206  12.so.0.1.2.6
- 1.2.7beta1-2        13    10207  12.so.0.1.2.7beta1-2
- 1.0.17rc1           10    10017  12.so.0.1.0.17rc1
- 1.2.7rc1            13    10207  12.so.0.1.2.7rc1
- 1.0.17              10    10017  12.so.0.1.0.17
- 1.2.7               13    10207  12.so.0.1.2.7
- 1.2.8beta1-5        13    10208  12.so.0.1.2.8beta1-5
- 1.0.18rc1-5         10    10018  12.so.0.1.0.18rc1-5
- 1.2.8rc1-5          13    10208  12.so.0.1.2.8rc1-5
- 1.0.18              10    10018  12.so.0.1.0.18
- 1.2.8               13    10208  12.so.0.1.2.8
- 1.2.9beta1-3        13    10209  12.so.0.1.2.9beta1-3
- 1.2.9beta4-11       13    10209  12.so.0.9[.0]
- 1.2.9rc1            13    10209  12.so.0.9[.0]
- 1.2.9               13    10209  12.so.0.9[.0]
- 1.2.10beta1-7       13    10210  12.so.0.10[.0]
- 1.2.10rc1-2         13    10210  12.so.0.10[.0]
- 1.2.10              13    10210  12.so.0.10[.0]
- 1.4.0beta1-6        14    10400  14.so.0.0[.0]
- 1.2.11beta1-4       13    10210  12.so.0.11[.0]
- 1.4.0beta7-8        14    10400  14.so.0.0[.0]
- 1.2.11              13    10211  12.so.0.11[.0]
- 1.2.12              13    10212  12.so.0.12[.0]
- 1.4.0beta9-14       14    10400  14.so.0.0[.0]
- 1.2.13              13    10213  12.so.0.13[.0]
- 1.4.0beta15-36      14    10400  14.so.0.0[.0]
- 1.4.0beta37-87      14    10400  14.so.14.0[.0]
- 1.4.0rc01           14    10400  14.so.14.0[.0]
- 1.4.0beta88-109     14    10400  14.so.14.0[.0]
- 1.4.0rc02-08        14    10400  14.so.14.0[.0]
- 1.4.0               14    10400  14.so.14.0[.0]
- 1.4.1beta01-03      14    10401  14.so.14.1[.0]
- 1.4.1rc01           14    10401  14.so.14.1[.0]
- 1.4.1beta04-12      14    10401  14.so.14.1[.0]
- 1.4.1               14    10401  14.so.14.1[.0]
- 1.4.2               14    10402  14.so.14.2[.0]
- 1.4.3               14    10403  14.so.14.3[.0]
- 1.4.4               14    10404  14.so.14.4[.0]
- 1.5.0beta01-58      15    10500  15.so.15.0[.0]
- 1.5.0rc01-07        15    10500  15.so.15.0[.0]
- 1.5.0               15    10500  15.so.15.0[.0]
- 1.5.1beta01-11      15    10501  15.so.15.1[.0]
- 1.5.1rc01-02        15    10501  15.so.15.1[.0]
- 1.5.1               15    10501  15.so.15.1[.0]
-
-Henceforth the source version will match the shared-library minor
-and patch numbers; the shared-library major version number will be
-used for changes in backward compatibility, as it is intended.  The
-PNG_PNGLIB_VER macro, which is not used within libpng but is available
-for applications, is an unsigned integer of the form xyyzz corresponding
-to the source version x.y.z (leading zeros in y and z).  Beta versions
-were given the previous public release number plus a letter, until
-version 1.0.6j; from then on they were given the upcoming public
-release number plus "betaNN" or "rcN".
-
-.SH "SEE ALSO"
-.BR "png"(5), " libpngpf"(3), " zlib"(3), " deflate"(5), " " and " zlib"(5)
-
-.LP
-.IR libpng :
-.IP
-http://libpng.sourceforge.net (follow the [DOWNLOAD] link)
-http://www.libpng.org/pub/png
-
-.LP
-.IR zlib :
-.IP
-(generally) at the same location as
-.I libpng
-or at
-.br
-ftp://ftp.info-zip.org/pub/infozip/zlib
-
-.LP
-.IR PNG specification: RFC 2083
-.IP
-(generally) at the same location as
-.I libpng
-or at
-.br
-ftp://ds.internic.net/rfc/rfc2083.txt
-.br
-or (as a W3C Recommendation) at
-.br
-http://www.w3.org/TR/REC-png.html
-
-.LP
-In the case of any inconsistency between the PNG specification
-and this library, the specification takes precedence.
-
-.SH AUTHORS
-This man page: Glenn Randers-Pehrson
-<glennrp at users.sourceforge.net>
-
-The contributing authors would like to thank all those who helped
-with testing, bug fixes, and patience.  This wouldn't have been
-possible without all of you.
-
-Thanks to Frank J. T. Wojcik for helping with the documentation.
-
-Libpng version 1.5.1 - February 3, 2011:
-Initially created in 1995 by Guy Eric Schalnat, then of Group 42, Inc.
-Currently maintained by Glenn Randers-Pehrson (glennrp at users.sourceforge.net).
-
-Supported by the PNG development group
-.br
-png-mng-implement at lists.sf.net
-(subscription required; visit
-png-mng-implement at lists.sourceforge.net (subscription required; visit
-https://lists.sourceforge.net/lists/listinfo/png-mng-implement
-to subscribe).
-
-.SH COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
-
-(This copy of the libpng notices is provided for your convenience.  In case of
-any discrepancy between this copy and the notices in the file png.h that is
-included in the libpng distribution, the latter shall prevail.)
-
-If you modify libpng you may insert additional notices immediately following
-this sentence.
-
-This code is released under the libpng license.
-
-libpng versions 1.2.6, August 15, 2004, through 1.5.1, February 3, 2011, are
-Copyright (c) 2004,2006-2007 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-1.2.5
-with the following individual added to the list of Contributing Authors
-
-   Cosmin Truta
-
-libpng versions 1.0.7, July 1, 2000, through 1.2.5 - October 3, 2002, are
-Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-1.0.6
-with the following individuals added to the list of Contributing Authors
-
-   Simon-Pierre Cadieux
-   Eric S. Raymond
-   Gilles Vollant
-
-and with the following additions to the disclaimer:
-
-   There is no warranty against interference with your
-   enjoyment of the library or against infringement.
-   There is no warranty that our efforts or the library
-   will fulfill any of your particular purposes or needs.
-   This library is provided with all faults, and the entire
-   risk of satisfactory quality, performance, accuracy, and
-   effort is with the user.
-
-libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
-Copyright (c) 1998, 1999 Glenn Randers-Pehrson
-Distributed according to the same disclaimer and license as libpng-0.96,
-with the following individuals added to the list of Contributing Authors:
-
-   Tom Lane
-   Glenn Randers-Pehrson
-   Willem van Schaik
-
-libpng versions 0.89, June 1996, through 0.96, May 1997, are
-Copyright (c) 1996, 1997 Andreas Dilger
-Distributed according to the same disclaimer and license as libpng-0.88,
-with the following individuals added to the list of Contributing Authors:
-
-   John Bowler
-   Kevin Bracey
-   Sam Bushell
-   Magnus Holmgren
-   Greg Roelofs
-   Tom Tanner
-
-libpng versions 0.5, May 1995, through 0.88, January 1996, are
-Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
-
-For the purposes of this copyright and license, "Contributing Authors"
-is defined as the following set of individuals:
-
-   Andreas Dilger
-   Dave Martindale
-   Guy Eric Schalnat
-   Paul Schmidt
-   Tim Wegner
-
-The PNG Reference Library is supplied "AS IS".  The Contributing Authors
-and Group 42, Inc. disclaim all warranties, expressed or implied,
-including, without limitation, the warranties of merchantability and of
-fitness for any purpose.  The Contributing Authors and Group 42, Inc.
-assume no liability for direct, indirect, incidental, special, exemplary,
-or consequential damages, which may result from the use of the PNG
-Reference Library, even if advised of the possibility of such damage.
-
-Permission is hereby granted to use, copy, modify, and distribute this
-source code, or portions hereof, for any purpose, without fee, subject
-to the following restrictions:
-
-1. The origin of this source code must not be misrepresented.
-
-2. Altered versions must be plainly marked as such and
-   must not be misrepresented as being the original source.
-
-3. This Copyright notice may not be removed or altered from
-   any source or altered source distribution.
-
-The Contributing Authors and Group 42, Inc. specifically permit, without
-fee, and encourage the use of this source code as a component to
-supporting the PNG file format in commercial products.  If you use this
-source code in a product, acknowledgment is not required but would be
-appreciated.
-
-
-A "png_get_copyright" function is available, for convenient use in "about"
-boxes and the like:
-
-   printf("%s",png_get_copyright(NULL));
-
-Also, the PNG logo (in PNG format, of course) is supplied in the
-files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
-
-Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is a
-certification mark of the Open Source Initiative.
-
-Glenn Randers-Pehrson
-glennrp at users.sourceforge.net
-February 3, 2011
-
-.\" end of man page
-
diff --git a/src/3rdparty/libpng/libpng.pc.in b/src/3rdparty/libpng/libpng.pc.in
deleted file mode 100644
index 3e7e2c5..0000000
--- a/src/3rdparty/libpng/libpng.pc.in
+++ /dev/null
@@ -1,11 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@/libpng@PNGLIB_MAJOR@@PNGLIB_MINOR@
-
-Name: libpng
-Description: Loads and saves PNG files
-Version: @PNGLIB_VERSION@
-Libs: -L${libdir} -lpng@PNGLIB_MAJOR@@PNGLIB_MINOR@
-Libs.private: @LIBS@
-Cflags: -I${includedir}
diff --git a/src/3rdparty/libpng/libpngpf.3 b/src/3rdparty/libpng/libpngpf.3
deleted file mode 100644
index ff6e164..0000000
--- a/src/3rdparty/libpng/libpngpf.3
+++ /dev/null
@@ -1,30 +0,0 @@
-.TH LIBPNGPF 3 "February 3, 2011"
-.SH NAME
-libpng \- Portable Network Graphics (PNG) Reference Library 1.5.1
-(private functions)
-.SH SYNOPSIS
-\fB#include \fI"pngpriv.h"
-
-\fI\fB
-
-\fBAs of libpng version \fP\fI1.5.1\fP\fB, this section is no longer \fP\fImaintained\fP\fB, now \fIthat
-
-\fBthe private function prototypes are hidden in pngpriv.h and not \fIaccessible
-
-\fBto applications. Look in pngpriv.h for the prototypes and a short \fIdescription
-
-\fBof each \fIfunction.
-
-\fI\fB
-
-.SH DESCRIPTION
-The functions previously listed here are  used privately by libpng
-and are not recommended for use by applications.  They are
-not "exported" to applications using shared libraries.  They
-are listed alphabetically here as an aid to libpng maintainers.
-See pngpriv.h for more information on these functions.
-
-.SH SEE ALSO
-.BR "png"(5), " libpng"(3), " zlib"(3), " deflate"(5), " " and " zlib"(5)
-.SH AUTHOR
-Glenn Randers-Pehrson
diff --git a/src/3rdparty/libpng/png.5 b/src/3rdparty/libpng/png.5
deleted file mode 100644
index 9c5f8d3..0000000
--- a/src/3rdparty/libpng/png.5
+++ /dev/null
@@ -1,74 +0,0 @@
-.TH PNG 5 "February 3, 2011"
-.SH NAME
-png \- Portable Network Graphics (PNG) format
-.SH DESCRIPTION
-PNG (Portable Network Graphics) is an extensible file format for the
-lossless, portable, well-compressed storage of raster images. PNG provides
-a patent-free replacement for GIF and can also replace many
-common uses of TIFF. Indexed-color, grayscale, and truecolor images are
-supported, plus an optional alpha channel. Sample depths range from
-1 to 16 bits.
-.br
-
-PNG is designed to work well in online viewing applications, such as the
-World Wide Web, so it is fully streamable with a progressive display
-option. PNG is robust, providing both full file integrity checking and
-fast, simple detection of common transmission errors. Also, PNG can store
-gamma and chromaticity data for improved color matching on heterogeneous
-platforms.
-
-.SH "SEE ALSO"
-.BR "libpng"(3), " libpngpf"(3), " zlib"(3), " deflate"(5), " " and " zlib"(5)
-.LP
-PNG specification (second edition), November 2003:
-.IP
-.br
-  <http://www.w3.org/TR/2003/REC-PNG-20031110/
-PNG 1.2 specification, July 1999:
-.IP
-.br
-http://www.libpng.org/pub/png
-.LP
-PNG 1.0 specification, October 1996:
-.IP
-.br
-RFC 2083
-.IP
-.br
-ftp://ds.internic.net/rfc/rfc2083.txt
-.br
-or (as a W3C Recommendation) at
-.br
-http://www.w3.org/TR/REC-png.html
-.SH AUTHORS
-This man page: Glenn Randers-Pehrson
-.LP
-Portable Network Graphics (PNG) Specification (Second Edition)
-Information technology - Computer graphics and image processing -
-Portable Network Graphics (PNG): Functional specification.
-ISO/IEC 15948:2003 (E) (November 10, 2003): David Duce and others.
-.LP
-Portable Network Graphics (PNG) Specification Version 1.2 (July 8, 1999):
-Glenn Randers-Pehrson and others (png-list).
-.LP
-Portable Network Graphics (PNG) Specification Version 1.0 (October 1, 1996):
-Thomas Boutell and others (png-list).
-.LP
-
-
-.SH COPYRIGHT NOTICE
-.LP
-This man page is Copyright (c) 1998-2006 Glenn Randers-Pehrson.  See png.h
-for conditions of use and distribution.
-.LP
-The PNG Specification (Second Edition) is
-Copyright (c) 2003 W3C. (MIT, ERCIM, Keio), All Rights Reserved.
-.LP
-The PNG-1.2 specification is copyright (c) 1999 Glenn Randers-Pehrson.
-See the specification for conditions of use and distribution.
-.LP
-The PNG-1.0 specification is copyright (c) 1996 Massachusetts Institute of
-Technology.  See the specification for conditions of use and distribution.
-.LP
-.\" end of man page
-
diff --git a/src/3rdparty/libpng/png.c b/src/3rdparty/libpng/png.c
index 764f47c..cba18ba 100644
--- a/src/3rdparty/libpng/png.c
+++ b/src/3rdparty/libpng/png.c
@@ -1,8 +1,8 @@
 
 /* png.c - location for general purpose libpng functions
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -14,7 +14,7 @@
 #include "pngpriv.h"
 
 /* Generate a compiler error if there is an old png.h in the search path. */
-typedef png_libpng_version_1_5_1 Your_png_h_is_not_version_1_5_1;
+typedef png_libpng_version_1_5_10 Your_png_h_is_not_version_1_5_10;
 
 /* Tells libpng that we have already handled the first "num_bytes" bytes
  * of the PNG file signature.  If the PNG data is embedded into another
@@ -43,7 +43,7 @@ png_set_sig_bytes(png_structp png_ptr, int num_bytes)
  * can simply check the remaining bytes for extra assurance.  Returns
  * an integer less than, equal to, or greater than zero if sig is found,
  * respectively, to be less than, to match, or be greater than the correct
- * PNG signature (this is the same behaviour as strcmp, memcmp, etc).
+ * PNG signature (this is the same behavior as strcmp, memcmp, etc).
  */
 int PNGAPI
 png_sig_cmp(png_const_bytep sig, png_size_t start, png_size_t num_to_check)
@@ -107,7 +107,8 @@ png_zfree(voidpf png_ptr, voidpf ptr)
 void /* PRIVATE */
 png_reset_crc(png_structp png_ptr)
 {
-   png_ptr->crc = crc32(0, Z_NULL, 0);
+   /* The cast is safe because the crc is a 32 bit value. */
+   png_ptr->crc = (png_uint_32)crc32(0, Z_NULL, 0);
 }
 
 /* Calculate the CRC over a section of data.  We can only pass as
@@ -120,21 +121,103 @@ png_calculate_crc(png_structp png_ptr, png_const_bytep ptr, png_size_t length)
 {
    int need_crc = 1;
 
-   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
+   if (PNG_CHUNK_ANCILLIARY(png_ptr->chunk_name))
    {
       if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
           (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
          need_crc = 0;
    }
 
-   else                                                    /* critical */
+   else /* critical */
    {
       if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
          need_crc = 0;
    }
 
-   if (need_crc)
-      png_ptr->crc = crc32(png_ptr->crc, ptr, (uInt)length);
+   /* 'uLong' is defined as unsigned long, this means that on some systems it is
+    * a 64 bit value.  crc32, however, returns 32 bits so the following cast is
+    * safe.  'uInt' may be no more than 16 bits, so it is necessary to perform a
+    * loop here.
+    */
+   if (need_crc && length > 0)
+   {
+      uLong crc = png_ptr->crc; /* Should never issue a warning */
+
+      do
+      {
+         uInt safeLength = (uInt)length;
+         if (safeLength == 0)
+            safeLength = (uInt)-1; /* evil, but safe */
+
+         crc = crc32(crc, ptr, safeLength);
+
+         /* The following should never issue compiler warnings, if they do the
+          * target system has characteristics that will probably violate other
+          * assumptions within the libpng code.
+          */
+         ptr += safeLength;
+         length -= safeLength;
+      }
+      while (length > 0);
+
+      /* And the following is always safe because the crc is only 32 bits. */
+      png_ptr->crc = (png_uint_32)crc;
+   }
+}
+
+/* Check a user supplied version number, called from both read and write
+ * functions that create a png_struct
+ */
+int
+png_user_version_check(png_structp png_ptr, png_const_charp user_png_ver)
+{
+   if (user_png_ver)
+   {
+      int i = 0;
+
+      do
+      {
+         if (user_png_ver[i] != png_libpng_ver[i])
+            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+      } while (png_libpng_ver[i++]);
+   }
+
+   else
+      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+
+   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
+   {
+     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
+      * we must recompile any applications that use any older library version.
+      * For versions after libpng 1.0, we will be compatible, so we need
+      * only check the first digit.
+      */
+      if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
+          (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
+          (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
+      {
+#ifdef PNG_WARNINGS_SUPPORTED
+         size_t pos = 0;
+         char m[128];
+
+         pos = png_safecat(m, sizeof m, pos, "Application built with libpng-");
+         pos = png_safecat(m, sizeof m, pos, user_png_ver);
+         pos = png_safecat(m, sizeof m, pos, " but running with ");
+         pos = png_safecat(m, sizeof m, pos, png_libpng_ver);
+
+         png_warning(png_ptr, m);
+#endif
+
+#ifdef PNG_ERROR_NUMBERS_SUPPORTED
+         png_ptr->flags = 0;
+#endif
+
+         return 0;
+      }
+   }
+
+   /* Success return. */
+   return 1;
 }
 
 /* Allocate the memory for an info_struct for the application.  We don't
@@ -291,12 +374,10 @@ png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,
    /* Free any sCAL entry */
    if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
    {
-#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
       png_free(png_ptr, info_ptr->scal_s_width);
       png_free(png_ptr, info_ptr->scal_s_height);
       info_ptr->scal_s_width = NULL;
       info_ptr->scal_s_height = NULL;
-#endif
       info_ptr->valid &= ~PNG_INFO_sCAL;
    }
 #endif
@@ -489,8 +570,8 @@ png_get_io_ptr(png_structp png_ptr)
 /* Initialize the default input/output functions for the PNG file.  If you
  * use your own read or write routines, you can call either png_set_read_fn()
  * or png_set_write_fn() instead of png_init_io().  If you have defined
- * PNG_NO_STDIO, you must use a function of your own because "FILE *" isn't
- * necessarily available.
+ * PNG_NO_STDIO or otherwise disabled PNG_STDIO_SUPPORTED, you must use a
+ * function of your own because "FILE *" isn't necessarily available.
  */
 void PNGAPI
 png_init_io(png_structp png_ptr, png_FILE_p fp)
@@ -518,28 +599,47 @@ png_convert_to_rfc1123(png_structp png_ptr, png_const_timep ptime)
    if (png_ptr == NULL)
       return (NULL);
 
-   if (png_ptr->time_buffer == NULL)
+   if (ptime->year > 9999 /* RFC1123 limitation */ ||
+       ptime->month == 0    ||  ptime->month > 12  ||
+       ptime->day   == 0    ||  ptime->day   > 31  ||
+       ptime->hour  > 23    ||  ptime->minute > 59 ||
+       ptime->second > 60)
    {
-      png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
-         png_sizeof(char)));
+      png_warning(png_ptr, "Ignoring invalid time value");
+      return (NULL);
    }
 
-#    ifdef USE_FAR_KEYWORD
    {
-      char near_time_buf[29];
-      png_snprintf6(near_time_buf, 29, "%d %s %d %02d:%02d:%02d +0000",
-          ptime->day % 32, short_months[(ptime->month - 1) % 12],
-          ptime->year, ptime->hour % 24, ptime->minute % 60,
-          ptime->second % 61);
-      png_memcpy(png_ptr->time_buffer, near_time_buf,
-          29*png_sizeof(char));
+      size_t pos = 0;
+      char number_buf[5]; /* enough for a four-digit year */
+
+#     define APPEND_STRING(string)\
+         pos = png_safecat(png_ptr->time_buffer, sizeof png_ptr->time_buffer,\
+            pos, (string))
+#     define APPEND_NUMBER(format, value)\
+         APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))
+#     define APPEND(ch)\
+         if (pos < (sizeof png_ptr->time_buffer)-1)\
+            png_ptr->time_buffer[pos++] = (ch)
+
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, (unsigned)ptime->day);
+      APPEND(' ');
+      APPEND_STRING(short_months[(ptime->month - 1)]);
+      APPEND(' ');
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, ptime->year);
+      APPEND(' ');
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->hour);
+      APPEND(':');
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->minute);
+      APPEND(':');
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->second);
+      APPEND_STRING(" +0000"); /* This reliably terminates the buffer */
+
+#     undef APPEND
+#     undef APPEND_NUMBER
+#     undef APPEND_STRING
    }
-#    else
-   png_snprintf6(png_ptr->time_buffer, 29, "%d %s %d %02d:%02d:%02d +0000",
-       ptime->day % 32, short_months[(ptime->month - 1) % 12],
-       ptime->year, ptime->hour % 24, ptime->minute % 60,
-       ptime->second % 61);
-#    endif
+
    return png_ptr->time_buffer;
 }
 #  endif /* PNG_TIME_RFC1123_SUPPORTED */
@@ -555,13 +655,13 @@ png_get_copyright(png_const_structp png_ptr)
 #else
 #  ifdef __STDC__
    return PNG_STRING_NEWLINE \
-     "libpng version 1.5.1 - February 3, 2011" PNG_STRING_NEWLINE \
+     "libpng version 1.5.10 - March 29, 2012" PNG_STRING_NEWLINE \
      "Copyright (c) 1998-2011 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
      "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
      "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
      PNG_STRING_NEWLINE;
 #  else
-      return "libpng version 1.5.1 - February 3, 2011\
+      return "libpng version 1.5.10 - March 29, 2012\
       Copyright (c) 1998-2011 Glenn Randers-Pehrson\
       Copyright (c) 1996-1997 Andreas Dilger\
       Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.";
@@ -608,25 +708,43 @@ png_get_header_version(png_const_structp png_ptr)
 #endif
 }
 
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#  ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
 int PNGAPI
 png_handle_as_unknown(png_structp png_ptr, png_const_bytep chunk_name)
 {
    /* Check chunk_name and return "keep" value if it's on the list, else 0 */
-   int i;
-   png_bytep p;
-   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)
-      return 0;
+   png_const_bytep p, p_end;
+
+   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list <= 0)
+      return PNG_HANDLE_CHUNK_AS_DEFAULT;
 
-   p = png_ptr->chunk_list + png_ptr->num_chunk_list*5 - 5;
-   for (i = png_ptr->num_chunk_list; i; i--, p -= 5)
+   p_end = png_ptr->chunk_list;
+   p = p_end + png_ptr->num_chunk_list*5; /* beyond end */
+
+   /* The code is the fifth byte after each four byte string.  Historically this
+    * code was always searched from the end of the list, so it should continue
+    * to do so in case there are duplicated entries.
+    */
+   do /* num_chunk_list > 0, so at least one */
+   {
+      p -= 5;
       if (!png_memcmp(chunk_name, p, 4))
-        return ((int)*(p + 4));
-   return 0;
+         return p[4];
+   }
+   while (p > p_end);
+
+   return PNG_HANDLE_CHUNK_AS_DEFAULT;
 }
-#  endif
-#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
+
+int /* PRIVATE */
+png_chunk_unknown_handling(png_structp png_ptr, png_uint_32 chunk_name)
+{
+   png_byte chunk_string[5];
+
+   PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);
+   return png_handle_as_unknown(png_ptr, chunk_string);
+}
+#endif
 
 #ifdef PNG_READ_SUPPORTED
 /* This function, added to libpng-1.0.6g, is untested. */
@@ -651,18 +769,9 @@ png_access_version_number(void)
 
 
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#  ifdef PNG_SIZE_T
-/* Added at libpng version 1.2.6 */
-   PNG_EXTERN png_size_t PNGAPI png_convert_size PNGARG((size_t size));
-png_size_t PNGAPI
-png_convert_size(size_t size)
-{
-   if (size > (png_size_t)-1)
-      PNG_ABORT();  /* We haven't got access to png_ptr, so no png_error() */
-
-   return ((png_size_t)size);
-}
-#  endif /* PNG_SIZE_T */
+/* png_convert_size: a PNGAPI but no longer in png.h, so deleted
+ * at libpng 1.5.5!
+ */
 
 /* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
 #  ifdef PNG_CHECK_cHRM_SUPPORTED
@@ -681,6 +790,13 @@ png_check_cHRM_fixed(png_structp png_ptr,
    if (png_ptr == NULL)
       return 0;
 
+   /* (x,y,z) values are first limited to 0..100000 (PNG_FP_1), the white
+    * y must also be greater than 0.  To test for the upper limit calculate
+    * (PNG_FP_1-y) - x must be <= to this for z to be >= 0 (and the expression
+    * cannot overflow.)  At this point we know x and y are >= 0 and (x+y) is
+    * <= PNG_FP_1.  The previous test on PNG_MAX_UINT_31 is removed because it
+    * pointless (and it produces compiler warnings!)
+    */
    if (white_x < 0 || white_y <= 0 ||
          red_x < 0 ||   red_y <  0 ||
        green_x < 0 || green_y <  0 ||
@@ -690,38 +806,26 @@ png_check_cHRM_fixed(png_structp png_ptr,
         "Ignoring attempt to set negative chromaticity value");
       ret = 0;
    }
-   if (white_x > (png_fixed_point)PNG_UINT_31_MAX ||
-       white_y > (png_fixed_point)PNG_UINT_31_MAX ||
-         red_x > (png_fixed_point)PNG_UINT_31_MAX ||
-         red_y > (png_fixed_point)PNG_UINT_31_MAX ||
-       green_x > (png_fixed_point)PNG_UINT_31_MAX ||
-       green_y > (png_fixed_point)PNG_UINT_31_MAX ||
-        blue_x > (png_fixed_point)PNG_UINT_31_MAX ||
-        blue_y > (png_fixed_point)PNG_UINT_31_MAX )
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set chromaticity value exceeding 21474.83");
-      ret = 0;
-   }
-   if (white_x > 100000L - white_y)
+   /* And (x+y) must be <= PNG_FP_1 (so z is >= 0) */
+   if (white_x > PNG_FP_1 - white_y)
    {
       png_warning(png_ptr, "Invalid cHRM white point");
       ret = 0;
    }
 
-   if (red_x > 100000L - red_y)
+   if (red_x > PNG_FP_1 - red_y)
    {
       png_warning(png_ptr, "Invalid cHRM red point");
       ret = 0;
    }
 
-   if (green_x > 100000L - green_y)
+   if (green_x > PNG_FP_1 - green_y)
    {
       png_warning(png_ptr, "Invalid cHRM green point");
       ret = 0;
    }
 
-   if (blue_x > 100000L - blue_y)
+   if (blue_x > PNG_FP_1 - blue_y)
    {
       png_warning(png_ptr, "Invalid cHRM blue point");
       ret = 0;
@@ -741,6 +845,326 @@ png_check_cHRM_fixed(png_structp png_ptr,
 }
 #  endif /* PNG_CHECK_cHRM_SUPPORTED */
 
+#ifdef PNG_cHRM_SUPPORTED
+/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for
+ * cHRM, as opposed to using chromaticities.  These internal APIs return
+ * non-zero on a parameter error.  The X, Y and Z values are required to be
+ * positive and less than 1.0.
+ */
+int png_xy_from_XYZ(png_xy *xy, png_XYZ XYZ)
+{
+   png_int_32 d, dwhite, whiteX, whiteY;
+
+   d = XYZ.redX + XYZ.redY + XYZ.redZ;
+   if (!png_muldiv(&xy->redx, XYZ.redX, PNG_FP_1, d)) return 1;
+   if (!png_muldiv(&xy->redy, XYZ.redY, PNG_FP_1, d)) return 1;
+   dwhite = d;
+   whiteX = XYZ.redX;
+   whiteY = XYZ.redY;
+
+   d = XYZ.greenX + XYZ.greenY + XYZ.greenZ;
+   if (!png_muldiv(&xy->greenx, XYZ.greenX, PNG_FP_1, d)) return 1;
+   if (!png_muldiv(&xy->greeny, XYZ.greenY, PNG_FP_1, d)) return 1;
+   dwhite += d;
+   whiteX += XYZ.greenX;
+   whiteY += XYZ.greenY;
+
+   d = XYZ.blueX + XYZ.blueY + XYZ.blueZ;
+   if (!png_muldiv(&xy->bluex, XYZ.blueX, PNG_FP_1, d)) return 1;
+   if (!png_muldiv(&xy->bluey, XYZ.blueY, PNG_FP_1, d)) return 1;
+   dwhite += d;
+   whiteX += XYZ.blueX;
+   whiteY += XYZ.blueY;
+
+   /* The reference white is simply the same of the end-point (X,Y,Z) vectors,
+    * thus:
+    */
+   if (!png_muldiv(&xy->whitex, whiteX, PNG_FP_1, dwhite)) return 1;
+   if (!png_muldiv(&xy->whitey, whiteY, PNG_FP_1, dwhite)) return 1;
+
+   return 0;
+}
+
+int png_XYZ_from_xy(png_XYZ *XYZ, png_xy xy)
+{
+   png_fixed_point red_inverse, green_inverse, blue_scale;
+   png_fixed_point left, right, denominator;
+
+   /* Check xy and, implicitly, z.  Note that wide gamut color spaces typically
+    * have end points with 0 tristimulus values (these are impossible end
+    * points, but they are used to cover the possible colors.)
+    */
+   if (xy.redx < 0 || xy.redx > PNG_FP_1) return 1;
+   if (xy.redy < 0 || xy.redy > PNG_FP_1-xy.redx) return 1;
+   if (xy.greenx < 0 || xy.greenx > PNG_FP_1) return 1;
+   if (xy.greeny < 0 || xy.greeny > PNG_FP_1-xy.greenx) return 1;
+   if (xy.bluex < 0 || xy.bluex > PNG_FP_1) return 1;
+   if (xy.bluey < 0 || xy.bluey > PNG_FP_1-xy.bluex) return 1;
+   if (xy.whitex < 0 || xy.whitex > PNG_FP_1) return 1;
+   if (xy.whitey < 0 || xy.whitey > PNG_FP_1-xy.whitex) return 1;
+
+   /* The reverse calculation is more difficult because the original tristimulus
+    * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8
+    * derived values were recorded in the cHRM chunk;
+    * (red,green,blue,white)x(x,y).  This loses one degree of freedom and
+    * therefore an arbitrary ninth value has to be introduced to undo the
+    * original transformations.
+    *
+    * Think of the original end-points as points in (X,Y,Z) space.  The
+    * chromaticity values (c) have the property:
+    *
+    *           C
+    *   c = ---------
+    *       X + Y + Z
+    *
+    * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the
+    * three chromaticity values (x,y,z) for each end-point obey the
+    * relationship:
+    *
+    *   x + y + z = 1
+    *
+    * This describes the plane in (X,Y,Z) space that intersects each axis at the
+    * value 1.0; call this the chromaticity plane.  Thus the chromaticity
+    * calculation has scaled each end-point so that it is on the x+y+z=1 plane
+    * and chromaticity is the intersection of the vector from the origin to the
+    * (X,Y,Z) value with the chromaticity plane.
+    *
+    * To fully invert the chromaticity calculation we would need the three
+    * end-point scale factors, (red-scale, green-scale, blue-scale), but these
+    * were not recorded.  Instead we calculated the reference white (X,Y,Z) and
+    * recorded the chromaticity of this.  The reference white (X,Y,Z) would have
+    * given all three of the scale factors since:
+    *
+    *    color-C = color-c * color-scale
+    *    white-C = red-C + green-C + blue-C
+    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale
+    *
+    * But cHRM records only white-x and white-y, so we have lost the white scale
+    * factor:
+    *
+    *    white-C = white-c*white-scale
+    *
+    * To handle this the inverse transformation makes an arbitrary assumption
+    * about white-scale:
+    *
+    *    Assume: white-Y = 1.0
+    *    Hence:  white-scale = 1/white-y
+    *    Or:     red-Y + green-Y + blue-Y = 1.0
+    *
+    * Notice the last statement of the assumption gives an equation in three of
+    * the nine values we want to calculate.  8 more equations come from the
+    * above routine as summarised at the top above (the chromaticity
+    * calculation):
+    *
+    *    Given: color-x = color-X / (color-X + color-Y + color-Z)
+    *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0
+    *
+    * This is 9 simultaneous equations in the 9 variables "color-C" and can be
+    * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix
+    * determinants, however this is not as bad as it seems because only 28 of
+    * the total of 90 terms in the various matrices are non-zero.  Nevertheless
+    * Cramer's rule is notoriously numerically unstable because the determinant
+    * calculation involves the difference of large, but similar, numbers.  It is
+    * difficult to be sure that the calculation is stable for real world values
+    * and it is certain that it becomes unstable where the end points are close
+    * together.
+    *
+    * So this code uses the perhaps slighly less optimal but more understandable
+    * and totally obvious approach of calculating color-scale.
+    *
+    * This algorithm depends on the precision in white-scale and that is
+    * (1/white-y), so we can immediately see that as white-y approaches 0 the
+    * accuracy inherent in the cHRM chunk drops off substantially.
+    *
+    * libpng arithmetic: a simple invertion of the above equations
+    * ------------------------------------------------------------
+    *
+    *    white_scale = 1/white-y
+    *    white-X = white-x * white-scale
+    *    white-Y = 1.0
+    *    white-Z = (1 - white-x - white-y) * white_scale
+    *
+    *    white-C = red-C + green-C + blue-C
+    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale
+    *
+    * This gives us three equations in (red-scale,green-scale,blue-scale) where
+    * all the coefficients are now known:
+    *
+    *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale
+    *       = white-x/white-y
+    *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1
+    *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale
+    *       = (1 - white-x - white-y)/white-y
+    *
+    * In the last equation color-z is (1 - color-x - color-y) so we can add all
+    * three equations together to get an alternative third:
+    *
+    *    red-scale + green-scale + blue-scale = 1/white-y = white-scale
+    *
+    * So now we have a Cramer's rule solution where the determinants are just
+    * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve
+    * multiplication of three coefficients so we can't guarantee to avoid
+    * overflow in the libpng fixed point representation.  Using Cramer's rule in
+    * floating point is probably a good choice here, but it's not an option for
+    * fixed point.  Instead proceed to simplify the first two equations by
+    * eliminating what is likely to be the largest value, blue-scale:
+    *
+    *    blue-scale = white-scale - red-scale - green-scale
+    *
+    * Hence:
+    *
+    *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =
+    *                (white-x - blue-x)*white-scale
+    *
+    *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =
+    *                1 - blue-y*white-scale
+    *
+    * And now we can trivially solve for (red-scale,green-scale):
+    *
+    *    green-scale =
+    *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale
+    *                -----------------------------------------------------------
+    *                                  green-x - blue-x
+    *
+    *    red-scale =
+    *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale
+    *                ---------------------------------------------------------
+    *                                  red-y - blue-y
+    *
+    * Hence:
+    *
+    *    red-scale =
+    *          ( (green-x - blue-x) * (white-y - blue-y) -
+    *            (green-y - blue-y) * (white-x - blue-x) ) / white-y
+    * -------------------------------------------------------------------------
+    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
+    *
+    *    green-scale =
+    *          ( (red-y - blue-y) * (white-x - blue-x) -
+    *            (red-x - blue-x) * (white-y - blue-y) ) / white-y
+    * -------------------------------------------------------------------------
+    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
+    *
+    * Accuracy:
+    * The input values have 5 decimal digits of accuracy.  The values are all in
+    * the range 0 < value < 1, so simple products are in the same range but may
+    * need up to 10 decimal digits to preserve the original precision and avoid
+    * underflow.  Because we are using a 32-bit signed representation we cannot
+    * match this; the best is a little over 9 decimal digits, less than 10.
+    *
+    * The approach used here is to preserve the maximum precision within the
+    * signed representation.  Because the red-scale calculation above uses the
+    * difference between two products of values that must be in the range -1..+1
+    * it is sufficient to divide the product by 7; ceil(100,000/32767*2).  The
+    * factor is irrelevant in the calculation because it is applied to both
+    * numerator and denominator.
+    *
+    * Note that the values of the differences of the products of the
+    * chromaticities in the above equations tend to be small, for example for
+    * the sRGB chromaticities they are:
+    *
+    * red numerator:    -0.04751
+    * green numerator:  -0.08788
+    * denominator:      -0.2241 (without white-y multiplication)
+    *
+    *  The resultant Y coefficients from the chromaticities of some widely used
+    *  color space definitions are (to 15 decimal places):
+    *
+    *  sRGB
+    *    0.212639005871510 0.715168678767756 0.072192315360734
+    *  Kodak ProPhoto
+    *    0.288071128229293 0.711843217810102 0.000085653960605
+    *  Adobe RGB
+    *    0.297344975250536 0.627363566255466 0.075291458493998
+    *  Adobe Wide Gamut RGB
+    *    0.258728243040113 0.724682314948566 0.016589442011321
+    */
+   /* By the argument, above overflow should be impossible here. The return
+    * value of 2 indicates an internal error to the caller.
+    */
+   if (!png_muldiv(&left, xy.greenx-xy.bluex, xy.redy - xy.bluey, 7)) return 2;
+   if (!png_muldiv(&right, xy.greeny-xy.bluey, xy.redx - xy.bluex, 7)) return 2;
+   denominator = left - right;
+
+   /* Now find the red numerator. */
+   if (!png_muldiv(&left, xy.greenx-xy.bluex, xy.whitey-xy.bluey, 7)) return 2;
+   if (!png_muldiv(&right, xy.greeny-xy.bluey, xy.whitex-xy.bluex, 7)) return 2;
+
+   /* Overflow is possible here and it indicates an extreme set of PNG cHRM
+    * chunk values.  This calculation actually returns the reciprocal of the
+    * scale value because this allows us to delay the multiplication of white-y
+    * into the denominator, which tends to produce a small number.
+    */
+   if (!png_muldiv(&red_inverse, xy.whitey, denominator, left-right) ||
+       red_inverse <= xy.whitey /* r+g+b scales = white scale */)
+      return 1;
+
+   /* Similarly for green_inverse: */
+   if (!png_muldiv(&left, xy.redy-xy.bluey, xy.whitex-xy.bluex, 7)) return 2;
+   if (!png_muldiv(&right, xy.redx-xy.bluex, xy.whitey-xy.bluey, 7)) return 2;
+   if (!png_muldiv(&green_inverse, xy.whitey, denominator, left-right) ||
+       green_inverse <= xy.whitey)
+      return 1;
+
+   /* And the blue scale, the checks above guarantee this can't overflow but it
+    * can still produce 0 for extreme cHRM values.
+    */
+   blue_scale = png_reciprocal(xy.whitey) - png_reciprocal(red_inverse) -
+      png_reciprocal(green_inverse);
+   if (blue_scale <= 0) return 1;
+
+
+   /* And fill in the png_XYZ: */
+   if (!png_muldiv(&XYZ->redX, xy.redx, PNG_FP_1, red_inverse)) return 1;
+   if (!png_muldiv(&XYZ->redY, xy.redy, PNG_FP_1, red_inverse)) return 1;
+   if (!png_muldiv(&XYZ->redZ, PNG_FP_1 - xy.redx - xy.redy, PNG_FP_1,
+      red_inverse))
+      return 1;
+
+   if (!png_muldiv(&XYZ->greenX, xy.greenx, PNG_FP_1, green_inverse)) return 1;
+   if (!png_muldiv(&XYZ->greenY, xy.greeny, PNG_FP_1, green_inverse)) return 1;
+   if (!png_muldiv(&XYZ->greenZ, PNG_FP_1 - xy.greenx - xy.greeny, PNG_FP_1,
+      green_inverse))
+      return 1;
+
+   if (!png_muldiv(&XYZ->blueX, xy.bluex, blue_scale, PNG_FP_1)) return 1;
+   if (!png_muldiv(&XYZ->blueY, xy.bluey, blue_scale, PNG_FP_1)) return 1;
+   if (!png_muldiv(&XYZ->blueZ, PNG_FP_1 - xy.bluex - xy.bluey, blue_scale,
+      PNG_FP_1))
+      return 1;
+
+   return 0; /*success*/
+}
+
+int png_XYZ_from_xy_checked(png_structp png_ptr, png_XYZ *XYZ, png_xy xy)
+{
+   switch (png_XYZ_from_xy(XYZ, xy))
+   {
+      case 0: /* success */
+         return 1;
+
+      case 1:
+         /* The chunk may be technically valid, but we got png_fixed_point
+          * overflow while trying to get XYZ values out of it.  This is
+          * entirely benign - the cHRM chunk is pretty extreme.
+          */
+         png_warning(png_ptr,
+            "extreme cHRM chunk cannot be converted to tristimulus values");
+         break;
+
+      default:
+         /* libpng is broken; this should be a warning but if it happens we
+          * want error reports so for the moment it is an error.
+          */
+         png_error(png_ptr, "internal error in png_XYZ_from_xy");
+         break;
+   }
+
+   /* ERROR RETURN */
+   return 0;
+}
+#endif
+
 void /* PRIVATE */
 png_check_IHDR(png_structp png_ptr,
    png_uint_32 width, png_uint_32 height, int bit_depth,
@@ -763,7 +1187,7 @@ png_check_IHDR(png_structp png_ptr,
    }
 
 #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   if (width > png_ptr->user_width_max || width > PNG_USER_WIDTH_MAX)
+   if (width > png_ptr->user_width_max)
 
 #  else
    if (width > PNG_USER_WIDTH_MAX)
@@ -774,7 +1198,7 @@ png_check_IHDR(png_structp png_ptr,
    }
 
 #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   if (height > png_ptr->user_height_max || height > PNG_USER_HEIGHT_MAX)
+   if (height > png_ptr->user_height_max)
 #  else
    if (height > PNG_USER_HEIGHT_MAX)
 #  endif
@@ -889,16 +1313,9 @@ png_check_IHDR(png_structp png_ptr,
 /* Check an ASCII formated floating point value, see the more detailed
  * comments in pngpriv.h
  */
-/* The following is used internally to preserve the 'valid' flag */
+/* The following is used internally to preserve the sticky flags */
 #define png_fp_add(state, flags) ((state) |= (flags))
-#define png_fp_set(state, value)\
-   ((state) = (value) | ((state) & PNG_FP_WAS_VALID))
-
-/* Internal type codes: bits above the base state! */
-#define PNG_FP_SIGN   0  /* [+-] */
-#define PNG_FP_DOT    4  /* . */
-#define PNG_FP_DIGIT  8  /* [0123456789] */
-#define PNG_FP_E     12  /* [Ee] */
+#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))
 
 int /* PRIVATE */
 png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
@@ -911,55 +1328,55 @@ png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
    {
       int type;
       /* First find the type of the next character */
+      switch (string[i])
       {
-         char ch = string[i];
-
-         if (ch >= 48 && ch <= 57)
-            type = PNG_FP_DIGIT;
-
-         else switch (ch)
-         {
-         case 43: case 45:  type = PNG_FP_SIGN;  break;
-         case 46:           type = PNG_FP_DOT;   break;
-         case 69: case 101: type = PNG_FP_E;     break;
-         default:           goto PNG_FP_End;
-         }
+      case 43:  type = PNG_FP_SAW_SIGN;                   break;
+      case 45:  type = PNG_FP_SAW_SIGN + PNG_FP_NEGATIVE; break;
+      case 46:  type = PNG_FP_SAW_DOT;                    break;
+      case 48:  type = PNG_FP_SAW_DIGIT;                  break;
+      case 49: case 50: case 51: case 52:
+      case 53: case 54: case 55: case 56:
+      case 57:  type = PNG_FP_SAW_DIGIT + PNG_FP_NONZERO; break;
+      case 69:
+      case 101: type = PNG_FP_SAW_E;                      break;
+      default:  goto PNG_FP_End;
       }
 
       /* Now deal with this type according to the current
        * state, the type is arranged to not overlap the
        * bits of the PNG_FP_STATE.
        */
-      switch ((state & PNG_FP_STATE) + type)
+      switch ((state & PNG_FP_STATE) + (type & PNG_FP_SAW_ANY))
       {
-      case PNG_FP_INTEGER + PNG_FP_SIGN:
+      case PNG_FP_INTEGER + PNG_FP_SAW_SIGN:
          if (state & PNG_FP_SAW_ANY)
             goto PNG_FP_End; /* not a part of the number */
 
-         png_fp_add(state, PNG_FP_SAW_SIGN);
+         png_fp_add(state, type);
          break;
 
-      case PNG_FP_INTEGER + PNG_FP_DOT:
+      case PNG_FP_INTEGER + PNG_FP_SAW_DOT:
          /* Ok as trailer, ok as lead of fraction. */
          if (state & PNG_FP_SAW_DOT) /* two dots */
             goto PNG_FP_End;
 
          else if (state & PNG_FP_SAW_DIGIT) /* trailing dot? */
-            png_fp_add(state, PNG_FP_SAW_DOT);
+            png_fp_add(state, type);
 
          else
-            png_fp_set(state, PNG_FP_FRACTION | PNG_FP_SAW_DOT);
+            png_fp_set(state, PNG_FP_FRACTION | type);
 
          break;
 
-      case PNG_FP_INTEGER + PNG_FP_DIGIT:
+      case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:
          if (state & PNG_FP_SAW_DOT) /* delayed fraction */
             png_fp_set(state, PNG_FP_FRACTION | PNG_FP_SAW_DOT);
 
-         png_fp_add(state, PNG_FP_SAW_DIGIT + PNG_FP_WAS_VALID);
+         png_fp_add(state, type | PNG_FP_WAS_VALID);
 
          break;
-      case PNG_FP_INTEGER + PNG_FP_E:
+
+      case PNG_FP_INTEGER + PNG_FP_SAW_E:
          if ((state & PNG_FP_SAW_DIGIT) == 0)
             goto PNG_FP_End;
 
@@ -967,17 +1384,17 @@ png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
 
          break;
 
-   /* case PNG_FP_FRACTION + PNG_FP_SIGN:
-         goto PNG_FP_End; ** no sign in exponent */
+   /* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:
+         goto PNG_FP_End; ** no sign in fraction */
 
-   /* case PNG_FP_FRACTION + PNG_FP_DOT:
+   /* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:
          goto PNG_FP_End; ** Because SAW_DOT is always set */
 
-      case PNG_FP_FRACTION + PNG_FP_DIGIT:
-         png_fp_add(state, PNG_FP_SAW_DIGIT + PNG_FP_WAS_VALID);
+      case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:
+         png_fp_add(state, type | PNG_FP_WAS_VALID);
          break;
 
-      case PNG_FP_FRACTION + PNG_FP_E:
+      case PNG_FP_FRACTION + PNG_FP_SAW_E:
          /* This is correct because the trailing '.' on an
           * integer is handled above - so we can only get here
           * with the sequence ".E" (with no preceding digits).
@@ -989,7 +1406,7 @@ png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
 
          break;
 
-      case PNG_FP_EXPONENT + PNG_FP_SIGN:
+      case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:
          if (state & PNG_FP_SAW_ANY)
             goto PNG_FP_End; /* not a part of the number */
 
@@ -997,15 +1414,15 @@ png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
 
          break;
 
-   /* case PNG_FP_EXPONENT + PNG_FP_DOT:
+   /* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:
          goto PNG_FP_End; */
 
-      case PNG_FP_EXPONENT + PNG_FP_DIGIT:
-         png_fp_add(state, PNG_FP_SAW_DIGIT + PNG_FP_WAS_VALID);
+      case PNG_FP_EXPONENT + PNG_FP_SAW_DIGIT:
+         png_fp_add(state, PNG_FP_SAW_DIGIT | PNG_FP_WAS_VALID);
 
          break;
 
-   /* case PNG_FP_EXPONEXT + PNG_FP_E:
+   /* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:
          goto PNG_FP_End; */
 
       default: goto PNG_FP_End; /* I.e. break 2 */
@@ -1033,8 +1450,11 @@ png_check_fp_string(png_const_charp string, png_size_t size)
    int        state=0;
    png_size_t char_index=0;
 
-   return png_check_fp_number(string, size, &state, &char_index) &&
-      (char_index == size || string[char_index] == 0);
+   if (png_check_fp_number(string, size, &state, &char_index) &&
+      (char_index == size || string[char_index] == 0))
+      return state /* must be non-zero - see above */;
+
+   return 0; /* i.e. fail */
 }
 #endif /* pCAL or sCAL */
 
@@ -1047,7 +1467,7 @@ static double
 png_pow10(int power)
 {
    int recip = 0;
-   double d = 1;
+   double d = 1.0;
 
    /* Handle negative exponent with a reciprocal at the end because
     * 10 is exact whereas .1 is inexact in base 2
@@ -1061,7 +1481,7 @@ png_pow10(int power)
    if (power > 0)
    {
       /* Decompose power bitwise. */
-      double mult = 10;
+      double mult = 10.0;
       do
       {
          if (power & 1) d *= mult;
@@ -1102,7 +1522,7 @@ png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
       if (fp < 0)
       {
          fp = -fp;
-         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1*/
+         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1 */
          --size;
       }
 
@@ -1180,7 +1600,8 @@ png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
             {
                double d;
 
-               fp *= 10;
+               fp *= 10.0;
+
                /* Use modf here, not floor and subtract, so that
                 * the separation is done in one step.  At the end
                 * of the loop don't break the number into parts so
@@ -1193,7 +1614,7 @@ png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
                {
                   d = floor(fp + .5);
 
-                  if (d > 9)
+                  if (d > 9.0)
                   {
                      /* Rounding up to 10, handle that here. */
                      if (czero > 0)
@@ -1201,9 +1622,10 @@ png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
                         --czero, d = 1;
                         if (cdigits == 0) --clead;
                      }
+
                      else
                      {
-                        while (cdigits > 0 && d > 9)
+                        while (cdigits > 0 && d > 9.0)
                         {
                            int ch = *--ascii;
 
@@ -1228,7 +1650,7 @@ png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
                          * exponent but take into account the leading
                          * decimal point.
                          */
-                        if (d > 9)  /* cdigits == 0 */
+                        if (d > 9.0)  /* cdigits == 0 */
                         {
                            if (exp_b10 == (-1))
                            {
@@ -1249,18 +1671,19 @@ png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
                               ++exp_b10;
 
                            /* In all cases we output a '1' */
-                           d = 1;
+                           d = 1.0;
                         }
                      }
                   }
                   fp = 0; /* Guarantees termination below. */
                }
 
-               if (d == 0)
+               if (d == 0.0)
                {
                   ++czero;
                   if (cdigits == 0) ++clead;
                }
+
                else
                {
                   /* Included embedded zeros in the digit count. */
@@ -1288,6 +1711,7 @@ png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
                                                                  above */
                      --exp_b10;
                   }
+
                   *ascii++ = (char)(48 + (int)d), ++cdigits;
                }
             }
@@ -1329,19 +1753,31 @@ png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
              */
             size -= cdigits;
 
-            *ascii++ = 69, --size;    /* 'E': PLUS 1 TOTAL 2+precision*/
-            if (exp_b10 < 0)
+            *ascii++ = 69, --size;    /* 'E': PLUS 1 TOTAL 2+precision */
+
+            /* The following use of an unsigned temporary avoids ambiguities in
+             * the signed arithmetic on exp_b10 and permits GCC at least to do
+             * better optimization.
+             */
             {
-               *ascii++ = 45, --size; /* '-': PLUS 1 TOTAL 3+precision */
-               exp_b10 = -exp_b10;
-            }
+               unsigned int uexp_b10;
 
-            cdigits = 0;
+               if (exp_b10 < 0)
+               {
+                  *ascii++ = 45, --size; /* '-': PLUS 1 TOTAL 3+precision */
+                  uexp_b10 = -exp_b10;
+               }
 
-            while (exp_b10 > 0)
-            {
-               exponent[cdigits++] = (char)(48 + exp_b10 % 10);
-               exp_b10 /= 10;
+               else
+                  uexp_b10 = exp_b10;
+
+               cdigits = 0;
+
+               while (uexp_b10 > 0)
+               {
+                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);
+                  uexp_b10 /= 10;
+               }
             }
 
             /* Need another size check here for the exponent digits, so
@@ -1399,9 +1835,9 @@ png_ascii_from_fixed(png_structp png_ptr, png_charp ascii, png_size_t size,
       else
          num = fp;
 
-      if (num <= 0x80000000U) /* else overflowed */
+      if (num <= 0x80000000) /* else overflowed */
       {
-         unsigned int ndigits = 0, first = 16/*flag value*/;
+         unsigned int ndigits = 0, first = 16 /* flag value */;
          char digits[10];
 
          while (num)
@@ -1495,7 +1931,7 @@ png_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,
          r /= divisor;
          r = floor(r+.5);
 
-         /* A png_fixed_point is a 32 bit integer. */
+         /* A png_fixed_point is a 32-bit integer. */
          if (r <= 2147483647. && r >= -2147483648.)
          {
             *res = (png_fixed_point)r;
@@ -1540,7 +1976,7 @@ png_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,
 
          if (s32 < D) /* else overflow */
          {
-            /* s32.s00 is now the 64 bit product, do a standard
+            /* s32.s00 is now the 64-bit product, do a standard
              * division, we know that s32 < D, so the maximum
              * required shift is 31.
              */
@@ -1683,7 +2119,7 @@ png_reciprocal2(png_fixed_point a, png_fixed_point b)
  * 2010: moved from pngset.c) */
 /*
  *    Multiply two 32-bit numbers, V1 and V2, using 32-bit
- *    arithmetic, to produce a 64 bit result in the HI/LO words.
+ *    arithmetic, to produce a 64-bit result in the HI/LO words.
  *
  *                  A B
  *                x C D
@@ -1727,24 +2163,24 @@ png_64bit_product (long v1, long v2, unsigned long *hi_product,
 /* Fixed point gamma.
  *
  * To calculate gamma this code implements fast log() and exp() calls using only
- * fixed point arithmetic.  This code has sufficient precision for either 8 or
- * 16 bit sample values.
+ * fixed point arithmetic.  This code has sufficient precision for either 8-bit
+ * or 16-bit sample values.
  *
  * The tables used here were calculated using simple 'bc' programs, but C double
  * precision floating point arithmetic would work fine.  The programs are given
  * at the head of each table.
  *
- * 8 bit log table
+ * 8-bit log table
  *   This is a table of -log(value/255)/log(2) for 'value' in the range 128 to
- *   255, so it's the base 2 logarithm of a normalized 8 bit floating point
- *   mantissa.  The numbers are 32 bit fractions.
+ *   255, so it's the base 2 logarithm of a normalized 8-bit floating point
+ *   mantissa.  The numbers are 32-bit fractions.
  */
 static png_uint_32
 png_8bit_l2[128] =
 {
-#  if PNG_DO_BC
+#  ifdef PNG_DO_BC
       for (i=128;i<256;++i) { .5 - l(i/255)/l(2)*65536*65536; }
-#  endif
+#  else
    4270715492U, 4222494797U, 4174646467U, 4127164793U, 4080044201U, 4033279239U,
    3986864580U, 3940795015U, 3895065449U, 3849670902U, 3804606499U, 3759867474U,
    3715449162U, 3671346997U, 3627556511U, 3584073329U, 3540893168U, 3498011834U,
@@ -1767,11 +2203,13 @@ png_8bit_l2[128] =
    324227938U, 298676034U, 273229066U, 247886176U, 222646516U, 197509248U,
    172473545U, 147538590U, 122703574U, 97967701U, 73330182U, 48790236U,
    24347096U, 0U
+#  endif
+
 #if 0
-   /* The following are the values for 16 bit tables - these work fine for the 8
-    * bit conversions but produce very slightly larger errors in the 16 bit log
-    * (about 1.2 as opposed to 0.7 absolute error in the final value).  To use
-    * these all the shifts below must be adjusted appropriately.
+   /* The following are the values for 16-bit tables - these work fine for the
+    * 8-bit conversions but produce very slightly larger errors in the 16-bit
+    * log (about 1.2 as opposed to 0.7 absolute error in the final value).  To
+    * use these all the shifts below must be adjusted appropriately.
     */
    65166, 64430, 63700, 62976, 62257, 61543, 60835, 60132, 59434, 58741, 58054,
    57371, 56693, 56020, 55352, 54689, 54030, 53375, 52726, 52080, 51439, 50803,
@@ -1788,7 +2226,7 @@ png_8bit_l2[128] =
 #endif
 };
 
-static png_int_32
+PNG_STATIC png_int_32
 png_log8bit(unsigned int x)
 {
    unsigned int lg2 = 0;
@@ -1814,11 +2252,11 @@ png_log8bit(unsigned int x)
    return (png_int_32)((lg2 << 16) + ((png_8bit_l2[x-128]+32768)>>16));
 }
 
-/* The above gives exact (to 16 binary places) log2 values for 8 bit images,
- * for 16 bit images we use the most significant 8 bits of the 16 bit value to
+/* The above gives exact (to 16 binary places) log2 values for 8-bit images,
+ * for 16-bit images we use the most significant 8 bits of the 16-bit value to
  * get an approximation then multiply the approximation by a correction factor
  * determined by the remaining up to 8 bits.  This requires an additional step
- * in the 16 bit case.
+ * in the 16-bit case.
  *
  * We want log2(value/65535), we have log2(v'/255), where:
  *
@@ -1827,8 +2265,8 @@ png_log8bit(unsigned int x)
  *
  * So f is value/v', which is equal to (256+v''/v') since v' is in the range 128
  * to 255 and v'' is in the range 0 to 255 f will be in the range 256 to less
- * than 258.  The final factor also needs to correct for the fact that our 8 bit
- * value is scaled by 255, whereas the 16 bit values must be scaled by 65535.
+ * than 258.  The final factor also needs to correct for the fact that our 8-bit
+ * value is scaled by 255, whereas the 16-bit values must be scaled by 65535.
  *
  * This gives a final formula using a calculated value 'x' which is value/v' and
  * scaling by 65536 to match the above table:
@@ -1838,13 +2276,13 @@ png_log8bit(unsigned int x)
  * Since these numbers are so close to '1' we can use simple linear
  * interpolation between the two end values 256/257 (result -368.61) and 258/257
  * (result 367.179).  The values used below are scaled by a further 64 to give
- * 16 bit precision in the interpolation:
+ * 16-bit precision in the interpolation:
  *
  * Start (256): -23591
  * Zero  (257):      0
  * End   (258):  23499
  */
-static png_int_32
+PNG_STATIC png_int_32
 png_log16bit(png_uint_32 x)
 {
    unsigned int lg2 = 0;
@@ -1865,7 +2303,7 @@ png_log16bit(png_uint_32 x)
    if ((x & 0x8000) == 0)
       lg2 += 1, x <<= 1;
 
-   /* Calculate the base logarithm from the top 8 bits as a 28 bit fractional
+   /* Calculate the base logarithm from the top 8 bits as a 28-bit fractional
     * value.
     */
    lg2 <<= 28;
@@ -1895,34 +2333,35 @@ png_log16bit(png_uint_32 x)
    return (png_int_32)((lg2 + 2048) >> 12);
 }
 
-/* The 'exp()' case must invert the above, taking a 20 bit fixed point
- * logarithmic value and returning a 16 or 8 bit number as appropriate.  In
+/* The 'exp()' case must invert the above, taking a 20-bit fixed point
+ * logarithmic value and returning a 16 or 8-bit number as appropriate.  In
  * each case only the low 16 bits are relevant - the fraction - since the
  * integer bits (the top 4) simply determine a shift.
  *
- * The worst case is the 16 bit distinction between 65535 and 65534, this
- * requires perhaps spurious accuracty in the decoding of the logarithm to
+ * The worst case is the 16-bit distinction between 65535 and 65534, this
+ * requires perhaps spurious accuracy in the decoding of the logarithm to
  * distinguish log2(65535/65534.5) - 10^-5 or 17 bits.  There is little chance
  * of getting this accuracy in practice.
  *
  * To deal with this the following exp() function works out the exponent of the
- * frational part of the logarithm by using an accurate 32 bit value from the
+ * frational part of the logarithm by using an accurate 32-bit value from the
  * top four fractional bits then multiplying in the remaining bits.
  */
 static png_uint_32
 png_32bit_exp[16] =
 {
-#  if PNG_DO_BC
+#  ifdef PNG_DO_BC
       for (i=0;i<16;++i) { .5 + e(-i/16*l(2))*2^32; }
-#  endif
-   /* NOTE: the first entry is deliberately set to the maximum 32 bit value. */
+#  else
+   /* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
    4294967295U, 4112874773U, 3938502376U, 3771522796U, 3611622603U, 3458501653U,
    3311872529U, 3171459999U, 3037000500U, 2908241642U, 2784941738U, 2666869345U,
    2553802834U, 2445529972U, 2341847524U, 2242560872U
+#  endif
 };
 
 /* Adjustment table; provided to explain the numbers in the code below. */
-#if PNG_DO_BC
+#ifdef PNG_DO_BC
 for (i=11;i>=0;--i){ print i, " ", (1 - e(-(2^i)/65536*l(2))) * 2^(32-i), "\n"}
    11 44937.64284865548751208448
    10 45180.98734845585101160448
@@ -1938,12 +2377,12 @@ for (i=11;i>=0;--i){ print i, " ", (1 - e(-(2^i)/65536*l(2))) * 2^(32-i), "\n"}
     0 45425.85339951654943850496
 #endif
 
-static png_uint_32
+PNG_STATIC png_uint_32
 png_exp(png_fixed_point x)
 {
    if (x > 0 && x <= 0xfffff) /* Else overflow or zero (underflow) */
    {
-      /* Obtain a 4 bit approximation */
+      /* Obtain a 4-bit approximation */
       png_uint_32 e = png_32bit_exp[(x >> 12) & 0xf];
 
       /* Incorporate the low 12 bits - these decrease the returned value by
@@ -1986,13 +2425,13 @@ png_exp(png_fixed_point x)
    return 0;
 }
 
-static png_byte
+PNG_STATIC png_byte
 png_exp8bit(png_fixed_point lg2)
 {
-   /* Get a 32 bit value: */
+   /* Get a 32-bit value: */
    png_uint_32 x = png_exp(lg2);
 
-   /* Convert the 32 bit value to 0..255 by multiplying by 256-1, note that the
+   /* Convert the 32-bit value to 0..255 by multiplying by 256-1, note that the
     * second, rounding, step can't overflow because of the first, subtraction,
     * step.
     */
@@ -2000,13 +2439,13 @@ png_exp8bit(png_fixed_point lg2)
    return (png_byte)((x + 0x7fffffU) >> 24);
 }
 
-static png_uint_16
+PNG_STATIC png_uint_16
 png_exp16bit(png_fixed_point lg2)
 {
-   /* Get a 32 bit value: */
+   /* Get a 32-bit value: */
    png_uint_32 x = png_exp(lg2);
 
-   /* Convert the 32 bit value to 0..65535 by multiplying by 65536-1: */
+   /* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */
    x -= x >> 16;
    return (png_uint_16)((x + 32767U) >> 16);
 }
@@ -2059,9 +2498,9 @@ png_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)
 }
 
 /* This does the right thing based on the bit_depth field of the
- * png_struct, interpreting values as 8 or 16 bit.  While the result
- * is nominally a 16 bit value if bit depth is 8 then the result is
- * 8 bit (as are the arguments.)
+ * png_struct, interpreting values as 8-bit or 16-bit.  While the result
+ * is nominally a 16-bit value if bit depth is 8 then the result is
+ * 8-bit (as are the arguments.)
  */
 png_uint_16 /* PRIVATE */
 png_gamma_correct(png_structp png_ptr, unsigned int value,
@@ -2084,8 +2523,8 @@ png_gamma_significant(png_fixed_point gamma_val)
        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
 }
 
-/* Internal function to build a single 16 bit table - the table consists of
- * 'num' 256 entry subtables, where 'num' is determined by 'shift' - the amount
+/* Internal function to build a single 16-bit table - the table consists of
+ * 'num' 256-entry subtables, where 'num' is determined by 'shift' - the amount
  * to shift the input values right (or 16-number_of_signifiant_bits).
  *
  * The caller is responsible for ensuring that the table gets cleaned up on
@@ -2111,7 +2550,7 @@ png_build_16bit_table(png_structp png_ptr, png_uint_16pp *ptable,
           (png_uint_16p)png_malloc(png_ptr, 256 * png_sizeof(png_uint_16));
 
       /* The 'threshold' test is repeated here because it can arise for one of
-       * the 16 bit tables even if the others don't hit it.
+       * the 16-bit tables even if the others don't hit it.
        */
       if (png_gamma_significant(gamma_val))
       {
@@ -2172,9 +2611,9 @@ png_build_16to8_table(png_structp png_ptr, png_uint_16pp *ptable,
    png_uint_16pp table = *ptable =
        (png_uint_16pp)png_calloc(png_ptr, num * png_sizeof(png_uint_16p));
 
-   /* 'num' is the number of tables and also the number of low bits of low
-    * bits of the input 16 bit value used to select a table.  Each table is
-    * itself index by the high 8 bits of the value.
+   /* 'num' is the number of tables and also the number of low bits of the
+    * input 16-bit value used to select a table.  Each table is itself indexed
+    * by the high 8 bits of the value.
     */
    for (i = 0; i < num; i++)
       table[i] = (png_uint_16p)png_malloc(png_ptr,
@@ -2183,24 +2622,24 @@ png_build_16to8_table(png_structp png_ptr, png_uint_16pp *ptable,
    /* 'gamma_val' is set to the reciprocal of the value calculated above, so
     * pow(out,g) is an *input* value.  'last' is the last input value set.
     *
-    * In the loop 'i' is used to find output values.  Since the output is 8
-    * bit there are only 256 possible values.  The tables are set up to
+    * In the loop 'i' is used to find output values.  Since the output is
+    * 8-bit there are only 256 possible values.  The tables are set up to
     * select the closest possible output value for each input by finding
     * the input value at the boundary between each pair of output values
     * and filling the table up to that boundary with the lower output
     * value.
     *
-    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9 bit
-    * values the code below uses a 16 bit value in i; the values start at
+    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit
+    * values the code below uses a 16-bit value in i; the values start at
     * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last
     * entries are filled with 255).  Start i at 128 and fill all 'last'
     * table entries <= 'max'
     */
    last = 0;
-   for (i = 0; i < 255; ++i) /* 8 bit output value */
+   for (i = 0; i < 255; ++i) /* 8-bit output value */
    {
       /* Find the corresponding maximum input value */
-      png_uint_16 out = (png_uint_16)(i * 257U); /* 16 bit output value */
+      png_uint_16 out = (png_uint_16)(i * 257U); /* 16-bit output value */
 
       /* Find the boundary value in 16 bits: */
       png_uint_32 bound = png_gamma_16bit_correct(out+128U, gamma_val);
@@ -2223,9 +2662,9 @@ png_build_16to8_table(png_structp png_ptr, png_uint_16pp *ptable,
    }
 }
 
-/* Build a single 8 bit table: same as the 16 bit case but much simpler (and
+/* Build a single 8-bit table: same as the 16-bit case but much simpler (and
  * typically much faster).  Note that libpng currently does no sBIT processing
- * (apparently contrary to the spec) so a 256 entry table is always generated.
+ * (apparently contrary to the spec) so a 256-entry table is always generated.
  */
 static void
 png_build_8bit_table(png_structp png_ptr, png_bytepp ptable,
@@ -2241,6 +2680,60 @@ png_build_8bit_table(png_structp png_ptr, png_bytepp ptable,
       table[i] = (png_byte)i;
 }
 
+/* Used from png_read_destroy and below to release the memory used by the gamma
+ * tables.
+ */
+void /* PRIVATE */
+png_destroy_gamma_table(png_structp png_ptr)
+{
+   png_free(png_ptr, png_ptr->gamma_table);
+   png_ptr->gamma_table = NULL;
+
+   if (png_ptr->gamma_16_table != NULL)
+   {
+      int i;
+      int istop = (1 << (8 - png_ptr->gamma_shift));
+      for (i = 0; i < istop; i++)
+      {
+         png_free(png_ptr, png_ptr->gamma_16_table[i]);
+      }
+   png_free(png_ptr, png_ptr->gamma_16_table);
+   png_ptr->gamma_16_table = NULL;
+   }
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
+   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+   png_free(png_ptr, png_ptr->gamma_from_1);
+   png_ptr->gamma_from_1 = NULL;
+   png_free(png_ptr, png_ptr->gamma_to_1);
+   png_ptr->gamma_to_1 = NULL;
+
+   if (png_ptr->gamma_16_from_1 != NULL)
+   {
+      int i;
+      int istop = (1 << (8 - png_ptr->gamma_shift));
+      for (i = 0; i < istop; i++)
+      {
+         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);
+      }
+   png_free(png_ptr, png_ptr->gamma_16_from_1);
+   png_ptr->gamma_16_from_1 = NULL;
+   }
+   if (png_ptr->gamma_16_to_1 != NULL)
+   {
+      int i;
+      int istop = (1 << (8 - png_ptr->gamma_shift));
+      for (i = 0; i < istop; i++)
+      {
+         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);
+      }
+   png_free(png_ptr, png_ptr->gamma_16_to_1);
+   png_ptr->gamma_16_to_1 = NULL;
+   }
+#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
+}
+
 /* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
  * tables, we don't make a full table if we are reducing to 8-bit in
  * the future.  Note also how the gamma_16 tables are segmented so that
@@ -2251,6 +2744,18 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
 {
   png_debug(1, "in png_build_gamma_table");
 
+  /* Remove any existing table; this copes with multiple calls to
+   * png_read_update_info.  The warning is because building the gamma tables
+   * multiple times is a performance hit - it's harmless but the ability to call
+   * png_read_update_info() multiple times is new in 1.5.6 so it seems sensible
+   * to warn if the app introduces such a hit.
+   */
+  if (png_ptr->gamma_table != NULL || png_ptr->gamma_16_table != NULL)
+  {
+    png_warning(png_ptr, "gamma table being rebuilt");
+    png_destroy_gamma_table(png_ptr);
+  }
+
   if (bit_depth <= 8)
   {
      png_build_8bit_table(png_ptr, &png_ptr->gamma_table,
@@ -2258,8 +2763,9 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
          png_ptr->screen_gamma) : PNG_FP_1);
 
 #if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
    defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-     if (png_ptr->transformations & ((PNG_BACKGROUND) | PNG_RGB_TO_GRAY))
+     if (png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY))
      {
         png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1,
             png_reciprocal(png_ptr->gamma));
@@ -2268,7 +2774,7 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
             png_ptr->screen_gamma > 0 ?  png_reciprocal(png_ptr->screen_gamma) :
             png_ptr->gamma/* Probably doing rgb_to_gray */);
      }
-#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
+#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
   }
   else
   {
@@ -2287,14 +2793,14 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
      else
         sig_bit = png_ptr->sig_bit.gray;
 
-     /* 16 bit gamma code uses this equation:
+     /* 16-bit gamma code uses this equation:
       *
       *   ov = table[(iv & 0xff) >> gamma_shift][iv >> 8]
       *
       * Where 'iv' is the input color value and 'ov' is the output value -
       * pow(iv, gamma).
       *
-      * Thus the gamma table consists of up to 256 256 entry tables.  The table
+      * Thus the gamma table consists of up to 256 256-entry tables.  The table
       * is selected by the (8-gamma_shift) most significant of the low 8 bits of
       * the color value then indexed by the upper 8 bits:
       *
@@ -2302,7 +2808,7 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
       *
       * So the table 'n' corresponds to all those 'iv' of:
       *
-      *   <all high 8 bit values><n << gamma_shift>..<(n+1 << gamma_shift)-1>
+      *   <all high 8-bit values><n << gamma_shift>..<(n+1 << gamma_shift)-1>
       *
       */
      if (sig_bit > 0 && sig_bit < 16U)
@@ -2311,7 +2817,7 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
      else
         shift = 0; /* keep all 16 bits */
 
-     if (png_ptr->transformations & PNG_16_TO_8)
+     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8))
      {
         /* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively
          * the significant bits in the *input* when the output will
@@ -2327,7 +2833,12 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
      png_ptr->gamma_shift = shift;
 
 #ifdef PNG_16BIT_SUPPORTED
-     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_BACKGROUND))
+     /* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now
+      * PNG_COMPOSE).  This effectively smashed the background calculation for
+      * 16-bit output because the 8-bit table assumes the result will be reduced
+      * to 8 bits.
+      */
+     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8))
 #endif
          png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,
          png_ptr->screen_gamma > 0 ? png_product2(png_ptr->gamma,
@@ -2341,8 +2852,9 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
 #endif
 
 #if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
    defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-     if (png_ptr->transformations & (PNG_BACKGROUND | PNG_RGB_TO_GRAY))
+     if (png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY))
      {
         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_to_1, shift,
             png_reciprocal(png_ptr->gamma));
@@ -2355,7 +2867,7 @@ png_build_gamma_table(png_structp png_ptr, int bit_depth)
             png_ptr->screen_gamma > 0 ? png_reciprocal(png_ptr->screen_gamma) :
             png_ptr->gamma/* Probably doing rgb_to_gray */);
      }
-#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
+#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
   }
 }
 #endif /* READ_GAMMA */
diff --git a/src/3rdparty/libpng/png.h b/src/3rdparty/libpng/png.h
index 100f56d..4e0dee1 100644
--- a/src/3rdparty/libpng/png.h
+++ b/src/3rdparty/libpng/png.h
@@ -1,8 +1,8 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.5.1 - February 3, 2011
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * libpng version 1.5.10 - March 29, 2012
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -11,7 +11,7 @@
  * Authors and maintainers:
  *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *   libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *   libpng versions 0.97, January 1998, through 1.5.1 - February 3, 2011: Glenn
+ *   libpng versions 0.97, January 1998, through 1.5.10 - March 29, 2012: Glenn
  *   See also "Contributing Authors", below.
  *
  * Note about libpng version numbers:
@@ -147,6 +147,33 @@
  *    1.5.1beta01-11          15    10501  15.so.15.1[.0]
  *    1.5.1rc01-02            15    10501  15.so.15.1[.0]
  *    1.5.1                   15    10501  15.so.15.1[.0]
+ *    1.5.2beta01-03          15    10502  15.so.15.2[.0]
+ *    1.5.2rc01-03            15    10502  15.so.15.2[.0]
+ *    1.5.2                   15    10502  15.so.15.2[.0]
+ *    1.5.3beta01-10          15    10503  15.so.15.3[.0]
+ *    1.5.3rc01-02            15    10503  15.so.15.3[.0]
+ *    1.5.3beta11             15    10503  15.so.15.3[.0]
+ *    1.5.3 [omitted]
+ *    1.5.4beta01-08          15    10504  15.so.15.4[.0]
+ *    1.5.4rc01               15    10504  15.so.15.4[.0]
+ *    1.5.4                   15    10504  15.so.15.4[.0]
+ *    1.5.5beta01-08          15    10505  15.so.15.5[.0]
+ *    1.5.5rc01               15    10505  15.so.15.5[.0]
+ *    1.5.5                   15    10505  15.so.15.5[.0]
+ *    1.5.6beta01-07          15    10506  15.so.15.6[.0]
+ *    1.5.6rc01-03            15    10506  15.so.15.6[.0]
+ *    1.5.6                   15    10506  15.so.15.6[.0]
+ *    1.5.7beta01-05          15    10507  15.so.15.7[.0]
+ *    1.5.7rc01-03            15    10507  15.so.15.7[.0]
+ *    1.5.7                   15    10507  15.so.15.7[.0]
+ *    1.5.8beta01             15    10508  15.so.15.8[.0]
+ *    1.5.8rc01               15    10508  15.so.15.8[.0]
+ *    1.5.8                   15    10508  15.so.15.8[.0]
+ *    1.5.9beta01-02          15    10509  15.so.15.9[.0]
+ *    1.5.9rc01               15    10509  15.so.15.9[.0]
+ *    1.5.9                   15    10509  15.so.15.9[.0]
+ *    1.5.10beta01-05         15    10510  15.so.15.10[.0]
+ *    1.5.10                  15    10510  15.so.15.10[.0]
  *
  *   Henceforth the source version will match the shared-library major
  *   and minor numbers; the shared-library major version number will be
@@ -156,7 +183,7 @@
  *   to the source version x.y.z (leading zeros in y and z).  Beta versions
  *   were given the previous public release number plus a letter, until
  *   version 1.0.6j; from then on they were given the upcoming public
- *   release number plus "betaNN" or "rcN".
+ *   release number plus "betaNN" or "rcNN".
  *
  *   Binary incompatibility exists only when applications make direct access
  *   to the info_ptr or png_ptr members through png.h, and the compiled
@@ -178,8 +205,8 @@
  *
  * This code is released under the libpng license.
  *
- * libpng versions 1.2.6, August 15, 2004, through 1.5.1, February 3, 2011, are
- * Copyright (c) 2004, 2006-2011 Glenn Randers-Pehrson, and are
+ * libpng versions 1.2.6, August 15, 2004, through 1.5.10, March 29, 2012, are
+ * Copyright (c) 2004, 2006-2012 Glenn Randers-Pehrson, and are
  * distributed according to the same disclaimer and license as libpng-1.2.5
  * with the following individual added to the list of Contributing Authors:
  *
@@ -205,7 +232,7 @@
  *
  * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
  * Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson, and are
- * distributed according to the same disclaimer and license as libpng-0.96, 
+ * distributed according to the same disclaimer and license as libpng-0.96,
  * with the following individuals added to the list of Contributing Authors:
  *
  *    Tom Lane
@@ -214,7 +241,7 @@
  *
  * libpng versions 0.89, June 1996, through 0.96, May 1997, are
  * Copyright (c) 1996, 1997 Andreas Dilger
- * Distributed according to the same disclaimer and license as libpng-0.88, 
+ * Distributed according to the same disclaimer and license as libpng-0.88,
  * with the following individuals added to the list of Contributing Authors:
  *
  *    John Bowler
@@ -237,10 +264,10 @@
  *    Tim Wegner
  *
  * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
- * and Group 42, Inc. disclaim all warranties, expressed or implied, 
+ * and Group 42, Inc. disclaim all warranties, expressed or implied,
  * including, without limitation, the warranties of merchantability and of
  * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
- * assume no liability for direct, indirect, incidental, special, exemplary, 
+ * assume no liability for direct, indirect, incidental, special, exemplary,
  * or consequential damages, which may result from the use of the PNG
  * Reference Library, even if advised of the possibility of such damage.
  *
@@ -290,25 +317,24 @@
  * Y2K compliance in libpng:
  * =========================
  *
- *    February 3, 2011
+ *    March 29, 2012
  *
  *    Since the PNG Development group is an ad-hoc body, we can't make
  *    an official declaration.
  *
  *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.5.1 are Y2K compliant.  It is my belief that
+ *    upward through 1.5.10 are Y2K compliant.  It is my belief that
  *    earlier versions were also Y2K compliant.
  *
- *    Libpng only has three year fields.  One is a 2-byte unsigned integer
- *    that will hold years up to 65535.  The other two hold the date in text
+ *    Libpng only has two year fields.  One is a 2-byte unsigned integer
+ *    that will hold years up to 65535.  The other holds the date in text
  *    format, and will hold years up to 9999.
  *
  *    The integer is
  *        "png_uint_16 year" in png_time_struct.
  *
- *    The strings are
- *        "png_charp time_buffer" in png_struct and
- *        "near_time_buffer", which is a local character string in png.c.
+ *    The string is
+ *        "png_char time_buffer" in png_struct
  *
  *    There are seven time-related functions:
  *        png.c: png_convert_to_rfc_1123() in png.c
@@ -326,7 +352,7 @@
  *    the full 4-digit year.  There is a possibility that applications using
  *    libpng are not passing 4-digit years into the png_convert_to_rfc_1123()
  *    function, or that they are incorrectly passing only a 2-digit year
- *    instead of "year - 1900" into the png_convert_from_struct_tm() function, 
+ *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
  *    but this is not under our control.  The libpng documentation has always
  *    stated that it works with 4-digit years, and the APIs have been
  *    documented as such.
@@ -349,12 +375,15 @@
  * describes how to use libpng, and the file example.c summarizes it
  * with some code on which to build.  This file is useful for looking
  * at the actual function definitions and structure components.
+ *
+ * If you just need to read a PNG file and don't want to read the documentation
+ * skip to the end of this file and read the section entitled 'simplified API'.
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.5.1"
+#define PNG_LIBPNG_VER_STRING "1.5.10"
 #define PNG_HEADER_VERSION_STRING \
-     " libpng version 1.5.1 - February 3, 2011\n"
+     " libpng version 1.5.10 - March 29, 2012\n"
 
 #define PNG_LIBPNG_VER_SONUM   15
 #define PNG_LIBPNG_VER_DLLNUM  15
@@ -362,7 +391,8 @@
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   5
-#define PNG_LIBPNG_VER_RELEASE 1
+#define PNG_LIBPNG_VER_RELEASE 10
+
 /* This should match the numeric part of the final component of
  * PNG_LIBPNG_VER_STRING, omitting any leading zero:
  */
@@ -384,7 +414,7 @@
 #define PNG_LIBPNG_BUILD_SPECIAL 32 /* Cannot be OR'ed with
                                        PNG_LIBPNG_BUILD_PRIVATE */
 
-#define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_BETA
+#define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE
 
 /* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
  * We must not include leading zeros.
@@ -392,7 +422,7 @@
  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
  */
-#define PNG_LIBPNG_VER 10501 /* 1.5.1 */
+#define PNG_LIBPNG_VER 10510 /* 1.5.10 */
 
 /* Library configuration: these options cannot be changed after
  * the library has been built.
@@ -405,19 +435,24 @@
 #endif
 
 #ifndef PNG_VERSION_INFO_ONLY
-/* Standard header files (not needed for the version info) */
-#  ifdef PNG_SETJMP_SUPPORTED
-#    include <setjmp.h>
+#  ifndef PNG_BUILDING_SYMBOL_TABLE
+  /*
+   *   Standard header files (not needed for the version info or while
+   *   building symbol table -- see scripts/pnglibconf.dfa)
+   */
+#    ifdef PNG_SETJMP_SUPPORTED
+#      include <setjmp.h>
+#    endif
+
+    /* Need the time information for converting tIME chunks, it
+     * defines struct tm:
+     */
+#    ifdef PNG_CONVERT_tIME_SUPPORTED
+       /* "time.h" functions are not supported on all operating systems */
+#      include <time.h>
+#    endif
 #  endif
 
-/* Need the time information for converting tIME chunks, it
- * defines struct tm:
- */
-#ifdef PNG_CONVERT_tIME_SUPPORTED
-   /* "time.h" functions are not supported on all operating systems */
-#  include <time.h>
-#endif
-
 /* Machine specific configuration. */
 #  include "pngconf.h"
 #endif
@@ -509,7 +544,7 @@ extern "C" {
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef char* png_libpng_version_1_5_1;
+typedef char* png_libpng_version_1_5_10;
 
 /* Three color definitions.  The order of the red, green, and blue, (and the
  * exact size) is not important, although the size of the fields need to
@@ -582,13 +617,22 @@ typedef PNG_CONST png_sPLT_t FAR * png_const_sPLT_tp;
 typedef png_sPLT_t FAR * FAR * png_sPLT_tpp;
 
 #ifdef PNG_TEXT_SUPPORTED
-/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file, 
+/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
  * and whether that contents is compressed or not.  The "key" field
- * points to a regular zero-terminated C string.  The "text", "lang", and
- * "lang_key" fields can be regular C strings, empty strings, or NULL pointers.
- * However, the * structure returned by png_get_text() will always contain
- * regular zero-terminated C strings (possibly empty), never NULL pointers, 
- * so they can be safely used in printf() and other string-handling functions.
+ * points to a regular zero-terminated C string.  The "text" fields can be a
+ * regular C string, an empty string, or a NULL pointer.
+ * However, the structure returned by png_get_text() will always contain
+ * the "text" field as a regular zero-terminated C string (possibly
+ * empty), never a NULL pointer, so it can be safely used in printf() and
+ * other string-handling functions.  Note that the "itxt_length", "lang", and
+ * "lang_key" members of the structure only exist when the library is built
+ * with iTXt chunk support.  Prior to libpng-1.4.0 the library was built by
+ * default without iTXt support. Also note that when iTXt *is* supported,
+ * the "lang" and "lang_key" fields contain NULL pointers when the
+ * "compression" field contains * PNG_TEXT_COMPRESSION_NONE or
+ * PNG_TEXT_COMPRESSION_zTXt. Note that the "compression value" is not the
+ * same as what appears in the PNG tEXt/zTXt/iTXt chunk's "compression flag"
+ * which is always 0 or 1, or its "compression method" which is always 0.
  */
 typedef struct png_text_struct
 {
@@ -657,12 +701,24 @@ typedef struct png_unknown_chunk_t
     /* libpng-using applications should NOT directly modify this byte. */
     png_byte location; /* mode of operation at read time */
 }
+
+
 png_unknown_chunk;
 typedef png_unknown_chunk FAR * png_unknown_chunkp;
 typedef PNG_CONST png_unknown_chunk FAR * png_const_unknown_chunkp;
 typedef png_unknown_chunk FAR * FAR * png_unknown_chunkpp;
 #endif
 
+/* Values for the unknown chunk location byte */
+
+#define PNG_HAVE_IHDR  0x01
+#define PNG_HAVE_PLTE  0x02
+#define PNG_AFTER_IDAT 0x08
+
+/* The complete definition of png_info has, as of libpng-1.5.0,
+ * been moved into a separate header file that is not accessible to
+ * applications.  Read libpng-manual.txt or libpng.3 for more info.
+ */
 typedef struct png_info_def png_info;
 typedef png_info FAR * png_infop;
 typedef PNG_CONST png_info FAR * png_const_infop;
@@ -678,6 +734,8 @@ typedef png_info FAR * FAR * png_infopp;
  */
 #define PNG_FP_1    100000
 #define PNG_FP_HALF  50000
+#define PNG_FP_MAX  ((png_fixed_point)0x7fffffffL)
+#define PNG_FP_MIN  (-PNG_FP_MAX)
 
 /* These describe the color_type field in png_info. */
 /* color type masks */
@@ -765,7 +823,7 @@ typedef png_info FAR * FAR * png_infopp;
 #define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
 #define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
 #define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
-#define PNG_INFO_IDAT 0x8000L  /* ESR, 1.0.6 */
+#define PNG_INFO_IDAT 0x8000   /* ESR, 1.0.6 */
 
 /* This is used for the transformation routines, as some of them
  * change these values for the row.  It also should enable using
@@ -784,6 +842,14 @@ typedef struct png_row_info_struct
 typedef png_row_info FAR * png_row_infop;
 typedef png_row_info FAR * FAR * png_row_infopp;
 
+/* The complete definition of png_struct has, as of libpng-1.5.0,
+ * been moved into a separate header file that is not accessible to
+ * applications.  Read libpng-manual.txt or libpng.3 for more info.
+ */
+typedef struct png_struct_def png_struct;
+typedef PNG_CONST png_struct FAR * png_const_structp;
+typedef png_struct FAR * png_structp;
+
 /* These are the function types for the I/O functions and for the functions
  * that allow the user to override the default I/O functions with his or her
  * own.  The png_error_ptr type should match that of user-supplied warning
@@ -792,61 +858,59 @@ typedef png_row_info FAR * FAR * png_row_infopp;
  * modify the buffer it is passed. The 'read' function, on the other hand, is
  * expected to return the read data in the buffer.
  */
-typedef struct png_struct_def png_struct;
-typedef PNG_CONST png_struct FAR * png_const_structp;
-typedef png_struct FAR * png_structp;
-
-typedef PNG_CALLBACK(void, *png_error_ptr, (png_structp, png_const_charp), );
-typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, png_size_t), );
-typedef PNG_CALLBACK(void, *png_flush_ptr, (png_structp), );
-typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32, 
-    int), );
-typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32, 
-    int), );
+typedef PNG_CALLBACK(void, *png_error_ptr, (png_structp, png_const_charp));
+typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, png_size_t));
+typedef PNG_CALLBACK(void, *png_flush_ptr, (png_structp));
+typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
+    int));
+typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32,
+    int));
 
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-typedef PNG_CALLBACK(void, *png_progressive_info_ptr, 
-    (png_structp, png_infop), );
-typedef PNG_CALLBACK(void, *png_progressive_end_ptr,
-    (png_structp, png_infop), );
-typedef PNG_CALLBACK(void, *png_progressive_row_ptr,
-    (png_structp, png_bytep, png_uint_32, int), );
+typedef PNG_CALLBACK(void, *png_progressive_info_ptr, (png_structp, png_infop));
+typedef PNG_CALLBACK(void, *png_progressive_end_ptr, (png_structp, png_infop));
+
+/* The following callback receives png_uint_32 row_number, int pass for the
+ * png_bytep data of the row.  When transforming an interlaced image the
+ * row number is the row number within the sub-image of the interlace pass, so
+ * the value will increase to the height of the sub-image (not the full image)
+ * then reset to 0 for the next pass.
+ *
+ * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
+ * find the output pixel (x,y) given an interlaced sub-image pixel
+ * (row,col,pass).  (See below for these macros.)
+ */
+typedef PNG_CALLBACK(void, *png_progressive_row_ptr, (png_structp, png_bytep,
+    png_uint_32, int));
 #endif
 
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-typedef PNG_CALLBACK(void, *png_user_transform_ptr,
-    (png_structp, png_row_infop, png_bytep), );
+typedef PNG_CALLBACK(void, *png_user_transform_ptr, (png_structp, png_row_infop,
+    png_bytep));
 #endif
 
 #ifdef PNG_USER_CHUNKS_SUPPORTED
-typedef PNG_CALLBACK(int, *png_user_chunk_ptr, (png_structp, 
-    png_unknown_chunkp), );
+typedef PNG_CALLBACK(int, *png_user_chunk_ptr, (png_structp,
+    png_unknown_chunkp));
 #endif
 #ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-typedef PNG_CALLBACK(void, *png_unknown_chunk_ptr, (png_structp), );
+typedef PNG_CALLBACK(void, *png_unknown_chunk_ptr, (png_structp));
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
-/* This must match the function definition in <setjmp.h>, and the
- * application must include this before png.h to obtain the definition
- * of jmp_buf.  The function is required to be PNG_NORETURN.  (Note that
- * PNG_PTR_NORETURN is used here because current versions of the Microsoft
- * C compiler do not support the PNG_NORETURN attribute on a pointer.)
- *
- * If you get a type warning from the compiler when linking against this line
- * then your compiler has 'longjmp' that does not match the requirements of the
- * compiler that built libpng.  You will have to write a wrapper function for
- * your compiler's longjmp and call png_set_longjmp_fn directly (not via the
- * png_jmpbuf macro.)
- *
- * If you get a warning here while building the library you will need to make
+/* This must match the function definition in <setjmp.h>, and the application
+ * must include this before png.h to obtain the definition of jmp_buf.  The
+ * function is required to be PNG_NORETURN, but this is not checked.  If the
+ * function does return the application will crash via an abort() or similar
+ * system level call.
+ *
+ * If you get a warning here while building the library you may need to make
  * changes to ensure that pnglibconf.h records the calling convention used by
  * your compiler.  This may be very difficult - try using a different compiler
  * to build the library!
  */
-typedef PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)), 
-   PNG_PTR_NORETURN);
+PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)), typedef);
 #endif
 
 /* Transform masks for the high-level interface */
@@ -868,21 +932,24 @@ typedef PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)),
 #define PNG_TRANSFORM_STRIP_FILLER_AFTER 0x1000 /* write only */
 /* Added to libpng-1.4.0 */
 #define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
+/* Added to libpng-1.5.4 */
+#define PNG_TRANSFORM_EXPAND_16     0x4000      /* read only */
+#define PNG_TRANSFORM_SCALE_16      0x8000      /* read only */
 
 /* Flags for MNG supported features */
 #define PNG_FLAG_MNG_EMPTY_PLTE     0x01
 #define PNG_FLAG_MNG_FILTER_64      0x04
 #define PNG_ALL_MNG_FEATURES        0x05
 
-/* NOTE: prior to 1.5 these functions had no 'API' style declaration, 
+/* NOTE: prior to 1.5 these functions had no 'API' style declaration,
  * this allowed the zlib default functions to be used on Windows
  * platforms.  In 1.5 the zlib default malloc (which just calls malloc and
  * ignores the first argument) should be completely compatible with the
  * following.
  */
-typedef PNG_CALLBACK(png_voidp, *png_malloc_ptr, (png_structp, 
-    png_alloc_size_t), );
-typedef PNG_CALLBACK(void, *png_free_ptr, (png_structp, png_voidp), );
+typedef PNG_CALLBACK(png_voidp, *png_malloc_ptr, (png_structp,
+    png_alloc_size_t));
+typedef PNG_CALLBACK(void, *png_free_ptr, (png_structp, png_voidp));
 
 typedef png_struct FAR * FAR * png_structpp;
 
@@ -928,7 +995,7 @@ PNG_EXPORT(2, void, png_set_sig_bytes, (png_structp png_ptr, int num_bytes));
  * signature, and non-zero otherwise.  Having num_to_check == 0 or
  * start > 7 will always fail (ie return non-zero).
  */
-PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, png_size_t start, 
+PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, png_size_t start,
     png_size_t num_to_check));
 
 /* Simple signature checking function.  This is the same as calling
@@ -939,19 +1006,19 @@ PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, png_size_t start,
 /* Allocate and initialize png_ptr struct for reading, and any other memory. */
 PNG_EXPORTA(4, png_structp, png_create_read_struct,
     (png_const_charp user_png_ver, png_voidp error_ptr,
-    png_error_ptr error_fn, png_error_ptr warn_fn), 
+    png_error_ptr error_fn, png_error_ptr warn_fn),
     PNG_ALLOCATED);
 
 /* Allocate and initialize png_ptr struct for writing, and any other memory */
 PNG_EXPORTA(5, png_structp, png_create_write_struct,
     (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
-    png_error_ptr warn_fn), 
+    png_error_ptr warn_fn),
     PNG_ALLOCATED);
 
 PNG_EXPORT(6, png_size_t, png_get_compression_buffer_size,
     (png_const_structp png_ptr));
 
-PNG_EXPORT(7, void, png_set_compression_buffer_size, (png_structp png_ptr, 
+PNG_EXPORT(7, void, png_set_compression_buffer_size, (png_structp png_ptr,
     png_size_t size));
 
 /* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
@@ -965,7 +1032,7 @@ PNG_EXPORT(7, void, png_set_compression_buffer_size, (png_structp png_ptr,
  * allocated by the library - the call will return NULL on a mismatch
  * indicating an ABI mismatch.
  */
-PNG_EXPORT(8, jmp_buf*, png_set_longjmp_fn, (png_structp png_ptr, 
+PNG_EXPORT(8, jmp_buf*, png_set_longjmp_fn, (png_structp png_ptr,
     png_longjmp_ptr longjmp_fn, size_t jmp_buf_size));
 #  define png_jmpbuf(png_ptr) \
       (*png_set_longjmp_fn((png_ptr), longjmp, sizeof (jmp_buf)))
@@ -990,13 +1057,13 @@ PNG_EXPORT(10, int, png_reset_zstream, (png_structp png_ptr));
 #ifdef PNG_USER_MEM_SUPPORTED
 PNG_EXPORTA(11, png_structp, png_create_read_struct_2,
     (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
-    png_error_ptr warn_fn, 
-    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn), 
+    png_error_ptr warn_fn,
+    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn),
     PNG_ALLOCATED);
 PNG_EXPORTA(12, png_structp, png_create_write_struct_2,
     (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
-    png_error_ptr warn_fn, 
-    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn), 
+    png_error_ptr warn_fn,
+    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn),
     PNG_ALLOCATED);
 #endif
 
@@ -1008,7 +1075,7 @@ PNG_EXPORT(14, void, png_write_chunk, (png_structp png_ptr, png_const_bytep
     chunk_name, png_const_bytep data, png_size_t length));
 
 /* Write the start of a PNG chunk - length and chunk name. */
-PNG_EXPORT(15, void, png_write_chunk_start, (png_structp png_ptr, 
+PNG_EXPORT(15, void, png_write_chunk_start, (png_structp png_ptr,
     png_const_bytep chunk_name, png_uint_32 length));
 
 /* Write the data of a PNG chunk started with png_write_chunk_start(). */
@@ -1019,10 +1086,10 @@ PNG_EXPORT(16, void, png_write_chunk_data, (png_structp png_ptr,
 PNG_EXPORT(17, void, png_write_chunk_end, (png_structp png_ptr));
 
 /* Allocate and initialize the info structure */
-PNG_EXPORTA(18, png_infop, png_create_info_struct, (png_structp png_ptr), 
+PNG_EXPORTA(18, png_infop, png_create_info_struct, (png_structp png_ptr),
     PNG_ALLOCATED);
 
-PNG_EXPORT(19, void, png_info_init_3, (png_infopp info_ptr, 
+PNG_EXPORT(19, void, png_info_init_3, (png_infopp info_ptr,
     png_size_t png_info_struct_size));
 
 /* Writes all the PNG information before the image. */
@@ -1039,13 +1106,13 @@ PNG_EXPORT(22, void, png_read_info,
 
 #ifdef PNG_TIME_RFC1123_SUPPORTED
 PNG_EXPORT(23, png_const_charp, png_convert_to_rfc1123,
-    (png_structp png_ptr, 
+    (png_structp png_ptr,
     png_const_timep ptime));
 #endif
 
 #ifdef PNG_CONVERT_tIME_SUPPORTED
 /* Convert from a struct tm to png_time */
-PNG_EXPORT(24, void, png_convert_from_struct_tm, (png_timep ptime, 
+PNG_EXPORT(24, void, png_convert_from_struct_tm, (png_timep ptime,
     PNG_CONST struct tm FAR * ttime));
 
 /* Convert from time_t to png_time.  Uses gmtime() */
@@ -1061,6 +1128,13 @@ PNG_EXPORT(28, void, png_set_palette_to_rgb, (png_structp png_ptr));
 PNG_EXPORT(29, void, png_set_tRNS_to_alpha, (png_structp png_ptr));
 #endif
 
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+/* Expand to 16-bit channels, forces conversion of palette to RGB and expansion
+ * of a tRNS chunk if present.
+ */
+PNG_EXPORT(221, void, png_set_expand_16, (png_structp png_ptr));
+#endif
+
 #if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
 /* Use blue, green, red order for pixels. */
 PNG_EXPORT(30, void, png_set_bgr, (png_structp png_ptr));
@@ -1073,17 +1147,233 @@ PNG_EXPORT(31, void, png_set_gray_to_rgb, (png_structp png_ptr));
 
 #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 /* Reduce RGB to grayscale. */
+#define PNG_ERROR_ACTION_NONE  1
+#define PNG_ERROR_ACTION_WARN  2
+#define PNG_ERROR_ACTION_ERROR 3
+#define PNG_RGB_TO_GRAY_DEFAULT (-1)/*for red/green coefficients*/
+
 PNG_FP_EXPORT(32, void, png_set_rgb_to_gray, (png_structp png_ptr,
     int error_action, double red, double green));
-PNG_FIXED_EXPORT(33, void, png_set_rgb_to_gray_fixed, (png_structp png_ptr, 
+PNG_FIXED_EXPORT(33, void, png_set_rgb_to_gray_fixed, (png_structp png_ptr,
     int error_action, png_fixed_point red, png_fixed_point green));
 
 PNG_EXPORT(34, png_byte, png_get_rgb_to_gray_status, (png_const_structp
     png_ptr));
 #endif
 
-PNG_EXPORT(35, void, png_build_grayscale_palette, (int bit_depth, 
+#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
+PNG_EXPORT(35, void, png_build_grayscale_palette, (int bit_depth,
     png_colorp palette));
+#endif
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+/* How the alpha channel is interpreted - this affects how the color channels of
+ * a PNG file are returned when an alpha channel, or tRNS chunk in a palette
+ * file, is present.
+ *
+ * This has no effect on the way pixels are written into a PNG output
+ * datastream. The color samples in a PNG datastream are never premultiplied
+ * with the alpha samples.
+ *
+ * The default is to return data according to the PNG specification: the alpha
+ * channel is a linear measure of the contribution of the pixel to the
+ * corresponding composited pixel.  The gamma encoded color channels must be
+ * scaled according to the contribution and to do this it is necessary to undo
+ * the encoding, scale the color values, perform the composition and reencode
+ * the values.  This is the 'PNG' mode.
+ *
+ * The alternative is to 'associate' the alpha with the color information by
+ * storing color channel values that have been scaled by the alpha.  The
+ * advantage is that the color channels can be resampled (the image can be
+ * scaled) in this form.  The disadvantage is that normal practice is to store
+ * linear, not (gamma) encoded, values and this requires 16-bit channels for
+ * still images rather than the 8-bit channels that are just about sufficient if
+ * gamma encoding is used.  In addition all non-transparent pixel values,
+ * including completely opaque ones, must be gamma encoded to produce the final
+ * image.  This is the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' mode (the
+ * latter being the two common names for associated alpha color channels.)
+ *
+ * Since it is not necessary to perform arithmetic on opaque color values so
+ * long as they are not to be resampled and are in the final color space it is
+ * possible to optimize the handling of alpha by storing the opaque pixels in
+ * the PNG format (adjusted for the output color space) while storing partially
+ * opaque pixels in the standard, linear, format.  The accuracy required for
+ * standard alpha composition is relatively low, because the pixels are
+ * isolated, therefore typically the accuracy loss in storing 8-bit linear
+ * values is acceptable.  (This is not true if the alpha channel is used to
+ * simulate transparency over large areas - use 16 bits or the PNG mode in
+ * this case!)  This is the 'OPTIMIZED' mode.  For this mode a pixel is
+ * treated as opaque only if the alpha value is equal to the maximum value.
+ *
+ * The final choice is to gamma encode the alpha channel as well.  This is
+ * broken because, in practice, no implementation that uses this choice
+ * correctly undoes the encoding before handling alpha composition.  Use this
+ * choice only if other serious errors in the software or hardware you use
+ * mandate it; the typical serious error is for dark halos to appear around
+ * opaque areas of the composited PNG image because of arithmetic overflow.
+ *
+ * The API function png_set_alpha_mode specifies which of these choices to use
+ * with an enumerated 'mode' value and the gamma of the required output:
+ */
+#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
+#define PNG_ALPHA_STANDARD      1 /* according to Porter/Duff */
+#define PNG_ALPHA_ASSOCIATED    1 /* as above; this is the normal practice */
+#define PNG_ALPHA_PREMULTIPLIED 1 /* as above */
+#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
+#define PNG_ALPHA_BROKEN        3 /* the alpha channel is gamma encoded */
+
+PNG_FP_EXPORT(227, void, png_set_alpha_mode, (png_structp png_ptr, int mode,
+    double output_gamma));
+PNG_FIXED_EXPORT(228, void, png_set_alpha_mode_fixed, (png_structp png_ptr,
+    int mode, png_fixed_point output_gamma));
+#endif
+
+#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_ALPHA_MODE_SUPPORTED)
+/* The output_gamma value is a screen gamma in libpng terminology: it expresses
+ * how to decode the output values, not how they are encoded.  The values used
+ * correspond to the normal numbers used to describe the overall gamma of a
+ * computer display system; for example 2.2 for an sRGB conformant system.  The
+ * values are scaled by 100000 in the _fixed version of the API (so 220000 for
+ * sRGB.)
+ *
+ * The inverse of the value is always used to provide a default for the PNG file
+ * encoding if it has no gAMA chunk and if png_set_gamma() has not been called
+ * to override the PNG gamma information.
+ *
+ * When the ALPHA_OPTIMIZED mode is selected the output gamma is used to encode
+ * opaque pixels however pixels with lower alpha values are not encoded,
+ * regardless of the output gamma setting.
+ *
+ * When the standard Porter Duff handling is requested with mode 1 the output
+ * encoding is set to be linear and the output_gamma value is only relevant
+ * as a default for input data that has no gamma information.  The linear output
+ * encoding will be overridden if png_set_gamma() is called - the results may be
+ * highly unexpected!
+ *
+ * The following numbers are derived from the sRGB standard and the research
+ * behind it.  sRGB is defined to be approximated by a PNG gAMA chunk value of
+ * 0.45455 (1/2.2) for PNG.  The value implicitly includes any viewing
+ * correction required to take account of any differences in the color
+ * environment of the original scene and the intended display environment; the
+ * value expresses how to *decode* the image for display, not how the original
+ * data was *encoded*.
+ *
+ * sRGB provides a peg for the PNG standard by defining a viewing environment.
+ * sRGB itself, and earlier TV standards, actually use a more complex transform
+ * (a linear portion then a gamma 2.4 power law) than PNG can express.  (PNG is
+ * limited to simple power laws.)  By saying that an image for direct display on
+ * an sRGB conformant system should be stored with a gAMA chunk value of 45455
+ * (11.3.3.2 and 11.3.3.5 of the ISO PNG specification) the PNG specification
+ * makes it possible to derive values for other display systems and
+ * environments.
+ *
+ * The Mac value is deduced from the sRGB based on an assumption that the actual
+ * extra viewing correction used in early Mac display systems was implemented as
+ * a power 1.45 lookup table.
+ *
+ * Any system where a programmable lookup table is used or where the behavior of
+ * the final display device characteristics can be changed requires system
+ * specific code to obtain the current characteristic.  However this can be
+ * difficult and most PNG gamma correction only requires an approximate value.
+ *
+ * By default, if png_set_alpha_mode() is not called, libpng assumes that all
+ * values are unencoded, linear, values and that the output device also has a
+ * linear characteristic.  This is only very rarely correct - it is invariably
+ * better to call png_set_alpha_mode() with PNG_DEFAULT_sRGB than rely on the
+ * default if you don't know what the right answer is!
+ *
+ * The special value PNG_GAMMA_MAC_18 indicates an older Mac system (pre Mac OS
+ * 10.6) which used a correction table to implement a somewhat lower gamma on an
+ * otherwise sRGB system.
+ *
+ * Both these values are reserved (not simple gamma values) in order to allow
+ * more precise correction internally in the future.
+ *
+ * NOTE: the following values can be passed to either the fixed or floating
+ * point APIs, but the floating point API will also accept floating point
+ * values.
+ */
+#define PNG_DEFAULT_sRGB -1       /* sRGB gamma and color space */
+#define PNG_GAMMA_MAC_18 -2       /* Old Mac '1.8' gamma and color space */
+#define PNG_GAMMA_sRGB   220000   /* Television standards--matches sRGB gamma */
+#define PNG_GAMMA_LINEAR PNG_FP_1 /* Linear */
+#endif
+
+/* The following are examples of calls to png_set_alpha_mode to achieve the
+ * required overall gamma correction and, where necessary, alpha
+ * premultiplication.
+ *
+ * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
+ *    This is the default libpng handling of the alpha channel - it is not
+ *    pre-multiplied into the color components.  In addition the call states
+ *    that the output is for a sRGB system and causes all PNG files without gAMA
+ *    chunks to be assumed to be encoded using sRGB.
+ *
+ * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
+ *    In this case the output is assumed to be something like an sRGB conformant
+ *    display preceeded by a power-law lookup table of power 1.45.  This is how
+ *    early Mac systems behaved.
+ *
+ * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);
+ *    This is the classic Jim Blinn approach and will work in academic
+ *    environments where everything is done by the book.  It has the shortcoming
+ *    of assuming that input PNG data with no gamma information is linear - this
+ *    is unlikely to be correct unless the PNG files where generated locally.
+ *    Most of the time the output precision will be so low as to show
+ *    significant banding in dark areas of the image.
+ *
+ * png_set_expand_16(pp);
+ * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);
+ *    This is a somewhat more realistic Jim Blinn inspired approach.  PNG files
+ *    are assumed to have the sRGB encoding if not marked with a gamma value and
+ *    the output is always 16 bits per component.  This permits accurate scaling
+ *    and processing of the data.  If you know that your input PNG files were
+ *    generated locally you might need to replace PNG_DEFAULT_sRGB with the
+ *    correct value for your system.
+ *
+ * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);
+ *    If you just need to composite the PNG image onto an existing background
+ *    and if you control the code that does this you can use the optimization
+ *    setting.  In this case you just copy completely opaque pixels to the
+ *    output.  For pixels that are not completely transparent (you just skip
+ *    those) you do the composition math using png_composite or png_composite_16
+ *    below then encode the resultant 8-bit or 16-bit values to match the output
+ *    encoding.
+ *
+ * Other cases
+ *    If neither the PNG nor the standard linear encoding work for you because
+ *    of the software or hardware you use then you have a big problem.  The PNG
+ *    case will probably result in halos around the image.  The linear encoding
+ *    will probably result in a washed out, too bright, image (it's actually too
+ *    contrasty.)  Try the ALPHA_OPTIMIZED mode above - this will probably
+ *    substantially reduce the halos.  Alternatively try:
+ *
+ * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);
+ *    This option will also reduce the halos, but there will be slight dark
+ *    halos round the opaque parts of the image where the background is light.
+ *    In the OPTIMIZED mode the halos will be light halos where the background
+ *    is dark.  Take your pick - the halos are unavoidable unless you can get
+ *    your hardware/software fixed!  (The OPTIMIZED approach is slightly
+ *    faster.)
+ *
+ * When the default gamma of PNG files doesn't match the output gamma.
+ *    If you have PNG files with no gamma information png_set_alpha_mode allows
+ *    you to provide a default gamma, but it also sets the ouput gamma to the
+ *    matching value.  If you know your PNG files have a gamma that doesn't
+ *    match the output you can take advantage of the fact that
+ *    png_set_alpha_mode always sets the output gamma but only sets the PNG
+ *    default if it is not already set:
+ *
+ * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
+ * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
+ *    The first call sets both the default and the output gamma values, the
+ *    second call overrides the output gamma without changing the default.  This
+ *    is easier than achieving the same effect with png_set_gamma.  You must use
+ *    PNG_ALPHA_PNG for the first call - internal checking in png_set_alpha will
+ *    fire if more than one call to png_set_alpha_mode and png_set_background is
+ *    made in the same read operation, however multiple calls with PNG_ALPHA_PNG
+ *    are ignored.
+ */
 
 #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
 PNG_EXPORT(36, void, png_set_strip_alpha, (png_structp png_ptr));
@@ -1101,14 +1391,14 @@ PNG_EXPORT(38, void, png_set_invert_alpha, (png_structp png_ptr));
 
 #if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
 /* Add a filler byte to 8-bit Gray or 24-bit RGB images. */
-PNG_EXPORT(39, void, png_set_filler, (png_structp png_ptr, png_uint_32 filler, 
+PNG_EXPORT(39, void, png_set_filler, (png_structp png_ptr, png_uint_32 filler,
     int flags));
 /* The values of the PNG_FILLER_ defines should NOT be changed */
 #  define PNG_FILLER_BEFORE 0
 #  define PNG_FILLER_AFTER 1
 /* Add an alpha byte to 8-bit Gray or 24-bit RGB images. */
 PNG_EXPORT(40, void, png_set_add_alpha,
-    (png_structp png_ptr, png_uint_32 filler, 
+    (png_structp png_ptr, png_uint_32 filler,
     int flags));
 #endif /* PNG_READ_FILLER_SUPPORTED || PNG_WRITE_FILLER_SUPPORTED */
 
@@ -1151,12 +1441,16 @@ PNG_EXPORT(46, void, png_set_invert_mono, (png_structp png_ptr));
 #endif
 
 #ifdef PNG_READ_BACKGROUND_SUPPORTED
-/* Handle alpha and tRNS by replacing with a background color. */
-PNG_FP_EXPORT(47, void, png_set_background, (png_structp png_ptr, 
-    png_const_color_16p background_color, int background_gamma_code, 
+/* Handle alpha and tRNS by replacing with a background color.  Prior to
+ * libpng-1.5.4 this API must not be called before the PNG file header has been
+ * read.  Doing so will result in unexpected behavior and possible warnings or
+ * errors if the PNG file contains a bKGD chunk.
+ */
+PNG_FP_EXPORT(47, void, png_set_background, (png_structp png_ptr,
+    png_const_color_16p background_color, int background_gamma_code,
     int need_expand, double background_gamma));
 PNG_FIXED_EXPORT(215, void, png_set_background_fixed, (png_structp png_ptr,
-    png_const_color_16p background_color, int background_gamma_code, 
+    png_const_color_16p background_color, int background_gamma_code,
     int need_expand, png_fixed_point background_gamma));
 #endif
 #ifdef PNG_READ_BACKGROUND_SUPPORTED
@@ -1166,7 +1460,13 @@ PNG_FIXED_EXPORT(215, void, png_set_background_fixed, (png_structp png_ptr,
 #  define PNG_BACKGROUND_GAMMA_UNIQUE  3
 #endif
 
-#ifdef PNG_READ_16_TO_8_SUPPORTED
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+/* Scale a 16-bit depth file down to 8-bit, accurately. */
+PNG_EXPORT(229, void, png_set_scale_16, (png_structp png_ptr));
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+#define PNG_READ_16_TO_8 SUPPORTED /* Name prior to 1.5.4 */
 /* Strip the second byte of information from a 16-bit depth file. */
 PNG_EXPORT(48, void, png_set_strip_16, (png_structp png_ptr));
 #endif
@@ -1176,8 +1476,8 @@ PNG_EXPORT(48, void, png_set_strip_16, (png_structp png_ptr));
  * available.
  */
 PNG_EXPORT(49, void, png_set_quantize,
-    (png_structp png_ptr, png_colorp palette, 
-    int num_palette, int maximum_colors, png_const_uint_16p histogram, 
+    (png_structp png_ptr, png_colorp palette,
+    int num_palette, int maximum_colors, png_const_uint_16p histogram,
     int full_quantize));
 #endif
 
@@ -1187,12 +1487,22 @@ PNG_EXPORT(49, void, png_set_quantize,
  */
 #define PNG_GAMMA_THRESHOLD (PNG_GAMMA_THRESHOLD_FIXED*.00001)
 
-/* Handle gamma correction. Screen_gamma=(display_exponent) */
+/* Handle gamma correction. Screen_gamma=(display_exponent).
+ * NOTE: this API simply sets the screen and file gamma values. It will
+ * therefore override the value for gamma in a PNG file if it is called after
+ * the file header has been read - use with care  - call before reading the PNG
+ * file for best results!
+ *
+ * These routines accept the same gamma values as png_set_alpha_mode (described
+ * above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either
+ * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value
+ * is the inverse of a 'screen gamma' value.
+ */
 PNG_FP_EXPORT(50, void, png_set_gamma,
-    (png_structp png_ptr, double screen_gamma, 
-    double default_file_gamma));
-PNG_FIXED_EXPORT(208, void, png_set_gamma_fixed, (png_structp png_ptr, 
-    png_fixed_point screen_gamma, png_fixed_point default_file_gamma));
+    (png_structp png_ptr, double screen_gamma,
+    double override_file_gamma));
+PNG_FIXED_EXPORT(208, void, png_set_gamma_fixed, (png_structp png_ptr,
+    png_fixed_point screen_gamma, png_fixed_point override_file_gamma));
 #endif
 
 #ifdef PNG_WRITE_FLUSH_SUPPORTED
@@ -1211,13 +1521,13 @@ PNG_EXPORT(54, void, png_read_update_info,
 
 #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 /* Read one or more rows of image data. */
-PNG_EXPORT(55, void, png_read_rows, (png_structp png_ptr, png_bytepp row, 
+PNG_EXPORT(55, void, png_read_rows, (png_structp png_ptr, png_bytepp row,
     png_bytepp display_row, png_uint_32 num_rows));
 #endif
 
 #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
 /* Read a row of data. */
-PNG_EXPORT(56, void, png_read_row, (png_structp png_ptr, png_bytep row, 
+PNG_EXPORT(56, void, png_read_row, (png_structp png_ptr, png_bytep row,
     png_bytep display_row));
 #endif
 
@@ -1235,7 +1545,7 @@ PNG_EXPORT(58, void, png_write_row,
  * of libpng and to allow the 'display_row' array from read_rows to be passed
  * unchanged to write_rows.
  */
-PNG_EXPORT(59, void, png_write_rows, (png_structp png_ptr, png_bytepp row, 
+PNG_EXPORT(59, void, png_write_rows, (png_structp png_ptr, png_bytepp row,
     png_uint_32 num_rows));
 
 /* Write the image data */
@@ -1252,15 +1562,15 @@ PNG_EXPORT(62, void, png_read_end, (png_structp png_ptr, png_infop info_ptr));
 #endif
 
 /* Free any memory associated with the png_info_struct */
-PNG_EXPORT(63, void, png_destroy_info_struct, (png_structp png_ptr, 
+PNG_EXPORT(63, void, png_destroy_info_struct, (png_structp png_ptr,
     png_infopp info_ptr_ptr));
 
 /* Free any memory associated with the png_struct and the png_info_structs */
-PNG_EXPORT(64, void, png_destroy_read_struct, (png_structpp png_ptr_ptr, 
+PNG_EXPORT(64, void, png_destroy_read_struct, (png_structpp png_ptr_ptr,
     png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr));
 
 /* Free any memory associated with the png_struct and the png_info_structs */
-PNG_EXPORT(65, void, png_destroy_write_struct, (png_structpp png_ptr_ptr, 
+PNG_EXPORT(65, void, png_destroy_write_struct, (png_structpp png_ptr_ptr,
     png_infopp info_ptr_ptr));
 
 /* Set the libpng method of handling chunk CRC errors */
@@ -1270,7 +1580,7 @@ PNG_EXPORT(66, void, png_set_crc_action,
 /* Values for png_set_crc_action() say how to handle CRC errors in
  * ancillary and critical chunks, and whether to use the data contained
  * therein.  Note that it is impossible to "discard" data in a critical
- * chunk.  For versions prior to 0.90, the action was always error/quit, 
+ * chunk.  For versions prior to 0.90, the action was always error/quit,
  * whereas in version 0.90 and later, the action for CRC errors in ancillary
  * chunks is warn/discard.  These values should NOT be changed.
  *
@@ -1350,11 +1660,11 @@ PNG_EXPORT(67, void, png_set_filter,
  * the weights and costs are set to 1.0, this degenerates the WEIGHTED method
  * to the UNWEIGHTED method, but with added encoding time/computation.
  */
-PNG_FP_EXPORT(68, void, png_set_filter_heuristics, (png_structp png_ptr, 
-    int heuristic_method, int num_weights, png_const_doublep filter_weights, 
+PNG_FP_EXPORT(68, void, png_set_filter_heuristics, (png_structp png_ptr,
+    int heuristic_method, int num_weights, png_const_doublep filter_weights,
     png_const_doublep filter_costs));
 PNG_FIXED_EXPORT(209, void, png_set_filter_heuristics_fixed,
-    (png_structp png_ptr, 
+    (png_structp png_ptr,
     int heuristic_method, int num_weights, png_const_fixed_point_p
     filter_weights, png_const_fixed_point_p filter_costs));
 #endif /*  PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */
@@ -1367,30 +1677,56 @@ PNG_FIXED_EXPORT(209, void, png_set_filter_heuristics_fixed,
 #define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
 #define PNG_FILTER_HEURISTIC_LAST       3  /* Not a valid value */
 
+#ifdef PNG_WRITE_SUPPORTED
 /* Set the library compression level.  Currently, valid values range from
  * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
  * (0 - no compression, 9 - "maximal" compression).  Note that tests have
  * shown that zlib compression levels 3-6 usually perform as well as level 9
- * for PNG images, and do considerably fewer caclulations.  In the future, 
+ * for PNG images, and do considerably fewer caclulations.  In the future,
  * these values may not correspond directly to the zlib compression levels.
  */
 PNG_EXPORT(69, void, png_set_compression_level,
     (png_structp png_ptr, int level));
 
-PNG_EXPORT(70, void, png_set_compression_mem_level, (png_structp png_ptr, 
+PNG_EXPORT(70, void, png_set_compression_mem_level, (png_structp png_ptr,
     int mem_level));
 
-PNG_EXPORT(71, void, png_set_compression_strategy, (png_structp png_ptr, 
+PNG_EXPORT(71, void, png_set_compression_strategy, (png_structp png_ptr,
     int strategy));
 
-PNG_EXPORT(72, void, png_set_compression_window_bits, (png_structp png_ptr, 
+/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
+ * smaller value of window_bits if it can do so safely.
+ */
+PNG_EXPORT(72, void, png_set_compression_window_bits, (png_structp png_ptr,
     int window_bits));
 
 PNG_EXPORT(73, void, png_set_compression_method, (png_structp png_ptr,
     int method));
+#endif
+
+#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
+/* Also set zlib parameters for compressing non-IDAT chunks */
+PNG_EXPORT(222, void, png_set_text_compression_level,
+    (png_structp png_ptr, int level));
+
+PNG_EXPORT(223, void, png_set_text_compression_mem_level, (png_structp png_ptr,
+    int mem_level));
+
+PNG_EXPORT(224, void, png_set_text_compression_strategy, (png_structp png_ptr,
+    int strategy));
+
+/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
+ * smaller value of window_bits if it can do so safely.
+ */
+PNG_EXPORT(225, void, png_set_text_compression_window_bits, (png_structp
+    png_ptr, int window_bits));
+
+PNG_EXPORT(226, void, png_set_text_compression_method, (png_structp png_ptr,
+    int method));
+#endif /* PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED */
 
 /* These next functions are called for input/output, memory, and error
- * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c, 
+ * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
  * and call standard C I/O routines such as fread(), fwrite(), and
  * fprintf().  These functions can be made to use other I/O routines
  * at run time for those applications that need to handle I/O in a
@@ -1412,7 +1748,7 @@ PNG_EXPORT(74, void, png_init_io, (png_structp png_ptr, png_FILE_p fp));
  */
 
 PNG_EXPORT(75, void, png_set_error_fn,
-    (png_structp png_ptr, png_voidp error_ptr, 
+    (png_structp png_ptr, png_voidp error_ptr,
     png_error_ptr error_fn, png_error_ptr warning_fn));
 
 /* Return the user pointer associated with the error functions */
@@ -1428,43 +1764,43 @@ PNG_EXPORT(76, png_voidp, png_get_error_ptr, (png_const_structp png_ptr));
  * default flush function, which uses the standard *FILE structure, will
  * be used.
  */
-PNG_EXPORT(77, void, png_set_write_fn, (png_structp png_ptr, png_voidp io_ptr, 
+PNG_EXPORT(77, void, png_set_write_fn, (png_structp png_ptr, png_voidp io_ptr,
     png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn));
 
 /* Replace the default data input function with a user supplied one. */
-PNG_EXPORT(78, void, png_set_read_fn, (png_structp png_ptr, png_voidp io_ptr, 
+PNG_EXPORT(78, void, png_set_read_fn, (png_structp png_ptr, png_voidp io_ptr,
     png_rw_ptr read_data_fn));
 
 /* Return the user pointer associated with the I/O functions */
 PNG_EXPORT(79, png_voidp, png_get_io_ptr, (png_structp png_ptr));
 
-PNG_EXPORT(80, void, png_set_read_status_fn, (png_structp png_ptr, 
+PNG_EXPORT(80, void, png_set_read_status_fn, (png_structp png_ptr,
     png_read_status_ptr read_row_fn));
 
-PNG_EXPORT(81, void, png_set_write_status_fn, (png_structp png_ptr, 
+PNG_EXPORT(81, void, png_set_write_status_fn, (png_structp png_ptr,
     png_write_status_ptr write_row_fn));
 
 #ifdef PNG_USER_MEM_SUPPORTED
 /* Replace the default memory allocation functions with user supplied one(s). */
-PNG_EXPORT(82, void, png_set_mem_fn, (png_structp png_ptr, png_voidp mem_ptr, 
+PNG_EXPORT(82, void, png_set_mem_fn, (png_structp png_ptr, png_voidp mem_ptr,
     png_malloc_ptr malloc_fn, png_free_ptr free_fn));
 /* Return the user pointer associated with the memory functions */
 PNG_EXPORT(83, png_voidp, png_get_mem_ptr, (png_const_structp png_ptr));
 #endif
 
 #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-PNG_EXPORT(84, void, png_set_read_user_transform_fn, (png_structp png_ptr, 
+PNG_EXPORT(84, void, png_set_read_user_transform_fn, (png_structp png_ptr,
     png_user_transform_ptr read_user_transform_fn));
 #endif
 
 #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-PNG_EXPORT(85, void, png_set_write_user_transform_fn, (png_structp png_ptr, 
+PNG_EXPORT(85, void, png_set_write_user_transform_fn, (png_structp png_ptr,
     png_user_transform_ptr write_user_transform_fn));
 #endif
 
 #ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-PNG_EXPORT(86, void, png_set_user_transform_info, (png_structp png_ptr, 
-    png_voidp user_transform_ptr, int user_transform_depth, 
+PNG_EXPORT(86, void, png_set_user_transform_info, (png_structp png_ptr,
+    png_voidp user_transform_ptr, int user_transform_depth,
     int user_transform_channels));
 /* Return the user pointer associated with the user transform functions */
 PNG_EXPORT(87, png_voidp, png_get_user_transform_ptr,
@@ -1475,16 +1811,20 @@ PNG_EXPORT(87, png_voidp, png_get_user_transform_ptr,
 /* Return information about the row currently being processed.  Note that these
  * APIs do not fail but will return unexpected results if called outside a user
  * transform callback.  Also note that when transforming an interlaced image the
- * row number is still the row in the final, de-interlaced, image but the row
- * only contains the data of the current pass - consult png_row_info for the
- * actual width of the row!
+ * row number is the row number within the sub-image of the interlace pass, so
+ * the value will increase to the height of the sub-image (not the full image)
+ * then reset to 0 for the next pass.
+ *
+ * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
+ * find the output pixel (x,y) given an interlaced sub-image pixel
+ * (row,col,pass).  (See below for these macros.)
  */
 PNG_EXPORT(217, png_uint_32, png_get_current_row_number, (png_const_structp));
 PNG_EXPORT(218, png_byte, png_get_current_pass_number, (png_const_structp));
 #endif
 
 #ifdef PNG_USER_CHUNKS_SUPPORTED
-PNG_EXPORT(88, void, png_set_read_user_chunk_fn, (png_structp png_ptr, 
+PNG_EXPORT(88, void, png_set_read_user_chunk_fn, (png_structp png_ptr,
     png_voidp user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn));
 PNG_EXPORT(89, png_voidp, png_get_user_chunk_ptr, (png_const_structp png_ptr));
 #endif
@@ -1493,8 +1833,8 @@ PNG_EXPORT(89, png_voidp, png_get_user_chunk_ptr, (png_const_structp png_ptr));
 /* Sets the function callbacks for the push reader, and a pointer to a
  * user-defined structure available to the callback functions.
  */
-PNG_EXPORT(90, void, png_set_progressive_read_fn, (png_structp png_ptr, 
-    png_voidp progressive_ptr, png_progressive_info_ptr info_fn, 
+PNG_EXPORT(90, void, png_set_progressive_read_fn, (png_structp png_ptr,
+    png_voidp progressive_ptr, png_progressive_info_ptr info_fn,
     png_progressive_row_ptr row_fn, png_progressive_end_ptr end_fn));
 
 /* Returns the user pointer associated with the push read functions */
@@ -1502,7 +1842,7 @@ PNG_EXPORT(91, png_voidp, png_get_progressive_ptr, (png_const_structp png_ptr));
 
 /* Function to be called when data becomes available */
 PNG_EXPORT(92, void, png_process_data,
-    (png_structp png_ptr, png_infop info_ptr, 
+    (png_structp png_ptr, png_infop info_ptr,
     png_bytep buffer, png_size_t buffer_size));
 
 /* A function which may be called *only* within png_process_data to stop the
@@ -1522,25 +1862,27 @@ PNG_EXPORT(219, png_size_t, png_process_data_pause, (png_structp, int save));
  */
 PNG_EXPORT(220, png_uint_32, png_process_data_skip, (png_structp));
 
+#ifdef PNG_READ_INTERLACING_SUPPORTED
 /* Function that combines rows.  'new_row' is a flag that should come from
  * the callback and be non-NULL if anything needs to be done; the library
  * stores its own version of the new data internally and ignores the passed
  * in value.
  */
-PNG_EXPORT(93, void, png_progressive_combine_row, (png_structp png_ptr, 
+PNG_EXPORT(93, void, png_progressive_combine_row, (png_structp png_ptr,
     png_bytep old_row, png_const_bytep new_row));
+#endif /* PNG_READ_INTERLACING_SUPPORTED */
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 
 PNG_EXPORTA(94, png_voidp, png_malloc,
-    (png_structp png_ptr, png_alloc_size_t size), 
+    (png_structp png_ptr, png_alloc_size_t size),
     PNG_ALLOCATED);
 /* Added at libpng version 1.4.0 */
 PNG_EXPORTA(95, png_voidp, png_calloc,
-    (png_structp png_ptr, png_alloc_size_t size), 
+    (png_structp png_ptr, png_alloc_size_t size),
     PNG_ALLOCATED);
 
 /* Added at libpng version 1.2.4 */
-PNG_EXPORTA(96, png_voidp, png_malloc_warn, (png_structp png_ptr, 
+PNG_EXPORTA(96, png_voidp, png_malloc_warn, (png_structp png_ptr,
     png_alloc_size_t size), PNG_ALLOCATED);
 
 /* Frees a pointer allocated by png_malloc() */
@@ -1575,7 +1917,7 @@ PNG_EXPORT(99, void, png_data_freer,
 #define PNG_FREE_MUL  0x4220 /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */
 
 #ifdef PNG_USER_MEM_SUPPORTED
-PNG_EXPORTA(100, png_voidp, png_malloc_default, (png_structp png_ptr, 
+PNG_EXPORTA(100, png_voidp, png_malloc_default, (png_structp png_ptr,
     png_alloc_size_t size), PNG_ALLOCATED);
 PNG_EXPORT(101, void, png_free_default, (png_structp png_ptr, png_voidp ptr));
 #endif
@@ -1583,11 +1925,11 @@ PNG_EXPORT(101, void, png_free_default, (png_structp png_ptr, png_voidp ptr));
 #ifdef PNG_ERROR_TEXT_SUPPORTED
 /* Fatal error in PNG image of libpng - can't continue */
 PNG_EXPORTA(102, void, png_error,
-    (png_structp png_ptr, png_const_charp error_message), 
+    (png_structp png_ptr, png_const_charp error_message),
     PNG_NORETURN);
 
 /* The same, but the chunk name is prepended to the error string. */
-PNG_EXPORTA(103, void, png_chunk_error, (png_structp png_ptr, 
+PNG_EXPORTA(103, void, png_chunk_error, (png_structp png_ptr,
     png_const_charp error_message), PNG_NORETURN);
 
 #else
@@ -1595,24 +1937,26 @@ PNG_EXPORTA(103, void, png_chunk_error, (png_structp png_ptr,
 PNG_EXPORTA(104, void, png_err, (png_structp png_ptr), PNG_NORETURN);
 #endif
 
+#ifdef PNG_WARNINGS_SUPPORTED
 /* Non-fatal error in libpng.  Can continue, but may have a problem. */
-PNG_EXPORT(105, void, png_warning, (png_structp png_ptr, 
+PNG_EXPORT(105, void, png_warning, (png_structp png_ptr,
     png_const_charp warning_message));
 
 /* Non-fatal error in libpng, chunk name is prepended to message. */
-PNG_EXPORT(106, void, png_chunk_warning, (png_structp png_ptr, 
+PNG_EXPORT(106, void, png_chunk_warning, (png_structp png_ptr,
     png_const_charp warning_message));
+#endif
 
 #ifdef PNG_BENIGN_ERRORS_SUPPORTED
 /* Benign error in libpng.  Can continue, but may have a problem.
  * User can choose whether to handle as a fatal error or as a warning. */
 #  undef png_benign_error
-PNG_EXPORT(107, void, png_benign_error, (png_structp png_ptr, 
+PNG_EXPORT(107, void, png_benign_error, (png_structp png_ptr,
     png_const_charp warning_message));
 
 /* Same, chunk name is prepended to message. */
 #  undef png_chunk_benign_error
-PNG_EXPORT(108, void, png_chunk_benign_error, (png_structp png_ptr, 
+PNG_EXPORT(108, void, png_chunk_benign_error, (png_structp png_ptr,
     png_const_charp warning_message));
 
 PNG_EXPORT(109, void, png_set_benign_errors,
@@ -1641,11 +1985,11 @@ PNG_EXPORT(109, void, png_set_benign_errors,
  */
 /* Returns "flag" if chunk data is valid in info_ptr. */
 PNG_EXPORT(110, png_uint_32, png_get_valid,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     png_uint_32 flag));
 
 /* Returns number of bytes needed to hold a transformed row. */
-PNG_EXPORT(111, png_size_t, png_get_rowbytes, (png_const_structp png_ptr, 
+PNG_EXPORT(111, png_size_t, png_get_rowbytes, (png_const_structp png_ptr,
     png_const_infop info_ptr));
 
 #ifdef PNG_INFO_IMAGE_SUPPORTED
@@ -1667,11 +2011,11 @@ PNG_EXPORT(114, png_byte, png_get_channels,
 
 #ifdef PNG_EASY_ACCESS_SUPPORTED
 /* Returns image width in pixels. */
-PNG_EXPORT(115, png_uint_32, png_get_image_width, (png_const_structp png_ptr, 
+PNG_EXPORT(115, png_uint_32, png_get_image_width, (png_const_structp png_ptr,
     png_const_infop info_ptr));
 
 /* Returns image height in pixels. */
-PNG_EXPORT(116, png_uint_32, png_get_image_height, (png_const_structp png_ptr, 
+PNG_EXPORT(116, png_uint_32, png_get_image_height, (png_const_structp png_ptr,
     png_const_infop info_ptr));
 
 /* Returns image bit_depth. */
@@ -1679,19 +2023,19 @@ PNG_EXPORT(117, png_byte, png_get_bit_depth,
     (png_const_structp png_ptr, png_const_infop info_ptr));
 
 /* Returns image color_type. */
-PNG_EXPORT(118, png_byte, png_get_color_type, (png_const_structp png_ptr, 
+PNG_EXPORT(118, png_byte, png_get_color_type, (png_const_structp png_ptr,
     png_const_infop info_ptr));
 
 /* Returns image filter_type. */
-PNG_EXPORT(119, png_byte, png_get_filter_type, (png_const_structp png_ptr, 
+PNG_EXPORT(119, png_byte, png_get_filter_type, (png_const_structp png_ptr,
     png_const_infop info_ptr));
 
 /* Returns image interlace_type. */
-PNG_EXPORT(120, png_byte, png_get_interlace_type, (png_const_structp png_ptr, 
+PNG_EXPORT(120, png_byte, png_get_interlace_type, (png_const_structp png_ptr,
     png_const_infop info_ptr));
 
 /* Returns image compression_type. */
-PNG_EXPORT(121, png_byte, png_get_compression_type, (png_const_structp png_ptr, 
+PNG_EXPORT(121, png_byte, png_get_compression_type, (png_const_structp png_ptr,
     png_const_infop info_ptr));
 
 /* Returns image resolution in pixels per meter, from pHYs chunk data. */
@@ -1705,7 +2049,7 @@ PNG_EXPORT(124, png_uint_32, png_get_y_pixels_per_meter,
 /* Returns pixel aspect ratio, computed from pHYs chunk data.  */
 PNG_FP_EXPORT(125, float, png_get_pixel_aspect_ratio,
     (png_const_structp png_ptr, png_const_infop info_ptr));
-PNG_FIXED_EXPORT(210, png_fixed_point, png_get_pixel_aspect_ratio_fixed, 
+PNG_FIXED_EXPORT(210, png_fixed_point, png_get_pixel_aspect_ratio_fixed,
     (png_const_structp png_ptr, png_const_infop info_ptr));
 
 /* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
@@ -1726,47 +2070,68 @@ PNG_EXPORT(130, png_const_bytep, png_get_signature,
 
 #ifdef PNG_bKGD_SUPPORTED
 PNG_EXPORT(131, png_uint_32, png_get_bKGD,
-    (png_const_structp png_ptr, png_infop info_ptr, 
+    (png_const_structp png_ptr, png_infop info_ptr,
     png_color_16p *background));
 #endif
 
 #ifdef PNG_bKGD_SUPPORTED
-PNG_EXPORT(132, void, png_set_bKGD, (png_structp png_ptr, png_infop info_ptr, 
+PNG_EXPORT(132, void, png_set_bKGD, (png_structp png_ptr, png_infop info_ptr,
     png_const_color_16p background));
 #endif
 
 #ifdef PNG_cHRM_SUPPORTED
-PNG_FP_EXPORT(133, png_uint_32, png_get_cHRM, (png_const_structp png_ptr, 
-   png_const_infop info_ptr, double *white_x, double *white_y, double *red_x, 
-    double *red_y, double *green_x, double *green_y, double *blue_x, 
+PNG_FP_EXPORT(133, png_uint_32, png_get_cHRM, (png_const_structp png_ptr,
+   png_const_infop info_ptr, double *white_x, double *white_y, double *red_x,
+    double *red_y, double *green_x, double *green_y, double *blue_x,
     double *blue_y));
+PNG_FP_EXPORT(230, png_uint_32, png_get_cHRM_XYZ, (png_structp png_ptr,
+    png_const_infop info_ptr, double *red_X, double *red_Y, double *red_Z,
+    double *green_X, double *green_Y, double *green_Z, double *blue_X,
+    double *blue_Y, double *blue_Z));
 #ifdef PNG_FIXED_POINT_SUPPORTED /* Otherwise not implemented */
 PNG_FIXED_EXPORT(134, png_uint_32, png_get_cHRM_fixed,
-    (png_const_structp png_ptr, 
-    png_const_infop info_ptr, png_fixed_point *int_white_x, 
-    png_fixed_point *int_white_y, png_fixed_point *int_red_x, 
-    png_fixed_point *int_red_y, png_fixed_point *int_green_x, 
-    png_fixed_point *int_green_y, png_fixed_point *int_blue_x, 
+    (png_const_structp png_ptr,
+    png_const_infop info_ptr, png_fixed_point *int_white_x,
+    png_fixed_point *int_white_y, png_fixed_point *int_red_x,
+    png_fixed_point *int_red_y, png_fixed_point *int_green_x,
+    png_fixed_point *int_green_y, png_fixed_point *int_blue_x,
     png_fixed_point *int_blue_y));
 #endif
+PNG_FIXED_EXPORT(231, png_uint_32, png_get_cHRM_XYZ_fixed,
+    (png_structp png_ptr, png_const_infop info_ptr,
+    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
+    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
+    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
+    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
+    png_fixed_point *int_blue_Z));
 #endif
 
 #ifdef PNG_cHRM_SUPPORTED
 PNG_FP_EXPORT(135, void, png_set_cHRM,
-    (png_structp png_ptr, png_infop info_ptr, 
-    double white_x, double white_y, double red_x, double red_y, double green_x, 
+    (png_structp png_ptr, png_infop info_ptr,
+    double white_x, double white_y, double red_x, double red_y, double green_x,
     double green_y, double blue_x, double blue_y));
-PNG_FIXED_EXPORT(136, void, png_set_cHRM_fixed, (png_structp png_ptr, 
-    png_infop info_ptr, png_fixed_point int_white_x, 
-    png_fixed_point int_white_y, png_fixed_point int_red_x, 
-    png_fixed_point int_red_y, png_fixed_point int_green_x, 
-    png_fixed_point int_green_y, png_fixed_point int_blue_x, 
+PNG_FP_EXPORT(232, void, png_set_cHRM_XYZ, (png_structp png_ptr,
+    png_infop info_ptr, double red_X, double red_Y, double red_Z,
+    double green_X, double green_Y, double green_Z, double blue_X,
+    double blue_Y, double blue_Z));
+PNG_FIXED_EXPORT(136, void, png_set_cHRM_fixed, (png_structp png_ptr,
+    png_infop info_ptr, png_fixed_point int_white_x,
+    png_fixed_point int_white_y, png_fixed_point int_red_x,
+    png_fixed_point int_red_y, png_fixed_point int_green_x,
+    png_fixed_point int_green_y, png_fixed_point int_blue_x,
     png_fixed_point int_blue_y));
+PNG_FIXED_EXPORT(233, void, png_set_cHRM_XYZ_fixed, (png_structp png_ptr,
+    png_infop info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,
+    png_fixed_point int_red_Z, png_fixed_point int_green_X,
+    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
+    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
+    png_fixed_point int_blue_Z));
 #endif
 
 #ifdef PNG_gAMA_SUPPORTED
 PNG_FP_EXPORT(137, png_uint_32, png_get_gAMA,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     double *file_gamma));
 PNG_FIXED_EXPORT(138, png_uint_32, png_get_gAMA_fixed,
     (png_const_structp png_ptr, png_const_infop info_ptr,
@@ -1776,13 +2141,13 @@ PNG_FIXED_EXPORT(138, png_uint_32, png_get_gAMA_fixed,
 #ifdef PNG_gAMA_SUPPORTED
 PNG_FP_EXPORT(139, void, png_set_gAMA, (png_structp png_ptr,
     png_infop info_ptr, double file_gamma));
-PNG_FIXED_EXPORT(140, void, png_set_gAMA_fixed, (png_structp png_ptr, 
+PNG_FIXED_EXPORT(140, void, png_set_gAMA_fixed, (png_structp png_ptr,
     png_infop info_ptr, png_fixed_point int_file_gamma));
 #endif
 
 #ifdef PNG_hIST_SUPPORTED
 PNG_EXPORT(141, png_uint_32, png_get_hIST,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     png_uint_16p *hist));
 #endif
 
@@ -1792,65 +2157,65 @@ PNG_EXPORT(142, void, png_set_hIST, (png_structp png_ptr,
 #endif
 
 PNG_EXPORT(143, png_uint_32, png_get_IHDR,
-    (png_structp png_ptr, png_infop info_ptr, 
-    png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, 
+    (png_structp png_ptr, png_infop info_ptr,
+    png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type,
     int *interlace_method, int *compression_method, int *filter_method));
 
 PNG_EXPORT(144, void, png_set_IHDR,
-    (png_structp png_ptr, png_infop info_ptr, 
-    png_uint_32 width, png_uint_32 height, int bit_depth, int color_type, 
+    (png_structp png_ptr, png_infop info_ptr,
+    png_uint_32 width, png_uint_32 height, int bit_depth, int color_type,
     int interlace_method, int compression_method, int filter_method));
 
 #ifdef PNG_oFFs_SUPPORTED
 PNG_EXPORT(145, png_uint_32, png_get_oFFs,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type));
 #endif
 
 #ifdef PNG_oFFs_SUPPORTED
 PNG_EXPORT(146, void, png_set_oFFs,
-    (png_structp png_ptr, png_infop info_ptr, 
+    (png_structp png_ptr, png_infop info_ptr,
     png_int_32 offset_x, png_int_32 offset_y, int unit_type));
 #endif
 
 #ifdef PNG_pCAL_SUPPORTED
 PNG_EXPORT(147, png_uint_32, png_get_pCAL,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type,
-    int *nparams, 
+    int *nparams,
     png_charp *units, png_charpp *params));
 #endif
 
 #ifdef PNG_pCAL_SUPPORTED
 PNG_EXPORT(148, void, png_set_pCAL, (png_structp png_ptr,
-    png_infop info_ptr, 
-    png_const_charp purpose, png_int_32 X0, png_int_32 X1, int type, 
+    png_infop info_ptr,
+    png_const_charp purpose, png_int_32 X0, png_int_32 X1, int type,
     int nparams, png_const_charp units, png_charpp params));
 #endif
 
 #ifdef PNG_pHYs_SUPPORTED
 PNG_EXPORT(149, png_uint_32, png_get_pHYs,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type));
 #endif
 
 #ifdef PNG_pHYs_SUPPORTED
 PNG_EXPORT(150, void, png_set_pHYs,
-    (png_structp png_ptr, png_infop info_ptr, 
+    (png_structp png_ptr, png_infop info_ptr,
     png_uint_32 res_x, png_uint_32 res_y, int unit_type));
 #endif
 
 PNG_EXPORT(151, png_uint_32, png_get_PLTE,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     png_colorp *palette, int *num_palette));
 
 PNG_EXPORT(152, void, png_set_PLTE,
-    (png_structp png_ptr, png_infop info_ptr, 
+    (png_structp png_ptr, png_infop info_ptr,
     png_const_colorp palette, int num_palette));
 
 #ifdef PNG_sBIT_SUPPORTED
 PNG_EXPORT(153, png_uint_32, png_get_sBIT,
-    (png_const_structp png_ptr, png_infop info_ptr, 
+    (png_const_structp png_ptr, png_infop info_ptr,
     png_color_8p *sig_bit));
 #endif
 
@@ -1867,44 +2232,44 @@ PNG_EXPORT(155, png_uint_32, png_get_sRGB, (png_const_structp png_ptr,
 #ifdef PNG_sRGB_SUPPORTED
 PNG_EXPORT(156, void, png_set_sRGB,
     (png_structp png_ptr, png_infop info_ptr, int srgb_intent));
-PNG_EXPORT(157, void, png_set_sRGB_gAMA_and_cHRM, (png_structp png_ptr, 
+PNG_EXPORT(157, void, png_set_sRGB_gAMA_and_cHRM, (png_structp png_ptr,
     png_infop info_ptr, int srgb_intent));
 #endif
 
 #ifdef PNG_iCCP_SUPPORTED
 PNG_EXPORT(158, png_uint_32, png_get_iCCP,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
-    png_charpp name, int *compression_type, png_bytepp profile, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
+    png_charpp name, int *compression_type, png_bytepp profile,
     png_uint_32 *proflen));
 #endif
 
 #ifdef PNG_iCCP_SUPPORTED
 PNG_EXPORT(159, void, png_set_iCCP,
-    (png_structp png_ptr, png_infop info_ptr, 
-    png_const_charp name, int compression_type, png_const_bytep profile, 
+    (png_structp png_ptr, png_infop info_ptr,
+    png_const_charp name, int compression_type, png_const_bytep profile,
     png_uint_32 proflen));
 #endif
 
 #ifdef PNG_sPLT_SUPPORTED
 PNG_EXPORT(160, png_uint_32, png_get_sPLT,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     png_sPLT_tpp entries));
 #endif
 
 #ifdef PNG_sPLT_SUPPORTED
 PNG_EXPORT(161, void, png_set_sPLT,
-    (png_structp png_ptr, png_infop info_ptr, 
+    (png_structp png_ptr, png_infop info_ptr,
     png_const_sPLT_tp entries, int nentries));
 #endif
 
 #ifdef PNG_TEXT_SUPPORTED
 /* png_get_text also returns the number of text chunks in *num_text */
 PNG_EXPORT(162, png_uint_32, png_get_text,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     png_textp *text_ptr, int *num_text));
 #endif
 
-/* Note while png_set_text() will accept a structure whose text, 
+/* Note while png_set_text() will accept a structure whose text,
  * language, and  translated keywords are NULL pointers, the structure
  * returned by png_get_text will always contain regular
  * zero-terminated C strings.  They might be empty strings but
@@ -1913,7 +2278,7 @@ PNG_EXPORT(162, png_uint_32, png_get_text,
 
 #ifdef PNG_TEXT_SUPPORTED
 PNG_EXPORT(163, void, png_set_text,
-    (png_structp png_ptr, png_infop info_ptr, 
+    (png_structp png_ptr, png_infop info_ptr,
     png_const_textp text_ptr, int num_text));
 #endif
 
@@ -1929,30 +2294,30 @@ PNG_EXPORT(165, void, png_set_tIME,
 
 #ifdef PNG_tRNS_SUPPORTED
 PNG_EXPORT(166, png_uint_32, png_get_tRNS,
-    (png_const_structp png_ptr, png_infop info_ptr, 
+    (png_const_structp png_ptr, png_infop info_ptr,
     png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color));
 #endif
 
 #ifdef PNG_tRNS_SUPPORTED
 PNG_EXPORT(167, void, png_set_tRNS,
-    (png_structp png_ptr, png_infop info_ptr, 
-    png_const_bytep trans_alpha, int num_trans, 
+    (png_structp png_ptr, png_infop info_ptr,
+    png_const_bytep trans_alpha, int num_trans,
     png_const_color_16p trans_color));
 #endif
 
 #ifdef PNG_sCAL_SUPPORTED
 PNG_FP_EXPORT(168, png_uint_32, png_get_sCAL,
-    (png_const_structp png_ptr, png_const_infop info_ptr, 
+    (png_const_structp png_ptr, png_const_infop info_ptr,
     int *unit, double *width, double *height));
 #ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-/* NOTE: this API is currently implemented using floating point arithmetic, 
+/* NOTE: this API is currently implemented using floating point arithmetic,
  * consequently it can only be used on systems with floating point support.
  * In any case the range of values supported by png_fixed_point is small and it
  * is highly recommended that png_get_sCAL_s be used instead.
  */
 PNG_FIXED_EXPORT(214, png_uint_32, png_get_sCAL_fixed,
     (png_structp png_ptr, png_const_infop info_ptr, int *unit,
-    png_fixed_point *width, 
+    png_fixed_point *width,
     png_fixed_point *height));
 #endif
 PNG_EXPORT(169, png_uint_32, png_get_sCAL_s,
@@ -1960,13 +2325,13 @@ PNG_EXPORT(169, png_uint_32, png_get_sCAL_s,
     int *unit, png_charpp swidth, png_charpp sheight));
 
 PNG_FP_EXPORT(170, void, png_set_sCAL,
-    (png_structp png_ptr, png_infop info_ptr, 
+    (png_structp png_ptr, png_infop info_ptr,
     int unit, double width, double height));
-PNG_FIXED_EXPORT(213, void, png_set_sCAL_fixed, (png_structp png_ptr, 
-   png_infop info_ptr, int unit, png_fixed_point width, 
+PNG_FIXED_EXPORT(213, void, png_set_sCAL_fixed, (png_structp png_ptr,
+   png_infop info_ptr, int unit, png_fixed_point width,
    png_fixed_point height));
 PNG_EXPORT(171, void, png_set_sCAL_s,
-    (png_structp png_ptr, png_infop info_ptr, 
+    (png_structp png_ptr, png_infop info_ptr,
     int unit, png_const_charp swidth, png_const_charp sheight));
 #endif /* PNG_sCAL_SUPPORTED */
 
@@ -1974,30 +2339,36 @@ PNG_EXPORT(171, void, png_set_sCAL_s,
 /* Provide a list of chunks and how they are to be handled, if the built-in
    handling or default unknown chunk handling is not desired.  Any chunks not
    listed will be handled in the default manner.  The IHDR and IEND chunks
-   must not be listed.
-      keep = 0: follow default behaviour
-           = 1: do not keep
-           = 2: keep only if safe-to-copy
-           = 3: keep even if unsafe-to-copy
+   must not be listed.  Because this turns off the default handling for chunks
+   that would otherwise be recognized the behavior of libpng transformations may
+   well become incorrect!
+      keep = 0: PNG_HANDLE_CHUNK_AS_DEFAULT: follow default behavior
+           = 1: PNG_HANDLE_CHUNK_NEVER:      do not keep
+           = 2: PNG_HANDLE_CHUNK_IF_SAFE:    keep only if safe-to-copy
+           = 3: PNG_HANDLE_CHUNK_ALWAYS:     keep even if unsafe-to-copy
 */
 PNG_EXPORT(172, void, png_set_keep_unknown_chunks,
-    (png_structp png_ptr, int keep, 
+    (png_structp png_ptr, int keep,
     png_const_bytep chunk_list, int num_chunks));
-PNG_EXPORT(173, int, png_handle_as_unknown, (png_structp png_ptr, 
+
+/* The handling code is returned; the result is therefore true (non-zero) if
+ * special handling is required, false for the default handling.
+ */
+PNG_EXPORT(173, int, png_handle_as_unknown, (png_structp png_ptr,
     png_const_bytep chunk_name));
 #endif
 #ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-PNG_EXPORT(174, void, png_set_unknown_chunks, (png_structp png_ptr, 
+PNG_EXPORT(174, void, png_set_unknown_chunks, (png_structp png_ptr,
     png_infop info_ptr, png_const_unknown_chunkp unknowns,
     int num_unknowns));
 PNG_EXPORT(175, void, png_set_unknown_chunk_location,
     (png_structp png_ptr, png_infop info_ptr, int chunk, int location));
-PNG_EXPORT(176, int, png_get_unknown_chunks, (png_const_structp png_ptr, 
+PNG_EXPORT(176, int, png_get_unknown_chunks, (png_const_structp png_ptr,
     png_const_infop info_ptr, png_unknown_chunkpp entries));
 #endif
 
 /* Png_free_data() will turn off the "valid" flag for anything it frees.
- * If you need to turn it off for a chunk that your application has freed, 
+ * If you need to turn it off for a chunk that your application has freed,
  * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);
  */
 PNG_EXPORT(177, void, png_set_invalid,
@@ -2005,9 +2376,9 @@ PNG_EXPORT(177, void, png_set_invalid,
 
 #ifdef PNG_INFO_IMAGE_SUPPORTED
 /* The "params" pointer is currently not used and is for future expansion. */
-PNG_EXPORT(178, void, png_read_png, (png_structp png_ptr, png_infop info_ptr, 
+PNG_EXPORT(178, void, png_read_png, (png_structp png_ptr, png_infop info_ptr,
     int transforms, png_voidp params));
-PNG_EXPORT(179, void, png_write_png, (png_structp png_ptr, png_infop info_ptr, 
+PNG_EXPORT(179, void, png_write_png, (png_structp png_ptr, png_infop info_ptr,
     int transforms, png_voidp params));
 #endif
 
@@ -2021,7 +2392,7 @@ PNG_EXPORT(183, png_const_charp, png_get_libpng_ver,
     (png_const_structp png_ptr));
 
 #ifdef PNG_MNG_FEATURES_SUPPORTED
-PNG_EXPORT(184, png_uint_32, png_permit_mng_features, (png_structp png_ptr, 
+PNG_EXPORT(184, png_uint_32, png_permit_mng_features, (png_structp png_ptr,
     png_uint_32 mng_features_permitted));
 #endif
 
@@ -2036,25 +2407,25 @@ PNG_EXPORT(184, png_uint_32, png_permit_mng_features, (png_structp png_ptr,
  */
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
 PNG_EXPORT(185, void, png_set_strip_error_numbers,
-    (png_structp png_ptr, 
+    (png_structp png_ptr,
     png_uint_32 strip_mode));
 #endif
 
 /* Added in libpng-1.2.6 */
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
-PNG_EXPORT(186, void, png_set_user_limits, (png_structp png_ptr, 
+PNG_EXPORT(186, void, png_set_user_limits, (png_structp png_ptr,
     png_uint_32 user_width_max, png_uint_32 user_height_max));
 PNG_EXPORT(187, png_uint_32, png_get_user_width_max,
     (png_const_structp png_ptr));
 PNG_EXPORT(188, png_uint_32, png_get_user_height_max,
     (png_const_structp png_ptr));
 /* Added in libpng-1.4.0 */
-PNG_EXPORT(189, void, png_set_chunk_cache_max, (png_structp png_ptr, 
+PNG_EXPORT(189, void, png_set_chunk_cache_max, (png_structp png_ptr,
     png_uint_32 user_chunk_cache_max));
 PNG_EXPORT(190, png_uint_32, png_get_chunk_cache_max,
     (png_const_structp png_ptr));
 /* Added in libpng-1.4.1 */
-PNG_EXPORT(191, void, png_set_chunk_malloc_max, (png_structp png_ptr, 
+PNG_EXPORT(191, void, png_set_chunk_malloc_max, (png_structp png_ptr,
     png_alloc_size_t user_chunk_cache_max));
 PNG_EXPORT(192, png_alloc_size_t, png_get_chunk_malloc_max,
     (png_const_structp png_ptr));
@@ -2073,19 +2444,19 @@ PNG_EXPORT(195, png_uint_32, png_get_y_pixels_per_inch,
 PNG_FP_EXPORT(196, float, png_get_x_offset_inches,
     (png_const_structp png_ptr, png_const_infop info_ptr));
 #ifdef PNG_FIXED_POINT_SUPPORTED /* otherwise not implemented. */
-PNG_FIXED_EXPORT(211, png_fixed_point, png_get_x_offset_inches_fixed, 
+PNG_FIXED_EXPORT(211, png_fixed_point, png_get_x_offset_inches_fixed,
     (png_structp png_ptr, png_const_infop info_ptr));
 #endif
 
-PNG_FP_EXPORT(197, float, png_get_y_offset_inches, (png_const_structp png_ptr, 
+PNG_FP_EXPORT(197, float, png_get_y_offset_inches, (png_const_structp png_ptr,
     png_const_infop info_ptr));
 #ifdef PNG_FIXED_POINT_SUPPORTED /* otherwise not implemented. */
-PNG_FIXED_EXPORT(212, png_fixed_point, png_get_y_offset_inches_fixed, 
+PNG_FIXED_EXPORT(212, png_fixed_point, png_get_y_offset_inches_fixed,
     (png_structp png_ptr, png_const_infop info_ptr));
 #endif
 
 #  ifdef PNG_pHYs_SUPPORTED
-PNG_EXPORT(198, png_uint_32, png_get_pHYs_dpi, (png_const_structp png_ptr, 
+PNG_EXPORT(198, png_uint_32, png_get_pHYs_dpi, (png_const_structp png_ptr,
     png_const_infop info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
     int *unit_type));
 #  endif /* PNG_pHYs_SUPPORTED */
@@ -2122,8 +2493,16 @@ PNG_EXPORT(216, png_uint_32, png_get_io_chunk_type,
  * full, image which appears in a given pass.  'pass' is in the range 0
  * to 6 and the result is in the range 0 to 7.
  */
-#define PNG_PASS_START_ROW(pass) (((1U&~(pass))<<(3-((pass)>>1)))&7)
-#define PNG_PASS_START_COL(pass) (((1U& (pass))<<(3-(((pass)+1)>>1)))&7)
+#define PNG_PASS_START_ROW(pass) (((1&~(pass))<<(3-((pass)>>1)))&7)
+#define PNG_PASS_START_COL(pass) (((1& (pass))<<(3-(((pass)+1)>>1)))&7)
+
+/* A macro to return the offset between pixels in the output row for a pair of
+ * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that
+ * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas
+ * COL_OFFSET is from one column to the next, within a row.
+ */
+#define PNG_PASS_ROW_OFFSET(pass) ((pass)>2?(8>>(((pass)-1)>>1)):8)
+#define PNG_PASS_COL_OFFSET(pass) (1<<((7-(pass))>>1))
 
 /* Two macros to help evaluate the number of rows or columns in each
  * pass.  This is expressed as a shift - effectively log2 of the number or
@@ -2142,8 +2521,9 @@ PNG_EXPORT(216, png_uint_32, png_get_io_chunk_type,
 #define PNG_PASS_COLS(width, pass) (((width)+(((1<<PNG_PASS_COL_SHIFT(pass))\
    -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))
 
-/* For the progressive reader it is necessary to find the row in the output
- * image given a row in an interlaced image, so two more macros:
+/* For the reader row callbacks (both progressive and sequential) it is
+ * necessary to find the row in the output image given a row in an interlaced
+ * image, so two more macros:
  */
 #define PNG_ROW_FROM_PASS_ROW(yIn, pass) \
    (((yIn)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
@@ -2157,8 +2537,8 @@ PNG_EXPORT(216, png_uint_32, png_get_io_chunk_type,
  * the tile.
  */
 #define PNG_PASS_MASK(pass,off) ( \
-   ((0x110145AFU>>(((7-(off))-(pass))<<2)) & 0xFU) | \
-   ((0x01145AF0U>>(((7-(off))-(pass))<<2)) & 0xF0U))
+   ((0x110145AF>>(((7-(off))-(pass))<<2)) & 0xF) | \
+   ((0x01145AF0>>(((7-(off))-(pass))<<2)) & 0xF0))
 
 #define PNG_ROW_IN_INTERLACE_PASS(y, pass) \
    ((PNG_PASS_MASK(pass,0) >> ((y)&7)) & 1)
@@ -2184,14 +2564,14 @@ PNG_EXPORT(216, png_uint_32, png_get_io_chunk_type,
      { png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
            * (png_uint_16)(alpha)                         \
            + (png_uint_16)(bg)*(png_uint_16)(255          \
-           - (png_uint_16)(alpha)) + (png_uint_16)128);   \
+           - (png_uint_16)(alpha)) + 128);                \
        (composite) = (png_byte)((temp + (temp >> 8)) >> 8); }
 
 #  define png_composite_16(composite, fg, alpha, bg)       \
      { png_uint_32 temp = (png_uint_32)((png_uint_32)(fg)  \
            * (png_uint_32)(alpha)                          \
-           + (png_uint_32)(bg)*(png_uint_32)(65535L        \
-           - (png_uint_32)(alpha)) + (png_uint_32)32768L); \
+           + (png_uint_32)(bg)*(65535                      \
+           - (png_uint_32)(alpha)) + 32768);               \
        (composite) = (png_uint_16)((temp + (temp >> 16)) >> 16); }
 
 #else  /* Standard method using integer division */
@@ -2199,12 +2579,12 @@ PNG_EXPORT(216, png_uint_32, png_get_io_chunk_type,
 #  define png_composite(composite, fg, alpha, bg)                          \
      (composite) = (png_byte)(((png_uint_16)(fg) * (png_uint_16)(alpha) +  \
      (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) +       \
-     (png_uint_16)127) / 255)
+     127) / 255)
 
 #  define png_composite_16(composite, fg, alpha, bg)                         \
      (composite) = (png_uint_16)(((png_uint_32)(fg) * (png_uint_32)(alpha) + \
-     (png_uint_32)(bg)*(png_uint_32)(65535L - (png_uint_32)(alpha)) +        \
-     (png_uint_32)32767) / (png_uint_32)65535L)
+     (png_uint_32)(bg)*(png_uint_32)(65535 - (png_uint_32)(alpha)) +         \
+     32767) / 65535)
 #endif /* PNG_READ_COMPOSITE_NODIV_SUPPORTED */
 
 #ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED
@@ -2213,7 +2593,7 @@ PNG_EXPORT(202, png_uint_16, png_get_uint_16, (png_const_bytep buf));
 PNG_EXPORT(203, png_int_32, png_get_int_32, (png_const_bytep buf));
 #endif
 
-PNG_EXPORT(204, png_uint_32, png_get_uint_31, (png_structp png_ptr, 
+PNG_EXPORT(204, png_uint_32, png_get_uint_31, (png_structp png_ptr,
     png_const_bytep buf));
 /* No png_get_int_16 -- may be added if there's a real need for it. */
 
@@ -2226,7 +2606,7 @@ PNG_EXPORT(206, void, png_save_int_32, (png_bytep buf, png_int_32 i));
 #endif
 
 /* Place a 16-bit number into a buffer in PNG byte order.
- * The parameter is declared unsigned int, not png_uint_16, 
+ * The parameter is declared unsigned int, not png_uint_16,
  * just to avoid potential problems on pre-ANSI C compilers.
  */
 #ifdef PNG_WRITE_INT_FUNCTIONS_SUPPORTED
@@ -2259,6 +2639,12 @@ PNG_EXPORT(207, void, png_save_uint_16, (png_bytep buf, unsigned int i));
       : (png_int_32)png_get_uint_32(buf)))
 #endif
 
+#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
+    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
+PNG_EXPORT(234, void, png_set_check_for_invalid_index, (png_structp png_ptr,
+    int allowed));
+#endif
+
 /* Maintainer: Put new public prototypes here ^, in libpng.3, and project
  * defs
  */
@@ -2268,7 +2654,7 @@ PNG_EXPORT(207, void, png_save_uint_16, (png_bytep buf, unsigned int i));
  * scripts/symbols.def as well.
  */
 #ifdef PNG_EXPORT_LAST_ORDINAL
-  PNG_EXPORT_LAST_ORDINAL(220);
+  PNG_EXPORT_LAST_ORDINAL(234);
 #endif
 
 #ifdef __cplusplus
diff --git a/src/3rdparty/libpng/pngconf.h b/src/3rdparty/libpng/pngconf.h
index dd7ebba..bbb547f 100644
--- a/src/3rdparty/libpng/pngconf.h
+++ b/src/3rdparty/libpng/pngconf.h
@@ -1,9 +1,9 @@
 
 /* pngconf.h - machine configurable file for libpng
  *
- * libpng version 1.5.1 - February 3, 2011
+ * libpng version 1.5.10 - March 29, 2012
  *
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -22,35 +22,37 @@
 #ifndef PNGCONF_H
 #define PNGCONF_H
 
+#ifndef PNG_BUILDING_SYMBOL_TABLE
 /* PNG_NO_LIMITS_H may be used to turn off the use of the standard C
  * definition file for  machine specific limits, this may impact the
  * correctness of the definitons below (see uses of INT_MAX).
  */
-#ifndef PNG_NO_LIMITS_H
-#  include <limits.h>
-#endif
+#  ifndef PNG_NO_LIMITS_H
+#    include <limits.h>
+#  endif
 
 /* For the memory copy APIs (i.e. the standard definitions of these),
  * because this file defines png_memcpy and so on the base APIs must
  * be defined here.
  */
-#if defined(BSD) && !defined(VXWORKS)
-#  include <strings.h>
-#else
-#  include <string.h>
-#endif
+#  ifdef BSD
+#    include <strings.h>
+#  else
+#    include <string.h>
+#  endif
 
 /* For png_FILE_p - this provides the standard definition of a
  * FILE
  */
-#ifdef PNG_STDIO_SUPPORTED
-#  include <stdio.h>
+#  ifdef PNG_STDIO_SUPPORTED
+#    include <stdio.h>
+#  endif
 #endif
 
 /* This controls optimization of the reading of 16 and 32 bit values
  * from PNG files.  It can be set on a per-app-file basis - it
- * just changes whether a macro is used to the function is called.
- * The library builder sets the default, if read functions are not
+ * just changes whether a macro is used when the function is called.
+ * The library builder sets the default; if read functions are not
  * built into the library the macro implementation is forced on.
  */
 #ifndef PNG_READ_INT_FUNCTIONS_SUPPORTED
@@ -162,7 +164,9 @@
  *                       'type', compiler specific.
  *
  * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
- *                make a symbol exported from the DLL.
+ *                make a symbol exported from the DLL.  Not used in the
+ *                public header files; see pngpriv.h for how it is used
+ *                in the libpng build.
  *
  * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
  *                from a DLL - used to define PNG_IMPEXP when
@@ -195,7 +199,7 @@
 #    define PNGCAPI __watcall
 #  endif
 
-#  if defined(__GNUC__) || (defined (_MSC_VER) && (_MSC_VER >= 800)) || defined(__WINSCW__)
+#  if defined(__GNUC__) || (defined (_MSC_VER) && (_MSC_VER >= 800))
 #    define PNGCAPI __cdecl
 #    if PNG_API_RULE == 1
 #      define PNGAPI __stdcall
@@ -256,25 +260,14 @@
 #  define PNGAPI PNGCAPI
 #endif
 
-/* The default for PNG_IMPEXP depends on whether the library is
- * being built or used.
+/* PNG_IMPEXP may be set on the compilation system command line or (if not set)
+ * then in an internal header file when building the library, otherwise (when
+ * using the library) it is set here.
  */
 #ifndef PNG_IMPEXP
-#  ifdef PNGLIB_BUILD
-    /* Building the library */
-#    if (defined(DLL_EXPORT)/*from libtool*/ ||\
-        defined(_WINDLL) || defined(_DLL) || defined(__DLL__) ||\
-        defined(_USRDLL) ||\
-        defined(PNG_BUILD_DLL)) && defined(PNG_DLL_EXPORT)
-      /* Building a DLL. */
-#      define PNG_IMPEXP PNG_DLL_EXPORT
-#    endif /* DLL */
-#  else
-    /* Using the library */
-#    if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
-      /* This forces use of a DLL, disallowing static linking */
-#      define PNG_IMPEXP PNG_DLL_IMPORT
-#    endif
+#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
+     /* This forces use of a DLL, disallowing static linking */
+#    define PNG_IMPEXP PNG_DLL_IMPORT
 #  endif
 
 #  ifndef PNG_IMPEXP
@@ -282,23 +275,15 @@
 #  endif
 #endif
 
-/* THe following complexity is concerned with getting the 'attributes' of the
- * declared function in the correct place.  This potentially requires a separate
- * PNG_EXPORT function for every compiler.
+/* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
+ * 'attributes' as a storage class - the attributes go at the start of the
+ * function definition, and attributes are always appended regardless of the
+ * compiler.  This considerably simplifies these macros but may cause problems
+ * if any compilers both need function attributes and fail to handle them as
+ * a storage class (this is unlikely.)
  */
 #ifndef PNG_FUNCTION
-#  ifdef __GNUC__
-#     define PNG_FUNCTION(type, name, args, attributes)\
-         attributes type name args
-#  else /* !GNUC */
-#     ifdef _MSC_VER
-#        define PNG_FUNCTION(type, name, args, attributes)\
-         attributes type name args
-#     else /* !MSC */
-#        define PNG_FUNCTION(type, name, args, attributes)\
-            type name args
-#     endif
-#  endif
+#  define PNG_FUNCTION(type, name, args, attributes) attributes type name args
 #endif
 
 #ifndef PNG_EXPORT_TYPE
@@ -310,13 +295,19 @@
     * scripts directory.
     */
 #ifndef PNG_EXPORTA
+
 #  define PNG_EXPORTA(ordinal, type, name, args, attributes)\
-      extern PNG_FUNCTION(PNG_EXPORT_TYPE(type),(PNGAPI name),PNGARG(args),\
-         attributes)
+      PNG_FUNCTION(PNG_EXPORT_TYPE(type),(PNGAPI name),PNGARG(args), \
+        extern attributes)
 #endif
 
+/* ANSI-C (C90) does not permit a macro to be invoked with an empty argument,
+ * so make something non-empty to satisfy the requirement:
+ */
+#define PNG_EMPTY /*empty list*/
+
 #define PNG_EXPORT(ordinal, type, name, args)\
-   PNG_EXPORTA(ordinal, type, name, args, )
+   PNG_EXPORTA(ordinal, type, name, args, PNG_EMPTY)
 
 /* Use PNG_REMOVED to comment out a removed interface. */
 #ifndef PNG_REMOVED
@@ -324,8 +315,7 @@
 #endif
 
 #ifndef PNG_CALLBACK
-#  define PNG_CALLBACK(type, name, args, attributes)\
-   type (PNGCBAPI name) PNGARG(args) attributes
+#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) PNGARG(args)
 #endif
 
 /* Support for compiler specific function attributes.  These are used
@@ -347,72 +337,49 @@
    * functions in png.h will generate compiler warnings.  Added at libpng
    * version 1.2.41.
    */
-#  ifdef __GNUC__
+#  if defined(__GNUC__)
 #    ifndef PNG_USE_RESULT
 #      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
 #    endif
 #    ifndef PNG_NORETURN
 #      define PNG_NORETURN   __attribute__((__noreturn__))
 #    endif
-#    ifndef PNG_PTR_NORETURN
-#      define PNG_PTR_NORETURN   __attribute__((__noreturn__))
-#    endif
 #    ifndef PNG_ALLOCATED
 #      define PNG_ALLOCATED  __attribute__((__malloc__))
 #    endif
-
-    /* This specifically protects structure members that should only be
-     * accessed from within the library, therefore should be empty during
-     * a library build.
-     */
-#    ifndef PNGLIB_BUILD
-#      ifndef PNG_DEPRECATED
-#        define PNG_DEPRECATED __attribute__((__deprecated__))
-#      endif
-#      ifndef PNG_DEPSTRUCT
-#        define PNG_DEPSTRUCT  __attribute__((__deprecated__))
+#    ifndef PNG_DEPRECATED
+#      define PNG_DEPRECATED __attribute__((__deprecated__))
+#    endif
+#    ifndef PNG_PRIVATE
+#      if 0 /* Doesn't work so we use deprecated instead*/
+#        define PNG_PRIVATE \
+          __attribute__((warning("This function is not exported by libpng.")))
+#      else
+#        define PNG_PRIVATE \
+          __attribute__((__deprecated__))
 #      endif
-#      ifndef PNG_PRIVATE
-#        if 0 /* Doesn't work so we use deprecated instead*/
-#          define PNG_PRIVATE \
-            __attribute__((warning("This function is not exported by libpng.")))
-#        else
-#          define PNG_PRIVATE \
-            __attribute__((__deprecated__))
-#        endif
-#      endif /* PNG_PRIVATE */
-#    endif /* PNGLIB_BUILD */
+#    endif
 #  endif /* __GNUC__ */
-#  ifdef _MSC_VER /* may need to check value */
+
+#  if defined(_MSC_VER)  && (_MSC_VER >= 1300)
 #    ifndef PNG_USE_RESULT
-#      define PNG_USE_RESULT /*not supported*/
+#      define PNG_USE_RESULT /* not supported */
 #    endif
 #    ifndef PNG_NORETURN
-#      define PNG_NORETURN   __declspec(noreturn)
-#    endif
-#    ifndef PNG_PTR_NORETURN
-#      define PNG_PTR_NORETURN /*not supported*/
+#      define PNG_NORETURN __declspec(noreturn)
 #    endif
 #    ifndef PNG_ALLOCATED
-#      define PNG_ALLOCATED __declspec(restrict)
-#    endif
-
-    /* This specifically protects structure members that should only be
-     * accessed from within the library, therefore should be empty during
-     * a library build.
-     */
-#    ifndef PNGLIB_BUILD
-#      ifndef PNG_DEPRECATED
-#        define PNG_DEPRECATED __declspec(deprecated)
-#      endif
-#      ifndef PNG_DEPSTRUCT
-#        define PNG_DEPSTRUCT  __declspec(deprecated)
+#      if (_MSC_VER >= 1400)
+#        define PNG_ALLOCATED __declspec(restrict)
 #      endif
-#      ifndef PNG_PRIVATE
-#        define PNG_PRIVATE __declspec(deprecated)
-#      endif /* PNG_PRIVATE */
-#    endif /* PNGLIB_BUILD */
-#  endif /* __GNUC__ */
+#    endif
+#    ifndef PNG_DEPRECATED
+#      define PNG_DEPRECATED __declspec(deprecated)
+#    endif
+#    ifndef PNG_PRIVATE
+#      define PNG_PRIVATE __declspec(deprecated)
+#    endif
+#  endif /* _MSC_VER */
 #endif /* PNG_PEDANTIC_WARNINGS */
 
 #ifndef PNG_DEPRECATED
@@ -427,9 +394,6 @@
 #ifndef PNG_ALLOCATED
 #  define PNG_ALLOCATED   /* The result of the function is new memory */
 #endif
-#ifndef PNG_DEPSTRUCT
-#  define PNG_DEPSTRUCT   /* Access to this struct member is deprecated */
-#endif
 #ifndef PNG_PRIVATE
 #  define PNG_PRIVATE     /* This is a private libpng function */
 #endif
diff --git a/src/3rdparty/libpng/pngerror.c b/src/3rdparty/libpng/pngerror.c
index 8290bb4..95002f8 100644
--- a/src/3rdparty/libpng/pngerror.c
+++ b/src/3rdparty/libpng/pngerror.c
@@ -1,8 +1,8 @@
 
 /* pngerror.c - stub functions for i/o and memory allocation
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.8 [February 1, 2011]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -89,15 +89,121 @@ png_error,(png_structp png_ptr, png_const_charp error_message),PNG_NORETURN)
 PNG_FUNCTION(void,PNGAPI
 png_err,(png_structp png_ptr),PNG_NORETURN)
 {
+   /* Prior to 1.5.2 the error_fn received a NULL pointer, expressed
+    * erroneously as '\0', instead of the empty string "".  This was
+    * apparently an error, introduced in libpng-1.2.20, and png_default_error
+    * will crash in this case.
+    */
    if (png_ptr != NULL && png_ptr->error_fn != NULL)
-      (*(png_ptr->error_fn))(png_ptr, '\0');
+      (*(png_ptr->error_fn))(png_ptr, "");
 
    /* If the custom handler doesn't exist, or if it returns,
       use the default handler, which will not return. */
-   png_default_error(png_ptr, '\0');
+   png_default_error(png_ptr, "");
 }
 #endif /* PNG_ERROR_TEXT_SUPPORTED */
 
+/* Utility to safely appends strings to a buffer.  This never errors out so
+ * error checking is not required in the caller.
+ */
+size_t
+png_safecat(png_charp buffer, size_t bufsize, size_t pos,
+   png_const_charp string)
+{
+   if (buffer != NULL && pos < bufsize)
+   {
+      if (string != NULL)
+         while (*string != '\0' && pos < bufsize-1)
+           buffer[pos++] = *string++;
+
+      buffer[pos] = '\0';
+   }
+
+   return pos;
+}
+
+#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_TIME_RFC1123_SUPPORTED)
+/* Utility to dump an unsigned value into a buffer, given a start pointer and
+ * and end pointer (which should point just *beyond* the end of the buffer!)
+ * Returns the pointer to the start of the formatted string.
+ */
+png_charp
+png_format_number(png_const_charp start, png_charp end, int format,
+   png_alloc_size_t number)
+{
+   int count = 0;    /* number of digits output */
+   int mincount = 1; /* minimum number required */
+   int output = 0;   /* digit output (for the fixed point format) */
+
+   *--end = '\0';
+
+   /* This is written so that the loop always runs at least once, even with
+    * number zero.
+    */
+   while (end > start && (number != 0 || count < mincount))
+   {
+
+      static const char digits[] = "0123456789ABCDEF";
+
+      switch (format)
+      {
+         case PNG_NUMBER_FORMAT_fixed:
+            /* Needs five digits (the fraction) */
+            mincount = 5;
+            if (output || number % 10 != 0)
+            {
+               *--end = digits[number % 10];
+               output = 1;
+            }
+            number /= 10;
+            break;
+
+         case PNG_NUMBER_FORMAT_02u:
+            /* Expects at least 2 digits. */
+            mincount = 2;
+            /* fall through */
+
+         case PNG_NUMBER_FORMAT_u:
+            *--end = digits[number % 10];
+            number /= 10;
+            break;
+
+         case PNG_NUMBER_FORMAT_02x:
+            /* This format expects at least two digits */
+            mincount = 2;
+            /* fall through */
+
+         case PNG_NUMBER_FORMAT_x:
+            *--end = digits[number & 0xf];
+            number >>= 4;
+            break;
+
+         default: /* an error */
+            number = 0;
+            break;
+      }
+
+      /* Keep track of the number of digits added */
+      ++count;
+
+      /* Float a fixed number here: */
+      if (format == PNG_NUMBER_FORMAT_fixed) if (count == 5) if (end > start)
+      {
+         /* End of the fraction, but maybe nothing was output?  In that case
+          * drop the decimal point.  If the number is a true zero handle that
+          * here.
+          */
+         if (output)
+            *--end = '.';
+         else if (number == 0) /* and !output */
+            *--end = '0';
+      }
+   }
+
+   return end;
+}
+#endif
+
 #ifdef PNG_WARNINGS_SUPPORTED
 /* This function is called whenever there is a non-fatal error.  This function
  * should not be changed.  If there is a need to handle warnings differently,
@@ -128,6 +234,124 @@ png_warning(png_structp png_ptr, png_const_charp warning_message)
    else
       png_default_warning(png_ptr, warning_message + offset);
 }
+
+/* These functions support 'formatted' warning messages with up to
+ * PNG_WARNING_PARAMETER_COUNT parameters.  In the format string the parameter
+ * is introduced by @<number>, where 'number' starts at 1.  This follows the
+ * standard established by X/Open for internationalizable error messages.
+ */
+void
+png_warning_parameter(png_warning_parameters p, int number,
+   png_const_charp string)
+{
+   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)
+      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);
+}
+
+void
+png_warning_parameter_unsigned(png_warning_parameters p, int number, int format,
+   png_alloc_size_t value)
+{
+   char buffer[PNG_NUMBER_BUFFER_SIZE];
+   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));
+}
+
+void
+png_warning_parameter_signed(png_warning_parameters p, int number, int format,
+   png_int_32 value)
+{
+   png_alloc_size_t u;
+   png_charp str;
+   char buffer[PNG_NUMBER_BUFFER_SIZE];
+
+   /* Avoid overflow by doing the negate in a png_alloc_size_t: */
+   u = (png_alloc_size_t)value;
+   if (value < 0)
+      u = ~u + 1;
+
+   str = PNG_FORMAT_NUMBER(buffer, format, u);
+
+   if (value < 0 && str > buffer)
+      *--str = '-';
+
+   png_warning_parameter(p, number, str);
+}
+
+void
+png_formatted_warning(png_structp png_ptr, png_warning_parameters p,
+   png_const_charp message)
+{
+   /* The internal buffer is just 192 bytes - enough for all our messages,
+    * overflow doesn't happen because this code checks!  If someone figures
+    * out how to send us a message longer than 192 bytes, all that will
+    * happen is that the message will be truncated appropriately.
+    */
+   size_t i = 0; /* Index in the msg[] buffer: */
+   char msg[192];
+
+   /* Each iteration through the following loop writes at most one character
+    * to msg[i++] then returns here to validate that there is still space for
+    * the trailing '\0'.  It may (in the case of a parameter) read more than
+    * one character from message[]; it must check for '\0' and continue to the
+    * test if it finds the end of string.
+    */
+   while (i<(sizeof msg)-1 && *message != '\0')
+   {
+      /* '@' at end of string is now just printed (previously it was skipped);
+       * it is an error in the calling code to terminate the string with @.
+       */
+      if (p != NULL && *message == '@' && message[1] != '\0')
+      {
+         int parameter_char = *++message; /* Consume the '@' */
+         static const char valid_parameters[] = "123456789";
+         int parameter = 0;
+
+         /* Search for the parameter digit, the index in the string is the
+          * parameter to use.
+          */
+         while (valid_parameters[parameter] != parameter_char &&
+            valid_parameters[parameter] != '\0')
+            ++parameter;
+
+         /* If the parameter digit is out of range it will just get printed. */
+         if (parameter < PNG_WARNING_PARAMETER_COUNT)
+         {
+            /* Append this parameter */
+            png_const_charp parm = p[parameter];
+            png_const_charp pend = p[parameter] + (sizeof p[parameter]);
+
+            /* No need to copy the trailing '\0' here, but there is no guarantee
+             * that parm[] has been initialized, so there is no guarantee of a
+             * trailing '\0':
+             */
+            while (i<(sizeof msg)-1 && *parm != '\0' && parm < pend)
+               msg[i++] = *parm++;
+
+            /* Consume the parameter digit too: */
+            ++message;
+            continue;
+         }
+
+         /* else not a parameter and there is a character after the @ sign; just
+          * copy that.  This is known not to be '\0' because of the test above.
+          */
+      }
+
+      /* At this point *message can't be '\0', even in the bad parameter case
+       * above where there is a lone '@' at the end of the message string.
+       */
+      msg[i++] = *message++;
+   }
+
+   /* i is always less than (sizeof msg), so: */
+   msg[i] = '\0';
+
+   /* And this is the formatted message, it may be larger than
+    * PNG_MAX_ERROR_TEXT, but that is only used for 'chunk' errors and these are
+    * not (currently) formatted.
+    */
+   png_warning(png_ptr, msg);
+}
 #endif /* PNG_WARNINGS_SUPPORTED */
 
 #ifdef PNG_BENIGN_ERRORS_SUPPORTED
@@ -159,11 +383,14 @@ static void /* PRIVATE */
 png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
     error_message)
 {
-   int iout = 0, iin = 0;
+   png_uint_32 chunk_name = png_ptr->chunk_name;
+   int iout = 0, ishift = 24;
 
-   while (iin < 4)
+   while (ishift >= 0)
    {
-      int c = png_ptr->chunk_name[iin++];
+      int c = (int)(chunk_name >> ishift) & 0xff;
+
+      ishift -= 8;
       if (isnonalpha(c))
       {
          buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;
@@ -174,7 +401,7 @@ png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
 
       else
       {
-         buffer[iout++] = (png_byte)c;
+         buffer[iout++] = (char)c;
       }
    }
 
@@ -183,10 +410,16 @@ png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
 
    else
    {
+      int iin = 0;
+
       buffer[iout++] = ':';
       buffer[iout++] = ' ';
-      png_memcpy(buffer + iout, error_message, PNG_MAX_ERROR_TEXT);
-      buffer[iout + PNG_MAX_ERROR_TEXT - 1] = '\0';
+
+      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\0')
+         buffer[iout++] = error_message[iin++];
+
+      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */
+      buffer[iout] = '\0';
    }
 }
 #endif /* PNG_WARNINGS_SUPPORTED || PNG_ERROR_TEXT_SUPPORTED */
@@ -272,7 +505,7 @@ png_set_longjmp_fn(png_structp png_ptr, png_longjmp_ptr longjmp_fn,
       return NULL;
 
    png_ptr->longjmp_fn = longjmp_fn;
-   return &png_ptr->png_jmpbuf;
+   return &png_ptr->longjmp_buffer;
 }
 #endif
 
@@ -287,7 +520,8 @@ png_default_error,(png_structp png_ptr, png_const_charp error_message),
 {
 #ifdef PNG_CONSOLE_IO_SUPPORTED
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   if (*error_message == PNG_LITERAL_SHARP)
+   /* Check on NULL only added in 1.5.4 */
+   if (error_message != NULL && *error_message == PNG_LITERAL_SHARP)
    {
       /* Strip "#nnnn " from beginning of error message. */
       int offset;
@@ -317,11 +551,11 @@ png_default_error,(png_structp png_ptr, png_const_charp error_message),
    else
 #endif
    {
-      fprintf(stderr, "libpng error: %s", error_message);
+      fprintf(stderr, "libpng error: %s", error_message ? error_message :
+         "undefined");
       fprintf(stderr, PNG_STRING_NEWLINE);
    }
-#endif
-#ifndef PNG_CONSOLE_IO_SUPPORTED
+#else
    PNG_UNUSED(error_message) /* Make compiler happy */
 #endif
    png_longjmp(png_ptr, 1);
@@ -335,13 +569,13 @@ png_longjmp,(png_structp png_ptr, int val),PNG_NORETURN)
    {
 #  ifdef USE_FAR_KEYWORD
       {
-         jmp_buf png_jmpbuf;
-         png_memcpy(png_jmpbuf, png_ptr->png_jmpbuf, png_sizeof(jmp_buf));
-         png_ptr->longjmp_fn(png_jmpbuf, val);
+         jmp_buf tmp_jmpbuf;
+         png_memcpy(tmp_jmpbuf, png_ptr->longjmp_buffer, png_sizeof(jmp_buf));
+         png_ptr->longjmp_fn(tmp_jmpbuf, val);
       }
 
 #  else
-   png_ptr->longjmp_fn(png_ptr->png_jmpbuf, val);
+   png_ptr->longjmp_fn(png_ptr->longjmp_buffer, val);
 #  endif
    }
 #endif
@@ -403,7 +637,7 @@ png_default_warning(png_structp png_ptr, png_const_charp warning_message)
 /* This function is called when the application wants to use another method
  * of handling errors and warnings.  Note that the error function MUST NOT
  * return to the calling routine or serious problems will occur.  The return
- * method used in the default routine calls longjmp(png_ptr->png_jmpbuf, 1)
+ * method used in the default routine calls longjmp(png_ptr->longjmp_buffer, 1)
  */
 void PNGAPI
 png_set_error_fn(png_structp png_ptr, png_voidp error_ptr,
@@ -414,7 +648,11 @@ png_set_error_fn(png_structp png_ptr, png_voidp error_ptr,
 
    png_ptr->error_ptr = error_ptr;
    png_ptr->error_fn = error_fn;
+#ifdef PNG_WARNINGS_SUPPORTED
    png_ptr->warning_fn = warning_fn;
+#else
+   PNG_UNUSED(warning_fn)
+#endif
 }
 
 
diff --git a/src/3rdparty/libpng/pngget.c b/src/3rdparty/libpng/pngget.c
index b5e5798..43400cd 100644
--- a/src/3rdparty/libpng/pngget.c
+++ b/src/3rdparty/libpng/pngget.c
@@ -1,7 +1,7 @@
 
 /* pngget.c - retrieval of values from info struct
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
+ * Last changed in libpng 1.5.7 [December 15, 2011]
  * Copyright (c) 1998-2011 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -459,6 +459,65 @@ png_get_bKGD(png_const_structp png_ptr, png_infop info_ptr,
 #endif
 
 #ifdef PNG_cHRM_SUPPORTED
+/* The XYZ APIs were added in 1.5.5 to take advantage of the code added at the
+ * same time to correct the rgb grayscale coefficient defaults obtained from the
+ * cHRM chunk in 1.5.4
+ */
+png_uint_32 PNGFAPI
+png_get_cHRM_XYZ_fixed(png_structp png_ptr, png_const_infop info_ptr,
+    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
+    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
+    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
+    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
+    png_fixed_point *int_blue_Z)
+{
+   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
+   {
+      png_xy xy;
+      png_XYZ XYZ;
+
+      png_debug1(1, "in %s retrieval function", "cHRM_XYZ");
+
+      xy.whitex = info_ptr->x_white;
+      xy.whitey = info_ptr->y_white;
+      xy.redx = info_ptr->x_red;
+      xy.redy = info_ptr->y_red;
+      xy.greenx = info_ptr->x_green;
+      xy.greeny = info_ptr->y_green;
+      xy.bluex = info_ptr->x_blue;
+      xy.bluey = info_ptr->y_blue;
+
+      /* The *_checked function handles error reporting, so just return 0 if
+       * there is a failure here.
+       */
+      if (png_XYZ_from_xy_checked(png_ptr, &XYZ, xy))
+      {
+         if (int_red_X != NULL)
+            *int_red_X = XYZ.redX;
+         if (int_red_Y != NULL)
+            *int_red_Y = XYZ.redY;
+         if (int_red_Z != NULL)
+            *int_red_Z = XYZ.redZ;
+         if (int_green_X != NULL)
+            *int_green_X = XYZ.greenX;
+         if (int_green_Y != NULL)
+            *int_green_Y = XYZ.greenY;
+         if (int_green_Z != NULL)
+            *int_green_Z = XYZ.greenZ;
+         if (int_blue_X != NULL)
+            *int_blue_X = XYZ.blueX;
+         if (int_blue_Y != NULL)
+            *int_blue_Y = XYZ.blueY;
+         if (int_blue_Z != NULL)
+            *int_blue_Z = XYZ.blueZ;
+
+         return (PNG_INFO_cHRM);
+      }
+   }
+
+   return (0);
+}
+
 #  ifdef PNG_FLOATING_POINT_SUPPORTED
 png_uint_32 PNGAPI
 png_get_cHRM(png_const_structp png_ptr, png_const_infop info_ptr,
@@ -490,6 +549,42 @@ png_get_cHRM(png_const_structp png_ptr, png_const_infop info_ptr,
 
    return (0);
 }
+
+png_uint_32 PNGAPI
+png_get_cHRM_XYZ(png_structp png_ptr, png_const_infop info_ptr,
+   double *red_X, double *red_Y, double *red_Z, double *green_X,
+   double *green_Y, double *green_Z, double *blue_X, double *blue_Y,
+   double *blue_Z)
+{
+   png_XYZ XYZ;
+
+   if (png_get_cHRM_XYZ_fixed(png_ptr, info_ptr,
+      &XYZ.redX, &XYZ.redY, &XYZ.redZ, &XYZ.greenX, &XYZ.greenY, &XYZ.greenZ,
+      &XYZ.blueX, &XYZ.blueY, &XYZ.blueZ) & PNG_INFO_cHRM)
+   {
+      if (red_X != NULL)
+         *red_X = png_float(png_ptr, XYZ.redX, "cHRM red X");
+      if (red_Y != NULL)
+         *red_Y = png_float(png_ptr, XYZ.redY, "cHRM red Y");
+      if (red_Z != NULL)
+         *red_Z = png_float(png_ptr, XYZ.redZ, "cHRM red Z");
+      if (green_X != NULL)
+         *green_X = png_float(png_ptr, XYZ.greenX, "cHRM green X");
+      if (green_Y != NULL)
+         *green_Y = png_float(png_ptr, XYZ.greenY, "cHRM green Y");
+      if (green_Z != NULL)
+         *green_Z = png_float(png_ptr, XYZ.greenZ, "cHRM green Z");
+      if (blue_X != NULL)
+         *blue_X = png_float(png_ptr, XYZ.blueX, "cHRM blue X");
+      if (blue_Y != NULL)
+         *blue_Y = png_float(png_ptr, XYZ.blueY, "cHRM blue Y");
+      if (blue_Z != NULL)
+         *blue_Z = png_float(png_ptr, XYZ.blueZ, "cHRM blue Z");
+      return (PNG_INFO_cHRM);
+   }
+
+   return (0);
+}
 #  endif
 
 #  ifdef PNG_FIXED_POINT_SUPPORTED
@@ -587,15 +682,16 @@ png_get_iCCP(png_const_structp png_ptr, png_const_infop info_ptr,
    png_debug1(1, "in %s retrieval function", "iCCP");
 
    if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)
-       && name != NULL && profile != NULL && proflen != NULL)
+       && name != NULL && compression_type != NULL && profile != NULL &&
+		 proflen != NULL)
    {
       *name = info_ptr->iccp_name;
       *profile = info_ptr->iccp_profile;
       /* Compression_type is a dummy so the API won't have to change
        * if we introduce multiple compression types later.
        */
-      *proflen = (int)info_ptr->iccp_proflen;
-      *compression_type = (int)info_ptr->iccp_compression;
+      *proflen = info_ptr->iccp_proflen;
+      *compression_type = info_ptr->iccp_compression;
       return (PNG_INFO_iCCP);
    }
 
@@ -855,9 +951,8 @@ png_get_text(png_const_structp png_ptr, png_const_infop info_ptr,
 {
    if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
    {
-      png_debug1(1, "in %s retrieval function",
-          (png_ptr->chunk_name[0] == '\0' ? "text" :
-          (png_const_charp)png_ptr->chunk_name));
+      png_debug1(1, "in 0x%lx retrieval function",
+         (unsigned long)png_ptr->chunk_name);
 
       if (text_ptr != NULL)
          *text_ptr = info_ptr->text;
@@ -971,10 +1066,9 @@ png_get_user_chunk_ptr(png_const_structp png_ptr)
 png_size_t PNGAPI
 png_get_compression_buffer_size(png_const_structp png_ptr)
 {
-   return (png_ptr ? png_ptr->zbuf_size : 0L);
+   return (png_ptr ? png_ptr->zbuf_size : 0);
 }
 
-
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
 /* These functions were added to libpng 1.2.6 and were enabled
  * by default in libpng-1.4.0 */
@@ -1016,16 +1110,14 @@ png_get_io_state (png_structp png_ptr)
 png_uint_32 PNGAPI
 png_get_io_chunk_type (png_const_structp png_ptr)
 {
-   return ((png_ptr->chunk_name[0] << 24) +
-           (png_ptr->chunk_name[1] << 16) +
-           (png_ptr->chunk_name[2] <<  8) +
-           (png_ptr->chunk_name[3]));
+   return png_ptr->chunk_name;
 }
 
 png_const_bytep PNGAPI
 png_get_io_chunk_name (png_structp png_ptr)
 {
-   return png_ptr->chunk_name;
+   PNG_CSTRING_FROM_CHUNK(png_ptr->io_chunk_string, png_ptr->chunk_name);
+   return png_ptr->io_chunk_string;
 }
 #endif /* ?PNG_IO_STATE_SUPPORTED */
 
diff --git a/src/3rdparty/libpng/pnginfo.h b/src/3rdparty/libpng/pnginfo.h
index fa19f85..a33bfab 100644
--- a/src/3rdparty/libpng/pnginfo.h
+++ b/src/3rdparty/libpng/pnginfo.h
@@ -138,7 +138,6 @@ defined(PNG_READ_BACKGROUND_SUPPORTED)
     * single color specified that should be treated as fully transparent.
     * Data is valid if (valid & PNG_INFO_tRNS) is non-zero.
     */
-   png_bytep trans;    /* alpha values for paletted image */
    png_bytep trans_alpha;    /* alpha values for paletted image */
    png_color_16 trans_color; /* transparent color for non-palette image */
 #endif
diff --git a/src/3rdparty/libpng/pnglibconf.h b/src/3rdparty/libpng/pnglibconf.h
index c46dde3..6facf39 100644
--- a/src/3rdparty/libpng/pnglibconf.h
+++ b/src/3rdparty/libpng/pnglibconf.h
@@ -3,176 +3,184 @@
 
 /* pnglibconf.h - library build configuration */
 
-/* libpng version 1.5.0 - last changed on January 6, 2011 */
+/* Libpng 1.5.10 - March 29, 2012 */
 
-/* Copyright (c) 1998-2011 Glenn Randers-Pehrson */
+/* Copyright (c) 1998-2012 Glenn Randers-Pehrson */
 
 /* This code is released under the libpng license. */
 /* For conditions of distribution and use, see the disclaimer */
 /* and license in png.h */
 
 /* pnglibconf.h */
-/* Machine generated file: DO NOT EDIT */
 /* Derived from: scripts/pnglibconf.dfa */
+/* If you edit this file by hand you must obey the rules expressed in */
+/* pnglibconf.dfa with respect to the dependencies between the following */
+/* symbols.  It is much better to generate a new file using */
+/* scripts/libpngconf.mak */
+
 #ifndef PNGLCONF_H
 #define PNGLCONF_H
 /* settings */
-#define PNG_MAX_GAMMA_8 11
-#define PNG_CALLOC_SUPPORTED
-#define PNG_QUANTIZE_RED_BITS 5
-#define PNG_USER_WIDTH_MAX 1000000L
-#define PNG_QUANTIZE_GREEN_BITS 5
 #define PNG_API_RULE 0
+#define PNG_CALLOC_SUPPORTED
+#define PNG_COST_SHIFT 3
+#define PNG_DEFAULT_READ_MACROS 1
+#define PNG_GAMMA_THRESHOLD_FIXED 5000
+#define PNG_MAX_GAMMA_8 11
 #define PNG_QUANTIZE_BLUE_BITS 5
-#define PNG_USER_CHUNK_CACHE_MAX 0
-#define PNG_USER_HEIGHT_MAX 1000000L
+#define PNG_QUANTIZE_GREEN_BITS 5
+#define PNG_QUANTIZE_RED_BITS 5
 #define PNG_sCAL_PRECISION 5
-#define PNG_COST_SHIFT 3
 #define PNG_WEIGHT_SHIFT 8
-#define PNG_USER_CHUNK_MALLOC_MAX 0
-#define PNG_DEFAULT_READ_MACROS 1
 #define PNG_ZBUF_SIZE 8192
-#define PNG_GAMMA_THRESHOLD_FIXED 5000
 /* end of settings */
 /* options */
-#define PNG_INFO_IMAGE_SUPPORTED
-#define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-#define PNG_POINTER_INDEXING_SUPPORTED
-#define PNG_WARNINGS_SUPPORTED
-#define PNG_FLOATING_ARITHMETIC_SUPPORTED
-#define PNG_WRITE_SUPPORTED
-#define PNG_WRITE_INTERLACING_SUPPORTED
-#define PNG_WRITE_16BIT_SUPPORTED
-#define PNG_EASY_ACCESS_SUPPORTED
+#define PNG_16BIT_SUPPORTED
 #define PNG_ALIGN_MEMORY_SUPPORTED
-#define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-#define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-#define PNG_USER_LIMITS_SUPPORTED
-#define PNG_FIXED_POINT_SUPPORTED
+#define PNG_BENIGN_ERRORS_SUPPORTED
+#define PNG_bKGD_SUPPORTED
+#define PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
+#define PNG_CHECK_cHRM_SUPPORTED
+#define PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
+#define PNG_cHRM_SUPPORTED
+#define PNG_CONSOLE_IO_SUPPORTED
+#define PNG_CONVERT_tIME_SUPPORTED
+#define PNG_EASY_ACCESS_SUPPORTED
 /*#undef PNG_ERROR_NUMBERS_SUPPORTED*/
 #define PNG_ERROR_TEXT_SUPPORTED
-#define PNG_READ_SUPPORTED
-/*#undef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED*/
-#define PNG_BENIGN_ERRORS_SUPPORTED
-#define PNG_SETJMP_SUPPORTED
-#define PNG_WRITE_FLUSH_SUPPORTED
-#define PNG_MNG_FEATURES_SUPPORTED
+#define PNG_FIXED_POINT_SUPPORTED
+#define PNG_FLOATING_ARITHMETIC_SUPPORTED
 #define PNG_FLOATING_POINT_SUPPORTED
+#define PNG_gAMA_SUPPORTED
+#define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+#define PNG_hIST_SUPPORTED
+#define PNG_iCCP_SUPPORTED
 #define PNG_INCH_CONVERSIONS_SUPPORTED
-#define PNG_STDIO_SUPPORTED
-#define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-#define PNG_USER_MEM_SUPPORTED
+#define PNG_INFO_IMAGE_SUPPORTED
 #define PNG_IO_STATE_SUPPORTED
-#define PNG_SET_USER_LIMITS_SUPPORTED
+#define PNG_iTXt_SUPPORTED
+#define PNG_MNG_FEATURES_SUPPORTED
+#define PNG_oFFs_SUPPORTED
+#define PNG_pCAL_SUPPORTED
+#define PNG_pHYs_SUPPORTED
+#define PNG_POINTER_INDEXING_SUPPORTED
+#define PNG_PROGRESSIVE_READ_SUPPORTED
+#define PNG_READ_16BIT_SUPPORTED
+#define PNG_READ_ALPHA_MODE_SUPPORTED
 #define PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
-#define PNG_WRITE_INT_FUNCTIONS_SUPPORTED
-#define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
-#define PNG_WRITE_FILTER_SUPPORTED
-#define PNG_SET_CHUNK_CACHE_LIMIT_SUPPORTED
-#define PNG_WRITE_iCCP_SUPPORTED
-#define PNG_READ_TRANSFORMS_SUPPORTED
-#define PNG_READ_GAMMA_SUPPORTED
+#define PNG_READ_BACKGROUND_SUPPORTED
+#define PNG_READ_BGR_SUPPORTED
 #define PNG_READ_bKGD_SUPPORTED
-#define PNG_UNKNOWN_CHUNKS_SUPPORTED
-#define PNG_READ_sCAL_SUPPORTED
-#define PNG_WRITE_hIST_SUPPORTED
-#define PNG_READ_OPT_PLTE_SUPPORTED
-#define PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
-#define PNG_WRITE_gAMA_SUPPORTED
+#define PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
+#define PNG_READ_cHRM_SUPPORTED
+#define PNG_READ_COMPOSITE_NODIV_SUPPORTED
+#define PNG_READ_COMPRESSED_TEXT_SUPPORTED
+#define PNG_READ_EXPAND_16_SUPPORTED
+#define PNG_READ_EXPAND_SUPPORTED
+#define PNG_READ_FILLER_SUPPORTED
+#define PNG_READ_gAMA_SUPPORTED
+#define PNG_READ_GAMMA_SUPPORTED
 #define PNG_READ_GRAY_TO_RGB_SUPPORTED
-#define PNG_WRITE_pCAL_SUPPORTED
+#define PNG_READ_hIST_SUPPORTED
+#define PNG_READ_iCCP_SUPPORTED
+#define PNG_READ_INTERLACING_SUPPORTED
+#define PNG_READ_INT_FUNCTIONS_SUPPORTED
 #define PNG_READ_INVERT_ALPHA_SUPPORTED
-#define PNG_WRITE_TRANSFORMS_SUPPORTED
-#define PNG_READ_sBIT_SUPPORTED
+#define PNG_READ_INVERT_SUPPORTED
+#define PNG_READ_iTXt_SUPPORTED
+#define PNG_READ_oFFs_SUPPORTED
+#define PNG_READ_OPT_PLTE_SUPPORTED
 #define PNG_READ_PACK_SUPPORTED
-#define PNG_WRITE_SWAP_SUPPORTED
-#define PNG_READ_cHRM_SUPPORTED
-#define PNG_WRITE_tIME_SUPPORTED
-#define PNG_READ_INTERLACING_SUPPORTED
-#define PNG_READ_tRNS_SUPPORTED
-#define PNG_WRITE_pHYs_SUPPORTED
-#define PNG_WRITE_INVERT_SUPPORTED
+#define PNG_READ_PACKSWAP_SUPPORTED
+#define PNG_READ_pCAL_SUPPORTED
+#define PNG_READ_pHYs_SUPPORTED
+#define PNG_READ_QUANTIZE_SUPPORTED
 #define PNG_READ_RGB_TO_GRAY_SUPPORTED
-#define PNG_WRITE_sRGB_SUPPORTED
-#define PNG_READ_oFFs_SUPPORTED
-#define PNG_WRITE_FILLER_SUPPORTED
-#define PNG_WRITE_TEXT_SUPPORTED
-#define PNG_WRITE_SHIFT_SUPPORTED
-#define PNG_PROGRESSIVE_READ_SUPPORTED
+#define PNG_READ_sBIT_SUPPORTED
+#define PNG_READ_SCALE_16_TO_8_SUPPORTED
+#define PNG_READ_sCAL_SUPPORTED
 #define PNG_READ_SHIFT_SUPPORTED
-#ifndef _WIN32_WCE
- #define PNG_CONVERT_tIME_SUPPORTED
-#endif
-#define PNG_READ_USER_TRANSFORM_SUPPORTED
-#define PNG_READ_INT_FUNCTIONS_SUPPORTED
-#define PNG_READ_USER_CHUNKS_SUPPORTED
-#define PNG_READ_hIST_SUPPORTED
-#define PNG_READ_16BIT_SUPPORTED
-#define PNG_READ_SWAP_ALPHA_SUPPORTED
-#define PNG_READ_COMPOSITE_NODIV_SUPPORTED
-#define PNG_SEQUENTIAL_READ_SUPPORTED
-#define PNG_READ_BACKGROUND_SUPPORTED
-#define PNG_READ_QUANTIZE_SUPPORTED
-#define PNG_READ_iCCP_SUPPORTED
-#define PNG_READ_STRIP_ALPHA_SUPPORTED
-#define PNG_READ_PACKSWAP_SUPPORTED
+#define PNG_READ_sPLT_SUPPORTED
 #define PNG_READ_sRGB_SUPPORTED
-#define PNG_WRITE_tEXt_SUPPORTED
-#define PNG_READ_gAMA_SUPPORTED
-#define PNG_READ_pCAL_SUPPORTED
-#define PNG_READ_EXPAND_SUPPORTED
-#define PNG_WRITE_sPLT_SUPPORTED
+#define PNG_READ_STRIP_16_TO_8_SUPPORTED
+#define PNG_READ_STRIP_ALPHA_SUPPORTED
+#define PNG_READ_SUPPORTED
+#define PNG_READ_SWAP_ALPHA_SUPPORTED
 #define PNG_READ_SWAP_SUPPORTED
+#define PNG_READ_tEXt_SUPPORTED
+#define PNG_READ_TEXT_SUPPORTED
 #define PNG_READ_tIME_SUPPORTED
-#define PNG_READ_pHYs_SUPPORTED
-#define PNG_WRITE_SWAP_ALPHA_SUPPORTED
+#define PNG_READ_TRANSFORMS_SUPPORTED
+#define PNG_READ_tRNS_SUPPORTED
+#define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
+#define PNG_READ_USER_CHUNKS_SUPPORTED
+#define PNG_READ_USER_TRANSFORM_SUPPORTED
+#define PNG_READ_zTXt_SUPPORTED
+#define PNG_SAVE_INT_32_SUPPORTED
+#define PNG_sBIT_SUPPORTED
+#define PNG_sCAL_SUPPORTED
+#define PNG_SEQUENTIAL_READ_SUPPORTED
+#define PNG_SET_CHUNK_CACHE_LIMIT_SUPPORTED
+#define PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
+#define PNG_SETJMP_SUPPORTED
+#define PNG_SET_USER_LIMITS_SUPPORTED
+#define PNG_sPLT_SUPPORTED
+#define PNG_sRGB_SUPPORTED
+#define PNG_STDIO_SUPPORTED
+#define PNG_tEXt_SUPPORTED
+#define PNG_TEXT_SUPPORTED
 #define PNG_TIME_RFC1123_SUPPORTED
-#define PNG_READ_TEXT_SUPPORTED
-#define PNG_WRITE_BGR_SUPPORTED
+#define PNG_tIME_SUPPORTED
+#define PNG_tRNS_SUPPORTED
+#define PNG_UNKNOWN_CHUNKS_SUPPORTED
 #define PNG_USER_CHUNKS_SUPPORTED
-#define PNG_CONSOLE_IO_SUPPORTED
-#define PNG_WRITE_PACK_SUPPORTED
-#define PNG_READ_FILLER_SUPPORTED
+#define PNG_USER_LIMITS_SUPPORTED
+#define PNG_USER_MEM_SUPPORTED
+#define PNG_USER_TRANSFORM_INFO_SUPPORTED
+#define PNG_USER_TRANSFORM_PTR_SUPPORTED
+#define PNG_WARNINGS_SUPPORTED
+#define PNG_WRITE_16BIT_SUPPORTED
+#define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
+#define PNG_WRITE_BGR_SUPPORTED
 #define PNG_WRITE_bKGD_SUPPORTED
-#define PNG_WRITE_tRNS_SUPPORTED
-#define PNG_READ_sPLT_SUPPORTED
-#define PNG_WRITE_sCAL_SUPPORTED
+#define PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
+#define PNG_WRITE_cHRM_SUPPORTED
+#define PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
+#define PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
+#define PNG_WRITE_FILLER_SUPPORTED
+#define PNG_WRITE_FILTER_SUPPORTED
+#define PNG_WRITE_FLUSH_SUPPORTED
+#define PNG_WRITE_gAMA_SUPPORTED
+#define PNG_WRITE_hIST_SUPPORTED
+#define PNG_WRITE_iCCP_SUPPORTED
+#define PNG_WRITE_INTERLACING_SUPPORTED
+#define PNG_WRITE_INT_FUNCTIONS_SUPPORTED
+#define PNG_WRITE_INVERT_ALPHA_SUPPORTED
+#define PNG_WRITE_INVERT_SUPPORTED
+#define PNG_WRITE_iTXt_SUPPORTED
 #define PNG_WRITE_oFFs_SUPPORTED
-#define PNG_READ_tEXt_SUPPORTED
+#define PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
+#define PNG_WRITE_PACK_SUPPORTED
+#define PNG_WRITE_PACKSWAP_SUPPORTED
+#define PNG_WRITE_pCAL_SUPPORTED
+#define PNG_WRITE_pHYs_SUPPORTED
 #define PNG_WRITE_sBIT_SUPPORTED
-#define PNG_READ_INVERT_SUPPORTED
-#define PNG_READ_16_TO_8_SUPPORTED
-#define PNG_WRITE_cHRM_SUPPORTED
-#define PNG_16BIT_SUPPORTED
+#define PNG_WRITE_sCAL_SUPPORTED
+#define PNG_WRITE_SHIFT_SUPPORTED
+#define PNG_WRITE_sPLT_SUPPORTED
+#define PNG_WRITE_sRGB_SUPPORTED
+#define PNG_WRITE_SUPPORTED
+#define PNG_WRITE_SWAP_ALPHA_SUPPORTED
+#define PNG_WRITE_SWAP_SUPPORTED
+#define PNG_WRITE_tEXt_SUPPORTED
+#define PNG_WRITE_TEXT_SUPPORTED
+#define PNG_WRITE_tIME_SUPPORTED
+#define PNG_WRITE_TRANSFORMS_SUPPORTED
+#define PNG_WRITE_tRNS_SUPPORTED
+#define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
 #define PNG_WRITE_USER_TRANSFORM_SUPPORTED
-#define PNG_READ_BGR_SUPPORTED
-#define PNG_WRITE_PACKSWAP_SUPPORTED
-#define PNG_WRITE_INVERT_ALPHA_SUPPORTED
-#define PNG_sCAL_SUPPORTED
+#define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
 #define PNG_WRITE_zTXt_SUPPORTED
-#define PNG_sBIT_SUPPORTED
-#define PNG_cHRM_SUPPORTED
-#define PNG_bKGD_SUPPORTED
-#define PNG_tRNS_SUPPORTED
-#define PNG_WRITE_iTXt_SUPPORTED
-#define PNG_oFFs_SUPPORTED
-#define PNG_USER_TRANSFORM_PTR_SUPPORTED
-#define PNG_USER_TRANSFORM_INFO_SUPPORTED
-#define PNG_hIST_SUPPORTED
-#define PNG_iCCP_SUPPORTED
-#define PNG_sRGB_SUPPORTED
-#define PNG_READ_zTXt_SUPPORTED
-#define PNG_gAMA_SUPPORTED
-#define PNG_pCAL_SUPPORTED
-#define PNG_CHECK_cHRM_SUPPORTED
-#define PNG_tIME_SUPPORTED
-#define PNG_pHYs_SUPPORTED
-#define PNG_READ_iTXt_SUPPORTED
-#define PNG_TEXT_SUPPORTED
-#define PNG_SAVE_INT_32_SUPPORTED
-#define PNG_sPLT_SUPPORTED
-#define PNG_tEXt_SUPPORTED
 #define PNG_zTXt_SUPPORTED
-#define PNG_iTXt_SUPPORTED
 /* end of options */
 #endif /* PNGLCONF_H */
diff --git a/src/3rdparty/libpng/pngmem.c b/src/3rdparty/libpng/pngmem.c
index a15d8b0..bf5ff03 100644
--- a/src/3rdparty/libpng/pngmem.c
+++ b/src/3rdparty/libpng/pngmem.c
@@ -1,7 +1,7 @@
 
 /* pngmem.c - stub functions for memory allocation
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
+ * Last changed in libpng 1.5.7 [December 15, 2011]
  * Copyright (c) 1998-2011 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -56,9 +56,9 @@ png_create_struct_2,(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr),
    if (malloc_fn != NULL)
    {
       png_struct dummy_struct;
-      png_structp png_ptr = &dummy_struct;
-      png_ptr->mem_ptr=mem_ptr;
-      struct_ptr = (*(malloc_fn))(png_ptr, (png_uint_32)size);
+      memset(&dummy_struct, 0, sizeof dummy_struct);
+      dummy_struct.mem_ptr=mem_ptr;
+      struct_ptr = (*(malloc_fn))(&dummy_struct, (png_alloc_size_t)size);
    }
 
    else
@@ -90,9 +90,9 @@ png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
       if (free_fn != NULL)
       {
          png_struct dummy_struct;
-         png_structp png_ptr = &dummy_struct;
-         png_ptr->mem_ptr=mem_ptr;
-         (*(free_fn))(png_ptr, struct_ptr);
+         memset(&dummy_struct, 0, sizeof dummy_struct);
+         dummy_struct.mem_ptr=mem_ptr;
+         (*(free_fn))(&dummy_struct, struct_ptr);
          return;
       }
 
@@ -143,7 +143,7 @@ png_malloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
 
 #  ifdef PNG_USER_MEM_SUPPORTED
    if (png_ptr->malloc_fn != NULL)
-      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
+      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, size));
 
    else
       ret = (png_malloc_default(png_ptr, size));
@@ -187,8 +187,9 @@ png_malloc_default,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
             int num_blocks;
             png_uint_32 total_size;
             png_bytep table;
-            int i;
+            int i, mem_level, window_bits;
             png_byte huge * hptr;
+            int window_bits
 
             if (ret != NULL)
             {
@@ -196,14 +197,22 @@ png_malloc_default,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
                ret = NULL;
             }
 
-            if (png_ptr->zlib_window_bits > 14)
-               num_blocks = (int)(1 << (png_ptr->zlib_window_bits - 14));
+            window_bits =
+                png_ptr->zlib_window_bits >= png_ptr->zlib_text_window_bits ?
+                png_ptr->zlib_window_bits : png_ptr->zlib_text_window_bits;
+
+            if (window_bits > 14)
+               num_blocks = (int)(1 << (window_bits - 14));
 
             else
                num_blocks = 1;
 
-            if (png_ptr->zlib_mem_level >= 7)
-               num_blocks += (int)(1 << (png_ptr->zlib_mem_level - 7));
+            mem_level =
+                png_ptr->zlib_mem_level >= png_ptr->zlib_text_mem_level ?
+                png_ptr->zlib_mem_level : png_ptr->zlib_text_mem_level;
+
+            if (mem_level >= 7)
+               num_blocks += (int)(1 << (mem_level - 7));
 
             else
                num_blocks++;
@@ -277,7 +286,7 @@ png_malloc_default,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
       {
 #  ifndef PNG_USER_MEM_SUPPORTED
          if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-            png_error(png_ptr, "Out of Memory"); /* Note "o" and "M" */
+            png_error(png_ptr, "Out of Memory"); /* Note "O" and "M" */
 
          else
             png_warning(png_ptr, "Out of Memory");
diff --git a/src/3rdparty/libpng/pngpread.c b/src/3rdparty/libpng/pngpread.c
index 7b1149b..8a5aa29 100644
--- a/src/3rdparty/libpng/pngpread.c
+++ b/src/3rdparty/libpng/pngpread.c
@@ -1,8 +1,8 @@
 
 /* pngpread.c - read a png file in push mode
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.9 [February 18, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -128,30 +128,6 @@ png_process_some_data(png_structp png_ptr, png_infop info_ptr)
          break;
       }
 
-#ifdef PNG_READ_tEXt_SUPPORTED
-      case PNG_READ_tEXt_MODE:
-      {
-         png_push_read_tEXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      case PNG_READ_zTXt_MODE:
-      {
-         png_push_read_zTXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      case PNG_READ_iTXt_MODE:
-      {
-         png_push_read_iTXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
       case PNG_SKIP_MODE:
       {
          png_push_crc_finish(png_ptr);
@@ -176,7 +152,7 @@ void /* PRIVATE */
 png_push_read_sig(png_structp png_ptr, png_infop info_ptr)
 {
    png_size_t num_checked = png_ptr->sig_bytes,
-             num_to_check = 8 - num_checked;
+       num_to_check = 8 - num_checked;
 
    if (png_ptr->buffer_size < num_to_check)
    {
@@ -196,6 +172,7 @@ png_push_read_sig(png_structp png_ptr, png_infop info_ptr)
       else
          png_error(png_ptr, "PNG file corrupted by ASCII conversion");
    }
+
    else
    {
       if (png_ptr->sig_bytes >= 8)
@@ -208,61 +185,7 @@ png_push_read_sig(png_structp png_ptr, png_infop info_ptr)
 void /* PRIVATE */
 png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 {
-      PNG_IHDR;
-      PNG_IDAT;
-      PNG_IEND;
-      PNG_PLTE;
-#ifdef PNG_READ_bKGD_SUPPORTED
-      PNG_bKGD;
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-      PNG_cHRM;
-#endif
-#ifdef PNG_READ_gAMA_SUPPORTED
-      PNG_gAMA;
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-      PNG_hIST;
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-      PNG_iCCP;
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      PNG_iTXt;
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-      PNG_oFFs;
-#endif
-#ifdef PNG_READ_pCAL_SUPPORTED
-      PNG_pCAL;
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-      PNG_pHYs;
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-      PNG_sBIT;
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-      PNG_sCAL;
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-      PNG_sRGB;
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-      PNG_sPLT;
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-      PNG_tEXt;
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-      PNG_tIME;
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-      PNG_tRNS;
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      PNG_zTXt;
-#endif
+   png_uint_32 chunk_name;
 
    /* First we make sure we have enough data for the 4 byte chunk name
     * and the 4 byte chunk length before proceeding with decoding the
@@ -273,6 +196,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
    if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
    {
       png_byte chunk_length[4];
+      png_byte chunk_tag[4];
 
       if (png_ptr->buffer_size < 8)
       {
@@ -283,16 +207,27 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
       png_push_fill_buffer(png_ptr, chunk_length, 4);
       png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
       png_reset_crc(png_ptr);
-      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
+      png_crc_read(png_ptr, chunk_tag, 4);
+      png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
       png_check_chunk_name(png_ptr, png_ptr->chunk_name);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
    }
 
-   if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+   chunk_name = png_ptr->chunk_name;
+
+   if (chunk_name == png_IDAT)
+   {
+      /* This is here above the if/else case statement below because if the
+       * unknown handling marks 'IDAT' as unknown then the IDAT handling case is
+       * completely skipped.
+       *
+       * TODO: there must be a better way of doing this.
+       */
       if (png_ptr->mode & PNG_AFTER_IDAT)
          png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
+   }
 
-   if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
+   if (chunk_name == png_IHDR)
    {
       if (png_ptr->push_length != 13)
          png_error(png_ptr, "Invalid IHDR length");
@@ -306,7 +241,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
       png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);
    }
 
-   else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
+   else if (chunk_name == png_IEND)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -321,7 +256,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
    }
 
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-   else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))
+   else if (png_chunk_unknown_handling(png_ptr, chunk_name))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -329,15 +264,15 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
          return;
       }
 
-      if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+      if (chunk_name == png_IDAT)
          png_ptr->mode |= PNG_HAVE_IDAT;
 
       png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
 
-      if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
+      if (chunk_name == png_PLTE)
          png_ptr->mode |= PNG_HAVE_PLTE;
 
-      else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+      else if (chunk_name == png_IDAT)
       {
          if (!(png_ptr->mode & PNG_HAVE_IHDR))
             png_error(png_ptr, "Missing IHDR before IDAT");
@@ -349,7 +284,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
    }
 
 #endif
-   else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
+   else if (chunk_name == png_PLTE)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -359,7 +294,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
       png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);
    }
 
-   else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+   else if (chunk_name == png_IDAT)
    {
       /* If we reach an IDAT chunk, this means we have read all of the
        * header chunks, and we can start reading the image (or if this
@@ -395,7 +330,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
    }
 
 #ifdef PNG_READ_gAMA_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
+   else if (png_ptr->chunk_name == png_gAMA)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -408,7 +343,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_sBIT_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
+   else if (png_ptr->chunk_name == png_sBIT)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -421,7 +356,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_cHRM_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
+   else if (png_ptr->chunk_name == png_cHRM)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -434,7 +369,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_sRGB_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
+   else if (chunk_name == png_sRGB)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -447,7 +382,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_iCCP_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
+   else if (png_ptr->chunk_name == png_iCCP)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -460,7 +395,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_sPLT_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
+   else if (chunk_name == png_sPLT)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -473,7 +408,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_tRNS_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
+   else if (chunk_name == png_tRNS)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -486,7 +421,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_bKGD_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
+   else if (chunk_name == png_bKGD)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -499,7 +434,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_hIST_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
+   else if (chunk_name == png_hIST)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -512,7 +447,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_pHYs_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
+   else if (chunk_name == png_pHYs)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -525,7 +460,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_oFFs_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
+   else if (chunk_name == png_oFFs)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -538,7 +473,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 #endif
 
 #ifdef PNG_READ_pCAL_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
+   else if (chunk_name == png_pCAL)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -551,7 +486,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_sCAL_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
+   else if (chunk_name == png_sCAL)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -564,7 +499,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_tIME_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
+   else if (chunk_name == png_tIME)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -577,7 +512,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
 
 #endif
 #ifdef PNG_READ_tEXt_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
+   else if (chunk_name == png_tEXt)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -585,12 +520,12 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
          return;
       }
 
-      png_push_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
    }
 
 #endif
 #ifdef PNG_READ_zTXt_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
+   else if (chunk_name == png_zTXt)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -598,12 +533,12 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
          return;
       }
 
-      png_push_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
    }
 
 #endif
 #ifdef PNG_READ_iTXt_SUPPORTED
-   else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
+   else if (chunk_name == png_iTXt)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -611,7 +546,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
          return;
       }
 
-      png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
    }
 
 #endif
@@ -622,7 +557,7 @@ png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
          png_push_save_buffer(png_ptr);
          return;
       }
-      png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
    }
 
    png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
@@ -662,6 +597,7 @@ png_push_crc_finish(png_structp png_ptr)
       png_ptr->save_buffer_size -= save_size;
       png_ptr->save_buffer_ptr += save_size;
    }
+
    if (png_ptr->skip_length && png_ptr->current_buffer_size)
    {
       png_size_t save_size = png_ptr->current_buffer_size;
@@ -683,6 +619,7 @@ png_push_crc_finish(png_structp png_ptr)
       png_ptr->current_buffer_size -= save_size;
       png_ptr->current_buffer_ptr += save_size;
    }
+
    if (!png_ptr->skip_length)
    {
       if (png_ptr->buffer_size < 4)
@@ -705,6 +642,7 @@ png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
       return;
 
    ptr = buffer;
+
    if (png_ptr->save_buffer_size)
    {
       png_size_t save_size;
@@ -722,6 +660,7 @@ png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
       png_ptr->save_buffer_size -= save_size;
       png_ptr->save_buffer_ptr += save_size;
    }
+
    if (length && png_ptr->current_buffer_size)
    {
       png_size_t save_size;
@@ -751,6 +690,7 @@ png_push_save_buffer(png_structp png_ptr)
          png_bytep dp;
 
          istop = png_ptr->save_buffer_size;
+
          for (i = 0, sp = png_ptr->save_buffer_ptr, dp = png_ptr->save_buffer;
              i < istop; i++, sp++, dp++)
          {
@@ -758,6 +698,7 @@ png_push_save_buffer(png_structp png_ptr)
          }
       }
    }
+
    if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >
        png_ptr->save_buffer_max)
    {
@@ -772,8 +713,7 @@ png_push_save_buffer(png_structp png_ptr)
 
       new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
       old_buffer = png_ptr->save_buffer;
-      png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr,
-          (png_size_t)new_max);
+      png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr, new_max);
 
       if (png_ptr->save_buffer == NULL)
       {
@@ -785,6 +725,7 @@ png_push_save_buffer(png_structp png_ptr)
       png_free(png_ptr, old_buffer);
       png_ptr->save_buffer_max = new_max;
    }
+
    if (png_ptr->current_buffer_size)
    {
       png_memcpy(png_ptr->save_buffer + png_ptr->save_buffer_size,
@@ -792,6 +733,7 @@ png_push_save_buffer(png_structp png_ptr)
       png_ptr->save_buffer_size += png_ptr->current_buffer_size;
       png_ptr->current_buffer_size = 0;
    }
+
    png_ptr->save_buffer_ptr = png_ptr->save_buffer;
    png_ptr->buffer_size = 0;
 }
@@ -809,11 +751,12 @@ png_push_restore_buffer(png_structp png_ptr, png_bytep buffer,
 void /* PRIVATE */
 png_push_read_IDAT(png_structp png_ptr)
 {
-   PNG_IDAT;
    if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
    {
       png_byte chunk_length[4];
+      png_byte chunk_tag[4];
 
+      /* TODO: this code can be commoned up with the same code in push_read */
       if (png_ptr->buffer_size < 8)
       {
          png_push_save_buffer(png_ptr);
@@ -823,10 +766,11 @@ png_push_read_IDAT(png_structp png_ptr)
       png_push_fill_buffer(png_ptr, chunk_length, 4);
       png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
       png_reset_crc(png_ptr);
-      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
+      png_crc_read(png_ptr, chunk_tag, 4);
+      png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
 
-      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+      if (png_ptr->chunk_name != png_IDAT)
       {
          png_ptr->process_mode = PNG_READ_CHUNK_MODE;
 
@@ -838,6 +782,7 @@ png_push_read_IDAT(png_structp png_ptr)
 
       png_ptr->idat_size = png_ptr->push_length;
    }
+
    if (png_ptr->idat_size && png_ptr->save_buffer_size)
    {
       png_size_t save_size = png_ptr->save_buffer_size;
@@ -890,6 +835,7 @@ png_push_read_IDAT(png_structp png_ptr)
       png_ptr->current_buffer_size -= save_size;
       png_ptr->current_buffer_ptr += save_size;
    }
+
    if (!png_ptr->idat_size)
    {
       if (png_ptr->buffer_size < 4)
@@ -1011,34 +957,56 @@ png_process_IDAT_data(png_structp png_ptr, png_bytep buffer,
 void /* PRIVATE */
 png_push_process_row(png_structp png_ptr)
 {
-   png_ptr->row_info.color_type = png_ptr->color_type;
-   png_ptr->row_info.width = png_ptr->iwidth;
-   png_ptr->row_info.channels = png_ptr->channels;
-   png_ptr->row_info.bit_depth = png_ptr->bit_depth;
-   png_ptr->row_info.pixel_depth = png_ptr->pixel_depth;
+   /* 1.5.6: row_info moved out of png_struct to a local here. */
+   png_row_info row_info;
 
-   png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
-       png_ptr->row_info.width);
+   row_info.width = png_ptr->iwidth; /* NOTE: width of current interlaced row */
+   row_info.color_type = png_ptr->color_type;
+   row_info.bit_depth = png_ptr->bit_depth;
+   row_info.channels = png_ptr->channels;
+   row_info.pixel_depth = png_ptr->pixel_depth;
+   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);
 
-   png_read_filter_row(png_ptr, &(png_ptr->row_info),
-       png_ptr->row_buf + 1, png_ptr->prev_row + 1,
-       (int)(png_ptr->row_buf[0]));
+   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
+   {
+      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
+         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,
+            png_ptr->prev_row + 1, png_ptr->row_buf[0]);
+      else
+         png_error(png_ptr, "bad adaptive filter value");
+   }
+
+   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
+    * 1.5.6, while the buffer really is this big in current versions of libpng
+    * it may not be in the future, so this was changed just to copy the
+    * interlaced row count:
+    */
+   png_memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);
+
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
+   if (png_ptr->transformations)
+      png_do_read_transformations(png_ptr, &row_info);
+#endif
+
+   /* The transformed pixel depth should match the depth now in row_info. */
+   if (png_ptr->transformed_pixel_depth == 0)
+   {
+      png_ptr->transformed_pixel_depth = row_info.pixel_depth;
+      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
+         png_error(png_ptr, "progressive row overflow");
+   }
 
-   png_memcpy(png_ptr->prev_row, png_ptr->row_buf, png_ptr->rowbytes + 1);
+   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
+      png_error(png_ptr, "internal progressive row size calculation error");
 
-   if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
-      png_do_read_transformations(png_ptr);
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
    /* Blow up interlaced rows to full size */
    if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
    {
       if (png_ptr->pass < 6)
-/*       old interface (pre-1.0.9):
-         png_do_read_interlace(&(png_ptr->row_info),
-             png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
- */
-         png_do_read_interlace(png_ptr);
+         png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,
+            png_ptr->transformations);
 
     switch (png_ptr->pass)
     {
@@ -1218,24 +1186,26 @@ png_push_process_row(png_structp png_ptr)
 void /* PRIVATE */
 png_read_push_finish_row(png_structp png_ptr)
 {
+#ifdef PNG_READ_INTERLACING_SUPPORTED
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
+   static PNG_CONST png_byte FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
+   static PNG_CONST png_byte FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
+   static PNG_CONST png_byte FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
+   static PNG_CONST png_byte FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
 
    /* Height of interlace block.  This is not currently used - if you need
     * it, uncomment it here and in png.h
-   PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
+   static PNG_CONST png_byte FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
    */
+#endif
 
    png_ptr->row_number++;
    if (png_ptr->row_number < png_ptr->num_rows)
@@ -1279,519 +1249,6 @@ png_read_push_finish_row(png_structp png_ptr)
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 }
 
-#ifdef PNG_READ_tEXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-    length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-      {
-         PNG_UNUSED(info_ptr) /* To quiet some compiler warnings */
-         png_error(png_ptr, "Out of place tEXt");
-         /*NOT REACHED*/
-      }
-
-#ifdef PNG_MAX_MALLOC_64K
-   png_ptr->skip_length = 0;  /* This may not be necessary */
-
-   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
-   {
-      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
-      png_ptr->skip_length = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-       (png_size_t)(length + 1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_tEXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_tEXt(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp text;
-      png_charp key;
-      int ret;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-#ifdef PNG_MAX_MALLOC_64K
-      if (png_ptr->skip_length)
-         return;
-#endif
-
-      key = png_ptr->current_text;
-
-      for (text = key; *text; text++)
-         /* Empty loop */ ;
-
-      if (text < key + png_ptr->current_text_size)
-         text++;
-
-      text_ptr = (png_textp)png_malloc(png_ptr, png_sizeof(png_text));
-      text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
-      text_ptr->key = key;
-      text_ptr->itxt_length = 0;
-      text_ptr->lang = NULL;
-      text_ptr->lang_key = NULL;
-      text_ptr->text = text;
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_free(png_ptr, key);
-      png_free(png_ptr, text_ptr);
-      png_ptr->current_text = NULL;
-
-      if (ret)
-         png_warning(png_ptr, "Insufficient memory to store text chunk");
-   }
-}
-#endif
-
-#ifdef PNG_READ_zTXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-   {
-      PNG_UNUSED(info_ptr) /* To quiet some compiler warnings */
-      png_error(png_ptr, "Out of place zTXt");
-      /*NOT REACHED*/
-   }
-
-#ifdef PNG_MAX_MALLOC_64K
-   /* We can't handle zTXt chunks > 64K, since we don't have enough space
-    * to be able to store the uncompressed data.  Actually, the threshold
-    * is probably around 32K, but it isn't as definite as 64K is.
-    */
-   if (length > (png_uint_32)65535L)
-   {
-      png_warning(png_ptr, "zTXt chunk too large to fit in memory");
-      png_push_crc_skip(png_ptr, length);
-      return;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-       (png_size_t)(length + 1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_zTXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp text;
-      png_charp key;
-      int ret;
-      png_size_t text_size, key_size;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-      key = png_ptr->current_text;
-
-      for (text = key; *text; text++)
-         /* Empty loop */ ;
-
-      /* zTXt can't have zero text */
-      if (text >= key + png_ptr->current_text_size)
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         return;
-      }
-
-      text++;
-
-      if (*text != PNG_TEXT_COMPRESSION_zTXt) /* Check compression byte */
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         return;
-      }
-
-      text++;
-
-      png_ptr->zstream.next_in = (png_bytep)text;
-      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -
-          (text - key));
-      png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-
-      key_size = text - key;
-      text_size = 0;
-      text = NULL;
-      ret = Z_STREAM_END;
-
-      while (png_ptr->zstream.avail_in)
-      {
-         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-         if (ret != Z_OK && ret != Z_STREAM_END)
-         {
-            inflateReset(&png_ptr->zstream);
-            png_ptr->zstream.avail_in = 0;
-            png_ptr->current_text = NULL;
-            png_free(png_ptr, key);
-            png_free(png_ptr, text);
-            return;
-         }
-
-         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)
-         {
-            if (text == NULL)
-            {
-               text = (png_charp)png_malloc(png_ptr,
-                   (png_ptr->zbuf_size
-                   - png_ptr->zstream.avail_out + key_size + 1));
-
-               png_memcpy(text + key_size, png_ptr->zbuf,
-                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-
-               png_memcpy(text, key, key_size);
-
-               text_size = key_size + png_ptr->zbuf_size -
-                   png_ptr->zstream.avail_out;
-
-               *(text + text_size) = '\0';
-            }
-
-            else
-            {
-               png_charp tmp;
-
-               tmp = text;
-               text = (png_charp)png_malloc(png_ptr, text_size +
-                   (png_ptr->zbuf_size
-                   - png_ptr->zstream.avail_out + 1));
-
-               png_memcpy(text, tmp, text_size);
-               png_free(png_ptr, tmp);
-
-               png_memcpy(text + text_size, png_ptr->zbuf,
-                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-
-               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-               *(text + text_size) = '\0';
-            }
-
-            if (ret != Z_STREAM_END)
-            {
-               png_ptr->zstream.next_out = png_ptr->zbuf;
-               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-            }
-         }
-         else
-         {
-            break;
-         }
-
-         if (ret == Z_STREAM_END)
-            break;
-      }
-
-      inflateReset(&png_ptr->zstream);
-      png_ptr->zstream.avail_in = 0;
-
-      if (ret != Z_STREAM_END)
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         png_free(png_ptr, text);
-         return;
-      }
-
-      png_ptr->current_text = NULL;
-      png_free(png_ptr, key);
-      key = text;
-      text += key_size;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-          png_sizeof(png_text));
-      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;
-      text_ptr->key = key;
-      text_ptr->itxt_length = 0;
-      text_ptr->lang = NULL;
-      text_ptr->lang_key = NULL;
-      text_ptr->text = text;
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_free(png_ptr, key);
-      png_free(png_ptr, text_ptr);
-
-      if (ret)
-         png_warning(png_ptr, "Insufficient memory to store text chunk");
-   }
-}
-#endif
-
-#ifdef PNG_READ_iTXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-    length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-   {
-      PNG_UNUSED(info_ptr) /* To quiet some compiler warnings */
-      png_error(png_ptr, "Out of place iTXt");
-      /*NOT REACHED*/
-   }
-
-#ifdef PNG_MAX_MALLOC_64K
-   png_ptr->skip_length = 0;  /* This may not be necessary */
-
-   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
-   {
-      png_warning(png_ptr, "iTXt chunk too large to fit in memory");
-      png_ptr->skip_length = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
-       (png_size_t)(length + 1));
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_iTXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_iTXt(png_structp png_ptr, png_infop info_ptr)
-{
-
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp key;
-      int comp_flag;
-      png_charp lang;
-      png_charp lang_key;
-      png_charp text;
-      int ret;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-#ifdef PNG_MAX_MALLOC_64K
-      if (png_ptr->skip_length)
-         return;
-#endif
-
-      key = png_ptr->current_text;
-
-      for (lang = key; *lang; lang++)
-         /* Empty loop */ ;
-
-      if (lang < key + png_ptr->current_text_size - 3)
-         lang++;
-
-      comp_flag = *lang++;
-      lang++;     /* Skip comp_type, always zero */
-
-      for (lang_key = lang; *lang_key; lang_key++)
-         /* Empty loop */ ;
-
-      lang_key++;        /* Skip NUL separator */
-
-      text=lang_key;
-
-      if (lang_key < key + png_ptr->current_text_size - 1)
-      {
-         for (; *text; text++)
-            /* Empty loop */ ;
-      }
-
-      if (text < key + png_ptr->current_text_size)
-         text++;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-          png_sizeof(png_text));
-
-      text_ptr->compression = comp_flag + 2;
-      text_ptr->key = key;
-      text_ptr->lang = lang;
-      text_ptr->lang_key = lang_key;
-      text_ptr->text = text;
-      text_ptr->text_length = 0;
-      text_ptr->itxt_length = png_strlen(text);
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_ptr->current_text = NULL;
-
-      png_free(png_ptr, text_ptr);
-      if (ret)
-         png_warning(png_ptr, "Insufficient memory to store iTXt chunk");
-   }
-}
-#endif
-
-/* This function is called when we haven't found a handler for this
- * chunk.  If there isn't a problem with the chunk itself (ie a bad chunk
- * name or a critical chunk), the chunk is (currently) silently ignored.
- */
-void /* PRIVATE */
-png_push_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32
-    length)
-{
-   png_uint_32 skip = 0;
-
-   if (!(png_ptr->chunk_name[0] & 0x20))
-   {
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
-          PNG_HANDLE_CHUNK_ALWAYS
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-          && png_ptr->read_user_chunk_fn == NULL
-#endif
-          )
-#endif
-         png_chunk_error(png_ptr, "unknown critical chunk");
-
-      PNG_UNUSED(info_ptr) /* To quiet some compiler warnings */
-   }
-
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
-   {
-#ifdef PNG_MAX_MALLOC_64K
-      if (length > (png_uint_32)65535L)
-      {
-         png_warning(png_ptr, "unknown chunk too large to fit in memory");
-         skip = length - (png_uint_32)65535L;
-         length = (png_uint_32)65535L;
-      }
-#endif
-      png_memcpy((png_charp)png_ptr->unknown_chunk.name,
-          (png_charp)png_ptr->chunk_name,
-          png_sizeof(png_ptr->unknown_chunk.name));
-      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name) - 1]
-          = '\0';
-
-      png_ptr->unknown_chunk.size = (png_size_t)length;
-
-      if (length == 0)
-         png_ptr->unknown_chunk.data = NULL;
-
-      else
-      {
-         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr,
-             (png_size_t)length);
-         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
-      }
-
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-      if (png_ptr->read_user_chunk_fn != NULL)
-      {
-         /* Callback to user unknown chunk handler */
-         int ret;
-         ret = (*(png_ptr->read_user_chunk_fn))
-             (png_ptr, &png_ptr->unknown_chunk);
-
-         if (ret < 0)
-            png_chunk_error(png_ptr, "error in user chunk");
-
-         if (ret == 0)
-         {
-            if (!(png_ptr->chunk_name[0] & 0x20))
-               if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
-                   PNG_HANDLE_CHUNK_ALWAYS)
-                  png_chunk_error(png_ptr, "unknown critical chunk");
-            png_set_unknown_chunks(png_ptr, info_ptr,
-                &png_ptr->unknown_chunk, 1);
-         }
-      }
-
-      else
-#endif
-         png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
-      png_free(png_ptr, png_ptr->unknown_chunk.data);
-      png_ptr->unknown_chunk.data = NULL;
-   }
-
-   else
-#endif
-      skip=length;
-   png_push_crc_skip(png_ptr, skip);
-}
-
 void /* PRIVATE */
 png_push_have_info(png_structp png_ptr, png_infop info_ptr)
 {
@@ -1814,19 +1271,22 @@ png_push_have_row(png_structp png_ptr, png_bytep row)
          (int)png_ptr->pass);
 }
 
+#ifdef PNG_READ_INTERLACING_SUPPORTED
 void PNGAPI
 png_progressive_combine_row (png_structp png_ptr, png_bytep old_row,
     png_const_bytep new_row)
 {
-   PNG_CONST int FARDATA png_pass_dsp_mask[7] =
-      {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
-
    if (png_ptr == NULL)
       return;
 
-   if (new_row != NULL)    /* new_row must == png_ptr->row_buf here. */
-      png_combine_row(png_ptr, old_row, png_pass_dsp_mask[png_ptr->pass]);
+   /* new_row is a flag here - if it is NULL then the app callback was called
+    * from an empty row (see the calls to png_struct::row_fn below), otherwise
+    * it must be png_ptr->row_buf+1
+    */
+   if (new_row != NULL)
+      png_combine_row(png_ptr, old_row, 1/*display*/);
 }
+#endif /* PNG_READ_INTERLACING_SUPPORTED */
 
 void PNGAPI
 png_set_progressive_read_fn(png_structp png_ptr, png_voidp progressive_ptr,
diff --git a/src/3rdparty/libpng/pngpriv.h b/src/3rdparty/libpng/pngpriv.h
index e248ad8..e76a579 100644
--- a/src/3rdparty/libpng/pngpriv.h
+++ b/src/3rdparty/libpng/pngpriv.h
@@ -2,11 +2,11 @@
 /* pngpriv.h - private declarations for use inside libpng
  *
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
- * Last changed in libpng 1.5.0 [January 6, 2011]
+ * Last changed in libpng 1.5.10 [March 29, 2012]
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -25,16 +25,30 @@
 #ifndef PNGPRIV_H
 #define PNGPRIV_H
 
-#ifdef _MSC_VER
-#  define _CRT_SECURE_NO_DEPRECATE
-#endif
+/* Feature Test Macros.  The following are defined here to ensure that correctly
+ * implemented libraries reveal the APIs libpng needs to build and hide those
+ * that are not needed and potentially damaging to the compilation.
+ *
+ * Feature Test Macros must be defined before any system header is included (see
+ * POSIX 1003.1 2.8.2 "POSIX Symbols."
+ *
+ * These macros only have an effect if the operating system supports either
+ * POSIX 1003.1 or C99, or both.  On other operating systems (particularly
+ * Windows/Visual Studio) there is no effect; the OS specific tests below are
+ * still required (as of 2011-05-02.)
+ */
+#define _POSIX_SOURCE 1 /* Just the POSIX 1003.1 and C89 APIs */
 
 /* This is required for the definition of abort(), used as a last ditch
  * error handler when all else fails.
  */
 #include <stdlib.h>
 
-#define PNGLIB_BUILD
+/* This is used to find 'offsetof', used below for alignment tests. */
+#include <stddef.h>
+
+#define PNGLIB_BUILD /*libpng is being built, not used*/
+
 #ifdef PNG_USER_CONFIG
 #  include "pngusr.h"
    /* These should have been defined in pngusr.h */
@@ -45,10 +59,120 @@
 #    define PNG_USER_DLLFNAME_POSTFIX "Cb"
 #  endif
 #endif
+
+/* Is this a build of a DLL where compilation of the object modules requires
+ * different preprocessor settings to those required for a simple library?  If
+ * so PNG_BUILD_DLL must be set.
+ *
+ * If libpng is used inside a DLL but that DLL does not export the libpng APIs
+ * PNG_BUILD_DLL must not be set.  To avoid the code below kicking in build a
+ * static library of libpng then link the DLL against that.
+ */
+#ifndef PNG_BUILD_DLL
+#  ifdef DLL_EXPORT
+      /* This is set by libtool when files are compiled for a DLL; libtool
+       * always compiles twice, even on systems where it isn't necessary.  Set
+       * PNG_BUILD_DLL in case it is necessary:
+       */
+#     define PNG_BUILD_DLL
+#  else
+#     ifdef _WINDLL
+         /* This is set by the Microsoft Visual Studio IDE in projects that
+          * build a DLL.  It can't easily be removed from those projects (it
+          * isn't visible in the Visual Studio UI) so it is a fairly reliable
+          * indication that PNG_IMPEXP needs to be set to the DLL export
+          * attributes.
+          */
+#        define PNG_BUILD_DLL
+#     else
+#        ifdef __DLL__
+            /* This is set by the Borland C system when compiling for a DLL
+             * (as above.)
+             */
+#           define PNG_BUILD_DLL
+#        else
+            /* Add additional compiler cases here. */
+#        endif
+#     endif
+#  endif
+#endif /* Setting PNG_BUILD_DLL if required */
+
+/* See pngconf.h for more details: the builder of the library may set this on
+ * the command line to the right thing for the specific compilation system or it
+ * may be automagically set above (at present we know of no system where it does
+ * need to be set on the command line.)
+ *
+ * PNG_IMPEXP must be set here when building the library to prevent pngconf.h
+ * setting it to the "import" setting for a DLL build.
+ */
+#ifndef PNG_IMPEXP
+#  ifdef PNG_BUILD_DLL
+#     define PNG_IMPEXP PNG_DLL_EXPORT
+#  else
+      /* Not building a DLL, or the DLL doesn't require specific export
+       * definitions.
+       */
+#     define PNG_IMPEXP
+#  endif
+#endif
+
+/* No warnings for private or deprecated functions in the build: */
+#ifndef PNG_DEPRECATED
+#  define PNG_DEPRECATED
+#endif
+#ifndef PNG_PRIVATE
+#  define PNG_PRIVATE
+#endif
+
 #include "png.h"
 #include "pnginfo.h"
 #include "pngstruct.h"
 
+/* pngconf.h does not set PNG_DLL_EXPORT unless it is required, so: */
+#ifndef PNG_DLL_EXPORT
+#  define PNG_DLL_EXPORT
+#endif
+
+/* SECURITY and SAFETY:
+ *
+ * By default libpng is built without any internal limits on image size,
+ * individual heap (png_malloc) allocations or the total amount of memory used.
+ * If PNG_SAFE_LIMITS_SUPPORTED is defined, however, the limits below are used
+ * (unless individually overridden).  These limits are believed to be fairly
+ * safe, but builders of secure systems should verify the values against the
+ * real system capabilities.
+ */
+
+#ifdef PNG_SAFE_LIMITS_SUPPORTED
+   /* 'safe' limits */
+#  ifndef PNG_USER_WIDTH_MAX
+#     define PNG_USER_WIDTH_MAX 1000000
+#  endif
+#  ifndef PNG_USER_HEIGHT_MAX
+#     define PNG_USER_HEIGHT_MAX 1000000
+#  endif
+#  ifndef PNG_USER_CHUNK_CACHE_MAX
+#     define PNG_USER_CHUNK_CACHE_MAX 128
+#  endif
+#  ifndef PNG_USER_CHUNK_MALLOC_MAX
+#     define PNG_USER_CHUNK_MALLOC_MAX 8000000
+#  endif
+#else
+   /* values for no limits */
+#  ifndef PNG_USER_WIDTH_MAX
+#     define PNG_USER_WIDTH_MAX 0x7fffffff
+#  endif
+#  ifndef PNG_USER_HEIGHT_MAX
+#     define PNG_USER_HEIGHT_MAX 0x7fffffff
+#  endif
+#  ifndef PNG_USER_CHUNK_CACHE_MAX
+#     define PNG_USER_CHUNK_CACHE_MAX 0
+#  endif
+#  ifndef PNG_USER_CHUNK_MALLOC_MAX
+#     define PNG_USER_CHUNK_MALLOC_MAX 0
+#  endif
+#endif
+
 /* This is used for 16 bit gamma tables - only the top level pointers are const,
  * this could be changed:
  */
@@ -87,13 +211,15 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
 #  define PNG_MAX_MALLOC_64K
 #endif
 
+#ifndef PNG_UNUSED
 /* Unused formal parameter warnings are silenced using the following macro
  * which is expected to have no bad effects on performance (optimizing
  * compilers will probably remove it entirely).  Note that if you replace
  * it with something other than whitespace, you must include the terminating
  * semicolon.
  */
-#define PNG_UNUSED(param) (void)param;
+#  define PNG_UNUSED(param) (void)param;
+#endif
 
 /* Just a little check that someone hasn't tried to define something
  * contradictory.
@@ -103,12 +229,44 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
 #  define PNG_ZBUF_SIZE 65536L
 #endif
 
-/* If warnings or errors are turned off the code is disabled
- * or redirected here.
+/* PNG_STATIC is used to mark internal file scope functions if they need to be
+ * accessed for implementation tests (see the code in tests/?*).
  */
-#ifndef PNG_WARNINGS_SUPPORTED
-#  define png_warning(s1,s2) ((void)0)
-#  define png_chunk_warning(s1,s2) ((void)0)
+#ifndef PNG_STATIC
+#   define PNG_STATIC static
+#endif
+
+/* C99 restrict is used where possible, to do this 'restrict' is defined as
+ * empty if we can't be sure it is supported.  configure builds have already
+ * done this work.
+ */
+#ifdef PNG_CONFIGURE_LIBPNG
+#  define PNG_RESTRICT restrict
+#else
+   /* Modern compilers support restrict, but assume not for anything not
+    * recognized here:
+    */
+#  if defined __GNUC__ || defined _MSC_VER || defined __WATCOMC__
+#     define PNG_RESTRICT restrict
+#  else
+#     define PNG_RESTRICT
+#  endif
+#endif
+
+/* If warnings or errors are turned off the code is disabled or redirected here.
+ * From 1.5.4 functions have been added to allow very limited formatting of
+ * error and warning messages - this code will also be disabled here.
+ */
+#ifdef PNG_WARNINGS_SUPPORTED
+#  define PNG_WARNING_PARAMETERS(p) png_warning_parameters p;
+#else
+#  define png_warning(s1,s2) ((void)(s1))
+#  define png_chunk_warning(s1,s2) ((void)(s1))
+#  define png_warning_parameter(p,number,string) ((void)0)
+#  define png_warning_parameter_unsigned(p,number,format,value) ((void)0)
+#  define png_warning_parameter_signed(p,number,format,value) ((void)0)
+#  define png_formatted_warning(pp,p,message) ((void)(pp))
+#  define PNG_WARNING_PARAMETERS(p)
 #endif
 #ifndef PNG_ERROR_TEXT_SUPPORTED
 #  define png_error(s1,s2) png_err(s1)
@@ -116,15 +274,28 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
 #  define png_fixed_error(s1,s2) png_err(s1)
 #endif
 
+/* C allows up-casts from (void*) to any pointer and (const void*) to any
+ * pointer to a const object.  C++ regards this as a type error and requires an
+ * explicit, static, cast and provides the static_cast<> rune to ensure that
+ * const is not cast away.
+ */
+#ifdef __cplusplus
+#  define png_voidcast(type, value) static_cast<type>(value)
+#else
+#  define png_voidcast(type, value) (value)
+#endif /* __cplusplus */
+
 #ifndef PNG_EXTERN
 /* The functions exported by PNG_EXTERN are internal functions, which
  * aren't usually used outside the library (as far as I know), so it is
  * debatable if they should be exported at all.  In the future, when it
  * is possible to have run-time registry of chunk-handling functions,
  * some of these might be made available again.
-#  define PNG_EXTERN extern
+ *
+ * 1.5.7: turned the use of 'extern' back on, since it is localized to pngpriv.h
+ * it should be safe now (it is unclear why it was turned off.)
  */
-#  define PNG_EXTERN
+#  define PNG_EXTERN extern
 #endif
 
 /* Some fixed point APIs are still required even if not exported because
@@ -189,7 +360,7 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
 
 /* Memory model/platform independent fns */
 #ifndef PNG_ABORT
-#  if defined(_WINDOWS_) || defined(_WIN32_WCE)
+#  ifdef _WINDOWS_
 #    define PNG_ABORT() ExitProcess(0)
 #  else
 #    define PNG_ABORT() abort()
@@ -202,60 +373,74 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
 #  define NOCHECK 0
 #  define CVT_PTR(ptr) (png_far_to_near(png_ptr,ptr,CHECK))
 #  define CVT_PTR_NOCHECK(ptr) (png_far_to_near(png_ptr,ptr,NOCHECK))
-#  define png_strcpy  _fstrcpy
-#  define png_strncpy _fstrncpy   /* Added to v 1.2.6 */
 #  define png_strlen  _fstrlen
 #  define png_memcmp  _fmemcmp    /* SJT: added */
 #  define png_memcpy  _fmemcpy
 #  define png_memset  _fmemset
-#  define png_sprintf sprintf
 #else
 #  ifdef _WINDOWS_  /* Favor Windows over C runtime fns */
 #    define CVT_PTR(ptr)         (ptr)
 #    define CVT_PTR_NOCHECK(ptr) (ptr)
-#    define png_strcpy  lstrcpyA
-#    define png_strncpy lstrcpynA
 #    define png_strlen  lstrlenA
 #    define png_memcmp  memcmp
 #    define png_memcpy  CopyMemory
 #    define png_memset  memset
-#    define png_sprintf wsprintfA
 #  else
 #    define CVT_PTR(ptr)         (ptr)
 #    define CVT_PTR_NOCHECK(ptr) (ptr)
-#    define png_strcpy  strcpy
-#    define png_strncpy strncpy     /* Added to v 1.2.6 */
 #    define png_strlen  strlen
 #    define png_memcmp  memcmp      /* SJT: added */
 #    define png_memcpy  memcpy
 #    define png_memset  memset
-#    define png_sprintf sprintf
 #  endif
 #endif
-/* End of memory model/platform independent support */
 
-#ifndef PNG_NO_SNPRINTF
-#  ifdef _MSC_VER
-#    define png_snprintf _snprintf   /* Added to v 1.2.19 */
-#    define png_snprintf2 _snprintf
-#    define png_snprintf6 _snprintf
+/* These macros may need to be architecture dependent. */
+#define PNG_ALIGN_NONE   0 /* do not use data alignment */
+#define PNG_ALIGN_ALWAYS 1 /* assume unaligned accesses are OK */
+#ifdef offsetof
+#  define PNG_ALIGN_OFFSET 2 /* use offsetof to determine alignment */
+#else
+#  define PNG_ALIGN_OFFSET -1 /* prevent the use of this */
+#endif
+#define PNG_ALIGN_SIZE   3 /* use sizeof to determine alignment */
+
+#ifndef PNG_ALIGN_TYPE
+   /* Default to using aligned access optimizations and requiring alignment to a
+    * multiple of the data type size.  Override in a compiler specific fashion
+    * if necessary by inserting tests here:
+    */
+#  define PNG_ALIGN_TYPE PNG_ALIGN_SIZE
+#endif
+
+#if PNG_ALIGN_TYPE == PNG_ALIGN_SIZE
+   /* This is used because in some compiler implementations non-aligned
+    * structure members are supported, so the offsetof approach below fails.
+    * Set PNG_ALIGN_TO_SIZE=0 for compiler combinations where unaligned access
+    * is good for performance.  Do not do this unless you have tested the result
+    * and understand it.
+    */
+#  define png_alignof(type) (sizeof (type))
+#else
+#  if PNG_ALIGN_TYPE == PNG_ALIGN_OFFSET
+#     define png_alignof(type) offsetof(struct{char c; type t;}, t)
 #  else
-#    define png_snprintf snprintf   /* Added to v 1.2.19 */
-#    define png_snprintf2 snprintf
-#    define png_snprintf6 snprintf
+#     if PNG_ALIGN_TYPE == PNG_ALIGN_ALWAYS
+#        define png_alignof(type) (1)
+#     endif
+      /* Else leave png_alignof undefined to prevent use thereof */
 #  endif
+#endif
+
+/* This implicitly assumes alignment is always to a power of 2. */
+#ifdef png_alignof
+#  define png_isaligned(ptr, type)\
+   ((((const char*)ptr-(const char*)0) & (png_alignof(type)-1)) == 0)
 #else
-  /* You don't have or don't want to use snprintf().  Caution: Using
-   * sprintf instead of snprintf exposes your application to accidental
-   * or malevolent buffer overflows.  If you don't have snprintf()
-   * as a general rule you should provide one (you can get one from
-   * Portable OpenSSH).
-   */
-#  define png_snprintf(s1,n,fmt,x1) png_sprintf(s1,fmt,x1)
-#  define png_snprintf2(s1,n,fmt,x1,x2) png_sprintf(s1,fmt,x1,x2)
-#  define png_snprintf6(s1,n,fmt,x1,x2,x3,x4,x5,x6) \
-      png_sprintf(s1,fmt,x1,x2,x3,x4,x5,x6)
+#  define png_isaligned(ptr, type) 0
 #endif
+
+/* End of memory model/platform independent support */
 /* End of 1.5.0beta36 move from pngconf.h */
 
 /* CONSTANTS and UTILITY MACROS
@@ -263,12 +448,14 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
  */
 
 /* Various modes of operation.  Note that after an init, mode is set to
- * zero automatically when the structure is created.
+ * zero automatically when the structure is created.  Three of these
+ * are defined in png.h because they need to be visible to applications
+ * that call png_set_unknown_chunk().
  */
-#define PNG_HAVE_IHDR               0x01
-#define PNG_HAVE_PLTE               0x02
+/* #define PNG_HAVE_IHDR            0x01 (defined in png.h) */
+/* #define PNG_HAVE_PLTE            0x02 (defined in png.h) */
 #define PNG_HAVE_IDAT               0x04
-#define PNG_AFTER_IDAT              0x08 /* Have complete zlib datastream */
+/* #define PNG_AFTER_IDAT           0x08 (defined in png.h) */
 #define PNG_HAVE_IEND               0x10
 #define PNG_HAVE_gAMA               0x20
 #define PNG_HAVE_cHRM               0x40
@@ -279,6 +466,7 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
 #define PNG_BACKGROUND_IS_GRAY     0x800
 #define PNG_HAVE_PNG_SIGNATURE    0x1000
 #define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
+#define PNG_HAVE_iCCP             0x4000
 
 /* Flags for the transformations the PNG library does on the image data */
 #define PNG_BGR                 0x0001
@@ -288,32 +476,31 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
 #define PNG_SWAP_BYTES          0x0010
 #define PNG_INVERT_MONO         0x0020
 #define PNG_QUANTIZE            0x0040
-#define PNG_BACKGROUND          0x0080
+#define PNG_COMPOSE             0x0080     /* Was PNG_BACKGROUND */
 #define PNG_BACKGROUND_EXPAND   0x0100
-                          /*    0x0200 unused */
-#define PNG_16_TO_8             0x0400
+#define PNG_EXPAND_16           0x0200     /* Added to libpng 1.5.2 */
+#define PNG_16_TO_8             0x0400     /* Becomes 'chop' in 1.5.4 */
 #define PNG_RGBA                0x0800
 #define PNG_EXPAND              0x1000
 #define PNG_GAMMA               0x2000
 #define PNG_GRAY_TO_RGB         0x4000
-#define PNG_FILLER              0x8000L
-#define PNG_PACKSWAP           0x10000L
-#define PNG_SWAP_ALPHA         0x20000L
-#define PNG_STRIP_ALPHA        0x40000L
-#define PNG_INVERT_ALPHA       0x80000L
-#define PNG_USER_TRANSFORM    0x100000L
-#define PNG_RGB_TO_GRAY_ERR   0x200000L
-#define PNG_RGB_TO_GRAY_WARN  0x400000L
-#define PNG_RGB_TO_GRAY       0x600000L  /* two bits, RGB_TO_GRAY_ERR|WARN */
-                       /*     0x800000L     Unused */
-#define PNG_ADD_ALPHA         0x1000000L  /* Added to libpng-1.2.7 */
-#define PNG_EXPAND_tRNS       0x2000000L  /* Added to libpng-1.2.9 */
-                       /*   0x4000000L  unused */
-                       /*   0x8000000L  unused */
-                       /*  0x10000000L  unused */
-                       /*  0x20000000L  unused */
-                       /*  0x40000000L  unused */
-
+#define PNG_FILLER              0x8000
+#define PNG_PACKSWAP           0x10000
+#define PNG_SWAP_ALPHA         0x20000
+#define PNG_STRIP_ALPHA        0x40000
+#define PNG_INVERT_ALPHA       0x80000
+#define PNG_USER_TRANSFORM    0x100000
+#define PNG_RGB_TO_GRAY_ERR   0x200000
+#define PNG_RGB_TO_GRAY_WARN  0x400000
+#define PNG_RGB_TO_GRAY       0x600000 /* two bits, RGB_TO_GRAY_ERR|WARN */
+#define PNG_ENCODE_ALPHA      0x800000 /* Added to libpng-1.5.4 */
+#define PNG_ADD_ALPHA         0x1000000 /* Added to libpng-1.2.7 */
+#define PNG_EXPAND_tRNS       0x2000000 /* Added to libpng-1.2.9 */
+#define PNG_SCALE_16_TO_8     0x4000000 /* Added to libpng-1.5.4 */
+                       /*   0x8000000 unused */
+                       /*  0x10000000 unused */
+                       /*  0x20000000 unused */
+                       /*  0x40000000 unused */
 /* Flags for png_create_struct */
 #define PNG_STRUCT_PNG   0x0001
 #define PNG_STRUCT_INFO  0x0002
@@ -335,25 +522,25 @@ typedef PNG_CONST png_uint_16p FAR * png_const_uint_16pp;
 #define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200
 #define PNG_FLAG_CRC_CRITICAL_USE         0x0400
 #define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800
-                                /*        0x1000  unused */
-                                /*        0x2000  unused */
-                                /*        0x4000  unused */
-#define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000L
-#define PNG_FLAG_KEEP_UNSAFE_CHUNKS       0x10000L
-#define PNG_FLAG_LIBRARY_MISMATCH         0x20000L
-#define PNG_FLAG_STRIP_ERROR_NUMBERS      0x40000L
-#define PNG_FLAG_STRIP_ERROR_TEXT         0x80000L
-#define PNG_FLAG_MALLOC_NULL_MEM_OK       0x100000L
-#define PNG_FLAG_ADD_ALPHA                0x200000L  /* Added to libpng-1.2.8 */
-#define PNG_FLAG_STRIP_ALPHA              0x400000L  /* Added to libpng-1.2.8 */
-#define PNG_FLAG_BENIGN_ERRORS_WARN       0x800000L  /* Added to libpng-1.4.0 */
-                                  /*     0x1000000L  unused */
-                                  /*     0x2000000L  unused */
-                                  /*     0x4000000L  unused */
-                                  /*     0x8000000L  unused */
-                                  /*    0x10000000L  unused */
-                                  /*    0x20000000L  unused */
-                                  /*    0x40000000L  unused */
+#define PNG_FLAG_ASSUME_sRGB              0x1000  /* Added to libpng-1.5.4 */
+#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000  /* Added to libpng-1.5.4 */
+#define PNG_FLAG_DETECT_UNINITIALIZED     0x4000  /* Added to libpng-1.5.4 */
+#define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000
+#define PNG_FLAG_KEEP_UNSAFE_CHUNKS       0x10000
+#define PNG_FLAG_LIBRARY_MISMATCH         0x20000
+#define PNG_FLAG_STRIP_ERROR_NUMBERS      0x40000
+#define PNG_FLAG_STRIP_ERROR_TEXT         0x80000
+#define PNG_FLAG_MALLOC_NULL_MEM_OK       0x100000
+                                  /*      0x200000  unused */
+                                  /*      0x400000  unused */
+#define PNG_FLAG_BENIGN_ERRORS_WARN       0x800000  /* Added to libpng-1.4.0 */
+#define PNG_FLAG_ZTXT_CUSTOM_STRATEGY    0x1000000  /* 5 lines added */
+#define PNG_FLAG_ZTXT_CUSTOM_LEVEL       0x2000000  /* to libpng-1.5.4 */
+#define PNG_FLAG_ZTXT_CUSTOM_MEM_LEVEL   0x4000000
+#define PNG_FLAG_ZTXT_CUSTOM_WINDOW_BITS 0x8000000
+#define PNG_FLAG_ZTXT_CUSTOM_METHOD      0x10000000
+                                  /*     0x20000000  unused */
+                                  /*     0x40000000  unused */
 
 #define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
                                      PNG_FLAG_CRC_ANCILLARY_NOWARN)
@@ -435,32 +622,75 @@ PNG_EXTERN png_fixed_point png_fixed PNGARG((png_structp png_ptr, double fp,
 #endif
 #endif
 
-/* Constant strings for known chunk types.  If you need to add a chunk,
- * define the name here, and add an invocation of the macro wherever it's
- * needed.
+/* Constants for known chunk types.  If you need to add a chunk, define the name
+ * here.  For historical reasons these constants have the form png_<name>; i.e.
+ * the prefix is lower case.  Please use decimal values as the parameters to
+ * match the ISO PNG specification and to avoid relying on the C locale
+ * interpretation of character values.
+ *
+ * Prior to 1.5.6 these constants were strings, as of 1.5.6 png_uint_32 values
+ * are computed and a new macro (PNG_STRING_FROM_CHUNK) added to allow a string
+ * to be generated if required.
+ *
+ * PNG_32b correctly produces a value shifted by up to 24 bits, even on
+ * architectures where (int) is only 16 bits.
  */
-#define PNG_IHDR PNG_CONST png_byte png_IHDR[5] = { 73,  72,  68,  82, '\0'}
-#define PNG_IDAT PNG_CONST png_byte png_IDAT[5] = { 73,  68,  65,  84, '\0'}
-#define PNG_IEND PNG_CONST png_byte png_IEND[5] = { 73,  69,  78,  68, '\0'}
-#define PNG_PLTE PNG_CONST png_byte png_PLTE[5] = { 80,  76,  84,  69, '\0'}
-#define PNG_bKGD PNG_CONST png_byte png_bKGD[5] = { 98,  75,  71,  68, '\0'}
-#define PNG_cHRM PNG_CONST png_byte png_cHRM[5] = { 99,  72,  82,  77, '\0'}
-#define PNG_gAMA PNG_CONST png_byte png_gAMA[5] = {103,  65,  77,  65, '\0'}
-#define PNG_hIST PNG_CONST png_byte png_hIST[5] = {104,  73,  83,  84, '\0'}
-#define PNG_iCCP PNG_CONST png_byte png_iCCP[5] = {105,  67,  67,  80, '\0'}
-#define PNG_iTXt PNG_CONST png_byte png_iTXt[5] = {105,  84,  88, 116, '\0'}
-#define PNG_oFFs PNG_CONST png_byte png_oFFs[5] = {111,  70,  70, 115, '\0'}
-#define PNG_pCAL PNG_CONST png_byte png_pCAL[5] = {112,  67,  65,  76, '\0'}
-#define PNG_sCAL PNG_CONST png_byte png_sCAL[5] = {115,  67,  65,  76, '\0'}
-#define PNG_pHYs PNG_CONST png_byte png_pHYs[5] = {112,  72,  89, 115, '\0'}
-#define PNG_sBIT PNG_CONST png_byte png_sBIT[5] = {115,  66,  73,  84, '\0'}
-#define PNG_sPLT PNG_CONST png_byte png_sPLT[5] = {115,  80,  76,  84, '\0'}
-#define PNG_sRGB PNG_CONST png_byte png_sRGB[5] = {115,  82,  71,  66, '\0'}
-#define PNG_sTER PNG_CONST png_byte png_sTER[5] = {115,  84,  69,  82, '\0'}
-#define PNG_tEXt PNG_CONST png_byte png_tEXt[5] = {116,  69,  88, 116, '\0'}
-#define PNG_tIME PNG_CONST png_byte png_tIME[5] = {116,  73,  77,  69, '\0'}
-#define PNG_tRNS PNG_CONST png_byte png_tRNS[5] = {116,  82,  78,  83, '\0'}
-#define PNG_zTXt PNG_CONST png_byte png_zTXt[5] = {122,  84,  88, 116, '\0'}
+#define PNG_32b(b,s) ((png_uint_32)(b) << (s))
+#define PNG_CHUNK(b1,b2,b3,b4) \
+   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
+
+#define png_IHDR PNG_CHUNK( 73,  72,  68,  82)
+#define png_IDAT PNG_CHUNK( 73,  68,  65,  84)
+#define png_IEND PNG_CHUNK( 73,  69,  78,  68)
+#define png_PLTE PNG_CHUNK( 80,  76,  84,  69)
+#define png_bKGD PNG_CHUNK( 98,  75,  71,  68)
+#define png_cHRM PNG_CHUNK( 99,  72,  82,  77)
+#define png_gAMA PNG_CHUNK(103,  65,  77,  65)
+#define png_hIST PNG_CHUNK(104,  73,  83,  84)
+#define png_iCCP PNG_CHUNK(105,  67,  67,  80)
+#define png_iTXt PNG_CHUNK(105,  84,  88, 116)
+#define png_oFFs PNG_CHUNK(111,  70,  70, 115)
+#define png_pCAL PNG_CHUNK(112,  67,  65,  76)
+#define png_sCAL PNG_CHUNK(115,  67,  65,  76)
+#define png_pHYs PNG_CHUNK(112,  72,  89, 115)
+#define png_sBIT PNG_CHUNK(115,  66,  73,  84)
+#define png_sPLT PNG_CHUNK(115,  80,  76,  84)
+#define png_sRGB PNG_CHUNK(115,  82,  71,  66)
+#define png_sTER PNG_CHUNK(115,  84,  69,  82)
+#define png_tEXt PNG_CHUNK(116,  69,  88, 116)
+#define png_tIME PNG_CHUNK(116,  73,  77,  69)
+#define png_tRNS PNG_CHUNK(116,  82,  78,  83)
+#define png_zTXt PNG_CHUNK(122,  84,  88, 116)
+
+/* The following will work on (signed char*) strings, whereas the get_uint_32
+ * macro will fail on top-bit-set values because of the sign extension.
+ */
+#define PNG_CHUNK_FROM_STRING(s)\
+   PNG_CHUNK(0xff&(s)[0], 0xff&(s)[1], 0xff&(s)[2], 0xff&(s)[3])
+
+/* This uses (char), not (png_byte) to avoid warnings on systems where (char) is
+ * signed and the argument is a (char[])  This macro will fail miserably on
+ * systems where (char) is more than 8 bits.
+ */
+#define PNG_STRING_FROM_CHUNK(s,c)\
+   (void)(((char*)(s))[0]=(char)((c)>>24), ((char*)(s))[1]=(char)((c)>>16),\
+   ((char*)(s))[2]=(char)((c)>>8), ((char*)(s))[3]=(char)((c)))
+
+/* Do the same but terminate with a null character. */
+#define PNG_CSTRING_FROM_CHUNK(s,c)\
+   (void)(PNG_STRING_FROM_CHUNK(s,c), ((char*)(s))[4] = 0)
+
+/* Test on flag values as defined in the spec (section 5.4): */
+#define PNG_CHUNK_ANCILLIARY(c)   (1 & ((c) >> 29))
+#define PNG_CHUNK_CRITICAL(c)     (!PNG_CHUNK_ANCILLIARY(c))
+#define PNG_CHUNK_PRIVATE(c)      (1 & ((c) >> 21))
+#define PNG_CHUNK_RESERVED(c)     (1 & ((c) >> 13))
+#define PNG_CHUNK_SAFE_TO_COPY(c) (1 & ((c) >>  5))
+
+/* Gamma values (new at libpng-1.5.4): */
+#define PNG_GAMMA_MAC_OLD 151724  /* Assume '1.8' is really 2.2/1.45! */
+#define PNG_GAMMA_MAC_INVERSE 65909
+#define PNG_GAMMA_sRGB_INVERSE 45455
 
 
 /* Inhibit C++ name-mangling for libpng functions but not for system calls. */
@@ -474,6 +704,12 @@ extern "C" {
  * be found in the files where the functions are located.
  */
 
+/* Check the user version string for compatibility, returns false if the version
+ * numbers aren't compatible.
+ */
+PNG_EXTERN int png_user_version_check(png_structp png_ptr,
+   png_const_charp user_png_ver);
+
 /* Allocate memory for an internal libpng struct */
 PNG_EXTERN PNG_FUNCTION(png_voidp,png_create_struct,PNGARG((int type)),
    PNG_ALLOCATED);
@@ -542,8 +778,7 @@ PNG_EXTERN void png_crc_read PNGARG((png_structp png_ptr, png_bytep buf,
     png_size_t length));
 
 /* Decompress data in a chunk that uses compression */
-#if defined(PNG_zTXt_SUPPORTED) || defined(PNG_iTXt_SUPPORTED) || \
-    defined(PNG_iCCP_SUPPORTED) || defined(PNG_sPLT_SUPPORTED)
+#if defined(PNG_READ_COMPRESSED_TEXT_SUPPORTED)
 PNG_EXTERN void png_decompress_chunk PNGARG((png_structp png_ptr,
     int comp_type, png_size_t chunklength, png_size_t prefix_length,
     png_size_t *data_length));
@@ -646,6 +881,7 @@ PNG_EXTERN void png_write_hIST PNGARG((png_structp png_ptr,
     png_const_uint_16p hist, int num_hist));
 #endif
 
+/* Chunks that have keywords */
 #if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
     defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
 PNG_EXTERN png_size_t png_check_keyword PNGARG((png_structp png_ptr,
@@ -706,17 +942,44 @@ PNG_EXTERN void png_write_finish_row PNGARG((png_structp png_ptr));
 /* Internal use only.   Called before first row of data */
 PNG_EXTERN void png_write_start_row PNGARG((png_structp png_ptr));
 
-/* Combine a row of data, dealing with alpha, etc. if requested */
+/* Combine a row of data, dealing with alpha, etc. if requested.  'row' is an
+ * array of png_ptr->width pixels.  If the image is not interlaced or this
+ * is the final pass this just does a png_memcpy, otherwise the "display" flag
+ * is used to determine whether to copy pixels that are not in the current pass.
+ *
+ * Because 'png_do_read_interlace' (below) replicates pixels this allows this
+ * function to achieve the documented 'blocky' appearance during interlaced read
+ * if display is 1 and the 'sparkle' appearance, where existing pixels in 'row'
+ * are not changed if they are not in the current pass, when display is 0.
+ *
+ * 'display' must be 0 or 1, otherwise the memcpy will be done regardless.
+ *
+ * The API always reads from the png_struct row buffer and always assumes that
+ * it is full width (png_do_read_interlace has already been called.)
+ *
+ * This function is only ever used to write to row buffers provided by the
+ * caller of the relevant libpng API and the row must have already been
+ * transformed by the read transformations.
+ *
+ * The PNG_USE_COMPILE_TIME_MASKS option causes generation of pre-computed
+ * bitmasks for use within the code, otherwise runtime generated masks are used.
+ * The default is compile time masks.
+ */
+#ifndef PNG_USE_COMPILE_TIME_MASKS
+#  define PNG_USE_COMPILE_TIME_MASKS 1
+#endif
 PNG_EXTERN void png_combine_row PNGARG((png_structp png_ptr, png_bytep row,
-    int mask));
+    int display));
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
-/* Expand an interlaced row */
-/* OLD pre-1.0.9 interface:
+/* Expand an interlaced row: the 'row_info' describes the pass data that has
+ * been read in and must correspond to the pixels in 'row', the pixels are
+ * expanded (moved apart) in 'row' to match the final layout, when doing this
+ * the pixels are *replicated* to the intervening space.  This is essential for
+ * the correct operation of png_combine_row, above.
+ */
 PNG_EXTERN void png_do_read_interlace PNGARG((png_row_infop row_info,
     png_bytep row, int pass, png_uint_32 transformations));
- */
-PNG_EXTERN void png_do_read_interlace PNGARG((png_structp png_ptr));
 #endif
 
 /* GRR TO DO (2.0 or whenever):  simplify other internal calling interfaces */
@@ -727,26 +990,42 @@ PNG_EXTERN void png_do_write_interlace PNGARG((png_row_infop row_info,
     png_bytep row, int pass));
 #endif
 
-/* Unfilter a row */
-PNG_EXTERN void png_read_filter_row PNGARG((png_structp png_ptr,
-    png_row_infop row_info, png_bytep row, png_const_bytep prev_row,
-    int filter));
+/* Unfilter a row: check the filter value before calling this, there is no point
+ * calling it for PNG_FILTER_VALUE_NONE.
+ */
+PNG_EXTERN void png_read_filter_row PNGARG((png_structp pp, png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row, int filter));
+
+PNG_EXTERN void png_read_filter_row_up_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_sub3_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_sub4_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_avg3_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_avg4_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_paeth3_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_paeth4_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row));
 
 /* Choose the best filter to use and filter the row data */
 PNG_EXTERN void png_write_find_filter PNGARG((png_structp png_ptr,
     png_row_infop row_info));
 
-/* Write out the filtered row. */
-PNG_EXTERN void png_write_filtered_row PNGARG((png_structp png_ptr,
-    png_bytep filtered_row));
 /* Finish a row while reading, dealing with interlacing passes, etc. */
 PNG_EXTERN void png_read_finish_row PNGARG((png_structp png_ptr));
 
 /* Initialize the row buffers, etc. */
 PNG_EXTERN void png_read_start_row PNGARG((png_structp png_ptr));
+
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
 /* Optional call to update the users info structure */
 PNG_EXTERN void png_read_transform_info PNGARG((png_structp png_ptr,
     png_infop info_ptr));
+#endif
 
 /* These are the functions that do the transformations */
 #ifdef PNG_READ_FILLER_SUPPORTED
@@ -776,8 +1055,8 @@ PNG_EXTERN void png_do_write_invert_alpha PNGARG((png_row_infop row_info,
 
 #if defined(PNG_WRITE_FILLER_SUPPORTED) || \
     defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
-PNG_EXTERN void png_do_strip_filler PNGARG((png_row_infop row_info,
-    png_bytep row, png_uint_32 flags));
+PNG_EXTERN void png_do_strip_channel PNGARG((png_row_infop row_info,
+    png_bytep row, int at_start));
 #endif
 
 #ifdef PNG_16BIT_SUPPORTED
@@ -818,7 +1097,12 @@ PNG_EXTERN void png_do_invert PNGARG((png_row_infop row_info,
     png_bytep row));
 #endif
 
-#ifdef PNG_READ_16_TO_8_SUPPORTED
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+PNG_EXTERN void png_do_scale_16_to_8 PNGARG((png_row_infop row_info,
+    png_bytep row));
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
 PNG_EXTERN void png_do_chop PNGARG((png_row_infop row_info,
     png_bytep row));
 #endif
@@ -849,26 +1133,20 @@ PNG_EXTERN void png_do_shift PNGARG((png_row_infop row_info,
     png_bytep row, png_const_color_8p bit_depth));
 #endif
 
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-#  ifdef PNG_READ_GAMMA_SUPPORTED
-PNG_EXTERN void png_do_background PNGARG((png_row_infop row_info,
-    png_bytep row, png_const_color_16p trans_color,
-    png_const_color_16p background, png_const_color_16p background_1,
-    png_const_bytep gamma_table, png_const_bytep gamma_from_1,
-    png_const_bytep gamma_to_1, png_const_uint_16pp gamma_16,
-    png_const_uint_16pp gamma_16_from_1, png_const_uint_16pp gamma_16_to_1,
-    int gamma_shift));
-#  else
-PNG_EXTERN void png_do_background PNGARG((png_row_infop row_info,
-    png_bytep row, png_const_color_16p trans_color,
-    png_const_color_16p background));
-#  endif
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
+    defined(PNG_READ_ALPHA_MODE_SUPPORTED)
+PNG_EXTERN void png_do_compose PNGARG((png_row_infop row_info,
+    png_bytep row, png_structp png_ptr));
 #endif
 
 #ifdef PNG_READ_GAMMA_SUPPORTED
 PNG_EXTERN void png_do_gamma PNGARG((png_row_infop row_info,
-    png_bytep row, png_const_bytep gamma_table,
-    png_const_uint_16pp gamma_16_table, int gamma_shift));
+    png_bytep row, png_structp png_ptr));
+#endif
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+PNG_EXTERN void png_do_encode_alpha PNGARG((png_row_infop row_info,
+   png_bytep row, png_structp png_ptr));
 #endif
 
 #ifdef PNG_READ_EXPAND_SUPPORTED
@@ -879,6 +1157,11 @@ PNG_EXTERN void png_do_expand PNGARG((png_row_infop row_info,
     png_bytep row, png_const_color_16p trans_color));
 #endif
 
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+PNG_EXTERN void png_do_expand_16 PNGARG((png_row_infop row_info,
+    png_bytep row));
+#endif
+
 /* The following decodes the appropriate chunks, and does error correction,
  * then calls the appropriate callback for the chunk if it is valid.
  */
@@ -976,17 +1259,35 @@ PNG_EXTERN void png_handle_zTXt PNGARG((png_structp png_ptr, png_infop info_ptr,
     png_uint_32 length));
 #endif
 
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
 PNG_EXTERN void png_handle_unknown PNGARG((png_structp png_ptr,
     png_infop info_ptr, png_uint_32 length));
+#endif
 
 PNG_EXTERN void png_check_chunk_name PNGARG((png_structp png_ptr,
-    png_const_bytep chunk_name));
+    png_uint_32 chunk_name));
+
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+/* Exactly as png_handle_as_unknown() except that the argument is a 32-bit chunk
+ * name, not a string.
+ */
+PNG_EXTERN int png_chunk_unknown_handling PNGARG((png_structp png_ptr,
+    png_uint_32 chunk_name));
+#endif
 
 /* Handle the transformations for reading and writing */
-PNG_EXTERN void png_do_read_transformations PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_do_write_transformations PNGARG((png_structp png_ptr));
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
+PNG_EXTERN void png_do_read_transformations PNGARG((png_structp png_ptr,
+   png_row_infop row_info));
+#endif
+#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
+PNG_EXTERN void png_do_write_transformations PNGARG((png_structp png_ptr,
+   png_row_infop row_info));
+#endif
 
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
 PNG_EXTERN void png_init_read_transformations PNGARG((png_structp png_ptr));
+#endif
 
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
 PNG_EXTERN void png_push_read_chunk PNGARG((png_structp png_ptr,
@@ -1060,12 +1361,48 @@ PNG_EXTERN void png_64bit_product PNGARG((long v1, long v2,
     unsigned long *hi_product, unsigned long *lo_product));
 #endif
 
+#ifdef PNG_cHRM_SUPPORTED
+/* Added at libpng version 1.5.5 */
+typedef struct png_xy
+{
+   png_fixed_point redx, redy;
+   png_fixed_point greenx, greeny;
+   png_fixed_point bluex, bluey;
+   png_fixed_point whitex, whitey;
+} png_xy;
+
+typedef struct png_XYZ
+{
+   png_fixed_point redX, redY, redZ;
+   png_fixed_point greenX, greenY, greenZ;
+   png_fixed_point blueX, blueY, blueZ;
+} png_XYZ;
+
+/* The conversion APIs return 0 on success, non-zero on a parameter error. They
+ * allow conversion between the above representations of a color encoding.  When
+ * converting from XYZ end points to chromaticities the absolute magnitude of
+ * the end points is lost, when converting back the sum of the Y values of the
+ * three end points will be 1.0
+ */
+PNG_EXTERN int png_xy_from_XYZ PNGARG((png_xy *xy, png_XYZ XYZ));
+PNG_EXTERN int png_XYZ_from_xy PNGARG((png_XYZ *XYZ, png_xy xy));
+PNG_EXTERN int png_XYZ_from_xy_checked PNGARG((png_structp png_ptr,
+   png_XYZ *XYZ, png_xy xy));
+#endif
+
 /* Added at libpng version 1.4.0 */
 PNG_EXTERN void png_check_IHDR PNGARG((png_structp png_ptr,
     png_uint_32 width, png_uint_32 height, int bit_depth,
     int color_type, int interlace_type, int compression_type,
     int filter_type));
 
+/* Added at libpng version 1.5.10 */
+#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
+    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
+PNG_EXTERN void png_do_check_palette_indexes PNGARG((png_structp png_ptr,
+    png_row_infop row_info));
+#endif
+
 /* Free all memory used by the read (old method - NOT DLL EXPORTED) */
 PNG_EXTERN void png_read_destroy PNGARG((png_structp png_ptr,
     png_infop info_ptr, png_infop end_info_ptr));
@@ -1083,6 +1420,76 @@ PNG_EXTERN PNG_FUNCTION(void, png_fixed_error, (png_structp png_ptr,
    png_const_charp name),PNG_NORETURN);
 #endif
 
+/* Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite
+ * the end.  Always leaves the buffer nul terminated.  Never errors out (and
+ * there is no error code.)
+ */
+PNG_EXTERN size_t png_safecat(png_charp buffer, size_t bufsize, size_t pos,
+    png_const_charp string);
+
+/* Various internal functions to handle formatted warning messages, currently
+ * only implemented for warnings.
+ */
+#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_TIME_RFC1123_SUPPORTED)
+/* Utility to dump an unsigned value into a buffer, given a start pointer and
+ * and end pointer (which should point just *beyond* the end of the buffer!)
+ * Returns the pointer to the start of the formatted string.  This utility only
+ * does unsigned values.
+ */
+PNG_EXTERN png_charp png_format_number(png_const_charp start, png_charp end,
+   int format, png_alloc_size_t number);
+
+/* Convenience macro that takes an array: */
+#define PNG_FORMAT_NUMBER(buffer,format,number) \
+   png_format_number(buffer, buffer + (sizeof buffer), format, number)
+
+/* Suggested size for a number buffer (enough for 64 bits and a sign!) */
+#define PNG_NUMBER_BUFFER_SIZE 24
+
+/* These are the integer formats currently supported, the name is formed from
+ * the standard printf(3) format string.
+ */
+#define PNG_NUMBER_FORMAT_u     1 /* chose unsigned API! */
+#define PNG_NUMBER_FORMAT_02u   2
+#define PNG_NUMBER_FORMAT_d     1 /* chose signed API! */
+#define PNG_NUMBER_FORMAT_02d   2
+#define PNG_NUMBER_FORMAT_x     3
+#define PNG_NUMBER_FORMAT_02x   4
+#define PNG_NUMBER_FORMAT_fixed 5 /* choose the signed API */
+#endif
+
+#ifdef PNG_WARNINGS_SUPPORTED
+/* New defines and members adding in libpng-1.5.4 */
+#  define PNG_WARNING_PARAMETER_SIZE 32
+#  define PNG_WARNING_PARAMETER_COUNT 8
+
+/* An l-value of this type has to be passed to the APIs below to cache the
+ * values of the parameters to a formatted warning message.
+ */
+typedef char png_warning_parameters[PNG_WARNING_PARAMETER_COUNT][
+   PNG_WARNING_PARAMETER_SIZE];
+
+PNG_EXTERN void png_warning_parameter(png_warning_parameters p, int number,
+    png_const_charp string);
+    /* Parameters are limited in size to PNG_WARNING_PARAMETER_SIZE characters,
+     * including the trailing '\0'.
+     */
+PNG_EXTERN void png_warning_parameter_unsigned(png_warning_parameters p,
+    int number, int format, png_alloc_size_t value);
+    /* Use png_alloc_size_t because it is an unsigned type as big as any we
+     * need to output.  Use the following for a signed value.
+     */
+PNG_EXTERN void png_warning_parameter_signed(png_warning_parameters p,
+    int number, int format, png_int_32 value);
+
+PNG_EXTERN void png_formatted_warning(png_structp png_ptr,
+    png_warning_parameters p, png_const_charp message);
+    /* 'message' follows the X/Open approach of using @1, @2 to insert
+     * parameters previously supplied using the above functions.  Errors in
+     * specifying the paramters will simple result in garbage substitutions.
+     */
+#endif
+
 /* ASCII to FP interfaces, currently only implemented if sCAL
  * support is required.
  */
@@ -1145,8 +1552,18 @@ PNG_EXTERN void png_ascii_from_fixed PNGARG((png_structp png_ptr,
 #define PNG_FP_SAW_DOT   16  /* Saw a dot in current state */
 #define PNG_FP_SAW_E     32  /* Saw an E (or e) in current state */
 #define PNG_FP_SAW_ANY   60  /* Saw any of the above 4 */
+
+/* These three values don't affect the parser.  They are set but not used.
+ */
 #define PNG_FP_WAS_VALID 64  /* Preceding substring is a valid fp number */
-#define PNG_FP_INVALID  128  /* Available for callers as a distinct value */
+#define PNG_FP_NEGATIVE 128  /* A negative number, including "-0" */
+#define PNG_FP_NONZERO  256  /* A non-zero value */
+#define PNG_FP_STICKY   448  /* The above three flags */
+
+/* This is available for the caller to store in 'state' if required.  Do not
+ * call the parser after setting it (the parser sometimes clears it.)
+ */
+#define PNG_FP_INVALID  512  /* Available for callers as a distinct value */
 
 /* Result codes for the parser (boolean - true meants ok, false means
  * not ok yet.)
@@ -1154,6 +1571,20 @@ PNG_EXTERN void png_ascii_from_fixed PNGARG((png_structp png_ptr,
 #define PNG_FP_MAYBE      0  /* The number may be valid in the future */
 #define PNG_FP_OK         1  /* The number is valid */
 
+/* Tests on the sticky non-zero and negative flags.  To pass these checks
+ * the state must also indicate that the whole number is valid - this is
+ * achieved by testing PNG_FP_SAW_DIGIT (see the implementation for why this
+ * is equivalent to PNG_FP_OK above.)
+ */
+#define PNG_FP_NZ_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
+   /* NZ_MASK: the string is valid and a non-zero negative value */
+#define PNG_FP_Z_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NONZERO)
+   /* Z MASK: the string is valid and a non-zero value. */
+   /* PNG_FP_SAW_DIGIT: the string is valid. */
+#define PNG_FP_IS_ZERO(state) (((state) & PNG_FP_Z_MASK) == PNG_FP_SAW_DIGIT)
+#define PNG_FP_IS_POSITIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_Z_MASK)
+#define PNG_FP_IS_NEGATIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_NZ_MASK)
+ 
 /* The actual parser.  This can be called repeatedly, it updates
  * the index into the string and the state variable (which must
  * be initialzed to 0).  It returns a result code, as above.  There
@@ -1173,7 +1604,10 @@ PNG_EXTERN int png_check_fp_number PNGARG((png_const_charp string,
     png_size_t size, int *statep, png_size_tp whereami));
 
 /* This is the same but it checks a complete string and returns true
- * only if it just contains a floating point number.
+ * only if it just contains a floating point number.  As of 1.5.4 this
+ * function also returns the state at the end of parsing the number if
+ * it was valid (otherwise it returns 0.)  This can be used for testing
+ * for negative or zero values using the sticky flag.
  */
 PNG_EXTERN int png_check_fp_string PNGARG((png_const_charp string,
     png_size_t size));
@@ -1188,13 +1622,13 @@ PNG_EXTERN int png_check_fp_string PNGARG((png_const_charp string,
  * holds the result.
  */
 PNG_EXTERN int png_muldiv PNGARG((png_fixed_point_p res, png_fixed_point a,
-    png_int_32 times, png_int_32 div));
+    png_int_32 multiplied_by, png_int_32 divided_by));
 #endif
 
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)
 /* Same deal, but issue a warning on overflow and return 0. */
 PNG_EXTERN png_fixed_point png_muldiv_warn PNGARG((png_structp png_ptr,
-    png_fixed_point a, png_int_32 times, png_int_32 div));
+    png_fixed_point a, png_int_32 multiplied_by, png_int_32 divided_by));
 #endif
 
 #ifdef PNG_READ_GAMMA_SUPPORTED
@@ -1221,19 +1655,19 @@ PNG_EXTERN png_fixed_point png_reciprocal2 PNGARG((png_fixed_point a,
  * correct bit value - 0..255 or 0..65535 as required.
  */
 PNG_EXTERN png_uint_16 png_gamma_correct PNGARG((png_structp png_ptr,
-    unsigned int value, png_fixed_point gamma));
-PNG_EXTERN int png_gamma_significant PNGARG((png_fixed_point gamma));
+    unsigned int value, png_fixed_point gamma_value));
+PNG_EXTERN int png_gamma_significant PNGARG((png_fixed_point gamma_value));
 PNG_EXTERN png_uint_16 png_gamma_16bit_correct PNGARG((unsigned int value,
-    png_fixed_point gamma));
+    png_fixed_point gamma_value));
 PNG_EXTERN png_byte png_gamma_8bit_correct PNGARG((unsigned int value,
-    png_fixed_point gamma));
+    png_fixed_point gamma_value));
+PNG_EXTERN void png_destroy_gamma_table(png_structp png_ptr);
 PNG_EXTERN void png_build_gamma_table PNGARG((png_structp png_ptr,
     int bit_depth));
 #endif
 
 /* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */
 
-
 #include "pngdebug.h"
 
 #ifdef __cplusplus
diff --git a/src/3rdparty/libpng/pngread.c b/src/3rdparty/libpng/pngread.c
index 2c8f2cd..1d8c6b3 100644
--- a/src/3rdparty/libpng/pngread.c
+++ b/src/3rdparty/libpng/pngread.c
@@ -1,8 +1,8 @@
 
 /* pngread.c - read a PNG file
  *
- * Last changed in libpng 1.5.1 [$RDATE%]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -47,12 +47,10 @@ png_create_read_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
 
 #ifdef PNG_SETJMP_SUPPORTED
 #ifdef USE_FAR_KEYWORD
-   jmp_buf png_jmpbuf;
+   jmp_buf tmp_jmpbuf;
 #endif
 #endif
 
-   int i;
-
    png_debug(1, "in png_create_read_struct");
 
 #ifdef PNG_USER_MEM_SUPPORTED
@@ -69,29 +67,26 @@ png_create_read_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_ptr->user_width_max = PNG_USER_WIDTH_MAX;
    png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;
 
-#  ifdef PNG_USER_CHUNK_CACHE_MAX
    /* Added at libpng-1.2.43 and 1.4.0 */
    png_ptr->user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;
-#  endif
 
-#  ifdef PNG_SET_USER_CHUNK_MALLOC_MAX
    /* Added at libpng-1.2.43 and 1.4.1 */
    png_ptr->user_chunk_malloc_max = PNG_USER_CHUNK_MALLOC_MAX;
-#  endif
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
 /* Applications that neglect to set up their own setjmp() and then
-   encounter a png_error() will longjmp here.  Since the jmpbuf is
-   then meaningless we abort instead of returning. */
+ * encounter a png_error() will longjmp here.  Since the jmpbuf is
+ * then meaningless we abort instead of returning.
+ */
 #ifdef USE_FAR_KEYWORD
-   if (setjmp(png_jmpbuf))
+   if (setjmp(tmp_jmpbuf))
 #else
    if (setjmp(png_jmpbuf(png_ptr))) /* Sets longjmp to match setjmp */
 #endif
       PNG_ABORT();
 #ifdef USE_FAR_KEYWORD
-   png_memcpy(png_jmpbuf(png_ptr), png_jmpbuf, png_sizeof(jmp_buf));
+   png_memcpy(png_jmpbuf(png_ptr), tmp_jmpbuf, png_sizeof(jmp_buf));
 #endif
 #endif /* PNG_SETJMP_SUPPORTED */
 
@@ -101,54 +96,9 @@ png_create_read_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
 
    png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);
 
-   if (user_png_ver)
-   {
-      i = 0;
-
-      do
-      {
-         if (user_png_ver[i] != png_libpng_ver[i])
-            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-      } while (png_libpng_ver[i++]);
-   }
-
-   else
-      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-
-
-   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
-   {
-     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
-      * we must recompile any applications that use any older library version.
-      * For versions after libpng 1.0, we will be compatible, so we need
-      * only check the first digit.
-      */
-      if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
-          (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
-          (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
-      {
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-         char msg[80];
-         if (user_png_ver)
-         {
-            png_snprintf2(msg, 80,
-                "Application built with libpng-%.20s"
-                " but running with %.20s",
-                user_png_ver,
-                png_libpng_ver);
-            png_warning(png_ptr, msg);
-         }
-#else
-         png_warning(png_ptr,
-             "Incompatible libpng version in application and library");
-#endif
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-         png_ptr->flags = 0;
-#endif
-
-         png_cleanup_needed = 1;
-      }
-   }
+   /* Call the general version checker (shared with read and write code): */
+   if (!png_user_version_check(png_ptr, user_png_ver))
+      png_cleanup_needed = 1;
 
    if (!png_cleanup_needed)
    {
@@ -237,89 +187,35 @@ png_read_info(png_structp png_ptr, png_infop info_ptr)
 
    for (;;)
    {
-      PNG_IHDR;
-      PNG_IDAT;
-      PNG_IEND;
-      PNG_PLTE;
-#ifdef PNG_READ_bKGD_SUPPORTED
-      PNG_bKGD;
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-      PNG_cHRM;
-#endif
-#ifdef PNG_READ_gAMA_SUPPORTED
-      PNG_gAMA;
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-      PNG_hIST;
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-      PNG_iCCP;
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      PNG_iTXt;
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-      PNG_oFFs;
-#endif
-#ifdef PNG_READ_pCAL_SUPPORTED
-      PNG_pCAL;
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-      PNG_pHYs;
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-      PNG_sBIT;
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-      PNG_sCAL;
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-      PNG_sPLT;
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-      PNG_sRGB;
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-      PNG_tEXt;
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-      PNG_tIME;
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-      PNG_tRNS;
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      PNG_zTXt;
-#endif
       png_uint_32 length = png_read_chunk_header(png_ptr);
-      PNG_CONST png_bytep chunk_name = png_ptr->chunk_name;
+      png_uint_32 chunk_name = png_ptr->chunk_name;
 
       /* This should be a binary subdivision search or a hash for
        * matching the chunk name rather than a linear search.
        */
-      if (!png_memcmp(chunk_name, png_IDAT, 4))
+      if (chunk_name == png_IDAT)
          if (png_ptr->mode & PNG_AFTER_IDAT)
             png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
 
-      if (!png_memcmp(chunk_name, png_IHDR, 4))
+      if (chunk_name == png_IHDR)
          png_handle_IHDR(png_ptr, info_ptr, length);
 
-      else if (!png_memcmp(chunk_name, png_IEND, 4))
+      else if (chunk_name == png_IEND)
          png_handle_IEND(png_ptr, info_ptr, length);
 
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-      else if (png_handle_as_unknown(png_ptr, chunk_name))
+      else if (png_chunk_unknown_handling(png_ptr, chunk_name) !=
+         PNG_HANDLE_CHUNK_AS_DEFAULT)
       {
-         if (!png_memcmp(chunk_name, png_IDAT, 4))
+         if (chunk_name == png_IDAT)
             png_ptr->mode |= PNG_HAVE_IDAT;
 
          png_handle_unknown(png_ptr, info_ptr, length);
 
-         if (!png_memcmp(chunk_name, png_PLTE, 4))
+         if (chunk_name == png_PLTE)
             png_ptr->mode |= PNG_HAVE_PLTE;
 
-         else if (!png_memcmp(chunk_name, png_IDAT, 4))
+         else if (chunk_name == png_IDAT)
          {
             if (!(png_ptr->mode & PNG_HAVE_IHDR))
                png_error(png_ptr, "Missing IHDR before IDAT");
@@ -332,10 +228,10 @@ png_read_info(png_structp png_ptr, png_infop info_ptr)
          }
       }
 #endif
-      else if (!png_memcmp(chunk_name, png_PLTE, 4))
+      else if (chunk_name == png_PLTE)
          png_handle_PLTE(png_ptr, info_ptr, length);
 
-      else if (!png_memcmp(chunk_name, png_IDAT, 4))
+      else if (chunk_name == png_IDAT)
       {
          if (!(png_ptr->mode & PNG_HAVE_IHDR))
             png_error(png_ptr, "Missing IHDR before IDAT");
@@ -350,87 +246,87 @@ png_read_info(png_structp png_ptr, png_infop info_ptr)
       }
 
 #ifdef PNG_READ_bKGD_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_bKGD, 4))
+      else if (chunk_name == png_bKGD)
          png_handle_bKGD(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_cHRM_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_cHRM, 4))
+      else if (chunk_name == png_cHRM)
          png_handle_cHRM(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_gAMA_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_gAMA, 4))
+      else if (chunk_name == png_gAMA)
          png_handle_gAMA(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_hIST_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_hIST, 4))
+      else if (chunk_name == png_hIST)
          png_handle_hIST(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_oFFs_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_oFFs, 4))
+      else if (chunk_name == png_oFFs)
          png_handle_oFFs(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_pCAL_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_pCAL, 4))
+      else if (chunk_name == png_pCAL)
          png_handle_pCAL(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_sCAL_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sCAL, 4))
+      else if (chunk_name == png_sCAL)
          png_handle_sCAL(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_pHYs_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_pHYs, 4))
+      else if (chunk_name == png_pHYs)
          png_handle_pHYs(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_sBIT_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sBIT, 4))
+      else if (chunk_name == png_sBIT)
          png_handle_sBIT(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_sRGB_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sRGB, 4))
+      else if (chunk_name == png_sRGB)
          png_handle_sRGB(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_iCCP_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_iCCP, 4))
+      else if (chunk_name == png_iCCP)
          png_handle_iCCP(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_sPLT_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sPLT, 4))
+      else if (chunk_name == png_sPLT)
          png_handle_sPLT(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_tEXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tEXt, 4))
+      else if (chunk_name == png_tEXt)
          png_handle_tEXt(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_tIME_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tIME, 4))
+      else if (chunk_name == png_tIME)
          png_handle_tIME(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_tRNS_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tRNS, 4))
+      else if (chunk_name == png_tRNS)
          png_handle_tRNS(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_zTXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_zTXt, 4))
+      else if (chunk_name == png_zTXt)
          png_handle_zTXt(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_iTXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_iTXt, 4))
+      else if (chunk_name == png_iTXt)
          png_handle_iTXt(png_ptr, info_ptr, length);
 #endif
 
@@ -449,15 +345,13 @@ png_read_update_info(png_structp png_ptr, png_infop info_ptr)
    if (png_ptr == NULL)
       return;
 
-   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
-      png_read_start_row(png_ptr);
-
-   else
-      png_warning(png_ptr,
-          "Ignoring extra png_read_update_info() call;"
-          " row buffer not reallocated");
+   png_read_start_row(png_ptr);
 
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
    png_read_transform_info(png_ptr, info_ptr);
+#else
+   PNG_UNUSED(info_ptr)
+#endif
 }
 
 #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
@@ -471,15 +365,8 @@ png_start_read_image(png_structp png_ptr)
 {
    png_debug(1, "in png_start_read_image");
 
-   if (png_ptr == NULL)
-      return;
-
-   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
-      png_read_start_row(png_ptr);
-   else
-      png_warning(png_ptr,
-          "Ignoring extra png_start_read_image() call;"
-          " row buffer not reallocated");
+   if (png_ptr != NULL)
+     png_read_start_row(png_ptr);
 }
 #endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
 
@@ -487,21 +374,30 @@ png_start_read_image(png_structp png_ptr)
 void PNGAPI
 png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
 {
-   PNG_IDAT;
-   PNG_CONST int png_pass_dsp_mask[7] = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55,
-       0xff};
-   PNG_CONST int png_pass_mask[7] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
    int ret;
 
+   png_row_info row_info;
+
    if (png_ptr == NULL)
       return;
 
    png_debug2(1, "in png_read_row (row %lu, pass %d)",
        (unsigned long)png_ptr->row_number, png_ptr->pass);
 
+   /* png_read_start_row sets the information (in particular iwidth) for this
+    * interlace pass.
+    */
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
 
+   /* 1.5.6: row_info moved out of png_struct to a local here. */
+   row_info.width = png_ptr->iwidth; /* NOTE: width of current interlaced row */
+   row_info.color_type = png_ptr->color_type;
+   row_info.bit_depth = png_ptr->bit_depth;
+   row_info.channels = png_ptr->channels;
+   row_info.pixel_depth = png_ptr->pixel_depth;
+   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);
+
    if (png_ptr->row_number == 0 && png_ptr->pass == 0)
    {
    /* Check for transforms that have been set but were defined out */
@@ -543,7 +439,12 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
    }
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
-   /* If interlaced and we do not need a new row, combine row and return */
+   /* If interlaced and we do not need a new row, combine row and return.
+    * Notice that the pixels we have from previous rows have been transformed
+    * already; we can only combine like with like (transformed or
+    * untransformed) and, because of the libpng API for interlaced images, this
+    * means we must transform before de-interlacing.
+    */
    if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
    {
       switch (png_ptr->pass)
@@ -552,8 +453,7 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
             if (png_ptr->row_number & 0x07)
             {
                if (dsp_row != NULL)
-                  png_combine_row(png_ptr, dsp_row,
-                     png_pass_dsp_mask[png_ptr->pass]);
+                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
                png_read_finish_row(png_ptr);
                return;
             }
@@ -563,8 +463,7 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
             if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)
             {
                if (dsp_row != NULL)
-                  png_combine_row(png_ptr, dsp_row,
-                      png_pass_dsp_mask[png_ptr->pass]);
+                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
 
                png_read_finish_row(png_ptr);
                return;
@@ -575,8 +474,7 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
             if ((png_ptr->row_number & 0x07) != 4)
             {
                if (dsp_row != NULL && (png_ptr->row_number & 4))
-                  png_combine_row(png_ptr, dsp_row,
-                      png_pass_dsp_mask[png_ptr->pass]);
+                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
 
                png_read_finish_row(png_ptr);
                return;
@@ -587,8 +485,7 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
             if ((png_ptr->row_number & 3) || png_ptr->width < 3)
             {
                if (dsp_row != NULL)
-                  png_combine_row(png_ptr, dsp_row,
-                      png_pass_dsp_mask[png_ptr->pass]);
+                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
 
                png_read_finish_row(png_ptr);
                return;
@@ -599,8 +496,7 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
             if ((png_ptr->row_number & 3) != 2)
             {
                if (dsp_row != NULL && (png_ptr->row_number & 2))
-                  png_combine_row(png_ptr, dsp_row,
-                      png_pass_dsp_mask[png_ptr->pass]);
+                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
 
                png_read_finish_row(png_ptr);
                return;
@@ -610,8 +506,7 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
             if ((png_ptr->row_number & 1) || png_ptr->width < 2)
             {
                if (dsp_row != NULL)
-                  png_combine_row(png_ptr, dsp_row,
-                      png_pass_dsp_mask[png_ptr->pass]);
+                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
 
                png_read_finish_row(png_ptr);
                return;
@@ -647,7 +542,7 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
             png_crc_finish(png_ptr, 0);
 
             png_ptr->idat_size = png_read_chunk_header(png_ptr);
-            if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+            if (png_ptr->chunk_name != png_IDAT)
                png_error(png_ptr, "Not enough image data");
          }
          png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
@@ -677,33 +572,47 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
 
    } while (png_ptr->zstream.avail_out);
 
-   png_ptr->row_info.color_type = png_ptr->color_type;
-   png_ptr->row_info.width = png_ptr->iwidth;
-   png_ptr->row_info.channels = png_ptr->channels;
-   png_ptr->row_info.bit_depth = png_ptr->bit_depth;
-   png_ptr->row_info.pixel_depth = png_ptr->pixel_depth;
-   png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
-       png_ptr->row_info.width);
-
-   if (png_ptr->row_buf[0])
-   png_read_filter_row(png_ptr, &(png_ptr->row_info),
-       png_ptr->row_buf + 1, png_ptr->prev_row + 1,
-       (int)(png_ptr->row_buf[0]));
+   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
+   {
+      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
+         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,
+            png_ptr->prev_row + 1, png_ptr->row_buf[0]);
+      else
+         png_error(png_ptr, "bad adaptive filter value");
+   }
 
-   png_memcpy(png_ptr->prev_row, png_ptr->row_buf, png_ptr->rowbytes + 1);
+   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
+    * 1.5.6, while the buffer really is this big in current versions of libpng
+    * it may not be in the future, so this was changed just to copy the
+    * interlaced count:
+    */
+   png_memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);
 
 #ifdef PNG_MNG_FEATURES_SUPPORTED
    if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
        (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
    {
       /* Intrapixel differencing */
-      png_do_read_intrapixel(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_read_intrapixel(&row_info, png_ptr->row_buf + 1);
    }
 #endif
 
 
-   if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
-      png_do_read_transformations(png_ptr);
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
+   if (png_ptr->transformations)
+      png_do_read_transformations(png_ptr, &row_info);
+#endif
+
+   /* The transformed pixel depth should match the depth now in row_info. */
+   if (png_ptr->transformed_pixel_depth == 0)
+   {
+      png_ptr->transformed_pixel_depth = row_info.pixel_depth;
+      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
+         png_error(png_ptr, "sequential row overflow");
+   }
+
+   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
+      png_error(png_ptr, "internal sequential row size calculation error");
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
    /* Blow up interlaced rows to full size */
@@ -711,27 +620,24 @@ png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
       (png_ptr->transformations & PNG_INTERLACE))
    {
       if (png_ptr->pass < 6)
-         /* Old interface (pre-1.0.9):
-          * png_do_read_interlace(&(png_ptr->row_info),
-          *    png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
-          */
-         png_do_read_interlace(png_ptr);
+         png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,
+            png_ptr->transformations);
 
       if (dsp_row != NULL)
-         png_combine_row(png_ptr, dsp_row, png_pass_dsp_mask[png_ptr->pass]);
+         png_combine_row(png_ptr, dsp_row, 1/*display*/);
 
       if (row != NULL)
-         png_combine_row(png_ptr, row, png_pass_mask[png_ptr->pass]);
+         png_combine_row(png_ptr, row, 0/*row*/);
    }
 
    else
 #endif
    {
       if (row != NULL)
-         png_combine_row(png_ptr, row, 0xff);
+         png_combine_row(png_ptr, row, -1/*ignored*/);
 
       if (dsp_row != NULL)
-         png_combine_row(png_ptr, dsp_row, 0xff);
+         png_combine_row(png_ptr, dsp_row, -1/*ignored*/);
    }
    png_read_finish_row(png_ptr);
 
@@ -895,87 +801,40 @@ png_read_end(png_structp png_ptr, png_infop info_ptr)
 
    png_crc_finish(png_ptr, 0); /* Finish off CRC from last IDAT chunk */
 
+#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   /* Report invalid palette index; added at libng-1.5.10 */
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
+      png_ptr->num_palette_max > png_ptr->num_palette)
+     png_benign_error(png_ptr, "Read palette index exceeding num_palette");
+#endif
+
    do
    {
-      PNG_IHDR;
-      PNG_IDAT;
-      PNG_IEND;
-      PNG_PLTE;
-#ifdef PNG_READ_bKGD_SUPPORTED
-      PNG_bKGD;
-#endif
-#ifdef PNG_READ_cHRM_SUPPORTED
-      PNG_cHRM;
-#endif
-#ifdef PNG_READ_gAMA_SUPPORTED
-      PNG_gAMA;
-#endif
-#ifdef PNG_READ_hIST_SUPPORTED
-      PNG_hIST;
-#endif
-#ifdef PNG_READ_iCCP_SUPPORTED
-      PNG_iCCP;
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      PNG_iTXt;
-#endif
-#ifdef PNG_READ_oFFs_SUPPORTED
-      PNG_oFFs;
-#endif
-#ifdef PNG_READ_pCAL_SUPPORTED
-      PNG_pCAL;
-#endif
-#ifdef PNG_READ_pHYs_SUPPORTED
-      PNG_pHYs;
-#endif
-#ifdef PNG_READ_sBIT_SUPPORTED
-      PNG_sBIT;
-#endif
-#ifdef PNG_READ_sCAL_SUPPORTED
-      PNG_sCAL;
-#endif
-#ifdef PNG_READ_sPLT_SUPPORTED
-      PNG_sPLT;
-#endif
-#ifdef PNG_READ_sRGB_SUPPORTED
-      PNG_sRGB;
-#endif
-#ifdef PNG_READ_tEXt_SUPPORTED
-      PNG_tEXt;
-#endif
-#ifdef PNG_READ_tIME_SUPPORTED
-      PNG_tIME;
-#endif
-#ifdef PNG_READ_tRNS_SUPPORTED
-      PNG_tRNS;
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      PNG_zTXt;
-#endif
       png_uint_32 length = png_read_chunk_header(png_ptr);
-      PNG_CONST png_bytep chunk_name = png_ptr->chunk_name;
+      png_uint_32 chunk_name = png_ptr->chunk_name;
 
-      if (!png_memcmp(chunk_name, png_IHDR, 4))
+      if (chunk_name == png_IHDR)
          png_handle_IHDR(png_ptr, info_ptr, length);
 
-      else if (!png_memcmp(chunk_name, png_IEND, 4))
+      else if (chunk_name == png_IEND)
          png_handle_IEND(png_ptr, info_ptr, length);
 
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-      else if (png_handle_as_unknown(png_ptr, chunk_name))
+      else if (png_chunk_unknown_handling(png_ptr, chunk_name) !=
+         PNG_HANDLE_CHUNK_AS_DEFAULT)
       {
-         if (!png_memcmp(chunk_name, png_IDAT, 4))
+         if (chunk_name == png_IDAT)
          {
             if ((length > 0) || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
                png_benign_error(png_ptr, "Too many IDATs found");
          }
          png_handle_unknown(png_ptr, info_ptr, length);
-         if (!png_memcmp(chunk_name, png_PLTE, 4))
+         if (chunk_name == png_PLTE)
             png_ptr->mode |= PNG_HAVE_PLTE;
       }
 #endif
 
-      else if (!png_memcmp(chunk_name, png_IDAT, 4))
+      else if (chunk_name == png_IDAT)
       {
          /* Zero length IDATs are legal after the last IDAT has been
           * read, but not after other chunks have been read.
@@ -985,91 +844,91 @@ png_read_end(png_structp png_ptr, png_infop info_ptr)
 
          png_crc_finish(png_ptr, length);
       }
-      else if (!png_memcmp(chunk_name, png_PLTE, 4))
+      else if (chunk_name == png_PLTE)
          png_handle_PLTE(png_ptr, info_ptr, length);
 
 #ifdef PNG_READ_bKGD_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_bKGD, 4))
+      else if (chunk_name == png_bKGD)
          png_handle_bKGD(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_cHRM_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_cHRM, 4))
+      else if (chunk_name == png_cHRM)
          png_handle_cHRM(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_gAMA_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_gAMA, 4))
+      else if (chunk_name == png_gAMA)
          png_handle_gAMA(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_hIST_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_hIST, 4))
+      else if (chunk_name == png_hIST)
          png_handle_hIST(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_oFFs_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_oFFs, 4))
+      else if (chunk_name == png_oFFs)
          png_handle_oFFs(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_pCAL_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_pCAL, 4))
+      else if (chunk_name == png_pCAL)
          png_handle_pCAL(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_sCAL_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sCAL, 4))
+      else if (chunk_name == png_sCAL)
          png_handle_sCAL(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_pHYs_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_pHYs, 4))
+      else if (chunk_name == png_pHYs)
          png_handle_pHYs(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_sBIT_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sBIT, 4))
+      else if (chunk_name == png_sBIT)
          png_handle_sBIT(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_sRGB_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sRGB, 4))
+      else if (chunk_name == png_sRGB)
          png_handle_sRGB(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_iCCP_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_iCCP, 4))
+      else if (chunk_name == png_iCCP)
          png_handle_iCCP(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_sPLT_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_sPLT, 4))
+      else if (chunk_name == png_sPLT)
          png_handle_sPLT(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_tEXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tEXt, 4))
+      else if (chunk_name == png_tEXt)
          png_handle_tEXt(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_tIME_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tIME, 4))
+      else if (chunk_name == png_tIME)
          png_handle_tIME(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_tRNS_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_tRNS, 4))
+      else if (chunk_name == png_tRNS)
          png_handle_tRNS(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_zTXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_zTXt, 4))
+      else if (chunk_name == png_zTXt)
          png_handle_zTXt(png_ptr, info_ptr, length);
 #endif
 
 #ifdef PNG_READ_iTXt_SUPPORTED
-      else if (!png_memcmp(chunk_name, png_iTXt, 4))
+      else if (chunk_name == png_iTXt)
          png_handle_iTXt(png_ptr, info_ptr, length);
 #endif
 
@@ -1161,7 +1020,9 @@ png_read_destroy(png_structp png_ptr, png_infop info_ptr,
    jmp_buf tmp_jmp;
 #endif
    png_error_ptr error_fn;
+#ifdef PNG_WARNINGS_SUPPORTED
    png_error_ptr warning_fn;
+#endif
    png_voidp error_ptr;
 #ifdef PNG_USER_MEM_SUPPORTED
    png_free_ptr free_fn;
@@ -1175,9 +1036,13 @@ png_read_destroy(png_structp png_ptr, png_infop info_ptr,
    if (end_info_ptr != NULL)
       png_info_destroy(png_ptr, end_info_ptr);
 
+#ifdef PNG_READ_GAMMA_SUPPORTED
+   png_destroy_gamma_table(png_ptr);
+#endif
+
    png_free(png_ptr, png_ptr->zbuf);
    png_free(png_ptr, png_ptr->big_row_buf);
-   png_free(png_ptr, png_ptr->prev_row);
+   png_free(png_ptr, png_ptr->big_prev_row);
    png_free(png_ptr, png_ptr->chunkdata);
 
 #ifdef PNG_READ_QUANTIZE_SUPPORTED
@@ -1185,15 +1050,6 @@ png_read_destroy(png_structp png_ptr, png_infop info_ptr,
    png_free(png_ptr, png_ptr->quantize_index);
 #endif
 
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   png_free(png_ptr, png_ptr->gamma_table);
-#endif
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   png_free(png_ptr, png_ptr->gamma_from_1);
-   png_free(png_ptr, png_ptr->gamma_to_1);
-#endif
-
    if (png_ptr->free_me & PNG_FREE_PLTE)
       png_zfree(png_ptr, png_ptr->palette);
    png_ptr->free_me &= ~PNG_FREE_PLTE;
@@ -1211,67 +1067,23 @@ png_read_destroy(png_structp png_ptr, png_infop info_ptr,
    png_ptr->free_me &= ~PNG_FREE_HIST;
 #endif
 
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   if (png_ptr->gamma_16_table != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_table[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_table);
-   }
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   if (png_ptr->gamma_16_from_1 != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_from_1);
-   }
-   if (png_ptr->gamma_16_to_1 != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_to_1);
-   }
-#endif
-#endif
-
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-   png_free(png_ptr, png_ptr->time_buffer);
-#endif
-
    inflateEnd(&png_ptr->zstream);
 
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
    png_free(png_ptr, png_ptr->save_buffer);
 #endif
 
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-#ifdef PNG_TEXT_SUPPORTED
-   png_free(png_ptr, png_ptr->current_text);
-#endif /* PNG_TEXT_SUPPORTED */
-#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
-
    /* Save the important info out of the png_struct, in case it is
     * being used again.
     */
 #ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(tmp_jmp, png_ptr->png_jmpbuf, png_sizeof(jmp_buf));
+   png_memcpy(tmp_jmp, png_ptr->longjmp_buffer, png_sizeof(jmp_buf));
 #endif
 
    error_fn = png_ptr->error_fn;
+#ifdef PNG_WARNINGS_SUPPORTED
    warning_fn = png_ptr->warning_fn;
+#endif
    error_ptr = png_ptr->error_ptr;
 #ifdef PNG_USER_MEM_SUPPORTED
    free_fn = png_ptr->free_fn;
@@ -1280,14 +1092,16 @@ png_read_destroy(png_structp png_ptr, png_infop info_ptr,
    png_memset(png_ptr, 0, png_sizeof(png_struct));
 
    png_ptr->error_fn = error_fn;
+#ifdef PNG_WARNINGS_SUPPORTED
    png_ptr->warning_fn = warning_fn;
+#endif
    png_ptr->error_ptr = error_ptr;
 #ifdef PNG_USER_MEM_SUPPORTED
    png_ptr->free_fn = free_fn;
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(png_ptr->png_jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
+   png_memcpy(png_ptr->longjmp_buffer, tmp_jmp, png_sizeof(jmp_buf));
 #endif
 
 }
@@ -1311,7 +1125,7 @@ png_read_png(png_structp png_ptr, png_infop info_ptr,
 {
    int row;
 
-   if (png_ptr == NULL)
+   if (png_ptr == NULL || info_ptr == NULL)
       return;
 
    /* png_read_info() gives us all of the information from the
@@ -1323,8 +1137,22 @@ png_read_png(png_structp png_ptr, png_infop info_ptr,
 
    /* -------------- image transformations start here ------------------- */
 
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-   /* Tell libpng to strip 16 bit/color files down to 8 bits per color.
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+   /* Tell libpng to strip 16-bit/color files down to 8 bits per color.
+    */
+   if (transforms & PNG_TRANSFORM_SCALE_16)
+   {
+     /* Added at libpng-1.5.4. "strip_16" produces the same result that it
+      * did in earlier versions, while "scale_16" is now more accurate.
+      */
+      png_set_scale_16(png_ptr);
+   }
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+   /* If both SCALE and STRIP are required pngrtran will effectively cancel the
+    * latter by doing SCALE first.  This is ok and allows apps not to check for
+    * which is supported to get the right answer.
     */
    if (transforms & PNG_TRANSFORM_STRIP_16)
       png_set_strip_16(png_ptr);
@@ -1405,7 +1233,7 @@ png_read_png(png_structp png_ptr, png_infop info_ptr,
 #endif
 
 #ifdef PNG_READ_SWAP_SUPPORTED
-   /* Swap bytes of 16 bit files to least significant byte first */
+   /* Swap bytes of 16-bit files to least significant byte first */
    if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)
       png_set_swap(png_ptr);
 #endif
@@ -1424,8 +1252,19 @@ png_read_png(png_structp png_ptr, png_infop info_ptr,
       png_set_gray_to_rgb(png_ptr);
 #endif
 
+/* Added at libpng-1.5.4 */
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+   if (transforms & PNG_TRANSFORM_EXPAND_16)
+      png_set_expand_16(png_ptr);
+#endif
+
    /* We don't handle adding filler bytes */
 
+   /* We use png_read_image and rely on that for interlace handling, but we also
+    * call png_read_update_info therefore must turn on interlace handling now:
+    */
+   (void)png_set_interlace_handling(png_ptr);
+
    /* Optional call to gamma correct and add the background to the palette
     * and update info structure.  REQUIRED if you are expecting libpng to
     * update the palette for you (i.e., you selected such a transform above).
diff --git a/src/3rdparty/libpng/pngrtran.c b/src/3rdparty/libpng/pngrtran.c
index e6e0c46..5561852 100644
--- a/src/3rdparty/libpng/pngrtran.c
+++ b/src/3rdparty/libpng/pngrtran.c
@@ -1,8 +1,8 @@
 
 /* pngrtran.c - transforms the data in a row for PNG readers
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -106,12 +106,18 @@ png_set_background_fixed(png_structp png_ptr,
       return;
    }
 
-   png_ptr->transformations |= PNG_BACKGROUND;
+   png_ptr->transformations |= PNG_COMPOSE | PNG_STRIP_ALPHA;
+   png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+   png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+
    png_memcpy(&(png_ptr->background), background_color,
       png_sizeof(png_color_16));
    png_ptr->background_gamma = background_gamma;
    png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
-   png_ptr->transformations |= (need_expand ? PNG_BACKGROUND_EXPAND : 0);
+   if (need_expand)
+      png_ptr->transformations |= PNG_BACKGROUND_EXPAND;
+   else
+      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
 }
 
 #  ifdef PNG_FLOATING_POINT_SUPPORTED
@@ -126,8 +132,25 @@ png_set_background(png_structp png_ptr,
 #  endif  /* FLOATING_POINT */
 #endif /* READ_BACKGROUND */
 
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-/* Strip 16 bit depth files to 8 bit depth */
+/* Scale 16-bit depth files to 8-bit depth.  If both of these are set then the
+ * one that pngrtran does first (scale) happens.  This is necessary to allow the
+ * TRANSFORM and API behavior to be somewhat consistent, and it's simpler.
+ */
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+void PNGAPI
+png_set_scale_16(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_scale_16");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_SCALE_16_TO_8;
+}
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+/* Chop 16-bit depth files to 8-bit depth */
 void PNGAPI
 png_set_strip_16(png_structp png_ptr)
 {
@@ -149,12 +172,194 @@ png_set_strip_alpha(png_structp png_ptr)
    if (png_ptr == NULL)
       return;
 
-   png_ptr->flags |= PNG_FLAG_STRIP_ALPHA;
+   png_ptr->transformations |= PNG_STRIP_ALPHA;
+}
+#endif
+
+#if defined(PNG_READ_ALPHA_MODE_SUPPORTED) || defined(PNG_READ_GAMMA_SUPPORTED)
+static png_fixed_point
+translate_gamma_flags(png_structp png_ptr, png_fixed_point output_gamma,
+   int is_screen)
+{
+   /* Check for flag values.  The main reason for having the old Mac value as a
+    * flag is that it is pretty near impossible to work out what the correct
+    * value is from Apple documentation - a working Mac system is needed to
+    * discover the value!
+    */
+   if (output_gamma == PNG_DEFAULT_sRGB ||
+      output_gamma == PNG_FP_1 / PNG_DEFAULT_sRGB)
+   {
+      /* If there is no sRGB support this just sets the gamma to the standard
+       * sRGB value.  (This is a side effect of using this function!)
+       */
+#     ifdef PNG_READ_sRGB_SUPPORTED
+         png_ptr->flags |= PNG_FLAG_ASSUME_sRGB;
+#     endif
+      if (is_screen)
+         output_gamma = PNG_GAMMA_sRGB;
+      else
+         output_gamma = PNG_GAMMA_sRGB_INVERSE;
+   }
+
+   else if (output_gamma == PNG_GAMMA_MAC_18 ||
+      output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18)
+   {
+      if (is_screen)
+         output_gamma = PNG_GAMMA_MAC_OLD;
+      else
+         output_gamma = PNG_GAMMA_MAC_INVERSE;
+   }
+
+   return output_gamma;
+}
+
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+static png_fixed_point
+convert_gamma_value(png_structp png_ptr, double output_gamma)
+{
+   /* The following silently ignores cases where fixed point (times 100,000)
+    * gamma values are passed to the floating point API.  This is safe and it
+    * means the fixed point constants work just fine with the floating point
+    * API.  The alternative would just lead to undetected errors and spurious
+    * bug reports.  Negative values fail inside the _fixed API unless they
+    * correspond to the flag values.
+    */
+   if (output_gamma > 0 && output_gamma < 128)
+      output_gamma *= PNG_FP_1;
+
+   /* This preserves -1 and -2 exactly: */
+   output_gamma = floor(output_gamma + .5);
+
+   if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)
+      png_fixed_error(png_ptr, "gamma value");
+
+   return (png_fixed_point)output_gamma;
+}
+#  endif
+#endif /* READ_ALPHA_MODE || READ_GAMMA */
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+void PNGFAPI
+png_set_alpha_mode_fixed(png_structp png_ptr, int mode,
+   png_fixed_point output_gamma)
+{
+   int compose = 0;
+   png_fixed_point file_gamma;
+
+   png_debug(1, "in png_set_alpha_mode");
+
+   if (png_ptr == NULL)
+      return;
+
+   output_gamma = translate_gamma_flags(png_ptr, output_gamma, 1/*screen*/);
+
+   /* Validate the value to ensure it is in a reasonable range. The value
+    * is expected to be 1 or greater, but this range test allows for some
+    * viewing correction values.  The intent is to weed out users of this API
+    * who use the inverse of the gamma value accidentally!  Since some of these
+    * values are reasonable this may have to be changed.
+    */
+   if (output_gamma < 70000 || output_gamma > 300000)
+      png_error(png_ptr, "output gamma out of expected range");
+
+   /* The default file gamma is the inverse of the output gamma; the output
+    * gamma may be changed below so get the file value first:
+    */
+   file_gamma = png_reciprocal(output_gamma);
+
+   /* There are really 8 possibilities here, composed of any combination
+    * of:
+    *
+    *    premultiply the color channels
+    *    do not encode non-opaque pixels
+    *    encode the alpha as well as the color channels
+    *
+    * The differences disappear if the input/output ('screen') gamma is 1.0,
+    * because then the encoding is a no-op and there is only the choice of
+    * premultiplying the color channels or not.
+    *
+    * png_set_alpha_mode and png_set_background interact because both use
+    * png_compose to do the work.  Calling both is only useful when
+    * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along
+    * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.
+    */
+   switch (mode)
+   {
+      case PNG_ALPHA_PNG:        /* default: png standard */
+         /* No compose, but it may be set by png_set_background! */
+         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+         break;
+
+      case PNG_ALPHA_ASSOCIATED: /* color channels premultiplied */
+         compose = 1;
+         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+         /* The output is linear: */
+         output_gamma = PNG_FP_1;
+         break;
+
+      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */
+         compose = 1;
+         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+         png_ptr->flags |= PNG_FLAG_OPTIMIZE_ALPHA;
+         /* output_gamma records the encoding of opaque pixels! */
+         break;
+
+      case PNG_ALPHA_BROKEN:     /* associated, non-linear, alpha encoded */
+         compose = 1;
+         png_ptr->transformations |= PNG_ENCODE_ALPHA;
+         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+         break;
+
+      default:
+         png_error(png_ptr, "invalid alpha mode");
+   }
+
+   /* Only set the default gamma if the file gamma has not been set (this has
+    * the side effect that the gamma in a second call to png_set_alpha_mode will
+    * be ignored.)
+    */
+   if (png_ptr->gamma == 0)
+      png_ptr->gamma = file_gamma;
+
+   /* But always set the output gamma: */
+   png_ptr->screen_gamma = output_gamma;
+
+   /* Finally, if pre-multiplying, set the background fields to achieve the
+    * desired result.
+    */
+   if (compose)
+   {
+      /* And obtain alpha pre-multiplication by composing on black: */
+      png_memset(&png_ptr->background, 0, sizeof png_ptr->background);
+      png_ptr->background_gamma = png_ptr->gamma; /* just in case */
+      png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_FILE;
+      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
+
+      if (png_ptr->transformations & PNG_COMPOSE)
+         png_error(png_ptr,
+            "conflicting calls to set alpha mode and background");
+
+      png_ptr->transformations |= PNG_COMPOSE;
+   }
+
+   /* New API, make sure apps call the correct initializers: */
+   png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;
+}
+
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+void PNGAPI
+png_set_alpha_mode(png_structp png_ptr, int mode, double output_gamma)
+{
+   png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
+      output_gamma));
 }
+#  endif
 #endif
 
 #ifdef PNG_READ_QUANTIZE_SUPPORTED
-/* Dither file to 8 bit.  Supply a palette, the current number
+/* Dither file to 8-bit.  Supply a palette, the current number
  * of elements in the palette, the maximum number of elements
  * allowed, and a histogram if possible.  If the current number
  * of colors is greater then the maximum number, the palette will be
@@ -560,30 +765,6 @@ png_set_quantize(png_structp png_ptr, png_colorp palette,
 #endif /* PNG_READ_QUANTIZE_SUPPORTED */
 
 #ifdef PNG_READ_GAMMA_SUPPORTED
-/* Transform the image from the file_gamma to the screen_gamma.  We
- * only do transformations on images where the file_gamma and screen_gamma
- * are not close reciprocals, otherwise it slows things down slightly, and
- * also needlessly introduces small errors.
- *
- * We will turn off gamma transformation later if no semitransparent entries
- * are present in the tRNS array for palette images.  We can't do it here
- * because we don't necessarily have the tRNS chunk yet.
- */
-static int /* PRIVATE */
-png_gamma_threshold(png_fixed_point scrn_gamma, png_fixed_point file_gamma)
-{
-   /* PNG_GAMMA_THRESHOLD is the threshold for performing gamma
-    * correction as a difference of the overall transform from 1.0
-    *
-    * We want to compare the threshold with s*f - 1, if we get
-    * overflow here it is because of wacky gamma values so we
-    * turn on processing anyway.
-    */
-   png_fixed_point gtest;
-   return !png_muldiv(&gtest, scrn_gamma, file_gamma, PNG_FP_1) ||
-       png_gamma_significant(gtest);
-}
-
 void PNGFAPI
 png_set_gamma_fixed(png_structp png_ptr, png_fixed_point scrn_gamma,
    png_fixed_point file_gamma)
@@ -593,10 +774,32 @@ png_set_gamma_fixed(png_structp png_ptr, png_fixed_point scrn_gamma,
    if (png_ptr == NULL)
       return;
 
-   if ((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) ||
-       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ||
-       png_gamma_threshold(scrn_gamma, file_gamma))
-      png_ptr->transformations |= PNG_GAMMA;
+   /* New in libpng-1.5.4 - reserve particular negative values as flags. */
+   scrn_gamma = translate_gamma_flags(png_ptr, scrn_gamma, 1/*screen*/);
+   file_gamma = translate_gamma_flags(png_ptr, file_gamma, 0/*file*/);
+
+#if PNG_LIBPNG_VER >= 10600
+   /* Checking the gamma values for being >0 was added in 1.5.4 along with the
+    * premultiplied alpha support; this actually hides an undocumented feature
+    * of the previous implementation which allowed gamma processing to be
+    * disabled in background handling.  There is no evidence (so far) that this
+    * was being used; however, png_set_background itself accepted and must still
+    * accept '0' for the gamma value it takes, because it isn't always used.
+    *
+    * Since this is an API change (albeit a very minor one that removes an
+    * undocumented API feature) it will not be made until libpng-1.6.0.
+    */
+   if (file_gamma <= 0)
+      png_error(png_ptr, "invalid file gamma in png_set_gamma");
+
+   if (scrn_gamma <= 0)
+      png_error(png_ptr, "invalid screen gamma in png_set_gamma");
+#endif
+
+   /* Set the gamma values unconditionally - this overrides the value in the PNG
+    * file if a gAMA chunk was present.  png_set_alpha_mode provides a
+    * different, easier, way to default the file gamma.
+    */
    png_ptr->gamma = file_gamma;
    png_ptr->screen_gamma = scrn_gamma;
 }
@@ -605,9 +808,8 @@ png_set_gamma_fixed(png_structp png_ptr, png_fixed_point scrn_gamma,
 void PNGAPI
 png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
 {
-   png_set_gamma_fixed(png_ptr,
-      png_fixed(png_ptr, scrn_gamma, "png_set_gamma screen gamma"),
-      png_fixed(png_ptr, file_gamma, "png_set_gamma file gamma"));
+   png_set_gamma_fixed(png_ptr, convert_gamma_value(png_ptr, scrn_gamma),
+      convert_gamma_value(png_ptr, file_gamma));
 }
 #  endif /* FLOATING_POINT_SUPPORTED */
 #endif /* READ_GAMMA */
@@ -686,6 +888,26 @@ png_set_tRNS_to_alpha(png_structp png_ptr)
 }
 #endif /* defined(PNG_READ_EXPAND_SUPPORTED) */
 
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise
+ * it may not work correctly.)
+ */
+void PNGAPI
+png_set_expand_16(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_expand_16");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= (PNG_EXPAND_16 | PNG_EXPAND | PNG_EXPAND_tRNS);
+   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
+
+   /* New API, make sure apps call the correct initializers: */
+   png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;
+}
+#endif
+
 #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 void PNGAPI
 png_set_gray_to_rgb(png_structp png_ptr)
@@ -714,15 +936,15 @@ png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
 
    switch(error_action)
    {
-      case 1:
+      case PNG_ERROR_ACTION_NONE:
          png_ptr->transformations |= PNG_RGB_TO_GRAY;
          break;
 
-      case 2:
+      case PNG_ERROR_ACTION_WARN:
          png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
          break;
 
-      case 3:
+      case PNG_ERROR_ACTION_ERROR:
          png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
          break;
 
@@ -742,30 +964,43 @@ png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
    }
 #endif
    {
-      png_uint_16 red_int, green_int;
-      if (red < 0 || green < 0)
+      if (red >= 0 && green >= 0 && red + green <= PNG_FP_1)
       {
-         red_int   =  6968; /* .212671 * 32768 + .5 */
-         green_int = 23434; /* .715160 * 32768 + .5 */
-      }
+         png_uint_16 red_int, green_int;
 
-      else if (red + green < 100000L)
-      {
-         red_int = (png_uint_16)(((png_uint_32)red*32768L)/100000L);
-         green_int = (png_uint_16)(((png_uint_32)green*32768L)/100000L);
+         /* NOTE: this calculation does not round, but this behavior is retained
+          * for consistency, the inaccuracy is very small.  The code here always
+          * overwrites the coefficients, regardless of whether they have been
+          * defaulted or set already.
+          */
+         red_int = (png_uint_16)(((png_uint_32)red*32768)/100000);
+         green_int = (png_uint_16)(((png_uint_32)green*32768)/100000);
+
+         png_ptr->rgb_to_gray_red_coeff   = red_int;
+         png_ptr->rgb_to_gray_green_coeff = green_int;
+         png_ptr->rgb_to_gray_coefficients_set = 1;
       }
 
       else
       {
-         png_warning(png_ptr, "ignoring out of range rgb_to_gray coefficients");
-         red_int   =  6968;
-         green_int = 23434;
+         if (red >= 0 && green >= 0)
+            png_warning(png_ptr,
+               "ignoring out of range rgb_to_gray coefficients");
+
+         /* Use the defaults, from the cHRM chunk if set, else the historical
+          * values which are close to the sRGB/HDTV/ITU-Rec 709 values.  See
+          * png_do_rgb_to_gray for more discussion of the values.  In this case
+          * the coefficients are not marked as 'set' and are not overwritten if
+          * something has already provided a default.
+          */
+         if (png_ptr->rgb_to_gray_red_coeff == 0 &&
+            png_ptr->rgb_to_gray_green_coeff == 0)
+         {
+            png_ptr->rgb_to_gray_red_coeff   = 6968;
+            png_ptr->rgb_to_gray_green_coeff = 23434;
+            /* png_ptr->rgb_to_gray_blue_coeff  = 2366; */
+         }
       }
-
-      png_ptr->rgb_to_gray_red_coeff   = red_int;
-      png_ptr->rgb_to_gray_green_coeff = green_int;
-      png_ptr->rgb_to_gray_blue_coeff  =
-          (png_uint_16)(32768 - red_int - green_int);
    }
 }
 
@@ -807,167 +1042,513 @@ png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
 }
 #endif
 
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
+#ifdef PNG_READ_GAMMA_SUPPORTED
+/* In the case of gamma transformations only do transformations on images where
+ * the [file] gamma and screen_gamma are not close reciprocals, otherwise it
+ * slows things down slightly, and also needlessly introduces small errors.
+ */
+static int /* PRIVATE */
+png_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point file_gamma)
+{
+   /* PNG_GAMMA_THRESHOLD is the threshold for performing gamma
+    * correction as a difference of the overall transform from 1.0
+    *
+    * We want to compare the threshold with s*f - 1, if we get
+    * overflow here it is because of wacky gamma values so we
+    * turn on processing anyway.
+    */
+   png_fixed_point gtest;
+   return !png_muldiv(&gtest, screen_gamma, file_gamma, PNG_FP_1) ||
+       png_gamma_significant(gtest);
+}
+#endif
+
 /* Initialize everything needed for the read.  This includes modifying
  * the palette.
  */
-void /* PRIVATE */
-png_init_read_transformations(png_structp png_ptr)
+
+/*For the moment 'png_init_palette_transformations' and
+ * 'png_init_rgb_transformations' only do some flag canceling optimizations.
+ * The intent is that these two routines should have palette or rgb operations
+ * extracted from 'png_init_read_transformations'.
+ */
+static void /* PRIVATE */
+png_init_palette_transformations(png_structp png_ptr)
 {
-   png_debug(1, "in png_init_read_transformations");
+   /* Called to handle the (input) palette case.  In png_do_read_transformations
+    * the first step is to expand the palette if requested, so this code must
+    * take care to only make changes that are invariant with respect to the
+    * palette expansion, or only do them if there is no expansion.
+    *
+    * STRIP_ALPHA has already been handled in the caller (by setting num_trans
+    * to 0.)
+    */
+   int input_has_alpha = 0;
+   int input_has_transparency = 0;
 
-  {
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
-    defined(PNG_READ_SHIFT_SUPPORTED) || \
-    defined(PNG_READ_GAMMA_SUPPORTED)
-   int color_type = png_ptr->color_type;
-#endif
+   if (png_ptr->num_trans > 0)
+   {
+      int i;
+
+      /* Ignore if all the entries are opaque (unlikely!) */
+      for (i=0; i<png_ptr->num_trans; ++i)
+         if (png_ptr->trans_alpha[i] == 255)
+            continue;
+         else if (png_ptr->trans_alpha[i] == 0)
+            input_has_transparency = 1;
+         else
+            input_has_alpha = 1;
+   }
+
+   /* If no alpha we can optimize. */
+   if (!input_has_alpha)
+   {
+      /* Any alpha means background and associative alpha processing is
+       * required, however if the alpha is 0 or 1 throughout OPTIIMIZE_ALPHA
+       * and ENCODE_ALPHA are irrelevant.
+       */
+      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+
+      if (!input_has_transparency)
+         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
+   }
 
 #if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
+   /* png_set_background handling - deals with the complexity of whether the
+    * background color is in the file format or the screen format in the case
+    * where an 'expand' will happen.
+    */
 
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /* Detect gray background and attempt to enable optimization
-    * for gray --> RGB case
-    *
-    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
-    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
-    * background color might actually be gray yet not be flagged as such.
-    * This is not a problem for the current code, which uses
-    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
-    * png_do_gray_to_rgb() transformation.
+   /* The following code cannot be entered in the alpha pre-multiplication case
+    * because PNG_BACKGROUND_EXPAND is cancelled below.
     */
    if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-       !(color_type & PNG_COLOR_MASK_COLOR))
+       (png_ptr->transformations & PNG_EXPAND))
    {
-      png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
-   }
+      {
+         png_ptr->background.red   =
+             png_ptr->palette[png_ptr->background.index].red;
+         png_ptr->background.green =
+             png_ptr->palette[png_ptr->background.index].green;
+         png_ptr->background.blue  =
+             png_ptr->palette[png_ptr->background.index].blue;
 
-   else if ((png_ptr->transformations & PNG_BACKGROUND) &&
-       !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-       (png_ptr->transformations & PNG_GRAY_TO_RGB) &&
-       png_ptr->background.red == png_ptr->background.green &&
-       png_ptr->background.red == png_ptr->background.blue)
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
+        if (png_ptr->transformations & PNG_INVERT_ALPHA)
+        {
+           if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
+           {
+              /* Invert the alpha channel (in tRNS) unless the pixels are
+               * going to be expanded, in which case leave it for later
+               */
+              int i, istop = png_ptr->num_trans;
+
+              for (i=0; i<istop; i++)
+                 png_ptr->trans_alpha[i] = (png_byte)(255 -
+                    png_ptr->trans_alpha[i]);
+           }
+        }
+#endif /* PNG_READ_INVERT_ALPHA_SUPPORTED */
+      }
+   } /* background expand and (therefore) no alpha association. */
+#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */
+}
+
+static void /* PRIVATE */
+png_init_rgb_transformations(png_structp png_ptr)
+{
+   /* Added to libpng-1.5.4: check the color type to determine whether there
+    * is any alpha or transparency in the image and simply cancel the
+    * background and alpha mode stuff if there isn't.
+    */
+   int input_has_alpha = (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0;
+   int input_has_transparency = png_ptr->num_trans > 0;
+
+   /* If no alpha we can optimize. */
+   if (!input_has_alpha)
    {
-      png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
-      png_ptr->background.gray = png_ptr->background.red;
+      /* Any alpha means background and associative alpha processing is
+       * required, however if the alpha is 0 or 1 throughout OPTIIMIZE_ALPHA
+       * and ENCODE_ALPHA are irrelevant.
+       */
+#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+#     endif
+
+      if (!input_has_transparency)
+         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
    }
-#endif
 
+#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
+   /* png_set_background handling - deals with the complexity of whether the
+    * background color is in the file format or the screen format in the case
+    * where an 'expand' will happen.
+    */
+
+   /* The following code cannot be entered in the alpha pre-multiplication case
+    * because PNG_BACKGROUND_EXPAND is cancelled below.
+    */
    if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-       (png_ptr->transformations & PNG_EXPAND))
+       (png_ptr->transformations & PNG_EXPAND) &&
+       !(png_ptr->color_type & PNG_COLOR_MASK_COLOR))
+       /* i.e., GRAY or GRAY_ALPHA */
    {
-      if (!(color_type & PNG_COLOR_MASK_COLOR))  /* i.e., GRAY or GRAY_ALPHA */
       {
          /* Expand background and tRNS chunks */
+         int gray = png_ptr->background.gray;
+         int trans_gray = png_ptr->trans_color.gray;
+
          switch (png_ptr->bit_depth)
          {
             case 1:
-               png_ptr->background.gray *= (png_uint_16)0xff;
-               png_ptr->background.red = png_ptr->background.green
-                   =  png_ptr->background.blue = png_ptr->background.gray;
-               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-               {
-                 png_ptr->trans_color.gray *= (png_uint_16)0xff;
-                 png_ptr->trans_color.red = png_ptr->trans_color.green
-                     = png_ptr->trans_color.blue = png_ptr->trans_color.gray;
-               }
+               gray *= 0xff;
+               trans_gray *= 0xff;
                break;
 
             case 2:
-               png_ptr->background.gray *= (png_uint_16)0x55;
-               png_ptr->background.red = png_ptr->background.green
-                   = png_ptr->background.blue = png_ptr->background.gray;
-               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-               {
-                  png_ptr->trans_color.gray *= (png_uint_16)0x55;
-                  png_ptr->trans_color.red = png_ptr->trans_color.green
-                      = png_ptr->trans_color.blue = png_ptr->trans_color.gray;
-               }
+               gray *= 0x55;
+               trans_gray *= 0x55;
                break;
 
             case 4:
-               png_ptr->background.gray *= (png_uint_16)0x11;
-               png_ptr->background.red = png_ptr->background.green
-                   = png_ptr->background.blue = png_ptr->background.gray;
-               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-               {
-                  png_ptr->trans_color.gray *= (png_uint_16)0x11;
-                  png_ptr->trans_color.red = png_ptr->trans_color.green
-                      = png_ptr->trans_color.blue = png_ptr->trans_color.gray;
-               }
+               gray *= 0x11;
+               trans_gray *= 0x11;
                break;
 
             default:
 
             case 8:
+               /* Already 8 bits, fall through */
 
             case 16:
-               png_ptr->background.red = png_ptr->background.green
-                   = png_ptr->background.blue = png_ptr->background.gray;
+               /* Already a full 16 bits */
                break;
          }
+
+         png_ptr->background.red = png_ptr->background.green =
+            png_ptr->background.blue = (png_uint_16)gray;
+
+         if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
+         {
+            png_ptr->trans_color.red = png_ptr->trans_color.green =
+               png_ptr->trans_color.blue = (png_uint_16)trans_gray;
+         }
       }
-      else if (color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         png_ptr->background.red   =
-             png_ptr->palette[png_ptr->background.index].red;
-         png_ptr->background.green =
-             png_ptr->palette[png_ptr->background.index].green;
-         png_ptr->background.blue  =
-             png_ptr->palette[png_ptr->background.index].blue;
+   } /* background expand and (therefore) no alpha association. */
+#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */
+}
 
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-        if (png_ptr->transformations & PNG_INVERT_ALPHA)
-        {
-#ifdef PNG_READ_EXPAND_SUPPORTED
-           if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-#endif
-           {
-              /* Invert the alpha channel (in tRNS) unless the pixels are
-               * going to be expanded, in which case leave it for later
-               */
-              int i, istop;
-              istop=(int)png_ptr->num_trans;
-              for (i=0; i<istop; i++)
-                 png_ptr->trans_alpha[i] = (png_byte)(255 -
-                    png_ptr->trans_alpha[i]);
-           }
-        }
-#endif
+void /* PRIVATE */
+png_init_read_transformations(png_structp png_ptr)
+{
+   png_debug(1, "in png_init_read_transformations");
+
+   /* This internal function is called from png_read_start_row in pngrutil.c
+    * and it is called before the 'rowbytes' calculation is done, so the code
+    * in here can change or update the transformations flags.
+    *
+    * First do updates that do not depend on the details of the PNG image data
+    * being processed.
+    */
+
+#ifdef PNG_READ_GAMMA_SUPPORTED
+   /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
+    * png_set_alpha_mode and this is another source for a default file gamma so
+    * the test needs to be performed later - here.  In addition prior to 1.5.4
+    * the tests were repeated for the PALETTE color type here - this is no
+    * longer necessary (and doesn't seem to have been necessary before.)
+    */
+   {
+      /* The following temporary indicates if overall gamma correction is
+       * required.
+       */
+      int gamma_correction = 0;
 
+      if (png_ptr->gamma != 0) /* has been set */
+      {
+         if (png_ptr->screen_gamma != 0) /* screen set too */
+            gamma_correction = png_gamma_threshold(png_ptr->gamma,
+               png_ptr->screen_gamma);
+
+         else
+            /* Assume the output matches the input; a long time default behavior
+             * of libpng, although the standard has nothing to say about this.
+             */
+            png_ptr->screen_gamma = png_reciprocal(png_ptr->gamma);
       }
+
+      else if (png_ptr->screen_gamma != 0)
+         /* The converse - assume the file matches the screen, note that this
+          * perhaps undesireable default can (from 1.5.4) be changed by calling
+          * png_set_alpha_mode (even if the alpha handling mode isn't required
+          * or isn't changed from the default.)
+          */
+         png_ptr->gamma = png_reciprocal(png_ptr->screen_gamma);
+
+      else /* neither are set */
+         /* Just in case the following prevents any processing - file and screen
+          * are both assumed to be linear and there is no way to introduce a
+          * third gamma value other than png_set_background with 'UNIQUE', and,
+          * prior to 1.5.4
+          */
+         png_ptr->screen_gamma = png_ptr->gamma = PNG_FP_1;
+
+      /* Now turn the gamma transformation on or off as appropriate.  Notice
+       * that PNG_GAMMA just refers to the file->screen correction.  Alpha
+       * composition may independently cause gamma correction because it needs
+       * linear data (e.g. if the file has a gAMA chunk but the screen gamma
+       * hasn't been specified.)  In any case this flag may get turned off in
+       * the code immediately below if the transform can be handled outside the
+       * row loop.
+       */
+      if (gamma_correction)
+         png_ptr->transformations |= PNG_GAMMA;
+
+      else
+         png_ptr->transformations &= ~PNG_GAMMA;
    }
 #endif
 
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
-   png_ptr->background_1 = png_ptr->background;
+   /* Certain transformations have the effect of preventing other
+    * transformations that happen afterward in png_do_read_transformations,
+    * resolve the interdependencies here.  From the code of
+    * png_do_read_transformations the order is:
+    *
+    *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)
+    *  2) PNG_STRIP_ALPHA (if no compose)
+    *  3) PNG_RGB_TO_GRAY
+    *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY
+    *  5) PNG_COMPOSE
+    *  6) PNG_GAMMA
+    *  7) PNG_STRIP_ALPHA (if compose)
+    *  8) PNG_ENCODE_ALPHA
+    *  9) PNG_SCALE_16_TO_8
+    * 10) PNG_16_TO_8
+    * 11) PNG_QUANTIZE (converts to palette)
+    * 12) PNG_EXPAND_16
+    * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY
+    * 14) PNG_INVERT_MONO
+    * 15) PNG_SHIFT
+    * 16) PNG_PACK
+    * 17) PNG_BGR
+    * 18) PNG_PACKSWAP
+    * 19) PNG_FILLER (includes PNG_ADD_ALPHA)
+    * 20) PNG_INVERT_ALPHA
+    * 21) PNG_SWAP_ALPHA
+    * 22) PNG_SWAP_BYTES
+    * 23) PNG_USER_TRANSFORM [must be last]
+    */
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
+   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
+      !(png_ptr->transformations & PNG_COMPOSE))
+   {
+      /* Stripping the alpha channel happens immediately after the 'expand'
+       * transformations, before all other transformation, so it cancels out
+       * the alpha handling.  It has the side effect negating the effect of
+       * PNG_EXPAND_tRNS too:
+       */
+      png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |
+         PNG_EXPAND_tRNS);
+      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+
+      /* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen
+       * so transparency information would remain just so long as it wasn't
+       * expanded.  This produces unexpected API changes if the set of things
+       * that do PNG_EXPAND_tRNS changes (perfectly possible given the
+       * documentation - which says ask for what you want, accept what you
+       * get.)  This makes the behavior consistent from 1.5.4:
+       */
+      png_ptr->num_trans = 0;
+   }
+#endif /* STRIP_ALPHA supported, no COMPOSE */
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+   /* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA
+    * settings will have no effect.
+    */
+   if (!png_gamma_significant(png_ptr->screen_gamma))
+   {
+      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+   }
 #endif
-#ifdef PNG_READ_GAMMA_SUPPORTED
 
-   if ((color_type == PNG_COLOR_TYPE_PALETTE && png_ptr->num_trans != 0)
-       && png_gamma_threshold(png_ptr->screen_gamma, png_ptr->gamma))
+#if defined(PNG_READ_EXPAND_SUPPORTED) && \
+   defined(PNG_READ_BACKGROUND_SUPPORTED) && \
+   defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+   /* Detect gray background and attempt to enable optimization for
+    * gray --> RGB case.
+    *
+    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
+    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
+    * background color might actually be gray yet not be flagged as such.
+    * This is not a problem for the current code, which uses
+    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
+    * png_do_gray_to_rgb() transformation.
+    *
+    * TODO: this code needs to be revised to avoid the complexity and
+    * interdependencies.  The color type of the background should be recorded in
+    * png_set_background, along with the bit depth, then the code has a record
+    * of exactly what color space the background is currently in.
+    */
+   if (png_ptr->transformations & PNG_BACKGROUND_EXPAND)
+   {
+      /* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if
+       * the file was grayscale the background value is gray.
+       */
+      if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR))
+         png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
+   }
+
+   else if (png_ptr->transformations & PNG_COMPOSE)
    {
-      int i, k;
-      k=0;
-      for (i=0; i<png_ptr->num_trans; i++)
+      /* PNG_COMPOSE: png_set_background was called with need_expand false,
+       * so the color is in the color space of the output or png_set_alpha_mode
+       * was called and the color is black.  Ignore RGB_TO_GRAY because that
+       * happens before GRAY_TO_RGB.
+       */
+      if (png_ptr->transformations & PNG_GRAY_TO_RGB)
       {
-        if (png_ptr->trans_alpha[i] != 0 && png_ptr->trans_alpha[i] != 0xff)
-           k=1; /* Partial transparency is present */
+         if (png_ptr->background.red == png_ptr->background.green &&
+             png_ptr->background.red == png_ptr->background.blue)
+         {
+            png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
+            png_ptr->background.gray = png_ptr->background.red;
+         }
       }
-      if (k == 0)
-         png_ptr->transformations &= ~PNG_GAMMA;
    }
+#endif /* PNG_READ_GRAY_TO_RGB_SUPPORTED (etc) */
+
+   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations
+    * can be performed directly on the palette, and some (such as rgb to gray)
+    * can be optimized inside the palette.  This is particularly true of the
+    * composite (background and alpha) stuff, which can be pretty much all done
+    * in the palette even if the result is expanded to RGB or gray afterward.
+    *
+    * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and
+    * earlier and the palette stuff is actually handled on the first row.  This
+    * leads to the reported bug that the palette returned by png_get_PLTE is not
+    * updated.
+    */
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+      png_init_palette_transformations(png_ptr);
+
+   else
+      png_init_rgb_transformations(png_ptr);
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
+   defined(PNG_READ_EXPAND_16_SUPPORTED)
+   if ((png_ptr->transformations & PNG_EXPAND_16) &&
+      (png_ptr->transformations & PNG_COMPOSE) &&
+      !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
+      png_ptr->bit_depth != 16)
+   {
+      /* TODO: fix this.  Because the expand_16 operation is after the compose
+       * handling the background color must be 8, not 16, bits deep, but the
+       * application will supply a 16-bit value so reduce it here.
+       *
+       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at
+       * present, so that case is ok (until do_expand_16 is moved.)
+       *
+       * NOTE: this discards the low 16 bits of the user supplied background
+       * color, but until expand_16 works properly there is no choice!
+       */
+#     define CHOP(x) (x)=((png_uint_16)(((png_uint_32)(x)*255+32895) >> 16))
+      CHOP(png_ptr->background.red);
+      CHOP(png_ptr->background.green);
+      CHOP(png_ptr->background.blue);
+      CHOP(png_ptr->background.gray);
+#     undef CHOP
+   }
+#endif /* PNG_READ_BACKGROUND_SUPPORTED && PNG_READ_EXPAND_16_SUPPORTED */
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
+   (defined(PNG_READ_SCALE_16_TO_8_SUPPORTED) || \
+   defined(PNG_READ_STRIP_16_TO_8_SUPPORTED))
+   if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) &&
+      (png_ptr->transformations & PNG_COMPOSE) &&
+      !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
+      png_ptr->bit_depth == 16)
+   {
+      /* On the other hand, if a 16-bit file is to be reduced to 8-bits per
+       * component this will also happen after PNG_COMPOSE and so the background
+       * color must be pre-expanded here.
+       *
+       * TODO: fix this too.
+       */
+      png_ptr->background.red = (png_uint_16)(png_ptr->background.red * 257);
+      png_ptr->background.green =
+         (png_uint_16)(png_ptr->background.green * 257);
+      png_ptr->background.blue = (png_uint_16)(png_ptr->background.blue * 257);
+      png_ptr->background.gray = (png_uint_16)(png_ptr->background.gray * 257);
+   }
+#endif
+
+   /* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the
+    * background support (see the comments in scripts/pnglibconf.dfa), this
+    * allows pre-multiplication of the alpha channel to be implemented as
+    * compositing on black.  This is probably sub-optimal and has been done in
+    * 1.5.4 betas simply to enable external critique and testing (i.e. to
+    * implement the new API quickly, without lots of internal changes.)
+    */
 
-   if ((png_ptr->transformations & (PNG_GAMMA | PNG_RGB_TO_GRAY)) &&
-       png_ptr->gamma != 0)
+#ifdef PNG_READ_GAMMA_SUPPORTED
+#  ifdef PNG_READ_BACKGROUND_SUPPORTED
+      /* Includes ALPHA_MODE */
+      png_ptr->background_1 = png_ptr->background;
+#  endif
+
+   /* This needs to change - in the palette image case a whole set of tables are
+    * built when it would be quicker to just calculate the correct value for
+    * each palette entry directly.  Also, the test is too tricky - why check
+    * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that
+    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the
+    * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction
+    * the gamma tables will not be built even if composition is required on a
+    * gamma encoded value.
+    *
+    * In 1.5.4 this is addressed below by an additional check on the individual
+    * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the
+    * tables.
+    */
+   if ((png_ptr->transformations & PNG_GAMMA)
+      || ((png_ptr->transformations & PNG_RGB_TO_GRAY)
+         && (png_gamma_significant(png_ptr->gamma) ||
+            png_gamma_significant(png_ptr->screen_gamma)))
+      || ((png_ptr->transformations & PNG_COMPOSE)
+         && (png_gamma_significant(png_ptr->gamma)
+            || png_gamma_significant(png_ptr->screen_gamma)
+#  ifdef PNG_READ_BACKGROUND_SUPPORTED
+            || (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_UNIQUE
+               && png_gamma_significant(png_ptr->background_gamma))
+#  endif
+      )) || ((png_ptr->transformations & PNG_ENCODE_ALPHA)
+         && png_gamma_significant(png_ptr->screen_gamma))
+      )
    {
       png_build_gamma_table(png_ptr, png_ptr->bit_depth);
 
 #ifdef PNG_READ_BACKGROUND_SUPPORTED
-      if (png_ptr->transformations & PNG_BACKGROUND)
+      if (png_ptr->transformations & PNG_COMPOSE)
       {
-         if (color_type == PNG_COLOR_TYPE_PALETTE)
+         /* Issue a warning about this combination: because RGB_TO_GRAY is
+          * optimized to do the gamma transform if present yet do_background has
+          * to do the same thing if both options are set a
+          * double-gamma-correction happens.  This is true in all versions of
+          * libpng to date.
+          */
+         if (png_ptr->transformations & PNG_RGB_TO_GRAY)
+            png_warning(png_ptr,
+               "libpng does not support gamma+background+rgb_to_gray");
+
+         if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
          {
-            /* Could skip if no transparency */
+            /* We don't get to here unless there is a tRNS chunk with non-opaque
+             * entries - see the checking code at the start of this function.
+             */
             png_color back, back_1;
             png_colorp palette = png_ptr->palette;
             int num_palette = png_ptr->num_palette;
@@ -1013,26 +1594,39 @@ png_init_read_transformations(png_structp png_ptr)
 
                if (png_gamma_significant(gs))
                {
+                  back.red = png_gamma_8bit_correct(png_ptr->background.red,
+                      gs);
+                  back.green = png_gamma_8bit_correct(png_ptr->background.green,
+                      gs);
+                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,
+                      gs);
+               }
+
+               else
+               {
                   back.red   = (png_byte)png_ptr->background.red;
                   back.green = (png_byte)png_ptr->background.green;
                   back.blue  = (png_byte)png_ptr->background.blue;
                }
 
+               if (png_gamma_significant(g))
+               {
+                  back_1.red = png_gamma_8bit_correct(png_ptr->background.red,
+                     g);
+                  back_1.green = png_gamma_8bit_correct(
+                     png_ptr->background.green, g);
+                  back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,
+                     g);
+               }
+
                else
                {
-                  back.red = png_gamma_8bit_correct(png_ptr->background.red,
-                      gs);
-                  back.green = png_gamma_8bit_correct(png_ptr->background.green,
-                      gs);
-                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,
-                      gs);
+                  back_1.red   = (png_byte)png_ptr->background.red;
+                  back_1.green = (png_byte)png_ptr->background.green;
+                  back_1.blue  = (png_byte)png_ptr->background.blue;
                }
-               back_1.red = png_gamma_8bit_correct(png_ptr->background.red, g);
-               back_1.green = png_gamma_8bit_correct(png_ptr->background.green,
-                   g);
-               back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,
-                   g);
             }
+
             for (i = 0; i < num_palette; i++)
             {
                if (i < (int)png_ptr->num_trans &&
@@ -1066,22 +1660,22 @@ png_init_read_transformations(png_structp png_ptr)
                   palette[i].blue = png_ptr->gamma_table[palette[i].blue];
                }
             }
-            /* Prevent the transformations being done again, and make sure
-             * that the now spurious alpha channel is stripped - the code
-             * has just reduced background composition and gamma correction
-             * to a simple alpha channel strip.
+
+            /* Prevent the transformations being done again.
+             *
+             * NOTE: this is highly dubious; it removes the transformations in
+             * place.  This seems inconsistent with the general treatment of the
+             * transformations elsewhere.
              */
-            png_ptr->transformations &= ~PNG_BACKGROUND;
-            png_ptr->transformations &= ~PNG_GAMMA;
-            png_ptr->flags |= PNG_FLAG_STRIP_ALPHA;
-         }
+            png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);
+         } /* color_type == PNG_COLOR_TYPE_PALETTE */
 
          /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
-         else
-         /* color_type != PNG_COLOR_TYPE_PALETTE */
+         else /* color_type != PNG_COLOR_TYPE_PALETTE */
          {
-            png_fixed_point g = PNG_FP_1;
-            png_fixed_point gs = PNG_FP_1;
+            int gs_sig, g_sig;
+            png_fixed_point g = PNG_FP_1;  /* Correction to linear */
+            png_fixed_point gs = PNG_FP_1; /* Correction to screen */
 
             switch (png_ptr->background_gamma_type)
             {
@@ -1105,34 +1699,45 @@ png_init_read_transformations(png_structp png_ptr)
                   png_error(png_ptr, "invalid background gamma type");
             }
 
-            png_ptr->background_1.gray = png_gamma_correct(png_ptr,
-                png_ptr->background.gray, g);
+            g_sig = png_gamma_significant(g);
+            gs_sig = png_gamma_significant(gs);
+
+            if (g_sig)
+               png_ptr->background_1.gray = png_gamma_correct(png_ptr,
+                   png_ptr->background.gray, g);
 
-            png_ptr->background.gray = png_gamma_correct(png_ptr,
-                png_ptr->background.gray, gs);
+            if (gs_sig)
+               png_ptr->background.gray = png_gamma_correct(png_ptr,
+                   png_ptr->background.gray, gs);
 
             if ((png_ptr->background.red != png_ptr->background.green) ||
                 (png_ptr->background.red != png_ptr->background.blue) ||
                 (png_ptr->background.red != png_ptr->background.gray))
             {
                /* RGB or RGBA with color background */
-               png_ptr->background_1.red = png_gamma_correct(png_ptr,
-                   png_ptr->background.red, g);
+               if (g_sig)
+               {
+                  png_ptr->background_1.red = png_gamma_correct(png_ptr,
+                      png_ptr->background.red, g);
 
-               png_ptr->background_1.green = png_gamma_correct(png_ptr,
-                   png_ptr->background.green, g);
+                  png_ptr->background_1.green = png_gamma_correct(png_ptr,
+                      png_ptr->background.green, g);
 
-               png_ptr->background_1.blue = png_gamma_correct(png_ptr,
-                   png_ptr->background.blue, g);
+                  png_ptr->background_1.blue = png_gamma_correct(png_ptr,
+                      png_ptr->background.blue, g);
+               }
 
-               png_ptr->background.red = png_gamma_correct(png_ptr,
-                   png_ptr->background.red, gs);
+               if (gs_sig)
+               {
+                  png_ptr->background.red = png_gamma_correct(png_ptr,
+                      png_ptr->background.red, gs);
 
-               png_ptr->background.green = png_gamma_correct(png_ptr,
-                   png_ptr->background.green, gs);
+                  png_ptr->background.green = png_gamma_correct(png_ptr,
+                      png_ptr->background.green, gs);
 
-               png_ptr->background.blue = png_gamma_correct(png_ptr,
-                   png_ptr->background.blue, gs);
+                  png_ptr->background.blue = png_gamma_correct(png_ptr,
+                      png_ptr->background.blue, gs);
+               }
             }
 
             else
@@ -1144,17 +1749,30 @@ png_init_read_transformations(png_structp png_ptr)
                png_ptr->background.red = png_ptr->background.green
                    = png_ptr->background.blue = png_ptr->background.gray;
             }
-         }
-      }
+
+            /* The background is now in screen gamma: */
+            png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_SCREEN;
+         } /* color_type != PNG_COLOR_TYPE_PALETTE */
+      }/* png_ptr->transformations & PNG_BACKGROUND */
+
       else
       /* Transformation does not include PNG_BACKGROUND */
 #endif /* PNG_READ_BACKGROUND_SUPPORTED */
-      if (color_type == PNG_COLOR_TYPE_PALETTE)
+      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+         /* RGB_TO_GRAY needs to have non-gamma-corrected values! */
+         && ((png_ptr->transformations & PNG_EXPAND) == 0 ||
+         (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)
+#endif
+         )
       {
          png_colorp palette = png_ptr->palette;
          int num_palette = png_ptr->num_palette;
          int i;
 
+         /*NOTE: there are other transformations that should probably be in here
+          * too.
+          */
          for (i = 0; i < num_palette; i++)
          {
             palette[i].red = png_ptr->gamma_table[palette[i].red];
@@ -1164,16 +1782,17 @@ png_init_read_transformations(png_structp png_ptr)
 
          /* Done the gamma correction. */
          png_ptr->transformations &= ~PNG_GAMMA;
-      }
+      } /* color_type == PALETTE && !PNG_BACKGROUND transformation */
    }
 #ifdef PNG_READ_BACKGROUND_SUPPORTED
    else
 #endif
 #endif /* PNG_READ_GAMMA_SUPPORTED */
+
 #ifdef PNG_READ_BACKGROUND_SUPPORTED
-   /* No GAMMA transformation */
-   if ((png_ptr->transformations & PNG_BACKGROUND) &&
-       (color_type == PNG_COLOR_TYPE_PALETTE))
+   /* No GAMMA transformation (see the hanging else 4 lines above) */
+   if ((png_ptr->transformations & PNG_COMPOSE) &&
+       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
    {
       int i;
       int istop = (int)png_ptr->num_trans;
@@ -1205,45 +1824,52 @@ png_init_read_transformations(png_structp png_ptr)
          }
       }
 
-      /* Handled alpha, still need to strip the channel. */
-      png_ptr->transformations &= ~PNG_BACKGROUND;
-      png_ptr->flags |= PNG_FLAG_STRIP_ALPHA;
+      png_ptr->transformations &= ~PNG_COMPOSE;
    }
 #endif /* PNG_READ_BACKGROUND_SUPPORTED */
 
 #ifdef PNG_READ_SHIFT_SUPPORTED
    if ((png_ptr->transformations & PNG_SHIFT) &&
-       (color_type == PNG_COLOR_TYPE_PALETTE))
+      !(png_ptr->transformations & PNG_EXPAND) &&
+       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
    {
-      png_uint_16 i;
-      png_uint_16 istop = png_ptr->num_palette;
-      int sr = 8 - png_ptr->sig_bit.red;
-      int sg = 8 - png_ptr->sig_bit.green;
-      int sb = 8 - png_ptr->sig_bit.blue;
+      int i;
+      int istop = png_ptr->num_palette;
+      int shift = 8 - png_ptr->sig_bit.red;
 
-      if (sr < 0 || sr > 8)
-         sr = 0;
+      png_ptr->transformations &= ~PNG_SHIFT;
 
-      if (sg < 0 || sg > 8)
-         sg = 0;
+      /* significant bits can be in the range 1 to 7 for a meaninful result, if
+       * the number of significant bits is 0 then no shift is done (this is an
+       * error condition which is silently ignored.)
+       */
+      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
+      {
+         int component = png_ptr->palette[i].red;
 
-      if (sb < 0 || sb > 8)
-         sb = 0;
+         component >>= shift;
+         png_ptr->palette[i].red = (png_byte)component;
+      }
 
-      for (i = 0; i < istop; i++)
+      shift = 8 - png_ptr->sig_bit.green;
+      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
       {
-         png_ptr->palette[i].red >>= sr;
-         png_ptr->palette[i].green >>= sg;
-         png_ptr->palette[i].blue >>= sb;
+         int component = png_ptr->palette[i].green;
+
+         component >>= shift;
+         png_ptr->palette[i].green = (png_byte)component;
+      }
+
+      shift = 8 - png_ptr->sig_bit.blue;
+      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
+      {
+         int component = png_ptr->palette[i].blue;
+
+         component >>= shift;
+         png_ptr->palette[i].blue = (png_byte)component;
       }
    }
 #endif  /* PNG_READ_SHIFT_SUPPORTED */
- }
-#if !defined(PNG_READ_GAMMA_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED) \
- && !defined(PNG_READ_BACKGROUND_SUPPORTED)
-   if (png_ptr)
-      return;
-#endif
 }
 
 /* Modify the info structure to reflect the transformations.  The
@@ -1260,8 +1886,11 @@ png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
    {
       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
       {
-         if (png_ptr->num_trans &&
-             (png_ptr->transformations & PNG_EXPAND_tRNS))
+         /* This check must match what actually happens in
+          * png_do_expand_palette; if it ever checks the tRNS chunk to see if
+          * it is all opaque we must do the same (at present it does not.)
+          */
+         if (png_ptr->num_trans > 0)
             info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
 
          else
@@ -1285,45 +1914,72 @@ png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
    }
 #endif
 
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   if (png_ptr->transformations & PNG_BACKGROUND)
-   {
-      info_ptr->color_type = (png_byte)(info_ptr->color_type &
-          ~PNG_COLOR_MASK_ALPHA);
-      info_ptr->num_trans = 0;
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
+   /* The following is almost certainly wrong unless the background value is in
+    * the screen space!
+    */
+   if (png_ptr->transformations & PNG_COMPOSE)
       info_ptr->background = png_ptr->background;
-   }
 #endif
 
 #ifdef PNG_READ_GAMMA_SUPPORTED
-   if (png_ptr->transformations & PNG_GAMMA)
-   {
-      info_ptr->gamma = png_ptr->gamma;
-   }
+   /* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),
+    * however it seems that the code in png_init_read_transformations, which has
+    * been called before this from png_read_update_info->png_read_start_row
+    * sometimes does the gamma transform and cancels the flag.
+    */
+   info_ptr->gamma = png_ptr->gamma;
 #endif
 
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-#ifdef PNG_READ_16BIT_SUPPORTED
-   if ((png_ptr->transformations & PNG_16_TO_8) && (info_ptr->bit_depth == 16))
-      info_ptr->bit_depth = 8;
-#else
-   /* Force chopping 16-bit input down to 8 */
    if (info_ptr->bit_depth == 16)
    {
-      png_ptr->transformations |=PNG_16_TO_8;
-      info_ptr->bit_depth = 8;
+#  ifdef PNG_READ_16BIT_SUPPORTED
+#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+         if (png_ptr->transformations & PNG_SCALE_16_TO_8)
+            info_ptr->bit_depth = 8;
+#     endif
+
+#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+         if (png_ptr->transformations & PNG_16_TO_8)
+            info_ptr->bit_depth = 8;
+#     endif
+
+#  else
+      /* No 16 bit support: force chopping 16-bit input down to 8, in this case
+       * the app program can chose if both APIs are available by setting the
+       * correct scaling to use.
+       */
+#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+         /* For compatibility with previous versions use the strip method by
+          * default.  This code works because if PNG_SCALE_16_TO_8 is already
+          * set the code below will do that in preference to the chop.
+          */
+         png_ptr->transformations |= PNG_16_TO_8;
+         info_ptr->bit_depth = 8;
+#     else
+
+#        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+            png_ptr->transformations |= PNG_SCALE_16_TO_8;
+            info_ptr->bit_depth = 8;
+#        else
+
+            CONFIGURATION ERROR: you must enable at least one 16 to 8 method
+#        endif
+#    endif
+#endif /* !READ_16BIT_SUPPORTED */
    }
-#endif
-#endif
 
 #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
    if (png_ptr->transformations & PNG_GRAY_TO_RGB)
-      info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
+      info_ptr->color_type = (png_byte)(info_ptr->color_type |
+         PNG_COLOR_MASK_COLOR);
 #endif
 
 #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
    if (png_ptr->transformations & PNG_RGB_TO_GRAY)
-      info_ptr->color_type &= ~PNG_COLOR_MASK_COLOR;
+      info_ptr->color_type = (png_byte)(info_ptr->color_type &
+         ~PNG_COLOR_MASK_COLOR);
 #endif
 
 #ifdef PNG_READ_QUANTIZE_SUPPORTED
@@ -1338,6 +1994,14 @@ png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
    }
 #endif
 
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+   if (png_ptr->transformations & PNG_EXPAND_16 && info_ptr->bit_depth == 8 &&
+      info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
+   {
+      info_ptr->bit_depth = 16;
+   }
+#endif
+
 #ifdef PNG_READ_PACK_SUPPORTED
    if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))
       info_ptr->bit_depth = 8;
@@ -1353,8 +2017,12 @@ png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
       info_ptr->channels = 1;
 
 #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)
-      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
+   if (png_ptr->transformations & PNG_STRIP_ALPHA)
+   {
+      info_ptr->color_type = (png_byte)(info_ptr->color_type &
+         ~PNG_COLOR_MASK_ALPHA);
+      info_ptr->num_trans = 0;
+   }
 #endif
 
    if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
@@ -1390,6 +2058,14 @@ defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
 
    info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);
 
+   /* Adding in 1.5.4: cache the above value in png_struct so that we can later
+    * check in png_rowbytes that the user buffer won't get overwritten.  Note
+    * that the field is not always set - if png_read_update_info isn't called
+    * the application has to either not do any transforms or get the calculation
+    * right itself.
+    */
+   png_ptr->info_rowbytes = info_ptr->rowbytes;
+
 #ifndef PNG_READ_EXPAND_SUPPORTED
    if (png_ptr)
       return;
@@ -1401,69 +2077,71 @@ defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
  * decide how it fits in with the other transformations here.
  */
 void /* PRIVATE */
-png_do_read_transformations(png_structp png_ptr)
+png_do_read_transformations(png_structp png_ptr, png_row_infop row_info)
 {
    png_debug(1, "in png_do_read_transformations");
 
    if (png_ptr->row_buf == NULL)
    {
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-      char msg[50];
-
-      png_snprintf2(msg, 50,
-          "NULL row buffer for row %ld, pass %d", (long)png_ptr->row_number,
-          png_ptr->pass);
-      png_error(png_ptr, msg);
-#else
+      /* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this
+       * error is incredibly rare and incredibly easy to debug without this
+       * information.
+       */
       png_error(png_ptr, "NULL row buffer");
-#endif
    }
-#ifdef PNG_WARN_UNINITIALIZED_ROW
-   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
-      /* Application has failed to call either png_read_start_image()
-       * or png_read_update_info() after setting transforms that expand
-       * pixels.  This check added to libpng-1.2.19
+
+   /* The following is debugging; prior to 1.5.4 the code was never compiled in;
+    * in 1.5.4 PNG_FLAG_DETECT_UNINITIALIZED was added and the macro
+    * PNG_WARN_UNINITIALIZED_ROW removed.  In 1.5 the new flag is set only for
+    * selected new APIs to ensure that there is no API change.
+    */
+   if ((png_ptr->flags & PNG_FLAG_DETECT_UNINITIALIZED) != 0 &&
+      !(png_ptr->flags & PNG_FLAG_ROW_INIT))
+   {
+      /* Application has failed to call either png_read_start_image() or
+       * png_read_update_info() after setting transforms that expand pixels.
+       * This check added to libpng-1.2.19 (but not enabled until 1.5.4).
        */
-#if (PNG_WARN_UNINITIALIZED_ROW==1)
       png_error(png_ptr, "Uninitialized row");
-#else
-      png_warning(png_ptr, "Uninitialized row");
-#endif
-#endif
+   }
 
 #ifdef PNG_READ_EXPAND_SUPPORTED
    if (png_ptr->transformations & PNG_EXPAND)
    {
-      if (png_ptr->row_info.color_type == PNG_COLOR_TYPE_PALETTE)
+      if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
       {
-         png_do_expand_palette(&(png_ptr->row_info), png_ptr->row_buf + 1,
+         png_do_expand_palette(row_info, png_ptr->row_buf + 1,
              png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);
       }
+
       else
       {
          if (png_ptr->num_trans &&
              (png_ptr->transformations & PNG_EXPAND_tRNS))
-            png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
+            png_do_expand(row_info, png_ptr->row_buf + 1,
                 &(png_ptr->trans_color));
-         else
 
-            png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
+         else
+            png_do_expand(row_info, png_ptr->row_buf + 1,
                 NULL);
       }
    }
 #endif
 
 #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)
-      png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
-          PNG_FLAG_FILLER_AFTER | (png_ptr->flags & PNG_FLAG_STRIP_ALPHA));
+   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
+      !(png_ptr->transformations & PNG_COMPOSE) &&
+      (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+      row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
+      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
+         0 /* at_start == false, because SWAP_ALPHA happens later */);
 #endif
 
 #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
    if (png_ptr->transformations & PNG_RGB_TO_GRAY)
    {
       int rgb_error =
-          png_do_rgb_to_gray(png_ptr, &(png_ptr->row_info),
+          png_do_rgb_to_gray(png_ptr, row_info,
               png_ptr->row_buf + 1);
 
       if (rgb_error)
@@ -1517,107 +2195,146 @@ png_do_read_transformations(png_structp png_ptr)
     */
    if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
        !(png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
-      png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
 #endif
 
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   if ((png_ptr->transformations & PNG_BACKGROUND) &&
-       ((png_ptr->num_trans != 0) ||
-       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA)))
-      png_do_background(&(png_ptr->row_info), png_ptr->row_buf + 1,
-          &(png_ptr->trans_color), &(png_ptr->background)
-#ifdef PNG_READ_GAMMA_SUPPORTED
-          , &(png_ptr->background_1),
-          png_ptr->gamma_table, png_ptr->gamma_from_1,
-          png_ptr->gamma_to_1, png_ptr->gamma_16_table,
-          png_ptr->gamma_16_from_1, png_ptr->gamma_16_to_1,
-          png_ptr->gamma_shift
-#endif
-          );
+#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
+   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
+   if (png_ptr->transformations & PNG_COMPOSE)
+      png_do_compose(row_info, png_ptr->row_buf + 1, png_ptr);
 #endif
 
 #ifdef PNG_READ_GAMMA_SUPPORTED
    if ((png_ptr->transformations & PNG_GAMMA) &&
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-       !((png_ptr->transformations & PNG_BACKGROUND) &&
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+      /* Because RGB_TO_GRAY does the gamma transform. */
+      !(png_ptr->transformations & PNG_RGB_TO_GRAY) &&
+#endif
+#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
+   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
+      /* Because PNG_COMPOSE does the gamma transform if there is something to
+       * do (if there is an alpha channel or transparency.)
+       */
+       !((png_ptr->transformations & PNG_COMPOSE) &&
        ((png_ptr->num_trans != 0) ||
        (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
 #endif
+      /* Because png_init_read_transformations transforms the palette, unless
+       * RGB_TO_GRAY will do the transform.
+       */
        (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
-      png_do_gamma(&(png_ptr->row_info), png_ptr->row_buf + 1,
-          png_ptr->gamma_table, png_ptr->gamma_16_table,
-          png_ptr->gamma_shift);
+      png_do_gamma(row_info, png_ptr->row_buf + 1, png_ptr);
 #endif
 
-#ifdef PNG_READ_16_TO_8_SUPPORTED
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
+   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
+      (png_ptr->transformations & PNG_COMPOSE) &&
+      (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+      row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
+      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
+         0 /* at_start == false, because SWAP_ALPHA happens later */);
+#endif
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+   if ((png_ptr->transformations & PNG_ENCODE_ALPHA) &&
+      (row_info->color_type & PNG_COLOR_MASK_ALPHA))
+      png_do_encode_alpha(row_info, png_ptr->row_buf + 1, png_ptr);
+#endif
+
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+   if (png_ptr->transformations & PNG_SCALE_16_TO_8)
+      png_do_scale_16_to_8(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+   /* There is no harm in doing both of these because only one has any effect,
+    * by putting the 'scale' option first if the app asks for scale (either by
+    * calling the API or in a TRANSFORM flag) this is what happens.
+    */
    if (png_ptr->transformations & PNG_16_TO_8)
-      png_do_chop(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_chop(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_READ_QUANTIZE_SUPPORTED
    if (png_ptr->transformations & PNG_QUANTIZE)
    {
-      png_do_quantize(&(png_ptr->row_info), png_ptr->row_buf + 1,
+      png_do_quantize(row_info, png_ptr->row_buf + 1,
           png_ptr->palette_lookup, png_ptr->quantize_index);
 
-      if (png_ptr->row_info.rowbytes == 0)
+      if (row_info->rowbytes == 0)
          png_error(png_ptr, "png_do_quantize returned rowbytes=0");
    }
 #endif /* PNG_READ_QUANTIZE_SUPPORTED */
 
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+   /* Do the expansion now, after all the arithmetic has been done.  Notice
+    * that previous transformations can handle the PNG_EXPAND_16 flag if this
+    * is efficient (particularly true in the case of gamma correction, where
+    * better accuracy results faster!)
+    */
+   if (png_ptr->transformations & PNG_EXPAND_16)
+      png_do_expand_16(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+   /*NOTE: moved here in 1.5.4 (from much later in this list.) */
+   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
+       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
+      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
+#endif
+
 #ifdef PNG_READ_INVERT_SUPPORTED
    if (png_ptr->transformations & PNG_INVERT_MONO)
-      png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_invert(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_READ_SHIFT_SUPPORTED
    if (png_ptr->transformations & PNG_SHIFT)
-      png_do_unshift(&(png_ptr->row_info), png_ptr->row_buf + 1,
+      png_do_unshift(row_info, png_ptr->row_buf + 1,
           &(png_ptr->shift));
 #endif
 
 #ifdef PNG_READ_PACK_SUPPORTED
    if (png_ptr->transformations & PNG_PACK)
-      png_do_unpack(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_unpack(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   /* Added at libpng-1.5.10 */
+   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
+      png_do_check_palette_indexes(png_ptr, row_info);
 #endif
 
 #ifdef PNG_READ_BGR_SUPPORTED
    if (png_ptr->transformations & PNG_BGR)
-      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_bgr(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_READ_PACKSWAP_SUPPORTED
    if (png_ptr->transformations & PNG_PACKSWAP)
-      png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /* If gray -> RGB, do so now only if we did not do so above */
-   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
-       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
-      png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_packswap(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_READ_FILLER_SUPPORTED
    if (png_ptr->transformations & PNG_FILLER)
-      png_do_read_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
+      png_do_read_filler(row_info, png_ptr->row_buf + 1,
           (png_uint_32)png_ptr->filler, png_ptr->flags);
 #endif
 
 #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
    if (png_ptr->transformations & PNG_INVERT_ALPHA)
-      png_do_read_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_read_invert_alpha(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
    if (png_ptr->transformations & PNG_SWAP_ALPHA)
-      png_do_read_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_read_swap_alpha(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_READ_16BIT_SUPPORTED
 #ifdef PNG_READ_SWAP_SUPPORTED
    if (png_ptr->transformations & PNG_SWAP_BYTES)
-      png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_swap(row_info, png_ptr->row_buf + 1);
 #endif
 #endif
 
@@ -1626,8 +2343,8 @@ png_do_read_transformations(png_structp png_ptr)
     {
       if (png_ptr->read_user_transform_fn != NULL)
          (*(png_ptr->read_user_transform_fn)) /* User read transform function */
-             (png_ptr,                    /* png_ptr */
-             &(png_ptr->row_info),     /* row_info: */
+             (png_ptr,     /* png_ptr */
+             row_info,     /* row_info: */
                 /*  png_uint_32 width;       width of row */
                 /*  png_size_t rowbytes;     number of bytes in row */
                 /*  png_byte color_type;     color type of pixels */
@@ -1637,19 +2354,17 @@ png_do_read_transformations(png_structp png_ptr)
              png_ptr->row_buf + 1);    /* start of pixel data for row */
 #ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
       if (png_ptr->user_transform_depth)
-         png_ptr->row_info.bit_depth = png_ptr->user_transform_depth;
+         row_info->bit_depth = png_ptr->user_transform_depth;
 
       if (png_ptr->user_transform_channels)
-         png_ptr->row_info.channels = png_ptr->user_transform_channels;
+         row_info->channels = png_ptr->user_transform_channels;
 #endif
-      png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
-          png_ptr->row_info.channels);
+      row_info->pixel_depth = (png_byte)(row_info->bit_depth *
+          row_info->channels);
 
-      png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
-          png_ptr->row_info.width);
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_info->width);
    }
 #endif
-
 }
 
 #ifdef PNG_READ_PACK_SUPPORTED
@@ -1761,105 +2476,128 @@ void /* PRIVATE */
 png_do_unshift(png_row_infop row_info, png_bytep row,
     png_const_color_8p sig_bits)
 {
+   int color_type;
+
    png_debug(1, "in png_do_unshift");
 
-   if (
-       row_info->color_type != PNG_COLOR_TYPE_PALETTE)
+   /* The palette case has already been handled in the _init routine. */
+   color_type = row_info->color_type;
+
+   if (color_type != PNG_COLOR_TYPE_PALETTE)
    {
       int shift[4];
       int channels = 0;
-      int c;
-      png_uint_16 value = 0;
-      png_uint_32 row_width = row_info->width;
+      int bit_depth = row_info->bit_depth;
 
-      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
+      if (color_type & PNG_COLOR_MASK_COLOR)
       {
-         shift[channels++] = row_info->bit_depth - sig_bits->red;
-         shift[channels++] = row_info->bit_depth - sig_bits->green;
-         shift[channels++] = row_info->bit_depth - sig_bits->blue;
+         shift[channels++] = bit_depth - sig_bits->red;
+         shift[channels++] = bit_depth - sig_bits->green;
+         shift[channels++] = bit_depth - sig_bits->blue;
       }
 
       else
       {
-         shift[channels++] = row_info->bit_depth - sig_bits->gray;
+         shift[channels++] = bit_depth - sig_bits->gray;
       }
 
-      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
+      if (color_type & PNG_COLOR_MASK_ALPHA)
       {
-         shift[channels++] = row_info->bit_depth - sig_bits->alpha;
+         shift[channels++] = bit_depth - sig_bits->alpha;
       }
 
-      for (c = 0; c < channels; c++)
       {
-         if (shift[c] <= 0)
-            shift[c] = 0;
+         int c, have_shift;
 
-         else
-            value = 1;
-      }
+         for (c = have_shift = 0; c < channels; ++c)
+         {
+            /* A shift of more than the bit depth is an error condition but it
+             * gets ignored here.
+             */
+            if (shift[c] <= 0 || shift[c] >= bit_depth)
+               shift[c] = 0;
 
-      if (!value)
-         return;
+            else
+               have_shift = 1;
+         }
 
-      switch (row_info->bit_depth)
+         if (!have_shift)
+            return;
+      }
+
+      switch (bit_depth)
       {
          default:
-            break; 
+         /* Must be 1bpp gray: should not be here! */
+            /* NOTREACHED */
+            break;
 
          case 2:
+         /* Must be 2bpp gray */
+         /* assert(channels == 1 && shift[0] == 1) */
          {
-            png_bytep bp;
-            png_size_t i;
-            png_size_t istop = row_info->rowbytes;
+            png_bytep bp = row;
+            png_bytep bp_end = bp + row_info->rowbytes;
 
-            for (bp = row, i = 0; i < istop; i++)
+            while (bp < bp_end)
             {
-               *bp >>= 1;
-               *bp++ &= 0x55;
+               int b = (*bp >> 1) & 0x55;
+               *bp++ = (png_byte)b;
             }
             break;
          }
 
          case 4:
+         /* Must be 4bpp gray */
+         /* assert(channels == 1) */
          {
             png_bytep bp = row;
-            png_size_t i;
-            png_size_t istop = row_info->rowbytes;
-            png_byte mask = (png_byte)((((int)0xf0 >> shift[0]) & (int)0xf0) |
-                (png_byte)((int)0xf >> shift[0]));
+            png_bytep bp_end = bp + row_info->rowbytes;
+            int gray_shift = shift[0];
+            int mask =  0xf >> gray_shift;
 
-            for (i = 0; i < istop; i++)
+            mask |= mask << 4;
+
+            while (bp < bp_end)
             {
-               *bp >>= shift[0];
-               *bp++ &= mask;
+               int b = (*bp >> gray_shift) & mask;
+               *bp++ = (png_byte)b;
             }
             break;
          }
 
          case 8:
+         /* Single byte components, G, GA, RGB, RGBA */
          {
             png_bytep bp = row;
-            png_uint_32 i;
-            png_uint_32 istop = row_width * channels;
+            png_bytep bp_end = bp + row_info->rowbytes;
+            int channel = 0;
 
-            for (i = 0; i < istop; i++)
+            while (bp < bp_end)
             {
-               *bp++ >>= shift[i%channels];
+               int b = *bp >> shift[channel];
+               if (++channel >= channels)
+                  channel = 0;
+               *bp++ = (png_byte)b;
             }
             break;
          }
 
 #ifdef PNG_READ_16BIT_SUPPORTED
          case 16:
+         /* Double byte components, G, GA, RGB, RGBA */
          {
             png_bytep bp = row;
-            png_uint_32 i;
-            png_uint_32 istop = channels * row_width;
+            png_bytep bp_end = bp + row_info->rowbytes;
+            int channel = 0;
 
-            for (i = 0; i < istop; i++)
+            while (bp < bp_end)
             {
-               value = (png_uint_16)((*bp << 8) + *(bp + 1));
-               value >>= shift[i%channels];
+               int value = (bp[0] << 8) + bp[1];
+
+               value >>= shift[channel];
+               if (++channel >= channels)
+                  channel = 0;
                *bp++ = (png_byte)(value >> 8);
                *bp++ = (png_byte)(value & 0xff);
             }
@@ -1871,54 +2609,86 @@ png_do_unshift(png_row_infop row_info, png_bytep row,
 }
 #endif
 
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-/* Chop rows of bit depth 16 down to 8 */
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+/* Scale rows of bit depth 16 down to 8 accurately */
+void /* PRIVATE */
+png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_scale_16_to_8");
+
+   if (row_info->bit_depth == 16)
+   {
+      png_bytep sp = row; /* source */
+      png_bytep dp = row; /* destination */
+      png_bytep ep = sp + row_info->rowbytes; /* end+1 */
+
+      while (sp < ep)
+      {
+         /* The input is an array of 16 bit components, these must be scaled to
+          * 8 bits each.  For a 16 bit value V the required value (from the PNG
+          * specification) is:
+          *
+          *    (V * 255) / 65535
+          *
+          * This reduces to round(V / 257), or floor((V + 128.5)/257)
+          *
+          * Represent V as the two byte value vhi.vlo.  Make a guess that the
+          * result is the top byte of V, vhi, then the correction to this value
+          * is:
+          *
+          *    error = floor(((V-vhi.vhi) + 128.5) / 257)
+          *          = floor(((vlo-vhi) + 128.5) / 257)
+          *
+          * This can be approximated using integer arithmetic (and a signed
+          * shift):
+          *
+          *    error = (vlo-vhi+128) >> 8;
+          *
+          * The approximate differs from the exact answer only when (vlo-vhi) is
+          * 128; it then gives a correction of +1 when the exact correction is
+          * 0.  This gives 128 errors.  The exact answer (correct for all 16 bit
+          * input values) is:
+          *
+          *    error = (vlo-vhi+128)*65535 >> 24;
+          *
+          * An alternative arithmetic calculation which also gives no errors is:
+          *
+          *    (V * 255 + 32895) >> 16
+          */
+
+         png_int_32 tmp = *sp++; /* must be signed! */
+         tmp += (((int)*sp++ - tmp + 128) * 65535) >> 24;
+         *dp++ = (png_byte)tmp;
+      }
+
+      row_info->bit_depth = 8;
+      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
+      row_info->rowbytes = row_info->width * row_info->channels;
+   }
+}
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
 void /* PRIVATE */
+/* Simply discard the low byte.  This was the default behavior prior
+ * to libpng-1.5.4.
+ */
 png_do_chop(png_row_infop row_info, png_bytep row)
 {
    png_debug(1, "in png_do_chop");
 
    if (row_info->bit_depth == 16)
    {
-      png_bytep sp = row;
-      png_bytep dp = row;
-      png_uint_32 i;
-      png_uint_32 istop = row_info->width * row_info->channels;
+      png_bytep sp = row; /* source */
+      png_bytep dp = row; /* destination */
+      png_bytep ep = sp + row_info->rowbytes; /* end+1 */
 
-      for (i = 0; i<istop; i++, sp += 2, dp++)
+      while (sp < ep)
       {
-#ifdef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
-      /* This does a more accurate scaling of the 16-bit color
-       * value, rather than a simple low-byte truncation.
-       *
-       * What the ideal calculation should be:
-       *   *dp = (((((png_uint_32)(*sp) << 8) |
-       *          (png_uint_32)(*(sp + 1))) * 255 + 127)
-       *          / (png_uint_32)65535L;
-       *
-       * GRR: no, I think this is what it really should be:
-       *   *dp = (((((png_uint_32)(*sp) << 8) |
-       *           (png_uint_32)(*(sp + 1))) + 128L)
-       *           / (png_uint_32)257L;
-       *
-       * GRR: here's the exact calculation with shifts:
-       *   temp = (((png_uint_32)(*sp) << 8) |
-       *           (png_uint_32)(*(sp + 1))) + 128L;
-       *   *dp = (temp - (temp >> 8)) >> 8;
-       *
-       * Approximate calculation with shift/add instead of multiply/divide:
-       *   *dp = ((((png_uint_32)(*sp) << 8) |
-       *          (png_uint_32)((int)(*(sp + 1)) - *sp)) + 128) >> 8;
-       *
-       * What we actually do to avoid extra shifting and conversion:
-       */
-
-         *dp = *sp + ((((int)(*(sp + 1)) - *sp) > 128) ? 1 : 0);
-#else
-       /* Simply discard the low order byte */
-         *dp = *sp;
-#endif
+         *dp++ = *sp;
+         sp += 2; /* skip low byte */
       }
+
       row_info->bit_depth = 8;
       row_info->pixel_depth = (png_byte)(8 * row_info->channels);
       row_info->rowbytes = row_info->width * row_info->channels;
@@ -2390,7 +3160,7 @@ png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
             }
          }
       }
-      row_info->channels += (png_byte)2;
+      row_info->channels = (png_byte)(row_info->channels + 2);
       row_info->color_type |= PNG_COLOR_MASK_COLOR;
       row_info->pixel_depth = (png_byte)(row_info->channels *
           row_info->bit_depth);
@@ -2401,33 +3171,61 @@ png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
 
 #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 /* Reduce RGB files to grayscale, with or without alpha
- * using the equation given in Poynton's ColorFAQ at
- * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008)
- * New link:
- * <http://www.poynton.com/notes/colour_and_gamma/>
+ * using the equation given in Poynton's ColorFAQ of 1998-01-04 at
+ * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but
+ * versions dated 1998 through November 2002 have been archived at
+ * http://web.archive.org/web/20000816232553/http://www.inforamp.net/
+ * ~poynton/notes/colour_and_gamma/ColorFAQ.txt )
  * Charles Poynton poynton at poynton.com
  *
  *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
  *
- *  We approximate this with
+ *  which can be expressed with integers as
+ *
+ *     Y = (6969 * R + 23434 * G + 2365 * B)/32768
+ *
+ * Poynton's current link (as of January 2003 through July 2011):
+ * <http://www.poynton.com/notes/colour_and_gamma/>
+ * has changed the numbers slightly:
  *
- *     Y = 0.21268 * R    + 0.7151 * G    + 0.07217 * B
+ *     Y = 0.2126*R + 0.7152*G + 0.0722*B
  *
  *  which can be expressed with integers as
  *
- *     Y = (6969 * R + 23434 * G + 2365 * B)/32768
+ *     Y = (6966 * R + 23436 * G + 2366 * B)/32768
+ *
+ *  Historically, however, libpng uses numbers derived from the ITU-R Rec 709
+ *  end point chromaticities and the D65 white point.  Depending on the
+ *  precision used for the D65 white point this produces a variety of different
+ *  numbers, however if the four decimal place value used in ITU-R Rec 709 is
+ *  used (0.3127,0.3290) the Y calculation would be:
+ *
+ *     Y = (6968 * R + 23435 * G + 2366 * B)/32768
  *
- *  The calculation is to be done in a linear colorspace.
+ *  While this is correct the rounding results in an overflow for white, because
+ *  the sum of the rounded coefficients is 32769, not 32768.  Consequently
+ *  libpng uses, instead, the closest non-overflowing approximation:
  *
- *  Other integer coefficents can be used via png_set_rgb_to_gray().
+ *     Y = (6968 * R + 23434 * G + 2366 * B)/32768
+ *
+ *  Starting with libpng-1.5.5, if the image being converted has a cHRM chunk
+ *  (including an sRGB chunk) then the chromaticities are used to calculate the
+ *  coefficients.  See the chunk handling in pngrutil.c for more information.
+ *
+ *  In all cases the calculation is to be done in a linear colorspace.  If no
+ *  gamma information is available to correct the encoding of the original RGB
+ *  values this results in an implicit assumption that the original PNG RGB
+ *  values were linear.
+ *
+ *  Other integer coefficents can be used via png_set_rgb_to_gray().  Because
+ *  the API takes just red and green coefficients the blue coefficient is
+ *  calculated to make the sum 32768.  This will result in different rounding
+ *  to that used above.
  */
 int /* PRIVATE */
 png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)
 
 {
-   png_uint_32 i;
-
-   png_uint_32 row_width = row_info->width;
    int rgb_error = 0;
 
    png_debug(1, "in png_do_rgb_to_gray");
@@ -2435,235 +3233,180 @@ png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)
    if (!(row_info->color_type & PNG_COLOR_MASK_PALETTE) &&
        (row_info->color_type & PNG_COLOR_MASK_COLOR))
    {
-      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
-      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
-      png_uint_32 bc = png_ptr->rgb_to_gray_blue_coeff;
+      PNG_CONST png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
+      PNG_CONST png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
+      PNG_CONST png_uint_32 bc = 32768 - rc - gc;
+      PNG_CONST png_uint_32 row_width = row_info->width;
+      PNG_CONST int have_alpha =
+         (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;
 
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB)
+      if (row_info->bit_depth == 8)
       {
-         if (row_info->bit_depth == 8)
-         {
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
+         /* Notice that gamma to/from 1 are not necessarily inverses (if
+          * there is an overall gamma correction).  Prior to 1.5.5 this code
+          * checked the linearized values for equality; this doesn't match
+          * the documentation, the original values must be checked.
+          */
+         if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
+         {
+            png_bytep sp = row;
+            png_bytep dp = row;
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
             {
-               png_bytep sp = row;
-               png_bytep dp = row;
+               png_byte red   = *(sp++);
+               png_byte green = *(sp++);
+               png_byte blue  = *(sp++);
 
-               for (i = 0; i < row_width; i++)
+               if (red != green || red != blue)
                {
-                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];
-                  png_byte green = png_ptr->gamma_to_1[*(sp++)];
-                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
-
-                  if (red != green || red != blue)
-                  {
-                     rgb_error |= 1;
-                     *(dp++) = png_ptr->gamma_from_1[
-                         (rc*red + gc*green + bc*blue)>>15];
-                  }
+                  red = png_ptr->gamma_to_1[red];
+                  green = png_ptr->gamma_to_1[green];
+                  blue = png_ptr->gamma_to_1[blue];
 
-                  else
-                     *(dp++) = *(sp - 1);
+                  rgb_error |= 1;
+                  *(dp++) = png_ptr->gamma_from_1[
+                      (rc*red + gc*green + bc*blue + 16384)>>15];
                }
-            }
-            else
-#endif
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_byte red   = *(sp++);
-                  png_byte green = *(sp++);
-                  png_byte blue  = *(sp++);
 
-                  if (red != green || red != blue)
-                  {
-                     rgb_error |= 1;
-                     *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
-                  }
+               else
+               {
+                  /* If there is no overall correction the table will not be
+                   * set.
+                   */
+                  if (png_ptr->gamma_table != NULL)
+                     red = png_ptr->gamma_table[red];
 
-                  else
-                     *(dp++) = *(sp - 1);
+                  *(dp++) = red;
                }
+
+               if (have_alpha)
+                  *(dp++) = *(sp++);
             }
          }
-
-         else /* RGB bit_depth == 16 */
+         else
+#endif
          {
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-            if (png_ptr->gamma_16_to_1 != NULL &&
-                png_ptr->gamma_16_from_1 != NULL)
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 red, green, blue, w;
-
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-
-                  if (red == green && red == blue)
-                     w = red;
-
-                  else
-                  {
-                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff)
-                         >> png_ptr->gamma_shift][red>>8];
-                     png_uint_16 green_1 =
-                         png_ptr->gamma_16_to_1[(green&0xff) >>
-                         png_ptr->gamma_shift][green>>8];
-                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff)
-                         >> png_ptr->gamma_shift][blue>>8];
-                     png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1
-                         + bc*blue_1)>>15);
-                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
-                         png_ptr->gamma_shift][gray16 >> 8];
-                     rgb_error |= 1;
-                  }
+            png_bytep sp = row;
+            png_bytep dp = row;
+            png_uint_32 i;
 
-                  *(dp++) = (png_byte)((w>>8) & 0xff);
-                  *(dp++) = (png_byte)(w & 0xff);
-               }
-            }
-            else
-#endif
+            for (i = 0; i < row_width; i++)
             {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 red, green, blue, gray16;
+               png_byte red   = *(sp++);
+               png_byte green = *(sp++);
+               png_byte blue  = *(sp++);
 
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               if (red != green || red != blue)
+               {
+                  rgb_error |= 1;
+                  /*NOTE: this is the historical approach which simply
+                   * truncates the results.
+                   */
+                  *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
+               }
 
-                  if (red != green || red != blue)
-                     rgb_error |= 1;
+               else
+                  *(dp++) = red;
 
-                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
-                  *(dp++) = (png_byte)((gray16>>8) & 0xff);
-                  *(dp++) = (png_byte)(gray16 & 0xff);
-               }
+               if (have_alpha)
+                  *(dp++) = *(sp++);
             }
          }
       }
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+
+      else /* RGB bit_depth == 16 */
       {
-         if (row_info->bit_depth == 8)
-         {
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
+         if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL)
+         {
+            png_bytep sp = row;
+            png_bytep dp = row;
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
             {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];
-                  png_byte green = png_ptr->gamma_to_1[*(sp++)];
-                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
+               png_uint_16 red, green, blue, w;
 
-                  if (red != green || red != blue)
-                     rgb_error |= 1;
+               red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+
+               if (red == green && red == blue)
+               {
+                  if (png_ptr->gamma_16_table != NULL)
+                     w = png_ptr->gamma_16_table[(red&0xff)
+                         >> png_ptr->gamma_shift][red>>8];
 
-                  *(dp++) =  png_ptr->gamma_from_1
-                      [(rc*red + gc*green + bc*blue)>>15];
+                  else
+                     w = red;
+               }
 
-                  *(dp++) = *(sp++);  /* alpha */
+               else
+               {
+                  png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff)
+                      >> png_ptr->gamma_shift][red>>8];
+                  png_uint_16 green_1 =
+                      png_ptr->gamma_16_to_1[(green&0xff) >>
+                      png_ptr->gamma_shift][green>>8];
+                  png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff)
+                      >> png_ptr->gamma_shift][blue>>8];
+                  png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1
+                      + bc*blue_1 + 16384)>>15);
+                  w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
+                      png_ptr->gamma_shift][gray16 >> 8];
+                  rgb_error |= 1;
                }
-            }
-            else
-#endif
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
+
+               *(dp++) = (png_byte)((w>>8) & 0xff);
+               *(dp++) = (png_byte)(w & 0xff);
+
+               if (have_alpha)
                {
-                  png_byte red   = *(sp++);
-                  png_byte green = *(sp++);
-                  png_byte blue  = *(sp++);
-                  if (red != green || red != blue)
-                     rgb_error |= 1;
-
-                  *(dp++) =  (png_byte)((rc*red + gc*green + bc*blue)>>15);
-                  *(dp++) = *(sp++);  /* alpha */
+                  *(dp++) = *(sp++);
+                  *(dp++) = *(sp++);
                }
             }
          }
-         else /* RGBA bit_depth == 16 */
+         else
+#endif
          {
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-            if (png_ptr->gamma_16_to_1 != NULL &&
-                png_ptr->gamma_16_from_1 != NULL)
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 red, green, blue, w;
-
-                  red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-                  green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-
-                  if (red == green && red == blue)
-                     w = red;
-
-                  else
-                  {
-                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
-                         png_ptr->gamma_shift][red>>8];
-
-                     png_uint_16 green_1 =
-                         png_ptr->gamma_16_to_1[(green&0xff) >>
-                         png_ptr->gamma_shift][green>>8];
+            png_bytep sp = row;
+            png_bytep dp = row;
+            png_uint_32 i;
 
-                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
-                         png_ptr->gamma_shift][blue>>8];
+            for (i = 0; i < row_width; i++)
+            {
+               png_uint_16 red, green, blue, gray16;
 
-                     png_uint_16 gray16  = (png_uint_16)((rc * red_1
-                         + gc * green_1 + bc * blue_1)>>15);
+               red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
 
-                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
-                         png_ptr->gamma_shift][gray16 >> 8];
+               if (red != green || red != blue)
+                  rgb_error |= 1;
 
-                     rgb_error |= 1;
-                  }
+               /* From 1.5.5 in the 16 bit case do the accurate conversion even
+                * in the 'fast' case - this is because this is where the code
+                * ends up when handling linear 16 bit data.
+                */
+               gray16  = (png_uint_16)((rc*red + gc*green + bc*blue + 16384) >>
+                  15);
+               *(dp++) = (png_byte)((gray16>>8) & 0xff);
+               *(dp++) = (png_byte)(gray16 & 0xff);
 
-                  *(dp++) = (png_byte)((w>>8) & 0xff);
-                  *(dp++) = (png_byte)(w & 0xff);
-                  *(dp++) = *(sp++);  /* alpha */
-                  *(dp++) = *(sp++);
-               }
-            }
-            else
-#endif
-            {
-               png_bytep sp = row;
-               png_bytep dp = row;
-               for (i = 0; i < row_width; i++)
+               if (have_alpha)
                {
-                  png_uint_16 red, green, blue, gray16;
-                  red   = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;
-                  green = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;
-                  blue  = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2;
-
-                  if (red != green || red != blue)
-                     rgb_error |= 1;
-
-                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
-                  *(dp++) = (png_byte)((gray16>>8) & 0xff);
-                  *(dp++) = (png_byte)(gray16 & 0xff);
-                  *(dp++) = *(sp++);  /* alpha */
+                  *(dp++) = *(sp++);
                   *(dp++) = *(sp++);
                }
             }
          }
       }
-      row_info->channels -= 2;
+
+      row_info->channels = (png_byte)(row_info->channels - 2);
       row_info->color_type = (png_byte)(row_info->color_type &
           ~PNG_COLOR_MASK_COLOR);
       row_info->pixel_depth = (png_byte)(row_info->channels *
@@ -2673,11 +3416,13 @@ png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)
    return rgb_error;
 }
 #endif
+#endif /* PNG_READ_TRANSFORMS_SUPPORTED */
 
+#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
 /* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
  * large of png_color.  This lets grayscale images be treated as
  * paletted.  Most useful for gamma correction and simplification
- * of code.
+ * of code.  This API is not used internally.
  */
 void PNGAPI
 png_build_grayscale_palette(int bit_depth, png_colorp palette)
@@ -2727,34 +3472,37 @@ png_build_grayscale_palette(int bit_depth, png_colorp palette)
       palette[i].blue = (png_byte)v;
    }
 }
+#endif
 
 
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
+#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
+   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
 /* Replace any alpha or transparency with the supplied background color.
  * "background" is already in the screen gamma, while "background_1" is
  * at a gamma of 1.0.  Paletted files have already been taken care of.
  */
 void /* PRIVATE */
-png_do_background(png_row_infop row_info, png_bytep row,
-    png_const_color_16p trans_color, png_const_color_16p background
+png_do_compose(png_row_infop row_info, png_bytep row, png_structp png_ptr)
+{
 #ifdef PNG_READ_GAMMA_SUPPORTED
-    , png_const_color_16p background_1, png_const_bytep gamma_table,
-    png_const_bytep gamma_from_1, png_const_bytep gamma_to_1,
-    png_const_uint_16pp gamma_16, png_const_uint_16pp gamma_16_from_1,
-    png_const_uint_16pp gamma_16_to_1, int gamma_shift
+   png_const_bytep gamma_table = png_ptr->gamma_table;
+   png_const_bytep gamma_from_1 = png_ptr->gamma_from_1;
+   png_const_bytep gamma_to_1 = png_ptr->gamma_to_1;
+   png_const_uint_16pp gamma_16 = png_ptr->gamma_16_table;
+   png_const_uint_16pp gamma_16_from_1 = png_ptr->gamma_16_from_1;
+   png_const_uint_16pp gamma_16_to_1 = png_ptr->gamma_16_to_1;
+   int gamma_shift = png_ptr->gamma_shift;
 #endif
-    )
-{
-   png_bytep sp, dp;
+
+   png_bytep sp;
    png_uint_32 i;
    png_uint_32 row_width = row_info->width;
+   int optimize = (png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0;
    int shift;
 
-   png_debug(1, "in png_do_background");
+   png_debug(1, "in png_do_compose");
 
-   if (background != NULL &&
-      (!(row_info->color_type & PNG_COLOR_MASK_ALPHA) ||
-      (row_info->color_type != PNG_COLOR_TYPE_PALETTE && trans_color)))
    {
       switch (row_info->color_type)
       {
@@ -2769,10 +3517,10 @@ png_do_background(png_row_infop row_info, png_bytep row,
                   for (i = 0; i < row_width; i++)
                   {
                      if ((png_uint_16)((*sp >> shift) & 0x01)
-                        == trans_color->gray)
+                        == png_ptr->trans_color.gray)
                      {
                         *sp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
-                        *sp |= (png_byte)(background->gray << shift);
+                        *sp |= (png_byte)(png_ptr->background.gray << shift);
                      }
 
                      if (!shift)
@@ -2797,10 +3545,10 @@ png_do_background(png_row_infop row_info, png_bytep row,
                      for (i = 0; i < row_width; i++)
                      {
                         if ((png_uint_16)((*sp >> shift) & 0x03)
-                            == trans_color->gray)
+                            == png_ptr->trans_color.gray)
                         {
                            *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                           *sp |= (png_byte)(background->gray << shift);
+                           *sp |= (png_byte)(png_ptr->background.gray << shift);
                         }
 
                         else
@@ -2831,10 +3579,10 @@ png_do_background(png_row_infop row_info, png_bytep row,
                      for (i = 0; i < row_width; i++)
                      {
                         if ((png_uint_16)((*sp >> shift) & 0x03)
-                            == trans_color->gray)
+                            == png_ptr->trans_color.gray)
                         {
                            *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                           *sp |= (png_byte)(background->gray << shift);
+                           *sp |= (png_byte)(png_ptr->background.gray << shift);
                         }
 
                         if (!shift)
@@ -2860,10 +3608,10 @@ png_do_background(png_row_infop row_info, png_bytep row,
                      for (i = 0; i < row_width; i++)
                      {
                         if ((png_uint_16)((*sp >> shift) & 0x0f)
-                            == trans_color->gray)
+                            == png_ptr->trans_color.gray)
                         {
                            *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                           *sp |= (png_byte)(background->gray << shift);
+                           *sp |= (png_byte)(png_ptr->background.gray << shift);
                         }
 
                         else
@@ -2894,10 +3642,10 @@ png_do_background(png_row_infop row_info, png_bytep row,
                      for (i = 0; i < row_width; i++)
                      {
                         if ((png_uint_16)((*sp >> shift) & 0x0f)
-                            == trans_color->gray)
+                            == png_ptr->trans_color.gray)
                         {
                            *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                           *sp |= (png_byte)(background->gray << shift);
+                           *sp |= (png_byte)(png_ptr->background.gray << shift);
                         }
 
                         if (!shift)
@@ -2921,8 +3669,8 @@ png_do_background(png_row_infop row_info, png_bytep row,
                      sp = row;
                      for (i = 0; i < row_width; i++, sp++)
                      {
-                        if (*sp == trans_color->gray)
-                           *sp = (png_byte)background->gray;
+                        if (*sp == png_ptr->trans_color.gray)
+                           *sp = (png_byte)png_ptr->background.gray;
 
                         else
                            *sp = gamma_table[*sp];
@@ -2934,8 +3682,8 @@ png_do_background(png_row_infop row_info, png_bytep row,
                      sp = row;
                      for (i = 0; i < row_width; i++, sp++)
                      {
-                        if (*sp == trans_color->gray)
-                           *sp = (png_byte)background->gray;
+                        if (*sp == png_ptr->trans_color.gray)
+                           *sp = (png_byte)png_ptr->background.gray;
                      }
                   }
                   break;
@@ -2953,11 +3701,11 @@ png_do_background(png_row_infop row_info, png_bytep row,
 
                         v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
 
-                        if (v == trans_color->gray)
+                        if (v == png_ptr->trans_color.gray)
                         {
                            /* Background is already in screen gamma */
-                           *sp = (png_byte)((background->gray >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(background->gray & 0xff);
+                           *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
+                           *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
                         }
 
                         else
@@ -2978,10 +3726,10 @@ png_do_background(png_row_infop row_info, png_bytep row,
 
                         v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
 
-                        if (v == trans_color->gray)
+                        if (v == png_ptr->trans_color.gray)
                         {
-                           *sp = (png_byte)((background->gray >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(background->gray & 0xff);
+                           *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
+                           *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
                         }
                      }
                   }
@@ -3004,13 +3752,13 @@ png_do_background(png_row_infop row_info, png_bytep row,
                   sp = row;
                   for (i = 0; i < row_width; i++, sp += 3)
                   {
-                     if (*sp == trans_color->red &&
-                         *(sp + 1) == trans_color->green &&
-                         *(sp + 2) == trans_color->blue)
+                     if (*sp == png_ptr->trans_color.red &&
+                         *(sp + 1) == png_ptr->trans_color.green &&
+                         *(sp + 2) == png_ptr->trans_color.blue)
                      {
-                        *sp = (png_byte)background->red;
-                        *(sp + 1) = (png_byte)background->green;
-                        *(sp + 2) = (png_byte)background->blue;
+                        *sp = (png_byte)png_ptr->background.red;
+                        *(sp + 1) = (png_byte)png_ptr->background.green;
+                        *(sp + 2) = (png_byte)png_ptr->background.blue;
                      }
 
                      else
@@ -3027,13 +3775,13 @@ png_do_background(png_row_infop row_info, png_bytep row,
                   sp = row;
                   for (i = 0; i < row_width; i++, sp += 3)
                   {
-                     if (*sp == trans_color->red &&
-                         *(sp + 1) == trans_color->green &&
-                         *(sp + 2) == trans_color->blue)
+                     if (*sp == png_ptr->trans_color.red &&
+                         *(sp + 1) == png_ptr->trans_color.green &&
+                         *(sp + 2) == png_ptr->trans_color.blue)
                      {
-                        *sp = (png_byte)background->red;
-                        *(sp + 1) = (png_byte)background->green;
-                        *(sp + 2) = (png_byte)background->blue;
+                        *sp = (png_byte)png_ptr->background.red;
+                        *(sp + 1) = (png_byte)png_ptr->background.green;
+                        *(sp + 2) = (png_byte)png_ptr->background.blue;
                      }
                   }
                }
@@ -3054,16 +3802,17 @@ png_do_background(png_row_infop row_info, png_bytep row,
                      png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
                          + *(sp + 5));
 
-                     if (r == trans_color->red && g == trans_color->green &&
-                         b == trans_color->blue)
+                     if (r == png_ptr->trans_color.red &&
+                         g == png_ptr->trans_color.green &&
+                         b == png_ptr->trans_color.blue)
                      {
                         /* Background is already in screen gamma */
-                        *sp = (png_byte)((background->red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(background->red & 0xff);
-                        *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(background->green & 0xff);
-                        *(sp + 4) = (png_byte)((background->blue >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(background->blue & 0xff);
+                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
+                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
                      }
 
                      else
@@ -3097,15 +3846,16 @@ png_do_background(png_row_infop row_info, png_bytep row,
                      png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
                          + *(sp + 5));
 
-                     if (r == trans_color->red && g == trans_color->green &&
-                         b == trans_color->blue)
+                     if (r == png_ptr->trans_color.red &&
+                         g == png_ptr->trans_color.green &&
+                         b == png_ptr->trans_color.blue)
                      {
-                        *sp = (png_byte)((background->red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(background->red & 0xff);
-                        *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(background->green & 0xff);
-                        *(sp + 4) = (png_byte)((background->blue >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(background->blue & 0xff);
+                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
+                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
                      }
                   }
                }
@@ -3122,18 +3872,17 @@ png_do_background(png_row_infop row_info, png_bytep row,
                    gamma_table != NULL)
                {
                   sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 2, dp++)
+                  for (i = 0; i < row_width; i++, sp += 2)
                   {
                      png_uint_16 a = *(sp + 1);
 
                      if (a == 0xff)
-                        *dp = gamma_table[*sp];
+                        *sp = gamma_table[*sp];
 
                      else if (a == 0)
                      {
                         /* Background is already in screen gamma */
-                        *dp = (png_byte)background->gray;
+                        *sp = (png_byte)png_ptr->background.gray;
                      }
 
                      else
@@ -3141,8 +3890,10 @@ png_do_background(png_row_infop row_info, png_bytep row,
                         png_byte v, w;
 
                         v = gamma_to_1[*sp];
-                        png_composite(w, v, a, background_1->gray);
-                        *dp = gamma_from_1[w];
+                        png_composite(w, v, a, png_ptr->background_1.gray);
+                        if (!optimize)
+                           w = gamma_from_1[w];
+                        *sp = w;
                      }
                   }
                }
@@ -3150,24 +3901,15 @@ png_do_background(png_row_infop row_info, png_bytep row,
 #endif
                {
                   sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 2, dp++)
+                  for (i = 0; i < row_width; i++, sp += 2)
                   {
                      png_byte a = *(sp + 1);
 
-                     if (a == 0xff)
-                        *dp = *sp;
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                     else if (a == 0)
-                        *dp = (png_byte)background->gray;
-
-                     else
-                        png_composite(*dp, *sp, a, background_1->gray);
+                     if (a == 0)
+                        *sp = (png_byte)png_ptr->background.gray;
 
-#else
-                     *dp = (png_byte)background->gray;
-#endif
+                     else if (a < 0xff)
+                        png_composite(*sp, *sp, a, png_ptr->background_1.gray);
                   }
                }
             }
@@ -3178,8 +3920,7 @@ png_do_background(png_row_infop row_info, png_bytep row,
                    gamma_16_to_1 != NULL)
                {
                   sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 4, dp += 2)
+                  for (i = 0; i < row_width; i++, sp += 4)
                   {
                      png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
                          + *(sp + 3));
@@ -3189,69 +3930,56 @@ png_do_background(png_row_infop row_info, png_bytep row,
                         png_uint_16 v;
 
                         v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *dp = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(v & 0xff);
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
                      }
 
-#ifdef PNG_READ_GAMMA_SUPPORTED
                      else if (a == 0)
-#else
-                     else
-#endif
                      {
                         /* Background is already in screen gamma */
-                        *dp = (png_byte)((background->gray >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(background->gray & 0xff);
+                        *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
                      }
 
-#ifdef PNG_READ_GAMMA_SUPPORTED
                      else
                      {
                         png_uint_16 g, v, w;
 
                         g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
-                        png_composite_16(v, g, a, background_1->gray);
-                        w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];
-                        *dp = (png_byte)((w >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(w & 0xff);
+                        png_composite_16(v, g, a, png_ptr->background_1.gray);
+                        if (optimize)
+                           w = v;
+                        else
+                           w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];
+                        *sp = (png_byte)((w >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(w & 0xff);
                      }
-#endif
                   }
                }
                else
 #endif
                {
                   sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 4, dp += 2)
+                  for (i = 0; i < row_width; i++, sp += 4)
                   {
                      png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
                          + *(sp + 3));
 
-                     if (a == (png_uint_16)0xffff)
-                        png_memcpy(dp, sp, 2);
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                     else if (a == 0)
-#else
-                     else
-#endif
+                     if (a == 0)
                      {
-                        *dp = (png_byte)((background->gray >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(background->gray & 0xff);
+                        *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
                      }
 
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                     else
+                     else if (a < 0xffff)
                      {
                         png_uint_16 g, v;
 
                         g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        png_composite_16(v, g, a, background_1->gray);
-                        *dp = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(v & 0xff);
+                        png_composite_16(v, g, a, png_ptr->background_1.gray);
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
                      }
-#endif
                   }
                }
             }
@@ -3267,24 +3995,23 @@ png_do_background(png_row_infop row_info, png_bytep row,
                    gamma_table != NULL)
                {
                   sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 4, dp += 3)
+                  for (i = 0; i < row_width; i++, sp += 4)
                   {
                      png_byte a = *(sp + 3);
 
                      if (a == 0xff)
                      {
-                        *dp = gamma_table[*sp];
-                        *(dp + 1) = gamma_table[*(sp + 1)];
-                        *(dp + 2) = gamma_table[*(sp + 2)];
+                        *sp = gamma_table[*sp];
+                        *(sp + 1) = gamma_table[*(sp + 1)];
+                        *(sp + 2) = gamma_table[*(sp + 2)];
                      }
 
                      else if (a == 0)
                      {
                         /* Background is already in screen gamma */
-                        *dp = (png_byte)background->red;
-                        *(dp + 1) = (png_byte)background->green;
-                        *(dp + 2) = (png_byte)background->blue;
+                        *sp = (png_byte)png_ptr->background.red;
+                        *(sp + 1) = (png_byte)png_ptr->background.green;
+                        *(sp + 2) = (png_byte)png_ptr->background.blue;
                      }
 
                      else
@@ -3292,16 +4019,19 @@ png_do_background(png_row_infop row_info, png_bytep row,
                         png_byte v, w;
 
                         v = gamma_to_1[*sp];
-                        png_composite(w, v, a, background_1->red);
-                        *dp = gamma_from_1[w];
+                        png_composite(w, v, a, png_ptr->background_1.red);
+                        if (!optimize) w = gamma_from_1[w];
+                        *sp = w;
 
                         v = gamma_to_1[*(sp + 1)];
-                        png_composite(w, v, a, background_1->green);
-                        *(dp + 1) = gamma_from_1[w];
+                        png_composite(w, v, a, png_ptr->background_1.green);
+                        if (!optimize) w = gamma_from_1[w];
+                        *(sp + 1) = w;
 
                         v = gamma_to_1[*(sp + 2)];
-                        png_composite(w, v, a, background_1->blue);
-                        *(dp + 2) = gamma_from_1[w];
+                        png_composite(w, v, a, png_ptr->background_1.blue);
+                        if (!optimize) w = gamma_from_1[w];
+                        *(sp + 2) = w;
                      }
                   }
                }
@@ -3309,34 +4039,26 @@ png_do_background(png_row_infop row_info, png_bytep row,
 #endif
                {
                   sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 4, dp += 3)
+                  for (i = 0; i < row_width; i++, sp += 4)
                   {
                      png_byte a = *(sp + 3);
 
-                     if (a == 0xff)
-                     {
-                        *dp = *sp;
-                        *(dp + 1) = *(sp + 1);
-                        *(dp + 2) = *(sp + 2);
-                     }
-
-                     else if (a == 0)
+                     if (a == 0)
                      {
-                        *dp = (png_byte)background->red;
-                        *(dp + 1) = (png_byte)background->green;
-                        *(dp + 2) = (png_byte)background->blue;
+                        *sp = (png_byte)png_ptr->background.red;
+                        *(sp + 1) = (png_byte)png_ptr->background.green;
+                        *(sp + 2) = (png_byte)png_ptr->background.blue;
                      }
 
-                     else
+                     else if (a < 0xff)
                      {
-                        png_composite(*dp, *sp, a, background->red);
+                        png_composite(*sp, *sp, a, png_ptr->background.red);
 
-                        png_composite(*(dp + 1), *(sp + 1), a,
-                            background->green);
+                        png_composite(*(sp + 1), *(sp + 1), a,
+                            png_ptr->background.green);
 
-                        png_composite(*(dp + 2), *(sp + 2), a,
-                            background->blue);
+                        png_composite(*(sp + 2), *(sp + 2), a,
+                            png_ptr->background.blue);
                      }
                   }
                }
@@ -3348,8 +4070,7 @@ png_do_background(png_row_infop row_info, png_bytep row,
                    gamma_16_to_1 != NULL)
                {
                   sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 8, dp += 6)
+                  for (i = 0; i < row_width; i++, sp += 8)
                   {
                      png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
                          << 8) + (png_uint_16)(*(sp + 7)));
@@ -3359,53 +4080,55 @@ png_do_background(png_row_infop row_info, png_bytep row,
                         png_uint_16 v;
 
                         v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *dp = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(v & 0xff);
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
 
                         v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        *(dp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(v & 0xff);
+                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(v & 0xff);
 
                         v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        *(dp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(v & 0xff);
+                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(v & 0xff);
                      }
 
                      else if (a == 0)
                      {
                         /* Background is already in screen gamma */
-                        *dp = (png_byte)((background->red >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(background->red & 0xff);
-                        *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(background->green & 0xff);
-                        *(dp + 4) = (png_byte)((background->blue >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(background->blue & 0xff);
+                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
+                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
                      }
 
                      else
                      {
-                        png_uint_16 v, w, x;
+                        png_uint_16 v, w;
 
                         v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
-                        png_composite_16(w, v, a, background_1->red);
-
-                        x = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
-                        *dp = (png_byte)((x >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(x & 0xff);
+                        png_composite_16(w, v, a, png_ptr->background_1.red);
+                        if (!optimize)
+                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
+                        *sp = (png_byte)((w >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(w & 0xff);
 
                         v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        png_composite_16(w, v, a, background_1->green);
+                        png_composite_16(w, v, a, png_ptr->background_1.green);
+                        if (!optimize)
+                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
 
-                        x = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
-                        *(dp + 2) = (png_byte)((x >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(x & 0xff);
+                        *(sp + 2) = (png_byte)((w >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(w & 0xff);
 
                         v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        png_composite_16(w, v, a, background_1->blue);
+                        png_composite_16(w, v, a, png_ptr->background_1.blue);
+                        if (!optimize)
+                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
 
-                        x = gamma_16_from_1[(w & 0xff) >> gamma_shift][w >> 8];
-                        *(dp + 4) = (png_byte)((x >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(x & 0xff);
+                        *(sp + 4) = (png_byte)((w >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(w & 0xff);
                      }
                   }
                }
@@ -3414,28 +4137,22 @@ png_do_background(png_row_infop row_info, png_bytep row,
 #endif
                {
                   sp = row;
-                  dp = row;
-                  for (i = 0; i < row_width; i++, sp += 8, dp += 6)
+                  for (i = 0; i < row_width; i++, sp += 8)
                   {
                      png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
                          << 8) + (png_uint_16)(*(sp + 7)));
 
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_memcpy(dp, sp, 6);
-                     }
-
-                     else if (a == 0)
+                     if (a == 0)
                      {
-                        *dp = (png_byte)((background->red >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(background->red & 0xff);
-                        *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(background->green & 0xff);
-                        *(dp + 4) = (png_byte)((background->blue >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(background->blue & 0xff);
+                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
+                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
                      }
 
-                     else
+                     else if (a < 0xffff)
                      {
                         png_uint_16 v;
 
@@ -3445,17 +4162,17 @@ png_do_background(png_row_infop row_info, png_bytep row,
                         png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
                             + *(sp + 5));
 
-                        png_composite_16(v, r, a, background->red);
-                        *dp = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 1) = (png_byte)(v & 0xff);
+                        png_composite_16(v, r, a, png_ptr->background.red);
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
 
-                        png_composite_16(v, g, a, background->green);
-                        *(dp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 3) = (png_byte)(v & 0xff);
+                        png_composite_16(v, g, a, png_ptr->background.green);
+                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(v & 0xff);
 
-                        png_composite_16(v, b, a, background->blue);
-                        *(dp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(dp + 5) = (png_byte)(v & 0xff);
+                        png_composite_16(v, b, a, png_ptr->background.blue);
+                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(v & 0xff);
                      }
                   }
                }
@@ -3466,19 +4183,9 @@ png_do_background(png_row_infop row_info, png_bytep row,
          default:
             break;
       }
-
-      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
-      {
-         row_info->color_type = (png_byte)(row_info->color_type &
-             ~PNG_COLOR_MASK_ALPHA);
-         row_info->channels--;
-         row_info->pixel_depth = (png_byte)(row_info->channels *
-             row_info->bit_depth);
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
    }
 }
-#endif
+#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_READ_ALPHA_MODE_SUPPORTED */
 
 #ifdef PNG_READ_GAMMA_SUPPORTED
 /* Gamma correct the image, avoiding the alpha channel.  Make sure
@@ -3488,10 +4195,12 @@ png_do_background(png_row_infop row_info, png_bytep row,
  * build_gamma_table().
  */
 void /* PRIVATE */
-png_do_gamma(png_row_infop row_info, png_bytep row,
-    png_const_bytep gamma_table, png_const_uint_16pp gamma_16_table,
-    int gamma_shift)
+png_do_gamma(png_row_infop row_info, png_bytep row, png_structp png_ptr)
 {
+   png_const_bytep gamma_table = png_ptr->gamma_table;
+   png_const_uint_16pp gamma_16_table = png_ptr->gamma_16_table;
+   int gamma_shift = png_ptr->gamma_shift;
+
    png_bytep sp;
    png_uint_32 i;
    png_uint_32 row_width=row_info->width;
@@ -3681,6 +4390,73 @@ png_do_gamma(png_row_infop row_info, png_bytep row,
 }
 #endif
 
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+/* Encode the alpha channel to the output gamma (the input channel is always
+ * linear.)  Called only with color types that have an alpha channel.  Needs the
+ * from_1 tables.
+ */
+void /* PRIVATE */
+png_do_encode_alpha(png_row_infop row_info, png_bytep row, png_structp png_ptr)
+{
+   png_uint_32 row_width = row_info->width;
+
+   png_debug(1, "in png_do_encode_alpha");
+
+   if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         PNG_CONST png_bytep table = png_ptr->gamma_from_1;
+
+         if (table != NULL)
+         {
+            PNG_CONST int step =
+               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;
+
+            /* The alpha channel is the last component: */
+            row += step - 1;
+
+            for (; row_width > 0; --row_width, row += step)
+               *row = table[*row];
+
+            return;
+         }
+      }
+
+      else if (row_info->bit_depth == 16)
+      {
+         PNG_CONST png_uint_16pp table = png_ptr->gamma_16_from_1;
+         PNG_CONST int gamma_shift = png_ptr->gamma_shift;
+
+         if (table != NULL)
+         {
+            PNG_CONST int step =
+               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;
+
+            /* The alpha channel is the last component: */
+            row += step - 2;
+
+            for (; row_width > 0; --row_width, row += step)
+            {
+               png_uint_16 v;
+
+               v = table[*(row + 1) >> gamma_shift][*row];
+               *row = (png_byte)((v >> 8) & 0xff);
+               *(row + 1) = (png_byte)(v & 0xff);
+            }
+
+            return;
+         }
+      }
+   }
+
+   /* Only get to here if called with a weird row_info; no harm has been done,
+    * so just issue a warning.
+    */
+   png_warning(png_ptr, "png_do_encode_alpha: unexpected call");
+}
+#endif
+
 #ifdef PNG_READ_EXPAND_SUPPORTED
 /* Expands a palette row to an RGB or RGBA row depending
  * upon whether you supply trans and num_trans.
@@ -3786,7 +4562,7 @@ png_do_expand_palette(png_row_infop row_info, png_bytep row,
       if (row_info->bit_depth == 8)
       {
          {
-            if (trans_alpha != NULL)
+            if (num_trans > 0)
             {
                sp = row + (png_size_t)row_width - 1;
                dp = row + (png_size_t)(row_width << 2) - 1;
@@ -3840,7 +4616,7 @@ png_do_expand_palette(png_row_infop row_info, png_bytep row,
  */
 void /* PRIVATE */
 png_do_expand(png_row_infop row_info, png_bytep row,
-    png_const_color_16p trans_value)
+    png_const_color_16p trans_color)
 {
    int shift, value;
    png_bytep sp, dp;
@@ -3852,7 +4628,7 @@ png_do_expand(png_row_infop row_info, png_bytep row,
    {
       if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
       {
-         png_uint_16 gray = (png_uint_16)(trans_value ? trans_value->gray : 0);
+         png_uint_16 gray = (png_uint_16)(trans_color ? trans_color->gray : 0);
 
          if (row_info->bit_depth < 8)
          {
@@ -3944,7 +4720,7 @@ png_do_expand(png_row_infop row_info, png_bytep row,
             row_info->rowbytes = row_width;
          }
 
-         if (trans_value != NULL)
+         if (trans_color != NULL)
          {
             if (row_info->bit_depth == 8)
             {
@@ -3996,13 +4772,13 @@ png_do_expand(png_row_infop row_info, png_bytep row,
                row_width);
          }
       }
-      else if (row_info->color_type == PNG_COLOR_TYPE_RGB && trans_value)
+      else if (row_info->color_type == PNG_COLOR_TYPE_RGB && trans_color)
       {
          if (row_info->bit_depth == 8)
          {
-            png_byte red = (png_byte)(trans_value->red & 0xff);
-            png_byte green = (png_byte)(trans_value->green & 0xff);
-            png_byte blue = (png_byte)(trans_value->blue & 0xff);
+            png_byte red = (png_byte)(trans_color->red & 0xff);
+            png_byte green = (png_byte)(trans_color->green & 0xff);
+            png_byte blue = (png_byte)(trans_color->blue & 0xff);
             sp = row + (png_size_t)row_info->rowbytes - 1;
             dp = row + (png_size_t)(row_width << 2) - 1;
             for (i = 0; i < row_width; i++)
@@ -4020,12 +4796,12 @@ png_do_expand(png_row_infop row_info, png_bytep row,
          }
          else if (row_info->bit_depth == 16)
          {
-            png_byte red_high = (png_byte)((trans_value->red >> 8) & 0xff);
-            png_byte green_high = (png_byte)((trans_value->green >> 8) & 0xff);
-            png_byte blue_high = (png_byte)((trans_value->blue >> 8) & 0xff);
-            png_byte red_low = (png_byte)(trans_value->red & 0xff);
-            png_byte green_low = (png_byte)(trans_value->green & 0xff);
-            png_byte blue_low = (png_byte)(trans_value->blue & 0xff);
+            png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);
+            png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);
+            png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);
+            png_byte red_low = (png_byte)(trans_color->red & 0xff);
+            png_byte green_low = (png_byte)(trans_color->green & 0xff);
+            png_byte blue_low = (png_byte)(trans_color->blue & 0xff);
             sp = row + row_info->rowbytes - 1;
             dp = row + (png_size_t)(row_width << 3) - 1;
             for (i = 0; i < row_width; i++)
@@ -4064,6 +4840,37 @@ png_do_expand(png_row_infop row_info, png_bytep row,
 }
 #endif
 
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+/* If the bit depth is 8 and the color type is not a palette type expand the
+ * whole row to 16 bits.  Has no effect otherwise.
+ */
+void /* PRIVATE */
+png_do_expand_16(png_row_infop row_info, png_bytep row)
+{
+   if (row_info->bit_depth == 8 &&
+      row_info->color_type != PNG_COLOR_TYPE_PALETTE)
+   {
+      /* The row have a sequence of bytes containing [0..255] and we need
+       * to turn it into another row containing [0..65535], to do this we
+       * calculate:
+       *
+       *  (input / 255) * 65535
+       *
+       *  Which happens to be exactly input * 257 and this can be achieved
+       *  simply by byte replication in place (copying backwards).
+       */
+      png_byte *sp = row + row_info->rowbytes; /* source, last byte + 1 */
+      png_byte *dp = sp + row_info->rowbytes;  /* destination, end + 1 */
+      while (dp > sp)
+         dp[-2] = dp[-1] = *--sp, dp -= 2;
+
+      row_info->rowbytes *= 2;
+      row_info->bit_depth = 16;
+      row_info->pixel_depth = (png_byte)(row_info->channels * 16);
+   }
+}
+#endif
+
 #ifdef PNG_READ_QUANTIZE_SUPPORTED
 void /* PRIVATE */
 png_do_quantize(png_row_infop row_info, png_bytep row,
@@ -4157,6 +4964,7 @@ png_do_quantize(png_row_infop row_info, png_bytep row,
    }
 }
 #endif /* PNG_READ_QUANTIZE_SUPPORTED */
+#endif /* PNG_READ_TRANSFORMS_SUPPORTED */
 
 #ifdef PNG_MNG_FEATURES_SUPPORTED
 /* Undoes intrapixel differencing  */
@@ -4210,8 +5018,8 @@ png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
             png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
             png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
             png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
-            png_uint_32 red  = (png_uint_32)((s0 + s1 + 65536L) & 0xffffL);
-            png_uint_32 blue = (png_uint_32)((s2 + s1 + 65536L) & 0xffffL);
+            png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;
+            png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;
             *(rp    ) = (png_byte)((red >> 8) & 0xff);
             *(rp + 1) = (png_byte)(red & 0xff);
             *(rp + 4) = (png_byte)((blue >> 8) & 0xff);
diff --git a/src/3rdparty/libpng/pngrutil.c b/src/3rdparty/libpng/pngrutil.c
index 4c3cd53..aa592cc 100644
--- a/src/3rdparty/libpng/pngrutil.c
+++ b/src/3rdparty/libpng/pngrutil.c
@@ -1,8 +1,8 @@
 
 /* pngrutil.c - utilities to read a PNG file
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -87,10 +87,10 @@ png_int_32 (PNGAPI
 png_get_int_32)(png_const_bytep buf)
 {
    png_uint_32 uval = png_get_uint_32(buf);
-   if ((uval & 0x80000000L) == 0) /* non-negative */
+   if ((uval & 0x80000000) == 0) /* non-negative */
       return uval;
 
-   uval = (uval ^ 0xffffffffL) + 1;  /* 2's complement: -x = ~x+1 */
+   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */
    return -(png_int_32)uval;
 }
 
@@ -165,14 +165,14 @@ png_read_chunk_header(png_structp png_ptr)
    length = png_get_uint_31(png_ptr, buf);
 
    /* Put the chunk name into png_ptr->chunk_name. */
-   png_memcpy(png_ptr->chunk_name, buf + 4, 4);
+   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);
 
-   png_debug2(0, "Reading %s chunk, length = %u",
-       png_ptr->chunk_name, length);
+   png_debug2(0, "Reading %lx chunk, length = %lu",
+       (unsigned long)png_ptr->chunk_name, (unsigned long)length);
 
    /* Reset the crc and run it over the chunk name. */
    png_reset_crc(png_ptr);
-   png_calculate_crc(png_ptr, png_ptr->chunk_name, 4);
+   png_calculate_crc(png_ptr, buf + 4, 4);
 
    /* Check to see if chunk name is valid. */
    png_check_chunk_name(png_ptr, png_ptr->chunk_name);
@@ -218,10 +218,9 @@ png_crc_finish(png_structp png_ptr, png_uint_32 skip)
 
    if (png_crc_error(png_ptr))
    {
-      if (((png_ptr->chunk_name[0] & 0x20) &&                /* Ancillary */
-          !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
-          (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */
-          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE)))
+      if (PNG_CHUNK_ANCILLIARY(png_ptr->chunk_name) ?
+          !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) :
+          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE))
       {
          png_chunk_warning(png_ptr, "CRC error");
       }
@@ -248,14 +247,14 @@ png_crc_error(png_structp png_ptr)
    png_uint_32 crc;
    int need_crc = 1;
 
-   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
+   if (PNG_CHUNK_ANCILLIARY(png_ptr->chunk_name))
    {
       if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
           (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
          need_crc = 0;
    }
 
-   else                                                    /* critical */
+   else /* critical */
    {
       if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
          need_crc = 0;
@@ -278,8 +277,7 @@ png_crc_error(png_structp png_ptr)
       return (0);
 }
 
-#if defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) || \
-    defined(PNG_READ_iCCP_SUPPORTED)
+#ifdef PNG_READ_COMPRESSED_TEXT_SUPPORTED
 static png_size_t
 png_inflate(png_structp png_ptr, png_bytep data, png_size_t size,
     png_bytep output, png_size_t output_size)
@@ -303,7 +301,7 @@ png_inflate(png_structp png_ptr, png_bytep data, png_size_t size,
    {
       int ret, avail;
 
-      /* The setting of 'avail_in' used to be outside the loop, by setting it
+      /* The setting of 'avail_in' used to be outside the loop; by setting it
        * inside it is possible to chunk the input to zlib and simply rely on
        * zlib to advance the 'next_in' pointer.  This allows arbitrary amounts o
        * data to be passed through zlib at the unavoidable cost of requiring a
@@ -370,41 +368,31 @@ png_inflate(png_structp png_ptr, png_bytep data, png_size_t size,
        * and the error message is dumped into the uncompressed
        * buffer if available.
        */
+#     ifdef PNG_WARNINGS_SUPPORTED
       {
-         PNG_CONST char *msg;
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-         char umsg[52];
-#endif
+         png_const_charp msg;
+
          if (png_ptr->zstream.msg != 0)
             msg = png_ptr->zstream.msg;
 
-         else
+         else switch (ret)
          {
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-            switch (ret)
-            {
-               case Z_BUF_ERROR:
-                  msg = "Buffer error in compressed datastream in %s chunk";
-                  break;
-
-               case Z_DATA_ERROR:
-                  msg = "Data error in compressed datastream in %s chunk";
-                  break;
+            case Z_BUF_ERROR:
+               msg = "Buffer error in compressed datastream";
+               break;
 
-               default:
-                  msg = "Incomplete compressed datastream in %s chunk";
-                  break;
-            }
+            case Z_DATA_ERROR:
+               msg = "Data error in compressed datastream";
+               break;
 
-            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);
-            msg = umsg;
-#else
-            msg = "Damaged compressed datastream in chunk other than IDAT";
-#endif
+            default:
+               msg = "Incomplete compressed datastream";
+               break;
          }
 
-         png_warning(png_ptr, msg);
+         png_chunk_warning(png_ptr, msg);
       }
+#     endif
 
       /* 0 means an error - notice that this code simply ignores
        * zero length compressed chunks as a result.
@@ -438,21 +426,22 @@ png_decompress_chunk(png_structp png_ptr, int comp_type,
       png_size_t expanded_size = png_inflate(png_ptr,
           (png_bytep)(png_ptr->chunkdata + prefix_size),
           chunklength - prefix_size,
-          0,            /*output*/
-          0);           /*output size*/
+          0,            /* output */
+          0);           /* output size */
 
       /* Now check the limits on this chunk - if the limit fails the
        * compressed data will be removed, the prefix will remain.
        */
-#ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
-      if (png_ptr->user_chunk_malloc_max &&
+      if (prefix_size >= (~(png_size_t)0) - 1 ||
+         expanded_size >= (~(png_size_t)0) - 1 - prefix_size
+#ifdef PNG_USER_LIMITS_SUPPORTED
+         || (png_ptr->user_chunk_malloc_max &&
           (prefix_size + expanded_size >= png_ptr->user_chunk_malloc_max - 1))
 #else
-#  ifdef PNG_USER_CHUNK_MALLOC_MAX
-      if ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
+         || ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
           prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)
-#  endif
 #endif
+         )
          png_warning(png_ptr, "Exceeded size limit while expanding chunk");
 
       /* If the size is zero either there was an error and a message
@@ -460,16 +449,11 @@ png_decompress_chunk(png_structp png_ptr, int comp_type,
        * and we have nothing to do - the code will exit through the
        * error case below.
        */
-#if defined(PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED) || \
-    defined(PNG_USER_CHUNK_MALLOC_MAX)
       else if (expanded_size > 0)
-#else
-      if (expanded_size > 0)
-#endif
       {
          /* Success (maybe) - really uncompress the chunk. */
          png_size_t new_size = 0;
-         png_charp text = png_malloc_warn(png_ptr,
+         png_charp text = (png_charp)png_malloc_warn(png_ptr,
              prefix_size + expanded_size + 1);
 
          if (text != NULL)
@@ -500,15 +484,9 @@ png_decompress_chunk(png_structp png_ptr, int comp_type,
 
    else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
    {
-#ifdef PNG_STDIO_SUPPORTED
-      char umsg[50];
-
-      png_snprintf(umsg, sizeof umsg,
-          "Unknown zTXt compression type %d", comp_type);
-      png_warning(png_ptr, umsg);
-#else
-      png_warning(png_ptr, "Unknown zTXt compression type");
-#endif
+      PNG_WARNING_PARAMETERS(p)
+      png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_d, comp_type);
+      png_formatted_warning(png_ptr, p, "Unknown compression type @1");
 
       /* The recovery is to simply drop the data. */
    }
@@ -518,7 +496,7 @@ png_decompress_chunk(png_structp png_ptr, int comp_type,
     * amount of compressed data.
     */
    {
-      png_charp text = png_malloc_warn(png_ptr, prefix_size + 1);
+      png_charp text = (png_charp)png_malloc_warn(png_ptr, prefix_size + 1);
 
       if (text != NULL)
       {
@@ -536,7 +514,7 @@ png_decompress_chunk(png_structp png_ptr, int comp_type,
 
    *newlength = prefix_size;
 }
-#endif
+#endif /* PNG_READ_COMPRESSED_TEXT_SUPPORTED */
 
 /* Read and check the IDHR chunk */
 void /* PRIVATE */
@@ -844,14 +822,12 @@ png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 #  ifdef PNG_READ_sRGB_SUPPORTED
    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
    {
-      if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
+      if (PNG_OUT_OF_RANGE(igamma, 45500, 500))
       {
-         png_warning(png_ptr,
-             "Ignoring incorrect gAMA value when sRGB is also present");
-
-#    ifdef PNG_CONSOLE_IO_SUPPORTED
-         fprintf(stderr, "gamma = (%d/100000)", (int)igamma);
-#    endif
+         PNG_WARNING_PARAMETERS(p)
+         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed, igamma);
+         png_formatted_warning(png_ptr, p,
+             "Ignoring incorrect gAMA value @1 when sRGB is also present");
          return;
       }
    }
@@ -961,7 +937,7 @@ png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 
    else if (png_ptr->mode & PNG_HAVE_PLTE)
       /* Should be an error, but we can cope with it */
-      png_warning(png_ptr, "Missing PLTE before cHRM");
+      png_warning(png_ptr, "Out of place cHRM chunk");
 
    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
 #  ifdef PNG_READ_sRGB_SUPPORTED
@@ -1013,28 +989,112 @@ png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
    {
       if (PNG_OUT_OF_RANGE(x_white, 31270,  1000) ||
           PNG_OUT_OF_RANGE(y_white, 32900,  1000) ||
-          PNG_OUT_OF_RANGE(x_red,   64000L, 1000) ||
+          PNG_OUT_OF_RANGE(x_red,   64000,  1000) ||
           PNG_OUT_OF_RANGE(y_red,   33000,  1000) ||
           PNG_OUT_OF_RANGE(x_green, 30000,  1000) ||
-          PNG_OUT_OF_RANGE(y_green, 60000L, 1000) ||
+          PNG_OUT_OF_RANGE(y_green, 60000,  1000) ||
           PNG_OUT_OF_RANGE(x_blue,  15000,  1000) ||
           PNG_OUT_OF_RANGE(y_blue,   6000,  1000))
       {
-         png_warning(png_ptr,
-             "Ignoring incorrect cHRM value when sRGB is also present");
-
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-         fprintf(stderr, "wx=%d, wy=%d, rx=%d, ry=%d\n",
-             x_white, y_white, x_red, y_red);
-
-         fprintf(stderr, "gx=%d, gy=%d, bx=%d, by=%d\n",
-             x_green, y_green, x_blue, y_blue);
-#endif /* PNG_CONSOLE_IO_SUPPORTED */
+         PNG_WARNING_PARAMETERS(p)
+
+         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed, x_white);
+         png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_fixed, y_white);
+         png_warning_parameter_signed(p, 3, PNG_NUMBER_FORMAT_fixed, x_red);
+         png_warning_parameter_signed(p, 4, PNG_NUMBER_FORMAT_fixed, y_red);
+         png_warning_parameter_signed(p, 5, PNG_NUMBER_FORMAT_fixed, x_green);
+         png_warning_parameter_signed(p, 6, PNG_NUMBER_FORMAT_fixed, y_green);
+         png_warning_parameter_signed(p, 7, PNG_NUMBER_FORMAT_fixed, x_blue);
+         png_warning_parameter_signed(p, 8, PNG_NUMBER_FORMAT_fixed, y_blue);
+
+         png_formatted_warning(png_ptr, p,
+             "Ignoring incorrect cHRM white(@1,@2) r(@3,@4)g(@5,@6)b(@7,@8) "
+             "when sRGB is also present");
       }
       return;
    }
 #endif /* PNG_READ_sRGB_SUPPORTED */
 
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+   /* Store the _white values as default coefficients for the rgb to gray
+    * operation if it is supported.  Check if the transform is already set to
+    * avoid destroying the transform values.
+    */
+   if (!png_ptr->rgb_to_gray_coefficients_set)
+   {
+      /* png_set_background has not been called and we haven't seen an sRGB
+       * chunk yet.  Find the XYZ of the three end points.
+       */
+      png_XYZ XYZ;
+      png_xy xy;
+
+      xy.redx = x_red;
+      xy.redy = y_red;
+      xy.greenx = x_green;
+      xy.greeny = y_green;
+      xy.bluex = x_blue;
+      xy.bluey = y_blue;
+      xy.whitex = x_white;
+      xy.whitey = y_white;
+
+      if (png_XYZ_from_xy_checked(png_ptr, &XYZ, xy))
+      {
+         /* The success case, because XYZ_from_xy normalises to a reference
+          * white Y of 1.0 we just need to scale the numbers.  This should
+          * always work just fine. It is an internal error if this overflows.
+          */
+         {
+            png_fixed_point r, g, b;
+            if (png_muldiv(&r, XYZ.redY, 32768, PNG_FP_1) &&
+               r >= 0 && r <= 32768 &&
+               png_muldiv(&g, XYZ.greenY, 32768, PNG_FP_1) &&
+               g >= 0 && g <= 32768 &&
+               png_muldiv(&b, XYZ.blueY, 32768, PNG_FP_1) &&
+               b >= 0 && b <= 32768 &&
+               r+g+b <= 32769)
+            {
+               /* We allow 0 coefficients here.  r+g+b may be 32769 if two or
+                * all of the coefficients were rounded up.  Handle this by
+                * reducing the *largest* coefficient by 1; this matches the
+                * approach used for the default coefficients in pngrtran.c
+                */
+               int add = 0;
+
+               if (r+g+b > 32768)
+                  add = -1;
+               else if (r+g+b < 32768)
+                  add = 1;
+
+               if (add != 0)
+               {
+                  if (g >= r && g >= b)
+                     g += add;
+                  else if (r >= g && r >= b)
+                     r += add;
+                  else
+                     b += add;
+               }
+
+               /* Check for an internal error. */
+               if (r+g+b != 32768)
+                  png_error(png_ptr,
+                     "internal error handling cHRM coefficients");
+
+               png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;
+               png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;
+            }
+
+            /* This is a png_error at present even though it could be ignored -
+             * it should never happen, but it is important that if it does, the
+             * bug is fixed.
+             */
+            else
+               png_error(png_ptr, "internal error handling cHRM->XYZ");
+         }
+      }
+   }
+#endif
+
    png_set_cHRM_fixed(png_ptr, info_ptr, x_white, y_white, x_red, y_red,
       x_green, y_green, x_blue, y_blue);
 }
@@ -1094,13 +1154,15 @@ png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 #if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA))
    {
-      if (PNG_OUT_OF_RANGE(info_ptr->gamma, 45500L, 500))
+      if (PNG_OUT_OF_RANGE(info_ptr->gamma, 45500, 500))
       {
-         png_warning(png_ptr,
-             "Ignoring incorrect gAMA value when sRGB is also present");
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-         fprintf(stderr, "incorrect gamma=(%d/100000)\n", info_ptr->gamma);
-#endif
+         PNG_WARNING_PARAMETERS(p)
+
+         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed,
+            info_ptr->gamma);
+
+         png_formatted_warning(png_ptr, p,
+             "Ignoring incorrect gAMA value @1 when sRGB is also present");
       }
    }
 #endif /* PNG_READ_gAMA_SUPPORTED */
@@ -1109,10 +1171,10 @@ png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
       if (PNG_OUT_OF_RANGE(info_ptr->x_white, 31270,  1000) ||
           PNG_OUT_OF_RANGE(info_ptr->y_white, 32900,  1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->x_red,   64000L, 1000) ||
+          PNG_OUT_OF_RANGE(info_ptr->x_red,   64000,  1000) ||
           PNG_OUT_OF_RANGE(info_ptr->y_red,   33000,  1000) ||
           PNG_OUT_OF_RANGE(info_ptr->x_green, 30000,  1000) ||
-          PNG_OUT_OF_RANGE(info_ptr->y_green, 60000L, 1000) ||
+          PNG_OUT_OF_RANGE(info_ptr->y_green, 60000,  1000) ||
           PNG_OUT_OF_RANGE(info_ptr->x_blue,  15000,  1000) ||
           PNG_OUT_OF_RANGE(info_ptr->y_blue,   6000,  1000))
       {
@@ -1121,6 +1183,47 @@ png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       }
 #endif /* PNG_READ_cHRM_SUPPORTED */
 
+   /* This is recorded for use when handling the cHRM chunk above.  An sRGB
+    * chunk unconditionally overwrites the coefficients for grayscale conversion
+    * too.
+    */
+   png_ptr->is_sRGB = 1;
+
+#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+      /* Don't overwrite user supplied values: */
+      if (!png_ptr->rgb_to_gray_coefficients_set)
+      {
+         /* These numbers come from the sRGB specification (or, since one has to
+          * pay much money to get a copy, the wikipedia sRGB page) the
+          * chromaticity values quoted have been inverted to get the reverse
+          * transformation from RGB to XYZ and the 'Y' coefficients scaled by
+          * 32768 (then rounded).
+          *
+          * sRGB and ITU Rec-709 both truncate the values for the D65 white
+          * point to four digits and, even though it actually stores five
+          * digits, the PNG spec gives the truncated value.
+          *
+          * This means that when the chromaticities are converted back to XYZ
+          * end points we end up with (6968,23435,2366), which, as described in
+          * pngrtran.c, would overflow.  If the five digit precision and up is
+          * used we get, instead:
+          *
+          *    6968*R + 23435*G + 2365*B
+          *
+          * (Notice that this rounds the blue coefficient down, rather than the
+          * choice used in pngrtran.c which is to round the green one down.)
+          */
+         png_ptr->rgb_to_gray_red_coeff   =  6968; /* 0.212639005871510 */
+         png_ptr->rgb_to_gray_green_coeff = 23434; /* 0.715168678767756 */
+         /* png_ptr->rgb_to_gray_blue_coeff  =  2366; 0.072192315360734	*/
+
+         /* The following keeps the cHRM chunk from destroying the
+          * coefficients again in the event that it follows the sRGB chunk.
+          */
+         png_ptr->rgb_to_gray_coefficients_set = 1;
+      }
+#  endif
+
    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
 }
 #endif /* PNG_READ_sRGB_SUPPORTED */
@@ -1154,13 +1257,16 @@ png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place iCCP chunk");
 
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
+   if ((png_ptr->mode & PNG_HAVE_iCCP) || (info_ptr != NULL &&
+      (info_ptr->valid & (PNG_INFO_iCCP|PNG_INFO_sRGB))))
    {
       png_warning(png_ptr, "Duplicate iCCP chunk");
       png_crc_finish(png_ptr, length);
       return;
    }
 
+   png_ptr->mode |= PNG_HAVE_iCCP;
+
 #ifdef PNG_MAX_MALLOC_64K
    if (length > (png_uint_32)65535L)
    {
@@ -1172,7 +1278,7 @@ png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 
    png_free(png_ptr, png_ptr->chunkdata);
    png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
-   slength = (png_size_t)length;
+   slength = length;
    png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, skip))
@@ -1240,23 +1346,15 @@ png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
    /* And the following guarantees that profile_size == profile_length. */
    if (profile_size > profile_length)
    {
+      PNG_WARNING_PARAMETERS(p)
+
       png_free(png_ptr, png_ptr->chunkdata);
       png_ptr->chunkdata = NULL;
-#ifdef PNG_STDIO_SUPPORTED
-      {
-         char umsg[80];
-
-         png_snprintf2(umsg, 80,
-             "Ignoring iCCP chunk with declared size = %u "
-              "and actual length = %u",
-              (unsigned int) profile_size,
-              (unsigned int) profile_length);
-         png_warning(png_ptr, umsg);
-      }
-#else
-      png_warning(png_ptr,
-         "Ignoring iCCP chunk with uncompressed size mismatch");
-#endif
+
+      png_warning_parameter_unsigned(p, 1, PNG_NUMBER_FORMAT_u, profile_size);
+      png_warning_parameter_unsigned(p, 2, PNG_NUMBER_FORMAT_u, profile_length);
+      png_formatted_warning(png_ptr, p,
+         "Ignoring iCCP chunk with declared size = @1 and actual length = @2");
       return;
    }
 
@@ -1275,9 +1373,7 @@ png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_bytep entry_start;
    png_sPLT_t new_palette;
-#ifdef PNG_POINTER_INDEXING_SUPPORTED
    png_sPLT_entryp pp;
-#endif
    png_uint_32 data_length;
    int entry_size, i;
    png_uint_32 skip = 0;
@@ -1332,7 +1428,7 @@ png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
     * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a
     * potential breakage point if the types in pngconf.h aren't exactly right.
     */
-   slength = (png_size_t)length;
+   slength = length;
    png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, skip))
@@ -1442,7 +1538,7 @@ png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
          pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;
       }
 
-      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
+      pp[i].frequency = png_get_uint_16(entry_start); entry_start += 2;
    }
 #endif
 
@@ -1567,6 +1663,7 @@ png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
    png_size_t truelen;
    png_byte buf[6];
+   png_color_16 background;
 
    png_debug(1, "in png_handle_bKGD");
 
@@ -1623,7 +1720,7 @@ png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
     */
    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
    {
-      png_ptr->background.index = buf[0];
+      background.index = buf[0];
 
       if (info_ptr && info_ptr->num_palette)
       {
@@ -1633,33 +1730,36 @@ png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
             return;
          }
 
-         png_ptr->background.red =
-             (png_uint_16)png_ptr->palette[buf[0]].red;
+         background.red = (png_uint_16)png_ptr->palette[buf[0]].red;
+         background.green = (png_uint_16)png_ptr->palette[buf[0]].green;
+         background.blue = (png_uint_16)png_ptr->palette[buf[0]].blue;
+      }
 
-         png_ptr->background.green =
-             (png_uint_16)png_ptr->palette[buf[0]].green;
+      else
+         background.red = background.green = background.blue = 0;
 
-         png_ptr->background.blue =
-             (png_uint_16)png_ptr->palette[buf[0]].blue;
-      }
+      background.gray = 0;
    }
 
    else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */
    {
-      png_ptr->background.red =
-      png_ptr->background.green =
-      png_ptr->background.blue =
-      png_ptr->background.gray = png_get_uint_16(buf);
+      background.index = 0;
+      background.red =
+      background.green =
+      background.blue =
+      background.gray = png_get_uint_16(buf);
    }
 
    else
    {
-      png_ptr->background.red = png_get_uint_16(buf);
-      png_ptr->background.green = png_get_uint_16(buf + 2);
-      png_ptr->background.blue = png_get_uint_16(buf + 4);
+      background.index = 0;
+      background.red = png_get_uint_16(buf);
+      background.green = png_get_uint_16(buf + 2);
+      background.blue = png_get_uint_16(buf + 4);
+      background.gray = 0;
    }
 
-   png_set_bKGD(png_ptr, info_ptr, &(png_ptr->background));
+   png_set_bKGD(png_ptr, info_ptr, &background);
 }
 #endif
 
@@ -1696,16 +1796,16 @@ png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       return;
    }
 
-   num = length / 2 ;
-
-   if (num != (unsigned int)png_ptr->num_palette || num >
-       (unsigned int)PNG_MAX_PALETTE_LENGTH)
+   if (length > 2*PNG_MAX_PALETTE_LENGTH ||
+       length != (unsigned int) (2*png_ptr->num_palette))
    {
       png_warning(png_ptr, "Incorrect hIST chunk length");
       png_crc_finish(png_ptr, length);
       return;
    }
 
+   num = length / 2 ;
+
    for (i = 0; i < num; i++)
    {
       png_byte buf[2];
@@ -1855,7 +1955,7 @@ png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       return;
    }
 
-   slength = (png_size_t)length;
+   slength = length;
    png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, 0))
@@ -1984,6 +2084,14 @@ png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       return;
    }
 
+   /* Need unit type, width, \0, height: minimum 4 bytes */
+   else if (length < 4)
+   {
+      png_warning(png_ptr, "sCAL chunk too short");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
    png_debug1(2, "Allocating and reading sCAL chunk data (%u bytes)",
       length + 1);
 
@@ -1996,7 +2104,7 @@ png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       return;
    }
 
-   slength = (png_size_t)length;
+   slength = length;
    png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
    png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */
 
@@ -2019,23 +2127,29 @@ png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
    /* Validate the ASCII numbers, need two ASCII numbers separated by
     * a '\0' and they need to fit exactly in the chunk data.
     */
-   i = 0;
+   i = 1;
    state = 0;
 
-   if (png_ptr->chunkdata[1] == 45 /* negative width */ ||
-       !png_check_fp_number(png_ptr->chunkdata, slength, &state, &i) ||
+   if (!png_check_fp_number(png_ptr->chunkdata, slength, &state, &i) ||
        i >= slength || png_ptr->chunkdata[i++] != 0)
       png_warning(png_ptr, "Invalid sCAL chunk ignored: bad width format");
 
+   else if (!PNG_FP_IS_POSITIVE(state))
+      png_warning(png_ptr, "Invalid sCAL chunk ignored: non-positive width");
+
    else
    {
       png_size_t heighti = i;
 
-      if (png_ptr->chunkdata[i] == 45 /* negative height */ ||
-          !png_check_fp_number(png_ptr->chunkdata, slength, &state, &i) ||
+      state = 0;
+      if (!png_check_fp_number(png_ptr->chunkdata, slength, &state, &i) ||
           i != slength)
          png_warning(png_ptr, "Invalid sCAL chunk ignored: bad height format");
 
+      else if (!PNG_FP_IS_POSITIVE(state))
+         png_warning(png_ptr,
+            "Invalid sCAL chunk ignored: non-positive height");
+
       else
          /* This is the (only) success case. */
          png_set_sCAL_s(png_ptr, info_ptr, png_ptr->chunkdata[0],
@@ -2150,7 +2264,7 @@ png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
      return;
    }
 
-   slength = (png_size_t)length;
+   slength = length;
    png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, skip))
@@ -2258,7 +2372,7 @@ png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       return;
    }
 
-   slength = (png_size_t)length;
+   slength = length;
    png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, 0))
@@ -2389,7 +2503,7 @@ png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       return;
    }
 
-   slength = (png_size_t)length;
+   slength = length;
    png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
 
    if (png_crc_finish(png_ptr, 0))
@@ -2425,6 +2539,14 @@ png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       comp_type = *lang++;
    }
 
+   if (comp_type || (comp_flag && comp_flag != PNG_TEXT_COMPRESSION_zTXt))
+   {
+      png_warning(png_ptr, "Unknown iTXt compression type or method");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+      return;
+   }
+
    for (lang_key = lang; *lang_key; lang_key++)
       /* Empty loop */ ;
 
@@ -2525,16 +2647,14 @@ png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 
    if (png_ptr->mode & PNG_HAVE_IDAT)
    {
-      PNG_IDAT;
-
-      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* Not an IDAT */
+      if (png_ptr->chunk_name != png_IDAT)
          png_ptr->mode |= PNG_AFTER_IDAT;
    }
 
-   if (!(png_ptr->chunk_name[0] & 0x20))
+   if (PNG_CHUNK_CRITICAL(png_ptr->chunk_name))
    {
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
+      if (png_chunk_unknown_handling(png_ptr, png_ptr->chunk_name) !=
           PNG_HANDLE_CHUNK_ALWAYS
 #ifdef PNG_READ_USER_CHUNKS_SUPPORTED
           && png_ptr->read_user_chunk_fn == NULL
@@ -2552,21 +2672,20 @@ png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
        )
    {
 #ifdef PNG_MAX_MALLOC_64K
-      if (length > (png_uint_32)65535L)
+      if (length > 65535)
       {
          png_warning(png_ptr, "unknown chunk too large to fit in memory");
-         skip = length - (png_uint_32)65535L;
-         length = (png_uint_32)65535L;
+         skip = length - 65535;
+         length = 65535;
       }
 #endif
 
-      png_memcpy((png_charp)png_ptr->unknown_chunk.name,
-          (png_charp)png_ptr->chunk_name,
-          png_sizeof(png_ptr->unknown_chunk.name));
-
-      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1]
-          = '\0';
-
+      /* TODO: this code is very close to the unknown handling in pngpread.c,
+       * maybe it can be put into a common utility routine?
+       * png_struct::unknown_chunk is just used as a temporary variable, along
+       * with the data into which the chunk is read.  These can be eliminated.
+       */
+      PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);
       png_ptr->unknown_chunk.size = (png_size_t)length;
 
       if (length == 0)
@@ -2575,7 +2694,7 @@ png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
       else
       {
          png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
-         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
+         png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);
       }
 
 #ifdef PNG_READ_USER_CHUNKS_SUPPORTED
@@ -2592,10 +2711,10 @@ png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 
          if (ret == 0)
          {
-            if (!(png_ptr->chunk_name[0] & 0x20))
+            if (PNG_CHUNK_CRITICAL(png_ptr->chunk_name))
             {
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-               if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
+               if (png_chunk_unknown_handling(png_ptr, png_ptr->chunk_name) !=
                    PNG_HANDLE_CHUNK_ALWAYS)
 #endif
                   png_chunk_error(png_ptr, "unknown critical chunk");
@@ -2632,259 +2751,523 @@ png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
  * the chunk name itself is valid.
  */
 
-#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
+/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
+ *
+ * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
+ */
 
 void /* PRIVATE */
-png_check_chunk_name(png_structp png_ptr, png_const_bytep chunk_name)
+png_check_chunk_name(png_structp png_ptr, png_uint_32 chunk_name)
 {
+   int i;
+
    png_debug(1, "in png_check_chunk_name");
-   if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||
-       isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))
+
+   for (i=1; i<=4; ++i)
    {
-      png_chunk_error(png_ptr, "invalid chunk type");
+      int c = chunk_name & 0xff;
+
+      if (c < 65 || c > 122 || (c > 90 && c < 97))
+         png_chunk_error(png_ptr, "invalid chunk type");
+
+      chunk_name >>= 8;
    }
 }
 
-/* Combines the row recently read in with the existing pixels in the
- * row.  This routine takes care of alpha and transparency if requested.
- * This routine also handles the two methods of progressive display
- * of interlaced images, depending on the mask value.
- * The mask value describes which pixels are to be combined with
- * the row.  The pattern always repeats every 8 pixels, so just 8
- * bits are needed.  A one indicates the pixel is to be combined,
- * a zero indicates the pixel is to be skipped.  This is in addition
- * to any alpha or transparency value associated with the pixel.  If
- * you want all pixels to be combined, pass 0xff (255) in mask.
+/* Combines the row recently read in with the existing pixels in the row.  This
+ * routine takes care of alpha and transparency if requested.  This routine also
+ * handles the two methods of progressive display of interlaced images,
+ * depending on the 'display' value; if 'display' is true then the whole row
+ * (dp) is filled from the start by replicating the available pixels.  If
+ * 'display' is false only those pixels present in the pass are filled in.
  */
-
 void /* PRIVATE */
-png_combine_row(png_structp png_ptr, png_bytep row, int mask)
+png_combine_row(png_structp png_ptr, png_bytep dp, int display)
 {
+   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;
+   png_const_bytep sp = png_ptr->row_buf + 1;
+   png_uint_32 row_width = png_ptr->width;
+   unsigned int pass = png_ptr->pass;
+   png_bytep end_ptr = 0;
+   png_byte end_byte = 0;
+   unsigned int end_mask;
+
    png_debug(1, "in png_combine_row");
 
-   if (mask == 0xff)
-   {
-      png_memcpy(row, png_ptr->row_buf + 1,
-          PNG_ROWBYTES(png_ptr->row_info.pixel_depth, png_ptr->width));
-   }
+   /* Added in 1.5.6: it should not be possible to enter this routine until at
+    * least one row has been read from the PNG data and transformed.
+    */
+   if (pixel_depth == 0)
+      png_error(png_ptr, "internal row logic error");
 
-   else
+   /* Added in 1.5.4: the pixel depth should match the information returned by
+    * any call to png_read_update_info at this point.  Do not continue if we got
+    * this wrong.
+    */
+   if (png_ptr->info_rowbytes != 0 && png_ptr->info_rowbytes !=
+          PNG_ROWBYTES(pixel_depth, row_width))
+      png_error(png_ptr, "internal row size calculation error");
+
+   /* Don't expect this to ever happen: */
+   if (row_width == 0)
+      png_error(png_ptr, "internal row width error");
+
+   /* Preserve the last byte in cases where only part of it will be overwritten,
+    * the multiply below may overflow, we don't care because ANSI-C guarantees
+    * we get the low bits.
+    */
+   end_mask = (pixel_depth * row_width) & 7;
+   if (end_mask != 0)
+   {
+      /* end_ptr == NULL is a flag to say do nothing */
+      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;
+      end_byte = *end_ptr;
+#     ifdef PNG_READ_PACKSWAP_SUPPORTED
+         if (png_ptr->transformations & PNG_PACKSWAP) /* little-endian byte */
+            end_mask = 0xff << end_mask;
+
+         else /* big-endian byte */
+#     endif
+         end_mask = 0xff >> end_mask;
+      /* end_mask is now the bits to *keep* from the destination row */
+   }
+
+   /* For non-interlaced images this reduces to a png_memcpy(). A png_memcpy()
+    * will also happen if interlacing isn't supported or if the application
+    * does not call png_set_interlace_handling().  In the latter cases the
+    * caller just gets a sequence of the unexpanded rows from each interlace
+    * pass.
+    */
+#ifdef PNG_READ_INTERLACING_SUPPORTED
+   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE) &&
+      pass < 6 && (display == 0 ||
+      /* The following copies everything for 'display' on passes 0, 2 and 4. */
+      (display == 1 && (pass & 1) != 0)))
    {
-      switch (png_ptr->row_info.pixel_depth)
+      /* Narrow images may have no bits in a pass; the caller should handle
+       * this, but this test is cheap:
+       */
+      if (row_width <= PNG_PASS_START_COL(pass))
+         return;
+
+      if (pixel_depth < 8)
       {
-         case 1:
+         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit
+          * into 32 bits, then a single loop over the bytes using the four byte
+          * values in the 32-bit mask can be used.  For the 'display' option the
+          * expanded mask may also not require any masking within a byte.  To
+          * make this work the PACKSWAP option must be taken into account - it
+          * simply requires the pixels to be reversed in each byte.
+          *
+          * The 'regular' case requires a mask for each of the first 6 passes,
+          * the 'display' case does a copy for the even passes in the range
+          * 0..6.  This has already been handled in the test above.
+          *
+          * The masks are arranged as four bytes with the first byte to use in
+          * the lowest bits (little-endian) regardless of the order (PACKSWAP or
+          * not) of the pixels in each byte.
+          *
+          * NOTE: the whole of this logic depends on the caller of this function
+          * only calling it on rows appropriate to the pass.  This function only
+          * understands the 'x' logic; the 'y' logic is handled by the caller.
+          *
+          * The following defines allow generation of compile time constant bit
+          * masks for each pixel depth and each possibility of swapped or not
+          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,
+          * is in the range 0..7; and the result is 1 if the pixel is to be
+          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'
+          * for the block method.
+          *
+          * With some compilers a compile time expression of the general form:
+          *
+          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)
+          *
+          * Produces warnings with values of 'shift' in the range 33 to 63
+          * because the right hand side of the ?: expression is evaluated by
+          * the compiler even though it isn't used.  Microsoft Visual C (various
+          * versions) and the Intel C compiler are known to do this.  To avoid
+          * this the following macros are used in 1.5.6.  This is a temporary
+          * solution to avoid destabilizing the code during the release process.
+          */
+#        if PNG_USE_COMPILE_TIME_MASKS
+#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))
+#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))
+#        else
+#           define PNG_LSR(x,s) ((x)>>(s))
+#           define PNG_LSL(x,s) ((x)<<(s))
+#        endif
+#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\
+           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)
+#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\
+           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)
+
+         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is
+          * little endian - the first pixel is at bit 0 - however the extra
+          * parameter 's' can be set to cause the mask position to be swapped
+          * within each byte, to match the PNG format.  This is done by XOR of
+          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.
+          */
+#        define PIXEL_MASK(p,x,d,s) \
+            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))
+
+         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.
+          */
+#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
+#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
+
+         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp
+          * cases the result needs replicating, for the 4-bpp case the above
+          * generates a full 32 bits.
+          */
+#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
+
+#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
+            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
+            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
+
+#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
+            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
+            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
+
+#if PNG_USE_COMPILE_TIME_MASKS
+         /* Utility macros to construct all the masks for a depth/swap
+          * combination.  The 's' parameter says whether the format is PNG
+          * (big endian bytes) or not.  Only the three odd-numbered passes are
+          * required for the display/block algorithm.
+          */
+#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
+            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
+
+#        define B_MASKS(d,s) { B_MASK(1,d,s), S_MASK(3,d,s), S_MASK(5,d,s) }
+
+#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
+
+         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
+          * then pass:
+          */
+         static PNG_CONST png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =
          {
-            png_bytep sp = png_ptr->row_buf + 1;
-            png_bytep dp = row;
-            int s_inc, s_start, s_end;
-            int m = 0x80;
-            int shift;
-            png_uint_32 i;
-            png_uint_32 row_width = png_ptr->width;
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
+            /* Little-endian byte masks for PACKSWAP */
+            { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
+            /* Normal (big-endian byte) masks - PNG format */
+            { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
+         };
+
+         /* display_mask has only three entries for the odd passes, so index by
+          * pass>>1.
+          */
+         static PNG_CONST png_uint_32 display_mask[2][3][3] =
+         {
+            /* Little-endian byte masks for PACKSWAP */
+            { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
+            /* Normal (big-endian byte) masks - PNG format */
+            { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
+         };
+
+#        define MASK(pass,depth,display,png)\
+            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\
+               row_mask[png][DEPTH_INDEX(depth)][pass])
+
+#else /* !PNG_USE_COMPILE_TIME_MASKS */
+         /* This is the runtime alternative: it seems unlikely that this will
+          * ever be either smaller or faster than the compile time approach.
+          */
+#        define MASK(pass,depth,display,png)\
+            ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))
+#endif /* !PNG_USE_COMPILE_TIME_MASKS */
+
+         /* Use the appropriate mask to copy the required bits.  In some cases
+          * the byte mask will be 0 or 0xff, optimize these cases.  row_width is
+          * the number of pixels, but the code copies bytes, so it is necessary
+          * to special case the end.
+          */
+         png_uint_32 pixels_per_byte = 8 / pixel_depth;
+         png_uint_32 mask;
+
+#        ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (png_ptr->transformations & PNG_PACKSWAP)
-            {
-                s_start = 0;
-                s_end = 7;
-                s_inc = 1;
-            }
+               mask = MASK(pass, pixel_depth, display, 0);
 
             else
-#endif
+#        endif
+            mask = MASK(pass, pixel_depth, display, 1);
+
+         for (;;)
+         {
+            png_uint_32 m;
+
+            /* It doesn't matter in the following if png_uint_32 has more than
+             * 32 bits because the high bits always match those in m<<24; it is,
+             * however, essential to use OR here, not +, because of this.
+             */
+            m = mask;
+            mask = (m >> 8) | (m << 24); /* rotate right to good compilers */
+            m &= 0xff;
+
+            if (m != 0) /* something to copy */
             {
-                s_start = 7;
-                s_end = 0;
-                s_inc = -1;
+               if (m != 0xff)
+                  *dp = (png_byte)((*dp & ~m) | (*sp & m));
+               else
+                  *dp = *sp;
             }
 
-            shift = s_start;
+            /* NOTE: this may overwrite the last byte with garbage if the image
+             * is not an exact number of bytes wide; libpng has always done
+             * this.
+             */
+            if (row_width <= pixels_per_byte)
+               break; /* May need to restore part of the last byte */
 
-            for (i = 0; i < row_width; i++)
-            {
-               if (m & mask)
-               {
-                  int value;
+            row_width -= pixels_per_byte;
+            ++dp;
+            ++sp;
+         }
+      }
 
-                  value = (*sp >> shift) & 0x01;
-                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
-                  *dp |= (png_byte)(value << shift);
-               }
+      else /* pixel_depth >= 8 */
+      {
+         unsigned int bytes_to_copy, bytes_to_jump;
 
-               if (shift == s_end)
-               {
-                  shift = s_start;
-                  sp++;
-                  dp++;
-               }
+         /* Validate the depth - it must be a multiple of 8 */
+         if (pixel_depth & 7)
+            png_error(png_ptr, "invalid user transform pixel depth");
 
-               else
-                  shift += s_inc;
+         pixel_depth >>= 3; /* now in bytes */
+         row_width *= pixel_depth;
 
-               if (m == 1)
-                  m = 0x80;
+         /* Regardless of pass number the Adam 7 interlace always results in a
+          * fixed number of pixels to copy then to skip.  There may be a
+          * different number of pixels to skip at the start though.
+          */
+         {
+            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;
 
-               else
-                  m >>= 1;
-            }
-            break;
+            row_width -= offset;
+            dp += offset;
+            sp += offset;
          }
 
-         case 2:
+         /* Work out the bytes to copy. */
+         if (display)
          {
-            png_bytep sp = png_ptr->row_buf + 1;
-            png_bytep dp = row;
-            int s_start, s_end, s_inc;
-            int m = 0x80;
-            int shift;
-            png_uint_32 i;
-            png_uint_32 row_width = png_ptr->width;
-            int value;
+            /* When doing the 'block' algorithm the pixel in the pass gets
+             * replicated to adjacent pixels.  This is why the even (0,2,4,6)
+             * passes are skipped above - the entire expanded row is copied.
+             */
+            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;
 
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-            if (png_ptr->transformations & PNG_PACKSWAP)
-            {
-               s_start = 0;
-               s_end = 6;
-               s_inc = 2;
-            }
+            /* But don't allow this number to exceed the actual row width. */
+            if (bytes_to_copy > row_width)
+               bytes_to_copy = row_width;
+         }
 
-            else
-#endif
-            {
-               s_start = 6;
-               s_end = 0;
-               s_inc = -2;
-            }
+         else /* normal row; Adam7 only ever gives us one pixel to copy. */
+            bytes_to_copy = pixel_depth;
+
+         /* In Adam7 there is a constant offset between where the pixels go. */
+         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;
+
+         /* And simply copy these bytes.  Some optimization is possible here,
+          * depending on the value of 'bytes_to_copy'.  Special case the low
+          * byte counts, which we know to be frequent.
+          *
+          * Notice that these cases all 'return' rather than 'break' - this
+          * avoids an unnecessary test on whether to restore the last byte
+          * below.
+          */
+         switch (bytes_to_copy)
+         {
+            case 1:
+               for (;;)
+               {
+                  *dp = *sp;
 
-            shift = s_start;
+                  if (row_width <= bytes_to_jump)
+                     return;
 
-            for (i = 0; i < row_width; i++)
-            {
-               if (m & mask)
-               {
-                  value = (*sp >> shift) & 0x03;
-                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                  *dp |= (png_byte)(value << shift);
+                  dp += bytes_to_jump;
+                  sp += bytes_to_jump;
+                  row_width -= bytes_to_jump;
                }
 
-               if (shift == s_end)
+            case 2:
+               /* There is a possibility of a partial copy at the end here; this
+                * slows the code down somewhat.
+                */
+               do
                {
-                  shift = s_start;
-                  sp++;
-                  dp++;
-               }
+                  dp[0] = sp[0], dp[1] = sp[1];
 
-               else
-                  shift += s_inc;
+                  if (row_width <= bytes_to_jump)
+                     return;
 
-               if (m == 1)
-                  m = 0x80;
+                  sp += bytes_to_jump;
+                  dp += bytes_to_jump;
+                  row_width -= bytes_to_jump;
+               }
+               while (row_width > 1);
 
-               else
-                  m >>= 1;
-            }
-            break;
-         }
+               /* And there can only be one byte left at this point: */
+               *dp = *sp;
+               return;
 
-         case 4:
-         {
-            png_bytep sp = png_ptr->row_buf + 1;
-            png_bytep dp = row;
-            int s_start, s_end, s_inc;
-            int m = 0x80;
-            int shift;
-            png_uint_32 i;
-            png_uint_32 row_width = png_ptr->width;
-            int value;
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-            if (png_ptr->transformations & PNG_PACKSWAP)
-            {
-               s_start = 0;
-               s_end = 4;
-               s_inc = 4;
-            }
+            case 3:
+               /* This can only be the RGB case, so each copy is exactly one
+                * pixel and it is not necessary to check for a partial copy.
+                */
+               for(;;)
+               {
+                  dp[0] = sp[0], dp[1] = sp[1], dp[2] = sp[2];
 
-            else
-#endif
-            {
-               s_start = 4;
-               s_end = 0;
-               s_inc = -4;
-            }
-            shift = s_start;
+                  if (row_width <= bytes_to_jump)
+                     return;
 
-            for (i = 0; i < row_width; i++)
-            {
-               if (m & mask)
-               {
-                  value = (*sp >> shift) & 0xf;
-                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                  *dp |= (png_byte)(value << shift);
+                  sp += bytes_to_jump;
+                  dp += bytes_to_jump;
+                  row_width -= bytes_to_jump;
                }
 
-               if (shift == s_end)
+            default:
+#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE
+               /* Check for double byte alignment and, if possible, use a
+                * 16-bit copy.  Don't attempt this for narrow images - ones that
+                * are less than an interlace panel wide.  Don't attempt it for
+                * wide bytes_to_copy either - use the png_memcpy there.
+                */
+               if (bytes_to_copy < 16 /*else use png_memcpy*/ &&
+                  png_isaligned(dp, png_uint_16) &&
+                  png_isaligned(sp, png_uint_16) &&
+                  bytes_to_copy % sizeof (png_uint_16) == 0 &&
+                  bytes_to_jump % sizeof (png_uint_16) == 0)
                {
-                  shift = s_start;
-                  sp++;
-                  dp++;
+                  /* Everything is aligned for png_uint_16 copies, but try for
+                   * png_uint_32 first.
+                   */
+                  if (png_isaligned(dp, png_uint_32) &&
+                     png_isaligned(sp, png_uint_32) &&
+                     bytes_to_copy % sizeof (png_uint_32) == 0 &&
+                     bytes_to_jump % sizeof (png_uint_32) == 0)
+                  {
+                     png_uint_32p dp32 = (png_uint_32p)dp;
+                     png_const_uint_32p sp32 = (png_const_uint_32p)sp;
+                     unsigned int skip = (bytes_to_jump-bytes_to_copy) /
+                        sizeof (png_uint_32);
+
+                     do
+                     {
+                        size_t c = bytes_to_copy;
+                        do
+                        {
+                           *dp32++ = *sp32++;
+                           c -= sizeof (png_uint_32);
+                        }
+                        while (c > 0);
+
+                        if (row_width <= bytes_to_jump)
+                           return;
+
+                        dp32 += skip;
+                        sp32 += skip;
+                        row_width -= bytes_to_jump;
+                     }
+                     while (bytes_to_copy <= row_width);
+
+                     /* Get to here when the row_width truncates the final copy.
+                      * There will be 1-3 bytes left to copy, so don't try the
+                      * 16-bit loop below.
+                      */
+                     dp = (png_bytep)dp32;
+                     sp = (png_const_bytep)sp32;
+                     do
+                        *dp++ = *sp++;
+                     while (--row_width > 0);
+                     return;
+                  }
+
+                  /* Else do it in 16-bit quantities, but only if the size is
+                   * not too large.
+                   */
+                  else
+                  {
+                     png_uint_16p dp16 = (png_uint_16p)dp;
+                     png_const_uint_16p sp16 = (png_const_uint_16p)sp;
+                     unsigned int skip = (bytes_to_jump-bytes_to_copy) /
+                        sizeof (png_uint_16);
+
+                     do
+                     {
+                        size_t c = bytes_to_copy;
+                        do
+                        {
+                           *dp16++ = *sp16++;
+                           c -= sizeof (png_uint_16);
+                        }
+                        while (c > 0);
+
+                        if (row_width <= bytes_to_jump)
+                           return;
+
+                        dp16 += skip;
+                        sp16 += skip;
+                        row_width -= bytes_to_jump;
+                     }
+                     while (bytes_to_copy <= row_width);
+
+                     /* End of row - 1 byte left, bytes_to_copy > row_width: */
+                     dp = (png_bytep)dp16;
+                     sp = (png_const_bytep)sp16;
+                     do
+                        *dp++ = *sp++;
+                     while (--row_width > 0);
+                     return;
+                  }
                }
+#endif /* PNG_ALIGN_ code */
 
-               else
-                  shift += s_inc;
+               /* The true default - use a png_memcpy: */
+               for (;;)
+               {
+                  png_memcpy(dp, sp, bytes_to_copy);
 
-               if (m == 1)
-                  m = 0x80;
+                  if (row_width <= bytes_to_jump)
+                     return;
 
-               else
-                  m >>= 1;
-            }
-            break;
+                  sp += bytes_to_jump;
+                  dp += bytes_to_jump;
+                  row_width -= bytes_to_jump;
+                  if (bytes_to_copy > row_width)
+                     bytes_to_copy = row_width;
+               }
          }
 
-         default:
-         {
-            png_bytep sp = png_ptr->row_buf + 1;
-            png_bytep dp = row;
-            png_size_t pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
-            png_uint_32 i;
-            png_uint_32 row_width = png_ptr->width;
-            png_byte m = 0x80;
-
-            for (i = 0; i < row_width; i++)
-            {
-               if (m & mask)
-               {
-                  png_memcpy(dp, sp, pixel_bytes);
-               }
+         /* NOT REACHED*/
+      } /* pixel_depth >= 8 */
 
-               sp += pixel_bytes;
-               dp += pixel_bytes;
+      /* Here if pixel_depth < 8 to check 'end_ptr' below. */
+   }
+   else
+#endif
 
-               if (m == 1)
-                  m = 0x80;
+   /* If here then the switch above wasn't used so just png_memcpy the whole row
+    * from the temporary row buffer (notice that this overwrites the end of the
+    * destination row if it is a partial byte.)
+    */
+   png_memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));
 
-               else
-                  m >>= 1;
-            }
-            break;
-         }
-      }
-   }
+   /* Restore the overwritten bits from the last byte if necessary. */
+   if (end_ptr != NULL)
+      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));
 }
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
 void /* PRIVATE */
-png_do_read_interlace(png_structp png_ptr)
+png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
+   png_uint_32 transformations /* Because these may affect the byte layout */)
 {
-   png_row_infop row_info = &(png_ptr->row_info);
-   png_bytep row = png_ptr->row_buf + 1;
-   int pass = png_ptr->pass;
-   png_uint_32 transformations = png_ptr->transformations;
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
    /* Offset to next interlace block */
-   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    png_debug(1, "in png_do_read_interlace");
    if (row != NULL && row_info != NULL)
@@ -3049,7 +3432,7 @@ png_do_read_interlace(png_structp png_ptr)
 
             for (i = 0; i < row_info->width; i++)
             {
-               png_byte v = (png_byte)((*sp >> sshift) & 0xf);
+               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);
                int j;
 
                for (j = 0; j < jstop; j++)
@@ -3078,6 +3461,7 @@ png_do_read_interlace(png_structp png_ptr)
             }
             break;
          }
+
          default:
          {
             png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
@@ -3108,6 +3492,7 @@ png_do_read_interlace(png_structp png_ptr)
             break;
          }
       }
+
       row_info->width = final_width;
       row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
    }
@@ -3117,132 +3502,252 @@ png_do_read_interlace(png_structp png_ptr)
 }
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 
-void /* PRIVATE */
-png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
-    png_const_bytep prev_row, int filter)
+static void
+png_read_filter_row_sub(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
 {
-   png_debug(1, "in png_read_filter_row");
-   png_debug2(2, "row = %u, filter = %d", png_ptr->row_number, filter);
-   switch (filter)
+   png_size_t i;
+   png_size_t istop = row_info->rowbytes;
+   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
+   png_bytep rp = row + bpp;
+
+   PNG_UNUSED(prev_row)
+
+   for (i = bpp; i < istop; i++)
    {
-      case PNG_FILTER_VALUE_NONE:
-         break;
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+}
 
-      case PNG_FILTER_VALUE_SUB:
-      {
-         png_size_t i;
-         png_size_t istop = row_info->rowbytes;
-         unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
-         png_bytep rp = row + bpp;
-         png_bytep lp = row;
+static void
+png_read_filter_row_up(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+   png_size_t i;
+   png_size_t istop = row_info->rowbytes;
+   png_bytep rp = row;
+   png_const_bytep pp = prev_row;
 
-         for (i = bpp; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
-            rp++;
-         }
-         break;
-      }
-      case PNG_FILTER_VALUE_UP:
-      {
-         png_size_t i;
-         png_size_t istop = row_info->rowbytes;
-         png_bytep rp = row;
-         png_const_bytep pp = prev_row;
+   for (i = 0; i < istop; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+      rp++;
+   }
+}
 
-         for (i = 0; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
-            rp++;
-         }
-         break;
-      }
-      case PNG_FILTER_VALUE_AVG:
-      {
-         png_size_t i;
-         png_bytep rp = row;
-         png_const_bytep pp = prev_row;
-         png_bytep lp = row;
-         unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
-         png_size_t istop = row_info->rowbytes - bpp;
-
-         for (i = 0; i < bpp; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) +
-                ((int)(*pp++) / 2 )) & 0xff);
+static void
+png_read_filter_row_avg(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+   png_size_t i;
+   png_bytep rp = row;
+   png_const_bytep pp = prev_row;
+   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
+   png_size_t istop = row_info->rowbytes - bpp;
 
-            rp++;
-         }
+   for (i = 0; i < bpp; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         ((int)(*pp++) / 2 )) & 0xff);
 
-         for (i = 0; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) +
-                (int)(*pp++ + *lp++) / 2 ) & 0xff);
+      rp++;
+   }
 
-            rp++;
-         }
-         break;
-      }
-      case PNG_FILTER_VALUE_PAETH:
-      {
-         png_size_t i;
-         png_bytep rp = row;
-         png_const_bytep pp = prev_row;
-         png_bytep lp = row;
-         png_const_bytep cp = prev_row;
-         unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
-         png_size_t istop=row_info->rowbytes - bpp;
-
-         for (i = 0; i < bpp; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
-            rp++;
-         }
+   for (i = 0; i < istop; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
 
-         for (i = 0; i < istop; i++)   /* Use leftover rp,pp */
-         {
-            int a, b, c, pa, pb, pc, p;
+      rp++;
+   }
+}
 
-            a = *lp++;
-            b = *pp++;
-            c = *cp++;
+static void
+png_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+   png_bytep rp_end = row + row_info->rowbytes;
+   int a, c;
 
-            p = b - c;
-            pc = a - c;
+   /* First pixel/byte */
+   c = *prev_row++;
+   a = *row + c;
+   *row++ = (png_byte)a;
 
-#ifdef PNG_USE_ABS
-            pa = abs(p);
-            pb = abs(pc);
-            pc = abs(p + pc);
-#else
-            pa = p < 0 ? -p : p;
-            pb = pc < 0 ? -pc : pc;
-            pc = (p + pc) < 0 ? -(p + pc) : p + pc;
-#endif
+   /* Remainder */
+   while (row < rp_end)
+   {
+      int b, pa, pb, pc, p;
 
-            /*
-               if (pa <= pb && pa <= pc)
-                  p = a;
+      a &= 0xff; /* From previous iteration or start */
+      b = *prev_row++;
 
-               else if (pb <= pc)
-                  p = b;
+      p = b - c;
+      pc = a - c;
 
-               else
-                  p = c;
-             */
+#     ifdef PNG_USE_ABS
+         pa = abs(p);
+         pb = abs(pc);
+         pc = abs(p + pc);
+#     else
+         pa = p < 0 ? -p : p;
+         pb = pc < 0 ? -pc : pc;
+         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#     endif
 
-            p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;
+      /* Find the best predictor, the least of pa, pb, pc favoring the earlier
+       * ones in the case of a tie.
+       */
+      if (pb < pa) pa = pb, a = b;
+      if (pc < pa) a = c;
 
-            *rp = (png_byte)(((int)(*rp) + p) & 0xff);
-            rp++;
-         }
+      /* Calculate the current pixel in a, and move the previous row pixel to c
+       * for the next time round the loop
+       */
+      c = b;
+      a += *row;
+      *row++ = (png_byte)a;
+   }
+}
+
+static void
+png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+   int bpp = (row_info->pixel_depth + 7) >> 3;
+   png_bytep rp_end = row + bpp;
+
+   /* Process the first pixel in the row completely (this is the same as 'up'
+    * because there is only one candidate predictor for the first row).
+    */
+   while (row < rp_end)
+   {
+      int a = *row + *prev_row++;
+      *row++ = (png_byte)a;
+   }
+
+   /* Remainder */
+   rp_end += row_info->rowbytes - bpp;
+
+   while (row < rp_end)
+   {
+      int a, b, c, pa, pb, pc, p;
+
+      c = *(prev_row - bpp);
+      a = *(row - bpp);
+      b = *prev_row++;
+
+      p = b - c;
+      pc = a - c;
+
+#     ifdef PNG_USE_ABS
+         pa = abs(p);
+         pb = abs(pc);
+         pc = abs(p + pc);
+#     else
+         pa = p < 0 ? -p : p;
+         pb = pc < 0 ? -pc : pc;
+         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#     endif
+
+      if (pb < pa) pa = pb, a = b;
+      if (pc < pa) a = c;
+
+      c = b;
+      a += *row;
+      *row++ = (png_byte)a;
+   }
+}
+
+#ifdef PNG_ARM_NEON
+
+#ifdef __linux__
+#include <stdio.h>
+#include <elf.h>
+#include <asm/hwcap.h>
+
+static int png_have_hwcap(unsigned cap)
+{
+   FILE *f = fopen("/proc/self/auxv", "r");
+   Elf32_auxv_t aux;
+   int have_cap = 0;
+
+   if (!f)
+      return 0;
+
+   while (fread(&aux, sizeof(aux), 1, f) > 0)
+   {
+      if (aux.a_type == AT_HWCAP &&
+          aux.a_un.a_val & cap)
+      {
+         have_cap = 1;
          break;
       }
-      default:
-         png_error(png_ptr, "Ignoring bad adaptive filter type");
-         /*NOT REACHED */
-         break;
    }
+
+   fclose(f);
+
+   return have_cap;
+}
+#endif /* __linux__ */
+
+static void
+png_init_filter_functions_neon(png_structp pp, unsigned int bpp)
+{
+#ifdef __linux__
+   if (!png_have_hwcap(HWCAP_NEON))
+      return;
+#endif
+
+   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_neon;
+
+   if (bpp == 3)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_neon;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_neon;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = 
+         png_read_filter_row_paeth3_neon;
+   }
+
+   else if (bpp == 4)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_neon;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_neon;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
+          png_read_filter_row_paeth4_neon;
+   }
+}
+#endif /* PNG_ARM_NEON */
+
+static void
+png_init_filter_functions(png_structp pp)
+{
+   unsigned int bpp = (pp->pixel_depth + 7) >> 3;
+
+   pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;
+   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;
+   pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;
+   if (bpp == 1)
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
+         png_read_filter_row_paeth_1byte_pixel;
+   else
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
+         png_read_filter_row_paeth_multibyte_pixel;
+
+#ifdef PNG_ARM_NEON
+   png_init_filter_functions_neon(pp, bpp);
+#endif
+}
+
+void /* PRIVATE */
+png_read_filter_row(png_structp pp, png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row, int filter)
+{
+   if (pp->read_filter[0] == NULL)
+      png_init_filter_functions(pp);
+   if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)
+      pp->read_filter[filter-1](row_info, row, prev_row);
 }
 
 #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
@@ -3253,16 +3758,16 @@ png_read_finish_row(png_structp png_ptr)
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 
    png_debug(1, "in png_read_finish_row");
@@ -3275,6 +3780,9 @@ png_read_finish_row(png_structp png_ptr)
    {
       png_ptr->row_number = 0;
 
+      /* TO DO: don't do this if prev_row isn't needed (requires
+       * read-ahead of the next row's filter byte.
+       */
       png_memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
 
       do
@@ -3309,7 +3817,6 @@ png_read_finish_row(png_structp png_ptr)
 
    if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
    {
-      PNG_IDAT;
       char extra;
       int ret;
 
@@ -3324,7 +3831,7 @@ png_read_finish_row(png_structp png_ptr)
             {
                png_crc_finish(png_ptr, 0);
                png_ptr->idat_size = png_read_chunk_header(png_ptr);
-               if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+               if (png_ptr->chunk_name != png_IDAT)
                   png_error(png_ptr, "Not enough image data");
             }
 
@@ -3383,16 +3890,16 @@ png_read_start_row(png_structp png_ptr)
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
 
    int max_pixel_depth;
@@ -3400,7 +3907,9 @@ png_read_start_row(png_structp png_ptr)
 
    png_debug(1, "in png_read_start_row");
    png_ptr->zstream.avail_in = 0;
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
    png_init_read_transformations(png_ptr);
+#endif
 #ifdef PNG_READ_INTERLACING_SUPPORTED
    if (png_ptr->interlaced)
    {
@@ -3426,6 +3935,16 @@ png_read_start_row(png_structp png_ptr)
 
    max_pixel_depth = png_ptr->pixel_depth;
 
+   /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpliar set of
+    * calculations to calculate the final pixel depth, then
+    * png_do_read_transforms actually does the transforms.  This means that the
+    * code which effectively calculates this value is actually repeated in three
+    * separate places.  They must all match.  Innocent changes to the order of
+    * transformations can and will break libpng in a way that causes memory
+    * overwrites.
+    *
+    * TODO: fix this.
+    */
 #ifdef PNG_READ_PACK_SUPPORTED
    if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)
       max_pixel_depth = 8;
@@ -3463,13 +3982,28 @@ png_read_start_row(png_structp png_ptr)
    }
 #endif
 
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+   if (png_ptr->transformations & PNG_EXPAND_16)
+   {
+#     ifdef PNG_READ_EXPAND_SUPPORTED
+         /* In fact it is an error if it isn't supported, but checking is
+          * the safe way.
+          */
+         if (png_ptr->transformations & PNG_EXPAND)
+         {
+            if (png_ptr->bit_depth < 16)
+               max_pixel_depth *= 2;
+         }
+         else
+#     endif
+         png_ptr->transformations &= ~PNG_EXPAND_16;
+   }
+#endif
+
 #ifdef PNG_READ_FILLER_SUPPORTED
    if (png_ptr->transformations & (PNG_FILLER))
    {
-      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-         max_pixel_depth = 32;
-
-      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
+      if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
       {
          if (max_pixel_depth <= 8)
             max_pixel_depth = 16;
@@ -3478,7 +4012,8 @@ png_read_start_row(png_structp png_ptr)
             max_pixel_depth = 32;
       }
 
-      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
+      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB ||
+         png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
       {
          if (max_pixel_depth <= 32)
             max_pixel_depth = 32;
@@ -3532,14 +4067,20 @@ png_read_start_row(png_structp png_ptr)
 defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    if (png_ptr->transformations & PNG_USER_TRANSFORM)
    {
-      int user_pixel_depth = png_ptr->user_transform_depth*
+      int user_pixel_depth = png_ptr->user_transform_depth *
          png_ptr->user_transform_channels;
 
       if (user_pixel_depth > max_pixel_depth)
-         max_pixel_depth=user_pixel_depth;
+         max_pixel_depth = user_pixel_depth;
    }
 #endif
 
+   /* This value is stored in png_struct and double checked in the row read
+    * code.
+    */
+   png_ptr->maximum_pixel_depth = (png_byte)max_pixel_depth;
+   png_ptr->transformed_pixel_depth = 0; /* calculated on demand */
+
    /* Align the width on the next larger 8 pixels.  Mainly used
     * for interlacing
     */
@@ -3558,28 +4099,39 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    if (row_bytes + 48 > png_ptr->old_big_row_buf_size)
    {
      png_free(png_ptr, png_ptr->big_row_buf);
+     png_free(png_ptr, png_ptr->big_prev_row);
 
      if (png_ptr->interlaced)
         png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,
             row_bytes + 48);
 
      else
-        png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr,
-            row_bytes + 48);
+        png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes + 48);
 
-     png_ptr->old_big_row_buf_size = row_bytes + 48;
+     png_ptr->big_prev_row = (png_bytep)png_malloc(png_ptr, row_bytes + 48);
 
 #ifdef PNG_ALIGNED_MEMORY_SUPPORTED
      /* Use 16-byte aligned memory for row_buf with at least 16 bytes
-      * of padding before and after row_buf.
+      * of padding before and after row_buf; treat prev_row similarly.
+      * NOTE: the alignment is to the start of the pixels, one beyond the start
+      * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this
+      * was incorrect; the filter byte was aligned, which had the exact
+      * opposite effect of that intended.
       */
-     png_ptr->row_buf = png_ptr->big_row_buf + 32 -
-         (((png_alloc_size_t)png_ptr->big_row_buf + 15) & 0x0F);
+     {
+        png_bytep temp = png_ptr->big_row_buf + 32;
+        int extra = (int)((temp - (png_bytep)0) & 0x0f);
+        png_ptr->row_buf = temp - extra - 1/*filter byte*/;
+
+        temp = png_ptr->big_prev_row + 32;
+        extra = (int)((temp - (png_bytep)0) & 0x0f);
+        png_ptr->prev_row = temp - extra - 1/*filter byte*/;
+     }
 
-     png_ptr->old_big_row_buf_size = row_bytes + 48;
 #else
-     /* Use 32 bytes of padding before and 16 bytes after row_buf. */
-     png_ptr->row_buf = png_ptr->big_row_buf + 32;
+     /* Use 31 bytes of padding before and 17 bytes after row_buf. */
+     png_ptr->row_buf = png_ptr->big_row_buf + 31;
+     png_ptr->prev_row = png_ptr->big_prev_row + 31;
 #endif
      png_ptr->old_big_row_buf_size = row_bytes + 48;
    }
@@ -3592,15 +4144,6 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    if (png_ptr->rowbytes > (PNG_SIZE_MAX - 1))
       png_error(png_ptr, "Row has too many bytes to allocate in memory");
 
-   if (png_ptr->rowbytes + 1 > png_ptr->old_prev_row_size)
-   {
-      png_free(png_ptr, png_ptr->prev_row);
-
-      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, png_ptr->rowbytes + 1);
-
-      png_ptr->old_prev_row_size = png_ptr->rowbytes + 1;
-   }
-
    png_memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
 
    png_debug1(3, "width = %u,", png_ptr->width);
diff --git a/src/3rdparty/libpng/pngset.c b/src/3rdparty/libpng/pngset.c
index 2cfcf33..e0118fa 100644
--- a/src/3rdparty/libpng/pngset.c
+++ b/src/3rdparty/libpng/pngset.c
@@ -1,8 +1,8 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [(PENDING RELEASE)]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -64,6 +64,39 @@ png_set_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
    }
 }
 
+void PNGFAPI
+png_set_cHRM_XYZ_fixed(png_structp png_ptr, png_infop info_ptr,
+    png_fixed_point int_red_X, png_fixed_point int_red_Y,
+    png_fixed_point int_red_Z, png_fixed_point int_green_X,
+    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
+    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
+    png_fixed_point int_blue_Z)
+{
+   png_XYZ XYZ;
+   png_xy xy;
+
+   png_debug1(1, "in %s storage function", "cHRM XYZ fixed");
+
+   if (png_ptr == NULL || info_ptr == NULL)
+      return;
+
+   XYZ.redX = int_red_X;
+   XYZ.redY = int_red_Y;
+   XYZ.redZ = int_red_Z;
+   XYZ.greenX = int_green_X;
+   XYZ.greenY = int_green_Y;
+   XYZ.greenZ = int_green_Z;
+   XYZ.blueX = int_blue_X;
+   XYZ.blueY = int_blue_Y;
+   XYZ.blueZ = int_blue_Z;
+
+   if (png_xy_from_XYZ(&xy, XYZ))
+      png_error(png_ptr, "XYZ values out of representable range");
+
+   png_set_cHRM_fixed(png_ptr, info_ptr, xy.whitex, xy.whitey, xy.redx, xy.redy,
+      xy.greenx, xy.greeny, xy.bluex, xy.bluey);
+}
+
 #  ifdef PNG_FLOATING_POINT_SUPPORTED
 void PNGAPI
 png_set_cHRM(png_structp png_ptr, png_infop info_ptr,
@@ -80,6 +113,23 @@ png_set_cHRM(png_structp png_ptr, png_infop info_ptr,
       png_fixed(png_ptr, blue_x, "cHRM Blue X"),
       png_fixed(png_ptr, blue_y, "cHRM Blue Y"));
 }
+
+void PNGAPI
+png_set_cHRM_XYZ(png_structp png_ptr, png_infop info_ptr, double red_X,
+    double red_Y, double red_Z, double green_X, double green_Y, double green_Z,
+    double blue_X, double blue_Y, double blue_Z)
+{
+   png_set_cHRM_XYZ_fixed(png_ptr, info_ptr,
+      png_fixed(png_ptr, red_X, "cHRM Red X"),
+      png_fixed(png_ptr, red_Y, "cHRM Red Y"),
+      png_fixed(png_ptr, red_Z, "cHRM Red Z"),
+      png_fixed(png_ptr, green_X, "cHRM Red X"),
+      png_fixed(png_ptr, green_Y, "cHRM Red Y"),
+      png_fixed(png_ptr, green_Z, "cHRM Red Z"),
+      png_fixed(png_ptr, blue_X, "cHRM Red X"),
+      png_fixed(png_ptr, blue_Y, "cHRM Red Y"),
+      png_fixed(png_ptr, blue_Z, "cHRM Red Z"));
+}
 #  endif /* PNG_FLOATING_POINT_SUPPORTED */
 
 #endif /* PNG_cHRM_SUPPORTED */
@@ -94,15 +144,16 @@ png_set_gAMA_fixed(png_structp png_ptr, png_infop info_ptr, png_fixed_point
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-   /* Previously these values were limited, however they must be
-    * wrong, therefore storing them (and setting PNG_INFO_gAMA)
-    * must be wrong too.
+   /* Changed in libpng-1.5.4 to limit the values to ensure overflow can't
+    * occur.  Since the fixed point representation is assymetrical it is
+    * possible for 1/gamma to overflow the limit of 21474 and this means the
+    * gamma value must be at least 5/100000 and hence at most 20000.0.  For
+    * safety the limits here are a little narrower.  The values are 0.00016 to
+    * 6250.0, which are truly ridiculous gammma values (and will produce
+    * displays that are all black or all white.)
     */
-   if (file_gamma > (png_fixed_point)PNG_UINT_31_MAX)
-      png_warning(png_ptr, "Gamma too large, ignored");
-
-   else if (file_gamma <= 0)
-      png_warning(png_ptr, "Negative or zero gamma ignored");
+   if (file_gamma < 16 || file_gamma > 625000000)
+      png_warning(png_ptr, "Out of range gamma value ignored");
 
    else
    {
@@ -340,12 +391,12 @@ png_set_sCAL_s(png_structp png_ptr, png_infop info_ptr,
    if (unit != 1 && unit != 2)
       png_error(png_ptr, "Invalid sCAL unit");
 
-   if (swidth == NULL || (lengthw = png_strlen(swidth)) <= 0 ||
-       swidth[0] == 45 /*'-'*/ || !png_check_fp_string(swidth, lengthw))
+   if (swidth == NULL || (lengthw = png_strlen(swidth)) == 0 ||
+       swidth[0] == 45 /* '-' */ || !png_check_fp_string(swidth, lengthw))
       png_error(png_ptr, "Invalid sCAL width");
 
-   if (sheight == NULL || (lengthh = png_strlen(sheight)) <= 0 ||
-       sheight[0] == 45 /*'-'*/ || !png_check_fp_string(sheight, lengthh))
+   if (sheight == NULL || (lengthh = png_strlen(sheight)) == 0 ||
+       sheight[0] == 45 /* '-' */ || !png_check_fp_string(sheight, lengthh))
       png_error(png_ptr, "Invalid sCAL height");
 
    info_ptr->scal_unit = (png_byte)unit;
@@ -545,16 +596,16 @@ png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr, png_infop info_ptr,
    png_set_sRGB(png_ptr, info_ptr, srgb_intent);
 
 #  ifdef PNG_gAMA_SUPPORTED
-   png_set_gAMA_fixed(png_ptr, info_ptr, 45455L);
+   png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_sRGB_INVERSE);
 #  endif
 
 #  ifdef PNG_cHRM_SUPPORTED
    png_set_cHRM_fixed(png_ptr, info_ptr,
       /* color      x       y */
-      /* white */ 31270L, 32900L,
-      /* red   */ 64000L, 33000L,
-      /* green */ 30000L, 60000L,
-      /* blue  */ 15000L,  6000L
+      /* white */ 31270, 32900,
+      /* red   */ 64000, 33000,
+      /* green */ 30000, 60000,
+      /* blue  */ 15000,  6000
    );
 #  endif /* cHRM */
 }
@@ -569,7 +620,7 @@ png_set_iCCP(png_structp png_ptr, png_infop info_ptr,
 {
    png_charp new_iccp_name;
    png_bytep new_iccp_profile;
-   png_uint_32 length;
+   png_size_t length;
 
    png_debug1(1, "in %s storage function", "iCCP");
 
@@ -630,9 +681,8 @@ png_set_text_2(png_structp png_ptr, png_infop info_ptr,
 {
    int i;
 
-   png_debug1(1, "in %s storage function", ((png_ptr == NULL ||
-       png_ptr->chunk_name[0] == '\0') ?
-       "text" : (png_const_charp)png_ptr->chunk_name));
+   png_debug1(1, "in %lx storage function", png_ptr == NULL ? "unexpected" :
+      (unsigned long)png_ptr->chunk_name);
 
    if (png_ptr == NULL || info_ptr == NULL || num_text == 0)
       return(0);
@@ -642,24 +692,28 @@ png_set_text_2(png_structp png_ptr, png_infop info_ptr,
     */
    if (info_ptr->num_text + num_text > info_ptr->max_text)
    {
+      int old_max_text = info_ptr->max_text;
+      int old_num_text = info_ptr->num_text;
+
       if (info_ptr->text != NULL)
       {
          png_textp old_text;
-         int old_max;
 
-         old_max = info_ptr->max_text;
          info_ptr->max_text = info_ptr->num_text + num_text + 8;
          old_text = info_ptr->text;
+
          info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
             (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));
 
          if (info_ptr->text == NULL)
          {
-            png_free(png_ptr, old_text);
+            /* Restore to previous condition */
+            info_ptr->max_text = old_max_text;
+            info_ptr->text = old_text;
             return(1);
          }
 
-         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *
+         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max_text *
              png_sizeof(png_text)));
          png_free(png_ptr, old_text);
       }
@@ -671,7 +725,12 @@ png_set_text_2(png_structp png_ptr, png_infop info_ptr,
          info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
              (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));
          if (info_ptr->text == NULL)
+         {
+            /* Restore to previous condition */
+            info_ptr->num_text = old_num_text;
+            info_ptr->max_text = old_max_text;
             return(1);
+         }
          info_ptr->free_me |= PNG_FREE_TEXT;
       }
 
@@ -814,6 +873,15 @@ png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_const_timep mod_time)
        (png_ptr->mode & PNG_WROTE_tIME))
       return;
 
+   if (mod_time->month == 0   || mod_time->month > 12  ||
+       mod_time->day   == 0   || mod_time->day   > 31  ||
+       mod_time->hour  > 23   || mod_time->minute > 59 ||
+       mod_time->second > 60)
+   {
+      png_warning(png_ptr, "Ignoring invalid time value");
+      return;
+   }
+
    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }
@@ -915,10 +983,10 @@ png_set_sPLT(png_structp png_ptr,
    {
       png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
       png_const_sPLT_tp from = entries + i;
-      png_uint_32 length;
+      png_size_t length;
 
       length = png_strlen(from->name) + 1;
-      to->name = (png_charp)png_malloc_warn(png_ptr, (png_size_t)length);
+      to->name = (png_charp)png_malloc_warn(png_ptr, length);
 
       if (to->name == NULL)
       {
@@ -929,7 +997,7 @@ png_set_sPLT(png_structp png_ptr,
 
       png_memcpy(to->name, from->name, length);
       to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
-          (png_size_t)(from->nentries * png_sizeof(png_sPLT_entry)));
+          from->nentries * png_sizeof(png_sPLT_entry));
 
       if (to->entries == NULL)
       {
@@ -1222,4 +1290,20 @@ png_set_benign_errors(png_structp png_ptr, int allowed)
       png_ptr->flags &= ~PNG_FLAG_BENIGN_ERRORS_WARN;
 }
 #endif /* PNG_BENIGN_ERRORS_SUPPORTED */
+
+#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   /* Do not report invalid palette index; added at libng-1.5.10 */
+void PNGAPI
+png_set_check_for_invalid_index(png_structp png_ptr, int allowed)
+{
+   png_debug(1, "in png_set_check_for_invalid_index");
+
+   if (allowed)
+      png_ptr->num_palette_max = 0;
+
+   else
+      png_ptr->num_palette_max = -1;
+}
+#endif
+
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff --git a/src/3rdparty/libpng/pngstruct.h b/src/3rdparty/libpng/pngstruct.h
index 8d781fa..43a45cd 100644
--- a/src/3rdparty/libpng/pngstruct.h
+++ b/src/3rdparty/libpng/pngstruct.h
@@ -5,7 +5,7 @@
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
- * Last changed in libpng 1.5.0 [January 6, 2011]
+ * Last changed in libpng 1.5.9 [March 29, 2012]
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -29,11 +29,13 @@
 struct png_struct_def
 {
 #ifdef PNG_SETJMP_SUPPORTED
-   jmp_buf png_jmpbuf;            /* used in png_error */
+   jmp_buf longjmp_buffer;    /* used in png_error */
    png_longjmp_ptr longjmp_fn;/* setjmp non-local goto function. */
 #endif
    png_error_ptr error_fn;    /* function for printing errors and aborting */
+#ifdef PNG_WARNINGS_SUPPORTED
    png_error_ptr warning_fn;  /* function for printing warnings */
+#endif
    png_voidp error_ptr;       /* user supplied struct for error functions */
    png_rw_ptr write_data_fn;  /* function for writing output data */
    png_rw_ptr read_data_fn;   /* function for reading input data */
@@ -64,11 +66,36 @@ struct png_struct_def
    z_stream zstream;          /* pointer to decompression structure (below) */
    png_bytep zbuf;            /* buffer for zlib */
    uInt zbuf_size;            /* size of zbuf (typically 65536) */
+#ifdef PNG_WRITE_SUPPORTED
+
+/* Added in 1.5.4: state to keep track of whether the zstream has been
+ * initialized and if so whether it is for IDAT or some other chunk.
+ */
+#define PNG_ZLIB_UNINITIALIZED 0
+#define PNG_ZLIB_FOR_IDAT      1
+#define PNG_ZLIB_FOR_TEXT      2 /* anything other than IDAT */
+#define PNG_ZLIB_USE_MASK      3 /* bottom two bits */
+#define PNG_ZLIB_IN_USE        4 /* a flag value */
+
+   png_uint_32 zlib_state;       /* State of zlib initialization */
+/* End of material added at libpng 1.5.4 */
+
    int zlib_level;            /* holds zlib compression level */
    int zlib_method;           /* holds zlib compression method */
    int zlib_window_bits;      /* holds zlib compression window bits */
    int zlib_mem_level;        /* holds zlib compression memory level */
    int zlib_strategy;         /* holds zlib compression strategy */
+#endif
+/* Added at libpng 1.5.4 */
+#if defined(PNG_WRITE_COMPRESSED_TEXT_SUPPORTED) || \
+    defined(PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED)
+   int zlib_text_level;            /* holds zlib compression level */
+   int zlib_text_method;           /* holds zlib compression method */
+   int zlib_text_window_bits;      /* holds zlib compression window bits */
+   int zlib_text_mem_level;        /* holds zlib compression memory level */
+   int zlib_text_strategy;         /* holds zlib compression strategy */
+#endif
+/* End of material added at libpng 1.5.4 */
 
    png_uint_32 width;         /* width of image in pixels */
    png_uint_32 height;        /* height of image in pixels */
@@ -77,20 +104,30 @@ struct png_struct_def
    png_size_t rowbytes;       /* size of row in bytes */
    png_uint_32 iwidth;        /* width of current interlaced row in pixels */
    png_uint_32 row_number;    /* current row in interlace pass */
-   png_bytep prev_row;        /* buffer to save previous (unfiltered) row */
-   png_bytep row_buf;         /* buffer to save current (unfiltered) row */
+   png_uint_32 chunk_name;    /* PNG_CHUNK() id of current chunk */
+   png_bytep prev_row;        /* buffer to save previous (unfiltered) row.
+                               * This is a pointer into big_prev_row
+                               */
+   png_bytep row_buf;         /* buffer to save current (unfiltered) row.
+                               * This is a pointer into big_row_buf
+                               */
    png_bytep sub_row;         /* buffer to save "sub" row when filtering */
    png_bytep up_row;          /* buffer to save "up" row when filtering */
    png_bytep avg_row;         /* buffer to save "avg" row when filtering */
    png_bytep paeth_row;       /* buffer to save "Paeth" row when filtering */
-   png_row_info row_info;     /* used for transformation routines */
+   png_size_t info_rowbytes;  /* Added in 1.5.4: cache of updated row bytes */
 
    png_uint_32 idat_size;     /* current IDAT size for read */
    png_uint_32 crc;           /* current chunk CRC value */
    png_colorp palette;        /* palette from the input file */
    png_uint_16 num_palette;   /* number of color entries in palette */
+
+/* Added at libpng-1.5.10 */
+#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   int num_palette_max;       /* maximum palette index found in IDAT */
+#endif
+
    png_uint_16 num_trans;     /* number of transparency values */
-   png_byte chunk_name[5];    /* null-terminated name of current chunk */
    png_byte compression;      /* file compression type (always 0) */
    png_byte filter;           /* file filter type (always 0) */
    png_byte interlaced;       /* PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */
@@ -98,17 +135,24 @@ struct png_struct_def
    png_byte do_filter;        /* row filter flags (see PNG_FILTER_ below ) */
    png_byte color_type;       /* color type of file */
    png_byte bit_depth;        /* bit depth of file */
-   png_byte usr_bit_depth;    /* bit depth of users row */
+   png_byte usr_bit_depth;    /* bit depth of users row: write only */
    png_byte pixel_depth;      /* number of bits per pixel */
    png_byte channels;         /* number of channels in file */
-   png_byte usr_channels;     /* channels at start of write */
+   png_byte usr_channels;     /* channels at start of write: write only */
    png_byte sig_bytes;        /* magic bytes read/written from start of file */
+   png_byte maximum_pixel_depth;
+                              /* pixel depth used for the row buffers */
+   png_byte transformed_pixel_depth;
+                              /* pixel depth after read/write transforms */
+   png_byte io_chunk_string[5];
+                              /* string name of chunk */
 
 #if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
    png_uint_16 filler;           /* filler bytes for pixel expansion */
 #endif
 
-#ifdef PNG_bKGD_SUPPORTED
+#if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
    png_byte background_gamma_type;
    png_fixed_point background_gamma;
    png_color_16 background;   /* background color in screen gamma space */
@@ -123,19 +167,21 @@ struct png_struct_def
    png_uint_32 flush_rows;    /* number of rows written since last flush */
 #endif
 
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
+#ifdef PNG_READ_GAMMA_SUPPORTED
    int gamma_shift;      /* number of "insignificant" bits in 16-bit gamma */
    png_fixed_point gamma;        /* file gamma value */
    png_fixed_point screen_gamma; /* screen gamma value (display_exponent) */
-#endif
 
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
    png_bytep gamma_table;     /* gamma table for 8-bit depth files */
+   png_uint_16pp gamma_16_table; /* gamma table for 16-bit depth files */
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
+   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
    png_bytep gamma_from_1;    /* converts from 1.0 to screen */
    png_bytep gamma_to_1;      /* converts from file to 1.0 */
-   png_uint_16pp gamma_16_table; /* gamma table for 16-bit depth files */
    png_uint_16pp gamma_16_from_1; /* converts from 1.0 to screen */
    png_uint_16pp gamma_16_to_1; /* converts from file to 1.0 */
+#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
 #endif
 
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_sBIT_SUPPORTED)
@@ -171,13 +217,6 @@ struct png_struct_def
    int process_mode;                 /* what push library is currently doing */
    int cur_palette;                  /* current push library palette index */
 
-#  ifdef PNG_TEXT_SUPPORTED
-     png_size_t current_text_size;   /* current size of text input data */
-     png_size_t current_text_left;   /* how much text left to read in input */
-     png_charp current_text;         /* current text chunk buffer */
-     png_charp current_text_ptr;     /* current location in current_text */
-#  endif /* PNG_PROGRESSIVE_READ_SUPPORTED && PNG_TEXT_SUPPORTED */
-
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 
 #if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
@@ -209,7 +248,7 @@ struct png_struct_def
 #endif
 
 #ifdef PNG_TIME_RFC1123_SUPPORTED
-   png_charp time_buffer; /* String to hold RFC 1123 time text */
+   char time_buffer[29]; /* String to hold RFC 1123 time text */
 #endif
 
 /* New members added in libpng-1.0.6 */
@@ -226,19 +265,24 @@ struct png_struct_def
    png_bytep chunk_list;
 #endif
 
+#ifdef PNG_READ_sRGB_SUPPORTED
+   /* Added in 1.5.5 to record an sRGB chunk in the png. */
+   png_byte is_sRGB;
+#endif
+
 /* New members added in libpng-1.0.3 */
 #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
    png_byte rgb_to_gray_status;
+   /* Added in libpng 1.5.5 to record setting of coefficients: */
+   png_byte rgb_to_gray_coefficients_set;
    /* These were changed from png_byte in libpng-1.0.6 */
    png_uint_16 rgb_to_gray_red_coeff;
    png_uint_16 rgb_to_gray_green_coeff;
-   png_uint_16 rgb_to_gray_blue_coeff;
+   /* deleted in 1.5.5: rgb_to_gray_blue_coeff; */
 #endif
 
 /* New member added in libpng-1.0.4 (renamed in 1.0.9) */
-#if defined(PNG_MNG_FEATURES_SUPPORTED) || \
-    defined(PNG_READ_EMPTY_PLTE_SUPPORTED) || \
-    defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED)
+#if defined(PNG_MNG_FEATURES_SUPPORTED)
 /* Changed from png_byte to png_uint_32 at version 1.2.0 */
    png_uint_32 mng_features_permitted;
 #endif
@@ -293,9 +337,8 @@ struct png_struct_def
    png_unknown_chunk unknown_chunk;
 #endif
 
-/* New members added in libpng-1.2.26 */
+/* New member added in libpng-1.2.26 */
   png_size_t old_big_row_buf_size;
-  png_size_t old_prev_row_size;
 
 /* New member added in libpng-1.2.30 */
   png_charp chunkdata;  /* buffer for reading chunk data */
@@ -304,5 +347,11 @@ struct png_struct_def
 /* New member added in libpng-1.4.0 */
    png_uint_32 io_state;
 #endif
+
+/* New member added in libpng-1.5.6 */
+   png_bytep big_prev_row;
+
+   void (*read_filter[PNG_FILTER_VALUE_LAST-1])(png_row_infop row_info,
+      png_bytep row, png_const_bytep prev_row);
 };
 #endif /* PNGSTRUCT_H */
diff --git a/src/3rdparty/libpng/pngtest.c b/src/3rdparty/libpng/pngtest.c
deleted file mode 100644
index cbb7eb2..0000000
--- a/src/3rdparty/libpng/pngtest.c
+++ /dev/null
@@ -1,1787 +0,0 @@
-
-/* pngtest.c - a simple test program to test libpng
- *
- * Last changed in libpng 1.5.0 [January 6, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This program reads in a PNG image, writes it out again, and then
- * compares the two files.  If the files are identical, this shows that
- * the basic chunk handling, filtering, and (de)compression code is working
- * properly.  It does not currently test all of the transforms, although
- * it probably should.
- *
- * The program will report "FAIL" in certain legitimate cases:
- * 1) when the compression level or filter selection method is changed.
- * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.
- * 3) unknown unsafe-to-copy ancillary chunks or unknown critical chunks
- *    exist in the input file.
- * 4) others not listed here...
- * In these cases, it is best to check with another tool such as "pngcheck"
- * to see what the differences between the two files are.
- *
- * If a filename is given on the command-line, then this file is used
- * for the input, rather than the default "pngtest.png".  This allows
- * testing a wide variety of files easily.  You can also test a number
- * of files at once by typing "pngtest -m file1.png file2.png ..."
- */
-
-#include "zlib.h"
-#include "png.h"
-/* Copied from pngpriv.h but only used in error messages below. */
-#ifndef PNG_ZBUF_SIZE
-#  define PNG_ZBUF_SIZE 8192
-#endif
-#  include <stdio.h>
-#  include <stdlib.h>
-#  include <string.h>
-#  define FCLOSE(file) fclose(file)
-
-#ifndef PNG_STDIO_SUPPORTED
-typedef FILE                * png_FILE_p;
-#endif
-
-/* Makes pngtest verbose so we can find problems. */
-#ifndef PNG_DEBUG
-#  define PNG_DEBUG 0
-#endif
-
-#if PNG_DEBUG > 1
-#  define pngtest_debug(m)        ((void)fprintf(stderr, m "\n"))
-#  define pngtest_debug1(m,p1)    ((void)fprintf(stderr, m "\n", p1))
-#  define pngtest_debug2(m,p1,p2) ((void)fprintf(stderr, m "\n", p1, p2))
-#else
-#  define pngtest_debug(m)        ((void)0)
-#  define pngtest_debug1(m,p1)    ((void)0)
-#  define pngtest_debug2(m,p1,p2) ((void)0)
-#endif
-
-#if !PNG_DEBUG
-#  define SINGLE_ROWBUF_ALLOC  /* Makes buffer overruns easier to nail */
-#endif
-
-/* The code uses memcmp and memcpy on large objects (typically row pointers) so
- * it is necessary to do soemthing special on certain architectures, note that
- * the actual support for this was effectively removed in 1.4, so only the
- * memory remains in this program:
- */
-#define CVT_PTR(ptr)         (ptr)
-#define CVT_PTR_NOCHECK(ptr) (ptr)
-#define png_memcmp  memcmp
-#define png_memcpy  memcpy
-#define png_memset  memset
-
-/* Turn on CPU timing
-#define PNGTEST_TIMING
-*/
-
-#ifndef PNG_FLOATING_POINT_SUPPORTED
-#undef PNGTEST_TIMING
-#endif
-
-#ifdef PNGTEST_TIMING
-static float t_start, t_stop, t_decode, t_encode, t_misc;
-#include <time.h>
-#endif
-
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-#define PNG_tIME_STRING_LENGTH 29
-static int tIME_chunk_present = 0;
-static char tIME_string[PNG_tIME_STRING_LENGTH] = "tIME chunk is not present";
-#endif
-
-static int verbose = 0;
-
-int test_one_file PNGARG((PNG_CONST char *inname, PNG_CONST char *outname));
-
-#ifdef __TURBOC__
-#include <mem.h>
-#endif
-
-/* Defined so I can write to a file on gui/windowing platforms */
-/*  #define STDERR stderr  */
-#define STDERR stdout   /* For DOS */
-
-/* Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng */
-#ifndef png_jmpbuf
-#  define png_jmpbuf(png_ptr) png_ptr->jmpbuf
-#endif
-
-/* Example of using row callbacks to make a simple progress meter */
-static int status_pass = 1;
-static int status_dots_requested = 0;
-static int status_dots = 1;
-
-void PNGCBAPI
-read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
-void PNGCBAPI
-read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
-{
-   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX)
-      return;
-
-   if (status_pass != pass)
-   {
-      fprintf(stdout, "\n Pass %d: ", pass);
-      status_pass = pass;
-      status_dots = 31;
-   }
-
-   status_dots--;
-
-   if (status_dots == 0)
-   {
-      fprintf(stdout, "\n         ");
-      status_dots=30;
-   }
-
-   fprintf(stdout, "r");
-}
-
-void PNGCBAPI
-write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass);
-void PNGCBAPI
-write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
-{
-   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX || pass > 7)
-      return;
-
-   fprintf(stdout, "w");
-}
-
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-/* Example of using user transform callback (we don't transform anything,
- * but merely examine the row filters.  We set this to 256 rather than
- * 5 in case illegal filter values are present.)
- */
-static png_uint_32 filters_used[256];
-void PNGCBAPI
-count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data);
-void PNGCBAPI
-count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data)
-{
-   if (png_ptr != NULL && row_info != NULL)
-      ++filters_used[*(data - 1)];
-}
-#endif
-
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-/* Example of using user transform callback (we don't transform anything,
- * but merely count the zero samples)
- */
-
-static png_uint_32 zero_samples;
-
-void PNGCBAPI
-count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data);
-void PNGCBAPI
-count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data)
-{
-   png_bytep dp = data;
-   if (png_ptr == NULL)
-      return;
-
-   /* Contents of row_info:
-    *  png_uint_32 width      width of row
-    *  png_uint_32 rowbytes   number of bytes in row
-    *  png_byte color_type    color type of pixels
-    *  png_byte bit_depth     bit depth of samples
-    *  png_byte channels      number of channels (1-4)
-    *  png_byte pixel_depth   bits per pixel (depth*channels)
-    */
-
-    /* Counts the number of zero samples (or zero pixels if color_type is 3 */
-
-    if (row_info->color_type == 0 || row_info->color_type == 3)
-    {
-       int pos = 0;
-       png_uint_32 n, nstop;
-
-       for (n = 0, nstop=row_info->width; n<nstop; n++)
-       {
-          if (row_info->bit_depth == 1)
-          {
-             if (((*dp << pos++ ) & 0x80) == 0)
-                zero_samples++;
-
-             if (pos == 8)
-             {
-                pos = 0;
-                dp++;
-             }
-          }
-
-          if (row_info->bit_depth == 2)
-          {
-             if (((*dp << (pos+=2)) & 0xc0) == 0)
-                zero_samples++;
-
-             if (pos == 8)
-             {
-                pos = 0;
-                dp++;
-             }
-          }
-
-          if (row_info->bit_depth == 4)
-          {
-             if (((*dp << (pos+=4)) & 0xf0) == 0)
-                zero_samples++;
-
-             if (pos == 8)
-             {
-                pos = 0;
-                dp++;
-             }
-          }
-
-          if (row_info->bit_depth == 8)
-             if (*dp++ == 0)
-                zero_samples++;
-
-          if (row_info->bit_depth == 16)
-          {
-             if ((*dp | *(dp+1)) == 0)
-                zero_samples++;
-             dp+=2;
-          }
-       }
-    }
-    else /* Other color types */
-    {
-       png_uint_32 n, nstop;
-       int channel;
-       int color_channels = row_info->channels;
-       if (row_info->color_type > 3)color_channels--;
-
-       for (n = 0, nstop=row_info->width; n<nstop; n++)
-       {
-          for (channel = 0; channel < color_channels; channel++)
-          {
-             if (row_info->bit_depth == 8)
-                if (*dp++ == 0)
-                   zero_samples++;
-
-             if (row_info->bit_depth == 16)
-             {
-                if ((*dp | *(dp+1)) == 0)
-                   zero_samples++;
-
-                dp+=2;
-             }
-          }
-          if (row_info->color_type > 3)
-          {
-             dp++;
-             if (row_info->bit_depth == 16)
-                dp++;
-          }
-       }
-    }
-}
-#endif /* PNG_WRITE_USER_TRANSFORM_SUPPORTED */
-
-static int wrote_question = 0;
-
-#ifndef PNG_STDIO_SUPPORTED
-/* START of code to validate stdio-free compilation */
-/* These copies of the default read/write functions come from pngrio.c and
- * pngwio.c.  They allow "don't include stdio" testing of the library.
- * This is the function that does the actual reading of data.  If you are
- * not reading from a standard C stream, you should create a replacement
- * read_data function and use it at run time with png_set_read_fn(), rather
- * than changing the library.
- */
-
-#ifdef PNG_IO_STATE_SUPPORTED
-void
-pngtest_check_io_state(png_structp png_ptr, png_size_t data_length,
-   png_uint_32 io_op);
-void
-pngtest_check_io_state(png_structp png_ptr, png_size_t data_length,
-   png_uint_32 io_op)
-{
-   png_uint_32 io_state = png_get_io_state(png_ptr);
-   int err = 0;
-
-   /* Check if the current operation (reading / writing) is as expected. */
-   if ((io_state & PNG_IO_MASK_OP) != io_op)
-      png_error(png_ptr, "Incorrect operation in I/O state");
-
-   /* Check if the buffer size specific to the current location
-    * (file signature / header / data / crc) is as expected.
-    */
-   switch (io_state & PNG_IO_MASK_LOC)
-   {
-   case PNG_IO_SIGNATURE:
-      if (data_length > 8)
-         err = 1;
-      break;
-   case PNG_IO_CHUNK_HDR:
-      if (data_length != 8)
-         err = 1;
-      break;
-   case PNG_IO_CHUNK_DATA:
-      break;  /* no restrictions here */
-   case PNG_IO_CHUNK_CRC:
-      if (data_length != 4)
-         err = 1;
-      break;
-   default:
-      err = 1;  /* uninitialized */
-   }
-   if (err)
-      png_error(png_ptr, "Bad I/O state or buffer size");
-}
-#endif
-
-#ifndef USE_FAR_KEYWORD
-static void PNGCBAPI
-pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check = 0;
-   png_voidp io_ptr;
-
-   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
-    * instead of an int, which is what fread() actually returns.
-    */
-   io_ptr = png_get_io_ptr(png_ptr);
-   if (io_ptr != NULL)
-   {
-      check = fread(data, 1, length, (png_FILE_p)io_ptr);
-   }
-
-   if (check != length)
-   {
-      png_error(png_ptr, "Read Error");
-   }
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   pngtest_check_io_state(png_ptr, length, PNG_IO_READING);
-#endif
-}
-#else
-/* This is the model-independent version. Since the standard I/O library
-   can't handle far buffers in the medium and small models, we have to copy
-   the data.
-*/
-
-#define NEAR_BUF_SIZE 1024
-#define MIN(a,b) (a <= b ? a : b)
-
-static void PNGCBAPI
-pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-   png_byte *n_data;
-   png_FILE_p io_ptr;
-
-   /* Check if data really is near. If so, use usual code. */
-   n_data = (png_byte *)CVT_PTR_NOCHECK(data);
-   io_ptr = (png_FILE_p)CVT_PTR(png_get_io_ptr(png_ptr));
-   if ((png_bytep)n_data == data)
-   {
-      check = fread(n_data, 1, length, io_ptr);
-   }
-   else
-   {
-      png_byte buf[NEAR_BUF_SIZE];
-      png_size_t read, remaining, err;
-      check = 0;
-      remaining = length;
-
-      do
-      {
-         read = MIN(NEAR_BUF_SIZE, remaining);
-         err = fread(buf, 1, 1, io_ptr);
-         png_memcpy(data, buf, read); /* Copy far buffer to near buffer */
-         if (err != read)
-            break;
-         else
-            check += err;
-         data += read;
-         remaining -= read;
-      }
-      while (remaining != 0);
-   }
-
-   if (check != length)
-      png_error(png_ptr, "Read Error");
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   pngtest_check_io_state(png_ptr, length, PNG_IO_READING);
-#endif
-}
-#endif /* USE_FAR_KEYWORD */
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-static void PNGCBAPI
-pngtest_flush(png_structp png_ptr)
-{
-   /* Do nothing; fflush() is said to be just a waste of energy. */
-   PNG_UNUSED(png_ptr)   /* Stifle compiler warning */
-}
-#endif
-
-/* This is the function that does the actual writing of data.  If you are
- * not writing to a standard C stream, you should create a replacement
- * write_data function and use it at run time with png_set_write_fn(), rather
- * than changing the library.
- */
-#ifndef USE_FAR_KEYWORD
-static void PNGCBAPI
-pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-
-   check = fwrite(data, 1, length, (png_FILE_p)png_get_io_ptr(png_ptr));
-
-   if (check != length)
-   {
-      png_error(png_ptr, "Write Error");
-   }
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING);
-#endif
-}
-#else
-/* This is the model-independent version. Since the standard I/O library
-   can't handle far buffers in the medium and small models, we have to copy
-   the data.
-*/
-
-#define NEAR_BUF_SIZE 1024
-#define MIN(a,b) (a <= b ? a : b)
-
-static void PNGCBAPI
-pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
-   png_FILE_p io_ptr;
-
-   /* Check if data really is near. If so, use usual code. */
-   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
-   io_ptr = (png_FILE_p)CVT_PTR(png_get_io_ptr(png_ptr));
-
-   if ((png_bytep)near_data == data)
-   {
-      check = fwrite(near_data, 1, length, io_ptr);
-   }
-
-   else
-   {
-      png_byte buf[NEAR_BUF_SIZE];
-      png_size_t written, remaining, err;
-      check = 0;
-      remaining = length;
-
-      do
-      {
-         written = MIN(NEAR_BUF_SIZE, remaining);
-         png_memcpy(buf, data, written); /* Copy far buffer to near buffer */
-         err = fwrite(buf, 1, written, io_ptr);
-         if (err != written)
-            break;
-         else
-            check += err;
-         data += written;
-         remaining -= written;
-      }
-      while (remaining != 0);
-   }
-
-   if (check != length)
-   {
-      png_error(png_ptr, "Write Error");
-   }
-
-#ifdef PNG_IO_STATE_SUPPORTED
-   pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING);
-#endif
-}
-#endif /* USE_FAR_KEYWORD */
-
-/* This function is called when there is a warning, but the library thinks
- * it can continue anyway.  Replacement functions don't have to do anything
- * here if you don't want to.  In the default configuration, png_ptr is
- * not used, but it is passed in case it may be useful.
- */
-static void PNGCBAPI
-pngtest_warning(png_structp png_ptr, png_const_charp message)
-{
-   PNG_CONST char *name = "UNKNOWN (ERROR!)";
-   char *test;
-   test = png_get_error_ptr(png_ptr);
-
-   if (test == NULL)
-     fprintf(STDERR, "%s: libpng warning: %s\n", name, message);
-
-   else
-     fprintf(STDERR, "%s: libpng warning: %s\n", test, message);
-}
-
-/* This is the default error handling function.  Note that replacements for
- * this function MUST NOT RETURN, or the program will likely crash.  This
- * function is used by default, or if the program supplies NULL for the
- * error function pointer in png_set_error_fn().
- */
-static void PNGCBAPI
-pngtest_error(png_structp png_ptr, png_const_charp message)
-{
-   pngtest_warning(png_ptr, message);
-   /* We can return because png_error calls the default handler, which is
-    * actually OK in this case.
-    */
-}
-#endif /* !PNG_STDIO_SUPPORTED */
-/* END of code to validate stdio-free compilation */
-
-/* START of code to validate memory allocation and deallocation */
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-
-/* Allocate memory.  For reasonable files, size should never exceed
- * 64K.  However, zlib may allocate more then 64K if you don't tell
- * it not to.  See zconf.h and png.h for more information.  zlib does
- * need to allocate exactly 64K, so whatever you call here must
- * have the ability to do that.
- *
- * This piece of code can be compiled to validate max 64K allocations
- * by setting MAXSEG_64K in zlib zconf.h *or* PNG_MAX_MALLOC_64K.
- */
-typedef struct memory_information
-{
-   png_alloc_size_t          size;
-   png_voidp                 pointer;
-   struct memory_information FAR *next;
-} memory_information;
-typedef memory_information FAR *memory_infop;
-
-static memory_infop pinformation = NULL;
-static int current_allocation = 0;
-static int maximum_allocation = 0;
-static int total_allocation = 0;
-static int num_allocations = 0;
-
-png_voidp PNGCBAPI png_debug_malloc PNGARG((png_structp png_ptr,
-    png_alloc_size_t size));
-void PNGCBAPI png_debug_free PNGARG((png_structp png_ptr, png_voidp ptr));
-
-png_voidp
-PNGCBAPI png_debug_malloc(png_structp png_ptr, png_alloc_size_t size)
-{
-
-   /* png_malloc has already tested for NULL; png_create_struct calls
-    * png_debug_malloc directly, with png_ptr == NULL which is OK
-    */
-
-   if (size == 0)
-      return (NULL);
-
-   /* This calls the library allocator twice, once to get the requested
-      buffer and once to get a new free list entry. */
-   {
-      /* Disable malloc_fn and free_fn */
-      memory_infop pinfo;
-      png_set_mem_fn(png_ptr, NULL, NULL, NULL);
-      pinfo = (memory_infop)png_malloc(png_ptr,
-         png_sizeof(*pinfo));
-      pinfo->size = size;
-      current_allocation += size;
-      total_allocation += size;
-      num_allocations ++;
-
-      if (current_allocation > maximum_allocation)
-         maximum_allocation = current_allocation;
-
-      pinfo->pointer = png_malloc(png_ptr, size);
-      /* Restore malloc_fn and free_fn */
-
-      png_set_mem_fn(png_ptr,
-          NULL, png_debug_malloc, png_debug_free);
-
-      if (size != 0 && pinfo->pointer == NULL)
-      {
-         current_allocation -= size;
-         total_allocation -= size;
-         png_error(png_ptr,
-           "out of memory in pngtest->png_debug_malloc");
-      }
-
-      pinfo->next = pinformation;
-      pinformation = pinfo;
-      /* Make sure the caller isn't assuming zeroed memory. */
-      png_memset(pinfo->pointer, 0xdd, pinfo->size);
-
-      if (verbose)
-         printf("png_malloc %lu bytes at %p\n", (unsigned long)size,
-            pinfo->pointer);
-
-      return (png_voidp)(pinfo->pointer);
-   }
-}
-
-/* Free a pointer.  It is removed from the list at the same time. */
-void PNGCBAPI
-png_debug_free(png_structp png_ptr, png_voidp ptr)
-{
-   if (png_ptr == NULL)
-      fprintf(STDERR, "NULL pointer to png_debug_free.\n");
-
-   if (ptr == 0)
-   {
-#if 0 /* This happens all the time. */
-      fprintf(STDERR, "WARNING: freeing NULL pointer\n");
-#endif
-      return;
-   }
-
-   /* Unlink the element from the list. */
-   {
-      memory_infop FAR *ppinfo = &pinformation;
-
-      for (;;)
-      {
-         memory_infop pinfo = *ppinfo;
-
-         if (pinfo->pointer == ptr)
-         {
-            *ppinfo = pinfo->next;
-            current_allocation -= pinfo->size;
-            if (current_allocation < 0)
-               fprintf(STDERR, "Duplicate free of memory\n");
-            /* We must free the list element too, but first kill
-               the memory that is to be freed. */
-            png_memset(ptr, 0x55, pinfo->size);
-            png_free_default(png_ptr, pinfo);
-            pinfo = NULL;
-            break;
-         }
-
-         if (pinfo->next == NULL)
-         {
-            fprintf(STDERR, "Pointer %x not found\n", (unsigned int)ptr);
-            break;
-         }
-
-         ppinfo = &pinfo->next;
-      }
-   }
-
-   /* Finally free the data. */
-   if (verbose)
-      printf("Freeing %p\n", ptr);
-
-   png_free_default(png_ptr, ptr);
-   ptr = NULL;
-}
-#endif /* PNG_USER_MEM_SUPPORTED && PNG_DEBUG */
-/* END of code to test memory allocation/deallocation */
-
-
-/* Demonstration of user chunk support of the sTER and vpAg chunks */
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-
-/* (sTER is a public chunk not yet known by libpng.  vpAg is a private
-chunk used in ImageMagick to store "virtual page" size).  */
-
-static png_uint_32 user_chunk_data[4];
-
-    /* 0: sTER mode + 1
-     * 1: vpAg width
-     * 2: vpAg height
-     * 3: vpAg units
-     */
-
-static int PNGCBAPI read_user_chunk_callback(png_struct *png_ptr,
-   png_unknown_chunkp chunk)
-{
-   png_uint_32
-     *my_user_chunk_data;
-
-   /* Return one of the following:
-    *    return (-n);  chunk had an error
-    *    return (0);  did not recognize
-    *    return (n);  success
-    *
-    * The unknown chunk structure contains the chunk data:
-    * png_byte name[5];
-    * png_byte *data;
-    * png_size_t size;
-    *
-    * Note that libpng has already taken care of the CRC handling.
-    */
-
-   if (chunk->name[0] == 115 && chunk->name[1] ==  84 &&     /* s  T */
-       chunk->name[2] ==  69 && chunk->name[3] ==  82)       /* E  R */
-      {
-         /* Found sTER chunk */
-         if (chunk->size != 1)
-            return (-1); /* Error return */
-
-         if (chunk->data[0] != 0 && chunk->data[0] != 1)
-            return (-1);  /* Invalid mode */
-
-         my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);
-         my_user_chunk_data[0]=chunk->data[0]+1;
-         return (1);
-      }
-
-   if (chunk->name[0] != 118 || chunk->name[1] != 112 ||    /* v  p */
-       chunk->name[2] !=  65 || chunk->name[3] != 103)      /* A  g */
-      return (0); /* Did not recognize */
-
-   /* Found ImageMagick vpAg chunk */
-
-   if (chunk->size != 9)
-      return (-1); /* Error return */
-
-   my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr);
-
-   my_user_chunk_data[1]=png_get_uint_31(png_ptr, chunk->data);
-   my_user_chunk_data[2]=png_get_uint_31(png_ptr, chunk->data + 4);
-   my_user_chunk_data[3]=(png_uint_32)chunk->data[8];
-
-   return (1);
-
-}
-#endif
-/* END of code to demonstrate user chunk support */
-
-/* Test one file */
-int
-test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
-{
-   static png_FILE_p fpin;
-   static png_FILE_p fpout;  /* "static" prevents setjmp corruption */
-   png_structp read_ptr;
-   png_infop read_info_ptr, end_info_ptr;
-#ifdef PNG_WRITE_SUPPORTED
-   png_structp write_ptr;
-   png_infop write_info_ptr;
-   png_infop write_end_info_ptr;
-#else
-   png_structp write_ptr = NULL;
-   png_infop write_info_ptr = NULL;
-   png_infop write_end_info_ptr = NULL;
-#endif
-   png_bytep row_buf;
-   png_uint_32 y;
-   png_uint_32 width, height;
-   int num_pass, pass;
-   int bit_depth, color_type;
-#ifdef PNG_SETJMP_SUPPORTED
-#ifdef USE_FAR_KEYWORD
-   jmp_buf png_jmpbuf;
-#endif
-#endif
-
-   char inbuf[256], outbuf[256];
-
-   row_buf = NULL;
-
-   if ((fpin = fopen(inname, "rb")) == NULL)
-   {
-      fprintf(STDERR, "Could not find input file %s\n", inname);
-      return (1);
-   }
-
-   if ((fpout = fopen(outname, "wb")) == NULL)
-   {
-      fprintf(STDERR, "Could not open output file %s\n", outname);
-      FCLOSE(fpin);
-      return (1);
-   }
-
-   pngtest_debug("Allocating read and write structures");
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-   read_ptr =
-      png_create_read_struct_2(PNG_LIBPNG_VER_STRING, NULL,
-      NULL, NULL, NULL, png_debug_malloc, png_debug_free);
-#else
-   read_ptr =
-      png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-#endif
-#ifndef PNG_STDIO_SUPPORTED
-   png_set_error_fn(read_ptr, (png_voidp)inname, pngtest_error,
-       pngtest_warning);
-#endif
-
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-   user_chunk_data[0] = 0;
-   user_chunk_data[1] = 0;
-   user_chunk_data[2] = 0;
-   user_chunk_data[3] = 0;
-   png_set_read_user_chunk_fn(read_ptr, user_chunk_data,
-     read_user_chunk_callback);
-
-#endif
-#ifdef PNG_WRITE_SUPPORTED
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-   write_ptr =
-      png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL,
-      NULL, NULL, NULL, png_debug_malloc, png_debug_free);
-#else
-   write_ptr =
-      png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-#endif
-#ifndef PNG_STDIO_SUPPORTED
-   png_set_error_fn(write_ptr, (png_voidp)inname, pngtest_error,
-       pngtest_warning);
-#endif
-#endif
-   pngtest_debug("Allocating read_info, write_info and end_info structures");
-   read_info_ptr = png_create_info_struct(read_ptr);
-   end_info_ptr = png_create_info_struct(read_ptr);
-#ifdef PNG_WRITE_SUPPORTED
-   write_info_ptr = png_create_info_struct(write_ptr);
-   write_end_info_ptr = png_create_info_struct(write_ptr);
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-   pngtest_debug("Setting jmpbuf for read struct");
-#ifdef USE_FAR_KEYWORD
-   if (setjmp(png_jmpbuf))
-#else
-   if (setjmp(png_jmpbuf(read_ptr)))
-#endif
-   {
-      fprintf(STDERR, "%s -> %s: libpng read error\n", inname, outname);
-      png_free(read_ptr, row_buf);
-      row_buf = NULL;
-      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
-#ifdef PNG_WRITE_SUPPORTED
-      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
-      png_destroy_write_struct(&write_ptr, &write_info_ptr);
-#endif
-      FCLOSE(fpin);
-      FCLOSE(fpout);
-      return (1);
-   }
-#ifdef USE_FAR_KEYWORD
-   png_memcpy(png_jmpbuf(read_ptr), png_jmpbuf, png_sizeof(jmp_buf));
-#endif
-
-#ifdef PNG_WRITE_SUPPORTED
-   pngtest_debug("Setting jmpbuf for write struct");
-#ifdef USE_FAR_KEYWORD
-
-   if (setjmp(png_jmpbuf))
-#else
-   if (setjmp(png_jmpbuf(write_ptr)))
-#endif
-   {
-      fprintf(STDERR, "%s -> %s: libpng write error\n", inname, outname);
-      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
-      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
-#ifdef PNG_WRITE_SUPPORTED
-      png_destroy_write_struct(&write_ptr, &write_info_ptr);
-#endif
-      FCLOSE(fpin);
-      FCLOSE(fpout);
-      return (1);
-   }
-
-#ifdef USE_FAR_KEYWORD
-   png_memcpy(png_jmpbuf(write_ptr), png_jmpbuf, png_sizeof(jmp_buf));
-#endif
-#endif
-#endif
-
-   pngtest_debug("Initializing input and output streams");
-#ifdef PNG_STDIO_SUPPORTED
-   png_init_io(read_ptr, fpin);
-#  ifdef PNG_WRITE_SUPPORTED
-   png_init_io(write_ptr, fpout);
-#  endif
-#else
-   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);
-#  ifdef PNG_WRITE_SUPPORTED
-   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,
-#    ifdef PNG_WRITE_FLUSH_SUPPORTED
-      pngtest_flush);
-#    else
-      NULL);
-#    endif
-#  endif
-#endif
-
-   if (status_dots_requested == 1)
-   {
-#ifdef PNG_WRITE_SUPPORTED
-      png_set_write_status_fn(write_ptr, write_row_callback);
-#endif
-      png_set_read_status_fn(read_ptr, read_row_callback);
-   }
-
-   else
-   {
-#ifdef PNG_WRITE_SUPPORTED
-      png_set_write_status_fn(write_ptr, NULL);
-#endif
-      png_set_read_status_fn(read_ptr, NULL);
-   }
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-   {
-      int i;
-
-      for (i = 0; i<256; i++)
-         filters_used[i] = 0;
-
-      png_set_read_user_transform_fn(read_ptr, count_filters);
-   }
-#endif
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-   zero_samples = 0;
-   png_set_write_user_transform_fn(write_ptr, count_zero_samples);
-#endif
-
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-#  ifndef PNG_HANDLE_CHUNK_ALWAYS
-#    define PNG_HANDLE_CHUNK_ALWAYS       3
-#  endif
-   png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_ALWAYS,
-      NULL, 0);
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-#  ifndef PNG_HANDLE_CHUNK_IF_SAFE
-#    define PNG_HANDLE_CHUNK_IF_SAFE      2
-#  endif
-   png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_IF_SAFE,
-      NULL, 0);
-#endif
-
-   pngtest_debug("Reading info struct");
-   png_read_info(read_ptr, read_info_ptr);
-
-   pngtest_debug("Transferring info struct");
-   {
-      int interlace_type, compression_type, filter_type;
-
-      if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height, &bit_depth,
-          &color_type, &interlace_type, &compression_type, &filter_type))
-      {
-         png_set_IHDR(write_ptr, write_info_ptr, width, height, bit_depth,
-#ifdef PNG_WRITE_INTERLACING_SUPPORTED
-            color_type, interlace_type, compression_type, filter_type);
-#else
-            color_type, PNG_INTERLACE_NONE, compression_type, filter_type);
-#endif
-      }
-   }
-#ifdef PNG_FIXED_POINT_SUPPORTED
-#ifdef PNG_cHRM_SUPPORTED
-   {
-      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
-         blue_y;
-
-      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y,
-         &red_x, &red_y, &green_x, &green_y, &blue_x, &blue_y))
-      {
-         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,
-            red_y, green_x, green_y, blue_x, blue_y);
-      }
-   }
-#endif
-#ifdef PNG_gAMA_SUPPORTED
-   {
-      png_fixed_point gamma;
-
-      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma))
-         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
-   }
-#endif
-#else /* Use floating point versions */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-#ifdef PNG_cHRM_SUPPORTED
-   {
-      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
-         blue_y;
-
-      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
-         &red_y, &green_x, &green_y, &blue_x, &blue_y))
-      {
-         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,
-            red_y, green_x, green_y, blue_x, blue_y);
-      }
-   }
-#endif
-#ifdef PNG_gAMA_SUPPORTED
-   {
-      double gamma;
-
-      if (png_get_gAMA(read_ptr, read_info_ptr, &gamma))
-         png_set_gAMA(write_ptr, write_info_ptr, gamma);
-   }
-#endif
-#endif /* Floating point */
-#endif /* Fixed point */
-#ifdef PNG_iCCP_SUPPORTED
-   {
-      png_charp name;
-      png_bytep profile;
-      png_uint_32 proflen;
-      int compression_type;
-
-      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,
-                      &profile, &proflen))
-      {
-         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,
-                      profile, proflen);
-      }
-   }
-#endif
-#ifdef PNG_sRGB_SUPPORTED
-   {
-      int intent;
-
-      if (png_get_sRGB(read_ptr, read_info_ptr, &intent))
-         png_set_sRGB(write_ptr, write_info_ptr, intent);
-   }
-#endif
-   {
-      png_colorp palette;
-      int num_palette;
-
-      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
-         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
-   }
-#ifdef PNG_bKGD_SUPPORTED
-   {
-      png_color_16p background;
-
-      if (png_get_bKGD(read_ptr, read_info_ptr, &background))
-      {
-         png_set_bKGD(write_ptr, write_info_ptr, background);
-      }
-   }
-#endif
-#ifdef PNG_hIST_SUPPORTED
-   {
-      png_uint_16p hist;
-
-      if (png_get_hIST(read_ptr, read_info_ptr, &hist))
-         png_set_hIST(write_ptr, write_info_ptr, hist);
-   }
-#endif
-#ifdef PNG_oFFs_SUPPORTED
-   {
-      png_int_32 offset_x, offset_y;
-      int unit_type;
-
-      if (png_get_oFFs(read_ptr, read_info_ptr, &offset_x, &offset_y,
-          &unit_type))
-      {
-         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);
-      }
-   }
-#endif
-#ifdef PNG_pCAL_SUPPORTED
-   {
-      png_charp purpose, units;
-      png_charpp params;
-      png_int_32 X0, X1;
-      int type, nparams;
-
-      if (png_get_pCAL(read_ptr, read_info_ptr, &purpose, &X0, &X1, &type,
-         &nparams, &units, &params))
-      {
-         png_set_pCAL(write_ptr, write_info_ptr, purpose, X0, X1, type,
-            nparams, units, params);
-      }
-   }
-#endif
-#ifdef PNG_pHYs_SUPPORTED
-   {
-      png_uint_32 res_x, res_y;
-      int unit_type;
-
-      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y, &unit_type))
-         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);
-   }
-#endif
-#ifdef PNG_sBIT_SUPPORTED
-   {
-      png_color_8p sig_bit;
-
-      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
-         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);
-   }
-#endif
-#ifdef PNG_sCAL_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-   {
-      int unit;
-      double scal_width, scal_height;
-
-      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,
-         &scal_height))
-      {
-         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);
-      }
-   }
-#else
-#ifdef PNG_FIXED_POINT_SUPPORTED
-   {
-      int unit;
-      png_charp scal_width, scal_height;
-
-      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,
-          &scal_height))
-      {
-         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width,
-             scal_height);
-      }
-   }
-#endif
-#endif
-#endif
-#ifdef PNG_TEXT_SUPPORTED
-   {
-      png_textp text_ptr;
-      int num_text;
-
-      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)
-      {
-         pngtest_debug1("Handling %d iTXt/tEXt/zTXt chunks", num_text);
-         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);
-      }
-   }
-#endif
-#ifdef PNG_tIME_SUPPORTED
-   {
-      png_timep mod_time;
-
-      if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))
-      {
-         png_set_tIME(write_ptr, write_info_ptr, mod_time);
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-         /* We have to use png_memcpy instead of "=" because the string
-          * pointed to by png_convert_to_rfc1123() gets free'ed before
-          * we use it.
-          */
-         png_memcpy(tIME_string,
-                    png_convert_to_rfc1123(read_ptr, mod_time),
-                    png_sizeof(tIME_string));
-
-         tIME_string[png_sizeof(tIME_string) - 1] = '\0';
-         tIME_chunk_present++;
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-      }
-   }
-#endif
-#ifdef PNG_tRNS_SUPPORTED
-   {
-      png_bytep trans_alpha;
-      int num_trans;
-      png_color_16p trans_color;
-
-      if (png_get_tRNS(read_ptr, read_info_ptr, &trans_alpha, &num_trans,
-         &trans_color))
-      {
-         int sample_max = (1 << bit_depth);
-         /* libpng doesn't reject a tRNS chunk with out-of-range samples */
-         if (!((color_type == PNG_COLOR_TYPE_GRAY &&
-             (int)trans_color->gray > sample_max) ||
-             (color_type == PNG_COLOR_TYPE_RGB &&
-             ((int)trans_color->red > sample_max ||
-             (int)trans_color->green > sample_max ||
-             (int)trans_color->blue > sample_max))))
-            png_set_tRNS(write_ptr, write_info_ptr, trans_alpha, num_trans,
-               trans_color);
-      }
-   }
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   {
-      png_unknown_chunkp unknowns;
-      int num_unknowns = png_get_unknown_chunks(read_ptr, read_info_ptr,
-         &unknowns);
-
-      if (num_unknowns)
-      {
-         int i;
-         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,
-           num_unknowns);
-         /* Copy the locations from the read_info_ptr.  The automatically
-          * generated locations in write_info_ptr are wrong because we
-          * haven't written anything yet.
-          */
-         for (i = 0; i < num_unknowns; i++)
-           png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,
-             unknowns[i].location);
-      }
-   }
-#endif
-
-#ifdef PNG_WRITE_SUPPORTED
-   pngtest_debug("Writing info struct");
-
-/* If we wanted, we could write info in two steps:
- * png_write_info_before_PLTE(write_ptr, write_info_ptr);
- */
-   png_write_info(write_ptr, write_info_ptr);
-
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-   if (user_chunk_data[0] != 0)
-   {
-      png_byte png_sTER[5] = {115,  84,  69,  82, '\0'};
-
-      unsigned char
-        ster_chunk_data[1];
-
-      if (verbose)
-         fprintf(STDERR, "\n stereo mode = %lu\n",
-           (unsigned long)(user_chunk_data[0] - 1));
-
-      ster_chunk_data[0]=(unsigned char)(user_chunk_data[0] - 1);
-      png_write_chunk(write_ptr, png_sTER, ster_chunk_data, 1);
-   }
-
-   if (user_chunk_data[1] != 0 || user_chunk_data[2] != 0)
-   {
-      png_byte png_vpAg[5] = {118, 112,  65, 103, '\0'};
-
-      unsigned char
-        vpag_chunk_data[9];
-
-      if (verbose)
-         fprintf(STDERR, " vpAg = %lu x %lu, units = %lu\n",
-           (unsigned long)user_chunk_data[1],
-           (unsigned long)user_chunk_data[2],
-           (unsigned long)user_chunk_data[3]);
-
-      png_save_uint_32(vpag_chunk_data, user_chunk_data[1]);
-      png_save_uint_32(vpag_chunk_data + 4, user_chunk_data[2]);
-      vpag_chunk_data[8] = (unsigned char)(user_chunk_data[3] & 0xff);
-      png_write_chunk(write_ptr, png_vpAg, vpag_chunk_data, 9);
-   }
-
-#endif
-#endif
-
-#ifdef SINGLE_ROWBUF_ALLOC
-   pngtest_debug("Allocating row buffer...");
-   row_buf = (png_bytep)png_malloc(read_ptr,
-      png_get_rowbytes(read_ptr, read_info_ptr));
-
-   pngtest_debug1("\t0x%08lx", (unsigned long)row_buf);
-#endif /* SINGLE_ROWBUF_ALLOC */
-   pngtest_debug("Writing row data");
-
-#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
-  defined(PNG_WRITE_INTERLACING_SUPPORTED)
-   num_pass = png_set_interlace_handling(read_ptr);
-#  ifdef PNG_WRITE_SUPPORTED
-   png_set_interlace_handling(write_ptr);
-#  endif
-#else
-   num_pass = 1;
-#endif
-
-#ifdef PNGTEST_TIMING
-   t_stop = (float)clock();
-   t_misc += (t_stop - t_start);
-   t_start = t_stop;
-#endif
-   for (pass = 0; pass < num_pass; pass++)
-   {
-      pngtest_debug1("Writing row data for pass %d", pass);
-      for (y = 0; y < height; y++)
-      {
-#ifndef SINGLE_ROWBUF_ALLOC
-         pngtest_debug2("Allocating row buffer (pass %d, y = %u)...", pass, y);
-         row_buf = (png_bytep)png_malloc(read_ptr,
-            png_get_rowbytes(read_ptr, read_info_ptr));
-
-         pngtest_debug2("\t0x%08lx (%u bytes)", (unsigned long)row_buf,
-            png_get_rowbytes(read_ptr, read_info_ptr));
-
-#endif /* !SINGLE_ROWBUF_ALLOC */
-         png_read_rows(read_ptr, (png_bytepp)&row_buf, NULL, 1);
-
-#ifdef PNG_WRITE_SUPPORTED
-#ifdef PNGTEST_TIMING
-         t_stop = (float)clock();
-         t_decode += (t_stop - t_start);
-         t_start = t_stop;
-#endif
-         png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);
-#ifdef PNGTEST_TIMING
-         t_stop = (float)clock();
-         t_encode += (t_stop - t_start);
-         t_start = t_stop;
-#endif
-#endif /* PNG_WRITE_SUPPORTED */
-
-#ifndef SINGLE_ROWBUF_ALLOC
-         pngtest_debug2("Freeing row buffer (pass %d, y = %u)", pass, y);
-         png_free(read_ptr, row_buf);
-         row_buf = NULL;
-#endif /* !SINGLE_ROWBUF_ALLOC */
-      }
-   }
-
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-   png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);
-#endif
-
-   pngtest_debug("Reading and writing end_info data");
-
-   png_read_end(read_ptr, end_info_ptr);
-#ifdef PNG_TEXT_SUPPORTED
-   {
-      png_textp text_ptr;
-      int num_text;
-
-      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)
-      {
-         pngtest_debug1("Handling %d iTXt/tEXt/zTXt chunks", num_text);
-         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
-      }
-   }
-#endif
-#ifdef PNG_tIME_SUPPORTED
-   {
-      png_timep mod_time;
-
-      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))
-      {
-         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-         /* We have to use png_memcpy instead of "=" because the string
-            pointed to by png_convert_to_rfc1123() gets free'ed before
-            we use it */
-         png_memcpy(tIME_string,
-                    png_convert_to_rfc1123(read_ptr, mod_time),
-                    png_sizeof(tIME_string));
-
-         tIME_string[png_sizeof(tIME_string) - 1] = '\0';
-         tIME_chunk_present++;
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-      }
-   }
-#endif
-#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-   {
-      png_unknown_chunkp unknowns;
-      int num_unknowns = png_get_unknown_chunks(read_ptr, end_info_ptr,
-         &unknowns);
-
-      if (num_unknowns)
-      {
-         int i;
-         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,
-           num_unknowns);
-         /* Copy the locations from the read_info_ptr.  The automatically
-          * generated locations in write_end_info_ptr are wrong because we
-          * haven't written the end_info yet.
-          */
-         for (i = 0; i < num_unknowns; i++)
-           png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,
-             unknowns[i].location);
-      }
-   }
-#endif
-#ifdef PNG_WRITE_SUPPORTED
-   png_write_end(write_ptr, write_end_info_ptr);
-#endif
-
-#ifdef PNG_EASY_ACCESS_SUPPORTED
-   if (verbose)
-   {
-      png_uint_32 iwidth, iheight;
-      iwidth = png_get_image_width(write_ptr, write_info_ptr);
-      iheight = png_get_image_height(write_ptr, write_info_ptr);
-      fprintf(STDERR, "\n Image width = %lu, height = %lu\n",
-         (unsigned long)iwidth, (unsigned long)iheight);
-   }
-#endif
-
-   pngtest_debug("Destroying data structs");
-#ifdef SINGLE_ROWBUF_ALLOC
-   pngtest_debug("destroying row_buf for read_ptr");
-   png_free(read_ptr, row_buf);
-   row_buf = NULL;
-#endif /* SINGLE_ROWBUF_ALLOC */
-   pngtest_debug("destroying read_ptr, read_info_ptr, end_info_ptr");
-   png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
-#ifdef PNG_WRITE_SUPPORTED
-   pngtest_debug("destroying write_end_info_ptr");
-   png_destroy_info_struct(write_ptr, &write_end_info_ptr);
-   pngtest_debug("destroying write_ptr, write_info_ptr");
-   png_destroy_write_struct(&write_ptr, &write_info_ptr);
-#endif
-   pngtest_debug("Destruction complete.");
-
-   FCLOSE(fpin);
-   FCLOSE(fpout);
-
-   pngtest_debug("Opening files for comparison");
-   if ((fpin = fopen(inname, "rb")) == NULL)
-   {
-      fprintf(STDERR, "Could not find file %s\n", inname);
-      return (1);
-   }
-
-   if ((fpout = fopen(outname, "rb")) == NULL)
-   {
-      fprintf(STDERR, "Could not find file %s\n", outname);
-      FCLOSE(fpin);
-      return (1);
-   }
-
-   for (;;)
-   {
-      png_size_t num_in, num_out;
-
-         num_in = fread(inbuf, 1, 1, fpin);
-         num_out = fread(outbuf, 1, 1, fpout);
-
-      if (num_in != num_out)
-      {
-         fprintf(STDERR, "\nFiles %s and %s are of a different size\n",
-                 inname, outname);
-
-         if (wrote_question == 0)
-         {
-            fprintf(STDERR,
-         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
-              inname, PNG_ZBUF_SIZE);
-            fprintf(STDERR,
-              "\n   filtering heuristic (libpng default), compression");
-            fprintf(STDERR,
-              " level (zlib default),\n   and zlib version (%s)?\n\n",
-              ZLIB_VERSION);
-            wrote_question = 1;
-         }
-
-         FCLOSE(fpin);
-         FCLOSE(fpout);
-         return (0);
-      }
-
-      if (!num_in)
-         break;
-
-      if (png_memcmp(inbuf, outbuf, num_in))
-      {
-         fprintf(STDERR, "\nFiles %s and %s are different\n", inname, outname);
-
-         if (wrote_question == 0)
-         {
-            fprintf(STDERR,
-         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
-                 inname, PNG_ZBUF_SIZE);
-            fprintf(STDERR,
-              "\n   filtering heuristic (libpng default), compression");
-            fprintf(STDERR,
-              " level (zlib default),\n   and zlib version (%s)?\n\n",
-              ZLIB_VERSION);
-            wrote_question = 1;
-         }
-
-         FCLOSE(fpin);
-         FCLOSE(fpout);
-         return (0);
-      }
-   }
-
-   FCLOSE(fpin);
-   FCLOSE(fpout);
-
-   return (0);
-}
-
-/* Input and output filenames */
-#ifdef RISCOS
-static PNG_CONST char *inname = "pngtest/png";
-static PNG_CONST char *outname = "pngout/png";
-#else
-static PNG_CONST char *inname = "pngtest.png";
-static PNG_CONST char *outname = "pngout.png";
-#endif
-
-int
-main(int argc, char *argv[])
-{
-   int multiple = 0;
-   int ierror = 0;
-
-   fprintf(STDERR, "\n Testing libpng version %s\n", PNG_LIBPNG_VER_STRING);
-   fprintf(STDERR, "   with zlib   version %s\n", ZLIB_VERSION);
-   fprintf(STDERR, "%s", png_get_copyright(NULL));
-   /* Show the version of libpng used in building the library */
-   fprintf(STDERR, " library (%lu):%s",
-      (unsigned long)png_access_version_number(),
-      png_get_header_version(NULL));
-
-   /* Show the version of libpng used in building the application */
-   fprintf(STDERR, " pngtest (%lu):%s", (unsigned long)PNG_LIBPNG_VER,
-      PNG_HEADER_VERSION_STRING);
-
-   /* Do some consistency checking on the memory allocation settings, I'm
-    * not sure this matters, but it is nice to know, the first of these
-    * tests should be impossible because of the way the macros are set
-    * in pngconf.h
-    */
-#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
-      fprintf(STDERR, " NOTE: Zlib compiled for max 64k, libpng not\n");
-#endif
-   /* I think the following can happen. */
-#if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K)
-      fprintf(STDERR, " NOTE: libpng compiled for max 64k, zlib not\n");
-#endif
-
-   if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))
-   {
-      fprintf(STDERR,
-         "Warning: versions are different between png.h and png.c\n");
-      fprintf(STDERR, "  png.h version: %s\n", PNG_LIBPNG_VER_STRING);
-      fprintf(STDERR, "  png.c version: %s\n\n", png_libpng_ver);
-      ++ierror;
-   }
-
-   if (argc > 1)
-   {
-      if (strcmp(argv[1], "-m") == 0)
-      {
-         multiple = 1;
-         status_dots_requested = 0;
-      }
-
-      else if (strcmp(argv[1], "-mv") == 0 ||
-               strcmp(argv[1], "-vm") == 0 )
-      {
-         multiple = 1;
-         verbose = 1;
-         status_dots_requested = 1;
-      }
-
-      else if (strcmp(argv[1], "-v") == 0)
-      {
-         verbose = 1;
-         status_dots_requested = 1;
-         inname = argv[2];
-      }
-
-      else
-      {
-         inname = argv[1];
-         status_dots_requested = 0;
-      }
-   }
-
-   if (!multiple && argc == 3 + verbose)
-     outname = argv[2 + verbose];
-
-   if ((!multiple && argc > 3 + verbose) || (multiple && argc < 2))
-   {
-     fprintf(STDERR,
-       "usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n",
-        argv[0], argv[0]);
-     fprintf(STDERR,
-       "  reads/writes one PNG file (without -m) or multiple files (-m)\n");
-     fprintf(STDERR,
-       "  with -m %s is used as a temporary file\n", outname);
-     exit(1);
-   }
-
-   if (multiple)
-   {
-      int i;
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-      int allocation_now = current_allocation;
-#endif
-      for (i=2; i<argc; ++i)
-      {
-         int kerror;
-         fprintf(STDERR, "\n Testing %s:", argv[i]);
-         kerror = test_one_file(argv[i], outname);
-         if (kerror == 0)
-         {
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-            int k;
-#endif
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-            fprintf(STDERR, "\n PASS (%lu zero samples)\n",
-               (unsigned long)zero_samples);
-#else
-            fprintf(STDERR, " PASS\n");
-#endif
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-            for (k = 0; k<256; k++)
-               if (filters_used[k])
-                  fprintf(STDERR, " Filter %d was used %lu times\n",
-                     k, (unsigned long)filters_used[k]);
-#endif
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-         if (tIME_chunk_present != 0)
-            fprintf(STDERR, " tIME = %s\n", tIME_string);
-
-         tIME_chunk_present = 0;
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-         }
-
-         else
-         {
-            fprintf(STDERR, " FAIL\n");
-            ierror += kerror;
-         }
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-         if (allocation_now != current_allocation)
-            fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
-               current_allocation - allocation_now);
-
-         if (current_allocation != 0)
-         {
-            memory_infop pinfo = pinformation;
-
-            fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
-               current_allocation);
-
-            while (pinfo != NULL)
-            {
-               fprintf(STDERR, " %lu bytes at %x\n",
-                 (unsigned long)pinfo->size,
-                 (unsigned int)pinfo->pointer);
-               pinfo = pinfo->next;
-            }
-         }
-#endif
-      }
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-         fprintf(STDERR, " Current memory allocation: %10d bytes\n",
-            current_allocation);
-         fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
-            maximum_allocation);
-         fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
-            total_allocation);
-         fprintf(STDERR, "     Number of allocations: %10d\n",
-            num_allocations);
-#endif
-   }
-
-   else
-   {
-      int i;
-      for (i = 0; i<3; ++i)
-      {
-         int kerror;
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-         int allocation_now = current_allocation;
-#endif
-         if (i == 1)
-            status_dots_requested = 1;
-
-         else if (verbose == 0)
-            status_dots_requested = 0;
-
-         if (i == 0 || verbose == 1 || ierror != 0)
-            fprintf(STDERR, "\n Testing %s:", inname);
-
-         kerror = test_one_file(inname, outname);
-
-         if (kerror == 0)
-         {
-            if (verbose == 1 || i == 2)
-            {
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-                int k;
-#endif
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-                fprintf(STDERR, "\n PASS (%lu zero samples)\n",
-                   (unsigned long)zero_samples);
-#else
-                fprintf(STDERR, " PASS\n");
-#endif
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-                for (k = 0; k<256; k++)
-                   if (filters_used[k])
-                      fprintf(STDERR, " Filter %d was used %lu times\n",
-                         k, (unsigned long)filters_used[k]);
-#endif
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-             if (tIME_chunk_present != 0)
-                fprintf(STDERR, " tIME = %s\n", tIME_string);
-#endif /* PNG_TIME_RFC1123_SUPPORTED */
-            }
-         }
-
-         else
-         {
-            if (verbose == 0 && i != 2)
-               fprintf(STDERR, "\n Testing %s:", inname);
-
-            fprintf(STDERR, " FAIL\n");
-            ierror += kerror;
-         }
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-         if (allocation_now != current_allocation)
-             fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
-               current_allocation - allocation_now);
-
-         if (current_allocation != 0)
-         {
-             memory_infop pinfo = pinformation;
-
-             fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
-                current_allocation);
-
-             while (pinfo != NULL)
-             {
-                fprintf(STDERR, " %lu bytes at %x\n",
-                   (unsigned long)pinfo->size, (unsigned int)pinfo->pointer);
-                pinfo = pinfo->next;
-             }
-          }
-#endif
-       }
-#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
-       fprintf(STDERR, " Current memory allocation: %10d bytes\n",
-          current_allocation);
-       fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
-          maximum_allocation);
-       fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
-          total_allocation);
-       fprintf(STDERR, "     Number of allocations: %10d\n",
-            num_allocations);
-#endif
-   }
-
-#ifdef PNGTEST_TIMING
-   t_stop = (float)clock();
-   t_misc += (t_stop - t_start);
-   t_start = t_stop;
-   fprintf(STDERR, " CPU time used = %.3f seconds",
-      (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);
-   fprintf(STDERR, " (decoding %.3f,\n",
-      t_decode/(float)CLOCKS_PER_SEC);
-   fprintf(STDERR, "        encoding %.3f ,",
-      t_encode/(float)CLOCKS_PER_SEC);
-   fprintf(STDERR, " other %.3f seconds)\n\n",
-      t_misc/(float)CLOCKS_PER_SEC);
-#endif
-
-   if (ierror == 0)
-      fprintf(STDERR, " libpng passes test\n");
-
-   else
-      fprintf(STDERR, " libpng FAILS test\n");
-
-   return (int)(ierror != 0);
-}
-
-/* Generate a compiler error if there is an old png.h in the search path. */
-typedef png_libpng_version_1_5_1 Your_png_h_is_not_version_1_5_1;
diff --git a/src/3rdparty/libpng/pngtrans.c b/src/3rdparty/libpng/pngtrans.c
index 137f555..fef12f1 100644
--- a/src/3rdparty/libpng/pngtrans.c
+++ b/src/3rdparty/libpng/pngtrans.c
@@ -1,8 +1,8 @@
 
 /* pngtrans.c - transforms the data in a row (used by both readers and writers)
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -424,170 +424,119 @@ png_do_packswap(png_row_infop row_info, png_bytep row)
 
 #if defined(PNG_WRITE_FILLER_SUPPORTED) || \
     defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
-/* Remove filler or alpha byte(s) */
+/* Remove a channel - this used to be 'png_do_strip_filler' but it used a
+ * somewhat weird combination of flags to determine what to do.  All the calls
+ * to png_do_strip_filler are changed in 1.5.2 to call this instead with the
+ * correct arguments.
+ *
+ * The routine isn't general - the channel must be the channel at the start or
+ * end (not in the middle) of each pixel.
+ */
 void /* PRIVATE */
-png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags)
+png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
 {
-   png_debug(1, "in png_do_strip_filler");
-
+   png_bytep sp = row; /* source pointer */
+   png_bytep dp = row; /* destination pointer */
+   png_bytep ep = row + row_info->rowbytes; /* One beyond end of row */
+
+   /* At the start sp will point to the first byte to copy and dp to where
+    * it is copied to.  ep always points just beyond the end of the row, so
+    * the loop simply copies (channels-1) channels until sp reaches ep.
+    *
+    * at_start:        0 -- convert AG, XG, ARGB, XRGB, AAGG, XXGG, etc.
+    *            nonzero -- convert GA, GX, RGBA, RGBX, GGAA, RRGGBBXX, etc.
+    */
+
+   /* GA, GX, XG cases */
+   if (row_info->channels == 2)
    {
-      png_bytep sp = row;
-      png_bytep dp = row;
-      png_uint_32 row_width = row_info->width;
-      png_uint_32 i;
-
-      if ((row_info->color_type == PNG_COLOR_TYPE_RGB ||
-          (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
-          (flags & PNG_FLAG_STRIP_ALPHA))) &&
-          row_info->channels == 4)
+      if (row_info->bit_depth == 8)
       {
-         if (row_info->bit_depth == 8)
-         {
-            /* This converts from RGBX or RGBA to RGB */
-            if (flags & PNG_FLAG_FILLER_AFTER)
-            {
-               dp += 3; sp += 4;
-               for (i = 1; i < row_width; i++)
-               {
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  sp++;
-               }
-            }
+         if (at_start) /* Skip initial filler */
+            ++sp;
+         else          /* Skip initial channel and, for sp, the filler */
+            sp += 2, ++dp;
 
-            /* This converts from XRGB or ARGB to RGB */
-            else
-            {
-               for (i = 0; i < row_width; i++)
-               {
-                  sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-               }
-            }
-            row_info->pixel_depth = 24;
-            row_info->rowbytes = row_width * 3;
-         }
+         /* For a 1 pixel wide image there is nothing to do */
+         while (sp < ep)
+            *dp++ = *sp, sp += 2;
 
-         else /* if (row_info->bit_depth == 16) */
-         {
-            if (flags & PNG_FLAG_FILLER_AFTER)
-            {
-               /* This converts from RRGGBBXX or RRGGBBAA to RRGGBB */
-               sp += 8; dp += 6;
-               for (i = 1; i < row_width; i++)
-               {
-                  /* This could be (although png_memcpy is probably slower):
-                  png_memcpy(dp, sp, 6);
-                  sp += 8;
-                  dp += 6;
-                  */
-
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  sp += 2;
-               }
-            }
+         row_info->pixel_depth = 8;
+      }
 
-            else
-            {
-               /* This converts from XXRRGGBB or AARRGGBB to RRGGBB */
-               for (i = 0; i < row_width; i++)
-               {
-                  /* This could be (although png_memcpy is probably slower):
-                  png_memcpy(dp, sp, 6);
-                  sp += 8;
-                  dp += 6;
-                  */
-
-                  sp += 2;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-               }
-            }
+      else if (row_info->bit_depth == 16)
+      {
+         if (at_start) /* Skip initial filler */
+            sp += 2;
+         else          /* Skip initial channel and, for sp, the filler */
+            sp += 4, dp += 2;
 
-            row_info->pixel_depth = 48;
-            row_info->rowbytes = row_width * 6;
-         }
-         row_info->channels = 3;
+         while (sp < ep)
+            *dp++ = *sp++, *dp++ = *sp, sp += 3;
+
+         row_info->pixel_depth = 16;
       }
 
-      else if ((row_info->color_type == PNG_COLOR_TYPE_GRAY ||
-         (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
-         (flags & PNG_FLAG_STRIP_ALPHA))) &&
-          row_info->channels == 2)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            if (flags & PNG_FLAG_FILLER_AFTER)
-            {
-               /* This converts from GX or GA to G */
-               for (i = 0; i < row_width; i++)
-               {
-                  *dp++ = *sp++;
-                  sp++;
-               }
-            }
+      else
+         return; /* bad bit depth */
 
-            else
-            {
-               /* This converts from XG or AG to G */
-               for (i = 0; i < row_width; i++)
-               {
-                  sp++;
-                  *dp++ = *sp++;
-               }
-            }
+      row_info->channels = 1;
 
-            row_info->pixel_depth = 8;
-            row_info->rowbytes = row_width;
-         }
+      /* Finally fix the color type if it records an alpha channel */
+      if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+         row_info->color_type = PNG_COLOR_TYPE_GRAY;
+   }
 
-         else /* if (row_info->bit_depth == 16) */
-         {
-            if (flags & PNG_FLAG_FILLER_AFTER)
-            {
-               /* This converts from GGXX or GGAA to GG */
-               sp += 4; dp += 2;
-               for (i = 1; i < row_width; i++)
-               {
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-                  sp += 2;
-               }
-            }
+   /* RGBA, RGBX, XRGB cases */
+   else if (row_info->channels == 4)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         if (at_start) /* Skip initial filler */
+            ++sp;
+         else          /* Skip initial channels and, for sp, the filler */
+            sp += 4, dp += 3;
 
-            else
-            {
-               /* This converts from XXGG or AAGG to GG */
-               for (i = 0; i < row_width; i++)
-               {
-                  sp += 2;
-                  *dp++ = *sp++;
-                  *dp++ = *sp++;
-               }
-            }
+         /* Note that the loop adds 3 to dp and 4 to sp each time. */
+         while (sp < ep)
+            *dp++ = *sp++, *dp++ = *sp++, *dp++ = *sp, sp += 2;
+
+         row_info->pixel_depth = 24;
+      }
+
+      else if (row_info->bit_depth == 16)
+      {
+         if (at_start) /* Skip initial filler */
+            sp += 2;
+         else          /* Skip initial channels and, for sp, the filler */
+            sp += 8, dp += 6;
 
-            row_info->pixel_depth = 16;
-            row_info->rowbytes = row_width * 2;
+         while (sp < ep)
+         {
+            /* Copy 6 bytes, skip 2 */
+            *dp++ = *sp++, *dp++ = *sp++;
+            *dp++ = *sp++, *dp++ = *sp++;
+            *dp++ = *sp++, *dp++ = *sp, sp += 3;
          }
-         row_info->channels = 1;
+
+         row_info->pixel_depth = 48;
       }
 
-      if (flags & PNG_FLAG_STRIP_ALPHA)
-        row_info->color_type = (png_byte)(row_info->color_type &
-            ~PNG_COLOR_MASK_ALPHA);
+      else
+         return; /* bad bit depth */
+
+      row_info->channels = 3;
+
+      /* Finally fix the color type if it records an alpha channel */
+      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+         row_info->color_type = PNG_COLOR_TYPE_RGB;
    }
+
+   else
+      return; /* The filler channel has gone already */
+
+   /* Fix the rowbytes value. */
+   row_info->rowbytes = dp-row;
 }
 #endif
 
@@ -670,6 +619,109 @@ png_do_bgr(png_row_infop row_info, png_bytep row)
 }
 #endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */
 
+#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
+    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
+/* Added at libpng-1.5.10 */
+void /* PRIVATE */
+png_do_check_palette_indexes(png_structp png_ptr, png_row_infop row_info)
+{
+   if (png_ptr->num_palette < (1 << row_info->bit_depth) &&
+      png_ptr->num_palette_max >= 0)
+   {
+      /* Calculations moved outside switch in an attempt to stop different
+       * compiler warnings.  'padding' is in *bits* within the last byte, it is
+       * an 'int' because pixel_depth becomes an 'int' in the expression below,
+       * and this calculation is used because it avoids warnings that other
+       * forms produced on either GCC or MSVC.
+       */
+      int padding = (-row_info->pixel_depth * row_info->width) & 7;
+      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;
+
+      switch (row_info->bit_depth)
+      {
+         case 1:
+         {
+            /* in this case, all bytes must be 0 so we don't need
+             * to unpack the pixels except for the rightmost one.
+             */
+            for (; rp > png_ptr->row_buf; rp--)
+            {
+              if (*rp >> padding != 0)
+                 png_ptr->num_palette_max = 1;
+              padding = 0;
+            }
+
+            break;
+         }
+
+         case 2:
+         {
+            for (; rp > png_ptr->row_buf; rp--)
+            {
+              int i = ((*rp >> padding) & 0x03);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              i = (((*rp >> padding) >> 2) & 0x03);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              i = (((*rp >> padding) >> 4) & 0x03);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              i = (((*rp >> padding) >> 6) & 0x03);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              padding = 0;
+            }
+
+            break;
+         }
+
+         case 4:
+         {
+            for (; rp > png_ptr->row_buf; rp--)
+            {
+              int i = ((*rp >> padding) & 0x0f);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              i = (((*rp >> padding) >> 4) & 0x0f);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              padding = 0;
+            }
+
+            break;
+         }
+
+         case 8:
+         {
+            for (; rp > png_ptr->row_buf; rp--)
+            {
+               if (*rp >= png_ptr->num_palette_max)
+                  png_ptr->num_palette_max = (int) *rp;
+            }
+
+            break;
+         }
+
+         default:
+            break;
+      }
+   }
+}
+#endif /* PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED */
+
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
 #ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
@@ -703,11 +755,16 @@ png_get_user_transform_ptr(png_const_structp png_ptr)
 }
 #endif
 
+#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED
 png_uint_32 PNGAPI
 png_get_current_row_number(png_const_structp png_ptr)
 {
+   /* See the comments in png.h - this is the sub-image row when reading and
+    * interlaced image.
+    */
    if (png_ptr != NULL)
       return png_ptr->row_number;
+
    return PNG_UINT_32_MAX; /* help the app not to fail silently */
 }
 
@@ -718,6 +775,7 @@ png_get_current_pass_number(png_const_structp png_ptr)
       return png_ptr->pass;
    return 8; /* invalid */
 }
+#endif /* PNG_USER_TRANSFORM_INFO_SUPPORTED */
 #endif /* PNG_READ_USER_TRANSFORM_SUPPORTED ||
           PNG_WRITE_USER_TRANSFORM_SUPPORTED */
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff --git a/src/3rdparty/libpng/pngvalid.c b/src/3rdparty/libpng/pngvalid.c
deleted file mode 100644
index faebe4b..0000000
--- a/src/3rdparty/libpng/pngvalid.c
+++ /dev/null
@@ -1,6658 +0,0 @@
-
-/* pngvalid.c - validate libpng by constructing then reading png files.
- *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 2011 Glenn Randers-Pehrson
- * Written by John Cunningham Bowler
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * NOTES:
- *   This is a C program that is intended to be linked against libpng.  It
- *   generates bitmaps internally, stores them as PNG files (using the
- *   sequential write code) then reads them back (using the sequential
- *   read code) and validates that the result has the correct data.
- *
- *   The program can be modified and extended to test the correctness of
- *   transformations performed by libpng.
- */
-
-#include "png.h"
-#if PNG_LIBPNG_VER < 10500
-/* This delibarately lacks the PNG_CONST. */
-typedef png_byte *png_const_bytep;
-
-/* This is copied from 1.5.1 png.h: */
-#define PNG_INTERLACE_ADAM7_PASSES 7
-#define PNG_PASS_START_ROW(pass) (((1U&~(pass))<<(3-((pass)>>1)))&7)
-#define PNG_PASS_START_COL(pass) (((1U& (pass))<<(3-(((pass)+1)>>1)))&7)
-#define PNG_PASS_ROW_SHIFT(pass) ((pass)>2?(8-(pass))>>1:3)
-#define PNG_PASS_COL_SHIFT(pass) ((pass)>1?(7-(pass))>>1:3)
-#define PNG_PASS_ROWS(height, pass) (((height)+(((1<<PNG_PASS_ROW_SHIFT(pass))\
-   -1)-PNG_PASS_START_ROW(pass)))>>PNG_PASS_ROW_SHIFT(pass))
-#define PNG_PASS_COLS(width, pass) (((width)+(((1<<PNG_PASS_COL_SHIFT(pass))\
-   -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))
-#define PNG_ROW_FROM_PASS_ROW(yIn, pass) \
-   (((yIn)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
-#define PNG_COL_FROM_PASS_COL(xIn, pass) \
-   (((xIn)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
-#define PNG_PASS_MASK(pass,off) ( \
-   ((0x110145AFU>>(((7-(off))-(pass))<<2)) & 0xFU) | \
-   ((0x01145AF0U>>(((7-(off))-(pass))<<2)) & 0xF0U))
-#define PNG_ROW_IN_INTERLACE_PASS(y, pass) \
-   ((PNG_PASS_MASK(pass,0) >> ((y)&7)) & 1)
-#define PNG_COL_IN_INTERLACE_PASS(x, pass) \
-   ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)
-
-/* These are needed too for the defualt build: */
-#define PNG_WRITE_16BIT_SUPPORTED
-#define PNG_READ_16BIT_SUPPORTED
-#endif
-
-#include "zlib.h"   /* For crc32 */
-
-#include <float.h>  /* For floating point constants */
-#include <stdlib.h> /* For malloc */
-#include <string.h> /* For memcpy, memset */
-#include <math.h>   /* For floor */
-
-/* Unused formal parameter errors are removed using the following macro which is
- * expected to have no bad effects on performance.
- */
-#ifndef UNUSED
-#  if defined(__GNUC__) || defined(_MSC_VER)
-#     define UNUSED(param) (void)param;
-#  else
-#     define UNUSED(param)
-#  endif
-#endif
-
-/***************************** EXCEPTION HANDLING *****************************/
-#include "contrib/visupng/cexcept.h"
-struct png_store;
-define_exception_type(struct png_store*);
-
-/* The following are macros to reduce typing everywhere where the well known
- * name 'the_exception_context' must be defined.
- */
-#define anon_context(ps) struct exception_context *the_exception_context = \
-   &(ps)->exception_context
-#define context(ps,fault) anon_context(ps); png_store *fault
-
-/******************************* UTILITIES ************************************/
-/* Error handling is particularly problematic in production code - error
- * handlers often themselves have bugs which lead to programs that detect
- * minor errors crashing.  The following functions deal with one very
- * common class of errors in error handlers - attempting to format error or
- * warning messages into buffers that are too small.
- */
-static size_t safecat(char *buffer, size_t bufsize, size_t pos,
-   PNG_CONST char *cat)
-{
-   while (pos < bufsize && cat != NULL && *cat != 0)
-      buffer[pos++] = *cat++;
-
-   if (pos >= bufsize)
-      pos = bufsize-1;
-
-   buffer[pos] = 0;
-   return pos;
-}
-
-static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-{
-   char number[64];
-   sprintf(number, "%d", n);
-   return safecat(buffer, bufsize, pos, number);
-}
-
-static size_t safecatd(char *buffer, size_t bufsize, size_t pos, double d,
-    int precision)
-{
-   char number[64];
-   sprintf(number, "%.*f", precision, d);
-   return safecat(buffer, bufsize, pos, number);
-}
-
-static PNG_CONST char invalid[] = "invalid";
-static PNG_CONST char sep[] = ": ";
-
-/* NOTE: this is indexed by ln2(bit_depth)! */
-static PNG_CONST char *bit_depths[8] =
-{
-   "1", "2", "4", "8", "16", invalid, invalid, invalid
-};
-
-static PNG_CONST char *colour_types[8] =
-{
-   "greyscale", invalid, "truecolour", "indexed-colour",
-   "greyscale with alpha", invalid, "truecolour with alpha", invalid
-};
-
-/* To get log-bit-depth from bit depth, returns 0 to 7 (7 on error). */
-static unsigned int
-log2depth(png_byte bit_depth)
-{
-   switch (bit_depth)
-   {
-      case 1:
-         return 0;
-
-      case 2:
-         return 1;
-
-      case 4:
-         return 2;
-
-      case 8:
-         return 3;
-
-      case 16:
-         return 4;
-
-      default:
-         return 7;
-   }
-}
-
-/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field
- * simply records whether pngvalid did the interlace itself or whether it
- * was done by libpng.  Width and height must be less than 256.
- */
-#define FILEID(col, depth, interlace, width, height, do_interlace) \
-   ((png_uint_32)((col) + ((depth)<<3) + ((interlace)<<8) + \
-    (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
-
-#define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
-#define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))
-#define INTERLACE_FROM_ID(id) ((int)(((id) >> 8) & 0x3))
-#define DO_INTERLACE_FROM_ID(id) ((int)(((id)>>15) & 1))
-#define WIDTH_FROM_ID(id) (((id)>>16) & 0xff)
-#define HEIGHT_FROM_ID(id) (((id)>>24) & 0xff)
-
-/* Utility to construct a standard name for a standard image. */
-static size_t
-standard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type,
-    int log_bit_depth, int interlace_type, png_uint_32 w, png_uint_32 h,
-    int do_interlace)
-{
-   pos = safecat(buffer, bufsize, pos, colour_types[colour_type]);
-   pos = safecat(buffer, bufsize, pos, " ");
-   pos = safecat(buffer, bufsize, pos, bit_depths[log_bit_depth]);
-   pos = safecat(buffer, bufsize, pos, " bit ");
-
-   if (interlace_type != PNG_INTERLACE_NONE)
-      pos = safecat(buffer, bufsize, pos, "interlaced");
-   if (do_interlace)
-      pos = safecat(buffer, bufsize, pos, "(pngvalid)");
-   else
-      pos = safecat(buffer, bufsize, pos, "(libpng)");
-   if (w > 0 || h > 0)
-   {
-      pos = safecat(buffer, bufsize, pos, " ");
-      pos = safecatn(buffer, bufsize, pos, w);
-      pos = safecat(buffer, bufsize, pos, "x");
-      pos = safecatn(buffer, bufsize, pos, h);
-   }
-
-   return pos;
-}
-
-static size_t
-standard_name_from_id(char *buffer, size_t bufsize, size_t pos, png_uint_32 id)
-{
-   return standard_name(buffer, bufsize, pos, COL_FROM_ID(id),
-      log2depth(DEPTH_FROM_ID(id)), INTERLACE_FROM_ID(id),
-      WIDTH_FROM_ID(id), HEIGHT_FROM_ID(id), DO_INTERLACE_FROM_ID(id));
-}
-
-/* Convenience API and defines to list valid formats.  Note that 16 bit read and
- * write support is required to do 16 bit read tests (we must be able to make a
- * 16 bit image to test!)
- */
-#ifdef PNG_WRITE_16BIT_SUPPORTED
-#  define WRITE_BDHI 4
-#  ifdef PNG_READ_16BIT_SUPPORTED
-#     define READ_BDHI 4
-#     define DO_16BIT
-#  endif
-#else
-#  define WRITE_BDHI 3
-#endif
-#ifndef DO_16BIT
-#  define READ_BDHI 3
-#endif
-
-static int
-next_format(png_bytep colour_type, png_bytep bit_depth)
-{
-   if (*bit_depth == 0)
-   {
-      *colour_type = 0, *bit_depth = 1;
-      return 1;
-   }
-
-   *bit_depth = (png_byte)(*bit_depth << 1);
-
-   /* Palette images are restricted to 8 bit depth */
-   if (*bit_depth <= 8
-#     ifdef DO_16BIT
-         || (*colour_type != 3 && *bit_depth <= 16)
-#     endif
-      )
-      return 1;
-
-   /* Move to the next color type, or return 0 at the end. */
-   switch (*colour_type)
-   {
-      case 0:
-         *colour_type = 2;
-         *bit_depth = 8;
-         return 1;
-
-      case 2:
-         *colour_type = 3;
-         *bit_depth = 1;
-         return 1;
-
-      case 3:
-         *colour_type = 4;
-         *bit_depth = 8;
-         return 1;
-
-      case 4:
-         *colour_type = 6;
-         *bit_depth = 8;
-         return 1;
-
-      default:
-         return 0;
-   }
-}
-
-static unsigned int
-sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,
-    png_uint_32 x, unsigned int sample_index)
-{
-   png_uint_32 bit_index, result;
-
-   /* Find a sample index for the desired sample: */
-   x *= bit_depth;
-   bit_index = x;
-
-   if ((colour_type & 1) == 0) /* !palette */
-   {
-      if (colour_type & 2)
-         bit_index *= 3;
-
-      if (colour_type & 4)
-         bit_index += x; /* Alpha channel */
-
-      if (colour_type & (2+4))
-         bit_index += sample_index * bit_depth; /* Multiple channels: select one */
-   }
-
-   /* Return the sample from the row as an integer. */
-   row += bit_index >> 3;
-   result = *row;
-
-   if (bit_depth == 8)
-      return result;
-
-   else if (bit_depth > 8)
-      return (result << 8) + *++row;
-
-   /* Less than 8 bits per sample. */
-   bit_index &= 7;
-   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);
-}
-
-/* Copy a single pixel, of a given size, from one buffer to another -
- * while this is basically bit addressed there is an implicit assumption
- * that pixels 8 or more bits in size are byte aligned and that pixels
- * do not otherwise cross byte boundaries.  (This is, so far as I know,
- * universally true in bitmap computer graphics.  [JCB 20101212])
- *
- * NOTE: The to and from buffers may be the same.
- */
-static void
-pixel_copy(png_bytep toBuffer, png_uint_32 toIndex,
-   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize)
-{
-   /* Assume we can multiply by 'size' without overflow because we are
-    * just working in a single buffer.
-    */
-   toIndex *= pixelSize;
-   fromIndex *= pixelSize;
-   if (pixelSize < 8) /* Sub-byte */
-   {
-      /* Mask to select the location of the copied pixel: */
-      unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7));
-      /* The following read the entire pixels and clears the extra: */
-      unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;
-      unsigned int sourceByte = fromBuffer[fromIndex >> 3];
-
-      /* Don't rely on << or >> supporting '0' here, just in case: */
-      fromIndex &= 7;
-      if (fromIndex > 0) sourceByte <<= fromIndex;
-      if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;
-
-      toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask));
-   }
-   else /* One or more bytes */
-      memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);
-}
-
-/* Compare pixels - they are assumed to start at the first byte in the
- * given buffers.
- */
-static int
-pixel_cmp(png_const_bytep pa, png_const_bytep pb, png_uint_32 bit_width)
-{
-   if (memcmp(pa, pb, bit_width>>3) == 0)
-   {
-      png_uint_32 p;
-
-      if ((bit_width & 7) == 0) return 0;
-
-      /* Ok, any differences? */
-      p = pa[bit_width >> 3];
-      p ^= pb[bit_width >> 3];
-
-      if (p == 0) return 0;
-
-      /* There are, but they may not be significant, remove the bits
-       * after the end (the low order bits in PNG.)
-       */
-      bit_width &= 7;
-      p >>= 8-bit_width;
-
-      if (p == 0) return 0;
-   }
-
-   return 1; /* Different */
-}
-
-/*************************** BASIC PNG FILE WRITING ***************************/
-/* A png_store takes data from the sequential writer or provides data
- * to the sequential reader.  It can also store the result of a PNG
- * write for later retrieval.
- */
-#define STORE_BUFFER_SIZE 500 /* arbitrary */
-typedef struct png_store_buffer
-{
-   struct png_store_buffer*  prev;    /* NOTE: stored in reverse order */
-   png_byte                  buffer[STORE_BUFFER_SIZE];
-} png_store_buffer;
-
-#define FILE_NAME_SIZE 64
-
-typedef struct png_store_file
-{
-   struct png_store_file*  next;      /* as many as you like... */
-   char                    name[FILE_NAME_SIZE];
-   png_uint_32             id;        /* must be correct (see FILEID) */
-   png_size_t              datacount; /* In this (the last) buffer */
-   png_store_buffer        data;      /* Last buffer in file */
-} png_store_file;
-
-/* The following is a pool of memory allocated by a single libpng read or write
- * operation.
- */
-typedef struct store_pool
-{
-   struct png_store    *store;   /* Back pointer */
-   struct store_memory *list;    /* List of allocated memory */
-   png_byte             mark[4]; /* Before and after data */
-
-   /* Statistics for this run. */
-   png_alloc_size_t     max;     /* Maximum single allocation */
-   png_alloc_size_t     current; /* Current allocation */
-   png_alloc_size_t     limit;   /* Highest current allocation */
-   png_alloc_size_t     total;   /* Total allocation */
-
-   /* Overall statistics (retained across successive runs). */
-   png_alloc_size_t     max_max;
-   png_alloc_size_t     max_limit;
-   png_alloc_size_t     max_total;
-} store_pool;
-
-typedef struct png_store
-{
-   /* For cexcept.h exception handling - simply store one of these;
-    * the context is a self pointer but it may point to a different
-    * png_store (in fact it never does in this program.)
-    */
-   struct exception_context
-                      exception_context;
-
-   unsigned int       verbose :1;
-   unsigned int       treat_warnings_as_errors :1;
-   unsigned int       expect_error :1;
-   unsigned int       expect_warning :1;
-   unsigned int       saw_warning :1;
-   unsigned int       speed :1;
-   unsigned int       progressive :1; /* use progressive read */
-   unsigned int       validated :1;   /* used as a temporary flag */
-   int                nerrors;
-   int                nwarnings;
-   char               test[128]; /* Name of test */
-   char               error[256];
-
-   /* Read fields */
-   png_structp        pread;    /* Used to read a saved file */
-   png_infop          piread;
-   png_store_file*    current;  /* Set when reading */
-   png_store_buffer*  next;     /* Set when reading */
-   png_size_t         readpos;  /* Position in *next */
-   png_byte*          image;    /* Buffer for reading interlaced images */
-   size_t             cb_image; /* Size of this buffer */
-   store_pool         read_memory_pool;
-
-   /* Write fields */
-   png_store_file*    saved;
-   png_structp        pwrite;   /* Used when writing a new file */
-   png_infop          piwrite;
-   png_size_t         writepos; /* Position in .new */
-   char               wname[FILE_NAME_SIZE];
-   png_store_buffer   new;      /* The end of the new PNG file being written. */
-   store_pool         write_memory_pool;
-} png_store;
-
-/* Initialization and cleanup */
-static void
-store_pool_mark(png_byte *mark)
-{
-   /* Generate a new mark.  This uses a boring repeatable algorithm and it is
-    * implemented here so that it gives the same set of numbers on every
-    * architecture.  It's a linear congruential generator (Knuth or Sedgewick
-    * "Algorithms") but it comes from the 'feedback taps' table in Horowitz and
-    * Hill, "The Art of Electronics".
-    */
-   static png_uint_32 u0 = 0x12345678, u1 = 1;
-
-   /* There are thirty three bits, the next bit in the sequence is bit-33 XOR
-    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.
-    */
-   int i;
-   for (i=0; i<4; ++i)
-   {
-      /* First generate 8 new bits then shift them in at the end. */
-      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
-      u1 <<= 8;
-      u1 |= u0 >> 24;
-      u0 <<= 8;
-      u0 |= u;
-      *mark++ = (png_byte)u;
-   }
-}
-
-/* Use this for random 32 bit values, this function makes sure the result is
- * non-zero.
- */
-static png_uint_32
-random_32(void)
-{
-
-   for(;;)
-   {
-      png_byte mark[4];
-      png_uint_32 result;
-
-      store_pool_mark(mark);
-      result = png_get_uint_32(mark);
-
-      if (result != 0)
-         return result;
-   }
-}
-
-static void
-store_pool_init(png_store *ps, store_pool *pool)
-{
-   memset(pool, 0, sizeof *pool);
-
-   pool->store = ps;
-   pool->list = NULL;
-   pool->max = pool->current = pool->limit = pool->total = 0;
-   pool->max_max = pool->max_limit = pool->max_total = 0;
-   store_pool_mark(pool->mark);
-}
-
-static void
-store_init(png_store* ps)
-{
-   memset(ps, 0, sizeof *ps);
-   init_exception_context(&ps->exception_context);
-   store_pool_init(ps, &ps->read_memory_pool);
-   store_pool_init(ps, &ps->write_memory_pool);
-   ps->verbose = 0;
-   ps->treat_warnings_as_errors = 0;
-   ps->expect_error = 0;
-   ps->expect_warning = 0;
-   ps->saw_warning = 0;
-   ps->speed = 0;
-   ps->progressive = 0;
-   ps->validated = 0;
-   ps->nerrors = ps->nwarnings = 0;
-   ps->pread = NULL;
-   ps->piread = NULL;
-   ps->saved = ps->current = NULL;
-   ps->next = NULL;
-   ps->readpos = 0;
-   ps->image = NULL;
-   ps->cb_image = 0;
-   ps->pwrite = NULL;
-   ps->piwrite = NULL;
-   ps->writepos = 0;
-   ps->new.prev = NULL;
-}
-
-/* This somewhat odd function is used when reading an image to ensure that the
- * buffer is big enough - this is why a png_structp is available.
- */
-static void
-store_ensure_image(png_store *ps, png_structp pp, size_t cb)
-{
-   if (ps->cb_image < cb)
-   {
-      if (ps->image != NULL)
-      {
-         free(ps->image-1);
-         ps->cb_image = 0;
-      }
-
-      /* The buffer is deliberately mis-aligned. */
-      ps->image = malloc(cb+1);
-      if (ps->image == NULL)
-         png_error(pp, "OOM allocating image buffer");
-
-      ++(ps->image);
-      ps->cb_image = cb;
-   }
-
-   /* And, for error checking, the whole buffer is set to '1' - this
-    * matches what happens with the 'size' test images on write and also
-    * matches the unused bits in the test rows.
-    */
-   memset(ps->image, 0xff, cb);
-}
-
-static void
-store_freebuffer(png_store_buffer* psb)
-{
-   if (psb->prev)
-   {
-      store_freebuffer(psb->prev);
-      free(psb->prev);
-      psb->prev = NULL;
-   }
-}
-
-static void
-store_freenew(png_store *ps)
-{
-   store_freebuffer(&ps->new);
-   ps->writepos = 0;
-}
-
-static void
-store_storenew(png_store *ps)
-{
-   png_store_buffer *pb;
-
-   if (ps->writepos != STORE_BUFFER_SIZE)
-      png_error(ps->pwrite, "invalid store call");
-
-   pb = malloc(sizeof *pb);
-
-   if (pb == NULL)
-      png_error(ps->pwrite, "store new: OOM");
-
-   *pb = ps->new;
-   ps->new.prev = pb;
-   ps->writepos = 0;
-}
-
-static void
-store_freefile(png_store_file **ppf)
-{
-   if (*ppf != NULL)
-   {
-      store_freefile(&(*ppf)->next);
-
-      store_freebuffer(&(*ppf)->data);
-      (*ppf)->datacount = 0;
-      free(*ppf);
-      *ppf = NULL;
-   }
-}
-
-/* Main interface to file storeage, after writing a new PNG file (see the API
- * below) call store_storefile to store the result with the given name and id.
- */
-static void
-store_storefile(png_store *ps, png_uint_32 id)
-{
-   png_store_file *pf = malloc(sizeof *pf);
-   if (pf == NULL)
-      png_error(ps->pwrite, "storefile: OOM");
-   safecat(pf->name, sizeof pf->name, 0, ps->wname);
-   pf->id = id;
-   pf->data = ps->new;
-   pf->datacount = ps->writepos;
-   ps->new.prev = NULL;
-   ps->writepos = 0;
-
-   /* And save it. */
-   pf->next = ps->saved;
-   ps->saved = pf;
-}
-
-/* Generate an error message (in the given buffer) */
-static size_t
-store_message(png_store *ps, png_structp pp, char *buffer, size_t bufsize,
-   size_t pos, PNG_CONST char *msg)
-{
-   if (pp != NULL && pp == ps->pread)
-   {
-      /* Reading a file */
-      pos = safecat(buffer, bufsize, pos, "read: ");
-
-      if (ps->current != NULL)
-      {
-         pos = safecat(buffer, bufsize, pos, ps->current->name);
-         pos = safecat(buffer, bufsize, pos, sep);
-      }
-   }
-
-   else if (pp != NULL && pp == ps->pwrite)
-   {
-      /* Writing a file */
-      pos = safecat(buffer, bufsize, pos, "write: ");
-      pos = safecat(buffer, bufsize, pos, ps->wname);
-      pos = safecat(buffer, bufsize, pos, sep);
-   }
-
-   else
-   {
-      /* Neither reading nor writing (or a memory error in struct delete) */
-      pos = safecat(buffer, bufsize, pos, "pngvalid: ");
-   }
-
-   if (ps->test[0] != 0)
-   {
-      pos = safecat(buffer, bufsize, pos, ps->test);
-      pos = safecat(buffer, bufsize, pos, sep);
-   }
-   pos = safecat(buffer, bufsize, pos, msg);
-   return pos;
-}
-
-/* Log an error or warning - the relevant count is always incremented. */
-static void
-store_log(png_store* ps, png_structp pp, png_const_charp message, int is_error)
-{
-   /* The warning is copied to the error buffer if there are no errors and it is
-    * the first warning.  The error is copied to the error buffer if it is the
-    * first error (overwriting any prior warnings).
-    */
-   if (is_error ? (ps->nerrors)++ == 0 :
-       (ps->nwarnings)++ == 0 && ps->nerrors == 0)
-      store_message(ps, pp, ps->error, sizeof ps->error, 0, message);
-
-   if (ps->verbose)
-   {
-      char buffer[256];
-      size_t pos;
-
-      if (is_error)
-         pos = safecat(buffer, sizeof buffer, 0, "error: ");
-      else
-         pos = safecat(buffer, sizeof buffer, 0, "warning: ");
-
-      store_message(ps, pp, buffer, sizeof buffer, pos, message);
-      fputs(buffer, stderr);
-      fputc('\n', stderr);
-   }
-}
-
-/* Functions to use as PNG callbacks. */
-static void
-store_error(png_structp pp, png_const_charp message) /* PNG_NORETURN */
-{
-   png_store *ps = png_get_error_ptr(pp);
-
-   if (!ps->expect_error)
-      store_log(ps, pp, message, 1 /* error */);
-
-   /* And finally throw an exception. */
-   {
-      struct exception_context *the_exception_context = &ps->exception_context;
-      Throw ps;
-   }
-}
-
-static void
-store_warning(png_structp pp, png_const_charp message)
-{
-   png_store *ps = png_get_error_ptr(pp);
-
-   if (!ps->expect_warning)
-      store_log(ps, pp, message, 0 /* warning */);
-   else
-      ps->saw_warning = 1;
-}
-
-static void
-store_write(png_structp pp, png_bytep pb, png_size_t st)
-{
-   png_store *ps = png_get_io_ptr(pp);
-
-   if (ps->pwrite != pp)
-      png_error(pp, "store state damaged");
-
-   while (st > 0)
-   {
-      size_t cb;
-
-      if (ps->writepos >= STORE_BUFFER_SIZE)
-         store_storenew(ps);
-
-      cb = st;
-
-      if (cb > STORE_BUFFER_SIZE - ps->writepos)
-         cb = STORE_BUFFER_SIZE - ps->writepos;
-
-      memcpy(ps->new.buffer + ps->writepos, pb, cb);
-      pb += cb;
-      st -= cb;
-      ps->writepos += cb;
-   }
-}
-
-static void
-store_flush(png_structp pp)
-{
-   UNUSED(pp) /*DOES NOTHING*/
-}
-
-static size_t
-store_read_buffer_size(png_store *ps)
-{
-   /* Return the bytes available for read in the current buffer. */
-   if (ps->next != &ps->current->data)
-      return STORE_BUFFER_SIZE;
-
-   return ps->current->datacount;
-}
-
-/* Return total bytes available for read. */
-static size_t
-store_read_buffer_avail(png_store *ps)
-{
-   if (ps->current != NULL && ps->next != NULL)
-   {
-      png_store_buffer *next = &ps->current->data;
-      size_t cbAvail = ps->current->datacount;
-
-      while (next != ps->next && next != NULL)
-      {
-         next = next->prev;
-         cbAvail += STORE_BUFFER_SIZE;
-      }
-
-      if (next != ps->next)
-         png_error(ps->pread, "buffer read error");
-
-      if (cbAvail > ps->readpos)
-         return cbAvail - ps->readpos;
-   }
-
-   return 0;
-}
-
-static int
-store_read_buffer_next(png_store *ps)
-{
-   png_store_buffer *pbOld = ps->next;
-   png_store_buffer *pbNew = &ps->current->data;
-   if (pbOld != pbNew)
-   {
-      while (pbNew != NULL && pbNew->prev != pbOld)
-         pbNew = pbNew->prev;
-
-      if (pbNew != NULL)
-      {
-         ps->next = pbNew;
-         ps->readpos = 0;
-         return 1;
-      }
-
-      png_error(ps->pread, "buffer lost");
-   }
-
-   return 0; /* EOF or error */
-}
-
-/* Need separate implementation and callback to allow use of the same code
- * during progressive read, where the io_ptr is set internally by libpng.
- */
-static void
-store_read_imp(png_store *ps, png_bytep pb, png_size_t st)
-{
-   if (ps->current == NULL || ps->next == NULL)
-      png_error(ps->pread, "store state damaged");
-
-   while (st > 0)
-   {
-      size_t cbAvail = store_read_buffer_size(ps) - ps->readpos;
-
-      if (cbAvail > 0)
-      {
-         if (cbAvail > st) cbAvail = st;
-         memcpy(pb, ps->next->buffer + ps->readpos, cbAvail);
-         st -= cbAvail;
-         pb += cbAvail;
-         ps->readpos += cbAvail;
-      }
-
-      else if (!store_read_buffer_next(ps))
-         png_error(ps->pread, "read beyond end of file");
-   }
-}
-
-static void
-store_read(png_structp pp, png_bytep pb, png_size_t st)
-{
-   png_store *ps = png_get_io_ptr(pp);
-
-   if (ps == NULL || ps->pread != pp)
-      png_error(pp, "bad store read call");
-
-   store_read_imp(ps, pb, st);
-}
-
-static void
-store_progressive_read(png_store *ps, png_structp pp, png_infop pi)
-{
-   /* Notice that a call to store_read will cause this function to fail because
-    * readpos will be set.
-    */
-   if (ps->pread != pp || ps->current == NULL || ps->next == NULL)
-      png_error(pp, "store state damaged (progressive)");
-
-   do
-   {
-      if (ps->readpos != 0)
-         png_error(pp, "store_read called during progressive read");
-
-      png_process_data(pp, pi, ps->next->buffer, store_read_buffer_size(ps));
-   }
-   while (store_read_buffer_next(ps));
-}
-
-/***************************** MEMORY MANAGEMENT*** ***************************/
-/* A store_memory is simply the header for an allocated block of memory.  The
- * pointer returned to libpng is just after the end of the header block, the
- * allocated memory is followed by a second copy of the 'mark'.
- */
-typedef struct store_memory
-{
-   store_pool          *pool;    /* Originating pool */
-   struct store_memory *next;    /* Singly linked list */
-   png_alloc_size_t     size;    /* Size of memory allocated */
-   png_byte             mark[4]; /* ID marker */
-} store_memory;
-
-/* Handle a fatal error in memory allocation.  This calls png_error if the
- * libpng struct is non-NULL, else it outputs a message and returns.  This means
- * that a memory problem while libpng is running will abort (png_error) the
- * handling of particular file while one in cleanup (after the destroy of the
- * struct has returned) will simply keep going and free (or attempt to free)
- * all the memory.
- */
-static void
-store_pool_error(png_store *ps, png_structp pp, PNG_CONST char *msg)
-{
-   if (pp != NULL)
-      png_error(pp, msg);
-
-   /* Else we have to do it ourselves.  png_error eventually calls store_log,
-    * above.  store_log accepts a NULL png_structp - it just changes what gets
-    * output by store_message.
-    */
-   store_log(ps, pp, msg, 1 /* error */);
-}
-
-static void
-store_memory_free(png_structp pp, store_pool *pool, store_memory *memory)
-{
-   /* Note that pp may be NULL (see store_pool_delete below), the caller has
-    * found 'memory' in pool->list *and* unlinked this entry, so this is a valid
-    * pointer (for sure), but the contents may have been trashed.
-    */
-   if (memory->pool != pool)
-      store_pool_error(pool->store, pp, "memory corrupted (pool)");
-
-   else if (memcmp(memory->mark, pool->mark, sizeof memory->mark) != 0)
-      store_pool_error(pool->store, pp, "memory corrupted (start)");
-
-   /* It should be safe to read the size field now. */
-   else
-   {
-      png_alloc_size_t cb = memory->size;
-
-      if (cb > pool->max)
-         store_pool_error(pool->store, pp, "memory corrupted (size)");
-
-      else if (memcmp((png_bytep)(memory+1)+cb, pool->mark, sizeof pool->mark)
-         != 0)
-         store_pool_error(pool->store, pp, "memory corrupted (end)");
-
-      /* Finally give the library a chance to find problems too: */
-      else
-         {
-         pool->current -= cb;
-         free(memory);
-         }
-   }
-}
-
-static void
-store_pool_delete(png_store *ps, store_pool *pool)
-{
-   if (pool->list != NULL)
-   {
-      fprintf(stderr, "%s: %s %s: memory lost (list follows):\n", ps->test,
-         pool == &ps->read_memory_pool ? "read" : "write",
-         pool == &ps->read_memory_pool ? (ps->current != NULL ?
-            ps->current->name : "unknown file") : ps->wname);
-      ++ps->nerrors;
-
-      do
-      {
-         store_memory *next = pool->list;
-         pool->list = next->next;
-         next->next = NULL;
-
-         fprintf(stderr, "\t%lu bytes @ %p\n",
-             (unsigned long)next->size, next+1);
-         /* The NULL means this will always return, even if the memory is
-          * corrupted.
-          */
-         store_memory_free(NULL, pool, next);
-      }
-      while (pool->list != NULL);
-   }
-
-   /* And reset the other fields too for the next time. */
-   if (pool->max > pool->max_max) pool->max_max = pool->max;
-   pool->max = 0;
-   if (pool->current != 0) /* unexpected internal error */
-      fprintf(stderr, "%s: %s %s: memory counter mismatch (internal error)\n",
-         ps->test, pool == &ps->read_memory_pool ? "read" : "write",
-         pool == &ps->read_memory_pool ? (ps->current != NULL ?
-            ps->current->name : "unknown file") : ps->wname);
-   pool->current = 0;
-
-   if (pool->limit > pool->max_limit)
-      pool->max_limit = pool->limit;
-
-   pool->limit = 0;
-
-   if (pool->total > pool->max_total)
-      pool->max_total = pool->total;
-
-   pool->total = 0;
-
-   /* Get a new mark too. */
-   store_pool_mark(pool->mark);
-}
-
-/* The memory callbacks: */
-static png_voidp
-store_malloc(png_structp pp, png_alloc_size_t cb)
-{
-   store_pool *pool = png_get_mem_ptr(pp);
-   store_memory *new = malloc(cb + (sizeof *new) + (sizeof pool->mark));
-
-   if (new != NULL)
-   {
-      if (cb > pool->max)
-         pool->max = cb;
-
-      pool->current += cb;
-
-      if (pool->current > pool->limit)
-         pool->limit = pool->current;
-
-      pool->total += cb;
-
-      new->size = cb;
-      memcpy(new->mark, pool->mark, sizeof new->mark);
-      memcpy((png_byte*)(new+1) + cb, pool->mark, sizeof pool->mark);
-      new->pool = pool;
-      new->next = pool->list;
-      pool->list = new;
-      ++new;
-   }
-
-   else
-      store_pool_error(pool->store, pp, "out of memory");
-
-   return new;
-}
-
-static void
-store_free(png_structp pp, png_voidp memory)
-{
-   store_pool *pool = png_get_mem_ptr(pp);
-   store_memory *this = memory, **test;
-
-   /* First check that this 'memory' really is valid memory - it must be in the
-    * pool list.  If it is, use the shared memory_free function to free it.
-    */
-   --this;
-   for (test = &pool->list; *test != this; test = &(*test)->next)
-   {
-      if (*test == NULL)
-      {
-         store_pool_error(pool->store, pp, "bad pointer to free");
-         return;
-      }
-   }
-
-   /* Unlink this entry, *test == this. */
-   *test = this->next;
-   this->next = NULL;
-   store_memory_free(pp, pool, this);
-}
-
-/* Setup functions. */
-/* Cleanup when aborting a write or after storing the new file. */
-static void
-store_write_reset(png_store *ps)
-{
-   if (ps->pwrite != NULL)
-   {
-      anon_context(ps);
-
-      Try
-         png_destroy_write_struct(&ps->pwrite, &ps->piwrite);
-
-      Catch_anonymous
-      {
-         /* memory corruption: continue. */
-      }
-
-      ps->pwrite = NULL;
-      ps->piwrite = NULL;
-   }
-
-   /* And make sure that all the memory has been freed - this will output
-    * spurious errors in the case of memory corruption above, but this is safe.
-    */
-   store_pool_delete(ps, &ps->write_memory_pool);
-
-   store_freenew(ps);
-}
-
-/* The following is the main write function, it returns a png_struct and,
- * optionally, a png_info suitable for writiing a new PNG file.  Use
- * store_storefile above to record this file after it has been written.  The
- * returned libpng structures as destroyed by store_write_reset above.
- */
-static png_structp
-set_store_for_write(png_store *ps, png_infopp ppi,
-   PNG_CONST char * volatile name)
-{
-   anon_context(ps);
-
-   Try
-   {
-      if (ps->pwrite != NULL)
-         png_error(ps->pwrite, "write store already in use");
-
-      store_write_reset(ps);
-      safecat(ps->wname, sizeof ps->wname, 0, name);
-
-      /* Don't do the slow memory checks if doing a speed test. */
-      if (ps->speed)
-         ps->pwrite = png_create_write_struct(PNG_LIBPNG_VER_STRING,
-            ps, store_error, store_warning);
-
-      else
-         ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,
-            ps, store_error, store_warning, &ps->write_memory_pool,
-            store_malloc, store_free);
-
-      png_set_write_fn(ps->pwrite, ps, store_write, store_flush);
-
-      if (ppi != NULL)
-         *ppi = ps->piwrite = png_create_info_struct(ps->pwrite);
-   }
-
-   Catch_anonymous
-      return NULL;
-
-   return ps->pwrite;
-}
-
-/* Cleanup when finished reading (either due to error or in the success case).
- */
-static void
-store_read_reset(png_store *ps)
-{
-   if (ps->pread != NULL)
-   {
-      anon_context(ps);
-
-      Try
-         png_destroy_read_struct(&ps->pread, &ps->piread, NULL);
-
-      Catch_anonymous
-      {
-         /* error already output: continue */
-      }
-
-      ps->pread = NULL;
-      ps->piread = NULL;
-   }
-
-   /* Always do this to be safe. */
-   store_pool_delete(ps, &ps->read_memory_pool);
-
-   ps->current = NULL;
-   ps->next = NULL;
-   ps->readpos = 0;
-   ps->validated = 0;
-}
-
-static void
-store_read_set(png_store *ps, png_uint_32 id)
-{
-   png_store_file *pf = ps->saved;
-
-   while (pf != NULL)
-   {
-      if (pf->id == id)
-      {
-         ps->current = pf;
-         ps->next = NULL;
-         store_read_buffer_next(ps);
-         return;
-      }
-
-      pf = pf->next;
-   }
-
-      {
-      size_t pos;
-      char msg[FILE_NAME_SIZE+64];
-
-      pos = standard_name_from_id(msg, sizeof msg, 0, id);
-      pos = safecat(msg, sizeof msg, pos, ": file not found");
-      png_error(ps->pread, msg);
-      }
-}
-
-/* The main interface for reading a saved file - pass the id number of the file
- * to retrieve.  Ids must be unique or the earlier file will be hidden.  The API
- * returns a png_struct and, optionally, a png_info.  Both of these will be
- * destroyed by store_read_reset above.
- */
-static png_structp
-set_store_for_read(png_store *ps, png_infopp ppi, png_uint_32 id,
-   PNG_CONST char *name)
-{
-   /* Set the name for png_error */
-   safecat(ps->test, sizeof ps->test, 0, name);
-
-   if (ps->pread != NULL)
-      png_error(ps->pread, "read store already in use");
-
-   store_read_reset(ps);
-
-   /* Both the create APIs can return NULL if used in their default mode
-    * (because there is no other way of handling an error because the jmp_buf
-    * by default is stored in png_struct and that has not been allocated!)
-    * However, given that store_error works correctly in these circumstances
-    * we don't ever expect NULL in this program.
-    */
-   if (ps->speed)
-      ps->pread = png_create_read_struct(PNG_LIBPNG_VER_STRING, ps,
-          store_error, store_warning);
-
-   else
-      ps->pread = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, ps,
-          store_error, store_warning, &ps->read_memory_pool, store_malloc,
-          store_free);
-
-   if (ps->pread == NULL)
-   {
-      struct exception_context *the_exception_context = &ps->exception_context;
-
-      store_log(ps, NULL, "png_create_read_struct returned NULL (unexpected)",
-         1 /*error*/);
-
-      Throw ps;
-   }
-
-   store_read_set(ps, id);
-
-   if (ppi != NULL)
-      *ppi = ps->piread = png_create_info_struct(ps->pread);
-
-   return ps->pread;
-}
-
-/* The overall cleanup of a store simply calls the above then removes all the
- * saved files.  This does not delete the store itself.
- */
-static void
-store_delete(png_store *ps)
-{
-   store_write_reset(ps);
-   store_read_reset(ps);
-   store_freefile(&ps->saved);
-
-   if (ps->image != NULL)
-   {
-      free(ps->image-1);
-      ps->image = NULL;
-      ps->cb_image = 0;
-   }
-}
-
-/*********************** PNG FILE MODIFICATION ON READ ************************/
-/* Files may be modified on read.  The following structure contains a complete
- * png_store together with extra members to handle modification and a special
- * read callback for libpng.  To use this the 'modifications' field must be set
- * to a list of png_modification structures that actually perform the
- * modification, otherwise a png_modifier is functionally equivalent to a
- * png_store.  There is a special read function, set_modifier_for_read, which
- * replaces set_store_for_read.
- */
-typedef struct png_modifier
-{
-   png_store               this;             /* I am a png_store */
-   struct png_modification *modifications;   /* Changes to make */
-
-   enum modifier_state
-   {
-      modifier_start,                        /* Initial value */
-      modifier_signature,                    /* Have a signature */
-      modifier_IHDR                          /* Have an IHDR */
-   }                        state;           /* My state */
-
-   /* Information from IHDR: */
-   png_byte                 bit_depth;       /* From IHDR */
-   png_byte                 colour_type;     /* From IHDR */
-
-   /* While handling PLTE, IDAT and IEND these chunks may be pended to allow
-    * other chunks to be inserted.
-    */
-   png_uint_32              pending_len;
-   png_uint_32              pending_chunk;
-
-   /* Test values */
-   double                  *gammas;
-   unsigned int             ngammas;
-
-   /* Lowest sbit to test (libpng fails for sbit < 8) */
-   png_byte                 sbitlow;
-
-   /* Error control - these are the limits on errors accepted by the gamma tests
-    * below.
-    */
-   double                   maxout8;  /* Maximum output value error */
-   double                   maxabs8;  /* Absolute sample error 0..1 */
-   double                   maxpc8;   /* Percentage sample error 0..100% */
-   double                   maxout16; /* Maximum output value error */
-   double                   maxabs16; /* Absolute sample error 0..1 */
-   double                   maxpc16;  /* Percentage sample error 0..100% */
-
-   /* Logged 8 and 16 bit errors ('output' values): */
-   double                   error_gray_2;
-   double                   error_gray_4;
-   double                   error_gray_8;
-   double                   error_gray_16;
-   double                   error_color_8;
-   double                   error_color_16;
-
-   /* Flags: */
-   /* Whether or not to interlace. */
-   int                      interlace_type :9; /* int, but must store '1' */
-
-   /* Run the standard tests? */
-   unsigned int             test_standard :1;
-
-   /* Run the odd-sized image and interlace read/write tests? */
-   unsigned int             test_size :1;
-
-   /* Run tests on reading with a combiniation of transforms, */
-   unsigned int             test_transform :1;
-
-   /* When to use the use_input_precision option: */
-   unsigned int             use_input_precision :1;
-   unsigned int             use_input_precision_sbit :1;
-   unsigned int             use_input_precision_16to8 :1;
-
-   /* Which gamma tests to run: */
-   unsigned int             test_gamma_threshold :1;
-   unsigned int             test_gamma_transform :1; /* main tests */
-   unsigned int             test_gamma_sbit :1;
-   unsigned int             test_gamma_strip16 :1;
-
-   unsigned int             log :1;   /* Log max error */
-
-   /* Buffer information, the buffer size limits the size of the chunks that can
-    * be modified - they must fit (including header and CRC) into the buffer!
-    */
-   size_t                   flush;           /* Count of bytes to flush */
-   size_t                   buffer_count;    /* Bytes in buffer */
-   size_t                   buffer_position; /* Position in buffer */
-   png_byte                 buffer[1024];
-} png_modifier;
-
-static double abserr(png_modifier *pm, png_byte bit_depth)
-{
-   return bit_depth == 16 ? pm->maxabs16 : pm->maxabs8;
-}
-
-static double pcerr(png_modifier *pm, png_byte bit_depth)
-{
-   return (bit_depth == 16 ? pm->maxpc16 : pm->maxpc8) * .01;
-}
-
-static double outerr(png_modifier *pm, png_byte bit_depth)
-{
-   /* There is a serious error in the 2 and 4 bit grayscale transform because
-    * the gamma table value (8 bits) is simply shifted, not rounded, so the
-    * error in 4 bit greyscale gamma is up to the value below.  This is a hack
-    * to allow pngvalid to succeed:
-    */
-   if (bit_depth == 2)
-      return .73182-.5;
-
-   if (bit_depth == 4)
-      return .90644-.5;
-
-   if (bit_depth == 16)
-     return pm->maxout16;
-
-   return pm->maxout8;
-}
-
-/* This returns true if the test should be stopped now because it has already
- * failed and it is running silently.
- */
-static int fail(png_modifier *pm)
-{
-   return !pm->log && !pm->this.verbose && (pm->this.nerrors > 0 ||
-       (pm->this.treat_warnings_as_errors && pm->this.nwarnings > 0));
-}
-
-static void
-modifier_init(png_modifier *pm)
-{
-   memset(pm, 0, sizeof *pm);
-   store_init(&pm->this);
-   pm->modifications = NULL;
-   pm->state = modifier_start;
-   pm->sbitlow = 1U;
-   pm->maxout8 = pm->maxpc8 = pm->maxabs8 = 0;
-   pm->maxout16 = pm->maxpc16 = pm->maxabs16 = 0;
-   pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = 0;
-   pm->error_gray_16 = pm->error_color_8 = pm->error_color_16 = 0;
-   pm->interlace_type = PNG_INTERLACE_NONE;
-   pm->test_standard = 0;
-   pm->test_size = 0;
-   pm->test_transform = 0;
-   pm->use_input_precision = 0;
-   pm->use_input_precision_sbit = 0;
-   pm->use_input_precision_16to8 = 0;
-   pm->test_gamma_threshold = 0;
-   pm->test_gamma_transform = 0;
-   pm->test_gamma_sbit = 0;
-   pm->test_gamma_strip16 = 0;
-   pm->log = 0;
-
-   /* Rely on the memset for all the other fields - there are no pointers */
-}
-
-/* One modification structure must be provided for each chunk to be modified (in
- * fact more than one can be provided if multiple separate changes are desired
- * for a single chunk.)  Modifications include adding a new chunk when a
- * suitable chunk does not exist.
- *
- * The caller of modify_fn will reset the CRC of the chunk and record 'modified'
- * or 'added' as appropriate if the modify_fn returns 1 (true).  If the
- * modify_fn is NULL the chunk is simply removed.
- */
-typedef struct png_modification
-{
-   struct png_modification *next;
-   png_uint_32              chunk;
-
-   /* If the following is NULL all matching chunks will be removed: */
-   int                    (*modify_fn)(struct png_modifier *pm,
-                               struct png_modification *me, int add);
-
-   /* If the following is set to PLTE, IDAT or IEND and the chunk has not been
-    * found and modified (and there is a modify_fn) the modify_fn will be called
-    * to add the chunk before the relevant chunk.
-    */
-   png_uint_32              add;
-   unsigned int             modified :1;     /* Chunk was modified */
-   unsigned int             added    :1;     /* Chunk was added */
-   unsigned int             removed  :1;     /* Chunk was removed */
-} png_modification;
-
-static void modification_reset(png_modification *pmm)
-{
-   if (pmm != NULL)
-   {
-      pmm->modified = 0;
-      pmm->added = 0;
-      pmm->removed = 0;
-      modification_reset(pmm->next);
-   }
-}
-
-static void
-modification_init(png_modification *pmm)
-{
-   memset(pmm, 0, sizeof *pmm);
-   pmm->next = NULL;
-   pmm->chunk = 0;
-   pmm->modify_fn = NULL;
-   pmm->add = 0;
-   modification_reset(pmm);
-}
-
-static void
-modifier_reset(png_modifier *pm)
-{
-   store_read_reset(&pm->this);
-   pm->modifications = NULL;
-   pm->state = modifier_start;
-   pm->bit_depth = pm->colour_type = 0;
-   pm->pending_len = pm->pending_chunk = 0;
-   pm->flush = pm->buffer_count = pm->buffer_position = 0;
-}
-
-/* Convenience macros. */
-#define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-#define CHUNK_IHDR CHUNK(73,72,68,82)
-#define CHUNK_PLTE CHUNK(80,76,84,69)
-#define CHUNK_IDAT CHUNK(73,68,65,84)
-#define CHUNK_IEND CHUNK(73,69,78,68)
-#define CHUNK_cHRM CHUNK(99,72,82,77)
-#define CHUNK_gAMA CHUNK(103,65,77,65)
-#define CHUNK_sBIT CHUNK(115,66,73,84)
-#define CHUNK_sRGB CHUNK(115,82,71,66)
-
-/* The guts of modification are performed during a read. */
-static void
-modifier_crc(png_bytep buffer)
-{
-   /* Recalculate the chunk CRC - a complete chunk must be in
-    * the buffer, at the start.
-    */
-   uInt datalen = png_get_uint_32(buffer);
-   png_save_uint_32(buffer+datalen+8, crc32(0L, buffer+4, datalen+4));
-}
-
-static void
-modifier_setbuffer(png_modifier *pm)
-{
-   modifier_crc(pm->buffer);
-   pm->buffer_count = png_get_uint_32(pm->buffer)+12;
-   pm->buffer_position = 0;
-}
-
-/* Separate the callback into the actual implementation (which is passed the
- * png_modifier explicitly) and the callback, which gets the modifier from the
- * png_struct.
- */
-static void
-modifier_read_imp(png_modifier *pm, png_bytep pb, png_size_t st)
-{
-   while (st > 0)
-   {
-      size_t cb;
-      png_uint_32 len, chunk;
-      png_modification *mod;
-
-      if (pm->buffer_position >= pm->buffer_count) switch (pm->state)
-      {
-         static png_byte sign[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
-         case modifier_start:
-            store_read_imp(&pm->this, pm->buffer, 8); /* size of signature. */
-            pm->buffer_count = 8;
-            pm->buffer_position = 0;
-
-            if (memcmp(pm->buffer, sign, 8) != 0)
-               png_error(pm->this.pread, "invalid PNG file signature");
-            pm->state = modifier_signature;
-            break;
-
-         case modifier_signature:
-            store_read_imp(&pm->this, pm->buffer, 13+12); /* size of IHDR */
-            pm->buffer_count = 13+12;
-            pm->buffer_position = 0;
-
-            if (png_get_uint_32(pm->buffer) != 13 ||
-                png_get_uint_32(pm->buffer+4) != CHUNK_IHDR)
-               png_error(pm->this.pread, "invalid IHDR");
-
-            /* Check the list of modifiers for modifications to the IHDR. */
-            mod = pm->modifications;
-            while (mod != NULL)
-            {
-               if (mod->chunk == CHUNK_IHDR && mod->modify_fn &&
-                   (*mod->modify_fn)(pm, mod, 0))
-                  {
-                  mod->modified = 1;
-                  modifier_setbuffer(pm);
-                  }
-
-               /* Ignore removal or add if IHDR! */
-               mod = mod->next;
-            }
-
-            /* Cache information from the IHDR (the modified one.) */
-            pm->bit_depth = pm->buffer[8+8];
-            pm->colour_type = pm->buffer[8+8+1];
-
-            pm->state = modifier_IHDR;
-            pm->flush = 0;
-            break;
-
-         case modifier_IHDR:
-         default:
-            /* Read a new chunk and process it until we see PLTE, IDAT or
-             * IEND.  'flush' indicates that there is still some data to
-             * output from the preceding chunk.
-             */
-            if ((cb = pm->flush) > 0)
-            {
-               if (cb > st) cb = st;
-               pm->flush -= cb;
-               store_read_imp(&pm->this, pb, cb);
-               pb += cb;
-               st -= cb;
-               if (st <= 0) return;
-            }
-
-            /* No more bytes to flush, read a header, or handle a pending
-             * chunk.
-             */
-            if (pm->pending_chunk != 0)
-            {
-               png_save_uint_32(pm->buffer, pm->pending_len);
-               png_save_uint_32(pm->buffer+4, pm->pending_chunk);
-               pm->pending_len = 0;
-               pm->pending_chunk = 0;
-            }
-            else
-               store_read_imp(&pm->this, pm->buffer, 8);
-
-            pm->buffer_count = 8;
-            pm->buffer_position = 0;
-
-            /* Check for something to modify or a terminator chunk. */
-            len = png_get_uint_32(pm->buffer);
-            chunk = png_get_uint_32(pm->buffer+4);
-
-            /* Terminators first, they may have to be delayed for added
-             * chunks
-             */
-            if (chunk == CHUNK_PLTE || chunk == CHUNK_IDAT ||
-                chunk == CHUNK_IEND)
-            {
-               mod = pm->modifications;
-
-               while (mod != NULL)
-               {
-                  if ((mod->add == chunk ||
-                      (mod->add == CHUNK_PLTE && chunk == CHUNK_IDAT)) &&
-                      mod->modify_fn != NULL && !mod->modified && !mod->added)
-                  {
-                     /* Regardless of what the modify function does do not run
-                      * this again.
-                      */
-                     mod->added = 1;
-
-                     if ((*mod->modify_fn)(pm, mod, 1 /*add*/))
-                     {
-                        /* Reset the CRC on a new chunk */
-                        if (pm->buffer_count > 0)
-                           modifier_setbuffer(pm);
-
-                        else
-                           {
-                           pm->buffer_position = 0;
-                           mod->removed = 1;
-                           }
-
-                        /* The buffer has been filled with something (we assume)
-                         * so output this.  Pend the current chunk.
-                         */
-                        pm->pending_len = len;
-                        pm->pending_chunk = chunk;
-                        break; /* out of while */
-                     }
-                  }
-
-                  mod = mod->next;
-               }
-
-               /* Don't do any further processing if the buffer was modified -
-                * otherwise the code will end up modifying a chunk that was
-                * just added.
-                */
-               if (mod != NULL)
-                  break; /* out of switch */
-            }
-
-            /* If we get to here then this chunk may need to be modified.  To
-             * do this it must be less than 1024 bytes in total size, otherwise
-             * it just gets flushed.
-             */
-            if (len+12 <= sizeof pm->buffer)
-            {
-               store_read_imp(&pm->this, pm->buffer+pm->buffer_count,
-                   len+12-pm->buffer_count);
-               pm->buffer_count = len+12;
-
-               /* Check for a modification, else leave it be. */
-               mod = pm->modifications;
-               while (mod != NULL)
-               {
-                  if (mod->chunk == chunk)
-                  {
-                     if (mod->modify_fn == NULL)
-                     {
-                        /* Remove this chunk */
-                        pm->buffer_count = pm->buffer_position = 0;
-                        mod->removed = 1;
-                        break; /* Terminate the while loop */
-                     }
-
-                     else if ((*mod->modify_fn)(pm, mod, 0))
-                     {
-                        mod->modified = 1;
-                        /* The chunk may have been removed: */
-                        if (pm->buffer_count == 0)
-                        {
-                           pm->buffer_position = 0;
-                           break;
-                        }
-                        modifier_setbuffer(pm);
-                     }
-                  }
-
-                  mod = mod->next;
-               }
-            }
-
-            else
-               pm->flush = len+12 - pm->buffer_count; /* data + crc */
-
-            /* Take the data from the buffer (if there is any). */
-            break;
-      }
-
-      /* Here to read from the modifier buffer (not directly from
-       * the store, as in the flush case above.)
-       */
-      cb = pm->buffer_count - pm->buffer_position;
-
-      if (cb > st)
-         cb = st;
-
-      memcpy(pb, pm->buffer + pm->buffer_position, cb);
-      st -= cb;
-      pb += cb;
-      pm->buffer_position += cb;
-   }
-}
-
-/* The callback: */
-static void
-modifier_read(png_structp pp, png_bytep pb, png_size_t st)
-{
-   png_modifier *pm = png_get_io_ptr(pp);
-
-   if (pm == NULL || pm->this.pread != pp)
-      png_error(pp, "bad modifier_read call");
-
-   modifier_read_imp(pm, pb, st);
-}
-
-/* Like store_progressive_read but the data is getting changed as we go so we
- * need a local buffer.
- */
-static void
-modifier_progressive_read(png_modifier *pm, png_structp pp, png_infop pi)
-{
-   if (pm->this.pread != pp || pm->this.current == NULL ||
-       pm->this.next == NULL)
-      png_error(pp, "store state damaged (progressive)");
-
-   /* This is another Horowitz and Hill random noise generator.  In this case
-    * the aim is to stress the progressive reader with truely horrible variable
-    * buffer sizes in the range 1..500, so a sequence of 9 bit random numbers
-    * is generated.  We could probably just count from 1 to 32767 and get as
-    * good a result.
-    */
-   for (;;)
-   {
-      static png_uint_32 noise = 1;
-      png_size_t cb, cbAvail;
-      png_byte buffer[512];
-
-      /* Generate 15 more bits of stuff: */
-      noise = (noise << 9) | ((noise ^ (noise >> (9-5))) & 0x1ff);
-      cb = noise & 0x1ff;
-
-      /* Check that this number of bytes are available (in the current buffer.)
-       * (This doesn't quite work - the modifier might delete a chunk; unlikely
-       * but possible, it doesn't happen at present because the modifier only
-       * adds chunks to standard images.)
-       */
-      cbAvail = store_read_buffer_avail(&pm->this);
-      if (pm->buffer_count > pm->buffer_position)
-         cbAvail += pm->buffer_count - pm->buffer_position;
-
-      if (cb > cbAvail)
-      {
-         /* Check for EOF: */
-         if (cbAvail == 0)
-            break;
-
-         cb = cbAvail;
-      }
-
-      modifier_read_imp(pm, buffer, cb);
-      png_process_data(pp, pi, buffer, cb);
-   }
-
-   /* Check the invariants at the end (if this fails it's a problem in this
-    * file!)
-    */
-   if (pm->buffer_count > pm->buffer_position ||
-       pm->this.next != &pm->this.current->data ||
-       pm->this.readpos < pm->this.current->datacount)
-      png_error(pp, "progressive read implementation error");
-}
-
-/* Set up a modifier. */
-static png_structp
-set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,
-    PNG_CONST char *name)
-{
-   /* Do this first so that the modifier fields are cleared even if an error
-    * happens allocating the png_struct.  No allocation is done here so no
-    * cleanup is required.
-    */
-   pm->state = modifier_start;
-   pm->bit_depth = 0;
-   pm->colour_type = 255;
-
-   pm->pending_len = 0;
-   pm->pending_chunk = 0;
-   pm->flush = 0;
-   pm->buffer_count = 0;
-   pm->buffer_position = 0;
-
-   return set_store_for_read(&pm->this, ppi, id, name);
-}
-
-/***************************** STANDARD PNG FILES *****************************/
-/* Standard files - write and save standard files. */
-/* There are two basic forms of standard images.  Those which attempt to have
- * all the possible pixel values (not possible for 16bpp images, but a range of
- * values are produced) and those which have a range of image sizes.  The former
- * are used for testing transforms, in particular gamma correction and bit
- * reduction and increase.  The latter are reserved for testing the behavior of
- * libpng with respect to 'odd' image sizes - particularly small images where
- * rows become 1 byte and interlace passes disappear.
- *
- * The first, most useful, set are the 'transform' images, the second set of
- * small images are the 'size' images.
- *
- * The transform files are constructed with rows which fit into a 1024 byte row
- * buffer.  This makes allocation easier below.  Further regardless of the file
- * format every row has 128 pixels (giving 1024 bytes for 64bpp formats).
- *
- * Files are stored with no gAMA or sBIT chunks, with a PLTE only when needed
- * and with an ID derived from the colour type, bit depth and interlace type
- * as above (FILEID).  The width (128) and height (variable) are not stored in
- * the FILEID - instead the fields are set to 0, indicating a transform file.
- *
- * The size files ar constructed with rows a maximum of 128 bytes wide, allowing
- * a maximum width of 16 pixels (for the 64bpp case.)  They also have a maximum
- * height of 16 rows.  The width and height are stored in the FILEID and, being
- * non-zero, indicate a size file.
- */
-
-/* The number of passes is related to the interlace type. There wass no libpng
- * API to determine this prior to 1.5, so we need an inquiry function:
- */
-static int
-npasses_from_interlace_type(png_structp pp, int interlace_type)
-{
-   switch (interlace_type)
-   {
-   default:
-      png_error(pp, "invalid interlace type");
-
-   case PNG_INTERLACE_NONE:
-      return 1;
-
-   case PNG_INTERLACE_ADAM7:
-      return PNG_INTERLACE_ADAM7_PASSES;
-   }
-}
-
-static unsigned int
-bit_size(png_structp pp, png_byte colour_type, png_byte bit_depth)
-{
-   switch (colour_type)
-   {
-      case 0:  return bit_depth;
-
-      case 2:  return 3*bit_depth;
-
-      case 3:  return bit_depth;
-
-      case 4:  return 2*bit_depth;
-
-      case 6:  return 4*bit_depth;
-
-      default: png_error(pp, "invalid color type");
-   }
-}
-
-#define TRANSFORM_WIDTH  128U
-#define TRANSFORM_ROWMAX (TRANSFORM_WIDTH*8U)
-#define SIZE_ROWMAX (16*8U) /* 16 pixels, max 8 bytes each - 128 bytes */
-#define STANDARD_ROWMAX TRANSFORM_ROWMAX /* The larger of the two */
-
-/* So the maximum image sizes are as follows.  A 'transform' image may require
- * more than 65535 bytes.  The size images are a maximum of 2046 bytes.
- */
-#define TRANSFORM_IMAGEMAX (TRANSFORM_ROWMAX * (png_uint_32)2048)
-#define SIZE_IMAGEMAX (SIZE_ROWMAX * 16U)
-
-static size_t
-transform_rowsize(png_structp pp, png_byte colour_type, png_byte bit_depth)
-{
-   return (TRANSFORM_WIDTH * bit_size(pp, colour_type, bit_depth)) / 8;
-}
-
-/* transform_width(pp, colour_type, bit_depth) current returns the same number
- * every time, so just use a macro:
- */
-#define transform_width(pp, colour_type, bit_depth) TRANSFORM_WIDTH
-
-static png_uint_32
-transform_height(png_structp pp, png_byte colour_type, png_byte bit_depth)
-{
-   switch (bit_size(pp, colour_type, bit_depth))
-   {
-      case 1:
-      case 2:
-      case 4:
-         return 1;   /* Total of 128 pixels */
-
-      case 8:
-         return 2;   /* Total of 256 pixels/bytes */
-
-      case 16:
-         return 512; /* Total of 65536 pixels */
-
-      case 24:
-      case 32:
-         return 512; /* 65536 pixels */
-
-      case 48:
-      case 64:
-         return 2048;/* 4 x 65536 pixels. */
-
-      default:
-         return 0;   /* Error, will be caught later */
-   }
-}
-
-/* The following can only be defined here, now we have the definitions
- * of the transform image sizes.
- */
-static png_uint_32
-standard_width(png_structp pp, png_uint_32 id)
-{
-   png_uint_32 width = WIDTH_FROM_ID(id);
-   UNUSED(pp)
-
-   if (width == 0)
-      width = transform_width(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));
-
-   return width;
-}
-
-static png_uint_32
-standard_height(png_structp pp, png_uint_32 id)
-{
-   png_uint_32 height = HEIGHT_FROM_ID(id);
-
-   if (height == 0)
-      height = transform_height(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));
-
-   return height;
-}
-
-static png_uint_32
-standard_rowsize(png_structp pp, png_uint_32 id)
-{
-   png_uint_32 width = standard_width(pp, id);
-
-   /* This won't overflow: */
-   width *= bit_size(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id));
-   return (width + 7) / 8;
-}
-
-static void
-transform_row(png_structp pp, png_byte buffer[TRANSFORM_ROWMAX],
-   png_byte colour_type, png_byte bit_depth, png_uint_32 y)
-{
-   png_uint_32 v = y << 7;
-   png_uint_32 i = 0;
-
-   switch (bit_size(pp, colour_type, bit_depth))
-   {
-      case 1:
-         while (i<128/8) buffer[i] = v & 0xff, v += 17, ++i;
-         return;
-
-      case 2:
-         while (i<128/4) buffer[i] = v & 0xff, v += 33, ++i;
-         return;
-
-      case 4:
-         while (i<128/2) buffer[i] = v & 0xff, v += 65, ++i;
-         return;
-
-      case 8:
-         /* 256 bytes total, 128 bytes in each row set as follows: */
-         while (i<128) buffer[i] = v & 0xff, ++v, ++i;
-         return;
-
-      case 16:
-         /* Generate all 65536 pixel values in order, which includes the 8 bit
-          * GA case as well as the 16 bit G case.
-          */
-         while (i<128)
-            buffer[2*i] = (v>>8) & 0xff, buffer[2*i+1] = v & 0xff, ++v, ++i;
-
-         return;
-
-      case 24:
-         /* 65535 pixels, but rotate the values. */
-         while (i<128)
-         {
-            /* Three bytes per pixel, r, g, b, make b by r^g */
-            buffer[3*i+0] = (v >> 8) & 0xff;
-            buffer[3*i+1] = v & 0xff;
-            buffer[3*i+2] = ((v >> 8) ^ v) & 0xff;
-            ++v;
-            ++i;
-         }
-
-         return;
-
-      case 32:
-         /* 65535 pixels, r, g, b, a; just replicate */
-         while (i<128)
-         {
-            buffer[4*i+0] = (v >> 8) & 0xff;
-            buffer[4*i+1] = v & 0xff;
-            buffer[4*i+2] = (v >> 8) & 0xff;
-            buffer[4*i+3] = v & 0xff;
-            ++v;
-            ++i;
-         }
-
-         return;
-
-      case 48:
-         /* y is maximum 2047, giving 4x65536 pixels, make 'r' increase by 1 at
-          * each pixel, g increase by 257 (0x101) and 'b' by 0x1111:
-          */
-         while (i<128)
-         {
-            png_uint_32 t = v++;
-            buffer[6*i+0] = (t >> 8) & 0xff;
-            buffer[6*i+1] = t & 0xff;
-            t *= 257;
-            buffer[6*i+2] = (t >> 8) & 0xff;
-            buffer[6*i+3] = t & 0xff;
-            t *= 17;
-            buffer[6*i+4] = (t >> 8) & 0xff;
-            buffer[6*i+5] = t & 0xff;
-            ++i;
-         }
-
-         return;
-
-      case 64:
-         /* As above in the 32 bit case. */
-         while (i<128)
-         {
-            png_uint_32 t = v++;
-            buffer[8*i+0] = (t >> 8) & 0xff;
-            buffer[8*i+1] = t & 0xff;
-            buffer[8*i+4] = (t >> 8) & 0xff;
-            buffer[8*i+5] = t & 0xff;
-            t *= 257;
-            buffer[8*i+2] = (t >> 8) & 0xff;
-            buffer[8*i+3] = t & 0xff;
-            buffer[8*i+6] = (t >> 8) & 0xff;
-            buffer[8*i+7] = t & 0xff;
-            ++i;
-         }
-         return;
-
-      default:
-         break;
-   }
-
-   png_error(pp, "internal error");
-}
-
-/* This is just to do the right cast - could be changed to a function to check
- * 'bd' but there isn't much point.
- */
-#define DEPTH(bd) ((png_byte)(1U << (bd)))
-
-/* Make a standardized image given a an image colour type, bit depth and
- * interlace type.  The standard images have a very restricted range of
- * rows and heights and are used for testing transforms rather than image
- * layout details.  See make_size_images below for a way to make images
- * that test odd sizes along with the libpng interlace handling.
- */
-static void
-make_transform_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,
-    png_byte PNG_CONST bit_depth, int interlace_type, png_const_charp name)
-{
-   context(ps, fault);
-
-   Try
-   {
-      png_infop pi;
-      png_structp pp = set_store_for_write(ps, &pi, name);
-      png_uint_32 h;
-
-      /* In the event of a problem return control to the Catch statement below
-       * to do the clean up - it is not possible to 'return' directly from a Try
-       * block.
-       */
-      if (pp == NULL)
-         Throw ps;
-
-      h = transform_height(pp, colour_type, bit_depth);
-
-      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth), h,
-         bit_depth, colour_type, interlace_type,
-         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-
-      if (colour_type == 3) /* palette */
-      {
-         unsigned int i = 0;
-         png_color pal[256];
-
-         do
-            pal[i].red = pal[i].green = pal[i].blue = (png_byte)i;
-         while(++i < 256U);
-
-         png_set_PLTE(pp, pi, pal, 256);
-      }
-
-      png_write_info(pp, pi);
-
-      if (png_get_rowbytes(pp, pi) !=
-          transform_rowsize(pp, colour_type, bit_depth))
-         png_error(pp, "row size incorrect");
-
-      else
-      {
-         /* Somewhat confusingly this must be called *after* png_write_info
-          * because if it is called before, the information in *pp has not been
-          * updated to reflect the interlaced image.
-          */
-         int npasses = png_set_interlace_handling(pp);
-         int pass;
-
-         if (npasses != npasses_from_interlace_type(pp, interlace_type))
-            png_error(pp, "write: png_set_interlace_handling failed");
-
-         for (pass=0; pass<npasses; ++pass)
-         {
-            png_uint_32 y;
-
-            for (y=0; y<h; ++y)
-            {
-               png_byte buffer[TRANSFORM_ROWMAX];
-
-               transform_row(pp, buffer, colour_type, bit_depth, y);
-               png_write_row(pp, buffer);
-            }
-         }
-      }
-
-      png_write_end(pp, pi);
-
-      /* And store this under the appropriate id, then clean up. */
-      store_storefile(ps, FILEID(colour_type, bit_depth, interlace_type,
-         0, 0, 0));
-
-      store_write_reset(ps);
-   }
-
-   Catch(fault)
-   {
-      /* Use the png_store returned by the exception. This may help the compiler
-       * because 'ps' is not used in this branch of the setjmp.  Note that fault
-       * and ps will always be the same value.
-       */
-      store_write_reset(fault);
-   }
-}
-
-static void
-make_standard(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, int bdlo,
-    int PNG_CONST bdhi)
-{
-   for (; bdlo <= bdhi; ++bdlo)
-   {
-      int interlace_type;
-
-      for (interlace_type = PNG_INTERLACE_NONE;
-           interlace_type < PNG_INTERLACE_LAST; ++interlace_type)
-      {
-         char name[FILE_NAME_SIZE];
-
-         standard_name(name, sizeof name, 0, colour_type, bdlo, interlace_type,
-            0, 0, 0);
-         make_transform_image(ps, colour_type, DEPTH(bdlo), interlace_type,
-            name);
-      }
-   }
-}
-
-static void
-make_transform_images(png_store *ps)
-{
-   /* This is in case of errors. */
-   safecat(ps->test, sizeof ps->test, 0, "make standard images");
-
-   /* Arguments are colour_type, low bit depth, high bit depth
-    */
-   make_standard(ps, 0, 0, WRITE_BDHI);
-   make_standard(ps, 2, 3, WRITE_BDHI);
-   make_standard(ps, 3, 0, 3 /*palette: max 8 bits*/);
-   make_standard(ps, 4, 3, WRITE_BDHI);
-   make_standard(ps, 6, 3, WRITE_BDHI);
-}
-
-/* The following two routines use the PNG interlace support macros from
- * png.h to interlace or deinterlace rows.
- */
-static void
-interlace_row(png_bytep buffer, png_const_bytep imageRow,
-   unsigned int pixel_size, png_uint_32 w, int pass)
-{
-   png_uint_32 xin, xout, xstep;
-
-   /* Note that this can, trivially, be optimized to a memcpy on pass 7, the
-    * code is presented this way to make it easier to understand.  In practice
-    * consult the code in the libpng source to see other ways of doing this.
-    */
-   xin = PNG_PASS_START_COL(pass);
-   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
-
-   for (xout=0; xin<w; xin+=xstep)
-   {
-      pixel_copy(buffer, xout, imageRow, xin, pixel_size);
-      ++xout;
-   }
-}
-
-static void
-deinterlace_row(png_bytep buffer, png_const_bytep row,
-   unsigned int pixel_size, png_uint_32 w, int pass)
-{
-   /* The inverse of the above, 'row' is part of row 'y' of the output image,
-    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute
-    * the pixels of row into buffer and return the number written (to allow
-    * this to be checked).
-    */
-   png_uint_32 xin, xout, xstep;
-
-   xout = PNG_PASS_START_COL(pass);
-   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
-
-   for (xin=0; xout<w; xout+=xstep)
-   {
-      pixel_copy(buffer, xout, row, xin, pixel_size);
-      ++xin;
-   }
-}
-
-/* Build a single row for the 'size' test images, this fills in only the
- * first bit_width bits of the sample row.
- */
-static void
-size_row(png_byte buffer[SIZE_ROWMAX], png_uint_32 bit_width, png_uint_32 y)
-{
-   /* height is in the range 1 to 16, so: */
-   y = ((y & 1) << 7) + ((y & 2) << 6) + ((y & 4) << 5) + ((y & 8) << 4);
-   /* the following ensures bits are set in small images: */
-   y ^= 0xA5;
-
-   while (bit_width >= 8)
-      *buffer++ = (png_byte)y++, bit_width -= 8;
-
-   /* There may be up to 7 remaining bits, these go in the most significant
-    * bits of the byte.
-    */
-   if (bit_width > 0)
-   {
-      png_uint_32 mask = (1U<<(8-bit_width))-1;
-      *buffer = (png_byte)((*buffer & mask) | (y & ~mask));
-   }
-}
-
-static void
-make_size_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,
-    png_byte PNG_CONST bit_depth, int PNG_CONST interlace_type,
-    png_uint_32 PNG_CONST w, png_uint_32 PNG_CONST h,
-    int PNG_CONST do_interlace)
-{
-   context(ps, fault);
-
-   Try
-   {
-      png_infop pi;
-      png_structp pp;
-      unsigned int pixel_size;
-
-      /* Make a name and get an appropriate id for the store: */
-      char name[FILE_NAME_SIZE];
-      PNG_CONST png_uint_32 id = FILEID(colour_type, bit_depth, interlace_type,
-         w, h, do_interlace);
-
-      standard_name_from_id(name, sizeof name, 0, id);
-      pp = set_store_for_write(ps, &pi, name);
-
-      /* In the event of a problem return control to the Catch statement below
-       * to do the clean up - it is not possible to 'return' directly from a Try
-       * block.
-       */
-      if (pp == NULL)
-         Throw ps;
-
-      png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type,
-         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-
-      /* Same palette as make_transform_image - I don' think there is any
-       * benefit from using a different one (JB 20101211)
-       */
-      if (colour_type == 3) /* palette */
-      {
-         unsigned int i = 0;
-         png_color pal[256];
-
-         do
-            pal[i].red = pal[i].green = pal[i].blue = (png_byte)i;
-         while(++i < 256U);
-
-         png_set_PLTE(pp, pi, pal, 256);
-      }
-
-      png_write_info(pp, pi);
-
-      /* Calculate the bit size, divide by 8 to get the byte size - this won't
-       * overflow because we know the w values are all small enough even for
-       * a system where 'unsigned int' is only 16 bits.
-       */
-      pixel_size = bit_size(pp, colour_type, bit_depth);
-      if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8)
-         png_error(pp, "row size incorrect");
-
-      else
-      {
-         int npasses = npasses_from_interlace_type(pp, interlace_type);
-         png_uint_32 y;
-         int pass;
-         png_byte image[16][SIZE_ROWMAX];
-
-         /* To help consistent error detection make the parts of this buffer
-          * that aren't set below all '1':
-          */
-         memset(image, 0xff, sizeof image);
-
-         if (!do_interlace && npasses != png_set_interlace_handling(pp))
-            png_error(pp, "write: png_set_interlace_handling failed");
-
-         /* Prepare the whole image first to avoid making it 7 times: */
-         for (y=0; y<h; ++y)
-            size_row(image[y], w * pixel_size, y);
-
-         for (pass=0; pass<npasses; ++pass)
-         {
-            /* The following two are for checking the macros: */
-            PNG_CONST png_uint_32 wPass = PNG_PASS_COLS(w, pass);
-
-            /* If do_interlace is set we don't call png_write_row for every
-             * row because some of them are empty.  In fact, for a 1x1 image,
-             * most of them are empty!
-             */
-            for (y=0; y<h; ++y)
-            {
-               png_const_bytep row = image[y];
-               png_byte tempRow[SIZE_ROWMAX];
-
-               /* If do_interlace *and* the image is interlaced we
-                * need a reduced interlace row, this may be reduced
-                * to empty.
-                */
-               if (do_interlace && interlace_type == PNG_INTERLACE_ADAM7)
-               {
-                  /* The row must not be written if it doesn't exist, notice
-                   * that there are two conditions here, either the row isn't
-                   * ever in the pass or the row would be but isn't wide
-                   * enough to contribute any pixels.  In fact the wPass test
-                   * can be used to skip the whole y loop in this case.
-                   */
-                  if (PNG_ROW_IN_INTERLACE_PASS(y, pass) && wPass > 0)
-                  {
-                     /* Set to all 1's for error detection (libpng tends to
-                      * set unset things to 0).
-                      */
-                     memset(tempRow, 0xff, sizeof tempRow);
-                     interlace_row(tempRow, row, pixel_size, w, pass);
-                     row = tempRow;
-                  }
-                  else
-                     continue;
-               }
-
-               /* Only get to here if the row has some pixels in it. */
-               png_write_row(pp, row);
-            }
-         }
-      }
-
-      png_write_end(pp, pi);
-
-      /* And store this under the appropriate id, then clean up. */
-      store_storefile(ps, id);
-
-      store_write_reset(ps);
-   }
-
-   Catch(fault)
-   {
-      /* Use the png_store returned by the exception. This may help the compiler
-       * because 'ps' is not used in this branch of the setjmp.  Note that fault
-       * and ps will always be the same value.
-       */
-      store_write_reset(fault);
-   }
-}
-
-static void
-make_size(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, int bdlo,
-    int PNG_CONST bdhi)
-{
-   for (; bdlo <= bdhi; ++bdlo)
-   {
-      png_uint_32 width;
-
-      for (width = 1; width <= 16; ++width)
-      {
-         png_uint_32 height;
-
-         for (height = 1; height <= 16; ++height)
-         {
-            /* The four combinations of DIY interlace and interlace or not -
-             * no interlace + DIY should be identical to no interlace with
-             * libpng doing it.
-             */
-            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,
-               width, height, 0);
-            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,
-               width, height, 1);
-            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,
-               width, height, 0);
-            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,
-               width, height, 1);
-         }
-      }
-   }
-}
-
-static void
-make_size_images(png_store *ps)
-{
-   /* This is in case of errors. */
-   safecat(ps->test, sizeof ps->test, 0, "make size images");
-
-   /* Arguments are colour_type, low bit depth, high bit depth
-    */
-   make_size(ps, 0, 0, WRITE_BDHI);
-   make_size(ps, 2, 3, WRITE_BDHI);
-   make_size(ps, 3, 0, 3 /*palette: max 8 bits*/);
-   make_size(ps, 4, 3, WRITE_BDHI);
-   make_size(ps, 6, 3, WRITE_BDHI);
-}
-
-/* Return a row based on image id and 'y' for checking: */
-static void
-standard_row(png_structp pp, png_byte std[STANDARD_ROWMAX], png_uint_32 id,
-   png_uint_32 y)
-{
-   if (WIDTH_FROM_ID(id) == 0)
-      transform_row(pp, std, COL_FROM_ID(id), DEPTH_FROM_ID(id), y);
-   else
-      size_row(std, WIDTH_FROM_ID(id) * bit_size(pp, COL_FROM_ID(id),
-         DEPTH_FROM_ID(id)), y);
-}
-
-/* Tests - individual test cases */
-/* Like 'make_standard' but errors are deliberately introduced into the calls
- * to ensure that they get detected - it should not be possible to write an
- * invalid image with libpng!
- */
-static void
-sBIT0_error_fn(png_structp pp, png_infop pi)
-{
-   /* 0 is invalid... */
-   png_color_8 bad;
-   bad.red = bad.green = bad.blue = bad.gray = bad.alpha = 0;
-   png_set_sBIT(pp, pi, &bad);
-}
-
-static void
-sBIT_error_fn(png_structp pp, png_infop pi)
-{
-   png_byte bit_depth;
-   png_color_8 bad;
-
-   if (png_get_color_type(pp, pi) == PNG_COLOR_TYPE_PALETTE)
-      bit_depth = 8;
-
-   else
-      bit_depth = png_get_bit_depth(pp, pi);
-
-   /* Now we know the bit depth we can easily generate an invalid sBIT entry */
-   bad.red = bad.green = bad.blue = bad.gray = bad.alpha =
-      (png_byte)(bit_depth+1);
-   png_set_sBIT(pp, pi, &bad);
-}
-
-static PNG_CONST struct
-{
-   void          (*fn)(png_structp, png_infop);
-   PNG_CONST char *msg;
-   unsigned int    warning :1; /* the error is a warning... */
-} error_test[] =
-    {
-       { sBIT0_error_fn, "sBIT(0): failed to detect error", 1 },
-       { sBIT_error_fn, "sBIT(too big): failed to detect error", 1 },
-    };
-
-static void
-make_error(png_store* volatile ps, png_byte PNG_CONST colour_type,
-    png_byte bit_depth, int interlace_type, int test, png_const_charp name)
-{
-   context(ps, fault);
-
-   Try
-   {
-      png_structp pp;
-      png_infop pi;
-
-      pp = set_store_for_write(ps, &pi, name);
-
-      if (pp == NULL)
-         Throw ps;
-
-      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth),
-         transform_height(pp, colour_type, bit_depth), bit_depth, colour_type,
-         interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-
-      if (colour_type == 3) /* palette */
-      {
-         unsigned int i = 0;
-         png_color pal[256];
-
-         do
-            pal[i].red = pal[i].green = pal[i].blue = (png_byte)i;
-         while(++i < 256U);
-
-         png_set_PLTE(pp, pi, pal, 256);
-      }
-
-      /* Time for a few errors, these are in various optional chunks, the
-       * standard tests test the standard chunks pretty well.
-       */
-#     define exception__prev exception_prev_1
-#     define exception__env exception_env_1
-      Try
-      {
-         /* Expect this to throw: */
-         ps->expect_error = !error_test[test].warning;
-         ps->expect_warning = error_test[test].warning;
-         ps->saw_warning = 0;
-         error_test[test].fn(pp, pi);
-
-         /* Normally the error is only detected here: */
-         png_write_info(pp, pi);
-
-         /* And handle the case where it was only a warning: */
-         if (ps->expect_warning && ps->saw_warning)
-            Throw ps;
-
-         /* If we get here there is a problem, we have success - no error or
-          * no warning - when we shouldn't have success.  Log an error.
-          */
-         store_log(ps, pp, error_test[test].msg, 1 /*error*/);
-      }
-
-      Catch (fault)
-         ps = fault; /* expected exit, make sure ps is not clobbered */
-#undef exception__prev
-#undef exception__env
-
-      /* And clear these flags */
-      ps->expect_error = 0;
-      ps->expect_warning = 0;
-
-      /* Now write the whole image, just to make sure that the detected, or
-       * undetected, errro has not created problems inside libpng.
-       */
-      if (png_get_rowbytes(pp, pi) !=
-          transform_rowsize(pp, colour_type, bit_depth))
-         png_error(pp, "row size incorrect");
-
-      else
-      {
-         png_uint_32 h = transform_height(pp, colour_type, bit_depth);
-         int npasses = png_set_interlace_handling(pp);
-         int pass;
-
-         if (npasses != npasses_from_interlace_type(pp, interlace_type))
-            png_error(pp, "write: png_set_interlace_handling failed");
-
-         for (pass=0; pass<npasses; ++pass)
-         {
-            png_uint_32 y;
-
-            for (y=0; y<h; ++y)
-            {
-               png_byte buffer[TRANSFORM_ROWMAX];
-
-               transform_row(pp, buffer, colour_type, bit_depth, y);
-               png_write_row(pp, buffer);
-            }
-         }
-      }
-
-      png_write_end(pp, pi);
-
-      /* The following deletes the file that was just written. */
-      store_write_reset(ps);
-   }
-
-   Catch(fault)
-   {
-      store_write_reset(fault);
-   }
-}
-
-static int
-make_errors(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
-    int bdlo, int PNG_CONST bdhi)
-{
-   for (; bdlo <= bdhi; ++bdlo)
-   {
-      int interlace_type;
-
-      for (interlace_type = PNG_INTERLACE_NONE;
-           interlace_type < PNG_INTERLACE_LAST; ++interlace_type)
-      {
-         unsigned int test;
-         char name[FILE_NAME_SIZE];
-
-         standard_name(name, sizeof name, 0, colour_type, bdlo, interlace_type,
-            0, 0, 0);
-
-         for (test=0; test<(sizeof error_test)/(sizeof error_test[0]); ++test)
-         {
-            make_error(&pm->this, colour_type, DEPTH(bdlo), interlace_type,
-               test, name);
-
-            if (fail(pm))
-               return 0;
-         }
-      }
-   }
-
-   return 1; /* keep going */
-}
-
-static void
-perform_error_test(png_modifier *pm)
-{
-   /* Need to do this here because we just write in this test. */
-   safecat(pm->this.test, sizeof pm->this.test, 0, "error test");
-
-   if (!make_errors(pm, 0, 0, WRITE_BDHI))
-      return;
-
-   if (!make_errors(pm, 2, 3, WRITE_BDHI))
-      return;
-
-   if (!make_errors(pm, 3, 0, 3))
-      return;
-
-   if (!make_errors(pm, 4, 3, WRITE_BDHI))
-      return;
-
-   if (!make_errors(pm, 6, 3, WRITE_BDHI))
-      return;
-}
-
-/* Because we want to use the same code in both the progressive reader and the
- * sequential reader it is necessary to deal with the fact that the progressive
- * reader callbacks only have one parameter (png_get_progressive_ptr()), so this
- * must contain all the test parameters and all the local variables directly
- * accessible to the sequential reader implementation.
- *
- * The technique adopted is to reinvent part of what Dijkstra termed a
- * 'display'; an array of pointers to the stack frames of enclosing functions so
- * that a nested function definition can access the local (C auto) variables of
- * the functions that contain its definition.  In fact C provides the first
- * pointer (the local variables - the stack frame pointer) and the last (the
- * global variables - the BCPL global vector typically implemented as global
- * addresses), this code requires one more pointer to make the display - the
- * local variables (and function call parameters) of the function that actually
- * invokes either the progressive or sequential reader.
- *
- * Perhaps confusingly this technique is confounded with classes - the
- * 'standard_display' defined here is sub-classed as the 'gamma_display' below.
- * A gamma_display is a standard_display, taking advantage of the ANSI-C
- * requirement that the pointer to the first member of a structure must be the
- * same as the pointer to the structure.  This allows us to reuse standard_
- * functions in the gamma test code; something that could not be done with
- * nested funtions!
- */
-typedef struct standard_palette_entry /* pngvalid format palette! */
-{
-   png_byte red;
-   png_byte green;
-   png_byte blue;
-   png_byte alpha;
-} standard_palette[256];
-
-typedef struct standard_display
-{
-   png_store*  ps;             /* Test parameters (passed to the function) */
-   png_byte    colour_type;
-   png_byte    bit_depth;
-   png_byte    red_sBIT;       /* Input data sBIT values. */
-   png_byte    green_sBIT;
-   png_byte    blue_sBIT;
-   png_byte    alpha_sBIT;
-   int         interlace_type;
-   png_uint_32 id;             /* Calculated file ID */
-   png_uint_32 w;              /* Width of image */
-   png_uint_32 h;              /* Height of image */
-   int         npasses;        /* Number of interlaced passes */
-   png_uint_32 pixel_size;     /* Width of one pixel in bits */
-   png_uint_32 bit_width;      /* Width of output row in bits */
-   size_t      cbRow;          /* Bytes in a row of the output image */
-   int         do_interlace;   /* Do interlacing internally */
-   int         is_transparent; /* Transparecy information was present. */
-   struct
-   {
-      png_uint_16 red;
-      png_uint_16 green;
-      png_uint_16 blue;
-   }           transparent;    /* The transparent color, if set. */
-   standard_palette
-               palette;
-} standard_display;
-
-static void
-standard_display_init(standard_display *dp, png_store* ps, png_uint_32 id,
-   int do_interlace)
-{
-   dp->ps = ps;
-   dp->colour_type = COL_FROM_ID(id);
-   dp->bit_depth = DEPTH_FROM_ID(id);
-   dp->alpha_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT =
-      dp->bit_depth;
-   dp->interlace_type = INTERLACE_FROM_ID(id);
-   dp->id = id;
-   /* All the rest are filled in after the read_info: */
-   dp->w = 0;
-   dp->h = 0;
-   dp->npasses = 0;
-   dp->pixel_size = 0;
-   dp->bit_width = 0;
-   dp->cbRow = 0;
-   dp->do_interlace = do_interlace;
-   dp->is_transparent = 0;
-   /* Preset the transparent color to black: */
-   memset(&dp->transparent, 0, sizeof dp->transparent);
-   /* Preset the palette to full intensity/opaque througout: */
-   memset(dp->palette, 0xff, sizeof dp->palette);
-
-}
-
-/* Call this only if the colour type is 3 - PNG_COLOR_TYPE_PALETTE - otherwise
- * it will png_error out.  The API returns true if tRNS information was
- * present.
- */
-static int
-standard_palette_init(standard_palette palette, png_structp pp, png_infop pi)
-{
-   png_colorp pal;
-   png_bytep trans_alpha;
-   int num;
-
-   pal = 0;
-   num = -1;
-   if (png_get_PLTE(pp, pi, &pal, &num) & PNG_INFO_PLTE)
-   {
-      int i;
-
-      for (i=0; i<num; ++i)
-      {
-         palette[i].red = pal[i].red;
-         palette[i].green = pal[i].green;
-         palette[i].blue = pal[i].blue;
-      }
-
-      /* Mark the remainder of the entries with a flag value: */
-      for (; i<256; ++i)
-         palette[i].red = palette[i].green = palette[i].blue = 126;
-   }
-
-   else /* !png_get_PLTE */
-      png_error(pp, "validate: missing PLTE with color type 3");
-
-   trans_alpha = 0;
-   num = -1;
-   if (png_get_tRNS(pp, pi, &trans_alpha, &num, 0) & PNG_INFO_tRNS)
-   {
-      int i;
-
-      /* Any of these are crash-worthy - given the implementation of
-       * png_get_tRNS up to 1.5 an app won't crash if it just checks the
-       * result above and fails to check that the variables it passed have
-       * actually been filled in!  Note that if the app were to pass the
-       * last, png_color_16p, variable too it couldn't rely on this.
-       */
-      if (trans_alpha == 0 || num <= 0 || num > 256)
-         png_error(pp, "validate: unexpected png_get_tRNS (palette) result");
-
-      for (i=0; i<num; ++i)
-         palette[i].alpha = trans_alpha[i];
-
-      for (; i<256; ++i)
-         palette[i].alpha = 255;
-
-      return 1; /* transparency */
-   }
-
-   else
-   {
-      /* No transparency - just set the alpha channel to opaque. */
-      int i;
-
-      for (i=0; i<256; ++i)
-         palette[i].alpha = 255;
-
-      return 0; /* no transparency */
-   }
-}
-
-/* By passing a 'standard_display' the progressive callbacks can be used
- * directly by the sequential code, the functions suffixed "_imp" are the
- * implementations, the functions without the suffix are the callbacks.
- *
- * The code for the info callback is split into two because this callback calls
- * png_read_update_info or png_start_read_image and what gets called depends on
- * whether the info needs updating (we want to test both calls in pngvalid.)
- */
-static void
-standard_info_part1(standard_display *dp, png_structp pp, png_infop pi)
-{
-   if (png_get_bit_depth(pp, pi) != dp->bit_depth)
-      png_error(pp, "validate: bit depth changed");
-
-   if (png_get_color_type(pp, pi) != dp->colour_type)
-      png_error(pp, "validate: color type changed");
-
-   if (png_get_filter_type(pp, pi) != PNG_FILTER_TYPE_BASE)
-      png_error(pp, "validate: filter type changed");
-
-   if (png_get_interlace_type(pp, pi) != dp->interlace_type)
-      png_error(pp, "validate: interlacing changed");
-
-   if (png_get_compression_type(pp, pi) != PNG_COMPRESSION_TYPE_BASE)
-      png_error(pp, "validate: compression type changed");
-
-   dp->w = png_get_image_width(pp, pi);
-
-   if (dp->w != standard_width(pp, dp->id))
-      png_error(pp, "validate: image width changed");
-
-   dp->h = png_get_image_height(pp, pi);
-
-   if (dp->h != standard_height(pp, dp->id))
-      png_error(pp, "validate: image height changed");
-
-   /* Record (but don't check at present) the input sBIT according to the colour
-    * type information.
-    */
-   {
-      png_color_8p sBIT = 0;
-
-      if (png_get_sBIT(pp, pi, &sBIT) & PNG_INFO_sBIT)
-      {
-         int sBIT_invalid = 0;
-
-         if (sBIT == 0)
-            png_error(pp, "validate: unexpected png_get_sBIT result");
-
-         if (dp->colour_type & PNG_COLOR_MASK_COLOR)
-         {
-            if (sBIT->red == 0 || sBIT->red > dp->bit_depth)
-               sBIT_invalid = 1;
-            else
-               dp->red_sBIT = sBIT->red;
-
-            if (sBIT->green == 0 || sBIT->green > dp->bit_depth)
-               sBIT_invalid = 1;
-            else
-               dp->green_sBIT = sBIT->green;
-
-            if (sBIT->blue == 0 || sBIT->blue > dp->bit_depth)
-               sBIT_invalid = 1;
-            else
-               dp->blue_sBIT = sBIT->blue;
-         }
-
-         else /* !COLOR */
-         {
-            if (sBIT->gray == 0 || sBIT->gray > dp->bit_depth)
-               sBIT_invalid = 1;
-            else
-               dp->blue_sBIT = dp->green_sBIT = dp->red_sBIT = sBIT->gray;
-         }
-
-         /* All 8 bits in tRNS for a palette image are significant - see the
-          * spec.
-          */
-         if (dp->colour_type & PNG_COLOR_MASK_ALPHA)
-         {
-            if (sBIT->alpha == 0 || sBIT->alpha > dp->bit_depth)
-               sBIT_invalid = 1;
-            else
-               dp->alpha_sBIT = sBIT->alpha;
-         }
-
-         if (sBIT_invalid)
-            png_error(pp, "validate: sBIT value out of range");
-      }
-   }
-
-   /* Important: this is validating the value *before* any transforms have been
-    * put in place.  It doesn't matter for the standard tests, where there are
-    * no transforms, but it does for other tests where rowbytes may change after
-    * png_read_update_info.
-    */
-   if (png_get_rowbytes(pp, pi) != standard_rowsize(pp, dp->id))
-      png_error(pp, "validate: row size changed");
-
-   /* The palette is never read for non-palette images, even though it is valid
-    * - this could be changed.
-    */
-   if (dp->colour_type == 3) /* palette */
-   {
-      int i;
-
-      dp->is_transparent = standard_palette_init(dp->palette, pp, pi);
-
-      /* And validate the result. */
-      for (i=0; i<256; ++i)
-         if (dp->palette[i].red != i || dp->palette[i].green != i ||
-            dp->palette[i].blue != i)
-            png_error(pp, "validate: color type 3 PLTE chunk changed");
-   }
-
-   /* In any case always check for a tranparent color: */
-   {
-      png_color_16p trans_color = 0;
-
-      if (png_get_tRNS(pp, pi, 0, 0, &trans_color) & PNG_INFO_tRNS)
-      {
-         if (trans_color == 0)
-            png_error(pp, "validate: unexpected png_get_tRNS (color) result");
-
-         switch (dp->colour_type)
-         {
-         case 0:
-            dp->transparent.red = dp->transparent.green = dp->transparent.blue =
-               trans_color->gray;
-            dp->is_transparent = 1;
-            break;
-
-         case 2:
-            dp->transparent.red = trans_color->red;
-            dp->transparent.green = trans_color->green;
-            dp->transparent.blue = trans_color->blue;
-            dp->is_transparent = 1;
-            break;
-
-         case 3:
-            /* Not expected because it should result in the array case
-             * above.
-             */
-            png_error(pp, "validate: unexpected png_get_tRNS result");
-            break;
-
-         default:
-            png_error(pp, "validate: invalid tRNS chunk with alpha image");
-         }
-      }
-   }
-
-   /* Read the number of passes - expected to match the value used when
-    * creating the image (interlaced or not).  This has the side effect of
-    * turning on interlace handling (if do_interlace is not set.)
-    */
-   dp->npasses = npasses_from_interlace_type(pp, dp->interlace_type);
-   if (!dp->do_interlace && dp->npasses != png_set_interlace_handling(pp))
-      png_error(pp, "validate: file changed interlace type");
-
-   /* Caller calls png_read_update_info or png_start_read_image now, then calls
-    * part2.
-    */
-}
-
-/* This must be called *after* the png_read_update_info call to get the correct
- * 'rowbytes' value, otherwise png_get_rowbytes will refer to the untransformed
- * image.
- */
-static void
-standard_info_part2(standard_display *dp, png_structp pp, png_infop pi,
-    int nImages)
-{
-   /* Record cbRow now that it can be found. */
-   dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),
-      png_get_bit_depth(pp, pi));
-   dp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;
-   dp->cbRow = png_get_rowbytes(pp, pi);
-
-   /* Validate the rowbytes here again. */
-   if (dp->cbRow != (dp->bit_width+7)/8)
-      png_error(pp, "bad png_get_rowbytes calculation");
-
-   /* Then ensure there is enough space for the output image(s). */
-   store_ensure_image(dp->ps, pp, nImages * dp->cbRow * dp->h);
-}
-
-static void
-standard_info_imp(standard_display *dp, png_structp pp, png_infop pi,
-    int nImages)
-{
-   /* Note that the validation routine has the side effect of turning on
-    * interlace handling in the subsequent code.
-    */
-   standard_info_part1(dp, pp, pi);
-
-   /* And the info callback has to call this (or png_read_update_info - see
-    * below in the png_modifier code for that variant.
-    */
-   png_start_read_image(pp);
-
-   /* Validate the height, width and rowbytes plus ensure that sufficient buffer
-    * exists for decoding the image.
-    */
-   standard_info_part2(dp, pp, pi, nImages);
-}
-
-static void
-standard_info(png_structp pp, png_infop pi)
-{
-   standard_display *dp = png_get_progressive_ptr(pp);
-
-   /* Call with nImages==1 because the progressive reader can only produce one
-    * image.
-    */
-   standard_info_imp(dp, pp, pi, 1 /*only one image*/);
-}
-
-static void
-progressive_row(png_structp pp, png_bytep new_row, png_uint_32 y, int pass)
-{
-   PNG_CONST standard_display *dp = png_get_progressive_ptr(pp);
-
-   /* When handling interlacing some rows will be absent in each pass, the
-    * callback still gets called, but with a NULL pointer.  This is checked
-    * in the 'else' clause below.  We need our own 'cbRow', but we can't call
-    * png_get_rowbytes because we got no info structure.
-    */
-   if (new_row != NULL)
-   {
-      png_bytep row;
-
-      /* In the case where the reader doesn't do the interlace it gives
-       * us the y in the sub-image:
-       */
-      if (dp->do_interlace && dp->interlace_type == PNG_INTERLACE_ADAM7)
-         y = PNG_ROW_FROM_PASS_ROW(y, pass);
-
-      /* Validate this just in case. */
-      if (y >= dp->h)
-         png_error(pp, "invalid y to progressive row callback");
-
-      row = dp->ps->image + y * dp->cbRow;
-
-      /* Combine the new row into the old: */
-      if (dp->do_interlace)
-      {
-         if (dp->interlace_type == PNG_INTERLACE_ADAM7)
-            deinterlace_row(row, new_row, dp->pixel_size, dp->w, pass);
-         else
-            memcpy(row, new_row, dp->cbRow);
-      }
-      else
-         png_progressive_combine_row(pp, row, new_row);
-   } else if (dp->interlace_type == PNG_INTERLACE_ADAM7 &&
-      PNG_ROW_IN_INTERLACE_PASS(y, pass) &&
-      PNG_PASS_COLS(dp->w, pass) > 0)
-      png_error(pp, "missing row in progressive de-interlacing");
-}
-
-static void
-sequential_row(standard_display *dp, png_structp pp, png_infop pi,
-    PNG_CONST png_bytep pImage, PNG_CONST png_bytep pDisplay)
-{
-   PNG_CONST int         npasses = dp->npasses;
-   PNG_CONST int         do_interlace = dp->do_interlace &&
-      dp->interlace_type == PNG_INTERLACE_ADAM7;
-   PNG_CONST png_uint_32 height = standard_height(pp, dp->id);
-   PNG_CONST png_uint_32 width = standard_width(pp, dp->id);
-   PNG_CONST size_t      cbRow = dp->cbRow;
-   int pass;
-
-   for (pass=0; pass<npasses; ++pass)
-   {
-      png_uint_32 y;
-      png_uint_32 wPass = PNG_PASS_COLS(width, pass);
-      png_bytep pRow1 = pImage;
-      png_bytep pRow2 = pDisplay;
-
-      for (y=0; y<height; ++y)
-      {
-         if (do_interlace)
-         {
-            /* wPass may be zero or this row may not be in this pass.
-             * png_read_row must not be called in either case.
-             */
-            if (wPass > 0 && PNG_ROW_IN_INTERLACE_PASS(y, pass))
-            {
-               /* Read the row into a pair of temporary buffers, then do the
-                * merge here into the output rows.
-                */
-               png_byte row[STANDARD_ROWMAX], display[STANDARD_ROWMAX];
-
-               /* The following aids (to some extent) error detection - we can
-                * see where png_read_row wrote.  Use opposite values in row and
-                * display to make this easier.
-                */
-               memset(row, 0xff, sizeof row);
-               memset(display, 0, sizeof display);
-
-               png_read_row(pp, row, display);
-
-               if (pRow1 != NULL)
-                  deinterlace_row(pRow1, row, dp->pixel_size, dp->w, pass);
-
-               if (pRow2 != NULL)
-                  deinterlace_row(pRow2, display, dp->pixel_size, dp->w, pass);
-            }
-         }
-         else
-            png_read_row(pp, pRow1, pRow2);
-
-         if (pRow1 != NULL)
-            pRow1 += cbRow;
-
-         if (pRow2 != NULL)
-            pRow2 += cbRow;
-      }
-   }
-
-   /* And finish the read operation (only really necessary if the caller wants
-    * to find additional data in png_info from chunks after the last IDAT.)
-    */
-   png_read_end(pp, pi);
-}
-
-static void
-standard_row_validate(standard_display *dp, png_structp pp, png_const_bytep row,
-   png_const_bytep display, png_uint_32 y)
-{
-   png_byte std[STANDARD_ROWMAX];
-
-   memset(std, 0xff, sizeof std);
-   standard_row(pp, std, dp->id, y);
-
-   /* At the end both the 'row' and 'display' arrays should end up identical.
-    * In earlier passes 'row' will be partially filled in, with only the pixels
-    * that have been read so far, but 'display' will have those pixels
-    * replicated to fill the unread pixels while reading an interlaced image.
-    * The side effect inside the libpng sequential reader is that the 'row'
-    * array retains the correct values for unwritten pixels within the row
-    * bytes, while the 'display' array gets bits off the end of the image (in
-    * the last byte) trashed.  Unfortunately in the progressive reader the
-    * row bytes are always trashed, so we always do a pixel_cmp here even though
-    * a memcmp of all cbRow bytes will succeed for the sequential reader.
-    */
-   if (row != NULL && pixel_cmp(std, row, dp->bit_width) != 0)
-   {
-      char msg[64];
-      sprintf(msg, "PNG image row %d changed", y);
-      png_error(pp, msg);
-   }
-
-   /* In this case use pixel_cmp because we need to compare a partial
-    * byte at the end of the row if the row is not an exact multiple
-    * of 8 bits wide.
-    */
-   if (display != NULL && pixel_cmp(std, display, dp->bit_width) != 0)
-   {
-      char msg[64];
-      sprintf(msg, "display row %d changed", y);
-      png_error(pp, msg);
-   }
-}
-
-static void
-standard_image_validate(standard_display *dp, png_structp pp,
-   png_const_bytep pImage, png_const_bytep pDisplay)
-{
-   png_uint_32 y;
-
-   for (y=0; y<dp->h; ++y)
-   {
-      standard_row_validate(dp, pp, pImage, pDisplay, y);
-
-      if (pImage != NULL)
-         pImage += dp->cbRow;
-
-      if (pDisplay != NULL)
-         pDisplay += dp->cbRow;
-   }
-
-   /* This avoids false positives if the validation code is never called! */
-   dp->ps->validated = 1;
-}
-
-static void
-standard_end(png_structp pp, png_infop pi)
-{
-   standard_display *dp = png_get_progressive_ptr(pp);
-
-   UNUSED(pi)
-
-   /* Validate the image - progressive reading only produces one variant for
-    * interlaced images.
-    */
-   standard_image_validate(dp, pp, dp->ps->image, NULL);
-}
-
-/* A single test run checking the standard image to ensure it is not damaged. */
-static void
-standard_test(png_store* PNG_CONST psIn, png_uint_32 PNG_CONST id,
-   int do_interlace)
-{
-   standard_display d;
-   context(psIn, fault);
-
-   /* Set up the display (stack frame) variables from the arguments to the
-    * function and initialize the locals that are filled in later.
-    */
-   standard_display_init(&d, psIn, id, do_interlace);
-
-   /* Everything is protected by a Try/Catch.  The functions called also
-    * typically have local Try/Catch blocks.
-    */
-   Try
-   {
-      png_structp pp;
-      png_infop pi;
-
-      /* Get a png_struct for reading the image. This will throw an error if it
-       * fails, so we don't need to check the result.
-       */
-      pp = set_store_for_read(d.ps, &pi, d.id,
-         d.do_interlace ?  (d.ps->progressive ?
-            "pngvalid progressive deinterlacer" :
-            "pngvalid sequential deinterlacer") : (d.ps->progressive ?
-               "progressive reader" : "sequential reader"));
-
-      /* Introduce the correct read function. */
-      if (d.ps->progressive)
-      {
-         png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,
-            standard_end);
-
-         /* Now feed data into the reader until we reach the end: */
-         store_progressive_read(d.ps, pp, pi);
-      }
-      else
-      {
-         /* Note that this takes the store, not the display. */
-         png_set_read_fn(pp, d.ps, store_read);
-
-         /* Check the header values: */
-         png_read_info(pp, pi);
-
-         /* The code tests both versions of the images that the sequential
-          * reader can produce.
-          */
-         standard_info_imp(&d, pp, pi, 2 /*images*/);
-
-         /* Need the total bytes in the image below; we can't get to this point
-          * unless the PNG file values have been checked against the expected
-          * values.
-          */
-         {
-            PNG_CONST png_bytep pImage = d.ps->image;
-            PNG_CONST png_bytep pDisplay = pImage + d.cbRow * d.h;
-
-            sequential_row(&d, pp, pi, pImage, pDisplay);
-
-            /* After the last pass loop over the rows again to check that the
-             * image is correct.
-             */
-            standard_image_validate(&d, pp, pImage, pDisplay);
-         }
-      }
-
-      /* Check for validation. */
-      if (!d.ps->validated)
-         png_error(pp, "image read failed silently");
-
-      /* Successful completion. */
-   }
-
-   Catch(fault)
-      d.ps = fault; /* make sure this hasn't been clobbered. */
-
-   /* In either case clean up the store. */
-   store_read_reset(d.ps);
-}
-
-static int
-test_standard(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
-    int bdlo, int PNG_CONST bdhi)
-{
-   for (; bdlo <= bdhi; ++bdlo)
-   {
-      int interlace_type;
-
-      for (interlace_type = PNG_INTERLACE_NONE;
-           interlace_type < PNG_INTERLACE_LAST; ++interlace_type)
-      {
-         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo),
-            interlace_type, 0, 0, 0), 0/*do_interlace*/);
-
-         if (fail(pm))
-            return 0;
-      }
-   }
-
-   return 1; /* keep going */
-}
-
-static void
-perform_standard_test(png_modifier *pm)
-{
-   /* Test each colour type over the valid range of bit depths (expressed as
-    * log2(bit_depth) in turn, stop as soon as any error is detected.
-    */
-   if (!test_standard(pm, 0, 0, READ_BDHI))
-      return;
-
-   if (!test_standard(pm, 2, 3, READ_BDHI))
-      return;
-
-   if (!test_standard(pm, 3, 0, 3))
-      return;
-
-   if (!test_standard(pm, 4, 3, READ_BDHI))
-      return;
-
-   if (!test_standard(pm, 6, 3, READ_BDHI))
-      return;
-}
-
-
-/********************************** SIZE TESTS ********************************/
-static int
-test_size(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
-    int bdlo, int PNG_CONST bdhi)
-{
-   /* Run the tests on each combination.
-    *
-    * NOTE: on my 32 bit x86 each of the following blocks takes
-    * a total of 3.5 seconds if done across every combo of bit depth
-    * width and height.  This is a waste of time in practice, hence the
-    * hinc and winc stuff:
-    */
-   static PNG_CONST png_byte hinc[] = {1, 3, 11, 1, 5};
-   static PNG_CONST png_byte winc[] = {1, 9, 5, 7, 1};
-   for (; bdlo <= bdhi; ++bdlo)
-   {
-      png_uint_32 h, w;
-
-      for (h=1; h<=16; h+=hinc[bdlo]) for (w=1; w<=16; w+=winc[bdlo])
-      {
-         /* First test all the 'size' images against the sequential
-          * reader using libpng to deinterlace (where required.)  This
-          * validates the write side of libpng.  There are four possibilities
-          * to validate.
-          */
-         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo),
-            PNG_INTERLACE_NONE, w, h, 0), 0/*do_interlace*/);
-
-         if (fail(pm))
-            return 0;
-
-         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo),
-            PNG_INTERLACE_NONE, w, h, 1), 0/*do_interlace*/);
-
-         if (fail(pm))
-            return 0;
-
-         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo),
-            PNG_INTERLACE_ADAM7, w, h, 0), 0/*do_interlace*/);
-
-         if (fail(pm))
-            return 0;
-
-         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo),
-            PNG_INTERLACE_ADAM7, w, h, 1), 0/*do_interlace*/);
-
-         if (fail(pm))
-            return 0;
-
-         /* Now validate the interlaced read side - do_interlace true,
-          * in the progressive case this does actually make a difference
-          * to the code used in the non-interlaced case too.
-          */
-         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo),
-            PNG_INTERLACE_NONE, w, h, 0), 1/*do_interlace*/);
-
-         if (fail(pm))
-            return 0;
-
-         standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo),
-            PNG_INTERLACE_ADAM7, w, h, 0), 1/*do_interlace*/);
-
-         if (fail(pm))
-            return 0;
-      }
-   }
-
-   return 1; /* keep going */
-}
-
-static void
-perform_size_test(png_modifier *pm)
-{
-   /* Test each colour type over the valid range of bit depths (expressed as
-    * log2(bit_depth) in turn, stop as soon as any error is detected.
-    */
-   if (!test_size(pm, 0, 0, READ_BDHI))
-      return;
-
-   if (!test_size(pm, 2, 3, READ_BDHI))
-      return;
-
-   /* For the moment don't do the palette test - it's a waste of time when
-    * compared to the greyscale test.
-    */
-#if 0
-   if (!test_size(pm, 3, 0, 3))
-      return;
-#endif
-
-   if (!test_size(pm, 4, 3, READ_BDHI))
-      return;
-
-   if (!test_size(pm, 6, 3, READ_BDHI))
-      return;
-}
-
-
-/******************************* TRANSFORM TESTS ******************************/
-/* A set of tests to validate libpng image transforms.  The possibilities here
- * are legion because the transforms can be combined in a combinatorial
- * fashion.  To deal with this some measure of restraint is required, otherwise
- * the tests would take forever.
- */
-typedef struct image_pixel
-{
-   /* A local (pngvalid) representation of a PNG pixel, in all its
-    * various forms.
-    */
-   unsigned int red, green, blue, alpha; /* For non-palette images. */
-   unsigned int palette_index;           /* For a palette image. */
-   png_byte colour_type;                 /* As in the spec. */
-   png_byte bit_depth;                   /* Defines bit size in row */
-   png_byte sample_depth;                /* Scale of samples */
-   int      have_tRNS;                   /* tRNS chunk may need processing */
-
-   /* For checking the code calculates double precision floating point values
-    * along with an error value, accumulated from the transforms.  Because an
-    * sBIT setting allows larger error bounds (indeed, by the spec, apparently
-    * up to just less than +/-1 in the scaled value) the *lowest* sBIT for each
-    * channel is stored.  This sBIT value is folded in to the stored error value
-    * at the end of the application of the transforms to the pixel.
-    */
-   double   redf, greenf, bluef, alphaf;
-   double   rede, greene, bluee, alphae;
-   png_byte red_sBIT, green_sBIT, blue_sBIT, alpha_sBIT;
-} image_pixel;
-
-/* Shared utility function, see below. */
-static void
-image_pixel_setf(image_pixel *this, unsigned int max)
-{
-   this->redf = this->red / (double)max;
-   this->greenf = this->green / (double)max;
-   this->bluef = this->blue / (double)max;
-   this->alphaf = this->alpha / (double)max;
-
-   if (this->red < max)
-      this->rede = this->redf * DBL_EPSILON;
-   else
-      this->rede = 0;
-   if (this->green < max)
-      this->greene = this->greenf * DBL_EPSILON;
-   else
-      this->greene = 0;
-   if (this->blue < max)
-      this->bluee = this->bluef * DBL_EPSILON;
-   else
-      this->bluee = 0;
-   if (this->alpha < max)
-      this->alphae = this->alphaf * DBL_EPSILON;
-   else
-      this->alphae = 0;
-}
-
-/* Initialize the structure for the next pixel - call this before doing any
- * transforms and call it for each pixel since all the fields may need to be
- * reset.
- */
-static void
-image_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,
-    png_byte bit_depth, png_uint_32 x, standard_palette palette)
-{
-   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==
-      PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);
-   PNG_CONST unsigned int max = (1U<<sample_depth)-1;
-
-   /* Initially just set everything to the same number and the alpha to opaque.
-    * Note that this currently assumes a simple palette where entry x has colour
-    * rgb(x,x,x)!
-    */
-   this->palette_index = this->red = this->green = this->blue =
-      sample(row, colour_type, bit_depth, x, 0);
-   this->alpha = max;
-   this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT =
-      sample_depth;
-
-   /* Then override as appropriate: */
-   if (colour_type == 3) /* palette */
-   {
-      /* This permits the caller to default to the sample value. */
-      if (palette != 0)
-      {
-         PNG_CONST unsigned int i = this->palette_index;
-
-         this->red = palette[i].red;
-         this->green = palette[i].green;
-         this->blue = palette[i].blue;
-         this->alpha = palette[i].alpha;
-      }
-   }
-
-   else /* not palette */
-   {
-      unsigned int i = 0;
-
-      if (colour_type & 2)
-      {
-         this->green = sample(row, colour_type, bit_depth, x, 1);
-         this->blue = sample(row, colour_type, bit_depth, x, 2);
-         i = 2;
-      }
-      if (colour_type & 4)
-         this->alpha = sample(row, colour_type, bit_depth, x, ++i);
-   }
-
-   /* Calculate the scaled values, these are simply the values divided by
-    * 'max' and the error is initialized to the double precision epsilon value
-    * from the header file.
-    */
-   image_pixel_setf(this, max);
-
-   /* Store the input information for use in the transforms - these will
-    * modify the information.
-    */
-   this->colour_type = colour_type;
-   this->bit_depth = bit_depth;
-   this->sample_depth = sample_depth;
-   this->have_tRNS = 0;
-}
-
-/* Convert a palette image to an rgb image.  This necessarily converts the tRNS
- * chunk at the same time, because the tRNS will be in palette form.
- */
-static void
-image_pixel_convert_PLTE(image_pixel *this, const standard_display *display)
-{
-   if (this->colour_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      PNG_CONST unsigned int i = this->palette_index;
-
-      this->bit_depth = this->sample_depth;
-      this->red = display->palette[i].red;
-      this->green = display->palette[i].green;
-      this->blue = display->palette[i].blue;
-      this->red_sBIT = display->red_sBIT;
-      this->green_sBIT = display->green_sBIT;
-      this->blue_sBIT = display->blue_sBIT;
-
-      if (this->have_tRNS)
-      {
-         this->alpha = display->palette[i].alpha;
-         this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;
-         this->have_tRNS = 0;
-      }
-      else
-      {
-         this->alpha = 255;
-         this->colour_type = PNG_COLOR_TYPE_RGB;
-      }
-      this->alpha_sBIT = 8;
-
-      /* And regenerate the scaled values and all the errors, which are now set
-       * back to the initial values.
-       */
-      image_pixel_setf(this, 255);
-   }
-}
-
-/* Add an alpha channel, this will glom in the tRNS information because tRNS is
- * not valid in an alpha image.  The bit depth will invariably be set to at
- * least 8.  Palette images will be converted to alpha (using the above API).
- */
-static void
-image_pixel_add_alpha(image_pixel *this, const standard_display *display)
-{
-   if (this->colour_type == PNG_COLOR_TYPE_PALETTE)
-      image_pixel_convert_PLTE(this, display);
-
-   if ((this->colour_type & PNG_COLOR_MASK_ALPHA) == 0)
-   {
-      if (this->colour_type == PNG_COLOR_TYPE_GRAY)
-      {
-         if (this->bit_depth < 8)
-            this->bit_depth = 8;
-
-         if (this->have_tRNS)
-         {
-            this->have_tRNS = 0;
-
-            /* Check the input, original, channel value here against the
-             * original tRNS gray chunk valie.
-             */
-            if (this->red == display->transparent.red)
-               this->alphaf = 0;
-            else
-               this->alphaf = 1;
-         }
-         else
-            this->alphaf = 1;
-
-         this->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;
-      }
-
-      else if (this->colour_type == PNG_COLOR_TYPE_RGB)
-      {
-         if (this->have_tRNS)
-         {
-            this->have_tRNS = 0;
-
-            /* Again, check the exact input values, not the current transformed
-             * value!
-             */
-            if (this->red == display->transparent.red &&
-               this->green == display->transparent.green &&
-               this->blue == display->transparent.blue)
-               this->alphaf = 0;
-            else
-               this->alphaf = 1;
-
-            this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;
-         }
-      }
-
-      /* The error in the alpha is zero and the sBIT value comes from the
-       * original sBIT data (actually it will always be the original bit depth).
-       */
-      this->alphae = 0;
-      this->alpha_sBIT = display->alpha_sBIT;
-   }
-}
-
-struct transform_display;
-typedef struct image_transform
-{
-   /* The name of this transform: a string. */
-   PNG_CONST char *name;
-
-   /* Each transform can be disabled from the command line: */
-   int enable;
-
-   /* The global list of transforms; read only. */
-   struct image_transform *PNG_CONST list;
-
-   /* The global count of the number of times this transform has been set on an
-    * image.
-    */
-   unsigned int global_use;
-
-   /* The local count of the number of times this transform has been set. */
-   unsigned int local_use;
-
-   /* The next transform in the list, each transform must call its own next
-    * transform after it has processed the pixel successfully.
-    */
-   PNG_CONST struct image_transform *next;
-
-   /* A single transform for the image, expressed as a series of function
-    * callbacks and some space for values.
-    *
-    * First a callback to set the transform on the current png_read_struct:
-    */
-   void (*set)(PNG_CONST struct image_transform *this,
-      struct transform_display *that, png_structp pp, png_infop pi);
-
-   /* Then a transform that takes an input pixel in one PNG format or another
-    * and modifies it by a pngvalid implementation of the transform (thus
-    * duplicating the libpng intent without, we hope, duplicating the bugs
-    * in the libpng implementation!)  The png_structp is solely to allow error
-    * reporting via png_error and png_warning.
-    */
-   void (*mod)(PNG_CONST struct image_transform *this, image_pixel *that,
-      png_structp pp, PNG_CONST struct transform_display *display);
-
-   /* Add this transform to the list and return true if the transform is
-    * meaningful for this colour type and bit depth - if false then the
-    * transform should have no effect on the image so there's not a lot of
-    * point running it.
-    */
-   int (*add)(struct image_transform *this,
-      PNG_CONST struct image_transform **that, png_byte colour_type,
-      png_byte bit_depth);
-} image_transform;
-
-typedef struct transform_display
-{
-   standard_display this;
-
-   /* Parameters */
-   png_modifier*              pm;
-   PNG_CONST image_transform* transform_list;
-
-   /* Local variables */
-   png_byte output_colour_type;
-   png_byte output_bit_depth;
-} transform_display;
-
-/* Two functions to end the list: */
-static void
-image_transform_set_end(PNG_CONST image_transform *this,
-   transform_display *that, png_structp pp, png_infop pi)
-{
-   UNUSED(this)
-   UNUSED(that)
-   UNUSED(pp)
-   UNUSED(pi)
-}
-
-/* At the end of the list recalculate the output image pixel value from the
- * double precision values set up by the preceding 'mod' calls:
- */
-static unsigned int
-sample_scale(double sample_value, unsigned int scale)
-{
-   sample_value = floor(sample_value * scale + .5);
-
-   /* Return NaN as 0: */
-   if (!(sample_value > 0))
-      sample_value = 0;
-   else if (sample_value > scale)
-      sample_value = scale;
-
-   return (unsigned int)sample_value;
-}
-
-static void
-image_transform_mod_end(PNG_CONST image_transform *this, image_pixel *that,
-    png_structp pp, PNG_CONST transform_display *display)
-{
-   PNG_CONST unsigned int scale = (1U<<that->sample_depth)-1;
-
-   UNUSED(this)
-   UNUSED(pp)
-   UNUSED(display)
-
-   /* At the end recalculate the digitized red green and blue values according
-    * to the current sample_depth of the pixel.
-    *
-    * The sample value is simply scaled to the maximum, checking for over
-    * and underflow (which can both happen for some image transforms,
-    * including simple size scaling, though libpng doesn't do that at present.
-    */
-   that->red = sample_scale(that->redf, scale);
-
-   /* The error value is increased, at the end, according to the lowest sBIT
-    * value seen.  Common sense tells us that the intermediate integer
-    * representations are no more accurate than +/- 0.5 in the integral values,
-    * the sBIT allows the implementation to be worse than this.  In addition the
-    * PNG specification actually permits any error within the range (-1..+1),
-    * but that is ignored here.  Instead the final digitized value is compared,
-    * below to the digitized value of the error limits - this has the net effect
-    * of allowing (almost) +/-1 in the output value.  It's difficult to see how
-    * any algorithm that digitizes intermediate results can be more accurate.
-    */
-   that->rede += 1./(2*((1U<<that->red_sBIT)-1));
-
-   if (that->colour_type & PNG_COLOR_MASK_COLOR)
-   {
-      that->green = sample_scale(that->greenf, scale);
-      that->blue = sample_scale(that->bluef, scale);
-      that->greene += 1./(2*((1U<<that->green_sBIT)-1));
-      that->bluee += 1./(2*((1U<<that->blue_sBIT)-1));
-   }
-   else
-   {
-      that->blue = that->green = that->red;
-      that->bluef = that->greenf = that->redf;
-      that->bluee = that->greene = that->rede;
-   }
-
-   if ((that->colour_type & PNG_COLOR_MASK_ALPHA) ||
-      that->colour_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      that->alpha = sample_scale(that->alphaf, scale);
-      that->alphae += 1./(2*((1U<<that->alpha_sBIT)-1));
-   }
-   else
-   {
-      that->alpha = scale; /* opaque */
-      that->alpha = 1;     /* Override this. */
-      that->alphae = 0;    /* It's exact ;-) */
-   }
-}
-
-/* Static 'end' structure: */
-static image_transform image_transform_end =
-{
-   "(end)", /* name */
-   1, /* enable */
-   0, /* list */
-   0, /* global_use */
-   0, /* local_use */
-   0, /* next */
-   image_transform_set_end,
-   image_transform_mod_end,
-   0 /* never called, I want it to crash if it is! */
-};
-
-/* Reader callbacks and implementations, where they differ from the standard
- * ones.
- */
-static void
-transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,
-    PNG_CONST image_transform *transform_list)
-{
-   /* Standard fields */
-   standard_display_init(&dp->this, &pm->this, id, 0/*do_interlace*/);
-
-   /* Parameter fields */
-   dp->pm = pm;
-   dp->transform_list = transform_list;
-
-   /* Local variable fields */
-   dp->output_colour_type = 255; /* invalid */
-   dp->output_bit_depth = 255;  /* invalid */
-}
-
-static void
-transform_info_imp(transform_display *dp, png_structp pp, png_infop pi)
-{
-   /* Reuse the standard stuff as appropriate. */
-   standard_info_part1(&dp->this, pp, pi);
-
-   /* Now set the list of transforms. */
-   dp->transform_list->set(dp->transform_list, dp, pp, pi);
-
-   /* Update the info structure for these transforms: */
-   png_read_update_info(pp, pi);
-
-   /* And get the output information into the standard_display */
-   standard_info_part2(&dp->this, pp, pi, 1/*images*/);
-
-   /* Plus the extra stuff we need for the transform tests: */
-   dp->output_colour_type = png_get_color_type(pp, pi);
-   dp->output_bit_depth = png_get_bit_depth(pp, pi);
-
-   /* Validate the combination of colour type and bit depth that we are getting
-    * out of libpng; the semantics of something not in the PNG spec are, at
-    * best, unclear.
-    */
-   switch (dp->output_colour_type)
-   {
-   case PNG_COLOR_TYPE_PALETTE:
-      if (dp->output_bit_depth > 8) goto error;
-      /*FALL THROUGH*/
-   case PNG_COLOR_TYPE_GRAY:
-      if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 ||
-         dp->output_bit_depth == 4)
-         break;
-      /*FALL THROUGH*/
-   default:
-      if (dp->output_bit_depth == 8 || dp->output_bit_depth == 16)
-         break;
-      /*FALL THROUGH*/
-   error:
-      {
-         char message[128];
-         size_t pos;
-
-         pos = safecat(message, sizeof message, 0,
-            "invalid final bit depth: colour type(");
-         pos = safecatn(message, sizeof message, pos, dp->output_colour_type);
-         pos = safecat(message, sizeof message, pos, ") with bit depth: ");
-         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);
-
-         png_error(pp, message);
-      }
-   }
-
-   /* Use a test pixel to check that the output agrees with what we expect -
-    * this avoids running the whole test if the output is unexpected.
-    */
-   {
-      image_pixel test_pixel;
-
-      memset(&test_pixel, 0, sizeof test_pixel);
-      test_pixel.colour_type = dp->this.colour_type; /* input */
-      test_pixel.bit_depth = dp->this.bit_depth;
-      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)
-         test_pixel.sample_depth = 8;
-      else
-         test_pixel.sample_depth = test_pixel.bit_depth;
-      /* Don't need sBIT here */
-      test_pixel.have_tRNS = dp->this.is_transparent;
-
-      dp->transform_list->mod(dp->transform_list, &test_pixel, pp, dp);
-
-      if (test_pixel.colour_type != dp->output_colour_type)
-      {
-         char message[128];
-         size_t pos = safecat(message, sizeof message, 0, "colour type ");
-
-         pos = safecatn(message, sizeof message, pos, dp->output_colour_type);
-         pos = safecat(message, sizeof message, pos, " expected ");
-         pos = safecatn(message, sizeof message, pos, test_pixel.colour_type);
-
-         png_error(pp, message);
-      }
-
-      if (test_pixel.bit_depth != dp->output_bit_depth)
-      {
-         char message[128];
-         size_t pos = safecat(message, sizeof message, 0, "bit depth ");
-
-         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);
-         pos = safecat(message, sizeof message, pos, " expected ");
-         pos = safecatn(message, sizeof message, pos, test_pixel.bit_depth);
-
-         png_error(pp, message);
-      }
-
-      /* If both bit depth and colour type are correct check the sample depth.
-       * I believe these are both internal errors.
-       */
-      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         if (test_pixel.sample_depth != 8) /* oops - internal error! */
-            png_error(pp, "pngvalid: internal: palette sample depth not 8");
-      }
-      else if (test_pixel.sample_depth != dp->output_bit_depth)
-      {
-         char message[128];
-         size_t pos = safecat(message, sizeof message, 0,
-            "internal: sample depth ");
-
-         pos = safecatn(message, sizeof message, pos, dp->output_bit_depth);
-         pos = safecat(message, sizeof message, pos, " expected ");
-         pos = safecatn(message, sizeof message, pos, test_pixel.sample_depth);
-
-         png_error(pp, message);
-      }
-   }
-}
-
-static void
-transform_info(png_structp pp, png_infop pi)
-{
-   transform_info_imp(png_get_progressive_ptr(pp), pp, pi);
-}
-
-static void
-transform_range_check(png_structp pp, unsigned int r, unsigned int g,
-   unsigned int b, unsigned int a, unsigned int in_digitized, double in,
-   unsigned int out, png_byte sample_depth, double err, PNG_CONST char *name)
-{
-   /* Compare the scaled, digitzed, values of our local calculation (in+-err)
-    * with the digitized values libpng produced;  'sample_depth' is the actual
-    * digitization depth of the libpng output colors (the bit depth except for
-    * palette images where it is always 8.)
-    */
-   unsigned int max = (1U<<sample_depth)-1;
-   double in_min = ceil((in-err)*max - .5);
-   double in_max = floor((in+err)*max + .5);
-   if (!(out >= in_min && out <= in_max))
-   {
-      char message[256];
-      size_t pos;
-
-      pos = safecat(message, sizeof message, 0, name);
-      pos = safecat(message, sizeof message, pos, " output value error: rgba(");
-      pos = safecatn(message, sizeof message, pos, r);
-      pos = safecat(message, sizeof message, pos, ",");
-      pos = safecatn(message, sizeof message, pos, g);
-      pos = safecat(message, sizeof message, pos, ",");
-      pos = safecatn(message, sizeof message, pos, b);
-      pos = safecat(message, sizeof message, pos, ",");
-      pos = safecatn(message, sizeof message, pos, a);
-      pos = safecat(message, sizeof message, pos, "): ");
-      pos = safecatn(message, sizeof message, pos, out);
-      pos = safecat(message, sizeof message, pos, " expected: ");
-      pos = safecatn(message, sizeof message, pos, in_digitized);
-      pos = safecat(message, sizeof message, pos, " (");
-      pos = safecatd(message, sizeof message, pos, (in-err)*max, 3);
-      pos = safecat(message, sizeof message, pos, "..");
-      pos = safecatd(message, sizeof message, pos, (in+err)*max, 3);
-      pos = safecat(message, sizeof message, pos, ")");
-
-      png_error(pp, message);
-   }
-}
-
-static void
-transform_image_validate(transform_display *dp, png_structp pp, png_infop pi,
-    png_const_bytep pRow)
-{
-   /* Constants for the loop below: */
-   PNG_CONST png_byte in_ct = dp->this.colour_type;
-   PNG_CONST png_byte in_bd = dp->this.bit_depth;
-   PNG_CONST png_uint_32 w = dp->this.w;
-   PNG_CONST png_uint_32 h = dp->this.h;
-   PNG_CONST size_t cbRow = dp->this.cbRow;
-   PNG_CONST png_byte out_ct = dp->output_colour_type;
-   PNG_CONST png_byte out_bd = dp->output_bit_depth;
-   PNG_CONST png_byte sample_depth = (png_byte)(out_ct ==
-      PNG_COLOR_TYPE_PALETTE ? 8 : out_bd);
-   PNG_CONST png_byte red_sBIT = dp->this.red_sBIT;
-   PNG_CONST png_byte green_sBIT = dp->this.green_sBIT;
-   PNG_CONST png_byte blue_sBIT = dp->this.blue_sBIT;
-   PNG_CONST png_byte alpha_sBIT = dp->this.alpha_sBIT;
-   PNG_CONST int have_tRNS = dp->this.is_transparent;
-
-   standard_palette out_palette;
-   png_uint_32 y;
-
-   UNUSED(pi)
-
-   /* Read the palette corresponding to the output if the output colour type
-    * indicates a palette, othewise set out_palette to garbage.
-    */
-   if (out_ct == PNG_COLOR_TYPE_PALETTE)
-      (void)standard_palette_init(out_palette, pp, pi);
-   else
-      memset(out_palette, 0x5e, sizeof out_palette);
-
-   for (y=0; y<h; ++y, pRow += cbRow)
-   {
-      png_uint_32 x;
-
-      /* The original, standard, row pre-transforms. */
-      png_byte std[STANDARD_ROWMAX];
-
-      transform_row(pp, std, in_ct, in_bd, y);
-
-      /* Go through each original pixel transforming it and comparing with what
-       * libpng did to the same pixel.
-       */
-      for (x=0; x<w; ++x)
-      {
-         image_pixel in_pixel, out_pixel;
-         unsigned int r, g, b, a;
-
-         /* Find out what we think the pixel should be: */
-         image_pixel_init(&in_pixel, std, in_ct, in_bd, x, dp->this.palette);
-
-         in_pixel.red_sBIT = red_sBIT;
-         in_pixel.green_sBIT = green_sBIT;
-         in_pixel.blue_sBIT = blue_sBIT;
-         in_pixel.alpha_sBIT = alpha_sBIT;
-         in_pixel.have_tRNS = have_tRNS;
-
-         /* For error detection, below. */
-         r = in_pixel.red;
-         g = in_pixel.green;
-         b = in_pixel.blue;
-         a = in_pixel.alpha;
-
-         dp->transform_list->mod(dp->transform_list, &in_pixel, pp, dp);
-
-         /* Read the output pixel and compare it to what we got, we don't
-          * use the error field here, so no need to update sBIT.
-          */
-         image_pixel_init(&out_pixel, pRow, out_ct, out_bd, x, out_palette);
-
-         /* We don't expect changes to the index here even if the bit depth is
-          * changed.
-          */
-         if (in_ct == PNG_COLOR_TYPE_PALETTE &&
-            out_ct == PNG_COLOR_TYPE_PALETTE)
-         {
-            if (in_pixel.palette_index != out_pixel.palette_index)
-               png_error(pp, "unexpected transformed palette index");
-         }
-
-         /* Check the colours for palette images too - in fact the palette could
-          * be separately verified itself in most cases.
-          */
-         if (in_pixel.red != out_pixel.red)
-            transform_range_check(pp, r, g, b, a, in_pixel.red, in_pixel.redf,
-               out_pixel.red, sample_depth, in_pixel.rede, "red/gray");
-
-         if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&
-            in_pixel.green != out_pixel.green)
-            transform_range_check(pp, r, g, b, a, in_pixel.green,
-               in_pixel.greenf, out_pixel.green, sample_depth, in_pixel.greene,
-               "green");
-
-         if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 &&
-            in_pixel.blue != out_pixel.blue)
-            transform_range_check(pp, r, g, b, a, in_pixel.blue, in_pixel.bluef,
-               out_pixel.blue, sample_depth, in_pixel.bluee, "blue");
-
-         if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&
-            in_pixel.alpha != out_pixel.alpha)
-            transform_range_check(pp, r, g, b, a, in_pixel.alpha,
-               in_pixel.alphaf, out_pixel.alpha, sample_depth, in_pixel.alphae,
-               "alpha");
-      } /* pixel (x) loop */
-   } /* row (y) loop */
-
-   /* Record that something was actually checked to avoid a false positive. */
-   dp->this.ps->validated = 1;
-}
-
-static void
-transform_end(png_structp pp, png_infop pi)
-{
-   transform_display *dp = png_get_progressive_ptr(pp);
-
-   transform_image_validate(dp, pp, pi, dp->this.ps->image);
-}
-
-/* A single test run. */
-static void
-transform_test(png_modifier *pmIn, PNG_CONST png_uint_32 idIn,
-    PNG_CONST image_transform* transform_listIn, PNG_CONST char *name)
-{
-   transform_display d;
-   context(&pmIn->this, fault);
-
-   transform_display_init(&d, pmIn, idIn, transform_listIn);
-
-   Try
-   {
-      png_structp pp;
-      png_infop pi;
-
-      /* Get a png_struct for writing the image. */
-      pp = set_modifier_for_read(d.pm, &pi, d.this.id, name);
-
-#     if 0
-         /* Logging (debugging only) */
-         {
-            char buffer[256];
-
-            (void)store_message(&d.pm->this, pp, buffer, sizeof buffer, 0,
-               "running test");
-
-            fprintf(stderr, "%s\n", buffer);
-         }
-#     endif
-
-      /* Introduce the correct read function. */
-      if (d.pm->this.progressive)
-      {
-         /* Share the row function with the standard implementation. */
-         png_set_progressive_read_fn(pp, &d, transform_info, progressive_row,
-            transform_end);
-
-         /* Now feed data into the reader until we reach the end: */
-         modifier_progressive_read(d.pm, pp, pi);
-      }
-      else
-      {
-         /* modifier_read expects a png_modifier* */
-         png_set_read_fn(pp, d.pm, modifier_read);
-
-         /* Check the header values: */
-         png_read_info(pp, pi);
-
-         /* Process the 'info' requirements. Only one image is generated */
-         transform_info_imp(&d, pp, pi);
-
-         sequential_row(&d.this, pp, pi, NULL, d.this.ps->image);
-
-         transform_image_validate(&d, pp, pi, d.this.ps->image);
-      }
-
-      modifier_reset(d.pm);
-   }
-
-   Catch(fault)
-      modifier_reset((png_modifier*)fault);
-}
-
-/* The transforms: */
-#define ITSTRUCT(name) image_transform_##name
-#define IT(name,prev)\
-static image_transform ITSTRUCT(name) =\
-{\
-   #name,\
-   1, /*enable*/\
-   &ITSTRUCT(prev), /*list*/\
-   0, /*global_use*/\
-   0, /*local_use*/\
-   0, /*next*/\
-   image_transform_png_set_##name##_set,\
-   image_transform_png_set_##name##_mod,\
-   image_transform_png_set_##name##_add\
-}
-
-/* To save code: */
-static int
-image_transform_default_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   UNUSED(colour_type)
-   UNUSED(bit_depth)
-
-   this->next = *that;
-   *that = this;
-
-   return 1;
-}
-
-/* png_set_palette_to_rgb */
-static void
-image_transform_png_set_palette_to_rgb_set(PNG_CONST image_transform *this,
-    transform_display *that, png_structp pp, png_infop pi)
-{
-   png_set_palette_to_rgb(pp);
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_palette_to_rgb_mod(PNG_CONST image_transform *this,
-    image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
-      image_pixel_convert_PLTE(that, &display->this);
-
-   this->next->mod(this->next, that, pp, display);
-}
-
-static int
-image_transform_png_set_palette_to_rgb_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   UNUSED(bit_depth)
-
-   this->next = *that;
-   *that = this;
-
-   return colour_type == PNG_COLOR_TYPE_PALETTE;
-}
-
-IT(palette_to_rgb, end);
-
-
-/* png_set_tRNS_to_alpha */
-static void
-image_transform_png_set_tRNS_to_alpha_set(PNG_CONST image_transform *this,
-   transform_display *that, png_structp pp, png_infop pi)
-{
-   png_set_tRNS_to_alpha(pp);
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_tRNS_to_alpha_mod(PNG_CONST image_transform *this,
-   image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   /* LIBPNG BUG: this always forces palette images to RGB. */
-   if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
-      image_pixel_convert_PLTE(that, &display->this);
-
-   /* This effectively does an 'expand' only if there is some transparency to
-    * covert to an alpha channel.
-    */
-   if (that->have_tRNS)
-      image_pixel_add_alpha(that, &display->this);
-
-   /* LIBPNG BUG: otherwise libpng still expands to 8 bits! */
-   else
-   {
-      if (that->bit_depth < 8)
-         that->bit_depth =8;
-      if (that->sample_depth < 8)
-         that->sample_depth = 8;
-   }
-
-   this->next->mod(this->next, that, pp, display);
-}
-
-static int
-image_transform_png_set_tRNS_to_alpha_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   UNUSED(bit_depth)
-
-   this->next = *that;
-   *that = this;
-
-   /* We don't know yet whether there will be a tRNS chunk, but we know that
-    * this transformation should do nothing if there already is an alpha
-    * channel.
-    */
-   return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
-}
-
-IT(tRNS_to_alpha,palette_to_rgb);
-
-/* png_set_gray_to_rgb */
-static void
-image_transform_png_set_gray_to_rgb_set(PNG_CONST image_transform *this,
-    transform_display *that, png_structp pp, png_infop pi)
-{
-   png_set_gray_to_rgb(pp);
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_gray_to_rgb_mod(PNG_CONST image_transform *this,
-    image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   /* NOTE: we can actually pend the tRNS processing at this point because we
-    * can correctly recognize the original pixel value even though we have
-    * mapped the one gray channel to the three RGB ones, but in fact libpng
-    * doesn't do this, so we don't either.
-    */
-   if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS)
-      image_pixel_add_alpha(that, &display->this);
-
-   /* Simply expand the bit depth and alter the colour type as required. */
-   if (that->colour_type == PNG_COLOR_TYPE_GRAY)
-   {
-      /* RGB images have a bit depth at least equal to '8' */
-      if (that->bit_depth < 8)
-         that->sample_depth = that->bit_depth = 8;
-
-      /* And just changing the colour type works here because the green and blue
-       * channels are being maintained in lock-step with the red/gray:
-       */
-      that->colour_type = PNG_COLOR_TYPE_RGB;
-   }
-
-   else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      that->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;
-
-   this->next->mod(this->next, that, pp, display);
-}
-
-static int
-image_transform_png_set_gray_to_rgb_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   UNUSED(bit_depth)
-
-   this->next = *that;
-   *that = this;
-
-   return (colour_type & PNG_COLOR_MASK_COLOR) == 0;
-}
-
-IT(gray_to_rgb,tRNS_to_alpha);
-
-/* png_set_expand */
-static void
-image_transform_png_set_expand_set(PNG_CONST image_transform *this,
-    transform_display *that, png_structp pp, png_infop pi)
-{
-   png_set_expand(pp);
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_expand_mod(PNG_CONST image_transform *this,
-    image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   /* The general expand case depends on what the colour type is: */
-   if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
-      image_pixel_convert_PLTE(that, &display->this);
-   else if (that->bit_depth < 8) /* grayscale */
-      that->sample_depth = that->bit_depth = 8;
-
-   if (that->have_tRNS)
-      image_pixel_add_alpha(that, &display->this);
-
-   this->next->mod(this->next, that, pp, display);
-}
-
-static int
-image_transform_png_set_expand_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   UNUSED(bit_depth)
-
-   this->next = *that;
-   *that = this;
-
-   /* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit
-    * depth is at least 8 already.
-    */
-   return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
-}
-
-IT(expand,gray_to_rgb);
-
-/* png_set_expand_gray_1_2_4_to_8
- * LIBPNG BUG: this just does an 'expand'
- */
-static void
-image_transform_png_set_expand_gray_1_2_4_to_8_set(
-    PNG_CONST image_transform *this, transform_display *that, png_structp pp,
-    png_infop pi)
-{
-   png_set_expand_gray_1_2_4_to_8(pp);
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_expand_gray_1_2_4_to_8_mod(
-    PNG_CONST image_transform *this, image_pixel *that, png_structp pp,
-    PNG_CONST transform_display *display)
-{
-   image_transform_png_set_expand_mod(this, that, pp, display);
-}
-
-static int
-image_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   return image_transform_png_set_expand_add(this, that, colour_type,
-      bit_depth);
-}
-
-IT(expand_gray_1_2_4_to_8, expand);
-
-/* png_set_strip_16 */
-static void
-image_transform_png_set_strip_16_set(PNG_CONST image_transform *this,
-    transform_display *that, png_structp pp, png_infop pi)
-{
-   png_set_strip_16(pp);
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_strip_16_mod(PNG_CONST image_transform *this,
-    image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   if (that->bit_depth == 16)
-   {
-      that->sample_depth = that->bit_depth = 8;
-      if (that->red_sBIT > 8) that->red_sBIT = 8;
-      if (that->green_sBIT > 8) that->green_sBIT = 8;
-      if (that->blue_sBIT > 8) that->blue_sBIT = 8;
-      if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;
-
-#     ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
-         /* The strip 16 algoirithm drops the low 8 bits rather than calculating
-          * 1/257, so we need to adjust the permitted errors appropriately:
-          */
-         {
-            PNG_CONST double d = (255-128.5)/65535;
-            that->rede += d;
-            that->greene += d;
-            that->bluee += d;
-            that->alphae += d;
-         }
-#     endif
-   }
-
-   this->next->mod(this->next, that, pp, display);
-}
-
-static int
-image_transform_png_set_strip_16_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   UNUSED(colour_type)
-
-   this->next = *that;
-   *that = this;
-
-   return bit_depth > 8;
-}
-
-IT(strip_16, expand_gray_1_2_4_to_8);
-
-/* png_set_strip_alpha */
-static void
-image_transform_png_set_strip_alpha_set(PNG_CONST image_transform *this,
-    transform_display *that, png_structp pp, png_infop pi)
-{
-   png_set_strip_alpha(pp);
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_strip_alpha_mod(PNG_CONST image_transform *this,
-    image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      that->colour_type = PNG_COLOR_TYPE_GRAY;
-   else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      that->colour_type = PNG_COLOR_TYPE_RGB;
-
-   that->have_tRNS = 0;
-   that->alphaf = 1;
-   that->alphae = 0;
-
-   this->next->mod(this->next, that, pp, display);
-}
-
-static int
-image_transform_png_set_strip_alpha_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   UNUSED(bit_depth)
-
-   this->next = *that;
-   *that = this;
-
-   return (colour_type & PNG_COLOR_MASK_ALPHA) != 0;
-}
-
-IT(strip_alpha,strip_16);
-
-/* png_set_rgb_to_gray(png_structp, int err_action, double red, double green)
- * png_set_rgb_to_gray_fixed(png_structp, int err_action, png_fixed_point red,
- *    png_fixed_point green)
- * png_get_rgb_to_gray_status
- *
- * At present the APIs are simply tested using the 16.16 fixed point conversion
- * values known to be used inside libpng:
- *
- *   red:    6968
- *   green: 23434
- *   blue:   2366
- *
- * NOTE: this currently ignores the gamma because no gamma is being set, the
- * tests on gamma need to happen in the gamma test set.
- */
-static void
-image_transform_png_set_rgb_to_gray_set(PNG_CONST image_transform *this,
-    transform_display *that, png_structp pp, png_infop pi)
-{
-   PNG_CONST int error_action = 1; /* no error, no defines in png.h */
-
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-      png_set_rgb_to_gray(pp, error_action, -1, -1);
-#  else
-      png_set_rgb_to_gray_fixed(pp, error_action, -1, -1);
-#  endif
-
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_rgb_to_gray_mod(PNG_CONST image_transform *this,
-    image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   if ((that->colour_type & PNG_COLOR_MASK_COLOR) != 0)
-   {
-      if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
-         image_pixel_convert_PLTE(that, &display->this);
-
-      /* Image now has RGB channels... */
-      that->bluef = that->greenf = that->redf = (that->redf * 6968 +
-         that->greenf * 23434 + that->bluef * 2366) / 32768;
-      that->bluee = that->greene = that->rede = (that->rede * 6968 +
-         that->greene * 23434 + that->bluee * 2366) / 32768 *
-         (1 + DBL_EPSILON * 6);
-
-      /* The sBIT is the minium of the three colour channel sBITs. */
-      if (that->red_sBIT > that->green_sBIT)
-         that->red_sBIT = that->green_sBIT;
-      if (that->red_sBIT > that->blue_sBIT)
-         that->red_sBIT = that->blue_sBIT;
-      that->blue_sBIT = that->green_sBIT = that->red_sBIT;
-
-      /* And zap the colour bit in the type: */
-      if (that->colour_type == PNG_COLOR_TYPE_RGB)
-         that->colour_type = PNG_COLOR_TYPE_GRAY;
-      else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)
-         that->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;
-   }
-
-   this->next->mod(this->next, that, pp, display);
-}
-
-static int
-image_transform_png_set_rgb_to_gray_add(image_transform *this,
-    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
-{
-   UNUSED(bit_depth)
-
-   this->next = *that;
-   *that = this;
-
-   return (colour_type & PNG_COLOR_MASK_COLOR) != 0;
-}
-
-IT(rgb_to_gray,strip_alpha);
-
-/* png_set_background(png_structp, png_const_color_16p background_color,
- *    int background_gamma_code, int need_expand, double background_gamma)
- * png_set_background_fixed(png_structp, png_const_color_16p background_color,
- *    int background_gamma_code, int need_expand,
- *    png_fixed_point background_gamma)
- *
- * As with rgb_to_gray this ignores the gamma.
-*/
-static void
-image_transform_png_set_background_set(PNG_CONST image_transform *this,
-    transform_display *that, png_structp pp, png_infop pi)
-{
-   png_color_16 back;
-
-   /* Since we don't know the output bit depth at this point we must use the
-    * input values and ask libpng to expand the chunk as required.
-    */
-   back.index = 255; /* Should not be used */
-   back.gray = back.blue = back.green = back.red =
-      (png_uint_16)((1U << that->this.bit_depth) >> 1);
-
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-      png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, 1, 0);
-#  else
-      png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, 1, 0);
-#  endif
-
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_background_mod(PNG_CONST image_transform *this,
-    image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   /* Check for tRNS first: */
-   if (that->have_tRNS && that->colour_type != PNG_COLOR_TYPE_PALETTE)
-      image_pixel_add_alpha(that, &display->this);
-
-   /* This is only necessary if the alpha value is less than 1. */
-   if (that->alphaf < 1)
-   {
-      /* Repeat the calculation above and scale the result: */
-      unsigned int tmp = (1U << display->this.bit_depth);
-      double component = (tmp >> 1)/(double)(tmp-1);
-
-      /* Now we do the background calculation without any gamma correction. */
-      if (that->alphaf <= 0)
-      {
-         that->bluef = that->greenf = that->redf = component;
-         that->bluee = that->greene = that->rede = component * DBL_EPSILON;
-         that->blue_sBIT = that->green_sBIT = that->red_sBIT = that->bit_depth;
-      }
-
-      else
-      {
-         component *= 1-that->alphaf;
-         that->redf = that->redf * that->alphaf + component;
-         that->rede = that->rede * that->alphaf + that->redf * 3 * DBL_EPSILON;
-         that->greenf = that->greenf * that->alphaf + component;
-         that->greene = that->greene * that->alphaf + that->greenf * 3 *
-            DBL_EPSILON;
-         that->bluef = that->bluef * that->alphaf + component;
-         that->bluee = that->bluee * that->alphaf + that->bluef * 3 *
-            DBL_EPSILON;
-      }
-
-      /* Remove the alpha type and set the alpha. */
-      that->alphaf = 1;
-      that->alphae = 0;
-
-      if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)
-         that->colour_type = PNG_COLOR_TYPE_RGB;
-      else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-         that->colour_type = PNG_COLOR_TYPE_GRAY;
-   }
-
-   this->next->mod(this->next, that, pp, display);
-}
-
-#define image_transform_png_set_background_add image_transform_default_add
-
-IT(background,rgb_to_gray);
-
-static image_transform *PNG_CONST image_transform_first = &ITSTRUCT(background);
-
-static void
-transform_enable(PNG_CONST char *name)
-{
-   /* Everything starts out enabled, so if we see an 'enable' disabled
-    * everything else the first time round.
-    */
-   static int all_disabled = 0;
-   int found_it = 0;
-   image_transform *list = image_transform_first;
-
-   while (list != &image_transform_end)
-   {
-      if (strcmp(list->name, name) == 0)
-      {
-         list->enable = 1;
-         found_it = 1;
-      }
-      else if (!all_disabled)
-         list->enable = 0;
-
-      list = list->list;
-   }
-
-   all_disabled = 1;
-
-   if (!found_it)
-   {
-      fprintf(stderr, "pngvalid: --transform-enable=%s: unknown transform\n",
-         name);
-      exit(1);
-   }
-}
-
-static void
-transform_disable(PNG_CONST char *name)
-{
-   image_transform *list = image_transform_first;
-
-   while (list != &image_transform_end)
-   {
-      if (strcmp(list->name, name) == 0)
-      {
-         list->enable = 0;
-         return;
-      }
-
-      list = list->list;
-   }
-
-   fprintf(stderr, "pngvalid: --transform-disable=%s: unknown transform\n",
-      name);
-   exit(1);
-}
-
-static void
-image_transform_reset_count(void)
-{
-   image_transform *next = image_transform_first;
-   int count = 0;
-
-   while (next != &image_transform_end)
-   {
-      next->local_use = 0;
-      next->next = 0;
-      next = next->list;
-      ++count;
-   }
-
-   /* This can only happen if we every have more than 32 transforms (excluding
-    * the end) in the list.
-    */
-   if (count > 32) abort();
-}
-
-static int
-image_transform_test_counter(png_uint_32 counter, unsigned int max)
-{
-   /* Test the list to see if there is any point contining, given a current
-    * counter and a 'max' value.
-    */
-   image_transform *next = image_transform_first;
-
-   while (next != &image_transform_end)
-   {
-      /* For max 0 or 1 continue until the counter overflows: */
-      counter >>= 1;
-
-      /* Continue if any entry hasn't reacked the max. */
-      if (max > 1 && next->local_use < max)
-         return 1;
-      next = next->list;
-   }
-
-   return max <= 1 && counter == 0;
-}
-
-static png_uint_32
-image_transform_add(PNG_CONST image_transform **this, unsigned int max,
-   png_uint_32 counter, char *name, size_t sizeof_name, size_t *pos,
-   png_byte colour_type, png_byte bit_depth)
-{
-   for (;;) /* until we manage to add something */
-   {
-      png_uint_32 mask;
-      image_transform *list;
-
-      /* Find the next counter value, if the counter is zero this is the start
-       * of the list.  This routine always returns the current counter (not the
-       * next) so it returns 0 at the end and expects 0 at the beginning.
-       */
-      if (counter == 0) /* first time */
-      {
-         image_transform_reset_count();
-         if (max <= 1)
-            counter = 1;
-         else
-            counter = random_32();
-      }
-      else /* advance the counter */
-      {
-         switch (max)
-         {
-            case 0:  ++counter; break;
-            case 1:  counter <<= 1; break;
-            default: counter = random_32(); break;
-         }
-      }
-
-      /* Now add all these items, if possible */
-      *this = &image_transform_end;
-      list = image_transform_first;
-      mask = 1;
-
-      /* Go through the whole list adding anything that the counter selects: */
-      while (list != &image_transform_end)
-      {
-         if ((counter & mask) != 0 && list->enable &&
-             (max == 0 || list->local_use < max))
-         {
-            /* Candidate to add: */
-            if (list->add(list, this, colour_type, bit_depth) || max == 0)
-            {
-               /* Added, so add to the name too. */
-               *pos = safecat(name, sizeof_name, *pos, " +");
-               *pos = safecat(name, sizeof_name, *pos, list->name);
-            }
-
-            else
-            {
-               /* Not useful and max>0, so remvoe it from *this: */
-               *this = list->next;
-               list->next = 0;
-
-               /* And, since we know it isn't useful, stop it being added again
-                * in this run:
-                */
-               list->local_use = max;
-            }
-         }
-
-         mask <<= 1;
-         list = list->list;
-      }
-
-      /* Now if anything was added we have something to do. */
-      if (*this != &image_transform_end)
-         return counter;
-
-      /* Nothing added, but was there anything in there to add? */
-      if (!image_transform_test_counter(counter, max))
-         return 0;
-   }
-}
-
-#ifdef THIS_IS_THE_PROFORMA
-static void
-image_transform_png_set_@_set(PNG_CONST image_transform *this,
-    transform_display *that, png_structp pp, png_infop pi)
-{
-   png_set_@(pp);
-   this->next->set(this->next, that, pp, pi);
-}
-
-static void
-image_transform_png_set_@_mod(PNG_CONST image_transform *this,
-    image_pixel *that, png_structp pp, PNG_CONST transform_display *display)
-{
-   this->next->mod(this->next, that, pp, display);
-}
-
-static int
-image_transform_png_set_@_add(image_transform *this,
-    PNG_CONST image_transform **that, char *name, size_t sizeof_name,
-    size_t *pos, png_byte colour_type, png_byte bit_depth)
-{
-   this->next = *that;
-   *that = this;
-
-   *pos = safecat(name, sizeof_name, *pos, " +@");
-
-   return 1;
-}
-
-IT(@);
-#endif
-
-/* png_set_quantize(png_structp, png_colorp palette, int num_palette,
- *    int maximum_colors, png_const_uint_16p histogram, int full_quantize)
- *
- * Very difficult to validate this!
- */
-/*NOTE: TBD NYI */
-
-/* The data layout transforms are handled by swapping our own channel data,
- * necessarily these need to happen at the end of the transform list because the
- * semantic of the channels changes after these are executed.  Some of these,
- * like set_shift and set_packing, can't be done at present because they change
- * the layout of the data at the sub-sample level so sample() won't get the
- * right answer.
- */
-/* png_set_invert_alpha */
-/*NOTE: TBD NYI */
-
-/* png_set_bgr */
-/*NOTE: TBD NYI */
-
-/* png_set_swap_alpha */
-/*NOTE: TBD NYI */
-
-/* png_set_swap */
-/*NOTE: TBD NYI */
-
-/* png_set_filler, (png_structp png_ptr, png_uint_32 filler, int flags)); */
-/*NOTE: TBD NYI */
-
-/* png_set_add_alpha, (png_structp png_ptr, png_uint_32 filler, int flags)); */
-/*NOTE: TBD NYI */
-
-/* png_set_packing */
-/*NOTE: TBD NYI */
-
-/* png_set_packswap */
-/*NOTE: TBD NYI */
-
-/* png_set_invert_mono */
-/*NOTE: TBD NYI */
-
-/* png_set_shift(png_structp, png_const_color_8p true_bits) */
-/*NOTE: TBD NYI */
-
-static int
-test_transform(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
-    int bdlo, int PNG_CONST bdhi, png_uint_32 max)
-{
-   for (; bdlo <= bdhi; ++bdlo)
-   {
-      PNG_CONST png_byte bit_depth = DEPTH(bdlo);
-      png_uint_32 counter = 0;
-      size_t base_pos;
-      char name[64];
-
-      base_pos = safecat(name, sizeof name, 0, "transform:");
-
-      for (;;)
-      {
-         size_t pos = base_pos;
-         PNG_CONST image_transform *list = 0;
-
-         counter = image_transform_add(&list, max, counter, name, sizeof name,
-            &pos, colour_type, bit_depth);
-
-         if (counter == 0)
-            break;
-
-         /* The command line can change this to checking interlaced images. */
-         transform_test(pm, FILEID(colour_type, bit_depth, pm->interlace_type,
-            0, 0, 0), list, name);
-
-         if (fail(pm))
-            return 0;
-      }
-   }
-
-   return 1; /* keep going */
-}
-
-static void
-perform_transform_test(png_modifier *pm)
-{
-   /* Test each colour type over the valid range of bit depths (expressed as
-    * log2(bit_depth) in turn, stop as soon as any error is detected.
-    */
-   if (!test_transform(pm, 0, 0, READ_BDHI, 1))
-      return;
-
-   if (!test_transform(pm, 2, 3, READ_BDHI, 1))
-      return;
-
-   if (!test_transform(pm, 3, 0, 3, 1))
-      return;
-
-   if (!test_transform(pm, 4, 3, READ_BDHI, 1))
-      return;
-
-   if (!test_transform(pm, 6, 3, READ_BDHI, 1))
-      return;
-}
-
-
-/********************************* GAMMA TESTS ********************************/
-/* Gamma test images. */
-typedef struct gamma_modification
-{
-   png_modification this;
-   png_fixed_point  gamma;
-} gamma_modification;
-
-static int
-gamma_modify(png_modifier *pm, png_modification *me, int add)
-{
-   UNUSED(add)
-   /* This simply dumps the given gamma value into the buffer. */
-   png_save_uint_32(pm->buffer, 4);
-   png_save_uint_32(pm->buffer+4, CHUNK_gAMA);
-   png_save_uint_32(pm->buffer+8, ((gamma_modification*)me)->gamma);
-   return 1;
-}
-
-static void
-gamma_modification_init(gamma_modification *me, png_modifier *pm, double gammad)
-{
-   double g;
-
-   modification_init(&me->this);
-   me->this.chunk = CHUNK_gAMA;
-   me->this.modify_fn = gamma_modify;
-   me->this.add = CHUNK_PLTE;
-   g = floor(gammad * 100000 + .5);
-   me->gamma = (png_fixed_point)g;
-   me->this.next = pm->modifications;
-   pm->modifications = &me->this;
-}
-
-typedef struct srgb_modification
-{
-   png_modification this;
-   png_byte         intent;
-} srgb_modification;
-
-static int
-srgb_modify(png_modifier *pm, png_modification *me, int add)
-{
-   UNUSED(add)
-   /* As above, ignore add and just make a new chunk */
-   png_save_uint_32(pm->buffer, 1);
-   png_save_uint_32(pm->buffer+4, CHUNK_sRGB);
-   pm->buffer[8] = ((srgb_modification*)me)->intent;
-   return 1;
-}
-
-static void
-srgb_modification_init(srgb_modification *me, png_modifier *pm, png_byte intent)
-{
-   modification_init(&me->this);
-   me->this.chunk = CHUNK_sBIT;
-
-   if (intent <= 3) /* if valid, else *delete* sRGB chunks */
-   {
-      me->this.modify_fn = srgb_modify;
-      me->this.add = CHUNK_PLTE;
-      me->intent = intent;
-   }
-
-   else
-   {
-      me->this.modify_fn = 0;
-      me->this.add = 0;
-      me->intent = 0;
-   }
-
-   me->this.next = pm->modifications;
-   pm->modifications = &me->this;
-}
-
-typedef struct sbit_modification
-{
-   png_modification this;
-   png_byte         sbit;
-} sbit_modification;
-
-static int
-sbit_modify(png_modifier *pm, png_modification *me, int add)
-{
-   png_byte sbit = ((sbit_modification*)me)->sbit;
-   if (pm->bit_depth > sbit)
-   {
-      int cb = 0;
-      switch (pm->colour_type)
-      {
-         case 0:
-            cb = 1;
-            break;
-
-         case 2:
-         case 3:
-            cb = 3;
-            break;
-
-         case 4:
-            cb = 2;
-            break;
-
-         case 6:
-            cb = 4;
-            break;
-
-         default:
-            png_error(pm->this.pread,
-               "unexpected colour type in sBIT modification");
-      }
-
-      png_save_uint_32(pm->buffer, cb);
-      png_save_uint_32(pm->buffer+4, CHUNK_sBIT);
-
-      while (cb > 0)
-         (pm->buffer+8)[--cb] = sbit;
-
-      return 1;
-   }
-   else if (!add)
-   {
-      /* Remove the sBIT chunk */
-      pm->buffer_count = pm->buffer_position = 0;
-      return 1;
-   }
-   else
-      return 0; /* do nothing */
-}
-
-static void
-sbit_modification_init(sbit_modification *me, png_modifier *pm, png_byte sbit)
-{
-   modification_init(&me->this);
-   me->this.chunk = CHUNK_sBIT;
-   me->this.modify_fn = sbit_modify;
-   me->this.add = CHUNK_PLTE;
-   me->sbit = sbit;
-   me->this.next = pm->modifications;
-   pm->modifications = &me->this;
-}
-
-/* Reader callbacks and implementations, where they differ from the standard
- * ones.
- */
-typedef struct gamma_display
-{
-   standard_display this;
-
-   /* Parameters */
-   png_modifier*    pm;
-   double           file_gamma;
-   double           screen_gamma;
-   png_byte         sbit;
-   int              threshold_test;
-   PNG_CONST char*  name;
-   int              speed;
-   int              use_input_precision;
-   int              strip16;
-
-   /* Local variables */
-   double       maxerrout;
-   double       maxerrpc;
-   double       maxerrabs;
-} gamma_display;
-
-static void
-gamma_display_init(gamma_display *dp, png_modifier *pm, png_uint_32 id,
-    double file_gamma, double screen_gamma, png_byte sbit, int threshold_test,
-    int speed, int use_input_precision, int strip16)
-{
-   /* Standard fields */
-   standard_display_init(&dp->this, &pm->this, id, 0/*do_interlace*/);
-
-   /* Parameter fields */
-   dp->pm = pm;
-   dp->file_gamma = file_gamma;
-   dp->screen_gamma = screen_gamma;
-   dp->sbit = sbit;
-   dp->threshold_test = threshold_test;
-   dp->speed = speed;
-   dp->use_input_precision = use_input_precision;
-   dp->strip16 = strip16;
-
-   /* Local variable fields */
-   dp->maxerrout = dp->maxerrpc = dp->maxerrabs = 0;
-}
-
-static void
-gamma_info_imp(gamma_display *dp, png_structp pp, png_infop pi)
-{
-   /* Reuse the standard stuff as appropriate. */
-   standard_info_part1(&dp->this, pp, pi);
-
-   /* If requested strip 16 to 8 bits - this is handled automagically below
-    * because the output bit depth is read from the library.  Note that there
-    * are interactions with sBIT but, internally, libpng makes sbit at most
-    * PNG_MAX_GAMMA_8 when doing the following.
-    */
-   if (dp->strip16)
-#     ifdef PNG_READ_16_TO_8_SUPPORTED
-         png_set_strip_16(pp);
-#     else
-         png_error(pp, "strip16 (16 to 8 bit conversion) not supported");
-#     endif
-
-   png_read_update_info(pp, pi);
-
-   /* Now we may get a different cbRow: */
-   standard_info_part2(&dp->this, pp, pi, 1 /*images*/);
-}
-
-static void
-gamma_info(png_structp pp, png_infop pi)
-{
-   gamma_info_imp(png_get_progressive_ptr(pp), pp, pi);
-}
-
-static void
-gamma_image_validate(gamma_display *dp, png_structp pp, png_infop pi,
-    png_const_bytep pRow)
-{
-   /* Get some constants derived from the input and output file formats: */
-   PNG_CONST png_byte sbit = dp->sbit;
-   PNG_CONST double file_gamma = dp->file_gamma;
-   PNG_CONST double screen_gamma = dp->screen_gamma;
-   PNG_CONST int use_input_precision = dp->use_input_precision;
-   PNG_CONST int speed = dp->speed;
-   PNG_CONST png_byte in_ct = dp->this.colour_type;
-   PNG_CONST png_byte in_bd = dp->this.bit_depth;
-   PNG_CONST png_uint_32 w = dp->this.w;
-   PNG_CONST png_uint_32 h = dp->this.h;
-   PNG_CONST size_t cbRow = dp->this.cbRow;
-   PNG_CONST png_byte out_ct = png_get_color_type(pp, pi);
-   PNG_CONST png_byte out_bd = png_get_bit_depth(pp, pi);
-   PNG_CONST unsigned int outmax = (1U<<out_bd)-1;
-   PNG_CONST double maxabs = abserr(dp->pm, out_bd);
-   PNG_CONST double maxout = outerr(dp->pm, out_bd);
-   PNG_CONST double maxpc = pcerr(dp->pm, out_bd);
-
-   /* There are three sources of error, firstly the quantization in the
-    * file encoding, determined by sbit and/or the file depth, secondly
-    * the output (screen) gamma and thirdly the output file encoding.
-    *
-    * Since this API receives the screen and file gamma in double
-    * precision it is possible to calculate an exact answer given an input
-    * pixel value.  Therefore we assume that the *input* value is exact -
-    * sample/maxsample - calculate the corresponding gamma corrected
-    * output to the limits of double precision arithmetic and compare with
-    * what libpng returns.
-    *
-    * Since the library must quantize the output to 8 or 16 bits there is
-    * a fundamental limit on the accuracy of the output of +/-.5 - this
-    * quantization limit is included in addition to the other limits
-    * specified by the paramaters to the API.  (Effectively, add .5
-    * everywhere.)
-    *
-    * The behavior of the 'sbit' paramter is defined by section 12.5
-    * (sample depth scaling) of the PNG spec.  That section forces the
-    * decoder to assume that the PNG values have been scaled if sBIT is
-    * present:
-    *
-    *     png-sample = floor( input-sample * (max-out/max-in) + .5);
-    *
-    * This means that only a subset of the possible PNG values should
-    * appear in the input. However, the spec allows the encoder to use a
-    * variety of approximations to the above and doesn't require any
-    * restriction of the values produced.
-    *
-    * Nevertheless the spec requires that the upper 'sBIT' bits of the
-    * value stored in a PNG file be the original sample bits.
-    * Consequently the code below simply scales the top sbit bits by
-    * (1<<sbit)-1 to obtain an original sample value.
-    *
-    * Because there is limited precision in the input it is arguable that
-    * an acceptable result is any valid result from input-.5 to input+.5.
-    * The basic tests below do not do this, however if
-    * 'use_input_precision' is set a subsequent test is performed below.
-    */
-   PNG_CONST int processing = (fabs(screen_gamma*file_gamma-1) >=
-      PNG_GAMMA_THRESHOLD && !dp->threshold_test && !speed && in_ct != 3) ||
-      in_bd != out_bd;
-
-   PNG_CONST unsigned int samples_per_pixel = (out_ct & 2U) ? 3U : 1U;
-
-   PNG_CONST double gamma_correction = 1/(file_gamma*screen_gamma);/* Overall */
-
-   double maxerrout = 0, maxerrabs = 0, maxerrpc = 0;
-   png_uint_32 y;
-
-   for (y=0; y<h; ++y, pRow += cbRow)
-   {
-      unsigned int s, x;
-      png_byte std[STANDARD_ROWMAX];
-
-      transform_row(pp, std, in_ct, in_bd, y);
-
-      if (processing)
-      {
-         for (x=0; x<w; ++x) for (s=0; s<samples_per_pixel; ++s)
-         {
-            /* Input sample values: */
-            PNG_CONST unsigned int
-               id = sample(std, in_ct, in_bd, x, s);
-
-            PNG_CONST unsigned int
-               od = sample(pRow, out_ct, out_bd, x, s);
-
-            PNG_CONST unsigned int
-               isbit = id >> (in_bd-sbit);
-
-            double i, input_sample, encoded_sample, output;
-            double encoded_error, error;
-            double es_lo, es_hi;
-
-            /* First check on the 'perfect' result obtained from the
-             * digitized input value, id, and compare this against the
-             * actual digitized result, 'od'.  'i' is the input result
-             * in the range 0..1:
-             *
-             * NOTE: sBIT should be taken into account here but isn't,
-             * as described above.
-             */
-            i = isbit; i /= (1U<<sbit)-1;
-
-            /* Then get the gamma corrected version of 'i' and compare
-             * to 'od', any error less than .5 is insignificant - just
-             * quantization of the output value to the nearest digital
-             * value (nevertheless the error is still recorded - it's
-             * interesting ;-)
-             */
-            encoded_sample = pow(i, gamma_correction) * outmax;
-            encoded_error = fabs(od-encoded_sample);
-
-            if (encoded_error > maxerrout)
-               maxerrout = encoded_error;
-
-            if (encoded_error < .5+maxout)
-               continue;
-
-            /* There may be an error, so calculate the actual sample
-             * values - unencoded light intensity values.  Note that
-             * in practice these are not unencoded because they
-             * include a 'viewing correction' to decrease or
-             * (normally) increase the perceptual contrast of the
-             * image.  There's nothing we can do about this - we don't
-             * know what it is - so assume the unencoded value is
-             * perceptually linear.
-             */
-            input_sample = pow(i, 1/file_gamma); /* In range 0..1 */
-            output = od;
-            output /= outmax;
-            output = pow(output, screen_gamma);
-
-            /* Now we have the numbers for real errors, both absolute
-             * values as as a percentage of the correct value (output):
-             */
-            error = fabs(input_sample-output);
-
-            if (error > maxerrabs)
-               maxerrabs = error;
-
-            /* The following is an attempt to ignore the tendency of
-             * quantization to dominate the percentage errors for low
-             * output sample values:
-             */
-            if (input_sample*maxpc > .5+maxabs)
-            {
-               double percentage_error = error/input_sample;
-               if (percentage_error > maxerrpc) maxerrpc = percentage_error;
-            }
-
-            /* Now calculate the digitization limits for
-             * 'encoded_sample' using the 'max' values.  Note that
-             * maxout is in the encoded space but maxpc and maxabs are
-             * in linear light space.
-             *
-             * First find the maximum error in linear light space,
-             * range 0..1:
-             */
-            {
-               double tmp = input_sample * maxpc;
-               if (tmp < maxabs) tmp = maxabs;
-
-               /* Low bound - the minimum of the three: */
-               es_lo = encoded_sample - maxout;
-
-               if (es_lo > 0 && input_sample-tmp > 0)
-               {
-                  double low_value = outmax * pow(input_sample-tmp,
-                     1/screen_gamma);
-                  if (low_value < es_lo) es_lo = low_value;
-               }
-
-               else
-                  es_lo = 0;
-
-               es_hi = encoded_sample + maxout;
-
-               if (es_hi < outmax && input_sample+tmp < 1)
-               {
-                  double high_value = outmax * pow(input_sample+tmp,
-                     1/screen_gamma);
-                  if (high_value > es_hi) es_hi = high_value;
-               }
-
-               else
-                  es_hi = outmax;
-            }
-
-            /* The primary test is that the final encoded value
-             * returned by the library should be between the two limits
-             * (inclusive) that were calculated above.  At this point
-             * quantization of the output must be taken into account.
-             */
-            if (od+.5 < es_lo || od-.5 > es_hi)
-            {
-               /* There has been an error in processing. */
-               double is_lo, is_hi;
-
-               if (use_input_precision)
-               {
-                  /* Ok, something is wrong - this actually happens in
-                   * current libpng sbit processing.  Assume that the
-                   * input value (id, adjusted for sbit) can be
-                   * anywhere between value-.5 and value+.5 - quite a
-                   * large range if sbit is low.
-                   */
-                  double tmp = (isbit - .5)/((1U<<sbit)-1);
-
-                  if (tmp > 0)
-                  {
-                     is_lo = outmax * pow(tmp, gamma_correction) - maxout;
-                     if (is_lo < 0) is_lo = 0;
-                  }
-
-                  else
-                     is_lo = 0;
-
-                  tmp = (isbit + .5)/((1U<<sbit)-1);
-
-                  if (tmp < 1)
-                  {
-                     is_hi = outmax * pow(tmp, gamma_correction) + maxout;
-                     if (is_hi > outmax) is_hi = outmax;
-                  }
-
-                  else
-                     is_hi = outmax;
-
-                  if (!(od+.5 < is_lo || od-.5 > is_hi))
-                     continue;
-               }
-               else
-                  is_lo = es_lo, is_hi = es_hi;
-
-               {
-                  char msg[256];
-
-                  sprintf(msg,
-                   "error: %.3f; %u{%u;%u} -> %u not %.2f (%.1f-%.1f)",
-                     od-encoded_sample, id, sbit, isbit, od,
-                     encoded_sample, is_lo, is_hi);
-
-                  png_warning(pp, msg);
-               }
-            }
-         }
-      }
-
-      else if (!speed && memcmp(std, pRow, cbRow) != 0)
-      {
-         char msg[64];
-
-         /* No transform is expected on the threshold tests. */
-         sprintf(msg, "gamma: below threshold row %d changed", y);
-
-         png_error(pp, msg);
-      }
-   } /* row (y) loop */
-
-   dp->maxerrout = maxerrout;
-   dp->maxerrabs = maxerrabs;
-   dp->maxerrpc = maxerrpc;
-   dp->this.ps->validated = 1;
-}
-
-static void
-gamma_end(png_structp pp, png_infop pi)
-{
-   gamma_display *dp = png_get_progressive_ptr(pp);
-
-   gamma_image_validate(dp, pp, pi, dp->this.ps->image);
-}
-
-/* A single test run checking a gamma transformation.
- *
- * maxabs: maximum absolute error as a fraction
- * maxout: maximum output error in the output units
- * maxpc:  maximum percentage error (as a percentage)
- */
-static void
-gamma_test(png_modifier *pmIn, PNG_CONST png_byte colour_typeIn,
-    PNG_CONST png_byte bit_depthIn, PNG_CONST int interlace_typeIn,
-    PNG_CONST double file_gammaIn, PNG_CONST double screen_gammaIn,
-    PNG_CONST png_byte sbitIn, PNG_CONST int threshold_testIn,
-    PNG_CONST char *name, PNG_CONST int speedIn,
-    PNG_CONST int use_input_precisionIn, PNG_CONST int strip16In)
-{
-   gamma_display d;
-   context(&pmIn->this, fault);
-
-   gamma_display_init(&d, pmIn, FILEID(colour_typeIn, bit_depthIn,
-      interlace_typeIn, 0, 0, 0), file_gammaIn, screen_gammaIn, sbitIn,
-      threshold_testIn, speedIn, use_input_precisionIn, strip16In);
-
-   Try
-   {
-      png_structp pp;
-      png_infop pi;
-      gamma_modification gamma_mod;
-      srgb_modification srgb_mod;
-      sbit_modification sbit_mod;
-
-      /* Make an appropriate modifier to set the PNG file gamma to the
-       * given gamma value and the sBIT chunk to the given precision.
-       */
-      d.pm->modifications = NULL;
-      gamma_modification_init(&gamma_mod, d.pm, d.file_gamma);
-      srgb_modification_init(&srgb_mod, d.pm, 127 /*delete*/);
-      sbit_modification_init(&sbit_mod, d.pm, d.sbit);
-
-      modification_reset(d.pm->modifications);
-
-      /* Get a png_struct for writing the image. */
-      pp = set_modifier_for_read(d.pm, &pi, d.this.id, name);
-
-      /* Set up gamma processing. */
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-      png_set_gamma(pp, d.screen_gamma, d.file_gamma);
-#else
-      {
-         png_fixed_point s = floor(d.screen_gamma*100000+.5);
-         png_fixed_point f = floor(d.file_gamma*100000+.5);
-         png_set_gamma_fixed(pp, s, f);
-      }
-#endif
-
-      /* Introduce the correct read function. */
-      if (d.pm->this.progressive)
-      {
-         /* Share the row function with the standard implementation. */
-         png_set_progressive_read_fn(pp, &d, gamma_info, progressive_row,
-            gamma_end);
-
-         /* Now feed data into the reader until we reach the end: */
-         modifier_progressive_read(d.pm, pp, pi);
-      }
-      else
-      {
-         /* modifier_read expects a png_modifier* */
-         png_set_read_fn(pp, d.pm, modifier_read);
-
-         /* Check the header values: */
-         png_read_info(pp, pi);
-
-         /* Process the 'info' requirements. Only one image is generated */
-         gamma_info_imp(&d, pp, pi);
-
-         sequential_row(&d.this, pp, pi, NULL, d.this.ps->image);
-
-         gamma_image_validate(&d, pp, pi, d.this.ps->image);
-      }
-
-      modifier_reset(d.pm);
-
-      if (d.pm->log && !d.threshold_test && !d.speed)
-         fprintf(stderr, "%d bit %s %s: max error %f (%.2g, %2g%%)\n",
-            d.this.bit_depth, colour_types[d.this.colour_type], d.name,
-            d.maxerrout, d.maxerrabs, 100*d.maxerrpc);
-
-      /* Log the summary values too. */
-      if (d.this.colour_type == 0 || d.this.colour_type == 4)
-      {
-         switch (d.this.bit_depth)
-         {
-         case 1:
-            break;
-
-         case 2:
-            if (d.maxerrout > d.pm->error_gray_2)
-               d.pm->error_gray_2 = d.maxerrout;
-
-            break;
-
-         case 4:
-            if (d.maxerrout > d.pm->error_gray_4)
-               d.pm->error_gray_4 = d.maxerrout;
-
-            break;
-
-         case 8:
-            if (d.maxerrout > d.pm->error_gray_8)
-               d.pm->error_gray_8 = d.maxerrout;
-
-            break;
-
-         case 16:
-            if (d.maxerrout > d.pm->error_gray_16)
-               d.pm->error_gray_16 = d.maxerrout;
-
-            break;
-
-         default:
-            png_error(pp, "bad bit depth (internal: 1)");
-         }
-      }
-
-      else if (d.this.colour_type == 2 || d.this.colour_type == 6)
-      {
-         switch (d.this.bit_depth)
-         {
-         case 8:
-
-            if (d.maxerrout > d.pm->error_color_8)
-               d.pm->error_color_8 = d.maxerrout;
-
-            break;
-
-         case 16:
-
-            if (d.maxerrout > d.pm->error_color_16)
-               d.pm->error_color_16 = d.maxerrout;
-
-            break;
-
-         default:
-            png_error(pp, "bad bit depth (internal: 2)");
-         }
-      }
-   }
-
-   Catch(fault)
-      modifier_reset((png_modifier*)fault);
-}
-
-static void gamma_threshold_test(png_modifier *pm, png_byte colour_type,
-    png_byte bit_depth, int interlace_type, double file_gamma,
-    double screen_gamma)
-{
-   size_t pos = 0;
-   char name[64];
-   pos = safecat(name, sizeof name, pos, "threshold ");
-   pos = safecatd(name, sizeof name, pos, file_gamma, 3);
-   pos = safecat(name, sizeof name, pos, "/");
-   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);
-
-   (void)gamma_test(pm, colour_type, bit_depth, interlace_type, file_gamma,
-      screen_gamma, bit_depth, 1, name, 0 /*speed*/, 0 /*no input precision*/,
-      0 /*no strip16*/);
-}
-
-static void
-perform_gamma_threshold_tests(png_modifier *pm)
-{
-   png_byte colour_type = 0;
-   png_byte bit_depth = 0;
-
-   while (next_format(&colour_type, &bit_depth))
-   {
-      double test_gamma = 1.0;
-      while (test_gamma >= .4)
-      {
-         /* There's little point testing the interlacing vs non-interlacing,
-          * but this can be set from the command line.
-          */
-         gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,
-            test_gamma, 1/test_gamma);
-         test_gamma *= .95;
-      }
-
-      /* And a special test for sRGB */
-      gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,
-          .45455, 2.2);
-
-      if (fail(pm))
-         return;
-   }
-}
-
-static void gamma_transform_test(png_modifier *pm,
-   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,
-   PNG_CONST int interlace_type, PNG_CONST double file_gamma,
-   PNG_CONST double screen_gamma, PNG_CONST png_byte sbit, PNG_CONST int speed,
-   PNG_CONST int use_input_precision, PNG_CONST int strip16)
-{
-   size_t pos = 0;
-   char name[64];
-
-   if (sbit != bit_depth)
-   {
-      pos = safecat(name, sizeof name, pos, "sbit(");
-      pos = safecatn(name, sizeof name, pos, sbit);
-      pos = safecat(name, sizeof name, pos, ") ");
-   }
-
-   else
-      pos = safecat(name, sizeof name, pos, "gamma ");
-
-   if (strip16)
-      pos = safecat(name, sizeof name, pos, "16to8 ");
-
-   pos = safecatd(name, sizeof name, pos, file_gamma, 3);
-   pos = safecat(name, sizeof name, pos, "->");
-   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);
-
-   gamma_test(pm, colour_type, bit_depth, interlace_type, file_gamma,
-      screen_gamma, sbit, 0, name, speed, use_input_precision, strip16);
-}
-
-static void perform_gamma_transform_tests(png_modifier *pm, int speed)
-{
-   png_byte colour_type = 0;
-   png_byte bit_depth = 0;
-
-   /* Ignore palette images - the gamma correction happens on the palette entry,
-    * haven't got the tests for this yet.
-    */
-   while (next_format(&colour_type, &bit_depth)) if (colour_type != 3)
-   {
-      unsigned int i, j;
-
-      for (i=0; i<pm->ngammas; ++i) for (j=0; j<pm->ngammas; ++j) if (i != j)
-      {
-         gamma_transform_test(pm, colour_type, bit_depth, pm->interlace_type,
-            1/pm->gammas[i], pm->gammas[j], bit_depth, speed,
-            pm->use_input_precision, 0 /*do not strip16*/);
-
-         if (fail(pm))
-            return;
-      }
-   }
-}
-
-static void perform_gamma_sbit_tests(png_modifier *pm, int speed)
-{
-   png_byte sbit;
-
-   /* The only interesting cases are colour and grayscale, alpha is ignored here
-    * for overall speed.  Only bit depths 8 and 16 are tested.
-    */
-   for (sbit=pm->sbitlow; sbit<(1<<READ_BDHI); ++sbit)
-   {
-      unsigned int i, j;
-
-      for (i=0; i<pm->ngammas; ++i)
-      {
-         for (j=0; j<pm->ngammas; ++j)
-         {
-            if (i != j)
-            {
-               if (sbit < 8)
-               {
-                  gamma_transform_test(pm, 0, 8, pm->interlace_type,
-                      1/pm->gammas[i], pm->gammas[j], sbit, speed,
-                      pm->use_input_precision_sbit, 0 /*strip16*/);
-
-                  if (fail(pm))
-                     return;
-
-                  gamma_transform_test(pm, 2, 8, pm->interlace_type,
-                      1/pm->gammas[i], pm->gammas[j], sbit, speed,
-                      pm->use_input_precision_sbit, 0 /*strip16*/);
-
-                  if (fail(pm))
-                     return;
-               }
-
-#ifdef DO_16BIT
-               gamma_transform_test(pm, 0, 16, pm->interlace_type,
-                   1/pm->gammas[i], pm->gammas[j], sbit, speed,
-                   pm->use_input_precision_sbit, 0 /*strip16*/);
-
-               if (fail(pm))
-                  return;
-
-               gamma_transform_test(pm, 2, 16, pm->interlace_type,
-                   1/pm->gammas[i], pm->gammas[j], sbit, speed,
-                   pm->use_input_precision_sbit, 0 /*strip16*/);
-
-               if (fail(pm))
-                  return;
-#endif
-            }
-         }
-      }
-   }
-}
-
-/* Note that this requires a 16 bit source image but produces 8 bit output, so
- * we only need the 16bit write support.
- */
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-static void perform_gamma_strip16_tests(png_modifier *pm, int speed)
-{
-#  ifndef PNG_MAX_GAMMA_8
-#     define PNG_MAX_GAMMA_8 11
-#  endif
-   /* Include the alpha cases here. Note that sbit matches the internal value
-    * used by the library - otherwise we will get spurious errors from the
-    * internal sbit style approximation.
-    *
-    * The threshold test is here because otherwise the 16 to 8 conversion will
-    * proceed *without* gamma correction, and the tests above will fail (but not
-    * by much) - this could be fixed, it only appears with the -g option.
-    */
-   unsigned int i, j;
-   for (i=0; i<pm->ngammas; ++i)
-   {
-      for (j=0; j<pm->ngammas; ++j)
-      {
-         if (i != j &&
-             fabs(pm->gammas[j]/pm->gammas[i]-1) >= PNG_GAMMA_THRESHOLD)
-         {
-            gamma_transform_test(pm, 0, 16, pm->interlace_type, 1/pm->gammas[i],
-                pm->gammas[j], PNG_MAX_GAMMA_8, speed,
-                pm->use_input_precision_16to8, 1 /*strip16*/);
-
-            if (fail(pm))
-               return;
-
-            gamma_transform_test(pm, 2, 16, pm->interlace_type, 1/pm->gammas[i],
-                pm->gammas[j], PNG_MAX_GAMMA_8, speed,
-                pm->use_input_precision_16to8, 1 /*strip16*/);
-
-            if (fail(pm))
-               return;
-
-            gamma_transform_test(pm, 4, 16, pm->interlace_type, 1/pm->gammas[i],
-                pm->gammas[j], PNG_MAX_GAMMA_8, speed,
-                pm->use_input_precision_16to8, 1 /*strip16*/);
-
-            if (fail(pm))
-               return;
-
-            gamma_transform_test(pm, 6, 16, pm->interlace_type, 1/pm->gammas[i],
-                pm->gammas[j], PNG_MAX_GAMMA_8, speed,
-                pm->use_input_precision_16to8, 1 /*strip16*/);
-
-            if (fail(pm))
-               return;
-         }
-      }
-   }
-}
-#endif /* 16 to 8 bit conversion */
-
-static void
-perform_gamma_test(png_modifier *pm, int speed, int summary)
-{
-   /* First some arbitrary no-transform tests: */
-   if (!speed && pm->test_gamma_threshold)
-   {
-      perform_gamma_threshold_tests(pm);
-
-      if (fail(pm))
-         return;
-   }
-
-   /* Now some real transforms. */
-   if (pm->test_gamma_transform)
-   {
-      perform_gamma_transform_tests(pm, speed);
-
-      if (summary)
-      {
-         printf("Gamma correction error summary\n\n");
-         printf("The printed value is the maximum error in the pixel values\n");
-         printf("calculated by the libpng gamma correction code.  The error\n");
-         printf("is calculated as the difference between the output pixel\n");
-         printf("value (always an integer) and the ideal value from the\n");
-         printf("libpng specification (typically not an integer).\n\n");
-
-         printf("Expect this value to be less than .5 for 8 bit formats,\n");
-         printf("less than 1 for formats with fewer than 8 bits and a small\n");
-         printf("number (typically less than 5) for the 16 bit formats.\n");
-         printf("For performance reasons the value for 16 bit formats\n");
-         printf("increases when the image file includes an sBIT chunk.\n\n");
-
-         printf("  2 bit gray:  %.5f\n", pm->error_gray_2);
-         printf("  4 bit gray:  %.5f\n", pm->error_gray_4);
-         printf("  8 bit gray:  %.5f\n", pm->error_gray_8);
-         printf("  8 bit color: %.5f\n", pm->error_color_8);
-#ifdef DO_16BIT
-         printf(" 16 bit gray:  %.5f\n", pm->error_gray_16);
-         printf(" 16 bit color: %.5f\n", pm->error_color_16);
-#endif
-      }
-   }
-
-   /* The sbit tests produce much larger errors: */
-   if (pm->test_gamma_sbit)
-   {
-      pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 =
-      pm->error_gray_16 = pm->error_color_8 = pm->error_color_16 = 0;
-      perform_gamma_sbit_tests(pm, speed);
-
-      if (summary)
-      {
-         printf("Gamma correction with sBIT:\n");
-
-         if (pm->sbitlow < 8U)
-         {
-            printf("  2 bit gray:  %.5f\n", pm->error_gray_2);
-            printf("  4 bit gray:  %.5f\n", pm->error_gray_4);
-            printf("  8 bit gray:  %.5f\n", pm->error_gray_8);
-            printf("  8 bit color: %.5f\n", pm->error_color_8);
-         }
-
-   #ifdef DO_16BIT
-         printf(" 16 bit gray:  %.5f\n", pm->error_gray_16);
-         printf(" 16 bit color: %.5f\n", pm->error_color_16);
-   #endif
-      }
-   }
-
-#ifdef PNG_READ_16_TO_8_SUPPORTED
-   if (pm->test_gamma_strip16)
-   {
-      /* The 16 to 8 bit strip operations: */
-      pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 =
-      pm->error_gray_16 = pm->error_color_8 = pm->error_color_16 = 0;
-      perform_gamma_strip16_tests(pm, speed);
-
-      if (summary)
-      {
-         printf("Gamma correction with 16 to 8 bit reduction:\n");
-         printf(" 16 bit gray:  %.5f\n", pm->error_gray_16);
-         printf(" 16 bit color: %.5f\n", pm->error_color_16);
-      }
-   }
-#endif
-}
-
-/* INTERLACE MACRO VALIDATION */
-/* This is copied verbatim from the specification, it is simply the pass
- * number in which each pixel in each 8x8 tile appears.  The array must
- * be indexed adam7[y][x] and notice that the pass numbers are based at
- * 1, not 0 - the base libpng uses.
- */
-static PNG_CONST
-png_byte adam7[8][8] =
-{
-   { 1,6,4,6,2,6,4,6 },
-   { 7,7,7,7,7,7,7,7 },
-   { 5,6,5,6,5,6,5,6 },
-   { 7,7,7,7,7,7,7,7 },
-   { 3,6,4,6,3,6,4,6 },
-   { 7,7,7,7,7,7,7,7 },
-   { 5,6,5,6,5,6,5,6 },
-   { 7,7,7,7,7,7,7,7 }
-};
-
-/* This routine validates all the interlace support macros in png.h for
- * a variety of valid PNG widths and heights.  It uses a number of similarly
- * named internal routines that feed off the above array.
- */
-static png_uint_32
-png_pass_start_row(int pass)
-{
-   int x, y;
-   ++pass;
-   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)
-      return y;
-   return 0xf;
-}
-
-static png_uint_32
-png_pass_start_col(int pass)
-{
-   int x, y;
-   ++pass;
-   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
-      return x;
-   return 0xf;
-}
-
-static int
-png_pass_row_shift(int pass)
-{
-   int x, y, base=(-1), inc=8;
-   ++pass;
-   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)
-   {
-      if (base == (-1))
-         base = y;
-      else if (base == y)
-         {}
-      else if (inc == y-base)
-         base=y;
-      else if (inc == 8)
-         inc = y-base, base=y;
-      else if (inc != y-base)
-         return 0xff; /* error - more than one 'inc' value! */
-   }
-
-   if (base == (-1)) return 0xfe; /* error - no row in pass! */
-
-   /* The shift is always 1, 2 or 3 - no pass has all the rows! */
-   switch (inc)
-   {
-case 2: return 1;
-case 4: return 2;
-case 8: return 3;
-default: break;
-   }
-
-   /* error - unrecognized 'inc' */
-   return (inc << 8) + 0xfd;
-}
-
-static int
-png_pass_col_shift(int pass)
-{
-   int x, y, base=(-1), inc=8;
-   ++pass;
-   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
-   {
-      if (base == (-1))
-         base = x;
-      else if (base == x)
-         {}
-      else if (inc == x-base)
-         base=x;
-      else if (inc == 8)
-         inc = x-base, base=x;
-      else if (inc != x-base)
-         return 0xff; /* error - more than one 'inc' value! */
-   }
-
-   if (base == (-1)) return 0xfe; /* error - no row in pass! */
-
-   /* The shift is always 1, 2 or 3 - no pass has all the rows! */
-   switch (inc)
-   {
-case 1: return 0; /* pass 7 has all the columns */
-case 2: return 1;
-case 4: return 2;
-case 8: return 3;
-default: break;
-   }
-
-   /* error - unrecognized 'inc' */
-   return (inc << 8) + 0xfd;
-}
-
-static png_uint_32
-png_row_from_pass_row(png_uint_32 yIn, int pass)
-{
-   /* By examination of the array: */
-   switch (pass)
-   {
-case 0: return yIn * 8;
-case 1: return yIn * 8;
-case 2: return yIn * 8 + 4;
-case 3: return yIn * 4;
-case 4: return yIn * 4 + 2;
-case 5: return yIn * 2;
-case 6: return yIn * 2 + 1;
-default: break;
-   }
-
-   return 0xff; /* bad pass number */
-}
-
-static png_uint_32
-png_col_from_pass_col(png_uint_32 xIn, int pass)
-{
-   /* By examination of the array: */
-   switch (pass)
-   {
-case 0: return xIn * 8;
-case 1: return xIn * 8 + 4;
-case 2: return xIn * 4;
-case 3: return xIn * 4 + 2;
-case 4: return xIn * 2;
-case 5: return xIn * 2 + 1;
-case 6: return xIn;
-default: break;
-   }
-
-   return 0xff; /* bad pass number */
-}
-
-static int
-png_row_in_interlace_pass(png_uint_32 y, int pass)
-{
-   /* Is row 'y' in pass 'pass'? */
-   int x;
-   y &= 7;
-   ++pass;
-   for (x=0; x<8; ++x) if (adam7[y][x] == pass)
-      return 1;
-
-   return 0;
-}
-
-static int
-png_col_in_interlace_pass(png_uint_32 x, int pass)
-{
-   /* Is column 'x' in pass 'pass'? */
-   int y;
-   x &= 7;
-   ++pass;
-   for (y=0; y<8; ++y) if (adam7[y][x] == pass)
-      return 1;
-
-   return 0;
-}
-
-static png_uint_32
-png_pass_rows(png_uint_32 height, int pass)
-{
-   png_uint_32 tiles = height>>3;
-   png_uint_32 rows = 0;
-   unsigned int x, y;
-
-   height &= 7;
-   ++pass;
-   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)
-   {
-      rows += tiles;
-      if (y < height) ++rows;
-      break; /* i.e. break the 'x', column, loop. */
-   }
-
-   return rows;
-}
-
-static png_uint_32
-png_pass_cols(png_uint_32 width, int pass)
-{
-   png_uint_32 tiles = width>>3;
-   png_uint_32 cols = 0;
-   unsigned int x, y;
-
-   width &= 7;
-   ++pass;
-   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
-   {
-      cols += tiles;
-      if (x < width) ++cols;
-      break; /* i.e. break the 'y', row, loop. */
-   }
-
-   return cols;
-}
-
-static void
-perform_interlace_macro_validation(void)
-{
-   /* The macros to validate, first those that depend only on pass:
-    *
-    * PNG_PASS_START_ROW(pass)
-    * PNG_PASS_START_COL(pass)
-    * PNG_PASS_ROW_SHIFT(pass)
-    * PNG_PASS_COL_SHIFT(pass)
-    */
-   int pass;
-
-   for (pass=0; pass<7; ++pass)
-   {
-      png_uint_32 m, f, v;
-
-      m = PNG_PASS_START_ROW(pass);
-      f = png_pass_start_row(pass);
-      if (m != f)
-      {
-         fprintf(stderr, "PNG_PASS_START_ROW(%d) = %u != %x\n", pass, m, f);
-         exit(1);
-      }
-
-      m = PNG_PASS_START_COL(pass);
-      f = png_pass_start_col(pass);
-      if (m != f)
-      {
-         fprintf(stderr, "PNG_PASS_START_COL(%d) = %u != %x\n", pass, m, f);
-         exit(1);
-      }
-
-      m = PNG_PASS_ROW_SHIFT(pass);
-      f = png_pass_row_shift(pass);
-      if (m != f)
-      {
-         fprintf(stderr, "PNG_PASS_ROW_SHIFT(%d) = %u != %x\n", pass, m, f);
-         exit(1);
-      }
-
-      m = PNG_PASS_COL_SHIFT(pass);
-      f = png_pass_col_shift(pass);
-      if (m != f)
-      {
-         fprintf(stderr, "PNG_PASS_COL_SHIFT(%d) = %u != %x\n", pass, m, f);
-         exit(1);
-      }
-
-      /* Macros that depend on the image or sub-image height too:
-       *
-       * PNG_PASS_ROWS(height, pass)
-       * PNG_PASS_COLS(width, pass)
-       * PNG_ROW_FROM_PASS_ROW(yIn, pass)
-       * PNG_COL_FROM_PASS_COL(xIn, pass)
-       * PNG_ROW_IN_INTERLACE_PASS(y, pass)
-       * PNG_COL_IN_INTERLACE_PASS(x, pass)
-       */
-      for (v=0;;)
-      {
-         /* First the base 0 stuff: */
-         m = PNG_ROW_FROM_PASS_ROW(v, pass);
-         f = png_row_from_pass_row(v, pass);
-         if (m != f)
-         {
-            fprintf(stderr, "PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\n",
-               v, pass, m, f);
-            exit(1);
-         }
-
-         m = PNG_COL_FROM_PASS_COL(v, pass);
-         f = png_col_from_pass_col(v, pass);
-         if (m != f)
-         {
-            fprintf(stderr, "PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\n",
-               v, pass, m, f);
-            exit(1);
-         }
-
-         m = PNG_ROW_IN_INTERLACE_PASS(v, pass);
-         f = png_row_in_interlace_pass(v, pass);
-         if (m != f)
-         {
-            fprintf(stderr, "PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\n",
-               v, pass, m, f);
-            exit(1);
-         }
-
-         m = PNG_COL_IN_INTERLACE_PASS(v, pass);
-         f = png_col_in_interlace_pass(v, pass);
-         if (m != f)
-         {
-            fprintf(stderr, "PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\n",
-               v, pass, m, f);
-            exit(1);
-         }
-
-         /* Then the base 1 stuff: */
-         ++v;
-         m = PNG_PASS_ROWS(v, pass);
-         f = png_pass_rows(v, pass);
-         if (m != f)
-         {
-            fprintf(stderr, "PNG_PASS_ROWS(%u, %d) = %u != %x\n",
-               v, pass, m, f);
-            exit(1);
-         }
-
-         m = PNG_PASS_COLS(v, pass);
-         f = png_pass_cols(v, pass);
-         if (m != f)
-         {
-            fprintf(stderr, "PNG_PASS_COLS(%u, %d) = %u != %x\n",
-               v, pass, m, f);
-            exit(1);
-         }
-
-         /* Move to the next v - the stepping algorithm starts skipping
-          * values above 1024.
-          */
-         if (v > 1024)
-         {
-            if (v == PNG_UINT_31_MAX)
-               break;
-
-            v = (v << 1) ^ v;
-            if (v >= PNG_UINT_31_MAX)
-               v = PNG_UINT_31_MAX-1;
-         }
-      }
-   }
-}
-
-/* main program */
-int main(int argc, PNG_CONST char **argv)
-{
-   volatile int summary = 1;  /* Print the error summary at the end */
-
-   /* Create the given output file on success: */
-   PNG_CONST char *volatile touch = NULL;
-
-   /* This is an array of standard gamma values (believe it or not I've seen
-    * every one of these mentioned somewhere.)
-    *
-    * In the following list the most useful values are first!
-    */
-   static double
-      gammas[]={2.2, 1.0, 2.2/1.45, 1.8, 1.5, 2.4, 2.5, 2.62, 2.9};
-
-   png_modifier pm;
-   context(&pm.this, fault);
-
-   modifier_init(&pm);
-
-   /* Preallocate the image buffer, because we know how big it needs to be,
-    * note that, for testing purposes, it is deliberately mis-aligned.
-    */
-   pm.this.image = malloc(2*TRANSFORM_IMAGEMAX+1);
-
-   if (pm.this.image != NULL)
-   {
-      /* Ignore OOM at this point - the 'ensure' routine above will allocate
-       * the array appropriately.
-       */
-      ++(pm.this.image);
-      pm.this.cb_image = 2*TRANSFORM_IMAGEMAX;
-   }
-
-   /* Default to error on warning: */
-   pm.this.treat_warnings_as_errors = 1;
-
-   /* Store the test gammas */
-   pm.gammas = gammas;
-   pm.ngammas = 0; /* default to off */
-   pm.sbitlow = 8U; /* because libpng doesn't do sBIT below 8! */
-   pm.use_input_precision_16to8 = 1U; /* Because of the way libpng does it */
-
-   /* Some default values (set the behavior for 'make check' here).
-    * These values simply control the maximum error permitted in the gamma
-    * transformations.  The practial limits for human perception are described
-    * below (the setting for maxpc16), however for 8 bit encodings it isn't
-    * possible to meet the accepted capabilities of human vision - i.e. 8 bit
-    * images can never be good enough, regardless of encoding.
-    */
-   pm.maxout8 = .1;     /* Arithmetic error in *encoded* value */
-   pm.maxabs8 = .00005; /* 1/20000 */
-   pm.maxpc8 = .499;    /* I.e., .499% fractional error */
-   pm.maxout16 = .499;  /* Error in *encoded* value */
-   pm.maxabs16 = .00005;/* 1/20000 */
-
-   /* NOTE: this is a reasonable perceptual limit. We assume that humans can
-    * perceive light level differences of 1% over a 100:1 range, so we need to
-    * maintain 1 in 10000 accuracy (in linear light space), which is what the
-    * following guarantees.  It also allows significantly higher errors at
-    * higher 16 bit values, which is important for performance.  The actual
-    * maximum 16 bit error is about +/-1.9 in the fixed point implementation but
-    * this is only allowed for values >38149 by the following:
-    */
-   pm.maxpc16 = .005;   /* I.e., 1/200% - 1/20000 */
-
-   /* Now parse the command line options. */
-   while (--argc >= 1)
-   {
-      if (strcmp(*++argv, "-v") == 0)
-         pm.this.verbose = 1;
-
-      else if (strcmp(*argv, "-l") == 0)
-         pm.log = 1;
-
-      else if (strcmp(*argv, "-q") == 0)
-         summary = pm.this.verbose = pm.log = 0;
-
-      else if (strcmp(*argv, "-w") == 0)
-         pm.this.treat_warnings_as_errors = 0;
-
-      else if (strcmp(*argv, "--speed") == 0)
-         pm.this.speed = 1, pm.ngammas = (sizeof gammas)/(sizeof gammas[0]),
-            pm.test_standard = 0;
-
-      else if (strcmp(*argv, "--size") == 0)
-         pm.test_size = 1;
-
-      else if (strcmp(*argv, "--nosize") == 0)
-         pm.test_size = 0;
-
-      else if (strcmp(*argv, "--standard") == 0)
-         pm.test_standard = 1;
-
-      else if (strcmp(*argv, "--nostandard") == 0)
-         pm.test_standard = 0;
-
-      else if (strcmp(*argv, "--transform") == 0)
-         pm.test_transform = 1;
-
-      else if (strcmp(*argv, "--notransform") == 0)
-         pm.test_transform = 0;
-
-      else if (strncmp(*argv, "--transform-disable=",
-         sizeof "--transform-disable") == 0)
-         {
-         pm.test_transform = 1;
-         transform_disable(*argv + sizeof "--transform-disable");
-         }
-
-      else if (strncmp(*argv, "--transform-enable=",
-         sizeof "--transform-enable") == 0)
-         {
-         pm.test_transform = 1;
-         transform_enable(*argv + sizeof "--transform-enable");
-         }
-
-      else if (strcmp(*argv, "--gamma") == 0)
-         {
-         /* Just do two gamma tests here (2.2 and linear) for speed: */
-         pm.ngammas = 2U;
-         pm.test_gamma_threshold = 1;
-         pm.test_gamma_transform = 1;
-         pm.test_gamma_sbit = 1;
-         pm.test_gamma_strip16 = 1;
-         }
-
-      else if (strcmp(*argv, "--nogamma") == 0)
-         pm.ngammas = 0;
-
-      else if (strcmp(*argv, "--gamma-threshold") == 0)
-         pm.ngammas = 2U, pm.test_gamma_threshold = 1;
-
-      else if (strcmp(*argv, "--nogamma-threshold") == 0)
-         pm.test_gamma_threshold = 0;
-
-      else if (strcmp(*argv, "--gamma-transform") == 0)
-         pm.ngammas = 2U, pm.test_gamma_transform = 1;
-
-      else if (strcmp(*argv, "--nogamma-transform") == 0)
-         pm.test_gamma_transform = 0;
-
-      else if (strcmp(*argv, "--gamma-sbit") == 0)
-         pm.ngammas = 2U, pm.test_gamma_sbit = 1;
-
-      else if (strcmp(*argv, "--nogamma-sbit") == 0)
-         pm.test_gamma_sbit = 0;
-
-      else if (strcmp(*argv, "--gamma-16-to-8") == 0)
-         pm.ngammas = 2U, pm.test_gamma_strip16 = 1;
-
-      else if (strcmp(*argv, "--nogamma-16-to-8") == 0)
-         pm.test_gamma_strip16 = 0;
-
-      else if (strcmp(*argv, "--all-gammas") == 0)
-         pm.ngammas = (sizeof gammas)/(sizeof gammas[0]);
-
-      else if (strcmp(*argv, "--progressive-read") == 0)
-         pm.this.progressive = 1;
-
-      else if (strcmp(*argv, "--interlace") == 0)
-         pm.interlace_type = PNG_INTERLACE_ADAM7;
-
-      else if (argc >= 1 && strcmp(*argv, "--sbitlow") == 0)
-         --argc, pm.sbitlow = (png_byte)atoi(*++argv);
-
-      else if (argc >= 1 && strcmp(*argv, "--touch") == 0)
-         --argc, touch = *++argv;
-
-      else if (argc >= 1 && strncmp(*argv, "--max", 4) == 0)
-      {
-         --argc;
-
-         if (strcmp(4+*argv, "abs8") == 0)
-            pm.maxabs8 = atof(*++argv);
-
-         else if (strcmp(4+*argv, "abs16") == 0)
-            pm.maxabs16 = atof(*++argv);
-
-         else if (strcmp(4+*argv, "out8") == 0)
-            pm.maxout8 = atof(*++argv);
-
-         else if (strcmp(4+*argv, "out16") == 0)
-            pm.maxout16 = atof(*++argv);
-
-         else if (strcmp(4+*argv, "pc8") == 0)
-            pm.maxpc8 = atof(*++argv);
-
-         else if (strcmp(4+*argv, "pc16") == 0)
-            pm.maxpc16 = atof(*++argv);
-
-         else
-         {
-            fprintf(stderr, "pngvalid: %s: unknown 'max' option\n", *argv);
-            exit(1);
-         }
-      }
-
-      else
-      {
-         fprintf(stderr, "pngvalid: %s: unknown argument\n", *argv);
-         exit(1);
-      }
-   }
-
-   /* If pngvalid is run with no arguments default to a reasonable set of the
-    * tests.
-    */
-   if (pm.test_standard == 0 && pm.test_size == 0 && pm.test_transform == 0 &&
-      pm.ngammas == 0)
-   {
-      pm.test_standard = 1;
-      pm.test_size = 1;
-      pm.test_transform = 1;
-      pm.ngammas = 3U;
-   }
-
-   if (pm.ngammas > 0 &&
-      pm.test_gamma_threshold == 0 && pm.test_gamma_transform == 0 &&
-      pm.test_gamma_sbit == 0 && pm.test_gamma_strip16 == 0)
-   {
-      pm.test_gamma_threshold = 1;
-      pm.test_gamma_transform = 1;
-      pm.test_gamma_sbit = 1;
-      pm.test_gamma_strip16 = 1;
-   }
-   
-   else if (pm.ngammas == 0)
-   {
-      /* Nothing to test so turn everything off: */
-      pm.test_gamma_threshold = 0;
-      pm.test_gamma_transform = 0;
-      pm.test_gamma_sbit = 0;
-      pm.test_gamma_strip16 = 0;
-   }
-
-   Try
-   {
-      /* Make useful base images */
-      make_transform_images(&pm.this);
-
-      /* Perform the standard and gamma tests. */
-      if (pm.test_standard)
-      {
-         perform_interlace_macro_validation();
-         perform_standard_test(&pm);
-         perform_error_test(&pm);
-      }
-
-      /* Various oddly sized images: */
-      if (pm.test_size)
-      {
-         make_size_images(&pm.this);
-         perform_size_test(&pm);
-      }
-
-      /* Combinatorial transforms: */
-      if (pm.test_transform)
-         perform_transform_test(&pm);
-
-      if (pm.ngammas > 0)
-         perform_gamma_test(&pm, pm.this.speed != 0,
-            summary && !pm.this.speed);
-   }
-
-   Catch(fault)
-   {
-      fprintf(stderr, "pngvalid: test aborted (probably failed in cleanup)\n");
-      if (!pm.this.verbose)
-      {
-         if (pm.this.error[0] != 0)
-            fprintf(stderr, "pngvalid: first error: %s\n", pm.this.error);
-
-         fprintf(stderr, "pngvalid: run with -v to see what happened\n");
-      }
-      exit(1);
-   }
-
-   if (summary && !pm.this.speed)
-   {
-      printf("Results using %s point arithmetic %s\n",
-#if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || PNG_LIBPNG_VER < 10500
-         "floating",
-#else
-         "fixed",
-#endif
-         (pm.this.nerrors || (pm.this.treat_warnings_as_errors &&
-            pm.this.nwarnings)) ? "(errors)" : (pm.this.nwarnings ?
-               "(warnings)" : "(no errors or warnings)")
-      );
-      printf("Allocated memory statistics (in bytes):\n"
-         "\tread  %lu maximum single, %lu peak, %lu total\n"
-         "\twrite %lu maximum single, %lu peak, %lu total\n",
-         (unsigned long)pm.this.read_memory_pool.max_max,
-         (unsigned long)pm.this.read_memory_pool.max_limit,
-         (unsigned long)pm.this.read_memory_pool.max_total,
-         (unsigned long)pm.this.write_memory_pool.max_max,
-         (unsigned long)pm.this.write_memory_pool.max_limit,
-         (unsigned long)pm.this.write_memory_pool.max_total);
-   }
-
-   /* Do this here to provoke memory corruption errors in memory not directly
-    * allocated by libpng - not a complete test, but better than nothing.
-    */
-   store_delete(&pm.this);
-
-   /* Error exit if there are any errors, and maybe if there are any
-    * warnings.
-    */
-   if (pm.this.nerrors || (pm.this.treat_warnings_as_errors &&
-       pm.this.nwarnings))
-   {
-      if (!pm.this.verbose)
-         fprintf(stderr, "pngvalid: %s\n", pm.this.error);
-
-      fprintf(stderr, "pngvalid: %d errors, %d warnings\n", pm.this.nerrors,
-          pm.this.nwarnings);
-
-      exit(1);
-   }
-
-   /* Success case. */
-   if (touch != NULL)
-   {
-      FILE *fsuccess = fopen(touch, "wt");
-
-      if (fsuccess != NULL)
-      {
-         int error = 0;
-         fprintf(fsuccess, "PNG validation succeeded\n");
-         fflush(fsuccess);
-         error = ferror(fsuccess);
-
-         if (fclose(fsuccess) || error)
-         {
-            fprintf(stderr, "%s: write failed\n", touch);
-            exit(1);
-         }
-      }
-   }
-
-   return 0;
-}
diff --git a/src/3rdparty/libpng/pngwrite.c b/src/3rdparty/libpng/pngwrite.c
index d90f449..b587f1b 100644
--- a/src/3rdparty/libpng/pngwrite.c
+++ b/src/3rdparty/libpng/pngwrite.c
@@ -1,8 +1,8 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.5.1 [February 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -99,8 +99,10 @@ png_write_info_before_PLTE(png_structp png_ptr, png_infop info_ptr)
          int keep = png_handle_as_unknown(png_ptr, up->name);
 
          if (keep != PNG_HANDLE_CHUNK_NEVER &&
-             up->location && !(up->location & PNG_HAVE_PLTE) &&
+             up->location &&
+             !(up->location & PNG_HAVE_PLTE) &&
              !(up->location & PNG_HAVE_IDAT) &&
+             !(up->location & PNG_AFTER_IDAT) &&
              ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
              (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
          {
@@ -273,8 +275,10 @@ png_write_info(png_structp png_ptr, png_infop info_ptr)
       {
          int keep = png_handle_as_unknown(png_ptr, up->name);
          if (keep != PNG_HANDLE_CHUNK_NEVER &&
-             up->location && (up->location & PNG_HAVE_PLTE) &&
+             up->location &&
+             (up->location & PNG_HAVE_PLTE) &&
              !(up->location & PNG_HAVE_IDAT) &&
+             !(up->location & PNG_AFTER_IDAT) &&
              ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
              (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
          {
@@ -301,6 +305,11 @@ png_write_end(png_structp png_ptr, png_infop info_ptr)
    if (!(png_ptr->mode & PNG_HAVE_IDAT))
       png_error(png_ptr, "No IDATs written into file");
 
+#ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   if (png_ptr->num_palette_max > png_ptr->num_palette)
+      png_benign_error(png_ptr, "Wrote palette index exceeding num_palette");
+#endif
+
    /* See if user wants us to write information chunks */
    if (info_ptr != NULL)
    {
@@ -380,7 +389,8 @@ png_write_end(png_structp png_ptr, png_infop info_ptr)
       {
          int keep = png_handle_as_unknown(png_ptr, up->name);
          if (keep != PNG_HANDLE_CHUNK_NEVER &&
-             up->location && (up->location & PNG_AFTER_IDAT) &&
+             up->location &&
+             (up->location & PNG_AFTER_IDAT) &&
              ((up->name[3] & 0x20) || keep == PNG_HANDLE_CHUNK_ALWAYS ||
              (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
          {
@@ -462,10 +472,9 @@ png_create_write_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_structp png_ptr;
 #ifdef PNG_SETJMP_SUPPORTED
 #ifdef USE_FAR_KEYWORD
-   jmp_buf png_jmpbuf;
+   jmp_buf tmp_jmpbuf;
 #endif
 #endif
-   int i;
 
    png_debug(1, "in png_create_write_struct");
 
@@ -486,15 +495,16 @@ png_create_write_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
 
 #ifdef PNG_SETJMP_SUPPORTED
 /* Applications that neglect to set up their own setjmp() and then
-   encounter a png_error() will longjmp here.  Since the jmpbuf is
-   then meaningless we abort instead of returning. */
+ * encounter a png_error() will longjmp here.  Since the jmpbuf is
+ * then meaningless we abort instead of returning.
+ */
 #ifdef USE_FAR_KEYWORD
-   if (setjmp(png_jmpbuf))
+   if (setjmp(tmp_jmpbuf))
 #else
    if (setjmp(png_jmpbuf(png_ptr))) /* sets longjmp to match setjmp */
 #endif
 #ifdef USE_FAR_KEYWORD
-   png_memcpy(png_jmpbuf(png_ptr), png_jmpbuf, png_sizeof(jmp_buf));
+   png_memcpy(png_jmpbuf(png_ptr), tmp_jmpbuf, png_sizeof(jmp_buf));
 #endif
       PNG_ABORT();
 #endif
@@ -504,49 +514,8 @@ png_create_write_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
 #endif /* PNG_USER_MEM_SUPPORTED */
    png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);
 
-   if (user_png_ver)
-   {
-      i = 0;
-      do
-      {
-         if (user_png_ver[i] != png_libpng_ver[i])
-            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-      } while (png_libpng_ver[i++]);
-   }
-
-   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
-   {
-     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
-      * we must recompile any applications that use any older library version.
-      * For versions after libpng 1.0, we will be compatible, so we need
-      * only check the first digit.
-      */
-     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
-         (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
-         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
-     {
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-        char msg[80];
-
-        if (user_png_ver)
-        {
-            png_snprintf2(msg, 80,
-                "Application built with libpng-%.20s"
-                " but running with %.20s",
-                user_png_ver,
-                png_libpng_ver);
-            png_warning(png_ptr, msg);
-         }
-#else
-         png_warning(png_ptr,
-             "Incompatible libpng version in application and library");
-#endif
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-        png_ptr->flags = 0;
-#endif
-        png_cleanup_needed = 1;
-     }
-   }
+   if (!png_user_version_check(png_ptr, user_png_ver))
+      png_cleanup_needed = 1;
 
    /* Initialize zbuf - compression buffer */
    png_ptr->zbuf_size = PNG_ZBUF_SIZE;
@@ -645,6 +614,9 @@ png_write_image(png_structp png_ptr, png_bytepp image)
 void PNGAPI
 png_write_row(png_structp png_ptr, png_const_bytep row)
 {
+   /* 1.5.6: moved from png_struct to be a local structure: */
+   png_row_info row_info;
+
    if (png_ptr == NULL)
       return;
 
@@ -768,36 +740,31 @@ png_write_row(png_structp png_ptr, png_const_bytep row)
 #endif
 
    /* Set up row info for transformations */
-   png_ptr->row_info.color_type = png_ptr->color_type;
-   png_ptr->row_info.width = png_ptr->usr_width;
-   png_ptr->row_info.channels = png_ptr->usr_channels;
-   png_ptr->row_info.bit_depth = png_ptr->usr_bit_depth;
-   png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
-      png_ptr->row_info.channels);
-
-   png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
-      png_ptr->row_info.width);
-
-   png_debug1(3, "row_info->color_type = %d", png_ptr->row_info.color_type);
-   png_debug1(3, "row_info->width = %u", png_ptr->row_info.width);
-   png_debug1(3, "row_info->channels = %d", png_ptr->row_info.channels);
-   png_debug1(3, "row_info->bit_depth = %d", png_ptr->row_info.bit_depth);
-   png_debug1(3, "row_info->pixel_depth = %d", png_ptr->row_info.pixel_depth);
-   png_debug1(3, "row_info->rowbytes = %lu",
-       (unsigned long)png_ptr->row_info.rowbytes);
+   row_info.color_type = png_ptr->color_type;
+   row_info.width = png_ptr->usr_width;
+   row_info.channels = png_ptr->usr_channels;
+   row_info.bit_depth = png_ptr->usr_bit_depth;
+   row_info.pixel_depth = (png_byte)(row_info.bit_depth * row_info.channels);
+   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);
+
+   png_debug1(3, "row_info->color_type = %d", row_info.color_type);
+   png_debug1(3, "row_info->width = %u", row_info.width);
+   png_debug1(3, "row_info->channels = %d", row_info.channels);
+   png_debug1(3, "row_info->bit_depth = %d", row_info.bit_depth);
+   png_debug1(3, "row_info->pixel_depth = %d", row_info.pixel_depth);
+   png_debug1(3, "row_info->rowbytes = %lu", (unsigned long)row_info.rowbytes);
 
    /* Copy user's row into buffer, leaving room for filter byte. */
-   png_memcpy(png_ptr->row_buf + 1, row, png_ptr->row_info.rowbytes);
+   png_memcpy(png_ptr->row_buf + 1, row, row_info.rowbytes);
 
 #ifdef PNG_WRITE_INTERLACING_SUPPORTED
    /* Handle interlacing */
    if (png_ptr->interlaced && png_ptr->pass < 6 &&
        (png_ptr->transformations & PNG_INTERLACE))
    {
-      png_do_write_interlace(&(png_ptr->row_info),
-          png_ptr->row_buf + 1, png_ptr->pass);
+      png_do_write_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass);
       /* This should always get caught above, but still ... */
-      if (!(png_ptr->row_info.width))
+      if (!(row_info.width))
       {
          png_write_finish_row(png_ptr);
          return;
@@ -805,9 +772,18 @@ png_write_row(png_structp png_ptr, png_const_bytep row)
    }
 #endif
 
+#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
    /* Handle other transformations */
    if (png_ptr->transformations)
-      png_do_write_transformations(png_ptr);
+      png_do_write_transformations(png_ptr, &row_info);
+#endif
+
+   /* At this point the row_info pixel depth must match the 'transformed' depth,
+    * which is also the output depth.
+    */
+   if (row_info.pixel_depth != png_ptr->pixel_depth ||
+      row_info.pixel_depth != png_ptr->transformed_pixel_depth)
+      png_error(png_ptr, "internal write transform logic error");
 
 #ifdef PNG_MNG_FEATURES_SUPPORTED
    /* Write filter_method 64 (intrapixel differencing) only if
@@ -823,12 +799,19 @@ png_write_row(png_structp png_ptr, png_const_bytep row)
        (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
    {
       /* Intrapixel differencing */
-      png_do_write_intrapixel(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_write_intrapixel(&row_info, png_ptr->row_buf + 1);
    }
 #endif
 
+/* Added at libpng-1.5.10 */
+#ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   /* Check for out-of-range palette index */
+   if(row_info.color_type == PNG_COLOR_TYPE_PALETTE)
+      png_do_check_palette_indexes(png_ptr, &row_info);
+#endif
+
    /* Find a filter if necessary, filter the row and write it out. */
-   png_write_find_filter(png_ptr, &(png_ptr->row_info));
+   png_write_find_filter(png_ptr, &row_info);
 
    if (png_ptr->write_row_fn != NULL)
       (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
@@ -884,8 +867,6 @@ png_write_flush(png_structp png_ptr)
       {
          /* Write the IDAT and reset the zlib output buffer */
          png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
-         png_ptr->zstream.next_out = png_ptr->zbuf;
-         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
          wrote_IDAT = 1;
       }
    } while (wrote_IDAT == 1);
@@ -896,8 +877,6 @@ png_write_flush(png_structp png_ptr)
       /* Write the IDAT and reset the zlib output buffer */
       png_write_IDAT(png_ptr, png_ptr->zbuf,
           png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-      png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
    }
    png_ptr->flush_rows = 0;
    png_flush(png_ptr);
@@ -918,13 +897,7 @@ png_destroy_write_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
    png_debug(1, "in png_destroy_write_struct");
 
    if (png_ptr_ptr != NULL)
-   {
       png_ptr = *png_ptr_ptr;
-#ifdef PNG_USER_MEM_SUPPORTED
-      free_fn = png_ptr->free_fn;
-      mem_ptr = png_ptr->mem_ptr;
-#endif
-   }
 
 #ifdef PNG_USER_MEM_SUPPORTED
    if (png_ptr != NULL)
@@ -983,7 +956,9 @@ png_write_destroy(png_structp png_ptr)
    jmp_buf tmp_jmp; /* Save jump buffer */
 #endif
    png_error_ptr error_fn;
+#ifdef PNG_WARNINGS_SUPPORTED
    png_error_ptr warning_fn;
+#endif
    png_voidp error_ptr;
 #ifdef PNG_USER_MEM_SUPPORTED
    png_free_ptr free_fn;
@@ -992,7 +967,8 @@ png_write_destroy(png_structp png_ptr)
    png_debug(1, "in png_write_destroy");
 
    /* Free any memory zlib uses */
-   deflateEnd(&png_ptr->zstream);
+   if (png_ptr->zlib_state != PNG_ZLIB_UNINITIALIZED)
+      deflateEnd(&png_ptr->zstream);
 
    /* Free our memory.  png_free checks NULL for us. */
    png_free(png_ptr, png_ptr->zbuf);
@@ -1005,10 +981,6 @@ png_write_destroy(png_structp png_ptr)
    png_free(png_ptr, png_ptr->paeth_row);
 #endif
 
-#ifdef PNG_TIME_RFC1123_SUPPORTED
-   png_free(png_ptr, png_ptr->time_buffer);
-#endif
-
 #ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
    /* Use this to save a little code space, it doesn't free the filter_costs */
    png_reset_filter_heuristics(png_ptr);
@@ -1018,11 +990,13 @@ png_write_destroy(png_structp png_ptr)
 
 #ifdef PNG_SETJMP_SUPPORTED
    /* Reset structure */
-   png_memcpy(tmp_jmp, png_ptr->png_jmpbuf, png_sizeof(jmp_buf));
+   png_memcpy(tmp_jmp, png_ptr->longjmp_buffer, png_sizeof(jmp_buf));
 #endif
 
    error_fn = png_ptr->error_fn;
+#ifdef PNG_WARNINGS_SUPPORTED
    warning_fn = png_ptr->warning_fn;
+#endif
    error_ptr = png_ptr->error_ptr;
 #ifdef PNG_USER_MEM_SUPPORTED
    free_fn = png_ptr->free_fn;
@@ -1031,14 +1005,16 @@ png_write_destroy(png_structp png_ptr)
    png_memset(png_ptr, 0, png_sizeof(png_struct));
 
    png_ptr->error_fn = error_fn;
+#ifdef PNG_WARNINGS_SUPPORTED
    png_ptr->warning_fn = warning_fn;
+#endif
    png_ptr->error_ptr = error_ptr;
 #ifdef PNG_USER_MEM_SUPPORTED
    png_ptr->free_fn = free_fn;
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
-   png_memcpy(png_ptr->png_jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
+   png_memcpy(png_ptr->longjmp_buffer, tmp_jmp, png_sizeof(jmp_buf));
 #endif
 }
 
@@ -1177,7 +1153,7 @@ png_set_filter(png_structp png_ptr, int method, int filters)
  * better compression.
  */
 #ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED      /* GRR 970116 */
-/* Conveneince reset API. */
+/* Convenience reset API. */
 static void
 png_reset_filter_heuristics(png_structp png_ptr)
 {
@@ -1451,6 +1427,9 @@ png_set_compression_strategy(png_structp png_ptr, int strategy)
    png_ptr->zlib_strategy = strategy;
 }
 
+/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
+ * smaller value of window_bits if it can do so safely.
+ */
 void PNGAPI
 png_set_compression_window_bits(png_structp png_ptr, int window_bits)
 {
@@ -1491,6 +1470,89 @@ png_set_compression_method(png_structp png_ptr, int method)
    png_ptr->zlib_method = method;
 }
 
+/* The following were added to libpng-1.5.4 */
+#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
+void PNGAPI
+png_set_text_compression_level(png_structp png_ptr, int level)
+{
+   png_debug(1, "in png_set_text_compression_level");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->flags |= PNG_FLAG_ZTXT_CUSTOM_LEVEL;
+   png_ptr->zlib_text_level = level;
+}
+
+void PNGAPI
+png_set_text_compression_mem_level(png_structp png_ptr, int mem_level)
+{
+   png_debug(1, "in png_set_text_compression_mem_level");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->flags |= PNG_FLAG_ZTXT_CUSTOM_MEM_LEVEL;
+   png_ptr->zlib_text_mem_level = mem_level;
+}
+
+void PNGAPI
+png_set_text_compression_strategy(png_structp png_ptr, int strategy)
+{
+   png_debug(1, "in png_set_text_compression_strategy");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->flags |= PNG_FLAG_ZTXT_CUSTOM_STRATEGY;
+   png_ptr->zlib_text_strategy = strategy;
+}
+
+/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
+ * smaller value of window_bits if it can do so safely.
+ */
+void PNGAPI
+png_set_text_compression_window_bits(png_structp png_ptr, int window_bits)
+{
+   if (png_ptr == NULL)
+      return;
+
+   if (window_bits > 15)
+      png_warning(png_ptr, "Only compression windows <= 32k supported by PNG");
+
+   else if (window_bits < 8)
+      png_warning(png_ptr, "Only compression windows >= 256 supported by PNG");
+
+#ifndef WBITS_8_OK
+   /* Avoid libpng bug with 256-byte windows */
+   if (window_bits == 8)
+      {
+        png_warning(png_ptr, "Text compression window is being reset to 512");
+        window_bits = 9;
+      }
+
+#endif
+   png_ptr->flags |= PNG_FLAG_ZTXT_CUSTOM_WINDOW_BITS;
+   png_ptr->zlib_text_window_bits = window_bits;
+}
+
+void PNGAPI
+png_set_text_compression_method(png_structp png_ptr, int method)
+{
+   png_debug(1, "in png_set_text_compression_method");
+
+   if (png_ptr == NULL)
+      return;
+
+   if (method != 8)
+      png_warning(png_ptr, "Only compression method 8 is supported by PNG");
+
+   png_ptr->flags |= PNG_FLAG_ZTXT_CUSTOM_METHOD;
+   png_ptr->zlib_text_method = method;
+}
+#endif /* PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED */
+/* end of API added to libpng-1.5.4 */
+
 void PNGAPI
 png_set_write_status_fn(png_structp png_ptr, png_write_status_ptr write_row_fn)
 {
@@ -1557,7 +1619,7 @@ png_write_png(png_structp png_ptr, png_infop info_ptr,
 #endif
 
 #ifdef PNG_WRITE_FILLER_SUPPORTED
-   /* Pack XRGB/RGBX/ARGB/RGBA into * RGB (4 channels -> 3 channels) */
+   /* Pack XRGB/RGBX/ARGB/RGBA into RGB (4 channels -> 3 channels) */
    if (transforms & PNG_TRANSFORM_STRIP_FILLER_AFTER)
       png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);
 
diff --git a/src/3rdparty/libpng/pngwtran.c b/src/3rdparty/libpng/pngwtran.c
index 115ca37..96608ef 100644
--- a/src/3rdparty/libpng/pngwtran.c
+++ b/src/3rdparty/libpng/pngwtran.c
@@ -1,7 +1,7 @@
 
 /* pngwtran.c - transforms the data in a row for PNG writers
  *
- * Last changed in libpng 1.5.0 [January 6, 2011]
+ * Last changed in libpng 1.5.6 [November 3, 2011]
  * Copyright (c) 1998-2011 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -15,11 +15,12 @@
 
 #ifdef PNG_WRITE_SUPPORTED
 
+#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
 /* Transform the data according to the user's wishes.  The order of
  * transformations is significant.
  */
 void /* PRIVATE */
-png_do_write_transformations(png_structp png_ptr)
+png_do_write_transformations(png_structp png_ptr, png_row_infop row_info)
 {
    png_debug(1, "in png_do_write_transformations");
 
@@ -31,8 +32,8 @@ png_do_write_transformations(png_structp png_ptr)
       if (png_ptr->write_user_transform_fn != NULL)
          (*(png_ptr->write_user_transform_fn)) /* User write transform
                                                  function */
-             (png_ptr,                    /* png_ptr */
-             &(png_ptr->row_info),           /* row_info: */
+             (png_ptr,  /* png_ptr */
+             row_info,  /* row_info: */
                 /*  png_uint_32 width;       width of row */
                 /*  png_size_t rowbytes;     number of bytes in row */
                 /*  png_byte color_type;     color type of pixels */
@@ -44,50 +45,50 @@ png_do_write_transformations(png_structp png_ptr)
 
 #ifdef PNG_WRITE_FILLER_SUPPORTED
    if (png_ptr->transformations & PNG_FILLER)
-      png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
-          png_ptr->flags);
+      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
+         !(png_ptr->flags & PNG_FLAG_FILLER_AFTER));
 #endif
 
 #ifdef PNG_WRITE_PACKSWAP_SUPPORTED
    if (png_ptr->transformations & PNG_PACKSWAP)
-      png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_packswap(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_WRITE_PACK_SUPPORTED
    if (png_ptr->transformations & PNG_PACK)
-      png_do_pack(&(png_ptr->row_info), png_ptr->row_buf + 1,
+      png_do_pack(row_info, png_ptr->row_buf + 1,
           (png_uint_32)png_ptr->bit_depth);
 #endif
 
 #ifdef PNG_WRITE_SWAP_SUPPORTED
    if (png_ptr->transformations & PNG_SWAP_BYTES)
-      png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_swap(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_WRITE_SHIFT_SUPPORTED
    if (png_ptr->transformations & PNG_SHIFT)
-      png_do_shift(&(png_ptr->row_info), png_ptr->row_buf + 1,
+      png_do_shift(row_info, png_ptr->row_buf + 1,
           &(png_ptr->shift));
 #endif
 
 #ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
    if (png_ptr->transformations & PNG_SWAP_ALPHA)
-      png_do_write_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_write_swap_alpha(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
    if (png_ptr->transformations & PNG_INVERT_ALPHA)
-      png_do_write_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_write_invert_alpha(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_WRITE_BGR_SUPPORTED
    if (png_ptr->transformations & PNG_BGR)
-      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_bgr(row_info, png_ptr->row_buf + 1);
 #endif
 
 #ifdef PNG_WRITE_INVERT_SUPPORTED
    if (png_ptr->transformations & PNG_INVERT_MONO)
-      png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
+      png_do_invert(row_info, png_ptr->row_buf + 1);
 #endif
 }
 
@@ -563,6 +564,7 @@ png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
    }
 }
 #endif
+#endif /* PNG_WRITE_TRANSFORMS_SUPPORTED */
 
 #ifdef PNG_MNG_FEATURES_SUPPORTED
 /* Undoes intrapixel differencing  */
diff --git a/src/3rdparty/libpng/pngwutil.c b/src/3rdparty/libpng/pngwutil.c
index 2c35785..b49704f 100644
--- a/src/3rdparty/libpng/pngwutil.c
+++ b/src/3rdparty/libpng/pngwutil.c
@@ -1,8 +1,8 @@
 
 /* pngwutil.c - utilities to write a PNG file
  *
- * Last changed in libpng 1.5.0 [January 6, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -82,39 +82,20 @@ png_write_sig(png_structp png_ptr)
       png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
 }
 
-/* Write a PNG chunk all at once.  The type is an array of ASCII characters
- * representing the chunk name.  The array must be at least 4 bytes in
- * length, and does not need to be null terminated.  To be safe, pass the
- * pre-defined chunk names here, and if you need a new one, define it
- * where the others are defined.  The length is the length of the data.
- * All the data must be present.  If that is not possible, use the
- * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
- * functions instead.
- */
-void PNGAPI
-png_write_chunk(png_structp png_ptr, png_const_bytep chunk_name,
-   png_const_bytep data, png_size_t length)
-{
-   if (png_ptr == NULL)
-      return;
-
-   png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
-   png_write_chunk_data(png_ptr, data, (png_size_t)length);
-   png_write_chunk_end(png_ptr);
-}
-
 /* Write the start of a PNG chunk.  The type is the chunk type.
  * The total_length is the sum of the lengths of all the data you will be
  * passing in png_write_chunk_data().
  */
-void PNGAPI
-png_write_chunk_start(png_structp png_ptr, png_const_bytep chunk_name,
+static void
+png_write_chunk_header(png_structp png_ptr, png_uint_32 chunk_name,
     png_uint_32 length)
 {
    png_byte buf[8];
 
-   png_debug2(0, "Writing %s chunk, length = %lu", chunk_name,
-      (unsigned long)length);
+#if defined(PNG_DEBUG) && (PNG_DEBUG > 0)
+   PNG_CSTRING_FROM_CHUNK(buf, chunk_name);
+   png_debug2(0, "Writing %s chunk, length = %lu", buf, (unsigned long)length);
+#endif
 
    if (png_ptr == NULL)
       return;
@@ -128,16 +109,16 @@ png_write_chunk_start(png_structp png_ptr, png_const_bytep chunk_name,
 
    /* Write the length and the chunk name */
    png_save_uint_32(buf, length);
-   png_memcpy(buf + 4, chunk_name, 4);
-   png_write_data(png_ptr, buf, (png_size_t)8);
+   png_save_uint_32(buf + 4, chunk_name);
+   png_write_data(png_ptr, buf, 8);
 
    /* Put the chunk name into png_ptr->chunk_name */
-   png_memcpy(png_ptr->chunk_name, chunk_name, 4);
+   png_ptr->chunk_name = chunk_name;
 
    /* Reset the crc and run it over the chunk name */
    png_reset_crc(png_ptr);
 
-   png_calculate_crc(png_ptr, chunk_name, 4);
+   png_calculate_crc(png_ptr, buf + 4, 4);
 
 #ifdef PNG_IO_STATE_SUPPORTED
    /* Inform the I/O callback that chunk data will (possibly) be written.
@@ -147,10 +128,17 @@ png_write_chunk_start(png_structp png_ptr, png_const_bytep chunk_name,
 #endif
 }
 
-/* Write the data of a PNG chunk started with png_write_chunk_start().
+void PNGAPI
+png_write_chunk_start(png_structp png_ptr, png_const_bytep chunk_string,
+    png_uint_32 length)
+{
+   png_write_chunk_header(png_ptr, PNG_CHUNK_FROM_STRING(chunk_string), length);
+}
+
+/* Write the data of a PNG chunk started with png_write_chunk_header().
  * Note that multiple calls to this function are allowed, and that the
  * sum of the lengths from these calls *must* add up to the total_length
- * given to png_write_chunk_start().
+ * given to png_write_chunk_header().
  */
 void PNGAPI
 png_write_chunk_data(png_structp png_ptr, png_const_bytep data,
@@ -171,7 +159,7 @@ png_write_chunk_data(png_structp png_ptr, png_const_bytep data,
    }
 }
 
-/* Finish a chunk started with png_write_chunk_start(). */
+/* Finish a chunk started with png_write_chunk_header(). */
 void PNGAPI
 png_write_chunk_end(png_structp png_ptr)
 {
@@ -192,7 +180,183 @@ png_write_chunk_end(png_structp png_ptr)
    png_write_data(png_ptr, buf, (png_size_t)4);
 }
 
-#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_iCCP_SUPPORTED)
+/* Write a PNG chunk all at once.  The type is an array of ASCII characters
+ * representing the chunk name.  The array must be at least 4 bytes in
+ * length, and does not need to be null terminated.  To be safe, pass the
+ * pre-defined chunk names here, and if you need a new one, define it
+ * where the others are defined.  The length is the length of the data.
+ * All the data must be present.  If that is not possible, use the
+ * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
+ * functions instead.
+ */
+static void
+png_write_complete_chunk(png_structp png_ptr, png_uint_32 chunk_name,
+   png_const_bytep data, png_size_t length)
+{
+   if (png_ptr == NULL)
+      return;
+
+   /* On 64 bit architectures 'length' may not fit in a png_uint_32. */
+   if (length > PNG_UINT_32_MAX)
+      png_error(png_ptr, "length exceeds PNG maxima");
+
+   png_write_chunk_header(png_ptr, chunk_name, (png_uint_32)length);
+   png_write_chunk_data(png_ptr, data, length);
+   png_write_chunk_end(png_ptr);
+}
+
+/* This is the API that calls the internal function above. */
+void PNGAPI
+png_write_chunk(png_structp png_ptr, png_const_bytep chunk_string,
+   png_const_bytep data, png_size_t length)
+{
+   png_write_complete_chunk(png_ptr, PNG_CHUNK_FROM_STRING(chunk_string), data,
+      length);
+}
+
+/* Initialize the compressor for the appropriate type of compression. */
+static void
+png_zlib_claim(png_structp png_ptr, png_uint_32 state)
+{
+   if (!(png_ptr->zlib_state & PNG_ZLIB_IN_USE))
+   {
+      /* If already initialized for 'state' do not re-init. */
+      if (png_ptr->zlib_state != state)
+      {
+         int ret = Z_OK;
+         png_const_charp who = "-";
+
+         /* If actually initialized for another state do a deflateEnd. */
+         if (png_ptr->zlib_state != PNG_ZLIB_UNINITIALIZED)
+         {
+            ret = deflateEnd(&png_ptr->zstream);
+            who = "end";
+            png_ptr->zlib_state = PNG_ZLIB_UNINITIALIZED;
+         }
+
+         /* zlib itself detects an incomplete state on deflateEnd */
+         if (ret == Z_OK) switch (state)
+         {
+#           ifdef PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
+               case PNG_ZLIB_FOR_TEXT:
+                  ret = deflateInit2(&png_ptr->zstream,
+                     png_ptr->zlib_text_level, png_ptr->zlib_text_method,
+                     png_ptr->zlib_text_window_bits,
+                     png_ptr->zlib_text_mem_level, png_ptr->zlib_text_strategy);
+                  who = "text";
+                  break;
+#           endif
+
+            case PNG_ZLIB_FOR_IDAT:
+               ret = deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
+                   png_ptr->zlib_method, png_ptr->zlib_window_bits,
+                   png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
+               who = "IDAT";
+               break;
+
+            default:
+               png_error(png_ptr, "invalid zlib state");
+         }
+
+         if (ret == Z_OK)
+            png_ptr->zlib_state = state;
+
+         else /* an error in deflateEnd or deflateInit2 */
+         {
+            size_t pos = 0;
+            char msg[64];
+
+            pos = png_safecat(msg, sizeof msg, pos,
+               "zlib failed to initialize compressor (");
+            pos = png_safecat(msg, sizeof msg, pos, who);
+
+            switch (ret)
+            {
+               case Z_VERSION_ERROR:
+                  pos = png_safecat(msg, sizeof msg, pos, ") version error");
+                  break;
+
+               case Z_STREAM_ERROR:
+                  pos = png_safecat(msg, sizeof msg, pos, ") stream error");
+                  break;
+
+               case Z_MEM_ERROR:
+                  pos = png_safecat(msg, sizeof msg, pos, ") memory error");
+                  break;
+
+               default:
+                  pos = png_safecat(msg, sizeof msg, pos, ") unknown error");
+                  break;
+            }
+
+            png_error(png_ptr, msg);
+         }
+      }
+
+      /* Here on success, claim the zstream: */
+      png_ptr->zlib_state |= PNG_ZLIB_IN_USE;
+   }
+
+   else
+      png_error(png_ptr, "zstream already in use (internal error)");
+}
+
+/* The opposite: release the stream.  It is also reset, this API will warn on
+ * error but will not fail.
+ */
+static void
+png_zlib_release(png_structp png_ptr)
+{
+   if (png_ptr->zlib_state & PNG_ZLIB_IN_USE)
+   {
+      int ret = deflateReset(&png_ptr->zstream);
+
+      png_ptr->zlib_state &= ~PNG_ZLIB_IN_USE;
+
+      if (ret != Z_OK)
+      {
+         png_const_charp err;
+         PNG_WARNING_PARAMETERS(p)
+
+         switch (ret)
+         {
+            case Z_VERSION_ERROR:
+               err = "version";
+               break;
+
+            case Z_STREAM_ERROR:
+               err = "stream";
+               break;
+
+            case Z_MEM_ERROR:
+               err = "memory";
+               break;
+
+            default:
+               err = "unknown";
+               break;
+         }
+
+         png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_d, ret);
+         png_warning_parameter(p, 2, err);
+
+         if (png_ptr->zstream.msg)
+            err = png_ptr->zstream.msg;
+         else
+            err = "[no zlib message]";
+
+         png_warning_parameter(p, 3, err);
+
+         png_formatted_warning(png_ptr, p,
+            "zlib failed to reset compressor: @1(@2): @3");
+      }
+   }
+
+   else
+      png_warning(png_ptr, "zstream not in use (internal error)");
+}
+
+#ifdef PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
 /* This pair of functions encapsulates the operation of (a) compressing a
  * text string, and (b) issuing it later as a series of chunk data writes.
  * The compression_state structure is shared context for these functions
@@ -220,25 +384,22 @@ png_text_compress(png_structp png_ptr,
    comp->max_output_ptr = 0;
    comp->output_ptr = NULL;
    comp->input = NULL;
-   comp->input_len = 0;
+   comp->input_len = text_len;
 
    /* We may just want to pass the text right through */
    if (compression == PNG_TEXT_COMPRESSION_NONE)
    {
       comp->input = (png_const_bytep)text;
-      comp->input_len = text_len;
       return((int)text_len);
    }
 
    if (compression >= PNG_TEXT_COMPRESSION_LAST)
    {
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-      char msg[50];
-      png_snprintf(msg, 50, "Unknown compression type %d", compression);
-      png_warning(png_ptr, msg);
-#else
-      png_warning(png_ptr, "Unknown compression type");
-#endif
+      PNG_WARNING_PARAMETERS(p)
+
+      png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_d,
+         compression);
+      png_formatted_warning(png_ptr, p, "Unknown compression type @1");
    }
 
    /* We can't write the chunk until we find out how much data we have,
@@ -255,10 +416,12 @@ png_text_compress(png_structp png_ptr,
     * data, or if the input string is incredibly large (although this
     * wouldn't cause a failure, just a slowdown due to swapping).
     */
+   png_zlib_claim(png_ptr, PNG_ZLIB_FOR_TEXT);
 
    /* Set up the compression buffers */
    /* TODO: the following cast hides a potential overflow problem. */
    png_ptr->zstream.avail_in = (uInt)text_len;
+
    /* NOTE: assume zlib doesn't overwrite the input */
    png_ptr->zstream.next_in = (Bytef *)text;
    png_ptr->zstream.avail_out = png_ptr->zbuf_size;
@@ -406,18 +569,84 @@ png_text_compress(png_structp png_ptr,
 
 /* Ship the compressed text out via chunk writes */
 static void /* PRIVATE */
-png_write_compressed_data_out(png_structp png_ptr, compression_state *comp)
+png_write_compressed_data_out(png_structp png_ptr, compression_state *comp,
+   png_size_t data_len)
 {
    int i;
 
    /* Handle the no-compression case */
    if (comp->input)
    {
-      png_write_chunk_data(png_ptr, comp->input, comp->input_len);
+      png_write_chunk_data(png_ptr, comp->input, data_len);
 
       return;
    }
 
+#ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
+   /* The zbuf_size test is because the code below doesn't work if zbuf_size is
+    * '1'; simply skip it to avoid memory overwrite.
+    */
+   if (data_len >= 2 && comp->input_len < 16384 && png_ptr->zbuf_size > 1)
+   {
+      unsigned int z_cmf;  /* zlib compression method and flags */
+
+      /* Optimize the CMF field in the zlib stream.  This hack of the zlib
+       * stream is compliant to the stream specification.
+       */
+
+      if (comp->num_output_ptr)
+        z_cmf = comp->output_ptr[0][0];
+      else
+        z_cmf = png_ptr->zbuf[0];
+
+      if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)
+      {
+         unsigned int z_cinfo;
+         unsigned int half_z_window_size;
+         png_size_t uncompressed_text_size = comp->input_len;
+
+         z_cinfo = z_cmf >> 4;
+         half_z_window_size = 1 << (z_cinfo + 7);
+
+         while (uncompressed_text_size <= half_z_window_size &&
+             half_z_window_size >= 256)
+         {
+            z_cinfo--;
+            half_z_window_size >>= 1;
+         }
+
+         z_cmf = (z_cmf & 0x0f) | (z_cinfo << 4);
+
+         if (comp->num_output_ptr)
+         {
+
+           if (comp->output_ptr[0][0] != z_cmf)
+           {
+              int tmp;
+
+              comp->output_ptr[0][0] = (png_byte)z_cmf;
+              tmp = comp->output_ptr[0][1] & 0xe0;
+              tmp += 0x1f - ((z_cmf << 8) + tmp) % 0x1f;
+              comp->output_ptr[0][1] = (png_byte)tmp;
+           }
+         }
+         else
+         {
+            int tmp;
+
+            png_ptr->zbuf[0] = (png_byte)z_cmf;
+            tmp = png_ptr->zbuf[1] & 0xe0;
+            tmp += 0x1f - ((z_cmf << 8) + tmp) % 0x1f;
+            png_ptr->zbuf[1] = (png_byte)tmp;
+         }
+      }
+
+      else
+         png_error(png_ptr,
+             "Invalid zlib compression method or flags in non-IDAT chunk");
+   }
+#endif /* PNG_WRITE_OPTIMIZE_CMF_SUPPORTED */
+
    /* Write saved output buffers, if any */
    for (i = 0; i < comp->num_output_ptr; i++)
    {
@@ -436,10 +665,9 @@ png_write_compressed_data_out(png_structp png_ptr, compression_state *comp)
           (png_size_t)(png_ptr->zbuf_size - png_ptr->zstream.avail_out));
 
    /* Reset zlib for another zTXt/iTXt or image data */
-   deflateReset(&png_ptr->zstream);
-   png_ptr->zstream.data_type = Z_BINARY;
+   png_zlib_release(png_ptr);
 }
-#endif
+#endif /* PNG_WRITE_COMPRESSED_TEXT_SUPPORTED */
 
 /* Write the IHDR chunk, and update the png_struct with the necessary
  * information.  Note that the rest of this code depends upon this
@@ -450,9 +678,6 @@ png_write_IHDR(png_structp png_ptr, png_uint_32 width, png_uint_32 height,
     int bit_depth, int color_type, int compression_type, int filter_type,
     int interlace_type)
 {
-   PNG_IHDR;
-   int ret;
-
    png_byte buf[13]; /* Buffer to store the IHDR info */
 
    png_debug(1, "in png_write_IHDR");
@@ -594,7 +819,7 @@ png_write_IHDR(png_structp png_ptr, png_uint_32 width, png_uint_32 height,
    buf[12] = (png_byte)interlace_type;
 
    /* Write the chunk */
-   png_write_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
+   png_write_complete_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
 
    /* Initialize zlib with PNG info */
    png_ptr->zstream.zalloc = png_zalloc;
@@ -632,35 +857,35 @@ png_write_IHDR(png_structp png_ptr, png_uint_32 width, png_uint_32 height,
    if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_METHOD))
       png_ptr->zlib_method = 8;
 
-   ret = deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
-       png_ptr->zlib_method, png_ptr->zlib_window_bits,
-       png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
+#ifdef PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
+#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
+   if (!(png_ptr->flags & PNG_FLAG_ZTXT_CUSTOM_STRATEGY))
+      png_ptr->zlib_text_strategy = Z_DEFAULT_STRATEGY;
 
-   if (ret != Z_OK)
-   {
-      if (ret == Z_VERSION_ERROR)
-         png_error(png_ptr,
-            "zlib failed to initialize compressor -- version error");
+   if (!(png_ptr->flags & PNG_FLAG_ZTXT_CUSTOM_LEVEL))
+      png_ptr->zlib_text_level = png_ptr->zlib_level;
 
-      if (ret == Z_STREAM_ERROR)
-         png_error(png_ptr,
-             "zlib failed to initialize compressor -- stream error");
-
-      if (ret == Z_MEM_ERROR)
-         png_error(png_ptr,
-             "zlib failed to initialize compressor -- mem error");
+   if (!(png_ptr->flags & PNG_FLAG_ZTXT_CUSTOM_MEM_LEVEL))
+      png_ptr->zlib_text_mem_level = png_ptr->zlib_mem_level;
 
-      png_error(png_ptr, "zlib failed to initialize compressor");
-   }
+   if (!(png_ptr->flags & PNG_FLAG_ZTXT_CUSTOM_WINDOW_BITS))
+      png_ptr->zlib_text_window_bits = png_ptr->zlib_window_bits;
 
-   png_ptr->zstream.next_out = png_ptr->zbuf;
-   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-   /* libpng is not interested in zstream.data_type, so set it
-    * to a predefined value, to avoid its evaluation inside zlib
-    */
-   png_ptr->zstream.data_type = Z_BINARY;
-
-   png_ptr->mode = PNG_HAVE_IHDR;
+   if (!(png_ptr->flags & PNG_FLAG_ZTXT_CUSTOM_METHOD))
+      png_ptr->zlib_text_method = png_ptr->zlib_method;
+#else
+   png_ptr->zlib_text_strategy = Z_DEFAULT_STRATEGY;
+   png_ptr->zlib_text_level = png_ptr->zlib_level;
+   png_ptr->zlib_text_mem_level = png_ptr->zlib_mem_level;
+   png_ptr->zlib_text_window_bits = png_ptr->zlib_window_bits;
+   png_ptr->zlib_text_method = png_ptr->zlib_method;
+#endif /* PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED */
+#endif /* PNG_WRITE_COMPRESSED_TEXT_SUPPORTED */
+
+   /* Record that the compressor has not yet been initialized. */
+   png_ptr->zlib_state = PNG_ZLIB_UNINITIALIZED;
+
+   png_ptr->mode = PNG_HAVE_IHDR; /* not READY_FOR_ZTXT */
 }
 
 /* Write the palette.  We are careful not to trust png_color to be in the
@@ -671,7 +896,6 @@ void /* PRIVATE */
 png_write_PLTE(png_structp png_ptr, png_const_colorp palette,
     png_uint_32 num_pal)
 {
-   PNG_PLTE;
    png_uint_32 i;
    png_const_colorp pal_ptr;
    png_byte buf[3];
@@ -707,7 +931,7 @@ png_write_PLTE(png_structp png_ptr, png_const_colorp palette,
    png_ptr->num_palette = (png_uint_16)num_pal;
    png_debug1(3, "num_palette = %d", png_ptr->num_palette);
 
-   png_write_chunk_start(png_ptr, png_PLTE, (png_uint_32)(num_pal * 3));
+   png_write_chunk_header(png_ptr, png_PLTE, (png_uint_32)(num_pal * 3));
 #ifdef PNG_POINTER_INDEXING_SUPPORTED
 
    for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)
@@ -741,16 +965,17 @@ png_write_PLTE(png_structp png_ptr, png_const_colorp palette,
 void /* PRIVATE */
 png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
 {
-   PNG_IDAT;
-
    png_debug(1, "in png_write_IDAT");
 
-   /* Optimize the CMF field in the zlib stream. */
-   /* This hack of the zlib stream is compliant to the stream specification. */
+#ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
    if (!(png_ptr->mode & PNG_HAVE_IDAT) &&
        png_ptr->compression_type == PNG_COMPRESSION_TYPE_BASE)
    {
+      /* Optimize the CMF field in the zlib stream.  This hack of the zlib
+       * stream is compliant to the stream specification.
+       */
       unsigned int z_cmf = data[0];  /* zlib compression method and flags */
+
       if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)
       {
          /* Avoid memory underflows and multiplication overflows.
@@ -761,11 +986,29 @@ png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
          if (length >= 2 &&
              png_ptr->height < 16384 && png_ptr->width < 16384)
          {
+            /* Compute the maximum possible length of the datastream */
+
+            /* Number of pixels, plus for each row a filter byte
+             * and possibly a padding byte, so increase the maximum
+             * size to account for these.
+             */
+            unsigned int z_cinfo;
+            unsigned int half_z_window_size;
             png_uint_32 uncompressed_idat_size = png_ptr->height *
                 ((png_ptr->width *
                 png_ptr->channels * png_ptr->bit_depth + 15) >> 3);
-            unsigned int z_cinfo = z_cmf >> 4;
-            unsigned int half_z_window_size = 1 << (z_cinfo + 7);
+
+            /* If it's interlaced, each block of 8 rows is sent as up to
+             * 14 rows, i.e., 6 additional rows, each with a filter byte
+             * and possibly a padding byte
+             */
+            if (png_ptr->interlaced)
+               uncompressed_idat_size += ((png_ptr->height + 7)/8) *
+                   (png_ptr->bit_depth < 8 ? 12 : 6);
+
+            z_cinfo = z_cmf >> 4;
+            half_z_window_size = 1 << (z_cinfo + 7);
+
             while (uncompressed_idat_size <= half_z_window_size &&
                 half_z_window_size >= 256)
             {
@@ -790,20 +1033,26 @@ png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
          png_error(png_ptr,
              "Invalid zlib compression method or flags in IDAT");
    }
+#endif /* PNG_WRITE_OPTIMIZE_CMF_SUPPORTED */
 
-   png_write_chunk(png_ptr, png_IDAT, data, length);
+   png_write_complete_chunk(png_ptr, png_IDAT, data, length);
    png_ptr->mode |= PNG_HAVE_IDAT;
+
+   /* Prior to 1.5.4 this code was replicated in every caller (except at the
+    * end, where it isn't technically necessary).  Since this function has
+    * flushed the data we can safely reset the zlib output buffer here.
+    */
+   png_ptr->zstream.next_out = png_ptr->zbuf;
+   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
 }
 
 /* Write an IEND chunk */
 void /* PRIVATE */
 png_write_IEND(png_structp png_ptr)
 {
-   PNG_IEND;
-
    png_debug(1, "in png_write_IEND");
 
-   png_write_chunk(png_ptr, png_IEND, NULL, (png_size_t)0);
+   png_write_complete_chunk(png_ptr, png_IEND, NULL, (png_size_t)0);
    png_ptr->mode |= PNG_HAVE_IEND;
 }
 
@@ -812,14 +1061,13 @@ png_write_IEND(png_structp png_ptr)
 void /* PRIVATE */
 png_write_gAMA_fixed(png_structp png_ptr, png_fixed_point file_gamma)
 {
-   PNG_gAMA;
    png_byte buf[4];
 
    png_debug(1, "in png_write_gAMA");
 
    /* file_gamma is saved in 1/100,000ths */
    png_save_uint_32(buf, (png_uint_32)file_gamma);
-   png_write_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
+   png_write_complete_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
 }
 #endif
 
@@ -828,7 +1076,6 @@ png_write_gAMA_fixed(png_structp png_ptr, png_fixed_point file_gamma)
 void /* PRIVATE */
 png_write_sRGB(png_structp png_ptr, int srgb_intent)
 {
-   PNG_sRGB;
    png_byte buf[1];
 
    png_debug(1, "in png_write_sRGB");
@@ -838,7 +1085,7 @@ png_write_sRGB(png_structp png_ptr, int srgb_intent)
           "Invalid sRGB rendering intent specified");
 
    buf[0]=(png_byte)srgb_intent;
-   png_write_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
+   png_write_complete_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
 }
 #endif
 
@@ -848,7 +1095,6 @@ void /* PRIVATE */
 png_write_iCCP(png_structp png_ptr, png_const_charp name, int compression_type,
     png_const_charp profile, int profile_len)
 {
-   PNG_iCCP;
    png_size_t name_len;
    png_charp new_name;
    compression_state comp;
@@ -909,7 +1155,7 @@ png_write_iCCP(png_structp png_ptr, png_const_charp name, int compression_type,
           (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp);
 
    /* Make sure we include the NULL after the name and the compression type */
-   png_write_chunk_start(png_ptr, png_iCCP,
+   png_write_chunk_header(png_ptr, png_iCCP,
        (png_uint_32)(name_len + profile_len + 2));
 
    new_name[name_len + 1] = 0x00;
@@ -918,7 +1164,9 @@ png_write_iCCP(png_structp png_ptr, png_const_charp name, int compression_type,
        (png_size_t)(name_len + 2));
 
    if (profile_len)
-      png_write_compressed_data_out(png_ptr, &comp);
+   {
+      png_write_compressed_data_out(png_ptr, &comp, profile_len);
+   }
 
    png_write_chunk_end(png_ptr);
    png_free(png_ptr, new_name);
@@ -930,7 +1178,6 @@ png_write_iCCP(png_structp png_ptr, png_const_charp name, int compression_type,
 void /* PRIVATE */
 png_write_sPLT(png_structp png_ptr, png_const_sPLT_tp spalette)
 {
-   PNG_sPLT;
    png_size_t name_len;
    png_charp new_name;
    png_byte entrybuf[10];
@@ -947,7 +1194,7 @@ png_write_sPLT(png_structp png_ptr, png_const_sPLT_tp spalette)
       return;
 
    /* Make sure we include the NULL after the name */
-   png_write_chunk_start(png_ptr, png_sPLT,
+   png_write_chunk_header(png_ptr, png_sPLT,
        (png_uint_32)(name_len + 2 + palette_size));
 
    png_write_chunk_data(png_ptr, (png_bytep)new_name,
@@ -1015,7 +1262,6 @@ png_write_sPLT(png_structp png_ptr, png_const_sPLT_tp spalette)
 void /* PRIVATE */
 png_write_sBIT(png_structp png_ptr, png_const_color_8p sbit, int color_type)
 {
-   PNG_sBIT;
    png_byte buf[4];
    png_size_t size;
 
@@ -1066,7 +1312,7 @@ png_write_sBIT(png_structp png_ptr, png_const_color_8p sbit, int color_type)
       buf[size++] = sbit->alpha;
    }
 
-   png_write_chunk(png_ptr, png_sBIT, buf, size);
+   png_write_complete_chunk(png_ptr, png_sBIT, buf, size);
 }
 #endif
 
@@ -1078,7 +1324,6 @@ png_write_cHRM_fixed(png_structp png_ptr, png_fixed_point white_x,
     png_fixed_point green_x, png_fixed_point green_y, png_fixed_point blue_x,
     png_fixed_point blue_y)
 {
-   PNG_cHRM;
    png_byte buf[32];
 
    png_debug(1, "in png_write_cHRM");
@@ -1101,7 +1346,7 @@ png_write_cHRM_fixed(png_structp png_ptr, png_fixed_point white_x,
       png_save_uint_32(buf + 24, (png_uint_32)blue_x);
       png_save_uint_32(buf + 28, (png_uint_32)blue_y);
 
-      png_write_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);
+      png_write_complete_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);
    }
 }
 #endif
@@ -1112,7 +1357,6 @@ void /* PRIVATE */
 png_write_tRNS(png_structp png_ptr, png_const_bytep trans_alpha,
     png_const_color_16p tran, int num_trans, int color_type)
 {
-   PNG_tRNS;
    png_byte buf[6];
 
    png_debug(1, "in png_write_tRNS");
@@ -1126,7 +1370,7 @@ png_write_tRNS(png_structp png_ptr, png_const_bytep trans_alpha,
       }
 
       /* Write the chunk out as it is */
-      png_write_chunk(png_ptr, png_tRNS, trans_alpha, (png_size_t)num_trans);
+      png_write_complete_chunk(png_ptr, png_tRNS, trans_alpha, (png_size_t)num_trans);
    }
 
    else if (color_type == PNG_COLOR_TYPE_GRAY)
@@ -1141,7 +1385,7 @@ png_write_tRNS(png_structp png_ptr, png_const_bytep trans_alpha,
       }
 
       png_save_uint_16(buf, tran->gray);
-      png_write_chunk(png_ptr, png_tRNS, buf, (png_size_t)2);
+      png_write_complete_chunk(png_ptr, png_tRNS, buf, (png_size_t)2);
    }
 
    else if (color_type == PNG_COLOR_TYPE_RGB)
@@ -1161,7 +1405,7 @@ png_write_tRNS(png_structp png_ptr, png_const_bytep trans_alpha,
          return;
       }
 
-      png_write_chunk(png_ptr, png_tRNS, buf, (png_size_t)6);
+      png_write_complete_chunk(png_ptr, png_tRNS, buf, (png_size_t)6);
    }
 
    else
@@ -1176,7 +1420,6 @@ png_write_tRNS(png_structp png_ptr, png_const_bytep trans_alpha,
 void /* PRIVATE */
 png_write_bKGD(png_structp png_ptr, png_const_color_16p back, int color_type)
 {
-   PNG_bKGD;
    png_byte buf[6];
 
    png_debug(1, "in png_write_bKGD");
@@ -1195,7 +1438,7 @@ png_write_bKGD(png_structp png_ptr, png_const_color_16p back, int color_type)
       }
 
       buf[0] = back->index;
-      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)1);
+      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)1);
    }
 
    else if (color_type & PNG_COLOR_MASK_COLOR)
@@ -1215,7 +1458,7 @@ png_write_bKGD(png_structp png_ptr, png_const_color_16p back, int color_type)
          return;
       }
 
-      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)6);
+      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)6);
    }
 
    else
@@ -1229,7 +1472,7 @@ png_write_bKGD(png_structp png_ptr, png_const_color_16p back, int color_type)
       }
 
       png_save_uint_16(buf, back->gray);
-      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);
+      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);
    }
 }
 #endif
@@ -1239,7 +1482,6 @@ png_write_bKGD(png_structp png_ptr, png_const_color_16p back, int color_type)
 void /* PRIVATE */
 png_write_hIST(png_structp png_ptr, png_const_uint_16p hist, int num_hist)
 {
-   PNG_hIST;
    int i;
    png_byte buf[3];
 
@@ -1254,7 +1496,7 @@ png_write_hIST(png_structp png_ptr, png_const_uint_16p hist, int num_hist)
       return;
    }
 
-   png_write_chunk_start(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));
+   png_write_chunk_header(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));
 
    for (i = 0; i < num_hist; i++)
    {
@@ -1313,15 +1555,11 @@ png_check_keyword(png_structp png_ptr, png_const_charp key, png_charpp new_key)
       if ((png_byte)*ikp < 0x20 ||
          ((png_byte)*ikp > 0x7E && (png_byte)*ikp < 0xA1))
       {
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-         char msg[40];
+         PNG_WARNING_PARAMETERS(p)
 
-         png_snprintf(msg, 40,
-             "invalid keyword character 0x%02X", (png_byte)*ikp);
-         png_warning(png_ptr, msg);
-#else
-         png_warning(png_ptr, "invalid character in keyword");
-#endif
+         png_warning_parameter_unsigned(p, 1, PNG_NUMBER_FORMAT_02x,
+            (png_byte)*ikp);
+         png_formatted_warning(png_ptr, p, "invalid keyword character 0x@1");
          *dp = ' ';
       }
 
@@ -1408,7 +1646,6 @@ void /* PRIVATE */
 png_write_tEXt(png_structp png_ptr, png_const_charp key, png_const_charp text,
     png_size_t text_len)
 {
-   PNG_tEXt;
    png_size_t key_len;
    png_charp new_key;
 
@@ -1424,7 +1661,7 @@ png_write_tEXt(png_structp png_ptr, png_const_charp key, png_const_charp text,
       text_len = png_strlen(text);
 
    /* Make sure we include the 0 after the key */
-   png_write_chunk_start(png_ptr, png_tEXt,
+   png_write_chunk_header(png_ptr, png_tEXt,
        (png_uint_32)(key_len + text_len + 1));
    /*
     * We leave it to the application to meet PNG-1.0 requirements on the
@@ -1450,7 +1687,6 @@ void /* PRIVATE */
 png_write_zTXt(png_structp png_ptr, png_const_charp key, png_const_charp text,
     png_size_t text_len, int compression)
 {
-   PNG_zTXt;
    png_size_t key_len;
    png_byte buf;
    png_charp new_key;
@@ -1484,7 +1720,7 @@ png_write_zTXt(png_structp png_ptr, png_const_charp key, png_const_charp text,
        &comp);
 
    /* Write start of chunk */
-   png_write_chunk_start(png_ptr, png_zTXt,
+   png_write_chunk_header(png_ptr, png_zTXt,
        (png_uint_32)(key_len+text_len + 2));
 
    /* Write key */
@@ -1499,7 +1735,7 @@ png_write_zTXt(png_structp png_ptr, png_const_charp key, png_const_charp text,
    png_write_chunk_data(png_ptr, &buf, (png_size_t)1);
 
    /* Write the compressed data */
-   png_write_compressed_data_out(png_ptr, &comp);
+   png_write_compressed_data_out(png_ptr, &comp, text_len);
 
    /* Close the chunk */
    png_write_chunk_end(png_ptr);
@@ -1512,7 +1748,6 @@ void /* PRIVATE */
 png_write_iTXt(png_structp png_ptr, int compression, png_const_charp key,
     png_const_charp lang, png_const_charp lang_key, png_const_charp text)
 {
-   PNG_iTXt;
    png_size_t lang_len, key_len, lang_key_len, text_len;
    png_charp new_lang;
    png_charp new_key = NULL;
@@ -1557,7 +1792,7 @@ png_write_iTXt(png_structp png_ptr, int compression, png_const_charp key,
     * and the NULs after the key, lang, and lang_key parts
     */
 
-   png_write_chunk_start(png_ptr, png_iTXt, (png_uint_32)(
+   png_write_chunk_header(png_ptr, png_iTXt, (png_uint_32)(
         5 /* comp byte, comp flag, terminators for key, lang and lang_key */
         + key_len
         + lang_len
@@ -1591,7 +1826,7 @@ png_write_iTXt(png_structp png_ptr, int compression, png_const_charp key,
    png_write_chunk_data(png_ptr, (lang_key ? (png_const_bytep)lang_key : cbuf),
        (png_size_t)(lang_key_len + 1));
 
-   png_write_compressed_data_out(png_ptr, &comp);
+   png_write_compressed_data_out(png_ptr, &comp, text_len);
 
    png_write_chunk_end(png_ptr);
 
@@ -1606,7 +1841,6 @@ void /* PRIVATE */
 png_write_oFFs(png_structp png_ptr, png_int_32 x_offset, png_int_32 y_offset,
     int unit_type)
 {
-   PNG_oFFs;
    png_byte buf[9];
 
    png_debug(1, "in png_write_oFFs");
@@ -1618,7 +1852,7 @@ png_write_oFFs(png_structp png_ptr, png_int_32 x_offset, png_int_32 y_offset,
    png_save_int_32(buf + 4, y_offset);
    buf[8] = (png_byte)unit_type;
 
-   png_write_chunk(png_ptr, png_oFFs, buf, (png_size_t)9);
+   png_write_complete_chunk(png_ptr, png_oFFs, buf, (png_size_t)9);
 }
 #endif
 #ifdef PNG_WRITE_pCAL_SUPPORTED
@@ -1628,9 +1862,8 @@ png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
     png_int_32 X1, int type, int nparams, png_const_charp units,
     png_charpp params)
 {
-   PNG_pCAL;
    png_size_t purpose_len, units_len, total_len;
-   png_uint_32p params_len;
+   png_size_tp params_len;
    png_byte buf[10];
    png_charp new_purpose;
    int i;
@@ -1646,8 +1879,8 @@ png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
    png_debug1(3, "pCAL units length = %d", (int)units_len);
    total_len = purpose_len + units_len + 10;
 
-   params_len = (png_uint_32p)png_malloc(png_ptr,
-       (png_alloc_size_t)(nparams * png_sizeof(png_uint_32)));
+   params_len = (png_size_tp)png_malloc(png_ptr,
+       (png_alloc_size_t)(nparams * png_sizeof(png_size_t)));
 
    /* Find the length of each parameter, making sure we don't count the
     * null terminator for the last parameter.
@@ -1657,13 +1890,12 @@ png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
       params_len[i] = png_strlen(params[i]) + (i == nparams - 1 ? 0 : 1);
       png_debug2(3, "pCAL parameter %d length = %lu", i,
           (unsigned long)params_len[i]);
-      total_len += (png_size_t)params_len[i];
+      total_len += params_len[i];
    }
 
    png_debug1(3, "pCAL total length = %d", (int)total_len);
-   png_write_chunk_start(png_ptr, png_pCAL, (png_uint_32)total_len);
-   png_write_chunk_data(png_ptr, (png_const_bytep)new_purpose,
-       (png_size_t)purpose_len);
+   png_write_chunk_header(png_ptr, png_pCAL, (png_uint_32)total_len);
+   png_write_chunk_data(png_ptr, (png_const_bytep)new_purpose, purpose_len);
    png_save_int_32(buf, X0);
    png_save_int_32(buf + 4, X1);
    buf[8] = (png_byte)type;
@@ -1675,8 +1907,7 @@ png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
 
    for (i = 0; i < nparams; i++)
    {
-      png_write_chunk_data(png_ptr, (png_const_bytep)params[i],
-          (png_size_t)params_len[i]);
+      png_write_chunk_data(png_ptr, (png_const_bytep)params[i], params_len[i]);
    }
 
    png_free(png_ptr, params_len);
@@ -1690,7 +1921,6 @@ void /* PRIVATE */
 png_write_sCAL_s(png_structp png_ptr, int unit, png_const_charp width,
     png_const_charp height)
 {
-   PNG_sCAL;
    png_byte buf[64];
    png_size_t wlen, hlen, total_len;
 
@@ -1711,7 +1941,7 @@ png_write_sCAL_s(png_structp png_ptr, int unit, png_const_charp width,
    png_memcpy(buf + wlen + 2, height, hlen);  /* Do NOT append the '\0' here */
 
    png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
-   png_write_chunk(png_ptr, png_sCAL, buf, total_len);
+   png_write_complete_chunk(png_ptr, png_sCAL, buf, total_len);
 }
 #endif
 
@@ -1722,7 +1952,6 @@ png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
     png_uint_32 y_pixels_per_unit,
     int unit_type)
 {
-   PNG_pHYs;
    png_byte buf[9];
 
    png_debug(1, "in png_write_pHYs");
@@ -1734,7 +1963,7 @@ png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
    png_save_uint_32(buf + 4, y_pixels_per_unit);
    buf[8] = (png_byte)unit_type;
 
-   png_write_chunk(png_ptr, png_pHYs, buf, (png_size_t)9);
+   png_write_complete_chunk(png_ptr, png_pHYs, buf, (png_size_t)9);
 }
 #endif
 
@@ -1745,7 +1974,6 @@ png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
 void /* PRIVATE */
 png_write_tIME(png_structp png_ptr, png_const_timep mod_time)
 {
-   PNG_tIME;
    png_byte buf[7];
 
    png_debug(1, "in png_write_tIME");
@@ -1765,7 +1993,7 @@ png_write_tIME(png_structp png_ptr, png_const_timep mod_time)
    buf[5] = mod_time->minute;
    buf[6] = mod_time->second;
 
-   png_write_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
+   png_write_complete_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
 }
 #endif
 
@@ -1777,28 +2005,32 @@ png_write_start_row(png_structp png_ptr)
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
 
-   png_size_t buf_size;
+   png_alloc_size_t buf_size;
+   int usr_pixel_depth;
 
    png_debug(1, "in png_write_start_row");
 
-   buf_size = (png_size_t)(PNG_ROWBYTES(
-       png_ptr->usr_channels*png_ptr->usr_bit_depth, png_ptr->width) + 1);
+   usr_pixel_depth = png_ptr->usr_channels * png_ptr->usr_bit_depth;
+   buf_size = PNG_ROWBYTES(usr_pixel_depth, png_ptr->width) + 1;
+
+   /* 1.5.6: added to allow checking in the row write code. */
+   png_ptr->transformed_pixel_depth = png_ptr->pixel_depth;
+   png_ptr->maximum_pixel_depth = (png_byte)usr_pixel_depth;
 
    /* Set up row buffer */
-   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr,
-       (png_alloc_size_t)buf_size);
+   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, buf_size);
 
    png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;
 
@@ -1815,8 +2047,7 @@ png_write_start_row(png_structp png_ptr)
    if (png_ptr->do_filter & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH))
    {
       /* Set up previous row buffer */
-      png_ptr->prev_row = (png_bytep)png_calloc(png_ptr,
-          (png_alloc_size_t)buf_size);
+      png_ptr->prev_row = (png_bytep)png_calloc(png_ptr, buf_size);
 
       if (png_ptr->do_filter & PNG_FILTER_UP)
       {
@@ -1871,6 +2102,7 @@ png_write_start_row(png_structp png_ptr)
       png_ptr->usr_width = png_ptr->width;
    }
 
+   png_zlib_claim(png_ptr, PNG_ZLIB_FOR_IDAT);
    png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
    png_ptr->zstream.next_out = png_ptr->zbuf;
 }
@@ -1883,16 +2115,16 @@ png_write_finish_row(png_structp png_ptr)
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
 
    int ret;
@@ -1992,7 +2224,7 @@ png_write_finish_row(png_structp png_ptr)
           png_ptr->zstream.avail_out);
    }
 
-   deflateReset(&png_ptr->zstream);
+   png_zlib_release(png_ptr);
    png_ptr->zstream.data_type = Z_BINARY;
 }
 
@@ -2010,10 +2242,10 @@ png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static PNG_CONST png_byte  png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    png_debug(1, "in png_do_write_interlace");
 
@@ -2181,6 +2413,9 @@ png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
  * been specified by the application, and then writes the row out with the
  * chosen filter.
  */
+static void png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row,
+   png_size_t row_bytes);
+
 #define PNG_MAXSUM (((png_uint_32)(-1)) >> 1)
 #define PNG_HISHIFT 10
 #define PNG_LOMASK ((png_uint_32)0xffffL)
@@ -2195,7 +2430,7 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
    png_byte filter_to_do = png_ptr->do_filter;
    png_size_t row_bytes = row_info->rowbytes;
 #ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   int num_p_filters = (int)png_ptr->num_prev_filters;
+   int num_p_filters = png_ptr->num_prev_filters;
 #endif
 
    png_debug(1, "in png_write_find_filter");
@@ -2832,9 +3067,9 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
       }
    }
 #endif /* PNG_WRITE_FILTER_SUPPORTED */
-   /* Do the actual writing of the filtered row data from the chosen filter. */
 
-   png_write_filtered_row(png_ptr, best_row);
+   /* Do the actual writing of the filtered row data from the chosen filter. */
+   png_write_filtered_row(png_ptr, best_row, row_info->rowbytes+1);
 
 #ifdef PNG_WRITE_FILTER_SUPPORTED
 #ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
@@ -2856,11 +3091,10 @@ png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
 
 
 /* Do the actual writing of a previously filtered row. */
-void /* PRIVATE */
-png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
+static void
+png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row,
+   png_size_t avail/*includes filter byte*/)
 {
-   png_size_t avail;
-
    png_debug(1, "in png_write_filtered_row");
 
    png_debug1(2, "filter = %d", filtered_row[0]);
@@ -2868,7 +3102,6 @@ png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
 
    png_ptr->zstream.next_in = filtered_row;
    png_ptr->zstream.avail_in = 0;
-   avail = png_ptr->row_info.rowbytes + 1;
    /* Repeat until we have compressed all the data */
    do
    {
@@ -2916,8 +3149,6 @@ png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
       {
          /* Write the IDAT and reset the zlib output buffer */
          png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
-         png_ptr->zstream.next_out = png_ptr->zbuf;
-         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
       }
    /* Repeat until all data has been compressed */
    } while (avail > 0 || png_ptr->zstream.avail_in > 0);