diff --git a/doc/src/audiooverview.qdoc b/doc/src/audiooverview.qdoc
index 3784476..b27f358 100644
--- a/doc/src/audiooverview.qdoc
+++ b/doc/src/audiooverview.qdoc
@@ -106,10 +106,7 @@ Here's an example of decoding a local file:
     \snippet doc/src/snippets/multimedia-snippets/audio.cpp Local audio decoding
 
 Note:  This API is preliminary at this time - the API may change or be
-removed before the final 5.0 release.  In addition, it is necessary to
-add "multimedia-private" to the QT variable in your .pro file to use this class.
-
-    \snippet doc/src/snippets/multimedia-snippets/audio.cpp Audio decoder header
+removed before the final 5.0 release.
 
 \section2 Recording audio to a file
 For recording audio to a file, the \l {QAudioRecorder} class allows you
diff --git a/doc/src/snippets/multimedia-snippets/audio.cpp b/doc/src/snippets/multimedia-snippets/audio.cpp
index d25c05e..29bf5c8 100644
--- a/doc/src/snippets/multimedia-snippets/audio.cpp
+++ b/doc/src/snippets/multimedia-snippets/audio.cpp
@@ -48,10 +48,7 @@
 #include "qaudioinput.h"
 #include "qaudiooutput.h"
 #include "qaudioprobe.h"
-
-//! [Audio decoder header]
-#include "qaudiodecoder_p.h"
-//! [Audio decoder header]
+#include "qaudiodecoder.h"
 
 class AudioInputExample : public QObject {
     Q_OBJECT
diff --git a/examples/audiodecoder/audiodecoder.h b/examples/audiodecoder/audiodecoder.h
index 63dd823..a950191 100644
--- a/examples/audiodecoder/audiodecoder.h
+++ b/examples/audiodecoder/audiodecoder.h
@@ -41,7 +41,7 @@
 #ifndef AUDIODECODER_H
 #define AUDIODECODER_H
 
-#include <private/qaudiodecoder_p.h>
+#include <qaudiodecoder.h>
 #include "wavefilewriter.h"
 #include <QSoundEffect>
 #include <QTextStream>
diff --git a/examples/examples.pro b/examples/examples.pro
index 164200f..60fc9c4 100644
--- a/examples/examples.pro
+++ b/examples/examples.pro
@@ -6,6 +6,7 @@ TEMPLATE = subdirs
         radio \
         camera \
         spectrum \
+        audiodecoder \
         audiorecorder \
         audiodevices \
         audioinput \
diff --git a/src/multimedia/audio/audio.pri b/src/multimedia/audio/audio.pri
index b58ecbb..fedfc97 100644
--- a/src/multimedia/audio/audio.pri
+++ b/src/multimedia/audio/audio.pri
@@ -11,14 +11,14 @@ PUBLIC_HEADERS += \
            audio/qaudiosystem.h  \
            audio/qsoundeffect.h \
            audio/qsound.h \
-           audio/qaudioprobe.h
+           audio/qaudioprobe.h \
+           audio/qaudiodecoder.h
 
 PRIVATE_HEADERS += \
            audio/qaudiobuffer_p.h \
            audio/qaudiodevicefactory_p.h \
            audio/qwavedecoder_p.h \
            audio/qsamplecache_p.h \
-           audio/qaudiodecoder_p.h
 
 SOURCES += \
            audio/qaudio.cpp \
@@ -35,7 +35,7 @@ SOURCES += \
            audio/qsound.cpp \
            audio/qaudiobuffer.cpp \
            audio/qaudioprobe.cpp \
-           audio/qaudiodecoder_p.cpp
+           audio/qaudiodecoder.cpp
 
 mac {
     PRIVATE_HEADERS +=  audio/qaudioinput_mac_p.h \
diff --git a/src/multimedia/audio/qaudiodecoder.cpp b/src/multimedia/audio/qaudiodecoder.cpp
new file mode 100644
index 0000000..1253deb
--- /dev/null
+++ b/src/multimedia/audio/qaudiodecoder.cpp
@@ -0,0 +1,547 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qaudiodecoder.h"
+
+#include "qmediaobject_p.h"
+#include <qmediaservice.h>
+#include "qaudiodecodercontrol.h"
+#include <private/qmediaserviceprovider_p.h>
+
+#include <QtCore/qcoreevent.h>
+#include <QtCore/qmetaobject.h>
+#include <QtCore/qtimer.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qpointer.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QAudioDecoder
+    \brief The QAudioDecoder class allows decoding audio.
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \ingroup multimedia_audio
+
+    \preliminary
+
+    The QAudioDecoder class is a high level class for decoding local
+    audio media files.  It is similar to the QMediaPlayer class except
+    that audio is provided back through this API rather than routed
+    directly to audio hardware, and playlists and network and streaming
+    based media is not supported.
+
+    \sa QAudioBuffer
+*/
+
+namespace
+{
+class AudioDecoderRegisterMetaTypes
+{
+public:
+    AudioDecoderRegisterMetaTypes()
+    {
+        qRegisterMetaType<QAudioDecoder::State>("QAudioDecoder::State");
+        qRegisterMetaType<QAudioDecoder::Error>("QAudioDecoder::Error");
+    }
+} _registerPlayerMetaTypes;
+}
+
+class QAudioDecoderPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QAudioDecoder)
+
+public:
+    QAudioDecoderPrivate()
+        : provider(0)
+        , control(0)
+        , state(QAudioDecoder::StoppedState)
+        , error(QAudioDecoder::NoError)
+    {}
+
+    QMediaServiceProvider *provider;
+    QAudioDecoderControl *control;
+    QAudioDecoder::State state;
+    QAudioDecoder::Error error;
+    QString errorString;
+
+    void _q_stateChanged(QAudioDecoder::State state);
+    void _q_error(int error, const QString &errorString);
+};
+
+void QAudioDecoderPrivate::_q_stateChanged(QAudioDecoder::State ps)
+{
+    Q_Q(QAudioDecoder);
+
+    if (ps != state) {
+        state = ps;
+
+        emit q->stateChanged(ps);
+    }
+}
+
+void QAudioDecoderPrivate::_q_error(int error, const QString &errorString)
+{
+    Q_Q(QAudioDecoder);
+
+    this->error = QAudioDecoder::Error(error);
+    this->errorString = errorString;
+
+    emit q->error(this->error);
+}
+
+/*!
+    Construct an QAudioDecoder instance
+    parented to \a parent.
+*/
+QAudioDecoder::QAudioDecoder(QObject *parent)
+    : QMediaObject(*new QAudioDecoderPrivate,
+                   parent,
+                   QMediaServiceProvider::defaultServiceProvider()->requestService(Q_MEDIASERVICE_AUDIODECODER))
+{
+    Q_D(QAudioDecoder);
+
+    d->provider = QMediaServiceProvider::defaultServiceProvider();
+    if (d->service == 0) {
+        d->error = ServiceMissingError;
+    } else {
+        d->control = qobject_cast<QAudioDecoderControl*>(d->service->requestControl(QAudioDecoderControl_iid));
+        if (d->control != 0) {
+            connect(d->control, SIGNAL(stateChanged(QAudioDecoder::State)), SLOT(_q_stateChanged(QAudioDecoder::State)));
+            connect(d->control, SIGNAL(error(int,QString)), SLOT(_q_error(int,QString)));
+
+            connect(d->control, SIGNAL(formatChanged(QAudioFormat)), SIGNAL(formatChanged(QAudioFormat)));
+            connect(d->control, SIGNAL(sourceChanged()), SIGNAL(sourceChanged()));
+            connect(d->control, SIGNAL(bufferReady()), this, SIGNAL(bufferReady()));
+            connect(d->control ,SIGNAL(bufferAvailableChanged(bool)), this, SIGNAL(bufferAvailableChanged(bool)));
+            connect(d->control ,SIGNAL(finished()), this, SIGNAL(finished()));
+            connect(d->control ,SIGNAL(positionChanged(qint64)), this, SIGNAL(positionChanged(qint64)));
+            connect(d->control ,SIGNAL(durationChanged(qint64)), this, SIGNAL(durationChanged(qint64)));
+        }
+    }
+}
+
+
+/*!
+    Destroys the audio decoder object.
+*/
+QAudioDecoder::~QAudioDecoder()
+{
+    Q_D(QAudioDecoder);
+
+    if (d->service) {
+        if (d->control)
+            d->service->releaseControl(d->control);
+
+        d->provider->releaseService(d->service);
+    }
+}
+
+QAudioDecoder::State QAudioDecoder::state() const
+{
+    return d_func()->state;
+}
+
+/*!
+    Returns the current error state.
+*/
+
+QAudioDecoder::Error QAudioDecoder::error() const
+{
+    return d_func()->error;
+}
+
+QString QAudioDecoder::errorString() const
+{
+    return d_func()->errorString;
+}
+
+/*!
+    Starts decoding the audio resource.
+
+    As data gets decoded, the \l bufferReady() signal will be emitted
+    when enough data has been decoded.  Calling \l read() will then return
+    an audio buffer without blocking.
+
+    Alternatively, if you wish to block until enough data has been decoded,
+    you can call read() at any time to block until a buffer is ready.
+
+    \sa read()
+*/
+void QAudioDecoder::start()
+{
+    Q_D(QAudioDecoder);
+
+    if (d->control == 0) {
+        QMetaObject::invokeMethod(this, "_q_error", Qt::QueuedConnection,
+                                    Q_ARG(int, QAudioDecoder::ServiceMissingError),
+                                    Q_ARG(QString, tr("The QAudioDecoder object does not have a valid service")));
+        return;
+    }
+
+    // Reset error conditions
+    d->error = NoError;
+    d->errorString.clear();
+
+    d->control->start();
+}
+
+/*!
+    Stop decoding audio.  Calling \l start() again will resume decoding from the beginning.
+*/
+void QAudioDecoder::stop()
+{
+    Q_D(QAudioDecoder);
+
+    if (d->control != 0)
+        d->control->stop();
+}
+
+/*!
+    Returns the current file name to decode.
+    If \l setSourceDevice was called, this will
+    be empty.
+*/
+QString QAudioDecoder::sourceFilename() const
+{
+    Q_D(const QAudioDecoder);
+    if (d->control)
+        return d->control->sourceFilename();
+    return QString();
+}
+
+/*!
+    Sets the current audio file name to \a fileName.
+
+    When this property is set any current decoding is stopped,
+    and any audio buffers are discarded.
+
+    You can only specify either a source filename or
+    a source QIODevice.  Setting one will unset the other.
+*/
+void QAudioDecoder::setSourceFilename(const QString &fileName)
+{
+    Q_D(QAudioDecoder);
+
+    if (d->control != 0)
+        d_func()->control->setSourceFilename(fileName);
+}
+
+/*!
+    Returns the current source QIODevice, if one was set.
+    If \l setSourceFilename() was called, this will be 0.
+*/
+QIODevice *QAudioDecoder::sourceDevice() const
+{
+    Q_D(const QAudioDecoder);
+    if (d->control)
+        return d->control->sourceDevice();
+    return 0;
+}
+
+/*!
+    Sets the current audio QIODevice to \a device.
+
+    When this property is set any current decoding is stopped,
+    and any audio buffers are discarded.
+
+    You can only specify either a source filename or
+    a source QIODevice.  Setting one will unset the other.
+*/
+void QAudioDecoder::setSourceDevice(QIODevice *device)
+{
+    Q_D(QAudioDecoder);
+
+    if (d->control != 0)
+        d_func()->control->setSourceDevice(device);
+}
+
+/*!
+    Returns the current audio format of the decoded stream.
+
+    Any buffers returned should have this format.
+
+    \sa setAudioFormat(), formatChanged()
+*/
+QAudioFormat QAudioDecoder::audioFormat() const
+{
+    Q_D(const QAudioDecoder);
+    if (d->control)
+        return d->control->audioFormat();
+    return QAudioFormat();
+}
+
+/*!
+    Set the desired audio format for decoded samples to \a format.
+
+    This property can only be set while the decoder is stopped.
+    Setting this property at other times will be ignored.
+
+    If the decoder does not support this format, \l error() will
+    be set to \c FormatError.
+
+    If you do not specify a format, the format of the decoded
+    audio itself will be used.  Otherwise, some format conversion
+    will be applied.
+
+    If you wish to reset the decoded format to that of the original
+    audio file, you can specify an invalid \a format.
+*/
+void QAudioDecoder::setAudioFormat(const QAudioFormat &format)
+{
+    Q_D(QAudioDecoder);
+
+    if (state() != QAudioDecoder::StoppedState)
+        return;
+
+    if (d->control != 0)
+        d_func()->control->setAudioFormat(format);
+}
+
+/*!
+    \internal
+*/
+
+bool QAudioDecoder::bind(QObject *obj)
+{
+    return QMediaObject::bind(obj);
+}
+
+/*!
+    \internal
+*/
+
+void QAudioDecoder::unbind(QObject *obj)
+{
+    QMediaObject::unbind(obj);
+}
+
+/*!
+    Returns the level of support an audio decoder has for a \a mimeType and a set of \a codecs.
+*/
+QtMultimedia::SupportEstimate QAudioDecoder::hasSupport(const QString &mimeType,
+                                               const QStringList& codecs)
+{
+    return QMediaServiceProvider::defaultServiceProvider()->hasSupport(QByteArray(Q_MEDIASERVICE_AUDIODECODER),
+                                                                    mimeType,
+                                                                    codecs);
+}
+
+/*!
+    \fn QAudioDecoder::bufferAvailable() const
+
+    Returns true if a buffer is available to be read,
+    and false otherwise.  If there is no buffer available, calling
+    the \l read() function may block until a buffer is available or
+    the end of the media is reached
+*/
+bool QAudioDecoder::bufferAvailable() const
+{
+    Q_D(const QAudioDecoder);
+    if (d->control)
+        return d->control->bufferAvailable();
+    return false;
+}
+
+/*!
+    Returns position (in milliseconds) of the last buffer read from
+    the decoder or -1 if no buffers have been read.
+*/
+
+qint64 QAudioDecoder::position() const
+{
+    Q_D(const QAudioDecoder);
+    if (d->control)
+        return d->control->position();
+    return -1;
+}
+
+/*!
+    Returns total duration (in milliseconds) of the audio stream or -1
+    if not available.
+*/
+
+qint64 QAudioDecoder::duration() const
+{
+    Q_D(const QAudioDecoder);
+    if (d->control)
+        return d->control->duration();
+    return -1;
+}
+
+/*!
+    Read a buffer from the decoder. Returns invalid buffer on failure.
+*/
+
+QAudioBuffer QAudioDecoder::read() const
+{
+    Q_D(const QAudioDecoder);
+
+    if (d->control) {
+        return d->control->read();
+    } else {
+        return QAudioBuffer();
+    }
+}
+
+// Enums
+/*!
+    \enum QAudioDecoder::State
+
+    Defines the current state of a media player.
+
+    \value DecodingState The audio player is currently decoding media.
+    \value StoppedState The decoder is not decoding.  Decoding will
+           start at the start of the media.
+*/
+
+/*!
+    \enum QAudioDecoder::Error
+
+    Defines a media player error condition.
+
+    \value NoError No error has occurred.
+    \value ResourceError A media resource couldn't be resolved.
+    \value FormatError The format of a media resource isn't supported.
+    \value AccessDeniedError There are not the appropriate permissions to play a media resource.
+    \value ServiceMissingError A valid playback service was not found, playback cannot proceed.
+*/
+
+// Signals
+/*!
+    \fn QAudioDecoder::error(QAudioDecoder::Error error)
+
+    Signals that an \a error condition has occurred.
+
+    \sa errorString()
+*/
+
+/*!
+    \fn void QAudioDecoder::stateChanged(State state)
+
+    Signal the \a state of the decoder object has changed.
+*/
+
+/*!
+    \fn void QAudioDecoder::sourceChanged()
+
+    Signals that the current source of the decoder has changed.
+
+    \sa sourceFilename(), sourceDevice()
+*/
+
+/*!
+    \fn void QAudioDecoder::formatChanged(const QAudioFormat &format)
+
+    Signals that the current audio format of the decoder has changed to \a format.
+
+    \sa audioFormat(), setAudioFormat()
+*/
+
+/*!
+    \fn void QAudioDecoder::bufferReady()
+
+    Signals that a new decoded audio buffer is available to be read.
+
+    \sa read(), bufferAvailable()
+*/
+
+/*!
+    \fn void QAudioDecoder::bufferAvailableChanged(bool available)
+
+    Signals the availability (if \a available is true) of a new buffer.
+
+    If \a available is false, there are no buffers available.
+
+    \sa bufferAvailable(), bufferReady()
+*/
+
+/*!
+    \fn void QAudioDecoder::finished()
+
+    Signals that the decoding has finished successfully.
+    If decoding fails, error signal is emitted instead.
+
+    \sa start(), stop(), error()
+*/
+
+/*!
+    \fn void QAudioDecoder::positionChanged(qint64 position)
+
+    Signals that the current \a position of the decoder has changed.
+
+    \sa durationChanged()
+*/
+
+/*!
+    \fn void QAudioDecoder::durationChanged(qint64 duration)
+
+    Signals that the estimated \a duration of the decoded data has changed.
+
+    \sa positionChanged()
+*/
+
+
+// Properties
+/*!
+    \property QAudioDecoder::state
+    \brief the audio decoder's playback state.
+
+    By default this property is QAudioDecoder::Stopped
+
+    \sa start(), stop()
+*/
+
+/*!
+    \property QAudioDecoder::error
+    \brief a string describing the last error condition.
+
+    \sa error()
+*/
+
+/*!
+    \property QAudioDecoder::sourceFilename
+    \brief the active filename being decoded by the decoder object.
+*/
+
+#include "moc_qaudiodecoder.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/audio/qaudiodecoder.h b/src/multimedia/audio/qaudiodecoder.h
new file mode 100644
index 0000000..a671f19
--- /dev/null
+++ b/src/multimedia/audio/qaudiodecoder.h
@@ -0,0 +1,149 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAUDIODECODER_H
+#define QAUDIODECODER_H
+
+#include "qmediaobject.h"
+#include "qmediaenumdebug.h"
+
+#include "qaudiobuffer.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QAudioDecoderPrivate;
+class Q_MULTIMEDIA_EXPORT QAudioDecoder : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QString sourceFilename READ sourceFilename WRITE setSourceFilename NOTIFY sourceChanged)
+    Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(QString error READ errorString)
+    Q_PROPERTY(bool bufferAvailable READ bufferAvailable NOTIFY bufferAvailableChanged)
+
+    Q_ENUMS(State)
+    Q_ENUMS(Error)
+
+public:
+    enum State
+    {
+        StoppedState,
+        DecodingState
+    };
+
+    enum Error
+    {
+        NoError,
+        ResourceError,
+        FormatError,
+        AccessDeniedError,
+        ServiceMissingError
+    };
+
+    QAudioDecoder(QObject *parent = 0);
+    ~QAudioDecoder();
+
+    static QtMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs = QStringList());
+
+    State state() const;
+
+    QString sourceFilename() const;
+    void setSourceFilename(const QString &fileName);
+
+    QIODevice* sourceDevice() const;
+    void setSourceDevice(QIODevice *device);
+
+    QAudioFormat audioFormat() const;
+    void setAudioFormat(const QAudioFormat &format);
+
+    Error error() const;
+    QString errorString() const;
+
+    QAudioBuffer read() const;
+    bool bufferAvailable() const;
+
+    qint64 position() const;
+    qint64 duration() const;
+
+public Q_SLOTS:
+    void start();
+    void stop();
+
+Q_SIGNALS:
+    void bufferAvailableChanged(bool);
+    void bufferReady();
+    void finished();
+
+    void stateChanged(QAudioDecoder::State newState);
+    void formatChanged(const QAudioFormat &format);
+
+    void error(QAudioDecoder::Error error);
+
+    void sourceChanged();
+
+    void positionChanged(qint64 position);
+    void durationChanged(qint64 duration);
+
+public:
+    virtual bool bind(QObject *);
+    virtual void unbind(QObject *);
+
+private:
+    Q_DISABLE_COPY(QAudioDecoder)
+    Q_DECLARE_PRIVATE(QAudioDecoder)
+    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QAudioDecoder::State))
+    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QAudioDecoder::State)
+Q_DECLARE_METATYPE(QAudioDecoder::Error)
+
+Q_MEDIA_ENUM_DEBUG(QAudioDecoder, State)
+Q_MEDIA_ENUM_DEBUG(QAudioDecoder, Error)
+
+QT_END_HEADER
+
+#endif  // QAUDIODECODER_H
diff --git a/src/multimedia/audio/qaudiodecoder_p.cpp b/src/multimedia/audio/qaudiodecoder_p.cpp
deleted file mode 100644
index b0d57ee..0000000
--- a/src/multimedia/audio/qaudiodecoder_p.cpp
+++ /dev/null
@@ -1,547 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qaudiodecoder_p.h"
-
-#include "qmediaobject_p.h"
-#include <qmediaservice.h>
-#include "qaudiodecodercontrol_p.h"
-#include <private/qmediaserviceprovider_p.h>
-
-#include <QtCore/qcoreevent.h>
-#include <QtCore/qmetaobject.h>
-#include <QtCore/qtimer.h>
-#include <QtCore/qdebug.h>
-#include <QtCore/qpointer.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QAudioDecoder
-    \brief The QAudioDecoder class allows decoding audio.
-    \inmodule QtMultimedia
-    \ingroup multimedia
-    \ingroup multimedia_audio
-
-    \preliminary
-
-    The QAudioDecoder class is a high level class for decoding local
-    audio media files.  It is similar to the QMediaPlayer class except
-    that audio is provided back through this API rather than routed
-    directly to audio hardware, and playlists and network and streaming
-    based media is not supported.
-
-    \sa QAudioBuffer
-*/
-
-namespace
-{
-class AudioDecoderRegisterMetaTypes
-{
-public:
-    AudioDecoderRegisterMetaTypes()
-    {
-        qRegisterMetaType<QAudioDecoder::State>("QAudioDecoder::State");
-        qRegisterMetaType<QAudioDecoder::Error>("QAudioDecoder::Error");
-    }
-} _registerPlayerMetaTypes;
-}
-
-class QAudioDecoderPrivate : public QMediaObjectPrivate
-{
-    Q_DECLARE_NON_CONST_PUBLIC(QAudioDecoder)
-
-public:
-    QAudioDecoderPrivate()
-        : provider(0)
-        , control(0)
-        , state(QAudioDecoder::StoppedState)
-        , error(QAudioDecoder::NoError)
-    {}
-
-    QMediaServiceProvider *provider;
-    QAudioDecoderControl *control;
-    QAudioDecoder::State state;
-    QAudioDecoder::Error error;
-    QString errorString;
-
-    void _q_stateChanged(QAudioDecoder::State state);
-    void _q_error(int error, const QString &errorString);
-};
-
-void QAudioDecoderPrivate::_q_stateChanged(QAudioDecoder::State ps)
-{
-    Q_Q(QAudioDecoder);
-
-    if (ps != state) {
-        state = ps;
-
-        emit q->stateChanged(ps);
-    }
-}
-
-void QAudioDecoderPrivate::_q_error(int error, const QString &errorString)
-{
-    Q_Q(QAudioDecoder);
-
-    this->error = QAudioDecoder::Error(error);
-    this->errorString = errorString;
-
-    emit q->error(this->error);
-}
-
-/*!
-    Construct an QAudioDecoder instance
-    parented to \a parent.
-*/
-QAudioDecoder::QAudioDecoder(QObject *parent)
-    : QMediaObject(*new QAudioDecoderPrivate,
-                   parent,
-                   QMediaServiceProvider::defaultServiceProvider()->requestService(Q_MEDIASERVICE_AUDIODECODER))
-{
-    Q_D(QAudioDecoder);
-
-    d->provider = QMediaServiceProvider::defaultServiceProvider();
-    if (d->service == 0) {
-        d->error = ServiceMissingError;
-    } else {
-        d->control = qobject_cast<QAudioDecoderControl*>(d->service->requestControl(QAudioDecoderControl_iid));
-        if (d->control != 0) {
-            connect(d->control, SIGNAL(stateChanged(QAudioDecoder::State)), SLOT(_q_stateChanged(QAudioDecoder::State)));
-            connect(d->control, SIGNAL(error(int,QString)), SLOT(_q_error(int,QString)));
-
-            connect(d->control, SIGNAL(formatChanged(QAudioFormat)), SIGNAL(formatChanged(QAudioFormat)));
-            connect(d->control, SIGNAL(sourceChanged()), SIGNAL(sourceChanged()));
-            connect(d->control, SIGNAL(bufferReady()), this, SIGNAL(bufferReady()));
-            connect(d->control ,SIGNAL(bufferAvailableChanged(bool)), this, SIGNAL(bufferAvailableChanged(bool)));
-            connect(d->control ,SIGNAL(finished()), this, SIGNAL(finished()));
-            connect(d->control ,SIGNAL(positionChanged(qint64)), this, SIGNAL(positionChanged(qint64)));
-            connect(d->control ,SIGNAL(durationChanged(qint64)), this, SIGNAL(durationChanged(qint64)));
-        }
-    }
-}
-
-
-/*!
-    Destroys the audio decoder object.
-*/
-QAudioDecoder::~QAudioDecoder()
-{
-    Q_D(QAudioDecoder);
-
-    if (d->service) {
-        if (d->control)
-            d->service->releaseControl(d->control);
-
-        d->provider->releaseService(d->service);
-    }
-}
-
-QAudioDecoder::State QAudioDecoder::state() const
-{
-    return d_func()->state;
-}
-
-/*!
-    Returns the current error state.
-*/
-
-QAudioDecoder::Error QAudioDecoder::error() const
-{
-    return d_func()->error;
-}
-
-QString QAudioDecoder::errorString() const
-{
-    return d_func()->errorString;
-}
-
-/*!
-    Starts decoding the audio resource.
-
-    As data gets decoded, the \l bufferReady() signal will be emitted
-    when enough data has been decoded.  Calling \l read() will then return
-    an audio buffer without blocking.
-
-    Alternatively, if you wish to block until enough data has been decoded,
-    you can call read() at any time to block until a buffer is ready.
-
-    \sa read()
-*/
-void QAudioDecoder::start()
-{
-    Q_D(QAudioDecoder);
-
-    if (d->control == 0) {
-        QMetaObject::invokeMethod(this, "_q_error", Qt::QueuedConnection,
-                                    Q_ARG(int, QAudioDecoder::ServiceMissingError),
-                                    Q_ARG(QString, tr("The QAudioDecoder object does not have a valid service")));
-        return;
-    }
-
-    // Reset error conditions
-    d->error = NoError;
-    d->errorString.clear();
-
-    d->control->start();
-}
-
-/*!
-    Stop decoding audio.  Calling \l start() again will resume decoding from the beginning.
-*/
-void QAudioDecoder::stop()
-{
-    Q_D(QAudioDecoder);
-
-    if (d->control != 0)
-        d->control->stop();
-}
-
-/*!
-    Returns the current file name to decode.
-    If \l setSourceDevice was called, this will
-    be empty.
-*/
-QString QAudioDecoder::sourceFilename() const
-{
-    Q_D(const QAudioDecoder);
-    if (d->control)
-        return d->control->sourceFilename();
-    return QString();
-}
-
-/*!
-    Sets the current audio file name to \a fileName.
-
-    When this property is set any current decoding is stopped,
-    and any audio buffers are discarded.
-
-    You can only specify either a source filename or
-    a source QIODevice.  Setting one will unset the other.
-*/
-void QAudioDecoder::setSourceFilename(const QString &fileName)
-{
-    Q_D(QAudioDecoder);
-
-    if (d->control != 0)
-        d_func()->control->setSourceFilename(fileName);
-}
-
-/*!
-    Returns the current source QIODevice, if one was set.
-    If \l setSourceFilename() was called, this will be 0.
-*/
-QIODevice *QAudioDecoder::sourceDevice() const
-{
-    Q_D(const QAudioDecoder);
-    if (d->control)
-        return d->control->sourceDevice();
-    return 0;
-}
-
-/*!
-    Sets the current audio QIODevice to \a device.
-
-    When this property is set any current decoding is stopped,
-    and any audio buffers are discarded.
-
-    You can only specify either a source filename or
-    a source QIODevice.  Setting one will unset the other.
-*/
-void QAudioDecoder::setSourceDevice(QIODevice *device)
-{
-    Q_D(QAudioDecoder);
-
-    if (d->control != 0)
-        d_func()->control->setSourceDevice(device);
-}
-
-/*!
-    Returns the current audio format of the decoded stream.
-
-    Any buffers returned should have this format.
-
-    \sa setAudioFormat(), formatChanged()
-*/
-QAudioFormat QAudioDecoder::audioFormat() const
-{
-    Q_D(const QAudioDecoder);
-    if (d->control)
-        return d->control->audioFormat();
-    return QAudioFormat();
-}
-
-/*!
-    Set the desired audio format for decoded samples to \a format.
-
-    This property can only be set while the decoder is stopped.
-    Setting this property at other times will be ignored.
-
-    If the decoder does not support this format, \l error() will
-    be set to \c FormatError.
-
-    If you do not specify a format, the format of the decoded
-    audio itself will be used.  Otherwise, some format conversion
-    will be applied.
-
-    If you wish to reset the decoded format to that of the original
-    audio file, you can specify an invalid \a format.
-*/
-void QAudioDecoder::setAudioFormat(const QAudioFormat &format)
-{
-    Q_D(QAudioDecoder);
-
-    if (state() != QAudioDecoder::StoppedState)
-        return;
-
-    if (d->control != 0)
-        d_func()->control->setAudioFormat(format);
-}
-
-/*!
-    \internal
-*/
-
-bool QAudioDecoder::bind(QObject *obj)
-{
-    return QMediaObject::bind(obj);
-}
-
-/*!
-    \internal
-*/
-
-void QAudioDecoder::unbind(QObject *obj)
-{
-    QMediaObject::unbind(obj);
-}
-
-/*!
-    Returns the level of support an audio decoder has for a \a mimeType and a set of \a codecs.
-*/
-QtMultimedia::SupportEstimate QAudioDecoder::hasSupport(const QString &mimeType,
-                                               const QStringList& codecs)
-{
-    return QMediaServiceProvider::defaultServiceProvider()->hasSupport(QByteArray(Q_MEDIASERVICE_AUDIODECODER),
-                                                                    mimeType,
-                                                                    codecs);
-}
-
-/*!
-    \fn QAudioDecoder::bufferAvailable() const
-
-    Returns true if a buffer is available to be read,
-    and false otherwise.  If there is no buffer available, calling
-    the \l read() function may block until a buffer is available or
-    the end of the media is reached
-*/
-bool QAudioDecoder::bufferAvailable() const
-{
-    Q_D(const QAudioDecoder);
-    if (d->control)
-        return d->control->bufferAvailable();
-    return false;
-}
-
-/*!
-    Returns position (in milliseconds) of the last buffer read from
-    the decoder or -1 if no buffers have been read.
-*/
-
-qint64 QAudioDecoder::position() const
-{
-    Q_D(const QAudioDecoder);
-    if (d->control)
-        return d->control->position();
-    return -1;
-}
-
-/*!
-    Returns total duration (in milliseconds) of the audio stream or -1
-    if not available.
-*/
-
-qint64 QAudioDecoder::duration() const
-{
-    Q_D(const QAudioDecoder);
-    if (d->control)
-        return d->control->duration();
-    return -1;
-}
-
-/*!
-    Read a buffer from the decoder. Returns invalid buffer on failure.
-*/
-
-QAudioBuffer QAudioDecoder::read() const
-{
-    Q_D(const QAudioDecoder);
-
-    if (d->control) {
-        return d->control->read();
-    } else {
-        return QAudioBuffer();
-    }
-}
-
-// Enums
-/*!
-    \enum QAudioDecoder::State
-
-    Defines the current state of a media player.
-
-    \value DecodingState The audio player is currently decoding media.
-    \value StoppedState The decoder is not decoding.  Decoding will
-           start at the start of the media.
-*/
-
-/*!
-    \enum QAudioDecoder::Error
-
-    Defines a media player error condition.
-
-    \value NoError No error has occurred.
-    \value ResourceError A media resource couldn't be resolved.
-    \value FormatError The format of a media resource isn't supported.
-    \value AccessDeniedError There are not the appropriate permissions to play a media resource.
-    \value ServiceMissingError A valid playback service was not found, playback cannot proceed.
-*/
-
-// Signals
-/*!
-    \fn QAudioDecoder::error(QAudioDecoder::Error error)
-
-    Signals that an \a error condition has occurred.
-
-    \sa errorString()
-*/
-
-/*!
-    \fn void QAudioDecoder::stateChanged(State state)
-
-    Signal the \a state of the decoder object has changed.
-*/
-
-/*!
-    \fn void QAudioDecoder::sourceChanged()
-
-    Signals that the current source of the decoder has changed.
-
-    \sa sourceFilename(), sourceDevice()
-*/
-
-/*!
-    \fn void QAudioDecoder::formatChanged(const QAudioFormat &format)
-
-    Signals that the current audio format of the decoder has changed to \a format.
-
-    \sa audioFormat(), setAudioFormat()
-*/
-
-/*!
-    \fn void QAudioDecoder::bufferReady()
-
-    Signals that a new decoded audio buffer is available to be read.
-
-    \sa read(), bufferAvailable()
-*/
-
-/*!
-    \fn void QAudioDecoder::bufferAvailableChanged(bool available)
-
-    Signals the availability (if \a available is true) of a new buffer.
-
-    If \a available is false, there are no buffers available.
-
-    \sa bufferAvailable(), bufferReady()
-*/
-
-/*!
-    \fn void QAudioDecoder::finished()
-
-    Signals that the decoding has finished successfully.
-    If decoding fails, error signal is emitted instead.
-
-    \sa start(), stop(), error()
-*/
-
-/*!
-    \fn void QAudioDecoder::positionChanged(qint64 position)
-
-    Signals that the current \a position of the decoder has changed.
-
-    \sa durationChanged()
-*/
-
-/*!
-    \fn void QAudioDecoder::durationChanged(qint64 duration)
-
-    Signals that the estimated \a duration of the decoded data has changed.
-
-    \sa positionChanged()
-*/
-
-
-// Properties
-/*!
-    \property QAudioDecoder::state
-    \brief the audio decoder's playback state.
-
-    By default this property is QAudioDecoder::Stopped
-
-    \sa start(), stop()
-*/
-
-/*!
-    \property QAudioDecoder::error
-    \brief a string describing the last error condition.
-
-    \sa error()
-*/
-
-/*!
-    \property QAudioDecoder::sourceFilename
-    \brief the active filename being decoded by the decoder object.
-*/
-
-#include "moc_qaudiodecoder_p.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/audio/qaudiodecoder_p.h b/src/multimedia/audio/qaudiodecoder_p.h
deleted file mode 100644
index a671f19..0000000
--- a/src/multimedia/audio/qaudiodecoder_p.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QAUDIODECODER_H
-#define QAUDIODECODER_H
-
-#include "qmediaobject.h"
-#include "qmediaenumdebug.h"
-
-#include "qaudiobuffer.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QAudioDecoderPrivate;
-class Q_MULTIMEDIA_EXPORT QAudioDecoder : public QMediaObject
-{
-    Q_OBJECT
-    Q_PROPERTY(QString sourceFilename READ sourceFilename WRITE setSourceFilename NOTIFY sourceChanged)
-    Q_PROPERTY(State state READ state NOTIFY stateChanged)
-    Q_PROPERTY(QString error READ errorString)
-    Q_PROPERTY(bool bufferAvailable READ bufferAvailable NOTIFY bufferAvailableChanged)
-
-    Q_ENUMS(State)
-    Q_ENUMS(Error)
-
-public:
-    enum State
-    {
-        StoppedState,
-        DecodingState
-    };
-
-    enum Error
-    {
-        NoError,
-        ResourceError,
-        FormatError,
-        AccessDeniedError,
-        ServiceMissingError
-    };
-
-    QAudioDecoder(QObject *parent = 0);
-    ~QAudioDecoder();
-
-    static QtMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs = QStringList());
-
-    State state() const;
-
-    QString sourceFilename() const;
-    void setSourceFilename(const QString &fileName);
-
-    QIODevice* sourceDevice() const;
-    void setSourceDevice(QIODevice *device);
-
-    QAudioFormat audioFormat() const;
-    void setAudioFormat(const QAudioFormat &format);
-
-    Error error() const;
-    QString errorString() const;
-
-    QAudioBuffer read() const;
-    bool bufferAvailable() const;
-
-    qint64 position() const;
-    qint64 duration() const;
-
-public Q_SLOTS:
-    void start();
-    void stop();
-
-Q_SIGNALS:
-    void bufferAvailableChanged(bool);
-    void bufferReady();
-    void finished();
-
-    void stateChanged(QAudioDecoder::State newState);
-    void formatChanged(const QAudioFormat &format);
-
-    void error(QAudioDecoder::Error error);
-
-    void sourceChanged();
-
-    void positionChanged(qint64 position);
-    void durationChanged(qint64 duration);
-
-public:
-    virtual bool bind(QObject *);
-    virtual void unbind(QObject *);
-
-private:
-    Q_DISABLE_COPY(QAudioDecoder)
-    Q_DECLARE_PRIVATE(QAudioDecoder)
-    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QAudioDecoder::State))
-    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
-};
-
-QT_END_NAMESPACE
-
-Q_DECLARE_METATYPE(QAudioDecoder::State)
-Q_DECLARE_METATYPE(QAudioDecoder::Error)
-
-Q_MEDIA_ENUM_DEBUG(QAudioDecoder, State)
-Q_MEDIA_ENUM_DEBUG(QAudioDecoder, Error)
-
-QT_END_HEADER
-
-#endif  // QAUDIODECODER_H
diff --git a/src/multimedia/controls/controls.pri b/src/multimedia/controls/controls.pri
index 69094f7..bf21187 100644
--- a/src/multimedia/controls/controls.pri
+++ b/src/multimedia/controls/controls.pri
@@ -2,6 +2,7 @@
 INCLUDEPATH += controls
 
 PUBLIC_HEADERS += \
+    controls/qaudiodecodercontrol.h \
     controls/qaudioencodercontrol.h \
     controls/qcameracapturebufferformatcontrol.h \
     controls/qcameracapturedestinationcontrol.h \
@@ -34,7 +35,6 @@ PUBLIC_HEADERS += \
     controls/qmediaavailabilitycontrol.h
 
 PRIVATE_HEADERS += \
-    controls/qaudiodecodercontrol_p.h \
     controls/qmediaplaylistcontrol_p.h \
     controls/qmediaplaylistsourcecontrol_p.h
 
@@ -70,7 +70,7 @@ SOURCES += \
     controls/qvideorenderercontrol.cpp \
     controls/qmediaaudioprobecontrol.cpp \
     controls/qmediavideoprobecontrol.cpp \
-    controls/qaudiodecodercontrol_p.cpp \
-    controls/qmediaavailabilitycontrol.cpp
+    controls/qmediaavailabilitycontrol.cpp \
+    controls/qaudiodecodercontrol.cpp
 
 
diff --git a/src/multimedia/controls/qaudiodecodercontrol.cpp b/src/multimedia/controls/qaudiodecodercontrol.cpp
new file mode 100644
index 0000000..f8e7a0f
--- /dev/null
+++ b/src/multimedia/controls/qaudiodecodercontrol.cpp
@@ -0,0 +1,269 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmediacontrol_p.h"
+#include "qaudiodecodercontrol.h"
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QAudioDecoderControl
+    \inmodule QtMultimedia
+
+    \ingroup multimedia
+    \ingroup multimedia_control
+
+    \brief The QAudioDecoderControl class provides access to the audio decoding
+    functionality of a QMediaService.
+
+    \preliminary
+
+    The functionality provided by this control is exposed to application
+    code through the QAudioDecoder class.
+
+    The interface name of QAudioDecoderControl is \c org.qt-project.qt.audiodecodercontrol/5.0 as
+    defined in QAudioDecoderControl_iid.
+
+    \sa QMediaService::requestControl(), QAudioDecoder
+*/
+
+/*!
+    \macro QAudioDecoderControl_iid
+
+    \c org.qt-project.qt.audiodecodercontrol/5.0
+
+    Defines the interface name of the QAudioDecoderControl class.
+
+    \relates QAudioDecoderControl
+*/
+
+/*!
+    Destroys an audio decoder control.
+*/
+QAudioDecoderControl::~QAudioDecoderControl()
+{
+}
+
+/*!
+    Constructs a new audio decoder control with the given \a parent.
+*/
+QAudioDecoderControl::QAudioDecoderControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    \fn QAudioDecoderControl::state() const
+
+    Returns the state of a player control.
+*/
+
+/*!
+    \fn QAudioDecoderControl::stateChanged(QAudioDecoder::State state)
+
+    Signals that the \a state of a player control has changed.
+
+    \sa state()
+*/
+
+/*!
+    \fn QAudioDecoderControl::sourceFilename() const
+
+    Returns the current media source filename, or a null QString if none (or a device)
+*/
+
+/*!
+    \fn QAudioDecoderControl::setSourceFilename(const QString &fileName)
+
+    Sets the current source to \a fileName.  Changing the source will
+    stop any current decoding and discard any buffers.
+
+    Sources are exclusive, so only one can be set.
+*/
+
+/*!
+    \fn QAudioDecoderControl::sourceDevice() const
+
+    Returns the current media source QIODevice, or 0 if none (or a file).
+*/
+
+/*!
+    \fn QAudioDecoderControl::setSourceDevice(QIODevice *device)
+
+    Sets the current source to \a device.  Changing the source will
+    stop any current decoding and discard any buffers.
+
+    Sources are exclusive, so only one can be set.
+*/
+
+/*!
+    \fn QAudioDecoderControl::start()
+
+    Starts decoding the current media.
+
+    If successful the player control will immediately enter the \l {QAudioDecoder::DecodingState}
+    {decoding} state.
+
+    \sa state(), read()
+*/
+
+/*!
+    \fn QAudioDecoderControl::stop()
+
+    Stops playback of the current media and discards any buffers.
+
+    If successful the player control will immediately enter the \l {QAudioDecoder::StoppedState}
+    {stopped} state.
+*/
+
+/*!
+    \fn QAudioDecoderControl::error(int error, const QString &errorString)
+
+    Signals that an \a error has occurred.  The \a errorString provides a more detailed explanation.
+*/
+
+/*!
+    \fn QAudioDecoderControl::bufferAvailableChanged(bool available)
+
+    Signals that the bufferAvailable property has changed to \a available.
+*/
+
+/*!
+    \fn QAudioDecoderControl::bufferReady()
+
+    Signals that a new buffer is ready for reading.
+*/
+
+/*!
+    \fn QAudioDecoderControl::bufferAvailable() const
+
+    Returns true if a buffer is available to be read,
+    and false otherwise.  If there is no buffer available, calling
+    the \l read() function may block until a buffer is available or
+    the end of the media is reached
+*/
+
+/*!
+    \fn QAudioDecoderControl::sourceChanged()
+
+    Signals that the current source of the decoder has changed.
+
+    \sa sourceFilename(), sourceDevice()
+*/
+
+/*!
+    \fn QAudioDecoderControl::formatChanged(const QAudioFormat &format)
+
+    Signals that the current audio format of the decoder has changed to \a format.
+
+    \sa audioFormat(), setAudioFormat()
+*/
+
+/*!
+    \fn void QAudioDecoderControl::finished()
+
+    Signals that the decoding has finished successfully.
+    If decoding fails, error signal is emitted instead.
+
+    \sa start(), stop(), error()
+*/
+
+/*!
+    \fn void QAudioDecoderControl::positionChanged(qint64 position)
+
+    Signals that the current \a position of the decoder has changed.
+
+    \sa durationChanged()
+*/
+
+/*!
+    \fn void QAudioDecoderControl::durationChanged(qint64 duration)
+
+    Signals that the estimated \a duration of the decoded data has changed.
+
+    \sa positionChanged()
+*/
+
+/*!
+    \fn QAudioDecoderControl::audioFormat() const
+    Returns the current audio format of the decoded stream.
+
+    Any buffers returned should have this format.
+
+    \sa setAudioFormat(), formatChanged()
+*/
+
+/*!
+    \fn QAudioDecoderControl::setAudioFormat(const QAudioFormat &format)
+    Set the desired audio format for decoded samples to \a format.
+
+    If the decoder does not support this format, \l error() will
+    be set to \c FormatError.
+
+    If you do not specify a format, the format of the decoded
+    audio itself will be used.  Otherwise, some format conversion
+    will be applied.
+
+    If you wish to reset the decoded format to that of the original
+    audio file, you can specify an invalid \a format.
+*/
+
+/*!
+    \fn QAudioDecoderControl::read()
+    Read a buffer from the decoder. Returns invalid buffer on failure.
+*/
+
+/*!
+    \fn QAudioDecoderControl::position() const
+    Returns position (in milliseconds) of the last buffer read from
+    the decoder or -1 if no buffers have been read.
+*/
+
+/*!
+    \fn QAudioDecoderControl::duration() const
+    Returns total duration (in milliseconds) of the audio stream
+    or -1 if not available.
+*/
+
+#include "moc_qaudiodecodercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qaudiodecodercontrol.h b/src/multimedia/controls/qaudiodecodercontrol.h
new file mode 100644
index 0000000..0c26e68
--- /dev/null
+++ b/src/multimedia/controls/qaudiodecodercontrol.h
@@ -0,0 +1,111 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAUDIODECODERCONTROL_H
+#define QAUDIODECODERCONTROL_H
+
+#include "qmediacontrol.h"
+#include "qaudiodecoder.h"
+
+#include <QtCore/qpair.h>
+
+#include "qaudiobuffer.h"
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Multimedia)
+
+class QIODevice;
+class Q_MULTIMEDIA_EXPORT QAudioDecoderControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QAudioDecoderControl();
+
+    virtual QAudioDecoder::State state() const = 0;
+
+    virtual QString sourceFilename() const = 0;
+    virtual void setSourceFilename(const QString &fileName) = 0;
+
+    virtual QIODevice* sourceDevice() const = 0;
+    virtual void setSourceDevice(QIODevice *device) = 0;
+
+    virtual void start() = 0;
+    virtual void stop() = 0;
+
+    virtual QAudioFormat audioFormat() const = 0;
+    virtual void setAudioFormat(const QAudioFormat &format) = 0;
+
+    virtual QAudioBuffer read() = 0;
+    virtual bool bufferAvailable() const = 0;
+
+    virtual qint64 position() const = 0;
+    virtual qint64 duration() const = 0;
+
+Q_SIGNALS:
+    void stateChanged(QAudioDecoder::State newState);
+    void formatChanged(const QAudioFormat &format);
+    void sourceChanged();
+
+    void error(int error, const QString &errorString);
+
+    void bufferReady();
+    void bufferAvailableChanged(bool available);
+    void finished();
+
+    void positionChanged(qint64 position);
+    void durationChanged(qint64 duration);
+
+protected:
+    QAudioDecoderControl(QObject* parent = 0);
+};
+
+#define QAudioDecoderControl_iid "org.qt-project.qt.audiodecodercontrol/5.0"
+Q_MEDIA_DECLARE_CONTROL(QAudioDecoderControl, QAudioDecoderControl_iid)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif  // QAUDIODECODERCONTROL_H
diff --git a/src/multimedia/controls/qaudiodecodercontrol_p.cpp b/src/multimedia/controls/qaudiodecodercontrol_p.cpp
deleted file mode 100644
index d2e1c7e..0000000
--- a/src/multimedia/controls/qaudiodecodercontrol_p.cpp
+++ /dev/null
@@ -1,269 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmediacontrol_p.h"
-#include "qaudiodecodercontrol_p.h"
-
-QT_BEGIN_NAMESPACE
-
-
-/*!
-    \class QAudioDecoderControl
-    \inmodule QtMultimedia
-
-    \ingroup multimedia
-    \ingroup multimedia_control
-
-    \brief The QAudioDecoderControl class provides access to the audio decoding
-    functionality of a QMediaService.
-
-    \preliminary
-
-    The functionality provided by this control is exposed to application
-    code through the QAudioDecoder class.
-
-    The interface name of QAudioDecoderControl is \c org.qt-project.qt.audiodecodercontrol/5.0 as
-    defined in QAudioDecoderControl_iid.
-
-    \sa QMediaService::requestControl(), QAudioDecoder
-*/
-
-/*!
-    \macro QAudioDecoderControl_iid
-
-    \c org.qt-project.qt.audiodecodercontrol/5.0
-
-    Defines the interface name of the QAudioDecoderControl class.
-
-    \relates QAudioDecoderControl
-*/
-
-/*!
-    Destroys an audio decoder control.
-*/
-QAudioDecoderControl::~QAudioDecoderControl()
-{
-}
-
-/*!
-    Constructs a new audio decoder control with the given \a parent.
-*/
-QAudioDecoderControl::QAudioDecoderControl(QObject *parent):
-    QMediaControl(*new QMediaControlPrivate, parent)
-{
-}
-
-/*!
-    \fn QAudioDecoderControl::state() const
-
-    Returns the state of a player control.
-*/
-
-/*!
-    \fn QAudioDecoderControl::stateChanged(QAudioDecoder::State state)
-
-    Signals that the \a state of a player control has changed.
-
-    \sa state()
-*/
-
-/*!
-    \fn QAudioDecoderControl::sourceFilename() const
-
-    Returns the current media source filename, or a null QString if none (or a device)
-*/
-
-/*!
-    \fn QAudioDecoderControl::setSourceFilename(const QString &fileName)
-
-    Sets the current source to \a fileName.  Changing the source will
-    stop any current decoding and discard any buffers.
-
-    Sources are exclusive, so only one can be set.
-*/
-
-/*!
-    \fn QAudioDecoderControl::sourceDevice() const
-
-    Returns the current media source QIODevice, or 0 if none (or a file).
-*/
-
-/*!
-    \fn QAudioDecoderControl::setSourceDevice(QIODevice *device)
-
-    Sets the current source to \a device.  Changing the source will
-    stop any current decoding and discard any buffers.
-
-    Sources are exclusive, so only one can be set.
-*/
-
-/*!
-    \fn QAudioDecoderControl::start()
-
-    Starts decoding the current media.
-
-    If successful the player control will immediately enter the \l {QAudioDecoder::DecodingState}
-    {decoding} state.
-
-    \sa state(), read()
-*/
-
-/*!
-    \fn QAudioDecoderControl::stop()
-
-    Stops playback of the current media and discards any buffers.
-
-    If successful the player control will immediately enter the \l {QAudioDecoder::StoppedState}
-    {stopped} state.
-*/
-
-/*!
-    \fn QAudioDecoderControl::error(int error, const QString &errorString)
-
-    Signals that an \a error has occurred.  The \a errorString provides a more detailed explanation.
-*/
-
-/*!
-    \fn QAudioDecoderControl::bufferAvailableChanged(bool available)
-
-    Signals that the bufferAvailable property has changed to \a available.
-*/
-
-/*!
-    \fn QAudioDecoderControl::bufferReady()
-
-    Signals that a new buffer is ready for reading.
-*/
-
-/*!
-    \fn QAudioDecoderControl::bufferAvailable() const
-
-    Returns true if a buffer is available to be read,
-    and false otherwise.  If there is no buffer available, calling
-    the \l read() function may block until a buffer is available or
-    the end of the media is reached
-*/
-
-/*!
-    \fn QAudioDecoderControl::sourceChanged()
-
-    Signals that the current source of the decoder has changed.
-
-    \sa sourceFilename(), sourceDevice()
-*/
-
-/*!
-    \fn QAudioDecoderControl::formatChanged(const QAudioFormat &format)
-
-    Signals that the current audio format of the decoder has changed to \a format.
-
-    \sa audioFormat(), setAudioFormat()
-*/
-
-/*!
-    \fn void QAudioDecoderControl::finished()
-
-    Signals that the decoding has finished successfully.
-    If decoding fails, error signal is emitted instead.
-
-    \sa start(), stop(), error()
-*/
-
-/*!
-    \fn void QAudioDecoderControl::positionChanged(qint64 position)
-
-    Signals that the current \a position of the decoder has changed.
-
-    \sa durationChanged()
-*/
-
-/*!
-    \fn void QAudioDecoderControl::durationChanged(qint64 duration)
-
-    Signals that the estimated \a duration of the decoded data has changed.
-
-    \sa positionChanged()
-*/
-
-/*!
-    \fn QAudioDecoderControl::audioFormat() const
-    Returns the current audio format of the decoded stream.
-
-    Any buffers returned should have this format.
-
-    \sa setAudioFormat(), formatChanged()
-*/
-
-/*!
-    \fn QAudioDecoderControl::setAudioFormat(const QAudioFormat &format)
-    Set the desired audio format for decoded samples to \a format.
-
-    If the decoder does not support this format, \l error() will
-    be set to \c FormatError.
-
-    If you do not specify a format, the format of the decoded
-    audio itself will be used.  Otherwise, some format conversion
-    will be applied.
-
-    If you wish to reset the decoded format to that of the original
-    audio file, you can specify an invalid \a format.
-*/
-
-/*!
-    \fn QAudioDecoderControl::read()
-    Read a buffer from the decoder. Returns invalid buffer on failure.
-*/
-
-/*!
-    \fn QAudioDecoderControl::position() const
-    Returns position (in milliseconds) of the last buffer read from
-    the decoder or -1 if no buffers have been read.
-*/
-
-/*!
-    \fn QAudioDecoderControl::duration() const
-    Returns total duration (in milliseconds) of the audio stream
-    or -1 if not available.
-*/
-
-#include "moc_qaudiodecodercontrol_p.cpp"
-QT_END_NAMESPACE
-
diff --git a/src/multimedia/controls/qaudiodecodercontrol_p.h b/src/multimedia/controls/qaudiodecodercontrol_p.h
deleted file mode 100644
index 00f6f95..0000000
--- a/src/multimedia/controls/qaudiodecodercontrol_p.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QAUDIODECODERCONTROL_H
-#define QAUDIODECODERCONTROL_H
-
-#include "qmediacontrol.h"
-#include <private/qaudiodecoder_p.h>
-
-#include <QtCore/qpair.h>
-
-#include "qaudiobuffer.h"
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Multimedia)
-
-class QIODevice;
-class Q_MULTIMEDIA_EXPORT QAudioDecoderControl : public QMediaControl
-{
-    Q_OBJECT
-
-public:
-    ~QAudioDecoderControl();
-
-    virtual QAudioDecoder::State state() const = 0;
-
-    virtual QString sourceFilename() const = 0;
-    virtual void setSourceFilename(const QString &fileName) = 0;
-
-    virtual QIODevice* sourceDevice() const = 0;
-    virtual void setSourceDevice(QIODevice *device) = 0;
-
-    virtual void start() = 0;
-    virtual void stop() = 0;
-
-    virtual QAudioFormat audioFormat() const = 0;
-    virtual void setAudioFormat(const QAudioFormat &format) = 0;
-
-    virtual QAudioBuffer read() = 0;
-    virtual bool bufferAvailable() const = 0;
-
-    virtual qint64 position() const = 0;
-    virtual qint64 duration() const = 0;
-
-Q_SIGNALS:
-    void stateChanged(QAudioDecoder::State newState);
-    void formatChanged(const QAudioFormat &format);
-    void sourceChanged();
-
-    void error(int error, const QString &errorString);
-
-    void bufferReady();
-    void bufferAvailableChanged(bool available);
-    void finished();
-
-    void positionChanged(qint64 position);
-    void durationChanged(qint64 duration);
-
-protected:
-    QAudioDecoderControl(QObject* parent = 0);
-};
-
-#define QAudioDecoderControl_iid "org.qt-project.qt.audiodecodercontrol/5.0"
-Q_MEDIA_DECLARE_CONTROL(QAudioDecoderControl, QAudioDecoderControl_iid)
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif  // QAUDIODECODERCONTROL_H
diff --git a/src/plugins/gstreamer/audiodecoder/qgstreameraudiodecodercontrol.h b/src/plugins/gstreamer/audiodecoder/qgstreameraudiodecodercontrol.h
index bee39aa..57429e2 100644
--- a/src/plugins/gstreamer/audiodecoder/qgstreameraudiodecodercontrol.h
+++ b/src/plugins/gstreamer/audiodecoder/qgstreameraudiodecodercontrol.h
@@ -47,8 +47,8 @@
 
 #include <qaudioformat.h>
 #include <qaudiobuffer.h>
-#include <private/qaudiodecoder_p.h>
-#include <private/qaudiodecodercontrol_p.h>
+#include <qaudiodecoder.h>
+#include <qaudiodecodercontrol.h>
 
 #include <limits.h>
 
diff --git a/src/plugins/gstreamer/audiodecoder/qgstreameraudiodecodersession.h b/src/plugins/gstreamer/audiodecoder/qgstreameraudiodecodersession.h
index 2c491cb..301123d 100644
--- a/src/plugins/gstreamer/audiodecoder/qgstreameraudiodecodersession.h
+++ b/src/plugins/gstreamer/audiodecoder/qgstreameraudiodecodersession.h
@@ -46,7 +46,7 @@
 #include <QtCore/qmutex.h>
 #include "qgstreameraudiodecodercontrol.h"
 #include <private/qgstreamerbushelper_p.h>
-#include <private/qaudiodecoder_p.h>
+#include "qaudiodecoder.h"
 
 #if defined(HAVE_GST_APPSRC)
 #include "qgstappsrc.h"
diff --git a/tests/auto/integration/qaudiodecoderbackend/tst_qaudiodecoderbackend.cpp b/tests/auto/integration/qaudiodecoderbackend/tst_qaudiodecoderbackend.cpp
index e437019..a901520 100644
--- a/tests/auto/integration/qaudiodecoderbackend/tst_qaudiodecoderbackend.cpp
+++ b/tests/auto/integration/qaudiodecoderbackend/tst_qaudiodecoderbackend.cpp
@@ -41,7 +41,7 @@
 
 #include <QtTest/QtTest>
 #include <QDebug>
-#include "qaudiodecoder_p.h"
+#include "qaudiodecoder.h"
 
 #define TEST_FILE_NAME "testdata/test.wav"
 
diff --git a/tests/auto/unit/qaudiodecoder/tst_qaudiodecoder.cpp b/tests/auto/unit/qaudiodecoder/tst_qaudiodecoder.cpp
index edc2501..43c51e3 100644
--- a/tests/auto/unit/qaudiodecoder/tst_qaudiodecoder.cpp
+++ b/tests/auto/unit/qaudiodecoder/tst_qaudiodecoder.cpp
@@ -43,7 +43,7 @@
 #include <QtCore/QString>
 #include <QtTest/QtTest>
 
-#include "qaudiodecoder_p.h"
+#include "qaudiodecoder.h"
 #include "mockaudiodecoderservice.h"
 #include "mockmediaserviceprovider.h"
 
diff --git a/tests/auto/unit/qmultimedia_common/mockaudiodecodercontrol.h b/tests/auto/unit/qmultimedia_common/mockaudiodecodercontrol.h
index f0b0adc..c0313da 100644
--- a/tests/auto/unit/qmultimedia_common/mockaudiodecodercontrol.h
+++ b/tests/auto/unit/qmultimedia_common/mockaudiodecodercontrol.h
@@ -43,7 +43,7 @@
 #define MOCKAUDIODECODERCONTROL_H
 
 #include "qmediacontrol.h"
-#include <private/qaudiodecodercontrol_p.h>
+#include "qaudiodecodercontrol.h"
 
 #include <QtCore/qpair.h>