diff --git a/src/imports/multimedia/multimedia.pro b/src/imports/multimedia/multimedia.pro
index 59c9853..45c10fa 100644
--- a/src/imports/multimedia/multimedia.pro
+++ b/src/imports/multimedia/multimedia.pro
@@ -12,7 +12,6 @@ LIBS += -lQtMultimediaQuick_p
 
 HEADERS += \
         qdeclarativeaudio_p.h \
-        qdeclarativemediabase_p.h \
         qdeclarativemediametadata_p.h \
         qdeclarativevideooutput_p.h \
         qsgvideonode_i420.h \
@@ -34,7 +33,6 @@ HEADERS += \
 SOURCES += \
         multimedia.cpp \
         qdeclarativeaudio.cpp \
-        qdeclarativemediabase.cpp \
         qdeclarativevideooutput.cpp \
         qsgvideonode_i420.cpp \
         qsgvideonode_rgb.cpp \
diff --git a/src/imports/multimedia/qdeclarativeaudio.cpp b/src/imports/multimedia/qdeclarativeaudio.cpp
index e1ab6e8..d34d450 100644
--- a/src/imports/multimedia/qdeclarativeaudio.cpp
+++ b/src/imports/multimedia/qdeclarativeaudio.cpp
@@ -38,14 +38,131 @@
 ** $QT_END_LICENSE$
 **
 ****************************************************************************/
+#include <QtDeclarative/qdeclarativeinfo.h>
 
 #include "qdeclarativeaudio_p.h"
 
 #include <qmediaplayercontrol.h>
 #include <qmediaavailabilitycontrol.h>
 
+#include <qmediaservice.h>
+#include <private/qmediaserviceprovider_p.h>
+#include <qmetadatareadercontrol.h>
+#include <qmediaavailabilitycontrol.h>
+
+#include "qdeclarativemediametadata_p.h"
+
+#include <QTimerEvent>
+
 QT_BEGIN_NAMESPACE
 
+
+class QDeclarativeMediaBaseObject : public QMediaObject
+{
+public:
+    QDeclarativeMediaBaseObject(QMediaService *service)
+        : QMediaObject(0, service)
+    {
+    }
+};
+
+class QDeclarativeMediaBasePlayerControl : public QMediaPlayerControl
+{
+public:
+    QDeclarativeMediaBasePlayerControl(QObject *parent)
+        : QMediaPlayerControl(parent)
+    {
+    }
+
+    QMediaPlayer::State state() const { return QMediaPlayer::StoppedState; }
+    QMediaPlayer::MediaStatus mediaStatus() const { return QMediaPlayer::NoMedia; }
+
+    qint64 duration() const { return 0; }
+    qint64 position() const { return 0; }
+    void setPosition(qint64) {}
+    int volume() const { return 0; }
+    void setVolume(int) {}
+    bool isMuted() const { return false; }
+    void setMuted(bool) {}
+    int bufferStatus() const { return 0; }
+    bool isAudioAvailable() const { return false; }
+    bool isVideoAvailable() const { return false; }
+    bool isSeekable() const { return false; }
+    QMediaTimeRange availablePlaybackRanges() const { return QMediaTimeRange(); }
+    qreal playbackRate() const { return 1; }
+    void setPlaybackRate(qreal) {}
+    QMediaContent media() const { return QMediaContent(); }
+    const QIODevice *mediaStream() const { return 0; }
+    void setMedia(const QMediaContent &, QIODevice *) {}
+
+    void play() {}
+    void pause() {}
+    void stop() {}
+};
+
+class QDeclarativeMediaBaseAvailabilityControl : public QMediaAvailabilityControl
+{
+public:
+    QDeclarativeMediaBaseAvailabilityControl(bool available)
+        : m_available(available)
+    {
+    }
+
+    QtMultimedia::AvailabilityError availability() const
+    {
+        return m_available ? QtMultimedia::NoError : QtMultimedia::ServiceMissingError;
+    }
+
+private:
+    bool m_available;
+};
+
+class QDeclarativeMediaBaseMetaDataControl : public QMetaDataReaderControl
+{
+public:
+    QDeclarativeMediaBaseMetaDataControl(QObject *parent)
+        : QMetaDataReaderControl(parent)
+    {
+    }
+
+    bool isMetaDataAvailable() const { return false; }
+
+    QVariant metaData(const QString &) const { return QVariant(); }
+    QStringList availableMetaData() const { return QStringList(); }
+};
+
+class QDeclarativeMediaBaseAnimation : public QObject
+{
+public:
+    QDeclarativeMediaBaseAnimation(QDeclarativeAudio *media)
+        : m_media(media)
+    {
+    }
+
+    void start() { if (!m_timer.isActive()) m_timer.start(500, this); }
+    void stop() { m_timer.stop(); }
+
+protected:
+    void timerEvent(QTimerEvent *event)
+    {
+        if (event->timerId() == m_timer.timerId()) {
+            event->accept();
+
+            if (m_media->m_playbackState == QMediaPlayer::PlayingState)
+                emit m_media->positionChanged();
+            if (m_media->m_status == QMediaPlayer::BufferingMedia || QMediaPlayer::StalledMedia)
+                emit m_media->bufferProgressChanged();
+        } else {
+            QObject::timerEvent(event);
+        }
+    }
+
+private:
+    QDeclarativeAudio *m_media;
+    QBasicTimer m_timer;
+};
+
+
 /*!
     \qmlclass MediaPlayer
     \brief The MediaPlayer element allows you to add media playback to a scene.
@@ -161,12 +278,38 @@ void QDeclarativeAudio::_q_availabilityChanged(QtMultimedia::AvailabilityError)
 
 QDeclarativeAudio::QDeclarativeAudio(QObject *parent)
     : QObject(parent)
+    , m_autoPlay(false)
+    , m_autoLoad(true)
+    , m_loaded(false)
+    , m_muted(false)
+    , m_complete(false)
+    , m_loopCount(1)
+    , m_runningCount(0)
+    , m_position(0)
+    , m_vol(1.0)
+    , m_playbackRate(1.0)
+    , m_mediaService(0)
+    , m_playerControl(0)
+    , m_mediaObject(0)
+    , m_mediaProvider(0)
+    , m_metaDataControl(0)
+    , m_animation(0)
+    , m_availabilityControl(0)
+    , m_playbackState(QMediaPlayer::StoppedState)
+    , m_status(QMediaPlayer::NoMedia)
+    , m_error(QMediaPlayer::ServiceMissingError)
 {
 }
 
 QDeclarativeAudio::~QDeclarativeAudio()
 {
-    shutdown();
+    delete m_mediaObject;
+    m_metaData.reset();
+
+    if (m_mediaProvider)
+        m_mediaProvider->releaseService(m_mediaService);
+
+    delete m_animation;
 }
 
 /*!
@@ -198,6 +341,217 @@ QDeclarativeAudio::Availability QDeclarativeAudio::availability() const
     return Available;
 }
 
+QUrl QDeclarativeAudio::source() const
+{
+    return m_source;
+}
+
+bool QDeclarativeAudio::autoPlay() const
+{
+    return m_autoPlay;
+}
+
+void QDeclarativeAudio::setAutoPlay(bool autoplay)
+{
+    if (m_autoPlay == autoplay)
+        return;
+
+    m_autoPlay = autoplay;
+    emit autoPlayChanged();
+}
+
+
+void QDeclarativeAudio::setSource(const QUrl &url)
+{
+    if (url == m_source)
+        return;
+
+    m_source = url;
+    m_loaded = false;
+    if (m_complete && (m_autoLoad || url.isEmpty() || m_autoPlay)) {
+        if (m_error != QMediaPlayer::ServiceMissingError && m_error != QMediaPlayer::NoError) {
+            m_error = QMediaPlayer::NoError;
+            m_errorString = QString();
+
+            emit errorChanged();
+        }
+
+        m_playerControl->setMedia(m_source, 0);
+        m_loaded = true;
+    }
+    else
+        emit sourceChanged();
+
+    if (m_autoPlay) m_playerControl->play();
+}
+
+bool QDeclarativeAudio::isAutoLoad() const
+{
+    return m_autoLoad;
+}
+
+void QDeclarativeAudio::setAutoLoad(bool autoLoad)
+{
+    if (m_autoLoad == autoLoad)
+        return;
+
+    m_autoLoad = autoLoad;
+    emit autoLoadChanged();
+}
+
+int QDeclarativeAudio::loopCount() const
+{
+    return m_loopCount;
+}
+
+void QDeclarativeAudio::setLoopCount(int loopCount)
+{
+    if (loopCount == 0)
+        loopCount = 1;
+    else if (loopCount < -1)
+        loopCount = -1;
+
+    if (m_loopCount == loopCount) {
+        return;
+    }
+    m_loopCount = loopCount;
+    m_runningCount = loopCount - 1;
+    emit loopCountChanged();
+}
+
+void QDeclarativeAudio::setPlaybackState(QMediaPlayer::State playbackState)
+{
+    if (m_playbackState == playbackState)
+        return;
+
+    if (m_complete) {
+        switch (playbackState){
+        case (QMediaPlayer::PlayingState):
+            if (!m_loaded) {
+                m_playerControl->setMedia(m_source, 0);
+                m_playerControl->setPosition(m_position);
+                m_loaded = true;
+            }
+            m_playerControl->play();
+            break;
+
+        case (QMediaPlayer::PausedState):
+            if (!m_loaded) {
+                m_playerControl->setMedia(m_source, 0);
+                m_playerControl->setPosition(m_position);
+                m_loaded = true;
+            }
+            m_playerControl->pause();
+            break;
+
+        case (QMediaPlayer::StoppedState):
+            m_playerControl->stop();
+        }
+    }
+}
+
+int QDeclarativeAudio::duration() const
+{
+    return !m_complete ? 0 : m_playerControl->duration();
+}
+
+int QDeclarativeAudio::position() const
+{
+    return !m_complete ? m_position : m_playerControl->position();
+}
+
+void QDeclarativeAudio::setPosition(int position)
+{
+    if (this->position() == position)
+        return;
+
+    m_position = position;
+    if (m_complete)
+        m_playerControl->setPosition(m_position);
+    else
+        emit positionChanged();
+}
+
+qreal QDeclarativeAudio::volume() const
+{
+    return !m_complete ? m_vol : qreal(m_playerControl->volume()) / 100;
+}
+
+void QDeclarativeAudio::setVolume(qreal volume)
+{
+    if (volume < 0 || volume > 1) {
+        qmlInfo(this) << tr("volume should be between 0.0 and 1.0");
+        return;
+    }
+
+    if (m_vol == volume)
+        return;
+
+    m_vol = volume;
+
+    if (m_complete)
+        m_playerControl->setVolume(qRound(volume * 100));
+    else
+        emit volumeChanged();
+}
+
+bool QDeclarativeAudio::isMuted() const
+{
+    return !m_complete ? m_muted : m_playerControl->isMuted();
+}
+
+void QDeclarativeAudio::setMuted(bool muted)
+{
+    if (m_muted == muted)
+        return;
+
+    m_muted = muted;
+
+    if (m_complete)
+        m_playerControl->setMuted(muted);
+    else
+        emit mutedChanged();
+}
+
+qreal QDeclarativeAudio::bufferProgress() const
+{
+    return !m_complete ? 0 : qreal(m_playerControl->bufferStatus()) / 100;
+}
+
+bool QDeclarativeAudio::isSeekable() const
+{
+    return !m_complete ? false : m_playerControl->isSeekable();
+}
+
+qreal QDeclarativeAudio::playbackRate() const
+{
+    return m_playbackRate;
+}
+
+void QDeclarativeAudio::setPlaybackRate(qreal rate)
+{
+    if (m_playbackRate == rate)
+        return;
+
+    m_playbackRate = rate;
+
+    if (m_complete)
+        m_playerControl->setPlaybackRate(m_playbackRate);
+    else
+        emit playbackRateChanged();
+}
+
+QString QDeclarativeAudio::errorString() const
+{
+    return m_errorString;
+}
+
+QDeclarativeMediaMetaData *QDeclarativeAudio::metaData() const
+{
+    return m_metaData.data();
+}
+
+
 /*!
     \qmlmethod QtMultimedia5::Audio::play()
 
@@ -428,7 +782,63 @@ QDeclarativeAudio::Error QDeclarativeAudio::error() const
 
 void QDeclarativeAudio::classBegin()
 {
-    setObject(this);
+    if ((m_mediaProvider = QMediaServiceProvider::defaultServiceProvider()) != 0) {
+        m_mediaService = m_mediaProvider->requestService(Q_MEDIASERVICE_MEDIAPLAYER);
+        if (m_mediaService != 0) {
+            m_playerControl = qobject_cast<QMediaPlayerControl *>(
+                    m_mediaService->requestControl(QMediaPlayerControl_iid));
+            m_metaDataControl = qobject_cast<QMetaDataReaderControl *>(
+                    m_mediaService->requestControl(QMetaDataReaderControl_iid));
+            m_mediaObject = new QDeclarativeMediaBaseObject(m_mediaService);
+            m_availabilityControl = m_mediaService->requestControl<QMediaAvailabilityControl*>();
+        }
+    }
+
+    bool realPlayer = m_playerControl;
+
+    if (m_playerControl) {
+        QObject::connect(m_playerControl, SIGNAL(stateChanged(QMediaPlayer::State)),
+                this, SLOT(_q_statusChanged()));
+        QObject::connect(m_playerControl, SIGNAL(mediaStatusChanged(QMediaPlayer::MediaStatus)),
+                this, SLOT(_q_statusChanged()));
+        QObject::connect(m_playerControl, SIGNAL(mediaChanged(QMediaContent)),
+                this, SIGNAL(sourceChanged()));
+        QObject::connect(m_playerControl, SIGNAL(durationChanged(qint64)),
+                this, SIGNAL(durationChanged()));
+        QObject::connect(m_playerControl, SIGNAL(positionChanged(qint64)),
+                this, SIGNAL(positionChanged()));
+        QObject::connect(m_playerControl, SIGNAL(volumeChanged(int)),
+                this, SIGNAL(volumeChanged()));
+        QObject::connect(m_playerControl, SIGNAL(mutedChanged(bool)),
+                this, SIGNAL(mutedChanged()));
+        QObject::connect(m_playerControl, SIGNAL(bufferStatusChanged(int)),
+                this, SIGNAL(bufferProgressChanged()));
+        QObject::connect(m_playerControl, SIGNAL(seekableChanged(bool)),
+                this, SIGNAL(seekableChanged()));
+        QObject::connect(m_playerControl, SIGNAL(playbackRateChanged(qreal)),
+                this, SIGNAL(playbackRateChanged()));
+        QObject::connect(m_playerControl, SIGNAL(error(int,QString)),
+                this, SLOT(_q_error(int,QString)));
+
+        m_animation = new QDeclarativeMediaBaseAnimation(this);
+        m_error = QMediaPlayer::NoError;
+    } else {
+        m_playerControl = new QDeclarativeMediaBasePlayerControl(this);
+    }
+
+    if (!m_metaDataControl)
+        m_metaDataControl = new QDeclarativeMediaBaseMetaDataControl(this);
+
+    if (!m_availabilityControl)
+        m_availabilityControl = new QDeclarativeMediaBaseAvailabilityControl(realPlayer);
+
+    QObject::connect(m_availabilityControl, SIGNAL(availabilityChanged(QtMultimedia::AvailabilityError)),
+                     this, SLOT(_q_availabilityChanged(QtMultimedia::AvailabilityError)));
+
+    m_metaData.reset(new QDeclarativeMediaMetaData(m_metaDataControl));
+
+    QObject::connect(m_metaDataControl, SIGNAL(metaDataChanged()),
+            m_metaData.data(), SIGNAL(metaDataChanged()));
 
     if (m_mediaService) {
         connect(m_playerControl, SIGNAL(audioAvailableChanged(bool)),
@@ -442,9 +852,79 @@ void QDeclarativeAudio::classBegin()
 
 void QDeclarativeAudio::componentComplete()
 {
-    QDeclarativeMediaBase::componentComplete();
+    if (!qFuzzyCompare(m_vol, qreal(1.0)))
+        m_playerControl->setVolume(m_vol * 100);
+    if (m_muted)
+        m_playerControl->setMuted(m_muted);
+    if (!qFuzzyCompare(m_playbackRate, qreal(1.0)))
+        m_playerControl->setPlaybackRate(m_playbackRate);
+
+    if (!m_source.isEmpty() && (m_autoLoad || m_autoPlay)) {
+        m_playerControl->setMedia(m_source, 0);
+        m_loaded = true;
+        if (m_position > 0)
+            m_playerControl->setPosition(m_position);
+    }
+
+    m_complete = true;
+
+    if (m_autoPlay) {
+        if (m_source.isEmpty()) {
+            m_playerControl->stop();
+        } else {
+            m_playerControl->play();
+        }
+    }
 }
 
+void QDeclarativeAudio::_q_statusChanged()
+{
+    if (m_playerControl->mediaStatus() == QMediaPlayer::EndOfMedia && m_runningCount != 0) {
+        m_runningCount -= 1;
+        m_playerControl->play();
+    }
+    const QMediaPlayer::MediaStatus oldStatus = m_status;
+    const QMediaPlayer::State lastPlaybackState = m_playbackState;
+
+    const QMediaPlayer::State state = m_playerControl->state();
+
+    m_playbackState = state;
+
+    m_status = m_playerControl->mediaStatus();
+
+    if (m_status != oldStatus)
+        emit statusChanged();
+
+    if (lastPlaybackState != state) {
+
+        if (lastPlaybackState == QMediaPlayer::StoppedState)
+            m_runningCount = m_loopCount - 1;
+
+        switch (state) {
+        case QMediaPlayer::StoppedState:
+            emit stopped();
+            break;
+        case QMediaPlayer::PausedState:
+            emit paused();
+            break;
+        case QMediaPlayer::PlayingState:
+            emit playing();
+            break;
+        }
+
+        emit playbackStateChanged();
+    }
+
+    // Check
+    if ((state == QMediaPlayer::PlayingState)
+            || m_status == QMediaPlayer::BufferingMedia
+            || m_status == QMediaPlayer::StalledMedia) {
+        m_animation->start();
+    }
+    else {
+        m_animation->stop();
+    }
+}
 
 /*!
     \qmlproperty string QtMultimedia5::Audio::errorString
diff --git a/src/imports/multimedia/qdeclarativeaudio_p.h b/src/imports/multimedia/qdeclarativeaudio_p.h
index fdbadbc..7dae410 100644
--- a/src/imports/multimedia/qdeclarativeaudio_p.h
+++ b/src/imports/multimedia/qdeclarativeaudio_p.h
@@ -57,15 +57,22 @@
 #include <QtQml/qqmlparserstatus.h>
 #include <QtQml/qqml.h>
 
-#include "qdeclarativemediabase_p.h"
+#include <qmediaplayer.h>
 
 QT_BEGIN_HEADER
 
 QT_BEGIN_NAMESPACE
 
 class QTimerEvent;
-
-class QDeclarativeAudio : public QObject, public QDeclarativeMediaBase, public QQmlParserStatus
+class QMediaPlayerControl;
+class QMediaService;
+class QMediaServiceProvider;
+class QMetaDataReaderControl;
+class QDeclarativeMediaBaseAnimation;
+class QDeclarativeMediaMetaData;
+class QMediaAvailabilityControl;
+
+class QDeclarativeAudio : public QObject, public QQmlParserStatus
 {
     Q_OBJECT
     Q_PROPERTY(QUrl source READ source WRITE setSource NOTIFY sourceChanged)
@@ -120,7 +127,7 @@ public:
 
     enum Loop
     {
-        Infinite = QDeclarativeMediaBase::INFINITE
+        Infinite = -1
     };
 
     enum PlaybackState
@@ -146,6 +153,7 @@ public:
     Status status() const;
     Error error() const;
     PlaybackState playbackState() const;
+    void setPlaybackState(QMediaPlayer::State playbackState);
 
     void classBegin();
     void componentComplete();
@@ -154,6 +162,40 @@ public:
 
     Availability availability() const;
 
+    QUrl source() const;
+    void setSource(const QUrl &url);
+
+    int loopCount() const;
+    void setLoopCount(int loopCount);
+
+    int duration() const;
+
+    int position() const;
+    void setPosition(int position);
+
+    qreal volume() const;
+    void setVolume(qreal volume);
+
+    bool isMuted() const;
+    void setMuted(bool muted);
+
+    qreal bufferProgress() const;
+
+    bool isSeekable() const;
+
+    qreal playbackRate() const;
+    void setPlaybackRate(qreal rate);
+
+    QString errorString() const;
+
+    QDeclarativeMediaMetaData *metaData() const;
+
+    bool isAutoLoad() const;
+    void setAutoLoad(bool autoLoad);
+
+    bool autoPlay() const;
+    void setAutoPlay(bool autoplay);
+
 public Q_SLOTS:
     void play();
     void pause();
@@ -196,12 +238,39 @@ Q_SIGNALS:
 private Q_SLOTS:
     void _q_error(int, const QString &);
     void _q_availabilityChanged(QtMultimedia::AvailabilityError);
+    void _q_statusChanged();
 
 private:
     Q_DISABLE_COPY(QDeclarativeAudio)
-    Q_PRIVATE_SLOT(mediaBase(), void _q_statusChanged())
 
-    inline QDeclarativeMediaBase *mediaBase() { return this; }
+    bool m_autoPlay;
+    bool m_autoLoad;
+    bool m_loaded;
+    bool m_muted;
+    bool m_complete;
+    int m_loopCount;
+    int m_runningCount;
+    int m_position;
+    qreal m_vol;
+    qreal m_playbackRate;
+    QMediaService *m_mediaService;
+    QMediaPlayerControl *m_playerControl;
+
+    QMediaObject *m_mediaObject;
+    QMediaServiceProvider *m_mediaProvider;
+    QMetaDataReaderControl *m_metaDataControl;
+    QDeclarativeMediaBaseAnimation *m_animation;
+    QScopedPointer<QDeclarativeMediaMetaData> m_metaData;
+
+    QMediaAvailabilityControl *m_availabilityControl;
+
+    QMediaPlayer::State m_playbackState;
+    QMediaPlayer::MediaStatus m_status;
+    QMediaPlayer::Error m_error;
+    QString m_errorString;
+    QUrl m_source;
+
+    friend class QDeclarativeMediaBaseAnimation;
 };
 
 QT_END_NAMESPACE
diff --git a/src/imports/multimedia/qdeclarativemediabase.cpp b/src/imports/multimedia/qdeclarativemediabase.cpp
deleted file mode 100644
index 2ec9cc1..0000000
--- a/src/imports/multimedia/qdeclarativemediabase.cpp
+++ /dev/null
@@ -1,563 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qdeclarativemediabase_p.h"
-
-#include <QtCore/qcoreevent.h>
-#include <QtCore/qurl.h>
-#include <QtQml/qqmlinfo.h>
-
-#include <qmediaplayercontrol.h>
-#include <qmediaservice.h>
-#include <private/qmediaserviceprovider_p.h>
-#include <qmetadatareadercontrol.h>
-#include <qmediaavailabilitycontrol.h>
-
-#include "qdeclarativemediametadata_p.h"
-
-QT_BEGIN_NAMESPACE
-
-
-class QDeclarativeMediaBaseObject : public QMediaObject
-{
-public:
-    QDeclarativeMediaBaseObject(QMediaService *service)
-        : QMediaObject(0, service)
-    {
-    }
-};
-
-class QDeclarativeMediaBasePlayerControl : public QMediaPlayerControl
-{
-public:
-    QDeclarativeMediaBasePlayerControl(QObject *parent)
-        : QMediaPlayerControl(parent)
-    {
-    }
-
-    QMediaPlayer::State state() const { return QMediaPlayer::StoppedState; }
-    QMediaPlayer::MediaStatus mediaStatus() const { return QMediaPlayer::NoMedia; }
-
-    qint64 duration() const { return 0; }
-    qint64 position() const { return 0; }
-    void setPosition(qint64) {}
-    int volume() const { return 0; }
-    void setVolume(int) {}
-    bool isMuted() const { return false; }
-    void setMuted(bool) {}
-    int bufferStatus() const { return 0; }
-    bool isAudioAvailable() const { return false; }
-    bool isVideoAvailable() const { return false; }
-    bool isSeekable() const { return false; }
-    QMediaTimeRange availablePlaybackRanges() const { return QMediaTimeRange(); }
-    qreal playbackRate() const { return 1; }
-    void setPlaybackRate(qreal) {}
-    QMediaContent media() const { return QMediaContent(); }
-    const QIODevice *mediaStream() const { return 0; }
-    void setMedia(const QMediaContent &, QIODevice *) {}
-
-    void play() {}
-    void pause() {}
-    void stop() {}
-};
-
-class QDeclarativeMediaBaseAvailabilityControl : public QMediaAvailabilityControl
-{
-public:
-    QDeclarativeMediaBaseAvailabilityControl(bool available)
-        : m_available(available)
-    {
-    }
-
-    QtMultimedia::AvailabilityError availability() const
-    {
-        return m_available ? QtMultimedia::NoError : QtMultimedia::ServiceMissingError;
-    }
-
-private:
-    bool m_available;
-};
-
-class QDeclarativeMediaBaseMetaDataControl : public QMetaDataReaderControl
-{
-public:
-    QDeclarativeMediaBaseMetaDataControl(QObject *parent)
-        : QMetaDataReaderControl(parent)
-    {
-    }
-
-    bool isMetaDataAvailable() const { return false; }
-
-    QVariant metaData(const QString &) const { return QVariant(); }
-    QStringList availableMetaData() const { return QStringList(); }
-};
-
-class QDeclarativeMediaBaseAnimation : public QObject
-{
-public:
-    QDeclarativeMediaBaseAnimation(QDeclarativeMediaBase *media)
-        : m_media(media)
-    {
-    }
-
-    void start() { if (!m_timer.isActive()) m_timer.start(500, this); }
-    void stop() { m_timer.stop(); }
-
-protected:
-    void timerEvent(QTimerEvent *event)
-    {
-        if (event->timerId() == m_timer.timerId()) {
-            event->accept();
-
-            if (m_media->m_playbackState == QMediaPlayer::PlayingState)
-                emit m_media->positionChanged();
-            if (m_media->m_status == QMediaPlayer::BufferingMedia || QMediaPlayer::StalledMedia)
-                emit m_media->bufferProgressChanged();
-        } else {
-            QObject::timerEvent(event);
-        }
-    }
-
-private:
-    QDeclarativeMediaBase *m_media;
-    QBasicTimer m_timer;
-};
-
-void QDeclarativeMediaBase::_q_statusChanged()
-{
-    if (m_playerControl->mediaStatus() == QMediaPlayer::EndOfMedia && m_runningCount != 0) {
-        m_runningCount -= 1;
-        m_playerControl->play();
-    }
-    const QMediaPlayer::MediaStatus oldStatus = m_status;
-    const QMediaPlayer::State lastPlaybackState = m_playbackState;
-
-    const QMediaPlayer::State state = m_playerControl->state();
-
-    m_playbackState = state;
-
-    m_status = m_playerControl->mediaStatus();
-
-    if (m_status != oldStatus)
-        emit statusChanged();
-
-    if (lastPlaybackState != state) {
-
-        if (lastPlaybackState == QMediaPlayer::StoppedState)
-            m_runningCount = m_loopCount - 1;
-
-        switch (state) {
-        case QMediaPlayer::StoppedState:
-            emit stopped();
-            break;
-        case QMediaPlayer::PausedState:
-            emit paused();
-            break;
-        case QMediaPlayer::PlayingState:
-            emit playing();
-            break;
-        }
-
-        emit playbackStateChanged();
-    }
-
-    // Check
-    if ((state == QMediaPlayer::PlayingState)
-            || m_status == QMediaPlayer::BufferingMedia
-            || m_status == QMediaPlayer::StalledMedia) {
-        m_animation->start();
-    }
-    else {
-        m_animation->stop();
-    }
-}
-
-QDeclarativeMediaBase::QDeclarativeMediaBase()
-    : m_autoPlay(false)
-    , m_autoLoad(true)
-    , m_loaded(false)
-    , m_muted(false)
-    , m_complete(false)
-    , m_loopCount(1)
-    , m_runningCount(0)
-    , m_position(0)
-    , m_vol(1.0)
-    , m_playbackRate(1.0)
-    , m_mediaService(0)
-    , m_playerControl(0)
-    , m_qmlObject(0)
-    , m_mediaObject(0)
-    , m_mediaProvider(0)
-    , m_metaDataControl(0)
-    , m_animation(0)
-    , m_availabilityControl(0)
-    , m_playbackState(QMediaPlayer::StoppedState)
-    , m_status(QMediaPlayer::NoMedia)
-    , m_error(QMediaPlayer::ServiceMissingError)
-{
-}
-
-QDeclarativeMediaBase::~QDeclarativeMediaBase()
-{
-}
-
-void QDeclarativeMediaBase::shutdown()
-{
-    delete m_mediaObject;
-    m_metaData.reset();
-
-    if (m_mediaProvider)
-        m_mediaProvider->releaseService(m_mediaService);
-
-    delete m_animation;
-
-}
-
-void QDeclarativeMediaBase::setObject(QObject *object, const QByteArray &type)
-{
-    m_qmlObject = object;
-
-    if ((m_mediaProvider = QMediaServiceProvider::defaultServiceProvider()) != 0) {
-        m_mediaService = m_mediaProvider->requestService(type);
-        if (m_mediaService != 0) {
-            m_playerControl = qobject_cast<QMediaPlayerControl *>(
-                    m_mediaService->requestControl(QMediaPlayerControl_iid));
-            m_metaDataControl = qobject_cast<QMetaDataReaderControl *>(
-                    m_mediaService->requestControl(QMetaDataReaderControl_iid));
-            m_mediaObject = new QDeclarativeMediaBaseObject(m_mediaService);
-            m_availabilityControl = m_mediaService->requestControl<QMediaAvailabilityControl*>();
-        }
-    }
-
-    bool realPlayer = m_playerControl;
-
-    if (m_playerControl) {
-        QObject::connect(m_playerControl, SIGNAL(stateChanged(QMediaPlayer::State)),
-                object, SLOT(_q_statusChanged()));
-        QObject::connect(m_playerControl, SIGNAL(mediaStatusChanged(QMediaPlayer::MediaStatus)),
-                object, SLOT(_q_statusChanged()));
-        QObject::connect(m_playerControl, SIGNAL(mediaChanged(QMediaContent)),
-                object, SIGNAL(sourceChanged()));
-        QObject::connect(m_playerControl, SIGNAL(durationChanged(qint64)),
-                object, SIGNAL(durationChanged()));
-        QObject::connect(m_playerControl, SIGNAL(positionChanged(qint64)),
-                object, SIGNAL(positionChanged()));
-        QObject::connect(m_playerControl, SIGNAL(volumeChanged(int)),
-                object, SIGNAL(volumeChanged()));
-        QObject::connect(m_playerControl, SIGNAL(mutedChanged(bool)),
-                object, SIGNAL(mutedChanged()));
-        QObject::connect(m_playerControl, SIGNAL(bufferStatusChanged(int)),
-                object, SIGNAL(bufferProgressChanged()));
-        QObject::connect(m_playerControl, SIGNAL(seekableChanged(bool)),
-                object, SIGNAL(seekableChanged()));
-        QObject::connect(m_playerControl, SIGNAL(playbackRateChanged(qreal)),
-                object, SIGNAL(playbackRateChanged()));
-        QObject::connect(m_playerControl, SIGNAL(error(int,QString)),
-                object, SLOT(_q_error(int,QString)));
-
-        m_animation = new QDeclarativeMediaBaseAnimation(this);
-        m_error = QMediaPlayer::NoError;
-    } else {
-        m_playerControl = new QDeclarativeMediaBasePlayerControl(object);
-    }
-
-    if (!m_metaDataControl)
-        m_metaDataControl = new QDeclarativeMediaBaseMetaDataControl(object);
-
-    if (!m_availabilityControl)
-        m_availabilityControl = new QDeclarativeMediaBaseAvailabilityControl(realPlayer);
-
-    QObject::connect(m_availabilityControl, SIGNAL(availabilityChanged(QtMultimedia::AvailabilityError)),
-                     object, SLOT(_q_availabilityChanged(QtMultimedia::AvailabilityError)));
-
-    m_metaData.reset(new QDeclarativeMediaMetaData(m_metaDataControl));
-
-    QObject::connect(m_metaDataControl, SIGNAL(metaDataChanged()),
-            m_metaData.data(), SIGNAL(metaDataChanged()));
-}
-
-void QDeclarativeMediaBase::componentComplete()
-{
-    if (!qFuzzyCompare(m_vol, qreal(1.0)))
-        m_playerControl->setVolume(m_vol * 100);
-    if (m_muted)
-        m_playerControl->setMuted(m_muted);
-    if (!qFuzzyCompare(m_playbackRate, qreal(1.0)))
-        m_playerControl->setPlaybackRate(m_playbackRate);
-
-    if (!m_source.isEmpty() && (m_autoLoad || m_autoPlay)) {
-        m_playerControl->setMedia(m_source, 0);
-        m_loaded = true;
-        if (m_position > 0)
-            m_playerControl->setPosition(m_position);
-    }
-
-    m_complete = true;
-
-    if (m_autoPlay) {
-        if (m_source.isEmpty()) {
-            m_playerControl->stop();
-        } else {
-            m_playerControl->play();
-        }
-    }
-}
-
-// Properties
-
-QUrl QDeclarativeMediaBase::source() const
-{
-    return m_source;
-}
-
-bool QDeclarativeMediaBase::autoPlay() const
-{
-    return m_autoPlay;
-}
-
-void QDeclarativeMediaBase::setAutoPlay(bool autoplay)
-{
-    if (m_autoPlay == autoplay)
-        return;
-
-    m_autoPlay = autoplay;
-    emit autoPlayChanged();
-}
-
-
-void QDeclarativeMediaBase::setSource(const QUrl &url)
-{
-    if (url == m_source)
-        return;
-
-    m_source = url;
-    m_loaded = false;
-    if (m_complete && (m_autoLoad || url.isEmpty() || m_autoPlay)) {
-        if (m_error != QMediaPlayer::ServiceMissingError && m_error != QMediaPlayer::NoError) {
-            m_error = QMediaPlayer::NoError;
-            m_errorString = QString();
-
-            emit errorChanged();
-        }
-
-        m_playerControl->setMedia(m_source, 0);
-        m_loaded = true;
-    }
-    else
-        emit sourceChanged();
-
-    if (m_autoPlay) m_playerControl->play();
-}
-
-bool QDeclarativeMediaBase::isAutoLoad() const
-{
-    return m_autoLoad;
-}
-
-void QDeclarativeMediaBase::setAutoLoad(bool autoLoad)
-{
-    if (m_autoLoad == autoLoad)
-        return;
-
-    m_autoLoad = autoLoad;
-    emit autoLoadChanged();
-}
-
-int QDeclarativeMediaBase::loopCount() const
-{
-    return m_loopCount;
-}
-
-void QDeclarativeMediaBase::setLoopCount(int loopCount)
-{
-    if (loopCount == 0)
-        loopCount = 1;
-    else if (loopCount < -1)
-        loopCount = -1;
-
-    if (m_loopCount == loopCount) {
-        return;
-    }
-    m_loopCount = loopCount;
-    m_runningCount = loopCount - 1;
-    emit loopCountChanged();
-}
-
-void QDeclarativeMediaBase::setPlaybackState(QMediaPlayer::State playbackState)
-{
-    if (m_playbackState == playbackState)
-        return;
-
-    if (m_complete) {
-        switch (playbackState){
-        case (QMediaPlayer::PlayingState):
-            if (!m_loaded) {
-                m_playerControl->setMedia(m_source, 0);
-                m_playerControl->setPosition(m_position);
-                m_loaded = true;
-            }
-            m_playerControl->play();
-            break;
-
-        case (QMediaPlayer::PausedState):
-            if (!m_loaded) {
-                m_playerControl->setMedia(m_source, 0);
-                m_playerControl->setPosition(m_position);
-                m_loaded = true;
-            }
-            m_playerControl->pause();
-            break;
-
-        case (QMediaPlayer::StoppedState):
-            m_playerControl->stop();
-        }
-    }
-}
-
-QMediaPlayer::State QDeclarativeMediaBase::playbackState() const
-{
-    return m_playbackState;
-}
-
-
-int QDeclarativeMediaBase::duration() const
-{
-    return !m_complete ? 0 : m_playerControl->duration();
-}
-
-int QDeclarativeMediaBase::position() const
-{
-    return !m_complete ? m_position : m_playerControl->position();
-}
-
-void QDeclarativeMediaBase::setPosition(int position)
-{
-    if (this->position() == position)
-        return;
-
-    m_position = position;
-    if (m_complete)
-        m_playerControl->setPosition(m_position);
-    else
-        emit positionChanged();
-}
-
-qreal QDeclarativeMediaBase::volume() const
-{
-    return !m_complete ? m_vol : qreal(m_playerControl->volume()) / 100;
-}
-
-void QDeclarativeMediaBase::setVolume(qreal volume)
-{
-    if (volume < 0 || volume > 1) {
-        qmlInfo(m_qmlObject) << m_qmlObject->tr("volume should be between 0.0 and 1.0");
-        return;
-    }
-
-    if (m_vol == volume)
-        return;
-
-    m_vol = volume;
-
-    if (m_complete)
-        m_playerControl->setVolume(qRound(volume * 100));
-    else
-        emit volumeChanged();
-}
-
-bool QDeclarativeMediaBase::isMuted() const
-{
-    return !m_complete ? m_muted : m_playerControl->isMuted();
-}
-
-void QDeclarativeMediaBase::setMuted(bool muted)
-{
-    if (m_muted == muted)
-        return;
-
-    m_muted = muted;
-
-    if (m_complete)
-        m_playerControl->setMuted(muted);
-    else
-        emit mutedChanged();
-}
-
-qreal QDeclarativeMediaBase::bufferProgress() const
-{
-    return !m_complete ? 0 : qreal(m_playerControl->bufferStatus()) / 100;
-}
-
-bool QDeclarativeMediaBase::isSeekable() const
-{
-    return !m_complete ? false : m_playerControl->isSeekable();
-}
-
-qreal QDeclarativeMediaBase::playbackRate() const
-{
-    return m_playbackRate;
-}
-
-void QDeclarativeMediaBase::setPlaybackRate(qreal rate)
-{
-    if (m_playbackRate == rate)
-        return;
-
-    m_playbackRate = rate;
-
-    if (m_complete)
-        m_playerControl->setPlaybackRate(m_playbackRate);
-    else
-        emit playbackRateChanged();
-}
-
-QString QDeclarativeMediaBase::errorString() const
-{
-    return m_errorString;
-}
-
-QDeclarativeMediaMetaData *QDeclarativeMediaBase::metaData() const
-{
-    return m_metaData.data();
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/imports/multimedia/qdeclarativemediabase_p.h b/src/imports/multimedia/qdeclarativemediabase_p.h
deleted file mode 100644
index bbf1c24..0000000
--- a/src/imports/multimedia/qdeclarativemediabase_p.h
+++ /dev/null
@@ -1,193 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QDECLARATIVEMEDIABASE_P_H
-#define QDECLARATIVEMEDIABASE_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience
-// of other Qt classes.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtCore/qbasictimer.h>
-#include <qmediaplayer.h>
-#include <private/qmediaserviceprovider_p.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-class QMediaPlayerControl;
-class QMediaService;
-class QMediaServiceProvider;
-class QMetaDataReaderControl;
-class QDeclarativeMediaBaseAnimation;
-class QDeclarativeMediaMetaData;
-class QMediaAvailabilityControl;
-
-class QDeclarativeMediaBase
-{
-public:
-    enum Loop {
-        INFINITE = -1
-    };
-
-    QDeclarativeMediaBase();
-    virtual ~QDeclarativeMediaBase();
-
-    QUrl source() const;
-    void setSource(const QUrl &url);
-
-    int loopCount() const;
-    void setLoopCount(int loopCount);
-
-    QMediaPlayer::State playbackState() const;
-    void setPlaybackState(QMediaPlayer::State playbackState);
-
-    int duration() const;
-
-    int position() const;
-    void setPosition(int position);
-
-    qreal volume() const;
-    void setVolume(qreal volume);
-
-    bool isMuted() const;
-    void setMuted(bool muted);
-
-    qreal bufferProgress() const;
-
-    bool isSeekable() const;
-
-    qreal playbackRate() const;
-    void setPlaybackRate(qreal rate);
-
-    QString errorString() const;
-
-    QDeclarativeMediaMetaData *metaData() const;
-
-    void _q_statusChanged();
-
-    void _q_metaDataChanged();
-
-    void componentComplete();
-
-    bool isAutoLoad() const;
-    void setAutoLoad(bool autoLoad);
-
-    bool autoPlay() const;
-    void setAutoPlay(bool autoplay);
-
-protected:
-    void shutdown();
-
-    void setObject(QObject *object, const QByteArray &type = Q_MEDIASERVICE_MEDIAPLAYER);
-
-    virtual void sourceChanged() = 0;
-    virtual void loopCountChanged() = 0;
-
-    virtual void paused() = 0;
-    virtual void stopped() = 0;
-    virtual void playing() = 0;
-
-    virtual void autoLoadChanged() = 0;
-
-    virtual void playbackStateChanged() = 0;
-
-    virtual void statusChanged() = 0;
-
-    virtual void durationChanged() = 0;
-    virtual void positionChanged() = 0;
-
-    virtual void volumeChanged() = 0;
-    virtual void mutedChanged() = 0;
-
-    virtual void bufferProgressChanged() = 0;
-
-    virtual void seekableChanged() = 0;
-    virtual void playbackRateChanged() = 0;
-
-    virtual void errorChanged() = 0;
-
-    virtual void autoPlayChanged() = 0;
-
-    bool m_autoPlay;
-    bool m_autoLoad;
-    bool m_loaded;
-    bool m_muted;
-    bool m_complete;
-    int m_loopCount;
-    int m_runningCount;
-    int m_position;
-    qreal m_vol;
-    qreal m_playbackRate;
-    QMediaService *m_mediaService;
-    QMediaPlayerControl *m_playerControl;
-
-    QObject *m_qmlObject;
-    QMediaObject *m_mediaObject;
-    QMediaServiceProvider *m_mediaProvider;
-    QMetaDataReaderControl *m_metaDataControl;
-    QDeclarativeMediaBaseAnimation *m_animation;
-    QScopedPointer<QDeclarativeMediaMetaData> m_metaData;
-
-    QMediaAvailabilityControl *m_availabilityControl;
-
-    QMediaPlayer::State m_playbackState;
-    QMediaPlayer::MediaStatus m_status;
-    QMediaPlayer::Error m_error;
-    QString m_errorString;
-    QUrl m_source;
-
-    friend class QDeclarativeMediaBaseAnimation;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif
diff --git a/tests/auto/unit/qdeclarativeaudio/qdeclarativeaudio.pro b/tests/auto/unit/qdeclarativeaudio/qdeclarativeaudio.pro
index 6f1fb0c..0584cba 100644
--- a/tests/auto/unit/qdeclarativeaudio/qdeclarativeaudio.pro
+++ b/tests/auto/unit/qdeclarativeaudio/qdeclarativeaudio.pro
@@ -6,12 +6,10 @@ CONFIG += no_private_qt_headers_warning
 
 HEADERS += \
         $$QT.multimedia.sources/../imports/multimedia/qdeclarativeaudio_p.h \
-        $$QT.multimedia.sources/../imports/multimedia/qdeclarativemediabase_p.h \
         $$QT.multimedia.sources/../imports/multimedia/qdeclarativemediametadata_p.h
 
 SOURCES += \
         tst_qdeclarativeaudio.cpp \
-        $$QT.multimedia.sources/../imports/multimedia/qdeclarativeaudio.cpp \
-        $$QT.multimedia.sources/../imports/multimedia/qdeclarativemediabase.cpp
+        $$QT.multimedia.sources/../imports/multimedia/qdeclarativeaudio.cpp
 
 INCLUDEPATH += $$QT.multimedia.sources/../imports/multimedia