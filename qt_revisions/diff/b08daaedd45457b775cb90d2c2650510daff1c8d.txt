diff --git a/src/corelib/codecs/qtextcodec.cpp b/src/corelib/codecs/qtextcodec.cpp
index ff1db7c..071bd1e 100644
--- a/src/corelib/codecs/qtextcodec.cpp
+++ b/src/corelib/codecs/qtextcodec.cpp
@@ -842,7 +842,7 @@ QTextCodec::ConverterState::~ConverterState()
     if (flags & FreeFunction)
         (QTextCodecUnalignedPointer::decode(state_data))(this);
     else if (d)
-        qFree(d);
+        free(d);
 }
 
 /*!
diff --git a/src/corelib/codecs/qtextcodec_symbian.cpp b/src/corelib/codecs/qtextcodec_symbian.cpp
index 2b1c98f..a4628cc 100644
--- a/src/corelib/codecs/qtextcodec_symbian.cpp
+++ b/src/corelib/codecs/qtextcodec_symbian.cpp
@@ -239,7 +239,7 @@ QString QSymbianTextCodec::convertToUnicode(const char *str, int len, ConverterS
         str2 = helperBA.data();
         if (state->remainingChars > 3) { // doesn't happen usually
             memcpy(str2, state->d, state->remainingChars);
-            qFree(state->d);
+            free(state->d);
             state->d = 0;
         } else {
             char charTbl[3];
@@ -326,7 +326,7 @@ QString QSymbianTextCodec::convertToUnicode(const char *str, int len, ConverterS
         }
         const unsigned char *charPtr = remainderOfForeignText.Right(remainingChars).Ptr();
         if (remainingChars > 3) { // doesn't happen usually
-            state->d = (void*)qMalloc(remainingChars);
+            state->d = (void*)malloc(remainingChars);
             if (!state->d)
                 return QString();
             // copy characters there
diff --git a/src/corelib/global/qmalloc.cpp b/src/corelib/global/qmalloc.cpp
index 2da9e34..2ec6938 100644
--- a/src/corelib/global/qmalloc.cpp
+++ b/src/corelib/global/qmalloc.cpp
@@ -78,7 +78,7 @@ void *qReallocAligned(void *oldptr, size_t newsize, size_t oldsize, size_t align
     void *actualptr = oldptr ? static_cast<void **>(oldptr)[-1] : 0;
     if (alignment <= sizeof(void*)) {
         // special, fast case
-        void **newptr = static_cast<void **>(qRealloc(actualptr, newsize + sizeof(void*)));
+        void **newptr = static_cast<void **>(realloc(actualptr, newsize + sizeof(void*)));
         if (!newptr)
             return 0;
         if (newptr == actualptr) {
@@ -90,7 +90,7 @@ void *qReallocAligned(void *oldptr, size_t newsize, size_t oldsize, size_t align
         return newptr + 1;
     }
 
-    // qMalloc returns pointers aligned at least at sizeof(size_t) boundaries
+    // malloc returns pointers aligned at least at sizeof(size_t) boundaries
     // but usually more (8- or 16-byte boundaries).
     // So we overallocate by alignment-sizeof(size_t) bytes, so we're guaranteed to find a
     // somewhere within the first alignment-sizeof(size_t) that is properly aligned.
@@ -98,7 +98,7 @@ void *qReallocAligned(void *oldptr, size_t newsize, size_t oldsize, size_t align
     // However, we need to store the actual pointer, so we need to allocate actually size +
     // alignment anyway.
 
-    void *real = qRealloc(actualptr, newsize + alignment);
+    void *real = realloc(actualptr, newsize + alignment);
     if (!real)
         return 0;
 
diff --git a/src/corelib/io/qfilesystemengine_win.cpp b/src/corelib/io/qfilesystemengine_win.cpp
index 5d4f4c3..80f5448 100644
--- a/src/corelib/io/qfilesystemengine_win.cpp
+++ b/src/corelib/io/qfilesystemengine_win.cpp
@@ -278,7 +278,7 @@ static QString readSymLink(const QFileSystemEntry &link)
                                0);
     if (handle != INVALID_HANDLE_VALUE) {
         DWORD bufsize = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
-        REPARSE_DATA_BUFFER *rdb = (REPARSE_DATA_BUFFER*)qMalloc(bufsize);
+        REPARSE_DATA_BUFFER *rdb = (REPARSE_DATA_BUFFER*)malloc(bufsize);
         DWORD retsize = 0;
         if (::DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, 0, 0, rdb, bufsize, &retsize, 0)) {
             if (rdb->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {
@@ -296,7 +296,7 @@ static QString readSymLink(const QFileSystemEntry &link)
             if (result.size() > 4 && result.at(0) == QLatin1Char('\\') && result.at(2) == QLatin1Char('?') && result.at(3) == QLatin1Char('\\'))
                 result = result.mid(4);
         }
-        qFree(rdb);
+        free(rdb);
         CloseHandle(handle);
 
 #if !defined(QT_NO_LIBRARY)
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index 2c462cb..7a4618b 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -143,7 +143,7 @@ static inline void qt_init_symbian_apa_arguments(int &argc, char **&argv)
             TPtrC8 apaCmdLine = commandLine->TailEnd();
             int tailLen = apaCmdLine.Length();
             if (tailLen) {
-                apaTail = reinterpret_cast<char *>(qMalloc(tailLen + 1));
+                apaTail = reinterpret_cast<char *>(malloc(tailLen + 1));
                 qMemCopy(apaTail, reinterpret_cast<const char *>(apaCmdLine.Ptr()), tailLen);
                 apaTail[tailLen] = '\0';
                 apaArgv = new QVector<char *>(8);
diff --git a/src/corelib/kernel/qmetaobject.cpp b/src/corelib/kernel/qmetaobject.cpp
index 04770b7..4e71d7a 100644
--- a/src/corelib/kernel/qmetaobject.cpp
+++ b/src/corelib/kernel/qmetaobject.cpp
@@ -855,7 +855,7 @@ QMetaProperty QMetaObject::property(int index) const
                 Q_ASSERT(colon <= enum_name || *(colon-1) == ':');
                 if (colon > enum_name) {
                     int len = colon-enum_name-1;
-                    scope_buffer = (char *)qMalloc(len+1);
+                    scope_buffer = (char *)malloc(len+1);
                     qMemCopy(scope_buffer, enum_name, len);
                     scope_buffer[len] = '\0';
                     scope_name = scope_buffer;
@@ -870,7 +870,7 @@ QMetaProperty QMetaObject::property(int index) const
                 if (scope)
                     result.menum = scope->enumerator(scope->indexOfEnumerator(enum_name));
                 if (scope_buffer)
-                    qFree(scope_buffer);
+                    free(scope_buffer);
             }
         }
     }
@@ -1644,9 +1644,9 @@ bool QMetaMethod::invoke(QObject *object,
         }
 
         int nargs = 1; // include return type
-        void **args = (void **) qMalloc(paramCount * sizeof(void *));
+        void **args = (void **) malloc(paramCount * sizeof(void *));
         Q_CHECK_PTR(args);
-        int *types = (int *) qMalloc(paramCount * sizeof(int));
+        int *types = (int *) malloc(paramCount * sizeof(int));
         Q_CHECK_PTR(types);
         types[0] = 0; // return type
         args[0] = 0;
@@ -1663,8 +1663,8 @@ bool QMetaMethod::invoke(QObject *object,
                     if (types[x] && args[x])
                         QMetaType::destroy(types[x], args[x]);
                 }
-                qFree(types);
-                qFree(args);
+                free(types);
+                free(args);
                 return false;
             }
         }
diff --git a/src/corelib/kernel/qmetaobjectbuilder.cpp b/src/corelib/kernel/qmetaobjectbuilder.cpp
index 0b4ff89..69cb25a 100644
--- a/src/corelib/kernel/qmetaobjectbuilder.cpp
+++ b/src/corelib/kernel/qmetaobjectbuilder.cpp
@@ -1444,7 +1444,7 @@ static int buildMetaObject(QMetaObjectBuilderPrivate *d, char *buf,
 
 /*!
     Converts this meta object builder into a concrete QMetaObject.
-    The return value should be deallocated using qFree() once it
+    The return value should be deallocated using free() once it
     is no longer needed.
 
     The returned meta object is a snapshot of the state of the
@@ -1455,7 +1455,7 @@ static int buildMetaObject(QMetaObjectBuilderPrivate *d, char *buf,
 QMetaObject *QMetaObjectBuilder::toMetaObject() const
 {
     int size = buildMetaObject(d, 0, false);
-    char *buf = reinterpret_cast<char *>(qMalloc(size));
+    char *buf = reinterpret_cast<char *>(malloc(size));
     memset(buf, 0, size);
     buildMetaObject(d, buf, false);
     return reinterpret_cast<QMetaObject *>(buf);
diff --git a/src/corelib/kernel/qobject.cpp b/src/corelib/kernel/qobject.cpp
index ebb0a3a..bebdcac 100644
--- a/src/corelib/kernel/qobject.cpp
+++ b/src/corelib/kernel/qobject.cpp
@@ -415,8 +415,8 @@ QMetaCallEvent::~QMetaCallEvent()
             if (types_[i] && args_[i])
                 QMetaType::destroy(types_[i], args_[i]);
         }
-        qFree(types_);
-        qFree(args_);
+        free(types_);
+        free(args_);
     }
 #ifndef QT_NO_THREAD
     if (semaphore_)
@@ -3104,9 +3104,9 @@ static void queued_activate(QObject *sender, int signal, QObjectPrivate::Connect
     int nargs = 1; // include return type
     while (argumentTypes[nargs-1])
         ++nargs;
-    int *types = (int *) qMalloc(nargs*sizeof(int));
+    int *types = (int *) malloc(nargs*sizeof(int));
     Q_CHECK_PTR(types);
-    void **args = (void **) qMalloc(nargs*sizeof(void *));
+    void **args = (void **) malloc(nargs*sizeof(void *));
     Q_CHECK_PTR(args);
     types[0] = 0; // return type
     args[0] = 0; // return value
diff --git a/src/corelib/tools/qbytearray.cpp b/src/corelib/tools/qbytearray.cpp
index d8c0668..8c625c2 100644
--- a/src/corelib/tools/qbytearray.cpp
+++ b/src/corelib/tools/qbytearray.cpp
@@ -546,7 +546,7 @@ QByteArray qUncompress(const uchar* data, int nbytes)
             qWarning("qUncompress: Input data is corrupted");
             return QByteArray();
         }
-        QByteArray::Data *p = static_cast<QByteArray::Data *>(qRealloc(d.data(), sizeof(QByteArray::Data) + alloc + 1));
+        QByteArray::Data *p = static_cast<QByteArray::Data *>(::realloc(d.data(), sizeof(QByteArray::Data) + alloc + 1));
         if (!p) {
             // we are not allowed to crash here when compiling with QT_NO_EXCEPTIONS
             qWarning("qUncompress: could not allocate enough memory to uncompress data");
@@ -567,7 +567,7 @@ QByteArray qUncompress(const uchar* data, int nbytes)
                     qWarning("qUncompress: Input data is corrupted");
                     return QByteArray();
                 }
-                QByteArray::Data *p = static_cast<QByteArray::Data *>(qRealloc(d.data(), sizeof(QByteArray::Data) + len + 1));
+                QByteArray::Data *p = static_cast<QByteArray::Data *>(::realloc(d.data(), sizeof(QByteArray::Data) + len + 1));
                 if (!p) {
                     // we are not allowed to crash here when compiling with QT_NO_EXCEPTIONS
                     qWarning("qUncompress: could not allocate enough memory to uncompress data");
@@ -883,7 +883,7 @@ QByteArray &QByteArray::operator=(const QByteArray & other)
 {
     other.d->ref.ref();
     if (!d->ref.deref())
-        qFree(d);
+        free(d);
     d = other.d;
     return *this;
 }
@@ -912,7 +912,7 @@ QByteArray &QByteArray::operator=(const char *str)
     }
     x->ref.ref();
     if (!d->ref.deref())
-         qFree(d);
+         free(d);
     d = x;
     return *this;
 }
@@ -1302,7 +1302,7 @@ QByteArray::QByteArray(const char *str)
         d = const_cast<Data *>(&shared_empty.ba);
     } else {
         int len = qstrlen(str);
-        d = static_cast<Data *>(qMalloc(sizeof(Data) + len + 1));
+        d = static_cast<Data *>(malloc(sizeof(Data) + len + 1));
         Q_CHECK_PTR(d);
         d->ref = 1;
         d->size = len;
@@ -1331,7 +1331,7 @@ QByteArray::QByteArray(const char *data, int size)
     } else if (size <= 0) {
         d = const_cast<Data *>(&shared_empty.ba);
     } else {
-        d = static_cast<Data *>(qMalloc(sizeof(Data) + size + 1));
+        d = static_cast<Data *>(malloc(sizeof(Data) + size + 1));
         Q_CHECK_PTR(d);
         d->ref = 1;
         d->size = size;
@@ -1355,7 +1355,7 @@ QByteArray::QByteArray(int size, char ch)
     if (size <= 0) {
         d = const_cast<Data *>(&shared_null.ba);
     } else {
-        d = static_cast<Data *>(qMalloc(sizeof(Data) + size + 1));
+        d = static_cast<Data *>(malloc(sizeof(Data) + size + 1));
         Q_CHECK_PTR(d);
         d->ref = 1;
         d->size = size;
@@ -1375,7 +1375,7 @@ QByteArray::QByteArray(int size, char ch)
 
 QByteArray::QByteArray(int size, Qt::Initialization)
 {
-    d = static_cast<Data *>(qMalloc(sizeof(Data) + size + 1));
+    d = static_cast<Data *>(malloc(sizeof(Data) + size + 1));
     Q_CHECK_PTR(d);
     d->ref = 1;
     d->size = size;
@@ -1411,7 +1411,7 @@ void QByteArray::resize(int size)
     if (size == 0 && !d->capacityReserved) {
         Data *x = const_cast<Data *>(&shared_empty.ba);
         if (!d->ref.deref())
-            qFree(d);
+            free(d);
         d = x;
     } else if (d == &shared_null.ba || d == &shared_empty.ba) {
         //
@@ -1422,7 +1422,7 @@ void QByteArray::resize(int size)
         // which is used in place of the Qt 3 idiom:
         //    QByteArray a(sz);
         //
-        Data *x = static_cast<Data *>(qMalloc(sizeof(Data) + size + 1));
+        Data *x = static_cast<Data *>(malloc(sizeof(Data) + size + 1));
         Q_CHECK_PTR(x);
         x->ref = 1;
         x->size = size;
@@ -1464,7 +1464,7 @@ QByteArray &QByteArray::fill(char ch, int size)
 void QByteArray::realloc(int alloc)
 {
     if (d->ref != 1 || d->offset) {
-        Data *x = static_cast<Data *>(qMalloc(sizeof(Data) + alloc + 1));
+        Data *x = static_cast<Data *>(malloc(sizeof(Data) + alloc + 1));
         Q_CHECK_PTR(x);
         x->ref = 1;
         x->size = qMin(alloc, d->size);
@@ -1474,10 +1474,10 @@ void QByteArray::realloc(int alloc)
         ::memcpy(x->data(), d->data(), x->size);
         x->data()[x->size] = '\0';
         if (!d->ref.deref())
-            qFree(d);
+            free(d);
         d = x;
     } else {
-        Data *x = static_cast<Data *>(qRealloc(d, sizeof(Data) + alloc + 1));
+        Data *x = static_cast<Data *>(::realloc(d, sizeof(Data) + alloc + 1));
         Q_CHECK_PTR(x);
         x->alloc = alloc;
         x->offset = 0;
@@ -2730,7 +2730,7 @@ QByteArray QByteArray::toUpper() const
 void QByteArray::clear()
 {
     if (!d->ref.deref())
-        qFree(d);
+        free(d);
     d = const_cast<Data *>(&shared_null.ba);
     d->ref.ref();
 }
@@ -3885,7 +3885,7 @@ QByteArray QByteArray::fromRawData(const char *data, int size)
     } else if (!size) {
         x = const_cast<Data *>(&shared_empty.ba);
     } else {
-        x = static_cast<Data *>(qMalloc(sizeof(Data) + 1));
+        x = static_cast<Data *>(malloc(sizeof(Data) + 1));
         Q_CHECK_PTR(x);
         x->ref = 1;
         x->size = size;
diff --git a/src/corelib/tools/qhash.cpp b/src/corelib/tools/qhash.cpp
index f4ec4eb..fac8c2f 100644
--- a/src/corelib/tools/qhash.cpp
+++ b/src/corelib/tools/qhash.cpp
@@ -171,7 +171,7 @@ const QHashData QHashData::shared_null = {
 
 void *QHashData::allocateNode(int nodeAlign)
 {
-    void *ptr = strictAlignment ? qMallocAligned(nodeSize, nodeAlign) : qMalloc(nodeSize);
+    void *ptr = strictAlignment ? qMallocAligned(nodeSize, nodeAlign) : malloc(nodeSize);
     Q_CHECK_PTR(ptr);
     return ptr;
 }
@@ -181,7 +181,7 @@ void QHashData::freeNode(void *node)
     if (strictAlignment)
         qFreeAligned(node);
     else
-        qFree(node);
+        free(node);
 }
 
 QHashData *QHashData::detach_helper(void (*node_duplicate)(Node *, void *),
diff --git a/src/corelib/tools/qlist.cpp b/src/corelib/tools/qlist.cpp
index 9ac4636..adc6ee7 100644
--- a/src/corelib/tools/qlist.cpp
+++ b/src/corelib/tools/qlist.cpp
@@ -42,7 +42,9 @@
 #include <new>
 #include "qlist.h"
 #include "qtools_p.h"
+
 #include <string.h>
+#include <stdlib.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -82,7 +84,7 @@ QListData::Data *QListData::detach_grow(int *idx, int num)
     int l = x->end - x->begin;
     int nl = l + num;
     int alloc = grow(nl);
-    Data* t = static_cast<Data *>(qMalloc(DataHeaderSize + alloc * sizeof(void *)));
+    Data* t = static_cast<Data *>(::malloc(DataHeaderSize + alloc * sizeof(void *)));
     Q_CHECK_PTR(t);
 
     t->ref = 1;
@@ -124,7 +126,7 @@ QListData::Data *QListData::detach_grow(int *idx, int num)
 QListData::Data *QListData::detach(int alloc)
 {
     Data *x = d;
-    Data* t = static_cast<Data *>(qMalloc(DataHeaderSize + alloc * sizeof(void *)));
+    Data* t = static_cast<Data *>(::malloc(DataHeaderSize + alloc * sizeof(void *)));
     Q_CHECK_PTR(t);
 
     t->ref = 1;
@@ -145,7 +147,7 @@ QListData::Data *QListData::detach(int alloc)
 void QListData::realloc(int alloc)
 {
     Q_ASSERT(d->ref == 1);
-    Data *x = static_cast<Data *>(qRealloc(d, DataHeaderSize + alloc * sizeof(void *)));
+    Data *x = static_cast<Data *>(::realloc(d, DataHeaderSize + alloc * sizeof(void *)));
     Q_CHECK_PTR(x);
 
     d = x;
diff --git a/src/corelib/tools/qmap.cpp b/src/corelib/tools/qmap.cpp
index 280409f..a688ae1 100644
--- a/src/corelib/tools/qmap.cpp
+++ b/src/corelib/tools/qmap.cpp
@@ -85,7 +85,7 @@ void QMapData::continueFreeData(int offset)
         if (strictAlignment)
             qFreeAligned(reinterpret_cast<char *>(prev) - offset);
         else
-            qFree(reinterpret_cast<char *>(prev) - offset);
+            free(reinterpret_cast<char *>(prev) - offset);
     }
     delete this;
 }
@@ -127,7 +127,7 @@ QMapData::Node *QMapData::node_create(Node *update[], int offset, int alignment)
 
     void *concreteNode = strictAlignment ?
                          qMallocAligned(offset + sizeof(Node) + level * sizeof(Node *), alignment) :
-                         qMalloc(offset + sizeof(Node) + level * sizeof(Node *));
+                         malloc(offset + sizeof(Node) + level * sizeof(Node *));
     Q_CHECK_PTR(concreteNode);
 
     Node *abstractNode = reinterpret_cast<Node *>(reinterpret_cast<char *>(concreteNode) + offset);
@@ -157,7 +157,7 @@ void QMapData::node_delete(Node *update[], int offset, Node *node)
     if (strictAlignment)
         qFreeAligned(reinterpret_cast<char *>(node) - offset);
     else
-        qFree(reinterpret_cast<char *>(node) - offset);
+        free(reinterpret_cast<char *>(node) - offset);
 }
 
 #ifdef QT_QMAP_DEBUG
diff --git a/src/corelib/tools/qstring.cpp b/src/corelib/tools/qstring.cpp
index 38e19d1..eea41ea 100644
--- a/src/corelib/tools/qstring.cpp
+++ b/src/corelib/tools/qstring.cpp
@@ -1030,7 +1030,7 @@ QString::QString(const QChar *unicode, int size)
     } else if (size <= 0) {
         d = const_cast<Data *>(&shared_empty.str);
     } else {
-        d = (Data*) qMalloc(sizeof(Data)+(size+1)*sizeof(QChar));
+        d = (Data*) ::malloc(sizeof(Data)+(size+1)*sizeof(QChar));
         Q_CHECK_PTR(d);
         d->ref = 1;
         d->size = size;
@@ -1062,7 +1062,7 @@ QString::QString(const QChar *unicode)
          if (!size) {
              d = const_cast<Data *>(&shared_empty.str);
          } else {
-             d = (Data*) qMalloc(sizeof(Data)+(size+1)*sizeof(QChar));
+             d = (Data*) ::malloc(sizeof(Data)+(size+1)*sizeof(QChar));
              Q_CHECK_PTR(d);
              d->ref = 1;
              d->size = size;
@@ -1087,7 +1087,7 @@ QString::QString(int size, QChar ch)
    if (size <= 0) {
         d = const_cast<Data *>(&shared_empty.str);
     } else {
-        d = (Data*) qMalloc(sizeof(Data)+(size+1)*sizeof(QChar));
+        d = (Data*) ::malloc(sizeof(Data)+(size+1)*sizeof(QChar));
         Q_CHECK_PTR(d);
         d->ref = 1;
         d->size = size;
@@ -1111,7 +1111,7 @@ QString::QString(int size, QChar ch)
 */
 QString::QString(int size, Qt::Initialization)
 {
-    d = (Data*) qMalloc(sizeof(Data)+(size+1)*sizeof(QChar));
+    d = (Data*) ::malloc(sizeof(Data)+(size+1)*sizeof(QChar));
     Q_CHECK_PTR(d);
     d->ref = 1;
     d->size = size;
@@ -1133,7 +1133,7 @@ QString::QString(int size, Qt::Initialization)
 */
 QString::QString(QChar ch)
 {
-    d = (Data *) qMalloc(sizeof(Data) + 2*sizeof(QChar));
+    d = (Data *) ::malloc(sizeof(Data) + 2*sizeof(QChar));
     Q_CHECK_PTR(d);
     d->ref = 1;
     d->size = 1;
@@ -1199,7 +1199,7 @@ QString::QString(QChar ch)
 // ### Qt 5: rename freeData() to avoid confusion. See task 197625.
 void QString::free(Data *d)
 {
-    qFree(d);
+    ::free(d);
 }
 
 /*!
@@ -1312,7 +1312,7 @@ void QString::resize(int size)
 void QString::realloc(int alloc)
 {
     if (d->ref != 1 || d->offset) {
-        Data *x = static_cast<Data *>(qMalloc(sizeof(Data) + (alloc+1) * sizeof(QChar)));
+        Data *x = static_cast<Data *>(::malloc(sizeof(Data) + (alloc+1) * sizeof(QChar)));
         Q_CHECK_PTR(x);
         x->ref = 1;
         x->size = qMin(alloc, d->size);
@@ -1325,7 +1325,7 @@ void QString::realloc(int alloc)
             QString::free(d);
         d = x;
     } else {
-        Data *p = static_cast<Data *>(qRealloc(d, sizeof(Data) + (alloc+1) * sizeof(QChar)));
+        Data *p = static_cast<Data *>(::realloc(d, sizeof(Data) + (alloc+1) * sizeof(QChar)));
         Q_CHECK_PTR(p);
         d = p;
         d->alloc = alloc;
@@ -1483,11 +1483,11 @@ QString& QString::insert(int i, const QChar *unicode, int size)
     const ushort *s = (const ushort *)unicode;
     if (s >= d->data() && s < d->data() + d->alloc) {
         // Part of me - take a copy
-        ushort *tmp = static_cast<ushort *>(qMalloc(size * sizeof(QChar)));
+        ushort *tmp = static_cast<ushort *>(::malloc(size * sizeof(QChar)));
         Q_CHECK_PTR(tmp);
         memcpy(tmp, s, size * sizeof(QChar));
         insert(i, reinterpret_cast<const QChar *>(tmp), size);
-        qFree(tmp);
+        ::free(tmp);
         return *this;
     }
 
@@ -1843,7 +1843,7 @@ void QString::replace_helper(uint *indices, int nIndices, int blen, const QChar
     // (which we could possibly invalidate via a realloc or corrupt via memcpy operations.)
     QChar *afterBuffer = const_cast<QChar *>(after);
     if (after >= reinterpret_cast<QChar *>(d->data()) && after < reinterpret_cast<QChar *>(d->data()) + d->size) {
-        afterBuffer = static_cast<QChar *>(qMalloc(alen*sizeof(QChar)));
+        afterBuffer = static_cast<QChar *>(::malloc(alen*sizeof(QChar)));
         Q_CHECK_PTR(afterBuffer);
         ::memcpy(afterBuffer, after, alen*sizeof(QChar));
     }
@@ -1898,11 +1898,11 @@ void QString::replace_helper(uint *indices, int nIndices, int blen, const QChar
         }
     } QT_CATCH(const std::bad_alloc &) {
         if (afterBuffer != after)
-            qFree(afterBuffer);
+            ::free(afterBuffer);
         QT_RETHROW;
     }
     if (afterBuffer != after)
-        qFree(afterBuffer);
+        ::free(afterBuffer);
 }
 
 /*!
@@ -3756,7 +3756,7 @@ QString::Data *QString::fromLatin1_helper(const char *str, int size)
     } else {
         if (size < 0)
             size = qstrlen(str);
-        d = static_cast<Data *>(qMalloc(sizeof(Data) + (size+1) * sizeof(QChar)));
+        d = static_cast<Data *>(::malloc(sizeof(Data) + (size+1) * sizeof(QChar)));
         Q_CHECK_PTR(d);
         d->ref = 1;
         d->size = size;
@@ -7063,7 +7063,7 @@ QString QString::fromRawData(const QChar *unicode, int size)
     } else if (!size) {
         x = const_cast<Data *>(&shared_empty.str);
     } else {
-        x = static_cast<Data *>(qMalloc(sizeof(Data) + sizeof(ushort)));
+        x = static_cast<Data *>(::malloc(sizeof(Data) + sizeof(ushort)));
         Q_CHECK_PTR(x);
         x->ref = 1;
         x->size = size;
diff --git a/src/corelib/tools/qvector.cpp b/src/corelib/tools/qvector.cpp
index c58c846..95775d4 100644
--- a/src/corelib/tools/qvector.cpp
+++ b/src/corelib/tools/qvector.cpp
@@ -41,7 +41,9 @@
 
 #include "qvector.h"
 #include "qtools_p.h"
+
 #include <string.h>
+#include <stdlib.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -56,7 +58,7 @@ const QVectorData QVectorData::shared_null = { Q_REFCOUNT_INITIALIZER(-1), 0, 0,
 
 QVectorData *QVectorData::malloc(int sizeofTypedData, int size, int sizeofT, QVectorData *init)
 {
-    QVectorData* p = (QVectorData *)qMalloc(sizeofTypedData + (size - 1) * sizeofT);
+    QVectorData* p = (QVectorData *)::malloc(sizeofTypedData + (size - 1) * sizeofT);
     Q_CHECK_PTR(p);
     ::memcpy(p, init, sizeofTypedData + (qMin(size, init->alloc) - 1) * sizeofT);
     return p;
@@ -64,14 +66,14 @@ QVectorData *QVectorData::malloc(int sizeofTypedData, int size, int sizeofT, QVe
 
 QVectorData *QVectorData::allocate(int size, int alignment)
 {
-    return static_cast<QVectorData *>(alignment > alignmentThreshold() ? qMallocAligned(size, alignment) : qMalloc(size));
+    return static_cast<QVectorData *>(alignment > alignmentThreshold() ? qMallocAligned(size, alignment) : ::malloc(size));
 }
 
 QVectorData *QVectorData::reallocate(QVectorData *x, int newsize, int oldsize, int alignment)
 {
     if (alignment > alignmentThreshold())
         return static_cast<QVectorData *>(qReallocAligned(x, newsize, oldsize, alignment));
-    return static_cast<QVectorData *>(qRealloc(x, newsize));
+    return static_cast<QVectorData *>(realloc(x, newsize));
 }
 
 void QVectorData::free(QVectorData *x, int alignment)
@@ -79,7 +81,7 @@ void QVectorData::free(QVectorData *x, int alignment)
     if (alignment > alignmentThreshold())
         qFreeAligned(x);
     else
-        qFree(x);
+        ::free(x);
 }
 
 int QVectorData::grow(int sizeofTypedData, int size, int sizeofT, bool excessive)
diff --git a/src/corelib/xml/qxmlstream.cpp b/src/corelib/xml/qxmlstream.cpp
index 787bbee..04336c3 100644
--- a/src/corelib/xml/qxmlstream.cpp
+++ b/src/corelib/xml/qxmlstream.cpp
@@ -885,9 +885,9 @@ void QXmlStreamReaderPrivate::parseEntity(const QString &value)
 inline void QXmlStreamReaderPrivate::reallocateStack()
 {
     stack_size <<= 1;
-    sym_stack = reinterpret_cast<Value*> (qRealloc(sym_stack, stack_size * sizeof(Value)));
+    sym_stack = reinterpret_cast<Value*> (realloc(sym_stack, stack_size * sizeof(Value)));
     Q_CHECK_PTR(sym_stack);
-    state_stack = reinterpret_cast<int*> (qRealloc(state_stack, stack_size * sizeof(int)));
+    state_stack = reinterpret_cast<int*> (realloc(state_stack, stack_size * sizeof(int)));
     Q_CHECK_PTR(sym_stack);
 }
 
@@ -897,8 +897,8 @@ QXmlStreamReaderPrivate::~QXmlStreamReaderPrivate()
 #ifndef QT_NO_TEXTCODEC
     delete decoder;
 #endif
-    qFree(sym_stack);
-    qFree(state_stack);
+    free(sym_stack);
+    free(state_stack);
     delete entityParser;
 }
 
diff --git a/src/gui/image/qtiffhandler.cpp b/src/gui/image/qtiffhandler.cpp
index 587e1e1..4756220 100644
--- a/src/gui/image/qtiffhandler.cpp
+++ b/src/gui/image/qtiffhandler.cpp
@@ -496,13 +496,13 @@ bool QTiffHandler::write(const QImage &image)
             }
             //// write the color table
             // allocate the color tables
-            uint16 *redTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));
-            uint16 *greenTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));
-            uint16 *blueTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));
+            uint16 *redTable = static_cast<uint16 *>(malloc(256 * sizeof(uint16)));
+            uint16 *greenTable = static_cast<uint16 *>(malloc(256 * sizeof(uint16)));
+            uint16 *blueTable = static_cast<uint16 *>(malloc(256 * sizeof(uint16)));
             if (!redTable || !greenTable || !blueTable) {
-                qFree(redTable);
-                qFree(greenTable);
-                qFree(blueTable);
+                free(redTable);
+                free(greenTable);
+                free(blueTable);
                 TIFFClose(tiff);
                 return false;
             }
@@ -519,9 +519,9 @@ bool QTiffHandler::write(const QImage &image)
 
             const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable, greenTable, blueTable);
 
-            qFree(redTable);
-            qFree(greenTable);
-            qFree(blueTable);
+            free(redTable);
+            free(greenTable);
+            free(blueTable);
 
             if (!setColorTableSuccess) {
                 TIFFClose(tiff);
diff --git a/src/gui/opengl/qopenglpaintengine.cpp b/src/gui/opengl/qopenglpaintengine.cpp
index 441b3fa..834beda 100644
--- a/src/gui/opengl/qopenglpaintengine.cpp
+++ b/src/gui/opengl/qopenglpaintengine.cpp
@@ -673,8 +673,8 @@ void QOpenGL2PaintEngineExPrivate::cleanupVectorPath(QPaintEngineEx *engine, voi
         d->unusedIBOSToClean << c->ibo;
 #else
     Q_UNUSED(engine);
-    qFree(c->vertices);
-    qFree(c->indices);
+    free(c->vertices);
+    free(c->indices);
 #endif
     delete c;
 }
@@ -719,7 +719,7 @@ void QOpenGL2PaintEngineExPrivate::fill(const QVectorPath& path)
                         cache->vbo = 0;
                         Q_ASSERT(cache->ibo == 0);
 #else
-                        qFree(cache->vertices);
+                        free(cache->vertices);
                         Q_ASSERT(cache->indices == 0);
 #endif
                         updateCache = true;
@@ -747,7 +747,7 @@ void QOpenGL2PaintEngineExPrivate::fill(const QVectorPath& path)
                 glBufferData(GL_ARRAY_BUFFER, floatSizeInBytes, vertexCoordinateArray.data(), GL_STATIC_DRAW);
                 cache->ibo = 0;
 #else
-                cache->vertices = (float *) qMalloc(floatSizeInBytes);
+                cache->vertices = (float *) malloc(floatSizeInBytes);
                 memcpy(cache->vertices, vertexCoordinateArray.data(), floatSizeInBytes);
                 cache->indices = 0;
 #endif
@@ -799,8 +799,8 @@ void QOpenGL2PaintEngineExPrivate::fill(const QVectorPath& path)
                         glDeleteBuffers(1, &cache->vbo);
                         glDeleteBuffers(1, &cache->ibo);
 #else
-                        qFree(cache->vertices);
-                        qFree(cache->indices);
+                        free(cache->vertices);
+                        free(cache->indices);
 #endif
                         updateCache = true;
                     }
@@ -835,12 +835,12 @@ void QOpenGL2PaintEngineExPrivate::fill(const QVectorPath& path)
                     vertices[i] = float(inverseScale * polys.vertices.at(i));
                 funcs.glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
 #else
-                cache->vertices = (float *) qMalloc(sizeof(float) * polys.vertices.size());
+                cache->vertices = (float *) malloc(sizeof(float) * polys.vertices.size());
                 if (polys.indices.type() == QVertexIndexVector::UnsignedInt) {
-                    cache->indices = (quint32 *) qMalloc(sizeof(quint32) * polys.indices.size());
+                    cache->indices = (quint32 *) malloc(sizeof(quint32) * polys.indices.size());
                     memcpy(cache->indices, polys.indices.data(), sizeof(quint32) * polys.indices.size());
                 } else {
-                    cache->indices = (quint16 *) qMalloc(sizeof(quint16) * polys.indices.size());
+                    cache->indices = (quint16 *) malloc(sizeof(quint16) * polys.indices.size());
                     memcpy(cache->indices, polys.indices.data(), sizeof(quint16) * polys.indices.size());
                 }
                 for (int i = 0; i < polys.vertices.size(); ++i)
diff --git a/src/network/kernel/qhostinfo_unix.cpp b/src/network/kernel/qhostinfo_unix.cpp
index 85df770..73882dd 100644
--- a/src/network/kernel/qhostinfo_unix.cpp
+++ b/src/network/kernel/qhostinfo_unix.cpp
@@ -329,7 +329,7 @@ QString QHostInfo::localDomainName()
     resolveLibrary();
     if (local_res_ninit) {
         // using thread-safe version
-        res_state_ptr state = res_state_ptr(qMalloc(sizeof(*state)));
+        res_state_ptr state = res_state_ptr(malloc(sizeof(*state)));
         Q_CHECK_PTR(state);
         memset(state, 0, sizeof(*state));
         local_res_ninit(state);
@@ -337,7 +337,7 @@ QString QHostInfo::localDomainName()
         if (domainName.isEmpty())
             domainName = QUrl::fromAce(state->dnsrch[0]);
         local_res_nclose(state);
-        qFree(state);
+        free(state);
 
         return domainName;
     }
diff --git a/src/network/kernel/qnetworkinterface_win.cpp b/src/network/kernel/qnetworkinterface_win.cpp
index 741e8e7..da9fa80 100644
--- a/src/network/kernel/qnetworkinterface_win.cpp
+++ b/src/network/kernel/qnetworkinterface_win.cpp
@@ -110,12 +110,12 @@ static QHash<QHostAddress, QHostAddress> ipv4Netmasks()
     DWORD retval = ptrGetAdaptersInfo(pAdapter, &bufSize);
     if (retval == ERROR_BUFFER_OVERFLOW) {
         // need more memory
-        pAdapter = (IP_ADAPTER_INFO *)qMalloc(bufSize);
+        pAdapter = (IP_ADAPTER_INFO *)malloc(bufSize);
         if (!pAdapter)
             return ipv4netmasks;
         // try again
         if (ptrGetAdaptersInfo(pAdapter, &bufSize) != ERROR_SUCCESS) {
-            qFree(pAdapter);
+            free(pAdapter);
             return ipv4netmasks;
         }
     } else if (retval != ERROR_SUCCESS) {
@@ -132,7 +132,7 @@ static QHash<QHostAddress, QHostAddress> ipv4Netmasks()
         }
     }
     if (pAdapter != staticBuf)
-        qFree(pAdapter);
+        free(pAdapter);
 
     return ipv4netmasks;
 
@@ -153,12 +153,12 @@ static QList<QNetworkInterfacePrivate *> interfaceListingWinXP()
     ULONG retval = ptrGetAdaptersAddresses(AF_UNSPEC, flags, NULL, pAdapter, &bufSize);
     if (retval == ERROR_BUFFER_OVERFLOW) {
         // need more memory
-        pAdapter = (IP_ADAPTER_ADDRESSES *)qMalloc(bufSize);
+        pAdapter = (IP_ADAPTER_ADDRESSES *)malloc(bufSize);
         if (!pAdapter)
             return interfaces;
         // try again
         if (ptrGetAdaptersAddresses(AF_UNSPEC, flags, NULL, pAdapter, &bufSize) != ERROR_SUCCESS) {
-            qFree(pAdapter);
+            free(pAdapter);
             return interfaces;
         }
     } else if (retval != ERROR_SUCCESS) {
@@ -219,7 +219,7 @@ static QList<QNetworkInterfacePrivate *> interfaceListingWinXP()
     }
 
     if (pAdapter != staticBuf)
-        qFree(pAdapter);
+        free(pAdapter);
 
     return interfaces;
 }
@@ -234,12 +234,12 @@ static QList<QNetworkInterfacePrivate *> interfaceListingWin2k()
     DWORD retval = ptrGetAdaptersInfo(pAdapter, &bufSize);
     if (retval == ERROR_BUFFER_OVERFLOW) {
         // need more memory
-        pAdapter = (IP_ADAPTER_INFO *)qMalloc(bufSize);
+        pAdapter = (IP_ADAPTER_INFO *)malloc(bufSize);
         if (!pAdapter)
             return interfaces;
         // try again
         if (ptrGetAdaptersInfo(pAdapter, &bufSize) != ERROR_SUCCESS) {
-            qFree(pAdapter);
+            free(pAdapter);
             return interfaces;
         }
     } else if (retval != ERROR_SUCCESS) {
@@ -273,7 +273,7 @@ static QList<QNetworkInterfacePrivate *> interfaceListingWin2k()
     }
 
     if (pAdapter != staticBuf)
-        qFree(pAdapter);
+        free(pAdapter);
 
     return interfaces;
 }
@@ -305,12 +305,12 @@ QString QHostInfo::localDomainName()
     ULONG bufSize = sizeof info;
     pinfo = &info;
     if (ptrGetNetworkParams(pinfo, &bufSize) == ERROR_BUFFER_OVERFLOW) {
-        pinfo = (FIXED_INFO *)qMalloc(bufSize);
+        pinfo = (FIXED_INFO *)malloc(bufSize);
         if (!pinfo)
             return QString();
         // try again
         if (ptrGetNetworkParams(pinfo, &bufSize) != ERROR_SUCCESS) {
-            qFree(pinfo);
+            free(pinfo);
             return QString();   // error
         }
     }
@@ -318,7 +318,7 @@ QString QHostInfo::localDomainName()
     QString domainName = QUrl::fromAce(pinfo->DomainName);
 
     if (pinfo != &info)
-        qFree(pinfo);
+        free(pinfo);
 
     return domainName;
 }
diff --git a/src/opengl/gl2paintengineex/qpaintengineex_opengl2.cpp b/src/opengl/gl2paintengineex/qpaintengineex_opengl2.cpp
index 388c3a3..85773fa 100644
--- a/src/opengl/gl2paintengineex/qpaintengineex_opengl2.cpp
+++ b/src/opengl/gl2paintengineex/qpaintengineex_opengl2.cpp
@@ -674,8 +674,8 @@ void QGL2PaintEngineExPrivate::cleanupVectorPath(QPaintEngineEx *engine, void *d
         d->unusedIBOSToClean << c->ibo;
 #else
     Q_UNUSED(engine);
-    qFree(c->vertices);
-    qFree(c->indices);
+    free(c->vertices);
+    free(c->indices);
 #endif
     delete c;
 }
@@ -720,7 +720,7 @@ void QGL2PaintEngineExPrivate::fill(const QVectorPath& path)
                         cache->vbo = 0;
                         Q_ASSERT(cache->ibo == 0);
 #else
-                        qFree(cache->vertices);
+                        free(cache->vertices);
                         Q_ASSERT(cache->indices == 0);
 #endif
                         updateCache = true;
@@ -748,7 +748,7 @@ void QGL2PaintEngineExPrivate::fill(const QVectorPath& path)
                 glBufferData(GL_ARRAY_BUFFER, floatSizeInBytes, vertexCoordinateArray.data(), GL_STATIC_DRAW);
                 cache->ibo = 0;
 #else
-                cache->vertices = (float *) qMalloc(floatSizeInBytes);
+                cache->vertices = (float *) malloc(floatSizeInBytes);
                 memcpy(cache->vertices, vertexCoordinateArray.data(), floatSizeInBytes);
                 cache->indices = 0;
 #endif
@@ -800,8 +800,8 @@ void QGL2PaintEngineExPrivate::fill(const QVectorPath& path)
                         glDeleteBuffers(1, &cache->vbo);
                         glDeleteBuffers(1, &cache->ibo);
 #else
-                        qFree(cache->vertices);
-                        qFree(cache->indices);
+                        free(cache->vertices);
+                        free(cache->indices);
 #endif
                         updateCache = true;
                     }
@@ -836,12 +836,12 @@ void QGL2PaintEngineExPrivate::fill(const QVectorPath& path)
                     vertices[i] = float(inverseScale * polys.vertices.at(i));
                 glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
 #else
-                cache->vertices = (float *) qMalloc(sizeof(float) * polys.vertices.size());
+                cache->vertices = (float *) malloc(sizeof(float) * polys.vertices.size());
                 if (polys.indices.type() == QVertexIndexVector::UnsignedInt) {
-                    cache->indices = (quint32 *) qMalloc(sizeof(quint32) * polys.indices.size());
+                    cache->indices = (quint32 *) malloc(sizeof(quint32) * polys.indices.size());
                     memcpy(cache->indices, polys.indices.data(), sizeof(quint32) * polys.indices.size());
                 } else {
-                    cache->indices = (quint16 *) qMalloc(sizeof(quint16) * polys.indices.size());
+                    cache->indices = (quint16 *) malloc(sizeof(quint16) * polys.indices.size());
                     memcpy(cache->indices, polys.indices.data(), sizeof(quint16) * polys.indices.size());
                 }
                 for (int i = 0; i < polys.vertices.size(); ++i)
diff --git a/src/plugins/platforms/xcb/qxcbbackingstore.cpp b/src/plugins/platforms/xcb/qxcbbackingstore.cpp
index 8f833de..4348ddb 100644
--- a/src/plugins/platforms/xcb/qxcbbackingstore.cpp
+++ b/src/plugins/platforms/xcb/qxcbbackingstore.cpp
@@ -124,7 +124,7 @@ QXcbShmImage::QXcbShmImage(QXcbScreen *screen, const QSize &size, uint depth, QI
 
         m_shm_info.shmaddr = 0;
 
-        m_xcb_image->data = (uint8_t *)qMalloc(segmentSize);
+        m_xcb_image->data = (uint8_t *)malloc(segmentSize);
     } else {
         if (shmctl(m_shm_info.shmid, IPC_RMID, 0) == -1)
             qWarning() << "QXcbBackingStore: Error while marking the shared memory segment to be destroyed";
@@ -146,7 +146,7 @@ void QXcbShmImage::destroy()
             shmdt(m_shm_info.shmaddr);
             shmctl(m_shm_info.shmid, IPC_RMID, 0);
         } else {
-            qFree(m_xcb_image->data);
+            free(m_xcb_image->data);
         }
     }
 
diff --git a/tests/auto/corelib/kernel/qmetaobjectbuilder/tst_qmetaobjectbuilder.cpp b/tests/auto/corelib/kernel/qmetaobjectbuilder/tst_qmetaobjectbuilder.cpp
index 5e2e67b..fb7122a 100644
--- a/tests/auto/corelib/kernel/qmetaobjectbuilder/tst_qmetaobjectbuilder.cpp
+++ b/tests/auto/corelib/kernel/qmetaobjectbuilder/tst_qmetaobjectbuilder.cpp
@@ -957,17 +957,17 @@ void tst_QMetaObjectBuilder::copyMetaObject()
     QMetaObjectBuilder builder(&QObject::staticMetaObject);
     QMetaObject *meta = builder.toMetaObject();
     QVERIFY(sameMetaObject(meta, &QObject::staticMetaObject));
-    qFree(meta);
+    free(meta);
 
     QMetaObjectBuilder builder2(&staticMetaObject);
     meta = builder2.toMetaObject();
     QVERIFY(sameMetaObject(meta, &staticMetaObject));
-    qFree(meta);
+    free(meta);
 
     QMetaObjectBuilder builder3(&SomethingOfEverything::staticMetaObject);
     meta = builder3.toMetaObject();
     QVERIFY(sameMetaObject(meta, &SomethingOfEverything::staticMetaObject));
-    qFree(meta);
+    free(meta);
 }
 
 // Serialize and deserialize a meta object and check that
@@ -992,8 +992,8 @@ void tst_QMetaObjectBuilder::serialize()
     QMetaObject *meta2 = builder2.toMetaObject();
 
     QVERIFY(sameMetaObject(meta, meta2));
-    qFree(meta);
-    qFree(meta2);
+    free(meta);
+    free(meta2);
     }
 
     // Partial QMetaObjectBuilder
diff --git a/tests/auto/widgets/graphicsview/qgraphicsanchorlayout/tst_qgraphicsanchorlayout.cpp b/tests/auto/widgets/graphicsview/qgraphicsanchorlayout/tst_qgraphicsanchorlayout.cpp
index 3e39d46..54b9355 100644
--- a/tests/auto/widgets/graphicsview/qgraphicsanchorlayout/tst_qgraphicsanchorlayout.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicsanchorlayout/tst_qgraphicsanchorlayout.cpp
@@ -1377,8 +1377,8 @@ void tst_QGraphicsAnchorLayout::stability()
         //static const int primes[] = {2, 3, 5, 13, 89, 233, 1597, 28657, 514229}; // fibo primes
         //const int primeCount = sizeof(primes)/sizeof(int);
         //int alloc = primes[pass % primeCount] + pass;
-        //void *mem = qMalloc(alloc);
-        //qFree(mem);
+        //void *mem = malloc(alloc);
+        //free(mem);
         QGraphicsAnchorLayout *l = createAmbiguousS60Layout();
         p->setLayout(l);
         QSizeF layoutMinimumSize = l->effectiveSizeHint(Qt::MinimumSize);
diff --git a/tests/benchmarks/network/access/qnetworkreply/tst_qnetworkreply.cpp b/tests/benchmarks/network/access/qnetworkreply/tst_qnetworkreply.cpp
index d30dafb..81f9c1a 100644
--- a/tests/benchmarks/network/access/qnetworkreply/tst_qnetworkreply.cpp
+++ b/tests/benchmarks/network/access/qnetworkreply/tst_qnetworkreply.cpp
@@ -690,15 +690,15 @@ public:
             QSharedPointer<char> data = downloadBufferAttribute.value<QSharedPointer<char> >();
         } else if (testType == DownloadBufferButUseRead) {
             // We had a download buffer but we benchmark here the "legacy" read() way to access it
-            char* replyData = (char*) qMalloc(uploadSize);
+            char* replyData = (char*) malloc(uploadSize);
             QVERIFY(reply->read(replyData, uploadSize) == uploadSize);
-            qFree(replyData);
+            free(replyData);
         } else if (testType == NoDownloadBuffer) {
             // We did not have a download buffer but we still need to benchmark having the data, e.g. reading it all.
             // This should be the slowest benchmark result.
-            char* replyData = (char*) qMalloc(uploadSize);
+            char* replyData = (char*) malloc(uploadSize);
             QVERIFY(reply->read(replyData, uploadSize) == uploadSize);
-            qFree(replyData);
+            free(replyData);
         }
 
         QMetaObject::invokeMethod(&QTestEventLoop::instance(), "exitLoop", Qt::QueuedConnection);