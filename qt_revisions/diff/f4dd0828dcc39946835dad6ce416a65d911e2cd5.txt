diff --git a/src/gui/kernel/kernel.pri b/src/gui/kernel/kernel.pri
index bf79837..f2c5334 100644
--- a/src/gui/kernel/kernel.pri
+++ b/src/gui/kernel/kernel.pri
@@ -61,7 +61,8 @@ HEADERS += \
         kernel/qplatformsharedgraphicscache.h \
         kernel/qplatformdialoghelper.h \
         kernel/qplatformservices.h \
-        kernel/qplatformscreenpageflipper.h
+        kernel/qplatformscreenpageflipper.h \
+        kernel/qplatformsystemtrayicon.h
 
 SOURCES += \
         kernel/qclipboard_qpa.cpp \
@@ -108,7 +109,8 @@ SOURCES += \
         kernel/qplatformsharedgraphicscache.cpp \
         kernel/qplatformdialoghelper.cpp \
         kernel/qplatformservices.cpp \
-        kernel/qplatformscreenpageflipper.cpp
+        kernel/qplatformscreenpageflipper.cpp \
+        kernel/qplatformsystemtrayicon_qpa.cpp
 
 contains(QT_CONFIG, opengl)|contains(QT_CONFIG, opengles2) {
     HEADERS += \
diff --git a/src/gui/kernel/qplatformsystemtrayicon.h b/src/gui/kernel/qplatformsystemtrayicon.h
new file mode 100644
index 0000000..4bf708e
--- /dev/null
+++ b/src/gui/kernel/qplatformsystemtrayicon.h
@@ -0,0 +1,95 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Copyright (C) 2012 Klaralvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Christoph Schleifenbaum <christoph.schleifenbaum@kdab.com>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QPLATFORMSYSTEMTRAYICON_H
+#define QPLATFORMSYSTEMTRAYICON_H
+
+#ifndef QT_NO_SYSTEMTRAYICON
+
+#include "QtCore/qobject.h"
+
+QT_BEGIN_NAMESPACE
+
+class QPlatformMenu;
+class QIcon;
+class QString;
+class QRect;
+
+class Q_GUI_EXPORT QPlatformSystemTrayIcon : public QObject
+{
+    Q_OBJECT
+public:
+    enum ActivationReason {
+        Unknown,
+        Context,
+        DoubleClick,
+        Trigger,
+        MiddleClick
+    };
+
+    enum MessageIcon { NoIcon, Information, Warning, Critical };
+
+    QPlatformSystemTrayIcon();
+    ~QPlatformSystemTrayIcon();
+
+    virtual void init() = 0;
+    virtual void cleanup() = 0;
+    virtual void updateIcon(const QIcon &icon) = 0;
+    virtual void updateToolTip(const QString &tooltip) = 0;
+    virtual void updateMenu(QPlatformMenu *menu) = 0;
+    virtual QRect geometry() const = 0;
+    virtual void showMessage(const QString &msg, const QString &title,
+                             const QIcon &icon, MessageIcon iconType, int secs) = 0;
+
+    virtual bool isSystemTrayAvailable() const = 0;
+    virtual bool supportsMessages() const = 0;
+
+Q_SIGNALS:
+    void activated(QPlatformSystemTrayIcon::ActivationReason reason);
+    void messageClicked();
+};
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_SYSTEMTRAYICON
+
+#endif // QSYSTEMTRAYICON_P_H
diff --git a/src/gui/kernel/qplatformsystemtrayicon_qpa.cpp b/src/gui/kernel/qplatformsystemtrayicon_qpa.cpp
new file mode 100644
index 0000000..304fc29
--- /dev/null
+++ b/src/gui/kernel/qplatformsystemtrayicon_qpa.cpp
@@ -0,0 +1,125 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Copyright (C) 2012 Klaralvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Christoph Schleifenbaum <christoph.schleifenbaum@kdab.com>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformsystemtrayicon.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QPlatformSystemTrayIcon
+    \brief The QPlatformSystemTrayIcon class abstracts the system tray icon and interaction.
+
+    \sa QSystemTray
+*/
+
+/*!
+    \internal
+ */
+QPlatformSystemTrayIcon::QPlatformSystemTrayIcon()
+{
+}
+
+/*!
+    \internal
+ */
+QPlatformSystemTrayIcon::~QPlatformSystemTrayIcon()
+{
+}
+
+/*!
+    \fn void QPlatformSystemTrayIcon::init()
+    This method is called to initialize the platform dependent implementation.
+*/
+
+/*!
+    \fn void QPlatformSystemTrayIcon::cleanup()
+    This method is called to cleanup the platform dependent implementation.
+*/
+
+/*!
+    \fn void QPlatformSystemTrayIcon::updateIcon(const QIcon &icon)
+    This method is called when the \a icon did change.
+*/
+
+/*!
+    \fn void QPlatformSystemTrayIcon::updateToolTip(const QString &tooltip)
+    This method is called when the \a tooltip text did change.
+*/
+
+/*!
+    \fn void QPlatformSystemTrayIcon::updateMenu(QPlatformMenu *menu)
+    This method is called when the system tray \a menu did change.
+*/
+
+/*!
+    \fn QRect QPlatformSystemTrayIcon::geometry() const
+    This method returns the geometry of the platform dependent system tray icon on the screen.
+*/
+
+/*!
+    \fn void QPlatformSystemTrayIcon::showMessage(const QString &msg, const QString &title,
+                                                  const QIcon &icon, MessageIcon iconType, int secs)
+    Shows a balloon message for the entry with the given \a title, message \msg and \a icon for
+    the time specified in \secs. \a iconType is used as a hint for the implementing platform.
+    \sa QSystemTrayIcon::showMessage
+*/
+
+/*!
+    \fn bool QPlatformSystemTrayIcon::isSystemTrayAvailable()
+    Returns true if the system tray is available on the platform.
+*/
+
+/*!
+    bool QPlatformSystemTrayIcon::supportsMessages()
+    Returns true if the system tray supports messages on the platform.
+*/
+
+/*!
+    \fn void activated(QPlatformSystemTrayIcon::ActivationReason reason)
+    This signal is emitted when the user activates the system tray icon.
+    \a reason specifies the reason for activation.
+    \sa QSystemTrayIcon::ActivationReason.
+*/
+
+QT_END_NAMESPACE
+
+#include "moc_qplatformsystemtrayicon.cpp"
diff --git a/src/gui/kernel/qplatformtheme.cpp b/src/gui/kernel/qplatformtheme.cpp
index 1038eb2..d1ca8b7 100644
--- a/src/gui/kernel/qplatformtheme.cpp
+++ b/src/gui/kernel/qplatformtheme.cpp
@@ -192,4 +192,15 @@ QPlatformMenuBar *QPlatformTheme::createPlatformMenuBar() const
     return 0;
 }
 
+#ifndef QT_NO_SYSTEMTRAYICON
+/*!
+   Factory function for QSystemTrayIcon. This function will return 0 if the platform
+   integration does not support creating any system tray icon.
+*/
+QPlatformSystemTrayIcon *QPlatformTheme::createPlatformSystemTrayIcon() const
+{
+    return 0;
+}
+#endif
+
 QT_END_NAMESPACE
diff --git a/src/gui/kernel/qplatformtheme.h b/src/gui/kernel/qplatformtheme.h
index f80f9e5..5ead94c 100644
--- a/src/gui/kernel/qplatformtheme.h
+++ b/src/gui/kernel/qplatformtheme.h
@@ -63,6 +63,7 @@ class QPlatformMenuItem;
 class QPlatformMenu;
 class QPlatformMenuBar;
 class QPlatformDialogHelper;
+class QPlatformSystemTrayIcon;
 class QVariant;
 class QPalette;
 class QFont;
@@ -170,6 +171,10 @@ public:
     virtual bool usePlatformNativeDialog(DialogType type) const;
     virtual QPlatformDialogHelper *createPlatformDialogHelper(DialogType type) const;
 
+#ifndef QT_NO_SYSTEMTRAYICON
+    virtual QPlatformSystemTrayIcon *createPlatformSystemTrayIcon() const;
+#endif
+
     virtual const QPalette *palette(Palette type = SystemPalette) const;
 
     virtual const QFont *font(Font type = SystemFont) const;
diff --git a/src/plugins/platforms/cocoa/cocoa.pro b/src/plugins/platforms/cocoa/cocoa.pro
index ac79ccc..106664a 100644
--- a/src/plugins/platforms/cocoa/cocoa.pro
+++ b/src/plugins/platforms/cocoa/cocoa.pro
@@ -35,6 +35,7 @@ OBJECTIVE_SOURCES += main.mm \
     qcocoasystemsettings.mm \
     qcocoainputcontext.mm \
     qcocoaservices.mm \
+    qcocoasystemtrayicon.mm \
 
 HEADERS += qcocoaintegration.h \
     qcocoatheme.h \
@@ -67,6 +68,7 @@ HEADERS += qcocoaintegration.h \
     qcocoasystemsettings.h \
     qcocoainputcontext.h \
     qcocoaservices.h \
+    qcocoasystemtrayicon.h \
 
 RESOURCES += qcocoaresources.qrc
 
diff --git a/src/plugins/platforms/cocoa/qcocoahelpers.h b/src/plugins/platforms/cocoa/qcocoahelpers.h
index f803260..dac7118 100644
--- a/src/plugins/platforms/cocoa/qcocoahelpers.h
+++ b/src/plugins/platforms/cocoa/qcocoahelpers.h
@@ -115,6 +115,12 @@ inline NSPoint qt_mac_flipPoint(const QPointF &p)
 
 NSRect qt_mac_flipRect(const QRect &rect, QWindow *window);
 
+Qt::MouseButton cocoaButton2QtButton(NSInteger buttonNum);
+
+bool qt_mac_execute_apple_script(const char *script, long script_len, AEDesc *ret);
+bool qt_mac_execute_apple_script(const char *script, AEDesc *ret);
+bool qt_mac_execute_apple_script(const QString &script, AEDesc *ret);
+
 // strip out '&' characters, and convert "&&" to a single '&', in menu
 // text - since menu text is sometimes decorated with these for Windows
 // accelerators.
diff --git a/src/plugins/platforms/cocoa/qcocoahelpers.mm b/src/plugins/platforms/cocoa/qcocoahelpers.mm
index c0b6f3a..8b09570 100644
--- a/src/plugins/platforms/cocoa/qcocoahelpers.mm
+++ b/src/plugins/platforms/cocoa/qcocoahelpers.mm
@@ -581,6 +581,84 @@ CGFloat qt_mac_get_scalefactor()
     return [[NSScreen mainScreen] userSpaceScaleFactor];
 }
 
+Qt::MouseButton cocoaButton2QtButton(NSInteger buttonNum)
+{
+    switch (buttonNum) {
+    case 0:
+        return Qt::LeftButton;
+    case 1:
+        return Qt::RightButton;
+    case 2:
+        return Qt::MidButton;
+    case 3:
+        return Qt::XButton1;
+    case 4:
+        return Qt::XButton2;
+    default:
+        return Qt::NoButton;
+    }
+}
+
+bool qt_mac_execute_apple_script(const char *script, long script_len, AEDesc *ret) {
+    OSStatus err;
+    AEDesc scriptTextDesc;
+    ComponentInstance theComponent = 0;
+    OSAID scriptID = kOSANullScript, resultID = kOSANullScript;
+
+    // set up locals to a known state
+    AECreateDesc(typeNull, 0, 0, &scriptTextDesc);
+    scriptID = kOSANullScript;
+    resultID = kOSANullScript;
+
+    // open the scripting component
+    theComponent = OpenDefaultComponent(kOSAComponentType, typeAppleScript);
+    if (!theComponent) {
+        err = paramErr;
+        goto bail;
+    }
+
+    // put the script text into an aedesc
+    err = AECreateDesc(typeUTF8Text, script, script_len, &scriptTextDesc);
+    if (err != noErr)
+        goto bail;
+
+    // compile the script
+    err = OSACompile(theComponent, &scriptTextDesc, kOSAModeNull, &scriptID);
+    if (err != noErr)
+        goto bail;
+
+    // run the script
+    err = OSAExecute(theComponent, scriptID, kOSANullScript, kOSAModeNull, &resultID);
+
+    // collect the results - if any
+    if (ret) {
+        AECreateDesc(typeNull, 0, 0, ret);
+        if (err == errOSAScriptError)
+            OSAScriptError(theComponent, kOSAErrorMessage, typeChar, ret);
+        else if (err == noErr && resultID != kOSANullScript)
+            OSADisplay(theComponent, resultID, typeChar, kOSAModeNull, ret);
+    }
+bail:
+    AEDisposeDesc(&scriptTextDesc);
+    if (scriptID != kOSANullScript)
+        OSADispose(theComponent, scriptID);
+    if (resultID != kOSANullScript)
+        OSADispose(theComponent, resultID);
+    if (theComponent)
+        CloseComponent(theComponent);
+    return err == noErr;
+}
+
+bool qt_mac_execute_apple_script(const char *script, AEDesc *ret)
+{
+    return qt_mac_execute_apple_script(script, qstrlen(script), ret);
+}
+
+bool qt_mac_execute_apple_script(const QString &script, AEDesc *ret)
+{
+    const QByteArray l = script.toUtf8(); return qt_mac_execute_apple_script(l.constData(), l.size(), ret);
+}
+
 QString qt_mac_removeAmpersandEscapes(QString s)
 {
     int i = 0;
diff --git a/src/plugins/platforms/cocoa/qcocoasystemtrayicon.h b/src/plugins/platforms/cocoa/qcocoasystemtrayicon.h
new file mode 100755
index 0000000..c9592cd
--- /dev/null
+++ b/src/plugins/platforms/cocoa/qcocoasystemtrayicon.h
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Copyright (C) 2012 Klaralvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Christoph Schleifenbaum <christoph.schleifenbaum@kdab.com>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QCOCOASYSTEMTRAYICON_P_H
+#define QCOCOASYSTEMTRAYICON_P_H
+
+#ifndef QT_NO_SYSTEMTRAYICON
+
+#include "QtCore/qstring.h"
+#include "QtGui/qpa/qplatformsystemtrayicon.h"
+
+QT_BEGIN_NAMESPACE
+
+class QSystemTrayIconSys;
+
+class Q_GUI_EXPORT QCocoaSystemTrayIcon : public QPlatformSystemTrayIcon
+{
+public:
+    QCocoaSystemTrayIcon() : m_sys(0) {}
+
+    virtual void init();
+    virtual void cleanup();
+    virtual void updateIcon(const QIcon &icon);
+    virtual void updateToolTip(const QString &toolTip);
+    virtual void updateMenu(QPlatformMenu *menu);
+    virtual QRect geometry() const;
+    virtual void showMessage(const QString &msg, const QString &title,
+                             const QIcon& icon, MessageIcon iconType, int secs);
+
+    virtual bool isSystemTrayAvailable() const;
+    virtual bool supportsMessages() const;
+
+private:
+    QSystemTrayIconSys *m_sys;
+};
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_SYSTEMTRAYICON
+
+#endif // QCOCOASYSTEMTRAYICON_P_H
diff --git a/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm b/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
new file mode 100755
index 0000000..ce775fd
--- /dev/null
+++ b/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
@@ -0,0 +1,465 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Copyright (C) 2012 Klaralvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Christoph Schleifenbaum <christoph.schleifenbaum@kdab.com>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/****************************************************************************
+**
+** Copyright (c) 2007-2008, Apple, Inc.
+**
+** All rights reserved.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**
+**   * Redistributions of source code must retain the above copyright notice,
+**     this list of conditions and the following disclaimer.
+**
+**   * Redistributions in binary form must reproduce the above copyright notice,
+**     this list of conditions and the following disclaimer in the documentation
+**     and/or other materials provided with the distribution.
+**
+**   * Neither the name of Apple, Inc. nor the names of its contributors
+**     may be used to endorse or promote products derived from this software
+**     without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+** CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+** EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+** PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+****************************************************************************/
+
+#define QT_MAC_SYSTEMTRAY_USE_GROWL
+
+#include "qcocoasystemtrayicon.h"
+#include <qtemporaryfile.h>
+#include <qimagewriter.h>
+#include <qapplication.h>
+#include <qdebug.h>
+
+#include "qcocoamenu.h"
+
+#include "qt_mac_p.h"
+#include "qcocoahelpers.h"
+
+#import <AppKit/AppKit.h>
+
+QT_USE_NAMESPACE
+
+@class QT_MANGLE_NAMESPACE(QNSMenu);
+@class QT_MANGLE_NAMESPACE(QNSImageView);
+
+@interface QT_MANGLE_NAMESPACE(QNSStatusItem) : NSObject {
+@public
+    QCocoaSystemTrayIcon *systray;
+    NSStatusItem *item;
+    QCocoaMenu *menu;
+    bool menuVisible;
+    QIcon icon;
+    QT_MANGLE_NAMESPACE(QNSImageView) *imageCell;
+}
+-(id)initWithSysTray:(QCocoaSystemTrayIcon *)systray;
+-(void)dealloc;
+-(NSStatusItem*)item;
+-(QRectF)geometry;
+- (void)triggerSelector:(id)sender button:(Qt::MouseButton)mouseButton;
+- (void)doubleClickSelector:(id)sender;
+@end
+
+@interface QT_MANGLE_NAMESPACE(QNSImageView) : NSImageView {
+    BOOL down;
+    QT_MANGLE_NAMESPACE(QNSStatusItem) *parent;
+}
+-(id)initWithParent:(QT_MANGLE_NAMESPACE(QNSStatusItem)*)myParent;
+-(void)menuTrackingDone:(NSNotification*)notification;
+-(void)mousePressed:(NSEvent *)mouseEvent button:(Qt::MouseButton)mouseButton;
+@end
+
+@interface QT_MANGLE_NAMESPACE(QNSMenu) : NSMenu <NSMenuDelegate> {
+    QPlatformMenu *qmenu;
+}
+-(QPlatformMenu*)menu;
+-(id)initWithQMenu:(QPlatformMenu*)qmenu;
+@end
+
+QT_BEGIN_NAMESPACE
+class QSystemTrayIconSys
+{
+public:
+    QSystemTrayIconSys(QCocoaSystemTrayIcon *sys) {
+        item = [[QT_MANGLE_NAMESPACE(QNSStatusItem) alloc] initWithSysTray:sys];
+    }
+    ~QSystemTrayIconSys() {
+        [[[item item] view] setHidden: YES];
+        [item release];
+    }
+    QT_MANGLE_NAMESPACE(QNSStatusItem) *item;
+};
+
+void QCocoaSystemTrayIcon::init()
+{
+    if (!m_sys)
+        m_sys = new QSystemTrayIconSys(this);
+}
+
+QRect QCocoaSystemTrayIcon::geometry() const
+{
+    if (!m_sys)
+        return QRect();
+
+    const QRectF geom = [m_sys->item geometry];
+    if (!geom.isNull())
+        return geom.toRect();
+    else
+        return QRect();
+}
+
+void QCocoaSystemTrayIcon::cleanup()
+{
+    delete m_sys;
+    m_sys = 0;
+}
+
+void QCocoaSystemTrayIcon::updateIcon(const QIcon &icon)
+{
+    if (!m_sys)
+        return;
+
+    m_sys->item->icon = icon;
+
+    const bool menuVisible = m_sys->item->menu && m_sys->item->menuVisible;
+
+    CGFloat hgt = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
+    const short scale = hgt - 4;
+
+    QPixmap pm = m_sys->item->icon.pixmap(QSize(scale, scale),
+                                          menuVisible ? QIcon::Selected : QIcon::Normal);
+    if (pm.isNull()) {
+        pm = QPixmap(scale, scale);
+        pm.fill(Qt::transparent);
+    }
+    NSImage *nsimage = static_cast<NSImage *>(qt_mac_create_nsimage(pm));
+    [(NSImageView*)[[m_sys->item item] view] setImage: nsimage];
+    [nsimage release];
+}
+
+void QCocoaSystemTrayIcon::updateMenu(QPlatformMenu *menu)
+{
+    if (!m_sys)
+        return;
+
+    m_sys->item->menu = static_cast<QCocoaMenu *>(menu);
+    if (menu && [m_sys->item->menu->nsMenu() numberOfItems] > 0) {
+        [[m_sys->item item] setHighlightMode:YES];
+    } else {
+        [[m_sys->item item] setHighlightMode:NO];
+    }
+}
+
+void QCocoaSystemTrayIcon::updateToolTip(const QString &toolTip)
+{
+    if (!m_sys)
+        return;
+    [[[m_sys->item item] view] setToolTip:QCFString::toNSString(toolTip)];
+}
+
+bool QCocoaSystemTrayIcon::isSystemTrayAvailable() const
+{
+    return true;
+}
+
+bool QCocoaSystemTrayIcon::supportsMessages() const
+{
+    return true;
+}
+
+void QCocoaSystemTrayIcon::showMessage(const QString &title, const QString &message,
+                                       const QIcon& icon, MessageIcon, int)
+{
+    if (!m_sys)
+        return;
+
+#ifdef QT_MAC_SYSTEMTRAY_USE_GROWL
+    // Make sure that we have Growl installed on the machine we are running on.
+    QCFType<CFURLRef> cfurl;
+    OSStatus status = LSGetApplicationForInfo(kLSUnknownType, kLSUnknownCreator,
+                                              CFSTR("growlTicket"), kLSRolesAll, 0, &cfurl);
+    if (status == kLSApplicationNotFoundErr)
+        return;
+    QCFType<CFBundleRef> bundle = CFBundleCreate(0, cfurl);
+
+    if (CFStringCompare(CFBundleGetIdentifier(bundle), CFSTR("com.Growl.GrowlHelperApp"),
+                kCFCompareCaseInsensitive |  kCFCompareBackwards) != kCFCompareEqualTo)
+        return;
+    QPixmap notificationIconPixmap = icon.pixmap(32, 32);
+    QTemporaryFile notificationIconFile;
+    QString notificationType(QLatin1String("Notification")), notificationIcon, notificationApp(QApplication::applicationName());
+    if (notificationApp.isEmpty())
+        notificationApp = QLatin1String("Application");
+    if (!notificationIconPixmap.isNull() && notificationIconFile.open()) {
+        QImageWriter writer(&notificationIconFile, "PNG");
+        if (writer.write(notificationIconPixmap.toImage()))
+            notificationIcon = QLatin1String("image from location \"file://") + notificationIconFile.fileName() + QLatin1String("\"");
+    }
+    const QString script(QLatin1String(
+        "tell application \"System Events\"\n"
+        "set isRunning to (count of (every process whose bundle identifier is \"com.Growl.GrowlHelperApp\")) > 0\n"
+        "end tell\n"
+        "if isRunning\n"
+        "tell application id \"com.Growl.GrowlHelperApp\"\n"
+        "-- Make a list of all the notification types (all)\n"
+        "set the allNotificationsList to {\"") + notificationType + QLatin1String("\"}\n"
+
+        "-- Make a list of the notifications (enabled)\n"
+        "set the enabledNotificationsList to {\"") + notificationType + QLatin1String("\"}\n"
+
+        "-- Register our script with growl.\n"
+        "register as application \"") + notificationApp + QLatin1String("\" all notifications allNotificationsList default notifications enabledNotificationsList\n"
+
+        "-- Send a Notification...\n") +
+        QLatin1String("notify with name \"") + notificationType +
+        QLatin1String("\" title \"") + title +
+        QLatin1String("\" description \"") + message +
+        QLatin1String("\" application name \"") + notificationApp +
+        QLatin1String("\" ")  + notificationIcon +
+        QLatin1String("\nend tell\nend if"));
+    qt_mac_execute_apple_script(script, 0);
+#else
+    Q_UNUSED(icon);
+    Q_UNUSED(title);
+    Q_UNUSED(message);
+#endif
+}
+QT_END_NAMESPACE
+
+@implementation NSStatusItem (Qt)
+@end
+
+@implementation QT_MANGLE_NAMESPACE(QNSImageView)
+-(id)initWithParent:(QT_MANGLE_NAMESPACE(QNSStatusItem)*)myParent {
+    self = [super init];
+    parent = myParent;
+    down = NO;
+    return self;
+}
+
+-(void)menuTrackingDone:(NSNotification*)notification
+{
+    Q_UNUSED(notification);
+    down = NO;
+
+    CGFloat hgt = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
+    const short scale = hgt - 4;
+
+    QPixmap pm = parent->icon.pixmap(QSize(scale, scale), QIcon::Normal);
+    if (pm.isNull()) {
+        pm = QPixmap(scale, scale);
+        pm.fill(Qt::transparent);
+    }
+    NSImage *nsaltimage = static_cast<NSImage *>(qt_mac_create_nsimage(pm));
+    [self setImage: nsaltimage];
+    [nsaltimage release];
+
+    parent->menuVisible = false;
+
+    [self setNeedsDisplay:YES];
+}
+
+-(void)mousePressed:(NSEvent *)mouseEvent button:(Qt::MouseButton)mouseButton
+{
+    down = YES;
+    int clickCount = [mouseEvent clickCount];
+    [self setNeedsDisplay:YES];
+
+    CGFloat hgt = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
+    const short scale = hgt - 4;
+
+    QPixmap pm = parent->icon.pixmap(QSize(scale, scale),
+                                     parent->menuVisible ? QIcon::Selected : QIcon::Normal);
+    if (pm.isNull()) {
+        pm = QPixmap(scale, scale);
+        pm.fill(Qt::transparent);
+    }
+    NSImage *nsaltimage = static_cast<NSImage *>(qt_mac_create_nsimage(pm));
+    [self setImage: nsaltimage];
+    [nsaltimage release];
+
+    if (clickCount == 2) {
+        [self menuTrackingDone:nil];
+        [parent doubleClickSelector:self];
+    } else {
+        [parent triggerSelector:self button:mouseButton];
+    }
+}
+
+-(void)mouseDown:(NSEvent *)mouseEvent
+{
+    [self mousePressed:mouseEvent button:Qt::LeftButton];
+}
+
+-(void)mouseUp:(NSEvent *)mouseEvent
+{
+    Q_UNUSED(mouseEvent);
+    [self menuTrackingDone:nil];
+}
+
+- (void)rightMouseDown:(NSEvent *)mouseEvent
+{
+    [self mousePressed:mouseEvent button:Qt::RightButton];
+}
+
+-(void)rightMouseUp:(NSEvent *)mouseEvent
+{
+    Q_UNUSED(mouseEvent);
+    [self menuTrackingDone:nil];
+}
+
+- (void)otherMouseDown:(NSEvent *)mouseEvent
+{
+    [self mousePressed:mouseEvent button:cocoaButton2QtButton([mouseEvent buttonNumber])];
+}
+
+-(void)otherMouseUp:(NSEvent *)mouseEvent
+{
+    Q_UNUSED(mouseEvent);
+    [self menuTrackingDone:nil];
+}
+
+-(void)drawRect:(NSRect)rect {
+    [[parent item] drawStatusBarBackgroundInRect:rect withHighlight:down];
+    [super drawRect:rect];
+}
+@end
+
+@implementation QT_MANGLE_NAMESPACE(QNSStatusItem)
+
+-(id)initWithSysTray:(QCocoaSystemTrayIcon *)sys
+{
+    self = [super init];
+    if (self) {
+        item = [[[NSStatusBar systemStatusBar] statusItemWithLength:NSSquareStatusItemLength] retain];
+        menu = 0;
+        menuVisible = false;
+        systray = sys;
+        imageCell = [[QT_MANGLE_NAMESPACE(QNSImageView) alloc] initWithParent:self];
+        [item setView: imageCell];
+    }
+    return self;
+}
+
+-(void)dealloc {
+    [[NSStatusBar systemStatusBar] removeStatusItem:item];
+    [imageCell release];
+    [item release];
+    [super dealloc];
+
+}
+
+-(NSStatusItem*)item {
+    return item;
+}
+-(QRectF)geometry {
+    if (NSWindow *window = [[item view] window]) {
+        NSRect screenRect = [[window screen] frame];
+        NSRect windowRect = [window frame];
+        return QRectF(windowRect.origin.x, screenRect.size.height-windowRect.origin.y-windowRect.size.height, windowRect.size.width, windowRect.size.height);
+    }
+    return QRectF();
+}
+
+- (void)triggerSelector:(id)sender button:(Qt::MouseButton)mouseButton {
+    Q_UNUSED(sender);
+    if (!systray)
+        return;
+
+    if (mouseButton == Qt::MidButton)
+        emit systray->activated(QPlatformSystemTrayIcon::MiddleClick);
+    else
+        emit systray->activated(QPlatformSystemTrayIcon::Trigger);
+
+    if (menu) {
+        NSMenu *m = menu->nsMenu();
+        [[NSNotificationCenter defaultCenter] addObserver:imageCell
+         selector:@selector(menuTrackingDone:)
+             name:NSMenuDidEndTrackingNotification
+                 object:m];
+        menuVisible = true;
+        [item popUpStatusItemMenu: m];
+    }
+}
+
+- (void)doubleClickSelector:(id)sender {
+    Q_UNUSED(sender);
+    if (!systray)
+        return;
+    emit systray->activated(QPlatformSystemTrayIcon::DoubleClick);
+}
+
+@end
+
+class QSystemTrayIconQMenu : public QPlatformMenu
+{
+public:
+    void doAboutToShow() { emit aboutToShow(); }
+private:
+    QSystemTrayIconQMenu();
+};
+
+@implementation QT_MANGLE_NAMESPACE(QNSMenu)
+-(id)initWithQMenu:(QPlatformMenu*)qm {
+    self = [super init];
+    if (self) {
+        self->qmenu = qm;
+        [self setDelegate:self];
+    }
+    return self;
+}
+-(QPlatformMenu*)menu {
+    return qmenu;
+}
+@end
diff --git a/src/plugins/platforms/cocoa/qcocoatheme.h b/src/plugins/platforms/cocoa/qcocoatheme.h
index 3c071d4..dad3f86 100644
--- a/src/plugins/platforms/cocoa/qcocoatheme.h
+++ b/src/plugins/platforms/cocoa/qcocoatheme.h
@@ -58,6 +58,10 @@ public:
     virtual QPlatformMenu* createPlatformMenu() const;
     virtual QPlatformMenuBar* createPlatformMenuBar() const;
 
+#ifndef QT_NO_SYSTEMTRAYICON
+    QPlatformSystemTrayIcon *createPlatformSystemTrayIcon() const;
+#endif
+
     bool usePlatformNativeDialog(DialogType dialogType) const;
     QPlatformDialogHelper *createPlatformDialogHelper(DialogType dialogType) const;
 
diff --git a/src/plugins/platforms/cocoa/qcocoatheme.mm b/src/plugins/platforms/cocoa/qcocoatheme.mm
index 0eb2136..6d4e240 100644
--- a/src/plugins/platforms/cocoa/qcocoatheme.mm
+++ b/src/plugins/platforms/cocoa/qcocoatheme.mm
@@ -47,6 +47,7 @@
 #include "qcocoafiledialoghelper.h"
 #include "qcocoafontdialoghelper.h"
 #include "qcocoasystemsettings.h"
+#include "qcocoasystemtrayicon.h"
 #include "qcocoamenuitem.h"
 #include "qcocoamenu.h"
 #include "qcocoamenubar.h"
@@ -103,6 +104,13 @@ QPlatformDialogHelper * QCocoaTheme::createPlatformDialogHelper(DialogType dialo
     }
 }
 
+#ifndef QT_NO_SYSTEMTRAYICON
+QPlatformSystemTrayIcon *QCocoaTheme::createPlatformSystemTrayIcon() const
+{
+    return new QCocoaSystemTrayIcon;
+}
+#endif
+
 const QPalette *QCocoaTheme::palette(Palette type) const
 {
     if (type == SystemPalette) {
diff --git a/src/widgets/util/qsystemtrayicon.cpp b/src/widgets/util/qsystemtrayicon.cpp
index b3af279..343a3c1 100644
--- a/src/widgets/util/qsystemtrayicon.cpp
+++ b/src/widgets/util/qsystemtrayicon.cpp
@@ -391,6 +391,12 @@ void QSystemTrayIcon::showMessage(const QString& title, const QString& msg,
         d->showMessage_sys(title, msg, icon, msecs);
 }
 
+void QSystemTrayIconPrivate::emitActivated(QPlatformSystemTrayIcon::ActivationReason reason)
+{
+    Q_Q(QSystemTrayIcon);
+    emit q->activated(static_cast<QSystemTrayIcon::ActivationReason>(reason));
+}
+
 //////////////////////////////////////////////////////////////////////
 static QBalloonTip *theSolitaryBalloonTip = 0;
 
@@ -665,11 +671,8 @@ void QBalloonTip::timerEvent(QTimerEvent *e)
     QWidget::timerEvent(e);
 }
 
-void qtsystray_sendActivated(QSystemTrayIcon *i, int r)
-{
-    emit i->activated((QSystemTrayIcon::ActivationReason)r);
-}
-
 QT_END_NAMESPACE
 
 #endif // QT_NO_SYSTEMTRAYICON
+
+#include "moc_qsystemtrayicon.cpp"
diff --git a/src/widgets/util/qsystemtrayicon.h b/src/widgets/util/qsystemtrayicon.h
index b2ca5f0..ee640b2 100644
--- a/src/widgets/util/qsystemtrayicon.h
+++ b/src/widgets/util/qsystemtrayicon.h
@@ -118,9 +118,10 @@ private:
     Q_DISABLE_COPY(QSystemTrayIcon)
     Q_DECLARE_PRIVATE(QSystemTrayIcon)
 
+    Q_PRIVATE_SLOT(d_func(), void emitActivated(QPlatformSystemTrayIcon::ActivationReason))
+
     friend class QSystemTrayIconSys;
     friend class QBalloonTip;
-    friend void qtsystray_sendActivated(QSystemTrayIcon *, int);
 };
 
 QT_END_NAMESPACE
diff --git a/src/widgets/util/qsystemtrayicon_mac.mm b/src/widgets/util/qsystemtrayicon_mac.mm
deleted file mode 100644
index 7f7d7cd..0000000
--- a/src/widgets/util/qsystemtrayicon_mac.mm
+++ /dev/null
@@ -1,562 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/****************************************************************************
-**
-** Copyright (c) 2007-2008, Apple, Inc.
-**
-** All rights reserved.
-**
-** Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are met:
-**
-**   * Redistributions of source code must retain the above copyright notice,
-**     this list of conditions and the following disclaimer.
-**
-**   * Redistributions in binary form must reproduce the above copyright notice,
-**     this list of conditions and the following disclaimer in the documentation
-**     and/or other materials provided with the distribution.
-**
-**   * Neither the name of Apple, Inc. nor the names of its contributors
-**     may be used to endorse or promote products derived from this software
-**     without specific prior written permission.
-**
-** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-** CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-** EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-** PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-**
-****************************************************************************/
-
-#define QT_MAC_SYSTEMTRAY_USE_GROWL
-
-#include <private/qt_cocoa_helpers_mac_p.h>
-#include <private/qsystemtrayicon_p.h>
-#include <qtemporaryfile.h>
-#include <qimagewriter.h>
-#include <qapplication.h>
-#include <qdebug.h>
-#include <qstyle.h>
-
-#include <private/qt_mac_p.h>
-#import <AppKit/AppKit.h>
-
-QT_BEGIN_NAMESPACE
-extern bool qt_mac_execute_apple_script(const QString &script, AEDesc *ret); //qapplication_mac.cpp
-extern void qtsystray_sendActivated(QSystemTrayIcon *i, int r); //qsystemtrayicon.cpp
-extern NSString *keySequenceToKeyEqivalent(const QKeySequence &accel); // qmenu_mac.mm
-extern NSUInteger keySequenceModifierMask(const QKeySequence &accel);  // qmenu_mac.mm
-extern Qt::MouseButton cocoaButton2QtButton(NSInteger buttonNum);
-QT_END_NAMESPACE
-
-QT_USE_NAMESPACE
-
-@class QT_MANGLE_NAMESPACE(QNSMenu);
-@class QT_MANGLE_NAMESPACE(QNSImageView);
-
-@interface QT_MANGLE_NAMESPACE(QNSStatusItem) : NSObject {
-    NSStatusItem *item;
-    QSystemTrayIcon *icon;
-    QSystemTrayIconPrivate *iconPrivate;
-    QT_MANGLE_NAMESPACE(QNSImageView) *imageCell;
-}
--(id)initWithIcon:(QSystemTrayIcon*)icon iconPrivate:(QSystemTrayIconPrivate *)iprivate;
--(void)dealloc;
--(QSystemTrayIcon*)icon;
--(NSStatusItem*)item;
--(QRectF)geometry;
-- (void)triggerSelector:(id)sender button:(Qt::MouseButton)mouseButton;
-- (void)doubleClickSelector:(id)sender;
-@end
-
-@interface QT_MANGLE_NAMESPACE(QNSImageView) : NSImageView {
-    BOOL down;
-    QT_MANGLE_NAMESPACE(QNSStatusItem) *parent;
-}
--(id)initWithParent:(QT_MANGLE_NAMESPACE(QNSStatusItem)*)myParent;
--(QSystemTrayIcon*)icon;
--(void)menuTrackingDone:(NSNotification*)notification;
--(void)mousePressed:(NSEvent *)mouseEvent button:(Qt::MouseButton)mouseButton;
-@end
-
-
-#if MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_5
-
-@protocol NSMenuDelegate <NSObject>
--(void)menuNeedsUpdate:(NSMenu*)menu;
-@end
-#endif
-
-
-@interface QT_MANGLE_NAMESPACE(QNSMenu) : NSMenu <NSMenuDelegate> {
-    QMenu *qmenu;
-}
--(QMenu*)menu;
--(id)initWithQMenu:(QMenu*)qmenu;
--(void)selectedAction:(id)item;
-@end
-
-QT_BEGIN_NAMESPACE
-class QSystemTrayIconSys
-{
-public:
-    QSystemTrayIconSys(QSystemTrayIcon *icon, QSystemTrayIconPrivate *d) {
-        QMacCocoaAutoReleasePool pool;
-        item = [[QT_MANGLE_NAMESPACE(QNSStatusItem) alloc] initWithIcon:icon iconPrivate:d];
-    }
-    ~QSystemTrayIconSys() {
-        QMacCocoaAutoReleasePool pool;
-        [[[item item] view] setHidden: YES];
-        [item release];
-    }
-    QT_MANGLE_NAMESPACE(QNSStatusItem) *item;
-};
-
-void QSystemTrayIconPrivate::install_sys()
-{
-    Q_Q(QSystemTrayIcon);
-    if (!sys) {
-        sys = new QSystemTrayIconSys(q, this);
-        updateIcon_sys();
-        updateMenu_sys();
-        updateToolTip_sys();
-    }
-}
-
-QRect QSystemTrayIconPrivate::geometry_sys() const
-{
-    if(sys) {
-        const QRectF geom = [sys->item geometry];
-        if(!geom.isNull())
-            return geom.toRect();
-    }
-    return QRect();
-}
-
-void QSystemTrayIconPrivate::remove_sys()
-{
-    delete sys;
-    sys = 0;
-}
-
-void QSystemTrayIconPrivate::updateIcon_sys()
-{
-    if(sys && !icon.isNull()) {
-        QMacCocoaAutoReleasePool pool;
-        CGFloat hgt = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
-        const short scale = hgt - 4;
-        NSImage *nsimage = static_cast<NSImage *>(qt_mac_create_nsimage(icon.pixmap(QSize(scale, scale))));
-        [(NSImageView*)[[sys->item item] view] setImage: nsimage];
-        [nsimage release];
-    }
-}
-
-void QSystemTrayIconPrivate::updateMenu_sys()
-{
-    if(sys) {
-        QMacCocoaAutoReleasePool pool;
-        if(menu && !menu->isEmpty()) {
-            [[sys->item item] setHighlightMode:YES];
-        } else {
-            [[sys->item item] setHighlightMode:NO];
-        }
-    }
-}
-
-void QSystemTrayIconPrivate::updateToolTip_sys()
-{
-    if(sys) {
-        QMacCocoaAutoReleasePool pool;
-        QCFString string(toolTip);
-        [[[sys->item item] view] setToolTip:(NSString*)static_cast<CFStringRef>(string)];
-    }
-}
-
-bool QSystemTrayIconPrivate::isSystemTrayAvailable_sys()
-{
-    return true;
-}
-
-bool QSystemTrayIconPrivate::supportsMessages_sys()
-{
-    return true;
-}
-
-void QSystemTrayIconPrivate::showMessage_sys(const QString &title, const QString &message, QSystemTrayIcon::MessageIcon icon, int)
-{
-
-    if(sys) {
-#ifdef QT_MAC_SYSTEMTRAY_USE_GROWL
-        // Make sure that we have Growl installed on the machine we are running on.
-        QCFType<CFURLRef> cfurl;
-        OSStatus status = LSGetApplicationForInfo(kLSUnknownType, kLSUnknownCreator,
-                                                  CFSTR("growlTicket"), kLSRolesAll, 0, &cfurl);
-        if (status == kLSApplicationNotFoundErr)
-            return;
-        QCFType<CFBundleRef> bundle = CFBundleCreate(0, cfurl);
-
-        if (CFStringCompare(CFBundleGetIdentifier(bundle), CFSTR("com.Growl.GrowlHelperApp"),
-                    kCFCompareCaseInsensitive |  kCFCompareBackwards) != kCFCompareEqualTo)
-            return;
-        QPixmap notificationIconPixmap;
-        if(icon == QSystemTrayIcon::Information)
-            notificationIconPixmap = QApplication::style()->standardPixmap(QStyle::SP_MessageBoxInformation);
-        else if(icon == QSystemTrayIcon::Warning)
-            notificationIconPixmap = QApplication::style()->standardPixmap(QStyle::SP_MessageBoxWarning);
-        else if(icon == QSystemTrayIcon::Critical)
-            notificationIconPixmap = QApplication::style()->standardPixmap(QStyle::SP_MessageBoxCritical);
-        QTemporaryFile notificationIconFile;
-        QString notificationType(QLatin1String("Notification")), notificationIcon, notificationApp(QApplication::applicationName());
-        if(notificationApp.isEmpty())
-            notificationApp = QLatin1String("Application");
-        if(!notificationIconPixmap.isNull() && notificationIconFile.open()) {
-            QImageWriter writer(&notificationIconFile, "PNG");
-            if(writer.write(notificationIconPixmap.toImage()))
-                notificationIcon = QLatin1String("image from location \"file://") + notificationIconFile.fileName() + QLatin1String("\"");
-        }
-        const QString script(QLatin1String(
-            "tell application \"System Events\"\n"
-            "set isRunning to (count of (every process whose bundle identifier is \"com.Growl.GrowlHelperApp\")) > 0\n"
-            "end tell\n"
-            "if isRunning\n"
-            "tell application id \"com.Growl.GrowlHelperApp\"\n"
-            "-- Make a list of all the notification types (all)\n"
-            "set the allNotificationsList to {\"") + notificationType + QLatin1String("\"}\n"
-
-            "-- Make a list of the notifications (enabled)\n"
-            "set the enabledNotificationsList to {\"") + notificationType + QLatin1String("\"}\n"
-
-            "-- Register our script with growl.\n"
-            "register as application \"") + notificationApp + QLatin1String("\" all notifications allNotificationsList default notifications enabledNotificationsList\n"
-
-            "--	Send a Notification...\n") +
-            QLatin1String("notify with name \"") + notificationType +
-            QLatin1String("\" title \"") + title +
-            QLatin1String("\" description \"") + message +
-            QLatin1String("\" application name \"") + notificationApp +
-            QLatin1String("\" ")  + notificationIcon +
-            QLatin1String("\nend tell\nend if"));
-        qt_mac_execute_apple_script(script, 0);
-#elif 0
-        Q_Q(QSystemTrayIcon);
-        NSView *v = [[sys->item item] view];
-        NSWindow *w = [v window];
-        w = [[sys->item item] window];
-        qDebug() << w << v;
-        QPoint p(qRound([w frame].origin.x), qRound([w frame].origin.y));
-        qDebug() << p;
-        QBalloonTip::showBalloon(icon, message, title, q, QPoint(0, 0), msecs);
-#else
-        Q_UNUSED(icon);
-        Q_UNUSED(title);
-        Q_UNUSED(message);
-#endif
-    }
-}
-QT_END_NAMESPACE
-
-@implementation NSStatusItem (Qt)
-@end
-
-@implementation QT_MANGLE_NAMESPACE(QNSImageView)
--(id)initWithParent:(QT_MANGLE_NAMESPACE(QNSStatusItem)*)myParent {
-    self = [super init];
-    parent = myParent;
-    down = NO;
-    return self;
-}
-
--(QSystemTrayIcon*)icon {
-    return [parent icon];
-}
-
--(void)menuTrackingDone:(NSNotification*)notification
-{
-    Q_UNUSED(notification);
-    down = NO;
-
-    if( ![self icon]->icon().isNull() ) {
-        CGFloat hgt = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
-        const short scale = hgt - 4;
-        NSImage *nsimage = static_cast<NSImage *>(qt_mac_create_nsimage([self icon]->icon().pixmap(QSize(scale, scale))));
-        [self setImage: nsimage];
-        [nsimage release];
-    }
-
-    if([self icon]->contextMenu())
-        [self icon]->contextMenu()->hide();
-
-    [self setNeedsDisplay:YES];
-}
-
--(void)mousePressed:(NSEvent *)mouseEvent button:(Qt::MouseButton)mouseButton
-{
-    down = YES;
-    int clickCount = [mouseEvent clickCount];  
-    [self setNeedsDisplay:YES];
-
-    CGFloat hgt = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
-    const short scale = hgt - 4;
-
-    if (![self icon]->icon().isNull() ) {
-        NSImage *nsaltimage = static_cast<NSImage *>(qt_mac_create_nsimage([self icon]->icon().pixmap(QSize(scale, scale), QIcon::Selected)));
-        [self setImage: nsaltimage];
-        [nsaltimage release];
-    }
-
-    if ((clickCount == 2)) {
-        [self menuTrackingDone:nil];
-        [parent doubleClickSelector:self];
-    } else {
-        [parent triggerSelector:self button:mouseButton];
-    }
-}
-
--(void)mouseDown:(NSEvent *)mouseEvent
-{
-    [self mousePressed:mouseEvent button:Qt::LeftButton];
-}
-
--(void)mouseUp:(NSEvent *)mouseEvent
-{
-    Q_UNUSED(mouseEvent);
-    [self menuTrackingDone:nil];
-}
-
-- (void)rightMouseDown:(NSEvent *)mouseEvent
-{
-    [self mousePressed:mouseEvent button:Qt::RightButton];
-}
-
--(void)rightMouseUp:(NSEvent *)mouseEvent
-{
-    Q_UNUSED(mouseEvent);
-    [self menuTrackingDone:nil];
-}
-
-- (void)otherMouseDown:(NSEvent *)mouseEvent
-{
-    [self mousePressed:mouseEvent button:cocoaButton2QtButton([mouseEvent buttonNumber])];
-}
-
--(void)otherMouseUp:(NSEvent *)mouseEvent
-{
-    Q_UNUSED(mouseEvent);
-    [self menuTrackingDone:nil];
-}
-
--(void)drawRect:(NSRect)rect {
-    [[parent item] drawStatusBarBackgroundInRect:rect withHighlight:down];
-    [super drawRect:rect];
-}
-@end
-
-@implementation QT_MANGLE_NAMESPACE(QNSStatusItem)
-
--(id)initWithIcon:(QSystemTrayIcon*)i iconPrivate:(QSystemTrayIconPrivate *)iPrivate
-{
-    self = [super init];
-    if(self) {
-        icon = i;
-        iconPrivate = iPrivate;
-        item = [[[NSStatusBar systemStatusBar] statusItemWithLength:NSSquareStatusItemLength] retain];
-        imageCell = [[QT_MANGLE_NAMESPACE(QNSImageView) alloc] initWithParent:self];
-        [item setView: imageCell];
-    }
-    return self;
-}
--(void)dealloc {
-    [[NSStatusBar systemStatusBar] removeStatusItem:item];
-    [imageCell release];
-    [item release];
-    [super dealloc];
-
-}
-
--(QSystemTrayIcon*)icon {
-    return icon;
-}
-
--(NSStatusItem*)item {
-    return item;
-}
--(QRectF)geometry {
-    if(NSWindow *window = [[item view] window]) {
-        NSRect screenRect = [[window screen] frame];
-        NSRect windowRect = [window frame];
-        return QRectF(windowRect.origin.x, screenRect.size.height-windowRect.origin.y-windowRect.size.height, windowRect.size.width, windowRect.size.height);
-    }
-    return QRectF();
-}
-
-- (void)triggerSelector:(id)sender button:(Qt::MouseButton)mouseButton {
-    Q_UNUSED(sender);
-    if (!icon)
-        return;
-
-    if (mouseButton == Qt::MidButton)
-        qtsystray_sendActivated(icon, QSystemTrayIcon::MiddleClick);
-    else
-        qtsystray_sendActivated(icon, QSystemTrayIcon::Trigger);
-
-    if (icon->contextMenu()) {
-        NSMenu *m = [[QT_MANGLE_NAMESPACE(QNSMenu) alloc] initWithQMenu:icon->contextMenu()];
-        [m setAutoenablesItems: NO];
-        [[NSNotificationCenter defaultCenter] addObserver:imageCell
-         selector:@selector(menuTrackingDone:)
-             name:NSMenuDidEndTrackingNotification
-                 object:m];
-        [item popUpStatusItemMenu: m];
-        [m release];
-    }
-}
-
-- (void)doubleClickSelector:(id)sender {
-    Q_UNUSED(sender);
-    if(!icon)
-        return;
-    qtsystray_sendActivated(icon, QSystemTrayIcon::DoubleClick);
-}
-
-@end
-
-class QSystemTrayIconQMenu : public QMenu
-{
-public:
-    void doAboutToShow() { emit aboutToShow(); }
-private:
-    QSystemTrayIconQMenu();
-};
-
-@implementation QT_MANGLE_NAMESPACE(QNSMenu)
--(id)initWithQMenu:(QMenu*)qm {
-    self = [super init];
-    if(self) {
-        self->qmenu = qm;
-        [self setDelegate:self];
-    }
-    return self;
-}
--(QMenu*)menu {
-    return qmenu;
-}
--(void)menuNeedsUpdate:(NSMenu*)nsmenu {
-    QT_MANGLE_NAMESPACE(QNSMenu) *menu = static_cast<QT_MANGLE_NAMESPACE(QNSMenu) *>(nsmenu);
-    emit static_cast<QSystemTrayIconQMenu*>(menu->qmenu)->doAboutToShow();
-    for(int i = [menu numberOfItems]-1; i >= 0; --i)
-        [menu removeItemAtIndex:i];
-    QList<QAction*> actions = menu->qmenu->actions();;
-    for(int i = 0; i < actions.size(); ++i) {
-        const QAction *action = actions[i];
-        if(!action->isVisible())
-            continue;
-
-        NSMenuItem *item = 0;
-        bool needRelease = false;
-        if(action->isSeparator()) {
-            item = [NSMenuItem separatorItem];
-        } else {
-            item = [[NSMenuItem alloc] init];
-            needRelease = true;
-            QString text = action->text();
-            QKeySequence accel = action->shortcut();
-            {
-                int st = text.lastIndexOf(QLatin1Char('\t'));
-                if(st != -1) {
-                    accel = QKeySequence(text.right(text.length()-(st+1)));
-                    text.remove(st, text.length()-st);
-                }
-            }
-            if(accel.count() > 1)
-                text += QLatin1String(" (****)"); //just to denote a multi stroke shortcut
-
-            [item setTitle:(NSString*)QCFString::toCFStringRef(qt_mac_removeMnemonics(text))];
-            [item setEnabled:menu->qmenu->isEnabled() && action->isEnabled()];
-            [item setState:action->isChecked() ? NSOnState : NSOffState];
-            [item setToolTip:(NSString*)QCFString::toCFStringRef(action->toolTip())];
-            const QIcon icon = action->icon();
-            if(!icon.isNull()) {
-                const short scale = [[NSApp mainMenu] menuBarHeight];
-                NSImage *nsimage = static_cast<NSImage *>(qt_mac_create_nsimage(icon.pixmap(QSize(scale, scale))));
-                [item setImage: nsimage];
-                [nsimage release];
-            }
-            if(action->menu()) {
-                QT_MANGLE_NAMESPACE(QNSMenu) *sub = [[QT_MANGLE_NAMESPACE(QNSMenu) alloc] initWithQMenu:action->menu()];
-                [item setSubmenu:sub];
-            } else {
-                [item setAction:@selector(selectedAction:)];
-                [item setTarget:self];
-            }
-            if(!accel.isEmpty()) {
-                [item setKeyEquivalent:keySequenceToKeyEqivalent(accel)];
-                [item setKeyEquivalentModifierMask:keySequenceModifierMask(accel)];
-            }
-        }
-        if(item)
-            [menu addItem:item];
-        if (needRelease)
-            [item release];
-    }
-}
--(void)selectedAction:(id)a {
-    const int activated = [self indexOfItem:a];
-    QAction *action = 0;
-    QList<QAction*> actions = qmenu->actions();
-    for(int i = 0, cnt = 0; i < actions.size(); ++i) {
-        if(actions.at(i)->isVisible() && (cnt++) == activated) {
-            action = actions.at(i);
-            break;
-        }
-    }
-    if(action) {
-        action->activate(QAction::Trigger);
-    }
-}
-@end
-
diff --git a/src/widgets/util/qsystemtrayicon_p.h b/src/widgets/util/qsystemtrayicon_p.h
index f7344df..3ab2ebc 100644
--- a/src/widgets/util/qsystemtrayicon_p.h
+++ b/src/widgets/util/qsystemtrayicon_p.h
@@ -60,12 +60,14 @@
 
 #include "QtWidgets/qmenu.h"
 #include "QtGui/qpixmap.h"
+#include <qpa/qplatformsystemtrayicon.h>
 #include "QtCore/qstring.h"
 #include "QtCore/qpointer.h"
 
 QT_BEGIN_NAMESPACE
 
 class QSystemTrayIconSys;
+class QPlatformSystemTrayIcon;
 class QToolButton;
 class QLabel;
 
@@ -74,7 +76,8 @@ class QSystemTrayIconPrivate : public QObjectPrivate
     Q_DECLARE_PUBLIC(QSystemTrayIcon)
 
 public:
-    QSystemTrayIconPrivate() : sys(0), visible(false) { }
+    QSystemTrayIconPrivate();
+    ~QSystemTrayIconPrivate();
 
     void install_sys();
     void remove_sys();
@@ -87,10 +90,13 @@ public:
     static bool isSystemTrayAvailable_sys();
     static bool supportsMessages_sys();
 
+    void emitActivated(QPlatformSystemTrayIcon::ActivationReason reason);
+
     QPointer<QMenu> menu;
     QIcon icon;
     QString toolTip;
     QSystemTrayIconSys *sys;
+    QPlatformSystemTrayIcon *qpa_sys;
     bool visible;
 };
 
diff --git a/src/widgets/util/qsystemtrayicon_qpa.cpp b/src/widgets/util/qsystemtrayicon_qpa.cpp
index be1da70..7f182bf 100644
--- a/src/widgets/util/qsystemtrayicon_qpa.cpp
+++ b/src/widgets/util/qsystemtrayicon_qpa.cpp
@@ -41,43 +41,90 @@
 
 #include "qsystemtrayicon_p.h"
 
+#include <QtGui/qpa/qplatformsystemtrayicon.h>
+#include <qpa/qplatformtheme.h>
+#include <private/qguiapplication_p.h>
+
+#include <QApplication>
+#include <QStyle>
+
 #ifndef QT_NO_SYSTEMTRAYICON
 
 QT_BEGIN_NAMESPACE
 
+QSystemTrayIconPrivate::QSystemTrayIconPrivate()
+    : qpa_sys(QGuiApplicationPrivate::platformTheme()->createPlatformSystemTrayIcon())
+    , visible(false)
+{
+}
+
+QSystemTrayIconPrivate::~QSystemTrayIconPrivate()
+{
+    delete qpa_sys;
+}
+
 void QSystemTrayIconPrivate::install_sys()
 {
+    if (qpa_sys) {
+        qpa_sys->init();
+        QObject::connect(qpa_sys, SIGNAL(activated(QPlatformSystemTrayIcon::ActivationReason)),
+                         q_func(), SLOT(emitActivated(QPlatformSystemTrayIcon::ActivationReason)));
+        QObject::connect(qpa_sys, SIGNAL(messageClicked()),
+                         q_func(), SIGNAL(messageClicked()));
+        updateMenu_sys();
+        updateIcon_sys();
+        updateToolTip_sys();
+    }
 }
 
 void QSystemTrayIconPrivate::remove_sys()
 {
+    if (qpa_sys)
+        qpa_sys->cleanup();
 }
 
 QRect QSystemTrayIconPrivate::geometry_sys() const
 {
-    return QRect();
+    if (qpa_sys)
+        return qpa_sys->geometry();
+    else
+        return QRect();
 }
 
 void QSystemTrayIconPrivate::updateIcon_sys()
 {
+    if (qpa_sys)
+        qpa_sys->updateIcon(icon);
 }
 
 void QSystemTrayIconPrivate::updateMenu_sys()
 {
+    if (qpa_sys && menu)
+        qpa_sys->updateMenu(menu->platformMenu());
 }
 
 void QSystemTrayIconPrivate::updateToolTip_sys()
 {
+    if (qpa_sys)
+        qpa_sys->updateToolTip(toolTip);
 }
 
 bool QSystemTrayIconPrivate::isSystemTrayAvailable_sys()
 {
-    return false;
+    QScopedPointer<QPlatformSystemTrayIcon> sys(QGuiApplicationPrivate::platformTheme()->createPlatformSystemTrayIcon());
+    if (sys)
+        return sys->isSystemTrayAvailable();
+    else
+        return false;
 }
 
 bool QSystemTrayIconPrivate::supportsMessages_sys()
 {
-    return false;
+    QScopedPointer<QPlatformSystemTrayIcon> sys(QGuiApplicationPrivate::platformTheme()->createPlatformSystemTrayIcon());
+    if (sys)
+        return sys->supportsMessages();
+    else
+        return false;
 }
 
 void QSystemTrayIconPrivate::showMessage_sys(const QString &message,
@@ -85,10 +132,25 @@ void QSystemTrayIconPrivate::showMessage_sys(const QString &message,
                                              QSystemTrayIcon::MessageIcon icon,
                                              int msecs)
 {
-    Q_UNUSED(message);
-    Q_UNUSED(title);
-    Q_UNUSED(icon);
-    Q_UNUSED(msecs);
+    if (!qpa_sys)
+        return;
+
+    QIcon notificationIcon;
+    switch (icon) {
+    case QSystemTrayIcon::Information:
+        notificationIcon = QApplication::style()->standardIcon(QStyle::SP_MessageBoxInformation);
+        break;
+    case QSystemTrayIcon::Warning:
+        notificationIcon = QApplication::style()->standardIcon(QStyle::SP_MessageBoxWarning);
+        break;
+    case QSystemTrayIcon::Critical:
+        notificationIcon = QApplication::style()->standardIcon(QStyle::SP_MessageBoxCritical);
+        break;
+    default:
+        break;
+    }
+    qpa_sys->showMessage(message, title, notificationIcon,
+                     static_cast<QPlatformSystemTrayIcon::MessageIcon>(icon), msecs);
 }
 
 QT_END_NAMESPACE
diff --git a/src/widgets/util/qsystemtrayicon_win.cpp b/src/widgets/util/qsystemtrayicon_win.cpp
index e81a8ee..9587510 100644
--- a/src/widgets/util/qsystemtrayicon_win.cpp
+++ b/src/widgets/util/qsystemtrayicon_win.cpp
@@ -370,6 +370,16 @@ bool QSystemTrayIconSys::winEvent( MSG *m, long *result )
     return false;
 }
 
+QSystemTrayIconPrivate::QSystemTrayIconPrivate()
+    : sys(0),
+      visible(false)
+{
+}
+
+QSystemTrayIconPrivate::~QSystemTrayIconPrivate()
+{
+}
+
 void QSystemTrayIconPrivate::install_sys()
 {
     Q_Q(QSystemTrayIcon);
diff --git a/src/widgets/util/qsystemtrayicon_wince.cpp b/src/widgets/util/qsystemtrayicon_wince.cpp
index 817c651..f71de21 100644
--- a/src/widgets/util/qsystemtrayicon_wince.cpp
+++ b/src/widgets/util/qsystemtrayicon_wince.cpp
@@ -201,6 +201,16 @@ bool QSystemTrayIconSys::winEvent( MSG *m, long *result )
     return 0;
 }
 
+QSystemTrayIconPrivate::QSystemTrayIconPrivate()
+    : sys(0),
+      visible(false)
+{
+}
+
+QSystemTrayIconPrivate::~QSystemTrayIconPrivate()
+{
+}
+
 void QSystemTrayIconPrivate::install_sys()
 {
     Q_Q(QSystemTrayIcon);
diff --git a/src/widgets/util/qsystemtrayicon_x11.cpp b/src/widgets/util/qsystemtrayicon_x11.cpp
index 07ed255..2939112 100644
--- a/src/widgets/util/qsystemtrayicon_x11.cpp
+++ b/src/widgets/util/qsystemtrayicon_x11.cpp
@@ -264,6 +264,16 @@ void QSystemTrayIconSys::paintEvent(QPaintEvent *)
 
 ////////////////////////////////////////////////////////////////////////////
 
+QSystemTrayIconPrivate::QSystemTrayIconPrivate()
+    : sys(0),
+      visible(false)
+{
+}
+
+QSystemTrayIconPrivate::~QSystemTrayIconPrivate()
+{
+}
+
 void QSystemTrayIconPrivate::install_sys()
 {
     Q_Q(QSystemTrayIcon);
diff --git a/src/widgets/util/util.pri b/src/widgets/util/util.pri
index 08574dd..5847b12 100644
--- a/src/widgets/util/util.pri
+++ b/src/widgets/util/util.pri
@@ -36,11 +36,6 @@ win32:!wince* {
     SOURCES += util/qsystemtrayicon_qpa.cpp
 }
 
-# TODO
-false:!x11:mac {
-		OBJECTIVE_SOURCES += util/qsystemtrayicon_mac.mm
-}
-
 macx {
     OBJECTIVE_SOURCES += util/qscroller_mac.mm
 }
diff --git a/tests/auto/widgets/util/qsystemtrayicon/tst_qsystemtrayicon.cpp b/tests/auto/widgets/util/qsystemtrayicon/tst_qsystemtrayicon.cpp
index 9a09af0..f73a99c 100644
--- a/tests/auto/widgets/util/qsystemtrayicon/tst_qsystemtrayicon.cpp
+++ b/tests/auto/widgets/util/qsystemtrayicon/tst_qsystemtrayicon.cpp
@@ -120,14 +120,14 @@ void tst_QSystemTrayIcon::getSetCheck()
 void tst_QSystemTrayIcon::supportsMessages()
 {
     // ### fixme: Check platforms.
-#if defined(Q_WS_QWS)
+#if defined(Q_OS_WINCE)
     QCOMPARE(QSystemTrayIcon::supportsMessages(), false);
-#elif defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
-    QCOMPARE(QSystemTrayIcon::supportsMessages(), true);
 #else
     const QString platform = QGuiApplication::platformName();
-    if (platform.compare(QStringLiteral("xcb"), Qt::CaseInsensitive)) {
-        QEXPECT_FAIL("", "QTBUG-20978 QSystemTrayIcon is unimplemented for qpa", Abort);
+    if (platform.compare(QStringLiteral("xcb"), Qt::CaseInsensitive)
+        && platform.compare(QStringLiteral("windows"), Qt::CaseInsensitive)
+        && platform.compare(QStringLiteral("cocoa"), Qt::CaseInsensitive)) {
+            QEXPECT_FAIL("", "QTBUG-20978 QSystemTrayIcon is unimplemented for this platform", Abort);
     }
     QCOMPARE(QSystemTrayIcon::supportsMessages(), true);
 #endif