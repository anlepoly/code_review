diff --git a/src/serialportengine_win.cpp b/src/serialportengine_win.cpp
index 11cd3ec..71c2c41 100755
--- a/src/serialportengine_win.cpp
+++ b/src/serialportengine_win.cpp
@@ -52,8 +52,7 @@
     \ingroup serialport-main
     \inmodule QtSerialPort
 
-    Currently the class supports all Windows NT-based OS (Win 2K/XP/Vista/7),
-    and various embedded Windows CE.
+    Currently the class supports all Windows NT-based OS (Win 2K/XP/Vista/7).
 
     WinSerialPortEngine (as well as other platform-dependent engines)
     is a class with multiple inheritance, which on the one hand,
@@ -72,18 +71,12 @@
     receive buffer, error I/O, and so forth. All events are handled in the
     Qt core event loop, so no additional threads are needed to perform these
     operations.
-
-    However, for Windows CE systems, this approach does not work, because they
-    have another Windows API. In this case, WinSerialPortEngine is derived
-    from QThread and creates an additional thread to track the events.
 */
 
 #include "serialportengine_win_p.h"
 
 #include <QtCore/qregexp.h>
-#ifndef Q_OS_WINCE
-#  include <QtCore/qcoreevent.h>
-#endif
+#include <QtCore/qcoreevent.h>
 
 #ifndef CTL_CODE
 #  define CTL_CODE(DeviceType, Function, Method, Access) ( \
@@ -129,9 +122,6 @@ WinSerialPortEngine::WinSerialPortEngine(SerialPortPrivate *d)
     , m_flagErrorFromCommEvent(false)
     , m_currentMask(0)
     , m_desiredMask(0)
-#ifdef Q_OS_WINCE
-    , m_running(true)
-#endif
 {
     Q_ASSERT(d);
     dptr = d;
@@ -140,12 +130,10 @@ WinSerialPortEngine::WinSerialPortEngine(SerialPortPrivate *d)
     ::memset(&m_currentCommTimeouts, 0, sizeof(m_currentCommTimeouts));
     ::memset(&m_restoredCommTimeouts, 0, sizeof(m_restoredCommTimeouts));
 
-#ifndef Q_OS_WINCE
     ::memset(&m_readOverlapped, 0, sizeof(m_readOverlapped));
     ::memset(&m_writeOverlapped, 0, sizeof(m_writeOverlapped));
     ::memset(&m_selectOverlapped, 0, sizeof(m_selectOverlapped));
     ::memset(&m_notifyOverlapped, 0, sizeof(m_notifyOverlapped));
-#endif
 }
 
 /*!
@@ -153,14 +141,7 @@ WinSerialPortEngine::WinSerialPortEngine(SerialPortPrivate *d)
 */
 WinSerialPortEngine::~WinSerialPortEngine()
 {
-#ifdef Q_OS_WINCE
-    m_running = false;
-    ::SetCommMask(m_descriptor, 0);
-    //terminate();
-    wait();
-#else
     setEnabled(false);
-#endif
 }
 
 /*!
@@ -184,14 +165,10 @@ bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode
 {
     DWORD desiredAccess = 0;
     DWORD shareMode = 0;
-    DWORD flagsAndAttributes = 0;
+    DWORD flagsAndAttributes = FILE_FLAG_OVERLAPPED;
     bool rxflag = false;
     bool txflag = false;
 
-#ifndef Q_OS_WINCE
-    flagsAndAttributes |= FILE_FLAG_OVERLAPPED;
-#endif
-
     if (mode & QIODevice::ReadOnly) {
         desiredAccess |= GENERIC_READ;
         //shareMode = FILE_SHARE_READ;
@@ -246,12 +223,10 @@ bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode
     if (!updateCommTimeouts())
         return false;
 
-#ifndef Q_OS_WINCE
     if (!createEvents(rxflag, txflag)) {
         dptr->setError(decodeSystemError());
         return false;
     }
-#endif
 
     detectDefaultSettings();
     return true;
@@ -265,9 +240,7 @@ void WinSerialPortEngine::close(const QString &location)
 {
     Q_UNUSED(location);
 
-#ifndef Q_OS_WINCE
     ::CancelIo(m_descriptor);
-#endif
 
     if (dptr->options.restoreSettingsOnClose) {
         ::SetCommState(m_descriptor, &m_restoredDcb);
@@ -276,9 +249,7 @@ void WinSerialPortEngine::close(const QString &location)
 
     ::CloseHandle(m_descriptor);
 
-#ifndef Q_OS_WINCE
     closeEvents();
-#endif
     m_descriptor = INVALID_HANDLE_VALUE;
 }
 
@@ -429,7 +400,6 @@ qint64 WinSerialPortEngine::bytesToWrite() const
     return cs.cbOutQue;
 }
 
-#ifndef Q_OS_WINCE
 // Clear overlapped structure, but does not affect the event.
 static void clear_overlapped(OVERLAPPED *overlapped)
 {
@@ -438,7 +408,6 @@ static void clear_overlapped(OVERLAPPED *overlapped)
     overlapped->Offset = 0;
     overlapped->OffsetHigh = 0;
 }
-#endif
 
 /*!
     Reads at most \a len bytes from the serial port into \a data, and returns
@@ -459,9 +428,7 @@ static void clear_overlapped(OVERLAPPED *overlapped)
 */
 qint64 WinSerialPortEngine::read(char *data, qint64 len)
 {
-#ifndef Q_OS_WINCE
     clear_overlapped(&m_readOverlapped);
-#endif
 
     DWORD readBytes = 0;
     bool sucessResult = false;
@@ -470,9 +437,6 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
     if (dptr->options.policy != SerialPort::IgnorePolicy)
         len = 1;
 
-#ifdef Q_OS_WINCE
-    sucessResult = ::ReadFile(m_descriptor, data, len, &readBytes, 0);
-#else
     if (::ReadFile(m_descriptor, data, len, &readBytes, &m_readOverlapped)) {
         sucessResult = true;
     } else if (::GetLastError() == ERROR_IO_PENDING
@@ -481,7 +445,6 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
              && ::GetOverlappedResult(m_descriptor, &m_readOverlapped, &readBytes, true)) {
         sucessResult = true;
     }
-#endif
 
     if (!sucessResult)
         return -1;
@@ -512,16 +475,11 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
 */
 qint64 WinSerialPortEngine::write(const char *data, qint64 len)
 {
-#ifndef Q_OS_WINCE
     clear_overlapped(&m_writeOverlapped);
-#endif
 
     DWORD writeBytes = 0;
     bool sucessResult = false;
 
-#ifdef Q_OS_WINCE
-    sucessResult = ::WriteFile(m_descriptor, data, len, &writeBytes, 0);
-#else
     if (::WriteFile(m_descriptor, data, len, &writeBytes, &m_writeOverlapped)) {
         sucessResult = true;
     } else if (::GetLastError() == ERROR_IO_PENDING) {
@@ -533,7 +491,6 @@ qint64 WinSerialPortEngine::write(const char *data, qint64 len)
         sucessResult = true;
         writeBytes = len;
     }
-#endif
 
     if (!sucessResult)
         return -1;
@@ -576,9 +533,7 @@ bool WinSerialPortEngine::select(int timeout,
         return true;
     }
 
-#ifndef Q_OS_WINCE
     clear_overlapped(&m_selectOverlapped);
-#endif
 
     DWORD oldEventMask = 0;
     DWORD currEventMask = 0;
@@ -603,7 +558,6 @@ bool WinSerialPortEngine::select(int timeout,
     currEventMask = 0;
     bool sucessResult = false;
 
-#ifndef Q_OS_WINCE
     if (::WaitCommEvent(m_descriptor, &currEventMask, &m_selectOverlapped)) {
         sucessResult = true;
     } else if (::GetLastError() == ERROR_IO_PENDING) {
@@ -615,15 +569,6 @@ bool WinSerialPortEngine::select(int timeout,
             // Here there was a timeout or other error.
         }
     }
-#else
-    // FIXME: Here the situation is not properly handled with zero timeout:
-    // breaker can work out before you call a method WaitCommEvent()
-    // and so it will loop forever!
-    WinCeWaitCommEventBreaker breaker(m_descriptor, qMax(timeout, 0));
-    ::WaitCommEvent(m_descriptor, &currEventMask, 0);
-    breaker.stop();
-    sucessResult = !breaker.isWorked();
-#endif
 
     if (sucessResult) {
         // FIXME: Here call the bytesAvailable() to protect against false positives
@@ -870,50 +815,6 @@ bool WinSerialPortEngine::processIOErrors()
     return ret;
 }
 
-#ifdef Q_OS_WINCE
-
-void WinSerialPortEngine::lockNotification(NotificationLockerType type, bool uselocker)
-{
-    QMutex *mutex = 0;
-    switch (type) {
-    case CanReadLocker:
-        mutex = &m_readNotificationMutex;
-        break;
-    case CanWriteLocker:
-        mutex = &m_writeNotificationMutex;
-        break;
-    case CanErrorLocker:
-        mutex = &m_errorNotificationMutex;
-        break;
-    default:
-        break;
-    }
-
-    if (uselocker)
-        QMutexLocker locker(mutex);
-    else
-        mutex->lock();
-}
-
-void WinSerialPortEngine::unlockNotification(NotificationLockerType type)
-{
-    switch (type) {
-    case CanReadLocker:
-        m_readNotificationMutex.unlock();
-        break;
-    case CanWriteLocker:
-        m_writeNotificationMutex.unlock();
-        break;
-    case CanErrorLocker:
-        m_errorNotificationMutex.unlock();
-        break;
-    default:
-        break;
-    }
-}
-
-#endif
-
 /* Protected methods */
 
 /*!
@@ -1016,47 +917,6 @@ SerialPort::PortError WinSerialPortEngine::decodeSystemError() const
     return error;
 }
 
-#ifdef Q_OS_WINCE
-
-/*!
-    Embedded-based (WinCE) event loop for the notification subsystem.
-    The serial port events EV_ERR, EV_RXCHAR, and EV_TXEMPTY are tracked
-    in a separate thread. When a relevant event occurs, the appropriate
-    handler from the parent class SerialPortPrivate is called.
-    At the same time in handlers to capture/release the mutex
-    (see handlers implementation).
-*/
-void WinSerialPortEngine::run()
-{
-    while (m_running) {
-
-        m_setCommMaskMutex.lock();
-        ::SetCommMask(m_descriptor, m_desiredMask);
-        m_setCommMaskMutex.unlock();
-
-        if (::WaitCommEvent(m_descriptor, &m_currentMask, 0) != 0) {
-
-            // Wait until complete the operation changes the port settings,
-            // see updateDcb().
-            m_settingsChangeMutex.lock();
-            m_settingsChangeMutex.unlock();
-
-            if (EV_ERR & m_currentMask & m_desiredMask) {
-                dptr->canErrorNotification();
-            }
-            if (EV_RXCHAR & m_currentMask & m_desiredMask) {
-                dptr->canReadNotification();
-            }
-            //FIXME: This is why it does not work?
-            if (EV_TXEMPTY & m_currentMask & m_desiredMask) {
-                dptr->canWriteNotification();
-            }
-        }
-    }
-}
-
-#else
-
 /*!
     Windows NT-based event loop for the notification subsystem.
     The serial port events EV_ERR, EV_RXCHAR, and EV_TXEMPTY are tracked
@@ -1088,10 +948,6 @@ bool WinSerialPortEngine::event(QEvent *e)
     return ret;
 }
 
-#endif
-
-#ifndef Q_OS_WINCE
-
 /*!
     For Windows NT-based OS, creates event handles for OVERLAPPED
     structures, that are used in the reading method (if \a rx is true),
@@ -1140,18 +996,11 @@ void WinSerialPortEngine::closeEvents()
     ::memset(&m_notifyOverlapped, 0, sizeof(m_notifyOverlapped));
 }
 
-#endif
-
 /*!
 */
 bool WinSerialPortEngine::isNotificationEnabled(DWORD mask) const
 {
-    bool enabled;
-#ifdef Q_OS_WINCE
-    enabled = isRunning();
-#else
-    enabled = isEnabled();
-#endif
+    bool enabled = isEnabled();
     return enabled && (m_desiredMask & mask);
 }
 
@@ -1159,12 +1008,6 @@ bool WinSerialPortEngine::isNotificationEnabled(DWORD mask) const
 */
 void WinSerialPortEngine::setNotificationEnabled(bool enable, DWORD mask)
 {
-
-#ifdef Q_OS_WINCE
-    m_setCommMaskMutex.lock();
-    ::GetCommMask(m_descriptor, &m_currentMask);
-#endif
-
     // Mask only the desired bits without affecting others.
     if (enable)
         m_desiredMask |= mask;
@@ -1173,12 +1016,6 @@ void WinSerialPortEngine::setNotificationEnabled(bool enable, DWORD mask)
 
     ::SetCommMask(m_descriptor, m_desiredMask);
 
-#ifdef Q_OS_WINCE
-    m_setCommMaskMutex.unlock();
-
-    if (enable && !isRunning())
-        start();
-#else
     enable = isEnabled();
 
     // If the desired mask is zero then no needed to restart
@@ -1191,8 +1028,6 @@ void WinSerialPortEngine::setNotificationEnabled(bool enable, DWORD mask)
     } else if (enable) {
         setEnabled(false);
     }
-#endif
-
 }
 
 /*!
@@ -1202,15 +1037,6 @@ void WinSerialPortEngine::setNotificationEnabled(bool enable, DWORD mask)
 */
 bool WinSerialPortEngine::updateDcb()
 {
-#ifdef Q_OS_WINCE
-    // Grab a mutex, in order after exit WaitCommEvent
-    // block the flow of run() notifier until there is a change DCB.
-    QMutexLocker locker(&m_settingsChangeMutex);
-    // This way, we reset in class WaitCommEvent to
-    // be able to change the DCB.
-    // Otherwise WaitCommEvent blocking any change!
-    ::SetCommMask(m_descriptor, 0);
-#endif
     if (::SetCommState(m_descriptor, &m_currentDcb) == 0) {
         dptr->setError(decodeSystemError());
         return false;
@@ -1241,11 +1067,7 @@ SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
 
 /* Public static the SerialPortPrivate methods */
 
-#ifndef Q_OS_WINCE
 static const QLatin1String defaultPathPrefix("\\\\.\\");
-#else
-static const QLatin1String defaultPathPostfix(":");
-#endif
 
 /*!
     Converts a platform specific \a port name to a system location
@@ -1254,13 +1076,8 @@ static const QLatin1String defaultPathPostfix(":");
 QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
 {
     QString ret = port;
-#ifndef Q_OS_WINCE
     if (!ret.contains(defaultPathPrefix))
         ret.prepend(defaultPathPrefix);
-#else
-    if (!ret.contains(defaultPathPostfix))
-        ret.append(defaultPathPostfix);
-#endif
     return ret;
 }
 
@@ -1271,13 +1088,8 @@ QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
 QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
 {
     QString ret = location;
-#ifndef Q_OS_WINCE
     if (ret.contains(defaultPathPrefix))
         ret.remove(defaultPathPrefix);
-#else
-    if (ret.contains(defaultPathPostfix))
-        ret.remove(defaultPathPostfix);
-#endif
     return ret;
 }
 
diff --git a/src/serialportengine_win_p.h b/src/serialportengine_win_p.h
index bc293f6..7451390 100755
--- a/src/serialportengine_win_p.h
+++ b/src/serialportengine_win_p.h
@@ -47,67 +47,15 @@
 #include "serialportengine_p.h"
 
 #include <qt_windows.h>
-#ifdef Q_OS_WINCE
-#  include <QtCore/qmutex.h>
-#  include <QtCore/qthread.h>
-#  include <QtCore/qtimer.h>
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 0, 0))
+#include <QtCore/qwineventnotifier.h>
 #else
-# if (QT_VERSION >= QT_VERSION_CHECK(5, 0, 0))
-#  include <QtCore/qwineventnotifier.h>
-# else
-#  include "qt4support/qwineventnotifier_p.h"
-# endif
+#include "qt4support/qwineventnotifier_p.h"
 #endif
 
 QT_BEGIN_NAMESPACE_SERIALPORT
 
-#ifdef Q_OS_WINCE
-
-class WinCeWaitCommEventBreaker : public QThread
-{
-    Q_OBJECT
-public:
-    WinCeWaitCommEventBreaker(HANDLE descriptor, int timeout, QObject *parent = 0)
-        : QThread(parent)
-        , m_descriptor(descriptor)
-        , m_timeout(timeout)
-        , m_worked(false) {
-        start();
-    }
-    virtual ~WinCeWaitCommEventBreaker() {
-        stop();
-        wait();
-    }
-    void stop() { exit(0); }
-    bool isWorked() const { return m_worked; }
-
-protected:
-    void run() {
-        QTimer timer;
-        QObject::connect(&timer, SIGNAL(timeout()), this, SLOT(procTimeout()), Qt::DirectConnection);
-        timer.start(m_timeout);
-        exec();
-        m_worked = true;
-    }
-
-private slots:
-    void procTimeout() {
-        ::SetCommMask(m_descriptor, 0);
-        stop();
-    }
-
-private:
-    HANDLE m_descriptor;
-    int m_timeout;
-    volatile bool m_worked;
-};
-#endif
-
-#ifdef Q_OS_WINCE
-class WinSerialPortEngine : public QThread, public SerialPortEngine
-#else
 class WinSerialPortEngine : public QWinEventNotifier, public SerialPortEngine
-#endif
 {
     Q_OBJECT
 public:
@@ -154,28 +102,14 @@ public:
 
     virtual bool processIOErrors();
 
-#ifdef Q_OS_WINCE
-    // FIXME
-    virtual void lockNotification(NotificationLockerType type, bool uselocker);
-    virtual void unlockNotification(NotificationLockerType type);
-#endif
-
 protected:
     virtual void detectDefaultSettings();
     virtual SerialPort::PortError decodeSystemError() const;
-
-#ifdef Q_OS_WINCE
-    virtual void run();
-#else
     virtual bool event(QEvent *e);
-#endif
 
 private:
-
-#ifndef Q_OS_WINCE
     bool createEvents(bool rx, bool tx);
     void closeEvents();
-#endif
 
     bool isNotificationEnabled(DWORD mask) const;
     void setNotificationEnabled(bool enable, DWORD mask);
@@ -193,19 +127,10 @@ private:
     DWORD m_currentMask;
     DWORD m_desiredMask;
 
-#ifdef Q_OS_WINCE
-    QMutex m_readNotificationMutex;
-    QMutex m_writeNotificationMutex;
-    QMutex m_errorNotificationMutex;
-    QMutex m_settingsChangeMutex;
-    QMutex m_setCommMaskMutex;
-    volatile bool m_running;
-#else
     OVERLAPPED m_readOverlapped;
     OVERLAPPED m_writeOverlapped;
     OVERLAPPED m_selectOverlapped;
     OVERLAPPED m_notifyOverlapped;
-#endif
 };
 
 QT_END_NAMESPACE_SERIALPORT
diff --git a/src/serialportengine_wince.cpp b/src/serialportengine_wince.cpp
new file mode 100644
index 0000000..673b1fa
--- /dev/null
+++ b/src/serialportengine_wince.cpp
@@ -0,0 +1,1133 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
+** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
+** Copyright (C) 2012 Andre Hartmann <aha_1980@gmx.de>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+    \class WinCESerialPortEngine
+    \internal
+
+    \brief The WinCESerialPortEngine class provides WindowsCE OS
+    platform-specific low level access to a serial port.
+
+    \reentrant
+    \ingroup serialport-main
+    \inmodule QtSerialPort
+
+    Currently the class supports various versionf of embedded Windows CE.
+
+    WinCESerialPortEngine (as well as other platform-dependent engines)
+    is a class with multiple inheritance, which on the one hand,
+    derives from a general abstract class interface SerialPortEngine,
+    on the other hand from QObject.
+
+    From the abstract class SerialPortEngine, this class inherits all virtual
+    interface methods that are common to all serial ports on any platform.
+    The class WinCESerialPortEngine implements these methods using the
+    Windows CE API.
+
+    For Windows CE systems WinCESerialPortEngine is derived
+    from QThread and creates an additional thread to track the events.
+*/
+
+#include "serialportengine_wince_p.h"
+
+#include <QtCore/qregexp.h>
+
+#ifndef CTL_CODE
+#  define CTL_CODE(DeviceType, Function, Method, Access) ( \
+    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
+    )
+#endif
+
+#ifndef FILE_DEVICE_SERIAL_PORT
+#  define FILE_DEVICE_SERIAL_PORT  27
+#endif
+
+#ifndef METHOD_BUFFERED
+#  define METHOD_BUFFERED  0
+#endif
+
+#ifndef FILE_ANY_ACCESS
+#  define FILE_ANY_ACCESS  0x00000000
+#endif
+
+#ifndef IOCTL_SERIAL_GET_DTRRTS
+#  define IOCTL_SERIAL_GET_DTRRTS \
+    CTL_CODE(FILE_DEVICE_SERIAL_PORT, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
+#endif
+
+#ifndef SERIAL_DTR_STATE
+#  define SERIAL_DTR_STATE  0x00000001
+#endif
+
+#ifndef SERIAL_RTS_STATE
+#  define SERIAL_RTS_STATE  0x00000002
+#endif
+
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+/*!
+    Constructs a WinCESerialPortEngine and initializes all internal variables
+    to their initial values. The pointer \a d to the private object of class
+    SerialPortPrivate is used to call some common methods.
+*/
+WinCESerialPortEngine::WinCESerialPortEngine(SerialPortPrivate *d)
+    : m_descriptor(INVALID_HANDLE_VALUE)
+    , m_flagErrorFromCommEvent(false)
+    , m_currentMask(0)
+    , m_desiredMask(0)
+    , m_running(true)
+{
+    Q_ASSERT(d);
+    dptr = d;
+    ::memset(&m_currentDcb, 0, sizeof(m_currentDcb));
+    ::memset(&m_restoredDcb, 0, sizeof(m_restoredDcb));
+    ::memset(&m_currentCommTimeouts, 0, sizeof(m_currentCommTimeouts));
+    ::memset(&m_restoredCommTimeouts, 0, sizeof(m_restoredCommTimeouts));
+}
+
+/*!
+    Stops the serial port event tracking and destructs a WinCESerialPortEngine.
+*/
+WinCESerialPortEngine::~WinCESerialPortEngine()
+{
+    m_running = false;
+    ::SetCommMask(m_descriptor, 0);
+    //terminate();
+    wait();
+}
+
+/*!
+    Attempts to open the desired serial port by \a location in the given open
+    \a mode. In the process of discovery, always sets the serial port in
+    non-blocking mode (where the read operation returns immediately) and tries
+    to determine and install the current configuration to the serial port.
+
+    It should be noted, that Windows has the following limitations when using
+    the serial port:
+    - support only binary transfers mode
+    - always open in exclusive mode
+
+    For Windows NT-based platforms, the serial port is opened in the overlapped
+    mode, with the flag FILE_FLAG_OVERLAPPED.
+
+    If successful, returns true; otherwise returns false and sets an
+    error code.
+*/
+bool WinCESerialPortEngine::open(const QString &location, QIODevice::OpenMode mode)
+{
+    DWORD desiredAccess = 0;
+    DWORD shareMode = 0;
+    DWORD flagsAndAttributes = 0;
+    bool rxflag = false;
+    bool txflag = false;
+
+    if (mode & QIODevice::ReadOnly) {
+        desiredAccess |= GENERIC_READ;
+        //shareMode = FILE_SHARE_READ;
+        rxflag = true;
+    }
+    if (mode & QIODevice::WriteOnly) {
+        desiredAccess |= GENERIC_WRITE;
+        //shareMode = FILE_SHARE_WRITE;
+        txflag = true;
+    }
+
+    // Try opened serial device.
+    m_descriptor = ::CreateFile(reinterpret_cast<const wchar_t*>(location.utf16()),
+                                desiredAccess, shareMode, 0, OPEN_EXISTING, flagsAndAttributes, 0);
+
+    if (m_descriptor == INVALID_HANDLE_VALUE) {
+        dptr->setError(decodeSystemError());
+        return false;
+    }
+
+    // Save current DCB port settings.
+    if (::GetCommState(m_descriptor, &m_restoredDcb) == 0) {
+        dptr->setError(decodeSystemError());
+        return false;
+    }
+    m_currentDcb = m_restoredDcb;
+
+    // Set other DCB port options.
+    m_currentDcb.fBinary = true;
+    m_currentDcb.fInX = false;
+    m_currentDcb.fOutX = false;
+    m_currentDcb.fAbortOnError = false;
+    m_currentDcb.fNull = false;
+    m_currentDcb.fErrorChar = false;
+
+    // Apply new DCB init settings.
+    if (!updateDcb())
+        return false;
+
+    // Save current port timeouts.
+    if (::GetCommTimeouts(m_descriptor, &m_restoredCommTimeouts) == 0) {
+        dptr->setError(decodeSystemError());
+        return false;
+    }
+    m_currentCommTimeouts = m_restoredCommTimeouts;
+
+    // Set new port timeouts.
+    ::memset(&m_currentCommTimeouts, 0, sizeof(m_currentCommTimeouts));
+    m_currentCommTimeouts.ReadIntervalTimeout = MAXDWORD;
+
+    // Apply new port timeouts.
+    if (!updateCommTimeouts())
+        return false;
+
+    detectDefaultSettings();
+    return true;
+}
+
+/*!
+    Closes a serial port. Before closing, restores the previous serial port
+    settings if necessary.
+*/
+void WinCESerialPortEngine::close(const QString &location)
+{
+    Q_UNUSED(location);
+
+    if (dptr->options.restoreSettingsOnClose) {
+        ::SetCommState(m_descriptor, &m_restoredDcb);
+        ::SetCommTimeouts(m_descriptor, &m_restoredCommTimeouts);
+    }
+
+    ::CloseHandle(m_descriptor);
+
+    m_descriptor = INVALID_HANDLE_VALUE;
+}
+
+/*!
+    Returns a bitmap state of the RS-232 line signals. On error,
+    the bitmap will be empty (equal zero).
+
+    The Windows API only provides the state of the following signals:
+    CTS, DSR, RING, DCD, DTR, and RTS. Other signals are not available.
+*/
+SerialPort::Lines WinCESerialPortEngine::lines() const
+{
+    DWORD modemStat = 0;
+    SerialPort::Lines ret = 0;
+
+    if (::GetCommModemStatus(m_descriptor, &modemStat) == 0)
+        return ret;
+
+    if (modemStat & MS_CTS_ON)
+        ret |= SerialPort::Cts;
+    if (modemStat & MS_DSR_ON)
+        ret |= SerialPort::Dsr;
+    if (modemStat & MS_RING_ON)
+        ret |= SerialPort::Ri;
+    if (modemStat & MS_RLSD_ON)
+        ret |= SerialPort::Dcd;
+
+    DWORD bytesReturned = 0;
+    if (::DeviceIoControl(m_descriptor, IOCTL_SERIAL_GET_DTRRTS, 0, 0,
+                          &modemStat, sizeof(bytesReturned),
+                          &bytesReturned, 0)) {
+
+        if (modemStat & SERIAL_DTR_STATE)
+            ret |= SerialPort::Dtr;
+        if (modemStat & SERIAL_RTS_STATE)
+            ret |= SerialPort::Rts;
+    }
+
+    return ret;
+}
+
+/*!
+    Set DTR signal to state \a set.
+
+    If successful, returns true; otherwise returns false.
+*/
+bool WinCESerialPortEngine::setDtr(bool set)
+{
+    return ::EscapeCommFunction(m_descriptor, set ? SETDTR : CLRDTR);
+}
+
+/*!
+    Set RTS signal to state \a set.
+
+    If successful, returns true; otherwise returns false.
+*/
+bool WinCESerialPortEngine::setRts(bool set)
+{
+    return ::EscapeCommFunction(m_descriptor, set ? SETRTS : CLRRTS);
+}
+
+/*!
+    Flushes the serial port's buffers and causes all buffered data to be written
+    to the serial port.
+
+    If successful, returns true; otherwise returns false.
+*/
+bool WinCESerialPortEngine::flush()
+{
+    return ::FlushFileBuffers(m_descriptor);
+}
+
+/*!
+    Discards all characters from the serial port's output or input buffer.
+    This can also terminate pending read or write operations.
+
+    If successful, returns true; otherwise returns false.
+*/
+bool WinCESerialPortEngine::reset()
+{
+    const DWORD flags = PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR;
+    return ::PurgeComm(m_descriptor, flags);
+}
+
+/*!
+    Sends a continuous stream of zero bits during a specified
+    period of time \a duration in msec.
+
+    If successful, returns true; otherwise returns false.
+*/
+bool WinCESerialPortEngine::sendBreak(int duration)
+{
+    // FIXME:
+    if (setBreak(true)) {
+        ::Sleep(duration);
+        if (setBreak(false))
+            return true;
+    }
+    return false;
+}
+
+/*!
+    Restores or suspend character transmission and places the
+    transmission line in a nonbreak or break state,
+    depending on the parameter \a set.
+
+    If successful, returns true; otherwise returns false.
+*/
+bool WinCESerialPortEngine::setBreak(bool set)
+{
+    if (set)
+        return ::SetCommBreak(m_descriptor);
+    return ::ClearCommBreak(m_descriptor);
+}
+
+/*!
+    Returns the number of bytes received by the serial provider
+    but not yet read by a read() operation. Also clears the
+    device's error flag to enable additional input and output
+    (I/O) operations.
+
+    If successful, returns true; otherwise returns false.
+*/
+qint64 WinCESerialPortEngine::bytesAvailable() const
+{
+    COMSTAT cs;
+    ::memset(&cs, 0, sizeof(cs));
+    if (::ClearCommError(m_descriptor, 0, &cs) == 0)
+        return -1;
+    return cs.cbInQue;
+}
+
+/*!
+    Returns the number of bytes of user data remaining to be
+    transmitted for all write operations. This value will be zero
+    for a nonoverlapped write (for embedded platform as WinCE).
+    Also clears the device's error flag to enable additional
+    input and output (I/O) operations.
+
+    If successful, returns true; otherwise returns false.
+*/
+qint64 WinCESerialPortEngine::bytesToWrite() const
+{
+    COMSTAT cs;
+    ::memset(&cs, 0, sizeof(cs));
+    if (::ClearCommError(m_descriptor, 0, &cs) == 0)
+        return -1;
+    return cs.cbOutQue;
+}
+
+/*!
+    Reads at most \a len bytes from the serial port into \a data, and returns
+    the number of bytes read. If an error occurs, this function returns -1
+    and sets an error code. This function returns immediately.
+
+    Also, this method processed the policy of operating with the
+    received symbol, in which the parity or frame error is detected.
+    This analysis and processing is executed by software-way in
+    this method. Parity or frame error flag determines subsystem
+    notification when it receives an event type EV_ERR. Since the
+    EV_ERR event appears before the event EV_RXCHAR, therefore,
+    we are able to handle errors by ordered, for each bad charachter
+    in this read method. This is true only when enabled the internal
+    read buffer of class SerialPort, ie when it is automatically
+    filled when the notification mode of reading is enabled. In
+    other cases, policy processing bad char is not guaranteed.
+*/
+qint64 WinCESerialPortEngine::read(char *data, qint64 len)
+{
+    DWORD readBytes = 0;
+    bool sucessResult = false;
+
+    // FIXME:
+    if (dptr->options.policy != SerialPort::IgnorePolicy)
+        len = 1;
+
+    sucessResult = ::ReadFile(m_descriptor, data, len, &readBytes, 0);
+    if (!sucessResult)
+        return -1;
+
+    // FIXME: Process emulate policy.
+    if (m_flagErrorFromCommEvent) {
+        m_flagErrorFromCommEvent = false;
+
+        switch (dptr->options.policy) {
+        case SerialPort::SkipPolicy:
+            return 0;
+        case SerialPort::PassZeroPolicy:
+            *data = '\0';
+            break;
+        case SerialPort::StopReceivingPolicy:
+            break;
+        default:
+            break;
+        }
+    }
+    return readBytes;
+}
+
+/*!
+    Writes at most \a len bytes of data from \a data to the serial port.
+    If successful, returns the number of bytes that were actually written;
+    otherwise returns -1 and sets an error code.
+*/
+qint64 WinCESerialPortEngine::write(const char *data, qint64 len)
+{
+    DWORD writeBytes = 0;
+    bool sucessResult = false;
+
+    sucessResult = ::WriteFile(m_descriptor, data, len, &writeBytes, 0);
+    if (!sucessResult)
+        return -1;
+
+    return writeBytes;
+}
+
+/*!
+    Implements a function blocking for waiting of events EV_RXCHAR or
+    EV_TXEMPTY, on the \a timeout in millisecond. Event EV_RXCHAR
+    controlled, if the flag \a checkRead is set on true, and
+    EV_TXEMPTY wehn flag \a checkWrite is set on true. The result
+    of catch in each of the events, save to the corresponding
+    variables \a selectForRead and \a selectForWrite.
+
+    For NT-based OS and Windows CE, this method have different
+    implementation. WinCE has no mechanism to exit out of a timeout,
+    therefore for this feature special class is used
+    WinCeWaitCommEventBreaker, without which it is locked to wait
+    forever in the absence of events EV_RXCHAR or EV_TXEMPTY. For
+    satisfactory operation of the breaker, the timeout should be
+    guaranteed a great, to the timer in the breaker does not trip
+    happen sooner than a function call WaitCommEvent(); otherwise it
+    will block forever (in the absence of events EV_RXCHAR or EV_TXEMPTY).
+
+    Returns true if the occurrence of any event before the timeout;
+    otherwise returns false.
+*/
+bool WinCESerialPortEngine::select(int timeout,
+                                 bool checkRead, bool checkWrite,
+                                 bool *selectForRead, bool *selectForWrite)
+{
+    // FIXME: Forward checking available data for read.
+    // This is a bad decision, because call bytesAvailable() automatically
+    // clears the error parity, frame, etc. That is, then in the future,
+    // it is impossible to identify them in the process of reading the data.
+    if (checkRead && (bytesAvailable() > 0)) {
+        Q_ASSERT(selectForRead);
+        *selectForRead = true;
+        return true;
+    }
+
+    DWORD oldEventMask = 0;
+    DWORD currEventMask = 0;
+
+    if (checkRead)
+        currEventMask |= EV_RXCHAR;
+    if (checkWrite)
+        currEventMask |= EV_TXEMPTY;
+
+    // Save old mask.
+    if (::GetCommMask(m_descriptor, &oldEventMask) == 0)
+        return false;
+
+    // Checking the old mask bits as in the current mask.
+    // And if these bits are not exists, then add them and set the reting mask.
+    if (currEventMask != (oldEventMask & currEventMask)) {
+        currEventMask |= oldEventMask;
+        if (::SetCommMask(m_descriptor, currEventMask) == 0)
+            return false;
+    }
+
+    currEventMask = 0;
+    bool sucessResult = false;
+
+    // FIXME: Here the situation is not properly handled with zero timeout:
+    // breaker can work out before you call a method WaitCommEvent()
+    // and so it will loop forever!
+    WinCeWaitCommEventBreaker breaker(m_descriptor, qMax(timeout, 0));
+    ::WaitCommEvent(m_descriptor, &currEventMask, 0);
+    breaker.stop();
+    sucessResult = !breaker.isWorked();
+
+    if (sucessResult) {
+        // FIXME: Here call the bytesAvailable() to protect against false positives
+        // WaitForSingleObject(), for example, when manually pulling USB/Serial
+        // converter from system, ie when devices are in fact not.
+        // While it may be possible to make additional checks - to catch an event EV_ERR,
+        // adding (in the code above) extra bits in the mask currEventMask.
+        if (checkRead) {
+            Q_ASSERT(selectForRead);
+            *selectForRead = (currEventMask & EV_RXCHAR) && bytesAvailable() > 0;
+        }
+        if (checkWrite) {
+            Q_ASSERT(selectForWrite);
+            *selectForWrite =  currEventMask & EV_TXEMPTY;
+        }
+    }
+
+    // Rerair old mask.
+    ::SetCommMask(m_descriptor, oldEventMask);
+    return sucessResult;
+}
+
+/*!
+    Sets the desired baud \a rate for the given direction \a dir.
+    As Windows does not support separate directions, the only valid value for
+    \dir is SerialPort::AllDirections.
+
+    If successful, returns true; otherwise returns false and sets an
+    error code.
+*/
+bool WinCESerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
+{
+    if (dir != SerialPort::AllDirections) {
+        dptr->setError(SerialPort::UnsupportedPortOperationError);
+        return false;
+    }
+    m_currentDcb.BaudRate = rate;
+    return updateDcb();
+}
+
+/*!
+    Sets the desired number of data bits \a dataBits in a frame. Windows
+    supports all present number of data bits 5, 6, 7, and 8.
+
+    If successful, returns true; otherwise returns false and sets an
+    error code.
+*/
+bool WinCESerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
+{
+    m_currentDcb.ByteSize = dataBits;
+    return updateDcb();
+}
+
+/*!
+    Sets the desired \a parity control mode. Windows supports
+    all present parity types: no parity, space, mark, even, and odd parity.
+
+    If successful, returns true; otherwise returns false and sets an
+    error code.
+*/
+bool WinCESerialPortEngine::setParity(SerialPort::Parity parity)
+{
+    m_currentDcb.fParity = true;
+    switch (parity) {
+    case SerialPort::NoParity:
+        m_currentDcb.Parity = NOPARITY;
+        m_currentDcb.fParity = false;
+        break;
+    case SerialPort::OddParity:
+        m_currentDcb.Parity = ODDPARITY;
+        break;
+    case SerialPort::EvenParity:
+        m_currentDcb.Parity = EVENPARITY;
+        break;
+    case SerialPort::MarkParity:
+        m_currentDcb.Parity = MARKPARITY;
+        break;
+    case SerialPort::SpaceParity:
+        m_currentDcb.Parity = SPACEPARITY;
+        break;
+    default:
+        m_currentDcb.Parity = NOPARITY;
+        m_currentDcb.fParity = false;
+        break;
+    }
+    return updateDcb();
+}
+
+/*!
+    Sets the desired number of stop bits \a stopBits in a frame.
+    Windows supports 1, 1.5, or 2 stop bits.
+
+    If successful, returns true; otherwise returns false and sets an
+    error code.
+*/
+bool WinCESerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
+{
+    switch (stopBits) {
+    case SerialPort::OneStop:
+        m_currentDcb.StopBits = ONESTOPBIT;
+        break;
+    case SerialPort::OneAndHalfStop:
+        m_currentDcb.StopBits = ONE5STOPBITS;
+        break;
+    case SerialPort::TwoStop:
+        m_currentDcb.StopBits = TWOSTOPBITS;
+        break;
+    default:
+        m_currentDcb.StopBits = ONESTOPBIT;
+        break;
+    }
+    return updateDcb();
+}
+
+/*!
+    Set desired \a flow control mode. Windows native supported all
+    present flow control modes: no control, hardware (RTS/CTS),
+    and software (XON/XOFF).
+
+    If successful, returns true; otherwise returns false and sets an
+    error code.
+*/
+bool WinCESerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
+{
+    m_currentDcb.fInX = false;
+    m_currentDcb.fOutX = false;
+    m_currentDcb.fOutxCtsFlow = false;
+    m_currentDcb.fRtsControl = RTS_CONTROL_DISABLE;
+    switch (flow) {
+    case SerialPort::NoFlowControl:
+        break;
+    case SerialPort::SoftwareControl:
+        m_currentDcb.fInX = true;
+        m_currentDcb.fOutX = true;
+        break;
+    case SerialPort::HardwareControl:
+        m_currentDcb.fOutxCtsFlow = true;
+        m_currentDcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
+        break;
+    default:
+        break;
+    }
+    return updateDcb();
+}
+
+/*!
+    Empty stub. Setting a variable is carried out methods in a
+    private class SerialPortPrivate.
+*/
+bool WinCESerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
+{
+    Q_UNUSED(policy)
+    return true;
+}
+
+/*!
+    Returns the current read notification subsystem status.
+*/
+bool WinCESerialPortEngine::isReadNotificationEnabled() const
+{
+    return isNotificationEnabled(EV_RXCHAR);
+}
+
+/*!
+    Enables or disables the read notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of the event EV_RXCHAR.
+    Thereby, SerialPort can emit the signal readyRead() and automatically
+    fill the internal receive buffer with new data, that was received from
+    the serial port in the event loop.
+*/
+void WinCESerialPortEngine::setReadNotificationEnabled(bool enable)
+{
+    setNotificationEnabled(enable, EV_RXCHAR);
+}
+
+/*!
+    Returns the current write notification subsystem status.
+*/
+bool WinCESerialPortEngine::isWriteNotificationEnabled() const
+{
+    return isNotificationEnabled(EV_TXEMPTY);
+}
+
+/*!
+    Enables or disables the write notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of the event EV_TXEMPTY.
+    Thereby, SerialPort can automatically write data from the
+    internal transfer buffer to the serial port in the event loop.
+*/
+void WinCESerialPortEngine::setWriteNotificationEnabled(bool enable)
+{
+    setNotificationEnabled(enable, EV_TXEMPTY);
+
+    // This only for OS Windows, as EV_TXEMPTY event is triggered only
+    // after the last byte of data.
+    // Therefore, we are forced to run writeNotification(), as EV_TXEMPTY does not work.
+    if (enable)
+        dptr->canWriteNotification();
+}
+
+/*!
+    Returns the current error notification subsystem status.
+*/
+bool WinCESerialPortEngine::isErrorNotificationEnabled() const
+{
+    return isNotificationEnabled(EV_ERR);
+}
+
+/*!
+    Enables or disables the error notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of an event EV_ERR.
+*/
+void WinCESerialPortEngine::setErrorNotificationEnabled(bool enable)
+{
+    setNotificationEnabled(enable, EV_ERR);
+}
+
+/*!
+    Defines the type of parity or frame error when an event EV_ERR occurs.
+
+    This method is automatically called from the error handler in the
+    parent class SerialPortPrivate, which is called by the error notification
+    subsystem when an event EV_ERR occurs.
+*/
+bool WinCESerialPortEngine::processIOErrors()
+{
+    DWORD err = 0;
+    const bool ret = ::ClearCommError(m_descriptor, &err, 0) != 0;
+    if (ret && err) {
+        if (err & CE_FRAME)
+            dptr->setError(SerialPort::FramingError);
+        else if (err & CE_RXPARITY)
+            dptr->setError(SerialPort::ParityError);
+        else if (err & CE_BREAK)
+            dptr->setError(SerialPort::BreakConditionError);
+        else
+            dptr->setError(SerialPort::UnknownPortError);
+
+        m_flagErrorFromCommEvent = true;
+    }
+    return ret;
+}
+
+void WinCESerialPortEngine::lockNotification(NotificationLockerType type, bool uselocker)
+{
+    QMutex *mutex = 0;
+    switch (type) {
+    case CanReadLocker:
+        mutex = &m_readNotificationMutex;
+        break;
+    case CanWriteLocker:
+        mutex = &m_writeNotificationMutex;
+        break;
+    case CanErrorLocker:
+        mutex = &m_errorNotificationMutex;
+        break;
+    default:
+        break;
+    }
+
+    if (uselocker)
+        QMutexLocker locker(mutex);
+    else
+        mutex->lock();
+}
+
+void WinCESerialPortEngine::unlockNotification(NotificationLockerType type)
+{
+    switch (type) {
+    case CanReadLocker:
+        m_readNotificationMutex.unlock();
+        break;
+    case CanWriteLocker:
+        m_writeNotificationMutex.unlock();
+        break;
+    case CanErrorLocker:
+        m_errorNotificationMutex.unlock();
+        break;
+    default:
+        break;
+    }
+}
+
+/* Protected methods */
+
+/*!
+    Attempts to determine the current serial port settings,
+    when the port is opened. Used only in the method open().
+*/
+void WinCESerialPortEngine::detectDefaultSettings()
+{
+    // Detect rate.
+    dptr->options.inputRate = quint32(m_currentDcb.BaudRate);
+    dptr->options.outputRate = dptr->options.inputRate;
+
+    // Detect databits.
+    switch (m_currentDcb.ByteSize) {
+    case 5:
+        dptr->options.dataBits = SerialPort::Data5;
+        break;
+    case 6:
+        dptr->options.dataBits = SerialPort::Data6;
+        break;
+    case 7:
+        dptr->options.dataBits = SerialPort::Data7;
+        break;
+    case 8:
+        dptr->options.dataBits = SerialPort::Data8;
+        break;
+    default:
+        dptr->options.dataBits = SerialPort::UnknownDataBits;
+        break;
+    }
+
+    // Detect parity.
+    if ((m_currentDcb.Parity == NOPARITY) && !m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::NoParity;
+    else if ((m_currentDcb.Parity == SPACEPARITY) && m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::SpaceParity;
+    else if ((m_currentDcb.Parity == MARKPARITY) && m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::MarkParity;
+    else if ((m_currentDcb.Parity == EVENPARITY) && m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::EvenParity;
+    else if ((m_currentDcb.Parity == ODDPARITY) && m_currentDcb.fParity)
+        dptr->options.parity = SerialPort::OddParity;
+    else
+        dptr->options.parity = SerialPort::UnknownParity;
+
+    // Detect stopbits.
+    switch (m_currentDcb.StopBits) {
+    case ONESTOPBIT:
+        dptr->options.stopBits = SerialPort::OneStop;
+        break;
+    case ONE5STOPBITS:
+        dptr->options.stopBits = SerialPort::OneAndHalfStop;
+        break;
+    case TWOSTOPBITS:
+        dptr->options.stopBits = SerialPort::TwoStop;
+        break;
+    default:
+        dptr->options.stopBits = SerialPort::UnknownStopBits;
+        break;
+    }
+
+    // Detect flow control.
+    if (!m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
+            && !m_currentDcb.fInX && !m_currentDcb.fOutX) {
+        dptr->options.flow = SerialPort::NoFlowControl;
+    } else if (!m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_DISABLE)
+               && m_currentDcb.fInX && m_currentDcb.fOutX) {
+        dptr->options.flow = SerialPort::SoftwareControl;
+    } else if (m_currentDcb.fOutxCtsFlow && (m_currentDcb.fRtsControl == RTS_CONTROL_HANDSHAKE)
+               && !m_currentDcb.fInX && !m_currentDcb.fOutX) {
+        dptr->options.flow = SerialPort::HardwareControl;
+    } else
+        dptr->options.flow = SerialPort::UnknownFlowControl;
+}
+
+/*!
+    Converts the platform-depend code of system error to the
+    corresponding value a SerialPort::PortError.
+*/
+SerialPort::PortError WinCESerialPortEngine::decodeSystemError() const
+{
+    SerialPort::PortError error;
+    switch (::GetLastError()) {
+    case ERROR_FILE_NOT_FOUND:
+        error = SerialPort::NoSuchDeviceError;
+        break;
+    case ERROR_ACCESS_DENIED:
+        error = SerialPort::PermissionDeniedError;
+        break;
+    case ERROR_INVALID_HANDLE:
+        error = SerialPort::DeviceIsNotOpenedError;
+        break;
+    case ERROR_INVALID_PARAMETER:
+        error = SerialPort::UnsupportedPortOperationError;
+        break;
+    default:
+        error = SerialPort::UnknownPortError;
+        break;
+    }
+    return error;
+}
+
+/*!
+    Embedded-based (WinCE) event loop for the notification subsystem.
+    The serial port events EV_ERR, EV_RXCHAR, and EV_TXEMPTY are tracked
+    in a separate thread. When a relevant event occurs, the appropriate
+    handler from the parent class SerialPortPrivate is called.
+    At the same time in handlers to capture/release the mutex
+    (see handlers implementation).
+*/
+void WinCESerialPortEngine::run()
+{
+    while (m_running) {
+
+        m_setCommMaskMutex.lock();
+        ::SetCommMask(m_descriptor, m_desiredMask);
+        m_setCommMaskMutex.unlock();
+
+        if (::WaitCommEvent(m_descriptor, &m_currentMask, 0) != 0) {
+
+            // Wait until complete the operation changes the port settings,
+            // see updateDcb().
+            m_settingsChangeMutex.lock();
+            m_settingsChangeMutex.unlock();
+
+            if (EV_ERR & m_currentMask & m_desiredMask) {
+                dptr->canErrorNotification();
+            }
+            if (EV_RXCHAR & m_currentMask & m_desiredMask) {
+                dptr->canReadNotification();
+            }
+            //FIXME: This is why it does not work?
+            if (EV_TXEMPTY & m_currentMask & m_desiredMask) {
+                dptr->canWriteNotification();
+            }
+        }
+    }
+}
+
+/*!
+*/
+bool WinCESerialPortEngine::isNotificationEnabled(DWORD mask) const
+{
+    bool enabled = isRunning();
+    return enabled && (m_desiredMask & mask);
+}
+
+/*!
+*/
+void WinCESerialPortEngine::setNotificationEnabled(bool enable, DWORD mask)
+{
+    m_setCommMaskMutex.lock();
+    ::GetCommMask(m_descriptor, &m_currentMask);
+
+    // Mask only the desired bits without affecting others.
+    if (enable)
+        m_desiredMask |= mask;
+    else
+        m_desiredMask &= ~mask;
+
+    ::SetCommMask(m_descriptor, m_desiredMask);
+
+    m_setCommMaskMutex.unlock();
+
+    if (enable && !isRunning())
+        start();
+}
+
+/*!
+    Updates the DCB structure when changing any serial port parameter.
+
+    If successful, returns true; otherwise returns false.
+*/
+bool WinCESerialPortEngine::updateDcb()
+{
+    // Grab a mutex, in order after exit WaitCommEvent
+    // block the flow of run() notifier until there is a change DCB.
+    QMutexLocker locker(&m_settingsChangeMutex);
+    // This way, we reset in class WaitCommEvent to
+    // be able to change the DCB.
+    // Otherwise WaitCommEvent blocking any change!
+    ::SetCommMask(m_descriptor, 0);
+    if (::SetCommState(m_descriptor, &m_currentDcb) == 0) {
+        dptr->setError(decodeSystemError());
+        return false;
+    }
+    return true;
+}
+
+/*!
+    Updates the COMMTIMEOUTS structure when changing any serial port
+    timeout parameter.
+
+    If successful, returns true; otherwise returns false.
+*/
+bool WinCESerialPortEngine::updateCommTimeouts()
+{
+    if (::SetCommTimeouts(m_descriptor, &m_currentCommTimeouts) == 0) {
+        dptr->setError(decodeSystemError());
+        return false;
+    }
+    return true;
+}
+
+// From <serialportengine_p.h>
+SerialPortEngine *SerialPortEngine::create(SerialPortPrivate *d)
+{
+    return new WinCESerialPortEngine(d);
+}
+
+/* Public static the SerialPortPrivate methods */
+
+static const QLatin1String defaultPathPostfix(":");
+
+/*!
+    Converts a platform specific \a port name to a system location
+    and returns the value.
+*/
+QString SerialPortPrivate::portNameToSystemLocation(const QString &port)
+{
+    QString ret = port;
+    if (!ret.contains(defaultPathPostfix))
+        ret.append(defaultPathPostfix);
+    return ret;
+}
+
+/*!
+    Converts a platform specific system \a location to a port name
+    and returns the value.
+*/
+QString SerialPortPrivate::portNameFromSystemLocation(const QString &location)
+{
+    QString ret = location;
+    if (ret.contains(defaultPathPostfix))
+        ret.remove(defaultPathPostfix);
+    return ret;
+}
+
+// This table contains standard values of baud rates that
+// are defined in MSDN and/or in Win SDK file winbase.h
+static
+const qint32 standardRatesTable[] =
+{
+    #ifdef CBR_110
+    CBR_110,
+    #endif
+    #ifdef CBR_300
+    CBR_300,
+    #endif
+    #ifdef CBR_600
+    CBR_600,
+    #endif
+    #ifdef CBR_1200
+    CBR_1200,
+    #endif
+    #ifdef CBR_2400
+    CBR_2400,
+    #endif
+    #ifdef CBR_4800
+    CBR_4800,
+    #endif
+    #ifdef CBR_9600
+    CBR_9600,
+    #endif
+    #ifdef CBR_14400
+    CBR_14400,
+    #endif
+    #ifdef CBR_19200
+    CBR_19200,
+    #endif
+    #ifdef CBR_38400
+    CBR_38400,
+    #endif
+    #ifdef CBR_56000
+    CBR_56000,
+    #endif
+    #ifdef CBR_57600
+    CBR_57600,
+    #endif
+    #ifdef CBR_115200
+    CBR_115200,
+    #endif
+    #ifdef CBR_128000
+    CBR_128000,
+    #endif
+    #ifdef CBR_256000
+    CBR_256000
+    #endif
+};
+
+static const qint32 *standardRatesTable_end =
+        standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
+
+/*!
+    Converts the windows-specific baud rate code \a setting to a numeric value.
+    If the desired item is not found, returns 0.
+*/
+qint32 SerialPortPrivate::rateFromSetting(qint32 setting)
+{
+    const qint32 *ret = qFind(standardRatesTable, standardRatesTable_end, setting);
+    return ret != standardRatesTable_end ? *ret : 0;
+}
+
+/*!
+    Converts a numeric baud \a rate value to the windows-specific code.
+    If the desired item is not found, returns 0.
+*/
+qint32 SerialPortPrivate::settingFromRate(qint32 rate)
+{
+    const qint32 *ret = qBinaryFind(standardRatesTable, standardRatesTable_end, rate);
+    return ret != standardRatesTable_end ? *ret : 0;
+}
+
+/*!
+   Returns a list of standard baud rates that
+   are defined in MSDN and/or in Win SDK file winbase.h.
+*/
+QList<qint32> SerialPortPrivate::standardRates()
+{
+   QList<qint32> l;
+   for (const qint32 *it = standardRatesTable; it != standardRatesTable_end; ++it)
+      l.append(*it);
+   return l;
+}
+
+#include "moc_serialportengine_wince_p.cpp"
+
+QT_END_NAMESPACE_SERIALPORT
+
diff --git a/src/serialportengine_wince_p.h b/src/serialportengine_wince_p.h
new file mode 100644
index 0000000..23eba83
--- /dev/null
+++ b/src/serialportengine_wince_p.h
@@ -0,0 +1,181 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Denis Shienkov <scapig@yandex.ru>
+** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SERIALPORTENGINE_WINCE_P_H
+#define SERIALPORTENGINE_WINCE_P_H
+
+#include "serialport.h"
+#include "serialportengine_p.h"
+
+#include <qt_windows.h>
+#include <QtCore/qmutex.h>
+#include <QtCore/qthread.h>
+#include <QtCore/qtimer.h>
+
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+class WinCEWaitCommEventBreaker : public QThread
+{
+    Q_OBJECT
+public:
+    WinCEWaitCommEventBreaker(HANDLE descriptor, int timeout, QObject *parent = 0)
+        : QThread(parent)
+        , m_descriptor(descriptor)
+        , m_timeout(timeout)
+        , m_worked(false) {
+        start();
+    }
+    virtual ~WinCEWaitCommEventBreaker() {
+        stop();
+        wait();
+    }
+    void stop() { exit(0); }
+    bool isWorked() const { return m_worked; }
+
+protected:
+    void run() {
+        QTimer timer;
+        QObject::connect(&timer, SIGNAL(timeout()), this, SLOT(procTimeout()), Qt::DirectConnection);
+        timer.start(m_timeout);
+        exec();
+        m_worked = true;
+    }
+
+private slots:
+    void procTimeout() {
+        ::SetCommMask(m_descriptor, 0);
+        stop();
+    }
+
+private:
+    HANDLE m_descriptor;
+    int m_timeout;
+    volatile bool m_worked;
+};
+
+class WinCESerialPortEngine : public QThread, public SerialPortEngine
+{
+    Q_OBJECT
+public:
+    WinCESerialPortEngine(SerialPortPrivate *d);
+    virtual ~WinCESerialPortEngine();
+
+    virtual bool open(const QString &location, QIODevice::OpenMode mode);
+    virtual void close(const QString &location);
+
+    virtual SerialPort::Lines lines() const;
+
+    virtual bool setDtr(bool set);
+    virtual bool setRts(bool set);
+
+    virtual bool flush();
+    virtual bool reset();
+
+    virtual bool sendBreak(int duration);
+    virtual bool setBreak(bool set);
+
+    virtual qint64 bytesAvailable() const;
+    virtual qint64 bytesToWrite() const;
+
+    virtual qint64 read(char *data, qint64 len);
+    virtual qint64 write(const char *data, qint64 len);
+    virtual bool select(int timeout,
+                        bool checkRead, bool checkWrite,
+                        bool *selectForRead, bool *selectForWrite);
+
+    virtual bool setRate(qint32 rate, SerialPort::Directions dir);
+    virtual bool setDataBits(SerialPort::DataBits dataBits);
+    virtual bool setParity(SerialPort::Parity parity);
+    virtual bool setStopBits(SerialPort::StopBits stopBits);
+    virtual bool setFlowControl(SerialPort::FlowControl flowControl);
+
+    virtual bool setDataErrorPolicy(SerialPort::DataErrorPolicy policy);
+
+    virtual bool isReadNotificationEnabled() const;
+    virtual void setReadNotificationEnabled(bool enable);
+    virtual bool isWriteNotificationEnabled() const;
+    virtual void setWriteNotificationEnabled(bool enable);
+    virtual bool isErrorNotificationEnabled() const;
+    virtual void setErrorNotificationEnabled(bool enable);
+
+    virtual bool processIOErrors();
+
+    // FIXME
+    virtual void lockNotification(NotificationLockerType type, bool uselocker);
+    virtual void unlockNotification(NotificationLockerType type);
+
+protected:
+    virtual void detectDefaultSettings();
+    virtual SerialPort::PortError decodeSystemError() const;
+
+    virtual void run();
+
+private:
+
+    bool isNotificationEnabled(DWORD mask) const;
+    void setNotificationEnabled(bool enable, DWORD mask);
+
+    bool updateDcb();
+    bool updateCommTimeouts();
+
+private:
+    DCB m_currentDcb;
+    DCB m_restoredDcb;
+    COMMTIMEOUTS m_currentCommTimeouts;
+    COMMTIMEOUTS m_restoredCommTimeouts;
+    HANDLE m_descriptor;
+    bool m_flagErrorFromCommEvent;
+    DWORD m_currentMask;
+    DWORD m_desiredMask;
+
+    QMutex m_readNotificationMutex;
+    QMutex m_writeNotificationMutex;
+    QMutex m_errorNotificationMutex;
+    QMutex m_settingsChangeMutex;
+    QMutex m_setCommMaskMutex;
+    volatile bool m_running;
+};
+
+QT_END_NAMESPACE_SERIALPORT
+
+#endif // SERIALPORTENGINE_WINCE_P_H
diff --git a/src/serialportinfo_win.cpp b/src/serialportinfo_win.cpp
index fb892a2..8842f78 100755
--- a/src/serialportinfo_win.cpp
+++ b/src/serialportinfo_win.cpp
@@ -48,9 +48,7 @@
 #include <qt_windows.h>
 #include <objbase.h>
 #include <initguid.h>
-#ifndef Q_OS_WINCE
-#  include <setupapi.h>
-#endif
+#include <setupapi.h>
 
 #include <QtCore/qvariant.h>
 #include <QtCore/qstringlist.h>
@@ -59,7 +57,6 @@ QT_BEGIN_NAMESPACE_SERIALPORT
 
 static const GUID guidsArray[] =
 {
-    #ifndef Q_OS_WINCE
     // Windows Ports Class GUID
     { 0x4D36E978, 0xE325, 0x11CE, { 0xBF, 0xC1, 0x08, 0x00, 0x2B, 0xE1, 0x03, 0x18 } },
     // Virtual Ports Class GUID (i.e. com0com and etc)
@@ -70,13 +67,8 @@ static const GUID guidsArray[] =
     { 0xCC0EF009, 0xB820, 0x42F4, { 0x95, 0xA9, 0x9B, 0xFA, 0x6A, 0x5A, 0xB7, 0xAB } },
     // Advanced Virtual COM Port GUID
     { 0x9341CD95, 0x4371, 0x4A37, { 0xA5, 0xAF, 0xFD, 0xB0, 0xA9, 0xD1, 0x96, 0x31 } },
-    #else
-    { 0xCC5195AC, 0xBA49, 0x48A0, { 0xBE, 0x17, 0xDF, 0x6D, 0x1B, 0x01, 0x73, 0xDD } }
-    #endif
 };
 
-#ifndef Q_OS_WINCE
-
 static QVariant getDeviceRegistryProperty(HDEVINFO deviceInfoSet,
                                           PSP_DEVINFO_DATA deviceInfoData,
                                           DWORD property)
@@ -213,68 +205,11 @@ static QString parseHardwareId(ExtractCommand cmd, const QStringList &hardwareId
     return rx.cap(cmd);
 }
 
-#else
-
-const static QString valueName(QLatin1String("FriendlyName"));
-static QString findDescription(HKEY parentKeyHandle, const QString &subKey)
-{
-    QString result;
-    HKEY hSubKey = 0;
-    LONG res = ::RegOpenKeyEx(parentKeyHandle, reinterpret_cast<const wchar_t *>(subKey.utf16()),
-                              0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hSubKey);
-
-    if (res == ERROR_SUCCESS) {
-
-        DWORD dataType = 0;
-        DWORD dataSize = 0;
-        res = ::RegQueryValueEx(hSubKey, reinterpret_cast<const wchar_t *>(valueName.utf16()),
-                                0, &dataType, 0, &dataSize);
-
-        if (res == ERROR_SUCCESS) {
-            QByteArray data(dataSize, 0);
-            res = ::RegQueryValueEx(hSubKey, reinterpret_cast<const wchar_t *>(valueName.utf16()),
-                                    0, 0,
-                                    reinterpret_cast<unsigned char *>(data.data()),
-                                    &dataSize);
-
-            if (res == ERROR_SUCCESS) {
-                switch (dataType) {
-                case REG_EXPAND_SZ:
-                case REG_SZ:
-                    if (dataSize)
-                        result = QString::fromWCharArray(reinterpret_cast<const wchar_t *>(data.constData()));
-                    break;
-                default:
-                    break;
-                }
-            }
-        } else {
-            DWORD index = 0;
-            dataSize = 255; // Max. key length (see MSDN).
-            QByteArray data(dataSize, 0);
-            while (::RegEnumKeyEx(hSubKey, index++,
-                                  reinterpret_cast<wchar_t *>(data.data()), &dataSize,
-                                  0, 0, 0, 0) == ERROR_SUCCESS) {
-
-                result = findDescription(hSubKey,
-                                         QString::fromUtf16(reinterpret_cast<ushort *>(data.data()), dataSize));
-                if (!result.isEmpty())
-                    break;
-            }
-        }
-        ::RegCloseKey(hSubKey);
-    }
-    return result;
-}
-
-#endif
-
 QList<SerialPortInfo> SerialPortInfo::availablePorts()
 {
     QList<SerialPortInfo> ports;
     static const int guidCount = sizeof(guidsArray)/sizeof(guidsArray[0]);
 
-#ifndef Q_OS_WINCE
     for (int i = 0; i < guidCount; ++i) {
 
         const HDEVINFO deviceInfoSet = ::SetupDiGetClassDevs(&guidsArray[i], 0, 0, DIGCF_PRESENT);
@@ -314,31 +249,7 @@ QList<SerialPortInfo> SerialPortInfo::availablePorts()
 
         ::SetupDiDestroyDeviceInfoList(deviceInfoSet);
     }
-#else
-    //for (int i = 0; i < guidCount; ++i) {
-    DEVMGR_DEVICE_INFORMATION di;
-    di.dwSize = sizeof(di);
-    const HANDLE hSearch = ::FindFirstDevice(DeviceSearchByLegacyName/*DeviceSearchByGuid*/,
-                                             L"COM*"/*&guidsArray[i]*/,
-                                             &di);
-    if (hSearch != INVALID_HANDLE_VALUE) {
-        do {
-            SerialPortInfo info;
-            info.d_ptr->device = QString::fromWCharArray(di.szLegacyName);
-            info.d_ptr->portName = SerialPortPrivate::portNameFromSystemLocation(info.d_ptr->device);
-            info.d_ptr->description = findDescription(HKEY_LOCAL_MACHINE,
-                                                      QString::fromWCharArray(di.szDeviceKey));
-
-            // Get manufacturer, vendor identifier, product identifier are not
-            // possible.
 
-            ports.append(info);
-
-        } while (::FindNextDevice(hSearch, &di));
-        ::FindClose(hSearch);
-    }
-    //}
-#endif
     return ports;
 }
 
diff --git a/src/serialportinfo_wince.cpp b/src/serialportinfo_wince.cpp
new file mode 100644
index 0000000..f9b6830
--- /dev/null
+++ b/src/serialportinfo_wince.cpp
@@ -0,0 +1,177 @@
+/****************************************************************************
+**
+** Copyright (C) 2011-2012 Denis Shienkov <scapig2@yandex.ru>
+** Copyright (C) 2011 Sergey Belyashov <Sergey.Belyashov@gmail.com>
+** Copyright (C) 2012 Laszlo Papp <lpapp@kde.org>
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtSerialPort module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "serialportinfo.h"
+#include "serialportinfo_p.h"
+#include "serialportengine_win_p.h"
+
+#include <qt_windows.h>
+#include <objbase.h>
+#include <initguid.h>
+
+#include <QtCore/qvariant.h>
+#include <QtCore/qstringlist.h>
+
+QT_BEGIN_NAMESPACE_SERIALPORT
+
+static const GUID guidsArray[] =
+{
+    { 0xCC5195AC, 0xBA49, 0x48A0, { 0xBE, 0x17, 0xDF, 0x6D, 0x1B, 0x01, 0x73, 0xDD } }
+};
+
+const static QString valueName(QLatin1String("FriendlyName"));
+static QString findDescription(HKEY parentKeyHandle, const QString &subKey)
+{
+    QString result;
+    HKEY hSubKey = 0;
+    LONG res = ::RegOpenKeyEx(parentKeyHandle, reinterpret_cast<const wchar_t *>(subKey.utf16()),
+                              0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hSubKey);
+
+    if (res == ERROR_SUCCESS) {
+
+        DWORD dataType = 0;
+        DWORD dataSize = 0;
+        res = ::RegQueryValueEx(hSubKey, reinterpret_cast<const wchar_t *>(valueName.utf16()),
+                                0, &dataType, 0, &dataSize);
+
+        if (res == ERROR_SUCCESS) {
+            QByteArray data(dataSize, 0);
+            res = ::RegQueryValueEx(hSubKey, reinterpret_cast<const wchar_t *>(valueName.utf16()),
+                                    0, 0,
+                                    reinterpret_cast<unsigned char *>(data.data()),
+                                    &dataSize);
+
+            if (res == ERROR_SUCCESS) {
+                switch (dataType) {
+                case REG_EXPAND_SZ:
+                case REG_SZ:
+                    if (dataSize)
+                        result = QString::fromWCharArray(reinterpret_cast<const wchar_t *>(data.constData()));
+                    break;
+                default:
+                    break;
+                }
+            }
+        } else {
+            DWORD index = 0;
+            dataSize = 255; // Max. key length (see MSDN).
+            QByteArray data(dataSize, 0);
+            while (::RegEnumKeyEx(hSubKey, index++,
+                                  reinterpret_cast<wchar_t *>(data.data()), &dataSize,
+                                  0, 0, 0, 0) == ERROR_SUCCESS) {
+
+                result = findDescription(hSubKey,
+                                         QString::fromUtf16(reinterpret_cast<ushort *>(data.data()), dataSize));
+                if (!result.isEmpty())
+                    break;
+            }
+        }
+        ::RegCloseKey(hSubKey);
+    }
+    return result;
+}
+
+QList<SerialPortInfo> SerialPortInfo::availablePorts()
+{
+    QList<SerialPortInfo> ports;
+
+    DEVMGR_DEVICE_INFORMATION di;
+    di.dwSize = sizeof(di);
+    const HANDLE hSearch = ::FindFirstDevice(DeviceSearchByLegacyName,
+                                             L"COM*",
+                                             &di);
+    if (hSearch != INVALID_HANDLE_VALUE) {
+        do {
+            SerialPortInfo info;
+            info.d_ptr->device = QString::fromWCharArray(di.szLegacyName);
+            info.d_ptr->portName = SerialPortPrivate::portNameFromSystemLocation(info.d_ptr->device);
+            info.d_ptr->description = findDescription(HKEY_LOCAL_MACHINE,
+                                                      QString::fromWCharArray(di.szDeviceKey));
+
+            // Get manufacturer, vendor identifier, product identifier are not
+            // possible.
+
+            ports.append(info);
+
+        } while (::FindNextDevice(hSearch, &di));
+        ::FindClose(hSearch);
+    }
+
+    return ports;
+}
+
+
+QList<qint32> SerialPortInfo::standardRates()
+{
+    return SerialPortPrivate::standardRates();
+}
+
+bool SerialPortInfo::isBusy() const
+{
+    const HANDLE descriptor = ::CreateFile(reinterpret_cast<const wchar_t*>(systemLocation().utf16()),
+                                           GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
+
+    if (descriptor == INVALID_HANDLE_VALUE) {
+        if (::GetLastError() == ERROR_ACCESS_DENIED)
+            return true;
+    } else {
+        ::CloseHandle(descriptor);
+    }
+    return false;
+}
+
+bool SerialPortInfo::isValid() const
+{
+    const HANDLE descriptor = ::CreateFile(reinterpret_cast<const wchar_t*>(systemLocation().utf16()),
+                                           GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
+
+    if (descriptor == INVALID_HANDLE_VALUE) {
+        if (::GetLastError() != ERROR_ACCESS_DENIED)
+            return false;
+    } else {
+        ::CloseHandle(descriptor);
+    }
+    return true;
+}
+
+QT_END_NAMESPACE_SERIALPORT
diff --git a/src/src-lib.pri b/src/src-lib.pri
index 9877951..fa89b0a 100644
--- a/src/src-lib.pri
+++ b/src/src-lib.pri
@@ -22,13 +22,23 @@ SOURCES += \
 
 
 win32 {
-    PRIVATE_HEADERS += \
-        $$PWD/serialportengine_win_p.h
-    SOURCES += \
-        $$PWD/serialportengine_win.cpp \
-        $$PWD/serialportinfo_win.cpp
+    !wince*: {
+        PRIVATE_HEADERS += \
+            $$PWD/serialportengine_win_p.h
+
+        SOURCES += \
+            $$PWD/serialportengine_win.cpp \
+            $$PWD/serialportinfo_win.cpp
 
-    !wince*: LIBS += -lsetupapi -luuid -ladvapi32
+        LIBS += -lsetupapi -luuid -ladvapi32
+    } else {
+        PRIVATE_HEADERS += \
+            $$PWD/serialportengine_wince_p.h
+
+        SOURCES += \
+            $$PWD/serialportengine_wince.cpp \
+            $$PWD/serialportinfo_wince.cpp
+    }
 }
 
 symbian {