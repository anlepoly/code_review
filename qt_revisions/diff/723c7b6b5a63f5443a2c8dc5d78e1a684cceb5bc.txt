diff --git a/src/serialportengine_symbian.cpp b/src/serialportengine_symbian.cpp
index aa4f772..34f3e19 100755
--- a/src/serialportengine_symbian.cpp
+++ b/src/serialportengine_symbian.cpp
@@ -6,32 +6,24 @@
     \class SymbianSerialPortEngine
     \internal
 
-    \brief The SymbianSerialPortEngine class provides *nix OS
+    \brief The SymbianSerialPortEngine class provides Symbian OS
     platform-specific low level access to a serial port.
 
     \reentrant
     \ingroup serialport-main
     \inmodule QtSerialPort
 
-    Currently the class supports all?? version of Symbian OS.
+    Currently the class supports Symbian3 and Symbian SR1 version of Symbian OS.
 
     SymbianSerialPortEngine (as well as other platform-dependent engines)
     is a class with multiple inheritance, which on the one hand,
     derives from a general abstract class interface SerialPortEngine,
-    on the other hand of a class inherited from QObject.
+    on the other hand from QObject.
 
-    From the abstract class SerialPortEngine, it inherits all virtual
+    From the abstract class SerialPortEngine, this class inherits all virtual
     interface methods that are common to all serial ports on any platform.
-    These methods, the class SymbianSerialPortEngine implements use
+    The class SymbianSerialPortEngine implements these methods using the
     Symbian API.
-
-    From QObject-like class ...
-    ...
-    ...
-    ...
-
-    That is, as seen from the above, the functional SymbianSerialPortEngine
-    completely covers all the necessary tasks.
 */
 
 #include "serialportengine_symbian_p.h"
@@ -95,11 +87,9 @@ QT_BEGIN_NAMESPACE_SERIALPORT
 /* Public methods */
 
 /*!
-    Constructs a SymbianSerialPortEngine with \a parent and
-    initializes all the internal variables of the initial values.
-
-    A pointer \a parent to the object class SerialPortPrivate
-    is required for the recursive call some of its methods.
+    Constructs a SymbianSerialPortEngine and initializes all internal variables
+    to their initial values. The pointer \a d to the private object of class
+    SerialPortPrivate is used to call some common methods.
 */
 SymbianSerialPortEngine::SymbianSerialPortEngine(SerialPortPrivate *d)
 {
@@ -117,18 +107,18 @@ SymbianSerialPortEngine::~SymbianSerialPortEngine()
 }
 
 /*!
-    Tries to open the object desired serial port by \a location
-    in the given open \a mode. In the API of Symbian there is no flag
-    to open the port in r/o, w/o or r/w, most likely he always opens
-    as r/w.
+    Attempts to open the desired serial port by \a location
+    in the given open \a mode. In the Symbian API there is no flag
+    to open the port in r/o, w/o or r/w. The port most likely always
+    opens as r/w.
 
-    Since the port in the Symbian OS can be open in any access mode,
-    then this method forcibly puts a port in exclusive mode access.
-    In the process of discovery, always set a port in non-blocking
-    mode (when the read operation returns immediately) and tries to
-    determine its current configuration and install them.
+    Since Symbian OS allows to open the port in any access mode, this
+    method forces the port in exclusive mode access.
+    In the process of discovery, always sets the serial port in non-blocking
+    mode (where the read operation returns immediately) and tries to determine
+    and install the current configuration to the serial port.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool SymbianSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode)
@@ -191,7 +181,7 @@ bool SymbianSerialPortEngine::open(const QString &location, QIODevice::OpenMode
 }
 
 /*!
-    Closes a serial port object. Before closing restore previous
+    Closes a serial port. Before closing, restores previous
     serial port settings if necessary.
 */
 void SymbianSerialPortEngine::close(const QString &location)
@@ -206,11 +196,11 @@ void SymbianSerialPortEngine::close(const QString &location)
 }
 
 /*!
-    Returns a bitmap state of RS-232 line signals. On error,
-    bitmap will be empty (equal zero).
+    Returns a bitmap state of the RS-232 line signals. On error,
+    the bitmap will be empty (equal zero).
 
-    Symbian API allows you to receive only the state of signals:
-    CTS, DSR, DCD, RING, RTS, DTR. Other signals are not available.
+    The Symbian API only provides the state of the following signals:
+    CTS, DSR, DCD, RING, RTS, and DTR. Other signals are not available.
 */
 SerialPort::Lines SymbianSerialPortEngine::lines() const
 {
@@ -240,7 +230,7 @@ SerialPort::Lines SymbianSerialPortEngine::lines() const
 /*!
     Set DTR signal to state \a set.
 
-
+    If successful, returns true; otherwise returns false.
 */
 bool SymbianSerialPortEngine::setDtr(bool set)
 {
@@ -256,7 +246,7 @@ bool SymbianSerialPortEngine::setDtr(bool set)
 /*!
     Set RTS signal to state \a set.
 
-
+    If successful, returns true; otherwise returns false.
 */
 bool SymbianSerialPortEngine::setRts(bool set)
 {
@@ -300,7 +290,7 @@ bool SymbianSerialPortEngine::reset()
 
     Setting breaks is not supported on the integral ARM
     serial hardware. EPOC has no support for detecting received
-    breaks. There is no way to detects whether setting a break is
+    breaks. There is no way to detect whether setting a break is
     supported using Caps().
 */
 bool SymbianSerialPortEngine::sendBreak(int duration)
@@ -320,7 +310,7 @@ bool SymbianSerialPortEngine::setBreak(bool set)
 }
 
 /*!
-    Gets the number of bytes currently waiting in the
+    Returns the number of bytes currently waiting in the
     driver's input buffer. A return value of zero means
     the buffer is empty.
 */
@@ -352,15 +342,15 @@ qint64 SymbianSerialPortEngine::bytesToWrite() const
 
 /*!
 
-    Reads data from a serial port only if it arrives before a
+    Reads data from the serial port only if it arrives before a
     specified time-out (zero). All reads from the serial device
-    use 8-bit m_descriptors as data buffers, even on a Unicode system.
+    use 8-bit descriptors as data buffers, even on a Unicode system.
 
     The length of the TDes8 is set to zero on entry, which means that
     buffers can be reused without having to be zeroed first.
 
     The number of bytes to read is set to the maximum length of the
-    m_descriptor.
+    descriptor.
 
     If a read is issued with a data length of zero the Read() completes
     immediately but with the side effect that the serial hardware is
@@ -369,7 +359,7 @@ qint64 SymbianSerialPortEngine::bytesToWrite() const
     When a Read() terminates with KErrTimedOut, different protocol
     modules can show different behaviours. Some may write any data
     received into the aDes buffer, while others may return just an
-    empty m_descriptor. In the case of a returned empty m_descriptor use
+    empty descriptor. In the case of a returned empty descriptor use
     ReadOneOrMore() to read any data left in the buffer.
 
     The behaviour of this API after a call to NotifyDataAvailable() is
@@ -395,11 +385,11 @@ qint64 SymbianSerialPortEngine::read(char *data, qint64 len)
 
 /*!
 
-    Writes data to a serial port. All writes to the serial device
-    use 8-bit m_descriptors as data buffers, even on a Unicode system.
+    Writes data to the serial port. All writes to the serial device
+    use 8-bit descriptors as data buffers, even on a Unicode system.
 
     The number of bytes to write is set to the maximum length of
-    the m_descriptor.
+    the descriptor.
 
     When a Write() is issued with a data length of zero it cannot
     complete until the current handshaking configuration and the
@@ -502,10 +492,10 @@ bool SymbianSerialPortEngine::select(int timeout,
 //static const QString defaultPathPostfix = ":";
 
 /*!
-    Converts a platform specific \a port name to system location
-    and return result.
+    Converts a platform specific \a port name to a system location
+    and returns the value.
 
-    Does not do anything because These concepts are equivalent.
+    Does not convert anything because on Symbian both are equal.
 */
 QString SymbianSerialPortEngine::toSystemLocation(const QString &port) const
 {
@@ -514,10 +504,10 @@ QString SymbianSerialPortEngine::toSystemLocation(const QString &port) const
 }
 
 /*!
-    Converts a platform specific system \a location to port name
-    and return result.
+    Converts a platform specific system \a location to a port name
+    and returns the value.
 
-    Does not do anything because These concepts are equivalent.
+    Does not convert anything because on Symbian both are equal.
 */
 QString SymbianSerialPortEngine::fromSystemLocation(const QString &location) const
 {
@@ -526,12 +516,13 @@ QString SymbianSerialPortEngine::fromSystemLocation(const QString &location) con
 }
 
 /*!
-    Set desired \a rate by given direction \a dir.
-    However, Symbian does not support separate directions, so the
-    method will return an error. Also it supports only the standard
-    set of speed.
+    Sets the desired baud \a rate for the given direction \a dir.
+    As Symbian does not support separate directions, the only valid value for
+    \dir is SerialPort::AllDirections.
+
+    On Symbian, this method only supports the standard baud rate set.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool SymbianSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
@@ -553,10 +544,10 @@ bool SymbianSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 }
 
 /*!
-    Set desired number of data bits \a dataBits in byte. Symbian
-    native supported all present number of data bits 5, 6, 7, 8.
+    Sets the desired number of data bits \a dataBits in a frame. Symbian
+    supports all present number of data bits: 5, 6, 7, and 8.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool SymbianSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
@@ -583,10 +574,10 @@ bool SymbianSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 }
 
 /*!
-    Set desired \a parity control mode. Symbian native supported
-    all present parity types no parity, space, mark, even, odd.
+    Sets the desired \a parity control mode. Symbian supports
+    all present parity types: no parity, space, mark, even, and odd parity.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool SymbianSerialPortEngine::setParity(SerialPort::Parity parity)
@@ -616,10 +607,10 @@ bool SymbianSerialPortEngine::setParity(SerialPort::Parity parity)
 }
 
 /*!
-    Set desired number of stop bits \a stopBits in frame. Symbian
-    native supported only 1, 2 number of stop bits.
+    Sets the desired number of stop bits \a stopBits in a frame. Symbian
+    only supports 1 or 2 stop bits.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool SymbianSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
@@ -640,11 +631,11 @@ bool SymbianSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
 }
 
 /*!
-    Set desired \a flow control mode. Symbian native supported all
-    present flow control modes no control, hardware (RTS/CTS),
-    software (XON/XOFF).
+    Sets the desired \a flow control mode. Symbian supports all
+    present flow control modes: no control, hardware (RTS/CTS),
+    and software (XON/XOFF).
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool SymbianSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
@@ -789,8 +780,8 @@ static const RatePair *standardRatesTable_end =
         standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
 
 /*!
-    Convert symbian-specific enum of baud rate to a numeric value.
-    If the desired item is not found then returns 0.
+    Converts the symbian-specific baud rate enum to a numeric value.
+    If the desired item is not found, returns 0.
 */
 qint32 SymbianSerialPortEngine::rateFromSetting(EBps setting)
 {
@@ -800,8 +791,8 @@ qint32 SymbianSerialPortEngine::rateFromSetting(EBps setting)
 }
 
 /*!
-    Convert a numeric value of baud rate to symbian-specific enum.
-    If the desired item is not found then returns 0.
+    Converts a numeric baud rate value to a symbian-specific enum.
+    If the desired item is not found, returns 0.
 */
 EBps SymbianSerialPortEngine::settingFromRate(qint32 rate)
 {
@@ -811,8 +802,9 @@ EBps SymbianSerialPortEngine::settingFromRate(qint32 rate)
 }
 
 /*!
-    Returns a list standard values of baud rates,
-    enums are defined in
+    Returns a list of standard baud rate values.
+
+    Enums are defined in:
    - d32comm.h for Symbian^3
    - d32public.h for Symbian SR1.
 */
@@ -827,8 +819,8 @@ QList<qint32> SymbianSerialPortEngine::standardRates()
 /* Protected methods */
 
 /*!
-    Attempts to determine the current settings of the serial port,
-    wehn it opened. Used only in the method open().
+    Attempts to determine the current serial port settings,
+    when the port is opened. Used only in the method open().
 */
 void SymbianSerialPortEngine::detectDefaultSettings()
 {
@@ -903,10 +895,9 @@ void SymbianSerialPortEngine::detectDefaultSettings()
 /* Private methods */
 
 /*!
-    Updates the TCommConfig structure wehn changing of any the
-    parameters a serial port.
+    Updates the TCommConfig structure when changing any serial port parameter.
 
-    If successful, returns true; otherwise returns false.
+    If successful, returns true; otherwise returns false and sets an error code.
 */
 bool SymbianSerialPortEngine::updateCommConfig()
 {
diff --git a/src/serialportengine_unix.cpp b/src/serialportengine_unix.cpp
index 4dce86d..b24d3f9 100755
--- a/src/serialportengine_unix.cpp
+++ b/src/serialportengine_unix.cpp
@@ -14,25 +14,21 @@
     \inmodule QtSerialPort
 
     Currently the class supports all POSIX-compatible OS (GNU/Linux, *BSD,
-    Mac OSX and etc).
+    Mac OSX and so forth).
 
     UnixSerialPortEngine (as well as other platform-dependent engines)
     is a class with multiple inheritance, which on the one hand,
     derives from a general abstract class interface SerialPortEngine,
-    on the other hand of a class inherited from QObject.
+    on the other hand from QObject.
 
-    From the abstract class SerialPortEngine, it inherits all virtual
-    interface methods that are common to all serial ports on any platform.
-    These methods, the class UnixSerialPortEngine implements use
-    POSIX ABI.
+    From the abstract class SerialPortEngine, this class inherits all virtual
+    interface methods that are common to all serial ports on any platform. The
+    class UnixSerialPortEngine implements these methods using the POSIX API.
 
-    From QObject-like class, it inherits a specific system Qt features.
-    For example, to track of events from a serial port uses the virtual
-    QObject method eventFilter(), who the make analysis of the events
-    from the type classes QSocketNotifier.
-
-    That is, as seen from the above, the functional UnixSerialPortEngine
-    completely covers all the necessary tasks.
+    From QObject, this class inherits system specific Qt features. For example,
+    to track serial port events, this class uses the virtual QObject method
+    eventFilter(), which analyses the events from the type class
+    QSocketNotifier.
 */
 
 #include "serialportengine_unix_p.h"
@@ -59,11 +55,9 @@ QT_BEGIN_NAMESPACE_SERIALPORT
 /* Public methods */
 
 /*!
-    Constructs a UnixSerialPortEngine with \a parent and
-    initializes all the internal variables of the initial values.
-
-    A pointer \a parent to the object class SerialPortPrivate
-    is required for the recursive call some of its methods.
+    Constructs a UnixSerialPortEngine and initializes all internal variables
+    to their initial values. The pointer \a d to the private object of class
+    SerialPortPrivate is used to call some common methods.
 */
 UnixSerialPortEngine::UnixSerialPortEngine(SerialPortPrivate *d)
     : m_descriptor(-1)
@@ -80,8 +74,7 @@ UnixSerialPortEngine::UnixSerialPortEngine(SerialPortPrivate *d)
 }
 
 /*!
-    Stops the tracking events of the serial port and
-    destructs a UnixSerialPortEngine.
+    Stops the serial port event tracking and destructs a UnixSerialPortEngine.
 */
 UnixSerialPortEngine::~UnixSerialPortEngine()
 {
@@ -94,32 +87,29 @@ UnixSerialPortEngine::~UnixSerialPortEngine()
 }
 
 /*!
-    Tries to open the m_descriptor desired serial port by \a location
-    in the given open \a mode.
+    Attempts to open the desired serial port by \a location in the given
+    open \a mode.
 
-    Before the opening of the serial port, checking for on exists the
-    appropriate lock the file and the information therein. If the
-    lock file is present, and the information contained in it is
-    relevant - it is concluded that the current serial port is
-    already occupied.
+    Before opening the serial port, open() checks if the appropriate lock file
+    exists. If the lock file is present and contains valid information, the
+    current serial port is already occupied and thus cannot be opened.
 
-    In the process of discovery, always set a serial port in
-    non-blocking mode (when the read operation returns immediately)
-    and tries to determine its current configuration and install them.
+    In the process of discovery, always sets the serial port in non-blocking
+    mode (where the read operation returns immediately) and tries to determine
+    and install the current configuration to the serial port.
 
-    Since the port in the POSIX OS by default opens in shared mode,
-    then this method forcibly puts a port in exclusive mode access.
+    Since the POSIX API by default opens the port in shared mode,
+    this method forces the port in exclusive access mode.
     This is done simultaneously in two ways:
-    - set to the pre-open m_descriptor a flag TIOCEXCL
-    - creates a lock file, which writes the pid of the process, that
-    opened the port and other information
+    - the flag TIOCEXCL is set to the pre-opened m_descriptor
+    - a lock file is created, which contains the PID of the process, that
+      opened the port and other information
 
-    Need to use two methods due to the fact that on some platforms can
-    not be defined constant TIOCEXCL, in this case, try to use the
-    lock file. Creation and analysis of lock file, by using a special
-    helper class TTYLocker.
+    Two methods need to be used due to the fact that some platforms doesn't
+    support the constant TIOCEXCL. In this case, only the lock file is used.
+    Lock file creation and analysis is done by the helper class TTYLocker.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode)
@@ -195,9 +185,9 @@ bool UnixSerialPortEngine::open(const QString &location, QIODevice::OpenMode mod
 }
 
 /*!
-    Closes a serial port m_descriptor. Before closing - clears exclusive
-    access flag and removes the lock file, restore previous serial port
-    settings if necessary.
+    Closes a serial port. Before closing, clears the exclusive access flag,
+    removes the lock file, and restores the previous serial port settings
+    if necessary.
 */
 void UnixSerialPortEngine::close(const QString &location)
 {
@@ -227,12 +217,12 @@ void UnixSerialPortEngine::close(const QString &location)
 }
 
 /*!
-    Returns a bitmap state of RS-232 line signals. On error,
-    bitmap will be empty (equal zero).
+    Returns a bitmap state of the RS-232 line signals. On error,
+    the bitmap will be empty (equal zero).
 
-    POSIX ABI allows you to receive all the state of signals:
-    LE, DTR, RTS, ST, SR, CTS, DCD, RING, DSR. Of course, if the
-    corresponding constants are defined in a particular platform.
+    The POSIX API provides the state of all signals:
+    LE, DTR, RTS, ST, SR, CTS, DCD, RING, and DSR. Of course, if the
+    corresponding constants are defined on the particular platform.
 */
 SerialPort::Lines UnixSerialPortEngine::lines() const
 {
@@ -417,7 +407,7 @@ qint64 UnixSerialPortEngine::bytesAvailable() const
 }
 
 /*!
-    Not supported on POSIX-compatible platform,
+    Not supported on POSIX-compatible platforms,
     always returns 0.
 */
 qint64 UnixSerialPortEngine::bytesToWrite() const
@@ -427,14 +417,12 @@ qint64 UnixSerialPortEngine::bytesToWrite() const
 }
 
 /*!
-    If successful, returns to the external buffer \a data the
-    real number of bytes read, which can be less than the
-    requested \a len; otherwise returned -1 with set error code.
-    In any case, reading function returns immediately.
+    Reads at most \a len bytes from the serial port into \a data, and returns
+    the number of bytes read. If an error occurs, this function returns -1
+    and sets an error code. This function returns immediately.
 
-    Some platforms do not support the mark or space parity, so
-    running software emulation of these modes in the process of
-    reading.
+    Some platforms does not support the mark or space parity, so
+    a software emulation of these modes is done while reading.
 
     Also, this method processed the policy of operating with the
     received symbol, in which the parity or frame error is detected.
@@ -489,13 +477,12 @@ qint64 UnixSerialPortEngine::read(char *data, qint64 len)
 }
 
 /*!
-    Write \a data to serial port. If successful, returns the
-    real number of bytes write, which can be less than the
-    requested \a len; otherwise returned -1 with set error code.
+    Writes at most \a len bytes of data from \a data to the serial port.
+    If successful, returns the number of bytes that were actually written;
+    otherwise returns -1 and sets an error code.
 
-    Some platforms do not support the mark or space parity, so
-    running software emulation of these modes in the process of
-    writting.
+    Some platforms does not support the mark or space parity, so
+    running software emulation of these modes while writing.
 */
 qint64 UnixSerialPortEngine::write(const char *data, qint64 len)
 {
@@ -594,8 +581,8 @@ static const QString defaultPathPrefix = QLatin1String("/dev/");
 #endif
 
 /*!
-    Converts a platform specific \a port name to system location
-    and return result.
+    Converts a platform specific \a port name to a system location
+    and returns the value.
 */
 QString UnixSerialPortEngine::toSystemLocation(const QString &port) const
 {
@@ -611,8 +598,8 @@ QString UnixSerialPortEngine::toSystemLocation(const QString &port) const
 }
 
 /*!
-    Converts a platform specific system \a location to port name
-    and return result.
+    Converts a platform specific system \a location to a port name
+    and returns the value.
 */
 QString UnixSerialPortEngine::fromSystemLocation(const QString &location) const
 {
@@ -627,12 +614,12 @@ QString UnixSerialPortEngine::fromSystemLocation(const QString &location) const
 }
 
 /*!
-    Set desired \a rate by given direction \a dir,
+    Sets the desired baud \a rate for the given direction \a dir,
     where \a rate is expressed by any positive integer type qint32.
-    Also the method make attempts to analyze the type of the desired
-    standard or custom speed and trying to set it.
+    Also the method makes attempts to analyze the type of the desired
+    standard or custom speed and sets the value.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
@@ -711,10 +698,10 @@ bool UnixSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 }
 
 /*!
-    Set desired number of data bits \a dataBits in byte. POSIX
-    native supported all present number of data bits 5, 6, 7, 8.
+    Sets the desired number of data bits \a dataBits in a frame. POSIX
+    supports all present number of data bits 5, 6, 7, and 8.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool UnixSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
@@ -741,13 +728,12 @@ bool UnixSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 }
 
 /*!
-    Set desired \a parity control mode. POSIX native not supported
-    modes mark and space, so is their software emulation in the
-    methods read() and write(). But, in particular, some GNU/Linux
-    has hardware support for these modes, therefore, no need to
-    emulate.
+    Sets the desired \a parity control mode. POSIX does not support
+    the modes mark and space, so they are software emulated in the
+    methods read() and write(). Some GNU/Linux variants have hardware
+    support for these modes and don't need an emulation.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool UnixSerialPortEngine::setParity(SerialPort::Parity parity)
@@ -788,10 +774,10 @@ bool UnixSerialPortEngine::setParity(SerialPort::Parity parity)
 }
 
 /*!
-    Set desired number of stop bits \a stopBits in frame. POSIX
-    native supported only 1, 2 number of stop bits.
+    Sets the desired number of stop bits \a stopBits in a frame. POSIX
+    only supports 1 or 2 stop bits.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool UnixSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
@@ -811,11 +797,11 @@ bool UnixSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
 }
 
 /*!
-    Set desired \a flow control mode. POSIX  native supported all
-    present flow control modes no control, hardware (RTS/CTS),
-    software (XON/XOFF).
+    Sets the desired \a flow control mode. POSIX supports all
+    present flow control modes: no control, hardware (RTS/CTS),
+    and software (XON/XOFF).
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false, and sets an
     error code.
 */
 bool UnixSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
@@ -841,8 +827,8 @@ bool UnixSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
 }
 
 /*!
-    Set desired char error \a policy when errors are detected
-    frame or parity.
+    Sets the desired char error \a policy when frame or parity errors are
+    detected.
 */
 bool UnixSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
 {
@@ -876,7 +862,7 @@ bool UnixSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy
 }
 
 /*!
-    Returns the current status of the read notification subsystem.
+    Returns the current read notification subsystem status.
 */
 bool UnixSerialPortEngine::isReadNotificationEnabled() const
 {
@@ -884,12 +870,12 @@ bool UnixSerialPortEngine::isReadNotificationEnabled() const
 }
 
 /*!
-    Enables or disables read notification subsystem, depending on
-    the \a enable parameter. If the subsystem is enabled, it will
-    asynchronously track the occurrence of an event fdread.
-    Thanks to that, SerialPort can emit a signal readyRead() and
-    fill up the internal receive buffer with new data, that
-    automatically received from a serial port in the event loop.
+    Enables or disables the read notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of the event fdread.
+    Thereby, SerialPort can emit the signal readyRead() and automatically
+    fill the internal receive buffer with new data that was received from
+    the serial port in the event loop.
 */
 void UnixSerialPortEngine::setReadNotificationEnabled(bool enable)
 {
@@ -905,7 +891,7 @@ void UnixSerialPortEngine::setReadNotificationEnabled(bool enable)
 }
 
 /*!
-    Returns the current status of the write notification subsystem.
+    Returns the current write notification subsystem status.
 */
 bool UnixSerialPortEngine::isWriteNotificationEnabled() const
 {
@@ -913,11 +899,11 @@ bool UnixSerialPortEngine::isWriteNotificationEnabled() const
 }
 
 /*!
-    Enables or disables write notification subsystem, depending on
-    the \a enable parameter. If the subsystem is enabled, it will
-    asynchronously track the occurrence of an event fdwrite.
-    Thanks to that, SerialPort can write data from internal transfer
-    buffer, to serial port automatically in the event loop.
+    Enables or disables the write notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of the event fdwrite.
+    Thereby, SerialPort can automatically write data from the
+    internal transfer buffer to the serial port in the event loop.
 */
 void UnixSerialPortEngine::setWriteNotificationEnabled(bool enable)
 {
@@ -933,7 +919,7 @@ void UnixSerialPortEngine::setWriteNotificationEnabled(bool enable)
 }
 
 /*!
-    Returns the current status of the errors notification subsystem.
+    Returns the current error notification subsystem status.
 */
 bool UnixSerialPortEngine::isErrorNotificationEnabled() const
 {
@@ -941,9 +927,9 @@ bool UnixSerialPortEngine::isErrorNotificationEnabled() const
 }
 
 /*!
-    Enables or disables errors notification subsystem, depending on
-    the \a enable parameter. If the subsystem is enabled, it will
-    asynchronously track the occurrence of an event fderror.
+    Enables or disables the error notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of the event fderror.
 */
 void UnixSerialPortEngine::setErrorNotificationEnabled(bool enable)
 {
@@ -962,7 +948,7 @@ void UnixSerialPortEngine::setErrorNotificationEnabled(bool enable)
     Not used in POSIX implementation, error handling is carried
     out in other ways.
 
-    Always returned false.
+    Always returns false.
 */
 bool UnixSerialPortEngine::processIOErrors()
 {
@@ -1081,8 +1067,8 @@ static const RatePair *standardRatesTable_end =
         standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
 
 /*!
-    Convert *nix-specific code of baud rate to a numeric value.
-    If the desired item is not found then returns 0.
+    Converts the *nix-specific baud rate code \a setting to a numeric value.
+    If the desired item is not found, returns 0.
 */
 qint32 UnixSerialPortEngine::rateFromSetting(qint32 setting)
 {
@@ -1092,8 +1078,8 @@ qint32 UnixSerialPortEngine::rateFromSetting(qint32 setting)
 }
 
 /*!
-    Convert a numeric value of baud rate to *nix-specific code.
-    If the desired item is not found then returns 0.
+    Converts a numeric baud \a rate value to the *nix-specific code.
+    If the desired item is not found, returns 0.
 */
 qint32 UnixSerialPortEngine::settingFromRate(qint32 rate)
 {
@@ -1103,8 +1089,7 @@ qint32 UnixSerialPortEngine::settingFromRate(qint32 rate)
 }
 
 /*!
-    Returns a list standard values of baud rates,
-    codes are defined in termios.h
+    Returns a list of standard baud rate values, codes are defined in termios.h.
 */
 QList<qint32> UnixSerialPortEngine::standardRates()
 {
@@ -1117,8 +1102,8 @@ QList<qint32> UnixSerialPortEngine::standardRates()
 /* Protected methods */
 
 /*!
-    Attempts to determine the current settings of the serial port,
-    wehn it opened. Used only in the method open().
+    Attempts to determine the current serial port settings,
+    when the port is opened. Used only in the method open().
 */
 void UnixSerialPortEngine::detectDefaultSettings()
 {
@@ -1225,9 +1210,9 @@ void UnixSerialPortEngine::detectDefaultSettings()
 /*!
     POSIX event loop for notification subsystem.
     Asynchronously in event loop continuous mode tracking the
-    events from the serial port, as: fderror, fdread, fdwrite.
-    When is occur a relevant event, calls him handler from
-    a parent class SerialPortPrivate.
+    events from the serial port, as: fderror, fdread, and fdwrite.
+    Calls the handler from the parent class SerialPortPrivate
+    when a relevant event occurs.
 */
 bool UnixSerialPortEngine::eventFilter(QObject *obj, QEvent *e)
 {
@@ -1251,8 +1236,7 @@ bool UnixSerialPortEngine::eventFilter(QObject *obj, QEvent *e)
 /* Private methods */
 
 /*!
-    Updates the termios structure wehn changing of any the
-    parameters a serial port.
+    Updates the termios structure when changing any serial port parameter.
 
     If successful, returns true; otherwise returns false.
 */
diff --git a/src/serialportengine_win.cpp b/src/serialportengine_win.cpp
index 4196c93..4e6dbbc 100755
--- a/src/serialportengine_win.cpp
+++ b/src/serialportengine_win.cpp
@@ -6,40 +6,37 @@
     \class WinSerialPortEngine
     \internal
 
-    \brief The WinSerialPortEngine class provides windows OS
+    \brief The WinSerialPortEngine class provides Windows OS
     platform-specific low level access to a serial port.
 
     \reentrant
     \ingroup serialport-main
     \inmodule QtSerialPort
 
-    Currently the class supports as NT-based OS (Win 2K/XP/Vista/7),
-    and as various embedded WinCE.
+    Currently the class supports all Windows NT-based OS (Win 2K/XP/Vista/7),
+    and various embedded Windows CE.
 
     WinSerialPortEngine (as well as other platform-dependent engines)
     is a class with multiple inheritance, which on the one hand,
     derives from a general abstract class interface SerialPortEngine,
-    on the other hand of a class inherited from QObject.
+    on the other hand from QObject.
 
-    From the abstract class SerialPortEngine, it inherits all virtual
+    From the abstract class SerialPortEngine, this class inherits all virtual
     interface methods that are common to all serial ports on any platform.
-    These methods, the class WinSerialPortEngine implements on the OS
-    Windows platform, using a corresponding Win API.
-
-    From QObject-like class, it inherits a specific system Qt features.
-    For example, for NT-based platforms WinSerialPortEngine uses private
-    Qt class QWinEventNotifier. Thanks to this class, it have the
-    opportunity to asynchronously track the events from the serial port,
-    such as the appearance of a character in the receive buffer,
-    error I/O, and etc. Ie events are handled in Qt core in its event
-    loop, so no need to create additional threads to perform these
-    operations. However, for embedded systems, this approach does not work,
-    because they have a another Win API. In this case, WinSerialPortEngine
-    is derived from QThread and creates an additional thread to keep track
-    of events.
-
-    That is, as seen from the above, the functional WinSerialPortEngine
-    completely covers all the necessary tasks.
+    The class WinSerialPortEngine implements these methods using the
+    Windows API.
+
+    From QObject, this class inherits system specific Qt features.
+    For NT-based platforms, WinSerialPortEngine uses the private Qt class
+    QWinEventNotifier. This class allows to asynchronously track events
+    from the serial port, such as the appearance of a character in the
+    receive buffer, error I/O, and so forth. All events are handled in the
+    Qt core event loop, so no additional threads are needed to perform these
+    operations.
+
+    However, for Windows CE systems, this approach does not work, because they
+    have another Windows API. In this case, WinSerialPortEngine is derived
+    from QThread and creates an additional thread to track the events.
 */
 
 #include "serialportengine_win_p.h"
@@ -86,11 +83,9 @@ QT_BEGIN_NAMESPACE_SERIALPORT
 /* Public methods */
 
 /*!
-    Constructs a WinSerialPortEngine with \a parent and
-    initializes all the internal variables of the initial values.
-
-    A pointer \a parent to the object class SerialPortPrivate
-    is required for the recursive call some of its methods.
+    Constructs a WinSerialPortEngine and initializes all internal variables
+    to their initial values. The pointer \a d to the private object of class
+    SerialPortPrivate is used to call some common methods.
 */
 WinSerialPortEngine::WinSerialPortEngine(SerialPortPrivate *d)
     : m_descriptor(INVALID_HANDLE_VALUE)
@@ -120,8 +115,7 @@ WinSerialPortEngine::WinSerialPortEngine(SerialPortPrivate *d)
 }
 
 /*!
-    Stops the tracking events of the serial port and
-    destructs a WinSerialPortEngine.
+    Stops the serial port event tracking and destructs a WinSerialPortEngine.
 */
 WinSerialPortEngine::~WinSerialPortEngine()
 {
@@ -136,21 +130,20 @@ WinSerialPortEngine::~WinSerialPortEngine()
 }
 
 /*!
-    Tries to open the handle desired serial port by \a location in the
-    given open \a mode. In the process of discovery, always set a
-    serial port in non-blocking mode (when the read operation returns
-    immediately) and tries to determine its current configuration and
-    install them.
-
-    It should be noted the following features that Windows performs
-    when using the serial port:
+    Attempts to open the desired serial port by \a location in the given open
+    \a mode. In the process of discovery, always sets the serial port in
+    non-blocking mode (where the read operation returns immediately) and tries
+    to determine and install the current configuration to the serial port.
+
+    It should be noted, that Windows has the following limitations when using
+    the serial port:
     - support only binary transfers mode
     - always open in exclusive mode
 
-    For Windows NT-based platforms, the serial port is opened in the
-    overlapped mode, with flag FILE_FLAG_OVERLAPPED.
+    For Windows NT-based platforms, the serial port is opened in the overlapped
+    mode, with the flag FILE_FLAG_OVERLAPPED.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode)
@@ -245,8 +238,8 @@ bool WinSerialPortEngine::open(const QString &location, QIODevice::OpenMode mode
 }
 
 /*!
-    Closes a serial port handle. Before closing - restore previous
-    serial port settings if necessary.
+    Closes a serial port. Before closing, restores the previous serial port
+    settings if necessary.
 */
 void WinSerialPortEngine::close(const QString &location)
 {
@@ -270,11 +263,11 @@ void WinSerialPortEngine::close(const QString &location)
 }
 
 /*!
-    Returns a bitmap state of RS-232 line signals. On error,
-    bitmap will be empty (equal zero).
+    Returns a bitmap state of the RS-232 line signals. On error,
+    the bitmap will be empty (equal zero).
 
-    Win API allows you to receive only the state of signals:
-    CTS, DSR, RING, DCD, DTR, RTS. Other signals are not available.
+    The Windows API only provides the state of the following signals:
+    CTS, DSR, RING, DCD, DTR, and RTS. Other signals are not available.
 */
 SerialPort::Lines WinSerialPortEngine::lines() const
 {
@@ -340,8 +333,8 @@ bool WinSerialPortEngine::setRts(bool set)
 }
 
 /*!
-    Flushes the buffers of a specified serial port and
-    causes all buffered data to be written to a serial port.
+    Flushes the serial port's buffers and causes all buffered data to be written
+    to the serial port.
 
     If successful, returns true; otherwise returns false.
 */
@@ -356,9 +349,8 @@ bool WinSerialPortEngine::flush()
 }
 
 /*!
-    Discards all characters from the output or input buffer of
-    a specified communications resource. It can also terminate
-    pending read or write operations on the resource.
+    Discards all characters from the serial port's output or input buffer.
+    This can also terminate pending read or write operations.
 
     If successful, returns true; otherwise returns false.
 */
@@ -420,7 +412,7 @@ static qint64 get_commstat_que(HANDLE m_descriptor, enum CommStatQue que)
 
 /*!
     Returns the number of bytes received by the serial provider
-    but not yet read by a read() operation. Also it clears the
+    but not yet read by a read() operation. Also clears the
     device's error flag to enable additional input and output
     (I/O) operations.
 
@@ -435,7 +427,7 @@ qint64 WinSerialPortEngine::bytesAvailable() const
     Returns the number of bytes of user data remaining to be
     transmitted for all write operations. This value will be zero
     for a nonoverlapped write (for embedded platform as WinCE).
-    Also it clears the device's error flag to enable additional
+    Also clears the device's error flag to enable additional
     input and output (I/O) operations.
 
     If successful, returns true; otherwise returns false.
@@ -457,13 +449,9 @@ static void clear_overlapped(OVERLAPPED *overlapped)
 #endif
 
 /*!
-    Read data from serial port. For NT-based platform, process
-    data's reading with the waiting wehn of pending I/O
-    operations is complete. Maybe this can cause some freezes.
-
-    If successful, returns to the external buffer \a data the
-    real number of bytes read, which can be less than the
-    requested \a len; otherwise returned -1 with set error code.
+    Reads at most \a len bytes from the serial port into \a data, and returns
+    the number of bytes read. If an error occurs, this function returns -1
+    and sets an error code. This function returns immediately.
 
     Also, this method processed the policy of operating with the
     received symbol, in which the parity or frame error is detected.
@@ -528,13 +516,9 @@ qint64 WinSerialPortEngine::read(char *data, qint64 len)
 }
 
 /*!
-    Write \a data to serial port. For NT-based platform, process
-    data's writing with the waiting wehn of pending I/O
-    operations is complete. Maybe this can cause some freezes.
-
-    If successful, returns the real number of bytes write, which
-    can be less than the requested \a len; otherwise returned -1
-    with set error code.
+    Writes at most \a len bytes of data from \a data to the serial port.
+    If successful, returns the number of bytes that were actually written;
+    otherwise returns -1 and sets an error code.
 */
 qint64 WinSerialPortEngine::write(const char *data, qint64 len)
 {
@@ -576,7 +560,7 @@ qint64 WinSerialPortEngine::write(const char *data, qint64 len)
     of catch in each of the events, save to the corresponding
     variables \a selectForRead and \a selectForWrite.
 
-    For NT-based OS and embedded, this method have different
+    For NT-based OS and Windows CE, this method have different
     implementation. WinCE has no mechanism to exit out of a timeout,
     therefore for this feature special class is used
     WinCeWaitCommEventBreaker, without which it is locked to wait
@@ -685,8 +669,8 @@ static const QString defaultPathPostfix = QLatin1String(":");
 #endif
 
 /*!
-    Converts a platform specific \a port name to system location
-    and return result.
+    Converts a platform specific \a port name to a system location
+    and returns the value.
 */
 QString WinSerialPortEngine::toSystemLocation(const QString &port) const
 {
@@ -702,8 +686,8 @@ QString WinSerialPortEngine::toSystemLocation(const QString &port) const
 }
 
 /*!
-    Converts a platform specific system \a location to port name
-    and return result.
+    Converts a platform specific system \a location to a port name
+    and returns the value.
 */
 QString WinSerialPortEngine::fromSystemLocation(const QString &location) const
 {
@@ -719,11 +703,11 @@ QString WinSerialPortEngine::fromSystemLocation(const QString &location) const
 }
 
 /*!
-    Set desired \a rate by given direction \a dir.
-    However, windows does not support separate directions, so the
-    method will return an error.
+    Sets the desired baud \a rate for the given direction \a dir.
+    As Windows does not support separate directions, the only valid value for
+    \dir is SerialPort::AllDirections.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool WinSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
@@ -737,10 +721,10 @@ bool WinSerialPortEngine::setRate(qint32 rate, SerialPort::Directions dir)
 }
 
 /*!
-    Set desired number of data bits \a dataBits in byte. Windows
-    native supported all present number of data bits 5, 6, 7, 8.
+    Sets the desired number of data bits \a dataBits in a frame. Windows
+    supports all present number of data bits 5, 6, 7, and 8.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool WinSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
@@ -750,10 +734,10 @@ bool WinSerialPortEngine::setDataBits(SerialPort::DataBits dataBits)
 }
 
 /*!
-    Set desired \a parity control mode. Windows native supported
-    all present parity types no parity, space, mark, even, odd.
+    Sets the desired \a parity control mode. Windows supports
+    all present parity types: no parity, space, mark, even, and odd parity.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool WinSerialPortEngine::setParity(SerialPort::Parity parity)
@@ -784,11 +768,10 @@ bool WinSerialPortEngine::setParity(SerialPort::Parity parity)
 }
 
 /*!
-    Set desired number of stop bits \a stopBits in frame.
-    Windows native supported all present number of stop bits
-    1, 1.5, 2.
+    Sets the desired number of stop bits \a stopBits in a frame.
+    Windows supports 1, 1.5, or 2 stop bits.
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool WinSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
@@ -812,10 +795,10 @@ bool WinSerialPortEngine::setStopBits(SerialPort::StopBits stopBits)
 
 /*!
     Set desired \a flow control mode. Windows native supported all
-    present flow control modes no control, hardware (RTS/CTS),
-    software (XON/XOFF).
+    present flow control modes: no control, hardware (RTS/CTS),
+    and software (XON/XOFF).
 
-    If successful, returns true; otherwise returns false, with the setup a
+    If successful, returns true; otherwise returns false and sets an
     error code.
 */
 bool WinSerialPortEngine::setFlowControl(SerialPort::FlowControl flow)
@@ -854,7 +837,7 @@ bool WinSerialPortEngine::setDataErrorPolicy(SerialPort::DataErrorPolicy policy)
 }
 
 /*!
-    Returns the current status of the read notification subsystem.
+    Returns the current read notification subsystem status.
 */
 bool WinSerialPortEngine::isReadNotificationEnabled() const
 {
@@ -862,12 +845,12 @@ bool WinSerialPortEngine::isReadNotificationEnabled() const
 }
 
 /*!
-    Enables or disables read notification subsystem, depending on
-    the \a enable parameter. If the subsystem is enabled, it will
-    asynchronously track the occurrence of an event EV_RXCHAR.
-    Thanks to that, SerialPort can emit a signal readyRead() and
-    fill up the internal receive buffer with new data, that
-    automatically received from a serial port in the event loop.
+    Enables or disables the read notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of the event EV_RXCHAR.
+    Thereby, SerialPort can emit the signal readyRead() and automatically
+    fill the internal receive buffer with new data, that was received from
+    the serial port in the event loop.
 */
 void WinSerialPortEngine::setReadNotificationEnabled(bool enable)
 {
@@ -875,7 +858,7 @@ void WinSerialPortEngine::setReadNotificationEnabled(bool enable)
 }
 
 /*!
-    Returns the current status of the write notification subsystem.
+    Returns the current write notification subsystem status.
 */
 bool WinSerialPortEngine::isWriteNotificationEnabled() const
 {
@@ -883,11 +866,11 @@ bool WinSerialPortEngine::isWriteNotificationEnabled() const
 }
 
 /*!
-    Enables or disables write notification subsystem, depending on
-    the \a enable parameter. If the subsystem is enabled, it will
-    asynchronously track the occurrence of an event EV_TXEMPTY.
-    Thanks to that, SerialPort can write data from internal transfer
-    buffer, to serial port automatically in the event loop.
+    Enables or disables the write notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of the event EV_TXEMPTY.
+    Thereby, SerialPort can automatically write data from the
+    internal transfer buffer to the serial port in the event loop.
 */
 void WinSerialPortEngine::setWriteNotificationEnabled(bool enable)
 {
@@ -901,7 +884,7 @@ void WinSerialPortEngine::setWriteNotificationEnabled(bool enable)
 }
 
 /*!
-    Returns the current status of the errors notification subsystem.
+    Returns the current error notification subsystem status.
 */
 bool WinSerialPortEngine::isErrorNotificationEnabled() const
 {
@@ -909,9 +892,9 @@ bool WinSerialPortEngine::isErrorNotificationEnabled() const
 }
 
 /*!
-    Enables or disables errors notification subsystem, depending on
-    the \a enable parameter. If the subsystem is enabled, it will
-    asynchronously track the occurrence of an event EV_ERR.
+    Enables or disables the error notification subsystem, depending on
+    the \a enable parameter. The enabled subsystem will asynchronously
+    track the occurrence of an event EV_ERR.
 */
 void WinSerialPortEngine::setErrorNotificationEnabled(bool enable)
 {
@@ -919,15 +902,11 @@ void WinSerialPortEngine::setErrorNotificationEnabled(bool enable)
 }
 
 /*!
-    Defines the type of parity or frame error when an event
-    occurs EV_ERR. In addition, in case of any errors, this method
-    sets to true a flag m_flagErrorFromCommEvent, that used in the
-    method of reading for policy processing.
-
-    This method is called automatically from an error handler in
-    parent class SerialPortPrivate, that called by error notification
-    subsystem, wehn occurred a event EV_ERR.
+    Defines the type of parity or frame error when an event EV_ERR occurs.
 
+    This method is automatically called from the error handler in the
+    parent class SerialPortPrivate, which is called by the error notification
+    subsystem when an event EV_ERR occurs.
 */
 bool WinSerialPortEngine::processIOErrors()
 {
@@ -1046,7 +1025,7 @@ static const qint32 *standardRatesTable_end =
         standardRatesTable + sizeof(standardRatesTable)/sizeof(*standardRatesTable);
 
 /*!
-   Returns a list standard values of baud rate that
+   Returns a list of standard baud rates that
    are defined in MSDN and/or in Win SDK file winbase.h.
 */
 QList<qint32> WinSerialPortEngine::standardRates()
@@ -1060,8 +1039,8 @@ QList<qint32> WinSerialPortEngine::standardRates()
 /* Protected methods */
 
 /*!
-    Attempts to determine the current settings of the serial port,
-    wehn it opened. Used only in the method open().
+    Attempts to determine the current serial port settings,
+    when the port is opened. Used only in the method open().
 */
 void WinSerialPortEngine::detectDefaultSettings()
 {
@@ -1133,10 +1112,10 @@ void WinSerialPortEngine::detectDefaultSettings()
 #if defined (Q_OS_WINCE)
 
 /*!
-    Embedded-based (WinCE) event loop for notification subsystem.
-    Tracking a separate thread the events from the serial port, as:
-    EV_ERR, EV_RXCHAR, EV_TXEMPTY. When is occur a relevant event,
-    calls him handler from a parent class SerialPortPrivate.
+    Embedded-based (WinCE) event loop for the notification subsystem.
+    The serial port events EV_ERR, EV_RXCHAR, and EV_TXEMPTY are tracked
+    in a separate thread. When a relevant event occurs, the appropriate
+    handler from the parent class SerialPortPrivate is called.
     At the same time in handlers to capture/release the mutex
     (see handlers implementation).
 */
@@ -1172,11 +1151,10 @@ void WinSerialPortEngine::run()
 #else
 
 /*!
-    Windows NT-based event loop for notification subsystem.
-    Asynchronously in event loop continuous mode tracking the
-    events from the serial port, as: EV_ERR, EV_RXCHAR, EV_TXEMPTY.
-    When is occur a relevant event, calls him handler from
-    a parent class SerialPortPrivate.
+    Windows NT-based event loop for the notification subsystem.
+    The serial port events EV_ERR, EV_RXCHAR, and EV_TXEMPTY are tracked
+    asynchronously in the event loop. When a relevant event occurs, the
+    appropriate handler from the parent class SerialPortPrivate is called.
 */
 bool WinSerialPortEngine::event(QEvent *e)
 {
@@ -1210,9 +1188,9 @@ bool WinSerialPortEngine::event(QEvent *e)
 #if !defined (Q_OS_WINCE)
 
 /*!
-    For Windows NT-based, creates handles events for OVERLAPPED
-    structures, that are used in the methods of reading \a rx,
-    writing \a tx, and waiting for data from the serial port.
+    For Windows NT-based OS, creates event handles for OVERLAPPED
+    structures, that are used in the reading method (if \a rx is true),
+    writing method (if \a tx is true), and waiting for data from the serial port.
     This method is only used in the method open().
 
     If successful, returns true; otherwise returns false.
@@ -1237,7 +1215,7 @@ bool WinSerialPortEngine::createEvents(bool rx, bool tx)
 }
 
 /*!
-    For Windows NT-based, release and closed handles events from
+    For Windows NT-based OS, releases and closes event handles for
     OVERLAPPED structures.
 */
 void WinSerialPortEngine::closeEvents()
@@ -1314,8 +1292,7 @@ void WinSerialPortEngine::setNotificationEnabled(bool enable, DWORD mask)
 }
 
 /*!
-    Updates the DCB structure wehn changing of any the parameters
-    a serial port.
+    Updates the DCB structure when changing any serial port parameter.
 
     If successful, returns true; otherwise returns false.
 */
@@ -1338,8 +1315,8 @@ bool WinSerialPortEngine::updateDcb()
 }
 
 /*!
-    Updates the COMMTIMEUTS structure wehn changing of any timeout the
-    parameters a serial port.
+    Updates the COMMTIMEOUTS structure when changing any serial port
+    timeout parameter.
 
     If successful, returns true; otherwise returns false.
 */