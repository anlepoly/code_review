diff --git a/src/widgets/styles/qgtk2painter.cpp b/src/widgets/styles/qgtk2painter.cpp
new file mode 100644
index 0000000..427041a
--- /dev/null
+++ b/src/widgets/styles/qgtk2painter.cpp
@@ -0,0 +1,705 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qgtk2painter_p.h"
+
+#include <QtCore/qglobal.h>
+#if !defined(QT_NO_STYLE_GTK)
+
+// This class is primarily a wrapper around the gtk painter functions
+// and takes care of converting all such calls into cached Qt pixmaps.
+
+#include <private/qgtkstyle_p.h>
+#include <private/qhexstring_p.h>
+#include <QtWidgets/QWidget>
+#include <QtGui/QPixmapCache>
+#include <QtCore/QLibrary>
+
+QT_BEGIN_NAMESPACE
+
+typedef GdkPixbuf* (*Ptr_gdk_pixbuf_get_from_drawable) (GdkPixbuf *, GdkDrawable *, GdkColormap *, int, int, int, int, int, int);
+typedef GdkPixmap* (*Ptr_gdk_pixmap_new) (GdkDrawable *, gint, gint, gint);
+typedef void (*Ptr_gdk_draw_rectangle) (GdkDrawable *, GdkGC *, gboolean, gint, gint, gint, gint);
+typedef void (*Ptr_gdk_drawable_unref)(GdkDrawable *);
+
+typedef void (*Ptr_gtk_paint_check) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
+typedef void (*Ptr_gtk_paint_box) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
+typedef void (*Ptr_gtk_paint_box_gap) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint, gint, gint , gint, GtkPositionType, gint, gint);
+typedef void (*Ptr_gtk_paint_resize_grip) (GtkStyle *, GdkWindow *, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, GdkWindowEdge, gint , gint , gint , gint);
+typedef void (*Ptr_gtk_paint_focus) (GtkStyle *, GdkWindow *, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
+typedef void (*Ptr_gtk_paint_shadow) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
+typedef void (*Ptr_gtk_paint_slider) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint, GtkOrientation);
+typedef void (*Ptr_gtk_paint_expander) (GtkStyle *, GdkWindow *, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , GtkExpanderStyle );
+typedef void (*Ptr_gtk_paint_handle) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint, GtkOrientation);
+typedef void (*Ptr_gtk_paint_arrow) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, GtkArrowType, gboolean, gint , gint , gint , gint);
+typedef void (*Ptr_gtk_paint_option) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
+typedef void (*Ptr_gtk_paint_flat_box) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
+typedef void (*Ptr_gtk_paint_extension) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint, gint, gint, gint, GtkPositionType);
+typedef void (*Ptr_gtk_paint_hline) (GtkStyle *, GdkWindow *, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, gint, gint, gint y);
+typedef void (*Ptr_gtk_paint_vline) (GtkStyle *, GdkWindow *, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, gint, gint, gint);
+
+namespace QGtk2PainterPrivate {
+    static Ptr_gdk_pixmap_new gdk_pixmap_new = 0;
+    static Ptr_gdk_pixbuf_get_from_drawable gdk_pixbuf_get_from_drawable = 0;
+    static Ptr_gdk_draw_rectangle gdk_draw_rectangle = 0;
+    static Ptr_gdk_drawable_unref gdk_drawable_unref = 0;
+
+    static Ptr_gtk_paint_check gtk_paint_check = 0;
+    static Ptr_gtk_paint_box gtk_paint_box = 0;
+    static Ptr_gtk_paint_box_gap gtk_paint_box_gap = 0;
+    static Ptr_gtk_paint_flat_box gtk_paint_flat_box = 0;
+    static Ptr_gtk_paint_option gtk_paint_option = 0;
+    static Ptr_gtk_paint_extension gtk_paint_extension = 0;
+    static Ptr_gtk_paint_slider gtk_paint_slider = 0;
+    static Ptr_gtk_paint_shadow gtk_paint_shadow = 0;
+    static Ptr_gtk_paint_resize_grip gtk_paint_resize_grip = 0;
+    static Ptr_gtk_paint_focus gtk_paint_focus = 0;
+    static Ptr_gtk_paint_arrow gtk_paint_arrow = 0;
+    static Ptr_gtk_paint_handle gtk_paint_handle = 0;
+    static Ptr_gtk_paint_expander gtk_paint_expander = 0;
+    static Ptr_gtk_paint_vline gtk_paint_vline = 0;
+    static Ptr_gtk_paint_hline gtk_paint_hline = 0;
+}
+
+static void initGtk()
+{
+    static bool initialized = false;
+    if (!initialized) {
+        // enforce the "0" suffix, so we'll open libgtk-x11-2.0.so.0
+        QLibrary libgtk(QLS("gtk-x11-2.0"), 0, 0);
+
+        QGtk2PainterPrivate::gdk_pixmap_new = (Ptr_gdk_pixmap_new)libgtk.resolve("gdk_pixmap_new");
+        QGtk2PainterPrivate::gdk_pixbuf_get_from_drawable = (Ptr_gdk_pixbuf_get_from_drawable)libgtk.resolve("gdk_pixbuf_get_from_drawable");
+        QGtk2PainterPrivate::gdk_draw_rectangle = (Ptr_gdk_draw_rectangle)libgtk.resolve("gdk_draw_rectangle");
+        QGtk2PainterPrivate::gdk_drawable_unref = (Ptr_gdk_drawable_unref)libgtk.resolve("gdk_drawable_unref");
+
+        QGtk2PainterPrivate::gtk_paint_check = (Ptr_gtk_paint_check)libgtk.resolve("gtk_paint_check");
+        QGtk2PainterPrivate::gtk_paint_box = (Ptr_gtk_paint_box)libgtk.resolve("gtk_paint_box");
+        QGtk2PainterPrivate::gtk_paint_flat_box = (Ptr_gtk_paint_flat_box)libgtk.resolve("gtk_paint_flat_box");
+        QGtk2PainterPrivate::gtk_paint_check = (Ptr_gtk_paint_check)libgtk.resolve("gtk_paint_check");
+        QGtk2PainterPrivate::gtk_paint_box = (Ptr_gtk_paint_box)libgtk.resolve("gtk_paint_box");
+        QGtk2PainterPrivate::gtk_paint_resize_grip = (Ptr_gtk_paint_resize_grip)libgtk.resolve("gtk_paint_resize_grip");
+        QGtk2PainterPrivate::gtk_paint_focus = (Ptr_gtk_paint_focus)libgtk.resolve("gtk_paint_focus");
+        QGtk2PainterPrivate::gtk_paint_shadow = (Ptr_gtk_paint_shadow)libgtk.resolve("gtk_paint_shadow");
+        QGtk2PainterPrivate::gtk_paint_slider = (Ptr_gtk_paint_slider)libgtk.resolve("gtk_paint_slider");
+        QGtk2PainterPrivate::gtk_paint_expander = (Ptr_gtk_paint_expander)libgtk.resolve("gtk_paint_expander");
+        QGtk2PainterPrivate::gtk_paint_handle = (Ptr_gtk_paint_handle)libgtk.resolve("gtk_paint_handle");
+        QGtk2PainterPrivate::gtk_paint_option = (Ptr_gtk_paint_option)libgtk.resolve("gtk_paint_option");
+        QGtk2PainterPrivate::gtk_paint_arrow = (Ptr_gtk_paint_arrow)libgtk.resolve("gtk_paint_arrow");
+        QGtk2PainterPrivate::gtk_paint_box_gap = (Ptr_gtk_paint_box_gap)libgtk.resolve("gtk_paint_box_gap");
+        QGtk2PainterPrivate::gtk_paint_extension = (Ptr_gtk_paint_extension)libgtk.resolve("gtk_paint_extension");
+        QGtk2PainterPrivate::gtk_paint_hline = (Ptr_gtk_paint_hline)libgtk.resolve("gtk_paint_hline");
+        QGtk2PainterPrivate::gtk_paint_vline = (Ptr_gtk_paint_vline)libgtk.resolve("gtk_paint_vline");
+
+        initialized = true;
+    }
+}
+
+// To recover alpha we apply the gtk painting function two times to
+// white, and black window backgrounds. This can be used to
+// recover the premultiplied alpha channel
+QPixmap QGtk2Painter::renderTheme(uchar *bdata, uchar *wdata, const QRect &rect) const
+{
+    const int bytecount = rect.width() * rect.height() * 4;
+    for (int index = 0; index < bytecount ; index += 4) {
+        uchar val = bdata[index + GTK_BLUE];
+        if (m_alpha) {
+            int alphaval = qMax(bdata[index + GTK_BLUE] - wdata[index + GTK_BLUE],
+                                bdata[index + GTK_GREEN] - wdata[index + GTK_GREEN]);
+            alphaval = qMax(alphaval, bdata[index + GTK_RED] - wdata[index + GTK_RED]) + 255;
+            bdata[index + QT_ALPHA] = alphaval;
+        }
+        bdata[index + QT_RED] = bdata[index + GTK_RED];
+        bdata[index + QT_GREEN] = bdata[index + GTK_GREEN];
+        bdata[index + QT_BLUE] = val;
+    }
+    QImage converted((const uchar*)bdata, rect.width(), rect.height(), m_alpha ?
+                     QImage::Format_ARGB32_Premultiplied : QImage::Format_RGB32);
+
+    if (m_hflipped || m_vflipped) {
+        return QPixmap::fromImage(converted.mirrored(m_hflipped, m_vflipped));
+    } else {
+        // on raster graphicssystem we need to do a copy here, because
+        // we intend to deallocate the qimage bits shortly after...
+        return QPixmap::fromImage(converted.copy());
+    }
+}
+
+// This macro is responsible for painting any GtkStyle painting function onto a QPixmap
+#define DRAW_TO_CACHE(draw_func)                                                                    \
+    if (rect.width() > QWIDGETSIZE_MAX || rect.height() > QWIDGETSIZE_MAX)                          \
+        return;                                                                                     \
+    QRect pixmapRect(0, 0, rect.width(), rect.height());                                            \
+    {                                                                                               \
+        GdkPixmap *pixmap = QGtk2PainterPrivate::gdk_pixmap_new((GdkDrawable*)(m_window->window),   \
+                                                                rect.width(), rect.height(), -1);   \
+        if (!pixmap)                                                                                \
+            return;                                                                                 \
+        style = QGtkStylePrivate::gtk_style_attach (style, m_window->window);                       \
+        QGtk2PainterPrivate::gdk_draw_rectangle(pixmap, m_alpha ? style->black_gc : *style->bg_gc,  \
+                                                true, 0, 0, rect.width(), rect.height());           \
+        draw_func;                                                                                  \
+        GdkPixbuf *imgb = QGtkStylePrivate::gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8,             \
+                                                           rect.width(), rect.height());            \
+        if (!imgb)                                                                                  \
+            return;                                                                                 \
+        imgb = QGtk2PainterPrivate::gdk_pixbuf_get_from_drawable(imgb, pixmap, NULL, 0, 0, 0, 0,    \
+                                                                 rect.width(), rect.height());      \
+        uchar* bdata = (uchar*)QGtkStylePrivate::gdk_pixbuf_get_pixels(imgb);                       \
+        if (m_alpha) {                                                                              \
+            QGtk2PainterPrivate::gdk_draw_rectangle(pixmap, style->white_gc, true, 0, 0,            \
+                                                    rect.width(), rect.height());                   \
+            draw_func;                                                                              \
+            GdkPixbuf *imgw = QGtkStylePrivate::gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8,         \
+                                                               rect.width(), rect.height());        \
+            if (!imgw)                                                                              \
+                return;                                                                             \
+            imgw = QGtk2PainterPrivate::gdk_pixbuf_get_from_drawable(imgw, pixmap, NULL, 0, 0, 0, 0,\
+                                                                     rect.width(), rect.height());  \
+            uchar* wdata = (uchar*)QGtkStylePrivate::gdk_pixbuf_get_pixels(imgw);                   \
+            cache = renderTheme(bdata, wdata, rect);                                                \
+            QGtkStylePrivate::gdk_pixbuf_unref(imgw);                                               \
+        } else {                                                                                    \
+            cache = renderTheme(bdata, 0, rect);                                                    \
+        }                                                                                           \
+        QGtk2PainterPrivate::gdk_drawable_unref(pixmap);                                            \
+        QGtkStylePrivate::gdk_pixbuf_unref(imgb);                                                   \
+    }
+
+QGtk2Painter::QGtk2Painter() : QGtkPainter(), m_window(QGtkStylePrivate::gtkWidget("GtkWindow"))
+{
+    initGtk();
+}
+
+// Note currently painted without alpha for performance reasons
+void QGtk2Painter::paintBoxGap(GtkWidget *gtkWidget, const gchar* part,
+                              const QRect &paintRect, GtkStateType state,
+                              GtkShadowType shadow, GtkPositionType gap_side,
+                              gint x, gint width,
+                              GtkStyle *style)
+{
+    if (!paintRect.isValid())
+        return;
+
+    QPixmap cache;
+    QRect rect = paintRect;
+
+    // To avoid exhausting cache on large tabframes we cheat a bit by
+    // tiling the center part.
+
+    const int maxHeight = 256;
+    const int border = 16;
+    if (rect.height() > maxHeight && (gap_side == GTK_POS_TOP || gap_side == GTK_POS_BOTTOM))
+        rect.setHeight(2 * border + 1);
+
+    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size(), gtkWidget)
+                         % HexString<uchar>(gap_side)
+                         % HexString<gint>(width)
+                         % HexString<gint>(x);
+
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_box_gap (style,
+                                           pixmap,
+                                           state,
+                                           shadow,
+                                           NULL,
+                                           gtkWidget,
+                                           (gchar*)part,
+                                           0, 0,
+                                           rect.width(),
+                                           rect.height(),
+                                           gap_side,
+                                           x,
+                                           width));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+    if (rect.size() != paintRect.size()) {
+        // We assume we can stretch the middle tab part
+        // Note: the side effect of this is that pinstripe patterns will get fuzzy
+        const QSize size = cache.size();
+        // top part
+        m_painter->drawPixmap(QRect(paintRect.left(), paintRect.top(),
+                                    paintRect.width(), border), cache,
+                             QRect(0, 0, size.width(), border));
+
+        // tiled center part
+        QPixmap tilePart(cache.width(), 1);
+        QPainter scanLinePainter(&tilePart);
+        scanLinePainter.drawPixmap(QRect(0, 0, tilePart.width(), tilePart.height()), cache, QRect(0, border, size.width(), 1));
+        scanLinePainter.end();
+        m_painter->drawTiledPixmap(QRect(paintRect.left(), paintRect.top() + border,
+                                         paintRect.width(), paintRect.height() - 2*border), tilePart);
+
+        // bottom part
+        m_painter->drawPixmap(QRect(paintRect.left(), paintRect.top() + paintRect.height() - border,
+                                    paintRect.width(), border), cache,
+                             QRect(0, size.height() - border, size.width(), border));
+    } else
+        m_painter->drawPixmap(paintRect.topLeft(), cache);
+}
+
+void QGtk2Painter::paintBox(GtkWidget *gtkWidget, const gchar* part,
+                           const QRect &paintRect, GtkStateType state,
+                           GtkShadowType shadow, GtkStyle *style,
+                           const QString &pmKey)
+{
+    if (!paintRect.isValid())
+        return;
+
+    QPixmap cache;
+    QRect rect = paintRect;
+
+    // To avoid exhausting cache on large tabframes we cheat a bit by
+    // tiling the center part.
+
+    const int maxHeight = 256;
+    const int maxArea = 256*512;
+    const int border = 32;
+    if (rect.height() > maxHeight && (rect.width()*rect.height() > maxArea))
+        rect.setHeight(2 * border + 1);
+
+    QString pixmapName = uniqueName(QLS(part), state, shadow,
+                                    rect.size(), gtkWidget) % pmKey;
+
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_box (style,
+                                           pixmap,
+                                           state,
+                                           shadow,
+                                           NULL,
+                                           gtkWidget,
+                                           part,
+                                           0, 0,
+                                           rect.width(),
+                                           rect.height()));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+    if (rect.size() != paintRect.size()) {
+        // We assume we can stretch the middle tab part
+        // Note: the side effect of this is that pinstripe patterns will get fuzzy
+        const QSize size = cache.size();
+        // top part
+        m_painter->drawPixmap(QRect(paintRect.left(), paintRect.top(),
+                                    paintRect.width(), border), cache,
+                              QRect(0, 0, size.width(), border));
+
+        // tiled center part
+        QPixmap tilePart(cache.width(), 1);
+        QPainter scanLinePainter(&tilePart);
+        scanLinePainter.drawPixmap(QRect(0, 0, tilePart.width(), tilePart.height()), cache, QRect(0, border, size.width(), 1));
+        scanLinePainter.end();
+        m_painter->drawTiledPixmap(QRect(paintRect.left(), paintRect.top() + border,
+                                         paintRect.width(), paintRect.height() - 2*border), tilePart);
+
+        // bottom part
+        m_painter->drawPixmap(QRect(paintRect.left(), paintRect.top() + paintRect.height() - border,
+                                    paintRect.width(), border), cache,
+                              QRect(0, size.height() - border, size.width(), border));
+    } else
+        m_painter->drawPixmap(paintRect.topLeft(), cache);
+}
+
+void QGtk2Painter::paintHline(GtkWidget *gtkWidget, const gchar* part,
+                             const QRect &rect, GtkStateType state,
+                             GtkStyle *style, int x1, int x2, int y,
+                             const QString &pmKey)
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, GTK_SHADOW_NONE, rect.size(), gtkWidget)
+                         % HexString<int>(x1)
+                         % HexString<int>(x2)
+                         % HexString<int>(y)
+                         % pmKey;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_hline (style,
+                                         pixmap,
+                                         state,
+                                         NULL,
+                                         gtkWidget,
+                                         part,
+                                         x1, x2, y));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+void QGtk2Painter::paintVline(GtkWidget *gtkWidget, const gchar* part,
+                             const QRect &rect, GtkStateType state,
+                             GtkStyle *style, int y1, int y2, int x,
+                             const QString &pmKey)
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, GTK_SHADOW_NONE, rect.size(), gtkWidget)
+                        % HexString<int>(y1)
+                        % HexString<int>(y2)
+                        % HexString<int>(x)
+                        % pmKey;
+
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_vline (style,
+                                         pixmap,
+                                         state,
+                                         NULL,
+                                         gtkWidget,
+                                         part,
+                                         y1, y2,
+                                         x));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+
+void QGtk2Painter::paintExpander(GtkWidget *gtkWidget,
+                                const gchar* part, const QRect &rect,
+                                GtkStateType state, GtkExpanderStyle expander_state,
+                                GtkStyle *style, const QString &pmKey)
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, GTK_SHADOW_NONE, rect.size(), gtkWidget)
+                         % HexString<uchar>(expander_state)
+                         % pmKey;
+
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_expander (style, pixmap,
+                                            state, NULL,
+                                            gtkWidget, part,
+                                            rect.width()/2,
+                                            rect.height()/2,
+                                            expander_state));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+void QGtk2Painter::paintFocus(GtkWidget *gtkWidget, const gchar* part,
+                             const QRect &rect, GtkStateType state,
+                             GtkStyle *style, const QString &pmKey)
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, GTK_SHADOW_NONE, rect.size(), gtkWidget) % pmKey;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_focus (style, pixmap, state, NULL,
+                                         gtkWidget,
+                                         part,
+                                         0, 0,
+                                         rect.width(),
+                                         rect.height()));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+
+void QGtk2Painter::paintResizeGrip(GtkWidget *gtkWidget, const gchar* part,
+                                  const QRect &rect, GtkStateType state,
+                                  GtkShadowType shadow, GdkWindowEdge edge,
+                                  GtkStyle *style, const QString &pmKey)
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size(), gtkWidget) % pmKey;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_resize_grip (style, pixmap, state,
+                                               NULL, gtkWidget,
+                                               part, edge, 0, 0,
+                                               rect.width(),
+                                               rect.height()));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+
+void QGtk2Painter::paintArrow(GtkWidget *gtkWidget, const gchar* part,
+                             const QRect &arrowrect, GtkArrowType arrow_type,
+                             GtkStateType state, GtkShadowType shadow,
+                             gboolean fill, GtkStyle *style, const QString &pmKey)
+{
+    QRect rect = m_cliprect.isValid() ? m_cliprect : arrowrect;
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size())
+                         % HexString<uchar>(arrow_type)
+                         % pmKey;
+
+    GdkRectangle gtkCliprect = {0, 0, rect.width(), rect.height()};
+    int xOffset = m_cliprect.isValid() ? arrowrect.x() - m_cliprect.x() : 0;
+    int yOffset = m_cliprect.isValid() ? arrowrect.y() - m_cliprect.y() : 0;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_arrow (style, pixmap, state, shadow,
+                                         &gtkCliprect,
+                                         gtkWidget,
+                                         part,
+                                         arrow_type, fill,
+                                         xOffset, yOffset,
+                                         arrowrect.width(),
+                                         arrowrect.height()))
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+
+void QGtk2Painter::paintHandle(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
+                              GtkStateType state, GtkShadowType shadow,
+                              GtkOrientation orientation, GtkStyle *style)
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size())
+                         % HexString<uchar>(orientation);
+
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_handle (style,
+                                          pixmap,
+                                          state,
+                                          shadow,
+                                          NULL,
+                                          gtkWidget,
+                                          part, 0, 0,
+                                          rect.width(),
+                                          rect.height(),
+                                          orientation));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+
+void QGtk2Painter::paintSlider(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
+                              GtkStateType state, GtkShadowType shadow,
+                              GtkStyle *style, GtkOrientation orientation,
+                              const QString &pmKey)
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size(), gtkWidget) % pmKey;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_slider (style,
+                                          pixmap,
+                                          state,
+                                          shadow,
+                                          NULL,
+                                          gtkWidget,
+                                          part,
+                                          0, 0,
+                                          rect.width(),
+                                          rect.height(),
+                                          orientation));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+
+void QGtk2Painter::paintShadow(GtkWidget *gtkWidget, const gchar* part,
+                              const QRect &rect, GtkStateType state,
+                              GtkShadowType shadow, GtkStyle *style,
+                              const QString &pmKey)
+
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size()) % pmKey;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_shadow(style, pixmap, state, shadow, NULL,
+                                         gtkWidget, part, 0, 0, rect.width(), rect.height()));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+void QGtk2Painter::paintFlatBox(GtkWidget *gtkWidget, const gchar* part,
+                               const QRect &rect, GtkStateType state,
+                               GtkShadowType shadow, GtkStyle *style,
+                               const QString &pmKey)
+{
+    if (!rect.isValid())
+        return;
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size()) % pmKey;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_flat_box (style,
+                                            pixmap,
+                                            state,
+                                            shadow,
+                                            NULL,
+                                            gtkWidget,
+                                            part, 0, 0,
+                                            rect.width(),
+                                            rect.height()));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+void QGtk2Painter::paintExtention(GtkWidget *gtkWidget,
+                                 const gchar *part, const QRect &rect,
+                                 GtkStateType state, GtkShadowType shadow,
+                                 GtkPositionType gap_pos, GtkStyle *style)
+{
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size(), gtkWidget)
+                         % HexString<uchar>(gap_pos);
+
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_extension (style, pixmap, state, shadow,
+                                             NULL, gtkWidget,
+                                             (gchar*)part, 0, 0,
+                                             rect.width(),
+                                             rect.height(),
+                                             gap_pos));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+void QGtk2Painter::paintOption(GtkWidget *gtkWidget, const QRect &radiorect,
+                              GtkStateType state, GtkShadowType shadow,
+                              GtkStyle *style, const QString &detail)
+
+{
+    QRect rect = m_cliprect.isValid() ? m_cliprect : radiorect;
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(detail, state, shadow, rect.size());
+    GdkRectangle gtkCliprect = {0, 0, rect.width(), rect.height()};
+    int xOffset = m_cliprect.isValid() ? radiorect.x() - m_cliprect.x() : 0;
+    int yOffset = m_cliprect.isValid() ? radiorect.y() - m_cliprect.y() : 0;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_option(style, pixmap,
+                                         state, shadow,
+                                         &gtkCliprect,
+                                         gtkWidget,
+                                         detail.toLatin1(),
+                                         xOffset, yOffset,
+                                         radiorect.width(),
+                                         radiorect.height()));
+
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+void QGtk2Painter::paintCheckbox(GtkWidget *gtkWidget, const QRect &checkrect,
+                                GtkStateType state, GtkShadowType shadow,
+                                GtkStyle *style, const QString &detail)
+
+{
+    QRect rect = m_cliprect.isValid() ? m_cliprect : checkrect;
+    if (!rect.isValid())
+        return;
+
+    QPixmap cache;
+    QString pixmapName = uniqueName(detail, state, shadow, rect.size());
+    GdkRectangle gtkCliprect = {0, 0, rect.width(), rect.height()};
+    int xOffset = m_cliprect.isValid() ? checkrect.x() - m_cliprect.x() : 0;
+    int yOffset = m_cliprect.isValid() ? checkrect.y() - m_cliprect.y() : 0;
+    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+        DRAW_TO_CACHE(QGtk2PainterPrivate::gtk_paint_check (style,
+                                         pixmap,
+                                         state,
+                                         shadow,
+                                         &gtkCliprect,
+                                         gtkWidget,
+                                         detail.toLatin1(),
+                                         xOffset, yOffset,
+                                         checkrect.width(),
+                                         checkrect.height()));
+        if (m_usePixmapCache)
+            QPixmapCache::insert(pixmapName, cache);
+    }
+
+    m_painter->drawPixmap(rect.topLeft(), cache);
+}
+
+QT_END_NAMESPACE
+
+#endif //!defined(QT_NO_STYLE_GTK)
diff --git a/src/widgets/styles/qgtk2painter_p.h b/src/widgets/styles/qgtk2painter_p.h
new file mode 100644
index 0000000..cbb49bf
--- /dev/null
+++ b/src/widgets/styles/qgtk2painter_p.h
@@ -0,0 +1,108 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGTK2PAINTER_P_H
+#define QGTK2PAINTER_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qglobal.h>
+#if !defined(QT_NO_STYLE_GTK)
+
+#include <private/qgtkpainter_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QGtk2Painter : public QGtkPainter
+{
+public:
+    QGtk2Painter();
+
+    void paintBoxGap(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
+                     GtkStateType state, GtkShadowType shadow, GtkPositionType gap_side, gint x,
+                     gint width, GtkStyle *style);
+    void paintBox(GtkWidget *gtkWidget, const gchar* part,
+                  const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style,
+                  const QString &pmKey = QString());
+    void paintHline(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
+                    int x1, int x2, int y, const QString &pmKey = QString());
+    void paintVline(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
+                    int y1, int y2, int x, const QString &pmKey = QString());
+    void paintExpander(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state,
+                       GtkExpanderStyle expander_state, GtkStyle *style, const QString &pmKey = QString());
+    void paintFocus(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
+                    const QString &pmKey = QString());
+    void paintResizeGrip(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
+                         GdkWindowEdge edge, GtkStyle *style, const QString &pmKey = QString());
+    void paintArrow(GtkWidget *gtkWidget, const gchar* part, const QRect &arrowrect, GtkArrowType arrow_type, GtkStateType state, GtkShadowType shadow,
+                    gboolean fill, GtkStyle *style, const QString &pmKey = QString());
+    void paintHandle(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
+                     GtkStateType state, GtkShadowType shadow, GtkOrientation orientation, GtkStyle *style);
+    void paintSlider(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
+                     GtkStyle *style, GtkOrientation orientation, const QString &pmKey = QString());
+    void paintShadow(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
+                     GtkStyle *style, const QString &pmKey = QString());
+    void paintFlatBox(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString & = QString());
+    void paintExtention(GtkWidget *gtkWidget, const gchar *part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
+                        GtkPositionType gap_pos, GtkStyle *style);
+    void paintOption(GtkWidget *gtkWidget, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString &detail);
+    void paintCheckbox(GtkWidget *gtkWidget, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString &detail);
+
+private:
+    QPixmap renderTheme(uchar *bdata, uchar *wdata, const QRect &rect) const;
+
+    GtkWidget *m_window;
+};
+
+QT_END_NAMESPACE
+
+#endif //!defined(QT_NO_STYLE_QGTK)
+
+#endif // QGTK2PAINTER_P_H
diff --git a/src/widgets/styles/qgtkglobal_p.h b/src/widgets/styles/qgtkglobal_p.h
new file mode 100644
index 0000000..6f693ec
--- /dev/null
+++ b/src/widgets/styles/qgtkglobal_p.h
@@ -0,0 +1,90 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGTKGLOBAL_P_H
+#define QGTKGLOBAL_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qglobal.h>
+#if !defined(QT_NO_STYLE_GTK)
+
+#undef signals // Collides with GTK symbols
+#include <gtk/gtk.h>
+
+typedef unsigned long XID;
+
+#undef GTK_OBJECT_FLAGS
+#define GTK_OBJECT_FLAGS(obj)(((GtkObject*)(obj))->flags)
+
+#define QLS(x) QLatin1String(x)
+
+QT_BEGIN_NAMESPACE
+
+#if Q_BYTE_ORDER == Q_BIG_ENDIAN
+#   define QT_RED 3
+#   define QT_GREEN 2
+#   define QT_BLUE 1
+#   define QT_ALPHA 0
+#else
+#   define QT_RED 0
+#   define QT_GREEN 1
+#   define QT_BLUE 2
+#   define QT_ALPHA 3
+#endif
+#   define GTK_RED 2
+#   define GTK_GREEN 1
+#   define GTK_BLUE 0
+#   define GTK_ALPHA 3
+
+QT_END_NAMESPACE
+
+#endif // !QT_NO_STYLE_GTK
+#endif // QGTKGLOBAL_P_H
diff --git a/src/widgets/styles/qgtkpainter.cpp b/src/widgets/styles/qgtkpainter.cpp
index 3d12323..a5c408f 100644
--- a/src/widgets/styles/qgtkpainter.cpp
+++ b/src/widgets/styles/qgtkpainter.cpp
@@ -41,119 +41,32 @@
 
 #include "qgtkpainter_p.h"
 
-#include <QtCore/qglobal.h>
 #if !defined(QT_NO_STYLE_GTK)
 
-// This class is primarily a wrapper around the gtk painter functions
-// and takes care of converting all such calls into cached Qt pixmaps.
-
-#include <private/qstylehelper_p.h>
-#include <QtWidgets/QWidget>
-#include <QtWidgets/QStyleOption>
-#include <QtGui/QPixmapCache>
+#include <private/qhexstring_p.h>
 
 QT_BEGIN_NAMESPACE
 
-#undef GTK_OBJECT_FLAGS
-#define GTK_OBJECT_FLAGS(obj)(((GtkObject*)(obj))->flags)
-
-#if Q_BYTE_ORDER == Q_BIG_ENDIAN
-#   define QT_RED 3
-#   define QT_GREEN 2
-#   define QT_BLUE 1
-#   define QT_ALPHA 0
-#else
-#   define QT_RED 0
-#   define QT_GREEN 1
-#   define QT_BLUE 2
-#   define QT_ALPHA 3
-#endif
-#   define GTK_RED 2
-#   define GTK_GREEN 1
-#   define GTK_BLUE 0
-#   define GTK_ALPHA 3
-
-// To recover alpha we apply the gtk painting function two times to
-// white, and black window backgrounds. This can be used to
-// recover the premultiplied alpha channel
-QPixmap QGtkPainter::renderTheme(uchar *bdata, uchar *wdata, const QRect &rect)
+QGtkPainter::QGtkPainter()
 {
-    const int bytecount = rect.width() * rect.height() * 4;
-    for (int index = 0; index < bytecount ; index += 4) {
-        uchar val = bdata[index + GTK_BLUE];
-        if (m_alpha) {
-            int alphaval = qMax(bdata[index + GTK_BLUE] - wdata[index + GTK_BLUE],
-                                bdata[index + GTK_GREEN] - wdata[index + GTK_GREEN]);
-            alphaval = qMax(alphaval, bdata[index + GTK_RED] - wdata[index + GTK_RED]) + 255;
-            bdata[index + QT_ALPHA] = alphaval;
-        }
-        bdata[index + QT_RED] = bdata[index + GTK_RED];
-        bdata[index + QT_GREEN] = bdata[index + GTK_GREEN];
-        bdata[index + QT_BLUE] = val;
-    }
-    QImage converted((const uchar*)bdata, rect.width(), rect.height(), m_alpha ?
-                     QImage::Format_ARGB32_Premultiplied : QImage::Format_RGB32);
-
-    if (m_hflipped || m_vflipped) {
-        return QPixmap::fromImage(converted.mirrored(m_hflipped, m_vflipped));
-    } else {
-        // on raster graphicssystem we need to do a copy here, because
-        // we intend to deallocate the qimage bits shortly after...
-        return QPixmap::fromImage(converted.copy());
-    }
+    reset(0);
 }
 
-// This macro is responsible for painting any GtkStyle painting function onto a QPixmap
-#define DRAW_TO_CACHE(draw_func)                                                                   \
-    if (rect.width() > QWIDGETSIZE_MAX || rect.height() > QWIDGETSIZE_MAX)                         \
-        return;                                                                                    \
-    QRect pixmapRect(0, 0, rect.width(), rect.height());                                           \
-    {                                                                                              \
-        GdkPixmap *pixmap = QGtkStylePrivate::gdk_pixmap_new((GdkDrawable*)(m_window->window),                    \
-                                            rect.width(), rect.height(), -1);                      \
-        if (!pixmap)                                                                               \
-            return;                                                                                \
-        style = QGtkStylePrivate::gtk_style_attach (style, m_window->window);                                  \
-        QGtkStylePrivate::gdk_draw_rectangle(pixmap, m_alpha ? style->black_gc : *style->bg_gc, true,                \
-                           0, 0, rect.width(), rect.height());                                     \
-        draw_func;                                                                                 \
-        GdkPixbuf *imgb = QGtkStylePrivate::gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, rect.width(), rect.height());\
-        if (!imgb)                                                                                 \
-            return;                                                                                \
-        imgb = QGtkStylePrivate::gdk_pixbuf_get_from_drawable(imgb, pixmap, NULL, 0, 0, 0, 0,                  \
-                                            rect.width(), rect.height());                          \
-        uchar* bdata = (uchar*)QGtkStylePrivate::gdk_pixbuf_get_pixels(imgb);                                  \
-        if (m_alpha) {                                                                             \
-            QGtkStylePrivate::gdk_draw_rectangle(pixmap, style->white_gc, true, 0, 0, rect.width(), rect.height());  \
-            draw_func;                                                                             \
-            GdkPixbuf *imgw = QGtkStylePrivate::gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, rect.              \
-                                             width(), rect.height());                              \
-            if (!imgw)                                                                             \
-                return;                                                                            \
-            imgw = QGtkStylePrivate::gdk_pixbuf_get_from_drawable(imgw, pixmap, NULL, 0, 0, 0, 0,              \
-                                                rect.width(), rect.height());                      \
-            uchar* wdata = (uchar*)QGtkStylePrivate::gdk_pixbuf_get_pixels(imgw);                                    \
-            cache = renderTheme(bdata, wdata, rect);                                               \
-            QGtkStylePrivate::gdk_pixbuf_unref(imgw);                                                          \
-        } else {                                                                                   \
-            cache = renderTheme(bdata, 0, rect);                                                   \
-        }                                                                                          \
-        QGtkStylePrivate::gdk_drawable_unref(pixmap);                                                          \
-        QGtkStylePrivate::gdk_pixbuf_unref(imgb);                                                              \
-    }
-
-QGtkPainter::QGtkPainter(QPainter *_painter)
-        : m_window(QGtkStylePrivate::gtkWidget("GtkWindow"))
-        , m_painter(_painter)
-        , m_alpha(true)
-        , m_hflipped(false)
-        , m_vflipped(false)
-        , m_usePixmapCache(true)
-{}
+QGtkPainter::~QGtkPainter()
+{
+}
 
+void QGtkPainter::reset(QPainter *painter)
+{
+    m_painter = painter;
+    m_alpha = true;
+    m_hflipped = false;
+    m_vflipped = false;
+    m_usePixmapCache = true;
+}
 
-static QString uniqueName(const QString &key, GtkStateType state, GtkShadowType shadow,
-                          const QSize &size, GtkWidget *widget = 0)
+QString QGtkPainter::uniqueName(const QString &key, GtkStateType state, GtkShadowType shadow,
+                                const QSize &size, GtkWidget *widget)
 {
     // Note the widget arg should ideally use the widget path, though would compromise performance
     QString tmp = key
@@ -165,552 +78,6 @@ static QString uniqueName(const QString &key, GtkStateType state, GtkShadowType
     return tmp;
 }
 
-
-GtkStateType QGtkPainter::gtkState(const QStyleOption *option)
-
-{
-    GtkStateType state = GTK_STATE_NORMAL;
-    if (!(option->state & QStyle::State_Enabled))
-        state = GTK_STATE_INSENSITIVE;
-    else if (option->state & QStyle::State_MouseOver)
-        state = GTK_STATE_PRELIGHT;
-
-    return state;
-}
-
-
-GtkStyle* QGtkPainter::getStyle(GtkWidget *gtkWidget)
-
-{
-    Q_ASSERT(gtkWidget);
-    GtkStyle* style = QGtkStylePrivate::gtk_widget_get_style(gtkWidget);
-    Q_ASSERT(style);
-    return style;
-}
-
-QPixmap QGtkPainter::getIcon(const char* iconName, GtkIconSize size)
-{
-    GtkStyle *style = QGtkStylePrivate::gtkStyle();
-    GtkIconSet* iconSet  = QGtkStylePrivate::gtk_icon_factory_lookup_default (iconName);
-    GdkPixbuf* icon = QGtkStylePrivate::gtk_icon_set_render_icon(iconSet,
-                                                 style,
-                                                 GTK_TEXT_DIR_LTR,
-                                                 GTK_STATE_NORMAL,
-                                                 size,
-                                                 NULL,
-                                                 "button");
-    uchar* data = (uchar*)QGtkStylePrivate::gdk_pixbuf_get_pixels(icon);
-    int width = QGtkStylePrivate::gdk_pixbuf_get_width(icon);
-    int height = QGtkStylePrivate::gdk_pixbuf_get_height(icon);
-    QImage converted(width, height, QImage::Format_ARGB32);
-    uchar* tdata = (uchar*)converted.bits();
-
-    for ( int index = 0 ; index < height * width*4 ; index +=4 ) {
-        //int index = y * rowstride + x;
-        tdata[index + QT_RED] = data[index + GTK_RED];
-        tdata[index + QT_GREEN] = data[index + GTK_GREEN];
-        tdata[index + QT_BLUE] = data[index + GTK_BLUE];
-        tdata[index + QT_ALPHA] = data[index + GTK_ALPHA];
-    }
-
-    QGtkStylePrivate::gdk_pixbuf_unref(icon);
-
-    // should we free iconset?
-    return QPixmap::fromImage(converted);
-
-}
-
-// Note currently painted without alpha for performance reasons
-void QGtkPainter::paintBoxGap(GtkWidget *gtkWidget, const gchar* part,
-                              const QRect &paintRect, GtkStateType state,
-                              GtkShadowType shadow, GtkPositionType gap_side,
-                              gint x, gint width,
-                              GtkStyle *style)
-{
-    if (!paintRect.isValid())
-        return;
-
-    QPixmap cache;
-    QRect rect = paintRect;
-
-    // To avoid exhausting cache on large tabframes we cheat a bit by
-    // tiling the center part.
-
-    const int maxHeight = 256;
-    const int border = 16;
-    if (rect.height() > maxHeight && (gap_side == GTK_POS_TOP || gap_side == GTK_POS_BOTTOM))
-        rect.setHeight(2 * border + 1);
-
-    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size(), gtkWidget)
-                         % HexString<uchar>(gap_side)
-                         % HexString<gint>(width)
-                         % HexString<gint>(x);
-
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_box_gap (style,
-                                           pixmap,
-                                           state,
-                                           shadow,
-                                           NULL,
-                                           gtkWidget,
-                                           (gchar*)part,
-                                           0, 0,
-                                           rect.width(),
-                                           rect.height(),
-                                           gap_side,
-                                           x,
-                                           width));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-    if (rect.size() != paintRect.size()) {
-        // We assume we can stretch the middle tab part
-        // Note: the side effect of this is that pinstripe patterns will get fuzzy
-        const QSize size = cache.size();
-        // top part
-        m_painter->drawPixmap(QRect(paintRect.left(), paintRect.top(),
-                                    paintRect.width(), border), cache,
-                             QRect(0, 0, size.width(), border));
-
-        // tiled center part
-        QPixmap tilePart(cache.width(), 1);
-        QPainter scanLinePainter(&tilePart);
-        scanLinePainter.drawPixmap(QRect(0, 0, tilePart.width(), tilePart.height()), cache, QRect(0, border, size.width(), 1));
-        scanLinePainter.end();
-        m_painter->drawTiledPixmap(QRect(paintRect.left(), paintRect.top() + border,
-                                         paintRect.width(), paintRect.height() - 2*border), tilePart);
-
-        // bottom part
-        m_painter->drawPixmap(QRect(paintRect.left(), paintRect.top() + paintRect.height() - border,
-                                    paintRect.width(), border), cache,
-                             QRect(0, size.height() - border, size.width(), border));
-    } else
-        m_painter->drawPixmap(paintRect.topLeft(), cache);
-}
-
-void QGtkPainter::paintBox(GtkWidget *gtkWidget, const gchar* part,
-                           const QRect &paintRect, GtkStateType state,
-                           GtkShadowType shadow, GtkStyle *style,
-                           const QString &pmKey)
-{
-    if (!paintRect.isValid())
-        return;
-
-    QPixmap cache;
-    QRect rect = paintRect;
-
-    // To avoid exhausting cache on large tabframes we cheat a bit by
-    // tiling the center part.
-
-    const int maxHeight = 256;
-    const int maxArea = 256*512;
-    const int border = 32;
-    if (rect.height() > maxHeight && (rect.width()*rect.height() > maxArea))
-        rect.setHeight(2 * border + 1);
-
-    QString pixmapName = uniqueName(QLS(part), state, shadow,
-                                    rect.size(), gtkWidget) % pmKey;
-
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_box (style,
-                                           pixmap,
-                                           state,
-                                           shadow,
-                                           NULL,
-                                           gtkWidget,
-                                           part,
-                                           0, 0,
-                                           rect.width(),
-                                           rect.height()));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-    if (rect.size() != paintRect.size()) {
-        // We assume we can stretch the middle tab part
-        // Note: the side effect of this is that pinstripe patterns will get fuzzy
-        const QSize size = cache.size();
-        // top part
-        m_painter->drawPixmap(QRect(paintRect.left(), paintRect.top(),
-                                    paintRect.width(), border), cache,
-                              QRect(0, 0, size.width(), border));
-
-        // tiled center part
-        QPixmap tilePart(cache.width(), 1);
-        QPainter scanLinePainter(&tilePart);
-        scanLinePainter.drawPixmap(QRect(0, 0, tilePart.width(), tilePart.height()), cache, QRect(0, border, size.width(), 1));
-        scanLinePainter.end();
-        m_painter->drawTiledPixmap(QRect(paintRect.left(), paintRect.top() + border,
-                                         paintRect.width(), paintRect.height() - 2*border), tilePart);
-
-        // bottom part
-        m_painter->drawPixmap(QRect(paintRect.left(), paintRect.top() + paintRect.height() - border,
-                                    paintRect.width(), border), cache,
-                              QRect(0, size.height() - border, size.width(), border));
-    } else
-        m_painter->drawPixmap(paintRect.topLeft(), cache);
-}
-
-void QGtkPainter::paintHline(GtkWidget *gtkWidget, const gchar* part,
-                             const QRect &rect, GtkStateType state,
-                             GtkStyle *style, int x1, int x2, int y,
-                             const QString &pmKey)
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, GTK_SHADOW_NONE, rect.size(), gtkWidget)
-                         % HexString<int>(x1)
-                         % HexString<int>(x2)
-                         % HexString<int>(y)
-                         % pmKey;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_hline (style,
-                                         pixmap,
-                                         state,
-                                         NULL,
-                                         gtkWidget,
-                                         part,
-                                         x1, x2, y));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-void QGtkPainter::paintVline(GtkWidget *gtkWidget, const gchar* part,
-                             const QRect &rect, GtkStateType state,
-                             GtkStyle *style, int y1, int y2, int x,
-                             const QString &pmKey)
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, GTK_SHADOW_NONE, rect.size(), gtkWidget)
-                        % HexString<int>(y1)
-                        % HexString<int>(y2)
-                        % HexString<int>(x)
-                        % pmKey;
-
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_vline (style,
-                                         pixmap,
-                                         state,
-                                         NULL,
-                                         gtkWidget,
-                                         part,
-                                         y1, y2,
-                                         x));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-
-void QGtkPainter::paintExpander(GtkWidget *gtkWidget,
-                                const gchar* part, const QRect &rect,
-                                GtkStateType state, GtkExpanderStyle expander_state,
-                                GtkStyle *style, const QString &pmKey)
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, GTK_SHADOW_NONE, rect.size(), gtkWidget)
-                         % HexString<uchar>(expander_state)
-                         % pmKey;
-
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_expander (style, pixmap,
-                                            state, NULL,
-                                            gtkWidget, part,
-                                            rect.width()/2,
-                                            rect.height()/2,
-                                            expander_state));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-void QGtkPainter::paintFocus(GtkWidget *gtkWidget, const gchar* part,
-                             const QRect &rect, GtkStateType state,
-                             GtkStyle *style, const QString &pmKey)
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, GTK_SHADOW_NONE, rect.size(), gtkWidget) % pmKey;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_focus (style, pixmap, state, NULL,
-                                         gtkWidget,
-                                         part,
-                                         0, 0,
-                                         rect.width(),
-                                         rect.height()));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-
-void QGtkPainter::paintResizeGrip(GtkWidget *gtkWidget, const gchar* part,
-                                  const QRect &rect, GtkStateType state,
-                                  GtkShadowType shadow, GdkWindowEdge edge,
-                                  GtkStyle *style, const QString &pmKey)
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size(), gtkWidget) % pmKey;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_resize_grip (style, pixmap, state,
-                                               NULL, gtkWidget,
-                                               part, edge, 0, 0,
-                                               rect.width(),
-                                               rect.height()));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-
-void QGtkPainter::paintArrow(GtkWidget *gtkWidget, const gchar* part,
-                             const QRect &arrowrect, GtkArrowType arrow_type,
-                             GtkStateType state, GtkShadowType shadow,
-                             gboolean fill, GtkStyle *style, const QString &pmKey)
-{
-    QRect rect = m_cliprect.isValid() ? m_cliprect : arrowrect;
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size())
-                         % HexString<uchar>(arrow_type)
-                         % pmKey;
-
-    GdkRectangle gtkCliprect = {0, 0, rect.width(), rect.height()};
-    int xOffset = m_cliprect.isValid() ? arrowrect.x() - m_cliprect.x() : 0;
-    int yOffset = m_cliprect.isValid() ? arrowrect.y() - m_cliprect.y() : 0;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_arrow (style, pixmap, state, shadow,
-                                         &gtkCliprect,
-                                         gtkWidget,
-                                         part,
-                                         arrow_type, fill,
-                                         xOffset, yOffset,
-                                         arrowrect.width(),
-                                         arrowrect.height()))
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-
-void QGtkPainter::paintHandle(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
-                              GtkStateType state, GtkShadowType shadow,
-                              GtkOrientation orientation, GtkStyle *style)
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size())
-                         % HexString<uchar>(orientation);
-
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_handle (style,
-                                          pixmap,
-                                          state,
-                                          shadow,
-                                          NULL,
-                                          gtkWidget,
-                                          part, 0, 0,
-                                          rect.width(),
-                                          rect.height(),
-                                          orientation));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-
-void QGtkPainter::paintSlider(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
-                              GtkStateType state, GtkShadowType shadow,
-                              GtkStyle *style, GtkOrientation orientation,
-                              const QString &pmKey)
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size(), gtkWidget) % pmKey;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_slider (style,
-                                          pixmap,
-                                          state,
-                                          shadow,
-                                          NULL,
-                                          gtkWidget,
-                                          part,
-                                          0, 0,
-                                          rect.width(),
-                                          rect.height(),
-                                          orientation));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-
-void QGtkPainter::paintShadow(GtkWidget *gtkWidget, const gchar* part,
-                              const QRect &rect, GtkStateType state,
-                              GtkShadowType shadow, GtkStyle *style,
-                              const QString &pmKey)
-
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size()) % pmKey;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_shadow(style, pixmap, state, shadow, NULL,
-                                         gtkWidget, part, 0, 0, rect.width(), rect.height()));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-void QGtkPainter::paintFlatBox(GtkWidget *gtkWidget, const gchar* part,
-                               const QRect &rect, GtkStateType state,
-                               GtkShadowType shadow, GtkStyle *style,
-                               const QString &pmKey)
-{
-    if (!rect.isValid())
-        return;
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size()) % pmKey;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_flat_box (style,
-                                            pixmap,
-                                            state,
-                                            shadow,
-                                            NULL,
-                                            gtkWidget,
-                                            part, 0, 0,
-                                            rect.width(),
-                                            rect.height()));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-void QGtkPainter::paintExtention(GtkWidget *gtkWidget,
-                                 const gchar *part, const QRect &rect,
-                                 GtkStateType state, GtkShadowType shadow,
-                                 GtkPositionType gap_pos, GtkStyle *style)
-{
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(QLS(part), state, shadow, rect.size(), gtkWidget)
-                         % HexString<uchar>(gap_pos);
-
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_extension (style, pixmap, state, shadow,
-                                             NULL, gtkWidget,
-                                             (gchar*)part, 0, 0,
-                                             rect.width(),
-                                             rect.height(),
-                                             gap_pos));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-void QGtkPainter::paintOption(GtkWidget *gtkWidget, const QRect &radiorect,
-                              GtkStateType state, GtkShadowType shadow,
-                              GtkStyle *style, const QString &detail)
-
-{
-    QRect rect = m_cliprect.isValid() ? m_cliprect : radiorect;
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(detail, state, shadow, rect.size());
-    GdkRectangle gtkCliprect = {0, 0, rect.width(), rect.height()};
-    int xOffset = m_cliprect.isValid() ? radiorect.x() - m_cliprect.x() : 0;
-    int yOffset = m_cliprect.isValid() ? radiorect.y() - m_cliprect.y() : 0;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_option(style, pixmap,
-                                         state, shadow,
-                                         &gtkCliprect,
-                                         gtkWidget,
-                                         detail.toLatin1(),
-                                         xOffset, yOffset,
-                                         radiorect.width(),
-                                         radiorect.height()));
-
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
-void QGtkPainter::paintCheckbox(GtkWidget *gtkWidget, const QRect &checkrect,
-                                GtkStateType state, GtkShadowType shadow,
-                                GtkStyle *style, const QString &detail)
-
-{
-    QRect rect = m_cliprect.isValid() ? m_cliprect : checkrect;
-    if (!rect.isValid())
-        return;
-
-    QPixmap cache;
-    QString pixmapName = uniqueName(detail, state, shadow, rect.size());
-    GdkRectangle gtkCliprect = {0, 0, rect.width(), rect.height()};
-    int xOffset = m_cliprect.isValid() ? checkrect.x() - m_cliprect.x() : 0;
-    int yOffset = m_cliprect.isValid() ? checkrect.y() - m_cliprect.y() : 0;
-    if (!m_usePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
-        DRAW_TO_CACHE(QGtkStylePrivate::gtk_paint_check (style,
-                                         pixmap,
-                                         state,
-                                         shadow,
-                                         &gtkCliprect,
-                                         gtkWidget,
-                                         detail.toLatin1(),
-                                         xOffset, yOffset,
-                                         checkrect.width(),
-                                         checkrect.height()));
-        if (m_usePixmapCache)
-            QPixmapCache::insert(pixmapName, cache);
-    }
-
-    m_painter->drawPixmap(rect.topLeft(), cache);
-}
-
 QT_END_NAMESPACE
 
 #endif //!defined(QT_NO_STYLE_GTK)
diff --git a/src/widgets/styles/qgtkpainter_p.h b/src/widgets/styles/qgtkpainter_p.h
index 90b8dd2..8dc9391 100644
--- a/src/widgets/styles/qgtkpainter_p.h
+++ b/src/widgets/styles/qgtkpainter_p.h
@@ -56,20 +56,22 @@
 #include <QtCore/qglobal.h>
 #if !defined(QT_NO_STYLE_GTK)
 
-#include <QtGui/QPainter>
-#include <QtGui/QPalette>
-#include <QtGui/QFont>
-#include <private/qgtkstyle_p.h>
+#include <private/qgtkglobal_p.h>
+#include <QtCore/qsize.h>
+#include <QtCore/qrect.h>
+#include <QtCore/qpoint.h>
+#include <QtGui/qpixmap.h>
+#include <QtGui/qpainter.h>
 
 QT_BEGIN_NAMESPACE
 
 class QGtkPainter
 {
-
 public:
-    QGtkPainter(QPainter *painter);
-    GtkStyle *getStyle(GtkWidget *gtkWidget);
-    GtkStateType gtkState(const QStyleOption *option);
+    QGtkPainter();
+    virtual ~QGtkPainter();
+
+    void reset(QPainter *painter = 0);
 
     void setAlphaSupport(bool value) { m_alpha = value; }
     void setClipRect(const QRect &rect) { m_cliprect = rect; }
@@ -77,48 +79,45 @@ public:
     void setFlipVertical(bool value) { m_vflipped = value; }
     void setUsePixmapCache(bool value) { m_usePixmapCache = value; }
 
-    void paintBoxGap(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
-                     GtkStateType state, GtkShadowType shadow, GtkPositionType gap_side, gint x,
-                     gint width, GtkStyle *style);
-    void paintBox(GtkWidget *gtkWidget, const gchar* part,
-                  const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style,
-                  const QString &pmKey = QString());
-    void paintHline(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
-                    int x1, int x2, int y, const QString &pmKey = QString());
-    void paintVline(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
-                    int y1, int y2, int x, const QString &pmKey = QString());
-    void paintExpander(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state,
-                       GtkExpanderStyle expander_state, GtkStyle *style, const QString &pmKey = QString());
-    void paintFocus(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
-                    const QString &pmKey = QString());
-    void paintResizeGrip(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
-                         GdkWindowEdge edge, GtkStyle *style, const QString &pmKey = QString());
-    void paintArrow(GtkWidget *gtkWidget, const gchar* part, const QRect &arrowrect, GtkArrowType arrow_type, GtkStateType state, GtkShadowType shadow,
-                    gboolean fill, GtkStyle *style, const QString &pmKey = QString());
-    void paintHandle(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
-                     GtkStateType state, GtkShadowType shadow, GtkOrientation orientation, GtkStyle *style);
-    void paintSlider(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
-                     GtkStyle *style, GtkOrientation orientation, const QString &pmKey = QString());
-    void paintShadow(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
-                     GtkStyle *style, const QString &pmKey = QString());
-    void paintFlatBox(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString & = QString());
-    void paintExtention(GtkWidget *gtkWidget, const gchar *part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
-                        GtkPositionType gap_pos, GtkStyle *style);
-    void paintOption(GtkWidget *gtkWidget, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString &detail);
-    void paintCheckbox(GtkWidget *gtkWidget, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString &detail);
+    virtual void paintBoxGap(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
+                             GtkStateType state, GtkShadowType shadow, GtkPositionType gap_side, gint x,
+                             gint width, GtkStyle *style) = 0;
+    virtual void paintBox(GtkWidget *gtkWidget, const gchar* part,
+                          const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style,
+                          const QString &pmKey = QString()) = 0;
+    virtual void paintHline(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
+                            int x1, int x2, int y, const QString &pmKey = QString()) = 0;
+    virtual void paintVline(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
+                            int y1, int y2, int x, const QString &pmKey = QString()) = 0;
+    virtual void paintExpander(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state,
+                               GtkExpanderStyle expander_state, GtkStyle *style, const QString &pmKey = QString()) = 0;
+    virtual void paintFocus(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkStyle *style,
+                            const QString &pmKey = QString()) = 0;
+    virtual void paintResizeGrip(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
+                                 GdkWindowEdge edge, GtkStyle *style, const QString &pmKey = QString()) = 0;
+    virtual void paintArrow(GtkWidget *gtkWidget, const gchar* part, const QRect &arrowrect, GtkArrowType arrow_type, GtkStateType state, GtkShadowType shadow,
+                            gboolean fill, GtkStyle *style, const QString &pmKey = QString()) = 0;
+    virtual void paintHandle(GtkWidget *gtkWidget, const gchar* part, const QRect &rect,
+                             GtkStateType state, GtkShadowType shadow, GtkOrientation orientation, GtkStyle *style) = 0;
+    virtual void paintSlider(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
+                             GtkStyle *style, GtkOrientation orientation, const QString &pmKey = QString()) = 0;
+    virtual void paintShadow(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
+                             GtkStyle *style, const QString &pmKey = QString()) = 0;
+    virtual void paintFlatBox(GtkWidget *gtkWidget, const gchar* part, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString & = QString()) = 0;
+    virtual void paintExtention(GtkWidget *gtkWidget, const gchar *part, const QRect &rect, GtkStateType state, GtkShadowType shadow,
+                                GtkPositionType gap_pos, GtkStyle *style) = 0;
+    virtual void paintOption(GtkWidget *gtkWidget, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString &detail) = 0;
+    virtual void paintCheckbox(GtkWidget *gtkWidget, const QRect &rect, GtkStateType state, GtkShadowType shadow, GtkStyle *style, const QString &detail) = 0;
 
-    static QPixmap getIcon(const char* iconName, GtkIconSize size = GTK_ICON_SIZE_BUTTON);
-private:
-    QPixmap renderTheme(uchar *bdata, uchar *wdata, const QRect&);
+protected:
+    static QString uniqueName(const QString &key, GtkStateType state, GtkShadowType shadow, const QSize &size, GtkWidget *widget = 0);
 
-    GtkWidget *m_window;
     QPainter *m_painter;
     bool m_alpha;
     bool m_hflipped;
     bool m_vflipped;
     bool m_usePixmapCache;
     QRect m_cliprect;
-
 };
 
 QT_END_NAMESPACE
diff --git a/src/widgets/styles/qgtkstyle.cpp b/src/widgets/styles/qgtkstyle.cpp
index 538e5b1..6aaa323 100644
--- a/src/widgets/styles/qgtkstyle.cpp
+++ b/src/widgets/styles/qgtkstyle.cpp
@@ -79,6 +79,48 @@
 
 QT_BEGIN_NAMESPACE
 
+static GtkStateType qt_gtk_state(const QStyleOption *option)
+{
+    GtkStateType state = GTK_STATE_NORMAL;
+    if (!(option->state & QStyle::State_Enabled))
+        state = GTK_STATE_INSENSITIVE;
+    else if (option->state & QStyle::State_MouseOver)
+        state = GTK_STATE_PRELIGHT;
+
+    return state;
+}
+
+static QPixmap qt_gtk_get_icon(const char* iconName, GtkIconSize size = GTK_ICON_SIZE_BUTTON)
+{
+    GtkStyle *style = QGtkStylePrivate::gtkStyle();
+    GtkIconSet* iconSet  = QGtkStylePrivate::gtk_icon_factory_lookup_default (iconName);
+    GdkPixbuf* icon = QGtkStylePrivate::gtk_icon_set_render_icon(iconSet,
+                                                 style,
+                                                 GTK_TEXT_DIR_LTR,
+                                                 GTK_STATE_NORMAL,
+                                                 size,
+                                                 NULL,
+                                                 "button");
+    uchar* data = (uchar*)QGtkStylePrivate::gdk_pixbuf_get_pixels(icon);
+    int width = QGtkStylePrivate::gdk_pixbuf_get_width(icon);
+    int height = QGtkStylePrivate::gdk_pixbuf_get_height(icon);
+    QImage converted(width, height, QImage::Format_ARGB32);
+    uchar* tdata = (uchar*)converted.bits();
+
+    for ( int index = 0 ; index < height * width*4 ; index +=4 ) {
+        //int index = y * rowstride + x;
+        tdata[index + QT_RED] = data[index + GTK_RED];
+        tdata[index + QT_GREEN] = data[index + GTK_GREEN];
+        tdata[index + QT_BLUE] = data[index + GTK_BLUE];
+        tdata[index + QT_ALPHA] = data[index + GTK_ALPHA];
+    }
+
+    QGtkStylePrivate::gdk_pixbuf_unref(icon);
+
+    // should we free iconset?
+    return QPixmap::fromImage(converted);
+}
+
 static void qt_gtk_draw_mdibutton(QPainter *painter, const QStyleOptionTitleBar *option, const QRect &tmp, bool hover, bool sunken)
 {
     QColor dark;
@@ -861,7 +903,7 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
     }
 
     GtkStyle* style = d->gtkStyle();
-    QGtkPainter gtkPainter(painter);
+    QGtkPainter* gtkPainter = d->gtkPainter(painter);
 
     switch (element) {
       case PE_Frame: {
@@ -886,8 +928,8 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
             pixmap = QPixmap(pmSize, pmSize);
             pixmap.fill(Qt::transparent);
             QPainter pmPainter(&pixmap);
-            QGtkPainter gtkFramePainter(&pmPainter);
-            gtkFramePainter.setUsePixmapCache(false); // Don't cache twice
+            gtkPainter->reset(&pmPainter);
+            gtkPainter->setUsePixmapCache(false); // Don't cache twice
 
             GtkShadowType shadow_type = GTK_SHADOW_NONE;
             if (option->state & State_Sunken)
@@ -898,10 +940,11 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
             GtkStyle *style = d->gtk_rc_get_style_by_paths(d->gtk_settings_get_default(),
                                      "*.GtkScrolledWindow", "*.GtkScrolledWindow", d->gtk_window_get_type());
             if (style)
-                gtkFramePainter.paintShadow(d->gtkWidget("GtkFrame"), "viewport", pmRect,
-                                         option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
-                                         shadow_type, style);
+                gtkPainter->paintShadow(d->gtkWidget("GtkFrame"), "viewport", pmRect,
+                                        option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
+                                        shadow_type, style);
             QPixmapCache::insert(pmKey, pixmap);
+            gtkPainter->reset(painter);
         }
 
         QRect rect = option->rect;
@@ -945,7 +988,7 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         GtkWidget *gtkWindow = d->gtkWidget("GtkWindow"); // The Murrine Engine currently assumes a widget is passed
         style = d->gtk_rc_get_style_by_paths(d->gtk_settings_get_default(), "gtk-tooltips", "GtkWindow",
                 d->gtk_window_get_type());
-        gtkPainter.paintFlatBox(gtkWindow, "tooltip", option->rect, GTK_STATE_NORMAL, GTK_SHADOW_NONE, style);
+        gtkPainter->paintFlatBox(gtkWindow, "tooltip", option->rect, GTK_STATE_NORMAL, GTK_SHADOW_NONE, style);
     }
     break;
 
@@ -959,15 +1002,15 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         GtkShadowType shadow_type;
         GtkWidget *gtkStatusbarFrame = d->gtkWidget("GtkStatusbar.GtkFrame");
         d->gtk_widget_style_get(d->gtk_widget_get_parent(gtkStatusbarFrame), "shadow-type", &shadow_type, NULL);
-        gtkPainter.paintShadow(gtkStatusbarFrame, "frame", option->rect, GTK_STATE_NORMAL,
-                               shadow_type, d->gtk_widget_get_style(gtkStatusbarFrame));
+        gtkPainter->paintShadow(gtkStatusbarFrame, "frame", option->rect, GTK_STATE_NORMAL,
+                                shadow_type, d->gtk_widget_get_style(gtkStatusbarFrame));
     }
     break;
 
     case PE_IndicatorHeaderArrow:
         if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
             GtkWidget *gtkTreeHeader = d->gtkWidget("GtkTreeView.GtkButton");
-            GtkStateType state = gtkPainter.gtkState(option);
+            GtkStateType state = qt_gtk_state(option);
             style = d->gtk_widget_get_style(gtkTreeHeader);
             GtkArrowType type = GTK_ARROW_UP;
             // This sorting indicator inversion is intentional, and follows the GNOME HIG.
@@ -977,8 +1020,8 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
             else if (header->sortIndicator & QStyleOptionHeader::SortDown)
                 type = GTK_ARROW_DOWN;
 
-            gtkPainter.paintArrow(gtkTreeHeader, "button", option->rect.adjusted(1, 1, -1, -1), type, state,
-                                  GTK_SHADOW_NONE, false, style);
+            gtkPainter->paintArrow(gtkTreeHeader, "button", option->rect.adjusted(1, 1, -1, -1), type, state,
+                                   GTK_SHADOW_NONE, false, style);
         }
         break;
 
@@ -989,11 +1032,11 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
                 // Dont draw anything
             } else if (qobject_cast<const QTabBar*>(widget)) {
                 GtkWidget *gtkNotebook = d->gtkWidget("GtkNotebook");
-                style = gtkPainter.getStyle(gtkNotebook);
-                gtkPainter.paintFocus(gtkNotebook, "tab", frameRect.adjusted(-1, 1, 1, 1), GTK_STATE_ACTIVE, style);
+                style = d->gtk_widget_get_style(gtkNotebook);
+                gtkPainter->paintFocus(gtkNotebook, "tab", frameRect.adjusted(-1, 1, 1, 1), GTK_STATE_ACTIVE, style);
             } else {
                 GtkWidget *gtkRadioButton = d->gtkWidget("GtkRadioButton");
-                gtkPainter.paintFocus(gtkRadioButton, "radiobutton", frameRect, GTK_STATE_ACTIVE, style);
+                gtkPainter->paintFocus(gtkRadioButton, "radiobutton", frameRect, GTK_STATE_ACTIVE, style);
             }
         }
         break;
@@ -1014,8 +1057,8 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
             else if (option->state & State_MouseOver)
                 state = GTK_STATE_PRELIGHT;
 
-            gtkPainter.paintExpander(gtkTreeView, "treeview", rect, state,
-                                     option->state & State_Open ? openState : closedState , d->gtk_widget_get_style(gtkTreeView));
+            gtkPainter->paintExpander(gtkTreeView, "treeview", rect, state,
+                                      option->state & State_Open ? openState : closedState , d->gtk_widget_get_style(gtkTreeView));
         }
         break;
 
@@ -1059,10 +1102,10 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
                     QGtkStylePrivate::gtkWidgetSetFocus(gtkTreeView, true);
                 }
                 bool isEnabled = (widget ? widget->isEnabled() : (vopt->state & QStyle::State_Enabled));
-                gtkPainter.paintFlatBox(gtkTreeView, detail, option->rect,
-                                        option->state & State_Selected ? GTK_STATE_SELECTED :
-                                        isEnabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
-                                        GTK_SHADOW_OUT, d->gtk_widget_get_style(gtkTreeView), key);
+                gtkPainter->paintFlatBox(gtkTreeView, detail, option->rect,
+                                         option->state & State_Selected ? GTK_STATE_SELECTED :
+                                         isEnabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
+                                         GTK_SHADOW_OUT, d->gtk_widget_get_style(gtkTreeView), key);
                 if (isActive )
                     QGtkStylePrivate::gtkWidgetSetFocus(gtkTreeView, false);
             }
@@ -1076,14 +1119,14 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
                 const int offset = option->rect.width()/2;
                 QRect rect = option->rect.adjusted(offset, margin, 0, -margin);
                 painter->setPen(QPen(option->palette.background().color().darker(110)));
-                gtkPainter.paintVline( gtkSeparator, "vseparator",
+                gtkPainter->paintVline(gtkSeparator, "vseparator",
                                        rect, GTK_STATE_NORMAL, d->gtk_widget_get_style(gtkSeparator),
                                        0, rect.height(), 0);
             } else { //Draw vertical separator
                 const int offset = option->rect.height()/2;
                 QRect rect = option->rect.adjusted(margin, offset, -margin, 0);
                 painter->setPen(QPen(option->palette.background().color().darker(110)));
-                gtkPainter.paintHline( gtkSeparator, "hseparator",
+                gtkPainter->paintHline(gtkSeparator, "hseparator",
                                        rect, GTK_STATE_NORMAL, d->gtk_widget_get_style(gtkSeparator),
                                        0, rect.width(), 0);
             }
@@ -1096,9 +1139,9 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         d->gtk_widget_style_get(gtkToolbar, "shadow-type", &shadow_type, NULL);
         //Note when the toolbar is horizontal, the handle is vertical
         painter->setClipRect(option->rect);
-        gtkPainter.paintHandle(gtkToolbar, "toolbar", option->rect.adjusted(-1, -1 ,0 ,1),
-                               GTK_STATE_NORMAL, shadow_type, !(option->state & State_Horizontal) ?
-                               GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, d->gtk_widget_get_style(gtkToolbar));
+        gtkPainter->paintHandle(gtkToolbar, "toolbar", option->rect.adjusted(-1, -1 ,0 ,1),
+                                GTK_STATE_NORMAL, shadow_type, !(option->state & State_Horizontal) ?
+                                GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, d->gtk_widget_get_style(gtkToolbar));
     }
     break;
 
@@ -1136,15 +1179,15 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         }
         QRect arrowRect = option->rect.adjusted(border + bsx, border + bsy, -border + bsx, -border + bsy);
         GtkShadowType shadow = option->state & State_Sunken ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
-        GtkStateType state = gtkPainter.gtkState(option);
+        GtkStateType state = qt_gtk_state(option);
 
         QColor arrowColor = option->palette.buttonText().color();
         GtkWidget *gtkArrow = d->gtkWidget("GtkArrow");
         GdkColor color = fromQColor(arrowColor);
         d->gtk_widget_modify_fg (gtkArrow, state, &color);
-        gtkPainter.paintArrow(gtkArrow, "button", arrowRect,
-                              type, state, shadow, false, d->gtk_widget_get_style(gtkArrow),
-                              QString::number(arrowColor.rgba(), 16));
+        gtkPainter->paintArrow(gtkArrow, "button", arrowRect,
+                               type, state, shadow, false, d->gtk_widget_get_style(gtkArrow),
+                               QString::number(arrowColor.rgba(), 16));
         // Passing NULL will revert the color change
         d->gtk_widget_modify_fg (gtkArrow, state, NULL);
     }
@@ -1156,8 +1199,8 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
 
     case PE_PanelMenu: {
             GtkWidget *gtkMenu = d->gtkWidget("GtkMenu");
-            gtkPainter.setAlphaSupport(false); // Note, alpha disabled for performance reasons
-            gtkPainter.paintBox(gtkMenu, "menu", option->rect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, d->gtk_widget_get_style(gtkMenu), QString());
+            gtkPainter->setAlphaSupport(false); // Note, alpha disabled for performance reasons
+            gtkPainter->paintBox(gtkMenu, "menu", option->rect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, d->gtk_widget_get_style(gtkMenu), QString());
         }
         break;
 
@@ -1168,9 +1211,9 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         // This is only used by floating tool bars
         if (qobject_cast<const QToolBar *>(widget)) {
             GtkWidget *gtkMenubar = d->gtkWidget("GtkMenuBar");
-            gtkPainter.paintBox( gtkMenubar, "toolbar",  option->rect,
+            gtkPainter->paintBox(gtkMenubar, "toolbar", option->rect,
                                  GTK_STATE_NORMAL, GTK_SHADOW_OUT, style);
-            gtkPainter.paintBox( gtkMenubar, "menu",  option->rect,
+            gtkPainter->paintBox(gtkMenubar, "menu", option->rect,
                                  GTK_STATE_NORMAL, GTK_SHADOW_OUT, style);
         }
         break;
@@ -1194,14 +1237,14 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
 
         if (option->state & State_HasFocus)
             QGtkStylePrivate::gtkWidgetSetFocus(gtkEntry, true);
-        gtkPainter.paintShadow(gtkEntry, "entry", rect, option->state & State_Enabled ? 
-                               GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, 
-                               GTK_SHADOW_IN, d->gtk_widget_get_style(gtkEntry),
-                               option->state & State_HasFocus ? QLS("focus") : QString());
+        gtkPainter->paintShadow(gtkEntry, "entry", rect, option->state & State_Enabled ?
+                                GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
+                                GTK_SHADOW_IN, d->gtk_widget_get_style(gtkEntry),
+                                option->state & State_HasFocus ? QLS("focus") : QString());
         if (!interior_focus && option->state & State_HasFocus)
-            gtkPainter.paintShadow(gtkEntry, "entry", option->rect, option->state & State_Enabled ? 
-                                   GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
-                                   GTK_SHADOW_IN, d->gtk_widget_get_style(gtkEntry), QLS("GtkEntryShadowIn"));
+            gtkPainter->paintShadow(gtkEntry, "entry", option->rect, option->state & State_Enabled ?
+                                    GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
+                                    GTK_SHADOW_IN, d->gtk_widget_get_style(gtkEntry), QLS("GtkEntryShadowIn"));
 
         if (option->state & State_HasFocus)
             QGtkStylePrivate::gtkWidgetSetFocus(gtkEntry, false);
@@ -1222,7 +1265,7 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
                 resolve_mask & (1 << QPalette::Base)) // Palette overridden by user
                 painter->fillRect(textRect, option->palette.base());
             else
-                gtkPainter.paintFlatBox( gtkEntry, "entry_bg", textRect,
+                gtkPainter->paintFlatBox(gtkEntry, "entry_bg", textRect,
                                          option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, GTK_SHADOW_NONE, gtkEntryStyle);
         }
         break;
@@ -1230,8 +1273,8 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
     case PE_FrameTabWidget:
         if (const QStyleOptionTabWidgetFrame *frame = qstyleoption_cast<const QStyleOptionTabWidgetFrame*>(option)) {
             GtkWidget *gtkNotebook = d->gtkWidget("GtkNotebook");
-            style = gtkPainter.getStyle(gtkNotebook);
-            gtkPainter.setAlphaSupport(false);
+            style = d->gtk_widget_get_style(gtkNotebook);
+            gtkPainter->setAlphaSupport(false);
             GtkShadowType shadow = GTK_SHADOW_OUT;
             GtkStateType state = GTK_STATE_NORMAL; // Only state supported by gtknotebook
             bool reverse = (option->direction == Qt::RightToLeft);
@@ -1250,13 +1293,13 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
                     gapStart = tabframe->selectedTabRect.y();
                     gapSize = tabframe->selectedTabRect.height();
                 }
-                gtkPainter.paintBoxGap(gtkNotebook, "notebook",  option->rect, state, shadow, frameType,
+                gtkPainter->paintBoxGap(gtkNotebook, "notebook", option->rect, state, shadow, frameType,
                                         gapStart, gapSize, style);
                 break; // done
             }
 
             // Note this is only the fallback option
-            gtkPainter.paintBox(gtkNotebook, "notebook",  option->rect, state, shadow, style);
+            gtkPainter->paintBox(gtkNotebook, "notebook", option->rect, state, shadow, style);
         }
         break;
 
@@ -1274,7 +1317,7 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         if (widget && widget->inherits("QDockWidgetTitleButton") && !(option->state & State_MouseOver))
             break;
 
-        GtkStateType state = gtkPainter.gtkState(option);
+        GtkStateType state = qt_gtk_state(option);
         if (option->state & State_On || option->state & State_Sunken)
             state = GTK_STATE_ACTIVE;
         GtkWidget *gtkButton = isTool ? d->gtkWidget("GtkToolButton.GtkButton") : d->gtkWidget("GtkButton");
@@ -1294,8 +1337,8 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
             key += QLS("def");
             QGtkStylePrivate::gtk_widget_set_can_default(gtkButton, true);
             QGtkStylePrivate::gtk_window_set_default((GtkWindow*)QGtkStylePrivate::gtk_widget_get_toplevel(gtkButton), gtkButton);
-            gtkPainter.paintBox(gtkButton, "buttondefault", buttonRect, state, GTK_SHADOW_IN,
-                                style, isDefault ? QLS("d") : QString());
+            gtkPainter->paintBox(gtkButton, "buttondefault", buttonRect, state, GTK_SHADOW_IN,
+                                 style, isDefault ? QLS("d") : QString());
         }
 
         bool hasFocus = option->state & State_HasFocus;
@@ -1311,8 +1354,8 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         GtkShadowType shadow = (option->state & State_Sunken || option->state & State_On ) ?
                                GTK_SHADOW_IN : GTK_SHADOW_OUT;
 
-        gtkPainter.paintBox(gtkButton, "button", buttonRect, state, shadow,
-                            style, key);
+        gtkPainter->paintBox(gtkButton, "button", buttonRect, state, shadow,
+                             style, key);
         if (isDefault)
             QGtkStylePrivate::gtk_window_set_default((GtkWindow*)QGtkStylePrivate::gtk_widget_get_toplevel(gtkButton), 0);
         if (hasFocus)
@@ -1322,7 +1365,7 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
 
     case PE_IndicatorRadioButton: {
         GtkShadowType shadow = GTK_SHADOW_OUT;
-        GtkStateType state = gtkPainter.gtkState(option);
+        GtkStateType state = qt_gtk_state(option);
 
         if (option->state & State_Sunken)
             state = GTK_STATE_ACTIVE;
@@ -1338,7 +1381,7 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         gint spacing;
         d->gtk_widget_style_get(gtkRadioButton, "indicator-spacing", &spacing, NULL);
         QRect buttonRect = option->rect.adjusted(spacing, spacing, -spacing, -spacing);
-        gtkPainter.setClipRect(option->rect);
+        gtkPainter->setClipRect(option->rect);
         // ### Note: Ubuntulooks breaks when the proper widget is passed
         //           Murrine engine requires a widget not to get RGBA check - warnings
         GtkWidget *gtkCheckButton = d->gtkWidget("GtkCheckButton");
@@ -1347,7 +1390,7 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
             key += QLatin1Char('f');
             QGtkStylePrivate::gtkWidgetSetFocus(gtkCheckButton, true);
         }
-        gtkPainter.paintOption(gtkCheckButton , buttonRect, state, shadow, d->gtk_widget_get_style(gtkRadioButton), key);
+        gtkPainter->paintOption(gtkCheckButton , buttonRect, state, shadow, d->gtk_widget_get_style(gtkRadioButton), key);
         if (option->state & State_HasFocus)
             QGtkStylePrivate::gtkWidgetSetFocus(gtkCheckButton, false);
     }
@@ -1355,7 +1398,7 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
 
     case PE_IndicatorCheckBox: {
         GtkShadowType shadow = GTK_SHADOW_OUT;
-        GtkStateType state = gtkPainter.gtkState(option);
+        GtkStateType state = qt_gtk_state(option);
 
         if (option->state & State_Sunken)
             state = GTK_STATE_ACTIVE;
@@ -1377,14 +1420,14 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
         }
 
         // Some styles such as aero-clone assume they can paint in the spacing area
-        gtkPainter.setClipRect(option->rect);
+        gtkPainter->setClipRect(option->rect);
 
         d->gtk_widget_style_get(gtkCheckButton, "indicator-spacing", &spacing, NULL);
 
         QRect checkRect = option->rect.adjusted(spacing, spacing, -spacing, -spacing);
 
-        gtkPainter.paintCheckbox(gtkCheckButton, checkRect, state, shadow, d->gtk_widget_get_style(gtkCheckButton),
-                                 key);
+        gtkPainter->paintCheckbox(gtkCheckButton, checkRect, state, shadow, d->gtk_widget_get_style(gtkCheckButton),
+                                  key);
         if (option->state & State_HasFocus)
             QGtkStylePrivate::gtkWidgetSetFocus(gtkCheckButton, false);
 
@@ -1456,7 +1499,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
     }
 
     GtkStyle* style = d->gtkStyle();
-    QGtkPainter gtkPainter(painter);
+    QGtkPainter* gtkPainter = d->gtkPainter(painter);
     QColor button = option->palette.button().color();
     QColor dark;
     QColor grooveColor;
@@ -1771,8 +1814,8 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
 
                 if (option->state & State_MouseOver) {
                     QRect bgRect = textRect | checkBoxRect;
-                    gtkPainter.paintFlatBox(gtkCheckButton, "checkbutton", bgRect.adjusted(0, 0, 0, -2),
-                                            GTK_STATE_PRELIGHT, GTK_SHADOW_ETCHED_OUT, d->gtk_widget_get_style(gtkCheckButton));
+                    gtkPainter->paintFlatBox(gtkCheckButton, "checkbutton", bgRect.adjusted(0, 0, 0, -2),
+                                             GTK_STATE_PRELIGHT, GTK_SHADOW_ETCHED_OUT, d->gtk_widget_get_style(gtkCheckButton));
                 }
 
                 if (!groupBox->text.isEmpty()) {
@@ -1794,7 +1837,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                     painter->drawText(textRect, Qt::TextShowMnemonic | Qt::AlignLeft| alignment, groupBox->text);
 
                     if (option->state & State_HasFocus)
-                        gtkPainter.paintFocus(gtkCheckButton, "checkbutton", textRect.adjusted(-4, -1, 0, -3), GTK_STATE_ACTIVE, style);
+                        gtkPainter->paintFocus(gtkCheckButton, "checkbutton", textRect.adjusted(-4, -1, 0, -3), GTK_STATE_ACTIVE, style);
                 }
             }
 
@@ -1818,12 +1861,12 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
         if (const QStyleOptionComboBox *comboBox = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
             bool sunken = comboBox->state & State_On; // play dead, if combobox has no items
             BEGIN_STYLE_PIXMAPCACHE(QString::fromLatin1("cb-%0-%1").arg(sunken).arg(comboBox->editable));
-            QGtkPainter gtkCachedPainter(p);
-            gtkCachedPainter.setUsePixmapCache(false); // cached externally
+            gtkPainter->reset(p);
+            gtkPainter->setUsePixmapCache(false); // cached externally
 
             bool isEnabled = (comboBox->state & State_Enabled);
             bool focus = isEnabled && (comboBox->state & State_HasFocus);
-            GtkStateType state = gtkPainter.gtkState(option);
+            GtkStateType state = qt_gtk_state(option);
             int appears_as_list = !proxy()->styleHint(QStyle::SH_ComboBox_Popup, comboBox, widget);
             QStyleOptionComboBox comboBoxCopy = *comboBox;
             comboBoxCopy.rect = option->rect;
@@ -1879,15 +1922,15 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                         resolve_mask & (1 << QPalette::Base)) // Palette overridden by user
                         p->fillRect(contentRect, option->palette.base().color());
                     else {
-                        gtkCachedPainter.paintFlatBox(gtkEntry, "entry_bg", contentRect,
-                                                option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
-                                                GTK_SHADOW_NONE, gtkEntryStyle, entryPath.toString() + QString::number(focus));
+                        gtkPainter->paintFlatBox(gtkEntry, "entry_bg", contentRect,
+                                                 option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
+                                                 GTK_SHADOW_NONE, gtkEntryStyle, entryPath.toString() + QString::number(focus));
                     }
 
-                    gtkCachedPainter.paintShadow(gtkEntry, comboBox->editable ? "entry" : "frame", frameRect, frameState,
-                                           GTK_SHADOW_IN, gtkEntryStyle, entryPath.toString() +
-                                           QString::number(focus) + QString::number(comboBox->editable) +
-                                           QString::number(option->direction));
+                    gtkPainter->paintShadow(gtkEntry, comboBox->editable ? "entry" : "frame", frameRect, frameState,
+                                            GTK_SHADOW_IN, gtkEntryStyle, entryPath.toString() +
+                                            QString::number(focus) + QString::number(comboBox->editable) +
+                                            QString::number(option->direction));
                     if (focus)
                         QGtkStylePrivate::gtkWidgetSetFocus(gtkEntry, false);
                 }
@@ -1902,7 +1945,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                     buttonState = GTK_STATE_PRELIGHT;
 
                 Q_ASSERT(gtkToggleButton);
-                gtkCachedPainter.paintBox( gtkToggleButton, "button", arrowButtonRect, buttonState,
+                gtkPainter->paintBox(gtkToggleButton, "button", arrowButtonRect, buttonState,
                                      shadow, d->gtk_widget_get_style(gtkToggleButton), buttonPath.toString() +
                                      QString::number(focus) + QString::number(option->direction));
                 if (focus)
@@ -1914,10 +1957,10 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
 
                 if (focus) // Clearlooks actually check the widget for the default state
                     QGtkStylePrivate::gtkWidgetSetFocus(gtkToggleButton, true);
-                gtkCachedPainter.paintBox(gtkToggleButton, "button",
-                                    buttonRect, state,
-                                    shadow, gtkToggleButtonStyle,
-                                    buttonPath.toString() + QString::number(focus));
+                gtkPainter->paintBox(gtkToggleButton, "button",
+                                     buttonRect, state,
+                                     shadow, gtkToggleButtonStyle,
+                                     buttonPath.toString() + QString::number(focus));
                 if (focus)
                     QGtkStylePrivate::gtkWidgetSetFocus(gtkToggleButton, false);
 
@@ -1932,9 +1975,9 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                     d->gtk_widget_get_allocation(gtkVSeparator, &allocation);
                     QRect vLineRect(allocation.x, allocation.y, allocation.width, allocation.height);
 
-                    gtkCachedPainter.paintVline( gtkVSeparator, "vseparator",
+                    gtkPainter->paintVline(gtkVSeparator, "vseparator",
                                            vLineRect, state, d->gtk_widget_get_style(gtkVSeparator),
-                                           0, vLineRect.height(), 0,  vSeparatorPath.toString());
+                                           0, vLineRect.height(), 0, vSeparatorPath.toString());
 
 
                     gint interiorFocus = true;
@@ -1942,10 +1985,10 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                     int xt = interiorFocus ? gtkToggleButtonStyle->xthickness : 0;
                     int yt = interiorFocus ? gtkToggleButtonStyle->ythickness : 0;
                     if (focus && ((option->state & State_KeyboardFocusChange) || styleHint(SH_UnderlineShortcut, option, widget)))
-                        gtkCachedPainter.paintFocus(gtkToggleButton, "button",
-                                              option->rect.adjusted(xt, yt, -xt, -yt),
-                                              option->state & State_Sunken ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL,
-                                              gtkToggleButtonStyle);
+                        gtkPainter->paintFocus(gtkToggleButton, "button",
+                                               option->rect.adjusted(xt, yt, -xt, -yt),
+                                               option->state & State_Sunken ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL,
+                                               gtkToggleButtonStyle);
                 }
             }
 
@@ -2011,8 +2054,8 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 // Some styles such as Nimbus paint outside the arrowRect
                 // hence we have provide the whole widget as the cliprect
                 if (gtkArrow) {
-                    gtkCachedPainter.setClipRect(option->rect);
-                    gtkCachedPainter.paintArrow( gtkArrow, "arrow", arrowRect,
+                    gtkPainter->setClipRect(option->rect);
+                    gtkPainter->paintArrow(gtkArrow, "arrow", arrowRect,
                                            GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, true,
                                            style, arrowPath.toString() + QString::number(option->direction));
                 }
@@ -2131,7 +2174,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
             gint trough_border = 1;
             if (!d->gtk_check_version(2, 10, 0)) {
                 d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
-                                           "trough-border",   &trough_border,
+                                           "trough-border",         &trough_border,
                                            "trough-side-details",   &trough_side_details,
                                            "trough-under-steppers", &trough_under_steppers,
                                            "activate-slider",       &activate_slider,
@@ -2176,7 +2219,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 if (trough_under_steppers)
                     grooveRect = option->rect;
 
-                gtkPainter.paintBox( scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
+                gtkPainter->paintBox(scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
             }
 
             //paint slider
@@ -2200,8 +2243,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                         scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
                 }
 
-                gtkPainter.paintSlider( scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
-
+                gtkPainter->paintSlider(scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
                                         horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
             }
 
@@ -2228,11 +2270,11 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarAddLine))
                     state = GTK_STATE_PRELIGHT;
 
-                gtkPainter.paintBox( scrollbarWidget,
+                gtkPainter->paintBox(scrollbarWidget,
                                      horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
                                      state, shadow, style, QLS("add"));
 
-                gtkPainter.paintArrow( scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
+                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
                                        horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
                                        GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, false, style);
             }
@@ -2260,12 +2302,12 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSubLine))
                     state = GTK_STATE_PRELIGHT;
 
-                gtkPainter.paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
-                                    state, shadow, style, QLS("sub"));
+                gtkPainter->paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
+                                     state, shadow, style, QLS("sub"));
 
-                gtkPainter.paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
-                                      horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
-                                      GTK_ARROW_UP, state, GTK_SHADOW_NONE, false, style);
+                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
+                                       horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
+                                       GTK_ARROW_UP, state, GTK_SHADOW_NONE, false, style);
             }
         }
         break;
@@ -2316,7 +2358,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                     editArea.setRight(upRect.left());
             }
             if (spinBox->frame) {
-                GtkStateType state = gtkPainter.gtkState(option);
+                GtkStateType state = qt_gtk_state(option);
 
                 if (!(option->state & State_Enabled))
                     state = GTK_STATE_INSENSITIVE;
@@ -2325,7 +2367,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 else if (state == GTK_STATE_PRELIGHT)
                     state = GTK_STATE_NORMAL;
 
-                style = gtkPainter.getStyle(gtkSpinButton);
+                style = d->gtk_widget_get_style(gtkSpinButton);
 
 
                 QString key;
@@ -2340,33 +2382,33 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 if (resolve_mask & (1 << QPalette::Base)) // Palette overridden by user
                     painter->fillRect(editRect, option->palette.base().color());
                 else
-                    gtkPainter.paintFlatBox(gtkSpinButton, "entry_bg", editArea.adjusted(style->xthickness, style->ythickness,
-                                            -style->xthickness, -style->ythickness),
-                                            option->state & State_Enabled ?
-                                            GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, GTK_SHADOW_NONE, style, key);
+                    gtkPainter->paintFlatBox(gtkSpinButton, "entry_bg", editArea.adjusted(style->xthickness, style->ythickness,
+                                             -style->xthickness, -style->ythickness),
+                                             option->state & State_Enabled ?
+                                             GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, GTK_SHADOW_NONE, style, key);
 
-                gtkPainter.paintShadow(gtkSpinButton, "entry", editArea, state, GTK_SHADOW_IN, d->gtk_widget_get_style(gtkSpinButton), key);
+                gtkPainter->paintShadow(gtkSpinButton, "entry", editArea, state, GTK_SHADOW_IN, d->gtk_widget_get_style(gtkSpinButton), key);
                 if (spinBox->buttonSymbols != QAbstractSpinBox::NoButtons) {
-                    gtkPainter.paintBox(gtkSpinButton, "spinbutton", buttonRect, state, GTK_SHADOW_IN, style, key);
+                    gtkPainter->paintBox(gtkSpinButton, "spinbutton", buttonRect, state, GTK_SHADOW_IN, style, key);
 
                     upRect.setSize(downRect.size());
                     if (!(option->state & State_Enabled))
-                        gtkPainter.paintBox( gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_INSENSITIVE, GTK_SHADOW_IN, style, key);
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_INSENSITIVE, GTK_SHADOW_IN, style, key);
                     else if (upIsActive && sunken)
-                        gtkPainter.paintBox( gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_ACTIVE, GTK_SHADOW_IN, style, key);
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_ACTIVE, GTK_SHADOW_IN, style, key);
                     else if (upIsActive && hover)
-                        gtkPainter.paintBox( gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style, key);
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style, key);
                     else
-                        gtkPainter.paintBox( gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, style, key);
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, style, key);
 
                     if (!(option->state & State_Enabled))
-                        gtkPainter.paintBox( gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_INSENSITIVE, GTK_SHADOW_IN, style, key);
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_INSENSITIVE, GTK_SHADOW_IN, style, key);
                     else if (downIsActive && sunken)
-                        gtkPainter.paintBox( gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_ACTIVE, GTK_SHADOW_IN, style, key);
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_ACTIVE, GTK_SHADOW_IN, style, key);
                     else if (downIsActive && hover)
-                        gtkPainter.paintBox( gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style, key);
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style, key);
                     else
-                        gtkPainter.paintBox( gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, style, key);
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, style, key);
 
                     if (option->state & State_HasFocus)
                         QGtkStylePrivate::gtkWidgetSetFocus(gtkSpinButton, false);
@@ -2408,7 +2450,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 if (!(option->state & State_Enabled) || !(spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled))
                     state = GTK_STATE_INSENSITIVE;
 
-                gtkPainter.paintArrow( gtkSpinButton, "spinbutton", arrowRect, GTK_ARROW_UP, state,
+                gtkPainter->paintArrow(gtkSpinButton, "spinbutton", arrowRect, GTK_ARROW_UP, state,
                                        GTK_SHADOW_NONE, false, style);
 
                 arrowRect.moveCenter(downRect.center());
@@ -2416,7 +2458,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 if (!(option->state & State_Enabled) || !(spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled))
                     state = GTK_STATE_INSENSITIVE;
 
-                gtkPainter.paintArrow( gtkSpinButton, "spinbutton", arrowRect, GTK_ARROW_DOWN, state,
+                gtkPainter->paintArrow(gtkSpinButton, "spinbutton", arrowRect, GTK_ARROW_DOWN, state,
                                        GTK_SHADOW_NONE, false, style);
             }
         }
@@ -2478,17 +2520,17 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 d->gtk_widget_style_get(scaleWidget, "trough-border", &outerSize, NULL);
                 outerSize++;
 
-                GtkStateType state = gtkPainter.gtkState(option);
+                GtkStateType state = qt_gtk_state(option);
                 int focusFrameMargin = 2;
                 QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
                                    -focusFrameMargin, -outerSize - focusFrameMargin);
 
                 gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
                 if (!d->gtk_check_version(2, 10, 0))
-                    d->gtk_widget_style_get((GtkWidget*)(scaleWidget), "trough-side-details",   &trough_side_details, NULL);
+                    d->gtk_widget_style_get((GtkWidget*)(scaleWidget), "trough-side-details", &trough_side_details, NULL);
 
                 if (!trough_side_details) {
-                    gtkPainter.paintBox( scaleWidget, "trough", grooveRect, state,
+                    gtkPainter->paintBox(scaleWidget, "trough", grooveRect, state,
                                          GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
                 } else {
                     QRect upperGroove = grooveRect;
@@ -2512,9 +2554,9 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                         }
                     }
 
-                    gtkPainter.paintBox( scaleWidget, "trough-upper", upperGroove, state,
+                    gtkPainter->paintBox(scaleWidget, "trough-upper", upperGroove, state,
                                          GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
-                    gtkPainter.paintBox( scaleWidget, "trough-lower", lowerGroove, state,
+                    gtkPainter->paintBox(scaleWidget, "trough-lower", lowerGroove, state,
                                          GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
                 }
             }
@@ -2602,8 +2644,7 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                     }
                     proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
                 }
-                gtkPainter.paintSlider( scaleWidget, horizontal ? "hscale" : "vscale", handle, state, shadow, style,
-
+                gtkPainter->paintSlider(scaleWidget, horizontal ? "hscale" : "vscale", handle, state, shadow, style,
                                         horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL);
             }
             painter->setBrush(oldBrush);
@@ -2641,7 +2682,7 @@ void QGtkStyle::drawControl(ControlElement element,
     }
 
     GtkStyle* style = d->gtkStyle();
-    QGtkPainter gtkPainter(painter);
+    QGtkPainter* gtkPainter = d->gtkPainter(painter);
 
     switch (element) {
     case CE_ProgressBarLabel:
@@ -2774,8 +2815,8 @@ void QGtkStyle::drawControl(ControlElement element,
             GtkWidget *gtkRadioButton = d->gtkWidget("GtkRadioButton");
 
             if (option->state & State_MouseOver) {
-                gtkPainter.paintFlatBox(gtkRadioButton, "checkbutton", option->rect,
-                                        GTK_STATE_PRELIGHT, GTK_SHADOW_ETCHED_OUT, d->gtk_widget_get_style(gtkRadioButton));
+                gtkPainter->paintFlatBox(gtkRadioButton, "checkbutton", option->rect,
+                                         GTK_STATE_PRELIGHT, GTK_SHADOW_ETCHED_OUT, d->gtk_widget_get_style(gtkRadioButton));
             }
 
             QStyleOptionButton subopt = *btn;
@@ -2922,13 +2963,13 @@ void QGtkStyle::drawControl(ControlElement element,
             Q_ASSERT(column);
 
             GtkWidget *gtkTreeHeader = column->button;
-            GtkStateType state = gtkPainter.gtkState(option);
+            GtkStateType state = qt_gtk_state(option);
             GtkShadowType shadow = GTK_SHADOW_OUT;
 
             if (option->state & State_Sunken)
                 shadow = GTK_SHADOW_IN;
             
-            gtkPainter.paintBox(gtkTreeHeader, "button",  option->rect.adjusted(-1, 0, 0, 0), state, shadow, d->gtk_widget_get_style(gtkTreeHeader));
+            gtkPainter->paintBox(gtkTreeHeader, "button", option->rect.adjusted(-1, 0, 0, 0), state, shadow, d->gtk_widget_get_style(gtkTreeHeader));
         }
 
         painter->restore();
@@ -2940,9 +2981,9 @@ void QGtkStyle::drawControl(ControlElement element,
         GtkWidget *gtkStatusbar = d->gtkWidget("GtkStatusbar.GtkFrame");
         GtkStyle *gtkStatusbarStyle = d->gtk_widget_get_style(gtkStatusbar);
         QRect gripRect = option->rect.adjusted(0, 0, -gtkStatusbarStyle->xthickness, -gtkStatusbarStyle->ythickness);
-        gtkPainter.paintResizeGrip( gtkStatusbar, "statusbar", gripRect, GTK_STATE_NORMAL,
+        gtkPainter->paintResizeGrip(gtkStatusbar, "statusbar", gripRect, GTK_STATE_NORMAL,
                                     GTK_SHADOW_OUT, QApplication::isRightToLeft() ?
-                                        GDK_WINDOW_EDGE_SOUTH_WEST : GDK_WINDOW_EDGE_SOUTH_EAST,
+                                    GDK_WINDOW_EDGE_SOUTH_WEST : GDK_WINDOW_EDGE_SOUTH_EAST,
                                     gtkStatusbarStyle);
     }
     break;
@@ -2958,13 +2999,14 @@ void QGtkStyle::drawControl(ControlElement element,
             QPixmap pixmap(menuBarRect.size());
             pixmap.fill(Qt::transparent);
             QPainter pmPainter(&pixmap);
-            QGtkPainter gtkMenuBarPainter(&pmPainter);
+            gtkPainter->reset(&pmPainter);
             GtkShadowType shadow_type;
             d->gtk_widget_style_get(gtkMenubar, "shadow-type", &shadow_type, NULL);
-            gtkMenuBarPainter.paintBox( gtkMenubar, "menubar",  menuBarRect,
-                                        GTK_STATE_NORMAL, shadow_type, d->gtk_widget_get_style(gtkMenubar));
+            gtkPainter->paintBox(gtkMenubar, "menubar", menuBarRect,
+                                 GTK_STATE_NORMAL, shadow_type, d->gtk_widget_get_style(gtkMenubar));
             pmPainter.end();
             painter->drawPixmap(option->rect, pixmap, option->rect);
+            gtkPainter->reset(painter);
         }
     }
     break;
@@ -2987,15 +3029,16 @@ void QGtkStyle::drawControl(ControlElement element,
                 QPixmap pixmap(menuBarRect.size());
                 pixmap.fill(Qt::transparent);
                 QPainter pmPainter(&pixmap);
-                QGtkPainter menubarPainter(&pmPainter);
+                gtkPainter->reset(&pmPainter);
                 GtkShadowType shadow_type;
                 d->gtk_widget_style_get(gtkMenubar, "shadow-type", &shadow_type, NULL);
                 GdkColor gdkBg = d->gtk_widget_get_style(gtkMenubar)->bg[GTK_STATE_NORMAL]; // Theme can depend on transparency
                 painter->fillRect(option->rect, QColor(gdkBg.red>>8, gdkBg.green>>8, gdkBg.blue>>8));
-                menubarPainter.paintBox(gtkMenubar, "menubar",  menuBarRect,
-                                        GTK_STATE_NORMAL, shadow_type, d->gtk_widget_get_style(gtkMenubar));
+                gtkPainter->paintBox(gtkMenubar, "menubar", menuBarRect,
+                                     GTK_STATE_NORMAL, shadow_type, d->gtk_widget_get_style(gtkMenubar));
                 pmPainter.end();
                 painter->drawPixmap(option->rect, pixmap, option->rect);
+                gtkPainter->reset(painter);
             }
 
             QStyleOptionMenuItem item = *mbi;
@@ -3014,8 +3057,8 @@ void QGtkStyle::drawControl(ControlElement element,
             if (act) {
                 GtkShadowType shadowType = GTK_SHADOW_NONE;
                 d->gtk_widget_style_get (gtkMenubarItem, "selected-shadow-type", &shadowType, NULL);
-                gtkPainter.paintBox(gtkMenubarItem, "menuitem",  option->rect.adjusted(0, 0, 0, 3),
-                                    GTK_STATE_PRELIGHT, shadowType, style);
+                gtkPainter->paintBox(gtkMenubarItem, "menuitem", option->rect.adjusted(0, 0, 0, 3),
+                                     GTK_STATE_PRELIGHT, shadowType, style);
                 //draw text
                 QPalette::ColorRole textRole = dis ? QPalette::Text : QPalette::HighlightedText;
                 uint alignment = Qt::AlignCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
@@ -3031,7 +3074,7 @@ void QGtkStyle::drawControl(ControlElement element,
 
     case CE_Splitter: {
         GtkWidget *gtkWindow = d->gtkWidget("GtkWindow"); // The Murrine Engine currently assumes a widget is passed
-        gtkPainter.paintHandle(gtkWindow, "splitter", option->rect, gtkPainter.gtkState(option), GTK_SHADOW_NONE,
+        gtkPainter->paintHandle(gtkWindow, "splitter", option->rect, qt_gtk_state(option), GTK_SHADOW_NONE,
                                 !(option->state & State_Horizontal) ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL,
                                 style);
     }
@@ -3053,7 +3096,7 @@ void QGtkStyle::drawControl(ControlElement element,
             GtkWidget *gtkToolbar = d->gtkWidget("GtkToolbar");
             GtkShadowType shadow_type = GTK_SHADOW_NONE;
             d->gtk_widget_style_get(gtkToolbar, "shadow-type", &shadow_type, NULL);
-            gtkPainter.paintBox( gtkToolbar, "toolbar",  rect,
+            gtkPainter->paintBox(gtkToolbar, "toolbar", rect,
                                  GTK_STATE_NORMAL, shadow_type, d->gtk_widget_get_style(gtkToolbar));
         }
         break;
@@ -3070,7 +3113,7 @@ void QGtkStyle::drawControl(ControlElement element,
             GtkWidget *gtkMenuItem = menuItem->checked ? d->gtkWidget("GtkMenu.GtkCheckMenuItem") :
                                      d->gtkWidget("GtkMenu.GtkMenuItem");
 
-            style = gtkPainter.getStyle(gtkMenuItem);
+            style = d->gtk_widget_get_style(gtkMenuItem);
             QColor shadow = option->palette.dark().color();
 
             if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
@@ -3092,10 +3135,10 @@ void QGtkStyle::drawControl(ControlElement element,
                 separatorRect.setWidth(option->rect.width() - 2 * (horizontal_padding + gtkMenuSeparatorStyle->xthickness));
                 separatorRect.moveCenter(option->rect.center());
                 if (wide_separators)
-                   gtkPainter.paintBox( gtkMenuSeparator, "hseparator",
+                   gtkPainter->paintBox(gtkMenuSeparator, "hseparator",
                                         separatorRect, GTK_STATE_NORMAL, GTK_SHADOW_NONE, gtkMenuSeparatorStyle);
                 else
-                    gtkPainter.paintHline( gtkMenuSeparator, "hseparator",
+                    gtkPainter->paintHline(gtkMenuSeparator, "hseparator",
                                            separatorRect, GTK_STATE_NORMAL, gtkMenuSeparatorStyle,
                                            0, option->rect.right() - 1, 1);
                 painter->restore();
@@ -3110,7 +3153,7 @@ void QGtkStyle::drawControl(ControlElement element,
                 if (qobject_cast<const QComboBox*>(widget))
                     rect = option->rect;
 #endif
-                gtkPainter.paintBox( gtkMenuItem, "menuitem", rect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style);
+                gtkPainter->paintBox(gtkMenuItem, "menuitem", rect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style);
             }
 
             bool checkable = menuItem->checkType != QStyleOptionMenuItem::NotCheckable;
@@ -3141,33 +3184,33 @@ void QGtkStyle::drawControl(ControlElement element,
                     if (menuItem->checkType & QStyleOptionMenuItem::Exclusive) {
                         // Radio button
                         GtkShadowType shadow = GTK_SHADOW_OUT;
-                        GtkStateType state = gtkPainter.gtkState(option);
+                        GtkStateType state = qt_gtk_state(option);
 
                         if (selected)
                             state = GTK_STATE_PRELIGHT;
                         if (checked)
                             shadow = GTK_SHADOW_IN;
 
-                        gtkPainter.setClipRect(checkRect.adjusted(-spacing, -spacing, spacing, spacing));
-                        gtkPainter.paintOption(gtkMenuItem, checkRect.translated(-spacing, -spacing), state, shadow,
-                                               style, QLS("option"));
-                        gtkPainter.setClipRect(QRect());
+                        gtkPainter->setClipRect(checkRect.adjusted(-spacing, -spacing, spacing, spacing));
+                        gtkPainter->paintOption(gtkMenuItem, checkRect.translated(-spacing, -spacing), state, shadow,
+                                                style, QLS("option"));
+                        gtkPainter->setClipRect(QRect());
 
                     } else {
                         // Check box
                         if (menuItem->icon.isNull()) {
                             GtkShadowType shadow = GTK_SHADOW_OUT;
-                            GtkStateType state = gtkPainter.gtkState(option);
+                            GtkStateType state = qt_gtk_state(option);
 
                             if (selected)
                                 state = GTK_STATE_PRELIGHT;
                             if (checked)
                                 shadow = GTK_SHADOW_IN;
 
-                            gtkPainter.setClipRect(checkRect.adjusted(-spacing, -spacing, -spacing, -spacing));
-                            gtkPainter.paintCheckbox(gtkMenuItem, checkRect.translated(-spacing, -spacing), state, shadow,
-                                                     style, QLS("check"));
-                           gtkPainter.setClipRect(QRect());
+                            gtkPainter->setClipRect(checkRect.adjusted(-spacing, -spacing, -spacing, -spacing));
+                            gtkPainter->paintCheckbox(gtkMenuItem, checkRect.translated(-spacing, -spacing), state, shadow,
+                                                      style, QLS("check"));
+                            gtkPainter->setClipRect(QRect());
                         }
                     }
                 }
@@ -3319,8 +3362,8 @@ void QGtkStyle::drawControl(ControlElement element,
                                                        menuItem->rect.height() / 2 - dim / 2, dim, dim));
                 GtkStateType state = enabled ? (act ? GTK_STATE_PRELIGHT: GTK_STATE_NORMAL) : GTK_STATE_INSENSITIVE;
                 GtkShadowType shadowType = (state == GTK_STATE_PRELIGHT) ? GTK_SHADOW_OUT : GTK_SHADOW_IN;
-                gtkPainter.paintArrow(gtkMenuItem, "menuitem", vSubMenuRect, QApplication::isRightToLeft() ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT, state,
-                                      shadowType, false, style);
+                gtkPainter->paintArrow(gtkMenuItem, "menuitem", vSubMenuRect, QApplication::isRightToLeft() ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT, state,
+                                       shadowType, false, style);
             }
         }
         painter->restore();
@@ -3342,10 +3385,10 @@ void QGtkStyle::drawControl(ControlElement element,
                 // The normal button focus rect does not work well for flat buttons in Clearlooks
                 proxy()->drawPrimitive(PE_FrameFocusRect, option, painter, widget);
             else if (btn->state & State_HasFocus)
-                gtkPainter.paintFocus(gtkButton, "button",
-                                      option->rect.adjusted(xt, yt, -xt, -yt),
-                                      btn->state & State_Sunken ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL,
-                                      gtkButtonStyle);
+                gtkPainter->paintFocus(gtkButton, "button",
+                                       option->rect.adjusted(xt, yt, -xt, -yt),
+                                       btn->state & State_Sunken ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL,
+                                       gtkButtonStyle);
 
             proxy()->drawControl(CE_PushButtonLabel, &subopt, painter, widget);
         }
@@ -3356,7 +3399,7 @@ void QGtkStyle::drawControl(ControlElement element,
     case CE_TabBarTabShape:
         if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {
             GtkWidget *gtkNotebook = d->gtkWidget("GtkNotebook");
-            style = gtkPainter.getStyle(gtkNotebook);
+            style = d->gtk_widget_get_style(gtkNotebook);
 
             QRect rect = option->rect;
             GtkShadowType shadow = GTK_SHADOW_OUT;
@@ -3384,27 +3427,27 @@ void QGtkStyle::drawControl(ControlElement element,
             case QTabBar::RoundedNorth:
                 if (!selected)
                     rect.adjust(first ? 0 : -tabOverlap, topIndent, last ? 0 : tabOverlap, -bottomIndent);
-                gtkPainter.paintExtention( gtkNotebook, "tab", rect,
+                gtkPainter->paintExtention(gtkNotebook, "tab", rect,
                                            state, shadow, GTK_POS_BOTTOM, style);
                 break;
 
             case QTabBar::RoundedSouth:
                 if (!selected)
                     rect.adjust(first ? 0 : -tabOverlap, 0, last ? 0 : tabOverlap, -topIndent);
-                gtkPainter.paintExtention( gtkNotebook, "tab", rect.adjusted(0, 1, 0, 0),
+                gtkPainter->paintExtention(gtkNotebook, "tab", rect.adjusted(0, 1, 0, 0),
                                            state, shadow, GTK_POS_TOP, style);
                 break;
 
             case QTabBar::RoundedWest:
                 if (!selected)
                     rect.adjust(topIndent, 0, -bottomIndent, 0);
-                gtkPainter.paintExtention( gtkNotebook, "tab", rect, state, shadow, GTK_POS_RIGHT, style);
+                gtkPainter->paintExtention(gtkNotebook, "tab", rect, state, shadow, GTK_POS_RIGHT, style);
                 break;
 
             case QTabBar::RoundedEast:
                 if (!selected)
                     rect.adjust(bottomIndent, 0, -topIndent, 0);
-                gtkPainter.paintExtention( gtkNotebook, "tab", rect, state, shadow, GTK_POS_LEFT, style);
+                gtkPainter->paintExtention(gtkNotebook, "tab", rect, state, shadow, GTK_POS_LEFT, style);
                 break;
 
             default:
@@ -3423,8 +3466,8 @@ void QGtkStyle::drawControl(ControlElement element,
         if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
             Q_UNUSED(bar);
             GtkWidget *gtkProgressBar = d->gtkWidget("GtkProgressBar");
-            GtkStateType state = gtkPainter.gtkState(option);
-            gtkPainter.paintBox( gtkProgressBar, "trough",  option->rect, state, GTK_SHADOW_IN, d->gtk_widget_get_style(gtkProgressBar));
+            GtkStateType state = qt_gtk_state(option);
+            gtkPainter->paintBox(gtkProgressBar, "trough", option->rect, state, GTK_SHADOW_IN, d->gtk_widget_get_style(gtkProgressBar));
         }
 
         break;
@@ -3434,7 +3477,7 @@ void QGtkStyle::drawControl(ControlElement element,
             GtkStateType state = option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE;
             GtkWidget *gtkProgressBar = d->gtkWidget("GtkProgressBar");
             style = d->gtk_widget_get_style(gtkProgressBar);
-            gtkPainter.paintBox( gtkProgressBar, "trough",  option->rect, state, GTK_SHADOW_IN, style);
+            gtkPainter->paintBox(gtkProgressBar, "trough", option->rect, state, GTK_SHADOW_IN, style);
             int xt = style->xthickness;
             int yt = style->ythickness;
             QRect rect = bar->rect.adjusted(xt, yt, -xt, -yt);
@@ -3502,9 +3545,9 @@ void QGtkStyle::drawControl(ControlElement element,
             QString key = QString(QLS("%0")).arg(fakePos);
             if (inverted) {
                 key += QLatin1String("inv");
-                gtkPainter.setFlipHorizontal(true);
+                gtkPainter->setFlipHorizontal(true);
             }
-            gtkPainter.paintBox( gtkProgressBar, "bar",  progressBar, GTK_STATE_SELECTED, GTK_SHADOW_OUT, style, key);
+            gtkPainter->paintBox(gtkProgressBar, "bar", progressBar, GTK_STATE_SELECTED, GTK_SHADOW_OUT, style, key);
         }
 
         break;
@@ -4036,31 +4079,31 @@ QPixmap QGtkStyle::standardPixmap(StandardPixmap sp, const QStyleOption *option,
     break;
 
     case SP_DialogDiscardButton:
-        return QGtkPainter::getIcon(GTK_STOCK_DELETE);
+        return qt_gtk_get_icon(GTK_STOCK_DELETE);
     case SP_DialogOkButton:
-        return QGtkPainter::getIcon(GTK_STOCK_OK);
+        return qt_gtk_get_icon(GTK_STOCK_OK);
     case SP_DialogCancelButton:
-        return QGtkPainter::getIcon(GTK_STOCK_CANCEL);
+        return qt_gtk_get_icon(GTK_STOCK_CANCEL);
     case SP_DialogYesButton:
-        return QGtkPainter::getIcon(GTK_STOCK_YES);
+        return qt_gtk_get_icon(GTK_STOCK_YES);
     case SP_DialogNoButton:
-        return QGtkPainter::getIcon(GTK_STOCK_NO);
+        return qt_gtk_get_icon(GTK_STOCK_NO);
     case SP_DialogOpenButton:
-        return QGtkPainter::getIcon(GTK_STOCK_OPEN);
+        return qt_gtk_get_icon(GTK_STOCK_OPEN);
     case SP_DialogCloseButton:
-        return QGtkPainter::getIcon(GTK_STOCK_CLOSE);
+        return qt_gtk_get_icon(GTK_STOCK_CLOSE);
     case SP_DialogApplyButton:
-        return QGtkPainter::getIcon(GTK_STOCK_APPLY);
+        return qt_gtk_get_icon(GTK_STOCK_APPLY);
     case SP_DialogSaveButton:
-        return QGtkPainter::getIcon(GTK_STOCK_SAVE);
+        return qt_gtk_get_icon(GTK_STOCK_SAVE);
     case SP_MessageBoxWarning:
-        return QGtkPainter::getIcon(GTK_STOCK_DIALOG_WARNING, GTK_ICON_SIZE_DIALOG);
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_WARNING, GTK_ICON_SIZE_DIALOG);
     case SP_MessageBoxQuestion:
-        return QGtkPainter::getIcon(GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
     case SP_MessageBoxInformation:
-        return QGtkPainter::getIcon(GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
     case SP_MessageBoxCritical:
-        return QGtkPainter::getIcon(GTK_STOCK_DIALOG_ERROR, GTK_ICON_SIZE_DIALOG);
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_ERROR, GTK_ICON_SIZE_DIALOG);
     default:
         return QCommonStyle::standardPixmap(sp, option, widget);
     }
@@ -4080,31 +4123,31 @@ QIcon QGtkStyle::standardIcon(StandardPixmap standardIcon,
         return QCommonStyle::standardIcon(standardIcon, option, widget);
     switch (standardIcon) {
     case SP_DialogDiscardButton:
-        return QGtkPainter::getIcon(GTK_STOCK_DELETE);
+        return qt_gtk_get_icon(GTK_STOCK_DELETE);
     case SP_DialogOkButton:
-        return QGtkPainter::getIcon(GTK_STOCK_OK);
+        return qt_gtk_get_icon(GTK_STOCK_OK);
     case SP_DialogCancelButton:
-        return QGtkPainter::getIcon(GTK_STOCK_CANCEL);
+        return qt_gtk_get_icon(GTK_STOCK_CANCEL);
     case SP_DialogYesButton:
-        return QGtkPainter::getIcon(GTK_STOCK_YES);
+        return qt_gtk_get_icon(GTK_STOCK_YES);
     case SP_DialogNoButton:
-        return QGtkPainter::getIcon(GTK_STOCK_NO);
+        return qt_gtk_get_icon(GTK_STOCK_NO);
     case SP_DialogOpenButton:
-        return QGtkPainter::getIcon(GTK_STOCK_OPEN);
+        return qt_gtk_get_icon(GTK_STOCK_OPEN);
     case SP_DialogCloseButton:
-        return QGtkPainter::getIcon(GTK_STOCK_CLOSE);
+        return qt_gtk_get_icon(GTK_STOCK_CLOSE);
     case SP_DialogApplyButton:
-        return QGtkPainter::getIcon(GTK_STOCK_APPLY);
+        return qt_gtk_get_icon(GTK_STOCK_APPLY);
     case SP_DialogSaveButton:
-        return QGtkPainter::getIcon(GTK_STOCK_SAVE);
+        return qt_gtk_get_icon(GTK_STOCK_SAVE);
     case SP_MessageBoxWarning:
-        return QGtkPainter::getIcon(GTK_STOCK_DIALOG_WARNING, GTK_ICON_SIZE_DIALOG);
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_WARNING, GTK_ICON_SIZE_DIALOG);
     case SP_MessageBoxQuestion:
-        return QGtkPainter::getIcon(GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
     case SP_MessageBoxInformation:
-        return QGtkPainter::getIcon(GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
     case SP_MessageBoxCritical:
-        return QGtkPainter::getIcon(GTK_STOCK_DIALOG_ERROR, GTK_ICON_SIZE_DIALOG);
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_ERROR, GTK_ICON_SIZE_DIALOG);
     default:
         return QCommonStyle::standardIcon(standardIcon, option, widget);
     }
diff --git a/src/widgets/styles/qgtkstyle_p.cpp b/src/widgets/styles/qgtkstyle_p.cpp
index 26d3a57..57f0ee0 100644
--- a/src/widgets/styles/qgtkstyle_p.cpp
+++ b/src/widgets/styles/qgtkstyle_p.cpp
@@ -62,6 +62,7 @@
 #include <QtCore/QLibrary>
 #include <QtCore/QDebug>
 
+#include <private/qgtk2painter_p.h>
 #include <private/qapplication_p.h>
 #include <private/qiconloader_p.h>
 
@@ -146,23 +147,8 @@ Ptr_gtk_fixed_new QGtkStylePrivate::gtk_fixed_new = 0;
 Ptr_gtk_tree_view_column_new QGtkStylePrivate::gtk_tree_view_column_new = 0;
 Ptr_gtk_tree_view_get_column QGtkStylePrivate::gtk_tree_view_get_column = 0;
 Ptr_gtk_tree_view_append_column QGtkStylePrivate::gtk_tree_view_append_column = 0;
-Ptr_gtk_paint_check QGtkStylePrivate::gtk_paint_check = 0;
-Ptr_gtk_paint_box QGtkStylePrivate::gtk_paint_box = 0;
-Ptr_gtk_paint_box_gap QGtkStylePrivate::gtk_paint_box_gap = 0;
-Ptr_gtk_paint_flat_box QGtkStylePrivate::gtk_paint_flat_box = 0;
-Ptr_gtk_paint_option QGtkStylePrivate::gtk_paint_option = 0;
-Ptr_gtk_paint_extension QGtkStylePrivate::gtk_paint_extension = 0;
-Ptr_gtk_paint_slider QGtkStylePrivate::gtk_paint_slider = 0;
-Ptr_gtk_paint_shadow QGtkStylePrivate::gtk_paint_shadow = 0;
-Ptr_gtk_paint_resize_grip QGtkStylePrivate::gtk_paint_resize_grip = 0;
-Ptr_gtk_paint_focus QGtkStylePrivate::gtk_paint_focus = 0;
-Ptr_gtk_paint_arrow QGtkStylePrivate::gtk_paint_arrow = 0;
-Ptr_gtk_paint_handle QGtkStylePrivate::gtk_paint_handle = 0;
-Ptr_gtk_paint_expander QGtkStylePrivate::gtk_paint_expander = 0;
 Ptr_gtk_adjustment_configure QGtkStylePrivate::gtk_adjustment_configure = 0;
 Ptr_gtk_adjustment_new QGtkStylePrivate::gtk_adjustment_new = 0;
-Ptr_gtk_paint_hline QGtkStylePrivate::gtk_paint_hline = 0;
-Ptr_gtk_paint_vline QGtkStylePrivate::gtk_paint_vline = 0;
 Ptr_gtk_menu_item_set_submenu QGtkStylePrivate::gtk_menu_item_set_submenu = 0;
 Ptr_gtk_settings_get_default QGtkStylePrivate::gtk_settings_get_default = 0;
 Ptr_gtk_separator_menu_item_new QGtkStylePrivate::gtk_separator_menu_item_new = 0;
@@ -210,12 +196,8 @@ Ptr_gtk_file_chooser_set_filename QGtkStylePrivate::gtk_file_chooser_set_filenam
 Ptr_gdk_pixbuf_get_pixels QGtkStylePrivate::gdk_pixbuf_get_pixels = 0;
 Ptr_gdk_pixbuf_get_width QGtkStylePrivate::gdk_pixbuf_get_width = 0;
 Ptr_gdk_pixbuf_get_height QGtkStylePrivate::gdk_pixbuf_get_height = 0;
-Ptr_gdk_pixmap_new QGtkStylePrivate::gdk_pixmap_new = 0;
 Ptr_gdk_pixbuf_new QGtkStylePrivate::gdk_pixbuf_new = 0;
-Ptr_gdk_pixbuf_get_from_drawable QGtkStylePrivate::gdk_pixbuf_get_from_drawable = 0;
-Ptr_gdk_draw_rectangle QGtkStylePrivate::gdk_draw_rectangle = 0;
 Ptr_gdk_pixbuf_unref QGtkStylePrivate::gdk_pixbuf_unref = 0;
-Ptr_gdk_drawable_unref QGtkStylePrivate::gdk_drawable_unref = 0;
 Ptr_gdk_color_free QGtkStylePrivate::gdk_color_free = 0;
 Ptr_gdk_x11_window_set_user_time QGtkStylePrivate::gdk_x11_window_set_user_time = 0;
 Ptr_gdk_x11_drawable_get_xid QGtkStylePrivate::gdk_x11_drawable_get_xid = 0;
@@ -314,6 +296,14 @@ void QGtkStylePrivate::init()
     initGtkWidgets();
 }
 
+QGtkPainter* QGtkStylePrivate::gtkPainter(QPainter *painter)
+{
+    // TODO: choose between gtk2 and gtk3
+    static QGtk2Painter instance;
+    instance.reset(painter);
+    return &instance;
+}
+
 GtkWidget* QGtkStylePrivate::gtkWidget(const QHashableLatin1Literal &path)
 {
     GtkWidget *widget = gtkWidgetMap()->value(path);
@@ -381,12 +371,8 @@ void QGtkStylePrivate::resolveGtk() const
     gdk_pixbuf_get_pixels = (Ptr_gdk_pixbuf_get_pixels)libgtk.resolve("gdk_pixbuf_get_pixels");
     gdk_pixbuf_get_width = (Ptr_gdk_pixbuf_get_width)libgtk.resolve("gdk_pixbuf_get_width");
     gdk_pixbuf_get_height = (Ptr_gdk_pixbuf_get_height)libgtk.resolve("gdk_pixbuf_get_height");
-    gdk_pixmap_new = (Ptr_gdk_pixmap_new)libgtk.resolve("gdk_pixmap_new");
     gdk_pixbuf_new = (Ptr_gdk_pixbuf_new)libgtk.resolve("gdk_pixbuf_new");
-    gdk_pixbuf_get_from_drawable = (Ptr_gdk_pixbuf_get_from_drawable)libgtk.resolve("gdk_pixbuf_get_from_drawable");
-    gdk_draw_rectangle = (Ptr_gdk_draw_rectangle)libgtk.resolve("gdk_draw_rectangle");
     gdk_pixbuf_unref = (Ptr_gdk_pixbuf_unref)libgtk.resolve("gdk_pixbuf_unref");
-    gdk_drawable_unref = (Ptr_gdk_drawable_unref)libgtk.resolve("gdk_drawable_unref");
     gdk_color_free = (Ptr_gdk_color_free)libgtk.resolve("gdk_color_free");
     gdk_x11_window_set_user_time = (Ptr_gdk_x11_window_set_user_time)libgtk.resolve("gdk_x11_window_set_user_time");
     gdk_x11_drawable_get_xid = (Ptr_gdk_x11_drawable_get_xid)libgtk.resolve("gdk_x11_drawable_get_xid");
@@ -435,23 +421,6 @@ void QGtkStylePrivate::resolveGtk() const
     gtk_tree_view_column_new = (Ptr_gtk_tree_view_column_new)libgtk.resolve("gtk_tree_view_column_new");
     gtk_tree_view_append_column= (Ptr_gtk_tree_view_append_column )libgtk.resolve("gtk_tree_view_append_column");
     gtk_tree_view_get_column = (Ptr_gtk_tree_view_get_column )libgtk.resolve("gtk_tree_view_get_column");
-    gtk_paint_check = (Ptr_gtk_paint_check)libgtk.resolve("gtk_paint_check");
-    gtk_paint_box = (Ptr_gtk_paint_box)libgtk.resolve("gtk_paint_box");
-    gtk_paint_flat_box = (Ptr_gtk_paint_flat_box)libgtk.resolve("gtk_paint_flat_box");
-    gtk_paint_check = (Ptr_gtk_paint_check)libgtk.resolve("gtk_paint_check");
-    gtk_paint_box = (Ptr_gtk_paint_box)libgtk.resolve("gtk_paint_box");
-    gtk_paint_resize_grip = (Ptr_gtk_paint_resize_grip)libgtk.resolve("gtk_paint_resize_grip");
-    gtk_paint_focus = (Ptr_gtk_paint_focus)libgtk.resolve("gtk_paint_focus");
-    gtk_paint_shadow = (Ptr_gtk_paint_shadow)libgtk.resolve("gtk_paint_shadow");
-    gtk_paint_slider = (Ptr_gtk_paint_slider)libgtk.resolve("gtk_paint_slider");
-    gtk_paint_expander = (Ptr_gtk_paint_expander)libgtk.resolve("gtk_paint_expander");
-    gtk_paint_handle = (Ptr_gtk_paint_handle)libgtk.resolve("gtk_paint_handle");
-    gtk_paint_option = (Ptr_gtk_paint_option)libgtk.resolve("gtk_paint_option");
-    gtk_paint_arrow = (Ptr_gtk_paint_arrow)libgtk.resolve("gtk_paint_arrow");
-    gtk_paint_box_gap = (Ptr_gtk_paint_box_gap)libgtk.resolve("gtk_paint_box_gap");
-    gtk_paint_extension = (Ptr_gtk_paint_extension)libgtk.resolve("gtk_paint_extension");
-    gtk_paint_hline = (Ptr_gtk_paint_hline)libgtk.resolve("gtk_paint_hline");
-    gtk_paint_vline = (Ptr_gtk_paint_vline)libgtk.resolve("gtk_paint_vline");
     gtk_adjustment_configure = (Ptr_gtk_adjustment_configure)libgtk.resolve("gtk_adjustment_configure");
     gtk_adjustment_new = (Ptr_gtk_adjustment_new)libgtk.resolve("gtk_adjustment_new");
     gtk_menu_item_set_submenu = (Ptr_gtk_menu_item_set_submenu)libgtk.resolve("gtk_menu_item_set_submenu");
diff --git a/src/widgets/styles/qgtkstyle_p.h b/src/widgets/styles/qgtkstyle_p.h
index 14055ee..eec241e 100644
--- a/src/widgets/styles/qgtkstyle_p.h
+++ b/src/widgets/styles/qgtkstyle_p.h
@@ -64,20 +64,10 @@
 
 #include <QtWidgets/QGtkStyle>
 #include <private/qcommonstyle_p.h>
+#include <private/qgtkglobal_p.h>
 
-#undef signals // Collides with GTK symbols
-#include <gtk/gtk.h>
-
-typedef unsigned long XID;
-
-#undef GTK_OBJECT_FLAGS
-#define GTK_OBJECT_FLAGS(obj)(((GtkObject*)(obj))->flags)
 #define Q_GTK_IS_WIDGET(widget) widget && G_TYPE_CHECK_INSTANCE_TYPE ((widget), QGtkStylePrivate::gtk_widget_get_type())
 
-#define QLS(x) QLatin1String(x)
-
-QT_BEGIN_NAMESPACE
-
 class QHashableLatin1Literal
 {
 public:
@@ -187,23 +177,8 @@ typedef GtkTreeViewColumn* (*Ptr_gtk_tree_view_column_new)(void);
 typedef GtkWidget* (*Ptr_gtk_fixed_new)(void);
 typedef GdkPixbuf* (*Ptr_gtk_icon_set_render_icon)(GtkIconSet *, GtkStyle *, GtkTextDirection, GtkStateType, GtkIconSize, GtkWidget *,const char *);
 typedef void (*Ptr_gtk_tree_view_append_column) (GtkTreeView*, GtkTreeViewColumn*);
-typedef void  (*Ptr_gtk_paint_check) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
-typedef void  (*Ptr_gtk_paint_box) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
-typedef void  (*Ptr_gtk_paint_box_gap) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint, gint, gint , gint, GtkPositionType, gint gap_x, gint gap_width);
-typedef void  (*Ptr_gtk_paint_resize_grip) (GtkStyle*,GdkWindow*, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, GdkWindowEdge, gint , gint , gint , gint);
-typedef void  (*Ptr_gtk_paint_focus) (GtkStyle*,GdkWindow*, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
-typedef void  (*Ptr_gtk_paint_shadow) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
-typedef void  (*Ptr_gtk_paint_slider) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint, GtkOrientation);
-typedef void  (*Ptr_gtk_paint_expander) (GtkStyle*,GdkWindow*, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , GtkExpanderStyle );
-typedef void  (*Ptr_gtk_paint_handle) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint, GtkOrientation);
-typedef void  (*Ptr_gtk_paint_arrow) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, GtkArrowType, gboolean, gint , gint , gint , gint);
-typedef void  (*Ptr_gtk_paint_option) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
-typedef void  (*Ptr_gtk_paint_flat_box) (GtkStyle*,GdkWindow*, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint , gint , gint , gint);
-typedef void (*Ptr_gtk_paint_extension) (GtkStyle *, GdkWindow *, GtkStateType, GtkShadowType, const GdkRectangle *, GtkWidget *, const gchar *, gint, gint, gint, gint, GtkPositionType);
 typedef void (*Ptr_gtk_adjustment_configure) (GtkAdjustment *, double, double, double, double, double, double);
 typedef GtkAdjustment* (*Ptr_gtk_adjustment_new) (double, double, double, double, double, double);
-typedef void   (*Ptr_gtk_paint_hline) (GtkStyle *, GdkWindow *, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, gint, gint, gint y);
-typedef void   (*Ptr_gtk_paint_vline) (GtkStyle *, GdkWindow *, GtkStateType, const GdkRectangle *, GtkWidget *, const gchar *, gint, gint, gint);
 typedef void (*Ptr_gtk_menu_item_set_submenu) (GtkMenuItem *, GtkWidget *);
 typedef void (*Ptr_gtk_container_forall) (GtkContainer *, GtkCallback, gpointer);
 typedef void (*Ptr_gtk_widget_size_allocate) (GtkWidget *, GtkAllocation*);
@@ -256,17 +231,9 @@ typedef guchar* (*Ptr_gdk_pixbuf_get_pixels) (const GdkPixbuf *pixbuf);
 typedef int (*Ptr_gdk_pixbuf_get_width) (const GdkPixbuf *pixbuf);
 typedef void (*Ptr_gdk_color_free) (const GdkColor *);
 typedef int (*Ptr_gdk_pixbuf_get_height) (const GdkPixbuf *pixbuf);
-typedef GdkPixbuf* (*Ptr_gdk_pixbuf_get_from_drawable) (GdkPixbuf *dest, GdkDrawable *src,
-                                                         GdkColormap *cmap, int src_x,
-                                                         int src_y, int dest_x, int dest_y,
-                                                         int width, int height);
-typedef GdkPixmap* (*Ptr_gdk_pixmap_new) (GdkDrawable *drawable, gint width, gint height, gint depth);
 typedef GdkPixbuf* (*Ptr_gdk_pixbuf_new) (GdkColorspace colorspace, gboolean has_alpha,
-                                         int bits_per_sample, int width, int height);
-typedef void (*Ptr_gdk_draw_rectangle) (GdkDrawable *drawable, GdkGC *gc,
-                                        gboolean filled, gint x, gint y, gint width, gint height);
+                                    int bits_per_sample, int width, int height);
 typedef void (*Ptr_gdk_pixbuf_unref)(GdkPixbuf *);
-typedef void (*Ptr_gdk_drawable_unref)(GdkDrawable *);
 typedef void (*Ptr_gdk_x11_window_set_user_time) (GdkWindow *window, guint32);
 typedef XID  (*Ptr_gdk_x11_drawable_get_xid) (GdkDrawable *);
 typedef Display* (*Ptr_gdk_x11_drawable_get_xdisplay) ( GdkDrawable *);
@@ -290,6 +257,7 @@ extern Q_WIDGETS_EXPORT _qt_filedialog_save_filename_hook qt_filedialog_save_fil
 extern Q_WIDGETS_EXPORT _qt_filedialog_existing_directory_hook qt_filedialog_existing_directory_hook;
 #endif //!QT_NO_FILEDIALOG
 
+class QGtkPainter;
 class QGtkStylePrivate;
 
 class QGtkStyleFilter : public QObject
@@ -334,6 +302,7 @@ public:
 
     QGtkStyleFilter filter;
 
+    static QGtkPainter* gtkPainter(QPainter *painter = 0);
     static GtkWidget* gtkWidget(const QHashableLatin1Literal &path);
     static GtkStyle* gtkStyle(const QHashableLatin1Literal &path = QHashableLatin1Literal("GtkWindow"));
     static void gtkWidgetSetFocus(GtkWidget *widget, bool focus);
@@ -424,23 +393,8 @@ public:
     static Ptr_gtk_fixed_new gtk_fixed_new;
     static Ptr_gtk_tree_view_column_new gtk_tree_view_column_new;
     static Ptr_gtk_tree_view_append_column gtk_tree_view_append_column;
-    static Ptr_gtk_paint_check gtk_paint_check;
-    static Ptr_gtk_paint_box gtk_paint_box;
-    static Ptr_gtk_paint_box_gap gtk_paint_box_gap;
-    static Ptr_gtk_paint_flat_box gtk_paint_flat_box;
-    static Ptr_gtk_paint_option gtk_paint_option;
-    static Ptr_gtk_paint_extension gtk_paint_extension;
-    static Ptr_gtk_paint_slider gtk_paint_slider;
-    static Ptr_gtk_paint_shadow gtk_paint_shadow;
-    static Ptr_gtk_paint_resize_grip gtk_paint_resize_grip;
-    static Ptr_gtk_paint_focus gtk_paint_focus;
-    static Ptr_gtk_paint_arrow gtk_paint_arrow;
-    static Ptr_gtk_paint_handle gtk_paint_handle;
-    static Ptr_gtk_paint_expander gtk_paint_expander;
     static Ptr_gtk_adjustment_configure gtk_adjustment_configure;
     static Ptr_gtk_adjustment_new gtk_adjustment_new;
-    static Ptr_gtk_paint_vline gtk_paint_vline;
-    static Ptr_gtk_paint_hline gtk_paint_hline;
     static Ptr_gtk_menu_item_set_submenu gtk_menu_item_set_submenu;
     static Ptr_gtk_settings_get_default gtk_settings_get_default;
     static Ptr_gtk_separator_menu_item_new gtk_separator_menu_item_new;
@@ -488,12 +442,8 @@ public:
     static Ptr_gdk_pixbuf_get_pixels gdk_pixbuf_get_pixels;
     static Ptr_gdk_pixbuf_get_width gdk_pixbuf_get_width;
     static Ptr_gdk_pixbuf_get_height gdk_pixbuf_get_height;
-    static Ptr_gdk_pixmap_new gdk_pixmap_new;
     static Ptr_gdk_pixbuf_new gdk_pixbuf_new;
-    static Ptr_gdk_pixbuf_get_from_drawable gdk_pixbuf_get_from_drawable;
-    static Ptr_gdk_draw_rectangle gdk_draw_rectangle;
     static Ptr_gdk_pixbuf_unref gdk_pixbuf_unref;
-    static Ptr_gdk_drawable_unref gdk_drawable_unref;
     static Ptr_gdk_color_free gdk_color_free;
     static Ptr_gdk_x11_window_set_user_time gdk_x11_window_set_user_time;
     static Ptr_gdk_x11_drawable_get_xid gdk_x11_drawable_get_xid;
diff --git a/src/widgets/styles/styles.pri b/src/widgets/styles/styles.pri
index 9c5a790..af510dc 100644
--- a/src/widgets/styles/styles.pri
+++ b/src/widgets/styles/styles.pri
@@ -99,11 +99,14 @@ contains( styles, windowsxp ) {
 }
 
 contains( styles, gtk ) {
+        HEADERS += styles/qgtkglobal_p.h
         HEADERS += styles/qgtkstyle.h
         HEADERS += styles/qgtkpainter_p.h
+        HEADERS += styles/qgtk2painter_p.h
         HEADERS += styles/qgtkstyle_p.h
         SOURCES += styles/qgtkstyle.cpp
         SOURCES += styles/qgtkpainter.cpp
+        SOURCES += styles/qgtk2painter.cpp
         SOURCES += styles/qgtkstyle_p.cpp
 } else {
     DEFINES += QT_NO_STYLE_GTK