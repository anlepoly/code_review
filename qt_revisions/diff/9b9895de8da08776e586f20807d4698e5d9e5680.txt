diff --git a/src/plugins/platforms/windows/accessible/qwindowsaccessibility.cpp b/src/plugins/platforms/windows/accessible/qwindowsaccessibility.cpp
index 6f2a601..21d0b83 100644
--- a/src/plugins/platforms/windows/accessible/qwindowsaccessibility.cpp
+++ b/src/plugins/platforms/windows/accessible/qwindowsaccessibility.cpp
@@ -84,10 +84,6 @@
 #include <comdef.h>
 #endif
 
-#ifdef Q_OS_WINCE
-#include "../qguifunctions_wince.h"
-#endif
-
 #include "../qtwindows_additional.h"
 
 
diff --git a/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.cpp b/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.cpp
index fafe624..b8d46fe 100644
--- a/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.cpp
+++ b/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.cpp
@@ -72,9 +72,6 @@
 #include <comdef.h>
 #endif
 
-#ifdef Q_OS_WINCE
-#include "../qguifunctions_wince.h"
-#endif
 
 #include "../qtwindows_additional.h"
 
diff --git a/src/plugins/platforms/windows/qplatformfunctions_wince.h b/src/plugins/platforms/windows/qplatformfunctions_wince.h
new file mode 100644
index 0000000..0e6a859
--- /dev/null
+++ b/src/plugins/platforms/windows/qplatformfunctions_wince.h
@@ -0,0 +1,325 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QPLATFORMFUNCTIONS_WCE_H
+#define QPLATFORMFUNCTIONS_WCE_H
+
+#ifdef Q_OS_WINCE
+#include <QtCore/qfunctions_wince.h>
+#define UNDER_NT
+#include <wingdi.h>
+#include <objidl.h>
+
+#ifndef WM_MOUSELEAVE
+# define WM_MOUSELEAVE                   0x02A3
+#endif
+
+#ifndef WM_TOUCH
+# define WM_TOUCH 0x0240
+#endif
+
+#ifndef WM_GETOBJECT
+#define WM_GETOBJECT                    0x003D
+#endif
+
+#define GetWindowLongPtr GetWindowLong
+#define SetWindowLongPtr SetWindowLong
+#define GWLP_USERDATA GWL_USERDATA
+
+#ifndef CWP_SKIPINVISIBLE
+#define CWP_SKIPINVISIBLE   0x0001
+#define findPlatformWindowAt(a, b, c) findPlatformWindowAt(a, b)
+#endif
+
+#ifndef CS_OWNDC
+#define CS_OWNDC  0x0020
+#endif
+
+#ifndef HWND_MESSAGE
+#define HWND_MESSAGE 0
+#endif
+
+#ifndef CAPTUREBLT
+#define CAPTUREBLT                   (DWORD)0x40000000
+#endif
+
+#define SW_SHOWMINIMIZED SW_MINIMIZE
+#define SW_SHOWMINNOACTIVE SW_MINIMIZE
+
+#ifndef ChildWindowFromPointEx
+#define ChildWindowFromPointEx(a, b, c) ChildWindowFromPoint(a, b)
+#endif
+
+#ifndef CF_DIBV5
+#define CF_DIBV5            17
+#endif
+
+#ifndef WM_MOUSEACTIVATE
+#define WM_MOUSEACTIVATE 0x0021
+#endif
+
+#ifndef WM_CHILDACTIVATE
+#define WM_CHILDACTIVATE 0x0022
+#endif
+
+#ifndef WM_PARENTNOTIFY
+#define WM_PARENTNOTIFY 0x0210
+#endif
+
+#ifndef WM_ENTERIDLE
+#define WM_ENTERIDLE 0x0121
+#endif
+
+#ifndef WM_GETMINMAXINFO
+#define WM_GETMINMAXINFO 0x0024
+#endif
+
+#ifndef WM_WINDOWPOSCHANGING
+#define WM_WINDOWPOSCHANGING 0x0046
+#endif
+
+#ifndef WM_NCMOUSEMOVE
+#define WM_NCMOUSEMOVE 0x00A0
+#endif
+
+#ifndef WM_NCMBUTTONDBLCLK
+#define WM_NCMBUTTONDBLCLK 0x00A
+#endif
+
+#ifndef WM_NCCREATE
+#define WM_NCCREATE 0x0081
+#endif
+
+#ifndef WM_NCCALCSIZE
+#define WM_NCCALCSIZE 0x0083
+#endif
+
+#ifndef WM_NCACTIVATE
+#define WM_NCACTIVATE 0x0086
+#endif
+
+#ifndef WM_NCMOUSELEAVE
+#define WM_NCMOUSELEAVE 0x02A2
+#endif
+
+#ifndef WM_NCLBUTTONDOWN
+#define WM_NCLBUTTONDOWN 0x00A1
+#endif
+
+#ifndef WM_NCLBUTTONUP
+#define WM_NCLBUTTONUP 0x00A2
+#endif
+
+#ifndef WM_NCPAINT
+#define WM_NCPAINT 0x0085
+#endif
+
+#ifndef WM_NCHITTEST
+#define WM_NCHITTEST 0x0084
+#endif
+
+#ifndef WM_THEMECHANGED
+#define WM_THEMECHANGED 0x031A
+#endif
+
+#ifndef WM_DISPLAYCHANGE
+#define WM_DISPLAYCHANGE 0x007E
+#endif
+
+#ifndef VREFRESH
+#define VREFRESH 116
+#endif
+
+// application defines
+#define SPI_SETNONCLIENTMETRICS 72
+#define SPI_SETICONTITLELOGFONT 0x0022
+#define WM_ACTIVATEAPP 0x001c
+#define SW_PARENTCLOSING    1
+#define SW_OTHERMAXIMIZED   2
+#define SW_PARENTOPENING    3
+#define SW_OTHERRESTORED    4
+#define GET_XBUTTON_WPARAM(wParam)      (HIWORD(wParam))
+
+// drag n drop
+#ifndef CFSTR_PERFORMEDDROPEFFECT
+#define CFSTR_PERFORMEDDROPEFFECT TEXT("Performed DropEffect")
+#endif
+
+// QWidget
+#define SW_SHOWMINIMIZED SW_MINIMIZE
+
+// QRegion
+#define ALTERNATE 0
+#define WINDING 1
+
+// QFontEngine
+typedef struct _FIXED {
+  WORD  fract;
+  short value;
+} FIXED;
+
+typedef struct tagPOINTFX {
+  FIXED x;
+  FIXED y;
+} POINTFX;
+
+typedef struct _MAT2 {
+  FIXED eM11;
+  FIXED eM12;
+  FIXED eM21;
+  FIXED eM22;
+} MAT2;
+
+typedef struct _GLYPHMETRICS {
+    UINT    gmBlackBoxX;
+    UINT    gmBlackBoxY;
+    POINT   gmptGlyphOrigin;
+    short   gmCellIncX;
+    short   gmCellIncY;
+} GLYPHMETRICS;
+
+typedef struct tagTTPOLYGONHEADER
+{
+    DWORD   cb;
+    DWORD   dwType;
+    POINTFX pfxStart;
+} TTPOLYGONHEADER;
+
+typedef struct tagTTPOLYCURVE
+{
+    WORD    wType;
+    WORD    cpfx;
+    POINTFX apfx[1];
+} TTPOLYCURVE;
+
+#define GGO_NATIVE 2
+#define GGO_GLYPH_INDEX 0x0080
+#define TT_PRIM_LINE 1
+#define TT_PRIM_QSPLINE 2
+#define TT_PRIM_CSPLINE 3
+#define ANSI_VAR_FONT 12
+
+#ifndef OleInitialize
+#define OleInitialize(a) 0
+#endif
+
+#ifndef SPI_GETSNAPTODEFBUTTON
+#define SPI_GETSNAPTODEFBUTTON  95
+#endif
+
+#ifndef WS_EX_LAYERED
+#define WS_EX_LAYERED 0x00080000
+#endif
+
+// Clipboard --------------------------------------------------------
+#ifndef WM_CHANGECBCHAIN
+#define WM_CHANGECBCHAIN 0x030D
+#endif
+
+#ifndef WM_DRAWCLIPBOARD
+#define WM_DRAWCLIPBOARD 0x0308
+#endif
+
+inline bool IsIconic( HWND /*hWnd*/ )
+{
+    return false;
+}
+
+inline bool IsZoomed( HWND /*hWnd*/ )
+{
+    return true;
+}
+
+inline int AddFontResourceExW( LPCWSTR /*name*/, DWORD /*fl*/, PVOID /*res*/)
+{
+    return 0;
+}
+
+inline bool RemoveFontResourceExW( LPCWSTR /*name*/, DWORD /*fl*/, PVOID /*pdv*/)
+{
+    return 0;
+}
+
+inline void OleUninitialize()
+{
+}
+
+inline DWORD GetGlyphOutline( HDC /*hdc*/, UINT /*uChar*/, INT /*fuFormat*/, GLYPHMETRICS * /*lpgm*/,
+                       DWORD /*cjBuffer*/, LPVOID /*pvBuffer*/, CONST MAT2 * /*lpmat2*/ )
+{
+    return GDI_ERROR;
+}
+
+#ifndef SPI_SETFONTSMOOTHINGTYPE
+#  define SPI_SETFONTSMOOTHINGTYPE 0x200B
+#endif
+#ifndef SPI_GETFONTSMOOTHINGTYPE
+#  define SPI_GETFONTSMOOTHINGTYPE 0x200A
+#endif
+#ifndef FE_FONTSMOOTHINGCLEARTYPE
+#  define FE_FONTSMOOTHINGCLEARTYPE 0x0002
+#endif
+
+#ifndef DEVICE_FONTTYPE
+#define DEVICE_FONTTYPE 0x0002
+#endif
+
+#ifndef RASTER_FONTTYPE
+#define RASTER_FONTTYPE 0x0001
+#endif
+
+#ifndef WM_DISPLAYCHANGE
+#define WM_DISPLAYCHANGE 0x007E
+#endif
+
+BOOL qt_wince_ChangeClipboardChain(
+    HWND hWndRemove,  // handle to window to remove
+    HWND hWndNewNext  // handle to next window
+);
+#define ChangeClipboardChain(a,b) qt_wince_ChangeClipboardChain(a,b);
+
+HWND qt_wince_SetClipboardViewer(
+    HWND hWndNewViewer   // handle to clipboard viewer window
+);
+#define SetClipboardViewer(a) qt_wince_SetClipboardViewer(a)
+
+#endif // Q_OS_WINCE
+#endif // QPLATFORMFUNCTIONS_WCE_H
diff --git a/src/plugins/platforms/windows/qtwindowsglobal.h b/src/plugins/platforms/windows/qtwindowsglobal.h
index 27cfbdc..ab23b06 100644
--- a/src/plugins/platforms/windows/qtwindowsglobal.h
+++ b/src/plugins/platforms/windows/qtwindowsglobal.h
@@ -44,6 +44,9 @@
 
 #include "qtwindows_additional.h"
 #include <QtCore/qnamespace.h>
+#ifdef Q_OS_WINCE
+#  include "qplatformfunctions_wince.h"
+#endif
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/platforms/windows/qwindowsclipboard.cpp b/src/plugins/platforms/windows/qwindowsclipboard.cpp
index 4166e56..41f22d5 100644
--- a/src/plugins/platforms/windows/qwindowsclipboard.cpp
+++ b/src/plugins/platforms/windows/qwindowsclipboard.cpp
@@ -98,79 +98,6 @@ QDebug operator<<(QDebug d, const QMimeData &m)
 }
 
 /*!
-    \class QWindowsInternalMimeDataBase
-    \brief Base for implementations of QInternalMimeData using a IDataObject COM object.
-
-    In clipboard handling and Drag and drop, static instances
-    of QInternalMimeData implementations are kept and passed to the client.
-
-    QInternalMimeData provides virtuals that query the formats and retrieve
-    mime data on demand when the client invokes functions like QMimeData::hasHtml(),
-    QMimeData::html() on the instance returned. Otherwise, expensive
-    construction of a new QMimeData object containing all possible
-    formats would have to be done in each call to mimeData().
-
-    The base class introduces new virtuals to obtain and release
-    the instances IDataObject from the clipboard or Drag and Drop and
-    does conversion using QWindowsMime classes.
-
-    \sa QInternalMimeData, QWindowsMime, QWindowsMimeConverter
-    \ingroup qt-lighthouse-win
-*/
-
-bool QWindowsInternalMimeData::hasFormat_sys(const QString &mime) const
-{
-    IDataObject *pDataObj = retrieveDataObject();
-    if (!pDataObj)
-        return false;
-
-    const QWindowsMimeConverter &mc = QWindowsContext::instance()->mimeConverter();
-    const bool has = mc.converterToMime(mime, pDataObj) != 0;
-    releaseDataObject(pDataObj);
-    if (QWindowsContext::verboseOLE)
-        qDebug() << __FUNCTION__ <<  mime << has;
-    return has;
-}
-
-QStringList QWindowsInternalMimeData::formats_sys() const
-{
-    IDataObject *pDataObj = retrieveDataObject();
-    if (!pDataObj)
-        return QStringList();
-
-    const QWindowsMimeConverter &mc = QWindowsContext::instance()->mimeConverter();
-    const QStringList fmts = mc.allMimesForFormats(pDataObj);
-    releaseDataObject(pDataObj);
-    if (QWindowsContext::verboseOLE)
-        qDebug() << __FUNCTION__ <<  fmts;
-    return fmts;
-}
-
-QVariant QWindowsInternalMimeData::retrieveData_sys(const QString &mimeType,
-                                                        QVariant::Type type) const
-{
-    IDataObject *pDataObj = retrieveDataObject();
-    if (!pDataObj)
-        return QVariant();
-
-    QVariant result;
-    const QWindowsMimeConverter &mc = QWindowsContext::instance()->mimeConverter();
-    if (const QWindowsMime *converter = mc.converterToMime(mimeType, pDataObj))
-        result = converter->convertToMime(mimeType, pDataObj, type);
-    releaseDataObject(pDataObj);
-#ifndef QT_NO_DEBUG_OUTPUT
-    if (QWindowsContext::verboseOLE) {
-        QDebug nospace = qDebug().nospace();
-        nospace << __FUNCTION__ <<  ' '  << mimeType << ' ' << type
-                << " returns " << result.type();
-        if (result.type() != QVariant::ByteArray)
-            nospace << ' ' << result;
-    }
-#endif
-    return result;
-}
-
-/*!
     \class QWindowsClipboardRetrievalMimeData
     \brief Special mime data class managing delayed retrieval of clipboard data.
 
diff --git a/src/plugins/platforms/windows/qwindowscontext.cpp b/src/plugins/platforms/windows/qwindowscontext.cpp
index 3a21135..f44ce38 100644
--- a/src/plugins/platforms/windows/qwindowscontext.cpp
+++ b/src/plugins/platforms/windows/qwindowscontext.cpp
@@ -113,6 +113,9 @@ static inline bool hasTouchSupport(QSysInfo::WinVersion wv)
 
 static inline bool useRTL_Extensions(QSysInfo::WinVersion ver)
 {
+    // This is SDK dependent on CE so out of scope for now
+    if (QSysInfo::windowsVersion() & QSysInfo::WV_CE_based)
+        return false;
     if ((ver & QSysInfo::WV_NT_based) && (ver >= QSysInfo::WV_VISTA)) {
         // Since the IsValidLanguageGroup/IsValidLocale functions always return true on
         // Vista, check the Keyboard Layouts for enabling RTL.
@@ -133,6 +136,7 @@ static inline bool useRTL_Extensions(QSysInfo::WinVersion ver)
         }
         return false;
     } // NT/Vista
+#ifndef Q_OS_WINCE
     // Pre-NT: figure out whether a RTL language is installed
     return IsValidLanguageGroup(LGRPID_ARABIC, LGRPID_INSTALLED)
                             || IsValidLanguageGroup(LGRPID_HEBREW, LGRPID_INSTALLED)
@@ -140,6 +144,9 @@ static inline bool useRTL_Extensions(QSysInfo::WinVersion ver)
                             || IsValidLocale(MAKELCID(MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT), SORT_DEFAULT), LCID_INSTALLED)
                             || IsValidLocale(MAKELCID(MAKELANGID(LANG_SYRIAC, SUBLANG_DEFAULT), SORT_DEFAULT), LCID_INSTALLED)
                             || IsValidLocale(MAKELCID(MAKELANGID(LANG_FARSI, SUBLANG_DEFAULT), SORT_DEFAULT), LCID_INSTALLED);
+#else
+    return false;
+#endif
 }
 
 /*!
@@ -157,6 +164,8 @@ static inline bool useRTL_Extensions(QSysInfo::WinVersion ver)
     \ingroup qt-lighthouse-win
 */
 
+#ifndef Q_OS_WINCE
+
 QWindowsUser32DLL::QWindowsUser32DLL() :
     setLayeredWindowAttributes(0), updateLayeredWindow(0),
     updateLayeredWindowIndirect(0),
@@ -212,6 +221,8 @@ void QWindowsShell32DLL::init()
 QWindowsUser32DLL QWindowsContext::user32dll;
 QWindowsShell32DLL QWindowsContext::shell32dll;
 
+#endif // !Q_OS_WINCE
+
 QWindowsContext *QWindowsContext::m_instance = 0;
 
 /*!
@@ -257,13 +268,16 @@ QWindowsContextPrivate::QWindowsContextPrivate() :
     m_oleInitializeResult(OleInitialize(NULL)),
     m_eventType(QByteArrayLiteral("windows_generic_MSG"))
 {
+#ifndef Q_OS_WINCE
     QWindowsContext::user32dll.init();
     QWindowsContext::shell32dll.init();
+#endif
 
     const QSysInfo::WinVersion ver = QSysInfo::windowsVersion();
-
+#ifndef Q_OS_WINCE
     if (hasTouchSupport(ver) && QWindowsContext::user32dll.initTouch())
         m_systemInfo |= QWindowsContext::SI_SupportsTouch;
+#endif
 
     if (useRTL_Extensions(ver)) {
         m_systemInfo |= QWindowsContext::SI_RTL_Extensions;
@@ -279,7 +293,9 @@ QWindowsContext::QWindowsContext() :
 #    pragma warning( disable : 4996 )
 #endif
     m_instance = this;
-    if (const char *v = getenv("QT_QPA_VERBOSE")) {
+    const QByteArray bv = qgetenv("QT_QPA_VERBOSE");
+    if (bv.isEmpty()) {
+        const char *v = bv.data();
         QWindowsContext::verboseIntegration = componentVerbose(v, "integration");
         QWindowsContext::verboseWindows = componentVerbose(v, "windows");
         QWindowsContext::verboseEvents = componentVerbose(v, "events");
@@ -419,13 +435,20 @@ QString QWindowsContext::registerWindowClass(QString cname,
     if (d->m_registeredWindowClassNames.contains(cname))        // already registered in our list
         return cname;
 
+#ifndef Q_OS_WINCE
     WNDCLASSEX wc;
     wc.cbSize       = sizeof(WNDCLASSEX);
+#else
+    WNDCLASS wc;
+#endif
     wc.style        = style;
     wc.lpfnWndProc  = proc;
     wc.cbClsExtra   = 0;
     wc.cbWndExtra   = 0;
     wc.hInstance    = appInstance;
+    wc.hCursor      = 0;
+#ifndef Q_OS_WINCE
+    wc.hbrBackground = brush;
     if (icon) {
         wc.hIcon = (HICON)LoadImage(appInstance, L"IDI_ICON1", IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
         if (wc.hIcon) {
@@ -440,11 +463,21 @@ QString QWindowsContext::registerWindowClass(QString cname,
         wc.hIcon    = 0;
         wc.hIconSm  = 0;
     }
-    wc.hCursor      = 0;
-    wc.hbrBackground = brush;
+#else
+    if (icon) {
+        wc.hIcon = (HICON)LoadImage(appInstance, L"IDI_ICON1", IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
+    } else {
+        wc.hIcon    = 0;
+    }
+#endif
+
     wc.lpszMenuName  = 0;
     wc.lpszClassName = (wchar_t*)cname.utf16();
+#ifndef Q_OS_WINCE
     ATOM atom = RegisterClassEx(&wc);
+#else
+    ATOM atom = RegisterClass(&wc);
+#endif
 
     if (!atom)
         qErrnoWarning("QApplication::regClass: Registering window class '%s' failed.",
@@ -719,9 +752,11 @@ bool QWindowsContext::windowsProc(HWND hwnd, UINT message,
     // Pass on to current creation context
     if (!platformWindow && !d->m_creationContext.isNull()) {
         switch (et) {
+#ifndef Q_OS_WINCE // maybe available on some SDKs revisit WM_GETMINMAXINFO
         case QtWindows::QuerySizeHints:
             d->m_creationContext->applyToMinMaxInfo(reinterpret_cast<MINMAXINFO *>(lParam));
             return true;
+#endif
         case QtWindows::ResizeEvent:
             d->m_creationContext->obtainedGeometry.setSize(QSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)));
             return true;
@@ -762,9 +797,10 @@ bool QWindowsContext::windowsProc(HWND hwnd, UINT message,
     case QtWindows::ResizeEvent:
         platformWindow->handleResized((int)wParam);
         return true;
+#ifndef Q_OS_WINCE // maybe available on some SDKs revisit WM_GETMINMAXINFO
     case QtWindows::QuerySizeHints:
         platformWindow->getSizeHints(reinterpret_cast<MINMAXINFO *>(lParam));
-        return true;
+        return true;// maybe available on some SDKs revisit WM_NCCALCSIZE
     case QtWindows::CalculateSize:
         // NCCALCSIZE_PARAMS structure if wParam==TRUE
         if (wParam && QWindowsContext::verboseWindows) {
@@ -772,6 +808,7 @@ bool QWindowsContext::windowsProc(HWND hwnd, UINT message,
             qDebug() << platformWindow->window() << *ncp;
         }
         break;
+#endif
     case QtWindows::ExposeEvent:
         return platformWindow->handleWmPaint(hwnd, message, wParam, lParam);
     case QtWindows::MouseWheelEvent:
@@ -800,11 +837,13 @@ bool QWindowsContext::windowsProc(HWND hwnd, UINT message,
         if (QWindowsTheme *theme = QWindowsTheme::instance())
             theme->windowsThemeChanged(platformWindow->window());
         return true;
+#ifndef Q_OS_WINCE
     case QtWindows::ActivateWindowEvent:
         if (platformWindow->testFlag(QWindowsWindow::BlockedByModal))
             if (const QWindow *modalWindow = QGuiApplication::modalWindow())
                 QWindowsWindow::baseWindowOf(modalWindow)->alertWindow();
         break;
+#endif
     default:
         break;
     }
diff --git a/src/plugins/platforms/windows/qwindowscontext.h b/src/plugins/platforms/windows/qwindowscontext.h
index 9f16ed2..983f940 100644
--- a/src/plugins/platforms/windows/qwindowscontext.h
+++ b/src/plugins/platforms/windows/qwindowscontext.h
@@ -59,6 +59,7 @@ struct QWindowCreationContext;
 struct QWindowsContextPrivate;
 class QPoint;
 
+#ifndef Q_OS_WINCE
 struct QWindowsUser32DLL
 {
     QWindowsUser32DLL();
@@ -98,6 +99,7 @@ struct QWindowsShell32DLL
 
     SHCreateItemFromParsingName sHCreateItemFromParsingName;
 };
+#endif // Q_OS_WINCE
 
 class QWindowsContext
 {
@@ -169,9 +171,10 @@ public:
 
     QWindowsMimeConverter &mimeConverter() const;
     QWindowsScreenManager &screenManager();
-
+#ifndef Q_OS_WINCE
     static QWindowsUser32DLL user32dll;
     static QWindowsShell32DLL shell32dll;
+#endif
 
     static QByteArray comErrorString(HRESULT hr);
 
diff --git a/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp b/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
index e283848..b4a6834 100644
--- a/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
+++ b/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
@@ -725,6 +725,7 @@ void QWindowsNativeFileDialogBase::setWindowTitle(const QString &title)
 
 IShellItem *QWindowsNativeFileDialogBase::shellItem(const QString &path)
 {
+#ifndef Q_OS_WINCE
     if (QWindowsContext::shell32dll.sHCreateItemFromParsingName) {
         IShellItem *result = 0;
         const QString native = QDir::toNativeSeparators(path);
@@ -735,6 +736,7 @@ IShellItem *QWindowsNativeFileDialogBase::shellItem(const QString &path)
         if (SUCCEEDED(hr))
             return result;
     }
+#endif
     qErrnoWarning("%s: SHCreateItemFromParsingName()) failed", __FUNCTION__);
     return 0;
 }
@@ -749,9 +751,11 @@ void QWindowsNativeFileDialogBase::setDirectory(const QString &directory)
 
 QString QWindowsNativeFileDialogBase::directory() const
 {
+#ifndef Q_OS_WINCE
     IShellItem *item = 0;
     if (m_fileDialog && SUCCEEDED(m_fileDialog->GetFolder(&item)) && item)
         return QWindowsNativeFileDialogBase::itemPath(item);
+#endif
     return QString();
 }
 
@@ -1230,6 +1234,7 @@ QString QWindowsFileDialogHelper::selectedNameFilter() const
 
 typedef QSharedPointer<QColor> SharedPointerColor;
 
+#ifdef USE_NATIVE_COLOR_DIALOG
 class QWindowsNativeColorDialog : public QWindowsNativeDialogBase
 {
     Q_OBJECT
@@ -1336,6 +1341,7 @@ QWindowsNativeDialogBase *QWindowsColorDialogHelper::createNativeDialog()
     nativeDialog->setWindowTitle(options()->windowTitle());
     return nativeDialog;
 }
+#endif // USE_NATIVE_COLOR_DIALOG
 
 namespace QWindowsDialogs {
 
diff --git a/src/plugins/platforms/windows/qwindowsdrag.cpp b/src/plugins/platforms/windows/qwindowsdrag.cpp
index d75752b..d377e51 100644
--- a/src/plugins/platforms/windows/qwindowsdrag.cpp
+++ b/src/plugins/platforms/windows/qwindowsdrag.cpp
@@ -41,7 +41,9 @@
 
 #include "qwindowsdrag.h"
 #include "qwindowscontext.h"
-#include "qwindowsclipboard.h"
+#ifndef QT_NO_CLIPBOARD
+#  include "qwindowsclipboard.h"
+#endif
 #include "qwindowsintegration.h"
 #include "qwindowsole.h"
 #include "qtwindows_additional.h"
diff --git a/src/plugins/platforms/windows/qwindowsfontdatabase.cpp b/src/plugins/platforms/windows/qwindowsfontdatabase.cpp
index caa1913..7e8c70e 100644
--- a/src/plugins/platforms/windows/qwindowsfontdatabase.cpp
+++ b/src/plugins/platforms/windows/qwindowsfontdatabase.cpp
@@ -55,9 +55,13 @@
 
 #include <wchar.h>
 
+#ifdef Q_OS_WINCE
+#  include "qplatformfunctions_wince.h"
+#endif
+
 #if !defined(QT_NO_DIRECTWRITE)
-#    include <dwrite.h>
-#    include <d2d1.h>
+#  include <dwrite.h>
+#  include <d2d1.h>
 #endif
 
 QT_BEGIN_NAMESPACE
@@ -1002,6 +1006,17 @@ static bool addFontToDatabase(QString familyName, const QString &scriptName,
         quint32 codePageRange[2] = {
             signature->fsCsb[0], signature->fsCsb[1]
         };
+#ifdef Q_OS_WINCE
+        if (signature->fsUsb[0] == 0) {
+            // If the unicode ranges bit mask is zero then
+            // EnumFontFamiliesEx failed to determine it properly.
+            // In this case we just pretend that the font supports all languages.
+            unicodeRange[0] = 0xbfffffff;   // second most significant bit must be zero
+            unicodeRange[1] = 0xffffffff;
+            unicodeRange[2] = 0xffffffff;
+            unicodeRange[3] = 0xffffffff;
+        }
+#endif
         writingSystemsFromTrueTypeBits(unicodeRange, codePageRange, &writingSystems);
         // ### Hack to work around problem with Thai text on Windows 7. Segoe UI contains
         // the symbol for Baht, and Windows thus reports that it supports the Thai script.
@@ -1603,6 +1618,7 @@ QFontEngine *QWindowsFontDatabase::createEngine(int script, const QFontDef &requ
         const QString fam = request.family.toLower();
         if (fam == QStringLiteral("default") || fam == QStringLiteral("system"))
             f = SYSTEM_FONT;
+#ifndef Q_OS_WINCE
         else if (fam == QStringLiteral("system_fixed"))
             f = SYSTEM_FIXED_FONT;
         else if (fam == QStringLiteral("ansi_fixed"))
@@ -1613,6 +1629,7 @@ QFontEngine *QWindowsFontDatabase::createEngine(int script, const QFontDef &requ
             f = DEVICE_DEFAULT_FONT;
         else if (fam == QStringLiteral("oem_fixed"))
             f = OEM_FIXED_FONT;
+#endif
         else if (fam.at(0) == QLatin1Char('#'))
             f = fam.right(fam.length()-1).toInt();
         hfont = (HFONT)GetStockObject(f);
@@ -1657,12 +1674,14 @@ QFontEngine *QWindowsFontDatabase::createEngine(int script, const QFontDef &requ
         int strat = OUT_DEFAULT_PRECIS;
         if (request.styleStrategy & QFont::PreferBitmap) {
             strat = OUT_RASTER_PRECIS;
+#ifndef Q_OS_WINCE
         } else if (request.styleStrategy & QFont::PreferDevice) {
             strat = OUT_DEVICE_PRECIS;
         } else if (request.styleStrategy & QFont::PreferOutline) {
             strat = OUT_OUTLINE_PRECIS;
         } else if (request.styleStrategy & QFont::ForceOutline) {
             strat = OUT_TT_ONLY_PRECIS;
+#endif
         }
 
         lf.lfOutPrecision   = strat;
@@ -1671,8 +1690,10 @@ QFontEngine *QWindowsFontDatabase::createEngine(int script, const QFontDef &requ
 
         if (request.styleStrategy & QFont::PreferMatch)
             qual = DRAFT_QUALITY;
+#ifndef Q_OS_WINCE
         else if (request.styleStrategy & QFont::PreferQuality)
             qual = PROOF_QUALITY;
+#endif
 
         if (request.styleStrategy & QFont::PreferAntialias) {
             if (QSysInfo::WindowsVersion >= QSysInfo::WV_XP) {
@@ -1733,10 +1754,17 @@ QFontEngine *QWindowsFontDatabase::createEngine(int script, const QFontDef &requ
                     qErrnoWarning("%s: CreateFontIndirect with stretch failed", __FUNCTION__);
             }
 
+#ifndef Q_OS_WINCE
             if (hfont == 0) {
                 hfont = (HFONT)GetStockObject(ANSI_VAR_FONT);
                 stockFont = true;
             }
+#else
+            if (hfont == 0) {
+                hfont = (HFONT)GetStockObject(SYSTEM_FONT);
+                stockFont = true;
+            }
+#endif
         }
 
 #if !defined(QT_NO_DIRECTWRITE)
diff --git a/src/plugins/platforms/windows/qwindowsfontengine.cpp b/src/plugins/platforms/windows/qwindowsfontengine.cpp
index e367707..801dba2 100644
--- a/src/plugins/platforms/windows/qwindowsfontengine.cpp
+++ b/src/plugins/platforms/windows/qwindowsfontengine.cpp
@@ -70,6 +70,10 @@
 
 #include <limits.h>
 
+#ifdef Q_OS_WINCE
+#  include "qplatformfunctions_wince.h"
+#endif
+
 QT_BEGIN_NAMESPACE
 
 //### mingw needed define
@@ -199,6 +203,9 @@ int QWindowsFontEngine::getGlyphIndexes(const QChar *str, int numChars, QGlyphLa
     int i = 0;
     int glyph_pos = 0;
     if (mirrored) {
+#if defined(Q_OS_WINCE)
+        {
+#else
         if (symbol) {
             for (; i < numChars; ++i, ++glyph_pos) {
                 unsigned int uc = getChar(str, i, numChars);
@@ -212,18 +219,26 @@ int QWindowsFontEngine::getGlyphIndexes(const QChar *str, int numChars, QGlyphLa
                 glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, QChar::mirroredChar(uc));
             }
         } else {
+#endif
             wchar_t first = tm.tmFirstChar;
             wchar_t last = tm.tmLastChar;
 
             for (; i < numChars; ++i, ++glyph_pos) {
                 uint ucs = QChar::mirroredChar(getChar(str, i, numChars));
-                if (ucs >= first && ucs <= last)
+                if (
+#ifdef Q_WS_WINCE
+                    tm.tmFirstChar > 60000 ||
+#endif
+                         ucs >= first && ucs <= last)
                     glyphs->glyphs[glyph_pos] = ucs;
                 else
                     glyphs->glyphs[glyph_pos] = 0;
             }
         }
     } else {
+#if defined(Q_OS_WINCE)
+        {
+#else
         if (symbol) {
             for (; i < numChars; ++i, ++glyph_pos) {
                 unsigned int uc = getChar(str, i, numChars);
@@ -237,12 +252,17 @@ int QWindowsFontEngine::getGlyphIndexes(const QChar *str, int numChars, QGlyphLa
                 glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
             }
         } else {
+#endif
             wchar_t first = tm.tmFirstChar;
             wchar_t last = tm.tmLastChar;
 
             for (; i < numChars; ++i, ++glyph_pos) {
                 uint uc = getChar(str, i, numChars);
-                if (uc >= first && uc <= last)
+                if (
+#ifdef Q_WS_WINCE
+                    tm.tmFirstChar > 60000 ||
+#endif
+                         uc >= first && uc <= last)
                     glyphs->glyphs[glyph_pos] = uc;
                 else
                     glyphs->glyphs[glyph_pos] = 0;
@@ -353,8 +373,12 @@ bool QWindowsFontEngine::stringToCMap(const QChar *str, int len, QGlyphLayout *g
 
 inline void calculateTTFGlyphWidth(HDC hdc, UINT glyph, int &width)
 {
+#if defined(Q_OS_WINCE)
+    GetCharWidth32(hdc, glyph, glyph, &width);
+#else
     if (ptrGetCharWidthI)
         ptrGetCharWidthI(hdc, glyph, 1, 0, &width);
+#endif
 }
 
 void QWindowsFontEngine::recalcAdvances(QGlyphLayout *glyphs, QTextEngine::ShaperFlags flags) const
@@ -442,7 +466,7 @@ glyph_metrics_t QWindowsFontEngine::boundingBox(const QGlyphLayout &glyphs)
 
     return glyph_metrics_t(0, -tm.tmAscent, w - lastRightBearing(glyphs), tm.tmHeight, w, 0);
 }
-
+#ifndef Q_OS_WINCE
 bool QWindowsFontEngine::getOutlineMetrics(glyph_t glyph, const QTransform &t, glyph_metrics_t *metrics) const
 {
     Q_ASSERT(metrics != 0);
@@ -494,9 +518,11 @@ bool QWindowsFontEngine::getOutlineMetrics(glyph_t glyph, const QTransform &t, g
         return false;
     }
 }
+#endif
 
 glyph_metrics_t QWindowsFontEngine::boundingBox(glyph_t glyph, const QTransform &t)
 {
+#ifndef Q_OS_WINCE
     HDC hdc = m_fontEngineData->hdc;
     SelectObject(hdc, hfont);
 
@@ -514,6 +540,34 @@ glyph_metrics_t QWindowsFontEngine::boundingBox(glyph_t glyph, const QTransform
     }
 
     return glyphMetrics;
+#else
+    HDC hdc = m_fontEngineData->hdc;
+    HGDIOBJ oldFont = SelectObject(hdc, hfont);
+
+    ABC abc;
+    int width;
+    int advance;
+#ifdef GWES_MGTT    // true type fonts
+    if (GetCharABCWidths(hdc, glyph, glyph, &abc)) {
+        width = qAbs(abc.abcA) + abc.abcB + qAbs(abc.abcC);
+        advance = abc.abcA + abc.abcB + abc.abcC;
+    }
+    else
+#endif
+#if defined(GWES_MGRAST) || defined(GWES_MGRAST2)   // raster fonts
+    if (GetCharWidth32(hdc, glyph, glyph, &width)) {
+        advance = width;
+    }
+    else
+#endif
+    {   // fallback
+        width = tm.tmMaxCharWidth;
+        advance = width;
+    }
+
+    SelectObject(hdc, oldFont);
+    return glyph_metrics_t(0, -tm.tmAscent, width, tm.tmHeight, advance, 0).transformed(t);
+#endif
 }
 
 QFixed QWindowsFontEngine::ascent() const
@@ -580,7 +634,9 @@ void QWindowsFontEngine::getGlyphBearings(glyph_t glyph, qreal *leftBearing, qre
     HDC hdc = m_fontEngineData->hdc;
     SelectObject(hdc, hfont);
 
+#ifndef Q_OS_WINCE
     if (ttf)
+#endif
     {
         ABC abcWidths;
         GetCharABCWidthsI(hdc, glyph, 1, 0, &abcWidths);
@@ -588,9 +644,12 @@ void QWindowsFontEngine::getGlyphBearings(glyph_t glyph, qreal *leftBearing, qre
             *leftBearing = abcWidths.abcA;
         if (rightBearing)
             *rightBearing = abcWidths.abcC;
-    } else {
+    }
+#ifndef Q_OS_WINCE
+    else {
         QFontEngine::getGlyphBearings(glyph, leftBearing, rightBearing);
     }
+#endif
 }
 #endif // Q_CC_MINGW
 
@@ -604,6 +663,7 @@ qreal QWindowsFontEngine::minLeftBearing() const
 
 qreal QWindowsFontEngine::minRightBearing() const
 {
+#ifndef Q_OS_WINCE
     if (rbearing == SHRT_MIN) {
         int ml = 0;
         int mr = 0;
@@ -659,6 +719,40 @@ qreal QWindowsFontEngine::minRightBearing() const
     }
 
     return rbearing;
+#else // !Q_OS_WINCE
+    if (rbearing == SHRT_MIN) {
+        int ml = 0;
+        int mr = 0;
+        HDC hdc = m_fontEngineData->hdc;
+        SelectObject(hdc, hfont);
+        if (ttf) {
+            ABC *abc = 0;
+            int n = tm.tmLastChar - tm.tmFirstChar;
+            if (n <= max_font_count) {
+                abc = new ABC[n+1];
+                GetCharABCWidths(hdc, tm.tmFirstChar, tm.tmLastChar, abc);
+            } else {
+                abc = new ABC[char_table_entries+1];
+                for (int i = 0; i < char_table_entries; i++)
+                    GetCharABCWidths(hdc, char_table[i], char_table[i], abc+i);
+                n = char_table_entries;
+            }
+            ml = abc[0].abcA;
+            mr = abc[0].abcC;
+            for (int i = 1; i < n; i++) {
+                if (abc[i].abcA + abc[i].abcB + abc[i].abcC != 0) {
+                    ml = qMin(ml,abc[i].abcA);
+                    mr = qMin(mr,abc[i].abcC);
+                }
+            }
+            delete [] abc;
+        }
+        lbearing = ml;
+        rbearing = mr;
+    }
+
+    return rbearing;
+#endif // Q_OS_WINCE
 }
 
 
@@ -973,6 +1067,7 @@ QWindowsNativeImage *QWindowsFontEngine::drawGDIGlyph(HFONT font, glyph_t glyph,
 
     bool has_transformation = t.type() > QTransform::TxTranslate;
 
+#ifndef Q_OS_WINCE
     unsigned int options = ttf ? ETO_GLYPH_INDEX : 0;
     XFORM xform;
 
@@ -1011,6 +1106,14 @@ QWindowsNativeImage *QWindowsFontEngine::drawGDIGlyph(HFONT font, glyph_t glyph,
         SelectObject(hdc, old_font);
         ReleaseDC(0, hdc);
     }
+#else // else wince
+    unsigned int options = 0;
+#ifdef DEBUG
+    Q_ASSERT(!has_transformation);
+#else
+    Q_UNUSED(has_transformation);
+#endif
+#endif // wince
     QWindowsNativeImage *ni = new QWindowsNativeImage(iw + 2 * margin + 4,
                                                       ih + 2 * margin + 4,
                                                       QWindowsNativeImage::systemFormat());
@@ -1030,11 +1133,13 @@ QWindowsNativeImage *QWindowsFontEngine::drawGDIGlyph(HFONT font, glyph_t glyph,
 
     HGDIOBJ old_font = SelectObject(hdc, font);
 
+#ifndef Q_OS_WINCE
     if (has_transformation) {
         SetGraphicsMode(hdc, GM_ADVANCED);
         SetWorldTransform(hdc, &xform);
         ExtTextOut(hdc, 0, 0, options, 0, (LPCWSTR) &glyph, 1, 0);
     } else
+#endif // !Q_OS_WINCE
     {
         ExtTextOut(hdc, -gx + margin, -gy + margin, options, 0, (LPCWSTR) &glyph, 1, 0);
     }
diff --git a/src/plugins/platforms/windows/qwindowsintegration.cpp b/src/plugins/platforms/windows/qwindowsintegration.cpp
index 255cf14..d46c138 100644
--- a/src/plugins/platforms/windows/qwindowsintegration.cpp
+++ b/src/plugins/platforms/windows/qwindowsintegration.cpp
@@ -43,20 +43,24 @@
 #include "qwindowsbackingstore.h"
 #include "qwindowswindow.h"
 #include "qwindowscontext.h"
-#include "qwindowsglcontext.h"
+#ifndef QT_NO_OPENGL
+#  include "qwindowsglcontext.h"
+#endif
 #include "qwindowsscreen.h"
 #include "qwindowstheme.h"
 #include "qwindowsservices.h"
 #ifndef QT_NO_FREETYPE
-#include "qwindowsfontdatabase_ft.h"
+#  include "qwindowsfontdatabase_ft.h"
 #endif
 #include "qwindowsfontdatabase.h"
 #include "qwindowsguieventdispatcher.h"
-#include "qwindowsclipboard.h"
+#ifndef QT_NO_CLIPBOARD
+#  include "qwindowsclipboard.h"
+#endif
 #include "qwindowsdrag.h"
 #include "qwindowsinputcontext.h"
 #include "qwindowskeymapper.h"
-#ifndef QT_NO_ACCESSIBILITY
+#  ifndef QT_NO_ACCESSIBILITY
 #include "accessible/qwindowsaccessibility.h"
 #endif
 
@@ -89,7 +93,9 @@ class QWindowsNativeInterface : public QPlatformNativeInterface
 {
     Q_OBJECT
 public:
+#ifndef QT_NO_OPENGL
     virtual void *nativeResourceForContext(const QByteArray &resource, QOpenGLContext *context);
+#endif
     virtual void *nativeResourceForWindow(const QByteArray &resource, QWindow *window);
     virtual void *nativeResourceForBackingStore(const QByteArray &resource, QBackingStore *bs);
     virtual EventFilter setEventFilter(const QByteArray &eventType, EventFilter filter)
@@ -134,6 +140,7 @@ void *QWindowsNativeInterface::nativeResourceForBackingStore(const QByteArray &r
     return 0;
 }
 
+#ifndef QT_NO_OPENGL
 void *QWindowsNativeInterface::nativeResourceForContext(const QByteArray &resource, QOpenGLContext *context)
 {
     if (!context || !context->handle()) {
@@ -147,6 +154,7 @@ void *QWindowsNativeInterface::nativeResourceForContext(const QByteArray &resour
     qWarning("%s: Invalid key '%s' requested.", __FUNCTION__, resource.constData());
     return 0;
 }
+#endif // !QT_NO_OPENGL
 
 /*!
     \brief Creates a non-visible window handle for filtering messages.
@@ -171,7 +179,9 @@ void *QWindowsNativeInterface::createMessageWindow(const QString &classNameTempl
 
 struct QWindowsIntegrationPrivate
 {
+#ifndef QT_NO_OPENGL
     typedef QSharedPointer<QOpenGLStaticContext> QOpenGLStaticContextPtr;
+#endif
 
     QWindowsIntegrationPrivate();
     ~QWindowsIntegrationPrivate();
@@ -179,10 +189,14 @@ struct QWindowsIntegrationPrivate
     QWindowsContext m_context;
     QPlatformFontDatabase *m_fontDatabase;
     QWindowsNativeInterface m_nativeInterface;
+#ifndef QT_NO_CLIPBOARD
     QWindowsClipboard m_clipboard;
+#endif
     QWindowsDrag m_drag;
     QWindowsGuiEventDispatcher *m_eventDispatcher;
+#ifndef QT_NO_OPENGL
     QOpenGLStaticContextPtr m_staticOpenGLContext;
+#endif
     QWindowsInputContext m_inputContext;
 #ifndef QT_NO_ACCESSIBILITY
     QWindowsAccessibility m_accessibility;
@@ -205,7 +219,9 @@ QWindowsIntegration::QWindowsIntegration() :
     d(new QWindowsIntegrationPrivate)
 {
     QGuiApplicationPrivate::instance()->setEventDispatcher(d->m_eventDispatcher);
+#ifndef QT_NO_CLIPBOARD
     d->m_clipboard.registerViewer();
+#endif
     d->m_context.screenManager().handleScreenChanges();
 }
 
@@ -220,10 +236,12 @@ bool QWindowsIntegration::hasCapability(QPlatformIntegration::Capability cap) co
     switch (cap) {
     case ThreadedPixmaps:
         return true;
+#ifndef QT_NO_OPENGL
     case OpenGL:
         return true;
     case ThreadedOpenGL:
         return true;
+#endif
     default:
         return QPlatformIntegration::hasCapability(cap);
     }
@@ -267,6 +285,7 @@ QPlatformBackingStore *QWindowsIntegration::createPlatformBackingStore(QWindow *
     return new QWindowsBackingStore(window);
 }
 
+#ifndef QT_NO_OPENGL
 QPlatformOpenGLContext
     *QWindowsIntegration::createPlatformOpenGLContext(QOpenGLContext *context) const
 {
@@ -280,6 +299,7 @@ QPlatformOpenGLContext
         return result.take();
     return 0;
 }
+#endif // !QT_NO_OPENGL
 
 /* Workaround for QTBUG-24205: In 'Auto', pick the FreeType engine for
  * QML2 applications. */
@@ -319,6 +339,7 @@ QPlatformFontDatabase *QWindowsIntegration::fontDatabase() const
     return d->m_fontDatabase;
 }
 
+#ifdef SPI_GETKEYBOARDSPEED
 static inline int keyBoardAutoRepeatRateMS()
 {
   DWORD time = 0;
@@ -326,6 +347,7 @@ static inline int keyBoardAutoRepeatRateMS()
       return time ? 1000 / static_cast<int>(time) : 500;
   return 30;
 }
+#endif
 
 QVariant QWindowsIntegration::styleHint(QPlatformIntegration::StyleHint hint) const
 {
@@ -334,8 +356,10 @@ QVariant QWindowsIntegration::styleHint(QPlatformIntegration::StyleHint hint) co
         if (const unsigned timeMS = GetCaretBlinkTime())
             return QVariant(int(timeMS));
         break;
+#ifdef SPI_GETKEYBOARDSPEED
     case KeyboardAutoRepeatRate:
         return QVariant(keyBoardAutoRepeatRateMS());
+#endif
     case QPlatformIntegration::StartDragTime:
     case QPlatformIntegration::StartDragDistance:
     case QPlatformIntegration::MouseDoubleClickInterval:
@@ -358,10 +382,12 @@ QPlatformNativeInterface *QWindowsIntegration::nativeInterface() const
     return &d->m_nativeInterface;
 }
 
+#ifndef QT_NO_CLIPBOARD
 QPlatformClipboard * QWindowsIntegration::clipboard() const
 {
     return &d->m_clipboard;
 }
+#endif // !QT_NO_CLIPBOARD
 
 QPlatformDrag *QWindowsIntegration::drag() const
 {
diff --git a/src/plugins/platforms/windows/qwindowsintegration.h b/src/plugins/platforms/windows/qwindowsintegration.h
index 76393be..ecae463 100644
--- a/src/plugins/platforms/windows/qwindowsintegration.h
+++ b/src/plugins/platforms/windows/qwindowsintegration.h
@@ -42,6 +42,7 @@
 #ifndef QWINDOWSINTEGRATION_H
 #define QWINDOWSINTEGRATION_H
 
+#include <QtCore/qconfig.h>
 #include <qpa/qplatformintegration.h>
 #include <QtCore/QScopedPointer>
 
@@ -60,10 +61,13 @@ public:
     virtual QPlatformPixmap *createPlatformPixmap(QPlatformPixmap::PixelType type) const;
     QPlatformWindow *createPlatformWindow(QWindow *window) const;
     QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const;
+#ifndef QT_NO_OPENGL
     virtual QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const;
+#endif
     virtual QAbstractEventDispatcher *guiThreadEventDispatcher() const;
-
+#ifndef QT_NO_CLIPBOARD
     virtual QPlatformClipboard *clipboard() const;
+#endif
     virtual QPlatformDrag *drag() const;
     virtual QPlatformInputContext *inputContext() const;
 #ifndef QT_NO_ACCESSIBILITY
diff --git a/src/plugins/platforms/windows/qwindowsinternalmimedata.cpp b/src/plugins/platforms/windows/qwindowsinternalmimedata.cpp
new file mode 100644
index 0000000..9bed609
--- /dev/null
+++ b/src/plugins/platforms/windows/qwindowsinternalmimedata.cpp
@@ -0,0 +1,116 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qwindowsinternalmimedata.h"
+#include "qwindowscontext.h"
+#include "qplatformfunctions_wince.h"
+#include "qwindowsmime.h"
+#include <QDebug>
+/*!
+    \class QWindowsInternalMimeDataBase
+    \brief Base for implementations of QInternalMimeData using a IDataObject COM object.
+
+    In clipboard handling and Drag and drop, static instances
+    of QInternalMimeData implementations are kept and passed to the client.
+
+    QInternalMimeData provides virtuals that query the formats and retrieve
+    mime data on demand when the client invokes functions like QMimeData::hasHtml(),
+    QMimeData::html() on the instance returned. Otherwise, expensive
+    construction of a new QMimeData object containing all possible
+    formats would have to be done in each call to mimeData().
+
+    The base class introduces new virtuals to obtain and release
+    the instances IDataObject from the clipboard or Drag and Drop and
+    does conversion using QWindowsMime classes.
+
+    \sa QInternalMimeData, QWindowsMime, QWindowsMimeConverter
+    \ingroup qt-lighthouse-win
+*/
+
+bool QWindowsInternalMimeData::hasFormat_sys(const QString &mime) const
+{
+    IDataObject *pDataObj = retrieveDataObject();
+    if (!pDataObj)
+        return false;
+
+    const QWindowsMimeConverter &mc = QWindowsContext::instance()->mimeConverter();
+    const bool has = mc.converterToMime(mime, pDataObj) != 0;
+    releaseDataObject(pDataObj);
+    if (QWindowsContext::verboseOLE)
+        qDebug() << __FUNCTION__ <<  mime << has;
+    return has;
+}
+
+QStringList QWindowsInternalMimeData::formats_sys() const
+{
+    IDataObject *pDataObj = retrieveDataObject();
+    if (!pDataObj)
+        return QStringList();
+
+    const QWindowsMimeConverter &mc = QWindowsContext::instance()->mimeConverter();
+    const QStringList fmts = mc.allMimesForFormats(pDataObj);
+    releaseDataObject(pDataObj);
+    if (QWindowsContext::verboseOLE)
+        qDebug() << __FUNCTION__ <<  fmts;
+    return fmts;
+}
+
+QVariant QWindowsInternalMimeData::retrieveData_sys(const QString &mimeType,
+                                                        QVariant::Type type) const
+{
+    IDataObject *pDataObj = retrieveDataObject();
+    if (!pDataObj)
+        return QVariant();
+
+    QVariant result;
+    const QWindowsMimeConverter &mc = QWindowsContext::instance()->mimeConverter();
+    if (const QWindowsMime *converter = mc.converterToMime(mimeType, pDataObj))
+        result = converter->convertToMime(mimeType, pDataObj, type);
+    releaseDataObject(pDataObj);
+    if (QWindowsContext::verboseOLE) {
+        QDebug nospace = qDebug().nospace();
+        nospace << __FUNCTION__ <<  ' '  << mimeType << ' ' << type
+                << " returns " << result.type();
+        if (result.type() != QVariant::ByteArray)
+            nospace << ' ' << result;
+    }
+    return result;
+}
diff --git a/src/plugins/platforms/windows/qwindowskeymapper.cpp b/src/plugins/platforms/windows/qwindowskeymapper.cpp
index 4b5e958..25d3d43 100644
--- a/src/plugins/platforms/windows/qwindowskeymapper.cpp
+++ b/src/plugins/platforms/windows/qwindowskeymapper.cpp
@@ -444,6 +444,34 @@ inline int winceKeyBend(int keyCode)
     return KeyTbl[keyCode];
 }
 
+#ifdef Q_OS_WINCE
+QT_BEGIN_INCLUDE_NAMESPACE
+int ToUnicode(UINT vk, int /*scancode*/, unsigned char* /*kbdBuffer*/, LPWSTR unicodeBuffer, int, int)
+{
+    QT_USE_NAMESPACE
+    QChar* buf = reinterpret_cast< QChar*>(unicodeBuffer);
+    if (KeyTbl[vk] == 0) {
+        buf[0] = vk;
+        return 1;
+    }
+    return 0;
+}
+
+int ToAscii(UINT vk, int scancode, unsigned char *kbdBuffer, LPWORD unicodeBuffer, int flag)
+{
+    return ToUnicode(vk, scancode, kbdBuffer, (LPWSTR) unicodeBuffer, 0, flag);
+
+}
+
+bool GetKeyboardState(unsigned char* kbuffer)
+{
+    for (int i=0; i< 256; ++i)
+        kbuffer[i] = GetAsyncKeyState(i);
+    return true;
+}
+QT_END_INCLUDE_NAMESPACE
+#endif // Q_OS_WINCE
+
 // Translate a VK into a Qt key code, or unicode character
 static inline int toKeyOrUnicode(int vk, int scancode, unsigned char *kbdBuffer, bool *isDeadkey = 0)
 {
@@ -672,6 +700,7 @@ static void showSystemMenu(QWindow* w)
     if (!menu)
         return; // no menu for this window
 
+#ifndef Q_OS_WINCE
 #define enabled (MF_BYCOMMAND | MF_ENABLED)
 #define disabled (MF_BYCOMMAND | MF_GRAYED)
 
@@ -696,6 +725,7 @@ static void showSystemMenu(QWindow* w)
 
 #undef enabled
 #undef disabled
+#endif // !Q_OS_WINCE
     const int ret = TrackPopupMenuEx(menu,
                                TPM_LEFTALIGN  | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                                topLevel->geometry().x(), topLevel->geometry().y(),
@@ -1014,6 +1044,7 @@ bool QWindowsKeyMapper::translateKeyEventInternal(QWindow *window, const MSG &ms
                                                            Qt::KeyboardModifier(state), scancode, msg.wParam, nModifiers, text, false, 0);
             result =true;
             bool store = true;
+#ifndef Q_OS_WINCE
             // Alt+<alphanumerical> go to the Win32 menu system if unhandled by Qt
             if (msgType == WM_SYSKEYDOWN && !result && a) {
                 HWND parent = GetParent(QWindowsWindow::handleOf(receiver));
@@ -1027,6 +1058,7 @@ bool QWindowsKeyMapper::translateKeyEventInternal(QWindow *window, const MSG &ms
                     parent = GetParent(parent);
                 }
             }
+#endif // !Q_OS_WINCE
             if (!store)
                 key_recorder.findKey(msg.wParam, true);
         }
@@ -1055,6 +1087,7 @@ bool QWindowsKeyMapper::translateKeyEventInternal(QWindow *window, const MSG &ms
                                                            Qt::KeyboardModifier(state), scancode, msg.wParam, nModifiers,
                                                            (rec ? rec->text : QString()), false, 0);
             result = true;
+#ifndef Q_OS_WINCE
             // don't pass Alt to Windows unless we are embedded in a non-Qt window
             if (code == Qt::Key_Alt) {
                 const QWindowsContext *context = QWindowsContext::instance();
@@ -1067,6 +1100,7 @@ bool QWindowsKeyMapper::translateKeyEventInternal(QWindow *window, const MSG &ms
                     parent = GetParent(parent);
                 }
             }
+#endif
         }
     }
     return result;
diff --git a/src/plugins/platforms/windows/qwindowsmousehandler.cpp b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
index 63c2444..f866f68 100644
--- a/src/plugins/platforms/windows/qwindowsmousehandler.cpp
+++ b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
@@ -164,6 +164,7 @@ bool QWindowsMouseHandler::translateMouseEvent(QWindow *window, HWND hwnd,
         if (QWindowsContext::verboseEvents)
             qDebug() << "Entering " << window;
         QWindowsWindow::baseWindowOf(window)->applyCursor();
+#ifndef Q_OS_WINCE
         QWindowSystemInterface::handleEnterEvent(window);
         TRACKMOUSEEVENT tme;
         tme.cbSize = sizeof(TRACKMOUSEEVENT);
@@ -172,6 +173,7 @@ bool QWindowsMouseHandler::translateMouseEvent(QWindow *window, HWND hwnd,
         tme.dwHoverTime = HOVER_DEFAULT; //
         if (!TrackMouseEvent(&tme))
             qWarning("TrackMouseEvent failed.");
+#endif // !Q_OS_WINCE
     }
     QWindowSystemInterface::handleMouseEvent(window, client,
                                              QWindowsGeometryHint::mapToGlobal(hwnd, client),
@@ -220,6 +222,7 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
                                                QtWindows::WindowsEventType,
                                                MSG msg, LRESULT *)
 {
+#ifndef Q_OS_WINCE
     typedef QWindowSystemInterface::TouchPoint QTouchPoint;
     typedef QList<QWindowSystemInterface::TouchPoint> QTouchPointList;
 
@@ -289,6 +292,9 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
                                              m_touchDevice,
                                              touchPoints);
     return true;
+#else
+    return false;
+#endif
 }
 
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/windows/qwindowsnativeimage.cpp b/src/plugins/platforms/windows/qwindowsnativeimage.cpp
index 8f727c6..9cd30df 100644
--- a/src/plugins/platforms/windows/qwindowsnativeimage.cpp
+++ b/src/plugins/platforms/windows/qwindowsnativeimage.cpp
@@ -127,7 +127,9 @@ QWindowsNativeImage::QWindowsNativeImage(int width, int height,
         m_image = QImage(width, height, format);
     }
 
+#ifndef Q_OS_WINCE
     GdiFlush();
+#endif
 }
 
 QWindowsNativeImage::~QWindowsNativeImage()
diff --git a/src/plugins/platforms/windows/qwindowsscreen.cpp b/src/plugins/platforms/windows/qwindowsscreen.cpp
index cc694fe..0c24ff7 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.cpp
+++ b/src/plugins/platforms/windows/qwindowsscreen.cpp
@@ -99,7 +99,14 @@ BOOL QT_WIN_CALLBACK monitorEnumCallback(HMONITOR hMonitor, HDC, LPRECT, LPARAM
     WindowsScreenDataList *result = reinterpret_cast<WindowsScreenDataList *>(p);
     QWindowsScreenData data;
     data.geometry = QRect(QPoint(info.rcMonitor.left, info.rcMonitor.top), QPoint(info.rcMonitor.right - 1, info.rcMonitor.bottom - 1));
-    if (HDC hdc = CreateDC(info.szDevice, NULL, NULL, NULL)) {
+#ifdef Q_OS_WINCE
+    //Windows CE, just supports one Display and expects to get only DISPLAY,
+    //instead of DISPLAY0 and so on, which are passed by info.szDevice
+    HDC hdc = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
+#else
+    HDC hdc = CreateDC(info.szDevice, NULL, NULL, NULL);
+#endif
+    if (hdc) {
         data.dpi = deviceDPI(hdc);
         data.depth = GetDeviceCaps(hdc, BITSPIXEL);
         data.format = data.depth == 16 ? QImage::Format_RGB16 : QImage::Format_RGB32;
diff --git a/src/plugins/platforms/windows/qwindowsscreen.h b/src/plugins/platforms/windows/qwindowsscreen.h
index 615d4fa..b34d592 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.h
+++ b/src/plugins/platforms/windows/qwindowsscreen.h
@@ -43,6 +43,9 @@
 #define QWINDOWSSCREEN_H
 
 #include "qwindowscursor.h"
+#ifdef Q_OS_WINCE
+#  include "qplatformfunctions_wince.h"
+#endif
 
 #include <QtCore/QList>
 #include <QtCore/QPair>
diff --git a/src/plugins/platforms/windows/qwindowsservices.cpp b/src/plugins/platforms/windows/qwindowsservices.cpp
index 905a1bd..a2688a1 100644
--- a/src/plugins/platforms/windows/qwindowsservices.cpp
+++ b/src/plugins/platforms/windows/qwindowsservices.cpp
@@ -46,7 +46,9 @@
 #include <QtCore/QDebug>
 
 #include <shlobj.h>
-#include <intshcut.h>
+#ifndef Q_OS_WINCE
+#  include <intshcut.h>
+#endif
 
 QT_BEGIN_NAMESPACE
 
@@ -54,6 +56,7 @@ enum { debug = 0 };
 
 static inline bool shellExecute(const QString &file)
 {
+#ifndef Q_OS_WINCE
     const quintptr result = (quintptr)ShellExecute(0, 0, (wchar_t*)file.utf16(), 0, 0, SW_SHOWNORMAL);
     // ShellExecute returns a value greater than 32 if successful
     if (result <= 32) {
@@ -61,6 +64,10 @@ static inline bool shellExecute(const QString &file)
         return false;
     }
     return true;
+#else
+    Q_UNUSED(file)
+    return false;
+#endif
 }
 
 // Retrieve the commandline for the default mail client. It contains a
@@ -95,9 +102,13 @@ static inline QString mailCommand()
     }
     if (!command[0])
         return QString();
+#ifndef Q_OS_WINCE
     wchar_t expandedCommand[MAX_PATH] = {0};
     return ExpandEnvironmentStrings(command, expandedCommand, MAX_PATH) ?
            QString::fromWCharArray(expandedCommand) : QString::fromWCharArray(command);
+#else
+    return QString();
+#endif
 }
 
 static inline bool launchMail(const QUrl &url)
diff --git a/src/plugins/platforms/windows/qwindowstheme.cpp b/src/plugins/platforms/windows/qwindowstheme.cpp
index 63ed20e..0feb62d 100644
--- a/src/plugins/platforms/windows/qwindowstheme.cpp
+++ b/src/plugins/platforms/windows/qwindowstheme.cpp
@@ -45,6 +45,10 @@
 #include "qwindowsintegration.h"
 #include "qt_windows.h"
 #include "qwindowsfontdatabase.h"
+#ifdef Q_OS_WINCE
+#  include "qplatformfunctions_wince.h"
+#  include "winuser.h"
+#endif
 
 #include <QtCore/QVariant>
 #include <QtCore/QCoreApplication>
@@ -226,8 +230,13 @@ static inline QPalette menuPalette(const QPalette &systemPalette)
     result.setColor(QPalette::Active, QPalette::ButtonText, menuTextColor);
     result.setColor(QPalette::Disabled, QPalette::WindowText, disabled);
     result.setColor(QPalette::Disabled, QPalette::Text, disabled);
+#ifndef Q_OS_WINCE
     result.setColor(QPalette::Disabled, QPalette::Highlight,
                     getSysColor(isFlat ? COLOR_MENUHILIGHT : COLOR_HIGHLIGHT));
+#else
+    result.setColor(QPalette::Disabled, QPalette::Highlight,
+                    getSysColor(COLOR_HIGHLIGHT));
+#endif
     result.setColor(QPalette::Disabled, QPalette::HighlightedText, disabled);
     result.setColor(QPalette::Disabled, QPalette::Button,
                     result.color(QPalette::Active, QPalette::Button));
@@ -253,7 +262,11 @@ static inline QPalette *menuBarPalette(const QPalette &menuPalette)
     QPalette *result = 0;
     if (booleanSystemParametersInfo(SPI_GETFLATMENU, false)) {
         result = new QPalette(menuPalette);
+#ifndef Q_OS_WINCE
         const QColor menubar(getSysColor(COLOR_MENUBAR));
+#else
+        const QColor menubar(getSysColor(COLOR_MENU));
+#endif
         result->setColor(QPalette::Active, QPalette::Button, menubar);
         result->setColor(QPalette::Disabled, QPalette::Button, menubar);
         result->setColor(QPalette::Inactive, QPalette::Button, menubar);
@@ -323,10 +336,12 @@ QVariant QWindowsTheme::themeHint(ThemeHint hint) const
         return QVariant(iconThemeSearchPaths());
     case StyleNames:
         return QVariant(styleNames());
+#ifndef Q_OS_WINCE
     case TextCursorWidth:
         return QVariant(int(dWordSystemParametersInfo(SPI_GETCARETWIDTH, 1u)));
     case DropShadow:
         return QVariant(booleanSystemParametersInfo(SPI_GETDROPSHADOW, false));
+#endif // !Q_OS_WINCE
     case MaximumScrollBarDragDistance:
         return QVariant(qRound(qreal(QWindowsContext::instance()->defaultDPI()) * 1.375));
     case KeyboardScheme:
@@ -368,6 +383,7 @@ void QWindowsTheme::clearFonts()
 
 void QWindowsTheme::refreshFonts()
 {
+#ifndef Q_OS_WINCE // ALL THIS FUNCTIONALITY IS MISSING ON WINCE
     clearFonts();
     if (!QGuiApplication::desktopSettingsAware())
         return;
@@ -398,6 +414,7 @@ void QWindowsTheme::refreshFonts()
         qDebug() << __FUNCTION__ << '\n'
                  << "  menuFont=" << menuFont
                  << "  messageBox=" << MessageBoxFont;
+#endif // !Q_OS_WINCE
 }
 
 bool QWindowsTheme::usePlatformNativeDialog(DialogType type) const
diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index c300f0f..ca23623 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -112,6 +112,7 @@ static QByteArray debugWindowStates(Qt::WindowStates s)
     return rc;
 }
 
+#ifndef Q_OS_WINCE // maybe available on some SDKs revisit WM_GETMINMAXINFO
 QDebug operator<<(QDebug d, const MINMAXINFO &i)
 {
     d.nospace() << "MINMAXINFO maxSize=" << i.ptMaxSize.x << ','
@@ -122,6 +123,7 @@ QDebug operator<<(QDebug d, const MINMAXINFO &i)
                  << i.ptMaxTrackSize.y;
     return d;
 }
+#endif // !Q_OS_WINCE
 
 static inline QSize qSizeOfRect(const RECT &rect)
 {
@@ -148,6 +150,7 @@ QDebug operator<<(QDebug d, const RECT &r)
     return d;
 }
 
+#ifndef Q_OS_WINCE // maybe available on some SDKs revisit WM_NCCALCSIZE
 QDebug operator<<(QDebug d, const NCCALCSIZE_PARAMS &p)
 {
     qDebug().nospace() << "NCCALCSIZE_PARAMS "
@@ -156,6 +159,7 @@ QDebug operator<<(QDebug d, const NCCALCSIZE_PARAMS &p)
         << qrectFromRECT(p.rgrc[2]);
     return d;
 }
+#endif // !Q_OS_WINCE
 
 // Return the frame geometry relative to the parent
 // if there is one.
@@ -507,6 +511,7 @@ QMargins QWindowsGeometryHint::frame(DWORD style, DWORD exStyle)
     return result;
 }
 
+#ifndef Q_OS_WINCE
 void QWindowsGeometryHint::applyToMinMaxInfo(HWND hwnd, MINMAXINFO *mmi) const
 {
     return applyToMinMaxInfo(GetWindowLong(hwnd, GWL_STYLE),
@@ -541,6 +546,7 @@ void QWindowsGeometryHint::applyToMinMaxInfo(DWORD style, DWORD exStyle, MINMAXI
                            << " frame=" << margins << ' ' << frameWidth << ',' << frameHeight
                            << " out " << *mmi;
 }
+#endif // !Q_OS_WINCE
 
 bool QWindowsGeometryHint::positionIncludesFrame(const QWindow *w)
 {
@@ -1264,6 +1270,9 @@ void QWindowsWindow::setOpacity(qreal level)
 
 void QWindowsWindow::setOpacity_sys(qreal level) const
 {
+#ifdef Q_OS_WINCE // maybe needs revisit WS_EX_LAYERED
+    Q_UNUSED(level);
+#else
     const long wl = GetWindowLong(m_data.hwnd, GWL_EXSTYLE);
     const bool isOpaque = level == 1.0;
 
@@ -1280,6 +1289,7 @@ void QWindowsWindow::setOpacity_sys(qreal level) const
             QWindowsContext::user32dll.setLayeredWindowAttributes(m_data.hwnd, 0, (int)(level * 255), LWA_ALPHA);
         }
     }
+#endif // !Q_OS_WINCE
 }
 
 void QWindowsWindow::requestActivateWindow()
@@ -1340,6 +1350,7 @@ void QWindowsWindow::setMouseGrabEnabled_sys(bool grab)
     }
 }
 
+#ifndef Q_OS_WINCE // maybe available on some SDKs revisit WM_GETMINMAXINFO
 void QWindowsWindow::getSizeHints(MINMAXINFO *mmi) const
 {
     const QWindowsGeometryHint hint(window());
@@ -1347,6 +1358,7 @@ void QWindowsWindow::getSizeHints(MINMAXINFO *mmi) const
     if (QWindowsContext::verboseWindows)
         qDebug() << __FUNCTION__ << window() << *mmi;
 }
+#endif // !Q_OS_WINCE
 
 /*!
     \brief Applies to cursor property set on the window to the global cursor.
@@ -1392,6 +1404,7 @@ QWindowsWindow *QWindowsWindow::childAt(const QPoint &clientPoint, unsigned cwex
     return 0;
 }
 
+#ifndef Q_OS_WINCE
 void QWindowsWindow::alertWindow(int durationMs)
 {
     DWORD timeOutMs = GetCaretBlinkTime();
@@ -1417,6 +1430,7 @@ void QWindowsWindow::stopAlertWindow()
     info.uCount = 0;
     FlashWindowEx(&info);
 }
+#endif // !Q_OS_WINCE
 
 bool QWindowsWindow::isEnabled() const
 {
diff --git a/src/plugins/platforms/windows/qwindowswindow.h b/src/plugins/platforms/windows/qwindowswindow.h
index 64fd78d..b558252 100644
--- a/src/plugins/platforms/windows/qwindowswindow.h
+++ b/src/plugins/platforms/windows/qwindowswindow.h
@@ -43,6 +43,9 @@
 #define QWINDOWSWINDOW_H
 
 #include "qtwindows_additional.h"
+#ifdef Q_OS_WINCE
+#  include "qplatformfunctions_wince.h"
+#endif
 #include "qwindowscursor.h"
 
 #include <qpa/qplatformwindow.h>
@@ -57,8 +60,10 @@ struct QWindowsGeometryHint
     QWindowsGeometryHint() {}
     explicit QWindowsGeometryHint(const QWindow *w);
     static QMargins frame(DWORD style, DWORD exStyle);
+#ifndef Q_OS_WINCE //MinMax maybe define struct if not available
     void applyToMinMaxInfo(DWORD style, DWORD exStyle, MINMAXINFO *mmi) const;
     void applyToMinMaxInfo(HWND hwnd, MINMAXINFO *mmi) const;
+#endif
     bool validSize(const QSize &s) const;
 
     static inline QPoint mapToGlobal(HWND hwnd, const QPoint &);
@@ -76,9 +81,10 @@ struct QWindowCreationContext
 {
     QWindowCreationContext(const QWindow *w, const QRect &r,
                            DWORD style, DWORD exStyle);
-
+#ifndef Q_OS_WINCE //MinMax maybe define struct if not available
     void applyToMinMaxInfo(MINMAXINFO *mmi) const
         { geometryHint.applyToMinMaxInfo(style, exStyle, mmi); }
+#endif
 
     QWindowsGeometryHint geometryHint;
     DWORD style;
@@ -176,8 +182,9 @@ public:
 
     HDC getDC();
     void releaseDC();
-
+#ifndef Q_OS_WINCE // maybe available on some SDKs revisit WM_GETMINMAXINFO
     void getSizeHints(MINMAXINFO *mmi) const;
+#endif
 
     QWindowsWindowCursor cursor() const { return m_cursor; }
     void setCursor(const QWindowsWindowCursor &c);
@@ -197,8 +204,10 @@ public:
     void setEnabled(bool enabled);
     bool isEnabled() const;
 
+#ifndef Q_OS_WINCE
     void alertWindow(int durationMs = 0);
     void stopAlertWindow();
+#endif
 
 private:
     inline void show_sys() const;
@@ -242,8 +251,10 @@ inline QRect operator-(const QRect &r, const QMargins &m)
 
 // Debug
 QDebug operator<<(QDebug d, const RECT &r);
+#ifndef Q_OS_WINCE // maybe available on some SDKs revisit WM_GETMINMAXINFO/WM_NCCALCSIZE
 QDebug operator<<(QDebug d, const MINMAXINFO &i);
 QDebug operator<<(QDebug d, const NCCALCSIZE_PARAMS &p);
+#endif
 
 // ---------- QWindowsGeometryHint inline functions.
 QPoint QWindowsGeometryHint::mapToGlobal(HWND hwnd, const QPoint &qp)
diff --git a/src/plugins/platforms/windows/windows.pro b/src/plugins/platforms/windows/windows.pro
index 63275d3..5fcf9bf 100644
--- a/src/plugins/platforms/windows/windows.pro
+++ b/src/plugins/platforms/windows/windows.pro
@@ -9,11 +9,13 @@ INCLUDEPATH += ../../../3rdparty/harfbuzz/src
 QTDIR_build:DESTDIR = $$QT_BUILD_TREE/plugins/platforms
 
 # Note: OpenGL32 must precede Gdi32 as it overwrites some functions.
-LIBS *= -lOpenGL32 -lGdi32 -lUser32 -lOle32 -lWinspool -lImm32 -lWinmm  -lOleaut32
+LIBS *= -lole32
+!wince*:LIBS *= -lgdi32 -luser32 -lwinspool -limm32 -lwinmm  -loleaut32
+contains(QT_CONFIG, opengl):LIBS *= -lOpenGL32
 win32-g++: LIBS *= -luuid
 # For the dialog helpers:
-LIBS *= -lshlwapi -lShell32
-LIBS *= -lAdvapi32
+!wince*:LIBS *= -lshlwapi -lshell32
+!wince*:LIBS *= -ladvapi32
 
 DEFINES *= QT_NO_CAST_FROM_ASCII
 
@@ -38,11 +40,10 @@ SOURCES += \
     qwindowsfontdatabase.cpp \
     qwindowsmousehandler.cpp \
     qwindowsguieventdispatcher.cpp \
-    qwindowsglcontext.cpp \
-    qwindowsclipboard.cpp \
     qwindowsole.cpp \
     qwindowsmime.cpp \
     qwindowsdrag.cpp \
+    qwindowsinternalmimedata.cpp \
     qwindowscursor.cpp \
     qwindowsinputcontext.cpp \
     qwindowstheme.cpp \
@@ -63,8 +64,6 @@ HEADERS += \
     qwindowsguieventdispatcher.h \
     qtwindowsglobal.h \
     qtwindows_additional.h \
-    qwindowsglcontext.h \
-    qwindowsclipboard.h \
     qwindowsole.h \
     qwindowsmime.h \
     qwindowsdrag.h \
@@ -74,7 +73,18 @@ HEADERS += \
     qwindowsinputcontext.h \
     qwindowstheme.h \
     qwindowsdialoghelpers.h \
-    qwindowsservices.h
+    qwindowsservices.h \
+    qplatformfunctions_wince.h
+
+contains(QT_CONFIG, opengl) {
+    SOURCES += qwindowsglcontext.cpp
+    HEADERS += qwindowsglcontext.h
+}
+
+!contains( DEFINES, QT_NO_CLIPBOARD ) {
+    SOURCES += qwindowsclipboard.cpp
+    HEADERS += qwindowsclipboard.h
+}
 
 # Enable access to HB_Face in harfbuzz includes included by qfontengine_p.h.
 DEFINES *= QT_COMPILES_IN_HARFBUZZ