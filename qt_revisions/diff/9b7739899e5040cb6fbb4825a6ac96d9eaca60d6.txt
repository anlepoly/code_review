diff --git a/tests/manual/windowflags/controllerwindow.cpp b/tests/manual/windowflags/controllerwindow.cpp
index cee8976..1b54711 100644
--- a/tests/manual/windowflags/controllerwindow.cpp
+++ b/tests/manual/windowflags/controllerwindow.cpp
@@ -49,6 +49,7 @@
 #include <QtWidgets/QHBoxLayout>
 
 #include "controllerwindow.h"
+#include "controls.h"
 
 //! [0]
 ControllerWindow::ControllerWindow()
@@ -62,8 +63,6 @@ ControllerWindow::ControllerWindow()
     previewDialog = new PreviewDialog;
 
     createTypeGroupBox();
-    createStateGroupBox();
-    createHintsGroupBox();
 
     quitButton = new QPushButton(tr("&Quit"));
     connect(quitButton, SIGNAL(clicked()), qApp, SLOT(quit()));
@@ -72,12 +71,25 @@ ControllerWindow::ControllerWindow()
     bottomLayout->addStretch();
     bottomLayout->addWidget(quitButton);
 
+    hintsControl = new HintControl;
+    hintsControl->setHints(previewWindow->windowFlags());
+    connect(hintsControl, SIGNAL(changed(Qt::WindowFlags)), this, SLOT(updatePreview()));
+
+    statesControl = new WindowStatesControl(WindowStatesControl::WantVisibleCheckBox);
+    statesControl->setStates(previewWindow->windowState());
+    statesControl->setVisibleValue(true);
+    connect(statesControl, SIGNAL(changed()), this, SLOT(updatePreview()));
+
+    typeControl = new TypeControl;
+    typeControl->setType(previewWindow->windowFlags());
+    connect(typeControl, SIGNAL(changed(Qt::WindowFlags)), this, SLOT(updatePreview()));
+
     QVBoxLayout *mainLayout = new QVBoxLayout;
     mainLayout->addWidget(widgetTypeGroupBox);
-    mainLayout->addWidget(windowStateGroupBox);
     mainLayout->addWidget(additionalOptionsGroupBox);
-    mainLayout->addWidget(typeGroupBox);
-    mainLayout->addWidget(hintsGroupBox);
+    mainLayout->addWidget(typeControl);
+    mainLayout->addWidget(hintsControl);
+    mainLayout->addWidget(statesControl);
     mainLayout->addLayout(bottomLayout);
     setLayout(mainLayout);
 
@@ -88,52 +100,7 @@ ControllerWindow::ControllerWindow()
 
 void ControllerWindow::updatePreview()
 {
-    Qt::WindowFlags flags = 0;
-
-    if (windowRadioButton->isChecked()) {
-        flags = Qt::Window;
-    } else if (dialogRadioButton->isChecked()) {
-        flags = Qt::Dialog;
-    } else if (sheetRadioButton->isChecked()) {
-        flags = Qt::Sheet;
-    } else if (drawerRadioButton->isChecked()) {
-        flags = Qt::Drawer;
-    } else if (popupRadioButton->isChecked()) {
-        flags = Qt::Popup;
-    } else if (toolRadioButton->isChecked()) {
-        flags = Qt::Tool;
-    } else if (toolTipRadioButton->isChecked()) {
-        flags = Qt::ToolTip;
-    } else if (splashScreenRadioButton->isChecked()) {
-        flags = Qt::SplashScreen;
-    }
-
-    if (msWindowsFixedSizeDialogCheckBox->isChecked())
-        flags |= Qt::MSWindowsFixedSizeDialogHint;
-    if (x11BypassWindowManagerCheckBox->isChecked())
-        flags |= Qt::X11BypassWindowManagerHint;
-    if (framelessWindowCheckBox->isChecked())
-        flags |= Qt::FramelessWindowHint;
-    if (windowTitleCheckBox->isChecked())
-        flags |= Qt::WindowTitleHint;
-    if (windowSystemMenuCheckBox->isChecked())
-        flags |= Qt::WindowSystemMenuHint;
-    if (windowMinimizeButtonCheckBox->isChecked())
-        flags |= Qt::WindowMinimizeButtonHint;
-    if (windowMaximizeButtonCheckBox->isChecked())
-        flags |= Qt::WindowMaximizeButtonHint;
-    if (windowCloseButtonCheckBox->isChecked())
-        flags |= Qt::WindowCloseButtonHint;
-    if (windowContextHelpButtonCheckBox->isChecked())
-        flags |= Qt::WindowContextHelpButtonHint;
-    if (windowShadeButtonCheckBox->isChecked())
-        flags |= Qt::WindowShadeButtonHint;
-    if (windowStaysOnTopCheckBox->isChecked())
-        flags |= Qt::WindowStaysOnTopHint;
-    if (windowStaysOnBottomCheckBox->isChecked())
-        flags |= Qt::WindowStaysOnBottomHint;
-    if (customizeWindowHintCheckBox->isChecked())
-        flags |= Qt::CustomizeWindowHint;
+    const Qt::WindowFlags flags = typeControl->type() | hintsControl->hints();
 
     previewWindow->hide();
     previewDialog->hide();
@@ -168,16 +135,8 @@ void ControllerWindow::updatePreview()
         pos.setY(0);
     widget->move(pos);
 
-    Qt::WindowState windowState = Qt::WindowNoState;
-    if (minimizeButton->isChecked())
-        windowState = Qt::WindowMinimized;
-    else if (maximizeButton->isChecked())
-        windowState = Qt::WindowMaximized;
-    else if (fullscreenButton->isChecked())
-        windowState = Qt::WindowFullScreen;
-
-    widget->setWindowState(windowState);
-    widget->setVisible(visibleCheckBox->isChecked());
+    widget->setWindowState(statesControl->states());
+    widget->setVisible(statesControl->visibleValue());
 }
 
 void ControllerWindow::createTypeGroupBox()
@@ -198,91 +157,9 @@ void ControllerWindow::createTypeGroupBox()
     l->addWidget(modalWindowCheckBox);
     l->addWidget(fixedSizeWindowCheckBox);
     additionalOptionsGroupBox->setLayout(l);
-
-    typeGroupBox = new QGroupBox(tr("Type"));
-
-    windowRadioButton = createRadioButton(tr("Window"));
-    dialogRadioButton = createRadioButton(tr("Dialog"));
-    sheetRadioButton = createRadioButton(tr("Sheet"));
-    drawerRadioButton = createRadioButton(tr("Drawer"));
-    popupRadioButton = createRadioButton(tr("Popup"));
-    toolRadioButton = createRadioButton(tr("Tool"));
-    toolTipRadioButton = createRadioButton(tr("Tooltip"));
-    splashScreenRadioButton = createRadioButton(tr("Splash screen"));
-    windowRadioButton->setChecked(true);
-
-    QGridLayout *layout = new QGridLayout;
-    layout->addWidget(windowRadioButton, 0, 0);
-    layout->addWidget(dialogRadioButton, 1, 0);
-    layout->addWidget(sheetRadioButton, 2, 0);
-    layout->addWidget(drawerRadioButton, 3, 0);
-    layout->addWidget(popupRadioButton, 0, 1);
-    layout->addWidget(toolRadioButton, 1, 1);
-    layout->addWidget(toolTipRadioButton, 2, 1);
-    layout->addWidget(splashScreenRadioButton, 3, 1);
-    typeGroupBox->setLayout(layout);
 }
 //! [5]
 
-void ControllerWindow::createStateGroupBox()
-{
-    windowStateGroupBox = new QGroupBox(tr("Window State"));
-    visibleCheckBox = createCheckBox(tr("Visible"));
-    visibleCheckBox->setChecked(true);
-
-    restoreButton = createRadioButton(tr("Normal"));
-    restoreButton->setChecked(true);
-    minimizeButton = createRadioButton(tr("Minimized"));
-    maximizeButton = createRadioButton(tr("Maximized"));
-    fullscreenButton = createRadioButton(tr("Fullscreen"));;
-
-    QHBoxLayout *l = new QHBoxLayout;
-    l->addWidget(visibleCheckBox);
-    l->addWidget(restoreButton);
-    l->addWidget(minimizeButton);
-    l->addWidget(maximizeButton);
-    l->addWidget(fullscreenButton);
-    windowStateGroupBox->setLayout(l);
-}
-
-//! [6]
-void ControllerWindow::createHintsGroupBox()
-{
-    hintsGroupBox = new QGroupBox(tr("Hints"));
-
-    msWindowsFixedSizeDialogCheckBox =
-            createCheckBox(tr("MS Windows fixed size dialog"));
-    x11BypassWindowManagerCheckBox =
-            createCheckBox(tr("X11 bypass window manager"));
-    framelessWindowCheckBox = createCheckBox(tr("Frameless window"));
-    windowTitleCheckBox = createCheckBox(tr("Window title"));
-    windowSystemMenuCheckBox = createCheckBox(tr("Window system menu"));
-    windowMinimizeButtonCheckBox = createCheckBox(tr("Window minimize button"));
-    windowMaximizeButtonCheckBox = createCheckBox(tr("Window maximize button"));
-    windowCloseButtonCheckBox = createCheckBox(tr("Window close button"));
-    windowContextHelpButtonCheckBox =
-            createCheckBox(tr("Window context help button"));
-    windowShadeButtonCheckBox = createCheckBox(tr("Window shade button"));
-    windowStaysOnTopCheckBox = createCheckBox(tr("Window stays on top"));
-    windowStaysOnBottomCheckBox = createCheckBox(tr("Window stays on bottom"));
-    customizeWindowHintCheckBox= createCheckBox(tr("Customize window"));
-
-    QGridLayout *layout = new QGridLayout;
-    layout->addWidget(msWindowsFixedSizeDialogCheckBox, 0, 0);
-    layout->addWidget(x11BypassWindowManagerCheckBox, 1, 0);
-    layout->addWidget(framelessWindowCheckBox, 2, 0);
-    layout->addWidget(windowTitleCheckBox, 3, 0);
-    layout->addWidget(windowSystemMenuCheckBox, 4, 0);
-    layout->addWidget(windowMinimizeButtonCheckBox, 0, 1);
-    layout->addWidget(windowMaximizeButtonCheckBox, 1, 1);
-    layout->addWidget(windowCloseButtonCheckBox, 2, 1);
-    layout->addWidget(windowContextHelpButtonCheckBox, 3, 1);
-    layout->addWidget(windowShadeButtonCheckBox, 4, 1);
-    layout->addWidget(windowStaysOnTopCheckBox, 5, 1);
-    layout->addWidget(windowStaysOnBottomCheckBox, 6, 1);
-    layout->addWidget(customizeWindowHintCheckBox, 5, 0);
-    hintsGroupBox->setLayout(layout);
-}
 //! [6]
 
 //! [7]
diff --git a/tests/manual/windowflags/controllerwindow.h b/tests/manual/windowflags/controllerwindow.h
index 02a8eb9..5f6edbb 100644
--- a/tests/manual/windowflags/controllerwindow.h
+++ b/tests/manual/windowflags/controllerwindow.h
@@ -55,6 +55,10 @@ class QRadioButton;
 class QMainWindow;
 QT_END_NAMESPACE
 
+class HintControl;
+class WindowStatesControl;
+class TypeControl;
+
 //! [0]
 class ControllerWindow : public QWidget
 {
@@ -68,55 +72,24 @@ private slots:
 
 private:
     void createTypeGroupBox();
-    void createStateGroupBox();
-    void createHintsGroupBox();
     QCheckBox *createCheckBox(const QString &text);
     QRadioButton *createRadioButton(const QString &text);
 
     QMainWindow *parentWindow;
     PreviewWindow *previewWindow;
     PreviewDialog *previewDialog;
-
     QGroupBox *widgetTypeGroupBox;
-    QGroupBox *windowStateGroupBox;
     QGroupBox *additionalOptionsGroupBox;
-    QGroupBox *typeGroupBox;
-    QGroupBox *hintsGroupBox;
+    TypeControl *typeControl;
+    HintControl *hintsControl;
+    WindowStatesControl *statesControl;
+
     QPushButton *quitButton;
 
     QRadioButton *previewWidgetButton;
     QRadioButton *previewDialogButton;
     QCheckBox *modalWindowCheckBox;
     QCheckBox *fixedSizeWindowCheckBox;
-
-    QCheckBox *visibleCheckBox;
-    QRadioButton *restoreButton;
-    QRadioButton *minimizeButton;
-    QRadioButton *maximizeButton;
-    QRadioButton *fullscreenButton;
-
-    QRadioButton *windowRadioButton;
-    QRadioButton *dialogRadioButton;
-    QRadioButton *sheetRadioButton;
-    QRadioButton *drawerRadioButton;
-    QRadioButton *popupRadioButton;
-    QRadioButton *toolRadioButton;
-    QRadioButton *toolTipRadioButton;
-    QRadioButton *splashScreenRadioButton;
-
-    QCheckBox *msWindowsFixedSizeDialogCheckBox;
-    QCheckBox *x11BypassWindowManagerCheckBox;
-    QCheckBox *framelessWindowCheckBox;
-    QCheckBox *windowTitleCheckBox;
-    QCheckBox *windowSystemMenuCheckBox;
-    QCheckBox *windowMinimizeButtonCheckBox;
-    QCheckBox *windowMaximizeButtonCheckBox;
-    QCheckBox *windowCloseButtonCheckBox;
-    QCheckBox *windowContextHelpButtonCheckBox;
-    QCheckBox *windowShadeButtonCheckBox;
-    QCheckBox *windowStaysOnTopCheckBox;
-    QCheckBox *windowStaysOnBottomCheckBox;
-    QCheckBox *customizeWindowHintCheckBox;
 };
 //! [0]
 
diff --git a/tests/manual/windowflags/controls.cpp b/tests/manual/windowflags/controls.cpp
new file mode 100644
index 0000000..bdd8894
--- /dev/null
+++ b/tests/manual/windowflags/controls.cpp
@@ -0,0 +1,314 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the examples of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "controls.h"
+
+#include <QGridLayout>
+#include <QVBoxLayout>
+#include <QHBoxLayout>
+#include <QRadioButton>
+#include <QCheckBox>
+#include <QRadioButton>
+#include <QButtonGroup>
+#include <QDebug>
+
+HintControl::HintControl(QWidget *parent)
+    : QGroupBox(tr("Hints"), parent)
+    , msWindowsFixedSizeDialogCheckBox(new QCheckBox(tr("MS Windows fixed size dialog")))
+    , x11BypassWindowManagerCheckBox(new QCheckBox(tr("X11 bypass window manager")))
+    , framelessWindowCheckBox(new QCheckBox(tr("Frameless window")))
+    , windowTitleCheckBox(new QCheckBox(tr("Window title")))
+    , windowSystemMenuCheckBox(new QCheckBox(tr("Window system menu")))
+    , windowMinimizeButtonCheckBox(new QCheckBox(tr("Window minimize button")))
+    , windowMaximizeButtonCheckBox(new QCheckBox(tr("Window maximize button")))
+    , windowCloseButtonCheckBox(new QCheckBox(tr("Window close button")))
+    , windowContextHelpButtonCheckBox(new QCheckBox(tr("Window context help button")))
+    , windowShadeButtonCheckBox(new QCheckBox(tr("Window shade button")))
+    , windowStaysOnTopCheckBox(new QCheckBox(tr("Window stays on top")))
+    , windowStaysOnBottomCheckBox(new QCheckBox(tr("Window stays on bottom")))
+    , customizeWindowHintCheckBox(new QCheckBox(tr("Customize window")))
+{
+    connect(msWindowsFixedSizeDialogCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(x11BypassWindowManagerCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(framelessWindowCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowTitleCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowSystemMenuCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowMinimizeButtonCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowMaximizeButtonCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowCloseButtonCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowContextHelpButtonCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowShadeButtonCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowStaysOnTopCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(windowStaysOnBottomCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    connect(customizeWindowHintCheckBox, SIGNAL(clicked()), this, SLOT(slotCheckBoxChanged()));
+    QGridLayout *layout = new QGridLayout(this);
+    layout->setSpacing(0);
+    layout->setMargin(ControlLayoutMargin);
+    layout->addWidget(msWindowsFixedSizeDialogCheckBox, 0, 0);
+    layout->addWidget(x11BypassWindowManagerCheckBox, 1, 0);
+    layout->addWidget(framelessWindowCheckBox, 2, 0);
+    layout->addWidget(windowTitleCheckBox, 3, 0);
+    layout->addWidget(windowSystemMenuCheckBox, 4, 0);
+    layout->addWidget(windowMinimizeButtonCheckBox, 0, 1);
+    layout->addWidget(windowMaximizeButtonCheckBox, 1, 1);
+    layout->addWidget(windowCloseButtonCheckBox, 2, 1);
+    layout->addWidget(windowContextHelpButtonCheckBox, 3, 1);
+    layout->addWidget(windowShadeButtonCheckBox, 4, 1);
+    layout->addWidget(windowStaysOnTopCheckBox, 5, 1);
+    layout->addWidget(windowStaysOnBottomCheckBox, 6, 1);
+    layout->addWidget(customizeWindowHintCheckBox, 5, 0);
+}
+
+Qt::WindowFlags HintControl::hints() const
+{
+    Qt::WindowFlags flags = 0;
+    if (msWindowsFixedSizeDialogCheckBox->isChecked())
+        flags |= Qt::MSWindowsFixedSizeDialogHint;
+    if (x11BypassWindowManagerCheckBox->isChecked())
+        flags |= Qt::X11BypassWindowManagerHint;
+    if (framelessWindowCheckBox->isChecked())
+        flags |= Qt::FramelessWindowHint;
+    if (windowTitleCheckBox->isChecked())
+        flags |= Qt::WindowTitleHint;
+    if (windowSystemMenuCheckBox->isChecked())
+        flags |= Qt::WindowSystemMenuHint;
+    if (windowMinimizeButtonCheckBox->isChecked())
+        flags |= Qt::WindowMinimizeButtonHint;
+    if (windowMaximizeButtonCheckBox->isChecked())
+        flags |= Qt::WindowMaximizeButtonHint;
+    if (windowCloseButtonCheckBox->isChecked())
+        flags |= Qt::WindowCloseButtonHint;
+    if (windowContextHelpButtonCheckBox->isChecked())
+        flags |= Qt::WindowContextHelpButtonHint;
+    if (windowShadeButtonCheckBox->isChecked())
+        flags |= Qt::WindowShadeButtonHint;
+    if (windowStaysOnTopCheckBox->isChecked())
+        flags |= Qt::WindowStaysOnTopHint;
+    if (windowStaysOnBottomCheckBox->isChecked())
+        flags |= Qt::WindowStaysOnBottomHint;
+    if (customizeWindowHintCheckBox->isChecked())
+        flags |= Qt::CustomizeWindowHint;
+    return flags;
+}
+
+void HintControl::setHints(Qt::WindowFlags flags)
+{
+    msWindowsFixedSizeDialogCheckBox->setChecked(flags & Qt::MSWindowsFixedSizeDialogHint);
+    x11BypassWindowManagerCheckBox->setChecked(flags & Qt::X11BypassWindowManagerHint);
+    framelessWindowCheckBox->setChecked(flags & Qt::FramelessWindowHint);
+    windowTitleCheckBox->setChecked(flags & Qt::WindowTitleHint);
+    windowSystemMenuCheckBox->setChecked(flags & Qt::WindowSystemMenuHint);
+    windowMinimizeButtonCheckBox->setChecked(flags & Qt::WindowMinimizeButtonHint);
+    windowMaximizeButtonCheckBox->setChecked(flags & Qt::WindowMaximizeButtonHint);
+    windowCloseButtonCheckBox->setChecked(flags & Qt::WindowCloseButtonHint);
+    windowContextHelpButtonCheckBox->setChecked(flags & Qt::WindowContextHelpButtonHint);
+    windowShadeButtonCheckBox->setChecked(flags & Qt::WindowShadeButtonHint);
+    windowStaysOnTopCheckBox->setChecked(flags & Qt::WindowStaysOnTopHint);
+    windowStaysOnBottomCheckBox->setChecked(flags & Qt::WindowStaysOnBottomHint);
+    customizeWindowHintCheckBox->setChecked(flags & Qt::CustomizeWindowHint);
+}
+
+void HintControl::slotCheckBoxChanged()
+{
+    emit changed(hints());
+}
+
+WindowStateControl::WindowStateControl(unsigned flags, QWidget *parent)
+    : QWidget(parent)
+    , group(new QButtonGroup)
+    , visibleCheckBox(0)
+    , restoreButton(new QRadioButton(tr("Normal")))
+    , minimizeButton(0)
+    , maximizeButton(new QRadioButton(tr("Maximized")))
+    , fullscreenButton(new QRadioButton(tr("Fullscreen")))
+{
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    layout->setSpacing(0);
+    layout->setMargin(ControlLayoutMargin);
+    if (flags & WantVisibleCheckBox) {
+        visibleCheckBox = new QCheckBox(tr("Visible"));
+        connect(visibleCheckBox, SIGNAL(toggled(bool)), this, SIGNAL(changed()));
+        layout->addWidget(visibleCheckBox);
+    }
+
+    group->setExclusive(true);
+    if (flags & WantMinimizeRadioButton) {
+        minimizeButton = new QRadioButton(tr("Minimized"));
+        group->addButton(minimizeButton, Qt::WindowMinimized);
+        layout->addWidget(minimizeButton);
+    }
+    group->addButton(restoreButton, Qt::WindowNoState);
+    layout->addWidget(restoreButton);
+    group->addButton(maximizeButton, Qt::WindowMaximized);
+    layout->addWidget(maximizeButton);
+    group->addButton(fullscreenButton, Qt::WindowFullScreen);
+    layout->addWidget(fullscreenButton);
+    connect(group, SIGNAL(buttonReleased(int)), this, SIGNAL(changed()));
+}
+
+Qt::WindowState WindowStateControl::state() const
+{
+    return Qt::WindowState(group->checkedId());
+}
+
+void WindowStateControl::setState(Qt::WindowState s)
+{
+    group->blockSignals(true);
+    if (QAbstractButton *b = group->button(s))
+        b->setChecked(true);
+    group->blockSignals(false);
+}
+
+bool WindowStateControl::visibleValue() const
+{
+    return visibleCheckBox && visibleCheckBox->isChecked();
+}
+
+void WindowStateControl::setVisibleValue(bool v)
+{
+    if (visibleCheckBox) {
+        visibleCheckBox->blockSignals(true);
+        visibleCheckBox->setChecked(v);
+        visibleCheckBox->blockSignals(false);
+    }
+}
+
+WindowStatesControl::WindowStatesControl(unsigned flags, QWidget *parent)
+    : QGroupBox(tr("States"), parent)
+    , visibleCheckBox(0)
+    , minimizeCheckBox(new QCheckBox(tr("Minimized")))
+    , stateControl(new WindowStateControl(0))
+{
+    QHBoxLayout *layout = new QHBoxLayout(this);
+    layout->setSpacing(0);
+    layout->setMargin(ControlLayoutMargin);
+    if (flags & WantVisibleCheckBox) {
+        visibleCheckBox = new QCheckBox(tr("Visible"));
+        connect(visibleCheckBox, SIGNAL(toggled(bool)), this, SIGNAL(changed()));
+        layout->addWidget(visibleCheckBox);
+    }
+    layout->addWidget(minimizeCheckBox);
+    layout->addWidget(stateControl);
+    connect(stateControl, SIGNAL(changed()), this, SIGNAL(changed()));
+    connect(minimizeCheckBox, SIGNAL(clicked()), this, SIGNAL(changed()));
+}
+
+Qt::WindowStates WindowStatesControl::states() const
+{
+    Qt::WindowStates s = stateControl->state();
+    if (minimizeCheckBox->isChecked())
+        s |= Qt::WindowMinimized;
+    return s;
+}
+
+void WindowStatesControl::setStates(Qt::WindowStates s)
+{
+    minimizeCheckBox->blockSignals(true);
+    minimizeCheckBox->setChecked(s & Qt::WindowMinimized);
+    minimizeCheckBox->blockSignals(false);
+    s &= ~Qt::WindowMinimized;
+    stateControl->setState(Qt::WindowState(int(s)));
+}
+
+bool WindowStatesControl::visibleValue() const
+{
+    return visibleCheckBox && visibleCheckBox->isChecked();
+}
+
+void WindowStatesControl::setVisibleValue(bool v)
+{
+    if (visibleCheckBox) {
+        visibleCheckBox->blockSignals(true);
+        visibleCheckBox->setChecked(v);
+        visibleCheckBox->blockSignals(false);
+    }
+}
+
+TypeControl::TypeControl(QWidget *parent)
+    : QGroupBox(tr("Type"), parent)
+    , group(new QButtonGroup)
+    , windowRadioButton(new QRadioButton(tr("Window")))
+    , dialogRadioButton(new QRadioButton(tr("Dialog")))
+    , sheetRadioButton(new QRadioButton(tr("Sheet")))
+    , drawerRadioButton(new QRadioButton(tr("Drawer")))
+    , popupRadioButton(new QRadioButton(tr("Popup")))
+    , toolRadioButton(new QRadioButton(tr("Tool")))
+    , toolTipRadioButton(new QRadioButton(tr("Tooltip")))
+    , splashScreenRadioButton(new QRadioButton(tr("Splash screen")))
+{
+    group->setExclusive(true);
+    QGridLayout *layout = new QGridLayout(this);
+    layout->setSpacing(0);
+    layout->setMargin(ControlLayoutMargin);
+    group->addButton(windowRadioButton, Qt::Window);
+    layout->addWidget(windowRadioButton, 0, 0);
+    group->addButton(dialogRadioButton, Qt::Dialog);
+    layout->addWidget(dialogRadioButton, 1, 0);
+    group->addButton(sheetRadioButton, Qt::Sheet);
+    layout->addWidget(sheetRadioButton, 2, 0);
+    group->addButton(drawerRadioButton, Qt::Drawer);
+    layout->addWidget(drawerRadioButton, 3, 0);
+    group->addButton(popupRadioButton, Qt::Popup);
+    layout->addWidget(popupRadioButton, 0, 1);
+    group->addButton(toolRadioButton, Qt::Tool);
+    layout->addWidget(toolRadioButton, 1, 1);
+    group->addButton(toolTipRadioButton, Qt::ToolTip);
+    layout->addWidget(toolTipRadioButton, 2, 1);
+    group->addButton(splashScreenRadioButton, Qt::SplashScreen);
+    layout->addWidget(splashScreenRadioButton, 3, 1);
+    connect(group, SIGNAL(buttonReleased(int)), this, SLOT(slotChanged()));
+}
+
+Qt::WindowFlags TypeControl::type() const
+{
+    return Qt::WindowFlags(group->checkedId());
+}
+
+void TypeControl::setType(Qt::WindowFlags s)
+{
+    if (QAbstractButton *b = group->button(s & Qt::WindowType_Mask))
+        b->setChecked(true);
+}
+
+void TypeControl::slotChanged()
+{
+    emit changed(type());
+}
diff --git a/tests/manual/windowflags/controls.h b/tests/manual/windowflags/controls.h
new file mode 100644
index 0000000..57d9798
--- /dev/null
+++ b/tests/manual/windowflags/controls.h
@@ -0,0 +1,171 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the examples of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef CONTROLS_H
+#define CONTROLS_H
+
+#include <QGroupBox>
+
+QT_BEGIN_NAMESPACE
+class QCheckBox;
+class QRadioButton;
+class QButtonGroup;
+QT_END_NAMESPACE
+
+enum { ControlLayoutMargin = 4 };
+
+// Control for the hint part of Qt::WindowFlags
+class HintControl : public QGroupBox
+{
+    Q_OBJECT
+public:
+    explicit HintControl(QWidget *parent= 0);
+
+    Qt::WindowFlags hints() const;
+    void setHints(Qt::WindowFlags hints);
+
+signals:
+    void changed(Qt::WindowFlags);
+
+private slots:
+    void slotCheckBoxChanged();
+
+private:
+    QCheckBox *msWindowsFixedSizeDialogCheckBox;
+    QCheckBox *x11BypassWindowManagerCheckBox;
+    QCheckBox *framelessWindowCheckBox;
+    QCheckBox *windowTitleCheckBox;
+    QCheckBox *windowSystemMenuCheckBox;
+    QCheckBox *windowMinimizeButtonCheckBox;
+    QCheckBox *windowMaximizeButtonCheckBox;
+    QCheckBox *windowCloseButtonCheckBox;
+    QCheckBox *windowContextHelpButtonCheckBox;
+    QCheckBox *windowShadeButtonCheckBox;
+    QCheckBox *windowStaysOnTopCheckBox;
+    QCheckBox *windowStaysOnBottomCheckBox;
+    QCheckBox *customizeWindowHintCheckBox;
+};
+
+// Control for the Qt::WindowState enum, optional with a "visible" QCheckbox
+class WindowStateControl : public QWidget {
+    Q_OBJECT
+public:
+    enum Flags {
+        WantVisibleCheckBox = 0x1,
+        WantMinimizeRadioButton = 0x2
+    };
+
+    explicit WindowStateControl(unsigned flags, QWidget *parent= 0);
+
+    Qt::WindowState state() const;
+    void setState(Qt::WindowState s);
+
+    bool visibleValue() const;
+    void setVisibleValue(bool);
+
+signals:
+    void changed();
+
+private:
+    QButtonGroup *group;
+    QCheckBox    *visibleCheckBox;
+    QRadioButton *restoreButton;
+    QRadioButton *minimizeButton;
+    QRadioButton *maximizeButton;
+    QRadioButton *fullscreenButton;
+};
+
+// Control for the Qt::WindowStates flags (normal, maximized, fullscreen exclusively
+// combined with minimized and optionally, with a "visible" QCheckbox)
+class WindowStatesControl : public QGroupBox
+{
+    Q_OBJECT
+public:
+    enum Flags {
+        WantVisibleCheckBox = 0x1
+    };
+
+    explicit WindowStatesControl(unsigned flags, QWidget *parent= 0);
+
+    Qt::WindowStates states() const;
+    void setStates(Qt::WindowStates s);
+
+    bool visibleValue() const;
+    void setVisibleValue(bool);
+
+signals:
+    void changed();
+
+private:
+    QCheckBox *visibleCheckBox;
+    QCheckBox *minimizeCheckBox;
+    WindowStateControl *stateControl;
+};
+
+// Control for the type part of Qt::WindowFlags
+class TypeControl : public QGroupBox
+{
+    Q_OBJECT
+public:
+    explicit TypeControl(QWidget *parent= 0);
+
+    Qt::WindowFlags type() const;
+    void setType(Qt::WindowFlags);
+
+signals:
+    void changed(Qt::WindowFlags);
+
+private slots:
+    void slotChanged();
+
+private:
+    QButtonGroup *group;
+    QRadioButton *windowRadioButton;
+    QRadioButton *dialogRadioButton;
+    QRadioButton *sheetRadioButton;
+    QRadioButton *drawerRadioButton;
+    QRadioButton *popupRadioButton;
+    QRadioButton *toolRadioButton;
+    QRadioButton *toolTipRadioButton;
+    QRadioButton *splashScreenRadioButton;
+};
+
+#endif // CONTROLS_H
diff --git a/tests/manual/windowflags/windowflags.pro b/tests/manual/windowflags/windowflags.pro
index 81ca7ad..46e9475 100644
--- a/tests/manual/windowflags/windowflags.pro
+++ b/tests/manual/windowflags/windowflags.pro
@@ -1,8 +1,12 @@
 QT += widgets
 
 HEADERS       = controllerwindow.h \
-                previewwindow.h
+                previewwindow.h \
+                controls.h
+
 SOURCES       = controllerwindow.cpp \
                 previewwindow.cpp \
-                main.cpp
+                main.cpp \
+                controls.cpp
+
 QT += widgets
diff --git a/tests/manual/windowgeometry/controllerwidget.cpp b/tests/manual/windowgeometry/controllerwidget.cpp
index bf0697a..6014329 100644
--- a/tests/manual/windowgeometry/controllerwidget.cpp
+++ b/tests/manual/windowgeometry/controllerwidget.cpp
@@ -40,6 +40,7 @@
 ****************************************************************************/
 
 #include "controllerwidget.h"
+#include <controls.h>
 
 #if QT_VERSION >= 0x050000
 #    include <QtWidgets>
@@ -62,6 +63,7 @@ CoordinateControl::CoordinateControl(const QString &sep) : m_x(new QSpinBox), m_
     m_y->setMaximum(2000);
     connect(m_y, SIGNAL(valueChanged(int)), this, SLOT(spinBoxChanged()));
     QHBoxLayout *l = new QHBoxLayout(this);
+    l->setSpacing(2);
     l->addWidget(m_x);
     l->addWidget(new QLabel(sep));
     l->addWidget(m_y);
@@ -95,6 +97,8 @@ RectControl::RectControl()
     , m_size(new CoordinateControl(QLatin1String("x")))
 {
     QHBoxLayout *l = new QHBoxLayout(this);
+    l->setSpacing(0);
+    l->setMargin(ControlLayoutMargin);
     connect(m_point, SIGNAL(pointValueChanged(QPoint)), this, SLOT(handleChanged()));
     connect(m_point, SIGNAL(pointValueChanged(QPoint)), this, SIGNAL(positionChanged(QPoint)));
     l->addWidget(m_point);
@@ -121,26 +125,43 @@ void RectControl::handleChanged()
 }
 
 BaseWindowControl::BaseWindowControl(QObject *w)
-    : m_geometry(new RectControl)
+    : m_layout(new QGridLayout(this))
+    , m_object(w)
+    , m_geometry(new RectControl)
     , m_framePosition(new CoordinateControl(QLatin1String("x")))
+    , m_typeControl(new TypeControl)
+    , m_hintControl(new HintControl)
     , m_moveEventLabel(new QLabel(tr("Move events")))
     , m_resizeEventLabel(new QLabel(tr("Resize events")))
     , m_mouseEventLabel(new QLabel(tr("Mouse events")))
-    , m_object(w)
     , m_moveCount(0)
     , m_resizeCount(0)
 {
     m_object->installEventFilter(this);
-    QGridLayout *l = new QGridLayout(this);
     m_geometry->setTitle(tr("Geometry"));
-    l->addWidget(m_geometry, 0, 0, 1, 2);
+    int row = 0;
+    m_layout->addWidget(m_geometry, row, 0, 1, 2);
+    m_layout->setMargin(ControlLayoutMargin);
     QGroupBox *frameGB = new QGroupBox(tr("Frame"));
     QVBoxLayout *frameL = new QVBoxLayout(frameGB);
+    frameL->setSpacing(0);
+    frameL->setMargin(ControlLayoutMargin);
     frameL->addWidget(m_framePosition);
-    l->addWidget(frameGB, 0, 2);
-    l->addWidget(m_moveEventLabel, 1, 0);
-    l->addWidget(m_resizeEventLabel, 1, 1);
-    l->addWidget(m_mouseEventLabel, 1, 2);
+    m_layout->addWidget(frameGB, row, 2);
+
+    m_layout->addWidget(m_hintControl, ++row, 0, 1, 2);
+    connect(m_hintControl, SIGNAL(changed(Qt::WindowFlags)), this, SLOT(windowFlagsChanged()));
+    m_layout->addWidget(m_typeControl, row, 2);
+    connect(m_typeControl, SIGNAL(changed(Qt::WindowFlags)), this, SLOT(windowFlagsChanged()));
+
+    QGroupBox *eventGroupBox = new QGroupBox(tr("Events"));
+    QVBoxLayout *l = new QVBoxLayout(eventGroupBox);
+    l->setSpacing(0);
+    l->setMargin(ControlLayoutMargin);
+    l->addWidget(m_moveEventLabel);
+    l->addWidget(m_resizeEventLabel);
+    l->addWidget(m_mouseEventLabel);
+    m_layout->addWidget(eventGroupBox, ++row, 2);
 
     connect(m_geometry, SIGNAL(positionChanged(QPoint)), this, SLOT(posChanged(QPoint)));
     connect(m_geometry, SIGNAL(sizeChanged(QSize)), this, SLOT(sizeChanged(QSize)));
@@ -174,6 +195,8 @@ bool BaseWindowControl::eventFilter(QObject *, QEvent *e)
                                    arg(pos.x()).arg(pos.y()).arg(globalPos.x()).arg(globalPos.y()));
     }
         break;
+    case QEvent::WindowStateChange:
+        refresh();
     default:
         break;
     }
@@ -199,18 +222,32 @@ void BaseWindowControl::framePosChanged(const QPoint &p)
     setObjectFramePosition(m_object, p);
 }
 
+void BaseWindowControl::windowFlagsChanged()
+{
+    const Qt::WindowFlags f = m_typeControl->type() | m_hintControl->hints();
+    setObjectWindowFlags(m_object, f);
+}
+
 void BaseWindowControl::refresh()
 {
     m_geometry->setRectValue(objectGeometry(m_object));
     m_framePosition->setPointValue(objectFramePosition(m_object));
+    const Qt::WindowFlags flags = objectWindowFlags(m_object);
+    m_typeControl->setType(flags);
+    m_hintControl->setHints(flags);
 }
 
 // A control for a QWidget
 class WidgetWindowControl : public BaseWindowControl
 {
+    Q_OBJECT
 public:
-    explicit WidgetWindowControl(QWidget *w ) : BaseWindowControl(w)
-        { setTitle(w->windowTitle()); }
+    explicit WidgetWindowControl(QWidget *w);
+
+    virtual void refresh();
+
+private slots:
+    void statesChanged();
 
 private:
     virtual QRect objectGeometry(const QObject *o) const
@@ -223,8 +260,46 @@ private:
         { static_cast<QWidget *>(o)->move(p); }
     virtual QPoint objectMapToGlobal(const QObject *o, const QPoint &p) const
         { return static_cast<const QWidget *>(o)->mapToGlobal(p); }
+    virtual Qt::WindowFlags objectWindowFlags(const QObject *o) const
+        { return static_cast<const QWidget *>(o)->windowFlags(); }
+    virtual void setObjectWindowFlags(QObject *o, Qt::WindowFlags f);
+
+    WindowStatesControl *m_statesControl;
 };
 
+WidgetWindowControl::WidgetWindowControl(QWidget *w )
+    : BaseWindowControl(w)
+    , m_statesControl(new WindowStatesControl(WindowStatesControl::WantVisibleCheckBox))
+{
+    setTitle(w->windowTitle());
+    m_layout->addWidget(m_statesControl, 2, 0);
+    connect(m_statesControl, SIGNAL(changed()), this, SLOT(statesChanged()));
+}
+
+void WidgetWindowControl::setObjectWindowFlags(QObject *o, Qt::WindowFlags f)
+{
+    QWidget *w = static_cast<QWidget *>(o);
+    const bool visible = w->isVisible();
+    w->setWindowFlags(f); // hides.
+    if (visible)
+        w->show();
+}
+
+void WidgetWindowControl::refresh()
+{
+    const QWidget *w = static_cast<const QWidget *>(m_object);
+    m_statesControl->setVisibleValue(w->isVisible());
+    m_statesControl->setStates(w->windowState());
+    BaseWindowControl::refresh();
+}
+
+void WidgetWindowControl::statesChanged()
+{
+    QWidget *w = static_cast<QWidget *>(m_object);
+    w->setVisible(m_statesControl->visibleValue());
+    w->setWindowState(m_statesControl->states());
+}
+
 #if QT_VERSION >= 0x050000
 
 // Test window drawing diagonal lines
@@ -267,9 +342,14 @@ void Window::render()
 // A control for a QWindow
 class WindowControl : public BaseWindowControl
 {
+    Q_OBJECT
 public:
-    explicit WindowControl(QWindow *w ) : BaseWindowControl(w)
-        { setTitle(w->windowTitle()); }
+    explicit WindowControl(QWindow *w);
+
+    virtual void refresh();
+
+private slots:
+    void stateChanged();
 
 private:
     virtual QRect objectGeometry(const QObject *o) const
@@ -282,8 +362,41 @@ private:
         { static_cast<QWindow *>(o)->setFramePos(p); }
     virtual QPoint objectMapToGlobal(const QObject *o, const QPoint &p) const
         { return static_cast<const QWindow *>(o)->mapToGlobal(p); }
+    virtual Qt::WindowFlags objectWindowFlags(const QObject *o) const
+        { return static_cast<const QWindow *>(o)->windowFlags(); }
+    virtual void setObjectWindowFlags(QObject *o, Qt::WindowFlags f)
+        { static_cast<QWindow *>(o)->setWindowFlags(f); }
+
+    WindowStateControl *m_stateControl;
 };
 
+WindowControl::WindowControl(QWindow *w )
+    : BaseWindowControl(w)
+    , m_stateControl(new WindowStateControl(WindowStateControl::WantVisibleCheckBox | WindowStateControl::WantMinimizeRadioButton))
+{
+    setTitle(w->windowTitle());
+    QGroupBox *stateGroupBox = new QGroupBox(tr("State"));
+    QVBoxLayout *l = new QVBoxLayout(stateGroupBox);
+    l->addWidget(m_stateControl);
+    m_layout->addWidget(stateGroupBox, 2, 0);
+    connect(m_stateControl, SIGNAL(changed()), this, SLOT(stateChanged()));
+}
+
+void WindowControl::refresh()
+{
+    const QWindow *w = static_cast<const QWindow *>(m_object);
+    BaseWindowControl::refresh();
+    m_stateControl->setVisibleValue(w->isVisible());
+    m_stateControl->setState(w->windowState());
+}
+
+void WindowControl::stateChanged()
+{
+    QWindow *w = static_cast<QWindow *>(m_object);
+    w->setVisible(m_stateControl->visibleValue());
+    w->setWindowState(m_stateControl->state());
+}
+
 #endif
 
 ControllerWidget::ControllerWidget(QWidget *parent)
@@ -363,3 +476,5 @@ ControllerWidget::ControllerWidget(QWidget *parent)
 ControllerWidget::~ControllerWidget()
 {
 }
+
+#include "controllerwidget.moc"
diff --git a/tests/manual/windowgeometry/controllerwidget.h b/tests/manual/windowgeometry/controllerwidget.h
index d0cbcbe..9e3901b 100644
--- a/tests/manual/windowgeometry/controllerwidget.h
+++ b/tests/manual/windowgeometry/controllerwidget.h
@@ -49,8 +49,12 @@
 QT_BEGIN_NAMESPACE
 class QSpinBox;
 class QLabel;
+class QGridLayout;
 QT_END_NAMESPACE
 
+class TypeControl;
+class HintControl;
+
 // A control for editing points or sizes
 class CoordinateControl : public QWidget
 {
@@ -112,12 +116,17 @@ protected:
 
 public:
     virtual bool eventFilter(QObject *, QEvent *);
-    void refresh();
+    virtual void refresh();
 
 private slots:
     void posChanged(const QPoint &);
     void sizeChanged(const QSize &);
     void framePosChanged(const QPoint &);
+    void windowFlagsChanged();
+
+protected:
+    QGridLayout *m_layout;
+    QObject *m_object;
 
 private:
     virtual QRect objectGeometry(const QObject *o) const = 0;
@@ -126,15 +135,18 @@ private:
     virtual QPoint objectFramePosition(const QObject *o) const = 0;
     virtual void setObjectFramePosition(QObject *o, const QPoint &) const = 0;
 
+    virtual Qt::WindowFlags objectWindowFlags(const QObject *o) const = 0;
+    virtual void setObjectWindowFlags(QObject *o, Qt::WindowFlags) = 0;
+
     virtual QPoint objectMapToGlobal(const QObject *o, const QPoint &) const = 0;
 
     RectControl *m_geometry;
     CoordinateControl *m_framePosition;
+    TypeControl *m_typeControl;
+    HintControl *m_hintControl;
     QLabel *m_moveEventLabel;
     QLabel *m_resizeEventLabel;
     QLabel *m_mouseEventLabel;
-
-    QObject *m_object;
     unsigned m_moveCount;
     unsigned m_resizeCount;
 };
diff --git a/tests/manual/windowgeometry/windowgeometry.pro b/tests/manual/windowgeometry/windowgeometry.pro
index d7d19ca..4450bfd 100644
--- a/tests/manual/windowgeometry/windowgeometry.pro
+++ b/tests/manual/windowgeometry/windowgeometry.pro
@@ -2,7 +2,8 @@ QT       += core gui
 TARGET = windowgeometry
 TEMPLATE = app
 
-SOURCES += main.cpp controllerwidget.cpp
-HEADERS += controllerwidget.h
+INCLUDEPATH += ../windowflags
+SOURCES += main.cpp controllerwidget.cpp ../windowflags/controls.cpp
+HEADERS += controllerwidget.h ../windowflags/controls.h
 
 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets