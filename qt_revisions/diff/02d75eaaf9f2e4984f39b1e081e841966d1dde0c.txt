diff --git a/src/3rdparty/iaccessible2/generated/amd64/Accessible2.h b/src/3rdparty/iaccessible2/generated/amd64/Accessible2.h
new file mode 100644
index 0000000..3973db3
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/Accessible2.h
@@ -0,0 +1,585 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for Accessible2.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __Accessible2_h__
+#define __Accessible2_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessible2_FWD_DEFINED__
+#define __IAccessible2_FWD_DEFINED__
+typedef interface IAccessible2 IAccessible2;
+#endif 	/* __IAccessible2_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "AccessibleRelation.h"
+#include "AccessibleStates.h"
+#include "IA2CommonTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_Accessible2_0000_0000 */
+/* [local] */ 
+
+typedef struct IA2Locale
+    {
+    BSTR language;
+    BSTR country;
+    BSTR variant;
+    } 	IA2Locale;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_Accessible2_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_Accessible2_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAccessible2_INTERFACE_DEFINED__
+#define __IAccessible2_INTERFACE_DEFINED__
+
+/* interface IAccessible2 */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessible2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("E89F726E-C4F4-4c19-BB19-B647D7FA8478")
+    IAccessible2 : public IAccessible
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nRelations( 
+            /* [retval][out] */ long *nRelations) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_relation( 
+            /* [in] */ long relationIndex,
+            /* [retval][out] */ IAccessibleRelation **relation) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_relations( 
+            /* [in] */ long maxRelations,
+            /* [length_is][size_is][out] */ IAccessibleRelation **relations,
+            /* [retval][out] */ long *nRelations) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE role( 
+            /* [retval][out] */ long *role) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE scrollTo( 
+            /* [in] */ enum IA2ScrollType scrollType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE scrollToPoint( 
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_groupPosition( 
+            /* [out] */ long *groupLevel,
+            /* [out] */ long *similarItemsInGroup,
+            /* [retval][out] */ long *positionInGroup) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_states( 
+            /* [retval][out] */ AccessibleStates *states) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_extendedRole( 
+            /* [retval][out] */ BSTR *extendedRole) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_localizedExtendedRole( 
+            /* [retval][out] */ BSTR *localizedExtendedRole) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nExtendedStates( 
+            /* [retval][out] */ long *nExtendedStates) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_extendedStates( 
+            /* [in] */ long maxExtendedStates,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **extendedStates,
+            /* [retval][out] */ long *nExtendedStates) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_localizedExtendedStates( 
+            /* [in] */ long maxLocalizedExtendedStates,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **localizedExtendedStates,
+            /* [retval][out] */ long *nLocalizedExtendedStates) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_uniqueID( 
+            /* [retval][out] */ long *uniqueID) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_windowHandle( 
+            /* [retval][out] */ HWND *windowHandle) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_indexInParent( 
+            /* [retval][out] */ long *indexInParent) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_locale( 
+            /* [retval][out] */ IA2Locale *locale) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
+            /* [retval][out] */ BSTR *attributes) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessible2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessible2 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessible2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessible2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
+            IAccessible2 * This,
+            /* [out] */ UINT *pctinfo);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
+            IAccessible2 * This,
+            /* [in] */ UINT iTInfo,
+            /* [in] */ LCID lcid,
+            /* [out] */ ITypeInfo **ppTInfo);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
+            IAccessible2 * This,
+            /* [in] */ REFIID riid,
+            /* [size_is][in] */ LPOLESTR *rgszNames,
+            /* [range][in] */ UINT cNames,
+            /* [in] */ LCID lcid,
+            /* [size_is][out] */ DISPID *rgDispId);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
+            IAccessible2 * This,
+            /* [in] */ DISPID dispIdMember,
+            /* [in] */ REFIID riid,
+            /* [in] */ LCID lcid,
+            /* [in] */ WORD wFlags,
+            /* [out][in] */ DISPPARAMS *pDispParams,
+            /* [out] */ VARIANT *pVarResult,
+            /* [out] */ EXCEPINFO *pExcepInfo,
+            /* [out] */ UINT *puArgErr);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accParent )( 
+            IAccessible2 * This,
+            /* [retval][out] */ IDispatch **ppdispParent);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accChildCount )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *pcountChildren);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accChild )( 
+            IAccessible2 * This,
+            /* [in] */ VARIANT varChild,
+            /* [retval][out] */ IDispatch **ppdispChild);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accName )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszName);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accValue )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszValue);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accDescription )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszDescription);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accRole )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ VARIANT *pvarRole);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accState )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ VARIANT *pvarState);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accHelp )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszHelp);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accHelpTopic )( 
+            IAccessible2 * This,
+            /* [out] */ BSTR *pszHelpFile,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ long *pidTopic);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accKeyboardShortcut )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszKeyboardShortcut);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accFocus )( 
+            IAccessible2 * This,
+            /* [retval][out] */ VARIANT *pvarChild);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accSelection )( 
+            IAccessible2 * This,
+            /* [retval][out] */ VARIANT *pvarChildren);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accDefaultAction )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszDefaultAction);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accSelect )( 
+            IAccessible2 * This,
+            /* [in] */ long flagsSelect,
+            /* [optional][in] */ VARIANT varChild);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accLocation )( 
+            IAccessible2 * This,
+            /* [out] */ long *pxLeft,
+            /* [out] */ long *pyTop,
+            /* [out] */ long *pcxWidth,
+            /* [out] */ long *pcyHeight,
+            /* [optional][in] */ VARIANT varChild);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accNavigate )( 
+            IAccessible2 * This,
+            /* [in] */ long navDir,
+            /* [optional][in] */ VARIANT varStart,
+            /* [retval][out] */ VARIANT *pvarEndUpAt);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accHitTest )( 
+            IAccessible2 * This,
+            /* [in] */ long xLeft,
+            /* [in] */ long yTop,
+            /* [retval][out] */ VARIANT *pvarChild);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accDoDefaultAction )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild);
+        
+        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_accName )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [in] */ BSTR szName);
+        
+        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_accValue )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [in] */ BSTR szValue);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nRelations )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *nRelations);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_relation )( 
+            IAccessible2 * This,
+            /* [in] */ long relationIndex,
+            /* [retval][out] */ IAccessibleRelation **relation);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_relations )( 
+            IAccessible2 * This,
+            /* [in] */ long maxRelations,
+            /* [length_is][size_is][out] */ IAccessibleRelation **relations,
+            /* [retval][out] */ long *nRelations);
+        
+        HRESULT ( STDMETHODCALLTYPE *role )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *role);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollTo )( 
+            IAccessible2 * This,
+            /* [in] */ enum IA2ScrollType scrollType);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollToPoint )( 
+            IAccessible2 * This,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_groupPosition )( 
+            IAccessible2 * This,
+            /* [out] */ long *groupLevel,
+            /* [out] */ long *similarItemsInGroup,
+            /* [retval][out] */ long *positionInGroup);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_states )( 
+            IAccessible2 * This,
+            /* [retval][out] */ AccessibleStates *states);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_extendedRole )( 
+            IAccessible2 * This,
+            /* [retval][out] */ BSTR *extendedRole);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedExtendedRole )( 
+            IAccessible2 * This,
+            /* [retval][out] */ BSTR *localizedExtendedRole);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nExtendedStates )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *nExtendedStates);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_extendedStates )( 
+            IAccessible2 * This,
+            /* [in] */ long maxExtendedStates,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **extendedStates,
+            /* [retval][out] */ long *nExtendedStates);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedExtendedStates )( 
+            IAccessible2 * This,
+            /* [in] */ long maxLocalizedExtendedStates,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **localizedExtendedStates,
+            /* [retval][out] */ long *nLocalizedExtendedStates);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_uniqueID )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *uniqueID);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_windowHandle )( 
+            IAccessible2 * This,
+            /* [retval][out] */ HWND *windowHandle);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_indexInParent )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *indexInParent);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_locale )( 
+            IAccessible2 * This,
+            /* [retval][out] */ IA2Locale *locale);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
+            IAccessible2 * This,
+            /* [retval][out] */ BSTR *attributes);
+        
+        END_INTERFACE
+    } IAccessible2Vtbl;
+
+    interface IAccessible2
+    {
+        CONST_VTBL struct IAccessible2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessible2_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessible2_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessible2_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessible2_GetTypeInfoCount(This,pctinfo)	\
+    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 
+
+#define IAccessible2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
+    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 
+
+#define IAccessible2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
+    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 
+
+#define IAccessible2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
+    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 
+
+
+#define IAccessible2_get_accParent(This,ppdispParent)	\
+    ( (This)->lpVtbl -> get_accParent(This,ppdispParent) ) 
+
+#define IAccessible2_get_accChildCount(This,pcountChildren)	\
+    ( (This)->lpVtbl -> get_accChildCount(This,pcountChildren) ) 
+
+#define IAccessible2_get_accChild(This,varChild,ppdispChild)	\
+    ( (This)->lpVtbl -> get_accChild(This,varChild,ppdispChild) ) 
+
+#define IAccessible2_get_accName(This,varChild,pszName)	\
+    ( (This)->lpVtbl -> get_accName(This,varChild,pszName) ) 
+
+#define IAccessible2_get_accValue(This,varChild,pszValue)	\
+    ( (This)->lpVtbl -> get_accValue(This,varChild,pszValue) ) 
+
+#define IAccessible2_get_accDescription(This,varChild,pszDescription)	\
+    ( (This)->lpVtbl -> get_accDescription(This,varChild,pszDescription) ) 
+
+#define IAccessible2_get_accRole(This,varChild,pvarRole)	\
+    ( (This)->lpVtbl -> get_accRole(This,varChild,pvarRole) ) 
+
+#define IAccessible2_get_accState(This,varChild,pvarState)	\
+    ( (This)->lpVtbl -> get_accState(This,varChild,pvarState) ) 
+
+#define IAccessible2_get_accHelp(This,varChild,pszHelp)	\
+    ( (This)->lpVtbl -> get_accHelp(This,varChild,pszHelp) ) 
+
+#define IAccessible2_get_accHelpTopic(This,pszHelpFile,varChild,pidTopic)	\
+    ( (This)->lpVtbl -> get_accHelpTopic(This,pszHelpFile,varChild,pidTopic) ) 
+
+#define IAccessible2_get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut)	\
+    ( (This)->lpVtbl -> get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut) ) 
+
+#define IAccessible2_get_accFocus(This,pvarChild)	\
+    ( (This)->lpVtbl -> get_accFocus(This,pvarChild) ) 
+
+#define IAccessible2_get_accSelection(This,pvarChildren)	\
+    ( (This)->lpVtbl -> get_accSelection(This,pvarChildren) ) 
+
+#define IAccessible2_get_accDefaultAction(This,varChild,pszDefaultAction)	\
+    ( (This)->lpVtbl -> get_accDefaultAction(This,varChild,pszDefaultAction) ) 
+
+#define IAccessible2_accSelect(This,flagsSelect,varChild)	\
+    ( (This)->lpVtbl -> accSelect(This,flagsSelect,varChild) ) 
+
+#define IAccessible2_accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild)	\
+    ( (This)->lpVtbl -> accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild) ) 
+
+#define IAccessible2_accNavigate(This,navDir,varStart,pvarEndUpAt)	\
+    ( (This)->lpVtbl -> accNavigate(This,navDir,varStart,pvarEndUpAt) ) 
+
+#define IAccessible2_accHitTest(This,xLeft,yTop,pvarChild)	\
+    ( (This)->lpVtbl -> accHitTest(This,xLeft,yTop,pvarChild) ) 
+
+#define IAccessible2_accDoDefaultAction(This,varChild)	\
+    ( (This)->lpVtbl -> accDoDefaultAction(This,varChild) ) 
+
+#define IAccessible2_put_accName(This,varChild,szName)	\
+    ( (This)->lpVtbl -> put_accName(This,varChild,szName) ) 
+
+#define IAccessible2_put_accValue(This,varChild,szValue)	\
+    ( (This)->lpVtbl -> put_accValue(This,varChild,szValue) ) 
+
+
+#define IAccessible2_get_nRelations(This,nRelations)	\
+    ( (This)->lpVtbl -> get_nRelations(This,nRelations) ) 
+
+#define IAccessible2_get_relation(This,relationIndex,relation)	\
+    ( (This)->lpVtbl -> get_relation(This,relationIndex,relation) ) 
+
+#define IAccessible2_get_relations(This,maxRelations,relations,nRelations)	\
+    ( (This)->lpVtbl -> get_relations(This,maxRelations,relations,nRelations) ) 
+
+#define IAccessible2_role(This,role)	\
+    ( (This)->lpVtbl -> role(This,role) ) 
+
+#define IAccessible2_scrollTo(This,scrollType)	\
+    ( (This)->lpVtbl -> scrollTo(This,scrollType) ) 
+
+#define IAccessible2_scrollToPoint(This,coordinateType,x,y)	\
+    ( (This)->lpVtbl -> scrollToPoint(This,coordinateType,x,y) ) 
+
+#define IAccessible2_get_groupPosition(This,groupLevel,similarItemsInGroup,positionInGroup)	\
+    ( (This)->lpVtbl -> get_groupPosition(This,groupLevel,similarItemsInGroup,positionInGroup) ) 
+
+#define IAccessible2_get_states(This,states)	\
+    ( (This)->lpVtbl -> get_states(This,states) ) 
+
+#define IAccessible2_get_extendedRole(This,extendedRole)	\
+    ( (This)->lpVtbl -> get_extendedRole(This,extendedRole) ) 
+
+#define IAccessible2_get_localizedExtendedRole(This,localizedExtendedRole)	\
+    ( (This)->lpVtbl -> get_localizedExtendedRole(This,localizedExtendedRole) ) 
+
+#define IAccessible2_get_nExtendedStates(This,nExtendedStates)	\
+    ( (This)->lpVtbl -> get_nExtendedStates(This,nExtendedStates) ) 
+
+#define IAccessible2_get_extendedStates(This,maxExtendedStates,extendedStates,nExtendedStates)	\
+    ( (This)->lpVtbl -> get_extendedStates(This,maxExtendedStates,extendedStates,nExtendedStates) ) 
+
+#define IAccessible2_get_localizedExtendedStates(This,maxLocalizedExtendedStates,localizedExtendedStates,nLocalizedExtendedStates)	\
+    ( (This)->lpVtbl -> get_localizedExtendedStates(This,maxLocalizedExtendedStates,localizedExtendedStates,nLocalizedExtendedStates) ) 
+
+#define IAccessible2_get_uniqueID(This,uniqueID)	\
+    ( (This)->lpVtbl -> get_uniqueID(This,uniqueID) ) 
+
+#define IAccessible2_get_windowHandle(This,windowHandle)	\
+    ( (This)->lpVtbl -> get_windowHandle(This,windowHandle) ) 
+
+#define IAccessible2_get_indexInParent(This,indexInParent)	\
+    ( (This)->lpVtbl -> get_indexInParent(This,indexInParent) ) 
+
+#define IAccessible2_get_locale(This,locale)	\
+    ( (This)->lpVtbl -> get_locale(This,locale) ) 
+
+#define IAccessible2_get_attributes(This,attributes)	\
+    ( (This)->lpVtbl -> get_attributes(This,attributes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessible2_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
+unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
+unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
+void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/Accessible2_i.c b/src/3rdparty/iaccessible2/generated/amd64/Accessible2_i.c
new file mode 100644
index 0000000..480a2a7
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/Accessible2_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for Accessible2.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessible2,0xE89F726E,0xC4F4,0x4c19,0xBB,0x19,0xB6,0x47,0xD7,0xFA,0x84,0x78);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/Accessible2_p.c b/src/3rdparty/iaccessible2/generated/amd64/Accessible2_p.c
new file mode 100644
index 0000000..281718a
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/Accessible2_p.c
@@ -0,0 +1,1196 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for Accessible2.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "Accessible2.h"
+
+#define TYPE_FORMAT_STRING_SIZE   189                               
+#define PROC_FORMAT_STRING_SIZE   751                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   2            
+
+typedef struct _Accessible2_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } Accessible2_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _Accessible2_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } Accessible2_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _Accessible2_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } Accessible2_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const Accessible2_MIDL_TYPE_FORMAT_STRING Accessible2__MIDL_TypeFormatString;
+extern const Accessible2_MIDL_PROC_FORMAT_STRING Accessible2__MIDL_ProcFormatString;
+extern const Accessible2_MIDL_EXPR_FORMAT_STRING Accessible2__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessible2_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessible2_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const Accessible2_MIDL_PROC_FORMAT_STRING Accessible2__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_nRelations */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x1c ),	/* 28 */
+/*  8 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nRelations */
+
+/* 26 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_relation */
+
+/* 38 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0x1d ),	/* 29 */
+/* 46 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 52 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 54 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter relationIndex */
+
+/* 64 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 66 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 68 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter relation */
+
+/* 70 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 72 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 74 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
+
+	/* Return value */
+
+/* 76 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 78 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 80 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_relations */
+
+/* 82 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 84 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x1e ),	/* 30 */
+/* 90 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 92 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 94 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 96 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 98 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 100 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxRelations */
+
+/* 108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 110 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter relations */
+
+/* 114 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
+/* 116 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 118 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Parameter nRelations */
+
+/* 120 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 122 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 128 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure role */
+
+/* 132 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x1f ),	/* 31 */
+/* 140 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 144 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 146 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 148 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 154 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter role */
+
+/* 158 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 160 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 162 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 164 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 166 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 168 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure scrollTo */
+
+/* 170 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 172 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 176 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 178 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 180 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 182 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 184 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 186 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 192 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter scrollType */
+
+/* 196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 198 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 200 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 202 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 204 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 206 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure scrollToPoint */
+
+/* 208 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 210 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 214 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 216 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 218 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 220 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 222 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 224 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 232 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter coordinateType */
+
+/* 234 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 236 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 238 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter x */
+
+/* 240 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 242 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 244 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 246 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 248 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 250 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 254 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 256 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_groupPosition */
+
+/* 258 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 264 */	NdrFcShort( 0x22 ),	/* 34 */
+/* 266 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 268 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 270 */	NdrFcShort( 0x5c ),	/* 92 */
+/* 272 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 274 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 278 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 280 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter groupLevel */
+
+/* 284 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 286 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 288 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter similarItemsInGroup */
+
+/* 290 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 292 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 294 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter positionInGroup */
+
+/* 296 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 298 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 300 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 302 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 304 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 306 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_states */
+
+/* 308 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 310 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 314 */	NdrFcShort( 0x23 ),	/* 35 */
+/* 316 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 320 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 322 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 324 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 330 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter states */
+
+/* 334 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 336 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 338 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 340 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 342 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 344 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_extendedRole */
+
+/* 346 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 348 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 352 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 354 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 358 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 360 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 362 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 364 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 366 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 368 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 370 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter extendedRole */
+
+/* 372 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 374 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 376 */	NdrFcShort( 0x54 ),	/* Type Offset=84 */
+
+	/* Return value */
+
+/* 378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 380 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 382 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_localizedExtendedRole */
+
+/* 384 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 386 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 390 */	NdrFcShort( 0x25 ),	/* 37 */
+/* 392 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 396 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 398 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 400 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 402 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 404 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 406 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter localizedExtendedRole */
+
+/* 410 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 412 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 414 */	NdrFcShort( 0x54 ),	/* Type Offset=84 */
+
+	/* Return value */
+
+/* 416 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 418 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 420 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nExtendedStates */
+
+/* 422 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 424 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 428 */	NdrFcShort( 0x26 ),	/* 38 */
+/* 430 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 434 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 436 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 438 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 440 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 442 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 444 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 446 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nExtendedStates */
+
+/* 448 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 450 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 452 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 454 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 456 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 458 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_extendedStates */
+
+/* 460 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 462 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 466 */	NdrFcShort( 0x27 ),	/* 39 */
+/* 468 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 470 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 472 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 474 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 476 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 478 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 480 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 482 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 484 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxExtendedStates */
+
+/* 486 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 488 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 490 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter extendedStates */
+
+/* 492 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 494 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 496 */	NdrFcShort( 0x5e ),	/* Type Offset=94 */
+
+	/* Parameter nExtendedStates */
+
+/* 498 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 500 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 502 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 504 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 506 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 508 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_localizedExtendedStates */
+
+/* 510 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 512 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 516 */	NdrFcShort( 0x28 ),	/* 40 */
+/* 518 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 520 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 522 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 524 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 526 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 528 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 532 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxLocalizedExtendedStates */
+
+/* 536 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 538 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 540 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter localizedExtendedStates */
+
+/* 542 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 544 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 546 */	NdrFcShort( 0x5e ),	/* Type Offset=94 */
+
+	/* Parameter nLocalizedExtendedStates */
+
+/* 548 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 550 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 552 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 554 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 556 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 558 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_uniqueID */
+
+/* 560 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 562 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 566 */	NdrFcShort( 0x29 ),	/* 41 */
+/* 568 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 570 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 572 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 574 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 576 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 578 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 580 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 584 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter uniqueID */
+
+/* 586 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 588 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 590 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 592 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 594 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 596 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_windowHandle */
+
+/* 598 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 600 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 604 */	NdrFcShort( 0x2a ),	/* 42 */
+/* 606 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 612 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 614 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 616 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 618 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 622 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter windowHandle */
+
+/* 624 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 626 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 628 */	NdrFcShort( 0x98 ),	/* Type Offset=152 */
+
+	/* Return value */
+
+/* 630 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 632 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 634 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_indexInParent */
+
+/* 636 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 638 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 642 */	NdrFcShort( 0x2b ),	/* 43 */
+/* 644 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 646 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 648 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 650 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 652 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 654 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 656 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter indexInParent */
+
+/* 662 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 664 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 666 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 670 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 672 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_locale */
+
+/* 674 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 676 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 680 */	NdrFcShort( 0x2c ),	/* 44 */
+/* 682 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 686 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 688 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 690 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 692 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter locale */
+
+/* 700 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 702 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 704 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */
+
+	/* Return value */
+
+/* 706 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 708 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 710 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_attributes */
+
+/* 712 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 714 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 718 */	NdrFcShort( 0x2d ),	/* 45 */
+/* 720 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 722 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 724 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 726 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 728 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 730 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 732 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 734 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 736 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter attributes */
+
+/* 738 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 740 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 742 */	NdrFcShort( 0x54 ),	/* Type Offset=84 */
+
+	/* Return value */
+
+/* 744 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 746 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 748 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const Accessible2_MIDL_TYPE_FORMAT_STRING Accessible2__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
+/* 10 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 12 */	NdrFcLong( 0x7cdf86ee ),	/* 2095023854 */
+/* 16 */	NdrFcShort( 0xc3da ),	/* -15398 */
+/* 18 */	NdrFcShort( 0x496a ),	/* 18794 */
+/* 20 */	0xbd,		/* 189 */
+			0xa4,		/* 164 */
+/* 22 */	0x28,		/* 40 */
+			0x1b,		/* 27 */
+/* 24 */	0x33,		/* 51 */
+			0x6e,		/* 110 */
+/* 26 */	0x1f,		/* 31 */
+			0xdc,		/* 220 */
+/* 28 */	
+			0x11, 0x0,	/* FC_RP */
+/* 30 */	NdrFcShort( 0x2 ),	/* Offset= 2 (32) */
+/* 32 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 38 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 40 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 42 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 44 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 46 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 48 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 50 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (10) */
+/* 52 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 54 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 56 */	NdrFcShort( 0x1c ),	/* Offset= 28 (84) */
+/* 58 */	
+			0x13, 0x0,	/* FC_OP */
+/* 60 */	NdrFcShort( 0xe ),	/* Offset= 14 (74) */
+/* 62 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 64 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 66 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 68 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 70 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 72 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 74 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 76 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 78 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (62) */
+/* 80 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 82 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 84 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 92 */	NdrFcShort( 0xffde ),	/* Offset= -34 (58) */
+/* 94 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 96 */	NdrFcShort( 0x2 ),	/* Offset= 2 (98) */
+/* 98 */	
+			0x13, 0x0,	/* FC_OP */
+/* 100 */	NdrFcShort( 0x2 ),	/* Offset= 2 (102) */
+/* 102 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 108 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 110 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 112 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 114 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 116 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 118 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 120 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (84) */
+/* 122 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 124 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 126 */	NdrFcShort( 0x1a ),	/* Offset= 26 (152) */
+/* 128 */	
+			0x13, 0x0,	/* FC_OP */
+/* 130 */	NdrFcShort( 0x2 ),	/* Offset= 2 (132) */
+/* 132 */	
+			0x2a,		/* FC_ENCAPSULATED_UNION */
+			0x48,		/* 72 */
+/* 134 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 136 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 138 */	NdrFcLong( 0x48746457 ),	/* 1215587415 */
+/* 142 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 144 */	NdrFcLong( 0x52746457 ),	/* 1383359575 */
+/* 148 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 150 */	NdrFcShort( 0xffff ),	/* Offset= -1 (149) */
+/* 152 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 154 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 160 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (128) */
+/* 162 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 164 */	NdrFcShort( 0x2 ),	/* Offset= 2 (166) */
+/* 166 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 168 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 170 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 172 */	NdrFcShort( 0x0 ),	/* Offset= 0 (172) */
+/* 174 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 176 */	NdrFcShort( 0xffa4 ),	/* Offset= -92 (84) */
+/* 178 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 180 */	NdrFcShort( 0xffa0 ),	/* Offset= -96 (84) */
+/* 182 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 184 */	NdrFcShort( 0xff9c ),	/* Offset= -100 (84) */
+/* 186 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            },
+            {
+            HWND_UserSize
+            ,HWND_UserMarshal
+            ,HWND_UserUnmarshal
+            ,HWND_UserFree
+            }
+
+        };
+
+
+
+/* Standard interface: __MIDL_itf_Accessible2_0000_0000, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IDispatch, ver. 0.0,
+   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessible, ver. 0.0,
+   GUID={0x618736e0,0x3c3d,0x11cf,{0x81,0x0c,0x00,0xaa,0x00,0x38,0x9b,0x71}} */
+
+
+/* Object interface: IAccessible2, ver. 0.0,
+   GUID={0xE89F726E,0xC4F4,0x4c19,{0xBB,0x19,0xB6,0x47,0xD7,0xFA,0x84,0x78}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessible2_FormatStringOffsetTable[] =
+    {
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    0,
+    38,
+    82,
+    132,
+    170,
+    208,
+    258,
+    308,
+    346,
+    384,
+    422,
+    460,
+    510,
+    560,
+    598,
+    636,
+    674,
+    712
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessible2_ProxyInfo =
+    {
+    &Object_StubDesc,
+    Accessible2__MIDL_ProcFormatString.Format,
+    &IAccessible2_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessible2_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    Accessible2__MIDL_ProcFormatString.Format,
+    &IAccessible2_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(46) _IAccessible2ProxyVtbl = 
+{
+    &IAccessible2_ProxyInfo,
+    &IID_IAccessible2,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    0 /* IDispatch::GetTypeInfoCount */ ,
+    0 /* IDispatch::GetTypeInfo */ ,
+    0 /* IDispatch::GetIDsOfNames */ ,
+    0 /* IDispatch_Invoke_Proxy */ ,
+    0 /* IAccessible::get_accParent */ ,
+    0 /* IAccessible::get_accChildCount */ ,
+    0 /* IAccessible::get_accChild */ ,
+    0 /* IAccessible::get_accName */ ,
+    0 /* IAccessible::get_accValue */ ,
+    0 /* IAccessible::get_accDescription */ ,
+    0 /* IAccessible::get_accRole */ ,
+    0 /* IAccessible::get_accState */ ,
+    0 /* IAccessible::get_accHelp */ ,
+    0 /* IAccessible::get_accHelpTopic */ ,
+    0 /* IAccessible::get_accKeyboardShortcut */ ,
+    0 /* IAccessible::get_accFocus */ ,
+    0 /* IAccessible::get_accSelection */ ,
+    0 /* IAccessible::get_accDefaultAction */ ,
+    0 /* IAccessible::accSelect */ ,
+    0 /* IAccessible::accLocation */ ,
+    0 /* IAccessible::accNavigate */ ,
+    0 /* IAccessible::accHitTest */ ,
+    0 /* IAccessible::accDoDefaultAction */ ,
+    0 /* IAccessible::put_accName */ ,
+    0 /* IAccessible::put_accValue */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_nRelations */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_relation */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_relations */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::role */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::scrollTo */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::scrollToPoint */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_groupPosition */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_states */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_extendedRole */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_localizedExtendedRole */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_nExtendedStates */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_extendedStates */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_localizedExtendedStates */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_uniqueID */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_windowHandle */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_indexInParent */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_locale */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_attributes */
+};
+
+
+static const PRPC_STUB_FUNCTION IAccessible2_table[] =
+{
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2
+};
+
+CInterfaceStubVtbl _IAccessible2StubVtbl =
+{
+    &IID_IAccessible2,
+    &IAccessible2_ServerInfo,
+    46,
+    &IAccessible2_table[-3],
+    CStdStubBuffer_DELEGATING_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    Accessible2__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _Accessible2_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessible2ProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _Accessible2_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessible2StubVtbl,
+    0
+};
+
+PCInterfaceName const _Accessible2_InterfaceNamesList[] = 
+{
+    "IAccessible2",
+    0
+};
+
+const IID *  const _Accessible2_BaseIIDList[] = 
+{
+    &IID_IAccessible,
+    0
+};
+
+
+#define _Accessible2_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _Accessible2, pIID, n)
+
+int __stdcall _Accessible2_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_Accessible2_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo Accessible2_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _Accessible2_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _Accessible2_StubVtblList,
+    (const PCInterfaceName * ) & _Accessible2_InterfaceNamesList,
+    (const IID ** ) & _Accessible2_BaseIIDList,
+    & _Accessible2_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction.h
new file mode 100644
index 0000000..8755505
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction.h
@@ -0,0 +1,220 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for AccessibleAction.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleAction_h__
+#define __AccessibleAction_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleAction_FWD_DEFINED__
+#define __IAccessibleAction_FWD_DEFINED__
+typedef interface IAccessibleAction IAccessibleAction;
+#endif 	/* __IAccessibleAction_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleAction_INTERFACE_DEFINED__
+#define __IAccessibleAction_INTERFACE_DEFINED__
+
+/* interface IAccessibleAction */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleAction;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("B70D9F59-3B5A-4dba-AB9E-22012F607DF5")
+    IAccessibleAction : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE nActions( 
+            /* [retval][out] */ long *nActions) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE doAction( 
+            /* [in] */ long actionIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_description( 
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_keyBinding( 
+            /* [in] */ long actionIndex,
+            /* [in] */ long nMaxBindings,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **keyBindings,
+            /* [retval][out] */ long *nBindings) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_name( 
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *name) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_localizedName( 
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *localizedName) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleActionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleAction * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleAction * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleAction * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *nActions )( 
+            IAccessibleAction * This,
+            /* [retval][out] */ long *nActions);
+        
+        HRESULT ( STDMETHODCALLTYPE *doAction )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_description )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_keyBinding )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex,
+            /* [in] */ long nMaxBindings,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **keyBindings,
+            /* [retval][out] */ long *nBindings);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *name);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedName )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *localizedName);
+        
+        END_INTERFACE
+    } IAccessibleActionVtbl;
+
+    interface IAccessibleAction
+    {
+        CONST_VTBL struct IAccessibleActionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleAction_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleAction_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleAction_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleAction_nActions(This,nActions)	\
+    ( (This)->lpVtbl -> nActions(This,nActions) ) 
+
+#define IAccessibleAction_doAction(This,actionIndex)	\
+    ( (This)->lpVtbl -> doAction(This,actionIndex) ) 
+
+#define IAccessibleAction_get_description(This,actionIndex,description)	\
+    ( (This)->lpVtbl -> get_description(This,actionIndex,description) ) 
+
+#define IAccessibleAction_get_keyBinding(This,actionIndex,nMaxBindings,keyBindings,nBindings)	\
+    ( (This)->lpVtbl -> get_keyBinding(This,actionIndex,nMaxBindings,keyBindings,nBindings) ) 
+
+#define IAccessibleAction_get_name(This,actionIndex,name)	\
+    ( (This)->lpVtbl -> get_name(This,actionIndex,name) ) 
+
+#define IAccessibleAction_get_localizedName(This,actionIndex,localizedName)	\
+    ( (This)->lpVtbl -> get_localizedName(This,actionIndex,localizedName) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleAction_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction_i.c
new file mode 100644
index 0000000..a4d754b
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for AccessibleAction.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleAction,0xB70D9F59,0x3B5A,0x4dba,0xAB,0x9E,0x22,0x01,0x2F,0x60,0x7D,0xF5);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction_p.c
new file mode 100644
index 0000000..68eeac0
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleAction_p.c
@@ -0,0 +1,557 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for AccessibleAction.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleAction.h"
+
+#define TYPE_FORMAT_STRING_SIZE   77                                
+#define PROC_FORMAT_STRING_SIZE   265                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleAction_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleAction_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleAction_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleAction_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleAction_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleAction_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleAction_MIDL_TYPE_FORMAT_STRING AccessibleAction__MIDL_TypeFormatString;
+extern const AccessibleAction_MIDL_PROC_FORMAT_STRING AccessibleAction__MIDL_ProcFormatString;
+extern const AccessibleAction_MIDL_EXPR_FORMAT_STRING AccessibleAction__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleAction_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleAction_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleAction_MIDL_PROC_FORMAT_STRING AccessibleAction__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure nActions */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nActions */
+
+/* 26 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure doAction */
+
+/* 38 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 46 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 52 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 54 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 64 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 66 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 68 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 72 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_description */
+
+/* 76 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 78 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 82 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 84 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 86 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 90 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 92 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 94 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 104 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 108 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 110 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 112 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 116 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_keyBinding */
+
+/* 120 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 122 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 126 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 128 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 130 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 132 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 134 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x5,		/* 5 */
+/* 136 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 138 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 146 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 148 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 150 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter nMaxBindings */
+
+/* 152 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 154 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 156 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter keyBindings */
+
+/* 158 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 160 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 162 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */
+
+	/* Parameter nBindings */
+
+/* 164 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 166 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 168 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 170 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 172 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 174 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_name */
+
+/* 176 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 178 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 182 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 184 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 186 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 188 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 190 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 192 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 194 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 202 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 204 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 206 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter name */
+
+/* 208 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 210 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 212 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 214 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 216 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 218 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_localizedName */
+
+/* 220 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 222 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 226 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 228 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 230 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 232 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 234 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 236 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 238 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 240 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 242 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 246 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 248 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 250 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter localizedName */
+
+/* 252 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 254 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 256 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 258 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 260 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 262 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleAction_MIDL_TYPE_FORMAT_STRING AccessibleAction__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  8 */	NdrFcShort( 0x1c ),	/* Offset= 28 (36) */
+/* 10 */	
+			0x13, 0x0,	/* FC_OP */
+/* 12 */	NdrFcShort( 0xe ),	/* Offset= 14 (26) */
+/* 14 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 16 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 18 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 20 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 22 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 24 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 26 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 28 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 30 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (14) */
+/* 32 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 34 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 36 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 42 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0xffde ),	/* Offset= -34 (10) */
+/* 46 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
+/* 50 */	
+			0x13, 0x0,	/* FC_OP */
+/* 52 */	NdrFcShort( 0x2 ),	/* Offset= 2 (54) */
+/* 54 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 60 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 62 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 64 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 66 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 68 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 70 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 72 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (36) */
+/* 74 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleAction, ver. 0.0,
+   GUID={0xB70D9F59,0x3B5A,0x4dba,{0xAB,0x9E,0x22,0x01,0x2F,0x60,0x7D,0xF5}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleAction_FormatStringOffsetTable[] =
+    {
+    0,
+    38,
+    76,
+    120,
+    176,
+    220
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleAction_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleAction__MIDL_ProcFormatString.Format,
+    &IAccessibleAction_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleAction_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleAction__MIDL_ProcFormatString.Format,
+    &IAccessibleAction_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(9) _IAccessibleActionProxyVtbl = 
+{
+    &IAccessibleAction_ProxyInfo,
+    &IID_IAccessibleAction,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::nActions */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::doAction */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::get_description */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::get_keyBinding */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::get_name */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::get_localizedName */
+};
+
+const CInterfaceStubVtbl _IAccessibleActionStubVtbl =
+{
+    &IID_IAccessibleAction,
+    &IAccessibleAction_ServerInfo,
+    9,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleAction__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleAction_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleActionProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleAction_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleActionStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleAction_InterfaceNamesList[] = 
+{
+    "IAccessibleAction",
+    0
+};
+
+
+#define _AccessibleAction_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleAction, pIID, n)
+
+int __stdcall _AccessibleAction_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleAction_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleAction_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleAction_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleAction_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleAction_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleAction_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication.h
new file mode 100644
index 0000000..7e90156
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication.h
@@ -0,0 +1,188 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleApplication.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleApplication_h__
+#define __AccessibleApplication_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleApplication_FWD_DEFINED__
+#define __IAccessibleApplication_FWD_DEFINED__
+typedef interface IAccessibleApplication IAccessibleApplication;
+#endif 	/* __IAccessibleApplication_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleApplication_INTERFACE_DEFINED__
+#define __IAccessibleApplication_INTERFACE_DEFINED__
+
+/* interface IAccessibleApplication */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleApplication;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("D49DED83-5B25-43F4-9B95-93B44595979E")
+    IAccessibleApplication : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_appName( 
+            /* [retval][out] */ BSTR *name) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_appVersion( 
+            /* [retval][out] */ BSTR *version) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_toolkitName( 
+            /* [retval][out] */ BSTR *name) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_toolkitVersion( 
+            /* [retval][out] */ BSTR *version) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleApplicationVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleApplication * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleApplication * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleApplication * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_appName )( 
+            IAccessibleApplication * This,
+            /* [retval][out] */ BSTR *name);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_appVersion )( 
+            IAccessibleApplication * This,
+            /* [retval][out] */ BSTR *version);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_toolkitName )( 
+            IAccessibleApplication * This,
+            /* [retval][out] */ BSTR *name);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_toolkitVersion )( 
+            IAccessibleApplication * This,
+            /* [retval][out] */ BSTR *version);
+        
+        END_INTERFACE
+    } IAccessibleApplicationVtbl;
+
+    interface IAccessibleApplication
+    {
+        CONST_VTBL struct IAccessibleApplicationVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleApplication_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleApplication_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleApplication_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleApplication_get_appName(This,name)	\
+    ( (This)->lpVtbl -> get_appName(This,name) ) 
+
+#define IAccessibleApplication_get_appVersion(This,version)	\
+    ( (This)->lpVtbl -> get_appVersion(This,version) ) 
+
+#define IAccessibleApplication_get_toolkitName(This,name)	\
+    ( (This)->lpVtbl -> get_toolkitName(This,name) ) 
+
+#define IAccessibleApplication_get_toolkitVersion(This,version)	\
+    ( (This)->lpVtbl -> get_toolkitVersion(This,version) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleApplication_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication_i.c
new file mode 100644
index 0000000..b50ae8a
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleApplication.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleApplication,0xD49DED83,0x5B25,0x43F4,0x9B,0x95,0x93,0xB4,0x45,0x95,0x97,0x9E);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication_p.c
new file mode 100644
index 0000000..84d7e30
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleApplication_p.c
@@ -0,0 +1,420 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleApplication.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleApplication.h"
+
+#define TYPE_FORMAT_STRING_SIZE   43                                
+#define PROC_FORMAT_STRING_SIZE   153                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleApplication_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleApplication_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleApplication_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleApplication_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleApplication_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleApplication_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleApplication_MIDL_TYPE_FORMAT_STRING AccessibleApplication__MIDL_TypeFormatString;
+extern const AccessibleApplication_MIDL_PROC_FORMAT_STRING AccessibleApplication__MIDL_ProcFormatString;
+extern const AccessibleApplication_MIDL_EXPR_FORMAT_STRING AccessibleApplication__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleApplication_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleApplication_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleApplication_MIDL_PROC_FORMAT_STRING AccessibleApplication__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_appName */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter name */
+
+/* 26 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_appVersion */
+
+/* 38 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 46 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 52 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 54 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 56 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter version */
+
+/* 64 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 66 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 68 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 72 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_toolkitName */
+
+/* 76 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 78 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 82 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 84 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 90 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 92 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 94 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter name */
+
+/* 102 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 104 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 106 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 110 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_toolkitVersion */
+
+/* 114 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 116 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 122 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 128 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 130 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 132 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter version */
+
+/* 140 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 142 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 144 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 146 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 148 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 150 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleApplication_MIDL_TYPE_FORMAT_STRING AccessibleApplication__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
+/* 10 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 14 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 20 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 22 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 26 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (10) */
+/* 28 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 30 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 32 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0xffde ),	/* Offset= -34 (6) */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleApplication, ver. 0.0,
+   GUID={0xD49DED83,0x5B25,0x43F4,{0x9B,0x95,0x93,0xB4,0x45,0x95,0x97,0x9E}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleApplication_FormatStringOffsetTable[] =
+    {
+    0,
+    38,
+    76,
+    114
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleApplication_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleApplication__MIDL_ProcFormatString.Format,
+    &IAccessibleApplication_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleApplication_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleApplication__MIDL_ProcFormatString.Format,
+    &IAccessibleApplication_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(7) _IAccessibleApplicationProxyVtbl = 
+{
+    &IAccessibleApplication_ProxyInfo,
+    &IID_IAccessibleApplication,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleApplication::get_appName */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleApplication::get_appVersion */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleApplication::get_toolkitName */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleApplication::get_toolkitVersion */
+};
+
+const CInterfaceStubVtbl _IAccessibleApplicationStubVtbl =
+{
+    &IID_IAccessibleApplication,
+    &IAccessibleApplication_ServerInfo,
+    7,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleApplication__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleApplication_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleApplicationProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleApplication_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleApplicationStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleApplication_InterfaceNamesList[] = 
+{
+    "IAccessibleApplication",
+    0
+};
+
+
+#define _AccessibleApplication_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleApplication, pIID, n)
+
+int __stdcall _AccessibleApplication_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleApplication_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleApplication_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleApplication_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleApplication_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleApplication_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleApplication_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent.h
new file mode 100644
index 0000000..38f696f
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent.h
@@ -0,0 +1,185 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleComponent.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleComponent_h__
+#define __AccessibleComponent_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleComponent_FWD_DEFINED__
+#define __IAccessibleComponent_FWD_DEFINED__
+typedef interface IAccessibleComponent IAccessibleComponent;
+#endif 	/* __IAccessibleComponent_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleComponent_0000_0000 */
+/* [local] */ 
+
+typedef long IA2Color;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleComponent_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleComponent_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAccessibleComponent_INTERFACE_DEFINED__
+#define __IAccessibleComponent_INTERFACE_DEFINED__
+
+/* interface IAccessibleComponent */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleComponent;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("1546D4B0-4C98-4bda-89AE-9A64748BDDE4")
+    IAccessibleComponent : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_locationInParent( 
+            /* [out] */ long *x,
+            /* [retval][out] */ long *y) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_foreground( 
+            /* [retval][out] */ IA2Color *foreground) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_background( 
+            /* [retval][out] */ IA2Color *background) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleComponentVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleComponent * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleComponent * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleComponent * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_locationInParent )( 
+            IAccessibleComponent * This,
+            /* [out] */ long *x,
+            /* [retval][out] */ long *y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_foreground )( 
+            IAccessibleComponent * This,
+            /* [retval][out] */ IA2Color *foreground);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_background )( 
+            IAccessibleComponent * This,
+            /* [retval][out] */ IA2Color *background);
+        
+        END_INTERFACE
+    } IAccessibleComponentVtbl;
+
+    interface IAccessibleComponent
+    {
+        CONST_VTBL struct IAccessibleComponentVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleComponent_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleComponent_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleComponent_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleComponent_get_locationInParent(This,x,y)	\
+    ( (This)->lpVtbl -> get_locationInParent(This,x,y) ) 
+
+#define IAccessibleComponent_get_foreground(This,foreground)	\
+    ( (This)->lpVtbl -> get_foreground(This,foreground) ) 
+
+#define IAccessibleComponent_get_background(This,background)	\
+    ( (This)->lpVtbl -> get_background(This,background) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleComponent_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent_i.c
new file mode 100644
index 0000000..34be13e
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleComponent.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleComponent,0x1546D4B0,0x4C98,0x4bda,0x89,0xAE,0x9A,0x64,0x74,0x8B,0xDD,0xE4);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent_p.c
new file mode 100644
index 0000000..ddcacff
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleComponent_p.c
@@ -0,0 +1,360 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleComponent.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleComponent.h"
+
+#define TYPE_FORMAT_STRING_SIZE   7                                 
+#define PROC_FORMAT_STRING_SIZE   121                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   0            
+
+typedef struct _AccessibleComponent_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleComponent_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleComponent_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleComponent_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleComponent_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleComponent_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleComponent_MIDL_TYPE_FORMAT_STRING AccessibleComponent__MIDL_TypeFormatString;
+extern const AccessibleComponent_MIDL_PROC_FORMAT_STRING AccessibleComponent__MIDL_ProcFormatString;
+extern const AccessibleComponent_MIDL_EXPR_FORMAT_STRING AccessibleComponent__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleComponent_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleComponent_ProxyInfo;
+
+
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleComponent_MIDL_PROC_FORMAT_STRING AccessibleComponent__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_locationInParent */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter x */
+
+/* 26 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 32 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 38 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 40 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 42 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_foreground */
+
+/* 44 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 50 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 52 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 58 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 60 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter foreground */
+
+/* 70 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 72 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 76 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 78 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 80 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_background */
+
+/* 82 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 84 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 90 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 96 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 98 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter background */
+
+/* 108 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 110 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 116 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleComponent_MIDL_TYPE_FORMAT_STRING AccessibleComponent__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+
+			0x0
+        }
+    };
+
+
+/* Standard interface: __MIDL_itf_AccessibleComponent_0000_0000, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleComponent, ver. 0.0,
+   GUID={0x1546D4B0,0x4C98,0x4bda,{0x89,0xAE,0x9A,0x64,0x74,0x8B,0xDD,0xE4}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleComponent_FormatStringOffsetTable[] =
+    {
+    0,
+    44,
+    82
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleComponent_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleComponent__MIDL_ProcFormatString.Format,
+    &IAccessibleComponent_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleComponent_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleComponent__MIDL_ProcFormatString.Format,
+    &IAccessibleComponent_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(6) _IAccessibleComponentProxyVtbl = 
+{
+    &IAccessibleComponent_ProxyInfo,
+    &IID_IAccessibleComponent,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleComponent::get_locationInParent */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleComponent::get_foreground */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleComponent::get_background */
+};
+
+const CInterfaceStubVtbl _IAccessibleComponentStubVtbl =
+{
+    &IID_IAccessibleComponent,
+    &IAccessibleComponent_ServerInfo,
+    6,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleComponent__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    0,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleComponent_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleComponentProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleComponent_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleComponentStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleComponent_InterfaceNamesList[] = 
+{
+    "IAccessibleComponent",
+    0
+};
+
+
+#define _AccessibleComponent_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleComponent, pIID, n)
+
+int __stdcall _AccessibleComponent_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleComponent_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleComponent_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleComponent_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleComponent_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleComponent_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleComponent_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText.h
new file mode 100644
index 0000000..4c94154
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText.h
@@ -0,0 +1,235 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleEditableText.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleEditableText_h__
+#define __AccessibleEditableText_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleEditableText_FWD_DEFINED__
+#define __IAccessibleEditableText_FWD_DEFINED__
+typedef interface IAccessibleEditableText IAccessibleEditableText;
+#endif 	/* __IAccessibleEditableText_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "IA2CommonTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleEditableText_INTERFACE_DEFINED__
+#define __IAccessibleEditableText_INTERFACE_DEFINED__
+
+/* interface IAccessibleEditableText */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleEditableText;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("A59AA09A-7011-4b65-939D-32B1FB5547E3")
+    IAccessibleEditableText : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE copyText( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE deleteText( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE insertText( 
+            /* [in] */ long offset,
+            /* [in] */ BSTR *text) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE cutText( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE pasteText( 
+            /* [in] */ long offset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE replaceText( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [in] */ BSTR *text) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE setAttributes( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [in] */ BSTR *attributes) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleEditableTextVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleEditableText * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleEditableText * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleEditableText * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *copyText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        HRESULT ( STDMETHODCALLTYPE *deleteText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        HRESULT ( STDMETHODCALLTYPE *insertText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long offset,
+            /* [in] */ BSTR *text);
+        
+        HRESULT ( STDMETHODCALLTYPE *cutText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        HRESULT ( STDMETHODCALLTYPE *pasteText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long offset);
+        
+        HRESULT ( STDMETHODCALLTYPE *replaceText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [in] */ BSTR *text);
+        
+        HRESULT ( STDMETHODCALLTYPE *setAttributes )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [in] */ BSTR *attributes);
+        
+        END_INTERFACE
+    } IAccessibleEditableTextVtbl;
+
+    interface IAccessibleEditableText
+    {
+        CONST_VTBL struct IAccessibleEditableTextVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleEditableText_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleEditableText_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleEditableText_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleEditableText_copyText(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> copyText(This,startOffset,endOffset) ) 
+
+#define IAccessibleEditableText_deleteText(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> deleteText(This,startOffset,endOffset) ) 
+
+#define IAccessibleEditableText_insertText(This,offset,text)	\
+    ( (This)->lpVtbl -> insertText(This,offset,text) ) 
+
+#define IAccessibleEditableText_cutText(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> cutText(This,startOffset,endOffset) ) 
+
+#define IAccessibleEditableText_pasteText(This,offset)	\
+    ( (This)->lpVtbl -> pasteText(This,offset) ) 
+
+#define IAccessibleEditableText_replaceText(This,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> replaceText(This,startOffset,endOffset,text) ) 
+
+#define IAccessibleEditableText_setAttributes(This,startOffset,endOffset,attributes)	\
+    ( (This)->lpVtbl -> setAttributes(This,startOffset,endOffset,attributes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleEditableText_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText_i.c
new file mode 100644
index 0000000..a444951
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleEditableText.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleEditableText,0xA59AA09A,0x7011,0x4b65,0x93,0x9D,0x32,0xB1,0xFB,0x55,0x47,0xE3);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText_p.c
new file mode 100644
index 0000000..9e9b466
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleEditableText_p.c
@@ -0,0 +1,579 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleEditableText.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleEditableText.h"
+
+#define TYPE_FORMAT_STRING_SIZE   43                                
+#define PROC_FORMAT_STRING_SIZE   315                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleEditableText_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleEditableText_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleEditableText_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleEditableText_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleEditableText_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleEditableText_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleEditableText_MIDL_TYPE_FORMAT_STRING AccessibleEditableText__MIDL_TypeFormatString;
+extern const AccessibleEditableText_MIDL_PROC_FORMAT_STRING AccessibleEditableText__MIDL_ProcFormatString;
+extern const AccessibleEditableText_MIDL_EXPR_FORMAT_STRING AccessibleEditableText__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleEditableText_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleEditableText_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleEditableText_MIDL_PROC_FORMAT_STRING AccessibleEditableText__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure copyText */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 32 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 38 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 40 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 42 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure deleteText */
+
+/* 44 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 50 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 52 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 54 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 56 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 58 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 60 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 70 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 72 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 76 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 78 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 80 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 82 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 84 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 86 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure insertText */
+
+/* 88 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 90 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 96 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 98 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 100 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 102 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 104 */	0xa,		/* 10 */
+			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 108 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 112 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 114 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 116 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 120 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
+/* 122 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 124 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 128 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure cutText */
+
+/* 132 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 140 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 142 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 144 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 146 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 148 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 154 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 158 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 160 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 162 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 164 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 166 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 168 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 170 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 172 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 174 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure pasteText */
+
+/* 176 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 178 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 182 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 184 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 186 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 188 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 190 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 192 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 202 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 204 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 206 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 208 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 210 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 212 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure replaceText */
+
+/* 214 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 216 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 220 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 222 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 224 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 226 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 228 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 230 */	0xa,		/* 10 */
+			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
+/* 232 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 234 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 240 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 242 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 244 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 246 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 248 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 250 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 252 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
+/* 254 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 256 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 258 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 260 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 262 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure setAttributes */
+
+/* 264 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 266 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 270 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 272 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 274 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 276 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 278 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 280 */	0xa,		/* 10 */
+			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
+/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 284 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 288 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 290 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 292 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 294 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 296 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 298 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 300 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter attributes */
+
+/* 302 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
+/* 304 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 306 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 308 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 310 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 312 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleEditableText_MIDL_TYPE_FORMAT_STRING AccessibleEditableText__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x0,	/* FC_RP */
+/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
+/*  6 */	
+			0x12, 0x0,	/* FC_UP */
+/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
+/* 10 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 14 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 20 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 22 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 26 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (10) */
+/* 28 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 30 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 32 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0xffde ),	/* Offset= -34 (6) */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleEditableText, ver. 0.0,
+   GUID={0xA59AA09A,0x7011,0x4b65,{0x93,0x9D,0x32,0xB1,0xFB,0x55,0x47,0xE3}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleEditableText_FormatStringOffsetTable[] =
+    {
+    0,
+    44,
+    88,
+    132,
+    176,
+    214,
+    264
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleEditableText_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleEditableText__MIDL_ProcFormatString.Format,
+    &IAccessibleEditableText_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleEditableText_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleEditableText__MIDL_ProcFormatString.Format,
+    &IAccessibleEditableText_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(10) _IAccessibleEditableTextProxyVtbl = 
+{
+    &IAccessibleEditableText_ProxyInfo,
+    &IID_IAccessibleEditableText,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::copyText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::deleteText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::insertText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::cutText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::pasteText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::replaceText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::setAttributes */
+};
+
+const CInterfaceStubVtbl _IAccessibleEditableTextStubVtbl =
+{
+    &IID_IAccessibleEditableText,
+    &IAccessibleEditableText_ServerInfo,
+    10,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleEditableText__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleEditableText_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleEditableTextProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleEditableText_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleEditableTextStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleEditableText_InterfaceNamesList[] = 
+{
+    "IAccessibleEditableText",
+    0
+};
+
+
+#define _AccessibleEditableText_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleEditableText, pIID, n)
+
+int __stdcall _AccessibleEditableText_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleEditableText_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleEditableText_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleEditableText_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleEditableText_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleEditableText_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleEditableText_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleEventID.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleEventID.h
new file mode 100644
index 0000000..6e6c8a8
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleEventID.h
@@ -0,0 +1,105 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleEventID.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __AccessibleEventID_h__
+#define __AccessibleEventID_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleEventID_0000_0000 */
+/* [local] */ 
+
+
+enum IA2EventID
+    {	IA2_EVENT_ACTION_CHANGED	= 0x101,
+	IA2_EVENT_ACTIVE_DECENDENT_CHANGED	= ( IA2_EVENT_ACTION_CHANGED + 1 ) ,
+	IA2_EVENT_ACTIVE_DESCENDANT_CHANGED	= IA2_EVENT_ACTIVE_DECENDENT_CHANGED,
+	IA2_EVENT_DOCUMENT_ATTRIBUTE_CHANGED	= ( IA2_EVENT_ACTIVE_DESCENDANT_CHANGED + 1 ) ,
+	IA2_EVENT_DOCUMENT_CONTENT_CHANGED	= ( IA2_EVENT_DOCUMENT_ATTRIBUTE_CHANGED + 1 ) ,
+	IA2_EVENT_DOCUMENT_LOAD_COMPLETE	= ( IA2_EVENT_DOCUMENT_CONTENT_CHANGED + 1 ) ,
+	IA2_EVENT_DOCUMENT_LOAD_STOPPED	= ( IA2_EVENT_DOCUMENT_LOAD_COMPLETE + 1 ) ,
+	IA2_EVENT_DOCUMENT_RELOAD	= ( IA2_EVENT_DOCUMENT_LOAD_STOPPED + 1 ) ,
+	IA2_EVENT_HYPERLINK_END_INDEX_CHANGED	= ( IA2_EVENT_DOCUMENT_RELOAD + 1 ) ,
+	IA2_EVENT_HYPERLINK_NUMBER_OF_ANCHORS_CHANGED	= ( IA2_EVENT_HYPERLINK_END_INDEX_CHANGED + 1 ) ,
+	IA2_EVENT_HYPERLINK_SELECTED_LINK_CHANGED	= ( IA2_EVENT_HYPERLINK_NUMBER_OF_ANCHORS_CHANGED + 1 ) ,
+	IA2_EVENT_HYPERTEXT_LINK_ACTIVATED	= ( IA2_EVENT_HYPERLINK_SELECTED_LINK_CHANGED + 1 ) ,
+	IA2_EVENT_HYPERTEXT_LINK_SELECTED	= ( IA2_EVENT_HYPERTEXT_LINK_ACTIVATED + 1 ) ,
+	IA2_EVENT_HYPERLINK_START_INDEX_CHANGED	= ( IA2_EVENT_HYPERTEXT_LINK_SELECTED + 1 ) ,
+	IA2_EVENT_HYPERTEXT_CHANGED	= ( IA2_EVENT_HYPERLINK_START_INDEX_CHANGED + 1 ) ,
+	IA2_EVENT_HYPERTEXT_NLINKS_CHANGED	= ( IA2_EVENT_HYPERTEXT_CHANGED + 1 ) ,
+	IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED	= ( IA2_EVENT_HYPERTEXT_NLINKS_CHANGED + 1 ) ,
+	IA2_EVENT_PAGE_CHANGED	= ( IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED + 1 ) ,
+	IA2_EVENT_SECTION_CHANGED	= ( IA2_EVENT_PAGE_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_CAPTION_CHANGED	= ( IA2_EVENT_SECTION_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_COLUMN_DESCRIPTION_CHANGED	= ( IA2_EVENT_TABLE_CAPTION_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_COLUMN_HEADER_CHANGED	= ( IA2_EVENT_TABLE_COLUMN_DESCRIPTION_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_MODEL_CHANGED	= ( IA2_EVENT_TABLE_COLUMN_HEADER_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_ROW_DESCRIPTION_CHANGED	= ( IA2_EVENT_TABLE_MODEL_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_ROW_HEADER_CHANGED	= ( IA2_EVENT_TABLE_ROW_DESCRIPTION_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_SUMMARY_CHANGED	= ( IA2_EVENT_TABLE_ROW_HEADER_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_ATTRIBUTE_CHANGED	= ( IA2_EVENT_TABLE_SUMMARY_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_CARET_MOVED	= ( IA2_EVENT_TEXT_ATTRIBUTE_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_CHANGED	= ( IA2_EVENT_TEXT_CARET_MOVED + 1 ) ,
+	IA2_EVENT_TEXT_COLUMN_CHANGED	= ( IA2_EVENT_TEXT_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_INSERTED	= ( IA2_EVENT_TEXT_COLUMN_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_REMOVED	= ( IA2_EVENT_TEXT_INSERTED + 1 ) ,
+	IA2_EVENT_TEXT_UPDATED	= ( IA2_EVENT_TEXT_REMOVED + 1 ) ,
+	IA2_EVENT_TEXT_SELECTION_CHANGED	= ( IA2_EVENT_TEXT_UPDATED + 1 ) ,
+	IA2_EVENT_VISIBLE_DATA_CHANGED	= ( IA2_EVENT_TEXT_SELECTION_CHANGED + 1 ) 
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleEventID_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleEventID_0000_0000_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink.h
new file mode 100644
index 0000000..24fad0b
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink.h
@@ -0,0 +1,252 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleHyperlink.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleHyperlink_h__
+#define __AccessibleHyperlink_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleHyperlink_FWD_DEFINED__
+#define __IAccessibleHyperlink_FWD_DEFINED__
+typedef interface IAccessibleHyperlink IAccessibleHyperlink;
+#endif 	/* __IAccessibleHyperlink_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "AccessibleAction.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleHyperlink_INTERFACE_DEFINED__
+#define __IAccessibleHyperlink_INTERFACE_DEFINED__
+
+/* interface IAccessibleHyperlink */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleHyperlink;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("01C20F2B-3DD2-400f-949F-AD00BDAB1D41")
+    IAccessibleHyperlink : public IAccessibleAction
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_anchor( 
+            /* [in] */ long index,
+            /* [retval][out] */ VARIANT *anchor) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_anchorTarget( 
+            /* [in] */ long index,
+            /* [retval][out] */ VARIANT *anchorTarget) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_startIndex( 
+            /* [retval][out] */ long *index) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_endIndex( 
+            /* [retval][out] */ long *index) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_valid( 
+            /* [retval][out] */ boolean *valid) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleHyperlinkVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleHyperlink * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleHyperlink * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *nActions )( 
+            IAccessibleHyperlink * This,
+            /* [retval][out] */ long *nActions);
+        
+        HRESULT ( STDMETHODCALLTYPE *doAction )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_description )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_keyBinding )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex,
+            /* [in] */ long nMaxBindings,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **keyBindings,
+            /* [retval][out] */ long *nBindings);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *name);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedName )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *localizedName);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_anchor )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long index,
+            /* [retval][out] */ VARIANT *anchor);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_anchorTarget )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long index,
+            /* [retval][out] */ VARIANT *anchorTarget);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_startIndex )( 
+            IAccessibleHyperlink * This,
+            /* [retval][out] */ long *index);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_endIndex )( 
+            IAccessibleHyperlink * This,
+            /* [retval][out] */ long *index);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_valid )( 
+            IAccessibleHyperlink * This,
+            /* [retval][out] */ boolean *valid);
+        
+        END_INTERFACE
+    } IAccessibleHyperlinkVtbl;
+
+    interface IAccessibleHyperlink
+    {
+        CONST_VTBL struct IAccessibleHyperlinkVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleHyperlink_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleHyperlink_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleHyperlink_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleHyperlink_nActions(This,nActions)	\
+    ( (This)->lpVtbl -> nActions(This,nActions) ) 
+
+#define IAccessibleHyperlink_doAction(This,actionIndex)	\
+    ( (This)->lpVtbl -> doAction(This,actionIndex) ) 
+
+#define IAccessibleHyperlink_get_description(This,actionIndex,description)	\
+    ( (This)->lpVtbl -> get_description(This,actionIndex,description) ) 
+
+#define IAccessibleHyperlink_get_keyBinding(This,actionIndex,nMaxBindings,keyBindings,nBindings)	\
+    ( (This)->lpVtbl -> get_keyBinding(This,actionIndex,nMaxBindings,keyBindings,nBindings) ) 
+
+#define IAccessibleHyperlink_get_name(This,actionIndex,name)	\
+    ( (This)->lpVtbl -> get_name(This,actionIndex,name) ) 
+
+#define IAccessibleHyperlink_get_localizedName(This,actionIndex,localizedName)	\
+    ( (This)->lpVtbl -> get_localizedName(This,actionIndex,localizedName) ) 
+
+
+#define IAccessibleHyperlink_get_anchor(This,index,anchor)	\
+    ( (This)->lpVtbl -> get_anchor(This,index,anchor) ) 
+
+#define IAccessibleHyperlink_get_anchorTarget(This,index,anchorTarget)	\
+    ( (This)->lpVtbl -> get_anchorTarget(This,index,anchorTarget) ) 
+
+#define IAccessibleHyperlink_get_startIndex(This,index)	\
+    ( (This)->lpVtbl -> get_startIndex(This,index) ) 
+
+#define IAccessibleHyperlink_get_endIndex(This,index)	\
+    ( (This)->lpVtbl -> get_endIndex(This,index) ) 
+
+#define IAccessibleHyperlink_get_valid(This,valid)	\
+    ( (This)->lpVtbl -> get_valid(This,valid) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleHyperlink_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
+unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
+unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
+void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink_i.c
new file mode 100644
index 0000000..f668740
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleHyperlink.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleHyperlink,0x01C20F2B,0x3DD2,0x400f,0x94,0x9F,0xAD,0x00,0xBD,0xAB,0x1D,0x41);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink_p.c
new file mode 100644
index 0000000..4cf0a13
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHyperlink_p.c
@@ -0,0 +1,1113 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:57 2012
+ */
+/* Compiler settings for AccessibleHyperlink.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleHyperlink.h"
+
+#define TYPE_FORMAT_STRING_SIZE   997                               
+#define PROC_FORMAT_STRING_SIZE   203                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleHyperlink_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleHyperlink_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleHyperlink_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleHyperlink_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleHyperlink_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleHyperlink_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleHyperlink_MIDL_TYPE_FORMAT_STRING AccessibleHyperlink__MIDL_TypeFormatString;
+extern const AccessibleHyperlink_MIDL_PROC_FORMAT_STRING AccessibleHyperlink__MIDL_ProcFormatString;
+extern const AccessibleHyperlink_MIDL_EXPR_FORMAT_STRING AccessibleHyperlink__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleHyperlink_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleHyperlink_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleHyperlink_MIDL_PROC_FORMAT_STRING AccessibleHyperlink__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_anchor */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x9 ),	/* 9 */
+/*  8 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 16 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter anchor */
+
+/* 32 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	NdrFcShort( 0x3d2 ),	/* Type Offset=978 */
+
+	/* Return value */
+
+/* 38 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 40 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 42 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_anchorTarget */
+
+/* 44 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 50 */	NdrFcShort( 0xa ),	/* 10 */
+/* 52 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 56 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 58 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 60 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 62 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 70 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 72 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter anchorTarget */
+
+/* 76 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 78 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 80 */	NdrFcShort( 0x3d2 ),	/* Type Offset=978 */
+
+	/* Return value */
+
+/* 82 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 84 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 86 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_startIndex */
+
+/* 88 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 90 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0xb ),	/* 11 */
+/* 96 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 102 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 104 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 112 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 114 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 116 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 122 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_endIndex */
+
+/* 126 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 128 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 132 */	NdrFcShort( 0xc ),	/* 12 */
+/* 134 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 140 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 142 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 148 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 152 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 154 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 156 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 158 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 160 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 162 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_valid */
+
+/* 164 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 166 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 170 */	NdrFcShort( 0xd ),	/* 13 */
+/* 172 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 176 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 178 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 180 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 186 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter valid */
+
+/* 190 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 192 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 194 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 196 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 198 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 200 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleHyperlink_MIDL_TYPE_FORMAT_STRING AccessibleHyperlink__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x3ce ),	/* Offset= 974 (978) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0x3b6 ),	/* Offset= 950 (958) */
+/* 10 */	
+			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
+			0x9,		/* FC_ULONG */
+/* 12 */	0x7,		/* Corr desc: FC_USHORT */
+			0x0,		/*  */
+/* 14 */	NdrFcShort( 0xfff8 ),	/* -8 */
+/* 16 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 18 */	NdrFcShort( 0x2 ),	/* Offset= 2 (20) */
+/* 20 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 22 */	NdrFcShort( 0x2f ),	/* 47 */
+/* 24 */	NdrFcLong( 0x14 ),	/* 20 */
+/* 28 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
+/* 30 */	NdrFcLong( 0x3 ),	/* 3 */
+/* 34 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 36 */	NdrFcLong( 0x11 ),	/* 17 */
+/* 40 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
+/* 42 */	NdrFcLong( 0x2 ),	/* 2 */
+/* 46 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 48 */	NdrFcLong( 0x4 ),	/* 4 */
+/* 52 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
+/* 54 */	NdrFcLong( 0x5 ),	/* 5 */
+/* 58 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
+/* 60 */	NdrFcLong( 0xb ),	/* 11 */
+/* 64 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 66 */	NdrFcLong( 0xa ),	/* 10 */
+/* 70 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 72 */	NdrFcLong( 0x6 ),	/* 6 */
+/* 76 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (308) */
+/* 78 */	NdrFcLong( 0x7 ),	/* 7 */
+/* 82 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
+/* 84 */	NdrFcLong( 0x8 ),	/* 8 */
+/* 88 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (314) */
+/* 90 */	NdrFcLong( 0xd ),	/* 13 */
+/* 94 */	NdrFcShort( 0xf6 ),	/* Offset= 246 (340) */
+/* 96 */	NdrFcLong( 0x9 ),	/* 9 */
+/* 100 */	NdrFcShort( 0x102 ),	/* Offset= 258 (358) */
+/* 102 */	NdrFcLong( 0x2000 ),	/* 8192 */
+/* 106 */	NdrFcShort( 0x10e ),	/* Offset= 270 (376) */
+/* 108 */	NdrFcLong( 0x24 ),	/* 36 */
+/* 112 */	NdrFcShort( 0x304 ),	/* Offset= 772 (884) */
+/* 114 */	NdrFcLong( 0x4024 ),	/* 16420 */
+/* 118 */	NdrFcShort( 0x2fe ),	/* Offset= 766 (884) */
+/* 120 */	NdrFcLong( 0x4011 ),	/* 16401 */
+/* 124 */	NdrFcShort( 0x2fc ),	/* Offset= 764 (888) */
+/* 126 */	NdrFcLong( 0x4002 ),	/* 16386 */
+/* 130 */	NdrFcShort( 0x2fa ),	/* Offset= 762 (892) */
+/* 132 */	NdrFcLong( 0x4003 ),	/* 16387 */
+/* 136 */	NdrFcShort( 0x2f8 ),	/* Offset= 760 (896) */
+/* 138 */	NdrFcLong( 0x4014 ),	/* 16404 */
+/* 142 */	NdrFcShort( 0x2f6 ),	/* Offset= 758 (900) */
+/* 144 */	NdrFcLong( 0x4004 ),	/* 16388 */
+/* 148 */	NdrFcShort( 0x2f4 ),	/* Offset= 756 (904) */
+/* 150 */	NdrFcLong( 0x4005 ),	/* 16389 */
+/* 154 */	NdrFcShort( 0x2f2 ),	/* Offset= 754 (908) */
+/* 156 */	NdrFcLong( 0x400b ),	/* 16395 */
+/* 160 */	NdrFcShort( 0x2dc ),	/* Offset= 732 (892) */
+/* 162 */	NdrFcLong( 0x400a ),	/* 16394 */
+/* 166 */	NdrFcShort( 0x2da ),	/* Offset= 730 (896) */
+/* 168 */	NdrFcLong( 0x4006 ),	/* 16390 */
+/* 172 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (912) */
+/* 174 */	NdrFcLong( 0x4007 ),	/* 16391 */
+/* 178 */	NdrFcShort( 0x2da ),	/* Offset= 730 (908) */
+/* 180 */	NdrFcLong( 0x4008 ),	/* 16392 */
+/* 184 */	NdrFcShort( 0x2dc ),	/* Offset= 732 (916) */
+/* 186 */	NdrFcLong( 0x400d ),	/* 16397 */
+/* 190 */	NdrFcShort( 0x2da ),	/* Offset= 730 (920) */
+/* 192 */	NdrFcLong( 0x4009 ),	/* 16393 */
+/* 196 */	NdrFcShort( 0x2d8 ),	/* Offset= 728 (924) */
+/* 198 */	NdrFcLong( 0x6000 ),	/* 24576 */
+/* 202 */	NdrFcShort( 0x2d6 ),	/* Offset= 726 (928) */
+/* 204 */	NdrFcLong( 0x400c ),	/* 16396 */
+/* 208 */	NdrFcShort( 0x2d4 ),	/* Offset= 724 (932) */
+/* 210 */	NdrFcLong( 0x10 ),	/* 16 */
+/* 214 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
+/* 216 */	NdrFcLong( 0x12 ),	/* 18 */
+/* 220 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 222 */	NdrFcLong( 0x13 ),	/* 19 */
+/* 226 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 228 */	NdrFcLong( 0x15 ),	/* 21 */
+/* 232 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
+/* 234 */	NdrFcLong( 0x16 ),	/* 22 */
+/* 238 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 240 */	NdrFcLong( 0x17 ),	/* 23 */
+/* 244 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 246 */	NdrFcLong( 0xe ),	/* 14 */
+/* 250 */	NdrFcShort( 0x2b2 ),	/* Offset= 690 (940) */
+/* 252 */	NdrFcLong( 0x400e ),	/* 16398 */
+/* 256 */	NdrFcShort( 0x2b6 ),	/* Offset= 694 (950) */
+/* 258 */	NdrFcLong( 0x4010 ),	/* 16400 */
+/* 262 */	NdrFcShort( 0x2b4 ),	/* Offset= 692 (954) */
+/* 264 */	NdrFcLong( 0x4012 ),	/* 16402 */
+/* 268 */	NdrFcShort( 0x270 ),	/* Offset= 624 (892) */
+/* 270 */	NdrFcLong( 0x4013 ),	/* 16403 */
+/* 274 */	NdrFcShort( 0x26e ),	/* Offset= 622 (896) */
+/* 276 */	NdrFcLong( 0x4015 ),	/* 16405 */
+/* 280 */	NdrFcShort( 0x26c ),	/* Offset= 620 (900) */
+/* 282 */	NdrFcLong( 0x4016 ),	/* 16406 */
+/* 286 */	NdrFcShort( 0x262 ),	/* Offset= 610 (896) */
+/* 288 */	NdrFcLong( 0x4017 ),	/* 16407 */
+/* 292 */	NdrFcShort( 0x25c ),	/* Offset= 604 (896) */
+/* 294 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 298 */	NdrFcShort( 0x0 ),	/* Offset= 0 (298) */
+/* 300 */	NdrFcLong( 0x1 ),	/* 1 */
+/* 304 */	NdrFcShort( 0x0 ),	/* Offset= 0 (304) */
+/* 306 */	NdrFcShort( 0xffff ),	/* Offset= -1 (305) */
+/* 308 */	
+			0x15,		/* FC_STRUCT */
+			0x7,		/* 7 */
+/* 310 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 312 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 314 */	
+			0x13, 0x0,	/* FC_OP */
+/* 316 */	NdrFcShort( 0xe ),	/* Offset= 14 (330) */
+/* 318 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 320 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 322 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 324 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 326 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 328 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 330 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 332 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 334 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (318) */
+/* 336 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 338 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 340 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 342 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 348 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 350 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 352 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 354 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 356 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 358 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 360 */	NdrFcLong( 0x20400 ),	/* 132096 */
+/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 366 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 368 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 370 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 372 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 374 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 376 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 378 */	NdrFcShort( 0x2 ),	/* Offset= 2 (380) */
+/* 380 */	
+			0x13, 0x0,	/* FC_OP */
+/* 382 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (866) */
+/* 384 */	
+			0x2a,		/* FC_ENCAPSULATED_UNION */
+			0x89,		/* 137 */
+/* 386 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 388 */	NdrFcShort( 0xa ),	/* 10 */
+/* 390 */	NdrFcLong( 0x8 ),	/* 8 */
+/* 394 */	NdrFcShort( 0x50 ),	/* Offset= 80 (474) */
+/* 396 */	NdrFcLong( 0xd ),	/* 13 */
+/* 400 */	NdrFcShort( 0x70 ),	/* Offset= 112 (512) */
+/* 402 */	NdrFcLong( 0x9 ),	/* 9 */
+/* 406 */	NdrFcShort( 0x90 ),	/* Offset= 144 (550) */
+/* 408 */	NdrFcLong( 0xc ),	/* 12 */
+/* 412 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (588) */
+/* 414 */	NdrFcLong( 0x24 ),	/* 36 */
+/* 418 */	NdrFcShort( 0x102 ),	/* Offset= 258 (676) */
+/* 420 */	NdrFcLong( 0x800d ),	/* 32781 */
+/* 424 */	NdrFcShort( 0x11e ),	/* Offset= 286 (710) */
+/* 426 */	NdrFcLong( 0x10 ),	/* 16 */
+/* 430 */	NdrFcShort( 0x138 ),	/* Offset= 312 (742) */
+/* 432 */	NdrFcLong( 0x2 ),	/* 2 */
+/* 436 */	NdrFcShort( 0x14e ),	/* Offset= 334 (770) */
+/* 438 */	NdrFcLong( 0x3 ),	/* 3 */
+/* 442 */	NdrFcShort( 0x164 ),	/* Offset= 356 (798) */
+/* 444 */	NdrFcLong( 0x14 ),	/* 20 */
+/* 448 */	NdrFcShort( 0x17a ),	/* Offset= 378 (826) */
+/* 450 */	NdrFcShort( 0xffff ),	/* Offset= -1 (449) */
+/* 452 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 456 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 460 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 462 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 466 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 468 */	
+			0x13, 0x0,	/* FC_OP */
+/* 470 */	NdrFcShort( 0xff74 ),	/* Offset= -140 (330) */
+/* 472 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 474 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 476 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 480 */	NdrFcShort( 0x6 ),	/* Offset= 6 (486) */
+/* 482 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 484 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 486 */	
+			0x11, 0x0,	/* FC_RP */
+/* 488 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (452) */
+/* 490 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 492 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 494 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 496 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 498 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 500 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 504 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 506 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 508 */	NdrFcShort( 0xff58 ),	/* Offset= -168 (340) */
+/* 510 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 512 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 514 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 516 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 518 */	NdrFcShort( 0x6 ),	/* Offset= 6 (524) */
+/* 520 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 522 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 524 */	
+			0x11, 0x0,	/* FC_RP */
+/* 526 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (490) */
+/* 528 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 532 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 536 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 538 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 542 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 544 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 546 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (358) */
+/* 548 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 550 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 552 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 556 */	NdrFcShort( 0x6 ),	/* Offset= 6 (562) */
+/* 558 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 560 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 562 */	
+			0x11, 0x0,	/* FC_RP */
+/* 564 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (528) */
+/* 566 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 568 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 570 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 572 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 574 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 576 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 580 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 582 */	
+			0x13, 0x0,	/* FC_OP */
+/* 584 */	NdrFcShort( 0x176 ),	/* Offset= 374 (958) */
+/* 586 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 588 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 590 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 592 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 594 */	NdrFcShort( 0x6 ),	/* Offset= 6 (600) */
+/* 596 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 598 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 600 */	
+			0x11, 0x0,	/* FC_RP */
+/* 602 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (566) */
+/* 604 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 606 */	NdrFcLong( 0x2f ),	/* 47 */
+/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 612 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 614 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 616 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 618 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 620 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 622 */	
+			0x1b,		/* FC_CARRAY */
+			0x0,		/* 0 */
+/* 624 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 626 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 628 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 630 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 632 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 634 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 636 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 638 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 640 */	NdrFcShort( 0xa ),	/* Offset= 10 (650) */
+/* 642 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 644 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 646 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (604) */
+/* 648 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 650 */	
+			0x13, 0x0,	/* FC_OP */
+/* 652 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (622) */
+/* 654 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 656 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 658 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 662 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 664 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 668 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 670 */	
+			0x13, 0x0,	/* FC_OP */
+/* 672 */	NdrFcShort( 0xffda ),	/* Offset= -38 (634) */
+/* 674 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 676 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 678 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 680 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 682 */	NdrFcShort( 0x6 ),	/* Offset= 6 (688) */
+/* 684 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 686 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 688 */	
+			0x11, 0x0,	/* FC_RP */
+/* 690 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (654) */
+/* 692 */	
+			0x1d,		/* FC_SMFARRAY */
+			0x0,		/* 0 */
+/* 694 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 696 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 698 */	
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 700 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 702 */	0x8,		/* FC_LONG */
+			0x6,		/* FC_SHORT */
+/* 704 */	0x6,		/* FC_SHORT */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 706 */	0x0,		/* 0 */
+			NdrFcShort( 0xfff1 ),	/* Offset= -15 (692) */
+			0x5b,		/* FC_END */
+/* 710 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 712 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 716 */	NdrFcShort( 0xa ),	/* Offset= 10 (726) */
+/* 718 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 720 */	0x36,		/* FC_POINTER */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 722 */	0x0,		/* 0 */
+			NdrFcShort( 0xffe7 ),	/* Offset= -25 (698) */
+			0x5b,		/* FC_END */
+/* 726 */	
+			0x11, 0x0,	/* FC_RP */
+/* 728 */	NdrFcShort( 0xff12 ),	/* Offset= -238 (490) */
+/* 730 */	
+			0x1b,		/* FC_CARRAY */
+			0x0,		/* 0 */
+/* 732 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 734 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 736 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 738 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 740 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 742 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 744 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 746 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 748 */	NdrFcShort( 0x6 ),	/* Offset= 6 (754) */
+/* 750 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 752 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 754 */	
+			0x13, 0x0,	/* FC_OP */
+/* 756 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (730) */
+/* 758 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 760 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 762 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 764 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 766 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 768 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 770 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 772 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 774 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 776 */	NdrFcShort( 0x6 ),	/* Offset= 6 (782) */
+/* 778 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 780 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 782 */	
+			0x13, 0x0,	/* FC_OP */
+/* 784 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (758) */
+/* 786 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 788 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 790 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 792 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 794 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 796 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 798 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 800 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 802 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 804 */	NdrFcShort( 0x6 ),	/* Offset= 6 (810) */
+/* 806 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 808 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 810 */	
+			0x13, 0x0,	/* FC_OP */
+/* 812 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (786) */
+/* 814 */	
+			0x1b,		/* FC_CARRAY */
+			0x7,		/* 7 */
+/* 816 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 818 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 820 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 822 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 824 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 826 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 828 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 832 */	NdrFcShort( 0x6 ),	/* Offset= 6 (838) */
+/* 834 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 836 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 838 */	
+			0x13, 0x0,	/* FC_OP */
+/* 840 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (814) */
+/* 842 */	
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 844 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 846 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 848 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 850 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 852 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 854 */	0x7,		/* Corr desc: FC_USHORT */
+			0x0,		/*  */
+/* 856 */	NdrFcShort( 0xffc8 ),	/* -56 */
+/* 858 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 860 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 862 */	NdrFcShort( 0xffec ),	/* Offset= -20 (842) */
+/* 864 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 866 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 868 */	NdrFcShort( 0x38 ),	/* 56 */
+/* 870 */	NdrFcShort( 0xffec ),	/* Offset= -20 (850) */
+/* 872 */	NdrFcShort( 0x0 ),	/* Offset= 0 (872) */
+/* 874 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 876 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 878 */	0x40,		/* FC_STRUCTPAD4 */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 880 */	0x0,		/* 0 */
+			NdrFcShort( 0xfe0f ),	/* Offset= -497 (384) */
+			0x5b,		/* FC_END */
+/* 884 */	
+			0x13, 0x0,	/* FC_OP */
+/* 886 */	NdrFcShort( 0xff04 ),	/* Offset= -252 (634) */
+/* 888 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 890 */	0x1,		/* FC_BYTE */
+			0x5c,		/* FC_PAD */
+/* 892 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 894 */	0x6,		/* FC_SHORT */
+			0x5c,		/* FC_PAD */
+/* 896 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 898 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 900 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 902 */	0xb,		/* FC_HYPER */
+			0x5c,		/* FC_PAD */
+/* 904 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 906 */	0xa,		/* FC_FLOAT */
+			0x5c,		/* FC_PAD */
+/* 908 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 910 */	0xc,		/* FC_DOUBLE */
+			0x5c,		/* FC_PAD */
+/* 912 */	
+			0x13, 0x0,	/* FC_OP */
+/* 914 */	NdrFcShort( 0xfda2 ),	/* Offset= -606 (308) */
+/* 916 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 918 */	NdrFcShort( 0xfda4 ),	/* Offset= -604 (314) */
+/* 920 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 922 */	NdrFcShort( 0xfdba ),	/* Offset= -582 (340) */
+/* 924 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 926 */	NdrFcShort( 0xfdc8 ),	/* Offset= -568 (358) */
+/* 928 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 930 */	NdrFcShort( 0xfdd6 ),	/* Offset= -554 (376) */
+/* 932 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 934 */	NdrFcShort( 0x2 ),	/* Offset= 2 (936) */
+/* 936 */	
+			0x13, 0x0,	/* FC_OP */
+/* 938 */	NdrFcShort( 0x14 ),	/* Offset= 20 (958) */
+/* 940 */	
+			0x15,		/* FC_STRUCT */
+			0x7,		/* 7 */
+/* 942 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 944 */	0x6,		/* FC_SHORT */
+			0x1,		/* FC_BYTE */
+/* 946 */	0x1,		/* FC_BYTE */
+			0x8,		/* FC_LONG */
+/* 948 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 950 */	
+			0x13, 0x0,	/* FC_OP */
+/* 952 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (940) */
+/* 954 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 956 */	0x2,		/* FC_CHAR */
+			0x5c,		/* FC_PAD */
+/* 958 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x7,		/* 7 */
+/* 960 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 962 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 964 */	NdrFcShort( 0x0 ),	/* Offset= 0 (964) */
+/* 966 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 968 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 970 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 972 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 974 */	NdrFcShort( 0xfc3c ),	/* Offset= -964 (10) */
+/* 976 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 978 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 980 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 982 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 986 */	NdrFcShort( 0xfc2c ),	/* Offset= -980 (6) */
+/* 988 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 990 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 992 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 994 */	0x3,		/* FC_SMALL */
+			0x5c,		/* FC_PAD */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            VARIANT_UserSize
+            ,VARIANT_UserMarshal
+            ,VARIANT_UserUnmarshal
+            ,VARIANT_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleAction, ver. 0.0,
+   GUID={0xB70D9F59,0x3B5A,0x4dba,{0xAB,0x9E,0x22,0x01,0x2F,0x60,0x7D,0xF5}} */
+
+
+/* Object interface: IAccessibleHyperlink, ver. 0.0,
+   GUID={0x01C20F2B,0x3DD2,0x400f,{0x94,0x9F,0xAD,0x00,0xBD,0xAB,0x1D,0x41}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleHyperlink_FormatStringOffsetTable[] =
+    {
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    0,
+    44,
+    88,
+    126,
+    164
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleHyperlink_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleHyperlink__MIDL_ProcFormatString.Format,
+    &IAccessibleHyperlink_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleHyperlink_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleHyperlink__MIDL_ProcFormatString.Format,
+    &IAccessibleHyperlink_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(14) _IAccessibleHyperlinkProxyVtbl = 
+{
+    &IAccessibleHyperlink_ProxyInfo,
+    &IID_IAccessibleHyperlink,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    0 /* IAccessibleAction::nActions */ ,
+    0 /* IAccessibleAction::doAction */ ,
+    0 /* IAccessibleAction::get_description */ ,
+    0 /* IAccessibleAction::get_keyBinding */ ,
+    0 /* IAccessibleAction::get_name */ ,
+    0 /* IAccessibleAction::get_localizedName */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_anchor */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_anchorTarget */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_startIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_endIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_valid */
+};
+
+
+static const PRPC_STUB_FUNCTION IAccessibleHyperlink_table[] =
+{
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2
+};
+
+CInterfaceStubVtbl _IAccessibleHyperlinkStubVtbl =
+{
+    &IID_IAccessibleHyperlink,
+    &IAccessibleHyperlink_ServerInfo,
+    14,
+    &IAccessibleHyperlink_table[-3],
+    CStdStubBuffer_DELEGATING_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleHyperlink__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleHyperlink_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleHyperlinkProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleHyperlink_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleHyperlinkStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleHyperlink_InterfaceNamesList[] = 
+{
+    "IAccessibleHyperlink",
+    0
+};
+
+const IID *  const _AccessibleHyperlink_BaseIIDList[] = 
+{
+    &IID_IAccessibleAction,
+    0
+};
+
+
+#define _AccessibleHyperlink_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleHyperlink, pIID, n)
+
+int __stdcall _AccessibleHyperlink_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleHyperlink_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleHyperlink_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleHyperlink_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleHyperlink_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleHyperlink_InterfaceNamesList,
+    (const IID ** ) & _AccessibleHyperlink_BaseIIDList,
+    & _AccessibleHyperlink_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext.h
new file mode 100644
index 0000000..91cb85c
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext.h
@@ -0,0 +1,349 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleHypertext.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleHypertext_h__
+#define __AccessibleHypertext_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleHypertext_FWD_DEFINED__
+#define __IAccessibleHypertext_FWD_DEFINED__
+typedef interface IAccessibleHypertext IAccessibleHypertext;
+#endif 	/* __IAccessibleHypertext_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "AccessibleText.h"
+#include "AccessibleHyperlink.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleHypertext_INTERFACE_DEFINED__
+#define __IAccessibleHypertext_INTERFACE_DEFINED__
+
+/* interface IAccessibleHypertext */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleHypertext;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6B4F8BBF-F1F2-418a-B35E-A195BC4103B9")
+    IAccessibleHypertext : public IAccessibleText
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nHyperlinks( 
+            /* [retval][out] */ long *hyperlinkCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_hyperlink( 
+            /* [in] */ long index,
+            /* [retval][out] */ IAccessibleHyperlink **hyperlink) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_hyperlinkIndex( 
+            /* [in] */ long charIndex,
+            /* [retval][out] */ long *hyperlinkIndex) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleHypertextVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleHypertext * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleHypertext * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleHypertext * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *addSelection )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *textAttributes);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_caretOffset )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ long *offset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_characterExtents )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [out] */ long *x,
+            /* [out] */ long *y,
+            /* [out] */ long *width,
+            /* [retval][out] */ long *height);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelections )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ long *nSelections);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_offsetAtPoint )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long x,
+            /* [in] */ long y,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [retval][out] */ long *offset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selection )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long selectionIndex,
+            /* [out] */ long *startOffset,
+            /* [retval][out] */ long *endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textBeforeOffset )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textAfterOffset )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textAtOffset )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        HRESULT ( STDMETHODCALLTYPE *removeSelection )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long selectionIndex);
+        
+        HRESULT ( STDMETHODCALLTYPE *setCaretOffset )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset);
+        
+        HRESULT ( STDMETHODCALLTYPE *setSelection )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long selectionIndex,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nCharacters )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ long *nCharacters);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollSubstringTo )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2ScrollType scrollType);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollSubstringToPoint )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_newText )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ IA2TextSegment *newText);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_oldText )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ IA2TextSegment *oldText);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nHyperlinks )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ long *hyperlinkCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_hyperlink )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long index,
+            /* [retval][out] */ IAccessibleHyperlink **hyperlink);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_hyperlinkIndex )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long charIndex,
+            /* [retval][out] */ long *hyperlinkIndex);
+        
+        END_INTERFACE
+    } IAccessibleHypertextVtbl;
+
+    interface IAccessibleHypertext
+    {
+        CONST_VTBL struct IAccessibleHypertextVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleHypertext_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleHypertext_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleHypertext_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleHypertext_addSelection(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> addSelection(This,startOffset,endOffset) ) 
+
+#define IAccessibleHypertext_get_attributes(This,offset,startOffset,endOffset,textAttributes)	\
+    ( (This)->lpVtbl -> get_attributes(This,offset,startOffset,endOffset,textAttributes) ) 
+
+#define IAccessibleHypertext_get_caretOffset(This,offset)	\
+    ( (This)->lpVtbl -> get_caretOffset(This,offset) ) 
+
+#define IAccessibleHypertext_get_characterExtents(This,offset,coordType,x,y,width,height)	\
+    ( (This)->lpVtbl -> get_characterExtents(This,offset,coordType,x,y,width,height) ) 
+
+#define IAccessibleHypertext_get_nSelections(This,nSelections)	\
+    ( (This)->lpVtbl -> get_nSelections(This,nSelections) ) 
+
+#define IAccessibleHypertext_get_offsetAtPoint(This,x,y,coordType,offset)	\
+    ( (This)->lpVtbl -> get_offsetAtPoint(This,x,y,coordType,offset) ) 
+
+#define IAccessibleHypertext_get_selection(This,selectionIndex,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> get_selection(This,selectionIndex,startOffset,endOffset) ) 
+
+#define IAccessibleHypertext_get_text(This,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_text(This,startOffset,endOffset,text) ) 
+
+#define IAccessibleHypertext_get_textBeforeOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textBeforeOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleHypertext_get_textAfterOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textAfterOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleHypertext_get_textAtOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textAtOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleHypertext_removeSelection(This,selectionIndex)	\
+    ( (This)->lpVtbl -> removeSelection(This,selectionIndex) ) 
+
+#define IAccessibleHypertext_setCaretOffset(This,offset)	\
+    ( (This)->lpVtbl -> setCaretOffset(This,offset) ) 
+
+#define IAccessibleHypertext_setSelection(This,selectionIndex,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> setSelection(This,selectionIndex,startOffset,endOffset) ) 
+
+#define IAccessibleHypertext_get_nCharacters(This,nCharacters)	\
+    ( (This)->lpVtbl -> get_nCharacters(This,nCharacters) ) 
+
+#define IAccessibleHypertext_scrollSubstringTo(This,startIndex,endIndex,scrollType)	\
+    ( (This)->lpVtbl -> scrollSubstringTo(This,startIndex,endIndex,scrollType) ) 
+
+#define IAccessibleHypertext_scrollSubstringToPoint(This,startIndex,endIndex,coordinateType,x,y)	\
+    ( (This)->lpVtbl -> scrollSubstringToPoint(This,startIndex,endIndex,coordinateType,x,y) ) 
+
+#define IAccessibleHypertext_get_newText(This,newText)	\
+    ( (This)->lpVtbl -> get_newText(This,newText) ) 
+
+#define IAccessibleHypertext_get_oldText(This,oldText)	\
+    ( (This)->lpVtbl -> get_oldText(This,oldText) ) 
+
+
+#define IAccessibleHypertext_get_nHyperlinks(This,hyperlinkCount)	\
+    ( (This)->lpVtbl -> get_nHyperlinks(This,hyperlinkCount) ) 
+
+#define IAccessibleHypertext_get_hyperlink(This,index,hyperlink)	\
+    ( (This)->lpVtbl -> get_hyperlink(This,index,hyperlink) ) 
+
+#define IAccessibleHypertext_get_hyperlinkIndex(This,charIndex,hyperlinkIndex)	\
+    ( (This)->lpVtbl -> get_hyperlinkIndex(This,charIndex,hyperlinkIndex) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleHypertext_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext_i.c
new file mode 100644
index 0000000..fbc3ef1
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleHypertext.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleHypertext,0x6B4F8BBF,0xF1F2,0x418a,0xB3,0x5E,0xA1,0x95,0xBC,0x41,0x03,0xB9);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext_p.c
new file mode 100644
index 0000000..e4df1ac
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleHypertext_p.c
@@ -0,0 +1,454 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleHypertext.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleHypertext.h"
+
+#define TYPE_FORMAT_STRING_SIZE   29                                
+#define PROC_FORMAT_STRING_SIZE   127                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   0            
+
+typedef struct _AccessibleHypertext_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleHypertext_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleHypertext_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleHypertext_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleHypertext_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleHypertext_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleHypertext_MIDL_TYPE_FORMAT_STRING AccessibleHypertext__MIDL_TypeFormatString;
+extern const AccessibleHypertext_MIDL_PROC_FORMAT_STRING AccessibleHypertext__MIDL_ProcFormatString;
+extern const AccessibleHypertext_MIDL_EXPR_FORMAT_STRING AccessibleHypertext__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleHypertext_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleHypertext_ProxyInfo;
+
+
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleHypertext_MIDL_PROC_FORMAT_STRING AccessibleHypertext__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_nHyperlinks */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x16 ),	/* 22 */
+/*  8 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter hyperlinkCount */
+
+/* 26 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_hyperlink */
+
+/* 38 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0x17 ),	/* 23 */
+/* 46 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 52 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 54 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 64 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 66 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 68 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter hyperlink */
+
+/* 70 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 72 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 74 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
+
+	/* Return value */
+
+/* 76 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 78 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 80 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_hyperlinkIndex */
+
+/* 82 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 84 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 90 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 92 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 94 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 96 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 98 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter charIndex */
+
+/* 108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 110 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter hyperlinkIndex */
+
+/* 114 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 116 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 122 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleHypertext_MIDL_TYPE_FORMAT_STRING AccessibleHypertext__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
+/* 10 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 12 */	NdrFcLong( 0x1c20f2b ),	/* 29495083 */
+/* 16 */	NdrFcShort( 0x3dd2 ),	/* 15826 */
+/* 18 */	NdrFcShort( 0x400f ),	/* 16399 */
+/* 20 */	0x94,		/* 148 */
+			0x9f,		/* 159 */
+/* 22 */	0xad,		/* 173 */
+			0x0,		/* 0 */
+/* 24 */	0xbd,		/* 189 */
+			0xab,		/* 171 */
+/* 26 */	0x1d,		/* 29 */
+			0x41,		/* 65 */
+
+			0x0
+        }
+    };
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleText, ver. 0.0,
+   GUID={0x24FD2FFB,0x3AAD,0x4a08,{0x83,0x35,0xA3,0xAD,0x89,0xC0,0xFB,0x4B}} */
+
+
+/* Object interface: IAccessibleHypertext, ver. 0.0,
+   GUID={0x6B4F8BBF,0xF1F2,0x418a,{0xB3,0x5E,0xA1,0x95,0xBC,0x41,0x03,0xB9}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleHypertext_FormatStringOffsetTable[] =
+    {
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    0,
+    38,
+    82
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleHypertext_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleHypertext__MIDL_ProcFormatString.Format,
+    &IAccessibleHypertext_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleHypertext_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleHypertext__MIDL_ProcFormatString.Format,
+    &IAccessibleHypertext_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(25) _IAccessibleHypertextProxyVtbl = 
+{
+    &IAccessibleHypertext_ProxyInfo,
+    &IID_IAccessibleHypertext,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    0 /* IAccessibleText::addSelection */ ,
+    0 /* IAccessibleText::get_attributes */ ,
+    0 /* IAccessibleText::get_caretOffset */ ,
+    0 /* IAccessibleText::get_characterExtents */ ,
+    0 /* IAccessibleText::get_nSelections */ ,
+    0 /* IAccessibleText::get_offsetAtPoint */ ,
+    0 /* IAccessibleText::get_selection */ ,
+    0 /* IAccessibleText::get_text */ ,
+    0 /* IAccessibleText::get_textBeforeOffset */ ,
+    0 /* IAccessibleText::get_textAfterOffset */ ,
+    0 /* IAccessibleText::get_textAtOffset */ ,
+    0 /* IAccessibleText::removeSelection */ ,
+    0 /* IAccessibleText::setCaretOffset */ ,
+    0 /* IAccessibleText::setSelection */ ,
+    0 /* IAccessibleText::get_nCharacters */ ,
+    0 /* IAccessibleText::scrollSubstringTo */ ,
+    0 /* IAccessibleText::scrollSubstringToPoint */ ,
+    0 /* IAccessibleText::get_newText */ ,
+    0 /* IAccessibleText::get_oldText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHypertext::get_nHyperlinks */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHypertext::get_hyperlink */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHypertext::get_hyperlinkIndex */
+};
+
+
+static const PRPC_STUB_FUNCTION IAccessibleHypertext_table[] =
+{
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2
+};
+
+CInterfaceStubVtbl _IAccessibleHypertextStubVtbl =
+{
+    &IID_IAccessibleHypertext,
+    &IAccessibleHypertext_ServerInfo,
+    25,
+    &IAccessibleHypertext_table[-3],
+    CStdStubBuffer_DELEGATING_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleHypertext__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    0,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleHypertext_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleHypertextProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleHypertext_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleHypertextStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleHypertext_InterfaceNamesList[] = 
+{
+    "IAccessibleHypertext",
+    0
+};
+
+const IID *  const _AccessibleHypertext_BaseIIDList[] = 
+{
+    &IID_IAccessibleText,
+    0
+};
+
+
+#define _AccessibleHypertext_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleHypertext, pIID, n)
+
+int __stdcall _AccessibleHypertext_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleHypertext_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleHypertext_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleHypertext_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleHypertext_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleHypertext_InterfaceNamesList,
+    (const IID ** ) & _AccessibleHypertext_BaseIIDList,
+    & _AccessibleHypertext_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage.h
new file mode 100644
index 0000000..a01e4dc
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage.h
@@ -0,0 +1,185 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleImage.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleImage_h__
+#define __AccessibleImage_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleImage_FWD_DEFINED__
+#define __IAccessibleImage_FWD_DEFINED__
+typedef interface IAccessibleImage IAccessibleImage;
+#endif 	/* __IAccessibleImage_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "IA2CommonTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleImage_INTERFACE_DEFINED__
+#define __IAccessibleImage_INTERFACE_DEFINED__
+
+/* interface IAccessibleImage */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleImage;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("FE5ABB3D-615E-4f7b-909F-5F0EDA9E8DDE")
+    IAccessibleImage : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_description( 
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_imagePosition( 
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [out] */ long *x,
+            /* [retval][out] */ long *y) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_imageSize( 
+            /* [out] */ long *height,
+            /* [retval][out] */ long *width) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleImageVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleImage * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleImage * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleImage * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_description )( 
+            IAccessibleImage * This,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_imagePosition )( 
+            IAccessibleImage * This,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [out] */ long *x,
+            /* [retval][out] */ long *y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageSize )( 
+            IAccessibleImage * This,
+            /* [out] */ long *height,
+            /* [retval][out] */ long *width);
+        
+        END_INTERFACE
+    } IAccessibleImageVtbl;
+
+    interface IAccessibleImage
+    {
+        CONST_VTBL struct IAccessibleImageVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleImage_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleImage_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleImage_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleImage_get_description(This,description)	\
+    ( (This)->lpVtbl -> get_description(This,description) ) 
+
+#define IAccessibleImage_get_imagePosition(This,coordinateType,x,y)	\
+    ( (This)->lpVtbl -> get_imagePosition(This,coordinateType,x,y) ) 
+
+#define IAccessibleImage_get_imageSize(This,height,width)	\
+    ( (This)->lpVtbl -> get_imageSize(This,height,width) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleImage_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage_i.c
new file mode 100644
index 0000000..1afecd1
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleImage.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleImage,0xFE5ABB3D,0x615E,0x4f7b,0x90,0x9F,0x5F,0x0E,0xDA,0x9E,0x8D,0xDE);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage_p.c
new file mode 100644
index 0000000..4b6aff7
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleImage_p.c
@@ -0,0 +1,414 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleImage.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleImage.h"
+
+#define TYPE_FORMAT_STRING_SIZE   47                                
+#define PROC_FORMAT_STRING_SIZE   133                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleImage_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleImage_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleImage_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleImage_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleImage_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleImage_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleImage_MIDL_TYPE_FORMAT_STRING AccessibleImage__MIDL_TypeFormatString;
+extern const AccessibleImage_MIDL_PROC_FORMAT_STRING AccessibleImage__MIDL_ProcFormatString;
+extern const AccessibleImage_MIDL_EXPR_FORMAT_STRING AccessibleImage__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleImage_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleImage_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleImage_MIDL_PROC_FORMAT_STRING AccessibleImage__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_description */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter description */
+
+/* 26 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_imagePosition */
+
+/* 38 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 46 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 48 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 50 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 52 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 54 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter coordinateType */
+
+/* 64 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 66 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 68 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter x */
+
+/* 70 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 72 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 76 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 78 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 80 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 82 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 84 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 86 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_imageSize */
+
+/* 88 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 90 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 96 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 102 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 104 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 112 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter height */
+
+/* 114 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 116 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter width */
+
+/* 120 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 122 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 128 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleImage_MIDL_TYPE_FORMAT_STRING AccessibleImage__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
+/* 10 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 14 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 20 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 22 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 26 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (10) */
+/* 28 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 30 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 32 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0xffde ),	/* Offset= -34 (6) */
+/* 42 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 44 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleImage, ver. 0.0,
+   GUID={0xFE5ABB3D,0x615E,0x4f7b,{0x90,0x9F,0x5F,0x0E,0xDA,0x9E,0x8D,0xDE}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleImage_FormatStringOffsetTable[] =
+    {
+    0,
+    38,
+    88
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleImage_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleImage__MIDL_ProcFormatString.Format,
+    &IAccessibleImage_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleImage_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleImage__MIDL_ProcFormatString.Format,
+    &IAccessibleImage_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(6) _IAccessibleImageProxyVtbl = 
+{
+    &IAccessibleImage_ProxyInfo,
+    &IID_IAccessibleImage,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleImage::get_description */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleImage::get_imagePosition */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleImage::get_imageSize */
+};
+
+const CInterfaceStubVtbl _IAccessibleImageStubVtbl =
+{
+    &IID_IAccessibleImage,
+    &IAccessibleImage_ServerInfo,
+    6,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleImage__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleImage_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleImageProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleImage_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleImageStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleImage_InterfaceNamesList[] = 
+{
+    "IAccessibleImage",
+    0
+};
+
+
+#define _AccessibleImage_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleImage, pIID, n)
+
+int __stdcall _AccessibleImage_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleImage_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleImage_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleImage_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleImage_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleImage_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleImage_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation.h
new file mode 100644
index 0000000..e153cd8
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation.h
@@ -0,0 +1,244 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleRelation.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleRelation_h__
+#define __AccessibleRelation_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleRelation_FWD_DEFINED__
+#define __IAccessibleRelation_FWD_DEFINED__
+typedef interface IAccessibleRelation IAccessibleRelation;
+#endif 	/* __IAccessibleRelation_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleRelation_0000_0000 */
+/* [local] */ 
+
+#define	IA2_RELATION_CONTROLLED_BY	( L"controlledBy" )
+
+#define	IA2_RELATION_CONTROLLER_FOR	( L"controllerFor" )
+
+#define	IA2_RELATION_DESCRIBED_BY	( L"describedBy" )
+
+#define	IA2_RELATION_DESCRIPTION_FOR	( L"descriptionFor" )
+
+#define	IA2_RELATION_EMBEDDED_BY	( L"embeddedBy" )
+
+#define	IA2_RELATION_EMBEDS	( L"embeds" )
+
+#define	IA2_RELATION_FLOWS_FROM	( L"flowsFrom" )
+
+#define	IA2_RELATION_FLOWS_TO	( L"flowsTo" )
+
+#define	IA2_RELATION_LABEL_FOR	( L"labelFor" )
+
+#define	IA2_RELATION_LABELED_BY	( L"labelledBy" )
+
+#define	IA2_RELATION_LABELLED_BY	( L"labelledBy" )
+
+#define	IA2_RELATION_MEMBER_OF	( L"memberOf" )
+
+#define	IA2_RELATION_NODE_CHILD_OF	( L"nodeChildOf" )
+
+#define	IA2_RELATION_PARENT_WINDOW_OF	( L"parentWindowOf" )
+
+#define	IA2_RELATION_POPUP_FOR	( L"popupFor" )
+
+#define	IA2_RELATION_SUBWINDOW_OF	( L"subwindowOf" )
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleRelation_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleRelation_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAccessibleRelation_INTERFACE_DEFINED__
+#define __IAccessibleRelation_INTERFACE_DEFINED__
+
+/* interface IAccessibleRelation */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleRelation;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7CDF86EE-C3DA-496a-BDA4-281B336E1FDC")
+    IAccessibleRelation : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_relationType( 
+            /* [retval][out] */ BSTR *relationType) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_localizedRelationType( 
+            /* [retval][out] */ BSTR *localizedRelationType) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nTargets( 
+            /* [retval][out] */ long *nTargets) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_target( 
+            /* [in] */ long targetIndex,
+            /* [retval][out] */ IUnknown **target) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_targets( 
+            /* [in] */ long maxTargets,
+            /* [length_is][size_is][out] */ IUnknown **targets,
+            /* [retval][out] */ long *nTargets) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleRelationVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleRelation * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleRelation * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleRelation * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_relationType )( 
+            IAccessibleRelation * This,
+            /* [retval][out] */ BSTR *relationType);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedRelationType )( 
+            IAccessibleRelation * This,
+            /* [retval][out] */ BSTR *localizedRelationType);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nTargets )( 
+            IAccessibleRelation * This,
+            /* [retval][out] */ long *nTargets);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_target )( 
+            IAccessibleRelation * This,
+            /* [in] */ long targetIndex,
+            /* [retval][out] */ IUnknown **target);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_targets )( 
+            IAccessibleRelation * This,
+            /* [in] */ long maxTargets,
+            /* [length_is][size_is][out] */ IUnknown **targets,
+            /* [retval][out] */ long *nTargets);
+        
+        END_INTERFACE
+    } IAccessibleRelationVtbl;
+
+    interface IAccessibleRelation
+    {
+        CONST_VTBL struct IAccessibleRelationVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleRelation_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleRelation_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleRelation_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleRelation_get_relationType(This,relationType)	\
+    ( (This)->lpVtbl -> get_relationType(This,relationType) ) 
+
+#define IAccessibleRelation_get_localizedRelationType(This,localizedRelationType)	\
+    ( (This)->lpVtbl -> get_localizedRelationType(This,localizedRelationType) ) 
+
+#define IAccessibleRelation_get_nTargets(This,nTargets)	\
+    ( (This)->lpVtbl -> get_nTargets(This,nTargets) ) 
+
+#define IAccessibleRelation_get_target(This,targetIndex,target)	\
+    ( (This)->lpVtbl -> get_target(This,targetIndex,target) ) 
+
+#define IAccessibleRelation_get_targets(This,maxTargets,targets,nTargets)	\
+    ( (This)->lpVtbl -> get_targets(This,maxTargets,targets,nTargets) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleRelation_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation_i.c
new file mode 100644
index 0000000..2ab3837
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleRelation.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleRelation,0x7CDF86EE,0xC3DA,0x496a,0xBD,0xA4,0x28,0x1B,0x33,0x6E,0x1F,0xDC);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation_p.c
new file mode 100644
index 0000000..e02cf72
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleRelation_p.c
@@ -0,0 +1,520 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:58 2012
+ */
+/* Compiler settings for AccessibleRelation.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleRelation.h"
+
+#define TYPE_FORMAT_STRING_SIZE   95                                
+#define PROC_FORMAT_STRING_SIZE   209                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleRelation_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleRelation_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleRelation_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleRelation_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleRelation_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleRelation_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleRelation_MIDL_TYPE_FORMAT_STRING AccessibleRelation__MIDL_TypeFormatString;
+extern const AccessibleRelation_MIDL_PROC_FORMAT_STRING AccessibleRelation__MIDL_ProcFormatString;
+extern const AccessibleRelation_MIDL_EXPR_FORMAT_STRING AccessibleRelation__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleRelation_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleRelation_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleRelation_MIDL_PROC_FORMAT_STRING AccessibleRelation__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_relationType */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter relationType */
+
+/* 26 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_localizedRelationType */
+
+/* 38 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 46 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 52 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 54 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 56 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter localizedRelationType */
+
+/* 64 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 66 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 68 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 72 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nTargets */
+
+/* 76 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 78 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 82 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 84 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 90 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 92 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nTargets */
+
+/* 102 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 104 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 110 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_target */
+
+/* 114 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 116 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 122 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 128 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 130 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter targetIndex */
+
+/* 140 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 142 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 144 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter target */
+
+/* 146 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 148 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 150 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */
+
+	/* Return value */
+
+/* 152 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 154 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 156 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_targets */
+
+/* 158 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 160 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 164 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 166 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 168 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 170 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 172 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 174 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 176 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 180 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxTargets */
+
+/* 184 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 186 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 188 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter targets */
+
+/* 190 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
+/* 192 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 194 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */
+
+	/* Parameter nTargets */
+
+/* 196 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 198 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 200 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 202 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 204 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 206 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleRelation_MIDL_TYPE_FORMAT_STRING AccessibleRelation__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
+/* 10 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 14 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 20 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 22 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 26 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (10) */
+/* 28 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 30 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 32 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0xffde ),	/* Offset= -34 (6) */
+/* 42 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 44 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 46 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
+/* 50 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 62 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 64 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 66 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 68 */	
+			0x11, 0x0,	/* FC_RP */
+/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
+/* 72 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 74 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 76 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 78 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 80 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 82 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 84 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 86 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 88 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 90 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (50) */
+/* 92 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Standard interface: __MIDL_itf_AccessibleRelation_0000_0000, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleRelation, ver. 0.0,
+   GUID={0x7CDF86EE,0xC3DA,0x496a,{0xBD,0xA4,0x28,0x1B,0x33,0x6E,0x1F,0xDC}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleRelation_FormatStringOffsetTable[] =
+    {
+    0,
+    38,
+    76,
+    114,
+    158
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleRelation_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleRelation__MIDL_ProcFormatString.Format,
+    &IAccessibleRelation_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleRelation_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleRelation__MIDL_ProcFormatString.Format,
+    &IAccessibleRelation_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(8) _IAccessibleRelationProxyVtbl = 
+{
+    &IAccessibleRelation_ProxyInfo,
+    &IID_IAccessibleRelation,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_relationType */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_localizedRelationType */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_nTargets */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_target */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_targets */
+};
+
+const CInterfaceStubVtbl _IAccessibleRelationStubVtbl =
+{
+    &IID_IAccessibleRelation,
+    &IAccessibleRelation_ServerInfo,
+    8,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleRelation__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleRelation_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleRelationProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleRelation_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleRelationStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleRelation_InterfaceNamesList[] = 
+{
+    "IAccessibleRelation",
+    0
+};
+
+
+#define _AccessibleRelation_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleRelation, pIID, n)
+
+int __stdcall _AccessibleRelation_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleRelation_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleRelation_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleRelation_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleRelation_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleRelation_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleRelation_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleRole.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleRole.h
new file mode 100644
index 0000000..bee6466
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleRole.h
@@ -0,0 +1,118 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:59 2012
+ */
+/* Compiler settings for AccessibleRole.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __AccessibleRole_h__
+#define __AccessibleRole_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+/* header files for imported files */
+#include "objidl.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleRole_0000_0000 */
+/* [local] */ 
+
+
+enum IA2Role
+    {	IA2_ROLE_UNKNOWN	= 0,
+	IA2_ROLE_CANVAS	= 0x401,
+	IA2_ROLE_CAPTION	= ( IA2_ROLE_CANVAS + 1 ) ,
+	IA2_ROLE_CHECK_MENU_ITEM	= ( IA2_ROLE_CAPTION + 1 ) ,
+	IA2_ROLE_COLOR_CHOOSER	= ( IA2_ROLE_CHECK_MENU_ITEM + 1 ) ,
+	IA2_ROLE_DATE_EDITOR	= ( IA2_ROLE_COLOR_CHOOSER + 1 ) ,
+	IA2_ROLE_DESKTOP_ICON	= ( IA2_ROLE_DATE_EDITOR + 1 ) ,
+	IA2_ROLE_DESKTOP_PANE	= ( IA2_ROLE_DESKTOP_ICON + 1 ) ,
+	IA2_ROLE_DIRECTORY_PANE	= ( IA2_ROLE_DESKTOP_PANE + 1 ) ,
+	IA2_ROLE_EDITBAR	= ( IA2_ROLE_DIRECTORY_PANE + 1 ) ,
+	IA2_ROLE_EMBEDDED_OBJECT	= ( IA2_ROLE_EDITBAR + 1 ) ,
+	IA2_ROLE_ENDNOTE	= ( IA2_ROLE_EMBEDDED_OBJECT + 1 ) ,
+	IA2_ROLE_FILE_CHOOSER	= ( IA2_ROLE_ENDNOTE + 1 ) ,
+	IA2_ROLE_FONT_CHOOSER	= ( IA2_ROLE_FILE_CHOOSER + 1 ) ,
+	IA2_ROLE_FOOTER	= ( IA2_ROLE_FONT_CHOOSER + 1 ) ,
+	IA2_ROLE_FOOTNOTE	= ( IA2_ROLE_FOOTER + 1 ) ,
+	IA2_ROLE_FORM	= ( IA2_ROLE_FOOTNOTE + 1 ) ,
+	IA2_ROLE_FRAME	= ( IA2_ROLE_FORM + 1 ) ,
+	IA2_ROLE_GLASS_PANE	= ( IA2_ROLE_FRAME + 1 ) ,
+	IA2_ROLE_HEADER	= ( IA2_ROLE_GLASS_PANE + 1 ) ,
+	IA2_ROLE_HEADING	= ( IA2_ROLE_HEADER + 1 ) ,
+	IA2_ROLE_ICON	= ( IA2_ROLE_HEADING + 1 ) ,
+	IA2_ROLE_IMAGE_MAP	= ( IA2_ROLE_ICON + 1 ) ,
+	IA2_ROLE_INPUT_METHOD_WINDOW	= ( IA2_ROLE_IMAGE_MAP + 1 ) ,
+	IA2_ROLE_INTERNAL_FRAME	= ( IA2_ROLE_INPUT_METHOD_WINDOW + 1 ) ,
+	IA2_ROLE_LABEL	= ( IA2_ROLE_INTERNAL_FRAME + 1 ) ,
+	IA2_ROLE_LAYERED_PANE	= ( IA2_ROLE_LABEL + 1 ) ,
+	IA2_ROLE_NOTE	= ( IA2_ROLE_LAYERED_PANE + 1 ) ,
+	IA2_ROLE_OPTION_PANE	= ( IA2_ROLE_NOTE + 1 ) ,
+	IA2_ROLE_PAGE	= ( IA2_ROLE_OPTION_PANE + 1 ) ,
+	IA2_ROLE_PARAGRAPH	= ( IA2_ROLE_PAGE + 1 ) ,
+	IA2_ROLE_RADIO_MENU_ITEM	= ( IA2_ROLE_PARAGRAPH + 1 ) ,
+	IA2_ROLE_REDUNDANT_OBJECT	= ( IA2_ROLE_RADIO_MENU_ITEM + 1 ) ,
+	IA2_ROLE_ROOT_PANE	= ( IA2_ROLE_REDUNDANT_OBJECT + 1 ) ,
+	IA2_ROLE_RULER	= ( IA2_ROLE_ROOT_PANE + 1 ) ,
+	IA2_ROLE_SCROLL_PANE	= ( IA2_ROLE_RULER + 1 ) ,
+	IA2_ROLE_SECTION	= ( IA2_ROLE_SCROLL_PANE + 1 ) ,
+	IA2_ROLE_SHAPE	= ( IA2_ROLE_SECTION + 1 ) ,
+	IA2_ROLE_SPLIT_PANE	= ( IA2_ROLE_SHAPE + 1 ) ,
+	IA2_ROLE_TEAR_OFF_MENU	= ( IA2_ROLE_SPLIT_PANE + 1 ) ,
+	IA2_ROLE_TERMINAL	= ( IA2_ROLE_TEAR_OFF_MENU + 1 ) ,
+	IA2_ROLE_TEXT_FRAME	= ( IA2_ROLE_TERMINAL + 1 ) ,
+	IA2_ROLE_TOGGLE_BUTTON	= ( IA2_ROLE_TEXT_FRAME + 1 ) ,
+	IA2_ROLE_VIEW_PORT	= ( IA2_ROLE_TOGGLE_BUTTON + 1 ) ,
+	IA2_ROLE_COMPLEMENTARY_CONTENT	= ( IA2_ROLE_VIEW_PORT + 1 ) 
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleRole_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleRole_0000_0000_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleStates.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleStates.h
new file mode 100644
index 0000000..fbb6ff9
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleStates.h
@@ -0,0 +1,95 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:59 2012
+ */
+/* Compiler settings for AccessibleStates.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __AccessibleStates_h__
+#define __AccessibleStates_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+/* header files for imported files */
+#include "objidl.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleStates_0000_0000 */
+/* [local] */ 
+
+typedef long AccessibleStates;
+
+
+enum IA2States
+    {	IA2_STATE_ACTIVE	= 0x1,
+	IA2_STATE_ARMED	= 0x2,
+	IA2_STATE_DEFUNCT	= 0x4,
+	IA2_STATE_EDITABLE	= 0x8,
+	IA2_STATE_HORIZONTAL	= 0x10,
+	IA2_STATE_ICONIFIED	= 0x20,
+	IA2_STATE_INVALID_ENTRY	= 0x40,
+	IA2_STATE_MANAGES_DESCENDANTS	= 0x80,
+	IA2_STATE_MODAL	= 0x100,
+	IA2_STATE_MULTI_LINE	= 0x200,
+	IA2_STATE_OPAQUE	= 0x400,
+	IA2_STATE_REQUIRED	= 0x800,
+	IA2_STATE_SELECTABLE_TEXT	= 0x1000,
+	IA2_STATE_SINGLE_LINE	= 0x2000,
+	IA2_STATE_STALE	= 0x4000,
+	IA2_STATE_SUPPORTS_AUTOCOMPLETION	= 0x8000,
+	IA2_STATE_TRANSIENT	= 0x10000,
+	IA2_STATE_VERTICAL	= 0x20000,
+	IA2_STATE_CHECKABLE	= 0x40000,
+	IA2_STATE_PINNED	= 0x80000
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleStates_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleStates_0000_0000_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable.h
new file mode 100644
index 0000000..fb9c747
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable.h
@@ -0,0 +1,497 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:59 2012
+ */
+/* Compiler settings for AccessibleTable.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleTable_h__
+#define __AccessibleTable_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleTable_FWD_DEFINED__
+#define __IAccessibleTable_FWD_DEFINED__
+typedef interface IAccessibleTable IAccessibleTable;
+#endif 	/* __IAccessibleTable_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "Accessible2.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleTable_INTERFACE_DEFINED__
+#define __IAccessibleTable_INTERFACE_DEFINED__
+
+/* interface IAccessibleTable */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleTable;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("35AD8070-C20C-4fb4-B094-F4F7275DD469")
+    IAccessibleTable : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_accessibleAt( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_caption( 
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_childIndex( 
+            /* [in] */ long rowIndex,
+            /* [in] */ long columnIndex,
+            /* [retval][out] */ long *cellIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnDescription( 
+            /* [in] */ long column,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnExtentAt( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ long *nColumnsSpanned) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnHeader( 
+            /* [out] */ IAccessibleTable **accessibleTable,
+            /* [retval][out] */ long *startingRowIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnIndex( 
+            /* [in] */ long cellIndex,
+            /* [retval][out] */ long *columnIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nColumns( 
+            /* [retval][out] */ long *columnCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nRows( 
+            /* [retval][out] */ long *rowCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedChildren( 
+            /* [retval][out] */ long *cellCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedColumns( 
+            /* [retval][out] */ long *columnCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedRows( 
+            /* [retval][out] */ long *rowCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowDescription( 
+            /* [in] */ long row,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowExtentAt( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ long *nRowsSpanned) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowHeader( 
+            /* [out] */ IAccessibleTable **accessibleTable,
+            /* [retval][out] */ long *startingColumnIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowIndex( 
+            /* [in] */ long cellIndex,
+            /* [retval][out] */ long *rowIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedChildren( 
+            /* [in] */ long maxChildren,
+            /* [length_is][length_is][size_is][size_is][out] */ long **children,
+            /* [retval][out] */ long *nChildren) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedColumns( 
+            /* [in] */ long maxColumns,
+            /* [length_is][length_is][size_is][size_is][out] */ long **columns,
+            /* [retval][out] */ long *nColumns) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedRows( 
+            /* [in] */ long maxRows,
+            /* [length_is][length_is][size_is][size_is][out] */ long **rows,
+            /* [retval][out] */ long *nRows) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_summary( 
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isColumnSelected( 
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isRowSelected( 
+            /* [in] */ long row,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isSelected( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE selectRow( 
+            /* [in] */ long row) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE selectColumn( 
+            /* [in] */ long column) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE unselectRow( 
+            /* [in] */ long row) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE unselectColumn( 
+            /* [in] */ long column) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowColumnExtentsAtIndex( 
+            /* [in] */ long index,
+            /* [out] */ long *row,
+            /* [out] */ long *column,
+            /* [out] */ long *rowExtents,
+            /* [out] */ long *columnExtents,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_modelChange( 
+            /* [retval][out] */ IA2TableModelChange *modelChange) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleTableVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleTable * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleTable * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleTable * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_accessibleAt )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_caption )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_childIndex )( 
+            IAccessibleTable * This,
+            /* [in] */ long rowIndex,
+            /* [in] */ long columnIndex,
+            /* [retval][out] */ long *cellIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnDescription )( 
+            IAccessibleTable * This,
+            /* [in] */ long column,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnExtentAt )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ long *nColumnsSpanned);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnHeader )( 
+            IAccessibleTable * This,
+            /* [out] */ IAccessibleTable **accessibleTable,
+            /* [retval][out] */ long *startingRowIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnIndex )( 
+            IAccessibleTable * This,
+            /* [in] */ long cellIndex,
+            /* [retval][out] */ long *columnIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nColumns )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *columnCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nRows )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *rowCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedChildren )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *cellCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedColumns )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *columnCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedRows )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *rowCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowDescription )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowExtentAt )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ long *nRowsSpanned);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowHeader )( 
+            IAccessibleTable * This,
+            /* [out] */ IAccessibleTable **accessibleTable,
+            /* [retval][out] */ long *startingColumnIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowIndex )( 
+            IAccessibleTable * This,
+            /* [in] */ long cellIndex,
+            /* [retval][out] */ long *rowIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedChildren )( 
+            IAccessibleTable * This,
+            /* [in] */ long maxChildren,
+            /* [length_is][length_is][size_is][size_is][out] */ long **children,
+            /* [retval][out] */ long *nChildren);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedColumns )( 
+            IAccessibleTable * This,
+            /* [in] */ long maxColumns,
+            /* [length_is][length_is][size_is][size_is][out] */ long **columns,
+            /* [retval][out] */ long *nColumns);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedRows )( 
+            IAccessibleTable * This,
+            /* [in] */ long maxRows,
+            /* [length_is][length_is][size_is][size_is][out] */ long **rows,
+            /* [retval][out] */ long *nRows);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_summary )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isColumnSelected )( 
+            IAccessibleTable * This,
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isRowSelected )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isSelected )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected);
+        
+        HRESULT ( STDMETHODCALLTYPE *selectRow )( 
+            IAccessibleTable * This,
+            /* [in] */ long row);
+        
+        HRESULT ( STDMETHODCALLTYPE *selectColumn )( 
+            IAccessibleTable * This,
+            /* [in] */ long column);
+        
+        HRESULT ( STDMETHODCALLTYPE *unselectRow )( 
+            IAccessibleTable * This,
+            /* [in] */ long row);
+        
+        HRESULT ( STDMETHODCALLTYPE *unselectColumn )( 
+            IAccessibleTable * This,
+            /* [in] */ long column);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowColumnExtentsAtIndex )( 
+            IAccessibleTable * This,
+            /* [in] */ long index,
+            /* [out] */ long *row,
+            /* [out] */ long *column,
+            /* [out] */ long *rowExtents,
+            /* [out] */ long *columnExtents,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_modelChange )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ IA2TableModelChange *modelChange);
+        
+        END_INTERFACE
+    } IAccessibleTableVtbl;
+
+    interface IAccessibleTable
+    {
+        CONST_VTBL struct IAccessibleTableVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleTable_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleTable_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleTable_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleTable_get_accessibleAt(This,row,column,accessible)	\
+    ( (This)->lpVtbl -> get_accessibleAt(This,row,column,accessible) ) 
+
+#define IAccessibleTable_get_caption(This,accessible)	\
+    ( (This)->lpVtbl -> get_caption(This,accessible) ) 
+
+#define IAccessibleTable_get_childIndex(This,rowIndex,columnIndex,cellIndex)	\
+    ( (This)->lpVtbl -> get_childIndex(This,rowIndex,columnIndex,cellIndex) ) 
+
+#define IAccessibleTable_get_columnDescription(This,column,description)	\
+    ( (This)->lpVtbl -> get_columnDescription(This,column,description) ) 
+
+#define IAccessibleTable_get_columnExtentAt(This,row,column,nColumnsSpanned)	\
+    ( (This)->lpVtbl -> get_columnExtentAt(This,row,column,nColumnsSpanned) ) 
+
+#define IAccessibleTable_get_columnHeader(This,accessibleTable,startingRowIndex)	\
+    ( (This)->lpVtbl -> get_columnHeader(This,accessibleTable,startingRowIndex) ) 
+
+#define IAccessibleTable_get_columnIndex(This,cellIndex,columnIndex)	\
+    ( (This)->lpVtbl -> get_columnIndex(This,cellIndex,columnIndex) ) 
+
+#define IAccessibleTable_get_nColumns(This,columnCount)	\
+    ( (This)->lpVtbl -> get_nColumns(This,columnCount) ) 
+
+#define IAccessibleTable_get_nRows(This,rowCount)	\
+    ( (This)->lpVtbl -> get_nRows(This,rowCount) ) 
+
+#define IAccessibleTable_get_nSelectedChildren(This,cellCount)	\
+    ( (This)->lpVtbl -> get_nSelectedChildren(This,cellCount) ) 
+
+#define IAccessibleTable_get_nSelectedColumns(This,columnCount)	\
+    ( (This)->lpVtbl -> get_nSelectedColumns(This,columnCount) ) 
+
+#define IAccessibleTable_get_nSelectedRows(This,rowCount)	\
+    ( (This)->lpVtbl -> get_nSelectedRows(This,rowCount) ) 
+
+#define IAccessibleTable_get_rowDescription(This,row,description)	\
+    ( (This)->lpVtbl -> get_rowDescription(This,row,description) ) 
+
+#define IAccessibleTable_get_rowExtentAt(This,row,column,nRowsSpanned)	\
+    ( (This)->lpVtbl -> get_rowExtentAt(This,row,column,nRowsSpanned) ) 
+
+#define IAccessibleTable_get_rowHeader(This,accessibleTable,startingColumnIndex)	\
+    ( (This)->lpVtbl -> get_rowHeader(This,accessibleTable,startingColumnIndex) ) 
+
+#define IAccessibleTable_get_rowIndex(This,cellIndex,rowIndex)	\
+    ( (This)->lpVtbl -> get_rowIndex(This,cellIndex,rowIndex) ) 
+
+#define IAccessibleTable_get_selectedChildren(This,maxChildren,children,nChildren)	\
+    ( (This)->lpVtbl -> get_selectedChildren(This,maxChildren,children,nChildren) ) 
+
+#define IAccessibleTable_get_selectedColumns(This,maxColumns,columns,nColumns)	\
+    ( (This)->lpVtbl -> get_selectedColumns(This,maxColumns,columns,nColumns) ) 
+
+#define IAccessibleTable_get_selectedRows(This,maxRows,rows,nRows)	\
+    ( (This)->lpVtbl -> get_selectedRows(This,maxRows,rows,nRows) ) 
+
+#define IAccessibleTable_get_summary(This,accessible)	\
+    ( (This)->lpVtbl -> get_summary(This,accessible) ) 
+
+#define IAccessibleTable_get_isColumnSelected(This,column,isSelected)	\
+    ( (This)->lpVtbl -> get_isColumnSelected(This,column,isSelected) ) 
+
+#define IAccessibleTable_get_isRowSelected(This,row,isSelected)	\
+    ( (This)->lpVtbl -> get_isRowSelected(This,row,isSelected) ) 
+
+#define IAccessibleTable_get_isSelected(This,row,column,isSelected)	\
+    ( (This)->lpVtbl -> get_isSelected(This,row,column,isSelected) ) 
+
+#define IAccessibleTable_selectRow(This,row)	\
+    ( (This)->lpVtbl -> selectRow(This,row) ) 
+
+#define IAccessibleTable_selectColumn(This,column)	\
+    ( (This)->lpVtbl -> selectColumn(This,column) ) 
+
+#define IAccessibleTable_unselectRow(This,row)	\
+    ( (This)->lpVtbl -> unselectRow(This,row) ) 
+
+#define IAccessibleTable_unselectColumn(This,column)	\
+    ( (This)->lpVtbl -> unselectColumn(This,column) ) 
+
+#define IAccessibleTable_get_rowColumnExtentsAtIndex(This,index,row,column,rowExtents,columnExtents,isSelected)	\
+    ( (This)->lpVtbl -> get_rowColumnExtentsAtIndex(This,index,row,column,rowExtents,columnExtents,isSelected) ) 
+
+#define IAccessibleTable_get_modelChange(This,modelChange)	\
+    ( (This)->lpVtbl -> get_modelChange(This,modelChange) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleTable_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2.h
new file mode 100644
index 0000000..eeacb21
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2.h
@@ -0,0 +1,367 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:59 2012
+ */
+/* Compiler settings for AccessibleTable2.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleTable2_h__
+#define __AccessibleTable2_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleTable2_FWD_DEFINED__
+#define __IAccessibleTable2_FWD_DEFINED__
+typedef interface IAccessibleTable2 IAccessibleTable2;
+#endif 	/* __IAccessibleTable2_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "Accessible2.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleTable2_INTERFACE_DEFINED__
+#define __IAccessibleTable2_INTERFACE_DEFINED__
+
+/* interface IAccessibleTable2 */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleTable2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6167f295-06f0-4cdd-a1fa-02e25153d869")
+    IAccessibleTable2 : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_cellAt( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ IUnknown **cell) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_caption( 
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnDescription( 
+            /* [in] */ long column,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nColumns( 
+            /* [retval][out] */ long *columnCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nRows( 
+            /* [retval][out] */ long *rowCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedCells( 
+            /* [retval][out] */ long *cellCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedColumns( 
+            /* [retval][out] */ long *columnCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedRows( 
+            /* [retval][out] */ long *rowCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowDescription( 
+            /* [in] */ long row,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedCells( 
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cells,
+            /* [retval][out] */ long *nSelectedCells) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedColumns( 
+            /* [size_is][size_is][out] */ long **selectedColumns,
+            /* [retval][out] */ long *nColumns) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedRows( 
+            /* [size_is][size_is][out] */ long **selectedRows,
+            /* [retval][out] */ long *nRows) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_summary( 
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isColumnSelected( 
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isRowSelected( 
+            /* [in] */ long row,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE selectRow( 
+            /* [in] */ long row) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE selectColumn( 
+            /* [in] */ long column) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE unselectRow( 
+            /* [in] */ long row) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE unselectColumn( 
+            /* [in] */ long column) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_modelChange( 
+            /* [retval][out] */ IA2TableModelChange *modelChange) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleTable2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleTable2 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleTable2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleTable2 * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_cellAt )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ IUnknown **cell);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_caption )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnDescription )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long column,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nColumns )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *columnCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nRows )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *rowCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedCells )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *cellCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedColumns )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *columnCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedRows )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *rowCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowDescription )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedCells )( 
+            IAccessibleTable2 * This,
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cells,
+            /* [retval][out] */ long *nSelectedCells);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedColumns )( 
+            IAccessibleTable2 * This,
+            /* [size_is][size_is][out] */ long **selectedColumns,
+            /* [retval][out] */ long *nColumns);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedRows )( 
+            IAccessibleTable2 * This,
+            /* [size_is][size_is][out] */ long **selectedRows,
+            /* [retval][out] */ long *nRows);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_summary )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isColumnSelected )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isRowSelected )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row,
+            /* [retval][out] */ boolean *isSelected);
+        
+        HRESULT ( STDMETHODCALLTYPE *selectRow )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row);
+        
+        HRESULT ( STDMETHODCALLTYPE *selectColumn )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long column);
+        
+        HRESULT ( STDMETHODCALLTYPE *unselectRow )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row);
+        
+        HRESULT ( STDMETHODCALLTYPE *unselectColumn )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long column);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_modelChange )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ IA2TableModelChange *modelChange);
+        
+        END_INTERFACE
+    } IAccessibleTable2Vtbl;
+
+    interface IAccessibleTable2
+    {
+        CONST_VTBL struct IAccessibleTable2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleTable2_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleTable2_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleTable2_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleTable2_get_cellAt(This,row,column,cell)	\
+    ( (This)->lpVtbl -> get_cellAt(This,row,column,cell) ) 
+
+#define IAccessibleTable2_get_caption(This,accessible)	\
+    ( (This)->lpVtbl -> get_caption(This,accessible) ) 
+
+#define IAccessibleTable2_get_columnDescription(This,column,description)	\
+    ( (This)->lpVtbl -> get_columnDescription(This,column,description) ) 
+
+#define IAccessibleTable2_get_nColumns(This,columnCount)	\
+    ( (This)->lpVtbl -> get_nColumns(This,columnCount) ) 
+
+#define IAccessibleTable2_get_nRows(This,rowCount)	\
+    ( (This)->lpVtbl -> get_nRows(This,rowCount) ) 
+
+#define IAccessibleTable2_get_nSelectedCells(This,cellCount)	\
+    ( (This)->lpVtbl -> get_nSelectedCells(This,cellCount) ) 
+
+#define IAccessibleTable2_get_nSelectedColumns(This,columnCount)	\
+    ( (This)->lpVtbl -> get_nSelectedColumns(This,columnCount) ) 
+
+#define IAccessibleTable2_get_nSelectedRows(This,rowCount)	\
+    ( (This)->lpVtbl -> get_nSelectedRows(This,rowCount) ) 
+
+#define IAccessibleTable2_get_rowDescription(This,row,description)	\
+    ( (This)->lpVtbl -> get_rowDescription(This,row,description) ) 
+
+#define IAccessibleTable2_get_selectedCells(This,cells,nSelectedCells)	\
+    ( (This)->lpVtbl -> get_selectedCells(This,cells,nSelectedCells) ) 
+
+#define IAccessibleTable2_get_selectedColumns(This,selectedColumns,nColumns)	\
+    ( (This)->lpVtbl -> get_selectedColumns(This,selectedColumns,nColumns) ) 
+
+#define IAccessibleTable2_get_selectedRows(This,selectedRows,nRows)	\
+    ( (This)->lpVtbl -> get_selectedRows(This,selectedRows,nRows) ) 
+
+#define IAccessibleTable2_get_summary(This,accessible)	\
+    ( (This)->lpVtbl -> get_summary(This,accessible) ) 
+
+#define IAccessibleTable2_get_isColumnSelected(This,column,isSelected)	\
+    ( (This)->lpVtbl -> get_isColumnSelected(This,column,isSelected) ) 
+
+#define IAccessibleTable2_get_isRowSelected(This,row,isSelected)	\
+    ( (This)->lpVtbl -> get_isRowSelected(This,row,isSelected) ) 
+
+#define IAccessibleTable2_selectRow(This,row)	\
+    ( (This)->lpVtbl -> selectRow(This,row) ) 
+
+#define IAccessibleTable2_selectColumn(This,column)	\
+    ( (This)->lpVtbl -> selectColumn(This,column) ) 
+
+#define IAccessibleTable2_unselectRow(This,row)	\
+    ( (This)->lpVtbl -> unselectRow(This,row) ) 
+
+#define IAccessibleTable2_unselectColumn(This,column)	\
+    ( (This)->lpVtbl -> unselectColumn(This,column) ) 
+
+#define IAccessibleTable2_get_modelChange(This,modelChange)	\
+    ( (This)->lpVtbl -> get_modelChange(This,modelChange) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleTable2_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2_i.c
new file mode 100644
index 0000000..56e5f31
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:59 2012
+ */
+/* Compiler settings for AccessibleTable2.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleTable2,0x6167f295,0x06f0,0x4cdd,0xa1,0xfa,0x02,0xe2,0x51,0x53,0xd8,0x69);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2_p.c
new file mode 100644
index 0000000..02c603f
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable2_p.c
@@ -0,0 +1,1099 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:59 2012
+ */
+/* Compiler settings for AccessibleTable2.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleTable2.h"
+
+#define TYPE_FORMAT_STRING_SIZE   141                               
+#define PROC_FORMAT_STRING_SIZE   815                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleTable2_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleTable2_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleTable2_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleTable2_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleTable2_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleTable2_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleTable2_MIDL_TYPE_FORMAT_STRING AccessibleTable2__MIDL_TypeFormatString;
+extern const AccessibleTable2_MIDL_PROC_FORMAT_STRING AccessibleTable2__MIDL_ProcFormatString;
+extern const AccessibleTable2_MIDL_EXPR_FORMAT_STRING AccessibleTable2__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleTable2_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleTable2_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleTable2_MIDL_PROC_FORMAT_STRING AccessibleTable2__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_cellAt */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 32 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter cell */
+
+/* 38 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 40 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 42 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 46 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 48 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_caption */
+
+/* 50 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 58 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 64 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 66 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 70 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 74 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessible */
+
+/* 76 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 78 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 80 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 82 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 84 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 86 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnDescription */
+
+/* 88 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 90 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 96 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 98 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 100 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 102 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 104 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 106 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 112 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 114 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 116 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 120 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 122 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 124 */	NdrFcShort( 0x36 ),	/* Type Offset=54 */
+
+	/* Return value */
+
+/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 128 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nColumns */
+
+/* 132 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 140 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 144 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 146 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 148 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 154 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnCount */
+
+/* 158 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 160 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 162 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 164 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 166 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 168 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nRows */
+
+/* 170 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 172 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 176 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 178 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 180 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 182 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 184 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 186 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 192 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowCount */
+
+/* 196 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 198 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 200 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 202 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 204 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 206 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedCells */
+
+/* 208 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 210 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 214 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 216 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 220 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 222 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 224 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 232 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellCount */
+
+/* 234 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 236 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 238 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 240 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 242 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 244 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedColumns */
+
+/* 246 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 248 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 252 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 254 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 258 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 260 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 262 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 264 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 268 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnCount */
+
+/* 272 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 274 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 276 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 280 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 282 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedRows */
+
+/* 284 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 286 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 290 */	NdrFcShort( 0xa ),	/* 10 */
+/* 292 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 294 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 296 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 298 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 300 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 304 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 306 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 308 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowCount */
+
+/* 310 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 312 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 314 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 316 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 318 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 320 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowDescription */
+
+/* 322 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 324 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 328 */	NdrFcShort( 0xb ),	/* 11 */
+/* 330 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 332 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 334 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 336 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 338 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 340 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 350 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 352 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 354 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 356 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 358 */	NdrFcShort( 0x36 ),	/* Type Offset=54 */
+
+	/* Return value */
+
+/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 362 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 364 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedCells */
+
+/* 366 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 372 */	NdrFcShort( 0xc ),	/* 12 */
+/* 374 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 376 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 378 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 380 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 382 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 384 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 390 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cells */
+
+/* 392 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 394 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 396 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */
+
+	/* Parameter nSelectedCells */
+
+/* 398 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 400 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 402 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 404 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 406 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 408 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedColumns */
+
+/* 410 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 412 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 416 */	NdrFcShort( 0xd ),	/* 13 */
+/* 418 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 422 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 424 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 426 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 428 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 430 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 434 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectedColumns */
+
+/* 436 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 438 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 440 */	NdrFcShort( 0x62 ),	/* Type Offset=98 */
+
+	/* Parameter nColumns */
+
+/* 442 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 444 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 446 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 448 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 450 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 452 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedRows */
+
+/* 454 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 456 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 460 */	NdrFcShort( 0xe ),	/* 14 */
+/* 462 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 464 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 466 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 468 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 470 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 472 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 476 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectedRows */
+
+/* 480 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 482 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 484 */	NdrFcShort( 0x62 ),	/* Type Offset=98 */
+
+	/* Parameter nRows */
+
+/* 486 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 488 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 490 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 492 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 494 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 496 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_summary */
+
+/* 498 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 500 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 504 */	NdrFcShort( 0xf ),	/* 15 */
+/* 506 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 508 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 510 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 512 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 514 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 516 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 518 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessible */
+
+/* 524 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 526 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 528 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 530 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 532 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 534 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isColumnSelected */
+
+/* 536 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 538 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 542 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 544 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 546 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 548 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 550 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 552 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 556 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 558 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 560 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 562 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 564 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 566 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 568 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 570 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 572 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 574 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 576 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 578 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isRowSelected */
+
+/* 580 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 582 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 586 */	NdrFcShort( 0x11 ),	/* 17 */
+/* 588 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 590 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 592 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 594 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 596 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 598 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 604 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 606 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 608 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 610 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 612 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 614 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 616 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 618 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 620 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 622 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure selectRow */
+
+/* 624 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 626 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 630 */	NdrFcShort( 0x12 ),	/* 18 */
+/* 632 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 634 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 636 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 638 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 640 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 642 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 644 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 646 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 650 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 652 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 654 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 656 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 658 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 660 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure selectColumn */
+
+/* 662 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 664 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 668 */	NdrFcShort( 0x13 ),	/* 19 */
+/* 670 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 672 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 674 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 676 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 678 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 680 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 682 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 688 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 690 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 692 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 694 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 696 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 698 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure unselectRow */
+
+/* 700 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 702 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 706 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 708 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 710 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 712 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 714 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 716 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 718 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 722 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 724 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 726 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 728 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 730 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 732 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 734 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 736 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure unselectColumn */
+
+/* 738 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 740 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 744 */	NdrFcShort( 0x15 ),	/* 21 */
+/* 746 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 748 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 750 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 752 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 754 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 756 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 758 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 760 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 762 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 764 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 766 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 768 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 770 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 772 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 774 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_modelChange */
+
+/* 776 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 778 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 782 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 784 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 786 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 788 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 790 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 792 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 796 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 798 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter modelChange */
+
+/* 802 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 804 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 806 */	NdrFcShort( 0x7e ),	/* Type Offset=126 */
+
+	/* Return value */
+
+/* 808 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 810 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 812 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleTable2_MIDL_TYPE_FORMAT_STRING AccessibleTable2__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/*  4 */	NdrFcShort( 0x2 ),	/* Offset= 2 (6) */
+/*  6 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/*  8 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 16 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 18 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 20 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 22 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 24 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 26 */	NdrFcShort( 0x1c ),	/* Offset= 28 (54) */
+/* 28 */	
+			0x13, 0x0,	/* FC_OP */
+/* 30 */	NdrFcShort( 0xe ),	/* Offset= 14 (44) */
+/* 32 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 34 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 36 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 38 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 40 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 42 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 44 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 48 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (32) */
+/* 50 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 52 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 54 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0xffde ),	/* Offset= -34 (28) */
+/* 64 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 66 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 68 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
+/* 72 */	
+			0x13, 0x0,	/* FC_OP */
+/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
+/* 76 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 80 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 82 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 84 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 86 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 90 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 92 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 94 */	NdrFcShort( 0xffa8 ),	/* Offset= -88 (6) */
+/* 96 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 98 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 100 */	NdrFcShort( 0x2 ),	/* Offset= 2 (102) */
+/* 102 */	
+			0x13, 0x0,	/* FC_OP */
+/* 104 */	NdrFcShort( 0x2 ),	/* Offset= 2 (106) */
+/* 106 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 108 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 110 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 112 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 114 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 116 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 118 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 120 */	0x3,		/* FC_SMALL */
+			0x5c,		/* FC_PAD */
+/* 122 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 124 */	NdrFcShort( 0x2 ),	/* Offset= 2 (126) */
+/* 126 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 128 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 130 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 132 */	NdrFcShort( 0x0 ),	/* Offset= 0 (132) */
+/* 134 */	0xd,		/* FC_ENUM16 */
+			0x8,		/* FC_LONG */
+/* 136 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 138 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleTable2, ver. 0.0,
+   GUID={0x6167f295,0x06f0,0x4cdd,{0xa1,0xfa,0x02,0xe2,0x51,0x53,0xd8,0x69}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleTable2_FormatStringOffsetTable[] =
+    {
+    0,
+    50,
+    88,
+    132,
+    170,
+    208,
+    246,
+    284,
+    322,
+    366,
+    410,
+    454,
+    498,
+    536,
+    580,
+    624,
+    662,
+    700,
+    738,
+    776
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleTable2_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleTable2__MIDL_ProcFormatString.Format,
+    &IAccessibleTable2_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleTable2_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleTable2__MIDL_ProcFormatString.Format,
+    &IAccessibleTable2_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(23) _IAccessibleTable2ProxyVtbl = 
+{
+    &IAccessibleTable2_ProxyInfo,
+    &IID_IAccessibleTable2,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_cellAt */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_caption */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_columnDescription */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nSelectedCells */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nSelectedColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nSelectedRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_rowDescription */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_selectedCells */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_selectedColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_selectedRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_summary */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_isColumnSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_isRowSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::selectRow */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::selectColumn */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::unselectRow */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::unselectColumn */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_modelChange */
+};
+
+const CInterfaceStubVtbl _IAccessibleTable2StubVtbl =
+{
+    &IID_IAccessibleTable2,
+    &IAccessibleTable2_ServerInfo,
+    23,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleTable2__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleTable2_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleTable2ProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleTable2_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleTable2StubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleTable2_InterfaceNamesList[] = 
+{
+    "IAccessibleTable2",
+    0
+};
+
+
+#define _AccessibleTable2_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleTable2, pIID, n)
+
+int __stdcall _AccessibleTable2_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleTable2_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleTable2_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleTable2_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleTable2_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleTable2_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleTable2_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell.h
new file mode 100644
index 0000000..85648fc
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell.h
@@ -0,0 +1,246 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleTableCell.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleTableCell_h__
+#define __AccessibleTableCell_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleTableCell_FWD_DEFINED__
+#define __IAccessibleTableCell_FWD_DEFINED__
+typedef interface IAccessibleTableCell IAccessibleTableCell;
+#endif 	/* __IAccessibleTableCell_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "Accessible2.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleTableCell_INTERFACE_DEFINED__
+#define __IAccessibleTableCell_INTERFACE_DEFINED__
+
+/* interface IAccessibleTableCell */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleTableCell;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("594116B1-C99F-4847-AD06-0A7A86ECE645")
+    IAccessibleTableCell : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnExtent( 
+            /* [retval][out] */ long *nColumnsSpanned) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnHeaderCells( 
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cellAccessibles,
+            /* [retval][out] */ long *nColumnHeaderCells) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnIndex( 
+            /* [retval][out] */ long *columnIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowExtent( 
+            /* [retval][out] */ long *nRowsSpanned) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowHeaderCells( 
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cellAccessibles,
+            /* [retval][out] */ long *nRowHeaderCells) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowIndex( 
+            /* [retval][out] */ long *rowIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isSelected( 
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowColumnExtents( 
+            /* [out] */ long *row,
+            /* [out] */ long *column,
+            /* [out] */ long *rowExtents,
+            /* [out] */ long *columnExtents,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_table( 
+            /* [retval][out] */ IUnknown **table) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleTableCellVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleTableCell * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleTableCell * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleTableCell * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnExtent )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ long *nColumnsSpanned);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnHeaderCells )( 
+            IAccessibleTableCell * This,
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cellAccessibles,
+            /* [retval][out] */ long *nColumnHeaderCells);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnIndex )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ long *columnIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowExtent )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ long *nRowsSpanned);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowHeaderCells )( 
+            IAccessibleTableCell * This,
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cellAccessibles,
+            /* [retval][out] */ long *nRowHeaderCells);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowIndex )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ long *rowIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isSelected )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowColumnExtents )( 
+            IAccessibleTableCell * This,
+            /* [out] */ long *row,
+            /* [out] */ long *column,
+            /* [out] */ long *rowExtents,
+            /* [out] */ long *columnExtents,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_table )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ IUnknown **table);
+        
+        END_INTERFACE
+    } IAccessibleTableCellVtbl;
+
+    interface IAccessibleTableCell
+    {
+        CONST_VTBL struct IAccessibleTableCellVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleTableCell_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleTableCell_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleTableCell_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleTableCell_get_columnExtent(This,nColumnsSpanned)	\
+    ( (This)->lpVtbl -> get_columnExtent(This,nColumnsSpanned) ) 
+
+#define IAccessibleTableCell_get_columnHeaderCells(This,cellAccessibles,nColumnHeaderCells)	\
+    ( (This)->lpVtbl -> get_columnHeaderCells(This,cellAccessibles,nColumnHeaderCells) ) 
+
+#define IAccessibleTableCell_get_columnIndex(This,columnIndex)	\
+    ( (This)->lpVtbl -> get_columnIndex(This,columnIndex) ) 
+
+#define IAccessibleTableCell_get_rowExtent(This,nRowsSpanned)	\
+    ( (This)->lpVtbl -> get_rowExtent(This,nRowsSpanned) ) 
+
+#define IAccessibleTableCell_get_rowHeaderCells(This,cellAccessibles,nRowHeaderCells)	\
+    ( (This)->lpVtbl -> get_rowHeaderCells(This,cellAccessibles,nRowHeaderCells) ) 
+
+#define IAccessibleTableCell_get_rowIndex(This,rowIndex)	\
+    ( (This)->lpVtbl -> get_rowIndex(This,rowIndex) ) 
+
+#define IAccessibleTableCell_get_isSelected(This,isSelected)	\
+    ( (This)->lpVtbl -> get_isSelected(This,isSelected) ) 
+
+#define IAccessibleTableCell_get_rowColumnExtents(This,row,column,rowExtents,columnExtents,isSelected)	\
+    ( (This)->lpVtbl -> get_rowColumnExtents(This,row,column,rowExtents,columnExtents,isSelected) ) 
+
+#define IAccessibleTableCell_get_table(This,table)	\
+    ( (This)->lpVtbl -> get_table(This,table) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleTableCell_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell_i.c
new file mode 100644
index 0000000..fa94037
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleTableCell.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleTableCell,0x594116B1,0xC99F,0x4847,0xAD,0x06,0x0A,0x7A,0x86,0xEC,0xE6,0x45);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell_p.c
new file mode 100644
index 0000000..bf18e65
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTableCell_p.c
@@ -0,0 +1,634 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleTableCell.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleTableCell.h"
+
+#define TYPE_FORMAT_STRING_SIZE   63                                
+#define PROC_FORMAT_STRING_SIZE   379                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   0            
+
+typedef struct _AccessibleTableCell_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleTableCell_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleTableCell_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleTableCell_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleTableCell_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleTableCell_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleTableCell_MIDL_TYPE_FORMAT_STRING AccessibleTableCell__MIDL_TypeFormatString;
+extern const AccessibleTableCell_MIDL_PROC_FORMAT_STRING AccessibleTableCell__MIDL_ProcFormatString;
+extern const AccessibleTableCell_MIDL_EXPR_FORMAT_STRING AccessibleTableCell__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleTableCell_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleTableCell_ProxyInfo;
+
+
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleTableCell_MIDL_PROC_FORMAT_STRING AccessibleTableCell__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_columnExtent */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nColumnsSpanned */
+
+/* 26 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnHeaderCells */
+
+/* 38 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 46 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 50 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 52 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 54 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 56 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellAccessibles */
+
+/* 64 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 66 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 68 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
+
+	/* Parameter nColumnHeaderCells */
+
+/* 70 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 72 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 76 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 78 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 80 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnIndex */
+
+/* 82 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 84 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 90 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 96 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 98 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnIndex */
+
+/* 108 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 110 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 116 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowExtent */
+
+/* 120 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 122 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 126 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 128 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 130 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 132 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 134 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 136 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nRowsSpanned */
+
+/* 146 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 148 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 150 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 152 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 154 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 156 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowHeaderCells */
+
+/* 158 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 160 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 164 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 166 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 168 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 170 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 172 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 174 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 176 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 180 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellAccessibles */
+
+/* 184 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 186 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 188 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
+
+	/* Parameter nRowHeaderCells */
+
+/* 190 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 192 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 194 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 196 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 198 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 200 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowIndex */
+
+/* 202 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 204 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 210 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 212 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 214 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 216 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 218 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 222 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 224 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowIndex */
+
+/* 228 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 230 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 232 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 236 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 238 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isSelected */
+
+/* 240 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 242 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 246 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 248 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 252 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 254 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 256 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 264 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter isSelected */
+
+/* 266 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 268 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 270 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 272 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 274 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 276 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowColumnExtents */
+
+/* 278 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 280 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 284 */	NdrFcShort( 0xa ),	/* 10 */
+/* 286 */	NdrFcShort( 0x38 ),	/* X64 Stack size/offset = 56 */
+/* 288 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 290 */	NdrFcShort( 0x91 ),	/* 145 */
+/* 292 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x6,		/* 6 */
+/* 294 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 296 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 298 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 300 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 304 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 306 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 308 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 310 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 312 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 314 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter rowExtents */
+
+/* 316 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 318 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 320 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columnExtents */
+
+/* 322 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 324 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 326 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 328 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 330 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 332 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 334 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 336 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 338 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_table */
+
+/* 340 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 342 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 346 */	NdrFcShort( 0xb ),	/* 11 */
+/* 348 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 352 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 354 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 356 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 362 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter table */
+
+/* 366 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 368 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 370 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */
+
+	/* Return value */
+
+/* 372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 374 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 376 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleTableCell_MIDL_TYPE_FORMAT_STRING AccessibleTableCell__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
+/* 10 */	
+			0x13, 0x0,	/* FC_OP */
+/* 12 */	NdrFcShort( 0x14 ),	/* Offset= 20 (32) */
+/* 14 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 16 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 26 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 28 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 30 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 32 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 38 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 40 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 42 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 46 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 48 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 50 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (14) */
+/* 52 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 54 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 56 */	0x3,		/* FC_SMALL */
+			0x5c,		/* FC_PAD */
+/* 58 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/* 60 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (14) */
+
+			0x0
+        }
+    };
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleTableCell, ver. 0.0,
+   GUID={0x594116B1,0xC99F,0x4847,{0xAD,0x06,0x0A,0x7A,0x86,0xEC,0xE6,0x45}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleTableCell_FormatStringOffsetTable[] =
+    {
+    0,
+    38,
+    82,
+    120,
+    158,
+    202,
+    240,
+    278,
+    340
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleTableCell_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleTableCell__MIDL_ProcFormatString.Format,
+    &IAccessibleTableCell_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleTableCell_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleTableCell__MIDL_ProcFormatString.Format,
+    &IAccessibleTableCell_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(12) _IAccessibleTableCellProxyVtbl = 
+{
+    &IAccessibleTableCell_ProxyInfo,
+    &IID_IAccessibleTableCell,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_columnExtent */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_columnHeaderCells */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_columnIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_rowExtent */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_rowHeaderCells */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_rowIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_isSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_rowColumnExtents */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_table */
+};
+
+const CInterfaceStubVtbl _IAccessibleTableCellStubVtbl =
+{
+    &IID_IAccessibleTableCell,
+    &IAccessibleTableCell_ServerInfo,
+    12,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleTableCell__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    0,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleTableCell_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleTableCellProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleTableCell_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleTableCellStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleTableCell_InterfaceNamesList[] = 
+{
+    "IAccessibleTableCell",
+    0
+};
+
+
+#define _AccessibleTableCell_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleTableCell, pIID, n)
+
+int __stdcall _AccessibleTableCell_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleTableCell_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleTableCell_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleTableCell_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleTableCell_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleTableCell_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleTableCell_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable_i.c
new file mode 100644
index 0000000..dd4e1fe
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:59 2012
+ */
+/* Compiler settings for AccessibleTable.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleTable,0x35AD8070,0xC20C,0x4fb4,0xB0,0x94,0xF4,0xF7,0x27,0x5D,0xD4,0x69);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable_p.c
new file mode 100644
index 0000000..cca4e37
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleTable_p.c
@@ -0,0 +1,1543 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:59 2012
+ */
+/* Compiler settings for AccessibleTable.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleTable.h"
+
+#define TYPE_FORMAT_STRING_SIZE   139                               
+#define PROC_FORMAT_STRING_SIZE   1277                              
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleTable_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleTable_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleTable_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleTable_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleTable_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleTable_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleTable_MIDL_TYPE_FORMAT_STRING AccessibleTable__MIDL_TypeFormatString;
+extern const AccessibleTable_MIDL_PROC_FORMAT_STRING AccessibleTable__MIDL_ProcFormatString;
+extern const AccessibleTable_MIDL_EXPR_FORMAT_STRING AccessibleTable__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleTable_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleTable_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleTable_MIDL_PROC_FORMAT_STRING AccessibleTable__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_accessibleAt */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 32 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter accessible */
+
+/* 38 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 40 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 42 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 46 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 48 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_caption */
+
+/* 50 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 58 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 64 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 66 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 70 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 74 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessible */
+
+/* 76 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 78 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 80 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 82 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 84 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 86 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_childIndex */
+
+/* 88 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 90 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 96 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 98 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 100 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 102 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 104 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 112 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowIndex */
+
+/* 114 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 116 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columnIndex */
+
+/* 120 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 122 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter cellIndex */
+
+/* 126 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 128 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 134 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 136 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnDescription */
+
+/* 138 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 140 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 144 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 146 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 150 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 152 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 154 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 156 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 164 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 166 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 168 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 170 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 172 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 174 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */
+
+	/* Return value */
+
+/* 176 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 178 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 180 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnExtentAt */
+
+/* 182 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 184 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 188 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 190 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 192 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 194 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 196 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 198 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 202 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 204 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 208 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 210 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 212 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 214 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 216 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 218 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter nColumnsSpanned */
+
+/* 220 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 222 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 224 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 226 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 228 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 230 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnHeader */
+
+/* 232 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 234 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 240 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 242 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 244 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 246 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 248 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 252 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 254 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessibleTable */
+
+/* 258 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 260 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 262 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */
+
+	/* Parameter startingRowIndex */
+
+/* 264 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 266 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 268 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 272 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 274 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnIndex */
+
+/* 276 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 278 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 282 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 284 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 286 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 288 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 290 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 292 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 294 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 296 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 298 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 300 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellIndex */
+
+/* 302 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 304 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 306 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columnIndex */
+
+/* 308 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 310 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 312 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 314 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 316 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 318 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nColumns */
+
+/* 320 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 322 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 326 */	NdrFcShort( 0xa ),	/* 10 */
+/* 328 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 330 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 332 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 334 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 336 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 340 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnCount */
+
+/* 346 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 348 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 350 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 352 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 354 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 356 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nRows */
+
+/* 358 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 360 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 364 */	NdrFcShort( 0xb ),	/* 11 */
+/* 366 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 368 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 370 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 372 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 374 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 376 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 380 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowCount */
+
+/* 384 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 386 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 388 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 392 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 394 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedChildren */
+
+/* 396 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 398 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 402 */	NdrFcShort( 0xc ),	/* 12 */
+/* 404 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 406 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 408 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 410 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 412 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 414 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 416 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 418 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellCount */
+
+/* 422 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 424 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 426 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 428 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 430 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 432 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedColumns */
+
+/* 434 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 436 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 440 */	NdrFcShort( 0xd ),	/* 13 */
+/* 442 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 444 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 446 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 448 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 450 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnCount */
+
+/* 460 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 462 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 464 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 466 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 468 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 470 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedRows */
+
+/* 472 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 474 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 478 */	NdrFcShort( 0xe ),	/* 14 */
+/* 480 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 482 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 484 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 486 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 488 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 492 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 494 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 496 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowCount */
+
+/* 498 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 500 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 502 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 504 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 506 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 508 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowDescription */
+
+/* 510 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 512 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 516 */	NdrFcShort( 0xf ),	/* 15 */
+/* 518 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 520 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 522 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 524 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 526 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 528 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 532 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 536 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 538 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 540 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 542 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 544 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 546 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */
+
+	/* Return value */
+
+/* 548 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 550 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 552 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowExtentAt */
+
+/* 554 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 556 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 560 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 562 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 564 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 566 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 568 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 570 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 572 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 576 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 578 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 580 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 582 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 584 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 586 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 588 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 590 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter nRowsSpanned */
+
+/* 592 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 594 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 596 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 598 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 600 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 602 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowHeader */
+
+/* 604 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 606 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 610 */	NdrFcShort( 0x11 ),	/* 17 */
+/* 612 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 614 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 616 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 618 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 620 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 622 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 624 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 626 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 628 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessibleTable */
+
+/* 630 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 632 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 634 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */
+
+	/* Parameter startingColumnIndex */
+
+/* 636 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 638 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 640 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 644 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 646 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowIndex */
+
+/* 648 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 654 */	NdrFcShort( 0x12 ),	/* 18 */
+/* 656 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 658 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 660 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 662 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 664 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellIndex */
+
+/* 674 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 676 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 678 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter rowIndex */
+
+/* 680 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 682 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 684 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 686 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 688 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 690 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedChildren */
+
+/* 692 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 694 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 698 */	NdrFcShort( 0x13 ),	/* 19 */
+/* 700 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 702 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 704 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 706 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 708 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 710 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 712 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 716 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxChildren */
+
+/* 718 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 720 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 722 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter children */
+
+/* 724 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 726 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 728 */	NdrFcShort( 0x5a ),	/* Type Offset=90 */
+
+	/* Parameter nChildren */
+
+/* 730 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 732 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 734 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 736 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 738 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 740 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedColumns */
+
+/* 742 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 744 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 748 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 750 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 752 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 754 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 756 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 758 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 760 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 762 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 764 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 766 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxColumns */
+
+/* 768 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 770 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 772 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columns */
+
+/* 774 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 776 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 778 */	NdrFcShort( 0x5a ),	/* Type Offset=90 */
+
+	/* Parameter nColumns */
+
+/* 780 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 782 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 784 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 786 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 788 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 790 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedRows */
+
+/* 792 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 794 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 798 */	NdrFcShort( 0x15 ),	/* 21 */
+/* 800 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 802 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 804 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 806 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 808 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 810 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 812 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 814 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 816 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxRows */
+
+/* 818 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 820 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 822 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter rows */
+
+/* 824 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 826 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 828 */	NdrFcShort( 0x5a ),	/* Type Offset=90 */
+
+	/* Parameter nRows */
+
+/* 830 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 832 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 834 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 836 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 838 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 840 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_summary */
+
+/* 842 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 844 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 848 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 850 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 852 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 854 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 856 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 858 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 862 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 864 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 866 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessible */
+
+/* 868 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 870 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 872 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 874 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 876 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 878 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isColumnSelected */
+
+/* 880 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 882 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 886 */	NdrFcShort( 0x17 ),	/* 23 */
+/* 888 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 890 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 892 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 894 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 896 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 898 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 902 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 904 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 906 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 908 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 910 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 914 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 916 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 920 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 922 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isRowSelected */
+
+/* 924 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 926 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 930 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 932 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 934 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 936 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 938 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 940 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 942 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 944 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 946 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 950 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 952 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 954 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 956 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 958 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 960 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 962 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 964 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 966 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isSelected */
+
+/* 968 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 970 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 974 */	NdrFcShort( 0x19 ),	/* 25 */
+/* 976 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 978 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 980 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 982 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 984 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 986 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 988 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 990 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 994 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 996 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 998 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 1000 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1002 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 1004 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 1006 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1008 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 1010 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1012 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1014 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 1016 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure selectRow */
+
+/* 1018 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1020 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1024 */	NdrFcShort( 0x1a ),	/* 26 */
+/* 1026 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 1028 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1030 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1032 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 1034 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1036 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1038 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1040 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1042 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 1044 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1046 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 1048 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1050 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1052 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 1054 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure selectColumn */
+
+/* 1056 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1058 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1062 */	NdrFcShort( 0x1b ),	/* 27 */
+/* 1064 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 1066 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1068 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1070 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 1072 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1074 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1076 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1078 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1080 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 1082 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1084 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 1086 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1088 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1090 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 1092 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure unselectRow */
+
+/* 1094 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1096 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1100 */	NdrFcShort( 0x1c ),	/* 28 */
+/* 1102 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 1104 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1106 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1108 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 1110 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1112 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1114 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1116 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1118 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 1120 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1122 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 1124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1128 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 1130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure unselectColumn */
+
+/* 1132 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1134 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1138 */	NdrFcShort( 0x1d ),	/* 29 */
+/* 1140 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 1142 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1144 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1146 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 1148 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1150 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1154 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1156 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 1158 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1160 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 1162 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1164 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1166 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 1168 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowColumnExtentsAtIndex */
+
+/* 1170 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1172 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1176 */	NdrFcShort( 0x1e ),	/* 30 */
+/* 1178 */	NdrFcShort( 0x40 ),	/* X64 Stack size/offset = 64 */
+/* 1180 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1182 */	NdrFcShort( 0x91 ),	/* 145 */
+/* 1184 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x7,		/* 7 */
+/* 1186 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1188 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1190 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1192 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1194 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 1196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1198 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 1200 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter row */
+
+/* 1202 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1204 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 1206 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 1208 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1210 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 1212 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter rowExtents */
+
+/* 1214 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1216 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 1218 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columnExtents */
+
+/* 1220 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1222 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 1224 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 1226 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1228 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 1230 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1232 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1234 */	NdrFcShort( 0x38 ),	/* X64 Stack size/offset = 56 */
+/* 1236 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_modelChange */
+
+/* 1238 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1240 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1244 */	NdrFcShort( 0x1f ),	/* 31 */
+/* 1246 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1250 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1252 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 1254 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1256 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1258 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1260 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1262 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter modelChange */
+
+/* 1264 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 1266 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 1268 */	NdrFcShort( 0x7c ),	/* Type Offset=124 */
+
+	/* Return value */
+
+/* 1270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1272 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 1274 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleTable_MIDL_TYPE_FORMAT_STRING AccessibleTable__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/*  4 */	NdrFcShort( 0x2 ),	/* Offset= 2 (6) */
+/*  6 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/*  8 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 16 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 18 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 20 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 22 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 24 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 26 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 28 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 30 */	NdrFcShort( 0x1c ),	/* Offset= 28 (58) */
+/* 32 */	
+			0x13, 0x0,	/* FC_OP */
+/* 34 */	NdrFcShort( 0xe ),	/* Offset= 14 (48) */
+/* 36 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 38 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 40 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 42 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 44 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 46 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 48 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 52 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (36) */
+/* 54 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 56 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 58 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 66 */	NdrFcShort( 0xffde ),	/* Offset= -34 (32) */
+/* 68 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
+/* 72 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 74 */	NdrFcLong( 0x35ad8070 ),	/* 900563056 */
+/* 78 */	NdrFcShort( 0xc20c ),	/* -15860 */
+/* 80 */	NdrFcShort( 0x4fb4 ),	/* 20404 */
+/* 82 */	0xb0,		/* 176 */
+			0x94,		/* 148 */
+/* 84 */	0xf4,		/* 244 */
+			0xf7,		/* 247 */
+/* 86 */	0x27,		/* 39 */
+			0x5d,		/* 93 */
+/* 88 */	0xd4,		/* 212 */
+			0x69,		/* 105 */
+/* 90 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 92 */	NdrFcShort( 0x2 ),	/* Offset= 2 (94) */
+/* 94 */	
+			0x13, 0x0,	/* FC_OP */
+/* 96 */	NdrFcShort( 0x2 ),	/* Offset= 2 (98) */
+/* 98 */	
+			0x1c,		/* FC_CVARRAY */
+			0x3,		/* 3 */
+/* 100 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 102 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 104 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 106 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 108 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 110 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 112 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 114 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 116 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 118 */	0x3,		/* FC_SMALL */
+			0x5c,		/* FC_PAD */
+/* 120 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 122 */	NdrFcShort( 0x2 ),	/* Offset= 2 (124) */
+/* 124 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 126 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 130 */	NdrFcShort( 0x0 ),	/* Offset= 0 (130) */
+/* 132 */	0xd,		/* FC_ENUM16 */
+			0x8,		/* FC_LONG */
+/* 134 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 136 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleTable, ver. 0.0,
+   GUID={0x35AD8070,0xC20C,0x4fb4,{0xB0,0x94,0xF4,0xF7,0x27,0x5D,0xD4,0x69}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleTable_FormatStringOffsetTable[] =
+    {
+    0,
+    50,
+    88,
+    138,
+    182,
+    232,
+    276,
+    320,
+    358,
+    396,
+    434,
+    472,
+    510,
+    554,
+    604,
+    648,
+    692,
+    742,
+    792,
+    842,
+    880,
+    924,
+    968,
+    1018,
+    1056,
+    1094,
+    1132,
+    1170,
+    1238
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleTable_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleTable__MIDL_ProcFormatString.Format,
+    &IAccessibleTable_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleTable_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleTable__MIDL_ProcFormatString.Format,
+    &IAccessibleTable_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(32) _IAccessibleTableProxyVtbl = 
+{
+    &IAccessibleTable_ProxyInfo,
+    &IID_IAccessibleTable,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_accessibleAt */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_caption */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_childIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_columnDescription */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_columnExtentAt */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_columnHeader */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_columnIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nSelectedChildren */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nSelectedColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nSelectedRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowDescription */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowExtentAt */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowHeader */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_selectedChildren */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_selectedColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_selectedRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_summary */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_isColumnSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_isRowSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_isSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::selectRow */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::selectColumn */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::unselectRow */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::unselectColumn */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowColumnExtentsAtIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_modelChange */
+};
+
+const CInterfaceStubVtbl _IAccessibleTableStubVtbl =
+{
+    &IID_IAccessibleTable,
+    &IAccessibleTable_ServerInfo,
+    32,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleTable__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleTable_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleTableProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleTable_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleTableStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleTable_InterfaceNamesList[] = 
+{
+    "IAccessibleTable",
+    0
+};
+
+
+#define _AccessibleTable_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleTable, pIID, n)
+
+int __stdcall _AccessibleTable_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleTable_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleTable_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleTable_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleTable_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleTable_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleTable_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleText.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleText.h
new file mode 100644
index 0000000..9b91196
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleText.h
@@ -0,0 +1,435 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleText.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleText_h__
+#define __AccessibleText_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleText_FWD_DEFINED__
+#define __IAccessibleText_FWD_DEFINED__
+typedef interface IAccessibleText IAccessibleText;
+#endif 	/* __IAccessibleText_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "IA2CommonTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleText_0000_0000 */
+/* [local] */ 
+
+typedef struct IA2TextSegment
+    {
+    BSTR text;
+    long start;
+    long end;
+    } 	IA2TextSegment;
+
+
+enum IA2TextBoundaryType
+    {	IA2_TEXT_BOUNDARY_CHAR	= 0,
+	IA2_TEXT_BOUNDARY_WORD	= ( IA2_TEXT_BOUNDARY_CHAR + 1 ) ,
+	IA2_TEXT_BOUNDARY_SENTENCE	= ( IA2_TEXT_BOUNDARY_WORD + 1 ) ,
+	IA2_TEXT_BOUNDARY_PARAGRAPH	= ( IA2_TEXT_BOUNDARY_SENTENCE + 1 ) ,
+	IA2_TEXT_BOUNDARY_LINE	= ( IA2_TEXT_BOUNDARY_PARAGRAPH + 1 ) ,
+	IA2_TEXT_BOUNDARY_ALL	= ( IA2_TEXT_BOUNDARY_LINE + 1 ) 
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleText_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleText_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAccessibleText_INTERFACE_DEFINED__
+#define __IAccessibleText_INTERFACE_DEFINED__
+
+/* interface IAccessibleText */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleText;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("24FD2FFB-3AAD-4a08-8335-A3AD89C0FB4B")
+    IAccessibleText : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE addSelection( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
+            /* [in] */ long offset,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *textAttributes) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_caretOffset( 
+            /* [retval][out] */ long *offset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_characterExtents( 
+            /* [in] */ long offset,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [out] */ long *x,
+            /* [out] */ long *y,
+            /* [out] */ long *width,
+            /* [retval][out] */ long *height) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelections( 
+            /* [retval][out] */ long *nSelections) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_offsetAtPoint( 
+            /* [in] */ long x,
+            /* [in] */ long y,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [retval][out] */ long *offset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selection( 
+            /* [in] */ long selectionIndex,
+            /* [out] */ long *startOffset,
+            /* [retval][out] */ long *endOffset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_text( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [retval][out] */ BSTR *text) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_textBeforeOffset( 
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_textAfterOffset( 
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_textAtOffset( 
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE removeSelection( 
+            /* [in] */ long selectionIndex) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE setCaretOffset( 
+            /* [in] */ long offset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE setSelection( 
+            /* [in] */ long selectionIndex,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nCharacters( 
+            /* [retval][out] */ long *nCharacters) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE scrollSubstringTo( 
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2ScrollType scrollType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE scrollSubstringToPoint( 
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_newText( 
+            /* [retval][out] */ IA2TextSegment *newText) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_oldText( 
+            /* [retval][out] */ IA2TextSegment *oldText) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleTextVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleText * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleText * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleText * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *addSelection )( 
+            IAccessibleText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *textAttributes);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_caretOffset )( 
+            IAccessibleText * This,
+            /* [retval][out] */ long *offset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_characterExtents )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [out] */ long *x,
+            /* [out] */ long *y,
+            /* [out] */ long *width,
+            /* [retval][out] */ long *height);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelections )( 
+            IAccessibleText * This,
+            /* [retval][out] */ long *nSelections);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_offsetAtPoint )( 
+            IAccessibleText * This,
+            /* [in] */ long x,
+            /* [in] */ long y,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [retval][out] */ long *offset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selection )( 
+            IAccessibleText * This,
+            /* [in] */ long selectionIndex,
+            /* [out] */ long *startOffset,
+            /* [retval][out] */ long *endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
+            IAccessibleText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textBeforeOffset )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textAfterOffset )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textAtOffset )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        HRESULT ( STDMETHODCALLTYPE *removeSelection )( 
+            IAccessibleText * This,
+            /* [in] */ long selectionIndex);
+        
+        HRESULT ( STDMETHODCALLTYPE *setCaretOffset )( 
+            IAccessibleText * This,
+            /* [in] */ long offset);
+        
+        HRESULT ( STDMETHODCALLTYPE *setSelection )( 
+            IAccessibleText * This,
+            /* [in] */ long selectionIndex,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nCharacters )( 
+            IAccessibleText * This,
+            /* [retval][out] */ long *nCharacters);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollSubstringTo )( 
+            IAccessibleText * This,
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2ScrollType scrollType);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollSubstringToPoint )( 
+            IAccessibleText * This,
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_newText )( 
+            IAccessibleText * This,
+            /* [retval][out] */ IA2TextSegment *newText);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_oldText )( 
+            IAccessibleText * This,
+            /* [retval][out] */ IA2TextSegment *oldText);
+        
+        END_INTERFACE
+    } IAccessibleTextVtbl;
+
+    interface IAccessibleText
+    {
+        CONST_VTBL struct IAccessibleTextVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleText_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleText_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleText_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleText_addSelection(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> addSelection(This,startOffset,endOffset) ) 
+
+#define IAccessibleText_get_attributes(This,offset,startOffset,endOffset,textAttributes)	\
+    ( (This)->lpVtbl -> get_attributes(This,offset,startOffset,endOffset,textAttributes) ) 
+
+#define IAccessibleText_get_caretOffset(This,offset)	\
+    ( (This)->lpVtbl -> get_caretOffset(This,offset) ) 
+
+#define IAccessibleText_get_characterExtents(This,offset,coordType,x,y,width,height)	\
+    ( (This)->lpVtbl -> get_characterExtents(This,offset,coordType,x,y,width,height) ) 
+
+#define IAccessibleText_get_nSelections(This,nSelections)	\
+    ( (This)->lpVtbl -> get_nSelections(This,nSelections) ) 
+
+#define IAccessibleText_get_offsetAtPoint(This,x,y,coordType,offset)	\
+    ( (This)->lpVtbl -> get_offsetAtPoint(This,x,y,coordType,offset) ) 
+
+#define IAccessibleText_get_selection(This,selectionIndex,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> get_selection(This,selectionIndex,startOffset,endOffset) ) 
+
+#define IAccessibleText_get_text(This,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_text(This,startOffset,endOffset,text) ) 
+
+#define IAccessibleText_get_textBeforeOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textBeforeOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleText_get_textAfterOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textAfterOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleText_get_textAtOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textAtOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleText_removeSelection(This,selectionIndex)	\
+    ( (This)->lpVtbl -> removeSelection(This,selectionIndex) ) 
+
+#define IAccessibleText_setCaretOffset(This,offset)	\
+    ( (This)->lpVtbl -> setCaretOffset(This,offset) ) 
+
+#define IAccessibleText_setSelection(This,selectionIndex,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> setSelection(This,selectionIndex,startOffset,endOffset) ) 
+
+#define IAccessibleText_get_nCharacters(This,nCharacters)	\
+    ( (This)->lpVtbl -> get_nCharacters(This,nCharacters) ) 
+
+#define IAccessibleText_scrollSubstringTo(This,startIndex,endIndex,scrollType)	\
+    ( (This)->lpVtbl -> scrollSubstringTo(This,startIndex,endIndex,scrollType) ) 
+
+#define IAccessibleText_scrollSubstringToPoint(This,startIndex,endIndex,coordinateType,x,y)	\
+    ( (This)->lpVtbl -> scrollSubstringToPoint(This,startIndex,endIndex,coordinateType,x,y) ) 
+
+#define IAccessibleText_get_newText(This,newText)	\
+    ( (This)->lpVtbl -> get_newText(This,newText) ) 
+
+#define IAccessibleText_get_oldText(This,oldText)	\
+    ( (This)->lpVtbl -> get_oldText(This,oldText) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleText_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleText_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleText_i.c
new file mode 100644
index 0000000..564c790
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleText_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleText.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleText,0x24FD2FFB,0x3AAD,0x4a08,0x83,0x35,0xA3,0xAD,0x89,0xC0,0xFB,0x4B);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleText_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleText_p.c
new file mode 100644
index 0000000..b2512f7
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleText_p.c
@@ -0,0 +1,1203 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleText.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleText.h"
+
+#define TYPE_FORMAT_STRING_SIZE   67                                
+#define PROC_FORMAT_STRING_SIZE   939                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleText_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleText_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleText_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleText_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleText_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleText_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleText_MIDL_TYPE_FORMAT_STRING AccessibleText__MIDL_TypeFormatString;
+extern const AccessibleText_MIDL_PROC_FORMAT_STRING AccessibleText__MIDL_ProcFormatString;
+extern const AccessibleText_MIDL_EXPR_FORMAT_STRING AccessibleText__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleText_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleText_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleText_MIDL_PROC_FORMAT_STRING AccessibleText__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure addSelection */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 16 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 32 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 38 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 40 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 42 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_attributes */
+
+/* 44 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 50 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 52 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 56 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 58 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x5,		/* 5 */
+/* 60 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 62 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 70 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 72 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 76 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 78 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 80 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 82 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 84 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 86 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter textAttributes */
+
+/* 88 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 90 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 92 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 94 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 96 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 98 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_caretOffset */
+
+/* 100 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 102 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 108 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 112 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 114 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 116 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 122 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 126 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 128 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 134 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 136 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_characterExtents */
+
+/* 138 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 140 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 144 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 146 */	NdrFcShort( 0x40 ),	/* X64 Stack size/offset = 64 */
+/* 148 */	NdrFcShort( 0xe ),	/* 14 */
+/* 150 */	NdrFcShort( 0x78 ),	/* 120 */
+/* 152 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x7,		/* 7 */
+/* 154 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 164 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 166 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 168 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter coordType */
+
+/* 170 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 172 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 174 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter x */
+
+/* 176 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 178 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 180 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 182 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 184 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 186 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter width */
+
+/* 188 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 190 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 192 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter height */
+
+/* 194 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 196 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 198 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 200 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 202 */	NdrFcShort( 0x38 ),	/* X64 Stack size/offset = 56 */
+/* 204 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelections */
+
+/* 206 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 208 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 212 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 214 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 216 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 218 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 220 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 222 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 224 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nSelections */
+
+/* 232 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 234 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 236 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 238 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 240 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 242 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_offsetAtPoint */
+
+/* 244 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 246 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 252 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 254 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 256 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 258 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x5,		/* 5 */
+/* 260 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 264 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 268 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter x */
+
+/* 270 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 272 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 274 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 278 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 280 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter coordType */
+
+/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 284 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 286 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter offset */
+
+/* 288 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 290 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 292 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 296 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 298 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selection */
+
+/* 300 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 302 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 306 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 308 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 310 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 312 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 314 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 316 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 320 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectionIndex */
+
+/* 326 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 328 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 330 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 332 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 334 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 336 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 338 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 340 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 342 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 344 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 346 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 348 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_text */
+
+/* 350 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 352 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 356 */	NdrFcShort( 0xa ),	/* 10 */
+/* 358 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 360 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 362 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 364 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 366 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 368 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 370 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 372 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 376 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 378 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 380 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 382 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 384 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 386 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 388 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 390 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 392 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 394 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 396 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 398 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_textBeforeOffset */
+
+/* 400 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 402 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 406 */	NdrFcShort( 0xb ),	/* 11 */
+/* 408 */	NdrFcShort( 0x38 ),	/* X64 Stack size/offset = 56 */
+/* 410 */	NdrFcShort( 0xe ),	/* 14 */
+/* 412 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 414 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x6,		/* 6 */
+/* 416 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 418 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 424 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 426 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 428 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 430 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter boundaryType */
+
+/* 432 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 434 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 436 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 438 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 440 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 442 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 444 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 446 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 448 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 450 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 452 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 454 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 456 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 458 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 460 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_textAfterOffset */
+
+/* 462 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 464 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 468 */	NdrFcShort( 0xc ),	/* 12 */
+/* 470 */	NdrFcShort( 0x38 ),	/* X64 Stack size/offset = 56 */
+/* 472 */	NdrFcShort( 0xe ),	/* 14 */
+/* 474 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 476 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x6,		/* 6 */
+/* 478 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 480 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 482 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 484 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 488 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 490 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 492 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter boundaryType */
+
+/* 494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 496 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 498 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 500 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 502 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 504 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 506 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 508 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 510 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 512 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 514 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 516 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 518 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 520 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 522 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_textAtOffset */
+
+/* 524 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 526 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 530 */	NdrFcShort( 0xd ),	/* 13 */
+/* 532 */	NdrFcShort( 0x38 ),	/* X64 Stack size/offset = 56 */
+/* 534 */	NdrFcShort( 0xe ),	/* 14 */
+/* 536 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 538 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x6,		/* 6 */
+/* 540 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 542 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 548 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 550 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 552 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 554 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter boundaryType */
+
+/* 556 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 558 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 560 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 562 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 564 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 566 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 568 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 570 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 572 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 574 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 576 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 578 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 580 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 582 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 584 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure removeSelection */
+
+/* 586 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 588 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 592 */	NdrFcShort( 0xe ),	/* 14 */
+/* 594 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 596 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 598 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 600 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 602 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 604 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 606 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectionIndex */
+
+/* 612 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 614 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 616 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 618 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 620 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 622 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure setCaretOffset */
+
+/* 624 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 626 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 630 */	NdrFcShort( 0xf ),	/* 15 */
+/* 632 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 634 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 636 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 638 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 640 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 642 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 644 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 646 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 650 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 652 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 654 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 656 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 658 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 660 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure setSelection */
+
+/* 662 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 664 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 668 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 670 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 672 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 674 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 676 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 678 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 680 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 682 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectionIndex */
+
+/* 688 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 690 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 692 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 694 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 696 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 698 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 700 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 702 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 704 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 706 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 708 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 710 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nCharacters */
+
+/* 712 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 714 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 718 */	NdrFcShort( 0x11 ),	/* 17 */
+/* 720 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 722 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 724 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 726 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 728 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 730 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 732 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 734 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 736 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nCharacters */
+
+/* 738 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 740 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 742 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 744 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 746 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 748 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure scrollSubstringTo */
+
+/* 750 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 752 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 756 */	NdrFcShort( 0x12 ),	/* 18 */
+/* 758 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 760 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 762 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 764 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 766 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 768 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 772 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 774 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startIndex */
+
+/* 776 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 778 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 780 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endIndex */
+
+/* 782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 784 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 786 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter scrollType */
+
+/* 788 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 790 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 792 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 794 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 796 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 798 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure scrollSubstringToPoint */
+
+/* 800 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 802 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 806 */	NdrFcShort( 0x13 ),	/* 19 */
+/* 808 */	NdrFcShort( 0x38 ),	/* X64 Stack size/offset = 56 */
+/* 810 */	NdrFcShort( 0x26 ),	/* 38 */
+/* 812 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 814 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x6,		/* 6 */
+/* 816 */	0xa,		/* 10 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 818 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 820 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startIndex */
+
+/* 826 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 828 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 830 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endIndex */
+
+/* 832 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 834 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 836 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter coordinateType */
+
+/* 838 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 840 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 842 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter x */
+
+/* 844 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 846 */	NdrFcShort( 0x20 ),	/* X64 Stack size/offset = 32 */
+/* 848 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 850 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 852 */	NdrFcShort( 0x28 ),	/* X64 Stack size/offset = 40 */
+/* 854 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 856 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 858 */	NdrFcShort( 0x30 ),	/* X64 Stack size/offset = 48 */
+/* 860 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_newText */
+
+/* 862 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 864 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 868 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 870 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 872 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 874 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 876 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 878 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 880 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 882 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 884 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 886 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter newText */
+
+/* 888 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 890 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 892 */	NdrFcShort( 0x32 ),	/* Type Offset=50 */
+
+	/* Return value */
+
+/* 894 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 896 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 898 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_oldText */
+
+/* 900 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 902 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 906 */	NdrFcShort( 0x15 ),	/* 21 */
+/* 908 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 910 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 912 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 914 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 916 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 918 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 920 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 922 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 924 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter oldText */
+
+/* 926 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 928 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 930 */	NdrFcShort( 0x32 ),	/* Type Offset=50 */
+
+	/* Return value */
+
+/* 932 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 934 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 936 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleText_MIDL_TYPE_FORMAT_STRING AccessibleText__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  8 */	NdrFcShort( 0x1c ),	/* Offset= 28 (36) */
+/* 10 */	
+			0x13, 0x0,	/* FC_OP */
+/* 12 */	NdrFcShort( 0xe ),	/* Offset= 14 (26) */
+/* 14 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 16 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 18 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 20 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 22 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 24 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 26 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 28 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 30 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (14) */
+/* 32 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 34 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 36 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 42 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0xffde ),	/* Offset= -34 (10) */
+/* 46 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
+/* 50 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 52 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x0 ),	/* Offset= 0 (56) */
+/* 58 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 60 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (36) */
+/* 62 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 64 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Standard interface: __MIDL_itf_AccessibleText_0000_0000, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleText, ver. 0.0,
+   GUID={0x24FD2FFB,0x3AAD,0x4a08,{0x83,0x35,0xA3,0xAD,0x89,0xC0,0xFB,0x4B}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleText_FormatStringOffsetTable[] =
+    {
+    0,
+    44,
+    100,
+    138,
+    206,
+    244,
+    300,
+    350,
+    400,
+    462,
+    524,
+    586,
+    624,
+    662,
+    712,
+    750,
+    800,
+    862,
+    900
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleText_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleText__MIDL_ProcFormatString.Format,
+    &IAccessibleText_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleText_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleText__MIDL_ProcFormatString.Format,
+    &IAccessibleText_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(22) _IAccessibleTextProxyVtbl = 
+{
+    &IAccessibleText_ProxyInfo,
+    &IID_IAccessibleText,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::addSelection */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_attributes */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_caretOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_characterExtents */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_nSelections */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_offsetAtPoint */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_selection */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_text */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_textBeforeOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_textAfterOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_textAtOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::removeSelection */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::setCaretOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::setSelection */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_nCharacters */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::scrollSubstringTo */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::scrollSubstringToPoint */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_newText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_oldText */
+};
+
+const CInterfaceStubVtbl _IAccessibleTextStubVtbl =
+{
+    &IID_IAccessibleText,
+    &IAccessibleText_ServerInfo,
+    22,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleText__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleText_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleTextProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleText_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleTextStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleText_InterfaceNamesList[] = 
+{
+    "IAccessibleText",
+    0
+};
+
+
+#define _AccessibleText_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleText, pIID, n)
+
+int __stdcall _AccessibleText_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleText_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleText_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleText_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleText_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleText_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleText_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue.h b/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue.h
new file mode 100644
index 0000000..b27f9bb
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue.h
@@ -0,0 +1,188 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleValue.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleValue_h__
+#define __AccessibleValue_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleValue_FWD_DEFINED__
+#define __IAccessibleValue_FWD_DEFINED__
+typedef interface IAccessibleValue IAccessibleValue;
+#endif 	/* __IAccessibleValue_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleValue_INTERFACE_DEFINED__
+#define __IAccessibleValue_INTERFACE_DEFINED__
+
+/* interface IAccessibleValue */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleValue;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("35855B5B-C566-4fd0-A7B1-E65465600394")
+    IAccessibleValue : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_currentValue( 
+            /* [retval][out] */ VARIANT *currentValue) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE setCurrentValue( 
+            /* [in] */ VARIANT value) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_maximumValue( 
+            /* [retval][out] */ VARIANT *maximumValue) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_minimumValue( 
+            /* [retval][out] */ VARIANT *minimumValue) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleValueVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleValue * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleValue * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleValue * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_currentValue )( 
+            IAccessibleValue * This,
+            /* [retval][out] */ VARIANT *currentValue);
+        
+        HRESULT ( STDMETHODCALLTYPE *setCurrentValue )( 
+            IAccessibleValue * This,
+            /* [in] */ VARIANT value);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_maximumValue )( 
+            IAccessibleValue * This,
+            /* [retval][out] */ VARIANT *maximumValue);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_minimumValue )( 
+            IAccessibleValue * This,
+            /* [retval][out] */ VARIANT *minimumValue);
+        
+        END_INTERFACE
+    } IAccessibleValueVtbl;
+
+    interface IAccessibleValue
+    {
+        CONST_VTBL struct IAccessibleValueVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleValue_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleValue_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleValue_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleValue_get_currentValue(This,currentValue)	\
+    ( (This)->lpVtbl -> get_currentValue(This,currentValue) ) 
+
+#define IAccessibleValue_setCurrentValue(This,value)	\
+    ( (This)->lpVtbl -> setCurrentValue(This,value) ) 
+
+#define IAccessibleValue_get_maximumValue(This,maximumValue)	\
+    ( (This)->lpVtbl -> get_maximumValue(This,maximumValue) ) 
+
+#define IAccessibleValue_get_minimumValue(This,minimumValue)	\
+    ( (This)->lpVtbl -> get_minimumValue(This,minimumValue) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleValue_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
+unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
+unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
+void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue_i.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue_i.c
new file mode 100644
index 0000000..bc757ff
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleValue.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleValue,0x35855B5B,0xC566,0x4fd0,0xA7,0xB1,0xE6,0x54,0x65,0x60,0x03,0x94);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue_p.c b/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue_p.c
new file mode 100644
index 0000000..c3fd72c
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/AccessibleValue_p.c
@@ -0,0 +1,1029 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for AccessibleValue.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleValue.h"
+
+#define TYPE_FORMAT_STRING_SIZE   1007                              
+#define PROC_FORMAT_STRING_SIZE   153                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleValue_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleValue_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleValue_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleValue_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleValue_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleValue_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleValue_MIDL_TYPE_FORMAT_STRING AccessibleValue__MIDL_TypeFormatString;
+extern const AccessibleValue_MIDL_PROC_FORMAT_STRING AccessibleValue__MIDL_ProcFormatString;
+extern const AccessibleValue_MIDL_EXPR_FORMAT_STRING AccessibleValue__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleValue_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleValue_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN64__)
+#error  Invalid build platform for this stub.
+#endif
+
+static const AccessibleValue_MIDL_PROC_FORMAT_STRING AccessibleValue__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_currentValue */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter currentValue */
+
+/* 26 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 28 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 30 */	NdrFcShort( 0x3d2 ),	/* Type Offset=978 */
+
+	/* Return value */
+
+/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 34 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 36 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure setCurrentValue */
+
+/* 38 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 46 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 52 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 54 */	0xa,		/* 10 */
+			0x85,		/* Ext Flags:  new corr desc, srv corr check, has big amd64 byval param */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter value */
+
+/* 64 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
+/* 66 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 68 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */
+
+	/* Return value */
+
+/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 72 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 74 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_maximumValue */
+
+/* 76 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 78 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 82 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 84 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 90 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 92 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 94 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maximumValue */
+
+/* 102 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 104 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 106 */	NdrFcShort( 0x3d2 ),	/* Type Offset=978 */
+
+	/* Return value */
+
+/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 110 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_minimumValue */
+
+/* 114 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 116 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 122 */	NdrFcShort( 0x18 ),	/* X64 Stack size/offset = 24 */
+/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 128 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 130 */	0xa,		/* 10 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 132 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter minimumValue */
+
+/* 140 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 142 */	NdrFcShort( 0x8 ),	/* X64 Stack size/offset = 8 */
+/* 144 */	NdrFcShort( 0x3d2 ),	/* Type Offset=978 */
+
+	/* Return value */
+
+/* 146 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 148 */	NdrFcShort( 0x10 ),	/* X64 Stack size/offset = 16 */
+/* 150 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleValue_MIDL_TYPE_FORMAT_STRING AccessibleValue__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x3ce ),	/* Offset= 974 (978) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0x3b6 ),	/* Offset= 950 (958) */
+/* 10 */	
+			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
+			0x9,		/* FC_ULONG */
+/* 12 */	0x7,		/* Corr desc: FC_USHORT */
+			0x0,		/*  */
+/* 14 */	NdrFcShort( 0xfff8 ),	/* -8 */
+/* 16 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 18 */	NdrFcShort( 0x2 ),	/* Offset= 2 (20) */
+/* 20 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 22 */	NdrFcShort( 0x2f ),	/* 47 */
+/* 24 */	NdrFcLong( 0x14 ),	/* 20 */
+/* 28 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
+/* 30 */	NdrFcLong( 0x3 ),	/* 3 */
+/* 34 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 36 */	NdrFcLong( 0x11 ),	/* 17 */
+/* 40 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
+/* 42 */	NdrFcLong( 0x2 ),	/* 2 */
+/* 46 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 48 */	NdrFcLong( 0x4 ),	/* 4 */
+/* 52 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
+/* 54 */	NdrFcLong( 0x5 ),	/* 5 */
+/* 58 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
+/* 60 */	NdrFcLong( 0xb ),	/* 11 */
+/* 64 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 66 */	NdrFcLong( 0xa ),	/* 10 */
+/* 70 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 72 */	NdrFcLong( 0x6 ),	/* 6 */
+/* 76 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (308) */
+/* 78 */	NdrFcLong( 0x7 ),	/* 7 */
+/* 82 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
+/* 84 */	NdrFcLong( 0x8 ),	/* 8 */
+/* 88 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (314) */
+/* 90 */	NdrFcLong( 0xd ),	/* 13 */
+/* 94 */	NdrFcShort( 0xf6 ),	/* Offset= 246 (340) */
+/* 96 */	NdrFcLong( 0x9 ),	/* 9 */
+/* 100 */	NdrFcShort( 0x102 ),	/* Offset= 258 (358) */
+/* 102 */	NdrFcLong( 0x2000 ),	/* 8192 */
+/* 106 */	NdrFcShort( 0x10e ),	/* Offset= 270 (376) */
+/* 108 */	NdrFcLong( 0x24 ),	/* 36 */
+/* 112 */	NdrFcShort( 0x304 ),	/* Offset= 772 (884) */
+/* 114 */	NdrFcLong( 0x4024 ),	/* 16420 */
+/* 118 */	NdrFcShort( 0x2fe ),	/* Offset= 766 (884) */
+/* 120 */	NdrFcLong( 0x4011 ),	/* 16401 */
+/* 124 */	NdrFcShort( 0x2fc ),	/* Offset= 764 (888) */
+/* 126 */	NdrFcLong( 0x4002 ),	/* 16386 */
+/* 130 */	NdrFcShort( 0x2fa ),	/* Offset= 762 (892) */
+/* 132 */	NdrFcLong( 0x4003 ),	/* 16387 */
+/* 136 */	NdrFcShort( 0x2f8 ),	/* Offset= 760 (896) */
+/* 138 */	NdrFcLong( 0x4014 ),	/* 16404 */
+/* 142 */	NdrFcShort( 0x2f6 ),	/* Offset= 758 (900) */
+/* 144 */	NdrFcLong( 0x4004 ),	/* 16388 */
+/* 148 */	NdrFcShort( 0x2f4 ),	/* Offset= 756 (904) */
+/* 150 */	NdrFcLong( 0x4005 ),	/* 16389 */
+/* 154 */	NdrFcShort( 0x2f2 ),	/* Offset= 754 (908) */
+/* 156 */	NdrFcLong( 0x400b ),	/* 16395 */
+/* 160 */	NdrFcShort( 0x2dc ),	/* Offset= 732 (892) */
+/* 162 */	NdrFcLong( 0x400a ),	/* 16394 */
+/* 166 */	NdrFcShort( 0x2da ),	/* Offset= 730 (896) */
+/* 168 */	NdrFcLong( 0x4006 ),	/* 16390 */
+/* 172 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (912) */
+/* 174 */	NdrFcLong( 0x4007 ),	/* 16391 */
+/* 178 */	NdrFcShort( 0x2da ),	/* Offset= 730 (908) */
+/* 180 */	NdrFcLong( 0x4008 ),	/* 16392 */
+/* 184 */	NdrFcShort( 0x2dc ),	/* Offset= 732 (916) */
+/* 186 */	NdrFcLong( 0x400d ),	/* 16397 */
+/* 190 */	NdrFcShort( 0x2da ),	/* Offset= 730 (920) */
+/* 192 */	NdrFcLong( 0x4009 ),	/* 16393 */
+/* 196 */	NdrFcShort( 0x2d8 ),	/* Offset= 728 (924) */
+/* 198 */	NdrFcLong( 0x6000 ),	/* 24576 */
+/* 202 */	NdrFcShort( 0x2d6 ),	/* Offset= 726 (928) */
+/* 204 */	NdrFcLong( 0x400c ),	/* 16396 */
+/* 208 */	NdrFcShort( 0x2d4 ),	/* Offset= 724 (932) */
+/* 210 */	NdrFcLong( 0x10 ),	/* 16 */
+/* 214 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
+/* 216 */	NdrFcLong( 0x12 ),	/* 18 */
+/* 220 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 222 */	NdrFcLong( 0x13 ),	/* 19 */
+/* 226 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 228 */	NdrFcLong( 0x15 ),	/* 21 */
+/* 232 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
+/* 234 */	NdrFcLong( 0x16 ),	/* 22 */
+/* 238 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 240 */	NdrFcLong( 0x17 ),	/* 23 */
+/* 244 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 246 */	NdrFcLong( 0xe ),	/* 14 */
+/* 250 */	NdrFcShort( 0x2b2 ),	/* Offset= 690 (940) */
+/* 252 */	NdrFcLong( 0x400e ),	/* 16398 */
+/* 256 */	NdrFcShort( 0x2b6 ),	/* Offset= 694 (950) */
+/* 258 */	NdrFcLong( 0x4010 ),	/* 16400 */
+/* 262 */	NdrFcShort( 0x2b4 ),	/* Offset= 692 (954) */
+/* 264 */	NdrFcLong( 0x4012 ),	/* 16402 */
+/* 268 */	NdrFcShort( 0x270 ),	/* Offset= 624 (892) */
+/* 270 */	NdrFcLong( 0x4013 ),	/* 16403 */
+/* 274 */	NdrFcShort( 0x26e ),	/* Offset= 622 (896) */
+/* 276 */	NdrFcLong( 0x4015 ),	/* 16405 */
+/* 280 */	NdrFcShort( 0x26c ),	/* Offset= 620 (900) */
+/* 282 */	NdrFcLong( 0x4016 ),	/* 16406 */
+/* 286 */	NdrFcShort( 0x262 ),	/* Offset= 610 (896) */
+/* 288 */	NdrFcLong( 0x4017 ),	/* 16407 */
+/* 292 */	NdrFcShort( 0x25c ),	/* Offset= 604 (896) */
+/* 294 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 298 */	NdrFcShort( 0x0 ),	/* Offset= 0 (298) */
+/* 300 */	NdrFcLong( 0x1 ),	/* 1 */
+/* 304 */	NdrFcShort( 0x0 ),	/* Offset= 0 (304) */
+/* 306 */	NdrFcShort( 0xffff ),	/* Offset= -1 (305) */
+/* 308 */	
+			0x15,		/* FC_STRUCT */
+			0x7,		/* 7 */
+/* 310 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 312 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 314 */	
+			0x13, 0x0,	/* FC_OP */
+/* 316 */	NdrFcShort( 0xe ),	/* Offset= 14 (330) */
+/* 318 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 320 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 322 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 324 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 326 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 328 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 330 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 332 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 334 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (318) */
+/* 336 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 338 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 340 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 342 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 348 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 350 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 352 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 354 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 356 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 358 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 360 */	NdrFcLong( 0x20400 ),	/* 132096 */
+/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 366 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 368 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 370 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 372 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 374 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 376 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 378 */	NdrFcShort( 0x2 ),	/* Offset= 2 (380) */
+/* 380 */	
+			0x13, 0x0,	/* FC_OP */
+/* 382 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (866) */
+/* 384 */	
+			0x2a,		/* FC_ENCAPSULATED_UNION */
+			0x89,		/* 137 */
+/* 386 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 388 */	NdrFcShort( 0xa ),	/* 10 */
+/* 390 */	NdrFcLong( 0x8 ),	/* 8 */
+/* 394 */	NdrFcShort( 0x50 ),	/* Offset= 80 (474) */
+/* 396 */	NdrFcLong( 0xd ),	/* 13 */
+/* 400 */	NdrFcShort( 0x70 ),	/* Offset= 112 (512) */
+/* 402 */	NdrFcLong( 0x9 ),	/* 9 */
+/* 406 */	NdrFcShort( 0x90 ),	/* Offset= 144 (550) */
+/* 408 */	NdrFcLong( 0xc ),	/* 12 */
+/* 412 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (588) */
+/* 414 */	NdrFcLong( 0x24 ),	/* 36 */
+/* 418 */	NdrFcShort( 0x102 ),	/* Offset= 258 (676) */
+/* 420 */	NdrFcLong( 0x800d ),	/* 32781 */
+/* 424 */	NdrFcShort( 0x11e ),	/* Offset= 286 (710) */
+/* 426 */	NdrFcLong( 0x10 ),	/* 16 */
+/* 430 */	NdrFcShort( 0x138 ),	/* Offset= 312 (742) */
+/* 432 */	NdrFcLong( 0x2 ),	/* 2 */
+/* 436 */	NdrFcShort( 0x14e ),	/* Offset= 334 (770) */
+/* 438 */	NdrFcLong( 0x3 ),	/* 3 */
+/* 442 */	NdrFcShort( 0x164 ),	/* Offset= 356 (798) */
+/* 444 */	NdrFcLong( 0x14 ),	/* 20 */
+/* 448 */	NdrFcShort( 0x17a ),	/* Offset= 378 (826) */
+/* 450 */	NdrFcShort( 0xffff ),	/* Offset= -1 (449) */
+/* 452 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 456 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 460 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 462 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 466 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 468 */	
+			0x13, 0x0,	/* FC_OP */
+/* 470 */	NdrFcShort( 0xff74 ),	/* Offset= -140 (330) */
+/* 472 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 474 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 476 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 480 */	NdrFcShort( 0x6 ),	/* Offset= 6 (486) */
+/* 482 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 484 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 486 */	
+			0x11, 0x0,	/* FC_RP */
+/* 488 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (452) */
+/* 490 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 492 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 494 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 496 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 498 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 500 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 504 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 506 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 508 */	NdrFcShort( 0xff58 ),	/* Offset= -168 (340) */
+/* 510 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 512 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 514 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 516 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 518 */	NdrFcShort( 0x6 ),	/* Offset= 6 (524) */
+/* 520 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 522 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 524 */	
+			0x11, 0x0,	/* FC_RP */
+/* 526 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (490) */
+/* 528 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 532 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 536 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 538 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 542 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 544 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 546 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (358) */
+/* 548 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 550 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 552 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 556 */	NdrFcShort( 0x6 ),	/* Offset= 6 (562) */
+/* 558 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 560 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 562 */	
+			0x11, 0x0,	/* FC_RP */
+/* 564 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (528) */
+/* 566 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 568 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 570 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 572 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 574 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 576 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 580 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 582 */	
+			0x13, 0x0,	/* FC_OP */
+/* 584 */	NdrFcShort( 0x176 ),	/* Offset= 374 (958) */
+/* 586 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 588 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 590 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 592 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 594 */	NdrFcShort( 0x6 ),	/* Offset= 6 (600) */
+/* 596 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 598 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 600 */	
+			0x11, 0x0,	/* FC_RP */
+/* 602 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (566) */
+/* 604 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 606 */	NdrFcLong( 0x2f ),	/* 47 */
+/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 612 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 614 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 616 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 618 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 620 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 622 */	
+			0x1b,		/* FC_CARRAY */
+			0x0,		/* 0 */
+/* 624 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 626 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 628 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 630 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 632 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 634 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 636 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 638 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 640 */	NdrFcShort( 0xa ),	/* Offset= 10 (650) */
+/* 642 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 644 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 646 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (604) */
+/* 648 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 650 */	
+			0x13, 0x0,	/* FC_OP */
+/* 652 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (622) */
+/* 654 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 656 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 658 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 662 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 664 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 668 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 670 */	
+			0x13, 0x0,	/* FC_OP */
+/* 672 */	NdrFcShort( 0xffda ),	/* Offset= -38 (634) */
+/* 674 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 676 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 678 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 680 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 682 */	NdrFcShort( 0x6 ),	/* Offset= 6 (688) */
+/* 684 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 686 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 688 */	
+			0x11, 0x0,	/* FC_RP */
+/* 690 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (654) */
+/* 692 */	
+			0x1d,		/* FC_SMFARRAY */
+			0x0,		/* 0 */
+/* 694 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 696 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 698 */	
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 700 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 702 */	0x8,		/* FC_LONG */
+			0x6,		/* FC_SHORT */
+/* 704 */	0x6,		/* FC_SHORT */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 706 */	0x0,		/* 0 */
+			NdrFcShort( 0xfff1 ),	/* Offset= -15 (692) */
+			0x5b,		/* FC_END */
+/* 710 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 712 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 716 */	NdrFcShort( 0xa ),	/* Offset= 10 (726) */
+/* 718 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 720 */	0x36,		/* FC_POINTER */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 722 */	0x0,		/* 0 */
+			NdrFcShort( 0xffe7 ),	/* Offset= -25 (698) */
+			0x5b,		/* FC_END */
+/* 726 */	
+			0x11, 0x0,	/* FC_RP */
+/* 728 */	NdrFcShort( 0xff12 ),	/* Offset= -238 (490) */
+/* 730 */	
+			0x1b,		/* FC_CARRAY */
+			0x0,		/* 0 */
+/* 732 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 734 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 736 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 738 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 740 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 742 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 744 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 746 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 748 */	NdrFcShort( 0x6 ),	/* Offset= 6 (754) */
+/* 750 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 752 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 754 */	
+			0x13, 0x0,	/* FC_OP */
+/* 756 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (730) */
+/* 758 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 760 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 762 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 764 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 766 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 768 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 770 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 772 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 774 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 776 */	NdrFcShort( 0x6 ),	/* Offset= 6 (782) */
+/* 778 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 780 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 782 */	
+			0x13, 0x0,	/* FC_OP */
+/* 784 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (758) */
+/* 786 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 788 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 790 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 792 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 794 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 796 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 798 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 800 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 802 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 804 */	NdrFcShort( 0x6 ),	/* Offset= 6 (810) */
+/* 806 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 808 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 810 */	
+			0x13, 0x0,	/* FC_OP */
+/* 812 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (786) */
+/* 814 */	
+			0x1b,		/* FC_CARRAY */
+			0x7,		/* 7 */
+/* 816 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 818 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 820 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 822 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 824 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 826 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 828 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 832 */	NdrFcShort( 0x6 ),	/* Offset= 6 (838) */
+/* 834 */	0x8,		/* FC_LONG */
+			0x40,		/* FC_STRUCTPAD4 */
+/* 836 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 838 */	
+			0x13, 0x0,	/* FC_OP */
+/* 840 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (814) */
+/* 842 */	
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 844 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 846 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 848 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 850 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 852 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 854 */	0x7,		/* Corr desc: FC_USHORT */
+			0x0,		/*  */
+/* 856 */	NdrFcShort( 0xffc8 ),	/* -56 */
+/* 858 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 860 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 862 */	NdrFcShort( 0xffec ),	/* Offset= -20 (842) */
+/* 864 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 866 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 868 */	NdrFcShort( 0x38 ),	/* 56 */
+/* 870 */	NdrFcShort( 0xffec ),	/* Offset= -20 (850) */
+/* 872 */	NdrFcShort( 0x0 ),	/* Offset= 0 (872) */
+/* 874 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 876 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 878 */	0x40,		/* FC_STRUCTPAD4 */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 880 */	0x0,		/* 0 */
+			NdrFcShort( 0xfe0f ),	/* Offset= -497 (384) */
+			0x5b,		/* FC_END */
+/* 884 */	
+			0x13, 0x0,	/* FC_OP */
+/* 886 */	NdrFcShort( 0xff04 ),	/* Offset= -252 (634) */
+/* 888 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 890 */	0x1,		/* FC_BYTE */
+			0x5c,		/* FC_PAD */
+/* 892 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 894 */	0x6,		/* FC_SHORT */
+			0x5c,		/* FC_PAD */
+/* 896 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 898 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 900 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 902 */	0xb,		/* FC_HYPER */
+			0x5c,		/* FC_PAD */
+/* 904 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 906 */	0xa,		/* FC_FLOAT */
+			0x5c,		/* FC_PAD */
+/* 908 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 910 */	0xc,		/* FC_DOUBLE */
+			0x5c,		/* FC_PAD */
+/* 912 */	
+			0x13, 0x0,	/* FC_OP */
+/* 914 */	NdrFcShort( 0xfda2 ),	/* Offset= -606 (308) */
+/* 916 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 918 */	NdrFcShort( 0xfda4 ),	/* Offset= -604 (314) */
+/* 920 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 922 */	NdrFcShort( 0xfdba ),	/* Offset= -582 (340) */
+/* 924 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 926 */	NdrFcShort( 0xfdc8 ),	/* Offset= -568 (358) */
+/* 928 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 930 */	NdrFcShort( 0xfdd6 ),	/* Offset= -554 (376) */
+/* 932 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 934 */	NdrFcShort( 0x2 ),	/* Offset= 2 (936) */
+/* 936 */	
+			0x13, 0x0,	/* FC_OP */
+/* 938 */	NdrFcShort( 0x14 ),	/* Offset= 20 (958) */
+/* 940 */	
+			0x15,		/* FC_STRUCT */
+			0x7,		/* 7 */
+/* 942 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 944 */	0x6,		/* FC_SHORT */
+			0x1,		/* FC_BYTE */
+/* 946 */	0x1,		/* FC_BYTE */
+			0x8,		/* FC_LONG */
+/* 948 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 950 */	
+			0x13, 0x0,	/* FC_OP */
+/* 952 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (940) */
+/* 954 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 956 */	0x2,		/* FC_CHAR */
+			0x5c,		/* FC_PAD */
+/* 958 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x7,		/* 7 */
+/* 960 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 962 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 964 */	NdrFcShort( 0x0 ),	/* Offset= 0 (964) */
+/* 966 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 968 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 970 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 972 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 974 */	NdrFcShort( 0xfc3c ),	/* Offset= -964 (10) */
+/* 976 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 978 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 980 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 982 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 986 */	NdrFcShort( 0xfc2c ),	/* Offset= -980 (6) */
+/* 988 */	
+			0x11, 0x0,	/* FC_RP */
+/* 990 */	NdrFcShort( 0x6 ),	/* Offset= 6 (996) */
+/* 992 */	
+			0x12, 0x0,	/* FC_UP */
+/* 994 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (958) */
+/* 996 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 998 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1000 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1004 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (992) */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            VARIANT_UserSize
+            ,VARIANT_UserMarshal
+            ,VARIANT_UserUnmarshal
+            ,VARIANT_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleValue, ver. 0.0,
+   GUID={0x35855B5B,0xC566,0x4fd0,{0xA7,0xB1,0xE6,0x54,0x65,0x60,0x03,0x94}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleValue_FormatStringOffsetTable[] =
+    {
+    0,
+    38,
+    76,
+    114
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleValue_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleValue__MIDL_ProcFormatString.Format,
+    &IAccessibleValue_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleValue_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleValue__MIDL_ProcFormatString.Format,
+    &IAccessibleValue_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(7) _IAccessibleValueProxyVtbl = 
+{
+    &IAccessibleValue_ProxyInfo,
+    &IID_IAccessibleValue,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleValue::get_currentValue */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleValue::setCurrentValue */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleValue::get_maximumValue */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleValue::get_minimumValue */
+};
+
+const CInterfaceStubVtbl _IAccessibleValueStubVtbl =
+{
+    &IID_IAccessibleValue,
+    &IAccessibleValue_ServerInfo,
+    7,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleValue__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleValue_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleValueProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleValue_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleValueStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleValue_InterfaceNamesList[] = 
+{
+    "IAccessibleValue",
+    0
+};
+
+
+#define _AccessibleValue_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleValue, pIID, n)
+
+int __stdcall _AccessibleValue_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleValue_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleValue_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleValue_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleValue_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleValue_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleValue_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/IA2CommonTypes.h b/src/3rdparty/iaccessible2/generated/amd64/IA2CommonTypes.h
new file mode 100644
index 0000000..5b5a313
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/IA2CommonTypes.h
@@ -0,0 +1,102 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for IA2CommonTypes.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __IA2CommonTypes_h__
+#define __IA2CommonTypes_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_IA2CommonTypes_0000_0000 */
+/* [local] */ 
+
+
+enum IA2ScrollType
+    {	IA2_SCROLL_TYPE_TOP_LEFT	= 0,
+	IA2_SCROLL_TYPE_BOTTOM_RIGHT	= ( IA2_SCROLL_TYPE_TOP_LEFT + 1 ) ,
+	IA2_SCROLL_TYPE_TOP_EDGE	= ( IA2_SCROLL_TYPE_BOTTOM_RIGHT + 1 ) ,
+	IA2_SCROLL_TYPE_BOTTOM_EDGE	= ( IA2_SCROLL_TYPE_TOP_EDGE + 1 ) ,
+	IA2_SCROLL_TYPE_LEFT_EDGE	= ( IA2_SCROLL_TYPE_BOTTOM_EDGE + 1 ) ,
+	IA2_SCROLL_TYPE_RIGHT_EDGE	= ( IA2_SCROLL_TYPE_LEFT_EDGE + 1 ) ,
+	IA2_SCROLL_TYPE_ANYWHERE	= ( IA2_SCROLL_TYPE_RIGHT_EDGE + 1 ) 
+    } ;
+
+enum IA2CoordinateType
+    {	IA2_COORDTYPE_SCREEN_RELATIVE	= 0,
+	IA2_COORDTYPE_PARENT_RELATIVE	= ( IA2_COORDTYPE_SCREEN_RELATIVE + 1 ) 
+    } ;
+
+enum IA2TextSpecialOffsets
+    {	IA2_TEXT_OFFSET_LENGTH	= -1,
+	IA2_TEXT_OFFSET_CARET	= -2
+    } ;
+
+enum IA2TableModelChangeType
+    {	IA2_TABLE_MODEL_CHANGE_INSERT	= 0,
+	IA2_TABLE_MODEL_CHANGE_DELETE	= ( IA2_TABLE_MODEL_CHANGE_INSERT + 1 ) ,
+	IA2_TABLE_MODEL_CHANGE_UPDATE	= ( IA2_TABLE_MODEL_CHANGE_DELETE + 1 ) 
+    } ;
+typedef struct IA2TableModelChange
+    {
+    enum IA2TableModelChangeType type;
+    long firstRow;
+    long lastRow;
+    long firstColumn;
+    long lastColumn;
+    } 	IA2TableModelChange;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_IA2CommonTypes_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_IA2CommonTypes_0000_0000_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary.h b/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary.h
new file mode 100644
index 0000000..31142c6
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary.h
@@ -0,0 +1,103 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for IA2TypeLibrary.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __IA2TypeLibrary_h__
+#define __IA2TypeLibrary_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_IA2TypeLibrary_0000_0000 */
+/* [local] */ 
+
+
+// Type Library Definitions
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_IA2TypeLibrary_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_IA2TypeLibrary_0000_0000_v0_0_s_ifspec;
+
+
+#ifndef __IAccessible2Lib_LIBRARY_DEFINED__
+#define __IAccessible2Lib_LIBRARY_DEFINED__
+
+/* library IAccessible2Lib */
+/* [hidden][version][helpstring][uuid] */ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+EXTERN_C const IID LIBID_IAccessible2Lib;
+#endif /* __IAccessible2Lib_LIBRARY_DEFINED__ */
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary.tlb b/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary.tlb
new file mode 100644
index 0000000..44e7cdc
Binary files /dev/null and b/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary.tlb differ
diff --git a/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary_i.c b/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary_i.c
new file mode 100644
index 0000000..f3eabd2
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/IA2TypeLibrary_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:54:00 2012
+ */
+/* Compiler settings for IA2TypeLibrary.idl:
+    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, LIBID_IAccessible2Lib,0xc974e070,0x3787,0x490a,0x87,0xb0,0xe3,0x33,0xb0,0x6c,0xa1,0xe2);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/amd64/dlldata.c b/src/3rdparty/iaccessible2/generated/amd64/dlldata.c
new file mode 100644
index 0000000..e1e15a1
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/amd64/dlldata.c
@@ -0,0 +1,64 @@
+/*********************************************************
+   DllData file -- generated by MIDL compiler 
+
+        DO NOT ALTER THIS FILE
+
+   This file is regenerated by MIDL on every IDL file compile.
+
+   To completely reconstruct this file, delete it and rerun MIDL
+   on all the IDL files in this DLL, specifying this file for the
+   /dlldata command line option
+
+*********************************************************/
+
+#define PROXY_DELEGATION
+
+#include <rpcproxy.h>
+
+#ifdef __cplusplus
+extern "C"   {
+#endif
+
+EXTERN_PROXY_FILE( Accessible2 )
+EXTERN_PROXY_FILE( AccessibleAction )
+EXTERN_PROXY_FILE( AccessibleApplication )
+EXTERN_PROXY_FILE( AccessibleComponent )
+EXTERN_PROXY_FILE( AccessibleEditableText )
+EXTERN_PROXY_FILE( AccessibleHyperlink )
+EXTERN_PROXY_FILE( AccessibleHypertext )
+EXTERN_PROXY_FILE( AccessibleImage )
+EXTERN_PROXY_FILE( AccessibleRelation )
+EXTERN_PROXY_FILE( AccessibleTable )
+EXTERN_PROXY_FILE( AccessibleTable2 )
+EXTERN_PROXY_FILE( AccessibleTableCell )
+EXTERN_PROXY_FILE( AccessibleText )
+EXTERN_PROXY_FILE( AccessibleValue )
+
+
+PROXYFILE_LIST_START
+/* Start of list */
+  REFERENCE_PROXY_FILE( Accessible2 ),
+  REFERENCE_PROXY_FILE( AccessibleAction ),
+  REFERENCE_PROXY_FILE( AccessibleApplication ),
+  REFERENCE_PROXY_FILE( AccessibleComponent ),
+  REFERENCE_PROXY_FILE( AccessibleEditableText ),
+  REFERENCE_PROXY_FILE( AccessibleHyperlink ),
+  REFERENCE_PROXY_FILE( AccessibleHypertext ),
+  REFERENCE_PROXY_FILE( AccessibleImage ),
+  REFERENCE_PROXY_FILE( AccessibleRelation ),
+  REFERENCE_PROXY_FILE( AccessibleTable ),
+  REFERENCE_PROXY_FILE( AccessibleTable2 ),
+  REFERENCE_PROXY_FILE( AccessibleTableCell ),
+  REFERENCE_PROXY_FILE( AccessibleText ),
+  REFERENCE_PROXY_FILE( AccessibleValue ),
+/* End of list */
+PROXYFILE_LIST_END
+
+
+DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )
+
+#ifdef __cplusplus
+}  /*extern "C" */
+#endif
+
+/* end of generated dlldata file */
diff --git a/src/3rdparty/iaccessible2/generated/x86/Accessible2.h b/src/3rdparty/iaccessible2/generated/x86/Accessible2.h
new file mode 100644
index 0000000..dcf13c0
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/Accessible2.h
@@ -0,0 +1,585 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:51 2012
+ */
+/* Compiler settings for Accessible2.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __Accessible2_h__
+#define __Accessible2_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessible2_FWD_DEFINED__
+#define __IAccessible2_FWD_DEFINED__
+typedef interface IAccessible2 IAccessible2;
+#endif 	/* __IAccessible2_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "AccessibleRelation.h"
+#include "AccessibleStates.h"
+#include "IA2CommonTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_Accessible2_0000_0000 */
+/* [local] */ 
+
+typedef struct IA2Locale
+    {
+    BSTR language;
+    BSTR country;
+    BSTR variant;
+    } 	IA2Locale;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_Accessible2_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_Accessible2_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAccessible2_INTERFACE_DEFINED__
+#define __IAccessible2_INTERFACE_DEFINED__
+
+/* interface IAccessible2 */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessible2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("E89F726E-C4F4-4c19-BB19-B647D7FA8478")
+    IAccessible2 : public IAccessible
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nRelations( 
+            /* [retval][out] */ long *nRelations) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_relation( 
+            /* [in] */ long relationIndex,
+            /* [retval][out] */ IAccessibleRelation **relation) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_relations( 
+            /* [in] */ long maxRelations,
+            /* [length_is][size_is][out] */ IAccessibleRelation **relations,
+            /* [retval][out] */ long *nRelations) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE role( 
+            /* [retval][out] */ long *role) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE scrollTo( 
+            /* [in] */ enum IA2ScrollType scrollType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE scrollToPoint( 
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_groupPosition( 
+            /* [out] */ long *groupLevel,
+            /* [out] */ long *similarItemsInGroup,
+            /* [retval][out] */ long *positionInGroup) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_states( 
+            /* [retval][out] */ AccessibleStates *states) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_extendedRole( 
+            /* [retval][out] */ BSTR *extendedRole) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_localizedExtendedRole( 
+            /* [retval][out] */ BSTR *localizedExtendedRole) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nExtendedStates( 
+            /* [retval][out] */ long *nExtendedStates) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_extendedStates( 
+            /* [in] */ long maxExtendedStates,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **extendedStates,
+            /* [retval][out] */ long *nExtendedStates) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_localizedExtendedStates( 
+            /* [in] */ long maxLocalizedExtendedStates,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **localizedExtendedStates,
+            /* [retval][out] */ long *nLocalizedExtendedStates) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_uniqueID( 
+            /* [retval][out] */ long *uniqueID) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_windowHandle( 
+            /* [retval][out] */ HWND *windowHandle) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_indexInParent( 
+            /* [retval][out] */ long *indexInParent) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_locale( 
+            /* [retval][out] */ IA2Locale *locale) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
+            /* [retval][out] */ BSTR *attributes) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessible2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessible2 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessible2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessible2 * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
+            IAccessible2 * This,
+            /* [out] */ UINT *pctinfo);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
+            IAccessible2 * This,
+            /* [in] */ UINT iTInfo,
+            /* [in] */ LCID lcid,
+            /* [out] */ ITypeInfo **ppTInfo);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
+            IAccessible2 * This,
+            /* [in] */ REFIID riid,
+            /* [size_is][in] */ LPOLESTR *rgszNames,
+            /* [range][in] */ UINT cNames,
+            /* [in] */ LCID lcid,
+            /* [size_is][out] */ DISPID *rgDispId);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
+            IAccessible2 * This,
+            /* [in] */ DISPID dispIdMember,
+            /* [in] */ REFIID riid,
+            /* [in] */ LCID lcid,
+            /* [in] */ WORD wFlags,
+            /* [out][in] */ DISPPARAMS *pDispParams,
+            /* [out] */ VARIANT *pVarResult,
+            /* [out] */ EXCEPINFO *pExcepInfo,
+            /* [out] */ UINT *puArgErr);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accParent )( 
+            IAccessible2 * This,
+            /* [retval][out] */ IDispatch **ppdispParent);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accChildCount )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *pcountChildren);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accChild )( 
+            IAccessible2 * This,
+            /* [in] */ VARIANT varChild,
+            /* [retval][out] */ IDispatch **ppdispChild);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accName )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszName);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accValue )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszValue);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accDescription )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszDescription);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accRole )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ VARIANT *pvarRole);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accState )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ VARIANT *pvarState);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accHelp )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszHelp);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accHelpTopic )( 
+            IAccessible2 * This,
+            /* [out] */ BSTR *pszHelpFile,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ long *pidTopic);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accKeyboardShortcut )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszKeyboardShortcut);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accFocus )( 
+            IAccessible2 * This,
+            /* [retval][out] */ VARIANT *pvarChild);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accSelection )( 
+            IAccessible2 * This,
+            /* [retval][out] */ VARIANT *pvarChildren);
+        
+        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_accDefaultAction )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [retval][out] */ BSTR *pszDefaultAction);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accSelect )( 
+            IAccessible2 * This,
+            /* [in] */ long flagsSelect,
+            /* [optional][in] */ VARIANT varChild);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accLocation )( 
+            IAccessible2 * This,
+            /* [out] */ long *pxLeft,
+            /* [out] */ long *pyTop,
+            /* [out] */ long *pcxWidth,
+            /* [out] */ long *pcyHeight,
+            /* [optional][in] */ VARIANT varChild);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accNavigate )( 
+            IAccessible2 * This,
+            /* [in] */ long navDir,
+            /* [optional][in] */ VARIANT varStart,
+            /* [retval][out] */ VARIANT *pvarEndUpAt);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accHitTest )( 
+            IAccessible2 * This,
+            /* [in] */ long xLeft,
+            /* [in] */ long yTop,
+            /* [retval][out] */ VARIANT *pvarChild);
+        
+        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE *accDoDefaultAction )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild);
+        
+        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_accName )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [in] */ BSTR szName);
+        
+        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_accValue )( 
+            IAccessible2 * This,
+            /* [optional][in] */ VARIANT varChild,
+            /* [in] */ BSTR szValue);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nRelations )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *nRelations);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_relation )( 
+            IAccessible2 * This,
+            /* [in] */ long relationIndex,
+            /* [retval][out] */ IAccessibleRelation **relation);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_relations )( 
+            IAccessible2 * This,
+            /* [in] */ long maxRelations,
+            /* [length_is][size_is][out] */ IAccessibleRelation **relations,
+            /* [retval][out] */ long *nRelations);
+        
+        HRESULT ( STDMETHODCALLTYPE *role )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *role);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollTo )( 
+            IAccessible2 * This,
+            /* [in] */ enum IA2ScrollType scrollType);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollToPoint )( 
+            IAccessible2 * This,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_groupPosition )( 
+            IAccessible2 * This,
+            /* [out] */ long *groupLevel,
+            /* [out] */ long *similarItemsInGroup,
+            /* [retval][out] */ long *positionInGroup);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_states )( 
+            IAccessible2 * This,
+            /* [retval][out] */ AccessibleStates *states);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_extendedRole )( 
+            IAccessible2 * This,
+            /* [retval][out] */ BSTR *extendedRole);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedExtendedRole )( 
+            IAccessible2 * This,
+            /* [retval][out] */ BSTR *localizedExtendedRole);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nExtendedStates )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *nExtendedStates);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_extendedStates )( 
+            IAccessible2 * This,
+            /* [in] */ long maxExtendedStates,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **extendedStates,
+            /* [retval][out] */ long *nExtendedStates);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedExtendedStates )( 
+            IAccessible2 * This,
+            /* [in] */ long maxLocalizedExtendedStates,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **localizedExtendedStates,
+            /* [retval][out] */ long *nLocalizedExtendedStates);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_uniqueID )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *uniqueID);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_windowHandle )( 
+            IAccessible2 * This,
+            /* [retval][out] */ HWND *windowHandle);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_indexInParent )( 
+            IAccessible2 * This,
+            /* [retval][out] */ long *indexInParent);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_locale )( 
+            IAccessible2 * This,
+            /* [retval][out] */ IA2Locale *locale);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
+            IAccessible2 * This,
+            /* [retval][out] */ BSTR *attributes);
+        
+        END_INTERFACE
+    } IAccessible2Vtbl;
+
+    interface IAccessible2
+    {
+        CONST_VTBL struct IAccessible2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessible2_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessible2_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessible2_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessible2_GetTypeInfoCount(This,pctinfo)	\
+    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 
+
+#define IAccessible2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
+    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 
+
+#define IAccessible2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
+    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 
+
+#define IAccessible2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
+    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 
+
+
+#define IAccessible2_get_accParent(This,ppdispParent)	\
+    ( (This)->lpVtbl -> get_accParent(This,ppdispParent) ) 
+
+#define IAccessible2_get_accChildCount(This,pcountChildren)	\
+    ( (This)->lpVtbl -> get_accChildCount(This,pcountChildren) ) 
+
+#define IAccessible2_get_accChild(This,varChild,ppdispChild)	\
+    ( (This)->lpVtbl -> get_accChild(This,varChild,ppdispChild) ) 
+
+#define IAccessible2_get_accName(This,varChild,pszName)	\
+    ( (This)->lpVtbl -> get_accName(This,varChild,pszName) ) 
+
+#define IAccessible2_get_accValue(This,varChild,pszValue)	\
+    ( (This)->lpVtbl -> get_accValue(This,varChild,pszValue) ) 
+
+#define IAccessible2_get_accDescription(This,varChild,pszDescription)	\
+    ( (This)->lpVtbl -> get_accDescription(This,varChild,pszDescription) ) 
+
+#define IAccessible2_get_accRole(This,varChild,pvarRole)	\
+    ( (This)->lpVtbl -> get_accRole(This,varChild,pvarRole) ) 
+
+#define IAccessible2_get_accState(This,varChild,pvarState)	\
+    ( (This)->lpVtbl -> get_accState(This,varChild,pvarState) ) 
+
+#define IAccessible2_get_accHelp(This,varChild,pszHelp)	\
+    ( (This)->lpVtbl -> get_accHelp(This,varChild,pszHelp) ) 
+
+#define IAccessible2_get_accHelpTopic(This,pszHelpFile,varChild,pidTopic)	\
+    ( (This)->lpVtbl -> get_accHelpTopic(This,pszHelpFile,varChild,pidTopic) ) 
+
+#define IAccessible2_get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut)	\
+    ( (This)->lpVtbl -> get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut) ) 
+
+#define IAccessible2_get_accFocus(This,pvarChild)	\
+    ( (This)->lpVtbl -> get_accFocus(This,pvarChild) ) 
+
+#define IAccessible2_get_accSelection(This,pvarChildren)	\
+    ( (This)->lpVtbl -> get_accSelection(This,pvarChildren) ) 
+
+#define IAccessible2_get_accDefaultAction(This,varChild,pszDefaultAction)	\
+    ( (This)->lpVtbl -> get_accDefaultAction(This,varChild,pszDefaultAction) ) 
+
+#define IAccessible2_accSelect(This,flagsSelect,varChild)	\
+    ( (This)->lpVtbl -> accSelect(This,flagsSelect,varChild) ) 
+
+#define IAccessible2_accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild)	\
+    ( (This)->lpVtbl -> accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild) ) 
+
+#define IAccessible2_accNavigate(This,navDir,varStart,pvarEndUpAt)	\
+    ( (This)->lpVtbl -> accNavigate(This,navDir,varStart,pvarEndUpAt) ) 
+
+#define IAccessible2_accHitTest(This,xLeft,yTop,pvarChild)	\
+    ( (This)->lpVtbl -> accHitTest(This,xLeft,yTop,pvarChild) ) 
+
+#define IAccessible2_accDoDefaultAction(This,varChild)	\
+    ( (This)->lpVtbl -> accDoDefaultAction(This,varChild) ) 
+
+#define IAccessible2_put_accName(This,varChild,szName)	\
+    ( (This)->lpVtbl -> put_accName(This,varChild,szName) ) 
+
+#define IAccessible2_put_accValue(This,varChild,szValue)	\
+    ( (This)->lpVtbl -> put_accValue(This,varChild,szValue) ) 
+
+
+#define IAccessible2_get_nRelations(This,nRelations)	\
+    ( (This)->lpVtbl -> get_nRelations(This,nRelations) ) 
+
+#define IAccessible2_get_relation(This,relationIndex,relation)	\
+    ( (This)->lpVtbl -> get_relation(This,relationIndex,relation) ) 
+
+#define IAccessible2_get_relations(This,maxRelations,relations,nRelations)	\
+    ( (This)->lpVtbl -> get_relations(This,maxRelations,relations,nRelations) ) 
+
+#define IAccessible2_role(This,role)	\
+    ( (This)->lpVtbl -> role(This,role) ) 
+
+#define IAccessible2_scrollTo(This,scrollType)	\
+    ( (This)->lpVtbl -> scrollTo(This,scrollType) ) 
+
+#define IAccessible2_scrollToPoint(This,coordinateType,x,y)	\
+    ( (This)->lpVtbl -> scrollToPoint(This,coordinateType,x,y) ) 
+
+#define IAccessible2_get_groupPosition(This,groupLevel,similarItemsInGroup,positionInGroup)	\
+    ( (This)->lpVtbl -> get_groupPosition(This,groupLevel,similarItemsInGroup,positionInGroup) ) 
+
+#define IAccessible2_get_states(This,states)	\
+    ( (This)->lpVtbl -> get_states(This,states) ) 
+
+#define IAccessible2_get_extendedRole(This,extendedRole)	\
+    ( (This)->lpVtbl -> get_extendedRole(This,extendedRole) ) 
+
+#define IAccessible2_get_localizedExtendedRole(This,localizedExtendedRole)	\
+    ( (This)->lpVtbl -> get_localizedExtendedRole(This,localizedExtendedRole) ) 
+
+#define IAccessible2_get_nExtendedStates(This,nExtendedStates)	\
+    ( (This)->lpVtbl -> get_nExtendedStates(This,nExtendedStates) ) 
+
+#define IAccessible2_get_extendedStates(This,maxExtendedStates,extendedStates,nExtendedStates)	\
+    ( (This)->lpVtbl -> get_extendedStates(This,maxExtendedStates,extendedStates,nExtendedStates) ) 
+
+#define IAccessible2_get_localizedExtendedStates(This,maxLocalizedExtendedStates,localizedExtendedStates,nLocalizedExtendedStates)	\
+    ( (This)->lpVtbl -> get_localizedExtendedStates(This,maxLocalizedExtendedStates,localizedExtendedStates,nLocalizedExtendedStates) ) 
+
+#define IAccessible2_get_uniqueID(This,uniqueID)	\
+    ( (This)->lpVtbl -> get_uniqueID(This,uniqueID) ) 
+
+#define IAccessible2_get_windowHandle(This,windowHandle)	\
+    ( (This)->lpVtbl -> get_windowHandle(This,windowHandle) ) 
+
+#define IAccessible2_get_indexInParent(This,indexInParent)	\
+    ( (This)->lpVtbl -> get_indexInParent(This,indexInParent) ) 
+
+#define IAccessible2_get_locale(This,locale)	\
+    ( (This)->lpVtbl -> get_locale(This,locale) ) 
+
+#define IAccessible2_get_attributes(This,attributes)	\
+    ( (This)->lpVtbl -> get_attributes(This,attributes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessible2_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
+unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
+unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
+void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/Accessible2_i.c b/src/3rdparty/iaccessible2/generated/x86/Accessible2_i.c
new file mode 100644
index 0000000..df0f940
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/Accessible2_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:51 2012
+ */
+/* Compiler settings for Accessible2.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessible2,0xE89F726E,0xC4F4,0x4c19,0xBB,0x19,0xB6,0x47,0xD7,0xFA,0x84,0x78);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/Accessible2_p.c b/src/3rdparty/iaccessible2/generated/x86/Accessible2_p.c
new file mode 100644
index 0000000..abb5883
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/Accessible2_p.c
@@ -0,0 +1,1190 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:51 2012
+ */
+/* Compiler settings for Accessible2.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "Accessible2.h"
+
+#define TYPE_FORMAT_STRING_SIZE   189                               
+#define PROC_FORMAT_STRING_SIZE   715                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   2            
+
+typedef struct _Accessible2_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } Accessible2_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _Accessible2_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } Accessible2_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _Accessible2_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } Accessible2_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const Accessible2_MIDL_TYPE_FORMAT_STRING Accessible2__MIDL_TypeFormatString;
+extern const Accessible2_MIDL_PROC_FORMAT_STRING Accessible2__MIDL_ProcFormatString;
+extern const Accessible2_MIDL_EXPR_FORMAT_STRING Accessible2__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessible2_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessible2_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const Accessible2_MIDL_PROC_FORMAT_STRING Accessible2__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_nRelations */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x1c ),	/* 28 */
+/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nRelations */
+
+/* 24 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_relation */
+
+/* 36 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 42 */	NdrFcShort( 0x1d ),	/* 29 */
+/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 52 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter relationIndex */
+
+/* 60 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 64 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter relation */
+
+/* 66 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 70 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
+
+	/* Return value */
+
+/* 72 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 74 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 76 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_relations */
+
+/* 78 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 80 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 84 */	NdrFcShort( 0x1e ),	/* 30 */
+/* 86 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 90 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 92 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 94 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 96 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxRelations */
+
+/* 102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter relations */
+
+/* 108 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
+/* 110 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 112 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Parameter nRelations */
+
+/* 114 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 122 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure role */
+
+/* 126 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 128 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 132 */	NdrFcShort( 0x1f ),	/* 31 */
+/* 134 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 140 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 142 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 148 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter role */
+
+/* 150 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 152 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 154 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 158 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 160 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure scrollTo */
+
+/* 162 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 164 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 168 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 170 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 172 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 174 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 176 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 178 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 180 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter scrollType */
+
+/* 186 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 188 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 190 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 194 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 196 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure scrollToPoint */
+
+/* 198 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 204 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 206 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 208 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 212 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 214 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 216 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter coordinateType */
+
+/* 222 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 224 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 226 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter x */
+
+/* 228 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 230 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 232 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 234 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 236 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 238 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 240 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 242 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 244 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_groupPosition */
+
+/* 246 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 248 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 252 */	NdrFcShort( 0x22 ),	/* 34 */
+/* 254 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 258 */	NdrFcShort( 0x5c ),	/* 92 */
+/* 260 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 262 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 264 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 268 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter groupLevel */
+
+/* 270 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 272 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 274 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter similarItemsInGroup */
+
+/* 276 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 278 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 280 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter positionInGroup */
+
+/* 282 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 284 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 286 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 288 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 290 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 292 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_states */
+
+/* 294 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 296 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 300 */	NdrFcShort( 0x23 ),	/* 35 */
+/* 302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 304 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 306 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 308 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 310 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 312 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 316 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter states */
+
+/* 318 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 320 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 322 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 324 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 326 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 328 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_extendedRole */
+
+/* 330 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 336 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 338 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 340 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 342 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 344 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 346 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 348 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 352 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter extendedRole */
+
+/* 354 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 356 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 358 */	NdrFcShort( 0x54 ),	/* Type Offset=84 */
+
+	/* Return value */
+
+/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 362 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 364 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_localizedExtendedRole */
+
+/* 366 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 372 */	NdrFcShort( 0x25 ),	/* 37 */
+/* 374 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 376 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 378 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 380 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 382 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 384 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter localizedExtendedRole */
+
+/* 390 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 392 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 394 */	NdrFcShort( 0x54 ),	/* Type Offset=84 */
+
+	/* Return value */
+
+/* 396 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 398 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 400 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nExtendedStates */
+
+/* 402 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 404 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 408 */	NdrFcShort( 0x26 ),	/* 38 */
+/* 410 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 414 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 416 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 418 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 424 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nExtendedStates */
+
+/* 426 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 428 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 430 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 432 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 434 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 436 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_extendedStates */
+
+/* 438 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 440 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 444 */	NdrFcShort( 0x27 ),	/* 39 */
+/* 446 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 448 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 450 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 452 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 454 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 456 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxExtendedStates */
+
+/* 462 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 464 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 466 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter extendedStates */
+
+/* 468 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 470 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 472 */	NdrFcShort( 0x5e ),	/* Type Offset=94 */
+
+	/* Parameter nExtendedStates */
+
+/* 474 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 476 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 478 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 482 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 484 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_localizedExtendedStates */
+
+/* 486 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 488 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 492 */	NdrFcShort( 0x28 ),	/* 40 */
+/* 494 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 496 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 498 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 500 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 502 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 504 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 508 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxLocalizedExtendedStates */
+
+/* 510 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 512 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 514 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter localizedExtendedStates */
+
+/* 516 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 518 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 520 */	NdrFcShort( 0x5e ),	/* Type Offset=94 */
+
+	/* Parameter nLocalizedExtendedStates */
+
+/* 522 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 524 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 526 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 528 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 530 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 532 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_uniqueID */
+
+/* 534 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 536 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 540 */	NdrFcShort( 0x29 ),	/* 41 */
+/* 542 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 546 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 548 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 550 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 552 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 556 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter uniqueID */
+
+/* 558 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 560 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 562 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 564 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 566 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 568 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_windowHandle */
+
+/* 570 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 572 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 576 */	NdrFcShort( 0x2a ),	/* 42 */
+/* 578 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 580 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 582 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 584 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 586 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 588 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 592 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter windowHandle */
+
+/* 594 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 596 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 598 */	NdrFcShort( 0x98 ),	/* Type Offset=152 */
+
+	/* Return value */
+
+/* 600 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 602 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 604 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_indexInParent */
+
+/* 606 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 608 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 612 */	NdrFcShort( 0x2b ),	/* 43 */
+/* 614 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 616 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 618 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 620 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 622 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 624 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 626 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 628 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter indexInParent */
+
+/* 630 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 632 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 634 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 636 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 638 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 640 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_locale */
+
+/* 642 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 644 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 648 */	NdrFcShort( 0x2c ),	/* 44 */
+/* 650 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 652 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 654 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 656 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 658 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 660 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 662 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter locale */
+
+/* 666 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 668 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 670 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */
+
+	/* Return value */
+
+/* 672 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 674 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 676 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_attributes */
+
+/* 678 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 680 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 684 */	NdrFcShort( 0x2d ),	/* 45 */
+/* 686 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 688 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 690 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 692 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 694 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 696 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 700 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter attributes */
+
+/* 702 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 704 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 706 */	NdrFcShort( 0x54 ),	/* Type Offset=84 */
+
+	/* Return value */
+
+/* 708 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 710 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 712 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const Accessible2_MIDL_TYPE_FORMAT_STRING Accessible2__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
+/* 10 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 12 */	NdrFcLong( 0x7cdf86ee ),	/* 2095023854 */
+/* 16 */	NdrFcShort( 0xc3da ),	/* -15398 */
+/* 18 */	NdrFcShort( 0x496a ),	/* 18794 */
+/* 20 */	0xbd,		/* 189 */
+			0xa4,		/* 164 */
+/* 22 */	0x28,		/* 40 */
+			0x1b,		/* 27 */
+/* 24 */	0x33,		/* 51 */
+			0x6e,		/* 110 */
+/* 26 */	0x1f,		/* 31 */
+			0xdc,		/* 220 */
+/* 28 */	
+			0x11, 0x0,	/* FC_RP */
+/* 30 */	NdrFcShort( 0x2 ),	/* Offset= 2 (32) */
+/* 32 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 38 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 40 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 42 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 44 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 46 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 48 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 50 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (10) */
+/* 52 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 54 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 56 */	NdrFcShort( 0x1c ),	/* Offset= 28 (84) */
+/* 58 */	
+			0x13, 0x0,	/* FC_OP */
+/* 60 */	NdrFcShort( 0xe ),	/* Offset= 14 (74) */
+/* 62 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 64 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 66 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 68 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 70 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 72 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 74 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 76 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 78 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (62) */
+/* 80 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 82 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 84 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 88 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 92 */	NdrFcShort( 0xffde ),	/* Offset= -34 (58) */
+/* 94 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 96 */	NdrFcShort( 0x2 ),	/* Offset= 2 (98) */
+/* 98 */	
+			0x13, 0x0,	/* FC_OP */
+/* 100 */	NdrFcShort( 0x2 ),	/* Offset= 2 (102) */
+/* 102 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 108 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 110 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 112 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 114 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 116 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 118 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 120 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (84) */
+/* 122 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 124 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 126 */	NdrFcShort( 0x1a ),	/* Offset= 26 (152) */
+/* 128 */	
+			0x13, 0x0,	/* FC_OP */
+/* 130 */	NdrFcShort( 0x2 ),	/* Offset= 2 (132) */
+/* 132 */	
+			0x2a,		/* FC_ENCAPSULATED_UNION */
+			0x48,		/* 72 */
+/* 134 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 136 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 138 */	NdrFcLong( 0x48746457 ),	/* 1215587415 */
+/* 142 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 144 */	NdrFcLong( 0x52746457 ),	/* 1383359575 */
+/* 148 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 150 */	NdrFcShort( 0xffff ),	/* Offset= -1 (149) */
+/* 152 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 154 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 156 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 160 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (128) */
+/* 162 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 164 */	NdrFcShort( 0x2 ),	/* Offset= 2 (166) */
+/* 166 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 168 */	NdrFcShort( 0xc ),	/* 12 */
+/* 170 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 172 */	NdrFcShort( 0x0 ),	/* Offset= 0 (172) */
+/* 174 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 176 */	NdrFcShort( 0xffa4 ),	/* Offset= -92 (84) */
+/* 178 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 180 */	NdrFcShort( 0xffa0 ),	/* Offset= -96 (84) */
+/* 182 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 184 */	NdrFcShort( 0xff9c ),	/* Offset= -100 (84) */
+/* 186 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            },
+            {
+            HWND_UserSize
+            ,HWND_UserMarshal
+            ,HWND_UserUnmarshal
+            ,HWND_UserFree
+            }
+
+        };
+
+
+
+/* Standard interface: __MIDL_itf_Accessible2_0000_0000, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IDispatch, ver. 0.0,
+   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessible, ver. 0.0,
+   GUID={0x618736e0,0x3c3d,0x11cf,{0x81,0x0c,0x00,0xaa,0x00,0x38,0x9b,0x71}} */
+
+
+/* Object interface: IAccessible2, ver. 0.0,
+   GUID={0xE89F726E,0xC4F4,0x4c19,{0xBB,0x19,0xB6,0x47,0xD7,0xFA,0x84,0x78}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessible2_FormatStringOffsetTable[] =
+    {
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    0,
+    36,
+    78,
+    126,
+    162,
+    198,
+    246,
+    294,
+    330,
+    366,
+    402,
+    438,
+    486,
+    534,
+    570,
+    606,
+    642,
+    678
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessible2_ProxyInfo =
+    {
+    &Object_StubDesc,
+    Accessible2__MIDL_ProcFormatString.Format,
+    &IAccessible2_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessible2_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    Accessible2__MIDL_ProcFormatString.Format,
+    &IAccessible2_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(46) _IAccessible2ProxyVtbl = 
+{
+    &IAccessible2_ProxyInfo,
+    &IID_IAccessible2,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    0 /* IDispatch::GetTypeInfoCount */ ,
+    0 /* IDispatch::GetTypeInfo */ ,
+    0 /* IDispatch::GetIDsOfNames */ ,
+    0 /* IDispatch_Invoke_Proxy */ ,
+    0 /* IAccessible::get_accParent */ ,
+    0 /* IAccessible::get_accChildCount */ ,
+    0 /* IAccessible::get_accChild */ ,
+    0 /* IAccessible::get_accName */ ,
+    0 /* IAccessible::get_accValue */ ,
+    0 /* IAccessible::get_accDescription */ ,
+    0 /* IAccessible::get_accRole */ ,
+    0 /* IAccessible::get_accState */ ,
+    0 /* IAccessible::get_accHelp */ ,
+    0 /* IAccessible::get_accHelpTopic */ ,
+    0 /* IAccessible::get_accKeyboardShortcut */ ,
+    0 /* IAccessible::get_accFocus */ ,
+    0 /* IAccessible::get_accSelection */ ,
+    0 /* IAccessible::get_accDefaultAction */ ,
+    0 /* IAccessible::accSelect */ ,
+    0 /* IAccessible::accLocation */ ,
+    0 /* IAccessible::accNavigate */ ,
+    0 /* IAccessible::accHitTest */ ,
+    0 /* IAccessible::accDoDefaultAction */ ,
+    0 /* IAccessible::put_accName */ ,
+    0 /* IAccessible::put_accValue */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_nRelations */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_relation */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_relations */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::role */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::scrollTo */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::scrollToPoint */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_groupPosition */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_states */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_extendedRole */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_localizedExtendedRole */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_nExtendedStates */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_extendedStates */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_localizedExtendedStates */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_uniqueID */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_windowHandle */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_indexInParent */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_locale */ ,
+    (void *) (INT_PTR) -1 /* IAccessible2::get_attributes */
+};
+
+
+static const PRPC_STUB_FUNCTION IAccessible2_table[] =
+{
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2
+};
+
+CInterfaceStubVtbl _IAccessible2StubVtbl =
+{
+    &IID_IAccessible2,
+    &IAccessible2_ServerInfo,
+    46,
+    &IAccessible2_table[-3],
+    CStdStubBuffer_DELEGATING_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    Accessible2__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _Accessible2_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessible2ProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _Accessible2_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessible2StubVtbl,
+    0
+};
+
+PCInterfaceName const _Accessible2_InterfaceNamesList[] = 
+{
+    "IAccessible2",
+    0
+};
+
+const IID *  const _Accessible2_BaseIIDList[] = 
+{
+    &IID_IAccessible,
+    0
+};
+
+
+#define _Accessible2_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _Accessible2, pIID, n)
+
+int __stdcall _Accessible2_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_Accessible2_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo Accessible2_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _Accessible2_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _Accessible2_StubVtblList,
+    (const PCInterfaceName * ) & _Accessible2_InterfaceNamesList,
+    (const IID ** ) & _Accessible2_BaseIIDList,
+    & _Accessible2_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleAction.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleAction.h
new file mode 100644
index 0000000..c1ebabb
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleAction.h
@@ -0,0 +1,220 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:51 2012
+ */
+/* Compiler settings for AccessibleAction.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleAction_h__
+#define __AccessibleAction_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleAction_FWD_DEFINED__
+#define __IAccessibleAction_FWD_DEFINED__
+typedef interface IAccessibleAction IAccessibleAction;
+#endif 	/* __IAccessibleAction_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleAction_INTERFACE_DEFINED__
+#define __IAccessibleAction_INTERFACE_DEFINED__
+
+/* interface IAccessibleAction */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleAction;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("B70D9F59-3B5A-4dba-AB9E-22012F607DF5")
+    IAccessibleAction : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE nActions( 
+            /* [retval][out] */ long *nActions) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE doAction( 
+            /* [in] */ long actionIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_description( 
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_keyBinding( 
+            /* [in] */ long actionIndex,
+            /* [in] */ long nMaxBindings,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **keyBindings,
+            /* [retval][out] */ long *nBindings) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_name( 
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *name) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_localizedName( 
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *localizedName) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleActionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleAction * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleAction * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleAction * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *nActions )( 
+            IAccessibleAction * This,
+            /* [retval][out] */ long *nActions);
+        
+        HRESULT ( STDMETHODCALLTYPE *doAction )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_description )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_keyBinding )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex,
+            /* [in] */ long nMaxBindings,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **keyBindings,
+            /* [retval][out] */ long *nBindings);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *name);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedName )( 
+            IAccessibleAction * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *localizedName);
+        
+        END_INTERFACE
+    } IAccessibleActionVtbl;
+
+    interface IAccessibleAction
+    {
+        CONST_VTBL struct IAccessibleActionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleAction_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleAction_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleAction_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleAction_nActions(This,nActions)	\
+    ( (This)->lpVtbl -> nActions(This,nActions) ) 
+
+#define IAccessibleAction_doAction(This,actionIndex)	\
+    ( (This)->lpVtbl -> doAction(This,actionIndex) ) 
+
+#define IAccessibleAction_get_description(This,actionIndex,description)	\
+    ( (This)->lpVtbl -> get_description(This,actionIndex,description) ) 
+
+#define IAccessibleAction_get_keyBinding(This,actionIndex,nMaxBindings,keyBindings,nBindings)	\
+    ( (This)->lpVtbl -> get_keyBinding(This,actionIndex,nMaxBindings,keyBindings,nBindings) ) 
+
+#define IAccessibleAction_get_name(This,actionIndex,name)	\
+    ( (This)->lpVtbl -> get_name(This,actionIndex,name) ) 
+
+#define IAccessibleAction_get_localizedName(This,actionIndex,localizedName)	\
+    ( (This)->lpVtbl -> get_localizedName(This,actionIndex,localizedName) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleAction_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleAction_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleAction_i.c
new file mode 100644
index 0000000..ea097ef
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleAction_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:51 2012
+ */
+/* Compiler settings for AccessibleAction.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleAction,0xB70D9F59,0x3B5A,0x4dba,0xAB,0x9E,0x22,0x01,0x2F,0x60,0x7D,0xF5);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleAction_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleAction_p.c
new file mode 100644
index 0000000..4185457
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleAction_p.c
@@ -0,0 +1,563 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:51 2012
+ */
+/* Compiler settings for AccessibleAction.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleAction.h"
+
+#define TYPE_FORMAT_STRING_SIZE   77                                
+#define PROC_FORMAT_STRING_SIZE   253                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleAction_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleAction_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleAction_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleAction_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleAction_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleAction_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleAction_MIDL_TYPE_FORMAT_STRING AccessibleAction__MIDL_TypeFormatString;
+extern const AccessibleAction_MIDL_PROC_FORMAT_STRING AccessibleAction__MIDL_ProcFormatString;
+extern const AccessibleAction_MIDL_EXPR_FORMAT_STRING AccessibleAction__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleAction_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleAction_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleAction_MIDL_PROC_FORMAT_STRING AccessibleAction__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure nActions */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nActions */
+
+/* 24 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure doAction */
+
+/* 36 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 44 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 52 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 60 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 64 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_description */
+
+/* 72 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 78 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 80 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 82 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 86 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 88 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 90 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 96 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 100 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 102 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 106 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 110 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_keyBinding */
+
+/* 114 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 116 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 122 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 124 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 126 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 128 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x5,		/* 5 */
+/* 130 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 132 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 138 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 140 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 142 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter nMaxBindings */
+
+/* 144 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 146 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 148 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter keyBindings */
+
+/* 150 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 152 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 154 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */
+
+	/* Parameter nBindings */
+
+/* 156 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 158 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 160 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 164 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 166 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_name */
+
+/* 168 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 174 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 176 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 178 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 182 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 184 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 186 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 192 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 194 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 196 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter name */
+
+/* 198 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 200 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 202 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 204 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 206 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 208 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_localizedName */
+
+/* 210 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 212 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 216 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 218 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 220 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 222 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 224 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 226 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 228 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 232 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter actionIndex */
+
+/* 234 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 236 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 238 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter localizedName */
+
+/* 240 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 242 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 244 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 246 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 248 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 250 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleAction_MIDL_TYPE_FORMAT_STRING AccessibleAction__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  8 */	NdrFcShort( 0x1c ),	/* Offset= 28 (36) */
+/* 10 */	
+			0x13, 0x0,	/* FC_OP */
+/* 12 */	NdrFcShort( 0xe ),	/* Offset= 14 (26) */
+/* 14 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 16 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 18 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 20 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 22 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 24 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 26 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 28 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 30 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (14) */
+/* 32 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 34 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 36 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 42 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0xffde ),	/* Offset= -34 (10) */
+/* 46 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
+/* 50 */	
+			0x13, 0x0,	/* FC_OP */
+/* 52 */	NdrFcShort( 0x2 ),	/* Offset= 2 (54) */
+/* 54 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 60 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 62 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 64 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 66 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 68 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 70 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 72 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (36) */
+/* 74 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleAction, ver. 0.0,
+   GUID={0xB70D9F59,0x3B5A,0x4dba,{0xAB,0x9E,0x22,0x01,0x2F,0x60,0x7D,0xF5}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleAction_FormatStringOffsetTable[] =
+    {
+    0,
+    36,
+    72,
+    114,
+    168,
+    210
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleAction_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleAction__MIDL_ProcFormatString.Format,
+    &IAccessibleAction_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleAction_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleAction__MIDL_ProcFormatString.Format,
+    &IAccessibleAction_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(9) _IAccessibleActionProxyVtbl = 
+{
+    &IAccessibleAction_ProxyInfo,
+    &IID_IAccessibleAction,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::nActions */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::doAction */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::get_description */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::get_keyBinding */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::get_name */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleAction::get_localizedName */
+};
+
+const CInterfaceStubVtbl _IAccessibleActionStubVtbl =
+{
+    &IID_IAccessibleAction,
+    &IAccessibleAction_ServerInfo,
+    9,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleAction__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleAction_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleActionProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleAction_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleActionStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleAction_InterfaceNamesList[] = 
+{
+    "IAccessibleAction",
+    0
+};
+
+
+#define _AccessibleAction_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleAction, pIID, n)
+
+int __stdcall _AccessibleAction_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleAction_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleAction_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleAction_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleAction_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleAction_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleAction_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication.h
new file mode 100644
index 0000000..e140968
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication.h
@@ -0,0 +1,188 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:52 2012
+ */
+/* Compiler settings for AccessibleApplication.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleApplication_h__
+#define __AccessibleApplication_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleApplication_FWD_DEFINED__
+#define __IAccessibleApplication_FWD_DEFINED__
+typedef interface IAccessibleApplication IAccessibleApplication;
+#endif 	/* __IAccessibleApplication_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleApplication_INTERFACE_DEFINED__
+#define __IAccessibleApplication_INTERFACE_DEFINED__
+
+/* interface IAccessibleApplication */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleApplication;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("D49DED83-5B25-43F4-9B95-93B44595979E")
+    IAccessibleApplication : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_appName( 
+            /* [retval][out] */ BSTR *name) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_appVersion( 
+            /* [retval][out] */ BSTR *version) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_toolkitName( 
+            /* [retval][out] */ BSTR *name) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_toolkitVersion( 
+            /* [retval][out] */ BSTR *version) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleApplicationVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleApplication * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleApplication * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleApplication * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_appName )( 
+            IAccessibleApplication * This,
+            /* [retval][out] */ BSTR *name);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_appVersion )( 
+            IAccessibleApplication * This,
+            /* [retval][out] */ BSTR *version);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_toolkitName )( 
+            IAccessibleApplication * This,
+            /* [retval][out] */ BSTR *name);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_toolkitVersion )( 
+            IAccessibleApplication * This,
+            /* [retval][out] */ BSTR *version);
+        
+        END_INTERFACE
+    } IAccessibleApplicationVtbl;
+
+    interface IAccessibleApplication
+    {
+        CONST_VTBL struct IAccessibleApplicationVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleApplication_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleApplication_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleApplication_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleApplication_get_appName(This,name)	\
+    ( (This)->lpVtbl -> get_appName(This,name) ) 
+
+#define IAccessibleApplication_get_appVersion(This,version)	\
+    ( (This)->lpVtbl -> get_appVersion(This,version) ) 
+
+#define IAccessibleApplication_get_toolkitName(This,name)	\
+    ( (This)->lpVtbl -> get_toolkitName(This,name) ) 
+
+#define IAccessibleApplication_get_toolkitVersion(This,version)	\
+    ( (This)->lpVtbl -> get_toolkitVersion(This,version) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleApplication_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication_i.c
new file mode 100644
index 0000000..daa0c1f
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:52 2012
+ */
+/* Compiler settings for AccessibleApplication.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleApplication,0xD49DED83,0x5B25,0x43F4,0x9B,0x95,0x93,0xB4,0x45,0x95,0x97,0x9E);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication_p.c
new file mode 100644
index 0000000..4e51a63
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleApplication_p.c
@@ -0,0 +1,428 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:52 2012
+ */
+/* Compiler settings for AccessibleApplication.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleApplication.h"
+
+#define TYPE_FORMAT_STRING_SIZE   43                                
+#define PROC_FORMAT_STRING_SIZE   145                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleApplication_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleApplication_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleApplication_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleApplication_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleApplication_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleApplication_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleApplication_MIDL_TYPE_FORMAT_STRING AccessibleApplication__MIDL_TypeFormatString;
+extern const AccessibleApplication_MIDL_PROC_FORMAT_STRING AccessibleApplication__MIDL_ProcFormatString;
+extern const AccessibleApplication_MIDL_EXPR_FORMAT_STRING AccessibleApplication__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleApplication_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleApplication_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleApplication_MIDL_PROC_FORMAT_STRING AccessibleApplication__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_appName */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter name */
+
+/* 24 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_appVersion */
+
+/* 36 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 44 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 52 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 54 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter version */
+
+/* 60 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 64 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_toolkitName */
+
+/* 72 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 78 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 86 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 88 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 90 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter name */
+
+/* 96 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 100 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_toolkitVersion */
+
+/* 108 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 114 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 122 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 124 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 126 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 130 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter version */
+
+/* 132 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 134 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 136 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 140 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 142 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleApplication_MIDL_TYPE_FORMAT_STRING AccessibleApplication__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
+/* 10 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 14 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 20 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 22 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 26 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (10) */
+/* 28 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 30 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 32 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0xffde ),	/* Offset= -34 (6) */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleApplication, ver. 0.0,
+   GUID={0xD49DED83,0x5B25,0x43F4,{0x9B,0x95,0x93,0xB4,0x45,0x95,0x97,0x9E}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleApplication_FormatStringOffsetTable[] =
+    {
+    0,
+    36,
+    72,
+    108
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleApplication_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleApplication__MIDL_ProcFormatString.Format,
+    &IAccessibleApplication_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleApplication_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleApplication__MIDL_ProcFormatString.Format,
+    &IAccessibleApplication_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(7) _IAccessibleApplicationProxyVtbl = 
+{
+    &IAccessibleApplication_ProxyInfo,
+    &IID_IAccessibleApplication,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleApplication::get_appName */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleApplication::get_appVersion */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleApplication::get_toolkitName */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleApplication::get_toolkitVersion */
+};
+
+const CInterfaceStubVtbl _IAccessibleApplicationStubVtbl =
+{
+    &IID_IAccessibleApplication,
+    &IAccessibleApplication_ServerInfo,
+    7,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleApplication__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleApplication_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleApplicationProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleApplication_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleApplicationStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleApplication_InterfaceNamesList[] = 
+{
+    "IAccessibleApplication",
+    0
+};
+
+
+#define _AccessibleApplication_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleApplication, pIID, n)
+
+int __stdcall _AccessibleApplication_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleApplication_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleApplication_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleApplication_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleApplication_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleApplication_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleApplication_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent.h
new file mode 100644
index 0000000..a5d6fa6
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent.h
@@ -0,0 +1,185 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:52 2012
+ */
+/* Compiler settings for AccessibleComponent.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleComponent_h__
+#define __AccessibleComponent_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleComponent_FWD_DEFINED__
+#define __IAccessibleComponent_FWD_DEFINED__
+typedef interface IAccessibleComponent IAccessibleComponent;
+#endif 	/* __IAccessibleComponent_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleComponent_0000_0000 */
+/* [local] */ 
+
+typedef long IA2Color;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleComponent_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleComponent_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAccessibleComponent_INTERFACE_DEFINED__
+#define __IAccessibleComponent_INTERFACE_DEFINED__
+
+/* interface IAccessibleComponent */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleComponent;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("1546D4B0-4C98-4bda-89AE-9A64748BDDE4")
+    IAccessibleComponent : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_locationInParent( 
+            /* [out] */ long *x,
+            /* [retval][out] */ long *y) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_foreground( 
+            /* [retval][out] */ IA2Color *foreground) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_background( 
+            /* [retval][out] */ IA2Color *background) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleComponentVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleComponent * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleComponent * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleComponent * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_locationInParent )( 
+            IAccessibleComponent * This,
+            /* [out] */ long *x,
+            /* [retval][out] */ long *y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_foreground )( 
+            IAccessibleComponent * This,
+            /* [retval][out] */ IA2Color *foreground);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_background )( 
+            IAccessibleComponent * This,
+            /* [retval][out] */ IA2Color *background);
+        
+        END_INTERFACE
+    } IAccessibleComponentVtbl;
+
+    interface IAccessibleComponent
+    {
+        CONST_VTBL struct IAccessibleComponentVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleComponent_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleComponent_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleComponent_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleComponent_get_locationInParent(This,x,y)	\
+    ( (This)->lpVtbl -> get_locationInParent(This,x,y) ) 
+
+#define IAccessibleComponent_get_foreground(This,foreground)	\
+    ( (This)->lpVtbl -> get_foreground(This,foreground) ) 
+
+#define IAccessibleComponent_get_background(This,background)	\
+    ( (This)->lpVtbl -> get_background(This,background) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleComponent_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent_i.c
new file mode 100644
index 0000000..b48fee2
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:52 2012
+ */
+/* Compiler settings for AccessibleComponent.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleComponent,0x1546D4B0,0x4C98,0x4bda,0x89,0xAE,0x9A,0x64,0x74,0x8B,0xDD,0xE4);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent_p.c
new file mode 100644
index 0000000..23230ff
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleComponent_p.c
@@ -0,0 +1,369 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:52 2012
+ */
+/* Compiler settings for AccessibleComponent.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleComponent.h"
+
+#define TYPE_FORMAT_STRING_SIZE   7                                 
+#define PROC_FORMAT_STRING_SIZE   115                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   0            
+
+typedef struct _AccessibleComponent_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleComponent_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleComponent_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleComponent_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleComponent_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleComponent_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleComponent_MIDL_TYPE_FORMAT_STRING AccessibleComponent__MIDL_TypeFormatString;
+extern const AccessibleComponent_MIDL_PROC_FORMAT_STRING AccessibleComponent__MIDL_ProcFormatString;
+extern const AccessibleComponent_MIDL_EXPR_FORMAT_STRING AccessibleComponent__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleComponent_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleComponent_ProxyInfo;
+
+
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleComponent_MIDL_PROC_FORMAT_STRING AccessibleComponent__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_locationInParent */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter x */
+
+/* 24 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 30 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 40 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_foreground */
+
+/* 42 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 48 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 50 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 54 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 56 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 58 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter foreground */
+
+/* 66 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 72 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 76 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_background */
+
+/* 78 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 80 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 84 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 86 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 88 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 90 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 92 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 94 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter background */
+
+/* 102 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 110 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleComponent_MIDL_TYPE_FORMAT_STRING AccessibleComponent__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+
+			0x0
+        }
+    };
+
+
+/* Standard interface: __MIDL_itf_AccessibleComponent_0000_0000, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleComponent, ver. 0.0,
+   GUID={0x1546D4B0,0x4C98,0x4bda,{0x89,0xAE,0x9A,0x64,0x74,0x8B,0xDD,0xE4}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleComponent_FormatStringOffsetTable[] =
+    {
+    0,
+    42,
+    78
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleComponent_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleComponent__MIDL_ProcFormatString.Format,
+    &IAccessibleComponent_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleComponent_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleComponent__MIDL_ProcFormatString.Format,
+    &IAccessibleComponent_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(6) _IAccessibleComponentProxyVtbl = 
+{
+    &IAccessibleComponent_ProxyInfo,
+    &IID_IAccessibleComponent,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleComponent::get_locationInParent */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleComponent::get_foreground */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleComponent::get_background */
+};
+
+const CInterfaceStubVtbl _IAccessibleComponentStubVtbl =
+{
+    &IID_IAccessibleComponent,
+    &IAccessibleComponent_ServerInfo,
+    6,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleComponent__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    0,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleComponent_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleComponentProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleComponent_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleComponentStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleComponent_InterfaceNamesList[] = 
+{
+    "IAccessibleComponent",
+    0
+};
+
+
+#define _AccessibleComponent_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleComponent, pIID, n)
+
+int __stdcall _AccessibleComponent_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleComponent_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleComponent_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleComponent_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleComponent_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleComponent_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleComponent_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText.h
new file mode 100644
index 0000000..3afeefb
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText.h
@@ -0,0 +1,235 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleEditableText.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleEditableText_h__
+#define __AccessibleEditableText_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleEditableText_FWD_DEFINED__
+#define __IAccessibleEditableText_FWD_DEFINED__
+typedef interface IAccessibleEditableText IAccessibleEditableText;
+#endif 	/* __IAccessibleEditableText_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "IA2CommonTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleEditableText_INTERFACE_DEFINED__
+#define __IAccessibleEditableText_INTERFACE_DEFINED__
+
+/* interface IAccessibleEditableText */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleEditableText;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("A59AA09A-7011-4b65-939D-32B1FB5547E3")
+    IAccessibleEditableText : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE copyText( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE deleteText( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE insertText( 
+            /* [in] */ long offset,
+            /* [in] */ BSTR *text) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE cutText( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE pasteText( 
+            /* [in] */ long offset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE replaceText( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [in] */ BSTR *text) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE setAttributes( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [in] */ BSTR *attributes) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleEditableTextVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleEditableText * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleEditableText * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleEditableText * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *copyText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        HRESULT ( STDMETHODCALLTYPE *deleteText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        HRESULT ( STDMETHODCALLTYPE *insertText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long offset,
+            /* [in] */ BSTR *text);
+        
+        HRESULT ( STDMETHODCALLTYPE *cutText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        HRESULT ( STDMETHODCALLTYPE *pasteText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long offset);
+        
+        HRESULT ( STDMETHODCALLTYPE *replaceText )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [in] */ BSTR *text);
+        
+        HRESULT ( STDMETHODCALLTYPE *setAttributes )( 
+            IAccessibleEditableText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [in] */ BSTR *attributes);
+        
+        END_INTERFACE
+    } IAccessibleEditableTextVtbl;
+
+    interface IAccessibleEditableText
+    {
+        CONST_VTBL struct IAccessibleEditableTextVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleEditableText_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleEditableText_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleEditableText_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleEditableText_copyText(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> copyText(This,startOffset,endOffset) ) 
+
+#define IAccessibleEditableText_deleteText(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> deleteText(This,startOffset,endOffset) ) 
+
+#define IAccessibleEditableText_insertText(This,offset,text)	\
+    ( (This)->lpVtbl -> insertText(This,offset,text) ) 
+
+#define IAccessibleEditableText_cutText(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> cutText(This,startOffset,endOffset) ) 
+
+#define IAccessibleEditableText_pasteText(This,offset)	\
+    ( (This)->lpVtbl -> pasteText(This,offset) ) 
+
+#define IAccessibleEditableText_replaceText(This,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> replaceText(This,startOffset,endOffset,text) ) 
+
+#define IAccessibleEditableText_setAttributes(This,startOffset,endOffset,attributes)	\
+    ( (This)->lpVtbl -> setAttributes(This,startOffset,endOffset,attributes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleEditableText_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText_i.c
new file mode 100644
index 0000000..c578bf5
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleEditableText.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleEditableText,0xA59AA09A,0x7011,0x4b65,0x93,0x9D,0x32,0xB1,0xFB,0x55,0x47,0xE3);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText_p.c
new file mode 100644
index 0000000..28d1e4b
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleEditableText_p.c
@@ -0,0 +1,584 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleEditableText.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleEditableText.h"
+
+#define TYPE_FORMAT_STRING_SIZE   43                                
+#define PROC_FORMAT_STRING_SIZE   301                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleEditableText_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleEditableText_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleEditableText_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleEditableText_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleEditableText_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleEditableText_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleEditableText_MIDL_TYPE_FORMAT_STRING AccessibleEditableText__MIDL_TypeFormatString;
+extern const AccessibleEditableText_MIDL_PROC_FORMAT_STRING AccessibleEditableText__MIDL_ProcFormatString;
+extern const AccessibleEditableText_MIDL_EXPR_FORMAT_STRING AccessibleEditableText__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleEditableText_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleEditableText_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleEditableText_MIDL_PROC_FORMAT_STRING AccessibleEditableText__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure copyText */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 30 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 40 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure deleteText */
+
+/* 42 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 48 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 50 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 52 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 56 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 58 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 66 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 72 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 76 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 82 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure insertText */
+
+/* 84 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 90 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 92 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 94 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 96 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 98 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 100 */	0x8,		/* 8 */
+			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
+/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 104 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 114 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
+/* 116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 118 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure cutText */
+
+/* 126 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 128 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 132 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 134 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 136 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 138 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 140 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 142 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 148 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 152 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 154 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 158 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 160 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 164 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 166 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure pasteText */
+
+/* 168 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 174 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 176 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 178 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 182 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 184 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 186 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 192 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 194 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 196 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 198 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 200 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 202 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure replaceText */
+
+/* 204 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 206 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 212 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 214 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 216 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 218 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 220 */	0x8,		/* 8 */
+			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
+/* 222 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 224 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 228 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 230 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 232 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 234 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 236 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 238 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 240 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
+/* 242 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 244 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 246 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 248 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 250 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure setAttributes */
+
+/* 252 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 254 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 258 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 260 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 262 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 264 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 266 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 268 */	0x8,		/* 8 */
+			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
+/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 272 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 280 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 284 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 286 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter attributes */
+
+/* 288 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
+/* 290 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 292 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 296 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 298 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleEditableText_MIDL_TYPE_FORMAT_STRING AccessibleEditableText__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x0,	/* FC_RP */
+/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
+/*  6 */	
+			0x12, 0x0,	/* FC_UP */
+/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
+/* 10 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 14 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 20 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 22 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 26 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (10) */
+/* 28 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 30 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 32 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0xffde ),	/* Offset= -34 (6) */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleEditableText, ver. 0.0,
+   GUID={0xA59AA09A,0x7011,0x4b65,{0x93,0x9D,0x32,0xB1,0xFB,0x55,0x47,0xE3}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleEditableText_FormatStringOffsetTable[] =
+    {
+    0,
+    42,
+    84,
+    126,
+    168,
+    204,
+    252
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleEditableText_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleEditableText__MIDL_ProcFormatString.Format,
+    &IAccessibleEditableText_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleEditableText_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleEditableText__MIDL_ProcFormatString.Format,
+    &IAccessibleEditableText_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(10) _IAccessibleEditableTextProxyVtbl = 
+{
+    &IAccessibleEditableText_ProxyInfo,
+    &IID_IAccessibleEditableText,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::copyText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::deleteText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::insertText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::cutText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::pasteText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::replaceText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleEditableText::setAttributes */
+};
+
+const CInterfaceStubVtbl _IAccessibleEditableTextStubVtbl =
+{
+    &IID_IAccessibleEditableText,
+    &IAccessibleEditableText_ServerInfo,
+    10,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleEditableText__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleEditableText_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleEditableTextProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleEditableText_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleEditableTextStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleEditableText_InterfaceNamesList[] = 
+{
+    "IAccessibleEditableText",
+    0
+};
+
+
+#define _AccessibleEditableText_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleEditableText, pIID, n)
+
+int __stdcall _AccessibleEditableText_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleEditableText_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleEditableText_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleEditableText_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleEditableText_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleEditableText_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleEditableText_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleEventID.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleEventID.h
new file mode 100644
index 0000000..252375d
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleEventID.h
@@ -0,0 +1,105 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleEventID.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __AccessibleEventID_h__
+#define __AccessibleEventID_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleEventID_0000_0000 */
+/* [local] */ 
+
+
+enum IA2EventID
+    {	IA2_EVENT_ACTION_CHANGED	= 0x101,
+	IA2_EVENT_ACTIVE_DECENDENT_CHANGED	= ( IA2_EVENT_ACTION_CHANGED + 1 ) ,
+	IA2_EVENT_ACTIVE_DESCENDANT_CHANGED	= IA2_EVENT_ACTIVE_DECENDENT_CHANGED,
+	IA2_EVENT_DOCUMENT_ATTRIBUTE_CHANGED	= ( IA2_EVENT_ACTIVE_DESCENDANT_CHANGED + 1 ) ,
+	IA2_EVENT_DOCUMENT_CONTENT_CHANGED	= ( IA2_EVENT_DOCUMENT_ATTRIBUTE_CHANGED + 1 ) ,
+	IA2_EVENT_DOCUMENT_LOAD_COMPLETE	= ( IA2_EVENT_DOCUMENT_CONTENT_CHANGED + 1 ) ,
+	IA2_EVENT_DOCUMENT_LOAD_STOPPED	= ( IA2_EVENT_DOCUMENT_LOAD_COMPLETE + 1 ) ,
+	IA2_EVENT_DOCUMENT_RELOAD	= ( IA2_EVENT_DOCUMENT_LOAD_STOPPED + 1 ) ,
+	IA2_EVENT_HYPERLINK_END_INDEX_CHANGED	= ( IA2_EVENT_DOCUMENT_RELOAD + 1 ) ,
+	IA2_EVENT_HYPERLINK_NUMBER_OF_ANCHORS_CHANGED	= ( IA2_EVENT_HYPERLINK_END_INDEX_CHANGED + 1 ) ,
+	IA2_EVENT_HYPERLINK_SELECTED_LINK_CHANGED	= ( IA2_EVENT_HYPERLINK_NUMBER_OF_ANCHORS_CHANGED + 1 ) ,
+	IA2_EVENT_HYPERTEXT_LINK_ACTIVATED	= ( IA2_EVENT_HYPERLINK_SELECTED_LINK_CHANGED + 1 ) ,
+	IA2_EVENT_HYPERTEXT_LINK_SELECTED	= ( IA2_EVENT_HYPERTEXT_LINK_ACTIVATED + 1 ) ,
+	IA2_EVENT_HYPERLINK_START_INDEX_CHANGED	= ( IA2_EVENT_HYPERTEXT_LINK_SELECTED + 1 ) ,
+	IA2_EVENT_HYPERTEXT_CHANGED	= ( IA2_EVENT_HYPERLINK_START_INDEX_CHANGED + 1 ) ,
+	IA2_EVENT_HYPERTEXT_NLINKS_CHANGED	= ( IA2_EVENT_HYPERTEXT_CHANGED + 1 ) ,
+	IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED	= ( IA2_EVENT_HYPERTEXT_NLINKS_CHANGED + 1 ) ,
+	IA2_EVENT_PAGE_CHANGED	= ( IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED + 1 ) ,
+	IA2_EVENT_SECTION_CHANGED	= ( IA2_EVENT_PAGE_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_CAPTION_CHANGED	= ( IA2_EVENT_SECTION_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_COLUMN_DESCRIPTION_CHANGED	= ( IA2_EVENT_TABLE_CAPTION_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_COLUMN_HEADER_CHANGED	= ( IA2_EVENT_TABLE_COLUMN_DESCRIPTION_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_MODEL_CHANGED	= ( IA2_EVENT_TABLE_COLUMN_HEADER_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_ROW_DESCRIPTION_CHANGED	= ( IA2_EVENT_TABLE_MODEL_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_ROW_HEADER_CHANGED	= ( IA2_EVENT_TABLE_ROW_DESCRIPTION_CHANGED + 1 ) ,
+	IA2_EVENT_TABLE_SUMMARY_CHANGED	= ( IA2_EVENT_TABLE_ROW_HEADER_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_ATTRIBUTE_CHANGED	= ( IA2_EVENT_TABLE_SUMMARY_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_CARET_MOVED	= ( IA2_EVENT_TEXT_ATTRIBUTE_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_CHANGED	= ( IA2_EVENT_TEXT_CARET_MOVED + 1 ) ,
+	IA2_EVENT_TEXT_COLUMN_CHANGED	= ( IA2_EVENT_TEXT_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_INSERTED	= ( IA2_EVENT_TEXT_COLUMN_CHANGED + 1 ) ,
+	IA2_EVENT_TEXT_REMOVED	= ( IA2_EVENT_TEXT_INSERTED + 1 ) ,
+	IA2_EVENT_TEXT_UPDATED	= ( IA2_EVENT_TEXT_REMOVED + 1 ) ,
+	IA2_EVENT_TEXT_SELECTION_CHANGED	= ( IA2_EVENT_TEXT_UPDATED + 1 ) ,
+	IA2_EVENT_VISIBLE_DATA_CHANGED	= ( IA2_EVENT_TEXT_SELECTION_CHANGED + 1 ) 
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleEventID_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleEventID_0000_0000_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink.h
new file mode 100644
index 0000000..858e6bb
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink.h
@@ -0,0 +1,252 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleHyperlink.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleHyperlink_h__
+#define __AccessibleHyperlink_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleHyperlink_FWD_DEFINED__
+#define __IAccessibleHyperlink_FWD_DEFINED__
+typedef interface IAccessibleHyperlink IAccessibleHyperlink;
+#endif 	/* __IAccessibleHyperlink_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "AccessibleAction.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleHyperlink_INTERFACE_DEFINED__
+#define __IAccessibleHyperlink_INTERFACE_DEFINED__
+
+/* interface IAccessibleHyperlink */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleHyperlink;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("01C20F2B-3DD2-400f-949F-AD00BDAB1D41")
+    IAccessibleHyperlink : public IAccessibleAction
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_anchor( 
+            /* [in] */ long index,
+            /* [retval][out] */ VARIANT *anchor) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_anchorTarget( 
+            /* [in] */ long index,
+            /* [retval][out] */ VARIANT *anchorTarget) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_startIndex( 
+            /* [retval][out] */ long *index) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_endIndex( 
+            /* [retval][out] */ long *index) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_valid( 
+            /* [retval][out] */ boolean *valid) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleHyperlinkVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleHyperlink * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleHyperlink * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *nActions )( 
+            IAccessibleHyperlink * This,
+            /* [retval][out] */ long *nActions);
+        
+        HRESULT ( STDMETHODCALLTYPE *doAction )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_description )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_keyBinding )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex,
+            /* [in] */ long nMaxBindings,
+            /* [length_is][length_is][size_is][size_is][out] */ BSTR **keyBindings,
+            /* [retval][out] */ long *nBindings);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *name);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedName )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long actionIndex,
+            /* [retval][out] */ BSTR *localizedName);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_anchor )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long index,
+            /* [retval][out] */ VARIANT *anchor);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_anchorTarget )( 
+            IAccessibleHyperlink * This,
+            /* [in] */ long index,
+            /* [retval][out] */ VARIANT *anchorTarget);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_startIndex )( 
+            IAccessibleHyperlink * This,
+            /* [retval][out] */ long *index);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_endIndex )( 
+            IAccessibleHyperlink * This,
+            /* [retval][out] */ long *index);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_valid )( 
+            IAccessibleHyperlink * This,
+            /* [retval][out] */ boolean *valid);
+        
+        END_INTERFACE
+    } IAccessibleHyperlinkVtbl;
+
+    interface IAccessibleHyperlink
+    {
+        CONST_VTBL struct IAccessibleHyperlinkVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleHyperlink_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleHyperlink_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleHyperlink_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleHyperlink_nActions(This,nActions)	\
+    ( (This)->lpVtbl -> nActions(This,nActions) ) 
+
+#define IAccessibleHyperlink_doAction(This,actionIndex)	\
+    ( (This)->lpVtbl -> doAction(This,actionIndex) ) 
+
+#define IAccessibleHyperlink_get_description(This,actionIndex,description)	\
+    ( (This)->lpVtbl -> get_description(This,actionIndex,description) ) 
+
+#define IAccessibleHyperlink_get_keyBinding(This,actionIndex,nMaxBindings,keyBindings,nBindings)	\
+    ( (This)->lpVtbl -> get_keyBinding(This,actionIndex,nMaxBindings,keyBindings,nBindings) ) 
+
+#define IAccessibleHyperlink_get_name(This,actionIndex,name)	\
+    ( (This)->lpVtbl -> get_name(This,actionIndex,name) ) 
+
+#define IAccessibleHyperlink_get_localizedName(This,actionIndex,localizedName)	\
+    ( (This)->lpVtbl -> get_localizedName(This,actionIndex,localizedName) ) 
+
+
+#define IAccessibleHyperlink_get_anchor(This,index,anchor)	\
+    ( (This)->lpVtbl -> get_anchor(This,index,anchor) ) 
+
+#define IAccessibleHyperlink_get_anchorTarget(This,index,anchorTarget)	\
+    ( (This)->lpVtbl -> get_anchorTarget(This,index,anchorTarget) ) 
+
+#define IAccessibleHyperlink_get_startIndex(This,index)	\
+    ( (This)->lpVtbl -> get_startIndex(This,index) ) 
+
+#define IAccessibleHyperlink_get_endIndex(This,index)	\
+    ( (This)->lpVtbl -> get_endIndex(This,index) ) 
+
+#define IAccessibleHyperlink_get_valid(This,valid)	\
+    ( (This)->lpVtbl -> get_valid(This,valid) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleHyperlink_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
+unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
+unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
+void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink_i.c
new file mode 100644
index 0000000..ef0921f
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleHyperlink.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleHyperlink,0x01C20F2B,0x3DD2,0x400f,0x94,0x9F,0xAD,0x00,0xBD,0xAB,0x1D,0x41);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink_p.c
new file mode 100644
index 0000000..c608123
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleHyperlink_p.c
@@ -0,0 +1,1191 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleHyperlink.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleHyperlink.h"
+
+#define TYPE_FORMAT_STRING_SIZE   1047                              
+#define PROC_FORMAT_STRING_SIZE   193                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleHyperlink_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleHyperlink_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleHyperlink_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleHyperlink_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleHyperlink_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleHyperlink_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleHyperlink_MIDL_TYPE_FORMAT_STRING AccessibleHyperlink__MIDL_TypeFormatString;
+extern const AccessibleHyperlink_MIDL_PROC_FORMAT_STRING AccessibleHyperlink__MIDL_ProcFormatString;
+extern const AccessibleHyperlink_MIDL_EXPR_FORMAT_STRING AccessibleHyperlink__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleHyperlink_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleHyperlink_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleHyperlink_MIDL_PROC_FORMAT_STRING AccessibleHyperlink__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_anchor */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x9 ),	/* 9 */
+/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 16 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter anchor */
+
+/* 30 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	NdrFcShort( 0x404 ),	/* Type Offset=1028 */
+
+	/* Return value */
+
+/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 40 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_anchorTarget */
+
+/* 42 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 48 */	NdrFcShort( 0xa ),	/* 10 */
+/* 50 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 56 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 58 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 60 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 66 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter anchorTarget */
+
+/* 72 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 76 */	NdrFcShort( 0x404 ),	/* Type Offset=1028 */
+
+	/* Return value */
+
+/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 82 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_startIndex */
+
+/* 84 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 90 */	NdrFcShort( 0xb ),	/* 11 */
+/* 92 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 96 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 98 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 100 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 108 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_endIndex */
+
+/* 120 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 122 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 126 */	NdrFcShort( 0xc ),	/* 12 */
+/* 128 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 130 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 132 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 134 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 136 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 144 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 146 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 148 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 150 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 154 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_valid */
+
+/* 156 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 158 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 162 */	NdrFcShort( 0xd ),	/* 13 */
+/* 164 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 166 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 168 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 170 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 172 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter valid */
+
+/* 180 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 182 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 184 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 186 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 188 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 190 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleHyperlink_MIDL_TYPE_FORMAT_STRING AccessibleHyperlink__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x400 ),	/* Offset= 1024 (1028) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0x3e8 ),	/* Offset= 1000 (1008) */
+/* 10 */	
+			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
+			0x9,		/* FC_ULONG */
+/* 12 */	0x7,		/* Corr desc: FC_USHORT */
+			0x0,		/*  */
+/* 14 */	NdrFcShort( 0xfff8 ),	/* -8 */
+/* 16 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 18 */	NdrFcShort( 0x2 ),	/* Offset= 2 (20) */
+/* 20 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 22 */	NdrFcShort( 0x2f ),	/* 47 */
+/* 24 */	NdrFcLong( 0x14 ),	/* 20 */
+/* 28 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
+/* 30 */	NdrFcLong( 0x3 ),	/* 3 */
+/* 34 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 36 */	NdrFcLong( 0x11 ),	/* 17 */
+/* 40 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
+/* 42 */	NdrFcLong( 0x2 ),	/* 2 */
+/* 46 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 48 */	NdrFcLong( 0x4 ),	/* 4 */
+/* 52 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
+/* 54 */	NdrFcLong( 0x5 ),	/* 5 */
+/* 58 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
+/* 60 */	NdrFcLong( 0xb ),	/* 11 */
+/* 64 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 66 */	NdrFcLong( 0xa ),	/* 10 */
+/* 70 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 72 */	NdrFcLong( 0x6 ),	/* 6 */
+/* 76 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (308) */
+/* 78 */	NdrFcLong( 0x7 ),	/* 7 */
+/* 82 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
+/* 84 */	NdrFcLong( 0x8 ),	/* 8 */
+/* 88 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (314) */
+/* 90 */	NdrFcLong( 0xd ),	/* 13 */
+/* 94 */	NdrFcShort( 0xf6 ),	/* Offset= 246 (340) */
+/* 96 */	NdrFcLong( 0x9 ),	/* 9 */
+/* 100 */	NdrFcShort( 0x102 ),	/* Offset= 258 (358) */
+/* 102 */	NdrFcLong( 0x2000 ),	/* 8192 */
+/* 106 */	NdrFcShort( 0x10e ),	/* Offset= 270 (376) */
+/* 108 */	NdrFcLong( 0x24 ),	/* 36 */
+/* 112 */	NdrFcShort( 0x336 ),	/* Offset= 822 (934) */
+/* 114 */	NdrFcLong( 0x4024 ),	/* 16420 */
+/* 118 */	NdrFcShort( 0x330 ),	/* Offset= 816 (934) */
+/* 120 */	NdrFcLong( 0x4011 ),	/* 16401 */
+/* 124 */	NdrFcShort( 0x32e ),	/* Offset= 814 (938) */
+/* 126 */	NdrFcLong( 0x4002 ),	/* 16386 */
+/* 130 */	NdrFcShort( 0x32c ),	/* Offset= 812 (942) */
+/* 132 */	NdrFcLong( 0x4003 ),	/* 16387 */
+/* 136 */	NdrFcShort( 0x32a ),	/* Offset= 810 (946) */
+/* 138 */	NdrFcLong( 0x4014 ),	/* 16404 */
+/* 142 */	NdrFcShort( 0x328 ),	/* Offset= 808 (950) */
+/* 144 */	NdrFcLong( 0x4004 ),	/* 16388 */
+/* 148 */	NdrFcShort( 0x326 ),	/* Offset= 806 (954) */
+/* 150 */	NdrFcLong( 0x4005 ),	/* 16389 */
+/* 154 */	NdrFcShort( 0x324 ),	/* Offset= 804 (958) */
+/* 156 */	NdrFcLong( 0x400b ),	/* 16395 */
+/* 160 */	NdrFcShort( 0x30e ),	/* Offset= 782 (942) */
+/* 162 */	NdrFcLong( 0x400a ),	/* 16394 */
+/* 166 */	NdrFcShort( 0x30c ),	/* Offset= 780 (946) */
+/* 168 */	NdrFcLong( 0x4006 ),	/* 16390 */
+/* 172 */	NdrFcShort( 0x316 ),	/* Offset= 790 (962) */
+/* 174 */	NdrFcLong( 0x4007 ),	/* 16391 */
+/* 178 */	NdrFcShort( 0x30c ),	/* Offset= 780 (958) */
+/* 180 */	NdrFcLong( 0x4008 ),	/* 16392 */
+/* 184 */	NdrFcShort( 0x30e ),	/* Offset= 782 (966) */
+/* 186 */	NdrFcLong( 0x400d ),	/* 16397 */
+/* 190 */	NdrFcShort( 0x30c ),	/* Offset= 780 (970) */
+/* 192 */	NdrFcLong( 0x4009 ),	/* 16393 */
+/* 196 */	NdrFcShort( 0x30a ),	/* Offset= 778 (974) */
+/* 198 */	NdrFcLong( 0x6000 ),	/* 24576 */
+/* 202 */	NdrFcShort( 0x308 ),	/* Offset= 776 (978) */
+/* 204 */	NdrFcLong( 0x400c ),	/* 16396 */
+/* 208 */	NdrFcShort( 0x306 ),	/* Offset= 774 (982) */
+/* 210 */	NdrFcLong( 0x10 ),	/* 16 */
+/* 214 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
+/* 216 */	NdrFcLong( 0x12 ),	/* 18 */
+/* 220 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 222 */	NdrFcLong( 0x13 ),	/* 19 */
+/* 226 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 228 */	NdrFcLong( 0x15 ),	/* 21 */
+/* 232 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
+/* 234 */	NdrFcLong( 0x16 ),	/* 22 */
+/* 238 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 240 */	NdrFcLong( 0x17 ),	/* 23 */
+/* 244 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 246 */	NdrFcLong( 0xe ),	/* 14 */
+/* 250 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (990) */
+/* 252 */	NdrFcLong( 0x400e ),	/* 16398 */
+/* 256 */	NdrFcShort( 0x2e8 ),	/* Offset= 744 (1000) */
+/* 258 */	NdrFcLong( 0x4010 ),	/* 16400 */
+/* 262 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (1004) */
+/* 264 */	NdrFcLong( 0x4012 ),	/* 16402 */
+/* 268 */	NdrFcShort( 0x2a2 ),	/* Offset= 674 (942) */
+/* 270 */	NdrFcLong( 0x4013 ),	/* 16403 */
+/* 274 */	NdrFcShort( 0x2a0 ),	/* Offset= 672 (946) */
+/* 276 */	NdrFcLong( 0x4015 ),	/* 16405 */
+/* 280 */	NdrFcShort( 0x29e ),	/* Offset= 670 (950) */
+/* 282 */	NdrFcLong( 0x4016 ),	/* 16406 */
+/* 286 */	NdrFcShort( 0x294 ),	/* Offset= 660 (946) */
+/* 288 */	NdrFcLong( 0x4017 ),	/* 16407 */
+/* 292 */	NdrFcShort( 0x28e ),	/* Offset= 654 (946) */
+/* 294 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 298 */	NdrFcShort( 0x0 ),	/* Offset= 0 (298) */
+/* 300 */	NdrFcLong( 0x1 ),	/* 1 */
+/* 304 */	NdrFcShort( 0x0 ),	/* Offset= 0 (304) */
+/* 306 */	NdrFcShort( 0xffff ),	/* Offset= -1 (305) */
+/* 308 */	
+			0x15,		/* FC_STRUCT */
+			0x7,		/* 7 */
+/* 310 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 312 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 314 */	
+			0x13, 0x0,	/* FC_OP */
+/* 316 */	NdrFcShort( 0xe ),	/* Offset= 14 (330) */
+/* 318 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 320 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 322 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 324 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 326 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 328 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 330 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 332 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 334 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (318) */
+/* 336 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 338 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 340 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 342 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 348 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 350 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 352 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 354 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 356 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 358 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 360 */	NdrFcLong( 0x20400 ),	/* 132096 */
+/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 366 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 368 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 370 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 372 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 374 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 376 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 378 */	NdrFcShort( 0x2 ),	/* Offset= 2 (380) */
+/* 380 */	
+			0x13, 0x0,	/* FC_OP */
+/* 382 */	NdrFcShort( 0x216 ),	/* Offset= 534 (916) */
+/* 384 */	
+			0x2a,		/* FC_ENCAPSULATED_UNION */
+			0x49,		/* 73 */
+/* 386 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 388 */	NdrFcShort( 0xa ),	/* 10 */
+/* 390 */	NdrFcLong( 0x8 ),	/* 8 */
+/* 394 */	NdrFcShort( 0x5a ),	/* Offset= 90 (484) */
+/* 396 */	NdrFcLong( 0xd ),	/* 13 */
+/* 400 */	NdrFcShort( 0x7e ),	/* Offset= 126 (526) */
+/* 402 */	NdrFcLong( 0x9 ),	/* 9 */
+/* 406 */	NdrFcShort( 0x9e ),	/* Offset= 158 (564) */
+/* 408 */	NdrFcLong( 0xc ),	/* 12 */
+/* 412 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (612) */
+/* 414 */	NdrFcLong( 0x24 ),	/* 36 */
+/* 418 */	NdrFcShort( 0x124 ),	/* Offset= 292 (710) */
+/* 420 */	NdrFcLong( 0x800d ),	/* 32781 */
+/* 424 */	NdrFcShort( 0x140 ),	/* Offset= 320 (744) */
+/* 426 */	NdrFcLong( 0x10 ),	/* 16 */
+/* 430 */	NdrFcShort( 0x15a ),	/* Offset= 346 (776) */
+/* 432 */	NdrFcLong( 0x2 ),	/* 2 */
+/* 436 */	NdrFcShort( 0x174 ),	/* Offset= 372 (808) */
+/* 438 */	NdrFcLong( 0x3 ),	/* 3 */
+/* 442 */	NdrFcShort( 0x18e ),	/* Offset= 398 (840) */
+/* 444 */	NdrFcLong( 0x14 ),	/* 20 */
+/* 448 */	NdrFcShort( 0x1a8 ),	/* Offset= 424 (872) */
+/* 450 */	NdrFcShort( 0xffff ),	/* Offset= -1 (449) */
+/* 452 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 454 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 456 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 460 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 462 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 464 */	
+			0x48,		/* FC_VARIABLE_REPEAT */
+			0x49,		/* FC_FIXED_OFFSET */
+/* 466 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 470 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 476 */	0x13, 0x0,	/* FC_OP */
+/* 478 */	NdrFcShort( 0xff6c ),	/* Offset= -148 (330) */
+/* 480 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 482 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 484 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 486 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 488 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 490 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 492 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 494 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 496 */	0x11, 0x0,	/* FC_RP */
+/* 498 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (452) */
+/* 500 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 502 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 504 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 508 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 512 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 514 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 518 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 520 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 522 */	NdrFcShort( 0xff4a ),	/* Offset= -182 (340) */
+/* 524 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 526 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 528 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 532 */	NdrFcShort( 0x6 ),	/* Offset= 6 (538) */
+/* 534 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 536 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 538 */	
+			0x11, 0x0,	/* FC_RP */
+/* 540 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (504) */
+/* 542 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 546 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 548 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 550 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 552 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 556 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 558 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 560 */	NdrFcShort( 0xff36 ),	/* Offset= -202 (358) */
+/* 562 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 564 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 566 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 568 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 570 */	NdrFcShort( 0x6 ),	/* Offset= 6 (576) */
+/* 572 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 574 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 576 */	
+			0x11, 0x0,	/* FC_RP */
+/* 578 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (542) */
+/* 580 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 582 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 584 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 588 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 590 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 592 */	
+			0x48,		/* FC_VARIABLE_REPEAT */
+			0x49,		/* FC_FIXED_OFFSET */
+/* 594 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 598 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 604 */	0x13, 0x0,	/* FC_OP */
+/* 606 */	NdrFcShort( 0x192 ),	/* Offset= 402 (1008) */
+/* 608 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 610 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 612 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 614 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 616 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 618 */	NdrFcShort( 0x6 ),	/* Offset= 6 (624) */
+/* 620 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 622 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 624 */	
+			0x11, 0x0,	/* FC_RP */
+/* 626 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (580) */
+/* 628 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 630 */	NdrFcLong( 0x2f ),	/* 47 */
+/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 636 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 638 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 640 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 642 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 644 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 646 */	
+			0x1b,		/* FC_CARRAY */
+			0x0,		/* 0 */
+/* 648 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 650 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 652 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 654 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 656 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 658 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 660 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 662 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 664 */	NdrFcShort( 0xa ),	/* Offset= 10 (674) */
+/* 666 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 668 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 670 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (628) */
+/* 672 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 674 */	
+			0x13, 0x0,	/* FC_OP */
+/* 676 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (646) */
+/* 678 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 680 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 682 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 686 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 688 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 690 */	
+			0x48,		/* FC_VARIABLE_REPEAT */
+			0x49,		/* FC_FIXED_OFFSET */
+/* 692 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 696 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 700 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 702 */	0x13, 0x0,	/* FC_OP */
+/* 704 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (658) */
+/* 706 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 708 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 710 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 712 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 716 */	NdrFcShort( 0x6 ),	/* Offset= 6 (722) */
+/* 718 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 720 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 722 */	
+			0x11, 0x0,	/* FC_RP */
+/* 724 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (678) */
+/* 726 */	
+			0x1d,		/* FC_SMFARRAY */
+			0x0,		/* 0 */
+/* 728 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 730 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 732 */	
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 734 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 736 */	0x8,		/* FC_LONG */
+			0x6,		/* FC_SHORT */
+/* 738 */	0x6,		/* FC_SHORT */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 740 */	0x0,		/* 0 */
+			NdrFcShort( 0xfff1 ),	/* Offset= -15 (726) */
+			0x5b,		/* FC_END */
+/* 744 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 746 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 750 */	NdrFcShort( 0xa ),	/* Offset= 10 (760) */
+/* 752 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 754 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 756 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (732) */
+/* 758 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 760 */	
+			0x11, 0x0,	/* FC_RP */
+/* 762 */	NdrFcShort( 0xfefe ),	/* Offset= -258 (504) */
+/* 764 */	
+			0x1b,		/* FC_CARRAY */
+			0x0,		/* 0 */
+/* 766 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 768 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 772 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 774 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 776 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 778 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 780 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 782 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 784 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 786 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 788 */	0x13, 0x0,	/* FC_OP */
+/* 790 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (764) */
+/* 792 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 794 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 796 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 798 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 800 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 802 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 804 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 806 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 808 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 810 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 812 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 814 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 816 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 818 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 820 */	0x13, 0x0,	/* FC_OP */
+/* 822 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (796) */
+/* 824 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 826 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 828 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 830 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 832 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 834 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 836 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 838 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 840 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 842 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 844 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 846 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 848 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 850 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 852 */	0x13, 0x0,	/* FC_OP */
+/* 854 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (828) */
+/* 856 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 858 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 860 */	
+			0x1b,		/* FC_CARRAY */
+			0x7,		/* 7 */
+/* 862 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 864 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 866 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 868 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 870 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 872 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 874 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 876 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 878 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 880 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 882 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 884 */	0x13, 0x0,	/* FC_OP */
+/* 886 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (860) */
+/* 888 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 890 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 892 */	
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 894 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 896 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 898 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 900 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 902 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 904 */	0x7,		/* Corr desc: FC_USHORT */
+			0x0,		/*  */
+/* 906 */	NdrFcShort( 0xffd8 ),	/* -40 */
+/* 908 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 910 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 912 */	NdrFcShort( 0xffec ),	/* Offset= -20 (892) */
+/* 914 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 916 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 918 */	NdrFcShort( 0x28 ),	/* 40 */
+/* 920 */	NdrFcShort( 0xffec ),	/* Offset= -20 (900) */
+/* 922 */	NdrFcShort( 0x0 ),	/* Offset= 0 (922) */
+/* 924 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 926 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 928 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 930 */	NdrFcShort( 0xfdde ),	/* Offset= -546 (384) */
+/* 932 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 934 */	
+			0x13, 0x0,	/* FC_OP */
+/* 936 */	NdrFcShort( 0xfeea ),	/* Offset= -278 (658) */
+/* 938 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 940 */	0x1,		/* FC_BYTE */
+			0x5c,		/* FC_PAD */
+/* 942 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 944 */	0x6,		/* FC_SHORT */
+			0x5c,		/* FC_PAD */
+/* 946 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 948 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 950 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 952 */	0xb,		/* FC_HYPER */
+			0x5c,		/* FC_PAD */
+/* 954 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 956 */	0xa,		/* FC_FLOAT */
+			0x5c,		/* FC_PAD */
+/* 958 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 960 */	0xc,		/* FC_DOUBLE */
+			0x5c,		/* FC_PAD */
+/* 962 */	
+			0x13, 0x0,	/* FC_OP */
+/* 964 */	NdrFcShort( 0xfd70 ),	/* Offset= -656 (308) */
+/* 966 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 968 */	NdrFcShort( 0xfd72 ),	/* Offset= -654 (314) */
+/* 970 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 972 */	NdrFcShort( 0xfd88 ),	/* Offset= -632 (340) */
+/* 974 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 976 */	NdrFcShort( 0xfd96 ),	/* Offset= -618 (358) */
+/* 978 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 980 */	NdrFcShort( 0xfda4 ),	/* Offset= -604 (376) */
+/* 982 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 984 */	NdrFcShort( 0x2 ),	/* Offset= 2 (986) */
+/* 986 */	
+			0x13, 0x0,	/* FC_OP */
+/* 988 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1008) */
+/* 990 */	
+			0x15,		/* FC_STRUCT */
+			0x7,		/* 7 */
+/* 992 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 994 */	0x6,		/* FC_SHORT */
+			0x1,		/* FC_BYTE */
+/* 996 */	0x1,		/* FC_BYTE */
+			0x8,		/* FC_LONG */
+/* 998 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 1000 */	
+			0x13, 0x0,	/* FC_OP */
+/* 1002 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (990) */
+/* 1004 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 1006 */	0x2,		/* FC_CHAR */
+			0x5c,		/* FC_PAD */
+/* 1008 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x7,		/* 7 */
+/* 1010 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1014 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1014) */
+/* 1016 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 1018 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 1020 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 1022 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 1024 */	NdrFcShort( 0xfc0a ),	/* Offset= -1014 (10) */
+/* 1026 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 1028 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 1030 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1032 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 1034 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1036 */	NdrFcShort( 0xfbfa ),	/* Offset= -1030 (6) */
+/* 1038 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 1040 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 1042 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 1044 */	0x3,		/* FC_SMALL */
+			0x5c,		/* FC_PAD */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            VARIANT_UserSize
+            ,VARIANT_UserMarshal
+            ,VARIANT_UserUnmarshal
+            ,VARIANT_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleAction, ver. 0.0,
+   GUID={0xB70D9F59,0x3B5A,0x4dba,{0xAB,0x9E,0x22,0x01,0x2F,0x60,0x7D,0xF5}} */
+
+
+/* Object interface: IAccessibleHyperlink, ver. 0.0,
+   GUID={0x01C20F2B,0x3DD2,0x400f,{0x94,0x9F,0xAD,0x00,0xBD,0xAB,0x1D,0x41}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleHyperlink_FormatStringOffsetTable[] =
+    {
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    0,
+    42,
+    84,
+    120,
+    156
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleHyperlink_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleHyperlink__MIDL_ProcFormatString.Format,
+    &IAccessibleHyperlink_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleHyperlink_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleHyperlink__MIDL_ProcFormatString.Format,
+    &IAccessibleHyperlink_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(14) _IAccessibleHyperlinkProxyVtbl = 
+{
+    &IAccessibleHyperlink_ProxyInfo,
+    &IID_IAccessibleHyperlink,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    0 /* IAccessibleAction::nActions */ ,
+    0 /* IAccessibleAction::doAction */ ,
+    0 /* IAccessibleAction::get_description */ ,
+    0 /* IAccessibleAction::get_keyBinding */ ,
+    0 /* IAccessibleAction::get_name */ ,
+    0 /* IAccessibleAction::get_localizedName */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_anchor */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_anchorTarget */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_startIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_endIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHyperlink::get_valid */
+};
+
+
+static const PRPC_STUB_FUNCTION IAccessibleHyperlink_table[] =
+{
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2
+};
+
+CInterfaceStubVtbl _IAccessibleHyperlinkStubVtbl =
+{
+    &IID_IAccessibleHyperlink,
+    &IAccessibleHyperlink_ServerInfo,
+    14,
+    &IAccessibleHyperlink_table[-3],
+    CStdStubBuffer_DELEGATING_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleHyperlink__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleHyperlink_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleHyperlinkProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleHyperlink_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleHyperlinkStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleHyperlink_InterfaceNamesList[] = 
+{
+    "IAccessibleHyperlink",
+    0
+};
+
+const IID *  const _AccessibleHyperlink_BaseIIDList[] = 
+{
+    &IID_IAccessibleAction,
+    0
+};
+
+
+#define _AccessibleHyperlink_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleHyperlink, pIID, n)
+
+int __stdcall _AccessibleHyperlink_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleHyperlink_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleHyperlink_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleHyperlink_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleHyperlink_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleHyperlink_InterfaceNamesList,
+    (const IID ** ) & _AccessibleHyperlink_BaseIIDList,
+    & _AccessibleHyperlink_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext.h
new file mode 100644
index 0000000..180fb39
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext.h
@@ -0,0 +1,349 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleHypertext.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleHypertext_h__
+#define __AccessibleHypertext_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleHypertext_FWD_DEFINED__
+#define __IAccessibleHypertext_FWD_DEFINED__
+typedef interface IAccessibleHypertext IAccessibleHypertext;
+#endif 	/* __IAccessibleHypertext_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "AccessibleText.h"
+#include "AccessibleHyperlink.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleHypertext_INTERFACE_DEFINED__
+#define __IAccessibleHypertext_INTERFACE_DEFINED__
+
+/* interface IAccessibleHypertext */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleHypertext;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6B4F8BBF-F1F2-418a-B35E-A195BC4103B9")
+    IAccessibleHypertext : public IAccessibleText
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nHyperlinks( 
+            /* [retval][out] */ long *hyperlinkCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_hyperlink( 
+            /* [in] */ long index,
+            /* [retval][out] */ IAccessibleHyperlink **hyperlink) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_hyperlinkIndex( 
+            /* [in] */ long charIndex,
+            /* [retval][out] */ long *hyperlinkIndex) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleHypertextVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleHypertext * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleHypertext * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleHypertext * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *addSelection )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *textAttributes);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_caretOffset )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ long *offset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_characterExtents )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [out] */ long *x,
+            /* [out] */ long *y,
+            /* [out] */ long *width,
+            /* [retval][out] */ long *height);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelections )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ long *nSelections);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_offsetAtPoint )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long x,
+            /* [in] */ long y,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [retval][out] */ long *offset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selection )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long selectionIndex,
+            /* [out] */ long *startOffset,
+            /* [retval][out] */ long *endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textBeforeOffset )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textAfterOffset )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textAtOffset )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        HRESULT ( STDMETHODCALLTYPE *removeSelection )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long selectionIndex);
+        
+        HRESULT ( STDMETHODCALLTYPE *setCaretOffset )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long offset);
+        
+        HRESULT ( STDMETHODCALLTYPE *setSelection )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long selectionIndex,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nCharacters )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ long *nCharacters);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollSubstringTo )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2ScrollType scrollType);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollSubstringToPoint )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_newText )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ IA2TextSegment *newText);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_oldText )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ IA2TextSegment *oldText);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nHyperlinks )( 
+            IAccessibleHypertext * This,
+            /* [retval][out] */ long *hyperlinkCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_hyperlink )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long index,
+            /* [retval][out] */ IAccessibleHyperlink **hyperlink);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_hyperlinkIndex )( 
+            IAccessibleHypertext * This,
+            /* [in] */ long charIndex,
+            /* [retval][out] */ long *hyperlinkIndex);
+        
+        END_INTERFACE
+    } IAccessibleHypertextVtbl;
+
+    interface IAccessibleHypertext
+    {
+        CONST_VTBL struct IAccessibleHypertextVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleHypertext_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleHypertext_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleHypertext_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleHypertext_addSelection(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> addSelection(This,startOffset,endOffset) ) 
+
+#define IAccessibleHypertext_get_attributes(This,offset,startOffset,endOffset,textAttributes)	\
+    ( (This)->lpVtbl -> get_attributes(This,offset,startOffset,endOffset,textAttributes) ) 
+
+#define IAccessibleHypertext_get_caretOffset(This,offset)	\
+    ( (This)->lpVtbl -> get_caretOffset(This,offset) ) 
+
+#define IAccessibleHypertext_get_characterExtents(This,offset,coordType,x,y,width,height)	\
+    ( (This)->lpVtbl -> get_characterExtents(This,offset,coordType,x,y,width,height) ) 
+
+#define IAccessibleHypertext_get_nSelections(This,nSelections)	\
+    ( (This)->lpVtbl -> get_nSelections(This,nSelections) ) 
+
+#define IAccessibleHypertext_get_offsetAtPoint(This,x,y,coordType,offset)	\
+    ( (This)->lpVtbl -> get_offsetAtPoint(This,x,y,coordType,offset) ) 
+
+#define IAccessibleHypertext_get_selection(This,selectionIndex,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> get_selection(This,selectionIndex,startOffset,endOffset) ) 
+
+#define IAccessibleHypertext_get_text(This,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_text(This,startOffset,endOffset,text) ) 
+
+#define IAccessibleHypertext_get_textBeforeOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textBeforeOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleHypertext_get_textAfterOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textAfterOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleHypertext_get_textAtOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textAtOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleHypertext_removeSelection(This,selectionIndex)	\
+    ( (This)->lpVtbl -> removeSelection(This,selectionIndex) ) 
+
+#define IAccessibleHypertext_setCaretOffset(This,offset)	\
+    ( (This)->lpVtbl -> setCaretOffset(This,offset) ) 
+
+#define IAccessibleHypertext_setSelection(This,selectionIndex,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> setSelection(This,selectionIndex,startOffset,endOffset) ) 
+
+#define IAccessibleHypertext_get_nCharacters(This,nCharacters)	\
+    ( (This)->lpVtbl -> get_nCharacters(This,nCharacters) ) 
+
+#define IAccessibleHypertext_scrollSubstringTo(This,startIndex,endIndex,scrollType)	\
+    ( (This)->lpVtbl -> scrollSubstringTo(This,startIndex,endIndex,scrollType) ) 
+
+#define IAccessibleHypertext_scrollSubstringToPoint(This,startIndex,endIndex,coordinateType,x,y)	\
+    ( (This)->lpVtbl -> scrollSubstringToPoint(This,startIndex,endIndex,coordinateType,x,y) ) 
+
+#define IAccessibleHypertext_get_newText(This,newText)	\
+    ( (This)->lpVtbl -> get_newText(This,newText) ) 
+
+#define IAccessibleHypertext_get_oldText(This,oldText)	\
+    ( (This)->lpVtbl -> get_oldText(This,oldText) ) 
+
+
+#define IAccessibleHypertext_get_nHyperlinks(This,hyperlinkCount)	\
+    ( (This)->lpVtbl -> get_nHyperlinks(This,hyperlinkCount) ) 
+
+#define IAccessibleHypertext_get_hyperlink(This,index,hyperlink)	\
+    ( (This)->lpVtbl -> get_hyperlink(This,index,hyperlink) ) 
+
+#define IAccessibleHypertext_get_hyperlinkIndex(This,charIndex,hyperlinkIndex)	\
+    ( (This)->lpVtbl -> get_hyperlinkIndex(This,charIndex,hyperlinkIndex) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleHypertext_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext_i.c
new file mode 100644
index 0000000..e6edec9
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleHypertext.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleHypertext,0x6B4F8BBF,0xF1F2,0x418a,0xB3,0x5E,0xA1,0x95,0xBC,0x41,0x03,0xB9);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext_p.c
new file mode 100644
index 0000000..40eddde
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleHypertext_p.c
@@ -0,0 +1,463 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleHypertext.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleHypertext.h"
+
+#define TYPE_FORMAT_STRING_SIZE   29                                
+#define PROC_FORMAT_STRING_SIZE   121                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   0            
+
+typedef struct _AccessibleHypertext_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleHypertext_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleHypertext_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleHypertext_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleHypertext_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleHypertext_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleHypertext_MIDL_TYPE_FORMAT_STRING AccessibleHypertext__MIDL_TypeFormatString;
+extern const AccessibleHypertext_MIDL_PROC_FORMAT_STRING AccessibleHypertext__MIDL_ProcFormatString;
+extern const AccessibleHypertext_MIDL_EXPR_FORMAT_STRING AccessibleHypertext__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleHypertext_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleHypertext_ProxyInfo;
+
+
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleHypertext_MIDL_PROC_FORMAT_STRING AccessibleHypertext__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_nHyperlinks */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x16 ),	/* 22 */
+/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter hyperlinkCount */
+
+/* 24 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_hyperlink */
+
+/* 36 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 42 */	NdrFcShort( 0x17 ),	/* 23 */
+/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 52 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 60 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 64 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter hyperlink */
+
+/* 66 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 70 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
+
+	/* Return value */
+
+/* 72 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 74 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 76 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_hyperlinkIndex */
+
+/* 78 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 80 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 84 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 86 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 88 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 90 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 92 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 94 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter charIndex */
+
+/* 102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter hyperlinkIndex */
+
+/* 108 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 110 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleHypertext_MIDL_TYPE_FORMAT_STRING AccessibleHypertext__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
+/* 10 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 12 */	NdrFcLong( 0x1c20f2b ),	/* 29495083 */
+/* 16 */	NdrFcShort( 0x3dd2 ),	/* 15826 */
+/* 18 */	NdrFcShort( 0x400f ),	/* 16399 */
+/* 20 */	0x94,		/* 148 */
+			0x9f,		/* 159 */
+/* 22 */	0xad,		/* 173 */
+			0x0,		/* 0 */
+/* 24 */	0xbd,		/* 189 */
+			0xab,		/* 171 */
+/* 26 */	0x1d,		/* 29 */
+			0x41,		/* 65 */
+
+			0x0
+        }
+    };
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleText, ver. 0.0,
+   GUID={0x24FD2FFB,0x3AAD,0x4a08,{0x83,0x35,0xA3,0xAD,0x89,0xC0,0xFB,0x4B}} */
+
+
+/* Object interface: IAccessibleHypertext, ver. 0.0,
+   GUID={0x6B4F8BBF,0xF1F2,0x418a,{0xB3,0x5E,0xA1,0x95,0xBC,0x41,0x03,0xB9}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleHypertext_FormatStringOffsetTable[] =
+    {
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    (unsigned short) -1,
+    0,
+    36,
+    78
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleHypertext_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleHypertext__MIDL_ProcFormatString.Format,
+    &IAccessibleHypertext_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleHypertext_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleHypertext__MIDL_ProcFormatString.Format,
+    &IAccessibleHypertext_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(25) _IAccessibleHypertextProxyVtbl = 
+{
+    &IAccessibleHypertext_ProxyInfo,
+    &IID_IAccessibleHypertext,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    0 /* IAccessibleText::addSelection */ ,
+    0 /* IAccessibleText::get_attributes */ ,
+    0 /* IAccessibleText::get_caretOffset */ ,
+    0 /* IAccessibleText::get_characterExtents */ ,
+    0 /* IAccessibleText::get_nSelections */ ,
+    0 /* IAccessibleText::get_offsetAtPoint */ ,
+    0 /* IAccessibleText::get_selection */ ,
+    0 /* IAccessibleText::get_text */ ,
+    0 /* IAccessibleText::get_textBeforeOffset */ ,
+    0 /* IAccessibleText::get_textAfterOffset */ ,
+    0 /* IAccessibleText::get_textAtOffset */ ,
+    0 /* IAccessibleText::removeSelection */ ,
+    0 /* IAccessibleText::setCaretOffset */ ,
+    0 /* IAccessibleText::setSelection */ ,
+    0 /* IAccessibleText::get_nCharacters */ ,
+    0 /* IAccessibleText::scrollSubstringTo */ ,
+    0 /* IAccessibleText::scrollSubstringToPoint */ ,
+    0 /* IAccessibleText::get_newText */ ,
+    0 /* IAccessibleText::get_oldText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHypertext::get_nHyperlinks */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHypertext::get_hyperlink */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleHypertext::get_hyperlinkIndex */
+};
+
+
+static const PRPC_STUB_FUNCTION IAccessibleHypertext_table[] =
+{
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    STUB_FORWARDING_FUNCTION,
+    NdrStubCall2,
+    NdrStubCall2,
+    NdrStubCall2
+};
+
+CInterfaceStubVtbl _IAccessibleHypertextStubVtbl =
+{
+    &IID_IAccessibleHypertext,
+    &IAccessibleHypertext_ServerInfo,
+    25,
+    &IAccessibleHypertext_table[-3],
+    CStdStubBuffer_DELEGATING_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleHypertext__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    0,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleHypertext_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleHypertextProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleHypertext_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleHypertextStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleHypertext_InterfaceNamesList[] = 
+{
+    "IAccessibleHypertext",
+    0
+};
+
+const IID *  const _AccessibleHypertext_BaseIIDList[] = 
+{
+    &IID_IAccessibleText,
+    0
+};
+
+
+#define _AccessibleHypertext_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleHypertext, pIID, n)
+
+int __stdcall _AccessibleHypertext_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleHypertext_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleHypertext_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleHypertext_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleHypertext_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleHypertext_InterfaceNamesList,
+    (const IID ** ) & _AccessibleHypertext_BaseIIDList,
+    & _AccessibleHypertext_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleImage.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleImage.h
new file mode 100644
index 0000000..d240bb6
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleImage.h
@@ -0,0 +1,185 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleImage.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleImage_h__
+#define __AccessibleImage_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleImage_FWD_DEFINED__
+#define __IAccessibleImage_FWD_DEFINED__
+typedef interface IAccessibleImage IAccessibleImage;
+#endif 	/* __IAccessibleImage_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "IA2CommonTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleImage_INTERFACE_DEFINED__
+#define __IAccessibleImage_INTERFACE_DEFINED__
+
+/* interface IAccessibleImage */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleImage;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("FE5ABB3D-615E-4f7b-909F-5F0EDA9E8DDE")
+    IAccessibleImage : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_description( 
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_imagePosition( 
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [out] */ long *x,
+            /* [retval][out] */ long *y) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_imageSize( 
+            /* [out] */ long *height,
+            /* [retval][out] */ long *width) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleImageVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleImage * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleImage * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleImage * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_description )( 
+            IAccessibleImage * This,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_imagePosition )( 
+            IAccessibleImage * This,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [out] */ long *x,
+            /* [retval][out] */ long *y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageSize )( 
+            IAccessibleImage * This,
+            /* [out] */ long *height,
+            /* [retval][out] */ long *width);
+        
+        END_INTERFACE
+    } IAccessibleImageVtbl;
+
+    interface IAccessibleImage
+    {
+        CONST_VTBL struct IAccessibleImageVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleImage_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleImage_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleImage_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleImage_get_description(This,description)	\
+    ( (This)->lpVtbl -> get_description(This,description) ) 
+
+#define IAccessibleImage_get_imagePosition(This,coordinateType,x,y)	\
+    ( (This)->lpVtbl -> get_imagePosition(This,coordinateType,x,y) ) 
+
+#define IAccessibleImage_get_imageSize(This,height,width)	\
+    ( (This)->lpVtbl -> get_imageSize(This,height,width) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleImage_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleImage_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleImage_i.c
new file mode 100644
index 0000000..37fa869
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleImage_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleImage.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleImage,0xFE5ABB3D,0x615E,0x4f7b,0x90,0x9F,0x5F,0x0E,0xDA,0x9E,0x8D,0xDE);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleImage_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleImage_p.c
new file mode 100644
index 0000000..daa8af2
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleImage_p.c
@@ -0,0 +1,423 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:53 2012
+ */
+/* Compiler settings for AccessibleImage.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleImage.h"
+
+#define TYPE_FORMAT_STRING_SIZE   47                                
+#define PROC_FORMAT_STRING_SIZE   127                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleImage_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleImage_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleImage_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleImage_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleImage_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleImage_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleImage_MIDL_TYPE_FORMAT_STRING AccessibleImage__MIDL_TypeFormatString;
+extern const AccessibleImage_MIDL_PROC_FORMAT_STRING AccessibleImage__MIDL_ProcFormatString;
+extern const AccessibleImage_MIDL_EXPR_FORMAT_STRING AccessibleImage__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleImage_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleImage_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleImage_MIDL_PROC_FORMAT_STRING AccessibleImage__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_description */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter description */
+
+/* 24 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_imagePosition */
+
+/* 36 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 44 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 46 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 48 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 50 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 52 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter coordinateType */
+
+/* 60 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 64 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter x */
+
+/* 66 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 72 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 74 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 76 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 80 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 82 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_imageSize */
+
+/* 84 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 90 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 92 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 96 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 98 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 100 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter height */
+
+/* 108 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter width */
+
+/* 114 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleImage_MIDL_TYPE_FORMAT_STRING AccessibleImage__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
+/* 10 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 14 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 20 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 22 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 26 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (10) */
+/* 28 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 30 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 32 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0xffde ),	/* Offset= -34 (6) */
+/* 42 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 44 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleImage, ver. 0.0,
+   GUID={0xFE5ABB3D,0x615E,0x4f7b,{0x90,0x9F,0x5F,0x0E,0xDA,0x9E,0x8D,0xDE}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleImage_FormatStringOffsetTable[] =
+    {
+    0,
+    36,
+    84
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleImage_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleImage__MIDL_ProcFormatString.Format,
+    &IAccessibleImage_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleImage_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleImage__MIDL_ProcFormatString.Format,
+    &IAccessibleImage_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(6) _IAccessibleImageProxyVtbl = 
+{
+    &IAccessibleImage_ProxyInfo,
+    &IID_IAccessibleImage,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleImage::get_description */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleImage::get_imagePosition */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleImage::get_imageSize */
+};
+
+const CInterfaceStubVtbl _IAccessibleImageStubVtbl =
+{
+    &IID_IAccessibleImage,
+    &IAccessibleImage_ServerInfo,
+    6,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleImage__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleImage_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleImageProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleImage_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleImageStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleImage_InterfaceNamesList[] = 
+{
+    "IAccessibleImage",
+    0
+};
+
+
+#define _AccessibleImage_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleImage, pIID, n)
+
+int __stdcall _AccessibleImage_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleImage_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleImage_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleImage_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleImage_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleImage_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleImage_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation.h
new file mode 100644
index 0000000..b24908a
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation.h
@@ -0,0 +1,244 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:54 2012
+ */
+/* Compiler settings for AccessibleRelation.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleRelation_h__
+#define __AccessibleRelation_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleRelation_FWD_DEFINED__
+#define __IAccessibleRelation_FWD_DEFINED__
+typedef interface IAccessibleRelation IAccessibleRelation;
+#endif 	/* __IAccessibleRelation_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleRelation_0000_0000 */
+/* [local] */ 
+
+#define	IA2_RELATION_CONTROLLED_BY	( L"controlledBy" )
+
+#define	IA2_RELATION_CONTROLLER_FOR	( L"controllerFor" )
+
+#define	IA2_RELATION_DESCRIBED_BY	( L"describedBy" )
+
+#define	IA2_RELATION_DESCRIPTION_FOR	( L"descriptionFor" )
+
+#define	IA2_RELATION_EMBEDDED_BY	( L"embeddedBy" )
+
+#define	IA2_RELATION_EMBEDS	( L"embeds" )
+
+#define	IA2_RELATION_FLOWS_FROM	( L"flowsFrom" )
+
+#define	IA2_RELATION_FLOWS_TO	( L"flowsTo" )
+
+#define	IA2_RELATION_LABEL_FOR	( L"labelFor" )
+
+#define	IA2_RELATION_LABELED_BY	( L"labelledBy" )
+
+#define	IA2_RELATION_LABELLED_BY	( L"labelledBy" )
+
+#define	IA2_RELATION_MEMBER_OF	( L"memberOf" )
+
+#define	IA2_RELATION_NODE_CHILD_OF	( L"nodeChildOf" )
+
+#define	IA2_RELATION_PARENT_WINDOW_OF	( L"parentWindowOf" )
+
+#define	IA2_RELATION_POPUP_FOR	( L"popupFor" )
+
+#define	IA2_RELATION_SUBWINDOW_OF	( L"subwindowOf" )
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleRelation_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleRelation_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAccessibleRelation_INTERFACE_DEFINED__
+#define __IAccessibleRelation_INTERFACE_DEFINED__
+
+/* interface IAccessibleRelation */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleRelation;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7CDF86EE-C3DA-496a-BDA4-281B336E1FDC")
+    IAccessibleRelation : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_relationType( 
+            /* [retval][out] */ BSTR *relationType) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_localizedRelationType( 
+            /* [retval][out] */ BSTR *localizedRelationType) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nTargets( 
+            /* [retval][out] */ long *nTargets) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_target( 
+            /* [in] */ long targetIndex,
+            /* [retval][out] */ IUnknown **target) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_targets( 
+            /* [in] */ long maxTargets,
+            /* [length_is][size_is][out] */ IUnknown **targets,
+            /* [retval][out] */ long *nTargets) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleRelationVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleRelation * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleRelation * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleRelation * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_relationType )( 
+            IAccessibleRelation * This,
+            /* [retval][out] */ BSTR *relationType);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_localizedRelationType )( 
+            IAccessibleRelation * This,
+            /* [retval][out] */ BSTR *localizedRelationType);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nTargets )( 
+            IAccessibleRelation * This,
+            /* [retval][out] */ long *nTargets);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_target )( 
+            IAccessibleRelation * This,
+            /* [in] */ long targetIndex,
+            /* [retval][out] */ IUnknown **target);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_targets )( 
+            IAccessibleRelation * This,
+            /* [in] */ long maxTargets,
+            /* [length_is][size_is][out] */ IUnknown **targets,
+            /* [retval][out] */ long *nTargets);
+        
+        END_INTERFACE
+    } IAccessibleRelationVtbl;
+
+    interface IAccessibleRelation
+    {
+        CONST_VTBL struct IAccessibleRelationVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleRelation_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleRelation_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleRelation_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleRelation_get_relationType(This,relationType)	\
+    ( (This)->lpVtbl -> get_relationType(This,relationType) ) 
+
+#define IAccessibleRelation_get_localizedRelationType(This,localizedRelationType)	\
+    ( (This)->lpVtbl -> get_localizedRelationType(This,localizedRelationType) ) 
+
+#define IAccessibleRelation_get_nTargets(This,nTargets)	\
+    ( (This)->lpVtbl -> get_nTargets(This,nTargets) ) 
+
+#define IAccessibleRelation_get_target(This,targetIndex,target)	\
+    ( (This)->lpVtbl -> get_target(This,targetIndex,target) ) 
+
+#define IAccessibleRelation_get_targets(This,maxTargets,targets,nTargets)	\
+    ( (This)->lpVtbl -> get_targets(This,maxTargets,targets,nTargets) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleRelation_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation_i.c
new file mode 100644
index 0000000..58c8b78
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:54 2012
+ */
+/* Compiler settings for AccessibleRelation.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleRelation,0x7CDF86EE,0xC3DA,0x496a,0xBD,0xA4,0x28,0x1B,0x33,0x6E,0x1F,0xDC);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation_p.c
new file mode 100644
index 0000000..a3a6cbd
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleRelation_p.c
@@ -0,0 +1,527 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:54 2012
+ */
+/* Compiler settings for AccessibleRelation.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleRelation.h"
+
+#define TYPE_FORMAT_STRING_SIZE   95                                
+#define PROC_FORMAT_STRING_SIZE   199                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleRelation_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleRelation_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleRelation_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleRelation_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleRelation_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleRelation_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleRelation_MIDL_TYPE_FORMAT_STRING AccessibleRelation__MIDL_TypeFormatString;
+extern const AccessibleRelation_MIDL_PROC_FORMAT_STRING AccessibleRelation__MIDL_ProcFormatString;
+extern const AccessibleRelation_MIDL_EXPR_FORMAT_STRING AccessibleRelation__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleRelation_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleRelation_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleRelation_MIDL_PROC_FORMAT_STRING AccessibleRelation__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_relationType */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter relationType */
+
+/* 24 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_localizedRelationType */
+
+/* 36 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 44 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 52 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 54 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter localizedRelationType */
+
+/* 60 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 64 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
+
+	/* Return value */
+
+/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nTargets */
+
+/* 72 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 78 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 84 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 86 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 88 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nTargets */
+
+/* 96 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 100 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_target */
+
+/* 108 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 114 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 116 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 118 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 120 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 122 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 124 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 126 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 130 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter targetIndex */
+
+/* 132 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 134 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 136 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter target */
+
+/* 138 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 140 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 142 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */
+
+	/* Return value */
+
+/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 146 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 148 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_targets */
+
+/* 150 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 156 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 158 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 160 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 162 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 164 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 166 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 168 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 170 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 172 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxTargets */
+
+/* 174 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 176 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 178 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter targets */
+
+/* 180 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
+/* 182 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 184 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */
+
+	/* Parameter nTargets */
+
+/* 186 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 188 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 190 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 194 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 196 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleRelation_MIDL_TYPE_FORMAT_STRING AccessibleRelation__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x1c ),	/* Offset= 28 (32) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0xe ),	/* Offset= 14 (22) */
+/* 10 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 14 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 20 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 22 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 26 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (10) */
+/* 28 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 30 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 32 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0xffde ),	/* Offset= -34 (6) */
+/* 42 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 44 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 46 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
+/* 50 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 62 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 64 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 66 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 68 */	
+			0x11, 0x0,	/* FC_RP */
+/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
+/* 72 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 74 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 76 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 78 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 80 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 82 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 84 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 86 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 88 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 90 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (50) */
+/* 92 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Standard interface: __MIDL_itf_AccessibleRelation_0000_0000, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleRelation, ver. 0.0,
+   GUID={0x7CDF86EE,0xC3DA,0x496a,{0xBD,0xA4,0x28,0x1B,0x33,0x6E,0x1F,0xDC}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleRelation_FormatStringOffsetTable[] =
+    {
+    0,
+    36,
+    72,
+    108,
+    150
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleRelation_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleRelation__MIDL_ProcFormatString.Format,
+    &IAccessibleRelation_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleRelation_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleRelation__MIDL_ProcFormatString.Format,
+    &IAccessibleRelation_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(8) _IAccessibleRelationProxyVtbl = 
+{
+    &IAccessibleRelation_ProxyInfo,
+    &IID_IAccessibleRelation,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_relationType */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_localizedRelationType */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_nTargets */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_target */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleRelation::get_targets */
+};
+
+const CInterfaceStubVtbl _IAccessibleRelationStubVtbl =
+{
+    &IID_IAccessibleRelation,
+    &IAccessibleRelation_ServerInfo,
+    8,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleRelation__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleRelation_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleRelationProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleRelation_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleRelationStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleRelation_InterfaceNamesList[] = 
+{
+    "IAccessibleRelation",
+    0
+};
+
+
+#define _AccessibleRelation_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleRelation, pIID, n)
+
+int __stdcall _AccessibleRelation_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleRelation_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleRelation_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleRelation_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleRelation_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleRelation_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleRelation_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleRole.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleRole.h
new file mode 100644
index 0000000..221d1d0
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleRole.h
@@ -0,0 +1,118 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:54 2012
+ */
+/* Compiler settings for AccessibleRole.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __AccessibleRole_h__
+#define __AccessibleRole_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+/* header files for imported files */
+#include "objidl.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleRole_0000_0000 */
+/* [local] */ 
+
+
+enum IA2Role
+    {	IA2_ROLE_UNKNOWN	= 0,
+	IA2_ROLE_CANVAS	= 0x401,
+	IA2_ROLE_CAPTION	= ( IA2_ROLE_CANVAS + 1 ) ,
+	IA2_ROLE_CHECK_MENU_ITEM	= ( IA2_ROLE_CAPTION + 1 ) ,
+	IA2_ROLE_COLOR_CHOOSER	= ( IA2_ROLE_CHECK_MENU_ITEM + 1 ) ,
+	IA2_ROLE_DATE_EDITOR	= ( IA2_ROLE_COLOR_CHOOSER + 1 ) ,
+	IA2_ROLE_DESKTOP_ICON	= ( IA2_ROLE_DATE_EDITOR + 1 ) ,
+	IA2_ROLE_DESKTOP_PANE	= ( IA2_ROLE_DESKTOP_ICON + 1 ) ,
+	IA2_ROLE_DIRECTORY_PANE	= ( IA2_ROLE_DESKTOP_PANE + 1 ) ,
+	IA2_ROLE_EDITBAR	= ( IA2_ROLE_DIRECTORY_PANE + 1 ) ,
+	IA2_ROLE_EMBEDDED_OBJECT	= ( IA2_ROLE_EDITBAR + 1 ) ,
+	IA2_ROLE_ENDNOTE	= ( IA2_ROLE_EMBEDDED_OBJECT + 1 ) ,
+	IA2_ROLE_FILE_CHOOSER	= ( IA2_ROLE_ENDNOTE + 1 ) ,
+	IA2_ROLE_FONT_CHOOSER	= ( IA2_ROLE_FILE_CHOOSER + 1 ) ,
+	IA2_ROLE_FOOTER	= ( IA2_ROLE_FONT_CHOOSER + 1 ) ,
+	IA2_ROLE_FOOTNOTE	= ( IA2_ROLE_FOOTER + 1 ) ,
+	IA2_ROLE_FORM	= ( IA2_ROLE_FOOTNOTE + 1 ) ,
+	IA2_ROLE_FRAME	= ( IA2_ROLE_FORM + 1 ) ,
+	IA2_ROLE_GLASS_PANE	= ( IA2_ROLE_FRAME + 1 ) ,
+	IA2_ROLE_HEADER	= ( IA2_ROLE_GLASS_PANE + 1 ) ,
+	IA2_ROLE_HEADING	= ( IA2_ROLE_HEADER + 1 ) ,
+	IA2_ROLE_ICON	= ( IA2_ROLE_HEADING + 1 ) ,
+	IA2_ROLE_IMAGE_MAP	= ( IA2_ROLE_ICON + 1 ) ,
+	IA2_ROLE_INPUT_METHOD_WINDOW	= ( IA2_ROLE_IMAGE_MAP + 1 ) ,
+	IA2_ROLE_INTERNAL_FRAME	= ( IA2_ROLE_INPUT_METHOD_WINDOW + 1 ) ,
+	IA2_ROLE_LABEL	= ( IA2_ROLE_INTERNAL_FRAME + 1 ) ,
+	IA2_ROLE_LAYERED_PANE	= ( IA2_ROLE_LABEL + 1 ) ,
+	IA2_ROLE_NOTE	= ( IA2_ROLE_LAYERED_PANE + 1 ) ,
+	IA2_ROLE_OPTION_PANE	= ( IA2_ROLE_NOTE + 1 ) ,
+	IA2_ROLE_PAGE	= ( IA2_ROLE_OPTION_PANE + 1 ) ,
+	IA2_ROLE_PARAGRAPH	= ( IA2_ROLE_PAGE + 1 ) ,
+	IA2_ROLE_RADIO_MENU_ITEM	= ( IA2_ROLE_PARAGRAPH + 1 ) ,
+	IA2_ROLE_REDUNDANT_OBJECT	= ( IA2_ROLE_RADIO_MENU_ITEM + 1 ) ,
+	IA2_ROLE_ROOT_PANE	= ( IA2_ROLE_REDUNDANT_OBJECT + 1 ) ,
+	IA2_ROLE_RULER	= ( IA2_ROLE_ROOT_PANE + 1 ) ,
+	IA2_ROLE_SCROLL_PANE	= ( IA2_ROLE_RULER + 1 ) ,
+	IA2_ROLE_SECTION	= ( IA2_ROLE_SCROLL_PANE + 1 ) ,
+	IA2_ROLE_SHAPE	= ( IA2_ROLE_SECTION + 1 ) ,
+	IA2_ROLE_SPLIT_PANE	= ( IA2_ROLE_SHAPE + 1 ) ,
+	IA2_ROLE_TEAR_OFF_MENU	= ( IA2_ROLE_SPLIT_PANE + 1 ) ,
+	IA2_ROLE_TERMINAL	= ( IA2_ROLE_TEAR_OFF_MENU + 1 ) ,
+	IA2_ROLE_TEXT_FRAME	= ( IA2_ROLE_TERMINAL + 1 ) ,
+	IA2_ROLE_TOGGLE_BUTTON	= ( IA2_ROLE_TEXT_FRAME + 1 ) ,
+	IA2_ROLE_VIEW_PORT	= ( IA2_ROLE_TOGGLE_BUTTON + 1 ) ,
+	IA2_ROLE_COMPLEMENTARY_CONTENT	= ( IA2_ROLE_VIEW_PORT + 1 ) 
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleRole_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleRole_0000_0000_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleStates.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleStates.h
new file mode 100644
index 0000000..058d2e5
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleStates.h
@@ -0,0 +1,95 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:54 2012
+ */
+/* Compiler settings for AccessibleStates.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __AccessibleStates_h__
+#define __AccessibleStates_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+/* header files for imported files */
+#include "objidl.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleStates_0000_0000 */
+/* [local] */ 
+
+typedef long AccessibleStates;
+
+
+enum IA2States
+    {	IA2_STATE_ACTIVE	= 0x1,
+	IA2_STATE_ARMED	= 0x2,
+	IA2_STATE_DEFUNCT	= 0x4,
+	IA2_STATE_EDITABLE	= 0x8,
+	IA2_STATE_HORIZONTAL	= 0x10,
+	IA2_STATE_ICONIFIED	= 0x20,
+	IA2_STATE_INVALID_ENTRY	= 0x40,
+	IA2_STATE_MANAGES_DESCENDANTS	= 0x80,
+	IA2_STATE_MODAL	= 0x100,
+	IA2_STATE_MULTI_LINE	= 0x200,
+	IA2_STATE_OPAQUE	= 0x400,
+	IA2_STATE_REQUIRED	= 0x800,
+	IA2_STATE_SELECTABLE_TEXT	= 0x1000,
+	IA2_STATE_SINGLE_LINE	= 0x2000,
+	IA2_STATE_STALE	= 0x4000,
+	IA2_STATE_SUPPORTS_AUTOCOMPLETION	= 0x8000,
+	IA2_STATE_TRANSIENT	= 0x10000,
+	IA2_STATE_VERTICAL	= 0x20000,
+	IA2_STATE_CHECKABLE	= 0x40000,
+	IA2_STATE_PINNED	= 0x80000
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleStates_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleStates_0000_0000_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTable.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable.h
new file mode 100644
index 0000000..0f7dd49
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable.h
@@ -0,0 +1,497 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:54 2012
+ */
+/* Compiler settings for AccessibleTable.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleTable_h__
+#define __AccessibleTable_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleTable_FWD_DEFINED__
+#define __IAccessibleTable_FWD_DEFINED__
+typedef interface IAccessibleTable IAccessibleTable;
+#endif 	/* __IAccessibleTable_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "Accessible2.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleTable_INTERFACE_DEFINED__
+#define __IAccessibleTable_INTERFACE_DEFINED__
+
+/* interface IAccessibleTable */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleTable;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("35AD8070-C20C-4fb4-B094-F4F7275DD469")
+    IAccessibleTable : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_accessibleAt( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_caption( 
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_childIndex( 
+            /* [in] */ long rowIndex,
+            /* [in] */ long columnIndex,
+            /* [retval][out] */ long *cellIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnDescription( 
+            /* [in] */ long column,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnExtentAt( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ long *nColumnsSpanned) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnHeader( 
+            /* [out] */ IAccessibleTable **accessibleTable,
+            /* [retval][out] */ long *startingRowIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnIndex( 
+            /* [in] */ long cellIndex,
+            /* [retval][out] */ long *columnIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nColumns( 
+            /* [retval][out] */ long *columnCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nRows( 
+            /* [retval][out] */ long *rowCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedChildren( 
+            /* [retval][out] */ long *cellCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedColumns( 
+            /* [retval][out] */ long *columnCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedRows( 
+            /* [retval][out] */ long *rowCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowDescription( 
+            /* [in] */ long row,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowExtentAt( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ long *nRowsSpanned) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowHeader( 
+            /* [out] */ IAccessibleTable **accessibleTable,
+            /* [retval][out] */ long *startingColumnIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowIndex( 
+            /* [in] */ long cellIndex,
+            /* [retval][out] */ long *rowIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedChildren( 
+            /* [in] */ long maxChildren,
+            /* [length_is][length_is][size_is][size_is][out] */ long **children,
+            /* [retval][out] */ long *nChildren) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedColumns( 
+            /* [in] */ long maxColumns,
+            /* [length_is][length_is][size_is][size_is][out] */ long **columns,
+            /* [retval][out] */ long *nColumns) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedRows( 
+            /* [in] */ long maxRows,
+            /* [length_is][length_is][size_is][size_is][out] */ long **rows,
+            /* [retval][out] */ long *nRows) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_summary( 
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isColumnSelected( 
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isRowSelected( 
+            /* [in] */ long row,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isSelected( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE selectRow( 
+            /* [in] */ long row) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE selectColumn( 
+            /* [in] */ long column) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE unselectRow( 
+            /* [in] */ long row) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE unselectColumn( 
+            /* [in] */ long column) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowColumnExtentsAtIndex( 
+            /* [in] */ long index,
+            /* [out] */ long *row,
+            /* [out] */ long *column,
+            /* [out] */ long *rowExtents,
+            /* [out] */ long *columnExtents,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_modelChange( 
+            /* [retval][out] */ IA2TableModelChange *modelChange) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleTableVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleTable * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleTable * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleTable * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_accessibleAt )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_caption )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_childIndex )( 
+            IAccessibleTable * This,
+            /* [in] */ long rowIndex,
+            /* [in] */ long columnIndex,
+            /* [retval][out] */ long *cellIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnDescription )( 
+            IAccessibleTable * This,
+            /* [in] */ long column,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnExtentAt )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ long *nColumnsSpanned);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnHeader )( 
+            IAccessibleTable * This,
+            /* [out] */ IAccessibleTable **accessibleTable,
+            /* [retval][out] */ long *startingRowIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnIndex )( 
+            IAccessibleTable * This,
+            /* [in] */ long cellIndex,
+            /* [retval][out] */ long *columnIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nColumns )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *columnCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nRows )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *rowCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedChildren )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *cellCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedColumns )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *columnCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedRows )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ long *rowCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowDescription )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowExtentAt )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ long *nRowsSpanned);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowHeader )( 
+            IAccessibleTable * This,
+            /* [out] */ IAccessibleTable **accessibleTable,
+            /* [retval][out] */ long *startingColumnIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowIndex )( 
+            IAccessibleTable * This,
+            /* [in] */ long cellIndex,
+            /* [retval][out] */ long *rowIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedChildren )( 
+            IAccessibleTable * This,
+            /* [in] */ long maxChildren,
+            /* [length_is][length_is][size_is][size_is][out] */ long **children,
+            /* [retval][out] */ long *nChildren);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedColumns )( 
+            IAccessibleTable * This,
+            /* [in] */ long maxColumns,
+            /* [length_is][length_is][size_is][size_is][out] */ long **columns,
+            /* [retval][out] */ long *nColumns);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedRows )( 
+            IAccessibleTable * This,
+            /* [in] */ long maxRows,
+            /* [length_is][length_is][size_is][size_is][out] */ long **rows,
+            /* [retval][out] */ long *nRows);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_summary )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isColumnSelected )( 
+            IAccessibleTable * This,
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isRowSelected )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isSelected )( 
+            IAccessibleTable * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected);
+        
+        HRESULT ( STDMETHODCALLTYPE *selectRow )( 
+            IAccessibleTable * This,
+            /* [in] */ long row);
+        
+        HRESULT ( STDMETHODCALLTYPE *selectColumn )( 
+            IAccessibleTable * This,
+            /* [in] */ long column);
+        
+        HRESULT ( STDMETHODCALLTYPE *unselectRow )( 
+            IAccessibleTable * This,
+            /* [in] */ long row);
+        
+        HRESULT ( STDMETHODCALLTYPE *unselectColumn )( 
+            IAccessibleTable * This,
+            /* [in] */ long column);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowColumnExtentsAtIndex )( 
+            IAccessibleTable * This,
+            /* [in] */ long index,
+            /* [out] */ long *row,
+            /* [out] */ long *column,
+            /* [out] */ long *rowExtents,
+            /* [out] */ long *columnExtents,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_modelChange )( 
+            IAccessibleTable * This,
+            /* [retval][out] */ IA2TableModelChange *modelChange);
+        
+        END_INTERFACE
+    } IAccessibleTableVtbl;
+
+    interface IAccessibleTable
+    {
+        CONST_VTBL struct IAccessibleTableVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleTable_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleTable_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleTable_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleTable_get_accessibleAt(This,row,column,accessible)	\
+    ( (This)->lpVtbl -> get_accessibleAt(This,row,column,accessible) ) 
+
+#define IAccessibleTable_get_caption(This,accessible)	\
+    ( (This)->lpVtbl -> get_caption(This,accessible) ) 
+
+#define IAccessibleTable_get_childIndex(This,rowIndex,columnIndex,cellIndex)	\
+    ( (This)->lpVtbl -> get_childIndex(This,rowIndex,columnIndex,cellIndex) ) 
+
+#define IAccessibleTable_get_columnDescription(This,column,description)	\
+    ( (This)->lpVtbl -> get_columnDescription(This,column,description) ) 
+
+#define IAccessibleTable_get_columnExtentAt(This,row,column,nColumnsSpanned)	\
+    ( (This)->lpVtbl -> get_columnExtentAt(This,row,column,nColumnsSpanned) ) 
+
+#define IAccessibleTable_get_columnHeader(This,accessibleTable,startingRowIndex)	\
+    ( (This)->lpVtbl -> get_columnHeader(This,accessibleTable,startingRowIndex) ) 
+
+#define IAccessibleTable_get_columnIndex(This,cellIndex,columnIndex)	\
+    ( (This)->lpVtbl -> get_columnIndex(This,cellIndex,columnIndex) ) 
+
+#define IAccessibleTable_get_nColumns(This,columnCount)	\
+    ( (This)->lpVtbl -> get_nColumns(This,columnCount) ) 
+
+#define IAccessibleTable_get_nRows(This,rowCount)	\
+    ( (This)->lpVtbl -> get_nRows(This,rowCount) ) 
+
+#define IAccessibleTable_get_nSelectedChildren(This,cellCount)	\
+    ( (This)->lpVtbl -> get_nSelectedChildren(This,cellCount) ) 
+
+#define IAccessibleTable_get_nSelectedColumns(This,columnCount)	\
+    ( (This)->lpVtbl -> get_nSelectedColumns(This,columnCount) ) 
+
+#define IAccessibleTable_get_nSelectedRows(This,rowCount)	\
+    ( (This)->lpVtbl -> get_nSelectedRows(This,rowCount) ) 
+
+#define IAccessibleTable_get_rowDescription(This,row,description)	\
+    ( (This)->lpVtbl -> get_rowDescription(This,row,description) ) 
+
+#define IAccessibleTable_get_rowExtentAt(This,row,column,nRowsSpanned)	\
+    ( (This)->lpVtbl -> get_rowExtentAt(This,row,column,nRowsSpanned) ) 
+
+#define IAccessibleTable_get_rowHeader(This,accessibleTable,startingColumnIndex)	\
+    ( (This)->lpVtbl -> get_rowHeader(This,accessibleTable,startingColumnIndex) ) 
+
+#define IAccessibleTable_get_rowIndex(This,cellIndex,rowIndex)	\
+    ( (This)->lpVtbl -> get_rowIndex(This,cellIndex,rowIndex) ) 
+
+#define IAccessibleTable_get_selectedChildren(This,maxChildren,children,nChildren)	\
+    ( (This)->lpVtbl -> get_selectedChildren(This,maxChildren,children,nChildren) ) 
+
+#define IAccessibleTable_get_selectedColumns(This,maxColumns,columns,nColumns)	\
+    ( (This)->lpVtbl -> get_selectedColumns(This,maxColumns,columns,nColumns) ) 
+
+#define IAccessibleTable_get_selectedRows(This,maxRows,rows,nRows)	\
+    ( (This)->lpVtbl -> get_selectedRows(This,maxRows,rows,nRows) ) 
+
+#define IAccessibleTable_get_summary(This,accessible)	\
+    ( (This)->lpVtbl -> get_summary(This,accessible) ) 
+
+#define IAccessibleTable_get_isColumnSelected(This,column,isSelected)	\
+    ( (This)->lpVtbl -> get_isColumnSelected(This,column,isSelected) ) 
+
+#define IAccessibleTable_get_isRowSelected(This,row,isSelected)	\
+    ( (This)->lpVtbl -> get_isRowSelected(This,row,isSelected) ) 
+
+#define IAccessibleTable_get_isSelected(This,row,column,isSelected)	\
+    ( (This)->lpVtbl -> get_isSelected(This,row,column,isSelected) ) 
+
+#define IAccessibleTable_selectRow(This,row)	\
+    ( (This)->lpVtbl -> selectRow(This,row) ) 
+
+#define IAccessibleTable_selectColumn(This,column)	\
+    ( (This)->lpVtbl -> selectColumn(This,column) ) 
+
+#define IAccessibleTable_unselectRow(This,row)	\
+    ( (This)->lpVtbl -> unselectRow(This,row) ) 
+
+#define IAccessibleTable_unselectColumn(This,column)	\
+    ( (This)->lpVtbl -> unselectColumn(This,column) ) 
+
+#define IAccessibleTable_get_rowColumnExtentsAtIndex(This,index,row,column,rowExtents,columnExtents,isSelected)	\
+    ( (This)->lpVtbl -> get_rowColumnExtentsAtIndex(This,index,row,column,rowExtents,columnExtents,isSelected) ) 
+
+#define IAccessibleTable_get_modelChange(This,modelChange)	\
+    ( (This)->lpVtbl -> get_modelChange(This,modelChange) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleTable_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2.h
new file mode 100644
index 0000000..d511869
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2.h
@@ -0,0 +1,367 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleTable2.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleTable2_h__
+#define __AccessibleTable2_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleTable2_FWD_DEFINED__
+#define __IAccessibleTable2_FWD_DEFINED__
+typedef interface IAccessibleTable2 IAccessibleTable2;
+#endif 	/* __IAccessibleTable2_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "Accessible2.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleTable2_INTERFACE_DEFINED__
+#define __IAccessibleTable2_INTERFACE_DEFINED__
+
+/* interface IAccessibleTable2 */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleTable2;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6167f295-06f0-4cdd-a1fa-02e25153d869")
+    IAccessibleTable2 : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_cellAt( 
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ IUnknown **cell) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_caption( 
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnDescription( 
+            /* [in] */ long column,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nColumns( 
+            /* [retval][out] */ long *columnCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nRows( 
+            /* [retval][out] */ long *rowCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedCells( 
+            /* [retval][out] */ long *cellCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedColumns( 
+            /* [retval][out] */ long *columnCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelectedRows( 
+            /* [retval][out] */ long *rowCount) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowDescription( 
+            /* [in] */ long row,
+            /* [retval][out] */ BSTR *description) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedCells( 
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cells,
+            /* [retval][out] */ long *nSelectedCells) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedColumns( 
+            /* [size_is][size_is][out] */ long **selectedColumns,
+            /* [retval][out] */ long *nColumns) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selectedRows( 
+            /* [size_is][size_is][out] */ long **selectedRows,
+            /* [retval][out] */ long *nRows) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_summary( 
+            /* [retval][out] */ IUnknown **accessible) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isColumnSelected( 
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isRowSelected( 
+            /* [in] */ long row,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE selectRow( 
+            /* [in] */ long row) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE selectColumn( 
+            /* [in] */ long column) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE unselectRow( 
+            /* [in] */ long row) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE unselectColumn( 
+            /* [in] */ long column) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_modelChange( 
+            /* [retval][out] */ IA2TableModelChange *modelChange) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleTable2Vtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleTable2 * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleTable2 * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleTable2 * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_cellAt )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row,
+            /* [in] */ long column,
+            /* [retval][out] */ IUnknown **cell);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_caption )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnDescription )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long column,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nColumns )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *columnCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nRows )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *rowCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedCells )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *cellCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedColumns )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *columnCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelectedRows )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ long *rowCount);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowDescription )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row,
+            /* [retval][out] */ BSTR *description);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedCells )( 
+            IAccessibleTable2 * This,
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cells,
+            /* [retval][out] */ long *nSelectedCells);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedColumns )( 
+            IAccessibleTable2 * This,
+            /* [size_is][size_is][out] */ long **selectedColumns,
+            /* [retval][out] */ long *nColumns);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selectedRows )( 
+            IAccessibleTable2 * This,
+            /* [size_is][size_is][out] */ long **selectedRows,
+            /* [retval][out] */ long *nRows);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_summary )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ IUnknown **accessible);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isColumnSelected )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long column,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isRowSelected )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row,
+            /* [retval][out] */ boolean *isSelected);
+        
+        HRESULT ( STDMETHODCALLTYPE *selectRow )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row);
+        
+        HRESULT ( STDMETHODCALLTYPE *selectColumn )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long column);
+        
+        HRESULT ( STDMETHODCALLTYPE *unselectRow )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long row);
+        
+        HRESULT ( STDMETHODCALLTYPE *unselectColumn )( 
+            IAccessibleTable2 * This,
+            /* [in] */ long column);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_modelChange )( 
+            IAccessibleTable2 * This,
+            /* [retval][out] */ IA2TableModelChange *modelChange);
+        
+        END_INTERFACE
+    } IAccessibleTable2Vtbl;
+
+    interface IAccessibleTable2
+    {
+        CONST_VTBL struct IAccessibleTable2Vtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleTable2_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleTable2_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleTable2_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleTable2_get_cellAt(This,row,column,cell)	\
+    ( (This)->lpVtbl -> get_cellAt(This,row,column,cell) ) 
+
+#define IAccessibleTable2_get_caption(This,accessible)	\
+    ( (This)->lpVtbl -> get_caption(This,accessible) ) 
+
+#define IAccessibleTable2_get_columnDescription(This,column,description)	\
+    ( (This)->lpVtbl -> get_columnDescription(This,column,description) ) 
+
+#define IAccessibleTable2_get_nColumns(This,columnCount)	\
+    ( (This)->lpVtbl -> get_nColumns(This,columnCount) ) 
+
+#define IAccessibleTable2_get_nRows(This,rowCount)	\
+    ( (This)->lpVtbl -> get_nRows(This,rowCount) ) 
+
+#define IAccessibleTable2_get_nSelectedCells(This,cellCount)	\
+    ( (This)->lpVtbl -> get_nSelectedCells(This,cellCount) ) 
+
+#define IAccessibleTable2_get_nSelectedColumns(This,columnCount)	\
+    ( (This)->lpVtbl -> get_nSelectedColumns(This,columnCount) ) 
+
+#define IAccessibleTable2_get_nSelectedRows(This,rowCount)	\
+    ( (This)->lpVtbl -> get_nSelectedRows(This,rowCount) ) 
+
+#define IAccessibleTable2_get_rowDescription(This,row,description)	\
+    ( (This)->lpVtbl -> get_rowDescription(This,row,description) ) 
+
+#define IAccessibleTable2_get_selectedCells(This,cells,nSelectedCells)	\
+    ( (This)->lpVtbl -> get_selectedCells(This,cells,nSelectedCells) ) 
+
+#define IAccessibleTable2_get_selectedColumns(This,selectedColumns,nColumns)	\
+    ( (This)->lpVtbl -> get_selectedColumns(This,selectedColumns,nColumns) ) 
+
+#define IAccessibleTable2_get_selectedRows(This,selectedRows,nRows)	\
+    ( (This)->lpVtbl -> get_selectedRows(This,selectedRows,nRows) ) 
+
+#define IAccessibleTable2_get_summary(This,accessible)	\
+    ( (This)->lpVtbl -> get_summary(This,accessible) ) 
+
+#define IAccessibleTable2_get_isColumnSelected(This,column,isSelected)	\
+    ( (This)->lpVtbl -> get_isColumnSelected(This,column,isSelected) ) 
+
+#define IAccessibleTable2_get_isRowSelected(This,row,isSelected)	\
+    ( (This)->lpVtbl -> get_isRowSelected(This,row,isSelected) ) 
+
+#define IAccessibleTable2_selectRow(This,row)	\
+    ( (This)->lpVtbl -> selectRow(This,row) ) 
+
+#define IAccessibleTable2_selectColumn(This,column)	\
+    ( (This)->lpVtbl -> selectColumn(This,column) ) 
+
+#define IAccessibleTable2_unselectRow(This,row)	\
+    ( (This)->lpVtbl -> unselectRow(This,row) ) 
+
+#define IAccessibleTable2_unselectColumn(This,column)	\
+    ( (This)->lpVtbl -> unselectColumn(This,column) ) 
+
+#define IAccessibleTable2_get_modelChange(This,modelChange)	\
+    ( (This)->lpVtbl -> get_modelChange(This,modelChange) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleTable2_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2_i.c
new file mode 100644
index 0000000..f544415
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleTable2.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleTable2,0x6167f295,0x06f0,0x4cdd,0xa1,0xfa,0x02,0xe2,0x51,0x53,0xd8,0x69);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2_p.c
new file mode 100644
index 0000000..f4b782f
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable2_p.c
@@ -0,0 +1,1091 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleTable2.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleTable2.h"
+
+#define TYPE_FORMAT_STRING_SIZE   141                               
+#define PROC_FORMAT_STRING_SIZE   775                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleTable2_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleTable2_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleTable2_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleTable2_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleTable2_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleTable2_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleTable2_MIDL_TYPE_FORMAT_STRING AccessibleTable2__MIDL_TypeFormatString;
+extern const AccessibleTable2_MIDL_PROC_FORMAT_STRING AccessibleTable2__MIDL_ProcFormatString;
+extern const AccessibleTable2_MIDL_EXPR_FORMAT_STRING AccessibleTable2__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleTable2_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleTable2_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleTable2_MIDL_PROC_FORMAT_STRING AccessibleTable2__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_cellAt */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 30 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter cell */
+
+/* 36 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 40 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 42 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 46 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_caption */
+
+/* 48 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 50 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 54 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 56 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 62 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 64 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 70 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessible */
+
+/* 72 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 76 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 82 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnDescription */
+
+/* 84 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 90 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 92 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 94 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 96 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 98 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 100 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 102 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 114 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 118 */	NdrFcShort( 0x36 ),	/* Type Offset=54 */
+
+	/* Return value */
+
+/* 120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nColumns */
+
+/* 126 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 128 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 132 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 134 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 140 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 142 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 148 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnCount */
+
+/* 150 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 152 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 154 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 158 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 160 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nRows */
+
+/* 162 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 164 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 168 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 170 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 172 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 174 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 176 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 178 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 180 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowCount */
+
+/* 186 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 188 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 190 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 194 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 196 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedCells */
+
+/* 198 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 204 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 206 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 208 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 210 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 212 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 214 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 216 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellCount */
+
+/* 222 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 224 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 226 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 230 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 232 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedColumns */
+
+/* 234 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 236 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 240 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 242 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 246 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 248 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 250 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 252 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 254 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnCount */
+
+/* 258 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 260 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 262 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 264 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 266 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 268 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedRows */
+
+/* 270 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 272 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 276 */	NdrFcShort( 0xa ),	/* 10 */
+/* 278 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 280 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 282 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 284 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 286 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 288 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 290 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 292 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowCount */
+
+/* 294 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 296 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 298 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 300 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 302 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 304 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowDescription */
+
+/* 306 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 308 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 312 */	NdrFcShort( 0xb ),	/* 11 */
+/* 314 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 316 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 318 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 320 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 322 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 324 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 330 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 332 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 334 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 336 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 338 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 340 */	NdrFcShort( 0x36 ),	/* Type Offset=54 */
+
+	/* Return value */
+
+/* 342 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 344 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 346 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedCells */
+
+/* 348 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 350 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 354 */	NdrFcShort( 0xc ),	/* 12 */
+/* 356 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 360 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 362 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 364 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 366 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 368 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 370 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cells */
+
+/* 372 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 374 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 376 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */
+
+	/* Parameter nSelectedCells */
+
+/* 378 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 380 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 382 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 384 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 386 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 388 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedColumns */
+
+/* 390 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 392 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 396 */	NdrFcShort( 0xd ),	/* 13 */
+/* 398 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 400 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 402 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 404 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 406 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 408 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 410 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectedColumns */
+
+/* 414 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 416 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 418 */	NdrFcShort( 0x62 ),	/* Type Offset=98 */
+
+	/* Parameter nColumns */
+
+/* 420 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 422 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 424 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 428 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 430 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedRows */
+
+/* 432 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 438 */	NdrFcShort( 0xe ),	/* 14 */
+/* 440 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 442 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 444 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 446 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 448 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 450 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectedRows */
+
+/* 456 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 458 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 460 */	NdrFcShort( 0x62 ),	/* Type Offset=98 */
+
+	/* Parameter nRows */
+
+/* 462 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 464 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 466 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 468 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 470 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 472 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_summary */
+
+/* 474 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 476 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 480 */	NdrFcShort( 0xf ),	/* 15 */
+/* 482 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 484 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 486 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 488 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 490 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 492 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 494 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 496 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessible */
+
+/* 498 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 500 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 502 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 504 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 506 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 508 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isColumnSelected */
+
+/* 510 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 512 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 516 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 518 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 520 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 522 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 524 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 526 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 532 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 534 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 536 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 538 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 540 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 542 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 544 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 546 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 548 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 550 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isRowSelected */
+
+/* 552 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 554 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 558 */	NdrFcShort( 0x11 ),	/* 17 */
+/* 560 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 562 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 564 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 566 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 568 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 570 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 572 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 576 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 578 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 580 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 582 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 584 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 586 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 588 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 590 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 592 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure selectRow */
+
+/* 594 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 596 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 600 */	NdrFcShort( 0x12 ),	/* 18 */
+/* 602 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 604 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 606 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 608 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 610 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 612 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 614 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 616 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 618 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 620 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 622 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 624 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 626 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 628 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure selectColumn */
+
+/* 630 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 632 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 636 */	NdrFcShort( 0x13 ),	/* 19 */
+/* 638 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 640 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 642 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 644 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 646 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 650 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 652 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 654 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 656 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 658 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 660 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 662 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 664 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure unselectRow */
+
+/* 666 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 668 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 672 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 674 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 676 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 678 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 680 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 682 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 688 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 690 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 692 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 694 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 696 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 698 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 700 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure unselectColumn */
+
+/* 702 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 704 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 708 */	NdrFcShort( 0x15 ),	/* 21 */
+/* 710 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 712 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 714 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 716 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 718 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 722 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 724 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 726 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 728 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 730 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 732 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 734 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 736 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_modelChange */
+
+/* 738 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 740 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 744 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 746 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 750 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 752 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 754 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 756 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 758 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 760 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter modelChange */
+
+/* 762 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 764 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 766 */	NdrFcShort( 0x7e ),	/* Type Offset=126 */
+
+	/* Return value */
+
+/* 768 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 770 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 772 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleTable2_MIDL_TYPE_FORMAT_STRING AccessibleTable2__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/*  4 */	NdrFcShort( 0x2 ),	/* Offset= 2 (6) */
+/*  6 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/*  8 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 16 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 18 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 20 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 22 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 24 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 26 */	NdrFcShort( 0x1c ),	/* Offset= 28 (54) */
+/* 28 */	
+			0x13, 0x0,	/* FC_OP */
+/* 30 */	NdrFcShort( 0xe ),	/* Offset= 14 (44) */
+/* 32 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 34 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 36 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 38 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 40 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 42 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 44 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 48 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (32) */
+/* 50 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 52 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 54 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0xffde ),	/* Offset= -34 (28) */
+/* 64 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 66 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 68 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
+/* 72 */	
+			0x13, 0x0,	/* FC_OP */
+/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
+/* 76 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 80 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 82 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 84 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 86 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 90 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 92 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 94 */	NdrFcShort( 0xffa8 ),	/* Offset= -88 (6) */
+/* 96 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 98 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 100 */	NdrFcShort( 0x2 ),	/* Offset= 2 (102) */
+/* 102 */	
+			0x13, 0x0,	/* FC_OP */
+/* 104 */	NdrFcShort( 0x2 ),	/* Offset= 2 (106) */
+/* 106 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 108 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 110 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 112 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 114 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 116 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 118 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 120 */	0x3,		/* FC_SMALL */
+			0x5c,		/* FC_PAD */
+/* 122 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 124 */	NdrFcShort( 0x2 ),	/* Offset= 2 (126) */
+/* 126 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 128 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 130 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 132 */	NdrFcShort( 0x0 ),	/* Offset= 0 (132) */
+/* 134 */	0xd,		/* FC_ENUM16 */
+			0x8,		/* FC_LONG */
+/* 136 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 138 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleTable2, ver. 0.0,
+   GUID={0x6167f295,0x06f0,0x4cdd,{0xa1,0xfa,0x02,0xe2,0x51,0x53,0xd8,0x69}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleTable2_FormatStringOffsetTable[] =
+    {
+    0,
+    48,
+    84,
+    126,
+    162,
+    198,
+    234,
+    270,
+    306,
+    348,
+    390,
+    432,
+    474,
+    510,
+    552,
+    594,
+    630,
+    666,
+    702,
+    738
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleTable2_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleTable2__MIDL_ProcFormatString.Format,
+    &IAccessibleTable2_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleTable2_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleTable2__MIDL_ProcFormatString.Format,
+    &IAccessibleTable2_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(23) _IAccessibleTable2ProxyVtbl = 
+{
+    &IAccessibleTable2_ProxyInfo,
+    &IID_IAccessibleTable2,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_cellAt */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_caption */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_columnDescription */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nSelectedCells */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nSelectedColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_nSelectedRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_rowDescription */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_selectedCells */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_selectedColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_selectedRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_summary */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_isColumnSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_isRowSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::selectRow */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::selectColumn */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::unselectRow */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::unselectColumn */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable2::get_modelChange */
+};
+
+const CInterfaceStubVtbl _IAccessibleTable2StubVtbl =
+{
+    &IID_IAccessibleTable2,
+    &IAccessibleTable2_ServerInfo,
+    23,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleTable2__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleTable2_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleTable2ProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleTable2_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleTable2StubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleTable2_InterfaceNamesList[] = 
+{
+    "IAccessibleTable2",
+    0
+};
+
+
+#define _AccessibleTable2_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleTable2, pIID, n)
+
+int __stdcall _AccessibleTable2_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleTable2_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleTable2_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleTable2_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleTable2_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleTable2_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleTable2_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell.h
new file mode 100644
index 0000000..621768e
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell.h
@@ -0,0 +1,246 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleTableCell.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleTableCell_h__
+#define __AccessibleTableCell_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleTableCell_FWD_DEFINED__
+#define __IAccessibleTableCell_FWD_DEFINED__
+typedef interface IAccessibleTableCell IAccessibleTableCell;
+#endif 	/* __IAccessibleTableCell_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "Accessible2.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleTableCell_INTERFACE_DEFINED__
+#define __IAccessibleTableCell_INTERFACE_DEFINED__
+
+/* interface IAccessibleTableCell */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleTableCell;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("594116B1-C99F-4847-AD06-0A7A86ECE645")
+    IAccessibleTableCell : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnExtent( 
+            /* [retval][out] */ long *nColumnsSpanned) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnHeaderCells( 
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cellAccessibles,
+            /* [retval][out] */ long *nColumnHeaderCells) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_columnIndex( 
+            /* [retval][out] */ long *columnIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowExtent( 
+            /* [retval][out] */ long *nRowsSpanned) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowHeaderCells( 
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cellAccessibles,
+            /* [retval][out] */ long *nRowHeaderCells) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowIndex( 
+            /* [retval][out] */ long *rowIndex) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_isSelected( 
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_rowColumnExtents( 
+            /* [out] */ long *row,
+            /* [out] */ long *column,
+            /* [out] */ long *rowExtents,
+            /* [out] */ long *columnExtents,
+            /* [retval][out] */ boolean *isSelected) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_table( 
+            /* [retval][out] */ IUnknown **table) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleTableCellVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleTableCell * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleTableCell * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleTableCell * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnExtent )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ long *nColumnsSpanned);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnHeaderCells )( 
+            IAccessibleTableCell * This,
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cellAccessibles,
+            /* [retval][out] */ long *nColumnHeaderCells);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnIndex )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ long *columnIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowExtent )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ long *nRowsSpanned);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowHeaderCells )( 
+            IAccessibleTableCell * This,
+            /* [size_is][size_is][size_is][out] */ IUnknown ***cellAccessibles,
+            /* [retval][out] */ long *nRowHeaderCells);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowIndex )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ long *rowIndex);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_isSelected )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_rowColumnExtents )( 
+            IAccessibleTableCell * This,
+            /* [out] */ long *row,
+            /* [out] */ long *column,
+            /* [out] */ long *rowExtents,
+            /* [out] */ long *columnExtents,
+            /* [retval][out] */ boolean *isSelected);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_table )( 
+            IAccessibleTableCell * This,
+            /* [retval][out] */ IUnknown **table);
+        
+        END_INTERFACE
+    } IAccessibleTableCellVtbl;
+
+    interface IAccessibleTableCell
+    {
+        CONST_VTBL struct IAccessibleTableCellVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleTableCell_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleTableCell_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleTableCell_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleTableCell_get_columnExtent(This,nColumnsSpanned)	\
+    ( (This)->lpVtbl -> get_columnExtent(This,nColumnsSpanned) ) 
+
+#define IAccessibleTableCell_get_columnHeaderCells(This,cellAccessibles,nColumnHeaderCells)	\
+    ( (This)->lpVtbl -> get_columnHeaderCells(This,cellAccessibles,nColumnHeaderCells) ) 
+
+#define IAccessibleTableCell_get_columnIndex(This,columnIndex)	\
+    ( (This)->lpVtbl -> get_columnIndex(This,columnIndex) ) 
+
+#define IAccessibleTableCell_get_rowExtent(This,nRowsSpanned)	\
+    ( (This)->lpVtbl -> get_rowExtent(This,nRowsSpanned) ) 
+
+#define IAccessibleTableCell_get_rowHeaderCells(This,cellAccessibles,nRowHeaderCells)	\
+    ( (This)->lpVtbl -> get_rowHeaderCells(This,cellAccessibles,nRowHeaderCells) ) 
+
+#define IAccessibleTableCell_get_rowIndex(This,rowIndex)	\
+    ( (This)->lpVtbl -> get_rowIndex(This,rowIndex) ) 
+
+#define IAccessibleTableCell_get_isSelected(This,isSelected)	\
+    ( (This)->lpVtbl -> get_isSelected(This,isSelected) ) 
+
+#define IAccessibleTableCell_get_rowColumnExtents(This,row,column,rowExtents,columnExtents,isSelected)	\
+    ( (This)->lpVtbl -> get_rowColumnExtents(This,row,column,rowExtents,columnExtents,isSelected) ) 
+
+#define IAccessibleTableCell_get_table(This,table)	\
+    ( (This)->lpVtbl -> get_table(This,table) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleTableCell_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell_i.c
new file mode 100644
index 0000000..4ea10e0
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleTableCell.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleTableCell,0x594116B1,0xC99F,0x4847,0xAD,0x06,0x0A,0x7A,0x86,0xEC,0xE6,0x45);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell_p.c
new file mode 100644
index 0000000..2627caa
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTableCell_p.c
@@ -0,0 +1,637 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleTableCell.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleTableCell.h"
+
+#define TYPE_FORMAT_STRING_SIZE   63                                
+#define PROC_FORMAT_STRING_SIZE   361                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   0            
+
+typedef struct _AccessibleTableCell_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleTableCell_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleTableCell_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleTableCell_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleTableCell_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleTableCell_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleTableCell_MIDL_TYPE_FORMAT_STRING AccessibleTableCell__MIDL_TypeFormatString;
+extern const AccessibleTableCell_MIDL_PROC_FORMAT_STRING AccessibleTableCell__MIDL_ProcFormatString;
+extern const AccessibleTableCell_MIDL_EXPR_FORMAT_STRING AccessibleTableCell__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleTableCell_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleTableCell_ProxyInfo;
+
+
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleTableCell_MIDL_PROC_FORMAT_STRING AccessibleTableCell__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_columnExtent */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nColumnsSpanned */
+
+/* 24 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnHeaderCells */
+
+/* 36 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 48 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 50 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 52 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 54 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellAccessibles */
+
+/* 60 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 64 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
+
+	/* Parameter nColumnHeaderCells */
+
+/* 66 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 72 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 74 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 76 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnIndex */
+
+/* 78 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 80 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 84 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 86 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 88 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 90 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 92 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 94 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnIndex */
+
+/* 102 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 110 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowExtent */
+
+/* 114 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 116 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 126 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 128 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 130 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nRowsSpanned */
+
+/* 138 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 140 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 142 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 146 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 148 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowHeaderCells */
+
+/* 150 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 156 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 158 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 162 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 164 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 166 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 168 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 170 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 172 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellAccessibles */
+
+/* 174 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 176 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 178 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
+
+	/* Parameter nRowHeaderCells */
+
+/* 180 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 182 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 184 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 186 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 188 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 190 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowIndex */
+
+/* 192 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 194 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 198 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 200 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 202 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 204 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 206 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 208 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 210 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 212 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowIndex */
+
+/* 216 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 218 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 220 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 222 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 224 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 226 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isSelected */
+
+/* 228 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 230 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 234 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 236 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 240 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 242 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 244 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 246 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 248 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter isSelected */
+
+/* 252 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 254 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 256 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 258 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 260 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 262 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowColumnExtents */
+
+/* 264 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 266 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 270 */	NdrFcShort( 0xa ),	/* 10 */
+/* 272 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
+/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 276 */	NdrFcShort( 0x91 ),	/* 145 */
+/* 278 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x6,		/* 6 */
+/* 280 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 288 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 292 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 294 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 298 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter rowExtents */
+
+/* 300 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 304 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columnExtents */
+
+/* 306 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 308 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 310 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 312 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 314 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 316 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 320 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 322 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_table */
+
+/* 324 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 326 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 330 */	NdrFcShort( 0xb ),	/* 11 */
+/* 332 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 336 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 338 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 340 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter table */
+
+/* 348 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 350 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 352 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */
+
+	/* Return value */
+
+/* 354 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 356 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 358 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleTableCell_MIDL_TYPE_FORMAT_STRING AccessibleTableCell__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
+/* 10 */	
+			0x13, 0x0,	/* FC_OP */
+/* 12 */	NdrFcShort( 0x14 ),	/* Offset= 20 (32) */
+/* 14 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 16 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 24 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 26 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 28 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 30 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 32 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 36 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 38 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 40 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 42 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 46 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 48 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 50 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (14) */
+/* 52 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 54 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 56 */	0x3,		/* FC_SMALL */
+			0x5c,		/* FC_PAD */
+/* 58 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/* 60 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (14) */
+
+			0x0
+        }
+    };
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleTableCell, ver. 0.0,
+   GUID={0x594116B1,0xC99F,0x4847,{0xAD,0x06,0x0A,0x7A,0x86,0xEC,0xE6,0x45}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleTableCell_FormatStringOffsetTable[] =
+    {
+    0,
+    36,
+    78,
+    114,
+    150,
+    192,
+    228,
+    264,
+    324
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleTableCell_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleTableCell__MIDL_ProcFormatString.Format,
+    &IAccessibleTableCell_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleTableCell_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleTableCell__MIDL_ProcFormatString.Format,
+    &IAccessibleTableCell_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(12) _IAccessibleTableCellProxyVtbl = 
+{
+    &IAccessibleTableCell_ProxyInfo,
+    &IID_IAccessibleTableCell,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_columnExtent */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_columnHeaderCells */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_columnIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_rowExtent */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_rowHeaderCells */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_rowIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_isSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_rowColumnExtents */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTableCell::get_table */
+};
+
+const CInterfaceStubVtbl _IAccessibleTableCellStubVtbl =
+{
+    &IID_IAccessibleTableCell,
+    &IAccessibleTableCell_ServerInfo,
+    12,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleTableCell__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    0,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleTableCell_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleTableCellProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleTableCell_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleTableCellStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleTableCell_InterfaceNamesList[] = 
+{
+    "IAccessibleTableCell",
+    0
+};
+
+
+#define _AccessibleTableCell_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleTableCell, pIID, n)
+
+int __stdcall _AccessibleTableCell_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleTableCell_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleTableCell_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleTableCell_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleTableCell_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleTableCell_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleTableCell_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTable_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable_i.c
new file mode 100644
index 0000000..0fa3396
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:54 2012
+ */
+/* Compiler settings for AccessibleTable.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleTable,0x35AD8070,0xC20C,0x4fb4,0xB0,0x94,0xF4,0xF7,0x27,0x5D,0xD4,0x69);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleTable_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable_p.c
new file mode 100644
index 0000000..9ec9ffd
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleTable_p.c
@@ -0,0 +1,1526 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:54 2012
+ */
+/* Compiler settings for AccessibleTable.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleTable.h"
+
+#define TYPE_FORMAT_STRING_SIZE   139                               
+#define PROC_FORMAT_STRING_SIZE   1219                              
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleTable_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleTable_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleTable_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleTable_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleTable_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleTable_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleTable_MIDL_TYPE_FORMAT_STRING AccessibleTable__MIDL_TypeFormatString;
+extern const AccessibleTable_MIDL_PROC_FORMAT_STRING AccessibleTable__MIDL_ProcFormatString;
+extern const AccessibleTable_MIDL_EXPR_FORMAT_STRING AccessibleTable__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleTable_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleTable_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleTable_MIDL_PROC_FORMAT_STRING AccessibleTable__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_accessibleAt */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 30 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter accessible */
+
+/* 36 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 40 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 42 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 46 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_caption */
+
+/* 48 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 50 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 54 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 56 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 60 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 62 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 64 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 70 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessible */
+
+/* 72 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 76 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 82 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_childIndex */
+
+/* 84 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 90 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 92 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 94 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 96 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 98 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 100 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowIndex */
+
+/* 108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 112 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columnIndex */
+
+/* 114 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 118 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter cellIndex */
+
+/* 120 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 128 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnDescription */
+
+/* 132 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 140 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 142 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 144 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 146 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 148 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 150 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 154 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 158 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 160 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 162 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 164 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 166 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */
+
+	/* Return value */
+
+/* 168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 170 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 172 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnExtentAt */
+
+/* 174 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 176 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 180 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 182 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 184 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 186 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 188 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 190 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 192 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 198 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 200 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 202 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 206 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 208 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter nColumnsSpanned */
+
+/* 210 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 212 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 214 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 216 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 218 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 220 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnHeader */
+
+/* 222 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 224 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 230 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 232 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 234 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 236 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 238 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 240 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 242 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessibleTable */
+
+/* 246 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 248 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 250 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */
+
+	/* Parameter startingRowIndex */
+
+/* 252 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 254 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 256 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 258 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 260 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 262 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_columnIndex */
+
+/* 264 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 266 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 270 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 272 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 276 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 278 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 280 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellIndex */
+
+/* 288 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 292 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columnIndex */
+
+/* 294 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 298 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 300 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 304 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nColumns */
+
+/* 306 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 308 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 312 */	NdrFcShort( 0xa ),	/* 10 */
+/* 314 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 316 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 318 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 320 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 322 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnCount */
+
+/* 330 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 332 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 334 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 336 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 338 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 340 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nRows */
+
+/* 342 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 344 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 348 */	NdrFcShort( 0xb ),	/* 11 */
+/* 350 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 352 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 354 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 356 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 358 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 362 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowCount */
+
+/* 366 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 368 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 370 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 374 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 376 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedChildren */
+
+/* 378 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 380 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 384 */	NdrFcShort( 0xc ),	/* 12 */
+/* 386 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 390 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 392 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 394 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 396 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 400 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellCount */
+
+/* 402 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 406 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 412 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedColumns */
+
+/* 414 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 416 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 420 */	NdrFcShort( 0xd ),	/* 13 */
+/* 422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 424 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 426 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 428 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 430 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 434 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 436 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter columnCount */
+
+/* 438 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 440 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 442 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 446 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 448 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelectedRows */
+
+/* 450 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 456 */	NdrFcShort( 0xe ),	/* 14 */
+/* 458 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 462 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 464 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 466 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter rowCount */
+
+/* 474 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 476 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 478 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 482 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 484 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowDescription */
+
+/* 486 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 488 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 492 */	NdrFcShort( 0xf ),	/* 15 */
+/* 494 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 496 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 498 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 500 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 502 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 504 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 508 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 510 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 512 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 514 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter description */
+
+/* 516 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 518 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 520 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */
+
+	/* Return value */
+
+/* 522 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 524 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 526 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowExtentAt */
+
+/* 528 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 530 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 534 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 536 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 538 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 540 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 542 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 544 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 548 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 550 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 552 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 554 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 556 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 558 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 560 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 562 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter nRowsSpanned */
+
+/* 564 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 566 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 568 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 572 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 574 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowHeader */
+
+/* 576 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 578 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 582 */	NdrFcShort( 0x11 ),	/* 17 */
+/* 584 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 588 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 590 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x3,		/* 3 */
+/* 592 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 598 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessibleTable */
+
+/* 600 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 602 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 604 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */
+
+	/* Parameter startingColumnIndex */
+
+/* 606 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 608 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 610 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 612 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 614 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 616 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowIndex */
+
+/* 618 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 620 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 624 */	NdrFcShort( 0x12 ),	/* 18 */
+/* 626 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 628 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 630 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 632 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 634 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 636 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 638 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 640 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter cellIndex */
+
+/* 642 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 644 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 646 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter rowIndex */
+
+/* 648 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 650 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 652 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 654 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 658 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedChildren */
+
+/* 660 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 662 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 666 */	NdrFcShort( 0x13 ),	/* 19 */
+/* 668 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 670 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 672 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 674 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 676 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 678 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 680 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 682 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxChildren */
+
+/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 686 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 688 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter children */
+
+/* 690 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 692 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 694 */	NdrFcShort( 0x5a ),	/* Type Offset=90 */
+
+	/* Parameter nChildren */
+
+/* 696 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 698 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 700 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 702 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 704 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 706 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedColumns */
+
+/* 708 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 710 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 714 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 716 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 718 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 720 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 722 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 724 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 726 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 728 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 730 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxColumns */
+
+/* 732 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 734 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 736 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columns */
+
+/* 738 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 740 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 742 */	NdrFcShort( 0x5a ),	/* Type Offset=90 */
+
+	/* Parameter nColumns */
+
+/* 744 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 746 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 748 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 750 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 752 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 754 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selectedRows */
+
+/* 756 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 758 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 762 */	NdrFcShort( 0x15 ),	/* 21 */
+/* 764 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 766 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 768 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 770 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 772 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 774 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 776 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 778 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maxRows */
+
+/* 780 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 782 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 784 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter rows */
+
+/* 786 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
+/* 788 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 790 */	NdrFcShort( 0x5a ),	/* Type Offset=90 */
+
+	/* Parameter nRows */
+
+/* 792 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 794 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 796 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 798 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 800 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 802 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_summary */
+
+/* 804 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 806 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 810 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 812 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 814 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 816 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 818 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 820 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter accessible */
+
+/* 828 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
+/* 830 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 832 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
+
+	/* Return value */
+
+/* 834 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 836 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 838 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isColumnSelected */
+
+/* 840 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 842 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 846 */	NdrFcShort( 0x17 ),	/* 23 */
+/* 848 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 850 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 852 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 854 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 856 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 862 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 864 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 866 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 868 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 870 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 872 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 874 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 876 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 878 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 880 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isRowSelected */
+
+/* 882 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 884 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 888 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 890 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 892 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 894 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 896 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 898 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 902 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 904 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 906 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 908 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 910 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 914 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 916 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 920 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 922 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_isSelected */
+
+/* 924 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 926 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 930 */	NdrFcShort( 0x19 ),	/* 25 */
+/* 932 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 934 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 936 */	NdrFcShort( 0x21 ),	/* 33 */
+/* 938 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 940 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 942 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 944 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 946 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 948 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 950 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 952 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 954 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 956 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 958 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 960 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 962 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 964 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 966 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 968 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 970 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure selectRow */
+
+/* 972 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 974 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 978 */	NdrFcShort( 0x1a ),	/* 26 */
+/* 980 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 982 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 984 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 986 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 988 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 990 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 994 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 996 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 998 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 1000 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1002 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1004 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 1006 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure selectColumn */
+
+/* 1008 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1010 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1014 */	NdrFcShort( 0x1b ),	/* 27 */
+/* 1016 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 1018 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1020 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1022 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 1024 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1028 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1030 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 1032 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1034 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 1036 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1038 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1040 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 1042 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure unselectRow */
+
+/* 1044 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1046 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1050 */	NdrFcShort( 0x1c ),	/* 28 */
+/* 1052 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 1054 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1056 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1058 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 1060 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1062 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1064 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1066 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter row */
+
+/* 1068 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1070 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 1072 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1074 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1076 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 1078 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure unselectColumn */
+
+/* 1080 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1082 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1086 */	NdrFcShort( 0x1d ),	/* 29 */
+/* 1088 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 1090 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1092 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1094 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 1096 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1098 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1100 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1102 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter column */
+
+/* 1104 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1106 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 1108 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1110 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1112 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 1114 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_rowColumnExtentsAtIndex */
+
+/* 1116 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1118 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1122 */	NdrFcShort( 0x1e ),	/* 30 */
+/* 1124 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
+/* 1126 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1128 */	NdrFcShort( 0x91 ),	/* 145 */
+/* 1130 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x7,		/* 7 */
+/* 1132 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1134 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1136 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1138 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter index */
+
+/* 1140 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 1142 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 1144 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter row */
+
+/* 1146 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1148 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 1150 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter column */
+
+/* 1152 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1154 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 1156 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter rowExtents */
+
+/* 1158 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1160 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 1162 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter columnExtents */
+
+/* 1164 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1166 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 1168 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter isSelected */
+
+/* 1170 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 1172 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 1174 */	0x3,		/* FC_SMALL */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 1176 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1178 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
+/* 1180 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_modelChange */
+
+/* 1182 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 1184 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 1188 */	NdrFcShort( 0x1f ),	/* 31 */
+/* 1190 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 1192 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1194 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 1196 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 1198 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 1200 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1202 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter modelChange */
+
+/* 1206 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
+/* 1208 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 1210 */	NdrFcShort( 0x7c ),	/* Type Offset=124 */
+
+	/* Return value */
+
+/* 1212 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 1214 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 1216 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleTable_MIDL_TYPE_FORMAT_STRING AccessibleTable__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/*  4 */	NdrFcShort( 0x2 ),	/* Offset= 2 (6) */
+/*  6 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/*  8 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 16 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 18 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 20 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 22 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 24 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 26 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 28 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 30 */	NdrFcShort( 0x1c ),	/* Offset= 28 (58) */
+/* 32 */	
+			0x13, 0x0,	/* FC_OP */
+/* 34 */	NdrFcShort( 0xe ),	/* Offset= 14 (48) */
+/* 36 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 38 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 40 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 42 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 44 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 46 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 48 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 52 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (36) */
+/* 54 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 56 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 58 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 62 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 66 */	NdrFcShort( 0xffde ),	/* Offset= -34 (32) */
+/* 68 */	
+			0x11, 0x10,	/* FC_RP [pointer_deref] */
+/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
+/* 72 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 74 */	NdrFcLong( 0x35ad8070 ),	/* 900563056 */
+/* 78 */	NdrFcShort( 0xc20c ),	/* -15860 */
+/* 80 */	NdrFcShort( 0x4fb4 ),	/* 20404 */
+/* 82 */	0xb0,		/* 176 */
+			0x94,		/* 148 */
+/* 84 */	0xf4,		/* 244 */
+			0xf7,		/* 247 */
+/* 86 */	0x27,		/* 39 */
+			0x5d,		/* 93 */
+/* 88 */	0xd4,		/* 212 */
+			0x69,		/* 105 */
+/* 90 */	
+			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
+/* 92 */	NdrFcShort( 0x2 ),	/* Offset= 2 (94) */
+/* 94 */	
+			0x13, 0x0,	/* FC_OP */
+/* 96 */	NdrFcShort( 0x2 ),	/* Offset= 2 (98) */
+/* 98 */	
+			0x1c,		/* FC_CVARRAY */
+			0x3,		/* 3 */
+/* 100 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 102 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x0,		/*  */
+/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 106 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 108 */	0x28,		/* Corr desc:  parameter, FC_LONG */
+			0x54,		/* FC_DEREFERENCE */
+/* 110 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 112 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 114 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 116 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/* 118 */	0x3,		/* FC_SMALL */
+			0x5c,		/* FC_PAD */
+/* 120 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 122 */	NdrFcShort( 0x2 ),	/* Offset= 2 (124) */
+/* 124 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 126 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 130 */	NdrFcShort( 0x0 ),	/* Offset= 0 (130) */
+/* 132 */	0xd,		/* FC_ENUM16 */
+			0x8,		/* FC_LONG */
+/* 134 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 136 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleTable, ver. 0.0,
+   GUID={0x35AD8070,0xC20C,0x4fb4,{0xB0,0x94,0xF4,0xF7,0x27,0x5D,0xD4,0x69}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleTable_FormatStringOffsetTable[] =
+    {
+    0,
+    48,
+    84,
+    132,
+    174,
+    222,
+    264,
+    306,
+    342,
+    378,
+    414,
+    450,
+    486,
+    528,
+    576,
+    618,
+    660,
+    708,
+    756,
+    804,
+    840,
+    882,
+    924,
+    972,
+    1008,
+    1044,
+    1080,
+    1116,
+    1182
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleTable_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleTable__MIDL_ProcFormatString.Format,
+    &IAccessibleTable_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleTable_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleTable__MIDL_ProcFormatString.Format,
+    &IAccessibleTable_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(32) _IAccessibleTableProxyVtbl = 
+{
+    &IAccessibleTable_ProxyInfo,
+    &IID_IAccessibleTable,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_accessibleAt */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_caption */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_childIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_columnDescription */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_columnExtentAt */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_columnHeader */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_columnIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nSelectedChildren */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nSelectedColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_nSelectedRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowDescription */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowExtentAt */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowHeader */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_selectedChildren */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_selectedColumns */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_selectedRows */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_summary */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_isColumnSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_isRowSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_isSelected */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::selectRow */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::selectColumn */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::unselectRow */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::unselectColumn */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_rowColumnExtentsAtIndex */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleTable::get_modelChange */
+};
+
+const CInterfaceStubVtbl _IAccessibleTableStubVtbl =
+{
+    &IID_IAccessibleTable,
+    &IAccessibleTable_ServerInfo,
+    32,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleTable__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleTable_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleTableProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleTable_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleTableStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleTable_InterfaceNamesList[] = 
+{
+    "IAccessibleTable",
+    0
+};
+
+
+#define _AccessibleTable_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleTable, pIID, n)
+
+int __stdcall _AccessibleTable_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleTable_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleTable_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleTable_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleTable_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleTable_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleTable_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleText.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleText.h
new file mode 100644
index 0000000..4ad53cf
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleText.h
@@ -0,0 +1,435 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleText.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleText_h__
+#define __AccessibleText_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleText_FWD_DEFINED__
+#define __IAccessibleText_FWD_DEFINED__
+typedef interface IAccessibleText IAccessibleText;
+#endif 	/* __IAccessibleText_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+#include "IA2CommonTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_AccessibleText_0000_0000 */
+/* [local] */ 
+
+typedef struct IA2TextSegment
+    {
+    BSTR text;
+    long start;
+    long end;
+    } 	IA2TextSegment;
+
+
+enum IA2TextBoundaryType
+    {	IA2_TEXT_BOUNDARY_CHAR	= 0,
+	IA2_TEXT_BOUNDARY_WORD	= ( IA2_TEXT_BOUNDARY_CHAR + 1 ) ,
+	IA2_TEXT_BOUNDARY_SENTENCE	= ( IA2_TEXT_BOUNDARY_WORD + 1 ) ,
+	IA2_TEXT_BOUNDARY_PARAGRAPH	= ( IA2_TEXT_BOUNDARY_SENTENCE + 1 ) ,
+	IA2_TEXT_BOUNDARY_LINE	= ( IA2_TEXT_BOUNDARY_PARAGRAPH + 1 ) ,
+	IA2_TEXT_BOUNDARY_ALL	= ( IA2_TEXT_BOUNDARY_LINE + 1 ) 
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleText_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_AccessibleText_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAccessibleText_INTERFACE_DEFINED__
+#define __IAccessibleText_INTERFACE_DEFINED__
+
+/* interface IAccessibleText */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleText;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("24FD2FFB-3AAD-4a08-8335-A3AD89C0FB4B")
+    IAccessibleText : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE addSelection( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
+            /* [in] */ long offset,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *textAttributes) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_caretOffset( 
+            /* [retval][out] */ long *offset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_characterExtents( 
+            /* [in] */ long offset,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [out] */ long *x,
+            /* [out] */ long *y,
+            /* [out] */ long *width,
+            /* [retval][out] */ long *height) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nSelections( 
+            /* [retval][out] */ long *nSelections) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_offsetAtPoint( 
+            /* [in] */ long x,
+            /* [in] */ long y,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [retval][out] */ long *offset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_selection( 
+            /* [in] */ long selectionIndex,
+            /* [out] */ long *startOffset,
+            /* [retval][out] */ long *endOffset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_text( 
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [retval][out] */ BSTR *text) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_textBeforeOffset( 
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_textAfterOffset( 
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_textAtOffset( 
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE removeSelection( 
+            /* [in] */ long selectionIndex) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE setCaretOffset( 
+            /* [in] */ long offset) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE setSelection( 
+            /* [in] */ long selectionIndex,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_nCharacters( 
+            /* [retval][out] */ long *nCharacters) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE scrollSubstringTo( 
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2ScrollType scrollType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE scrollSubstringToPoint( 
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_newText( 
+            /* [retval][out] */ IA2TextSegment *newText) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_oldText( 
+            /* [retval][out] */ IA2TextSegment *oldText) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleTextVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleText * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleText * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleText * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *addSelection )( 
+            IAccessibleText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *textAttributes);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_caretOffset )( 
+            IAccessibleText * This,
+            /* [retval][out] */ long *offset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_characterExtents )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [out] */ long *x,
+            /* [out] */ long *y,
+            /* [out] */ long *width,
+            /* [retval][out] */ long *height);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nSelections )( 
+            IAccessibleText * This,
+            /* [retval][out] */ long *nSelections);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_offsetAtPoint )( 
+            IAccessibleText * This,
+            /* [in] */ long x,
+            /* [in] */ long y,
+            /* [in] */ enum IA2CoordinateType coordType,
+            /* [retval][out] */ long *offset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_selection )( 
+            IAccessibleText * This,
+            /* [in] */ long selectionIndex,
+            /* [out] */ long *startOffset,
+            /* [retval][out] */ long *endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
+            IAccessibleText * This,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textBeforeOffset )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textAfterOffset )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_textAtOffset )( 
+            IAccessibleText * This,
+            /* [in] */ long offset,
+            /* [in] */ enum IA2TextBoundaryType boundaryType,
+            /* [out] */ long *startOffset,
+            /* [out] */ long *endOffset,
+            /* [retval][out] */ BSTR *text);
+        
+        HRESULT ( STDMETHODCALLTYPE *removeSelection )( 
+            IAccessibleText * This,
+            /* [in] */ long selectionIndex);
+        
+        HRESULT ( STDMETHODCALLTYPE *setCaretOffset )( 
+            IAccessibleText * This,
+            /* [in] */ long offset);
+        
+        HRESULT ( STDMETHODCALLTYPE *setSelection )( 
+            IAccessibleText * This,
+            /* [in] */ long selectionIndex,
+            /* [in] */ long startOffset,
+            /* [in] */ long endOffset);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_nCharacters )( 
+            IAccessibleText * This,
+            /* [retval][out] */ long *nCharacters);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollSubstringTo )( 
+            IAccessibleText * This,
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2ScrollType scrollType);
+        
+        HRESULT ( STDMETHODCALLTYPE *scrollSubstringToPoint )( 
+            IAccessibleText * This,
+            /* [in] */ long startIndex,
+            /* [in] */ long endIndex,
+            /* [in] */ enum IA2CoordinateType coordinateType,
+            /* [in] */ long x,
+            /* [in] */ long y);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_newText )( 
+            IAccessibleText * This,
+            /* [retval][out] */ IA2TextSegment *newText);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_oldText )( 
+            IAccessibleText * This,
+            /* [retval][out] */ IA2TextSegment *oldText);
+        
+        END_INTERFACE
+    } IAccessibleTextVtbl;
+
+    interface IAccessibleText
+    {
+        CONST_VTBL struct IAccessibleTextVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleText_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleText_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleText_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleText_addSelection(This,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> addSelection(This,startOffset,endOffset) ) 
+
+#define IAccessibleText_get_attributes(This,offset,startOffset,endOffset,textAttributes)	\
+    ( (This)->lpVtbl -> get_attributes(This,offset,startOffset,endOffset,textAttributes) ) 
+
+#define IAccessibleText_get_caretOffset(This,offset)	\
+    ( (This)->lpVtbl -> get_caretOffset(This,offset) ) 
+
+#define IAccessibleText_get_characterExtents(This,offset,coordType,x,y,width,height)	\
+    ( (This)->lpVtbl -> get_characterExtents(This,offset,coordType,x,y,width,height) ) 
+
+#define IAccessibleText_get_nSelections(This,nSelections)	\
+    ( (This)->lpVtbl -> get_nSelections(This,nSelections) ) 
+
+#define IAccessibleText_get_offsetAtPoint(This,x,y,coordType,offset)	\
+    ( (This)->lpVtbl -> get_offsetAtPoint(This,x,y,coordType,offset) ) 
+
+#define IAccessibleText_get_selection(This,selectionIndex,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> get_selection(This,selectionIndex,startOffset,endOffset) ) 
+
+#define IAccessibleText_get_text(This,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_text(This,startOffset,endOffset,text) ) 
+
+#define IAccessibleText_get_textBeforeOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textBeforeOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleText_get_textAfterOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textAfterOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleText_get_textAtOffset(This,offset,boundaryType,startOffset,endOffset,text)	\
+    ( (This)->lpVtbl -> get_textAtOffset(This,offset,boundaryType,startOffset,endOffset,text) ) 
+
+#define IAccessibleText_removeSelection(This,selectionIndex)	\
+    ( (This)->lpVtbl -> removeSelection(This,selectionIndex) ) 
+
+#define IAccessibleText_setCaretOffset(This,offset)	\
+    ( (This)->lpVtbl -> setCaretOffset(This,offset) ) 
+
+#define IAccessibleText_setSelection(This,selectionIndex,startOffset,endOffset)	\
+    ( (This)->lpVtbl -> setSelection(This,selectionIndex,startOffset,endOffset) ) 
+
+#define IAccessibleText_get_nCharacters(This,nCharacters)	\
+    ( (This)->lpVtbl -> get_nCharacters(This,nCharacters) ) 
+
+#define IAccessibleText_scrollSubstringTo(This,startIndex,endIndex,scrollType)	\
+    ( (This)->lpVtbl -> scrollSubstringTo(This,startIndex,endIndex,scrollType) ) 
+
+#define IAccessibleText_scrollSubstringToPoint(This,startIndex,endIndex,coordinateType,x,y)	\
+    ( (This)->lpVtbl -> scrollSubstringToPoint(This,startIndex,endIndex,coordinateType,x,y) ) 
+
+#define IAccessibleText_get_newText(This,newText)	\
+    ( (This)->lpVtbl -> get_newText(This,newText) ) 
+
+#define IAccessibleText_get_oldText(This,oldText)	\
+    ( (This)->lpVtbl -> get_oldText(This,oldText) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleText_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleText_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleText_i.c
new file mode 100644
index 0000000..bfa9e76
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleText_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleText.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleText,0x24FD2FFB,0x3AAD,0x4a08,0x83,0x35,0xA3,0xAD,0x89,0xC0,0xFB,0x4B);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleText_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleText_p.c
new file mode 100644
index 0000000..ea56621
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleText_p.c
@@ -0,0 +1,1196 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleText.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleText.h"
+
+#define TYPE_FORMAT_STRING_SIZE   67                                
+#define PROC_FORMAT_STRING_SIZE   901                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleText_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleText_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleText_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleText_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleText_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleText_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleText_MIDL_TYPE_FORMAT_STRING AccessibleText__MIDL_TypeFormatString;
+extern const AccessibleText_MIDL_PROC_FORMAT_STRING AccessibleText__MIDL_ProcFormatString;
+extern const AccessibleText_MIDL_EXPR_FORMAT_STRING AccessibleText__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleText_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleText_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleText_MIDL_PROC_FORMAT_STRING AccessibleText__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure addSelection */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x3,		/* 3 */
+/* 16 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 30 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 40 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_attributes */
+
+/* 42 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 48 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 50 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 54 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 56 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x5,		/* 5 */
+/* 58 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 60 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 66 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 72 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 76 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 78 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 82 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter textAttributes */
+
+/* 84 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 86 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 88 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 90 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 92 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 94 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_caretOffset */
+
+/* 96 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 98 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 102 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 104 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 108 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 110 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 112 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 114 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 120 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 122 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 124 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 128 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 130 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_characterExtents */
+
+/* 132 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 138 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 140 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
+/* 142 */	NdrFcShort( 0xe ),	/* 14 */
+/* 144 */	NdrFcShort( 0x78 ),	/* 120 */
+/* 146 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x7,		/* 7 */
+/* 148 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 154 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 158 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 160 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter coordType */
+
+/* 162 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 164 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 166 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter x */
+
+/* 168 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 170 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 172 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 174 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 176 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 178 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter width */
+
+/* 180 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 182 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 184 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter height */
+
+/* 186 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 188 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 190 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 194 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
+/* 196 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nSelections */
+
+/* 198 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 204 */	NdrFcShort( 0x7 ),	/* 7 */
+/* 206 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 208 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 210 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 212 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 214 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 216 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nSelections */
+
+/* 222 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 224 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 226 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 230 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 232 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_offsetAtPoint */
+
+/* 234 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 236 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 240 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 242 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 244 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 246 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 248 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x5,		/* 5 */
+/* 250 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 252 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 254 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter x */
+
+/* 258 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 260 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 262 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 264 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 266 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 268 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter coordType */
+
+/* 270 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 272 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 274 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter offset */
+
+/* 276 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 278 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 280 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 282 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 284 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 286 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_selection */
+
+/* 288 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 290 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 294 */	NdrFcShort( 0x9 ),	/* 9 */
+/* 296 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 298 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 300 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 302 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 304 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 306 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 308 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 310 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectionIndex */
+
+/* 312 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 314 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 316 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 318 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 320 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 322 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 324 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 326 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 328 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 330 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 332 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 334 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_text */
+
+/* 336 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 342 */	NdrFcShort( 0xa ),	/* 10 */
+/* 344 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 346 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 348 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 350 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x4,		/* 4 */
+/* 352 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 354 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startOffset */
+
+/* 360 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 362 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 364 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 366 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 368 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 370 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 372 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 374 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 376 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 380 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 382 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_textBeforeOffset */
+
+/* 384 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 386 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 390 */	NdrFcShort( 0xb ),	/* 11 */
+/* 392 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
+/* 394 */	NdrFcShort( 0xe ),	/* 14 */
+/* 396 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 398 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x6,		/* 6 */
+/* 400 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 402 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 404 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 406 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 410 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 412 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter boundaryType */
+
+/* 414 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 416 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 418 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 420 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 424 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 426 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 428 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 430 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 432 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 434 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 436 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 438 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 440 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 442 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_textAfterOffset */
+
+/* 444 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 446 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 450 */	NdrFcShort( 0xc ),	/* 12 */
+/* 452 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
+/* 454 */	NdrFcShort( 0xe ),	/* 14 */
+/* 456 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 458 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x6,		/* 6 */
+/* 460 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 462 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 464 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 468 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 470 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 472 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter boundaryType */
+
+/* 474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 476 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 478 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 480 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 482 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 484 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 486 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 488 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 490 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 492 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 494 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 496 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 498 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 500 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 502 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_textAtOffset */
+
+/* 504 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 506 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 510 */	NdrFcShort( 0xd ),	/* 13 */
+/* 512 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
+/* 514 */	NdrFcShort( 0xe ),	/* 14 */
+/* 516 */	NdrFcShort( 0x40 ),	/* 64 */
+/* 518 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x6,		/* 6 */
+/* 520 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 522 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 526 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 528 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 530 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 532 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter boundaryType */
+
+/* 534 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 536 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 538 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 540 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 542 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 544 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 546 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 548 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 550 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter text */
+
+/* 552 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
+/* 554 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 556 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */
+
+	/* Return value */
+
+/* 558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 560 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 562 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure removeSelection */
+
+/* 564 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 566 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 570 */	NdrFcShort( 0xe ),	/* 14 */
+/* 572 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 578 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 580 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 584 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectionIndex */
+
+/* 588 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 590 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 592 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 594 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 596 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 598 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure setCaretOffset */
+
+/* 600 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 602 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 606 */	NdrFcShort( 0xf ),	/* 15 */
+/* 608 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 612 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 614 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 616 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 618 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 622 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter offset */
+
+/* 624 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 626 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 628 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 630 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 632 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 634 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure setSelection */
+
+/* 636 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 638 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 642 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 644 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 646 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 648 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 650 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 652 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 654 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 656 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter selectionIndex */
+
+/* 660 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 662 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 664 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter startOffset */
+
+/* 666 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 668 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 670 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endOffset */
+
+/* 672 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 674 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 676 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 678 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 680 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 682 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_nCharacters */
+
+/* 684 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 686 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 690 */	NdrFcShort( 0x11 ),	/* 17 */
+/* 692 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 696 */	NdrFcShort( 0x24 ),	/* 36 */
+/* 698 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x2,		/* 2 */
+/* 700 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 702 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 704 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 706 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter nCharacters */
+
+/* 708 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
+/* 710 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 712 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 714 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 716 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 718 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure scrollSubstringTo */
+
+/* 720 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 722 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 726 */	NdrFcShort( 0x12 ),	/* 18 */
+/* 728 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 730 */	NdrFcShort( 0x16 ),	/* 22 */
+/* 732 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 734 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x4,		/* 4 */
+/* 736 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 738 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 742 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startIndex */
+
+/* 744 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 746 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 748 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endIndex */
+
+/* 750 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 752 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 754 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter scrollType */
+
+/* 756 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 758 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 760 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 762 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 764 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 766 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure scrollSubstringToPoint */
+
+/* 768 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 770 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 774 */	NdrFcShort( 0x13 ),	/* 19 */
+/* 776 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
+/* 778 */	NdrFcShort( 0x26 ),	/* 38 */
+/* 780 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 782 */	0x44,		/* Oi2 Flags:  has return, has ext, */
+			0x6,		/* 6 */
+/* 784 */	0x8,		/* 8 */
+			0x1,		/* Ext Flags:  new corr desc, */
+/* 786 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 788 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 790 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter startIndex */
+
+/* 792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 794 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 796 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter endIndex */
+
+/* 798 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 800 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 802 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter coordinateType */
+
+/* 804 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 806 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 808 */	0xd,		/* FC_ENUM16 */
+			0x0,		/* 0 */
+
+	/* Parameter x */
+
+/* 810 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 812 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
+/* 814 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Parameter y */
+
+/* 816 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
+/* 818 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 820 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Return value */
+
+/* 822 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 824 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 826 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_newText */
+
+/* 828 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 830 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 834 */	NdrFcShort( 0x14 ),	/* 20 */
+/* 836 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 838 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 840 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 842 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 844 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 846 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 848 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 850 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter newText */
+
+/* 852 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 854 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 856 */	NdrFcShort( 0x32 ),	/* Type Offset=50 */
+
+	/* Return value */
+
+/* 858 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 860 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 862 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_oldText */
+
+/* 864 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 866 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 870 */	NdrFcShort( 0x15 ),	/* 21 */
+/* 872 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 874 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 876 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 878 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 880 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 882 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 884 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 886 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter oldText */
+
+/* 888 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 890 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 892 */	NdrFcShort( 0x32 ),	/* Type Offset=50 */
+
+	/* Return value */
+
+/* 894 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 896 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 898 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleText_MIDL_TYPE_FORMAT_STRING AccessibleText__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
+/*  4 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/*  6 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  8 */	NdrFcShort( 0x1c ),	/* Offset= 28 (36) */
+/* 10 */	
+			0x13, 0x0,	/* FC_OP */
+/* 12 */	NdrFcShort( 0xe ),	/* Offset= 14 (26) */
+/* 14 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 16 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 18 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 20 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 22 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 24 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 26 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 28 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 30 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (14) */
+/* 32 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 34 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 36 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 40 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 42 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 44 */	NdrFcShort( 0xffde ),	/* Offset= -34 (10) */
+/* 46 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/* 48 */	NdrFcShort( 0x2 ),	/* Offset= 2 (50) */
+/* 50 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 52 */	NdrFcShort( 0xc ),	/* 12 */
+/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x0 ),	/* Offset= 0 (56) */
+/* 58 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 60 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (36) */
+/* 62 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 64 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            BSTR_UserSize
+            ,BSTR_UserMarshal
+            ,BSTR_UserUnmarshal
+            ,BSTR_UserFree
+            }
+
+        };
+
+
+
+/* Standard interface: __MIDL_itf_AccessibleText_0000_0000, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleText, ver. 0.0,
+   GUID={0x24FD2FFB,0x3AAD,0x4a08,{0x83,0x35,0xA3,0xAD,0x89,0xC0,0xFB,0x4B}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleText_FormatStringOffsetTable[] =
+    {
+    0,
+    42,
+    96,
+    132,
+    198,
+    234,
+    288,
+    336,
+    384,
+    444,
+    504,
+    564,
+    600,
+    636,
+    684,
+    720,
+    768,
+    828,
+    864
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleText_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleText__MIDL_ProcFormatString.Format,
+    &IAccessibleText_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleText_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleText__MIDL_ProcFormatString.Format,
+    &IAccessibleText_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(22) _IAccessibleTextProxyVtbl = 
+{
+    &IAccessibleText_ProxyInfo,
+    &IID_IAccessibleText,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::addSelection */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_attributes */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_caretOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_characterExtents */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_nSelections */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_offsetAtPoint */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_selection */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_text */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_textBeforeOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_textAfterOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_textAtOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::removeSelection */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::setCaretOffset */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::setSelection */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_nCharacters */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::scrollSubstringTo */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::scrollSubstringToPoint */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_newText */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleText::get_oldText */
+};
+
+const CInterfaceStubVtbl _IAccessibleTextStubVtbl =
+{
+    &IID_IAccessibleText,
+    &IAccessibleText_ServerInfo,
+    22,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleText__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleText_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleTextProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleText_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleTextStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleText_InterfaceNamesList[] = 
+{
+    "IAccessibleText",
+    0
+};
+
+
+#define _AccessibleText_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleText, pIID, n)
+
+int __stdcall _AccessibleText_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleText_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleText_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleText_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleText_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleText_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleText_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleValue.h b/src/3rdparty/iaccessible2/generated/x86/AccessibleValue.h
new file mode 100644
index 0000000..6ef70c2
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleValue.h
@@ -0,0 +1,188 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleValue.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __AccessibleValue_h__
+#define __AccessibleValue_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAccessibleValue_FWD_DEFINED__
+#define __IAccessibleValue_FWD_DEFINED__
+typedef interface IAccessibleValue IAccessibleValue;
+#endif 	/* __IAccessibleValue_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oaidl.h"
+#include "oleacc.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#ifndef __IAccessibleValue_INTERFACE_DEFINED__
+#define __IAccessibleValue_INTERFACE_DEFINED__
+
+/* interface IAccessibleValue */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAccessibleValue;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("35855B5B-C566-4fd0-A7B1-E65465600394")
+    IAccessibleValue : public IUnknown
+    {
+    public:
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_currentValue( 
+            /* [retval][out] */ VARIANT *currentValue) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE setCurrentValue( 
+            /* [in] */ VARIANT value) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_maximumValue( 
+            /* [retval][out] */ VARIANT *maximumValue) = 0;
+        
+        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_minimumValue( 
+            /* [retval][out] */ VARIANT *minimumValue) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAccessibleValueVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAccessibleValue * This,
+            /* [in] */ REFIID riid,
+            /* [annotation][iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAccessibleValue * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAccessibleValue * This);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_currentValue )( 
+            IAccessibleValue * This,
+            /* [retval][out] */ VARIANT *currentValue);
+        
+        HRESULT ( STDMETHODCALLTYPE *setCurrentValue )( 
+            IAccessibleValue * This,
+            /* [in] */ VARIANT value);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_maximumValue )( 
+            IAccessibleValue * This,
+            /* [retval][out] */ VARIANT *maximumValue);
+        
+        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_minimumValue )( 
+            IAccessibleValue * This,
+            /* [retval][out] */ VARIANT *minimumValue);
+        
+        END_INTERFACE
+    } IAccessibleValueVtbl;
+
+    interface IAccessibleValue
+    {
+        CONST_VTBL struct IAccessibleValueVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAccessibleValue_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAccessibleValue_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAccessibleValue_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAccessibleValue_get_currentValue(This,currentValue)	\
+    ( (This)->lpVtbl -> get_currentValue(This,currentValue) ) 
+
+#define IAccessibleValue_setCurrentValue(This,value)	\
+    ( (This)->lpVtbl -> setCurrentValue(This,value) ) 
+
+#define IAccessibleValue_get_maximumValue(This,maximumValue)	\
+    ( (This)->lpVtbl -> get_maximumValue(This,maximumValue) ) 
+
+#define IAccessibleValue_get_minimumValue(This,minimumValue)	\
+    ( (This)->lpVtbl -> get_minimumValue(This,minimumValue) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAccessibleValue_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
+unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
+unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
+void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleValue_i.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleValue_i.c
new file mode 100644
index 0000000..dffdb12
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleValue_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleValue.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, IID_IAccessibleValue,0x35855B5B,0xC566,0x4fd0,0xA7,0xB1,0xE6,0x54,0x65,0x60,0x03,0x94);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/AccessibleValue_p.c b/src/3rdparty/iaccessible2/generated/x86/AccessibleValue_p.c
new file mode 100644
index 0000000..166e214
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/AccessibleValue_p.c
@@ -0,0 +1,1105 @@
+
+
+/* this ALWAYS GENERATED file contains the proxy stub code */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:55 2012
+ */
+/* Compiler settings for AccessibleValue.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#if !defined(_M_IA64) && !defined(_M_AMD64)
+
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+#if _MSC_VER >= 1200
+#pragma warning(push)
+#endif
+
+#pragma warning( disable: 4211 )  /* redefine extern to static */
+#pragma warning( disable: 4232 )  /* dllimport identity*/
+#pragma warning( disable: 4024 )  /* array to pointer mapping*/
+#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
+#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
+
+#pragma optimize("", off ) 
+
+#define USE_STUBLESS_PROXY
+
+
+/* verify that the <rpcproxy.h> version is high enough to compile this file*/
+#ifndef __REDQ_RPCPROXY_H_VERSION__
+#define __REQUIRED_RPCPROXY_H_VERSION__ 475
+#endif
+
+
+#include "rpcproxy.h"
+#ifndef __RPCPROXY_H_VERSION__
+#error this stub requires an updated version of <rpcproxy.h>
+#endif /* __RPCPROXY_H_VERSION__ */
+
+
+#include "AccessibleValue.h"
+
+#define TYPE_FORMAT_STRING_SIZE   1053                              
+#define PROC_FORMAT_STRING_SIZE   145                               
+#define EXPR_FORMAT_STRING_SIZE   1                                 
+#define TRANSMIT_AS_TABLE_SIZE    0            
+#define WIRE_MARSHAL_TABLE_SIZE   1            
+
+typedef struct _AccessibleValue_MIDL_TYPE_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
+    } AccessibleValue_MIDL_TYPE_FORMAT_STRING;
+
+typedef struct _AccessibleValue_MIDL_PROC_FORMAT_STRING
+    {
+    short          Pad;
+    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
+    } AccessibleValue_MIDL_PROC_FORMAT_STRING;
+
+typedef struct _AccessibleValue_MIDL_EXPR_FORMAT_STRING
+    {
+    long          Pad;
+    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
+    } AccessibleValue_MIDL_EXPR_FORMAT_STRING;
+
+
+static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
+{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
+
+
+extern const AccessibleValue_MIDL_TYPE_FORMAT_STRING AccessibleValue__MIDL_TypeFormatString;
+extern const AccessibleValue_MIDL_PROC_FORMAT_STRING AccessibleValue__MIDL_ProcFormatString;
+extern const AccessibleValue_MIDL_EXPR_FORMAT_STRING AccessibleValue__MIDL_ExprFormatString;
+
+
+extern const MIDL_STUB_DESC Object_StubDesc;
+
+
+extern const MIDL_SERVER_INFO IAccessibleValue_ServerInfo;
+extern const MIDL_STUBLESS_PROXY_INFO IAccessibleValue_ProxyInfo;
+
+
+extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];
+
+#if !defined(__RPC_WIN32__)
+#error  Invalid build platform for this stub.
+#endif
+
+#if !(TARGET_IS_NT50_OR_LATER)
+#error You need Windows 2000 or later to run this stub because it uses these features:
+#error   /robust command line switch.
+#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
+#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
+#endif
+
+
+static const AccessibleValue_MIDL_PROC_FORMAT_STRING AccessibleValue__MIDL_ProcFormatString =
+    {
+        0,
+        {
+
+	/* Procedure get_currentValue */
+
+			0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
+/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
+/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 16 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter currentValue */
+
+/* 24 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 28 */	NdrFcShort( 0x404 ),	/* Type Offset=1028 */
+
+	/* Return value */
+
+/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 34 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure setCurrentValue */
+
+/* 36 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 44 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
+/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 50 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 52 */	0x8,		/* 8 */
+			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
+/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 56 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter value */
+
+/* 60 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
+/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 64 */	NdrFcShort( 0x412 ),	/* Type Offset=1042 */
+
+	/* Return value */
+
+/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 68 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
+/* 70 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_maximumValue */
+
+/* 72 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 78 */	NdrFcShort( 0x5 ),	/* 5 */
+/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 86 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 88 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 90 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter maximumValue */
+
+/* 96 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 100 */	NdrFcShort( 0x404 ),	/* Type Offset=1028 */
+
+	/* Return value */
+
+/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 106 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+	/* Procedure get_minimumValue */
+
+/* 108 */	0x33,		/* FC_AUTO_HANDLE */
+			0x6c,		/* Old Flags:  object, Oi2 */
+/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 114 */	NdrFcShort( 0x6 ),	/* 6 */
+/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
+/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 120 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 122 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
+			0x2,		/* 2 */
+/* 124 */	0x8,		/* 8 */
+			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
+/* 126 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 130 */	NdrFcShort( 0x0 ),	/* 0 */
+
+	/* Parameter minimumValue */
+
+/* 132 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
+/* 134 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
+/* 136 */	NdrFcShort( 0x404 ),	/* Type Offset=1028 */
+
+	/* Return value */
+
+/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
+/* 140 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
+/* 142 */	0x8,		/* FC_LONG */
+			0x0,		/* 0 */
+
+			0x0
+        }
+    };
+
+static const AccessibleValue_MIDL_TYPE_FORMAT_STRING AccessibleValue__MIDL_TypeFormatString =
+    {
+        0,
+        {
+			NdrFcShort( 0x0 ),	/* 0 */
+/*  2 */	
+			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
+/*  4 */	NdrFcShort( 0x400 ),	/* Offset= 1024 (1028) */
+/*  6 */	
+			0x13, 0x0,	/* FC_OP */
+/*  8 */	NdrFcShort( 0x3e8 ),	/* Offset= 1000 (1008) */
+/* 10 */	
+			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
+			0x9,		/* FC_ULONG */
+/* 12 */	0x7,		/* Corr desc: FC_USHORT */
+			0x0,		/*  */
+/* 14 */	NdrFcShort( 0xfff8 ),	/* -8 */
+/* 16 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 18 */	NdrFcShort( 0x2 ),	/* Offset= 2 (20) */
+/* 20 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 22 */	NdrFcShort( 0x2f ),	/* 47 */
+/* 24 */	NdrFcLong( 0x14 ),	/* 20 */
+/* 28 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
+/* 30 */	NdrFcLong( 0x3 ),	/* 3 */
+/* 34 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 36 */	NdrFcLong( 0x11 ),	/* 17 */
+/* 40 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
+/* 42 */	NdrFcLong( 0x2 ),	/* 2 */
+/* 46 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 48 */	NdrFcLong( 0x4 ),	/* 4 */
+/* 52 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
+/* 54 */	NdrFcLong( 0x5 ),	/* 5 */
+/* 58 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
+/* 60 */	NdrFcLong( 0xb ),	/* 11 */
+/* 64 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 66 */	NdrFcLong( 0xa ),	/* 10 */
+/* 70 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 72 */	NdrFcLong( 0x6 ),	/* 6 */
+/* 76 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (308) */
+/* 78 */	NdrFcLong( 0x7 ),	/* 7 */
+/* 82 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
+/* 84 */	NdrFcLong( 0x8 ),	/* 8 */
+/* 88 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (314) */
+/* 90 */	NdrFcLong( 0xd ),	/* 13 */
+/* 94 */	NdrFcShort( 0xf6 ),	/* Offset= 246 (340) */
+/* 96 */	NdrFcLong( 0x9 ),	/* 9 */
+/* 100 */	NdrFcShort( 0x102 ),	/* Offset= 258 (358) */
+/* 102 */	NdrFcLong( 0x2000 ),	/* 8192 */
+/* 106 */	NdrFcShort( 0x10e ),	/* Offset= 270 (376) */
+/* 108 */	NdrFcLong( 0x24 ),	/* 36 */
+/* 112 */	NdrFcShort( 0x336 ),	/* Offset= 822 (934) */
+/* 114 */	NdrFcLong( 0x4024 ),	/* 16420 */
+/* 118 */	NdrFcShort( 0x330 ),	/* Offset= 816 (934) */
+/* 120 */	NdrFcLong( 0x4011 ),	/* 16401 */
+/* 124 */	NdrFcShort( 0x32e ),	/* Offset= 814 (938) */
+/* 126 */	NdrFcLong( 0x4002 ),	/* 16386 */
+/* 130 */	NdrFcShort( 0x32c ),	/* Offset= 812 (942) */
+/* 132 */	NdrFcLong( 0x4003 ),	/* 16387 */
+/* 136 */	NdrFcShort( 0x32a ),	/* Offset= 810 (946) */
+/* 138 */	NdrFcLong( 0x4014 ),	/* 16404 */
+/* 142 */	NdrFcShort( 0x328 ),	/* Offset= 808 (950) */
+/* 144 */	NdrFcLong( 0x4004 ),	/* 16388 */
+/* 148 */	NdrFcShort( 0x326 ),	/* Offset= 806 (954) */
+/* 150 */	NdrFcLong( 0x4005 ),	/* 16389 */
+/* 154 */	NdrFcShort( 0x324 ),	/* Offset= 804 (958) */
+/* 156 */	NdrFcLong( 0x400b ),	/* 16395 */
+/* 160 */	NdrFcShort( 0x30e ),	/* Offset= 782 (942) */
+/* 162 */	NdrFcLong( 0x400a ),	/* 16394 */
+/* 166 */	NdrFcShort( 0x30c ),	/* Offset= 780 (946) */
+/* 168 */	NdrFcLong( 0x4006 ),	/* 16390 */
+/* 172 */	NdrFcShort( 0x316 ),	/* Offset= 790 (962) */
+/* 174 */	NdrFcLong( 0x4007 ),	/* 16391 */
+/* 178 */	NdrFcShort( 0x30c ),	/* Offset= 780 (958) */
+/* 180 */	NdrFcLong( 0x4008 ),	/* 16392 */
+/* 184 */	NdrFcShort( 0x30e ),	/* Offset= 782 (966) */
+/* 186 */	NdrFcLong( 0x400d ),	/* 16397 */
+/* 190 */	NdrFcShort( 0x30c ),	/* Offset= 780 (970) */
+/* 192 */	NdrFcLong( 0x4009 ),	/* 16393 */
+/* 196 */	NdrFcShort( 0x30a ),	/* Offset= 778 (974) */
+/* 198 */	NdrFcLong( 0x6000 ),	/* 24576 */
+/* 202 */	NdrFcShort( 0x308 ),	/* Offset= 776 (978) */
+/* 204 */	NdrFcLong( 0x400c ),	/* 16396 */
+/* 208 */	NdrFcShort( 0x306 ),	/* Offset= 774 (982) */
+/* 210 */	NdrFcLong( 0x10 ),	/* 16 */
+/* 214 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
+/* 216 */	NdrFcLong( 0x12 ),	/* 18 */
+/* 220 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
+/* 222 */	NdrFcLong( 0x13 ),	/* 19 */
+/* 226 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 228 */	NdrFcLong( 0x15 ),	/* 21 */
+/* 232 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
+/* 234 */	NdrFcLong( 0x16 ),	/* 22 */
+/* 238 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 240 */	NdrFcLong( 0x17 ),	/* 23 */
+/* 244 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
+/* 246 */	NdrFcLong( 0xe ),	/* 14 */
+/* 250 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (990) */
+/* 252 */	NdrFcLong( 0x400e ),	/* 16398 */
+/* 256 */	NdrFcShort( 0x2e8 ),	/* Offset= 744 (1000) */
+/* 258 */	NdrFcLong( 0x4010 ),	/* 16400 */
+/* 262 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (1004) */
+/* 264 */	NdrFcLong( 0x4012 ),	/* 16402 */
+/* 268 */	NdrFcShort( 0x2a2 ),	/* Offset= 674 (942) */
+/* 270 */	NdrFcLong( 0x4013 ),	/* 16403 */
+/* 274 */	NdrFcShort( 0x2a0 ),	/* Offset= 672 (946) */
+/* 276 */	NdrFcLong( 0x4015 ),	/* 16405 */
+/* 280 */	NdrFcShort( 0x29e ),	/* Offset= 670 (950) */
+/* 282 */	NdrFcLong( 0x4016 ),	/* 16406 */
+/* 286 */	NdrFcShort( 0x294 ),	/* Offset= 660 (946) */
+/* 288 */	NdrFcLong( 0x4017 ),	/* 16407 */
+/* 292 */	NdrFcShort( 0x28e ),	/* Offset= 654 (946) */
+/* 294 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 298 */	NdrFcShort( 0x0 ),	/* Offset= 0 (298) */
+/* 300 */	NdrFcLong( 0x1 ),	/* 1 */
+/* 304 */	NdrFcShort( 0x0 ),	/* Offset= 0 (304) */
+/* 306 */	NdrFcShort( 0xffff ),	/* Offset= -1 (305) */
+/* 308 */	
+			0x15,		/* FC_STRUCT */
+			0x7,		/* 7 */
+/* 310 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 312 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 314 */	
+			0x13, 0x0,	/* FC_OP */
+/* 316 */	NdrFcShort( 0xe ),	/* Offset= 14 (330) */
+/* 318 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 320 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 322 */	0x9,		/* Corr desc: FC_ULONG */
+			0x0,		/*  */
+/* 324 */	NdrFcShort( 0xfffc ),	/* -4 */
+/* 326 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 328 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 330 */	
+			0x17,		/* FC_CSTRUCT */
+			0x3,		/* 3 */
+/* 332 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 334 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (318) */
+/* 336 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 338 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 340 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 342 */	NdrFcLong( 0x0 ),	/* 0 */
+/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 348 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 350 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 352 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 354 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 356 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 358 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 360 */	NdrFcLong( 0x20400 ),	/* 132096 */
+/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 366 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 368 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 370 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 372 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 374 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 376 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 378 */	NdrFcShort( 0x2 ),	/* Offset= 2 (380) */
+/* 380 */	
+			0x13, 0x0,	/* FC_OP */
+/* 382 */	NdrFcShort( 0x216 ),	/* Offset= 534 (916) */
+/* 384 */	
+			0x2a,		/* FC_ENCAPSULATED_UNION */
+			0x49,		/* 73 */
+/* 386 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 388 */	NdrFcShort( 0xa ),	/* 10 */
+/* 390 */	NdrFcLong( 0x8 ),	/* 8 */
+/* 394 */	NdrFcShort( 0x5a ),	/* Offset= 90 (484) */
+/* 396 */	NdrFcLong( 0xd ),	/* 13 */
+/* 400 */	NdrFcShort( 0x7e ),	/* Offset= 126 (526) */
+/* 402 */	NdrFcLong( 0x9 ),	/* 9 */
+/* 406 */	NdrFcShort( 0x9e ),	/* Offset= 158 (564) */
+/* 408 */	NdrFcLong( 0xc ),	/* 12 */
+/* 412 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (612) */
+/* 414 */	NdrFcLong( 0x24 ),	/* 36 */
+/* 418 */	NdrFcShort( 0x124 ),	/* Offset= 292 (710) */
+/* 420 */	NdrFcLong( 0x800d ),	/* 32781 */
+/* 424 */	NdrFcShort( 0x140 ),	/* Offset= 320 (744) */
+/* 426 */	NdrFcLong( 0x10 ),	/* 16 */
+/* 430 */	NdrFcShort( 0x15a ),	/* Offset= 346 (776) */
+/* 432 */	NdrFcLong( 0x2 ),	/* 2 */
+/* 436 */	NdrFcShort( 0x174 ),	/* Offset= 372 (808) */
+/* 438 */	NdrFcLong( 0x3 ),	/* 3 */
+/* 442 */	NdrFcShort( 0x18e ),	/* Offset= 398 (840) */
+/* 444 */	NdrFcLong( 0x14 ),	/* 20 */
+/* 448 */	NdrFcShort( 0x1a8 ),	/* Offset= 424 (872) */
+/* 450 */	NdrFcShort( 0xffff ),	/* Offset= -1 (449) */
+/* 452 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 454 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 456 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 460 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 462 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 464 */	
+			0x48,		/* FC_VARIABLE_REPEAT */
+			0x49,		/* FC_FIXED_OFFSET */
+/* 466 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 470 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 476 */	0x13, 0x0,	/* FC_OP */
+/* 478 */	NdrFcShort( 0xff6c ),	/* Offset= -148 (330) */
+/* 480 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 482 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 484 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 486 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 488 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 490 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 492 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 494 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 496 */	0x11, 0x0,	/* FC_RP */
+/* 498 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (452) */
+/* 500 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 502 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 504 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 508 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 512 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 514 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 518 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 520 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 522 */	NdrFcShort( 0xff4a ),	/* Offset= -182 (340) */
+/* 524 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 526 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 528 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 532 */	NdrFcShort( 0x6 ),	/* Offset= 6 (538) */
+/* 534 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 536 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 538 */	
+			0x11, 0x0,	/* FC_RP */
+/* 540 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (504) */
+/* 542 */	
+			0x21,		/* FC_BOGUS_ARRAY */
+			0x3,		/* 3 */
+/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 546 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 548 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 550 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 552 */	NdrFcLong( 0xffffffff ),	/* -1 */
+/* 556 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
+/* 558 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 560 */	NdrFcShort( 0xff36 ),	/* Offset= -202 (358) */
+/* 562 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 564 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 566 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 568 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 570 */	NdrFcShort( 0x6 ),	/* Offset= 6 (576) */
+/* 572 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 574 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 576 */	
+			0x11, 0x0,	/* FC_RP */
+/* 578 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (542) */
+/* 580 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 582 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 584 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 588 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 590 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 592 */	
+			0x48,		/* FC_VARIABLE_REPEAT */
+			0x49,		/* FC_FIXED_OFFSET */
+/* 594 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 598 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 604 */	0x13, 0x0,	/* FC_OP */
+/* 606 */	NdrFcShort( 0x192 ),	/* Offset= 402 (1008) */
+/* 608 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 610 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 612 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 614 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 616 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 618 */	NdrFcShort( 0x6 ),	/* Offset= 6 (624) */
+/* 620 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 622 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 624 */	
+			0x11, 0x0,	/* FC_RP */
+/* 626 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (580) */
+/* 628 */	
+			0x2f,		/* FC_IP */
+			0x5a,		/* FC_CONSTANT_IID */
+/* 630 */	NdrFcLong( 0x2f ),	/* 47 */
+/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 636 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 638 */	0xc0,		/* 192 */
+			0x0,		/* 0 */
+/* 640 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 642 */	0x0,		/* 0 */
+			0x0,		/* 0 */
+/* 644 */	0x0,		/* 0 */
+			0x46,		/* 70 */
+/* 646 */	
+			0x1b,		/* FC_CARRAY */
+			0x0,		/* 0 */
+/* 648 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 650 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 652 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 654 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 656 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 658 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 660 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 662 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 664 */	NdrFcShort( 0xa ),	/* Offset= 10 (674) */
+/* 666 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 668 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 670 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (628) */
+/* 672 */	0x36,		/* FC_POINTER */
+			0x5b,		/* FC_END */
+/* 674 */	
+			0x13, 0x0,	/* FC_OP */
+/* 676 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (646) */
+/* 678 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 680 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 682 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 686 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 688 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 690 */	
+			0x48,		/* FC_VARIABLE_REPEAT */
+			0x49,		/* FC_FIXED_OFFSET */
+/* 692 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 696 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 700 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 702 */	0x13, 0x0,	/* FC_OP */
+/* 704 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (658) */
+/* 706 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 708 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 710 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 712 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 716 */	NdrFcShort( 0x6 ),	/* Offset= 6 (722) */
+/* 718 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 720 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 722 */	
+			0x11, 0x0,	/* FC_RP */
+/* 724 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (678) */
+/* 726 */	
+			0x1d,		/* FC_SMFARRAY */
+			0x0,		/* 0 */
+/* 728 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 730 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 732 */	
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 734 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 736 */	0x8,		/* FC_LONG */
+			0x6,		/* FC_SHORT */
+/* 738 */	0x6,		/* FC_SHORT */
+			0x4c,		/* FC_EMBEDDED_COMPLEX */
+/* 740 */	0x0,		/* 0 */
+			NdrFcShort( 0xfff1 ),	/* Offset= -15 (726) */
+			0x5b,		/* FC_END */
+/* 744 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 746 */	NdrFcShort( 0x18 ),	/* 24 */
+/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 750 */	NdrFcShort( 0xa ),	/* Offset= 10 (760) */
+/* 752 */	0x8,		/* FC_LONG */
+			0x36,		/* FC_POINTER */
+/* 754 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 756 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (732) */
+/* 758 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 760 */	
+			0x11, 0x0,	/* FC_RP */
+/* 762 */	NdrFcShort( 0xfefe ),	/* Offset= -258 (504) */
+/* 764 */	
+			0x1b,		/* FC_CARRAY */
+			0x0,		/* 0 */
+/* 766 */	NdrFcShort( 0x1 ),	/* 1 */
+/* 768 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 772 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 774 */	0x1,		/* FC_BYTE */
+			0x5b,		/* FC_END */
+/* 776 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 778 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 780 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 782 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 784 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 786 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 788 */	0x13, 0x0,	/* FC_OP */
+/* 790 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (764) */
+/* 792 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 794 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 796 */	
+			0x1b,		/* FC_CARRAY */
+			0x1,		/* 1 */
+/* 798 */	NdrFcShort( 0x2 ),	/* 2 */
+/* 800 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 802 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 804 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 806 */	0x6,		/* FC_SHORT */
+			0x5b,		/* FC_END */
+/* 808 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 810 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 812 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 814 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 816 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 818 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 820 */	0x13, 0x0,	/* FC_OP */
+/* 822 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (796) */
+/* 824 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 826 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 828 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 830 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 832 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 834 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 836 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 838 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 840 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 842 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 844 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 846 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 848 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 850 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 852 */	0x13, 0x0,	/* FC_OP */
+/* 854 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (828) */
+/* 856 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 858 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 860 */	
+			0x1b,		/* FC_CARRAY */
+			0x7,		/* 7 */
+/* 862 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 864 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
+			0x0,		/*  */
+/* 866 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 868 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 870 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 872 */	
+			0x16,		/* FC_PSTRUCT */
+			0x3,		/* 3 */
+/* 874 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 876 */	
+			0x4b,		/* FC_PP */
+			0x5c,		/* FC_PAD */
+/* 878 */	
+			0x46,		/* FC_NO_REPEAT */
+			0x5c,		/* FC_PAD */
+/* 880 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 882 */	NdrFcShort( 0x4 ),	/* 4 */
+/* 884 */	0x13, 0x0,	/* FC_OP */
+/* 886 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (860) */
+/* 888 */	
+			0x5b,		/* FC_END */
+
+			0x8,		/* FC_LONG */
+/* 890 */	0x8,		/* FC_LONG */
+			0x5b,		/* FC_END */
+/* 892 */	
+			0x15,		/* FC_STRUCT */
+			0x3,		/* 3 */
+/* 894 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 896 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 898 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 900 */	
+			0x1b,		/* FC_CARRAY */
+			0x3,		/* 3 */
+/* 902 */	NdrFcShort( 0x8 ),	/* 8 */
+/* 904 */	0x7,		/* Corr desc: FC_USHORT */
+			0x0,		/*  */
+/* 906 */	NdrFcShort( 0xffd8 ),	/* -40 */
+/* 908 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
+/* 910 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 912 */	NdrFcShort( 0xffec ),	/* Offset= -20 (892) */
+/* 914 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 916 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x3,		/* 3 */
+/* 918 */	NdrFcShort( 0x28 ),	/* 40 */
+/* 920 */	NdrFcShort( 0xffec ),	/* Offset= -20 (900) */
+/* 922 */	NdrFcShort( 0x0 ),	/* Offset= 0 (922) */
+/* 924 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 926 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 928 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 930 */	NdrFcShort( 0xfdde ),	/* Offset= -546 (384) */
+/* 932 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 934 */	
+			0x13, 0x0,	/* FC_OP */
+/* 936 */	NdrFcShort( 0xfeea ),	/* Offset= -278 (658) */
+/* 938 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 940 */	0x1,		/* FC_BYTE */
+			0x5c,		/* FC_PAD */
+/* 942 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 944 */	0x6,		/* FC_SHORT */
+			0x5c,		/* FC_PAD */
+/* 946 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 948 */	0x8,		/* FC_LONG */
+			0x5c,		/* FC_PAD */
+/* 950 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 952 */	0xb,		/* FC_HYPER */
+			0x5c,		/* FC_PAD */
+/* 954 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 956 */	0xa,		/* FC_FLOAT */
+			0x5c,		/* FC_PAD */
+/* 958 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 960 */	0xc,		/* FC_DOUBLE */
+			0x5c,		/* FC_PAD */
+/* 962 */	
+			0x13, 0x0,	/* FC_OP */
+/* 964 */	NdrFcShort( 0xfd70 ),	/* Offset= -656 (308) */
+/* 966 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 968 */	NdrFcShort( 0xfd72 ),	/* Offset= -654 (314) */
+/* 970 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 972 */	NdrFcShort( 0xfd88 ),	/* Offset= -632 (340) */
+/* 974 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 976 */	NdrFcShort( 0xfd96 ),	/* Offset= -618 (358) */
+/* 978 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 980 */	NdrFcShort( 0xfda4 ),	/* Offset= -604 (376) */
+/* 982 */	
+			0x13, 0x10,	/* FC_OP [pointer_deref] */
+/* 984 */	NdrFcShort( 0x2 ),	/* Offset= 2 (986) */
+/* 986 */	
+			0x13, 0x0,	/* FC_OP */
+/* 988 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1008) */
+/* 990 */	
+			0x15,		/* FC_STRUCT */
+			0x7,		/* 7 */
+/* 992 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 994 */	0x6,		/* FC_SHORT */
+			0x1,		/* FC_BYTE */
+/* 996 */	0x1,		/* FC_BYTE */
+			0x8,		/* FC_LONG */
+/* 998 */	0xb,		/* FC_HYPER */
+			0x5b,		/* FC_END */
+/* 1000 */	
+			0x13, 0x0,	/* FC_OP */
+/* 1002 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (990) */
+/* 1004 */	
+			0x13, 0x8,	/* FC_OP [simple_pointer] */
+/* 1006 */	0x2,		/* FC_CHAR */
+			0x5c,		/* FC_PAD */
+/* 1008 */	
+			0x1a,		/* FC_BOGUS_STRUCT */
+			0x7,		/* 7 */
+/* 1010 */	NdrFcShort( 0x20 ),	/* 32 */
+/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1014 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1014) */
+/* 1016 */	0x8,		/* FC_LONG */
+			0x8,		/* FC_LONG */
+/* 1018 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 1020 */	0x6,		/* FC_SHORT */
+			0x6,		/* FC_SHORT */
+/* 1022 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
+			0x0,		/* 0 */
+/* 1024 */	NdrFcShort( 0xfc0a ),	/* Offset= -1014 (10) */
+/* 1026 */	0x5c,		/* FC_PAD */
+			0x5b,		/* FC_END */
+/* 1028 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 1030 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1032 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 1034 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1036 */	NdrFcShort( 0xfbfa ),	/* Offset= -1030 (6) */
+/* 1038 */	
+			0x12, 0x0,	/* FC_UP */
+/* 1040 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (1008) */
+/* 1042 */	0xb4,		/* FC_USER_MARSHAL */
+			0x83,		/* 131 */
+/* 1044 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1046 */	NdrFcShort( 0x10 ),	/* 16 */
+/* 1048 */	NdrFcShort( 0x0 ),	/* 0 */
+/* 1050 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (1038) */
+
+			0x0
+        }
+    };
+
+static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
+        {
+            
+            {
+            VARIANT_UserSize
+            ,VARIANT_UserMarshal
+            ,VARIANT_UserUnmarshal
+            ,VARIANT_UserFree
+            }
+
+        };
+
+
+
+/* Object interface: IUnknown, ver. 0.0,
+   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */
+
+
+/* Object interface: IAccessibleValue, ver. 0.0,
+   GUID={0x35855B5B,0xC566,0x4fd0,{0xA7,0xB1,0xE6,0x54,0x65,0x60,0x03,0x94}} */
+
+#pragma code_seg(".orpc")
+static const unsigned short IAccessibleValue_FormatStringOffsetTable[] =
+    {
+    0,
+    36,
+    72,
+    108
+    };
+
+static const MIDL_STUBLESS_PROXY_INFO IAccessibleValue_ProxyInfo =
+    {
+    &Object_StubDesc,
+    AccessibleValue__MIDL_ProcFormatString.Format,
+    &IAccessibleValue_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0
+    };
+
+
+static const MIDL_SERVER_INFO IAccessibleValue_ServerInfo = 
+    {
+    &Object_StubDesc,
+    0,
+    AccessibleValue__MIDL_ProcFormatString.Format,
+    &IAccessibleValue_FormatStringOffsetTable[-3],
+    0,
+    0,
+    0,
+    0};
+CINTERFACE_PROXY_VTABLE(7) _IAccessibleValueProxyVtbl = 
+{
+    &IAccessibleValue_ProxyInfo,
+    &IID_IAccessibleValue,
+    IUnknown_QueryInterface_Proxy,
+    IUnknown_AddRef_Proxy,
+    IUnknown_Release_Proxy ,
+    (void *) (INT_PTR) -1 /* IAccessibleValue::get_currentValue */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleValue::setCurrentValue */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleValue::get_maximumValue */ ,
+    (void *) (INT_PTR) -1 /* IAccessibleValue::get_minimumValue */
+};
+
+const CInterfaceStubVtbl _IAccessibleValueStubVtbl =
+{
+    &IID_IAccessibleValue,
+    &IAccessibleValue_ServerInfo,
+    7,
+    0, /* pure interpreted */
+    CStdStubBuffer_METHODS
+};
+
+static const MIDL_STUB_DESC Object_StubDesc = 
+    {
+    0,
+    NdrOleAllocate,
+    NdrOleFree,
+    0,
+    0,
+    0,
+    0,
+    0,
+    AccessibleValue__MIDL_TypeFormatString.Format,
+    1, /* -error bounds_check flag */
+    0x50002, /* Ndr library version */
+    0,
+    0x700022b, /* MIDL Version 7.0.555 */
+    0,
+    UserMarshalRoutines,
+    0,  /* notify & notify_flag routine table */
+    0x1, /* MIDL flag */
+    0, /* cs routines */
+    0,   /* proxy/server info */
+    0
+    };
+
+const CInterfaceProxyVtbl * const _AccessibleValue_ProxyVtblList[] = 
+{
+    ( CInterfaceProxyVtbl *) &_IAccessibleValueProxyVtbl,
+    0
+};
+
+const CInterfaceStubVtbl * const _AccessibleValue_StubVtblList[] = 
+{
+    ( CInterfaceStubVtbl *) &_IAccessibleValueStubVtbl,
+    0
+};
+
+PCInterfaceName const _AccessibleValue_InterfaceNamesList[] = 
+{
+    "IAccessibleValue",
+    0
+};
+
+
+#define _AccessibleValue_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AccessibleValue, pIID, n)
+
+int __stdcall _AccessibleValue_IID_Lookup( const IID * pIID, int * pIndex )
+{
+    
+    if(!_AccessibleValue_CHECK_IID(0))
+        {
+        *pIndex = 0;
+        return 1;
+        }
+
+    return 0;
+}
+
+const ExtendedProxyFileInfo AccessibleValue_ProxyFileInfo = 
+{
+    (PCInterfaceProxyVtblList *) & _AccessibleValue_ProxyVtblList,
+    (PCInterfaceStubVtblList *) & _AccessibleValue_StubVtblList,
+    (const PCInterfaceName * ) & _AccessibleValue_InterfaceNamesList,
+    0, /* no delegation */
+    & _AccessibleValue_IID_Lookup, 
+    1,
+    2,
+    0, /* table of [async_uuid] interfaces */
+    0, /* Filler1 */
+    0, /* Filler2 */
+    0  /* Filler3 */
+};
+#pragma optimize("", on )
+#if _MSC_VER >= 1200
+#pragma warning(pop)
+#endif
+
+
+#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/IA2CommonTypes.h b/src/3rdparty/iaccessible2/generated/x86/IA2CommonTypes.h
new file mode 100644
index 0000000..7d1df60
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/IA2CommonTypes.h
@@ -0,0 +1,102 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for IA2CommonTypes.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __IA2CommonTypes_h__
+#define __IA2CommonTypes_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_IA2CommonTypes_0000_0000 */
+/* [local] */ 
+
+
+enum IA2ScrollType
+    {	IA2_SCROLL_TYPE_TOP_LEFT	= 0,
+	IA2_SCROLL_TYPE_BOTTOM_RIGHT	= ( IA2_SCROLL_TYPE_TOP_LEFT + 1 ) ,
+	IA2_SCROLL_TYPE_TOP_EDGE	= ( IA2_SCROLL_TYPE_BOTTOM_RIGHT + 1 ) ,
+	IA2_SCROLL_TYPE_BOTTOM_EDGE	= ( IA2_SCROLL_TYPE_TOP_EDGE + 1 ) ,
+	IA2_SCROLL_TYPE_LEFT_EDGE	= ( IA2_SCROLL_TYPE_BOTTOM_EDGE + 1 ) ,
+	IA2_SCROLL_TYPE_RIGHT_EDGE	= ( IA2_SCROLL_TYPE_LEFT_EDGE + 1 ) ,
+	IA2_SCROLL_TYPE_ANYWHERE	= ( IA2_SCROLL_TYPE_RIGHT_EDGE + 1 ) 
+    } ;
+
+enum IA2CoordinateType
+    {	IA2_COORDTYPE_SCREEN_RELATIVE	= 0,
+	IA2_COORDTYPE_PARENT_RELATIVE	= ( IA2_COORDTYPE_SCREEN_RELATIVE + 1 ) 
+    } ;
+
+enum IA2TextSpecialOffsets
+    {	IA2_TEXT_OFFSET_LENGTH	= -1,
+	IA2_TEXT_OFFSET_CARET	= -2
+    } ;
+
+enum IA2TableModelChangeType
+    {	IA2_TABLE_MODEL_CHANGE_INSERT	= 0,
+	IA2_TABLE_MODEL_CHANGE_DELETE	= ( IA2_TABLE_MODEL_CHANGE_INSERT + 1 ) ,
+	IA2_TABLE_MODEL_CHANGE_UPDATE	= ( IA2_TABLE_MODEL_CHANGE_DELETE + 1 ) 
+    } ;
+typedef struct IA2TableModelChange
+    {
+    enum IA2TableModelChangeType type;
+    long firstRow;
+    long lastRow;
+    long firstColumn;
+    long lastColumn;
+    } 	IA2TableModelChange;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_IA2CommonTypes_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_IA2CommonTypes_0000_0000_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary.h b/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary.h
new file mode 100644
index 0000000..e80b272
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary.h
@@ -0,0 +1,103 @@
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for IA2TypeLibrary.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+
+#ifndef __IA2TypeLibrary_h__
+#define __IA2TypeLibrary_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_IA2TypeLibrary_0000_0000 */
+/* [local] */ 
+
+
+// Type Library Definitions
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_IA2TypeLibrary_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_IA2TypeLibrary_0000_0000_v0_0_s_ifspec;
+
+
+#ifndef __IAccessible2Lib_LIBRARY_DEFINED__
+#define __IAccessible2Lib_LIBRARY_DEFINED__
+
+/* library IAccessible2Lib */
+/* [hidden][version][helpstring][uuid] */ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+EXTERN_C const IID LIBID_IAccessible2Lib;
+#endif /* __IAccessible2Lib_LIBRARY_DEFINED__ */
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary.tlb b/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary.tlb
new file mode 100644
index 0000000..b4c56c7
Binary files /dev/null and b/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary.tlb differ
diff --git a/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary_i.c b/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary_i.c
new file mode 100644
index 0000000..1bf9d51
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/IA2TypeLibrary_i.c
@@ -0,0 +1,79 @@
+
+
+/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
+
+/* link this file in with the server and any clients */
+
+
+ /* File created by MIDL compiler version 7.00.0555 */
+/* at Thu Mar 08 14:53:56 2012
+ */
+/* Compiler settings for IA2TypeLibrary.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+/* @@MIDL_FILE_HEADING(  ) */
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifdef _MIDL_USE_GUIDDEF_
+
+#ifndef INITGUID
+#define INITGUID
+#include <guiddef.h>
+#undef INITGUID
+#else
+#include <guiddef.h>
+#endif
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)
+
+#else // !_MIDL_USE_GUIDDEF_
+
+#ifndef __IID_DEFINED__
+#define __IID_DEFINED__
+
+typedef struct _IID
+{
+    unsigned long x;
+    unsigned short s1;
+    unsigned short s2;
+    unsigned char  c[8];
+} IID;
+
+#endif // __IID_DEFINED__
+
+#ifndef CLSID_DEFINED
+#define CLSID_DEFINED
+typedef IID CLSID;
+#endif // CLSID_DEFINED
+
+#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
+        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+
+#endif !_MIDL_USE_GUIDDEF_
+
+MIDL_DEFINE_GUID(IID, LIBID_IAccessible2Lib,0xc974e070,0x3787,0x490a,0x87,0xb0,0xe3,0x33,0xb0,0x6c,0xa1,0xe2);
+
+#undef MIDL_DEFINE_GUID
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
diff --git a/src/3rdparty/iaccessible2/generated/x86/dlldata.c b/src/3rdparty/iaccessible2/generated/x86/dlldata.c
new file mode 100644
index 0000000..e1e15a1
--- /dev/null
+++ b/src/3rdparty/iaccessible2/generated/x86/dlldata.c
@@ -0,0 +1,64 @@
+/*********************************************************
+   DllData file -- generated by MIDL compiler 
+
+        DO NOT ALTER THIS FILE
+
+   This file is regenerated by MIDL on every IDL file compile.
+
+   To completely reconstruct this file, delete it and rerun MIDL
+   on all the IDL files in this DLL, specifying this file for the
+   /dlldata command line option
+
+*********************************************************/
+
+#define PROXY_DELEGATION
+
+#include <rpcproxy.h>
+
+#ifdef __cplusplus
+extern "C"   {
+#endif
+
+EXTERN_PROXY_FILE( Accessible2 )
+EXTERN_PROXY_FILE( AccessibleAction )
+EXTERN_PROXY_FILE( AccessibleApplication )
+EXTERN_PROXY_FILE( AccessibleComponent )
+EXTERN_PROXY_FILE( AccessibleEditableText )
+EXTERN_PROXY_FILE( AccessibleHyperlink )
+EXTERN_PROXY_FILE( AccessibleHypertext )
+EXTERN_PROXY_FILE( AccessibleImage )
+EXTERN_PROXY_FILE( AccessibleRelation )
+EXTERN_PROXY_FILE( AccessibleTable )
+EXTERN_PROXY_FILE( AccessibleTable2 )
+EXTERN_PROXY_FILE( AccessibleTableCell )
+EXTERN_PROXY_FILE( AccessibleText )
+EXTERN_PROXY_FILE( AccessibleValue )
+
+
+PROXYFILE_LIST_START
+/* Start of list */
+  REFERENCE_PROXY_FILE( Accessible2 ),
+  REFERENCE_PROXY_FILE( AccessibleAction ),
+  REFERENCE_PROXY_FILE( AccessibleApplication ),
+  REFERENCE_PROXY_FILE( AccessibleComponent ),
+  REFERENCE_PROXY_FILE( AccessibleEditableText ),
+  REFERENCE_PROXY_FILE( AccessibleHyperlink ),
+  REFERENCE_PROXY_FILE( AccessibleHypertext ),
+  REFERENCE_PROXY_FILE( AccessibleImage ),
+  REFERENCE_PROXY_FILE( AccessibleRelation ),
+  REFERENCE_PROXY_FILE( AccessibleTable ),
+  REFERENCE_PROXY_FILE( AccessibleTable2 ),
+  REFERENCE_PROXY_FILE( AccessibleTableCell ),
+  REFERENCE_PROXY_FILE( AccessibleText ),
+  REFERENCE_PROXY_FILE( AccessibleValue ),
+/* End of list */
+PROXYFILE_LIST_END
+
+
+DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )
+
+#ifdef __cplusplus
+}  /*extern "C" */
+#endif
+
+/* end of generated dlldata file */
diff --git a/src/3rdparty/iaccessible2/iaccessible2.pri b/src/3rdparty/iaccessible2/iaccessible2.pri
new file mode 100644
index 0000000..f89655a
--- /dev/null
+++ b/src/3rdparty/iaccessible2/iaccessible2.pri
@@ -0,0 +1,88 @@
+
+ARCH_SUBDIR=x86
+contains(QMAKE_TARGET.arch, x86_64): {
+    ARCH_SUBDIR=amd64
+} else {
+    !contains(QMAKE_TARGET.arch, x86): message("ERROR: Could not detect architecture from QMAKE_TARGET.arch")
+}
+
+MIDL_GENERATED = $$PWD/generated/$${ARCH_SUBDIR}
+
+INCLUDEPATH += $$MIDL_GENERATED
+
+SOURCES +=  $${MIDL_GENERATED}/Accessible2_p.c \
+            $${MIDL_GENERATED}/AccessibleAction_p.c \
+            $${MIDL_GENERATED}/AccessibleApplication_p.c \
+            $${MIDL_GENERATED}/AccessibleComponent_p.c \
+            $${MIDL_GENERATED}/AccessibleEditableText_p.c \
+            $${MIDL_GENERATED}/AccessibleHyperlink_p.c \
+            $${MIDL_GENERATED}/AccessibleHypertext_p.c \
+            $${MIDL_GENERATED}/AccessibleImage_p.c \
+            $${MIDL_GENERATED}/AccessibleRelation_p.c \
+            $${MIDL_GENERATED}/AccessibleTable2_p.c \
+            $${MIDL_GENERATED}/AccessibleTableCell_p.c \
+            $${MIDL_GENERATED}/AccessibleTable_p.c \
+            $${MIDL_GENERATED}/AccessibleText_p.c \
+            $${MIDL_GENERATED}/AccessibleValue_p.c
+
+SOURCES +=  $${MIDL_GENERATED}/Accessible2_i.c \
+            $${MIDL_GENERATED}/AccessibleAction_i.c \
+            $${MIDL_GENERATED}/AccessibleApplication_i.c \
+            $${MIDL_GENERATED}/AccessibleComponent_i.c \
+            $${MIDL_GENERATED}/AccessibleEditableText_i.c \
+            $${MIDL_GENERATED}/AccessibleHyperlink_i.c \
+            $${MIDL_GENERATED}/AccessibleHypertext_i.c \
+            $${MIDL_GENERATED}/AccessibleImage_i.c \
+            $${MIDL_GENERATED}/AccessibleRelation_i.c \
+            $${MIDL_GENERATED}/AccessibleTable2_i.c \
+            $${MIDL_GENERATED}/AccessibleTableCell_i.c \
+            $${MIDL_GENERATED}/AccessibleTable_i.c \
+            $${MIDL_GENERATED}/AccessibleText_i.c \
+            $${MIDL_GENERATED}/AccessibleValue_i.c
+
+SOURCES +=  $${MIDL_GENERATED}/IA2TypeLibrary_i.c \
+            $${MIDL_GENERATED}/dlldata.c
+
+HEADERS +=  $${MIDL_GENERATED}/Accessible2.h \
+            $${MIDL_GENERATED}/AccessibleAction.h \
+            $${MIDL_GENERATED}/AccessibleApplication.h \
+            $${MIDL_GENERATED}/AccessibleComponent.h \
+            $${MIDL_GENERATED}/AccessibleEditableText.h \
+            $${MIDL_GENERATED}/AccessibleEventID.h \
+            $${MIDL_GENERATED}/AccessibleHyperlink.h \
+            $${MIDL_GENERATED}/AccessibleHypertext.h \
+            $${MIDL_GENERATED}/AccessibleImage.h \
+            $${MIDL_GENERATED}/AccessibleRelation.h \
+            $${MIDL_GENERATED}/AccessibleRole.h \
+            $${MIDL_GENERATED}/AccessibleStates.h \
+            $${MIDL_GENERATED}/AccessibleTable.h \
+            $${MIDL_GENERATED}/AccessibleTable2.h \
+            $${MIDL_GENERATED}/AccessibleTableCell.h \
+            $${MIDL_GENERATED}/AccessibleText.h \
+            $${MIDL_GENERATED}/AccessibleValue.h \
+            $${MIDL_GENERATED}/IA2CommonTypes.h \
+            $${MIDL_GENERATED}/IA2TypeLibrary.h
+
+
+OTHER_FILES = \
+    $$PWD/idl/Accessible2.idl \
+    $$PWD/idl/AccessibleAction.idl \
+    $$PWD/idl/AccessibleApplication.idl \
+    $$PWD/idl/AccessibleComponent.idl \
+    $$PWD/idl/AccessibleEditableText.idl \
+    $$PWD/idl/AccessibleEventID.idl \
+    $$PWD/idl/AccessibleHyperlink.idl \
+    $$PWD/idl/AccessibleHypertext.idl \
+    $$PWD/idl/AccessibleImage.idl \
+    $$PWD/idl/AccessibleRelation.idl \
+    $$PWD/idl/AccessibleRole.idl \
+    $$PWD/idl/AccessibleStates.idl \
+    $$PWD/idl/AccessibleTable.idl \
+    $$PWD/idl/AccessibleTable2.idl \
+    $$PWD/idl/AccessibleTableCell.idl \
+    $$PWD/idl/AccessibleText.idl \
+    $$PWD/idl/AccessibleValue.idl \
+    $$PWD/idl/IA2CommonTypes.idl \
+    $$PWD/idl/IA2TypeLibrary.idl
+
+LIBS += -lRpcRT4
diff --git a/src/3rdparty/iaccessible2/idl/Accessible2.idl b/src/3rdparty/iaccessible2/idl/Accessible2.idl
new file mode 100644
index 0000000..6a0d750
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/Accessible2.idl
@@ -0,0 +1,679 @@
+/*************************************************************************
+ *
+ *  File Name (Accessible2.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @mainpage
+
+ @section _interfaces Interfaces
+  IAccessible2\n
+  IAccessibleAction\n
+  IAccessibleApplication\n
+  IAccessibleComponent\n
+  IAccessibleHypertext\n
+  IAccessibleHyperlink\n
+  IAccessibleImage\n
+  IAccessibleRelation\n
+  IAccessibleTable [Deprecated]\n
+  IAccessibleTable2\n
+  IAccessibleTableCell\n
+  IAccessibleText\n
+  IAccessibleEditableText\n
+  IAccessibleValue
+
+ @section _structs Structs
+  IA2Locale\n
+  IA2TableModelChange\n
+  IA2TextSegment
+
+ @section _enums Enums
+  ::IA2CoordinateType values define the requested coordinate type (screen or parent window).\n
+  ::IA2EventID values identify events.\n
+  ::IA2Role values defines roles which are in addition to the existing MSAA roles.\n
+  ::IA2ScrollType values define where to place an object or substring on the screen.\n
+  ::IA2States values define states which are in addition to the existing MSAA states.\n
+  ::IA2TableModelChangeType values describe the kinds of changes made to a table (insert, delete, update).\n
+  ::IA2TextBoundaryType values define the requested text unit (character, word, sentence, line, paragraph).\n
+  ::IA2TextSpecialOffsets values define special offsets for use in the text interfaces.
+
+ @section _constants Constants
+  @ref grpRelations
+
+ @section _misc Miscellaneous
+  @ref _licensePage "BSD License"\n
+  @ref _generalInfo "General Information"\n
+
+ @page _licensePage BSD License
+  %IAccessible2 IDL Specification
+
+  Copyright (c) 2007, 2010 Linux Foundation\n
+  Copyright (c) 2006 IBM Corporation\n
+  Copyright (c) 2000, 2006 Sun Microsystems, Inc.\n
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+   2. Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials
+      provided with the distribution.
+
+   3. Neither the name of the Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products
+      derived from this software without specific prior written
+      permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  This BSD License conforms to the Open Source Initiative "Simplified
+  BSD License" as published at:
+  http://www.opensource.org/licenses/bsd-license.php
+
+  %IAccessible2 is a trademark of the Linux Foundation. The %IAccessible2
+  mark may be used in accordance with the
+  <a href="http://www.linuxfoundation.org/collaborate/workgroups/accessibility/trademark-policy">
+  Linux Foundation Trademark Policy</a> to indicate compliance with the %IAccessible2 specification.
+
+ @page _generalInfo General Information
+  The following information is applicable to two or more interfaces.
+
+ @ref _errors\n
+ @ref _memory\n
+ &nbsp;&nbsp;@ref _arrayConsideration\n
+ @ref _indexes\n
+ @ref _enums\n
+ @ref _specialOffsets\n
+ @ref _dicoveringInterfaces\n
+ @ref _changingInterfaces\n
+ @ref _applicationInfo\n
+ @ref _childIDs\n
+ @ref _variants\n
+ @ref _iaaction-iahyperlink\n
+ @ref _trademark
+
+ @section _errors Error Handling
+  HRESULT values are defined by the Microsoft&reg; Win32&reg; API.  For more information, refer to
+  <a href="http://msdn2.microsoft.com/en-us/library/bb401631.aspx">Interpreting HRESULT Values</a>
+  in MSDN&reg;.
+
+  Note that the S_FALSE return value is considered a non-error value and the
+  SUCCEEDED macro will return TRUE.  S_FALSE is used when there is no failure
+  but there was nothing valid to return, e.g. in IAccessible2::attributes when
+  there are no attributes.  When S_FALSE is returned [out] pointer types should
+  be NULL and [out] longs should generally be 0, but sometimes -1 is used such
+  as IAccessible2::indexInParent, IAccessibleText::caretOffset, and
+  IAccessibleHypertext::hyperlinkIndex.
+
+  Note that for BSTR [out] variables common COM practice is that the server does
+  the SysAllocString and the client does the SysFreeString.  Also note that when
+  NULL is returned there is no need for the client to call SysFreeString.  Please
+  refer to the documentation for each method for more details regarding error handling.
+
+ @section _memory Memory Management
+  The following memory management issues should be considered:
+  @li Although [out] BSTR variables are declared by the client, their space is
+   allocated by the server.  They need to be freed with SysFreeString by the
+   client at end of life; the same is true when BSTRs are used in structs or
+   arrays which are passed to the server.
+  @li If there is no valid [out] BSTR to return, the server should return S_FALSE and
+   assign NULL to the output, e.g. *theOutBSTR = NULL;.
+  @li COM interfaces need to be referenced with AddRef when used and dereferenced
+   with Release at end of life.
+  @li Single [out] longs, HWNDs, booleans, and structs are declared by the caller
+   and passed by reference. The marshaller does all the memory management.
+
+  The following articles may be helpful for understanding memory management issues:
+  @li An article by Don Box in a
+   <a href="http://www.microsoft.com/msj/1196/activex1196.aspx">Q & A section</a>
+   of the November 1996 edition of the Microsoft Systems Journal.
+  @li A posting to a CodeGuru forum,
+   <a href="http://www.codeguru.com/forum/showthread.php?t=364511">Windows SDK
+   String: What are the rules for BSTR allocation and deallocation?</a>
+
+ @subsection _arrayConsideration Special Consideration when using Arrays
+  There are several methods which return arrays.  In the case of IAccessible2::relations
+  and IAccessibleRelation::targets the client must allocate and free the arrays.
+
+  For the remaining methods which return arrays, the server must allocate the array
+  and the client must free the array when no longer needed.  These methods are
+  IAccessible2::extendedStates, IAccessible2::localizedExtendedStates,
+  IAccessibleAction::keyBinding, IAccessibleTable2::selectedCells,
+  IAccessibleTable2::selectedColumns, and IAccessibleTable2::selectedRows.  For
+  those methods, the server must allocate both the top level array and any storage
+  associated with it, e.g. for BSTRs.  The server must allocate the arrays with
+  CoTaskMemAlloc and any BSTRs with SysAllocString.  The client must use CoTaskMemFree
+  to free the array and any BSTRs must be freed with SysFreeString.
+
+  Also, the IDL for those six methods includes an extraneous [in] parameter for the
+  caller to specify the max size of the array.  This parameter will be ignored by
+  the COM server.
+
+ @section _indexes Zero and One Based Indexes
+  Unless otherwise specified all offsets and indexes are 0 based.
+
+ @section _enums Enums
+  Note that enums start at 0.
+
+ @section _specialOffsets Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods
+  IAccessibleText and IAccessibleEditableText can use one or more of the following
+  special offset values.  They are defined in the ::IA2TextSpecialOffsets enum.
+  @li Using ::IA2_TEXT_OFFSET_LENGTH (-1) as an offset in any of the IAccessibleText or
+   IAccessibleEditableText methods is the same as specifying the length of the string.
+  @li Using ::IA2_TEXT_OFFSET_CARET (-2) as an offset for IAccessibleText::textBeforeOffset,
+   IAccessibleText::textAtOffset, and IAccessibleText::textAfterOffset indicates that the
+   text related to the physical location of the caret should be used.  This is needed for
+   applications that consider the character offset of the end of one line (as reached by
+   pressing the End key) the same as the offset of the first character on the next line.
+   Since the same offset is associated with two different lines a special means is needed
+   to fetch text from the line where the caret is physically located.
+
+ @section _dicoveringInterfaces Discovery of Interfaces
+  In general AT (Assistive Technology) should try IAccessible2 interfaces, followed by using
+  the MSAA (Microsoft&reg; Active Accessibility&reg;) interfaces.  (In cases where the an application
+  is known to have custom interfaces which provide information not supplied by IAccessible2
+  or MSAA, then those custom interfaces can be used.)  The AT can then, by default, support
+  unknown IAccessible2/MSAA applications, without the application developers having to request
+  AT vendors for support on an individual application by application basis.
+
+  When you have a reference to an IAccessible and require a reference to an IAccessible2 use
+  QueryService as follows:
+  @code
+  // pAcc is a reference to the accessible object's IAccessible interface.
+  IServiceProvider *pService = NULL;
+  hr = pAcc->QueryInterface(IID_IServiceProvider, (void **)&pService);
+  if(SUCCEEDED(hr)) {
+    IAccessible2 *pIA2 = NULL;
+    hr = pService->QueryService(IID_IAccessible, IID_IAccessible2, (void**)&pIA2);
+    if (SUCCEEDED(hr) && pIA2) {
+      // The control supports IAccessible2.
+      // pIA2 is the reference to the accessible object's IAccessible2 interface.
+    }
+  }
+  @endcode
+
+  @section _changingInterfaces Changing between Accessible Interfaces
+  Note that developers must always implement MSAA's IAccessible and, if needed, some
+  of the interfaces in the set of IAccessible2 interfaces.  Although the IAccessible2
+  IDL is coded such that IAccessible2 is a subclass of MSAA's IAccessible, none of
+  MSAA's IAccessible methods are redefined by IAccessible2.
+
+  QueryService must be used to switch from a reference to an MSAA IAccessible interface
+  to another interface.  This has been
+  <a href="http://www.accessinteropalliance.org/docs/Introducing_IAccessibleEx.doc">
+  documented by Microsoft</a> and the pertinent facts have been extracted below:
+
+  @par
+   Why use QueryService instead of just using QueryInterface to get IAccessibleEx
+   directly? The reason is that since MSAA 2.0, clients don't talk to a server's
+   IAccessible interface directly; instead they talk to an intermediate MSAA-provided
+   wrapper that calls through to the original IAccessible. This wrapper provides services
+   such as implementing IDispatch, supplying information from MSAA 2.0's Dynamic Annotation
+   service, and scaling locations when running on Windows Vista with DPI scaling enabled.
+   QueryService is the supported way to expose additional interfaces from an existing
+   IAccessible and was originally used by MSHTML to expose IHTMLElement objects corresponding
+   to IAccessibles. QueryService is often more convenient for servers to implement than
+   QueryInterface because it does not have the same requirements for preserving object
+   identity or symmetry/transitivity as QueryInterface, so QueryService allows servers to
+   easily implement the interface on the same object or a separate object. The latter is
+   often hard to do with QueryInterface unless the original object supports aggregation.
+
+  Two related references in MSDN&reg; are:
+  @li <a href="http://msdn.microsoft.com/en-us/library/ms696078(VS.85).aspx">
+  "Using QueryService to expose a native object model interface for an IAccessible object"</a>
+  @li <a href="http://msdn.microsoft.com/en-us/library/ms528415.aspx#acc_obj">
+  "Accessing the Internet Explorer Object Associated with an Accessible Object"</a>
+
+  Based on this information from Microsoft, QueryService must be used to switch back and forth
+  between a reference to an MSAA IAccessible interface and any of the IAccessible2 interfaces.
+
+  Regarding switching between any of the IAccessible2 interfaces, applications implementing
+  IAccessible2 should implement the IAccessible2 interfaces on a single object since ATs
+  will be using QueryInterface to switch between the IAccessilbe2 interfaces.  Implementing
+  the IAccessible2 interfaces on separate objects would require the use of QueryService.
+  There is one exception, IAccessibleApplication can be implemented on a separate object so
+  its common code doesn't have to be included in each accessible object.  ATs should use
+  QueryService to access IAccessibleApplication.
+
+ @section _applicationInfo Access to Information about the Application
+  Servers implementing IAccessible2 should provide access to the IAccessibleApplication
+  interface via QueryService from any object so that ATs can easily determine specific
+  information about the application such as its name or version.
+
+ @section _childIDs Child IDs
+  The IAccessible2 interfaces do not support child IDs, i.e. simple child elements.
+  Full accessible objects must be created for each object that supports IAccessible2.
+  Therefore MSAA's get_accChild should never return a child ID (other than CHILDID_SELF)
+  for an object that implements any of the IAccessible2 interfaces.
+
+  Microsoft's UI Automation specification has the same limitation and this was resolved
+  in the UI Automation Express specification by adding IAccessibleEx::GetObjectForChild
+  and IAccessibleEx::GetIAccessiblePair.  These methods allow mapping back and forth
+  between an IAccessibleEx and an {IAccessible, Child ID} pair.  A future version of
+  IAccessible2 may include similar methods to map back and forth between an IAccessible2
+  and an {IAccessible, Child ID} pair.
+
+ @section _variants VARIANTs
+  Some methods return a VARIANT.  Implementers need to make sure that the return type is
+  specified, i.e. VT_I4, VT_IDISPATCH, etc.  The methods that return VARIANTs are
+  IAccessibleHyperlink::anchor, IAccessibleHyperlink::anchorTarget, IAccessibleValue::currentValue,
+  IAccessibleValue::maximumValue, IAccessibleValue::minimumValue.
+
+ @section _iaaction-iahyperlink IAccessibleHyperlink as subclass of IAccessibleAction
+  In this version of the IDL, IAccessibleHyperlink is a subclass of IAccessibleAction.
+  However, there is no practical need for that inheritance and in some cases, such as
+  an image map of smart tags, it doesn't make sense because such an image map doesn't
+  have actionable objects; it's the secondary smart tags that are actionable.  As a
+  result, implementations should not rely on the inheritance as it may be removed in
+  a later version of the IDL.
+
+ @section _trademark Trademark Attribution
+  The names of actual companies and products mentioned herein may be the trademarks of
+  their respective owners.  In particular, Active Accessibility, Microsoft, MSDN, and Win32
+  are trademarks of the Microsoft group of companies in the U.S.A. and/or other countries.
+
+**/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "AccessibleRelation.idl";
+import "AccessibleStates.idl";
+import "IA2CommonTypes.idl";
+
+/** A structure defining the locale of an accessible object.
+
+IAccessible2::locale returns this struct.
+*/
+typedef struct IA2Locale {
+  BSTR language; ///< ISO 639-1 Alpha-2 two character language code
+  BSTR country;  ///< ISO 3166-1 Alpha-2 two character country code
+  BSTR variant;  ///< Application specific variant of the locale
+} IA2Locale;
+
+/** @brief This interface exposes the primary set of information about an
+ IAccessible2 enabled accessible object.
+
+ This interface must always be provided for objects that support some
+ portion of the collection of the %IAccessible2 interfaces.
+
+ Please refer to @ref _changingInterfaces "Changing between Accessible Interfaces"
+ for special considerations related to use of the MSAA IAccessible interface and
+ the set of %IAccessible2 interfaces.
+ */
+[object, uuid(E89F726E-C4F4-4c19-BB19-B647D7FA8478)]
+interface IAccessible2 : IAccessible
+{
+
+  /** @brief Returns the number of accessible relations for this object.
+   @param [out] nRelations
+   @retval S_OK
+  */
+  [propget] HRESULT nRelations
+    (
+     [out, retval] long *nRelations
+    );
+
+  /** @brief Returns one accessible relation for this object.
+   @param [in] relationIndex
+     0 based
+   @param [out] relation
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT relation
+    (
+     [in] long relationIndex,
+     [out, retval] IAccessibleRelation **relation
+    );
+
+  /** @brief Returns multiple accessible relations for this object.
+   @param [in] maxRelations
+     maximum size of the array allocated by the client
+   @param [out] relations
+    The array of accessible relation objects.  Note that this array is to be
+    allocated by the client and freed when no longer needed.  Refer to @ref
+    _arrayConsideration "Special Consideration when using Arrays" for more details.
+   @param [out] nRelations
+    actual number of relations in the returned array (not more than maxRelations)
+   @retval S_OK
+   @retval S_FALSE if there are no relations, nRelations is set to 0
+  */
+  [propget] HRESULT relations
+    (
+     [in] long maxRelations,
+     [out, size_is(maxRelations), length_is(*nRelations)]
+       IAccessibleRelation **relations,
+     [out, retval] long *nRelations
+    );
+
+  /** @brief Returns the role of an %IAccessible2 object.
+   @param [out] role
+    The role of an %IAccessible2 object.
+   @retval S_OK
+   @note
+   @li For convenience MSAA roles are also passed through this method so the
+    AT doesn't have to also fetch roles through MSAA's get_accRole.
+   @li %IAccessible2 roles should not be passed through MSAA's get_accRole.
+   @li For compatibility with non IAccessible2 enabled ATs, IAccessible2
+    applications should also add support to get_accRole to return the closest
+    MSAA role or ROLE_SYSTEM_CLIENT (the MSAA defined default role) if there
+    is not a good match.
+   @li This method is missing a [propget] prefix in the IDL.  The result is the
+    method is named role in generated C++ code instead of get_role.
+  */
+  HRESULT role
+    (
+     [out, retval] long *role
+    );
+
+  /** @brief Makes an object visible on the screen.
+   @param [in] scrollType
+    Defines where the object should be placed on the screen.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT scrollTo
+    (
+     [in] enum IA2ScrollType scrollType
+    );
+
+  /** @brief Moves the top left of an object to a specified location.
+
+   @param [in] coordinateType
+    Specifies whether the coordinates are relative to the screen or the parent object.
+   @param [in] x
+    Defines the x coordinate.
+   @param [in] y
+    Defines the y coordinate.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT scrollToPoint
+    (
+     [in] enum IA2CoordinateType coordinateType,
+     [in] long x,
+     [in] long y
+    );
+
+  /** @brief Returns grouping information.
+
+   Used for tree items, list items, tab panel labels, radio buttons, etc.
+   Also used for collections of non-text objects.
+
+   @param [out] groupLevel
+    1 based, 0 indicates that this value is not applicable
+   @param [out] similarItemsInGroup
+    1 based, 0 indicates that this value is not applicable
+   @param [out] positionInGroup
+    1 based, 0 indicates that this value is not applicable. This is an index
+    into the objects in the current group, not an index into all the objects
+    at the same group level.
+   @retval S_OK if at least one value is valid
+   @retval S_FALSE if no values are valid, [out] values are 0s
+   @note This method is meant to describe the nature of an object's containment
+    structure.  It's exposed by trees, tree grids, nested lists, nested menus,
+    but not headings, which uses the level object attribute.  It is also exposed
+    by radio buttons (with groupLevel == 0).
+   @note This is normally not implemented on a combo box to describe the nature
+    of its contents.  Normally an AT will get that information from its child list
+    object.  However, in some cases when non-edit combo boxes are not able to be structured
+    such that the list is a child of the combo box, this method is implemented on
+    the combo box itself. ATs can use this interface if a child list is not found.
+    */
+  [propget] HRESULT groupPosition
+    (
+     [out] long *groupLevel,
+     [out] long *similarItemsInGroup,
+     [out, retval] long *positionInGroup
+    );
+
+  /** @brief Returns the bit strip containing any IAccessible2 states.
+
+   The IAccessible2 states are in addition to the MSAA states and are defined in
+   the IA2States enum.
+
+   @param [out] states
+   @retval S_OK
+  */
+  [propget] HRESULT states
+    (
+     [out, retval] AccessibleStates *states
+    );
+
+  /** @brief Returns the extended role.
+
+   An extended role is a role which is dynamically generated by the application.
+   It is not predefined by the %IAccessible2 specification.
+
+   @param [out] extendedRole
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT extendedRole
+    (
+     [out, retval] BSTR *extendedRole
+    );
+
+  /** @brief Returns the localized extended role.
+   @param [out] localizedExtendedRole
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT localizedExtendedRole
+    (
+     [out, retval] BSTR *localizedExtendedRole
+    );
+
+  /** @brief Returns the number of extended states.
+   @param [out] nExtendedStates
+   @retval S_OK
+  */
+  [propget] HRESULT nExtendedStates
+    (
+     [out, retval] long *nExtendedStates
+    );
+
+  /** @brief Returns the extended states (array of strings).
+
+   An extended state is a state which is dynamically generated by the application.
+   It is not predefined by the %IAccessible2 specification.
+
+   @param [in] maxExtendedStates
+    This parameter is ignored. Refer to @ref _arrayConsideration
+    "Special Consideration when using Arrays" for more details.
+   @param [out] extendedStates
+    This array is allocated by the server.  Free it with CoTaskMemFree.
+   @param [out] nExtendedStates
+    The number of extended states returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are no states, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT extendedStates
+    (
+     [in] long maxExtendedStates,
+     [out, size_is(,maxExtendedStates), length_is(,*nExtendedStates)] BSTR **extendedStates,
+     [out, retval] long *nExtendedStates
+    );
+
+  /** @brief Returns the localized extended states (array of strings).
+   @param [in] maxLocalizedExtendedStates
+    This parameter is ignored. Refer to @ref _arrayConsideration
+    "Special Consideration when using Arrays" for more details.
+   @param [out] localizedExtendedStates
+    This array is allocated by the server.  Free it with CoTaskMemFree.
+   @param [out] nLocalizedExtendedStates
+    The number of localized extended states returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are no states, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT localizedExtendedStates
+    (
+     [in] long maxLocalizedExtendedStates,
+     [out, size_is(,maxLocalizedExtendedStates), length_is(,*nLocalizedExtendedStates)] BSTR **localizedExtendedStates,
+     [out, retval] long *nLocalizedExtendedStates
+    );
+
+  /** @brief Returns the unique ID.
+
+   The uniqueID is an identifier for this object, is unique within the
+   current window, and remains the same for the lifetime of the accessible
+   object.
+
+   The uniqueID is not related to:
+   - the MSAA objectID which is used by the server to disambiguate between
+   IAccessibles per HWND or
+   - the MSAA childID which is used to disambiguate between children being
+   managed by an IAccessible.
+
+   This value is provided so the AT can have access to a unique runtime persistent
+   identifier even when not handling an event for the object.
+
+   An example of when this value is useful is if the AT wants to build a cache.
+   The AT could cache the uniqueIDs in addition to other data being cached.
+   When an event is fired the AT could map the uniqueID to its internal model.
+   Thus, if there's a REORDER/SHOW/HIDE event the AT knows which part of the
+   internal structure has been invalidated and can refetch just that part.
+
+   This value can also be used by an AT to determine when the current control
+   has changed. If the role is the same for two controls that are adjacent in
+   the tab order, this can be used to detect the new control.
+
+   Another use of this value by an AT is to identify when a grouping object has
+   changed, e.g. when moving from a radio button in one group to a radio button in a
+   different group.
+
+   One means of implementing this would be to create a factory with a 32 bit number
+   generator and a reuse pool.  The number generator would emit numbers starting
+   at 1.  Each time an object's life cycle ended, its number would be saved into a
+   reuse pool.  The number generator would be used whenever the reuse pool was empty.
+
+   Another way to create a unique ID is to generate it from a pointer value, e.g. an
+   object's address. That would be unique because no two active objects can use the
+   same allocated memory space.
+
+   @param [out] uniqueID
+   @retval S_OK
+  */
+  [propget] HRESULT uniqueID
+    (
+     [out, retval] long *uniqueID
+    );
+
+  /** @brief Returns the window handle for the parent window which contains this object.
+
+   This is the same window handle which will be passed for any events that occur on the
+   object, but is cached in the accessible object for use when it would be helpful to
+   access the window handle in cases where an event isn't fired on this object.
+
+   A use case is when a screen reader is grabbing an entire web page on a page load.
+   Without the availability of windowHandle, the AT would have to get the window handle
+   by using WindowFromAccessibleObject on each IAccessible, which is slow because it's
+   implemented by oleacc.dll as a loop which crawls up the ancestor chain and looks for
+   a ROLE_WINDOW object, mapping that back to a window handle.
+
+   @param [out] windowHandle
+   @retval S_OK
+  */
+  [propget] HRESULT windowHandle
+    (
+     [out, retval] HWND *windowHandle
+    );
+
+  /** @brief Returns the index of this object in its parent object.
+   @param [out] indexInParent
+     0 based; -1 indicates there is no parent; the upper bound is the value
+     returned by the parent's IAccessible::get_accChildCount.
+   @retval S_OK
+   @retval S_FALSE if no parent, [out] value is -1
+  */
+  [propget] HRESULT indexInParent
+    (
+     [out, retval] long *indexInParent
+    );
+
+  /** @brief Returns the IA2Locale of the accessible object.
+   @param [out] locale
+   @retval S_OK
+  */
+  [propget] HRESULT locale
+    (
+     [out, retval] IA2Locale *locale
+    );
+
+  /** @brief Returns the attributes specific to this %IAccessible2 object, such as a cell's formula.
+   @param [out] attributes
+   @retval S_OK
+   @retval S_FALSE returned if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT attributes
+    (
+     [out, retval] BSTR *attributes
+    );
+
+}
+
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleAction.idl b/src/3rdparty/iaccessible2/idl/AccessibleAction.idl
new file mode 100644
index 0000000..edab0d2
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleAction.idl
@@ -0,0 +1,194 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleAction.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+
+/** @brief This interface gives access to actions that can be executed
+  for accessible objects.
+
+ Every accessible object that can be manipulated via the native GUI beyond the
+  methods available either in the MSAA IAccessible interface or in the set of
+  IAccessible2 interfaces (other than this IAccessibleAction interface) should
+  support the IAccessibleAction interface in order to provide Assistive Technology
+  access to all the actions that can be performed by the object.  Each action can
+  be performed or queried for a name, description or associated key bindings.
+  Actions are needed more for ATs that assist the mobility impaired, such as
+  on-screen keyboards and voice command software.  By providing actions directly,
+  the AT can present them to the user without the user having to perform the extra
+  steps to navigate a context menu.
+
+ The first action should be equivalent to the MSAA default action.  If there is
+  only one action, %IAccessibleAction should also be implemented.
+*/
+[object, uuid(B70D9F59-3B5A-4dba-AB9E-22012F607DF5)]
+interface IAccessibleAction : IUnknown
+{
+
+  /** @brief Returns the number of accessible actions available in this object.
+
+   If there are more than one, the first one is considered the
+    "default" action of the object.
+   @param [out] nActions
+    The returned value of the number of actions is zero if there are
+    no actions.
+   @retval S_OK
+   @note This method is missing a [propget] prefix in the IDL.  The result is the
+    method is named nActions in generated C++ code instead of get_nActions.
+  */
+  HRESULT nActions
+    (
+     [out,retval] long* nActions
+    );
+
+  /** @brief Performs the specified Action on the object.
+   @param [in] actionIndex
+    0 based index specifying the action to perform.  If it lies outside
+    the valid range no action is performed.
+   @retval S_OK
+   @retval S_FALSE if action could not be performed
+   @retval E_INVALIDARG if bad [in] passed
+    */
+  HRESULT doAction
+    (
+     [in] long actionIndex
+    );
+
+  /** @brief Returns a description of the specified action of the object.
+   @param [in] actionIndex
+    0 based index specifying which action's description to return.
+    If it lies outside the valid range an empty string is returned.
+   @param [out] description
+    The returned value is a localized string of the specified action.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+    */
+  [propget] HRESULT description
+    (
+     [in] long actionIndex,
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns an array of BSTRs describing one or more key bindings, if
+   there are any, associated with the specified action.
+
+   The returned strings are the localized human readable key sequences to be
+   used to activate each action, e.g. "Ctrl+Shift+D".  Since these key
+   sequences are to be used when the object has focus, they are like
+   mnemonics (access keys), and not like shortcut (accelerator) keys.
+
+   There is no need to implement this method for single action controls since
+   that would be redundant with the standard MSAA programming practice of
+   getting the mnemonic from get_accKeyboardShortcut.
+
+   An AT such as an On Screen Keyboard might not expose these bindings but
+   provide alternative means of activation.
+
+   Note: the client allocates and passes in an array of pointers.  The server
+   allocates the BSTRs and passes back one or more pointers to these BSTRs into
+   the array of pointers allocated by the client.  The client is responsible
+   for deallocating the BSTRs.
+
+   @param [in] actionIndex
+    0 based index specifying which action's key bindings should be returned.
+   @param [in] nMaxBindings
+    This parameter is ignored. Refer to @ref _arrayConsideration
+    "Special Consideration when using Arrays" for more details.
+   @param [out] keyBindings
+    An array of BSTRs, allocated by the server, one for each key binding.
+    Free it with CoTaskMemFree.
+   @param [out] nBindings
+    The number of key bindings returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are no key bindings, [out] values are NULL and 0 respectively
+   @retval E_INVALIDARG if bad [in] passed
+    */
+  [propget] HRESULT keyBinding
+    (
+     [in] long actionIndex,
+     [in] long nMaxBindings,
+     [out, size_is(,nMaxBindings), length_is(,*nBindings)] BSTR **keyBindings,
+     [out, retval] long *nBindings
+    );
+
+  /** @brief Returns the non-localized name of specified action.
+   @param [in] actionIndex
+    0 based index specifying which action's non-localized name should be returned.
+   @param [out] name
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+   */
+  [propget] HRESULT name
+    (
+     [in] long actionIndex,
+     [out, retval] BSTR *name
+    );
+
+  /** @brief Returns the localized name of specified action.
+   @param [in] actionIndex
+    0 based index specifying which action's localized name should be returned.
+   @param [out] localizedName
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+   */
+  [propget] HRESULT localizedName
+    (
+     [in] long actionIndex,
+     [out, retval] BSTR *localizedName
+    );
+
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleApplication.idl b/src/3rdparty/iaccessible2/idl/AccessibleApplication.idl
new file mode 100644
index 0000000..ed15aa0
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleApplication.idl
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleApplication.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+
+/** @brief This interface gives access to the application's name and version information.
+
+ This interface provides the AT with the information it needs to differentiate
+ this application from other applications, from other versions of this
+ application, or from other versions of this application running on different
+ versions of an accessibility bridge or accessibility toolkit.
+
+ Servers implementing IAccessible2 should provide access to the %IAccessibleApplication
+ interface via QueryService from any object so that ATs can easily determine specific
+ information about the application such as its name or version.
+*/
+[object, uuid(D49DED83-5B25-43F4-9B95-93B44595979E)]
+interface IAccessibleApplication : IUnknown
+{
+
+  /** @brief Returns the application name.
+   @param [out] name
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT appName
+    (
+     [out, retval] BSTR *name
+    );
+
+  /** @brief Returns the application version.
+   @param [out] version
+    The version string must not contain levels when it is know beforehand that
+    this information will never require a change in a client's behavior.
+    For example, use "3.6.0" rather than "3.6.0.v201005131500".
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT appVersion
+    (
+     [out, retval] BSTR *version
+    );
+
+  /** @brief Returns the toolkit/bridge name.
+   @param [out] name
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT toolkitName
+    (
+     [out, retval] BSTR *name
+    );
+
+  /** @brief Returns the toolkit/bridge version.
+   @param [out] version
+    The version string must not contain levels when it is know beforehand that
+    this information will never require a change in a client's behavior.
+    For example, use "3.6.0" rather than "3.6.0.v201005131500".
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT toolkitVersion
+    (
+     [out, retval] BSTR *version
+    );
+
+}
+
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleComponent.idl b/src/3rdparty/iaccessible2/idl/AccessibleComponent.idl
new file mode 100644
index 0000000..bea623a
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleComponent.idl
@@ -0,0 +1,124 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleComponent.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+
+/** A value specifying a color in ARGB format, where each 8 bit color component
+specifies alpha, red, green, and blue respectively.  The alpha value is optional.
+*/
+typedef long IA2Color;
+
+/** @brief This interface is implemented by any object that can be rendered
+ on the screen.
+
+ This interface provides the standard mechanism for an assistive technology
+  to retrieve information concerning the graphical representation of an object.
+  Coordinates used by the functions of this interface are specified in
+  different coordinate systems.  Their scale is the same and is equal to
+  that of the screen coordinate system.  In other words all coordinates
+  are measured in pixels.  They differ in their respective origin:
+  <ul>
+   <li>The screen coordinate system has its origin in the upper left
+    corner of the current screen.</li>
+   <li>The origin of the parent coordinate system is the upper left corner
+    of the parent's bounding box.  With no parent the screen coordinate
+    system is used instead.</li>
+  </ul>
+*/
+[object, uuid(1546D4B0-4C98-4bda-89AE-9A64748BDDE4)]
+interface IAccessibleComponent : IUnknown
+{
+
+  /** @brief Returns the location of the upper left corner of the object's
+    bounding box relative to the immediate parent object.
+
+    The coordinates of the bounding box are given relative to the parent's
+    coordinate system. The coordinates of the returned position are relative
+    to this object's parent or relative to the screen on which this object
+    is rendered if it has no parent. If the object is not on any screen
+    the returned position is (0,0).
+
+   @param [out] x
+   @param [out] y
+   @retval S_OK
+  */
+  [propget] HRESULT locationInParent
+    (
+     [out] long *x,
+     [out, retval] long *y
+    );
+
+  /** @brief Returns the foreground color of this object.
+   @param [out] foreground
+    The returned color is the foreground color of this object or, if
+    that is not supported, the default foreground color.
+   @retval S_OK
+  */
+  [propget] HRESULT foreground
+    (
+     [out, retval] IA2Color *foreground
+    );
+
+   /** @brief Returns the background color of this object.
+    @param [out] background
+     The returned color is the background color of this object or, if
+     that is not supported, the default background color.
+    @retval S_OK
+   */
+  [propget] HRESULT background
+    (
+     [out, retval] IA2Color *background
+    );
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleEditableText.idl b/src/3rdparty/iaccessible2/idl/AccessibleEditableText.idl
new file mode 100644
index 0000000..48fefd3
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleEditableText.idl
@@ -0,0 +1,259 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleEditableText.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "IA2CommonTypes.idl";
+
+/** @brief This interface provides clipboard capability to text objects.
+
+ This interface is typically used in conjunction with the IAccessibleText
+  interface and complements that interface with the additional capability of
+  clipboard operations.  Note that even a read only text object can support
+  the copy capability so this interface is not limited to editable objects.
+
+ The substrings used with this interface are specified as follows:
+  If startOffset is less than endOffset, the substring starts with the
+  character at startOffset and ends with the character just before endOffset.
+  If endOffset is lower than startOffset,  the result is the same as a call
+  with the two arguments exchanged. The whole text can be defined by passing
+  the indices zero and IAccessibleText::nCharacters. If both indices have the
+  same value, an empty string is defined.
+
+ Refer to the @ref _specialOffsets
+  "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+  for information about a special offset constant that can be used in %IAccessibleEditableText methods.
+*/
+[object, uuid(A59AA09A-7011-4b65-939D-32B1FB5547E3)]
+interface IAccessibleEditableText : IUnknown
+{
+
+  /** @brief Copies the text range into the clipboard.
+
+   The selection is set to the specified offsets and then selection is copied into
+   the system clipboard.
+
+   @param [in] startOffset
+    Start index of the text to moved into the clipboard.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text to moved into the clipboard.
+    The valid range is 0..length.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+  */
+  HRESULT copyText
+    (
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Deletes a range of text.
+
+   The text between and including the two given indices is deleted
+    from the text represented by this object.
+
+   @param [in] startOffset
+    Start index of the text to be deleted.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text to be deleted.
+    The valid range is 0..length.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+  */
+  HRESULT deleteText
+    (
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Inserts text at the specified position.
+
+   The specified string is inserted at the given index into the text
+    represented by this object.
+
+   @param [in] offset
+    Index at which to insert the text.
+    The valid range is 0..length.
+    Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+   @param [in] text
+    Text that is inserted.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT insertText
+    (
+     [in] long offset,
+     [in] BSTR *text
+    );
+
+  /** @brief Deletes a range of text and copies it to the clipboard.
+
+   The selection is set to the specified offsets, the selection is then copied into
+    the system clipboard, and then the selection is deleted.
+
+   @param [in] startOffset
+    Start index of the text to be deleted.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text to be deleted.
+    The valid range is 0..length.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+  */
+  HRESULT cutText
+    (
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Pastes content from the clipboard.
+
+   Any existing selection is removed, the clipboard content is then pasted into
+    this object's text at the given offset.  This method is similar to the insertText
+    method.  If the index is not valid the system clipboard content is not inserted. The
+    behavior is the same as    when Ctrl+V is used, i.e. the pasted contents are not
+    necessarily plain text.
+
+   @param [in] offset
+    Index at which to insert the content from the system clipboard into
+    the text represented by this object.
+    The valid range is 0..length.
+    Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT pasteText
+    (
+     [in] long offset
+    );
+
+  /** @brief Replaces text.
+
+   The text between the two given indices is replaced by the specified
+    replacement string. This method is equivalent to calling first
+    IAccessibleEditableText::deleteText with the two indices and then
+    calling IAccessibleEditableText::insertText with the replacement text
+    at the start index.
+
+   @param [in] startOffset
+    Start index of the text to be replaced.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text to be replaced.
+    The valid range is 0..length.
+   @param [in] text
+    The Text that replaces the text between the given indices.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+  */
+  HRESULT replaceText
+    (
+     [in] long startOffset,
+     [in] long endOffset,
+     [in] BSTR *text
+    );
+
+  /** @brief Replaces the attributes of a text range by the given set of attributes.
+
+   Sets the attributes for the text between the two given indices. The old
+    attributes are replaced by the new list of attributes.
+
+   @param [in] startOffset
+    Start index of the text whose attributes are modified.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text whose attributes are modified.
+    The valid range is 0..length.
+   @param [in] attributes
+    Set of attributes that replaces the old list of attributes of
+    the specified text portion.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+  */
+  HRESULT setAttributes
+    (
+     [in] long startOffset,
+     [in] long endOffset,
+     [in] BSTR *attributes
+    );
+}
+
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleEventID.idl b/src/3rdparty/iaccessible2/idl/AccessibleEventID.idl
new file mode 100644
index 0000000..1db957d
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleEventID.idl
@@ -0,0 +1,230 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleEventID.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** %IAccessible2 specific event constants
+
+ This enum defines the event IDs fired by %IAccessible2 objects.  The event IDs
+ are in addition to those used by MSAA.
+*/
+enum IA2EventID {
+
+  /** The change of the number or attributes of actions of an accessible
+    object is signaled by events of this type.
+  */
+  IA2_EVENT_ACTION_CHANGED = 0x101,
+
+  /** <b>Deprecated.</b> The active descendant of a component has changed.
+
+    Note: This event constant is misspelled and thus is deprecated and will be
+    removed in a later version. Please use the correctly spelled version which
+    follows.
+  */
+  IA2_EVENT_ACTIVE_DECENDENT_CHANGED,
+
+  /** The active descendant of a component has changed.  The active descendant
+    is used in objects with transient children.
+
+    Note: Due to the fact that MSAA's WinEvents don't allow the active child index
+    to be passed on the IA2_EVENT_ACTIVE_DESCENDANT_CHANGED event the manages
+    descendants    scheme can't be used.  Instead the active child object has to fire
+    MSAA's EVENT_OBJECT_FOCUS.  In a future release a new event mechanism may be
+    added to provide for event specific data to be passed with the event.  At that
+    time the IA2_EVENT_ACTIVE_DECENDENT_CHANGED event and
+    IA2_STATE_MANAGES_DESCENDANTS state would be useful.
+  */
+  IA2_EVENT_ACTIVE_DESCENDANT_CHANGED = IA2_EVENT_ACTIVE_DECENDENT_CHANGED,
+
+  /** The document wide attributes of the document object have changed.
+  */
+  IA2_EVENT_DOCUMENT_ATTRIBUTE_CHANGED,
+
+  /** The contents of the document have changed.
+  */
+  IA2_EVENT_DOCUMENT_CONTENT_CHANGED,
+
+  /** The loading of the document has completed.
+  */
+  IA2_EVENT_DOCUMENT_LOAD_COMPLETE,
+
+  /** The loading of the document was interrupted.
+  */
+  IA2_EVENT_DOCUMENT_LOAD_STOPPED,
+
+  /** The document contents are being reloaded.
+  */
+  IA2_EVENT_DOCUMENT_RELOAD,
+
+  /** The ending index of this link within the containing string has changed.
+  */
+  IA2_EVENT_HYPERLINK_END_INDEX_CHANGED,
+
+  /** The number of anchors associated with this hyperlink object has changed.
+  */
+  IA2_EVENT_HYPERLINK_NUMBER_OF_ANCHORS_CHANGED,
+
+  /** The hyperlink selected state changed from selected to unselected or
+    from unselected to selected.
+  */
+  IA2_EVENT_HYPERLINK_SELECTED_LINK_CHANGED,
+
+  /** One of the links associated with the hypertext object has been activated.
+  */
+  IA2_EVENT_HYPERTEXT_LINK_ACTIVATED,
+
+  /** One of the links associated with the hypertext object has been selected.
+  */
+  IA2_EVENT_HYPERTEXT_LINK_SELECTED,
+
+  /** The starting index of this link within the containing string has changed.
+  */
+  IA2_EVENT_HYPERLINK_START_INDEX_CHANGED,
+
+  /** Focus has changed from one hypertext object to another, or focus moved
+   from a non-hypertext object to a hypertext object, or focus moved from a
+   hypertext object to a non-hypertext object.
+  */
+  IA2_EVENT_HYPERTEXT_CHANGED,
+
+  /** The number of hyperlinks associated with a hypertext object changed
+  */
+  IA2_EVENT_HYPERTEXT_NLINKS_CHANGED,
+
+  /** An object's attributes changed.
+  Also see ::IA2_EVENT_TEXT_ATTRIBUTE_CHANGED.
+  */
+  IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED,
+
+  /** A slide changed in a presentation document or a page boundary was
+   crossed in a word processing document.
+  */
+  IA2_EVENT_PAGE_CHANGED,
+
+  /** The caret moved from one section to the next.
+  */
+  IA2_EVENT_SECTION_CHANGED,
+
+  /** A table caption changed.
+  */
+  IA2_EVENT_TABLE_CAPTION_CHANGED,
+
+  /** A table's column description changed.
+  */
+  IA2_EVENT_TABLE_COLUMN_DESCRIPTION_CHANGED,
+
+  /** A table's column header changed.
+  */
+  IA2_EVENT_TABLE_COLUMN_HEADER_CHANGED,
+
+  /** A table's data changed.
+  */
+  IA2_EVENT_TABLE_MODEL_CHANGED,
+
+  /** A table's row description changed.
+  */
+  IA2_EVENT_TABLE_ROW_DESCRIPTION_CHANGED,
+
+  /** A table's row header changed.
+  */
+  IA2_EVENT_TABLE_ROW_HEADER_CHANGED,
+
+  /** A table's summary changed.
+  */
+  IA2_EVENT_TABLE_SUMMARY_CHANGED,
+
+  /** A text object's attributes changed.
+  Also see ::IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED.
+  */
+  IA2_EVENT_TEXT_ATTRIBUTE_CHANGED,
+
+  /** The caret has moved to a new position.
+  */
+  IA2_EVENT_TEXT_CARET_MOVED,
+
+  /** <b>Deprecated.</b>  This event is equivalent to ::IA2_EVENT_TEXT_UPDATED.
+  */
+  IA2_EVENT_TEXT_CHANGED,
+
+  /** The caret moved from one column to the next.
+  */
+  IA2_EVENT_TEXT_COLUMN_CHANGED,
+
+  /** Text was inserted.
+  */
+  IA2_EVENT_TEXT_INSERTED,
+
+  /** Text was removed.
+  */
+  IA2_EVENT_TEXT_REMOVED,
+
+  /** This event indicates general text changes, i.e. changes to text that are
+    exposed through the IAccessibleText interface.  For compatibility with ATK/AT-SPI
+    which does not have an equivalent event, servers can alternatively fire
+    ::IA2_EVENT_TEXT_REMOVED and ::IA2_EVENT_TEXT_INSERTED.
+  */
+  IA2_EVENT_TEXT_UPDATED,
+
+  /** The text selection changed.  Later versions of Microsoft development environments
+   have an equivalent event identified, EVENT_OBJECT_TEXTSELECTIONCHANGED.  Servers
+   should use that if it is available and use IA2_EVENT_TEXT_SELECTION_CHANGED otherwise.
+   Clients should be prepared to respond to either event.
+
+  */
+  IA2_EVENT_TEXT_SELECTION_CHANGED,
+
+  /** A visible data event indicates the change of the visual appearance
+    of an accessible object.  This includes for example most of the
+    attributes available via the IAccessibleComponent interface.
+  */
+  IA2_EVENT_VISIBLE_DATA_CHANGED
+
+};
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleHyperlink.idl b/src/3rdparty/iaccessible2/idl/AccessibleHyperlink.idl
new file mode 100644
index 0000000..9311176
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleHyperlink.idl
@@ -0,0 +1,187 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleHyperlink.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "AccessibleAction.idl";
+
+/** @brief This interface represents hyperlinks.
+
+ This interface represents a hyperlink associated with a single substring
+  of text or single non-text object.  Non-text objects can have either a
+  single link or a collection of links such as when the non-text object is
+  an image map.
+
+ Linked objects and anchors are implementation dependent. This interface is derived
+  from IAccessibleAction.  IAccessibleAction::nActions is one greater than the
+  maximum value for the indices used with the methods of this interface.
+
+ Furthermore, the object that implements this interface has to be connected
+  implicitly or explicitly with an object that implements IAccessibleText.
+  IAccessibleHyperlink::startIndex and IAccessibleHyperlink::endIndex are
+  indices with respect to the text exposed by IAccessibleText.
+
+ This interface provides access to a single object which can have multiple actions.
+  An example is an image map which is an image with multiple links each of which is
+  associated with a separate non-overlapping area of the image.  This interface could
+  also be applied to other kinds of objects with multiple actions such as "smart tags"
+  which are objects, typically strings, which have multiple actions such as
+  "Activate URI", "Bookmark URI", etc.
+
+ An interesting use case is an image map where each area is associated with multiple
+  actions, e.g. an image map of smart tags.  In this case you would have to implement
+  two levels of accessible hyperlinks.  The first level hyperlinks would only implement
+  anchor and anchorTarget.  The anchors would all reference the image object.  The
+  anchorTargets would reference the second level accessible hyperlink objects.  None
+  of the IAccessibleAction methods would be implemented on the first level hyperlink
+  objects.  The second level hyperlink objects would implement the IAccessibleAction
+  methods.  Their anchors would also reference the image object and their anchorTargets
+  would reference URLs or the objects that would be activated.
+
+ This use case demonstrates that in some cases there is no need for IAccessibleHyperlink
+  to derive from IAccessibleAction.  As a result it may be removed in a later version of
+  the IDL and it is suggested that implementations should not rely on the inheritance.
+
+*/
+[object, uuid(01C20F2B-3DD2-400f-949F-AD00BDAB1D41)]
+interface IAccessibleHyperlink : IAccessibleAction
+{
+
+  /** @brief Returns an object that represents the link anchor, as appropriate
+   for the link at the specified index.
+   @param [in] index
+    A 0 based index identifies the anchor when, as in the case of an image map,
+    there is more than one link represented by this object.  The valid maximal
+    index is indicated by IAccessibleAction::nActions.
+   @param [out] anchor
+    This is an implementation dependent value.  For example, for a text link this
+    method could return the substring of the containing string where the substring
+    is overridden with link behavior, and for an image link this method could return
+    an IUnknown VARIANT for IAccessibleImage.  See the section about
+    @ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT anchor
+    (
+     [in] long index,
+     [out, retval] VARIANT *anchor
+    );
+
+  /** @brief Returns an object representing the target of the link, as appropriate
+   for the link at the specified index.
+   @param [in] index
+    A 0 based index identifies the anchor when, as in the case of an image map,
+    there is more than one link represented by this object.  The valid maximal
+    index is indicated by IAccessibleAction::nActions.
+   @param [out] anchorTarget
+    This is an implementation dependent value.  For example this method could
+    return a BSTR VARIANT of the URI.  Alternatively this method could return an
+    IUnknown VARIANT of a COM interface representing a target object to be
+    activated when the link is activated.  See the section about
+    @ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT anchorTarget
+    (
+     [in] long index,
+     [out, retval] VARIANT *anchorTarget
+    );
+
+  /** @brief Returns the 0 based character offset at which the textual representation of the hyperlink starts.
+
+   The returned value is related to the IAccessibleText interface of the object that
+   owns this hyperlink.
+   @param [out] index
+   @retval S_OK
+  */
+  [propget] HRESULT startIndex
+    (
+     [out, retval] long *index
+    );
+
+  /** @brief Returns the 0 based character offset at which the textual representation of the hyperlink ends.
+
+   The returned value is related to the IAccessibleText interface of the object that
+   owns this hyperlink. The character at the index is not part of the hypertext.
+   @param [out] index
+   @retval S_OK
+  */
+  [propget] HRESULT endIndex
+    (
+     [out, retval] long *index
+    );
+
+  /** @brief Returns whether the target object referenced by this link is still valid.
+
+   This is a volatile state that may change without sending an appropriate event.
+   Returns TRUE if the referenced target is still valid and FALSE otherwise.
+
+   This has also been used to indicate whether or not the URI of the anchorTarget
+   is malformed.
+
+   @param [out] valid
+    If false, one or more of the object's links are invalid.
+    If true, all of the object's links are valid.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is FALSE
+   @note This method is not being used, is deprecated, and should not be implemented or
+    used.  It is likely that this method will be removed in a later version of the IDL.
+  */
+  [propget] HRESULT valid
+    (
+     [out, retval] boolean *valid
+    );
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleHypertext.idl b/src/3rdparty/iaccessible2/idl/AccessibleHypertext.idl
new file mode 100644
index 0000000..13093bf
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleHypertext.idl
@@ -0,0 +1,123 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleHypertext.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "AccessibleText.idl";
+import "AccessibleHyperlink.idl";
+
+/** @brief This interface exposes information about hypertext in a document.
+
+ The %IAccessibleHypertext interface is the main interface to expose
+  hyperlinks in a document, typically a text document, that are used
+  to reference other documents.  A typical implementation is to implement
+  this interface on the smallest text object such as a paragraph of text.
+*/
+[object, uuid(6B4F8BBF-F1F2-418a-B35E-A195BC4103B9)]
+interface IAccessibleHypertext : IAccessibleText
+{
+
+  /** @brief Returns the number of links and link groups contained within this hypertext
+    paragraph.
+   @param [out] hyperlinkCount
+    The number of links and link groups within this hypertext paragraph.
+    Returns 0 if there is no link.
+   @retval S_OK
+  */
+  [propget] HRESULT nHyperlinks
+    (
+     [out, retval] long *hyperlinkCount
+    );
+
+  /** @brief Returns the specified link.
+
+   The returned IAccessibleHyperlink object encapsulates the hyperlink and
+    provides several kinds of information describing it.
+   @param [in] index
+    This 0 based index specifies the hyperlink to return.
+   @param [out] hyperlink
+    If the given index is valid, i.e. lies in the interval from 0 to the number
+    of links minus one, a reference to the specified hyperlink object is returned.
+    If the index is invalid then a NULL pointer is returned.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT hyperlink
+    (
+     [in] long index,
+     [out, retval] IAccessibleHyperlink **hyperlink
+    );
+
+  /** @brief Returns the index of the hyperlink that is associated with this character index.
+
+   This is the case when a link spans the given character index.
+   @param [in] charIndex
+    A 0 based index of the character for which to return the link index.  If
+    IAccessibleText is used to represent the text containing the link, then the
+    character index is only  valid if it is greater than or equal to zero and
+    lower than the number of characters in the text.
+   @param [out] hyperlinkIndex
+    Returns the 0 based index of the hyperlink that is associated with this
+    character index, or -1 if charIndex is not on a link.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is -1
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT hyperlinkIndex
+    (
+     [in] long charIndex,
+     [out, retval] long *hyperlinkIndex
+    );
+
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleImage.idl b/src/3rdparty/iaccessible2/idl/AccessibleImage.idl
new file mode 100644
index 0000000..e347614
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleImage.idl
@@ -0,0 +1,111 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleImage.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "IA2CommonTypes.idl";
+
+/** @brief This interface represents images and icons.
+
+ This interface is used for a representation of images like icons on buttons.
+  %IAccessibleImage only needs to be implemented in certain situations.  Some
+  examples are:
+  <ol>
+   <li>The accessible name and description are not enough to fully
+    describe the image, e.g. when the accessible description is used to define the
+    behavior of an actionable image and the image itself conveys semantically
+    significant information.
+   <li>The user can edit the content that includes an
+    image and therefore the user needs to be able to review the image's position.
+  </ol>
+*/
+[object, uuid(FE5ABB3D-615E-4f7b-909F-5F0EDA9E8DDE)]
+interface IAccessibleImage : IUnknown
+{
+  /** @brief Returns the localized description of the image.
+   @param [out] description
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT description
+    (
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns the coordinates of the image.
+   @param [in] coordinateType
+    Specifies whether the returned coordinates should be relative to the screen or the parent object.
+   @param [out] x
+   @param [out] y
+   @retval S_OK
+  */
+  [propget] HRESULT imagePosition
+    (
+     [in] enum IA2CoordinateType coordinateType,
+     [out] long *x,
+     [out, retval] long *y
+    );
+
+  /** @brief Returns the size of the image in units specified by parent's coordinate system.
+   @param [out] height
+   @param [out] width
+   @retval S_OK
+  */
+
+  [propget] HRESULT imageSize
+    (
+     [out] long *height,
+     [out, retval] long *width
+    );
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleRelation.idl b/src/3rdparty/iaccessible2/idl/AccessibleRelation.idl
new file mode 100644
index 0000000..b0c6dfc
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleRelation.idl
@@ -0,0 +1,197 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleRelation.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+
+/** @defgroup grpRelations Relations
+  Use the following constants to compare against the BSTRs returned by
+  IAccessibleRelation::relationType.
+*/
+///@{
+
+/** Some attribute of this object is affected by a target object. */
+const WCHAR *const IA2_RELATION_CONTROLLED_BY = L"controlledBy";
+
+/** This object is interactive and controls some attribute of a target object. */
+const WCHAR *const IA2_RELATION_CONTROLLER_FOR = L"controllerFor";
+
+/** This object is described by the target object. */
+const WCHAR *const IA2_RELATION_DESCRIBED_BY = L"describedBy";
+
+/** This object is describes the target object. */
+const WCHAR *const IA2_RELATION_DESCRIPTION_FOR = L"descriptionFor";
+
+/** This object is embedded by a target object. */
+const WCHAR *const IA2_RELATION_EMBEDDED_BY = L"embeddedBy";
+
+/** This object embeds a target object. This relation can be used on the
+ OBJID_CLIENT accessible for a top level window to show where the content
+ areas are.
+*/
+const WCHAR *const IA2_RELATION_EMBEDS = L"embeds";
+
+/** Content flows to this object from a target object.
+ This relation and IA2_RELATION_FLOWS_TO are useful to tie text and non-text
+ objects together in order to allow assistive technology to follow the
+ intended reading order.
+*/
+const WCHAR *const IA2_RELATION_FLOWS_FROM = L"flowsFrom";
+
+/** Content flows from this object to a target object. */
+const WCHAR *const IA2_RELATION_FLOWS_TO = L"flowsTo";
+
+/** This object is label for a target object. */
+const WCHAR *const IA2_RELATION_LABEL_FOR = L"labelFor";
+
+/** This object is labelled by a target object. Note that the double L spelling
+ which follows is preferred.  Please use it instead.  This single L version may
+ be removed in a later version.
+*/
+const WCHAR *const IA2_RELATION_LABELED_BY = L"labelledBy";
+
+/** This object is labelled by a target object. */
+const WCHAR *const IA2_RELATION_LABELLED_BY = L"labelledBy";
+
+/** This object is a member of a group of one or more objects. When
+ there is more than one object in the group each member may have one and the
+ same target, e.g. a grouping object.  It is also possible that each member has
+ multiple additional targets, e.g. one for every other member in the group.
+*/
+const WCHAR *const IA2_RELATION_MEMBER_OF = L"memberOf";
+
+/** This object is a child of a target object. */
+const WCHAR *const IA2_RELATION_NODE_CHILD_OF = L"nodeChildOf";
+
+/** This object is a parent window of the target object. */
+const WCHAR *const IA2_RELATION_PARENT_WINDOW_OF = L"parentWindowOf";
+
+/** This object is a transient component related to the target object.
+ When this object is activated the target object doesn't lose focus.
+*/
+const WCHAR *const IA2_RELATION_POPUP_FOR = L"popupFor";
+
+/** This object is a sub window of a target object. */
+const WCHAR *const IA2_RELATION_SUBWINDOW_OF = L"subwindowOf";
+
+///@}
+
+/// This interface gives access to an object's set of relations.
+[object, uuid(7CDF86EE-C3DA-496a-BDA4-281B336E1FDC)]
+interface IAccessibleRelation : IUnknown
+{
+  /** @brief Returns the type of the relation.
+   @param [out] relationType
+    The strings returned are defined @ref grpRelations "in this section of the documentation".
+   @retval S_OK
+  */
+  [propget] HRESULT relationType
+    (
+     [out, retval] BSTR *relationType
+    );
+
+  /** @brief Returns a localized version of the relation type.
+   @param [out] localizedRelationType
+   @retval S_OK
+  */
+  [propget] HRESULT localizedRelationType
+    (
+     [out, retval] BSTR *localizedRelationType
+    );
+
+  /** @brief Returns the number of targets for this relation.
+   @param [out] nTargets
+   @retval S_OK
+  */
+  [propget] HRESULT nTargets
+    (
+     [out, retval] long *nTargets
+    );
+
+  /** @brief Returns one accessible relation target.
+   @param [in] targetIndex
+    0 based index
+   @param [out] target
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Use QueryInterface to get IAccessible2.
+  */
+  [propget] HRESULT target
+    (
+     [in] long targetIndex,
+     [out, retval] IUnknown **target
+    );
+
+  /** @brief Returns multiple accessible relation targets
+   @param [in] maxTargets
+    maximum size of the array allocated by the client
+   @param [out] targets
+    The array of target objects.  Note that this array is to be allocated by the
+    client and freed when no longer needed.  Refer to @ref _arrayConsideration
+    "Special Consideration when using Arrays" for more details.  You will need to use
+    QueryInterface on the IUnknown to get the IAccessible2.
+   @param [out] nTargets
+    actual number of targets in the returned array (not more than maxTargets)
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, e.g. a negative value
+  */
+  [propget] HRESULT targets
+    (
+     [in] long maxTargets,
+     [out, size_is(maxTargets), length_is(*nTargets)]
+       IUnknown **targets,
+     [out, retval] long *nTargets
+    );
+
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleRole.idl b/src/3rdparty/iaccessible2/idl/AccessibleRole.idl
new file mode 100644
index 0000000..385e02d
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleRole.idl
@@ -0,0 +1,293 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleRole.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+
+/** Collection of roles
+
+  This enumerator defines an extended set of accessible roles of objects implementing
+  the %IAccessible2 interface. These roles are in addition to the MSAA roles obtained
+  through the MSAA get_accRole method.  Examples are 'footnote', 'heading', and
+  'label'. You obtain an object's %IAccessible2 roles by calling IAccessible2::role.
+*/
+enum IA2Role {
+
+  /** Unknown role. The object contains some Accessible information, but its
+   role is not known.
+  */
+  IA2_ROLE_UNKNOWN = 0,
+
+  /** An object that can be drawn into and to manage events from the objects
+   drawn into it.  Also refer to ::IA2_ROLE_FRAME,
+   ::IA2_ROLE_GLASS_PANE, and ::IA2_ROLE_LAYERED_PANE.
+  */
+  IA2_ROLE_CANVAS = 0x401,
+
+  /// A caption describing another object.
+  IA2_ROLE_CAPTION,
+
+  /// Used for check buttons that are menu items.
+  IA2_ROLE_CHECK_MENU_ITEM,
+
+  /// A specialized dialog that lets the user choose a color.
+  IA2_ROLE_COLOR_CHOOSER,
+
+  /// A date editor.
+  IA2_ROLE_DATE_EDITOR,
+
+  /** An iconified internal frame in an ::IA2_ROLE_DESKTOP_PANE.
+   Also refer to ::IA2_ROLE_INTERNAL_FRAME.
+  */
+  IA2_ROLE_DESKTOP_ICON,
+
+  /** A desktop pane. A pane that supports internal frames and iconified
+   versions of those internal frames.  Also refer to ::IA2_ROLE_INTERNAL_FRAME.
+  */
+  IA2_ROLE_DESKTOP_PANE,
+
+  /** A directory pane. A pane that allows the user to navigate through
+   and select the contents of a directory. May be used by a file chooser.
+   Also refer to ::IA2_ROLE_FILE_CHOOSER.
+  */
+  IA2_ROLE_DIRECTORY_PANE,
+
+  /** An editable text object in a toolbar. <b>Deprecated.</b>
+   The edit bar role was meant for a text area in a tool bar. However, to detect
+   a text area in a tool bar the AT can query the parent.
+  */
+  IA2_ROLE_EDITBAR,
+
+  /// Embedded (OLE) object.
+  IA2_ROLE_EMBEDDED_OBJECT,
+
+  /// Text that is used as an endnote (footnote at the end of a chapter or section).
+  IA2_ROLE_ENDNOTE,
+
+  /** A file chooser. A specialized dialog that displays the files in the
+   directory and lets the user select a file, browse a different directory,
+   or specify a filename. May use the directory pane to show the contents of
+   a directory.
+   Also refer to ::IA2_ROLE_DIRECTORY_PANE.
+  */
+  IA2_ROLE_FILE_CHOOSER,
+
+  /** A font chooser. A font chooser is a component that lets the user pick
+   various attributes for fonts.
+  */
+  IA2_ROLE_FONT_CHOOSER,
+
+  /** Footer of a document page.
+   Also refer to ::IA2_ROLE_HEADER.
+  */
+  IA2_ROLE_FOOTER,
+
+  /// Text that is used as a footnote.  Also refer to ::IA2_ROLE_ENDNOTE.
+  IA2_ROLE_FOOTNOTE,
+
+  /** A container of form controls.  An example of the use of this role is to
+   represent an HTML FORM tag.
+  */
+  IA2_ROLE_FORM,
+
+  /** Frame role. A top level window with a title bar, border, menu bar, etc.
+   It is often used as the primary window for an application.  Also refer to
+   ::IA2_ROLE_CANVAS and the MSAA roles of dialog and window.
+  */
+  IA2_ROLE_FRAME,
+
+  /** A glass pane. A pane that is guaranteed to be painted on top of all panes
+   beneath it.  Also refer to ::IA2_ROLE_CANVAS, ::IA2_ROLE_INTERNAL_FRAME, and
+   ::IA2_ROLE_ROOT_PANE.
+  */
+  IA2_ROLE_GLASS_PANE,
+
+  /** Header of a document page.
+   Also refer to ::IA2_ROLE_FOOTER.
+  */
+  IA2_ROLE_HEADER,
+
+  /// Heading.  Use the IAccessible2::attributes level attribute to determine the heading level.
+  IA2_ROLE_HEADING,
+
+  /// A small fixed size picture, typically used to decorate components.
+  IA2_ROLE_ICON,
+
+  /** An image map object.  Usually a graphic with multiple hotspots, where
+   each hotspot can be activated resulting in the loading of another document
+   or section of a document.
+  */
+  IA2_ROLE_IMAGE_MAP,
+
+  /** An object which is used to allow input of characters not found on a keyboard,
+   such as the input of Chinese characters on a Western keyboard.
+  */
+  IA2_ROLE_INPUT_METHOD_WINDOW,
+
+  /** An internal frame. A frame-like object that is clipped by a desktop pane.
+   The desktop pane, internal frame, and desktop icon objects are often used to
+   create multiple document interfaces within an application.
+   Also refer to ::IA2_ROLE_DESKTOP_ICON, ::IA2_ROLE_DESKTOP_PANE, and ::IA2_ROLE_FRAME.
+  */
+  IA2_ROLE_INTERNAL_FRAME,
+
+  /// An object used to present an icon or short string in an interface.
+  IA2_ROLE_LABEL,
+
+  /** A layered pane. A specialized pane that allows its children to be drawn
+   in layers, providing a form of stacking order. This is usually the pane that
+   holds the menu bar as  well as the pane that contains most of the visual
+   components in a window.
+   Also refer to ::IA2_ROLE_CANVAS, ::IA2_ROLE_GLASS_PANE, and ::IA2_ROLE_ROOT_PANE.
+  */
+  IA2_ROLE_LAYERED_PANE,
+
+  /// An embedded note which is not visible until activated.
+  IA2_ROLE_NOTE,
+
+ /** A specialized pane whose primary use is inside a dialog.
+   Also refer to MSAA's dialog role.
+  */
+  IA2_ROLE_OPTION_PANE,
+
+  /** An object representing a page of document content.  It is used in documents
+   which are accessed by the user on a page by page basis.
+  */
+  IA2_ROLE_PAGE,
+
+  /// A paragraph of text.
+  IA2_ROLE_PARAGRAPH,
+
+  /** A radio button that is a menu item.
+   Also refer to MSAA's button and menu item roles.
+  */
+  IA2_ROLE_RADIO_MENU_ITEM,
+
+  /** An object which is redundant with another object in the accessible hierarchy.
+   ATs typically ignore objects with this role.
+  */
+  IA2_ROLE_REDUNDANT_OBJECT,
+
+  /** A root pane. A specialized pane that has a glass pane and a layered pane
+   as its children.
+   Also refer to ::IA2_ROLE_GLASS_PANE and ::IA2_ROLE_LAYERED_PANE
+  */
+  IA2_ROLE_ROOT_PANE,
+
+  /** A ruler such as those used in word processors.
+  */
+  IA2_ROLE_RULER,
+
+  /** A scroll pane. An object that allows a user to incrementally view a large
+   amount of information.  Its children can include scroll bars and a viewport.
+   Also refer to ::IA2_ROLE_VIEW_PORT and MSAA's scroll bar role.
+  */
+  IA2_ROLE_SCROLL_PANE,
+
+  /** A container of document content.  An example of the use of this role is to
+   represent an HTML DIV tag.  A section may be used as a region.  A region is a
+   group of elements that together form a perceivable unit.  A region does not
+   necessarily follow the logical structure of the content, but follows the
+   perceivable structure of the page.  A region may have an attribute in the set
+   of IAccessible2::attributes which indicates that it is "live".  A live region
+   is content that is likely to change in response to a timed change, a user
+   event, or some other programmed logic or event.
+  */
+  IA2_ROLE_SECTION,
+
+  /// Object with graphical representation used to represent content on draw pages.
+  IA2_ROLE_SHAPE,
+
+  /** A split pane. A specialized panel that presents two other panels at the
+   same time. Between the two panels is a divider the user can manipulate to make
+   one panel larger and the other panel smaller.
+  */
+  IA2_ROLE_SPLIT_PANE,
+
+  /** An object that forms part of a menu system but which can be "undocked"
+   from or "torn off" the menu system to exist as a separate window.
+  */
+  IA2_ROLE_TEAR_OFF_MENU,
+
+  /// An object used as a terminal emulator.
+  IA2_ROLE_TERMINAL,
+
+  /// Collection of objects that constitute a logical text entity.
+  IA2_ROLE_TEXT_FRAME,
+
+  /** A toggle button. A specialized push button that can be checked or unchecked,
+   but does not provide a separate indicator for the current state.
+   Also refer to MSAA's roles of push button, check box, and radio button.
+   <BR><B>Note:</B> IA2_ROLE_TOGGLE_BUTTON should not be used.  Instead, use MSAA's
+   ROLE_SYSTEM_PUSHBUTTON and STATE_SYSTEM_PRESSED.
+  */
+  IA2_ROLE_TOGGLE_BUTTON,
+
+  /** A viewport. An object usually used in a scroll pane. It represents the
+   portion of the entire data that the user can see. As the user manipulates
+   the scroll bars, the contents of the viewport can change.
+   Also refer to ::IA2_ROLE_SCROLL_PANE.
+  */
+  IA2_ROLE_VIEW_PORT,
+
+  /** An object containing content which is complementary to the main content of
+   a document, but remains meaningful when separated from the main content.  There
+   are various types of content that would appropriately have this role.  For example,
+   in the case where content is delivered via a web portal to a web browser, this may
+   include but not be limited to show times, current weather, related articles, or
+   stocks to watch.  The complementary role indicates that contained content is relevant
+   to the main content.  If the complementary content is completely separable main
+   content, it may be appropriate to use a more general role.
+  */
+  IA2_ROLE_COMPLEMENTARY_CONTENT
+
+};
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleStates.idl b/src/3rdparty/iaccessible2/idl/AccessibleStates.idl
new file mode 100644
index 0000000..0304b64
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleStates.idl
@@ -0,0 +1,209 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleStates.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+
+typedef long AccessibleStates;
+
+/** %IAccessible2 specific state bit constants
+
+  This enum defines the state bits returned by IAccessible2::states.  The
+  %IAccessible2 state bits are in addition to those returned by MSAA.
+*/
+enum IA2States {
+
+/** Indicates a window is currently the active window, or is an active subelement
+  within a container or table.
+
+ This state can be used to indicate the current active item in a container, even
+  if the container itself is not currently active. In other words this would indicate
+  the item that will get focus if you tab to the container.
+
+ This information is important for knowing what to report for trees and potentially
+  other containers in a virtual buffer.
+
+ Also, see ::IA2_STATE_MANAGES_DESCENDANTS for more information.
+*/
+IA2_STATE_ACTIVE =                    0x1,
+
+/** Indicates that the object is armed.
+
+ Used to indicate that the control is "pressed" and will be invoked when the
+  actuator, e.g. a mouse button, is "released".  An AT which either monitors the
+  mouse or synthesizes mouse events might need to know that, and possibly a talking
+  interface would even let the user know about it.  It could also potentially be
+  useful to on screen keyboards or test tools since the information does indicate
+  something about the state of the interface, for example, code operating asynchronously
+  might need to wait for the armed state to change before doing something else.
+
+*/
+IA2_STATE_ARMED =                    0x2,
+
+/** Indicates the user interface object corresponding to this object no longer exists. */
+IA2_STATE_DEFUNCT =                    0x4,
+
+/** An object with this state has a caret and implements the IAccessibleText interface.
+
+ Such fields may be read-only, so STATE_SYSTEM_READONLY is valid in combination
+  with IA2_STATE_EDITABLE.
+
+*/
+IA2_STATE_EDITABLE =                0x8,
+
+/** Indicates the orientation of this object is horizontal. */
+IA2_STATE_HORIZONTAL =                0x10,
+
+/** Indicates this object is minimized and is represented only by an icon. */
+IA2_STATE_ICONIFIED =                0x20,
+
+/** Indicates an input validation failure. */
+IA2_STATE_INVALID_ENTRY =            0x40,
+
+/** Indicates that this object manages its children.
+
+ Note: Due to the fact that MSAA's WinEvents don't allow the active child index
+  to be passed on the IA2_EVENT_ACTIVE_DESCENDANT_CHANGED event, the manages
+  descendants    scheme can't be used.  Instead the active child object has to fire
+  MSAA's EVENT_OBJECT_FOCUS.  In a future release a new event mechanism may be
+  added to provide for event specific data to be passed with the event.  At that
+  time the IA2_EVENT_ACTIVE_DECENDENT_CHANGED event and
+  IA2_STATE_MANAGES_DESCENDANTS state would be useful.
+*/
+IA2_STATE_MANAGES_DESCENDANTS =        0x80,
+
+/** Indicates that an object is modal.
+
+ Modal objects have the behavior that something must be done with the object
+  before the user can interact with an object in a different window.
+*/
+IA2_STATE_MODAL =                    0x100,
+
+/** Indicates this text object can contain multiple lines of text. */
+IA2_STATE_MULTI_LINE =                0x200,
+
+/** Indicates this object paints every pixel within its rectangular region. */
+IA2_STATE_OPAQUE =                    0x400,
+
+/** Indicates that user interaction is required.
+
+ An example of when this state is used is when a field in a form must be filled
+  before a form can be processed.
+*/
+IA2_STATE_REQUIRED =                0x800,
+
+/** Indicates an object which supports text selection.
+
+ Note: This is different than MSAA STATE_SYSTEM_SELECTABLE.
+*/
+IA2_STATE_SELECTABLE_TEXT =            0x1000,
+
+/** Indicates that this text object can contain only a single line of text. */
+IA2_STATE_SINGLE_LINE =                0x2000,
+
+/** Indicates that the accessible object is stale.
+
+ This state is used when the accessible object no longer accurately
+  represents the state of the object which it is representing such as when an
+  object is transient or when an object has been or is in the process of being
+  destroyed or when the object's index in its parent has changed.
+*/
+IA2_STATE_STALE =                    0x4000,
+
+/** Indicates that the object implements autocompletion.
+
+ This state indicates that a text control will respond to the input of
+ one ore more characters and cause a sub-item to become selected.  The
+ selection may also result in events fired on the parent object.
+*/
+IA2_STATE_SUPPORTS_AUTOCOMPLETION =    0x8000,
+
+/** Indicates this object is transient.
+
+ An object has this state when its parent object has the state ::IA2_STATE_MANAGES_DESCENDANTS.
+ For example, a list item object may be managed by its parent list object and may only
+ exist as long as the object is actually rendered.  Similarly a table cell's accessible
+ object may exist only while the cell has focus.  However, from the perspective of an
+ assistive technology a transient object behaves like a non-transient object.  As a
+ result it is likely that this state is not of use to an assistive technology, but it
+ is provided in case an assistive technology determines that knowledge of the transient
+ nature of the object is useful and also for harmony with the Linux accessibility API.
+
+ Also, see ::IA2_STATE_MANAGES_DESCENDANTS for more information.
+ */
+IA2_STATE_TRANSIENT =                0x10000,
+
+/** Indicates the orientation of this object is vertical. */
+IA2_STATE_VERTICAL =                0x20000,
+
+/** Indicates this object is checkable.
+
+ The standard checkable objects are check boxes, radio buttons, check box menu
+ items, radio menu items, and toggle buttons.  Since assistive technology will
+ determine that these objects are checkable via the object's role the checkable
+ state is not required.  However, this state is necessary in those cases where
+ an object has a role which is not one of the previously mentioned roles.  An
+ example is a table cell which indicates whether or not an email has an attachment,
+ whether or not an mail is considered spam, and whether or not an email has been read.
+ */
+IA2_STATE_CHECKABLE =                0x40000,
+
+/** Indicates this object is pinned.
+
+ This state indicates that an object is fixed at a certain location.  One example
+ is a browser tab that when pinned cannot be moved until unpinned.  Another example
+ is a movable or floating object that when pinned remains in its pinned location
+ until being unpinned.
+ */
+IA2_STATE_PINNED =                    0x80000
+
+};
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleTable.idl b/src/3rdparty/iaccessible2/idl/AccessibleTable.idl
new file mode 100644
index 0000000..69c99a7
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleTable.idl
@@ -0,0 +1,551 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleTable.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "Accessible2.idl";
+import "IA2CommonTypes.idl";
+
+/** @brief This interface gives access to a two-dimensional table.
+
+ Typically all accessible objects that represent cells or cell-clusters of a table
+  will be at the same time children of the table.  In this case IAccessible2::indexInParent
+  will return the child index which then can be used when calling IAccessibleTable::rowIndex
+  and IAccessibleTable::columnIndex.
+
+ However, in some cases that kind of implementation will not be possible.  When
+  the table cells are not direct children of a table, the object representing
+  the cell can define a "table-cell-index" object attribute identifying the 0
+  based table cell index.  This object attribute is obtained by parsing the
+  attribute string returned by IAccessible2::attributes.  The "table-cell-index"
+  attribute can be used just like a child index of the typical case.  ATs should
+  first test for the presence of the "table-cell-index" attribute and if it is not
+  present then IAccessible2::indexInParent can be used as in the typical case
+  where cells are direct children of the table.
+
+ The range of valid coordinates for this interface are implementation dependent.
+  However, that range includes at least the intervals from the from the first row
+  or column with the index 0 up to the last (but not including) used row or column
+  as returned by IAccessibleTable::nRows and IAccessibleTable::nColumns.
+
+ Note that newer implementations are now using IAccessibleTable2 and IAccessibleTableCell
+  rather than this interface.
+*/
+[object, uuid(35AD8070-C20C-4fb4-B094-F4F7275DD469)]
+interface IAccessibleTable : IUnknown
+{
+
+  /** @brief Returns the accessible object at the specified row and column in
+    the table.  This object could be an IAccessible or an IAccessible2.
+   @param [in] row
+    The 0 based row index for which to retrieve the cell.
+   @param [in] column
+    The 0 based column index for which to retrieve the cell.
+   @param [out] accessible
+    If both row and column index are valid then the corresponding accessible
+    object is returned that represents the requested cell regardless of whether
+    the cell is currently visible (on the screen).
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is NULL
+  */
+  [propget] HRESULT accessibleAt
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Returns the caption for the table.  The returned object could be
+    an IAccessible or an IAccessible2.
+   @param [out] accessible
+    If the table has a caption then a reference to it is returned, else a NULL
+    pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT caption
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Translates the given row and column indexes into the corresponding cell index.
+   @param [in] rowIndex
+    0 based row index for the cell.
+   @param [in] columnIndex
+    0 based column index for the cell.
+   @param [out] cellIndex
+    Returns the 0 based index of the cell at the specified row and column indexes.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+   @note The returned value is not necessarily a child index of the immediate parent.
+    In cases where the table cells are not direct children of the table the index
+    is actually the cell index, i.e. conceptually it's an index into a one dimensional
+    array of cells laid out in row order.
+  */
+  [propget] HRESULT childIndex
+    (
+     [in] long rowIndex,
+     [in] long columnIndex,
+     [out, retval] long *cellIndex
+    );
+
+  /** @brief Returns the description text of the specified column in the table.
+   @param [in] column
+    The 0 based index of the column for which to retrieve the description.
+   @param [out] description
+    Returns the description text of the specified column in the table if such a
+    description exists.  Otherwise a NULL pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed, [out] value is NULL
+  */
+  [propget] HRESULT columnDescription
+    (
+     [in] long column,
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns the number of columns occupied by the accessible object
+    at the specified row and column in the table.
+
+   The result is greater than 1 if the specified cell spans multiple columns.
+   @param [in] row
+    0 based row index of the accessible for which to return the column extent.
+   @param [in] column
+    0 based column index of the accessible for which to return the column extent.
+   @param [out] nColumnsSpanned
+    Returns the 1 based column extent of the specified cell.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+  */
+  [propget] HRESULT columnExtentAt
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] long *nColumnsSpanned
+    );
+
+  /** @brief Returns the column headers as an %IAccessibleTable object.
+
+   Content and size of the returned table are implementation dependent.
+   @param [out] accessibleTable
+    The column header
+   @param [out] startingRowIndex
+    The 0 based row index where the header starts, usually 0.
+   @retval S_OK
+   @retval S_FALSE if there is no header, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT columnHeader
+    (
+     [out] IAccessibleTable **accessibleTable,
+     [out, retval] long *startingRowIndex
+    );
+
+  /** @brief Translates the given cell index into the corresponding column index.
+   @param [in] cellIndex
+    0 based index of the cell in the parent or closest ancestor table.  Typically this
+    is the value returned from IAccessible2::indexInParent, but in the case where the
+    table cells are not direct children of the table this is the cell index specified
+    by the "table-cell-index" object attribute obtained from parsing the attributes
+    string returned by calling IAccessible2::attributes on the cell object.
+   @param [out] columnIndex
+    Returns the 0 based column index of the cell of the specified child or the index of
+    the first column if the child spans multiple columns.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+  */
+  [propget] HRESULT columnIndex
+    (
+     [in] long cellIndex,
+     [out, retval] long *columnIndex
+    );
+
+  /** @brief Returns the total number of columns in table
+   @param [out] columnCount
+    Number of columns in table (including columns outside the current viewport)
+   @retval S_OK
+  */
+  [propget] HRESULT nColumns
+    (
+     [out, retval] long *columnCount
+    );
+
+  /** @brief Returns the total number of rows in table
+   @param [out] rowCount
+    Number of rows in table (including rows outside the current viewport)
+   @retval S_OK
+  */
+  [propget] HRESULT nRows
+    (
+     [out, retval] long *rowCount
+    );
+
+  /** @brief Returns the total number of selected cells
+   @param [out] cellCount
+    Number of cells currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedChildren
+    (
+     [out, retval] long *cellCount
+    );
+
+  /** @brief Returns the total number of selected columns
+   @param [out] columnCount
+    Number of columns currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedColumns
+    (
+     [out, retval] long *columnCount
+    );
+
+  /** @brief Returns the total number of selected rows
+   @param [out] rowCount
+    Number of rows currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedRows
+    (
+     [out, retval] long *rowCount
+    );
+
+  /** @brief Returns the description text of the specified row in the table.
+   @param [in] row
+    The 0 based index of the row for which to retrieve the description.
+   @param [out] description
+    Returns the description text of the specified row in the table if such a
+    description exists.  Otherwise a NULL pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed, [out] value is NULL
+  */
+  [propget] HRESULT rowDescription
+    (
+     [in] long row,
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns the number of rows occupied by the accessible object
+    at the specified row and column in the table.
+
+   The result is greater than 1 if the specified cell spans multiple rows.
+   @param [in] row
+    0 based row index of the accessible for which to return the row extent.
+   @param [in] column
+    0 based column index of the accessible for which to return the row extent.
+   @param [out] nRowsSpanned
+    Returns the row extent of the specified cell.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+  */
+  [propget] HRESULT rowExtentAt
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] long *nRowsSpanned
+    );
+
+  /** @brief Returns the row headers as an %IAccessibleTable object.
+
+   Content and size of the returned table are implementation dependent.
+   @param [out] accessibleTable
+    The row header.
+   @param [out] startingColumnIndex
+    The 0 based column index where the header starts, usually 0.
+   @retval S_OK
+   @retval S_FALSE if there is no header, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT rowHeader
+    (
+     [out] IAccessibleTable **accessibleTable,
+     [out, retval] long *startingColumnIndex
+    );
+
+  /** @brief Translates the given cell index into a row index.
+   @param [in] cellIndex
+    0 based index of the cell in the parent or closest ancestor table.  Typically this
+    is the value returned from IAccessible2::indexInParent, but in the case where the
+    table cells are not direct children of the table this is the cell index specified
+    by the "table-cell-index" object attribute obtained from parsing the attributes
+    string returned by calling IAccessible2::attributes on the cell object.
+   @param [out] rowIndex
+    0 based row index
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+  */
+  [propget] HRESULT rowIndex
+    (
+     [in] long cellIndex,
+     [out, retval] long *rowIndex
+    );
+
+  /** @brief Returns a list of cell indexes currently selected (0 based).
+   @param [in] maxChildren
+    This parameter is ignored. Refer to @ref _arrayConsideration
+    "Special Consideration when using Arrays" for more details.
+   @param [out] children
+    An array of cell indexes of selected cells (each index is 0 based),
+    allocated by the server. Free it with CoTaskMemFree.
+   @param [out] nChildren
+    The number of cell indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedChildren
+    (
+     [in] long maxChildren,
+     [out, size_is(,maxChildren), length_is(,*nChildren)] long **children,
+     [out, retval] long *nChildren
+    );
+
+  /** @brief Returns a list of column indexes currently selected (0 based).
+   @param [in] maxColumns
+    This parameter is ignored. Refer to @ref _arrayConsideration
+    "Special Consideration when using Arrays" for more details.
+   @param [out] columns
+    An array of column indexes of selected columns (each index is 0 based), allocated
+    by the server. Free it with CoTaskMemFree.
+   @param [out] nColumns
+    The number of column indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedColumns
+    (
+     [in] long maxColumns,
+     [out, size_is(,maxColumns), length_is(,*nColumns)] long **columns,
+     [out, retval] long *nColumns
+    );
+
+  /** @brief Returns a list of row indexes currently selected (0 based).
+   @param [in] maxRows
+    This parameter is ignored. Refer to @ref _arrayConsideration
+    "Special Consideration when using Arrays" for more details.
+   @param [out] rows
+    An array of row indexes of selected rows (each index is 0 based), allocated
+    by the server. Free it with CoTaskMemFree.
+   @param [out] nRows
+    The number of row indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedRows
+    (
+     [in] long maxRows,
+     [out, size_is(,maxRows), length_is(,*nRows)] long **rows,
+     [out, retval] long *nRows
+    );
+
+  /** @brief Returns the summary description of the table.  The returned object could be
+    an IAccessible or an IAccessible2.
+   @param [out] accessible
+    Returns a reference to an implementation dependent accessible object
+    representing the table's summary or a NULL pointer if the table
+    does not support a summary.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT summary
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified column is
+    completely selected.
+   @param [in] column
+    0 based index of the column for which to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified column is selected completely and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is FALSE
+  */
+  [propget] HRESULT isColumnSelected
+    (
+     [in] long column,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified row is completely
+    selected.
+   @param [in] row
+    0 based index of the row for which to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified row is selected completely and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is FALSE
+  */
+  [propget] HRESULT isRowSelected
+    (
+     [in] long row,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified cell is selected.
+   @param [in] row
+    0 based index of the row for the cell to determine whether it is selected.
+   @param [in] column
+    0 based index of the column for the cell to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified cell is selected and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is FALSE
+  */
+  [propget] HRESULT isSelected
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Selects a row and unselects all previously selected rows.
+   @param [in] row
+    0 based index of the row to be selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT selectRow
+    (
+     [in] long row
+    );
+
+  /** @brief Selects a column and unselects all previously selected columns.
+   @param [in] column
+    0 based index of the column to be selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT selectColumn
+    (
+     [in] long column
+    );
+
+  /** @brief Unselects one row, leaving other selected rows selected (if any).
+   @param [in] row
+    0 based index of the row to be unselected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT unselectRow
+    (
+     [in] long row
+    );
+
+  /** @brief Unselects one column, leaving other selected columns selected (if any).
+   @param [in] column
+    0 based index of the column to be unselected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT unselectColumn
+    (
+     [in] long column
+    );
+
+  /** @brief Given a cell index, gets the row and column indexes and extents of a cell
+    and whether or not it is selected.
+
+   This is a convenience function.  It is not mandatory to implement it.
+   @param [in] index
+    0 based index of this cell in the table.
+   @param [out] row
+    0 based row index.
+   @param [out] column
+    0 based column index.
+   @param [out] rowExtents
+    Number of cells spanned by this cell in this row.
+   @param [out] columnExtents
+    Number of cells spanned by this cell in this column.
+   @param [out] isSelected
+    Indicates if the specified cell is selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] values are 0s and FALSE respectively
+  */
+  [propget] HRESULT rowColumnExtentsAtIndex
+    (
+     [in] long index,
+     [out] long *row,
+     [out] long *column,
+     [out] long *rowExtents,
+     [out] long *columnExtents,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns the type and extents describing how a table changed.
+
+   Provided for use by the IA2_EVENT_TABLE_MODEL_CHANGED event handler.
+
+   This data is only guaranteed to be valid while the thread notifying the event
+   continues. Once the handler has returned, the validity of the data depends on
+   how the server manages the life cycle of its objects. Also, note that the server
+   may have different life cycle management strategies for controls depending on
+   whether or not a control manages its children. Lists, trees, and tables can have
+   a large number of children and thus it's possible that the child objects for those
+   controls would only be created as needed. Servers should document their life cycle
+   strategy as this will be of interest to assistive technology or script engines
+   accessing data out of process or from other threads. Servers only need to save the
+   most recent row and column values associated with the change and a scope of the
+   entire application is adequate.
+
+   @param [out] modelChange
+    A struct of (type(insert, delete, update), firstRow, lastRow, firstColumn, lastColumn).
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT modelChange
+    (
+     [out, retval] IA2TableModelChange *modelChange
+    );
+
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleTable2.idl b/src/3rdparty/iaccessible2/idl/AccessibleTable2.idl
new file mode 100644
index 0000000..9d7f3e4
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleTable2.idl
@@ -0,0 +1,375 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleTable2.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "Accessible2.idl";
+import "IA2CommonTypes.idl";
+
+/** @brief This interface gives access to a two-dimensional table.
+
+ Please also refer to the IAccessibleTableCell interface.
+
+ If you want to support older applications you should also support the
+  IAccessibleTable inteface.
+*/
+[object, uuid(6167f295-06f0-4cdd-a1fa-02e25153d869)]
+interface IAccessibleTable2 : IUnknown
+{
+
+  /** @brief Returns the accessible object at the specified row and column in
+    the table.  This object could be an IAccessible or an IAccessible2.
+   @param [in] row
+    The 0 based row index for which to retrieve the cell.
+   @param [in] column
+    The 0 based column index for which to retrieve the cell.
+   @param [out] cell
+    If both row and column index are valid then the corresponding accessible
+    object is returned that represents the requested cell regardless of whether
+    the cell is currently visible (on the screen).
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT cellAt
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] IUnknown **cell
+    );
+
+  /** @brief Returns the caption for the table.  The returned object could be
+    an IAccessible or an IAccessible2.
+   @param [out] accessible
+    If the table has a caption then a reference to it is returned, else a NULL
+    pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT caption
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Returns the description text of the specified column in the table.
+   @param [in] column
+    The 0 based index of the column for which to retrieve the description.
+   @param [out] description
+    Returns the description text of the specified column in the table if such a
+    description exists.  Otherwise a NULL pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT columnDescription
+    (
+     [in] long column,
+     [out, retval] BSTR *description
+    );
+
+
+  /** @brief Returns the total number of columns in table
+   @param [out] columnCount
+    Number of columns in table (including columns outside the current viewport)
+   @retval S_OK
+  */
+  [propget] HRESULT nColumns
+    (
+     [out, retval] long *columnCount
+    );
+
+  /** @brief Returns the total number of rows in table
+   @param [out] rowCount
+    Number of rows in table (including rows outside the current viewport)
+   @retval S_OK
+  */
+  [propget] HRESULT nRows
+    (
+     [out, retval] long *rowCount
+    );
+
+  /** @brief Returns the total number of selected cells
+   @param [out] cellCount
+    Number of cells currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedCells
+    (
+     [out, retval] long *cellCount
+    );
+
+  /** @brief Returns the total number of selected columns
+   @param [out] columnCount
+    Number of columns currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedColumns
+    (
+     [out, retval] long *columnCount
+    );
+
+  /** @brief Returns the total number of selected rows
+   @param [out] rowCount
+    Number of rows currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedRows
+    (
+     [out, retval] long *rowCount
+    );
+
+  /** @brief Returns the description text of the specified row in the table.
+   @param [in] row
+    The 0 based index of the row for which to retrieve the description.
+   @param [out] description
+    Returns the description text of the specified row in the table if such a
+    description exists.  Otherwise a NULL pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT rowDescription
+    (
+     [in] long row,
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns a list of accessibles currently selected.
+   @param [out] cells
+    Pointer to an array of references to selected accessibles.  The array is
+    allocated by the server with CoTaskMemAlloc and freed by the client with
+    CoTaskMemFree.
+   @param [out] nSelectedCells
+    The number of accessibles returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedCells
+    (
+     [out, size_is(,*nSelectedCells,)] IUnknown ***cells,
+     [out, retval] long *nSelectedCells
+    );
+
+  /** @brief Returns a list of column indexes currently selected (0 based).
+   @param [out] selectedColumns
+    A pointer to an array of column indexes of selected columns (each index is
+    0 based).  The array is allocated by the server with CoTaskMemAlloc and
+    freed by the client with CoTaskMemFree.
+   @param [out] nColumns
+    The number of column indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedColumns
+    (
+     [out, size_is(,*nColumns)] long **selectedColumns,
+     [out, retval] long *nColumns
+    );
+
+  /** @brief Returns a list of row indexes currently selected (0 based).
+   @param [out] selectedRows
+    An array of row indexes of selected rows (each index is 0 based).  The array
+    is allocated by the server with CoTaskMemAlloc and freed by the client with
+    CoTaskMemFree.
+   @param [out] nRows
+    The number of row indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedRows
+    (
+     [out, size_is(,*nRows)] long **selectedRows,
+     [out, retval] long *nRows
+    );
+
+  /** @brief Returns the summary description of the table.  The returned object could be
+    an IAccessible or an IAccessible2.
+   @param [out] accessible
+    Returns a reference to an implementation dependent accessible object
+    representing the table's summary or a NULL pointer if the table
+    does not support a summary.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT summary
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified column is
+    completely selected.
+   @param [in] column
+    0 based index of the column for which to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified column is selected completely and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT isColumnSelected
+    (
+     [in] long column,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified row is completely
+    selected.
+   @param [in] row
+    0 based index of the row for which to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified row is selected completely and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT isRowSelected
+    (
+     [in] long row,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Selects a row and unselects all previously selected rows.
+
+   The behavior should mimic that of the application, but for those applications
+    which do not have a means in the GUI to select a full row of cells the behavior
+    should be as follows:  First any selected rows in the table are unselected.  Then
+    the entire row of cells for the specified row is selected.  If any of the
+    cells in the selected row span additional rows, the cells in those rows
+    are also selected.
+   @param [in] row
+    0 based index of the row to be selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT selectRow
+    (
+     [in] long row
+    );
+
+  /** @brief Selects a column and unselects all previously selected columns.
+
+   The behavior should mimic that of the application, but for those applications
+    which do not have a means in the GUI to select a full column of cells the behavior
+    should be as follows:  First any selected columns in the table are unselected.  Then
+    the entire column of cells for the specified column is selected.  If any of the
+    cells in the selected column span additional columns, the cells in those columns
+    are also selected.
+   @param [in] column
+    0 based index of the column to be selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT selectColumn
+    (
+     [in] long column
+    );
+
+  /** @brief Unselects one row, leaving other selected rows selected (if any).
+
+   The behavior should mimic that of the application, but for those applications
+    which do not have a means in the GUI to unselect a full row of cells the
+    behavior should be as follows:  The entire row of cells for the specified
+    row is unselected.  If any of the cells in the selected row span additional
+    rows, the cells in those rows are also unselected.
+   @param [in] row
+    0 based index of the row to be unselected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT unselectRow
+    (
+     [in] long row
+    );
+
+  /** @brief Unselects one column, leaving other selected columns selected (if any).
+
+   The behavior should mimic that of the application, but for those applications
+    which do not have a means in the GUI to unselect a full column of cells the
+    behavior should be as follows:  The entire column of cells for the specified
+    column is unselected.  If any of the cells in the selected column span additional
+    columns, the cells in those columns are also unselected.
+   @param [in] column
+    0 based index of the column to be unselected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT unselectColumn
+    (
+     [in] long column
+    );
+
+  /** @brief Returns the type and extents describing how a table changed.
+
+   Provided for use by the IA2_EVENT_TABLE_MODEL_CHANGED event handler.
+
+   This data is only guaranteed to be valid while the thread notifying the event
+   continues. Once the handler has returned, the validity of the data depends on
+   how the server manages the life cycle of its objects. Also, note that the server
+   may have different life cycle management strategies for controls depending on
+   whether or not a control manages its children. Lists, trees, and tables can have
+   a large number of children and thus it's possible that the child objects for those
+   controls would only be created as needed. Servers should document their life cycle
+   strategy as this will be of interest to assistive technology or script engines
+   accessing data out of process or from other threads. Servers only need to save the
+   most recent row and column values associated with the change and a scope of the
+   entire application is adequate.
+
+   @param [out] modelChange
+    A struct of (type(insert, delete, update), firstRow, lastRow, firstColumn, lastColumn).
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT modelChange
+    (
+     [out, retval] IA2TableModelChange *modelChange
+    );
+
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleTableCell.idl b/src/3rdparty/iaccessible2/idl/AccessibleTableCell.idl
new file mode 100644
index 0000000..a4cd988
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleTableCell.idl
@@ -0,0 +1,194 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleTableCell.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "Accessible2.idl";
+
+/** @brief This interface gives access to the cells of a two-dimensional table.
+
+ Please also refer to the IAccessibleTable2 interface.
+
+*/
+[object, uuid(594116B1-C99F-4847-AD06-0A7A86ECE645)]
+interface IAccessibleTableCell : IUnknown
+{
+
+  /** @brief Returns the number of columns occupied by this cell accessible.
+
+   The result is greater than 1 if the specified cell spans multiple columns.
+   @param [out] nColumnsSpanned
+    Returns the 1 based column extent of the specified cell.
+   @retval S_OK
+  */
+  [propget] HRESULT columnExtent
+    (
+     [out, retval] long *nColumnsSpanned
+    );
+
+  /** @brief Returns the column headers as an array of cell accessibles.
+
+   @param [out] cellAccessibles
+    Pointer to an array of references to cell accessibles.  The array is allocated
+    by the server.  Free it with CoTaskMemFree.
+   @param [out] nColumnHeaderCells
+    The number of accessibles returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there is no header, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT columnHeaderCells
+    (
+     [out, size_is(,*nColumnHeaderCells,)] IUnknown ***cellAccessibles,
+     [out, retval] long *nColumnHeaderCells
+    );
+
+  /** @brief Translates this cell accessible into the corresponding column index.
+
+   @param [out] columnIndex
+    Returns the 0 based column index of the cell of the specified cell or the index of
+    the first column if the cell spans multiple columns.
+   @retval S_OK
+  */
+  [propget] HRESULT columnIndex
+    (
+     [out, retval] long *columnIndex
+    );
+
+  /** @brief Returns the number of rows occupied by this cell accessible.
+
+   @param [out] nRowsSpanned
+    Returns the row extent of the specified cell.
+   @retval S_OK
+  */
+  [propget] HRESULT rowExtent
+    (
+     [out, retval] long *nRowsSpanned
+    );
+
+  /** @brief Returns the row headers as an array of cell accessibles.
+
+   @param [out] cellAccessibles
+    Pointer to an array of references to cell accessibles.  The array is allocated
+    by the server.  Free it with CoTaskMemFree.
+   @param [out] nRowHeaderCells
+    The number of accessibles returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there is no header, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT rowHeaderCells
+    (
+     [out, size_is(,*nRowHeaderCells,)] IUnknown ***cellAccessibles,
+     [out, retval] long *nRowHeaderCells
+    );
+
+  /** @brief Translates this cell accessible into the corresponding row index.
+
+   @param [out] rowIndex
+    Returns the 0 based row index of the specified cell or the index of
+    the first row if the cell spans multiple rows.
+   @retval S_OK
+  */
+  [propget] HRESULT rowIndex
+    (
+     [out, retval] long *rowIndex
+    );
+
+  /** @brief Returns a boolean value indicating whether this cell is selected.
+
+   @param [out] isSelected
+    Returns TRUE if the specified cell is selected and FALSE otherwise.
+   @retval S_OK
+  */
+  [propget] HRESULT isSelected
+    (
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Gets the row and column indexes and extents of this cell accessible
+    and whether or not it is selected.
+
+   This is a convenience function.  It is not mandatory to implement it.
+   @param [out] row
+    0 based row index.
+   @param [out] column
+    0 based column index.
+   @param [out] rowExtents
+    Number of cells spanned by this cell in this row.
+   @param [out] columnExtents
+    Number of cells spanned by this cell in this column.
+   @param [out] isSelected
+    Indicates if the specified cell is selected.
+   @retval S_OK
+  */
+  [propget] HRESULT rowColumnExtents
+    (
+     [out] long *row,
+     [out] long *column,
+     [out] long *rowExtents,
+     [out] long *columnExtents,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns a reference to the accessbile of the containing table.
+
+   @param [out] table
+    Returns a reference to the IUnknown of the containing table.
+   @retval S_OK
+  */
+  [propget] HRESULT table
+    (
+     [out, retval] IUnknown **table
+    );
+
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleText.idl b/src/3rdparty/iaccessible2/idl/AccessibleText.idl
new file mode 100644
index 0000000..86fd93a
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleText.idl
@@ -0,0 +1,674 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleText.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+import "IA2CommonTypes.idl";
+
+/** A structure containing a substring and the start and end offsets in the enclosing string.
+
+ IAccessibleText::newText and IAccessibleText::oldText return this struct.
+*/
+typedef struct IA2TextSegment {
+  BSTR text;    ///< A copy of a segment of text taken from an enclosing paragraph.
+  long start;    ///< Index of the first character of the segment in the enclosing text.
+  long end;        ///< Index of the character following the last character of the segment in the enclosing text.
+} IA2TextSegment;
+
+/** This enum defines values which specify a text boundary type.
+
+ IA2_TEXT_BOUNDARY_SENTENCE is optional.  When a method doesn't implement this
+ method it must return S_FALSE.  Typically this feature would not be implemented
+ by an application.  However, if the application developer was not satisfied with
+ how screen readers have handled the reading of sentences this boundary type
+ could be implemented and screen readers could use the application's version of a
+ sentence rather than the screen reader's.
+
+ The rest of the boundary types must be supported.
+
+ This enum is used in IAccessibleText::textBeforeOffset, IAccessibleText::textAtOffset,
+ and IAccessibleText::textAfterOffset.
+*/
+
+enum IA2TextBoundaryType {
+  IA2_TEXT_BOUNDARY_CHAR,        /**< Typically, a single character is returned.  In some cases more than
+                                 one character is returned, for example, when a document contains field
+                                 data such as a field containing a date, time, or footnote reference.
+                                 In this case the caret can move over several characters in one movement
+                                 of the caret.  Note that after the caret moves, the caret offset changes
+                                 by the number of characters in the field, e.g. by 8 characters in the
+                                 following date: 03/26/07. */
+  IA2_TEXT_BOUNDARY_WORD,        /**< The range provided matches the range observed when the application
+                                 processes the Ctrl + left arrow and Ctrl + right arrow key sequences.
+                                 Typically this is from the start of one word to the start of the next, but
+                                 various applications are inconsistent in the handling of the end of a line. */
+  IA2_TEXT_BOUNDARY_SENTENCE,    ///< Range is from start of one sentence to the start of another sentence.
+  IA2_TEXT_BOUNDARY_PARAGRAPH,    ///< Range is from start of one paragraph to the start of another paragraph.
+  IA2_TEXT_BOUNDARY_LINE,        /**< Range is from start of one line to the start of another line. This
+                                 often means that an end-of-line character will appear at the end of the
+                                 range. However in the case of some applications an end-of-line character
+                                 indicates the end of a paragraph and the lines composing the paragraph,
+                                 other than the last line, do not contain an end of line character. */
+  IA2_TEXT_BOUNDARY_ALL            ///< Using this value will cause all text to be returned.
+};
+
+/** @brief This interface gives read-only access to text.
+
+ The %IAccessibleText interface should be implemented by all components
+  that present textual information on the display like  buttons,
+  text entry fields, or text portions of the document window.  The interface
+  provides access to the text's content, attributes, and spatial location.
+  However, text can not be modified with this interface.  That is the task
+  of the IAccessibleEditableText interface.
+
+ The text length, i.e. the number of characters in the text, is
+  returned by IAccessibleText::nCharacters. All methods that operate
+  on particular characters (e.g. IAccessibleText::textAtOffset) use character
+  indices from 0 to length-1. All methods that operate on character positions
+  (e.g. IAccessibleText::text) use indices from 0 to length.
+
+ Please note that accessible text does not necessarily support selection.
+  In this case it should behave as if there where no selection.  An empty
+  selection is used for example to express the current cursor position.
+
+ Refer to @ref _specialOffsets
+  "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+  for information about special offsets that can be used in %IAccessibleText methods.
+
+ E_FAIL is returned in the following cases
+ @li endOffset < startOffset
+ @li endoffset > length
+*/
+[object, uuid(24FD2FFB-3AAD-4a08-8335-A3AD89C0FB4B)]
+interface IAccessibleText : IUnknown
+{
+
+  /** @brief Adds a text selection
+   @param [in] startOffset
+    Starting offset ( 0 based).
+   @param [in] endOffset
+    Offset of first character after new selection (0 based).
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note  Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  HRESULT addSelection
+    (
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Returns text attributes.
+   @param [in] offset
+    Text offset (0 based).  Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [out] startOffset
+    The starting offset of the character range over which all text attributes match
+    those of offset. (0 based)
+   @param [out] endOffset
+    The offset of the first character past the character range over which all text
+    attributes match those of offset. (0 based)
+   @param [out] textAttributes
+    A string of attributes describing the text.  The attributes are described in the
+    <a href="http://www.linuxfoundation.org/en/Accessibility/IAccessible2/TextAttributes">
+    text attributes specification</a> on the %IAccessible2 web site.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] values are 0s and NULL respectively
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT attributes
+    (
+     [in] long offset,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *textAttributes
+    );
+
+  /** @brief Returns the position of the caret.
+
+   Returns the 0-based offset of the caret within the text.  If the text is
+   implemented as a tree of text objects with embed characters in higher levels
+   representing substrings of child text objects and the caret is in one of the
+   child text objects, then the offset in the higher level text object would be
+   at the embed character representing child text object that contains the caret.
+
+   For example, if the string "one two three" is implemented as a two text objects,
+   with a top level text object containing an embed character "one ? three" and a
+   child text object containing "two" and if the caret is in the descendant object
+   just before the 'o' in "two", then:
+   <ul>
+   <li>the caretOffset for the "one ? three" object would be 4, matching the embed character</li>
+   <li>the caretOffset for "two" would be 2, matching the "o"</li>
+   </ul>
+   The caret position/offset is that of the character logically following it, e.g.
+   to the right of it in a left to right language, or to the left of it in a right
+   to left language.
+   @param [out] offset
+    The returned offset is relative to the text represented by this object.
+   @retval S_OK
+   @retval S_FALSE if the caret is not currently active on this object, i.e. the
+    caret is located on some other object.  The returned offset value will be -1.
+   @note S_FALSE (and an offset of -1) will not be returned if the caret is somewhere
+   in the text object or one of its descendants.
+  */
+  [propget] HRESULT caretOffset
+    (
+     [out, retval] long *offset
+    );
+
+
+  /** @brief Returns the bounding box of the specified position.
+
+   The virtual character after the last character of the represented
+    text, i.e. the one at position length is a special case. It represents the
+    current input position and will therefore typically be queried by AT more
+    often than other positions.  Because it does not represent an existing character
+    its bounding box is defined in relation to preceding characters.  It should be
+    roughly equivalent to the bounding box of some character when inserted at the
+    end of the text.  Its height typically being the maximal height of all the
+    characters in the text or the height of the preceding character, its width being
+    at least one pixel so that the bounding box is not degenerate.
+
+   Note that the index 'length' is not always valid.  Whether it is or not is
+    implementation dependent.  It typically is when text is editable or otherwise
+    when on the screen the caret can be placed behind the text.  You can be sure
+    that the index is valid after you have received a ::IA2_EVENT_TEXT_CARET_MOVED
+    event for this index.
+   @param [in] offset
+    Index of the character for which to return its bounding box. The valid range
+    is 0..length.  Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [in] coordType
+    Specifies if the coordinates are relative to the screen or to the parent window.
+   @param [out] x
+    X coordinate of the top left corner of the bounding box of the referenced character.
+   @param [out] y
+    Y coordinate of the top left corner of the bounding box of the referenced character.
+   @param [out] width
+    Width of the bounding box of the referenced character.
+   @param [out] height
+    Height of the bounding box of the referenced character.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT characterExtents
+    (
+     [in] long offset,
+     [in] enum IA2CoordinateType coordType,
+     [out] long *x,
+     [out] long *y,
+     [out] long *width,
+     [out, retval] long *height
+    );
+
+
+  /** @brief Returns the number of active non-contiguous selections
+   @param [out] nSelections
+   @retval S_OK
+  */
+  [propget] HRESULT nSelections
+    (
+     [out, retval] long *nSelections
+    );
+
+  /** @brief Returns the text position for the specified screen position.
+
+   Given a point return the zero-based index of the character under that
+   point.  The same functionality could be achieved by using the bounding
+   boxes for each character as returned by IAccessibleText::characterExtents.
+   The method IAccessibleText::offsetAtPoint, however, can be implemented
+   more efficiently.
+
+   @param [in] x
+    The position's x value for which to look up the index of the character that
+    is rendered on to the display at that point.
+   @param [in] y
+    The position's y value for which to look up the index of the character that
+    is rendered on to the display at that point.
+   @param [in] coordType
+    Screen coordinates or window coordinates.
+   @param [out] offset
+    Index of the character under the given point or -1 if the point
+    is invalid or there is no character under the point.
+   @retval S_OK
+   @retval S_FALSE if nothing to return, [out] value is -1
+
+   @retval E_INVALIDARG if bad [in] passed
+    */
+  [propget] HRESULT offsetAtPoint
+    (
+     [in] long x,
+     [in] long y,
+     [in] enum IA2CoordinateType coordType,
+     [out, retval] long *offset
+    );
+
+  /** @brief Returns the character offsets of Nth active text selection
+
+   Returns the 0-based starting and ending offsets of the Nth selection.  If the
+   text is implemented as a tree of text objects with embed characters in higher
+   levels representing substrings of child text objects, consider the following.
+   If the starting selection offset is in one of the child text objects, then the
+   starting offset in the higher level text object would be at the embed character
+   representing the child text object that contains the starting selection offset.
+   If the ending selection offset is in one of the child text objects, then the
+   ending offset in the higher level text object would be just after the embed
+   character representing the child text object that contains the ending selection
+   offset.
+
+   For example, if the string "one two three" is implemented as a two text objects,
+   with a top level text object containing an embed character "one ? three" and a
+   child text object containing "two" and if the selection is the string "two" then:
+   <ul>
+   <li>the startOffset for the "one ? three" object would be 4, matching the embed character and the endOffset would be 5.</li>
+   <li>the startOffset for the "two" object would be 0, and the endOffset would be 3</li>
+   </ul>
+   Selection offsets are that of the character logically following it, e.g.
+   to the right of it in a left to right language or to the left of it in a right to left language.
+   @param [in] selectionIndex
+    Index of selection (0 based).
+   @param [out] startOffset
+    0 based offset of first selected character
+   @param [out] endOffset
+    0 based offset of one past the last selected character.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT selection
+    (
+     [in] long selectionIndex,
+     [out] long *startOffset,
+     [out, retval] long *endOffset
+    );
+
+  /** @brief Returns the substring between the two given indices.
+
+   The substring starts with the character at startOffset (inclusive) and up to
+    the character at endOffset (exclusive), if startOffset is less or equal
+    endOffset.  If endOffset is lower than startOffset, the result is the same
+    as a call with the two arguments being exchanged.
+
+   The whole text can be requested by passing the indices zero and
+    IAccessibleText::nCharacters. If both indices have the same value, an empty
+    string is returned.
+   @param [in] startOffset
+    Index of the first character to include in the returned string. The valid range
+    is 0..length.
+   @param [in] endOffset
+    Index of the last character to exclude in the returned string. The valid range
+    is 0..length.
+   @param [out] text
+    Returns the substring starting with the character at startOffset (inclusive)
+    and up to the character at endOffset (exclusive), if startOffset is less than
+    or equal to endOffset.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note
+   @li The returned string may be longer than endOffset-startOffset bytes if text
+    contains multi-byte characters.
+   @li Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  [propget] HRESULT text
+    (
+     [in] long startOffset,
+     [in] long endOffset,
+     [out, retval] BSTR *text
+    );
+
+  /** @brief Returns a text portion before the given position.
+
+   Returns the substring of the specified text type that is located before the
+    given character and does not include it. The result of this method should be
+    same as a result for IAccessibleText::textAtOffset with a suitably decreased
+    index value.
+
+   For example, if text type is ::IA2_TEXT_BOUNDARY_WORD, then the complete
+    word that is closest to and located before offset is returned.
+
+   If the index is valid, but no suitable word (or other boundary type) is found, a
+    NULL pointer is returned.
+
+   @param [in] offset
+    Index of the character for which to return the text part before it.  The index
+    character will not be part of the returned string. The valid range is 0..length.
+    Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [in] boundaryType
+    The type of the text portion to return.  See ::IA2TextBoundaryType for the
+    complete list.
+   @param [out] startOffset
+    0 based offset of first character.
+   @param [out] endOffset
+    0 based offset of one past the last character.
+   @param [out] text
+    Returns the requested text portion.  This portion may be empty or invalid when
+    no appropriate text portion is found or text type is invalid.
+   @retval S_OK
+   @retval S_FALSE if the requested boundary type is not implemented, such as
+    ::IA2_TEXT_BOUNDARY_SENTENCE, or if there is nothing to return;
+    [out] values are 0s and NULL respectively
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT textBeforeOffset
+    (
+     [in] long offset,
+     [in] enum IA2TextBoundaryType boundaryType,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *text
+    );
+
+  /** @brief Returns a text portion after the given position.
+
+   Returns the substring of the specified text type that is located after the
+    given character and does not include it. The result of this method should be
+    same as a result for IAccessibleText::textAtOffset with a suitably increased
+    index value.
+
+   For example, if text type is ::IA2_TEXT_BOUNDARY_WORD, then the complete
+    word that is closest to and located after offset is returned.
+
+   If the index is valid, but no suitable word (or other text type) is found, a
+    NULL pointer is returned.
+
+   @param [in] offset
+    Index of the character for which to return the text part after it.  The index
+    character will not be part of the returned string. The valid range is 0..length.
+    Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [in] boundaryType
+    The type of the text portion to return.  See ::IA2TextBoundaryType for the complete
+    list.
+   @param [out] startOffset
+    0 based offset of first character.
+   @param [out] endOffset
+    0 based offset of one past the last character.
+   @param [out] text
+    Returns the requested text portion.  This portion may be empty or invalid when
+    no appropriate text portion is found or text type is invalid.
+   @retval S_OK
+   @retval S_FALSE if the requested boundary type is not implemented, such as
+    ::IA2_TEXT_BOUNDARY_SENTENCE, or if there is nothing to return;
+    [out] values are 0s and NULL respectively
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT textAfterOffset
+    (
+     [in] long offset,
+     [in] enum IA2TextBoundaryType boundaryType,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *text
+    );
+
+  /** @brief Returns a text portion that spans the given position.
+
+   Returns the substring of the specified text type at the specified offset.
+
+   If the index is valid, but no suitable word (or other text type) is found, a
+    NULL pointer is returned.
+
+   @param [in] offset
+    Index of the character for which to return the text part before it.  The index
+    character will not be part of the returned string. The valid range is 0..length.
+    Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [in] boundaryType
+    The type of the text portion to return.  See ::IA2TextBoundaryType for the complete
+    list.
+   @param [out] startOffset
+    0 based offset of first character.
+   @param [out] endOffset
+    0 based offset of one past the last character.
+   @param [out] text
+    Returns the requested text portion.  This portion may be empty or invalid when
+    no appropriate text portion is found or text type is invalid.
+   @retval S_OK
+   @retval S_FALSE if the requested boundary type is not implemented, such as
+    ::IA2_TEXT_BOUNDARY_SENTENCE, or if there is nothing to return;
+    [out] values are 0s and NULL respectively
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT textAtOffset
+    (
+     [in] long offset,
+     [in] enum IA2TextBoundaryType boundaryType,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *text
+    );
+
+  /** @brief Unselects a range of text.
+   @param [in] selectionIndex
+    Index of selection to remove (0 based).
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT removeSelection
+    (
+     [in] long selectionIndex
+    );
+
+  /** @brief Sets the position of the caret.
+
+   The caret position/offset is that of the character logically following it,
+   e.g. to the right of it in a left to right language.
+
+   Setting the caret position may or may not alter the current selection.  A
+    change of the selection is notified to the accessibility event listeners with
+    an ::IA2_EVENT_TEXT_SELECTION_CHANGED event.
+
+   When the new caret position differs from the old one (which, of course, is the
+    standard case) this is notified to the accessibility event listeners with an
+    ::IA2_EVENT_TEXT_CARET_MOVED event.
+   @param [in] offset
+    The new index of the caret.  This caret is actually placed to the left side of
+    the character with that index.  An index of 0 places the caret so that the next
+    insertion goes before the first character.  An index of IAccessibleText::nCharacters
+    leads to insertion after the last character.  Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @retval S_OK
+   @retval E_FAIL if the caret cannot be set
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT setCaretOffset
+    (
+     [in] long offset
+    );
+
+  /** @brief Changes the bounds of an existing selection.
+   @param [in] selectionIndex
+    Index of selection to change (0 based)
+   @param [in] startOffset
+    New starting offset (0 based)
+   @param [in] endOffset
+    New ending offset (0 based) - the offset of the character just past the last character of the selection.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  HRESULT setSelection
+    (
+     [in] long selectionIndex,
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Returns total number of characters.
+
+   Note that this may be different than the total number of bytes required to store the
+    text, if the text contains multi-byte characters.
+   @param [out] nCharacters
+   @retval S_OK
+  */
+  [propget] HRESULT nCharacters
+    (
+     [out, retval] long *nCharacters
+    );
+
+  /** @brief Makes a specific part of string visible on screen.
+   @param [in] startIndex
+    0 based character offset.
+   @param [in] endIndex
+    0 based character offset - the offset of the character just past the last character of the string.
+   @param [in] scrollType
+    Defines where the object should be placed on the screen.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  HRESULT scrollSubstringTo
+    (
+     [in] long startIndex,
+     [in] long endIndex,
+     [in] enum IA2ScrollType scrollType
+    );
+
+  /** @brief Moves the top left of a substring to a specified location.
+
+   @param [in] startIndex
+    0 based character offset.
+   @param [in] endIndex
+    0 based character offset - the offset of the character just past the last character of the string.
+   @param [in] coordinateType
+    Specifies whether the coordinates are relative to the screen or the parent object.
+   @param [in] x
+    Defines the x coordinate.
+   @param [in] y
+    Defines the y coordinate.
+   @retval S_OK
+   @retval S_FALSE if the object is already at the specified location.
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  HRESULT scrollSubstringToPoint
+    (
+     [in] long startIndex,
+     [in] long endIndex,
+     [in] enum IA2CoordinateType coordinateType,
+     [in] long x,
+     [in] long y
+    );
+
+  /** @brief Returns any inserted text.
+
+   Provided for use by the ::IA2_EVENT_TEXT_INSERTED and ::IA2_EVENT_TEXT_UPDATED
+    event handlers.
+
+   This data is only guaranteed to be valid while the thread notifying the event
+   continues. Once the handler has returned, the validity of the data depends on
+   how the server manages the life cycle of its objects. Also, note that the server
+   may have different life cycle management strategies for controls depending on
+   whether or not a control manages its children. Lists, trees, and tables can have
+   a large number of children and thus it's possible that the child objects for those
+   controls would only be created as needed. Servers should document their life cycle
+   strategy as this will be of interest to assistive technology or script engines
+   accessing data out of process or from other threads. Servers only need to save the
+   last inserted block of text and a scope of the entire application is adequate.
+
+   @param [out] newText
+    The text that was just inserted.
+   @retval S_OK
+   @retval S_FALSE If there is nothing to return, the values of IA2TextSegment
+    struct are set as follows:  text = NULL, start = 0, end = 0.
+
+  */
+  [propget] HRESULT newText
+    (
+     [out, retval] IA2TextSegment *newText
+    );
+
+  /** @brief Returns any removed text.
+
+   Provided for use by the IA2_EVENT_TEXT_REMOVED/UPDATED event handlers.
+
+   This data is only guaranteed to be valid while the thread notifying the event
+   continues. Once the handler has returned, the validity of the data depends on
+   how the server manages the life cycle of its objects. Also, note that the server
+   may have different life cycle management strategies for controls depending on
+   whether or not a control manages its children. Lists, trees, and tables can have
+   a large number of children and thus it's possible that the child objects for those
+   controls would only be created as needed. Servers should document their life cycle
+   strategy as this will be of interest to assistive technology or script engines
+   accessing data out of process or from other threads. Servers only need to save the
+   last removed block of text and a scope of the entire application is adequate.
+
+   @param [out] oldText
+    The text that was just removed.
+   @retval S_OK
+   @retval S_FALSE If there is nothing to return, the values of IA2TextSegment
+    struct are set as follows:  text = NULL, start = 0, end = 0.
+  */
+  [propget] HRESULT oldText
+    (
+     [out, retval] IA2TextSegment *oldText
+    );
+
+}
diff --git a/src/3rdparty/iaccessible2/idl/AccessibleValue.idl b/src/3rdparty/iaccessible2/idl/AccessibleValue.idl
new file mode 100644
index 0000000..cd013d7
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/AccessibleValue.idl
@@ -0,0 +1,136 @@
+/*************************************************************************
+ *
+ *  File Name (AccessibleValue.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+
+/** @brief This interface gives access to a single numerical value.
+
+ The %IAccessibleValue interface represents a single numerical value and should
+  be implemented by any class that supports numerical value like progress bars
+  and spin boxes.  This interface lets you access the value and its upper and
+  lower bounds.
+*/
+[object, uuid(35855B5B-C566-4fd0-A7B1-E65465600394)]
+interface IAccessibleValue : IUnknown
+{
+
+  /** @brief Returns the value of this object as a number.
+
+   The exact return type is implementation dependent.  Typical types are long and
+    double.
+   @param [out] currentValue
+    Returns the current value represented by this object.  See the section about
+    @ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is a VARIANT with vt = VT_EMPTY
+  */
+  [propget] HRESULT currentValue
+    (
+     [out, retval] VARIANT *currentValue
+    );
+
+  /** @brief Sets the value of this object to the given number.
+
+   The argument is clipped to the valid interval whose upper and lower
+    bounds are returned by the methods IAccessibleValue::maximumValue and
+    IAccessibleValue::minimumValue, i.e. if it is     lower than the minimum
+    value the new value will be the minimum and if it is greater than the
+    maximum then the new value will be the maximum.
+
+   @param [in] value
+    The new value represented by this object.  The set of admissible types for
+    this argument is implementation dependent.
+   @retval S_OK
+  */
+  HRESULT setCurrentValue
+    (
+     [in] VARIANT value
+    );
+
+  /** @brief Returns the maximal value that can be represented by this object.
+
+   The type of the returned value is implementation dependent.  It does not have
+    to be the same type as that returned by method IAccessibleValue::currentValue.
+
+   @param [out] maximumValue
+    Returns the maximal value in an implementation dependent type. If this object
+    has no upper bound then an empty object is returned.  See the section about
+    @ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is a VARIANT with vt = VT_EMPTY
+  */
+  [propget] HRESULT maximumValue
+    (
+     [out, retval] VARIANT *maximumValue
+    );
+
+  /** @brief Returns the minimal value that can be represented by this object.
+
+   The type of the returned value is implementation dependent.  It does not have
+    to be the same type as that returned by method IAccessibleValue::currentValue.
+
+   @param [out] minimumValue
+    Returns the minimal value in an implementation dependent type. If this object
+    has no lower bound then an empty object is returned.  See the section about
+    @ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is a VARIANT with vt = VT_EMPTY
+  */
+  [propget] HRESULT minimumValue
+    (
+     [out, retval] VARIANT *minimumValue
+    );
+
+};
diff --git a/src/3rdparty/iaccessible2/idl/IA2CommonTypes.idl b/src/3rdparty/iaccessible2/idl/IA2CommonTypes.idl
new file mode 100644
index 0000000..d3da110
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/IA2CommonTypes.idl
@@ -0,0 +1,191 @@
+/*************************************************************************
+ *
+ *  File Name (IA2CommonTypes.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+ /** These constants control the scrolling of an object or substring into a window.
+
+ This enum is used in IAccessible2::scrollTo and IAccessibleText::scrollSubstringTo.
+*/
+enum IA2ScrollType {
+
+  /** Scroll the top left corner of the object or substring such that the top left
+   corner (and as much as possible of the rest of the object or substring) is within
+   the top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_TOP_LEFT,
+
+  /** Scroll the bottom right corner of the object or substring such that the bottom right
+   corner (and as much as possible of the rest of the object or substring) is within
+   the top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_BOTTOM_RIGHT,
+
+  /** Scroll the top edge of the object or substring such that the top edge
+   (and as much as possible of the rest of the object or substring) is within the
+   top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_TOP_EDGE,
+
+  /** Scroll the bottom edge of the object or substring such that the bottom edge
+   (and as much as possible of the rest of the object or substring) is within the
+   top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_BOTTOM_EDGE,
+
+  /** Scroll the left edge of the object or substring such that the left edge
+   (and as much as possible of the rest of the object or substring) is within the
+   top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_LEFT_EDGE,
+
+  /** Scroll the right edge of the object or substring such that the right edge
+   (and as much as possible of the rest of the object or substring) is within the
+   top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_RIGHT_EDGE,
+
+  /** Scroll the object or substring such that as much as possible of the
+   object or substring is within the top level window.  The placement of
+   the object is dependent on the application.  For example, the object or
+   substring may be scrolled to to closest edge, the furthest edge, or midway
+   between those two edges.
+  */
+  IA2_SCROLL_TYPE_ANYWHERE
+};
+
+/** These constants define which coordinate system a point is located in.
+
+ This enum is used in IAccessible2::scrollToPoint, IAccessibleImage::imagePosition,
+ IAccessibleText::characterExtents, and IAccessibleText::offsetAtPoint, and
+ IAccessibleText::scrollSubstringToPoint.
+*/
+enum IA2CoordinateType {
+
+  /// The coordinates are relative to the screen.
+  IA2_COORDTYPE_SCREEN_RELATIVE,
+
+  /** The coordinates are relative to the upper left corner of the bounding box
+   of the immediate parent.
+  */
+  IA2_COORDTYPE_PARENT_RELATIVE
+
+};
+
+/** Special offsets for use in IAccessibleText and IAccessibleEditableText methods
+
+  Refer to @ref _specialOffsets
+  "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+  for more information.
+*/
+enum IA2TextSpecialOffsets {
+  IA2_TEXT_OFFSET_LENGTH = -1,    /**< This offset is equivalent to the length of the string.  It eliminates
+                                 the need to call IAccessibleText::nCharacters. */
+  IA2_TEXT_OFFSET_CARET = -2    /**< This offset signifies that the text related to the physical location
+                                 of the caret should be used. */
+};
+
+/** These constants specify the kind of change made to a table.
+
+   This enum is used in the IA2TableModelChange struct which in turn is used by
+   IAccessibleTable::modelChange and IAccessibleTable2::modelChange.
+*/
+enum IA2TableModelChangeType {
+  IA2_TABLE_MODEL_CHANGE_INSERT,  // = 0;
+  IA2_TABLE_MODEL_CHANGE_DELETE,
+  IA2_TABLE_MODEL_CHANGE_UPDATE
+};
+
+/** A structure defining the type of and extents of changes made to a table
+
+ IAccessibleTable::modelChange and IAccessibleTable2::modelChange return this struct.
+ In the case of an insertion or change the row and column offsets define the boundaries
+ of the inserted or changed subtable after the operation.  In the case of a deletion
+ the row and column offsets define the boundaries of the subtable being removed before
+ the removal.
+*/
+typedef struct IA2TableModelChange {
+  enum IA2TableModelChangeType type;    // insert, delete, update
+  long firstRow;        ///< 0 based, inclusive
+  long lastRow;            ///< 0 based, inclusive
+  long firstColumn;        ///< 0 based, inclusive
+  long lastColumn;        ///< 0 based, inclusive
+} IA2TableModelChange;
diff --git a/src/3rdparty/iaccessible2/idl/IA2TypeLibrary.idl b/src/3rdparty/iaccessible2/idl/IA2TypeLibrary.idl
new file mode 100644
index 0000000..7753825
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/IA2TypeLibrary.idl
@@ -0,0 +1,94 @@
+/*************************************************************************
+ *
+ *  File Name (IA2TypeLibrary.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+// This is not a standalone file.  It is to be appended to the end of the
+// merged IDL file.
+
+cpp_quote("")
+cpp_quote("// Type Library Definitions")
+cpp_quote("")
+
+[
+    uuid(c974e070-3787-490a-87b0-e333b06ca1e2),
+    helpstring("IAccessible2 Type Library"),
+    version(1.2),
+    hidden
+]
+
+library IAccessible2Lib
+{
+    importlib ("stdole2.tlb");
+    importlib ("oleacc.dll");
+    interface IAccessible2;
+    interface IAccessibleAction;
+    interface IAccessibleApplication;
+    interface IAccessibleComponent;
+    interface IAccessibleEditableText;
+    interface IAccessibleHyperlink;
+    interface IAccessibleHypertext;
+    interface IAccessibleImage;
+    interface IAccessibleRelation;
+    interface IAccessibleTable;
+    interface IAccessibleTable2;
+    interface IAccessibleTableCell;
+    interface IAccessibleText;
+    interface IAccessibleValue;
+    enum IA2CoordinateType;
+    enum IA2EventID;
+    enum IA2Role;
+    enum IA2ScrollType;
+    enum IA2States;
+    enum IA2TableModelChangeType;
+    enum IA2TextBoundaryType;
+    enum IA2TextSpecialOffsets;
+}
diff --git a/src/3rdparty/iaccessible2/idl/Makefile b/src/3rdparty/iaccessible2/idl/Makefile
new file mode 100644
index 0000000..eb56d9f
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/Makefile
@@ -0,0 +1,58 @@
+
+MIDL        = midl
+MIDL_OPTS   = /out ..\generated
+
+first: all
+
+all: x86 amd64
+
+MIDL_OPTS   = /out ..\generated\x86 /env win32
+
+x86:
+	-del ..\generated\x86\dlldata.c
+	-md ..\generated\x86
+	$(MIDL) $(MIDL_OPTS) Accessible2.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleAction.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleApplication.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleComponent.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleEditableText.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleEventID.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleHyperlink.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleHypertext.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleImage.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleRelation.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleRole.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleStates.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleTable.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleTable2.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleTableCell.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleText.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleValue.idl
+	$(MIDL) $(MIDL_OPTS) IA2CommonTypes.idl
+	$(MIDL) $(MIDL_OPTS) IA2TypeLibrary.idl
+
+MIDL_OPTS   = /out ..\generated\amd64 /env amd64
+
+amd64:
+	-del ..\generated\amd64\dlldata.c
+	-md ..\generated\amd64
+	$(MIDL) $(MIDL_OPTS) Accessible2.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleAction.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleApplication.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleComponent.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleEditableText.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleEventID.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleHyperlink.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleHypertext.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleImage.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleRelation.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleRole.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleStates.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleTable.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleTable2.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleTableCell.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleText.idl
+	$(MIDL) $(MIDL_OPTS) AccessibleValue.idl
+	$(MIDL) $(MIDL_OPTS) IA2CommonTypes.idl
+	$(MIDL) $(MIDL_OPTS) IA2TypeLibrary.idl
+
diff --git a/src/3rdparty/iaccessible2/idl/README b/src/3rdparty/iaccessible2/idl/README
new file mode 100644
index 0000000..0a299f1
--- /dev/null
+++ b/src/3rdparty/iaccessible2/idl/README
@@ -0,0 +1,6 @@
+Just type
+    nmake
+in this directory to generate the files from the idl files.
+The generated files will be put in
+..\generated\x86 and ..\generated\amd64
+
diff --git a/src/gui/accessible/qaccessible2.h b/src/gui/accessible/qaccessible2.h
index 61e46eb..af7dea5 100644
--- a/src/gui/accessible/qaccessible2.h
+++ b/src/gui/accessible/qaccessible2.h
@@ -164,6 +164,9 @@ public:
     virtual bool isSelected() const = 0;
 
     //            Gets the row and column indexes and extents of this cell accessible and whether or not it is selected.
+    //          ### Is this really needed??
+    //
+    //          ### Maybe change to QSize cellSize(), we already have accessors for the row, column and selected
     virtual void rowColumnExtents(int *row, int *column, int *rowExtents, int *columnExtents, bool *selected) const = 0;
     //            Returns a reference to the accessbile of the containing table.
     virtual QAccessibleInterface* table() const = 0;
diff --git a/src/plugins/platforms/windows/accessible/accessible.pri b/src/plugins/platforms/windows/accessible/accessible.pri
new file mode 100644
index 0000000..bf25ad8
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/accessible.pri
@@ -0,0 +1,15 @@
+
+SOURCES += \
+    $$PWD/qwindowsmsaaaccessible.cpp \
+    $$PWD/qwindowsaccessibility.cpp \
+    $$PWD/iaccessible2.cpp \
+    $$PWD/comutils.cpp
+
+HEADERS += \
+    $$PWD/qwindowsmsaaaccessible.h \
+    $$PWD/qwindowsaccessibility.h \
+    $$PWD/iaccessible2.h \
+    $$PWD/comutils.h
+
+
+include(../../../../3rdparty/iaccessible2/iaccessible2.pri)
diff --git a/src/plugins/platforms/windows/accessible/comutils.cpp b/src/plugins/platforms/windows/accessible/comutils.cpp
new file mode 100644
index 0000000..9a0fce2
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/comutils.cpp
@@ -0,0 +1,641 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <ocidl.h>
+#include <olectl.h>
+
+#include "comutils.h"
+#include <QtCore/qdatetime.h>
+#include <QtGui/qpixmap.h>
+#include <QtGui/qfont.h>
+
+
+#include <QtCore/qvariant.h>
+#include <QtCore/qbytearray.h>
+#include <QtGui/qcolor.h>
+
+static DATE QDateTimeToDATE(const QDateTime &dt)
+{
+    if (!dt.isValid() || dt.isNull())
+        return 949998;  // Special value for no date (01/01/4501)
+
+    SYSTEMTIME stime;
+    memset(&stime, 0, sizeof(stime));
+    QDate date = dt.date();
+    QTime time = dt.time();
+    if (date.isValid() && !date.isNull()) {
+        stime.wDay = date.day();
+        stime.wMonth = date.month();
+        stime.wYear = date.year();
+    }
+    if (time.isValid() && !time.isNull()) {
+        stime.wMilliseconds = time.msec();
+        stime.wSecond = time.second();
+        stime.wMinute = time.minute();
+        stime.wHour = time.hour();
+    }
+
+    double vtime;
+    SystemTimeToVariantTime(&stime, &vtime);
+
+    return vtime;
+}
+
+inline uint QColorToOLEColor(const QColor &col)
+{
+    return qRgba(col.blue(), col.green(), col.red(), 0x00);
+}
+
+bool QVariantToVARIANT(const QVariant &var, VARIANT &arg, const QByteArray &typeName, bool out)
+{
+    QVariant qvar = var;
+    // "type" is the expected type, so coerce if necessary
+    QVariant::Type proptype = typeName.isEmpty() ? QVariant::Invalid : QVariant::nameToType(typeName);
+    if (proptype == QVariant::UserType && !typeName.isEmpty()) {
+        if (typeName == "short" || typeName == "char")
+            proptype = QVariant::Int;
+        else if (typeName == "float")
+            proptype = QVariant::Double;
+    }
+    if (proptype != QVariant::Invalid && proptype != QVariant::UserType && proptype != qvar.type()) {
+        if (qvar.canConvert(proptype))
+            qvar.convert(proptype);
+        else
+            qvar = QVariant(proptype);
+    }
+
+    if (out && arg.vt == (VT_VARIANT|VT_BYREF) && arg.pvarVal) {
+        return QVariantToVARIANT(var, *arg.pvarVal, typeName, false);
+    }
+
+    if (out && proptype == QVariant::UserType && typeName == "QVariant") {
+        VARIANT *pVariant = new VARIANT;
+        QVariantToVARIANT(var, *pVariant, QByteArray(), false);
+        arg.vt = VT_VARIANT|VT_BYREF;
+        arg.pvarVal = pVariant;
+        return true;
+    }
+
+    switch ((int)qvar.type()) {
+    case QVariant::String:
+        if (out && arg.vt == (VT_BSTR|VT_BYREF)) {
+            if (*arg.pbstrVal)
+                SysFreeString(*arg.pbstrVal);
+            *arg.pbstrVal = QStringToBSTR(qvar.toString());
+            arg.vt = VT_BSTR|VT_BYREF;
+        } else {
+            arg.vt = VT_BSTR;
+            arg.bstrVal = QStringToBSTR(qvar.toString());
+            if (out) {
+                arg.pbstrVal = new BSTR(arg.bstrVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+
+    case QVariant::Int:
+        if (out && arg.vt == (VT_I4|VT_BYREF)) {
+            *arg.plVal = qvar.toInt();
+        } else {
+            arg.vt = VT_I4;
+            arg.lVal = qvar.toInt();
+            if (out) {
+                if (typeName == "short") {
+                    arg.vt = VT_I2;
+                    arg.piVal = new short(arg.lVal);
+                } else if (typeName == "char") {
+                    arg.vt = VT_I1;
+                    arg.pcVal= new char(arg.lVal);
+                } else {
+                    arg.plVal = new long(arg.lVal);
+                }
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+
+    case QVariant::UInt:
+        if (out && (arg.vt == (VT_UINT|VT_BYREF) || arg.vt == (VT_I4|VT_BYREF))) {
+            *arg.puintVal = qvar.toUInt();
+        } else {
+            arg.vt = VT_UINT;
+            arg.uintVal = qvar.toUInt();
+            if (out) {
+                arg.puintVal = new uint(arg.uintVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+
+    case QVariant::LongLong:
+        if (out && arg.vt == (VT_CY|VT_BYREF)) {
+            arg.pcyVal->int64 = qvar.toLongLong();
+#if !defined(Q_OS_WINCE) && defined(_MSC_VER) && _MSC_VER >= 1400
+        } else if (out && arg.vt == (VT_I8|VT_BYREF)) {
+            *arg.pllVal = qvar.toLongLong();
+        } else {
+            arg.vt = VT_I8;
+            arg.llVal = qvar.toLongLong();
+            if (out) {
+                arg.pllVal = new LONGLONG(arg.llVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+#else
+        } else {
+            arg.vt = VT_CY;
+            arg.cyVal.int64 = qvar.toLongLong();
+            if (out) {
+                arg.pcyVal = new CY(arg.cyVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+#endif
+        break;
+
+    case QVariant::ULongLong:
+        if (out && arg.vt == (VT_CY|VT_BYREF)) {
+            arg.pcyVal->int64 = qvar.toULongLong();
+#if !defined(Q_OS_WINCE) && defined(_MSC_VER) && _MSC_VER >= 1400
+        } else if (out && arg.vt == (VT_UI8|VT_BYREF)) {
+            *arg.pullVal = qvar.toULongLong();
+        } else {
+            arg.vt = VT_UI8;
+            arg.ullVal = qvar.toULongLong();
+            if (out) {
+                arg.pullVal = new ULONGLONG(arg.ullVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+#else
+        } else {
+            arg.vt = VT_CY;
+            arg.cyVal.int64 = qvar.toULongLong();
+            if (out) {
+                arg.pcyVal = new CY(arg.cyVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+
+#endif
+
+        break;
+
+    case QVariant::Bool:
+        if (out && arg.vt == (VT_BOOL|VT_BYREF)) {
+            *arg.pboolVal = qvar.toBool() ? VARIANT_TRUE : VARIANT_FALSE;
+        } else {
+            arg.vt = VT_BOOL;
+            arg.boolVal = qvar.toBool() ? VARIANT_TRUE : VARIANT_FALSE;
+            if (out) {
+                arg.pboolVal = new short(arg.boolVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+    case QVariant::Double:
+        if (out && arg.vt == (VT_R8|VT_BYREF)) {
+            *arg.pdblVal = qvar.toDouble();
+        } else {
+            arg.vt = VT_R8;
+            arg.dblVal = qvar.toDouble();
+            if (out) {
+                if (typeName == "float") {
+                    arg.vt = VT_R4;
+                    arg.pfltVal = new float(arg.dblVal);
+                } else {
+                    arg.pdblVal = new double(arg.dblVal);
+                }
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+    case QVariant::Color:
+        if (out && arg.vt == (VT_COLOR|VT_BYREF)) {
+
+            *arg.plVal = QColorToOLEColor(qvariant_cast<QColor>(qvar));
+        } else {
+            arg.vt = VT_COLOR;
+            arg.lVal = QColorToOLEColor(qvariant_cast<QColor>(qvar));
+            if (out) {
+                arg.plVal = new long(arg.lVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+
+    case QVariant::Date:
+    case QVariant::Time:
+    case QVariant::DateTime:
+        if (out && arg.vt == (VT_DATE|VT_BYREF)) {
+            *arg.pdate = QDateTimeToDATE(qvar.toDateTime());
+        } else {
+            arg.vt = VT_DATE;
+            arg.date = QDateTimeToDATE(qvar.toDateTime());
+            if (out) {
+                arg.pdate = new DATE(arg.date);
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+#if 0   // not a value with min/max semantics
+    case QVariant::Font:
+        if (out && arg.vt == (VT_DISPATCH|VT_BYREF)) {
+            if (*arg.ppdispVal)
+                (*arg.ppdispVal)->Release();
+            *arg.ppdispVal = QFontToIFont(qvariant_cast<QFont>(qvar));
+        } else {
+            arg.vt = VT_DISPATCH;
+            arg.pdispVal = QFontToIFont(qvariant_cast<QFont>(qvar));
+            if (out) {
+                arg.ppdispVal = new IDispatch*(arg.pdispVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+    case QVariant::Pixmap:
+        if (out && arg.vt == (VT_DISPATCH|VT_BYREF)) {
+            if (*arg.ppdispVal)
+                (*arg.ppdispVal)->Release();
+            *arg.ppdispVal = QPixmapToIPicture(qvariant_cast<QPixmap>(qvar));
+        } else {
+            arg.vt = VT_DISPATCH;
+            arg.pdispVal = QPixmapToIPicture(qvariant_cast<QPixmap>(qvar));
+            if (out) {
+                arg.ppdispVal = new IDispatch*(arg.pdispVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+    case QVariant::Cursor:
+        {
+#ifndef QT_NO_CURSOR
+            int shape = qvariant_cast<QCursor>(qvar).shape();
+            if (out && (arg.vt & VT_BYREF)) {
+                switch (arg.vt & ~VT_BYREF) {
+                case VT_I4:
+                    *arg.plVal = shape;
+                    break;
+                case VT_I2:
+                    *arg.piVal = shape;
+                    break;
+                case VT_UI4:
+                    *arg.pulVal = shape;
+                    break;
+                case VT_UI2:
+                    *arg.puiVal = shape;
+                    break;
+                case VT_INT:
+                    *arg.pintVal = shape;
+                    break;
+                case VT_UINT:
+                    *arg.puintVal = shape;
+                    break;
+                }
+            } else {
+                arg.vt = VT_I4;
+                arg.lVal = shape;
+                if (out) {
+                    arg.plVal = new long(arg.lVal);
+                    arg.vt |= VT_BYREF;
+                }
+            }
+#endif
+        }
+        break;
+
+    case QVariant::List:
+        {
+            const QList<QVariant> list = qvar.toList();
+            const int count = list.count();
+            VARTYPE vt = VT_VARIANT;
+            QVariant::Type listType = QVariant::LastType; // == QVariant
+            if (!typeName.isEmpty() && typeName.startsWith("QList<")) {
+                const QByteArray listTypeName = typeName.mid(6, typeName.length() - 7); // QList<int> -> int
+                listType = QVariant::nameToType(listTypeName);
+            }
+
+            VARIANT variant;
+            void *pElement = &variant;
+            switch (listType) {
+            case QVariant::Int:
+                vt = VT_I4;
+                pElement = &variant.lVal;
+                break;
+            case QVariant::Double:
+                vt = VT_R8;
+                pElement = &variant.dblVal;
+                break;
+            case QVariant::DateTime:
+                vt = VT_DATE;
+                pElement = &variant.date;
+                break;
+            case QVariant::Bool:
+                vt = VT_BOOL;
+                pElement = &variant.boolVal;
+                break;
+            case QVariant::LongLong:
+#if !defined(Q_OS_WINCE) && defined(_MSC_VER) && _MSC_VER >= 1400
+                vt = VT_I8;
+                pElement = &variant.llVal;
+#else
+                vt = VT_CY;
+                pElement = &variant.cyVal;
+#endif
+                break;
+            default:
+                break;
+            }
+            SAFEARRAY *array = 0;
+            bool is2D = false;
+            // If the first element in the array is a list the whole list is
+            // treated as a 2D array. The column count is taken from the 1st element.
+            if (count) {
+                QVariantList col = list.at(0).toList();
+                int maxColumns = col.count();
+                if (maxColumns) {
+                    is2D = true;
+                    SAFEARRAYBOUND rgsabound[2] = { {0} };
+                    rgsabound[0].cElements = count;
+                    rgsabound[1].cElements = maxColumns;
+                    array = SafeArrayCreate(VT_VARIANT, 2, rgsabound);
+                    LONG rgIndices[2];
+                    for (LONG i = 0; i < count; ++i) {
+                        rgIndices[0] = i;
+                        QVariantList columns = list.at(i).toList();
+                        int columnCount = qMin(maxColumns, columns.count());
+                        for (LONG j = 0;  j < columnCount; ++j) {
+                            QVariant elem = columns.at(j);
+                            VariantInit(&variant);
+                            QVariantToVARIANT(elem, variant, elem.typeName());
+                            rgIndices[1] = j;
+                            SafeArrayPutElement(array, rgIndices, pElement);
+                            clearVARIANT(&variant);
+                        }
+                    }
+
+                }
+            }
+            if (!is2D) {
+                array = SafeArrayCreateVector(vt, 0, count);
+                for (LONG index = 0; index < count; ++index) {
+                    QVariant elem = list.at(index);
+                    if (listType != QVariant::LastType)
+                        elem.convert(listType);
+                    VariantInit(&variant);
+                    QVariantToVARIANT(elem, variant, elem.typeName());
+                    SafeArrayPutElement(array, &index, pElement);
+                    clearVARIANT(&variant);
+                }
+            }
+            if (out && arg.vt == (VT_ARRAY|vt|VT_BYREF)) {
+                if (*arg.pparray)
+                    SafeArrayDestroy(*arg.pparray);
+                *arg.pparray = array;
+            } else {
+                arg.vt = VT_ARRAY|vt;
+                arg.parray = array;
+                if (out) {
+                    arg.pparray = new SAFEARRAY*(arg.parray);
+                    arg.vt |= VT_BYREF;
+                }
+            }
+        }
+        break;
+
+    case QVariant::StringList:
+        {
+            const QStringList list = qvar.toStringList();
+            const int count = list.count();
+            SAFEARRAY *array = SafeArrayCreateVector(VT_BSTR, 0, count);
+            for (LONG index = 0; index < count; ++index) {
+                QString elem = list.at(index);
+                BSTR bstr = QStringToBSTR(elem);
+                SafeArrayPutElement(array, &index, bstr);
+                SysFreeString(bstr);
+            }
+
+            if (out && arg.vt == (VT_ARRAY|VT_BSTR|VT_BYREF)) {
+                if (*arg.pparray)
+                    SafeArrayDestroy(*arg.pparray);
+                *arg.pparray = array;
+            } else {
+                arg.vt = VT_ARRAY|VT_BSTR;
+                arg.parray = array;
+                if (out) {
+                    arg.pparray = new SAFEARRAY*(arg.parray);
+                    arg.vt |= VT_BYREF;
+                }
+            }
+        }
+        break;
+
+    case QVariant::ByteArray:
+        {
+            const QByteArray bytes = qvar.toByteArray();
+            const uint count = bytes.count();
+            SAFEARRAY *array = SafeArrayCreateVector(VT_UI1, 0, count);
+            if (count) {
+                const char *data = bytes.constData();
+                char *dest;
+                SafeArrayAccessData(array, (void **)&dest);
+                memcpy(dest, data, count);
+                SafeArrayUnaccessData(array);
+            }
+
+            if (out && arg.vt == (VT_ARRAY|VT_UI1|VT_BYREF)) {
+                if (*arg.pparray)
+                    SafeArrayDestroy(*arg.pparray);
+                *arg.pparray = array;
+            } else {
+                arg.vt = VT_ARRAY|VT_UI1;
+                arg.parray = array;
+                if (out) {
+                    arg.pparray = new SAFEARRAY*(arg.parray);
+                    arg.vt |= VT_BYREF;
+                }
+            }
+        }
+        break;
+
+#ifdef QAX_SERVER
+    case QVariant::Rect:
+    case QVariant::Size:
+    case QVariant::Point:
+        {
+            typedef HRESULT(WINAPI* PGetRecordInfoFromTypeInfo)(ITypeInfo *, IRecordInfo **);
+            static PGetRecordInfoFromTypeInfo pGetRecordInfoFromTypeInfo = 0;
+            static bool resolved = false;
+            if (!resolved) {
+                QSystemLibrary oleaut32(QLatin1String("oleaut32"));
+                pGetRecordInfoFromTypeInfo = (PGetRecordInfoFromTypeInfo)oleaut32.resolve("GetRecordInfoFromTypeInfo");
+                resolved = true;
+            }
+            if (!pGetRecordInfoFromTypeInfo)
+                break;
+
+            ITypeInfo *typeInfo = 0;
+            IRecordInfo *recordInfo = 0;
+            CLSID clsid = qvar.type() == QVariant::Rect ? CLSID_QRect
+                :qvar.type() == QVariant::Size ? CLSID_QSize
+                :CLSID_QPoint;
+            qAxTypeLibrary->GetTypeInfoOfGuid(clsid, &typeInfo);
+            if (!typeInfo)
+                break;
+            pGetRecordInfoFromTypeInfo(typeInfo, &recordInfo);
+            typeInfo->Release();
+            if (!recordInfo)
+                break;
+
+            void *record = 0;
+            switch (qvar.type()) {
+            case QVariant::Rect:
+                {
+                    QRect qrect(qvar.toRect());
+                    recordInfo->RecordCreateCopy(&qrect, &record);
+                }
+                break;
+            case QVariant::Size:
+                {
+                    QSize qsize(qvar.toSize());
+                    recordInfo->RecordCreateCopy(&qsize, &record);
+                }
+                break;
+            case QVariant::Point:
+                {
+                    QPoint qpoint(qvar.toPoint());
+                    recordInfo->RecordCreateCopy(&qpoint, &record);
+                }
+                break;
+            }
+
+            arg.vt = VT_RECORD;
+            arg.pRecInfo = recordInfo,
+            arg.pvRecord = record;
+            if (out) {
+                qWarning("QVariantToVARIANT: out-parameter not supported for records");
+                return false;
+           }
+        }
+        break;
+#endif // QAX_SERVER
+    case QVariant::UserType:
+        {
+            QByteArray subType = qvar.typeName();
+#ifdef QAX_SERVER
+            if (subType.endsWith('*'))
+                subType.truncate(subType.length() - 1);
+#endif
+            if (!qstrcmp(qvar.typeName(), "IDispatch*")) {
+                arg.vt = VT_DISPATCH;
+                arg.pdispVal = *(IDispatch**)qvar.data();
+                if (arg.pdispVal)
+                    arg.pdispVal->AddRef();
+                if (out) {
+                    qWarning("QVariantToVARIANT: out-parameter not supported for IDispatch");
+                    return false;
+                }
+            } else if (!qstrcmp(qvar.typeName(), "IDispatch**")) {
+                arg.vt = VT_DISPATCH;
+                arg.ppdispVal = *(IDispatch***)qvar.data();
+                if (out)
+                    arg.vt |= VT_BYREF;
+            } else if (!qstrcmp(qvar.typeName(), "IUnknown*")) {
+                arg.vt = VT_UNKNOWN;
+                arg.punkVal = *(IUnknown**)qvar.data();
+                if (arg.punkVal)
+                    arg.punkVal->AddRef();
+                if (out) {
+                    qWarning("QVariantToVARIANT: out-parameter not supported for IUnknown");
+                    return false;
+                }
+#ifdef QAX_SERVER
+            } else if (qAxFactory()->metaObject(QString::fromLatin1(subType.constData()))) {
+                arg.vt = VT_DISPATCH;
+                void *user = *(void**)qvar.constData();
+//                qVariantGet(qvar, user, qvar.typeName());
+                if (!user) {
+                    arg.pdispVal = 0;
+                } else {
+                    qAxFactory()->createObjectWrapper(static_cast<QObject*>(user), &arg.pdispVal);
+                }
+                if (out) {
+                    qWarning("QVariantToVARIANT: out-parameter not supported for subtype");
+                    return false;
+                }
+#else
+            } else if (QMetaType::type(subType)) {
+                QAxObject *object = *(QAxObject**)qvar.constData();
+//                qVariantGet(qvar, object, subType);
+                arg.vt = VT_DISPATCH;
+                object->queryInterface(IID_IDispatch, (void**)&arg.pdispVal);
+                if (out) {
+                    qWarning("QVariantToVARIANT: out-parameter not supported for subtype");
+                    return false;
+                }
+#endif
+            } else {
+                return false;
+            }
+        }
+        break;
+#endif
+
+    case QVariant::Invalid: // default-parameters not set
+        if (out && arg.vt == (VT_ERROR|VT_BYREF)) {
+            *arg.plVal = DISP_E_PARAMNOTFOUND;
+        } else {
+            arg.vt = VT_ERROR;
+            arg.lVal = DISP_E_PARAMNOTFOUND;
+            if (out) {
+                arg.plVal = new long(arg.lVal);
+                arg.vt |= VT_BYREF;
+            }
+        }
+        break;
+
+    default:
+        return false;
+    }
+
+    Q_ASSERT(!out || (arg.vt & VT_BYREF));
+    return true;
+}
+
diff --git a/src/plugins/platforms/windows/accessible/comutils.h b/src/plugins/platforms/windows/accessible/comutils.h
new file mode 100644
index 0000000..08420cc
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/comutils.h
@@ -0,0 +1,61 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef COMUTILS_H
+#define COMUTILS_H
+
+#if !defined(_WINDOWS_) && !defined(_WINDOWS_H) && !defined(__WINDOWS__)
+#error Must include windows.h first!
+#endif
+
+#include <ocidl.h>
+#include <QtCore/qstring.h>
+
+class QVariant;
+
+bool QVariantToVARIANT(const QVariant &var, VARIANT &arg, const QByteArray &typeName, bool out);
+
+inline BSTR QStringToBSTR(const QString &str)
+{
+    return SysAllocStringLen((OLECHAR*)str.unicode(), str.length());
+}
+
+#endif // COMUTILS_H
+
diff --git a/src/plugins/platforms/windows/accessible/iaccessible2.cpp b/src/plugins/platforms/windows/accessible/iaccessible2.cpp
new file mode 100644
index 0000000..f223497
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/iaccessible2.cpp
@@ -0,0 +1,1467 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QtCore/QtConfig>
+#ifndef QT_NO_ACCESSIBILITY
+
+#include "iaccessible2.h"
+#include "qwindowsaccessibility.h"
+
+#include <QtGui/qaccessible2.h>
+#include <QtWidgets/qapplication.h>
+#include <QtCore/qdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+/**************************************************************\
+ *                     AccessibleApplication                  *
+ **************************************************************/
+//  IUnknown
+HRESULT STDMETHODCALLTYPE AccessibleApplication::QueryInterface(REFIID id, LPVOID *iface)
+{
+    *iface = 0;
+    if (id == IID_IUnknown) {
+        accessibleDebug("AccessibleApplication::QI(): IID_IUnknown");
+        *iface = (IUnknown*)this;
+    } else if (id == IID_IAccessibleApplication) {
+        accessibleDebug("AccessibleApplication::QI(): IID_IAccessibleApplication");
+        *iface = static_cast<IAccessibleApplication*>(this);
+    }
+
+    if (*iface) {
+        AddRef();
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+ULONG STDMETHODCALLTYPE AccessibleApplication::AddRef()
+{
+    return ++m_ref;
+}
+
+ULONG STDMETHODCALLTYPE AccessibleApplication::Release()
+{
+    if (!--m_ref) {
+        delete this;
+        return 0;
+    }
+    return m_ref;
+}
+
+/* IAccessibleApplication */
+HRESULT STDMETHODCALLTYPE AccessibleApplication::get_appName(/* [retval][out] */ BSTR *name)
+{
+    const QString appName = QGuiApplication::applicationName();
+    *name = QStringToBSTR(appName);
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE AccessibleApplication::get_appVersion(/* [retval][out] */ BSTR *version)
+{
+    const QString appName = QGuiApplication::applicationVersion();
+    *version = QStringToBSTR(appName);
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE AccessibleApplication::get_toolkitName(/* [retval][out] */ BSTR *name)
+{
+    *name = ::SysAllocString(L"Qt");
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE AccessibleApplication::get_toolkitVersion(/* [retval][out] */ BSTR *version)
+{
+    *version = ::SysAllocString(QT_UNICODE_LITERAL(QT_VERSION_STR));
+    return S_OK;
+}
+
+
+
+/*!
+  \internal
+  Client allocates and deallocates array
+  (see "Special Consideration when using Arrays", in Accessible2.idl)
+  */
+HRESULT STDMETHODCALLTYPE AccessibleRelation::get_target(
+    /* [in] */ long targetIndex,
+    /* [retval][out] */ IUnknown **target)
+{
+    if (targetIndex >= 0 && targetIndex < m_targets.count()) {
+        QAccessibleInterface *iface = m_targets.at(targetIndex);
+        *target = QWindowsAccessibility::wrap(iface);
+        if (*target)
+            return S_OK;
+        return E_FAIL;
+    }
+    return E_INVALIDARG;
+}
+
+/*!
+  \internal
+  Client allocates and deallocates \a targets array
+  (see "Special Consideration when using Arrays", in Accessible2.idl)
+  */
+HRESULT STDMETHODCALLTYPE AccessibleRelation::get_targets(
+    /* [in] */ long maxTargets,     // Hmmm, ignore ???
+    /* [length_is][size_is][out] */ IUnknown **targets,
+    /* [retval][out] */ long *nTargets)
+{
+
+    const int numTargets = qMin((int)maxTargets, m_targets.count());
+    for (int i = 0; i < numTargets; ++i) {
+        QAccessibleInterface *iface = m_targets.at(i);
+        IAccessible *iacc = QWindowsAccessibility::wrap(iface);
+        if (!iacc)
+            return E_FAIL;
+        *targets = iacc;
+        ++targets;
+    }
+    *nTargets = numTargets;
+    // \a targets array is allocated by client.
+    return numTargets > 0 ? S_OK : S_FALSE;
+}
+
+
+/**************************************************************\
+ *                                                             *
+ *                        IUnknown                             *
+ *                                                             *
+ **************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::QueryInterface(REFIID id, LPVOID *iface)
+{
+    *iface = 0;
+
+    QByteArray strIID = IIDToString(id);
+    if (!strIID.isEmpty()) {
+        QString ss; QDebug dbg(&ss); dbg << accessible;
+        accessibleDebug("QWindowsIA2Accessible::QI() - IID:%s, iface:%s ", strIID.constData(), qPrintable(ss));
+    }
+    if (id == IID_IUnknown) {
+        *iface = (IUnknown*)(IDispatch*)this;
+    } else if (id == IID_IDispatch) {
+        *iface = (IDispatch*)this;
+    } else if (id == IID_IAccessible) {
+        *iface = (IAccessible*)this;
+    } else if (id == IID_IOleWindow) {
+        *iface = (IOleWindow*)this;
+    } else if (id == IID_IServiceProvider) {
+        *iface = (IServiceProvider*)this;
+    } else if (id == IID_IAccessible2) {
+        *iface = (IAccessible2*)this;
+    } else if (id == IID_IAccessibleAction) {
+        if (accessible->actionInterface())
+            *iface = (IAccessibleAction*)this;
+    } else if (id == IID_IAccessibleComponent) {
+        *iface = (IAccessibleComponent*)this;
+    } else if (id == IID_IAccessibleEditableText) {
+        //if (accessible->editableTextInterface()) {
+            //*iface = (IAccessibleEditableText*)this;
+        //}
+    } else if (id == IID_IAccessibleHyperlink) {
+        //*iface = (IAccessibleHyperlink*)this;
+    } else if (id == IID_IAccessibleHypertext) {
+        //*iface = (IAccessibleHypertext*)this;
+    } else if (id == IID_IAccessibleImage) {
+        //*iface = (IAccessibleImage*)this;
+    } else if (id == IID_IAccessibleRelation) {
+        *iface = (IAccessibleRelation*)this;
+    } else if (id == IID_IAccessibleTable) {
+        //*iface = (IAccessibleTable*)this; // not supported
+    } else if (id == IID_IAccessibleTable2) {
+        if (accessible->tableInterface())
+            *iface = (IAccessibleTable2*)this;
+    } else if (id == IID_IAccessibleTableCell) {
+        if (accessible->tableCellInterface())
+            *iface = (IAccessibleTableCell*)this;
+    } else if (id == IID_IAccessibleText) {
+        if (accessible->textInterface())
+            *iface = (IAccessibleText*)this;
+    } else if (id == IID_IAccessibleValue) {
+        if (accessible->valueInterface())
+            *iface = (IAccessibleValue*)this;
+    }
+    if (*iface) {
+        AddRef();
+        return S_OK;
+    }
+
+    return E_NOINTERFACE;
+}
+
+ULONG STDMETHODCALLTYPE QWindowsIA2Accessible::AddRef()
+{
+    return ++ref;
+}
+
+ULONG STDMETHODCALLTYPE QWindowsIA2Accessible::Release()
+{
+    if (!--ref) {
+        delete this;
+        return 0;
+    }
+    return ref;
+}
+
+
+
+/**************************************************************\
+ *                                                             *
+ *                        IAccessible2                         *
+ *                                                             *
+ **************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nRelations(long *nRelations)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!nRelations)
+      return E_INVALIDARG;
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    return getRelationsHelper(0, 0, 0, nRelations);
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_relation(long relationIndex, IAccessibleRelation **relation)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!relation)
+      return E_INVALIDARG;
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    return getRelationsHelper(relation, relationIndex,  1);
+}
+
+/*!
+  \internal
+  Client allocates and deallocates array
+  (see "Special Consideration when using Arrays", in Accessible2.idl)
+  */
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_relations(long maxRelations,
+                                        IAccessibleRelation **relations,
+                                        long *nRelations)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    return getRelationsHelper(relations, 0, maxRelations, nRelations);
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::role(long *ia2role)
+{
+    accessibleDebugClientCalls(accessible);
+    //### Change QAccessibleInterface::role() to return both MSAA and IA2 roles.
+    // When that is completed, we must patch the MSAA bridge not not return any
+    // IA2-specific roles from get_accRole().
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *ia2role = accessible->role();
+    return S_OK;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::scrollTo(enum IA2ScrollType /*scrollType*/)
+{
+    //### Ignore for now
+    return E_NOTIMPL;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::scrollToPoint(enum IA2CoordinateType /*coordinateType*/, long /*x*/, long /*y*/)
+{
+    //### Ignore for now
+    return E_NOTIMPL;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_groupPosition(long *groupLevel,
+                                            long *similarItemsInGroup,
+                                            long *positionInGroup)
+{
+    // ### Ignore for now. Not sure what this is used for.....
+    *groupLevel = 0;            // Not applicable
+    *similarItemsInGroup = 0;   // Not applicable
+    *positionInGroup = 0;       // Not applicable
+    return S_FALSE;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_states(AccessibleStates *states)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    if (!states)
+        return E_POINTER;
+    QAccessible::State st = accessible->state();
+    AccessibleStates ia2states = 0;
+    if (st.active)
+        ia2states |= IA2_STATE_ACTIVE;
+    if (st.invalid)
+        ia2states |= IA2_STATE_DEFUNCT;
+    if (st.editable)
+        ia2states |= IA2_STATE_EDITABLE;
+    if (st.multiLine)
+        ia2states |= IA2_STATE_MULTI_LINE;
+    if (st.selectableText)
+        ia2states |= IA2_STATE_SELECTABLE_TEXT;
+    if (st.supportsAutoCompletion)
+        ia2states |= IA2_STATE_SUPPORTS_AUTOCOMPLETION;
+
+    *states = ia2states;
+    return S_OK;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_extendedRole(BSTR *extendedRole)
+{
+    //###
+    *extendedRole = 0;
+    return E_NOTIMPL;   // mozilla does this
+    //return S_FALSE;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_localizedExtendedRole(BSTR *localizedExtendedRole)
+{
+    //###
+    *localizedExtendedRole = 0;
+    return E_NOTIMPL;   // mozilla does this
+    //return S_FALSE;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nExtendedStates(long *nExtendedStates)
+{
+    // Who will ever intepret these values into something meaningful??
+    *nExtendedStates = 0;
+    return E_NOTIMPL;   // mozilla does this
+    //return S_FALSE;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_extendedStates(long /*maxExtendedStates*/,
+                                             BSTR **extendedStates,
+                                             long *nExtendedStates)
+{
+    *extendedStates = 0;
+    *nExtendedStates = 0;
+    return E_NOTIMPL;   // mozilla does this
+    //return S_FALSE;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_localizedExtendedStates(long /*maxLocalizedExtendedStates*/,
+                                                      BSTR **localizedExtendedStates,
+                                                      long *nLocalizedExtendedStates)
+{
+    *localizedExtendedStates = 0;
+    *nLocalizedExtendedStates = 0;
+    return E_NOTIMPL;   // mozilla does this
+    //return S_FALSE;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_uniqueID(long *outUniqueID)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    // ### FIXME SERIOUSLY, NOT A STABLE SOLUTION IF NODES ARE DELETED ETC
+    // Return 0 if no object and no parent. This is really an error case.
+    uint uid = uniqueID();
+    accessibleDebug("uniqueID: %08x", uid);
+
+    *outUniqueID = (long)uid;
+    return uid ? S_OK : S_FALSE;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_windowHandle(HWND *windowHandle)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    return GetWindow(windowHandle);
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_indexInParent(long *indexInParent)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    if (!indexInParent)
+      return E_INVALIDARG;
+    QAccessibleInterface *par = accessible->parent();
+    if (!par) {
+        *indexInParent = -1;
+        return S_FALSE;
+    }
+    int indexOfChild = par->indexOfChild(accessible);
+    delete par;
+    Q_ASSERT(indexOfChild >= 0);
+    *indexInParent = indexOfChild;
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_locale(IA2Locale *locale)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    IA2Locale res;
+    QLocale l;
+    res.country = QStringToBSTR(QLocale::countryToString(l.country()));
+    res.language = QStringToBSTR(QLocale::languageToString(l.language()));
+    *locale = res;
+    return S_OK;
+}
+
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_attributes(BSTR *attributes)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *attributes = 0;//QStringToBSTR(QString());
+    return S_FALSE;
+}
+
+/**************************************************************\
+ *                      IAccessibleAction                      *
+ **************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::nActions(long *nActions)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *nActions = 0;
+
+    if (QAccessibleActionInterface *actionIface = actionInterface())
+        *nActions = actionIface->actionNames().count();
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::doAction(long actionIndex)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    if (QAccessibleActionInterface *actionIface = actionInterface()) {
+        const QStringList actionNames = actionIface->actionNames();
+        if (actionIndex < 0 || actionIndex >= actionNames.count())
+            return E_INVALIDARG;
+        const QString actionName = actionNames.at(actionIndex);
+        actionIface->doAction(actionName);
+        return S_OK;
+    }
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_description(long actionIndex, BSTR *description)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *description = 0;
+    if (QAccessibleActionInterface *actionIface = actionInterface()) {
+        const QStringList actionNames = actionIface->actionNames();
+        if (actionIndex < 0 || actionIndex >= actionNames.count())
+            return E_INVALIDARG;
+        const QString actionName = actionNames.at(actionIndex);
+        *description = QStringToBSTR(actionIface->localizedActionDescription(actionName));
+    }
+    return *description ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_keyBinding(long actionIndex, long nMaxBindings, BSTR **keyBindings, long *nBindings)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    Q_UNUSED(nMaxBindings);
+    BSTR *arrayOfBindingsToReturn = 0;
+    int numBindings = 0;
+    if (QAccessibleActionInterface *actionIface = actionInterface()) {
+        const QStringList actionNames = actionIface->actionNames();
+        if (actionIndex < 0 || actionIndex >= actionNames.count())
+            return E_INVALIDARG;
+        const QString actionName = actionNames.at(actionIndex);
+        const QStringList keyBindings = actionIface->keyBindingsForAction(actionName);
+        numBindings = keyBindings.count();
+        if (numBindings > 0) {
+            // The IDL documents that the client must free with CoTaskMemFree
+            arrayOfBindingsToReturn = (BSTR*)::CoTaskMemAlloc(sizeof(BSTR) * numBindings);
+            for (int i = 0; i < numBindings; ++i)
+                arrayOfBindingsToReturn[i] = QStringToBSTR(keyBindings.at(i));
+        }
+    }
+    *keyBindings = arrayOfBindingsToReturn;
+    *nBindings = numBindings;
+
+    return numBindings ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_name(long actionIndex, BSTR *name)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *name = 0;
+    if (QAccessibleActionInterface *actionIface = actionInterface()) {
+        const QStringList actionNames = actionIface->actionNames();
+        if (actionIndex < 0 || actionIndex >= actionNames.count())
+            return E_INVALIDARG;
+        const QString actionName = actionNames.at(actionIndex);
+        *name = QStringToBSTR(actionName);
+    }
+    return *name ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_localizedName(long actionIndex, BSTR *localizedName)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *localizedName = 0;
+    if (QAccessibleActionInterface *actionIface = actionInterface()) {
+        const QStringList actionNames = actionIface->actionNames();
+        if (actionIndex < 0 || actionIndex >= actionNames.count())
+            return E_INVALIDARG;
+
+        const QString actionName = actionNames.at(actionIndex);
+        *localizedName = QStringToBSTR(actionIface->localizedActionName(actionName));
+    }
+    return *localizedName ? S_OK : S_FALSE;
+}
+
+/**************************************************************\
+ *                     IAccessibleComponent                    *
+ **************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_locationInParent(long *x, long *y)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QPoint topLeft = accessible->rect().topLeft();
+
+    if (QAccessibleInterface *parentIface = accessible->parent())
+        topLeft -= parentIface->rect().topLeft();
+
+    *x = topLeft.x();
+    *y = topLeft.y();
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_foreground(IA2Color *foreground)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    // IA2Color is a typedef for long
+    *foreground = (IA2Color)accessible->foregroundColor().rgb();
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_background(IA2Color *background)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    // IA2Color is a typedef for long
+    *background = (IA2Color)accessible->backgroundColor().rgb();
+    return S_OK;
+}
+
+/**************************************************************\
+ *                     IAccessibleTable2                      *
+ **************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_cellAt( long row, long column, IUnknown **cell)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *cell = 0;
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        if (QAccessibleInterface *qtCell = tableIface->cellAt(row, column)) {
+            *cell = QWindowsAccessibility::wrap(qtCell);
+        }
+    }
+    accessibleDebug("found cell? %p", *cell);
+    return *cell ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_caption( IUnknown **captionInterface)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *captionInterface = 0;
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        if (QAccessibleInterface *iface = tableIface->caption())
+            *captionInterface = QWindowsAccessibility::wrap(iface);
+    }
+    return *captionInterface ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_columnDescription( long column, BSTR *description)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *description = 0;
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        const QString qtDesc = tableIface->columnDescription(column);
+        if (!qtDesc.isEmpty())
+            *description = QStringToBSTR(qtDesc);
+    }
+    return *description ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nColumns( long *columnCount)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        *columnCount = tableIface->columnCount();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nRows(long *rowCount)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        *rowCount = tableIface->rowCount();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nSelectedCells(long *cellCount)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        *cellCount = tableIface->selectedCellCount();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nSelectedColumns(long *columnCount)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        *columnCount = tableIface->selectedColumnCount();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nSelectedRows(long *rowCount)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        *rowCount = tableIface->selectedRowCount();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_rowDescription(long row, BSTR *description)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *description = 0;
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        const QString qtDesc = tableIface->columnDescription(row);
+        if (!qtDesc.isEmpty())
+            *description = QStringToBSTR(qtDesc);
+    }
+    return *description ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_selectedCells(IUnknown ***cells, long *nSelectedCells)
+{
+    accessibleDebugClientCalls(accessible);
+    Q_UNUSED(cells);
+    Q_UNUSED(nSelectedCells);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QList<QAccessibleInterface*> selectedCells = tableInterface()->selectedCells();
+    return wrapListOfCells(selectedCells, cells, nSelectedCells);
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_selectedColumns(long **selectedColumns, long *nColumns)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        const QList<int> selectedIndices = tableIface->selectedColumns();
+        const int &count = selectedIndices.count();
+        long *selected = (count ? (long*)::CoTaskMemAlloc(sizeof(long) * count) : (long*)0);
+        for (int i = 0; i < count; ++i)
+            selected[i] = selectedIndices.at(i);
+        *selectedColumns = selected;
+        *nColumns = count;
+        return count ? S_OK : S_FALSE;
+    }
+    return E_FAIL;
+
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_selectedRows(long **selectedRows, long *nRows)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        const QList<int> selectedIndices = tableIface->selectedRows();
+        const int &count = selectedIndices.count();
+        long *selected = (count ? (long*)::CoTaskMemAlloc(sizeof(long) * count) : (long*)0);
+        for (int i = 0; i < count; ++i)
+            selected[i] = selectedIndices.at(i);
+        *selectedRows = selected;
+        *nRows = count;
+        return count ? S_OK : S_FALSE;
+    }
+    return E_FAIL;
+
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_summary(IUnknown **summaryInterface)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *summaryInterface = 0;
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        if (QAccessibleInterface *iface = tableIface->summary())
+            *summaryInterface = QWindowsAccessibility::wrap(iface);
+    }
+    return *summaryInterface ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_isColumnSelected(long column, boolean *isSelected)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        *isSelected = tableIface->isColumnSelected(column);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_isRowSelected(long row, boolean *isSelected)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        *isSelected = tableIface->isRowSelected(row);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::selectRow(long row)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        bool ok = tableIface->selectRow(row);
+        return ok ? S_OK : E_INVALIDARG;    //### Not sure of the return value if it fails???
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::selectColumn(long column)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        bool ok = tableIface->selectColumn(column);
+        return ok ? S_OK : E_INVALIDARG;    //### Not sure of the return value if it fails???
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::unselectRow(long row)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        bool ok = tableIface->unselectRow(row);
+        return ok ? S_OK : E_INVALIDARG;    //### Not sure of the return value if it fails???
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::unselectColumn(long column)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleTableInterface *tableIface = tableInterface()) {
+        bool ok = tableIface->unselectColumn(column);
+        return ok ? S_OK : E_INVALIDARG;    //### Not sure of the return value if it fails???
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_modelChange( IA2TableModelChange * /*modelChange*/)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    return E_NOTIMPL;
+}
+
+/**************************************************************\
+ *                     IAccessibleTableCell                   *
+\**************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_columnExtent(long *nColumnsSpanned)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *nColumnsSpanned = tableCellInterface()->columnExtent();
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_columnHeaderCells(IUnknown ***cellAccessibles,
+                                                                    long *nColumnHeaderCells)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    const QList<QAccessibleInterface*> headerCells = tableCellInterface()->columnHeaderCells();
+    return wrapListOfCells(headerCells, cellAccessibles, nColumnHeaderCells);
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_columnIndex(long *columnIndex)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *columnIndex = tableCellInterface()->columnIndex();
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_rowExtent(long *nRowsSpanned)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *nRowsSpanned = tableCellInterface()->rowExtent();
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_rowHeaderCells(IUnknown ***cellAccessibles,
+                                                                 long *nRowHeaderCells)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    const QList<QAccessibleInterface*> headerCells = tableCellInterface()->rowHeaderCells();
+    return wrapListOfCells(headerCells, cellAccessibles, nRowHeaderCells);
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_rowIndex(long *rowIndex)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *rowIndex = tableCellInterface()->rowIndex();
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_isSelected( boolean *isSelected)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    *isSelected = tableCellInterface()->isSelected();
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_rowColumnExtents(long *row, long *column,
+                                               long *rowExtents, long *columnExtents,
+                                               boolean *isSelected)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    tableCellInterface()->rowColumnExtents((int*)row, (int*)column, (int*)rowExtents, (int*)columnExtents, (bool*)isSelected);
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_table(IUnknown **table)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QAccessibleInterface *tableIface = tableCellInterface()->table();
+
+    *table = QWindowsAccessibility::wrap(tableIface);
+    return S_OK;
+}
+
+/**************************************************************\
+ *                     IAccessibleText                        *
+\**************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::addSelection(long startOffset,
+                                                           long endOffset)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *text = textInterface()) {
+        text->addSelection(startOffset, endOffset);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_attributes(long offset,
+                                                             long *startOffset,
+                                                             long *endOffset,
+                                                             BSTR *textAttributes)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *text = textInterface()) {
+        const QString attrs = text->attributes(offset, (int*)startOffset, (int*)endOffset);
+        *textAttributes = QStringToBSTR(attrs);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_caretOffset(long *offset)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *text = textInterface()) {
+        *offset = text->cursorPosition();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_characterExtents(long offset,
+                                                                   enum IA2CoordinateType coordType,
+                                                                   long *x,
+                                                                   long *y,
+                                                                   long *width,
+                                                                   long *height)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *text = textInterface()) {
+        const QRect rect = text->characterRect(offset, (QAccessible2::CoordinateType)coordType);
+        *x = rect.x();
+        *y = rect.y();
+        *width = rect.width();
+        *height = rect.height();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nSelections(long *nSelections)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *text = textInterface()) {
+        *nSelections = text->selectionCount();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_offsetAtPoint(long x,
+                                                                long y,
+                                                                enum IA2CoordinateType coordType,
+                                                                long *offset)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *text = textInterface()) {
+        *offset = text->offsetAtPoint(QPoint(x,y), (QAccessible2::CoordinateType)coordType);
+        return (*offset >=0 ? S_OK : S_FALSE);
+    }
+    return E_FAIL;
+
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_selection(long selectionIndex,
+                                                            long *startOffset,
+                                                            long *endOffset)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *text = textInterface()) {
+        text->selection(selectionIndex, (int*)startOffset, (int*)endOffset);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_text(long startOffset,
+                                                       long endOffset,
+                                                       BSTR *text)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textif = textInterface()) {
+        const QString t = textif->text(startOffset, endOffset);
+        if (!t.isEmpty()) {
+            *text = QStringToBSTR(t);
+            return S_OK;
+        }
+        return E_INVALIDARG;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_textBeforeOffset(long offset,
+                                               enum IA2TextBoundaryType boundaryType,
+                                               long *startOffset,
+                                               long *endOffset,
+                                               BSTR *text)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textIface = textInterface()) {
+        const QString txt = textIface->textBeforeOffset(offset, (QAccessible2::BoundaryType)boundaryType, (int*)startOffset, (int*)endOffset);
+        if (!txt.isEmpty()) {
+            *text = QStringToBSTR(txt);
+            return S_OK;
+        }
+        return S_FALSE;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_textAfterOffset(
+    long offset,
+    enum IA2TextBoundaryType boundaryType,
+    long *startOffset,
+    long *endOffset,
+    BSTR *text)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textIface = textInterface()) {
+        const QString txt = textIface->textAfterOffset(offset, (QAccessible2::BoundaryType)boundaryType, (int*)startOffset, (int*)endOffset);
+        if (!txt.isEmpty()) {
+            *text = QStringToBSTR(txt);
+            return S_OK;
+        }
+        return S_FALSE;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_textAtOffset(long offset,
+                                                               enum IA2TextBoundaryType boundaryType,
+                                                               long *startOffset,
+                                                               long *endOffset,
+                                                               BSTR *text)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textIface = textInterface()) {
+        const QString txt = textIface->textAtOffset(offset, (QAccessible2::BoundaryType)boundaryType, (int*)startOffset, (int*)endOffset);
+        if (!txt.isEmpty()) {
+            *text = QStringToBSTR(txt);
+            return S_OK;
+        }
+        return S_FALSE;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::removeSelection(long selectionIndex)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textIface = textInterface()) {
+        textIface->removeSelection(selectionIndex);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::setCaretOffset(long offset)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textIface = textInterface()) {
+        textIface->setCursorPosition(offset);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::setSelection(long selectionIndex,
+                                                           long startOffset,
+                                                           long endOffset)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textIface = textInterface()) {
+        textIface->setSelection(selectionIndex, startOffset, endOffset);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_nCharacters(long *nCharacters)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textIface = textInterface()) {
+        *nCharacters = textIface->characterCount();
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::scrollSubstringTo(long startIndex,
+                                                                long endIndex,
+                                                                enum IA2ScrollType scrollType)
+{
+    accessibleDebugClientCalls(accessible);
+    if (QAccessibleTextInterface *textIface = textInterface()) {
+        Q_UNUSED(scrollType);   //###
+        textIface->scrollToSubstring(startIndex, endIndex);
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::scrollSubstringToPoint(long startIndex,
+                                                                     long endIndex,
+                                                                     enum IA2CoordinateType coordinateType,
+                                                                     long x,
+                                                                     long y)
+{
+    Q_UNUSED(startIndex);
+    Q_UNUSED(endIndex);
+    Q_UNUSED(coordinateType);
+    Q_UNUSED(x);
+    Q_UNUSED(y);
+
+    return E_NOTIMPL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_newText(IA2TextSegment *newText)
+{
+    Q_UNUSED(newText);
+    return E_NOTIMPL;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_oldText(IA2TextSegment *oldText)
+{
+    Q_UNUSED(oldText);
+    return E_NOTIMPL;
+}
+
+/**************************************************************\
+ *                         IAccessibleValue                    *
+ **************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_currentValue(VARIANT *currentValue)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    if (QAccessibleValueInterface *valueIface = valueInterface()) {
+        const QVariant var = valueIface->currentValue();
+        if (QVariantToVARIANT(var, *currentValue, QByteArray(), false))
+            return S_OK;
+
+    }
+    currentValue->vt = VT_EMPTY;
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::setCurrentValue(VARIANT value)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    HRESULT hr = S_FALSE;
+    if (QAccessibleValueInterface *valueIface = valueInterface()) {
+        hr = VariantChangeType(&value, &value, 0, VT_R8);
+        if (SUCCEEDED(hr)) {
+            // ### works only for numbers (not date, strings, etc)
+            valueIface->setCurrentValue(QVariant(value.dblVal));
+        }
+    }
+    return hr;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_maximumValue(VARIANT *maximumValue)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    if (QAccessibleValueInterface *valueIface = valueInterface()) {
+        const QVariant var = valueIface->maximumValue();
+        if (QVariantToVARIANT(var, *maximumValue, QByteArray(), false))
+            return S_OK;
+    }
+    maximumValue->vt = VT_EMPTY;
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::get_minimumValue(VARIANT *minimumValue)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    if (QAccessibleValueInterface *valueIface = valueInterface()) {
+        const QVariant var = valueIface->minimumValue();
+        if (QVariantToVARIANT(var, *minimumValue, QByteArray(), false))
+            return S_OK;
+    }
+    minimumValue->vt = VT_EMPTY;
+    return S_FALSE;
+}
+
+
+/**************************************************************\
+ *                      IServiceProvider                       *
+ **************************************************************/
+/*!
+  \internal
+  Reimplemented from IServiceProvider
+*/
+HRESULT STDMETHODCALLTYPE QWindowsIA2Accessible::QueryService(REFGUID guidService, REFIID riid, void **iface)
+{
+    if (!iface)
+        return E_POINTER;
+    Q_UNUSED(guidService);
+    *iface = 0;
+    accessibleDebug("QWindowsIA2Accessible::QS(): %s", IIDToString(riid).constData());
+    if (riid == IID_IAccessible || riid == IID_IUnknown || riid == IID_IDispatch) {
+        *iface = static_cast<IAccessible*>(this);
+    } else if (/*guidService == IID_IAccessible && */riid == IID_IAccessible2) {
+        *iface = static_cast<IAccessible2*>(this);
+    } else  if (riid == IID_IAccessibleApplication) {
+        *iface = new AccessibleApplication;
+        return S_OK;
+    } else {
+        QueryInterface(riid, iface);
+    }
+    if (*iface) {
+        AddRef();
+        return S_OK;
+    }
+
+    return E_NOINTERFACE;
+}
+
+
+/*!
+  \internal
+  private function..
+  \a maxRelations max number of relations to return in \a relations
+  \a relations the array of relations matching
+  \a startIndex Index to start to return from,
+                   it will return only that specific relation in \a relations
+
+  If \a relations is null, \a startIndex and \a maxRelations are ignored, causing
+  it to return the number of relations in \a nRelations
+*/
+HRESULT QWindowsIA2Accessible::getRelationsHelper(IAccessibleRelation **relations, int startIndex, long maxRelations, long *nRelations /* = 0*/)
+{
+    if (nRelations)
+        *nRelations = 0;
+    typedef QPair<QAccessibleInterface *, QAccessible::Relation> RelationEntry;
+    QVector<RelationEntry> rels = accessible->relations();
+    QMap<QAccessible::Relation, QAccessibleInterface *> relationMap;
+    for (QVector<RelationEntry>::const_iterator it = rels.constBegin(); it != rels.constEnd(); ++it)
+    {
+        RelationEntry e = *it;
+        relationMap.insertMulti(e.second, e.first);
+    }
+
+    QList<QAccessible::Relation> keys = relationMap.keys();
+    const int numRelations = keys.count();
+    if (relations) {
+        for (int i = startIndex; i < qMin(startIndex + (int)maxRelations, numRelations); ++i) {
+            QAccessible::Relation relation = keys.at(i);
+            QList<QAccessibleInterface*> targets = relationMap.values(relation);
+            AccessibleRelation *rel = new AccessibleRelation(targets, relation);
+            *relations = rel;
+            ++relations;
+        }
+    }
+    if (nRelations)
+        *nRelations = numRelations;
+
+    return numRelations > 0 ? S_OK : S_FALSE;
+}
+
+
+
+
+/*!
+  \internal
+  helper to wrap a QList<QAccessibleInterface*> inside an array of IAccessible*
+  The IAccessible* array is returned as a IUnknown*
+*/
+HRESULT QWindowsIA2Accessible::wrapListOfCells(const QList<QAccessibleInterface*> &inputCells, IUnknown ***outputAccessibles, long *nCellCount)
+{
+    const int count = inputCells.count();
+    // Server allocates array
+    IUnknown **outputCells = count ? (IUnknown**)::CoTaskMemAlloc(sizeof(IUnknown*) * count ) : (IUnknown**)0;
+    for (int i = 0; i < count; ++i)
+        outputCells[i] = QWindowsAccessibility::wrap(inputCells.at(i));
+
+    *outputAccessibles = outputCells;
+    *nCellCount = count;
+    return count > 0 ? S_OK : S_FALSE;
+}
+
+uint QWindowsIA2Accessible::uniqueID() const
+{
+    uint uid = 0;
+    if (QObject *obj = accessible->object())
+        uid = qHash(obj);
+
+    if (!uid) {
+        QAccessibleInterface *acc = accessible;
+        QVector<int> indexOfNodes;
+        while (acc && !acc->object()) {
+            QAccessibleInterface *par = acc->parent();
+            indexOfNodes.append(par->indexOfChild(acc));
+            if (acc != accessible)
+                delete acc;
+            acc = par;
+        }
+        if (acc) {
+            if (acc->object()) {
+                uid = qHash(acc->object());
+                for (int i = 0; i < indexOfNodes.count(); ++i)
+                    uid = qHash(uid + indexOfNodes.at(i));
+
+            }
+            if (acc != accessible)
+                delete acc;
+        }
+    }
+    return uid;
+}
+
+
+#define IF_EQUAL_RETURN_IIDSTRING(id, iid) if (id == iid) return QByteArray(#iid)
+
+QByteArray QWindowsIA2Accessible::IIDToString(REFIID id)
+{
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IUnknown);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IDispatch);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessible);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IOleWindow);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IServiceProvider);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessible2);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleAction);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleApplication);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleComponent);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleEditableText);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleHyperlink);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleHypertext);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleImage);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleRelation);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleTable);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleTable2);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleTableCell);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleText);
+    IF_EQUAL_RETURN_IIDSTRING(id, IID_IAccessibleValue);
+
+    // else...
+    QByteArray strGuid;
+#if 0   // Can be useful for debugging, but normally we'd like to reduce the noise a bit...
+    OLECHAR szGuid[39]={0};
+    ::StringFromGUID2(id, szGuid, 39);
+    strGuid.reserve(40);
+    ::WideCharToMultiByte(CP_UTF8, 0, szGuid, 39, strGuid.data(), 39, NULL, NULL);
+    strGuid[38] = '\0';
+#endif
+    return strGuid;
+}
+
+
+QT_END_NAMESPACE
+
+#endif //QT_NO_ACCESSIBILITY
diff --git a/src/plugins/platforms/windows/accessible/iaccessible2.h b/src/plugins/platforms/windows/accessible/iaccessible2.h
new file mode 100644
index 0000000..11889df
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/iaccessible2.h
@@ -0,0 +1,375 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef IACCESSIBLE2_H
+#define IACCESSIBLE2_H
+
+#include <QtCore/QtConfig>
+#ifndef QT_NO_ACCESSIBILITY
+
+#include "qwindowsmsaaaccessible.h"
+#include "comutils.h"
+
+#include "Accessible2.h"
+#include "AccessibleAction.h"
+#include "AccessibleApplication.h"
+#include "AccessibleComponent.h"
+#include "AccessibleEditableText.h"
+#include "AccessibleHyperlink.h"
+#include "AccessibleHypertext.h"
+#include "AccessibleImage.h"
+#include "AccessibleRelation.h"
+#include "AccessibleTable.h"
+#include "AccessibleTable2.h"
+#include "AccessibleTableCell.h"
+#include "AccessibleText.h"
+#include "AccessibleValue.h"
+
+#include "AccessibleEventID.h"
+#include "AccessibleRole.h"
+#include "AccessibleStates.h"
+
+QT_BEGIN_NAMESPACE
+
+class QWindowsIA2Accessible : public QWindowsMsaaAccessible,
+        public IAccessibleAction,
+        public IAccessibleComponent,
+        /*public IAccessibleEditableText,*/
+        public IAccessibleTable2,
+        public IAccessibleTableCell,
+        public IAccessibleText,
+        public IAccessibleValue,
+        public IServiceProvider
+{
+public:
+    QWindowsIA2Accessible(QAccessibleInterface *a) : QWindowsMsaaAccessible(a) {}
+
+    /* IUnknown */
+    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *);
+    ULONG STDMETHODCALLTYPE AddRef();
+    ULONG STDMETHODCALLTYPE Release();
+
+    /* IAccessible2 */
+    HRESULT STDMETHODCALLTYPE get_nRelations(long *nRelations);
+    HRESULT STDMETHODCALLTYPE get_relation(long relationIndex, IAccessibleRelation **relation);
+    HRESULT STDMETHODCALLTYPE get_relations(long maxRelations, IAccessibleRelation **relations, long *nRelations);
+    HRESULT STDMETHODCALLTYPE role(long *role);
+    HRESULT STDMETHODCALLTYPE scrollTo(enum IA2ScrollType scrollType);
+    HRESULT STDMETHODCALLTYPE scrollToPoint(enum IA2CoordinateType coordinateType, long x, long y);
+    HRESULT STDMETHODCALLTYPE get_groupPosition(long *groupLevel, long *similarItemsInGroup, long *positionInGroup);
+    HRESULT STDMETHODCALLTYPE get_states(AccessibleStates *states);
+    HRESULT STDMETHODCALLTYPE get_extendedRole(BSTR *extendedRole);
+    HRESULT STDMETHODCALLTYPE get_localizedExtendedRole(BSTR *localizedExtendedRole);
+    HRESULT STDMETHODCALLTYPE get_nExtendedStates(long *nExtendedStates);
+    HRESULT STDMETHODCALLTYPE get_extendedStates(long maxExtendedStates, BSTR **extendedStates, long *nExtendedStates);
+    HRESULT STDMETHODCALLTYPE get_localizedExtendedStates(long maxLocalizedExtendedStates, BSTR **localizedExtendedStates, long *nLocalizedExtendedStates);
+    HRESULT STDMETHODCALLTYPE get_uniqueID(long *uniqueID);
+    HRESULT STDMETHODCALLTYPE get_windowHandle(HWND *windowHandle);
+    HRESULT STDMETHODCALLTYPE get_indexInParent(long *indexInParent);
+    HRESULT STDMETHODCALLTYPE get_locale(IA2Locale *locale);
+    HRESULT STDMETHODCALLTYPE get_attributes(BSTR *attributes);
+
+    /* IAccessibleAction */
+    HRESULT STDMETHODCALLTYPE nActions(long *nActions);
+    HRESULT STDMETHODCALLTYPE doAction(long actionIndex);
+    HRESULT STDMETHODCALLTYPE get_description(long actionIndex, BSTR *description);
+    HRESULT STDMETHODCALLTYPE get_keyBinding(long actionIndex, long nMaxBindings, BSTR **keyBindings, long *nBindings);
+    HRESULT STDMETHODCALLTYPE get_name(long actionIndex, BSTR *name);
+    HRESULT STDMETHODCALLTYPE get_localizedName(long actionIndex, BSTR *localizedName);
+
+    /* IAccessibleComponent */
+    HRESULT STDMETHODCALLTYPE get_locationInParent(long *x,long *y);
+    HRESULT STDMETHODCALLTYPE get_foreground(IA2Color *foreground);
+    HRESULT STDMETHODCALLTYPE get_background(IA2Color *background);
+
+    /* IAccessibleEditableText */
+    /*
+    HRESULT STDMETHODCALLTYPE copyText(long startOffset, long endOffset);
+    HRESULT STDMETHODCALLTYPE deleteText(long startOffset, long endOffset);
+    HRESULT STDMETHODCALLTYPE insertText(long offset, BSTR *text);
+    HRESULT STDMETHODCALLTYPE cutText(long startOffset, long endOffset);
+    HRESULT STDMETHODCALLTYPE pasteText(long offset);
+    HRESULT STDMETHODCALLTYPE replaceText(long startOffset, long endOffset, BSTR *text);
+    HRESULT STDMETHODCALLTYPE setAttributes(long startOffset, long endOffset, BSTR *attributes);
+    */
+
+    /* IAccessibleTable2 */
+    HRESULT STDMETHODCALLTYPE get_cellAt( long row, long column, IUnknown **cell);
+    HRESULT STDMETHODCALLTYPE get_caption( IUnknown **accessible);
+    HRESULT STDMETHODCALLTYPE get_columnDescription( long column, BSTR *description);
+    HRESULT STDMETHODCALLTYPE get_nColumns( long *columnCount);
+    HRESULT STDMETHODCALLTYPE get_nRows( long *rowCount);
+    HRESULT STDMETHODCALLTYPE get_nSelectedCells( long *cellCount);
+    HRESULT STDMETHODCALLTYPE get_nSelectedColumns( long *columnCount);
+    HRESULT STDMETHODCALLTYPE get_nSelectedRows( long *rowCount);
+    HRESULT STDMETHODCALLTYPE get_rowDescription( long row, BSTR *description);
+    HRESULT STDMETHODCALLTYPE get_selectedCells( IUnknown ***cells, long *nSelectedCells);
+    HRESULT STDMETHODCALLTYPE get_selectedColumns( long **selectedColumns, long *nColumns);
+    HRESULT STDMETHODCALLTYPE get_selectedRows( long **selectedRows, long *nRows);
+    HRESULT STDMETHODCALLTYPE get_summary( IUnknown **accessible);
+    HRESULT STDMETHODCALLTYPE get_isColumnSelected( long column, boolean *isSelected);
+    HRESULT STDMETHODCALLTYPE get_isRowSelected( long row, boolean *isSelected);
+    HRESULT STDMETHODCALLTYPE selectRow( long row);
+    HRESULT STDMETHODCALLTYPE selectColumn( long column);
+    HRESULT STDMETHODCALLTYPE unselectRow( long row);
+    HRESULT STDMETHODCALLTYPE unselectColumn( long column);
+    HRESULT STDMETHODCALLTYPE get_modelChange( IA2TableModelChange *modelChange);
+
+    /* IAccessibleTableCell */
+    HRESULT STDMETHODCALLTYPE get_columnExtent(long *nColumnsSpanned);
+    HRESULT STDMETHODCALLTYPE get_columnHeaderCells(IUnknown ***cellAccessibles, long *nColumnHeaderCells);
+    HRESULT STDMETHODCALLTYPE get_columnIndex(long *columnIndex);
+    HRESULT STDMETHODCALLTYPE get_rowExtent(long *nRowsSpanned);
+    HRESULT STDMETHODCALLTYPE get_rowHeaderCells(IUnknown ***cellAccessibles, long *nRowHeaderCells);
+    HRESULT STDMETHODCALLTYPE get_rowIndex(long *rowIndex);
+    HRESULT STDMETHODCALLTYPE get_isSelected( boolean *isSelected);
+    HRESULT STDMETHODCALLTYPE get_rowColumnExtents(long *row, long *column,
+                                                   long *rowExtents, long *columnExtents,
+                                                   boolean *isSelected);
+    HRESULT STDMETHODCALLTYPE get_table(IUnknown **table);
+
+
+    /* IAccessibleText */
+    HRESULT STDMETHODCALLTYPE addSelection(long startOffset, long endOffset);
+    HRESULT STDMETHODCALLTYPE get_attributes(long offset, long *startOffset,
+                                             long *endOffset, BSTR *textAttributes);
+    HRESULT STDMETHODCALLTYPE get_caretOffset(long *offset);
+    HRESULT STDMETHODCALLTYPE get_characterExtents(long offset, enum IA2CoordinateType coordType,
+                                                   long *x, long *y,
+                                                   long *width, long *height);
+    HRESULT STDMETHODCALLTYPE get_nSelections(long *nSelections);
+    HRESULT STDMETHODCALLTYPE get_offsetAtPoint(long x, long y, enum IA2CoordinateType coordType, long *offset);
+    HRESULT STDMETHODCALLTYPE get_selection(long selectionIndex, long *startOffset, long *endOffset);
+    HRESULT STDMETHODCALLTYPE get_text(long startOffset, long endOffset, BSTR *text);
+    HRESULT STDMETHODCALLTYPE get_textBeforeOffset(long offset, enum IA2TextBoundaryType boundaryType,
+                                                   long *startOffset, long *endOffset, BSTR *text);
+    HRESULT STDMETHODCALLTYPE get_textAfterOffset(long offset, enum IA2TextBoundaryType boundaryType,
+                                                  long *startOffset, long *endOffset, BSTR *text);
+    HRESULT STDMETHODCALLTYPE get_textAtOffset(long offset, enum IA2TextBoundaryType boundaryType,
+                                               long *startOffset, long *endOffset, BSTR *text);
+    HRESULT STDMETHODCALLTYPE removeSelection(long selectionIndex);
+    HRESULT STDMETHODCALLTYPE setCaretOffset(long offset);
+    HRESULT STDMETHODCALLTYPE setSelection(long selectionIndex, long startOffset, long endOffset);
+    HRESULT STDMETHODCALLTYPE get_nCharacters(long *nCharacters);
+    HRESULT STDMETHODCALLTYPE scrollSubstringTo(long startIndex, long endIndex, enum IA2ScrollType scrollType);
+    HRESULT STDMETHODCALLTYPE scrollSubstringToPoint(long startIndex, long endIndex,
+                                                     enum IA2CoordinateType coordinateType, long x, long y);
+    HRESULT STDMETHODCALLTYPE get_newText(IA2TextSegment *newText);
+    HRESULT STDMETHODCALLTYPE get_oldText(IA2TextSegment *oldText);
+
+    /* IAccessibleValue */
+    HRESULT STDMETHODCALLTYPE get_currentValue(VARIANT *currentValue);
+    HRESULT STDMETHODCALLTYPE setCurrentValue(VARIANT value);
+    HRESULT STDMETHODCALLTYPE get_maximumValue(VARIANT *maximumValue);
+    HRESULT STDMETHODCALLTYPE get_minimumValue(VARIANT *minimumValue);
+
+    /* IServiceProvider */
+    HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, void **ppv);
+
+    /* private helper functions */
+private:
+    inline QAccessibleTextInterface *textInterface() const {
+        return accessible->isValid() ? accessible->textInterface() : static_cast<QAccessibleTextInterface *>(0);
+    }
+
+    inline QAccessibleActionInterface *actionInterface() const {
+        return accessible->actionInterface();
+    }
+
+    inline QAccessibleValueInterface *valueInterface() const {
+        return accessible->valueInterface();
+    }
+
+    inline QAccessibleTableInterface *tableInterface() const {
+        return accessible->tableInterface();
+    }
+
+    inline QAccessibleTableCellInterface *tableCellInterface() const {
+        return accessible->tableCellInterface();
+    }
+
+    HRESULT getRelationsHelper(IAccessibleRelation **relations, int startIndex, long maxRelations, long *nRelations = 0);
+    HRESULT wrapListOfCells(const QList<QAccessibleInterface*> &inputCells, IUnknown ***outputAccessibles, long *nCellCount);
+    uint uniqueID() const;
+    QByteArray IIDToString(REFIID id);
+
+private:
+    ULONG ref;
+
+};
+
+/**************************************************************\
+ *                     AccessibleApplication                  *
+ **************************************************************/
+class AccessibleApplication : public IAccessibleApplication
+{
+public:
+    AccessibleApplication() : m_ref(1)
+    {
+
+    }
+
+    virtual ~AccessibleApplication() {}
+
+    /* IUnknown */
+    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *);
+    ULONG STDMETHODCALLTYPE AddRef();
+    ULONG STDMETHODCALLTYPE Release();
+
+    /* IAccessibleApplication */
+    HRESULT STDMETHODCALLTYPE get_appName(/* [retval][out] */ BSTR *name);
+    HRESULT STDMETHODCALLTYPE get_appVersion(/* [retval][out] */ BSTR *version);
+    HRESULT STDMETHODCALLTYPE get_toolkitName(/* [retval][out] */ BSTR *name);
+    HRESULT STDMETHODCALLTYPE get_toolkitVersion(/* [retval][out] */ BSTR *version);
+private:
+    ULONG m_ref;
+};
+
+
+
+/**************************************************************\
+ *                     IAccessibleRelation                     *
+ **************************************************************/
+struct AccessibleRelation : public IAccessibleRelation
+{
+    AccessibleRelation(const QList<QAccessibleInterface *> &targets,
+                        QAccessible::Relation relation)
+        : m_targets(targets), m_relation(relation), m_ref(1)
+    {
+        Q_ASSERT(m_targets.count());
+    }
+
+
+    /* IUnknown */
+    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID id, LPVOID *iface)
+    {
+        *iface = 0;
+        if (id == IID_IUnknown)
+            *iface = (IUnknown*)this;
+
+        if (*iface) {
+            AddRef();
+            return S_OK;
+        }
+
+        return E_NOINTERFACE;
+    }
+
+    ULONG STDMETHODCALLTYPE AddRef()
+    {
+        return ++m_ref;
+    }
+
+    ULONG STDMETHODCALLTYPE Release()
+    {
+        if (!--m_ref) {
+            delete this;
+            return 0;
+        }
+        return m_ref;
+    }
+
+    /* IAccessibleRelation */
+    HRESULT STDMETHODCALLTYPE get_relationType(
+        /* [retval][out] */ BSTR *relationType)
+    {
+        *relationType = relationToBSTR(m_relation);
+        return S_OK;
+    }
+
+    HRESULT STDMETHODCALLTYPE get_localizedRelationType(
+        /* [retval][out] */ BSTR *localizedRelationType)
+    {
+        // Who ever needs this???
+        *localizedRelationType = relationToBSTR(m_relation);
+        return S_OK;
+    }
+
+    HRESULT STDMETHODCALLTYPE get_nTargets(
+        /* [retval][out] */ long *nTargets)
+    {
+        // ### always one target
+        *nTargets = m_targets.count();
+        return S_OK;
+    }
+
+    HRESULT STDMETHODCALLTYPE get_target(long targetIndex, IUnknown **target);
+
+
+    /*!
+      \internal
+      Client allocates and deallocates \a targets array
+      (see "Special Consideration when using Arrays", in Accessible2.idl)
+      */
+    HRESULT STDMETHODCALLTYPE get_targets(
+        /* [in] */ long maxTargets,     // Hmmm, ignore ???
+        /* [length_is][size_is][out] */ IUnknown **targets,
+        /* [retval][out] */ long *nTargets);
+
+private:
+    static BSTR relationToBSTR(QAccessible::Relation relation)
+    {
+        wchar_t *constRelationString = 0;
+        switch (relation) {
+        case QAccessible::Controlled:
+            constRelationString = IA2_RELATION_CONTROLLED_BY;
+            break;
+        }
+
+        if (constRelationString) {
+            BSTR bstrVal;
+            const UINT wlen = (UINT)wcslen(constRelationString);
+            bstrVal = ::SysAllocStringLen(constRelationString, wlen);
+            return bstrVal;
+        }
+        return 0;
+    }
+
+
+    QList<QAccessibleInterface *> m_targets;
+    QAccessible::Relation m_relation;
+    ULONG m_ref;
+};
+
+QT_END_NAMESPACE
+
+#endif //QT_NO_ACCESSIBILITY
+
+#endif // IACCESSIBLE2_H
diff --git a/src/plugins/platforms/windows/accessible/qwindowsaccessibility.cpp b/src/plugins/platforms/windows/accessible/qwindowsaccessibility.cpp
new file mode 100644
index 0000000..f409730
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/qwindowsaccessibility.cpp
@@ -0,0 +1,301 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/QtConfig>
+#ifndef QT_NO_ACCESSIBILITY
+
+
+#include <private/qsystemlibrary_p.h>
+
+#include <QtCore/qlocale.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qpair.h>
+#include <QtCore/qsettings.h>
+#include <QtGui/qaccessible.h>
+#include <QtGui/qaccessible2.h>
+#include <QtGui/qplatformnativeinterface_qpa.h>
+#include <QtGui/qwindow.h>
+#include <QtGui/qguiapplication.h>
+#include <QtWidgets/qapplication.h>
+#include <QtWidgets/qgraphicsitem.h>
+#include <QtWidgets/qgraphicsview.h>
+#include <QtWidgets/qmessagebox.h>
+
+#include "qwindowsaccessibility.h"
+#include "iaccessible2.h"
+#include "comutils.h"
+
+#include <oleacc.h>
+
+//#include <uiautomationcoreapi.h>
+#ifndef UiaRootObjectId
+#define UiaRootObjectId        -25
+#endif
+
+#include <winuser.h>
+#if !defined(WINABLEAPI)
+#  if defined(Q_OS_WINCE)
+#    include <bldver.h>
+#  endif
+#  include <winable.h>
+#endif
+
+#include <oleacc.h>
+#include <servprov.h>
+#if !defined(Q_CC_BOR) && !defined (Q_CC_GNU)
+#include <comdef.h>
+#endif
+
+#ifdef Q_OS_WINCE
+#include "../qguifunctions_wince.h"
+#endif
+
+#include "../qtwindows_additional.h"
+
+
+// This stuff is used for widgets/items with no window handle:
+typedef QMap<int, QPair<QObject*,int> > NotifyMap;
+Q_GLOBAL_STATIC(NotifyMap, qAccessibleRecentSentEvents)
+
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \!internal
+    \class QWindowsAccessibility
+
+    Implements QPlatformAccessibility
+
+*/
+QWindowsAccessibility::QWindowsAccessibility()
+{
+}
+
+void QWindowsAccessibility::notifyAccessibilityUpdate(const QAccessibleEvent &event)
+{
+    QString soundName;
+    switch (event.type()) {
+    case QAccessible::PopupMenuStart:
+        soundName = QLatin1String("MenuPopup");
+        break;
+
+    case QAccessible::MenuCommand:
+        soundName = QLatin1String("MenuCommand");
+        break;
+
+    case QAccessible::Alert:
+        {
+        /*      ### FIXME
+#ifndef QT_NO_MESSAGEBOX
+            QMessageBox *mb = qobject_cast<QMessageBox*>(o);
+            if (mb) {
+                switch (mb->icon()) {
+                case QMessageBox::Warning:
+                    soundName = QLatin1String("SystemExclamation");
+                    break;
+                case QMessageBox::Critical:
+                    soundName = QLatin1String("SystemHand");
+                    break;
+                case QMessageBox::Information:
+                    soundName = QLatin1String("SystemAsterisk");
+                    break;
+                default:
+                    break;
+                }
+            } else
+#endif // QT_NO_MESSAGEBOX
+*/
+            {
+                soundName = QLatin1String("SystemAsterisk");
+            }
+
+        }
+        break;
+    default:
+        break;
+    }
+
+    if (!soundName.isEmpty()) {
+#ifndef QT_NO_SETTINGS
+        QSettings settings(QLatin1String("HKEY_CURRENT_USER\\AppEvents\\Schemes\\Apps\\.Default\\") + soundName,
+                           QSettings::NativeFormat);
+        QString file = settings.value(QLatin1String(".Current/.")).toString();
+#else
+        QString file;
+#endif
+        if (!file.isEmpty()) {
+            PlaySound(reinterpret_cast<const wchar_t *>(soundName.utf16()), 0, SND_ALIAS | SND_ASYNC | SND_NODEFAULT | SND_NOWAIT);
+        }
+    }
+
+    typedef void (WINAPI *PtrNotifyWinEvent)(DWORD, HWND, LONG, LONG);
+
+#if defined(Q_OS_WINCE) // ### TODO: check for NotifyWinEvent in CE 6.0
+    // There is no user32.lib nor NotifyWinEvent for CE
+    return;
+#else
+    static PtrNotifyWinEvent ptrNotifyWinEvent = 0;
+    static bool resolvedNWE = false;
+    if (!resolvedNWE) {
+        resolvedNWE = true;
+        ptrNotifyWinEvent = (PtrNotifyWinEvent)QSystemLibrary::resolve(QLatin1String("user32"), "NotifyWinEvent");
+    }
+    if (!ptrNotifyWinEvent)
+        return;
+
+    // An event has to be associated with a window,
+    // so find the first parent that is a widget and that has a WId
+    QAccessibleInterface *iface = event.accessibleInterface();
+    QWindow *window = iface ? window_helper(iface) : 0;
+    delete iface;
+
+    if (!window) {
+        window = QGuiApplication::activeWindow();
+        if (!window)
+            return;
+    }
+
+    QPlatformNativeInterface *platform = QGuiApplication::platformNativeInterface();
+    HWND hWnd = (HWND)platform->nativeResourceForWindow("handle", window);
+
+    static int eventNum = 0;
+    if (event.type() != QAccessible::MenuCommand) { // MenuCommand is faked
+        // See comment "SENDING EVENTS TO OBJECTS WITH NO WINDOW HANDLE"
+        eventNum %= 50;              //[0..49]
+        int eventId = - (eventNum - 1);
+
+        qAccessibleRecentSentEvents()->insert(eventId, qMakePair(event.object(), event.child()));
+        ptrNotifyWinEvent(event.type(), hWnd, OBJID_CLIENT, eventId );
+
+        ++eventNum;
+    }
+#endif // Q_OS_WINCE
+}
+
+
+/*!
+  \internal
+  helper to wrap a QAccessibleInterface inside a IAccessible*
+*/
+IAccessible *QWindowsAccessibility::wrap(QAccessibleInterface *acc)
+{
+    if (!acc)
+        return 0;
+    QWindowsIA2Accessible *wacc = new QWindowsIA2Accessible(acc);
+    IAccessible *iacc = 0;
+    wacc->QueryInterface(IID_IAccessible, (void**)&iacc);
+    return iacc;
+}
+
+/*!
+  \internal
+*/
+QPair<QObject*, int> QWindowsAccessibility::getCachedObject(int entryId)
+{
+    return qAccessibleRecentSentEvents()->value(entryId);
+}
+
+/*
+void QWindowsAccessibility::setRootObject(QObject *o)
+{
+
+}
+
+void QWindowsAccessibility::initialize()
+{
+
+}
+
+void QWindowsAccessibility::cleanup()
+{
+
+}
+
+*/
+
+bool QWindowsAccessibility::handleAccessibleObjectFromWindowRequest(HWND hwnd, WPARAM wParam, LPARAM lParam, LRESULT *lResult)
+{
+    if (static_cast<long>(lParam) == static_cast<long>(UiaRootObjectId)) {
+        /* For UI Automation */
+    } else if ((DWORD)lParam == OBJID_CLIENT) {
+#if 1
+        // Ignoring all requests while starting up
+        // ### Maybe QPA takes care of this???
+        if (QApplication::startingUp() || QApplication::closingDown())
+            return false;
+#endif
+
+        typedef LRESULT (WINAPI *PtrLresultFromObject)(REFIID, WPARAM, LPUNKNOWN);
+        static PtrLresultFromObject ptrLresultFromObject = 0;
+        static bool oleaccChecked = false;
+
+        if (!oleaccChecked) {
+            oleaccChecked = true;
+#if !defined(Q_OS_WINCE)
+            ptrLresultFromObject = (PtrLresultFromObject)QSystemLibrary::resolve(QLatin1String("oleacc"), "LresultFromObject");
+#endif
+        }
+
+        if (ptrLresultFromObject) {
+            QWindow *window = QWindowsContext::instance()->findWindow(hwnd);
+            if (window) {
+                QAccessibleInterface *acc = window->accessibleRoot();
+                if (acc) {
+                    if (IAccessible *iface = wrap(acc)) {
+                        *lResult = ptrLresultFromObject(IID_IAccessible, wParam, iface);  // ref == 2
+                        if (*lResult) {
+                            iface->Release(); // the client will release the object again, and then it will destroy itself
+                        }
+                        return true;
+                    } else {
+                        delete acc;
+                    }
+                }
+            }
+        }
+    }
+    return false;
+}
+
+QT_END_NAMESPACE
+
+#endif //QT_NO_ACCESSIBILITY
diff --git a/src/plugins/platforms/windows/accessible/qwindowsaccessibility.h b/src/plugins/platforms/windows/accessible/qwindowsaccessibility.h
new file mode 100644
index 0000000..3b70695
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/qwindowsaccessibility.h
@@ -0,0 +1,73 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QWINDOWSACCESSIBILITY_H
+#define QWINDOWSACCESSIBILITY_H
+
+#include "../qtwindowsglobal.h"
+#include "../qwindowscontext.h"
+#include <QtGui/QPlatformAccessibility>
+
+#include <oleacc.h>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+class QWindowsAccessibility : public QPlatformAccessibility
+{
+public:
+    QWindowsAccessibility();
+    static bool handleAccessibleObjectFromWindowRequest(HWND hwnd, WPARAM wParam, LPARAM lParam, LRESULT *lResult);
+    virtual void notifyAccessibilityUpdate(const QAccessibleEvent &event);
+    /*
+    virtual void setRootObject(QObject *o);
+    virtual void initialize();
+    virtual void cleanup();
+    */
+    static IAccessible *wrap(QAccessibleInterface *acc);
+
+    static QPair<QObject*, int> getCachedObject(int entryId);
+};
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // QWINDOWSACCESSIBILITY_H
diff --git a/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.cpp b/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.cpp
new file mode 100644
index 0000000..ca3ce0a
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.cpp
@@ -0,0 +1,1228 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/QtConfig>
+#ifndef QT_NO_ACCESSIBILITY
+
+#include "qwindowsmsaaaccessible.h"
+#include "qwindowsaccessibility.h"
+#include <oleacc.h>
+#include <servprov.h>
+#include <winuser.h>
+#include "comutils.h"
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qpair.h>
+#include <QtCore/qsettings.h>
+#include <QtGui/qaccessible.h>
+#include <QtGui/qaccessible2.h>
+#include <QtGui/qguiapplication.h>
+#include <QtGui/qplatformnativeinterface_qpa.h>
+#include <QtGui/qwindow.h>
+#include <QtWidgets/qapplication.h>
+#include <QtWidgets/qgraphicsitem.h>
+#include <QtWidgets/qgraphicsview.h>
+#include <QtWidgets/qmessagebox.h>
+
+//#include <uiautomationcoreapi.h>
+#ifndef UiaRootObjectId
+#define UiaRootObjectId        -25
+#endif
+
+#if !defined(Q_CC_BOR) && !defined (Q_CC_GNU)
+#include <comdef.h>
+#endif
+
+#ifdef Q_OS_WINCE
+#include "../qguifunctions_wince.h"
+#endif
+
+#include "../qtwindows_additional.h"
+
+
+QT_BEGIN_NAMESPACE
+
+class QWindowsEnumerate : public IEnumVARIANT
+{
+public:
+    QWindowsEnumerate(const QVector<int> &a)
+        : ref(0), current(0),array(a)
+    {
+    }
+
+    virtual ~QWindowsEnumerate() {}
+
+    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *);
+    ULONG STDMETHODCALLTYPE AddRef();
+    ULONG STDMETHODCALLTYPE Release();
+
+    HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **ppEnum);
+    HRESULT STDMETHODCALLTYPE Next(unsigned long  celt, VARIANT FAR*  rgVar, unsigned long FAR*  pCeltFetched);
+    HRESULT STDMETHODCALLTYPE Reset();
+    HRESULT STDMETHODCALLTYPE Skip(unsigned long celt);
+
+private:
+    ULONG ref;
+    ULONG current;
+    QVector<int> array;
+};
+
+HRESULT STDMETHODCALLTYPE QWindowsEnumerate::QueryInterface(REFIID id, LPVOID *iface)
+{
+    *iface = 0;
+    if (id == IID_IUnknown)
+        *iface = (IUnknown*)this;
+    else if (id == IID_IEnumVARIANT)
+        *iface = (IEnumVARIANT*)this;
+
+    if (*iface) {
+        AddRef();
+        return S_OK;
+    }
+
+    return E_NOINTERFACE;
+}
+
+ULONG STDMETHODCALLTYPE QWindowsEnumerate::AddRef()
+{
+    return ++ref;
+}
+
+ULONG STDMETHODCALLTYPE QWindowsEnumerate::Release()
+{
+    if (!--ref) {
+        delete this;
+        return 0;
+    }
+    return ref;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsEnumerate::Clone(IEnumVARIANT **ppEnum)
+{
+    QWindowsEnumerate *penum = 0;
+    *ppEnum = 0;
+
+    penum = new QWindowsEnumerate(array);
+    if (!penum)
+        return E_OUTOFMEMORY;
+    penum->current = current;
+    penum->array = array;
+    penum->AddRef();
+    *ppEnum = penum;
+
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsEnumerate::Next(unsigned long  celt, VARIANT FAR*  rgVar, unsigned long FAR*  pCeltFetched)
+{
+    if (pCeltFetched)
+        *pCeltFetched = 0;
+
+    ULONG l;
+    for (l = 0; l < celt; l++) {
+        VariantInit(&rgVar[l]);
+        if ((current+1) > (ULONG)array.size()) {
+            *pCeltFetched = l;
+            return S_FALSE;
+        }
+
+        rgVar[l].vt = VT_I4;
+        rgVar[l].lVal = array[(int)current];
+        ++current;
+    }
+    *pCeltFetched = l;
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsEnumerate::Reset()
+{
+    current = 0;
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsEnumerate::Skip(unsigned long celt)
+{
+    current += celt;
+    if (current > (ULONG)array.size()) {
+        current = array.size();
+        return S_FALSE;
+    }
+    return S_OK;
+}
+
+static bool compareAccessible(QAccessibleInterface *one, QAccessibleInterface *other)
+{
+    if (one == other) return true;
+    if (!one || !other) return false;
+
+    if (one->object() && other->object() && (one->object() == other->object()))
+        return true;
+    QAIPointer onePar(one->parent());
+    QAIPointer otherPar(other->parent());
+
+    if (compareAccessible(onePar.data(), otherPar.data()))
+        return onePar->indexOfChild(one) == otherPar->indexOfChild(other);
+    return false;
+}
+
+#ifndef QT_NO_DEBUG
+bool debug_accessibility()
+{
+    static int debugging = -1;
+    if (debugging == -1)
+        debugging = qgetenv("QT_DEBUG_ACCESSIBILITY").toInt();
+    return !!debugging;
+}
+#endif
+
+#if defined(DEBUG_SHOW_ATCLIENT_COMMANDS)
+void accessibleDebugClientCalls_helper(const char* funcName, const QAccessibleInterface *iface)
+{
+    QString str;
+    QDebug dbg(&str);
+    dbg << iface << QLatin1String(funcName);
+    accessibleDebug("%s", qPrintable(str));
+}
+#endif
+
+/*
+  IDispatch
+*/
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::GetTypeInfoCount(unsigned int * pctinfo)
+{
+    // We don't use a type library
+    *pctinfo = 0;
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::GetTypeInfo(unsigned int, unsigned long, ITypeInfo **pptinfo)
+{
+    // We don't use a type library
+    *pptinfo = 0;
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::GetIDsOfNames(const _GUID &, wchar_t **rgszNames, unsigned int, unsigned long, long *rgdispid)
+{
+#if !defined(Q_CC_BOR) && !defined(Q_CC_GNU)
+    // PROPERTIES:  Hierarchical
+    if (_bstr_t(rgszNames[0]) == _bstr_t(L"accParent"))
+        rgdispid[0] = DISPID_ACC_PARENT;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accChildCount"))
+        rgdispid[0] = DISPID_ACC_CHILDCOUNT;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accChild"))
+        rgdispid[0] = DISPID_ACC_CHILD;
+
+    // PROPERTIES:  Descriptional
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accName("))
+        rgdispid[0] = DISPID_ACC_NAME;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accValue"))
+        rgdispid[0] = DISPID_ACC_VALUE;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accDescription"))
+        rgdispid[0] = DISPID_ACC_DESCRIPTION;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accRole"))
+        rgdispid[0] = DISPID_ACC_ROLE;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accState"))
+        rgdispid[0] = DISPID_ACC_STATE;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accHelp"))
+        rgdispid[0] = DISPID_ACC_HELP;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accHelpTopic"))
+        rgdispid[0] = DISPID_ACC_HELPTOPIC;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accKeyboardShortcut"))
+        rgdispid[0] = DISPID_ACC_KEYBOARDSHORTCUT;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accFocus"))
+        rgdispid[0] = DISPID_ACC_FOCUS;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accSelection"))
+        rgdispid[0] = DISPID_ACC_SELECTION;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accDefaultAction"))
+        rgdispid[0] = DISPID_ACC_DEFAULTACTION;
+
+    // METHODS
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accSelect"))
+        rgdispid[0] = DISPID_ACC_SELECT;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accLocation"))
+        rgdispid[0] = DISPID_ACC_LOCATION;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accNavigate"))
+        rgdispid[0] = DISPID_ACC_NAVIGATE;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accHitTest"))
+        rgdispid[0] = DISPID_ACC_HITTEST;
+    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accDoDefaultAction"))
+        rgdispid[0] = DISPID_ACC_DODEFAULTACTION;
+    else
+        return DISP_E_UNKNOWNINTERFACE;
+
+    return S_OK;
+#else
+    Q_UNUSED(rgszNames);
+    Q_UNUSED(rgdispid);
+
+    return DISP_E_MEMBERNOTFOUND;
+#endif
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::Invoke(long dispIdMember,
+                                                     const _GUID &,
+                                                     unsigned long,
+                                                     unsigned short wFlags,
+                                                     tagDISPPARAMS *pDispParams,
+                                                     tagVARIANT *pVarResult,
+                                                     tagEXCEPINFO *, unsigned int *)
+{
+    HRESULT hr = DISP_E_MEMBERNOTFOUND;
+
+    switch (dispIdMember)
+    {
+        case DISPID_ACC_PARENT:
+            if (wFlags == DISPATCH_PROPERTYGET) {
+                if (!pVarResult)
+                    return E_INVALIDARG;
+                hr = get_accParent(&pVarResult->pdispVal);
+            } else {
+                hr = DISP_E_MEMBERNOTFOUND;
+            }
+            break;
+
+        case DISPID_ACC_CHILDCOUNT:
+            if (wFlags == DISPATCH_PROPERTYGET) {
+                if (!pVarResult)
+                    return E_INVALIDARG;
+                hr = get_accChildCount(&pVarResult->lVal);
+            } else {
+                hr = DISP_E_MEMBERNOTFOUND;
+            }
+            break;
+
+        case DISPID_ACC_CHILD:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accChild(pDispParams->rgvarg[0], &pVarResult->pdispVal);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_NAME:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accName(pDispParams->rgvarg[0], &pVarResult->bstrVal);
+            else if (wFlags == DISPATCH_PROPERTYPUT)
+                hr = put_accName(pDispParams->rgvarg[0], pVarResult->bstrVal);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_VALUE:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accValue(pDispParams->rgvarg[0], &pVarResult->bstrVal);
+            else if (wFlags == DISPATCH_PROPERTYPUT)
+                hr = put_accValue(pDispParams->rgvarg[0], pVarResult->bstrVal);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_DESCRIPTION:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accDescription(pDispParams->rgvarg[0], &pVarResult->bstrVal);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_ROLE:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accRole(pDispParams->rgvarg[0], pVarResult);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_STATE:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accState(pDispParams->rgvarg[0], pVarResult);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_HELP:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accHelp(pDispParams->rgvarg[0], &pVarResult->bstrVal);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_HELPTOPIC:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accHelpTopic(&pDispParams->rgvarg[2].bstrVal, pDispParams->rgvarg[1], &pDispParams->rgvarg[0].lVal);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_KEYBOARDSHORTCUT:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accKeyboardShortcut(pDispParams->rgvarg[0], &pVarResult->bstrVal);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_FOCUS:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accFocus(pVarResult);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_SELECTION:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accSelection(pVarResult);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_DEFAULTACTION:
+            if (wFlags == DISPATCH_PROPERTYGET)
+                hr = get_accDefaultAction(pDispParams->rgvarg[0], &pVarResult->bstrVal);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_SELECT:
+            if (wFlags == DISPATCH_METHOD)
+                hr = accSelect(pDispParams->rgvarg[1].lVal, pDispParams->rgvarg[0]);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_LOCATION:
+            if (wFlags == DISPATCH_METHOD)
+                hr = accLocation(&pDispParams->rgvarg[4].lVal, &pDispParams->rgvarg[3].lVal, &pDispParams->rgvarg[2].lVal, &pDispParams->rgvarg[1].lVal, pDispParams->rgvarg[0]);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_NAVIGATE:
+            if (wFlags == DISPATCH_METHOD)
+                hr = accNavigate(pDispParams->rgvarg[1].lVal, pDispParams->rgvarg[0], pVarResult);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_HITTEST:
+            if (wFlags == DISPATCH_METHOD)
+                hr = accHitTest(pDispParams->rgvarg[1].lVal, pDispParams->rgvarg[0].lVal, pVarResult);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        case DISPID_ACC_DODEFAULTACTION:
+            if (wFlags == DISPATCH_METHOD)
+                hr = accDoDefaultAction(pDispParams->rgvarg[0]);
+            else
+                hr = DISP_E_MEMBERNOTFOUND;
+            break;
+
+        default:
+            hr = DISP_E_MEMBERNOTFOUND;
+            break;
+    }
+
+    if (!SUCCEEDED(hr)) {
+        return hr;
+    }
+    return hr;
+}
+
+/*
+  IAccessible
+
+IAccessible::accHitTest documents the value returned in pvarID like this:
+
+| *Point location*                                       | *vt member* | *Value member*          |
++========================================================+=============+=========================+
+| Outside of the object's boundaries, and either inside  | VT_EMPTY    | None.                   |
+| or outside of the object's bounding rectangle.         |             |                         |
++--------------------------------------------------------+-------------+-------------------------+
+|  Within the object but not within a child element or a | VT_I4       | lVal is CHILDID_SELF    |
+|  child object.                                         |             |                         |
++--------------------------------------------------------+-------------+-------------------------+
+| Within a child element.                                | VT_I4       | lVal contains           |
+|                                                        |             | the child ID.           |
++--------------------------------------------------------+-------------+-------------------------+
+| Within a child object.                                 | VT_DISPATCH | pdispVal is set to the  |
+|                                                        |             | child object's IDispatch|
+|                                                        |             | interface pointer       |
++--------------------------------------------------------+-------------+-------------------------+
+*/
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::accHitTest(long xLeft, long yTop, VARIANT *pvarID)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QAccessibleInterface *child = accessible->childAt(xLeft, yTop);
+    if (child == 0) {
+        // no child found, return this item if it contains the coordinates
+        if (accessible->rect().contains(xLeft, yTop)) {
+            (*pvarID).vt = VT_I4;
+            (*pvarID).lVal = CHILDID_SELF;
+            return S_OK;
+        }
+    } else {
+        IAccessible *iface = QWindowsAccessibility::wrap(child);
+        if (iface) {
+            (*pvarID).vt = VT_DISPATCH;
+            (*pvarID).pdispVal = iface;
+            return S_OK;
+        }
+    }
+
+    // Did not find anything
+    (*pvarID).vt = VT_EMPTY;
+    return S_FALSE;
+}
+
+/*
+ It is recommended to read
+    "Implementing a Microsoft Active Accessibility (MSAA) Server.
+    Practical Tips for Developers and How Mozilla Does It"
+    (https://developer.mozilla.org/En/Accessibility/Implementing_an_MSAA_Server)
+
+ to get an overview of what's important to implement and what parts of MSAA
+ can be ignored. All stuff prefixed with "moz" are information from that page.
+*/
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varID)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QRect rect;
+    if (varID.lVal) {
+        QAIPointer child = QAIPointer(accessible->child(varID.lVal - 1));
+        if (child->isValid())
+            rect = child->rect();
+    } else {
+        rect = accessible->rect();
+    }
+
+    *pxLeft = rect.x();
+    *pyTop = rect.y();
+    *pcxWidth = rect.width();
+    *pcyHeight = rect.height();
+
+    return S_OK;
+}
+
+// moz: [important, but no need to implement up/down/left/right]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEnd)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QAccessibleInterface *acc = 0;
+    switch (navDir) {
+    case NAVDIR_FIRSTCHILD:
+        acc = accessible->child(0);
+        break;
+    case NAVDIR_LASTCHILD:
+        acc = accessible->child(accessible->childCount() - 1);
+        break;
+    case NAVDIR_NEXT:
+    case NAVDIR_PREVIOUS:
+        if (!varStart.lVal){
+            QAccessibleInterface *parent = accessible->parent();
+            if (parent) {
+                int index = parent->indexOfChild(accessible);
+                index += (navDir == NAVDIR_NEXT) ? 1 : -1;
+                if (index >= 0 && index < parent->childCount())
+                    acc = parent->child(index);
+                delete parent;
+            }
+        } else {
+            int index = varStart.lVal;
+            index += (navDir == NAVDIR_NEXT) ? 1 : -1;
+            if (index > 0 && index <= accessible->childCount())
+                acc = accessible->child(index - 1);
+        }
+        break;
+
+    // Geometrical
+    case NAVDIR_UP:
+    case NAVDIR_DOWN:
+    case NAVDIR_LEFT:
+    case NAVDIR_RIGHT:
+        if (QAccessibleInterface *pIface = accessible->parent()) {
+            const int indexOfOurself = pIface->indexOfChild(accessible);
+            QRect startg = accessible->rect();
+            QPoint startc = startg.center();
+            QAccessibleInterface *candidate = 0;
+            unsigned mindist = UINT_MAX;    // will work on screen sizes at least up to 46340x46340
+            const int sibCount = pIface->childCount();
+            for (int i = 0; i < sibCount; ++i) {
+                QAccessibleInterface *sibling = 0;
+                sibling = pIface->child(i);
+                Q_ASSERT(sibling);
+                if (i == indexOfOurself || sibling->state().invisible) {
+                    //ignore ourself and invisible siblings
+                    delete sibling;
+                    continue;
+                }
+
+                QRect sibg = sibling->rect();
+                QPoint sibc = sibg.center();
+                QPoint sibp;
+                QPoint startp;
+                QPoint distp;
+                switch (navDir) {
+                case NAVDIR_LEFT:
+                    startp = QPoint(startg.left(), startg.top() + startg.height() / 2);
+                    sibp = QPoint(sibg.right(), sibg.top() + sibg.height() / 2);
+                    if (QPoint(sibc - startc).x() >= 0) {
+                        delete sibling;
+                        continue;
+                    }
+                    distp = sibp - startp;
+                    break;
+                case NAVDIR_RIGHT:
+                    startp = QPoint(startg.right(), startg.top() + startg.height() / 2);
+                    sibp = QPoint(sibg.left(), sibg.top() + sibg.height() / 2);
+                    if (QPoint(sibc - startc).x() <= 0) {
+                        delete sibling;
+                        continue;
+                    }
+                    distp = sibp - startp;
+                    break;
+                case NAVDIR_UP:
+                    startp = QPoint(startg.left() + startg.width() / 2, startg.top());
+                    sibp = QPoint(sibg.left() + sibg.width() / 2, sibg.bottom());
+                    if (QPoint(sibc - startc).y() >= 0) {
+                        delete sibling;
+                        continue;
+                    }
+                    distp = sibp - startp;
+                    break;
+                case NAVDIR_DOWN:
+                    startp = QPoint(startg.left() + startg.width() / 2, startg.bottom());
+                    sibp = QPoint(sibg.left() + sibg.width() / 2, sibg.top());
+                    if (QPoint(sibc - startc).y() <= 0) {
+                        delete sibling;
+                        continue;
+                    }
+                    distp = sibp - startp;
+                    break;
+                default:
+                    break;
+                }
+
+                // Since we're *comparing* (and not measuring) distances, we can compare the
+                // squared distance, (thus, no need to take the sqrt()).
+                unsigned dist = distp.x() * distp.x() + distp.y() * distp.y();
+                if (dist < mindist) {
+                    delete candidate;
+                    candidate = sibling;
+                    mindist = dist;
+                } else {
+                    delete sibling;
+                }
+            }
+            delete pIface;
+            acc = candidate;
+        }
+        break;
+    default:
+        break;
+    }
+    if (!acc) {
+        (*pvarEnd).vt = VT_EMPTY;
+        return S_FALSE;
+    }
+
+    if (IAccessible *iface = QWindowsAccessibility::wrap(acc)) {
+        (*pvarEnd).vt = VT_DISPATCH;
+        (*pvarEnd).pdispVal = iface;
+        return S_OK;
+    } else {
+        if (acc != accessible)
+            delete acc;
+    }
+
+    (*pvarEnd).vt = VT_EMPTY;
+    return S_FALSE;
+}
+
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accChild(VARIANT varChildID, IDispatch** ppdispChild)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (varChildID.vt != VT_I4)
+        return E_INVALIDARG;
+
+
+    int childIndex = varChildID.lVal;
+    QAccessibleInterface *acc = 0;
+
+    if (childIndex < 0) {
+        const int entry = childIndex;
+        QPair<QObject*, int> ref = QWindowsAccessibility::getCachedObject(entry);
+        if (ref.first) {
+            acc = QAccessible::queryAccessibleInterface(ref.first);
+            if (acc && ref.second >= 0) {
+                QAccessibleInterface *res = acc->child(ref.second);
+                delete acc;
+                if (!res)
+                    return E_INVALIDARG;
+                acc = res;
+            }
+        } else {
+            qWarning("get_accChild got a negative varChildID, but did not find it in cache");
+        }
+    } else {
+        if (childIndex) {
+            acc = accessible->child(childIndex - 1);
+        } else {
+            // Yes, some AT clients (Active Accessibility Object Inspector)
+            // actually ask for the same object. As a consequence, we need to clone ourselves:
+            if (QAccessibleInterface *par = accessible->parent()) {
+                const int indexOf = par->indexOfChild(accessible);
+                QAccessibleInterface *clone = par->child(indexOf);
+                delete par;
+                acc = clone;
+            }
+        }
+    }
+
+    if (acc) {
+        *ppdispChild = QWindowsAccessibility::wrap(acc);
+        return S_OK;
+    }
+
+    return E_FAIL;
+}
+
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accChildCount(long* pcountChildren)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *pcountChildren = accessible->childCount();
+    return S_OK;
+}
+
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accParent(IDispatch** ppdispParent)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QAccessibleInterface *acc = accessible->parent();
+    if (acc) {
+        if (IAccessible *iface = QWindowsAccessibility::wrap(acc)) {
+            *ppdispParent = iface;
+            return S_OK;
+        } else {
+            delete acc;
+        }
+    }
+
+    *ppdispParent = 0;
+    return S_FALSE;
+}
+
+/*
+  Properties and methods
+*/
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::accDoDefaultAction(VARIANT varID)
+{
+    Q_UNUSED(varID);
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleActionInterface *actionIface = accessible->actionInterface()) {
+        const QString def = actionIface->actionNames().value(0);
+        if (!def.isEmpty()) {
+            actionIface->doAction(def);
+            return S_OK;
+        }
+    }
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accDefaultAction(VARIANT varID, BSTR* pszDefaultAction)
+{
+    Q_UNUSED(varID);
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *pszDefaultAction = 0;
+    if (QAccessibleActionInterface *actionIface = accessible->actionInterface()) {
+        const QString def = actionIface->actionNames().value(0);
+        if (!def.isEmpty())
+            *pszDefaultAction = QStringToBSTR(def);
+    }
+    return *pszDefaultAction ? S_OK : S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accDescription(VARIANT varID, BSTR* pszDescription)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+
+    QString descr;
+    if (varID.lVal) {
+        QAIPointer child = childPointer(varID);
+        if (!child)
+            return E_FAIL;
+        descr = child->text(QAccessible::Description);
+    } else {
+        descr = accessible->text(QAccessible::Description);
+    }
+    if (descr.size()) {
+        *pszDescription = QStringToBSTR(descr);
+        return S_OK;
+    }
+
+    *pszDescription = 0;
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accHelp(VARIANT varID, BSTR *pszHelp)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QString help;
+    if (varID.lVal) {
+        QAIPointer child = childPointer(varID);
+        if (!child)
+            return E_FAIL;
+        help = child->text(QAccessible::Help);
+    } else {
+        help = accessible->text(QAccessible::Help);
+    }
+    if (help.size()) {
+        *pszHelp = QStringToBSTR(help);
+        return S_OK;
+    }
+
+    *pszHelp = 0;
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accHelpTopic(BSTR *, VARIANT, long *)
+{
+    return DISP_E_MEMBERNOTFOUND;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accKeyboardShortcut(VARIANT varID, BSTR *pszKeyboardShortcut)
+{
+    Q_UNUSED(varID);
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    *pszKeyboardShortcut = 0;
+    if (QAccessibleActionInterface *actionIface = accessible->actionInterface()) {
+        const QString def = actionIface->actionNames().value(0);
+        if (!def.isEmpty()) {
+            const QString keyBoardShortCut = actionIface->keyBindingsForAction(def).value(0);
+            if (!keyBoardShortCut.isEmpty())
+                *pszKeyboardShortcut = QStringToBSTR(keyBoardShortCut);
+        }
+    }
+    return *pszKeyboardShortcut ? S_OK : S_FALSE;
+}
+
+static QAccessibleInterface *relatedInterface(QAccessibleInterface *iface, QAccessible::RelationFlag flag)
+{
+    typedef QPair<QAccessibleInterface *, QAccessible::Relation> RelationPair;
+    QVector<RelationPair> rels = iface->relations(flag);
+
+    for (int i = 1; i < rels.count(); ++i)
+        delete rels.at(i).first;
+
+    return rels.value(0).first;
+}
+
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accName(VARIANT varID, BSTR* pszName)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QString name;
+    if (varID.lVal) {
+        QAIPointer child = childPointer(varID);
+        if (!child)
+            return E_FAIL;
+        name = child->text(QAccessible::Name);
+        if (name.isEmpty()) {
+            if (QAccessibleInterface *labelInterface = relatedInterface(child.data(), QAccessible::Label)) {
+                name = labelInterface->text(QAccessible::Name);
+                delete labelInterface;
+            }
+        }
+    } else {
+        name = accessible->text(QAccessible::Name);
+        if (name.isEmpty()) {
+            if (QAccessibleInterface *labelInterface = relatedInterface(accessible, QAccessible::Label)) {
+                name = labelInterface->text(QAccessible::Name);
+                delete labelInterface;
+            }
+        }
+    }
+    if (name.size()) {
+        *pszName = QStringToBSTR(name);
+        return S_OK;
+    }
+
+    *pszName = 0;
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::put_accName(VARIANT, BSTR)
+{
+    accessibleDebugClientCalls(accessible);
+    return DISP_E_MEMBERNOTFOUND;
+}
+
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accRole(VARIANT varID, VARIANT *pvarRole)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QAccessible::Role role;
+    if (varID.lVal) {
+        QAIPointer child = childPointer(varID);
+        if (!child)
+            return E_FAIL;
+        role = child->role();
+    } else {
+        role = accessible->role();
+    }
+
+    if (role != QAccessible::NoRole) {
+        if (role == QAccessible::LayeredPane)
+            role = QAccessible::Pane;
+        (*pvarRole).vt = VT_I4;
+        (*pvarRole).lVal = role;
+    } else {
+        (*pvarRole).vt = VT_EMPTY;
+    }
+    return S_OK;
+}
+
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accState(VARIANT varID, VARIANT *pvarState)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    QAccessible::State state;
+    if (varID.lVal) {
+        QAIPointer child = childPointer(varID);
+        if (!child.data())
+            return E_FAIL;
+        state = child->state();
+    } else {
+        state = accessible->state();
+    }
+
+    LONG st = 0;
+    if (state.animated)
+        st |= STATE_SYSTEM_ANIMATED;
+    if (state.busy)
+        st |= STATE_SYSTEM_BUSY;
+    if (state.checked)
+        st |= STATE_SYSTEM_CHECKED;
+    if (state.collapsed)
+        st |= STATE_SYSTEM_COLLAPSED;
+    if (state.defaultButton)
+        st |= STATE_SYSTEM_DEFAULT;
+    if (state.expanded)
+        st |= STATE_SYSTEM_EXPANDED;
+    if (state.extSelectable)
+        st |= STATE_SYSTEM_EXTSELECTABLE;
+    if (state.focusable)
+        st |= STATE_SYSTEM_FOCUSABLE;
+    if (state.focused)
+        st |= STATE_SYSTEM_FOCUSED;
+    if (state.hasPopup)
+        st |= STATE_SYSTEM_HASPOPUP;
+    if (state.hotTracked)
+        st |= STATE_SYSTEM_HOTTRACKED;
+    if (state.invisible)
+        st |= STATE_SYSTEM_INVISIBLE;
+    if (state.linked)
+        st |= STATE_SYSTEM_LINKED;
+    if (state.marqueed)
+        st |= STATE_SYSTEM_MARQUEED;
+    if (state.checkStateMixed)
+        st |= STATE_SYSTEM_MIXED;
+    if (state.movable)
+        st |= STATE_SYSTEM_MOVEABLE;
+    if (state.multiSelectable)
+        st |= STATE_SYSTEM_MULTISELECTABLE;
+    if (state.offscreen)
+        st |= STATE_SYSTEM_OFFSCREEN;
+    if (state.pressed)
+        st |= STATE_SYSTEM_PRESSED;
+    if (state.passwordEdit)
+        st |= STATE_SYSTEM_PROTECTED;
+    if (state.readOnly)
+        st |= STATE_SYSTEM_READONLY;
+    if (state.selectable)
+        st |= STATE_SYSTEM_SELECTABLE;
+    if (state.selected)
+        st |= STATE_SYSTEM_SELECTED;
+    if (state.selfVoicing)
+        st |= STATE_SYSTEM_SELFVOICING;
+    if (state.sizeable)
+        st |= STATE_SYSTEM_SIZEABLE;
+    if (state.traversed)
+        st |= STATE_SYSTEM_TRAVERSED;
+
+    (*pvarState).vt = VT_I4;
+    (*pvarState).lVal = st;
+    return S_OK;
+}
+
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accValue(VARIANT varID, BSTR* pszValue)
+{
+    accessibleDebugClientCalls(accessible);
+    if (varID.vt != VT_I4)
+        return E_INVALIDARG;
+
+    if (!accessible->isValid() || varID.lVal) {
+        return E_FAIL;
+    }
+
+    QString value;
+    if (accessible->valueInterface()) {
+        value = QString::number(accessible->valueInterface()->currentValue().toDouble());
+    } else {
+        value = accessible->text(QAccessible::Value);
+    }
+    if (!value.isNull()) {
+        *pszValue = QStringToBSTR(value);
+        return S_OK;
+    }
+
+    *pszValue = 0;
+    accessibleDebug("return S_FALSE");
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::put_accValue(VARIANT, BSTR)
+{
+    accessibleDebugClientCalls(accessible);
+    return DISP_E_MEMBERNOTFOUND;
+}
+
+// moz: [important]
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::accSelect(long flagsSelect, VARIANT varID)
+{
+    Q_UNUSED(flagsSelect);
+    Q_UNUSED(varID);
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    bool res = false;
+
+/*
+  ### Check for accessibleTableInterface() or accessibleTextInterface()
+
+  ### and if there are no ia2 interfaces we should do nothing??
+    if (flagsSelect & SELFLAG_TAKEFOCUS)
+        res = accessible->doAction(SetFocus, varID.lVal, QVariantList());
+    if (flagsSelect & SELFLAG_TAKESELECTION) {
+        accessible->doAction(ClearSelection, 0, QVariantList());
+        res = accessible->doAction(AddToSelection, varID.lVal, QVariantList());
+    }
+    if (flagsSelect & SELFLAG_EXTENDSELECTION)
+        res = accessible->doAction(ExtendSelection, varID.lVal, QVariantList());
+    if (flagsSelect & SELFLAG_ADDSELECTION)
+        res = accessible->doAction(AddToSelection, varID.lVal, QVariantList());
+    if (flagsSelect & SELFLAG_REMOVESELECTION)
+        res = accessible->doAction(RemoveSelection, varID.lVal, QVariantList());
+*/
+    return res ? S_OK : S_FALSE;
+}
+
+/*!
+    \internal
+    Can return:
+
+  +-------------+------------------------------------------------------------------------------+
+  | VT_EMPTY    | None. Neither this object nor any of its children has the keyboard focus.    |
+  +-------------+------------------------------------------------------------------------------+
+  | VT_I4       | lVal is CHILDID_SELF. The object itself has the keyboard focus.              |
+  +-------------+------------------------------------------------------------------------------+
+  | VT_I4       | lVal contains the child ID of the child element that has the keyboard focus. |
+  +-------------+------------------------------------------------------------------------------+
+  | VT_DISPATCH | pdispVal member is the address of the IDispatch interface for the child      |
+  |             | object that has the keyboard focus.                                          |
+  +-------------+------------------------------------------------------------------------------+
+    moz: [important]
+*/
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accFocus(VARIANT *pvarID)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    if (QAccessibleInterface *acc = accessible->focusChild()) {
+        if (compareAccessible(acc, accessible)) {
+            (*pvarID).vt = VT_I4;
+            (*pvarID).lVal = CHILDID_SELF;
+            delete acc;
+            return S_OK;
+        } else {
+            if (IAccessible *iface = QWindowsAccessibility::wrap(acc)) {
+                (*pvarID).vt = VT_DISPATCH;
+                (*pvarID).pdispVal = iface;
+                return S_OK;
+            }
+        }
+        delete acc;
+    }
+    (*pvarID).vt = VT_EMPTY;
+    return S_FALSE;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::get_accSelection(VARIANT *pvarChildren)
+{
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+
+    int cc = accessible->childCount();
+    QVector<int> sel(cc);
+    int selIndex = 0;
+    for (int i = 0; i < cc; ++i) {
+        bool isSelected = false;
+        QAccessibleInterface *child = accessible->child(i);
+        if (child) {
+            isSelected = child->state().selected;
+            delete child;
+        }
+        if (isSelected)
+            sel[selIndex++] = i+1;
+    }
+    sel.resize(selIndex);
+    if (sel.isEmpty()) {
+        (*pvarChildren).vt = VT_EMPTY;
+        return S_FALSE;
+    }
+    if (sel.size() == 1) {
+        (*pvarChildren).vt = VT_I4;
+        (*pvarChildren).lVal = sel[0];
+        return S_OK;
+    }
+    IEnumVARIANT *iface = new QWindowsEnumerate(sel);
+    IUnknown *uiface;
+    iface->QueryInterface(IID_IUnknown, (void**)&uiface);
+    (*pvarChildren).vt = VT_UNKNOWN;
+    (*pvarChildren).punkVal = uiface;
+
+    return S_OK;
+}
+
+QWindow *window_helper(const QAccessibleInterface *iface)
+{
+    QWindow *window = iface->window();
+    if (!window) {
+        QAccessibleInterface *acc = iface->parent();
+        while (acc && !window) {
+            window = acc->window();
+            QAccessibleInterface *par = acc->parent();
+            delete acc;
+            acc = par;
+        }
+    }
+    return window;
+}
+
+/**************************************************************\
+ *                         IOleWindow                          *
+ **************************************************************/
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::GetWindow(HWND *phwnd)
+{
+    *phwnd = 0;
+    accessibleDebugClientCalls(accessible);
+    if (!accessible->isValid())
+        return E_FAIL;
+    if (!accessible->isValid())
+        return E_UNEXPECTED;
+
+    QWindow *window = window_helper(accessible);
+    if (!window)
+        return E_FAIL;
+
+    QPlatformNativeInterface *platform = QGuiApplication::platformNativeInterface();
+    Q_ASSERT(platform);
+    *phwnd = (HWND)platform->nativeResourceForWindow("handle", window);
+    accessibleDebug("QWindowsAccessible::GetWindow(): %p", *phwnd);
+    return S_OK;
+}
+
+HRESULT STDMETHODCALLTYPE QWindowsMsaaAccessible::ContextSensitiveHelp(BOOL)
+{
+    return S_OK;
+}
+
+QT_END_NAMESPACE
+
+#endif //QT_NO_ACCESSIBILITY
diff --git a/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.h b/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.h
new file mode 100644
index 0000000..609f57b
--- /dev/null
+++ b/src/plugins/platforms/windows/accessible/qwindowsmsaaaccessible.h
@@ -0,0 +1,138 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QWINDOWSMSAAACCESSIBLE_H
+#define QWINDOWSMSAAACCESSIBLE_H
+
+#include <QtCore/QtConfig>
+#ifndef QT_NO_ACCESSIBILITY
+
+#include <oleacc.h>
+#include "Accessible2.h"
+#include <QtCore/qsharedpointer.h>
+#include <QtGui/qaccessible.h>
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_DEBUG
+bool debug_accessibility();
+# define accessibleDebug !debug_accessibility() ? (void)0 : qDebug
+#else
+# define accessibleDebug()
+#endif
+
+#define DEBUG_SHOW_ATCLIENT_COMMANDS
+#if defined(DEBUG_SHOW_ATCLIENT_COMMANDS)
+void accessibleDebugClientCalls_helper(const char* funcName, const QAccessibleInterface *iface);
+# define accessibleDebugClientCalls(iface) accessibleDebugClientCalls_helper(Q_FUNC_INFO, iface)
+#else
+# define accessibleDebugClientCalls(iface)
+#endif
+
+typedef QSharedPointer<QAccessibleInterface> QAIPointer;
+
+QWindow *window_helper(const QAccessibleInterface *iface);
+
+/**************************************************************\
+ *                     QWindowsAccessible                     *
+ **************************************************************/
+class QWindowsMsaaAccessible : public IAccessible2, public IOleWindow
+{
+public:
+    QWindowsMsaaAccessible(QAccessibleInterface *a)
+        : accessible(a)
+    {
+    }
+
+    virtual ~QWindowsMsaaAccessible()
+    {
+        delete accessible;
+    }
+
+
+    /* IDispatch */
+    HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int *);
+    HRESULT STDMETHODCALLTYPE GetTypeInfo(unsigned int, unsigned long, ITypeInfo **);
+    HRESULT STDMETHODCALLTYPE GetIDsOfNames(const _GUID &, wchar_t **, unsigned int, unsigned long, long *);
+    HRESULT STDMETHODCALLTYPE Invoke(long, const _GUID &, unsigned long, unsigned short, tagDISPPARAMS *, tagVARIANT *, tagEXCEPINFO *, unsigned int *);
+
+    /* IAccessible */
+    HRESULT STDMETHODCALLTYPE accHitTest(long xLeft, long yTop, VARIANT *pvarID);
+    HRESULT STDMETHODCALLTYPE accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varID);
+    HRESULT STDMETHODCALLTYPE accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEnd);
+    HRESULT STDMETHODCALLTYPE get_accChild(VARIANT varChildID, IDispatch** ppdispChild);
+    HRESULT STDMETHODCALLTYPE get_accChildCount(long* pcountChildren);
+    HRESULT STDMETHODCALLTYPE get_accParent(IDispatch** ppdispParent);
+
+    HRESULT STDMETHODCALLTYPE accDoDefaultAction(VARIANT varID);
+    HRESULT STDMETHODCALLTYPE get_accDefaultAction(VARIANT varID, BSTR* pszDefaultAction);
+    HRESULT STDMETHODCALLTYPE get_accDescription(VARIANT varID, BSTR* pszDescription);
+    HRESULT STDMETHODCALLTYPE get_accHelp(VARIANT varID, BSTR *pszHelp);
+    HRESULT STDMETHODCALLTYPE get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
+    HRESULT STDMETHODCALLTYPE get_accKeyboardShortcut(VARIANT varID, BSTR *pszKeyboardShortcut);
+    HRESULT STDMETHODCALLTYPE get_accName(VARIANT varID, BSTR* pszName);
+    HRESULT STDMETHODCALLTYPE put_accName(VARIANT varChild, BSTR szName);
+    HRESULT STDMETHODCALLTYPE get_accRole(VARIANT varID, VARIANT *pvarRole);
+    HRESULT STDMETHODCALLTYPE get_accState(VARIANT varID, VARIANT *pvarState);
+    HRESULT STDMETHODCALLTYPE get_accValue(VARIANT varID, BSTR* pszValue);
+    HRESULT STDMETHODCALLTYPE put_accValue(VARIANT varChild, BSTR szValue);
+
+    HRESULT STDMETHODCALLTYPE accSelect(long flagsSelect, VARIANT varID);
+    HRESULT STDMETHODCALLTYPE get_accFocus(VARIANT *pvarID);
+    HRESULT STDMETHODCALLTYPE get_accSelection(VARIANT *pvarChildren);
+
+    /* IOleWindow */
+    HRESULT STDMETHODCALLTYPE GetWindow(HWND *phwnd);
+    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);
+
+protected:
+    QAccessibleInterface *accessible;
+
+    QAIPointer childPointer(VARIANT varID)
+    {
+        return QAIPointer(accessible->child(varID.lVal - 1));
+    }
+};
+
+QT_END_NAMESPACE
+
+#endif //QT_NO_ACCESSIBILITY
+
+#endif // QWINDOWSMSAAACCESSIBLE_H
diff --git a/src/plugins/platforms/windows/qwindowsaccessibility.cpp b/src/plugins/platforms/windows/qwindowsaccessibility.cpp
deleted file mode 100644
index 134b1c8..0000000
--- a/src/plugins/platforms/windows/qwindowsaccessibility.cpp
+++ /dev/null
@@ -1,1525 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QtCore/QtConfig>
-#ifndef QT_NO_ACCESSIBILITY
-
-
-#include "qwindowsaccessibility.h"
-#include "qwindowscontext.h"
-
-#include <private/qsystemlibrary_p.h>
-
-#include <QtCore/qmap.h>
-#include <QtCore/qsettings.h>
-#include <QtCore/qsharedpointer.h>
-#include <QtCore/qpair.h>
-#include <QtWidgets/qapplication.h>
-#include <QtWidgets/qmessagebox.h>
-#include <QtWidgets/qgraphicsitem.h>
-#include <QtWidgets/qgraphicsview.h>
-#include <QtGui/qaccessible.h>
-#include <QtGui/qplatformnativeinterface_qpa.h>
-#include <QtGui/qwindow.h>
-#include <QtGui/qaccessible2.h>
-#include <oleacc.h>
-
-//#include <uiautomationcoreapi.h>
-#ifndef UiaRootObjectId
-#define UiaRootObjectId        -25
-#endif
-
-#include <winuser.h>
-#if !defined(WINABLEAPI)
-#  if defined(Q_OS_WINCE)
-#    include <bldver.h>
-#  endif
-#  include <winable.h>
-#endif
-
-#include <oleacc.h>
-#if !defined(Q_CC_BOR) && !defined (Q_CC_GNU)
-#include <comdef.h>
-#endif
-
-#ifdef Q_OS_WINCE
-#include "qguifunctions_wince.h"
-#endif
-
-#include "qtwindows_additional.h"
-
-QT_BEGIN_NAMESPACE
-
-#ifndef QT_NO_DEBUG
-QT_BEGIN_INCLUDE_NAMESPACE
-# include <qdebug.h>
-QT_END_INCLUDE_NAMESPACE
-static inline bool debug_accessibility()
-{
-    static signed int debugging = -1;
-    if (debugging == -1)
-        debugging = qgetenv("QT_DEBUG_ACCESSIBILITY").toInt();
-    return !!debugging;
-}
-# define accessibleDebug !debug_accessibility() ? (void)0 : qDebug
-#else
-# define accessibleDebug()
-#endif
-
-//#define DEBUG_SHOW_ATCLIENT_COMMANDS
-#if defined(DEBUG_SHOW_ATCLIENT_COMMANDS)
-void accessibleDebugClientCalls_helper(const char* funcName, const QAccessibleInterface *iface)
-{
-    QString str;
-    QDebug dbg(&str);
-    dbg << iface << QLatin1String(funcName);
-    accessibleDebug("%s", qPrintable(str));
-}
-# define accessibleDebugClientCalls(iface) accessibleDebugClientCalls_helper(Q_FUNC_INFO, iface)
-#else
-# define accessibleDebugClientCalls(iface)
-#endif
-
-
-typedef QSharedPointer<QAccessibleInterface> QAIPointer;
-
-static bool compareAccessible(QAccessibleInterface *one, QAccessibleInterface *other)
-{
-    if (one == other) return true;
-    if (!one || !other) return false;
-
-    if (one->object() && other->object() && (one->object() == other->object()))
-        return true;
-    QAIPointer onePar(one->parent());
-    QAIPointer otherPar(other->parent());
-
-    if (compareAccessible(onePar.data(), otherPar.data()))
-        return onePar->indexOfChild(one) == otherPar->indexOfChild(other);
-    return false;
-}
-
-// This stuff is used for widgets/items with no window handle:
-typedef QMap<int, QPair<QObject*,int> > NotifyMap;
-Q_GLOBAL_STATIC(NotifyMap, qAccessibleRecentSentEvents)
-static int eventNum = 0;
-
-class QWindowsEnumerate : public IEnumVARIANT
-{
-public:
-    QWindowsEnumerate(const QVector<int> &a)
-        : ref(0), current(0),array(a)
-    {
-    }
-
-    virtual ~QWindowsEnumerate() {}
-
-    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *);
-    ULONG STDMETHODCALLTYPE AddRef();
-    ULONG STDMETHODCALLTYPE Release();
-
-    HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **ppEnum);
-    HRESULT STDMETHODCALLTYPE Next(unsigned long  celt, VARIANT FAR*  rgVar, unsigned long FAR*  pCeltFetched);
-    HRESULT STDMETHODCALLTYPE Reset();
-    HRESULT STDMETHODCALLTYPE Skip(unsigned long celt);
-
-private:
-    ULONG ref;
-    ULONG current;
-    QVector<int> array;
-};
-
-HRESULT STDMETHODCALLTYPE QWindowsEnumerate::QueryInterface(REFIID id, LPVOID *iface)
-{
-    *iface = 0;
-    if (id == IID_IUnknown)
-        *iface = (IUnknown*)this;
-    else if (id == IID_IEnumVARIANT)
-        *iface = (IEnumVARIANT*)this;
-
-    if (*iface) {
-        AddRef();
-        return S_OK;
-    }
-
-    return E_NOINTERFACE;
-}
-
-ULONG STDMETHODCALLTYPE QWindowsEnumerate::AddRef()
-{
-    return ++ref;
-}
-
-ULONG STDMETHODCALLTYPE QWindowsEnumerate::Release()
-{
-    if (!--ref) {
-        delete this;
-        return 0;
-    }
-    return ref;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsEnumerate::Clone(IEnumVARIANT **ppEnum)
-{
-    QWindowsEnumerate *penum = 0;
-    *ppEnum = 0;
-
-    penum = new QWindowsEnumerate(array);
-    if (!penum)
-        return E_OUTOFMEMORY;
-    penum->current = current;
-    penum->array = array;
-    penum->AddRef();
-    *ppEnum = penum;
-
-    return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsEnumerate::Next(unsigned long  celt, VARIANT FAR*  rgVar, unsigned long FAR*  pCeltFetched)
-{
-    if (pCeltFetched)
-        *pCeltFetched = 0;
-
-    ULONG l;
-    for (l = 0; l < celt; l++) {
-        VariantInit(&rgVar[l]);
-        if ((current+1) > (ULONG)array.size()) {
-            *pCeltFetched = l;
-            return S_FALSE;
-        }
-
-        rgVar[l].vt = VT_I4;
-        rgVar[l].lVal = array[(int)current];
-        ++current;
-    }
-    *pCeltFetched = l;
-    return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsEnumerate::Reset()
-{
-    current = 0;
-    return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsEnumerate::Skip(unsigned long celt)
-{
-    current += celt;
-    if (current > (ULONG)array.size()) {
-        current = array.size();
-        return S_FALSE;
-    }
-    return S_OK;
-}
-
-/*
-*/
-class QWindowsAccessible : public IAccessible, IOleWindow
-{
-public:
-    QWindowsAccessible(QAccessibleInterface *a)
-        : ref(0), accessible(a)
-    {
-    }
-
-    virtual ~QWindowsAccessible()
-    {
-        delete accessible;
-    }
-
-    /* IUnknown */
-    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *);
-    ULONG STDMETHODCALLTYPE AddRef();
-    ULONG STDMETHODCALLTYPE Release();
-
-    /* IDispatch */
-    HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int *);
-    HRESULT STDMETHODCALLTYPE GetTypeInfo(unsigned int, unsigned long, ITypeInfo **);
-    HRESULT STDMETHODCALLTYPE GetIDsOfNames(const _GUID &, wchar_t **, unsigned int, unsigned long, long *);
-    HRESULT STDMETHODCALLTYPE Invoke(long, const _GUID &, unsigned long, unsigned short, tagDISPPARAMS *, tagVARIANT *, tagEXCEPINFO *, unsigned int *);
-
-    /* IAccessible */
-    HRESULT STDMETHODCALLTYPE accHitTest(long xLeft, long yTop, VARIANT *pvarID);
-    HRESULT STDMETHODCALLTYPE accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varID);
-    HRESULT STDMETHODCALLTYPE accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEnd);
-    HRESULT STDMETHODCALLTYPE get_accChild(VARIANT varChildID, IDispatch** ppdispChild);
-    HRESULT STDMETHODCALLTYPE get_accChildCount(long* pcountChildren);
-    HRESULT STDMETHODCALLTYPE get_accParent(IDispatch** ppdispParent);
-
-    HRESULT STDMETHODCALLTYPE accDoDefaultAction(VARIANT varID);
-    HRESULT STDMETHODCALLTYPE get_accDefaultAction(VARIANT varID, BSTR* pszDefaultAction);
-    HRESULT STDMETHODCALLTYPE get_accDescription(VARIANT varID, BSTR* pszDescription);
-    HRESULT STDMETHODCALLTYPE get_accHelp(VARIANT varID, BSTR *pszHelp);
-    HRESULT STDMETHODCALLTYPE get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
-    HRESULT STDMETHODCALLTYPE get_accKeyboardShortcut(VARIANT varID, BSTR *pszKeyboardShortcut);
-    HRESULT STDMETHODCALLTYPE get_accName(VARIANT varID, BSTR* pszName);
-    HRESULT STDMETHODCALLTYPE put_accName(VARIANT varChild, BSTR szName);
-    HRESULT STDMETHODCALLTYPE get_accRole(VARIANT varID, VARIANT *pvarRole);
-    HRESULT STDMETHODCALLTYPE get_accState(VARIANT varID, VARIANT *pvarState);
-    HRESULT STDMETHODCALLTYPE get_accValue(VARIANT varID, BSTR* pszValue);
-    HRESULT STDMETHODCALLTYPE put_accValue(VARIANT varChild, BSTR szValue);
-
-    HRESULT STDMETHODCALLTYPE accSelect(long flagsSelect, VARIANT varID);
-    HRESULT STDMETHODCALLTYPE get_accFocus(VARIANT *pvarID);
-    HRESULT STDMETHODCALLTYPE get_accSelection(VARIANT *pvarChildren);
-
-    /* IOleWindow */
-    HRESULT STDMETHODCALLTYPE GetWindow(HWND *phwnd);
-    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);
-
-private:
-    ULONG ref;
-    QAccessibleInterface *accessible;
-
-    QAIPointer childPointer(VARIANT varID)
-    {
-        return QAIPointer(accessible->child(varID.lVal - 1));
-    }
-};
-
-static inline BSTR QStringToBSTR(const QString &str)
-{
-    BSTR bstrVal;
-
-    int wlen = str.length()+1;
-    bstrVal = SysAllocStringByteLen(0, wlen*2);
-    memcpy(bstrVal, str.unicode(), sizeof(QChar)*(wlen));
-    bstrVal[wlen] = 0;
-
-    return bstrVal;
-}
-
-/*
-*/
-
-/*
-  IUnknown
-*/
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::QueryInterface(REFIID id, LPVOID *iface)
-{
-    *iface = 0;
-    if (id == IID_IUnknown)
-        *iface = (IUnknown*)(IDispatch*)this;
-    else if (id == IID_IDispatch)
-        *iface = (IDispatch*)this;
-    else if (id == IID_IAccessible)
-        *iface = (IAccessible*)this;
-    else if (id == IID_IOleWindow)
-        *iface = (IOleWindow*)this;
-    else
-        return E_NOINTERFACE;
-
-    AddRef();
-    return S_OK;
-}
-
-ULONG STDMETHODCALLTYPE QWindowsAccessible::AddRef()
-{
-    return ++ref;
-}
-
-ULONG STDMETHODCALLTYPE QWindowsAccessible::Release()
-{
-    if (!--ref) {
-        delete this;
-        return 0;
-    }
-    return ref;
-}
-
-/*
-  IDispatch
-*/
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::GetTypeInfoCount(unsigned int * pctinfo)
-{
-    // We don't use a type library
-    *pctinfo = 0;
-    return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::GetTypeInfo(unsigned int, unsigned long, ITypeInfo **pptinfo)
-{
-    // We don't use a type library
-    *pptinfo = 0;
-    return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::GetIDsOfNames(const _GUID &, wchar_t **rgszNames, unsigned int, unsigned long, long *rgdispid)
-{
-#if !defined(Q_CC_BOR) && !defined(Q_CC_GNU)
-    // PROPERTIES:  Hierarchical
-    if (_bstr_t(rgszNames[0]) == _bstr_t(L"accParent"))
-        rgdispid[0] = DISPID_ACC_PARENT;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accChildCount"))
-        rgdispid[0] = DISPID_ACC_CHILDCOUNT;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accChild"))
-        rgdispid[0] = DISPID_ACC_CHILD;
-
-    // PROPERTIES:  Descriptional
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accName("))
-        rgdispid[0] = DISPID_ACC_NAME;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accValue"))
-        rgdispid[0] = DISPID_ACC_VALUE;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accDescription"))
-        rgdispid[0] = DISPID_ACC_DESCRIPTION;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accRole"))
-        rgdispid[0] = DISPID_ACC_ROLE;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accState"))
-        rgdispid[0] = DISPID_ACC_STATE;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accHelp"))
-        rgdispid[0] = DISPID_ACC_HELP;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accHelpTopic"))
-        rgdispid[0] = DISPID_ACC_HELPTOPIC;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accKeyboardShortcut"))
-        rgdispid[0] = DISPID_ACC_KEYBOARDSHORTCUT;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accFocus"))
-        rgdispid[0] = DISPID_ACC_FOCUS;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accSelection"))
-        rgdispid[0] = DISPID_ACC_SELECTION;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accDefaultAction"))
-        rgdispid[0] = DISPID_ACC_DEFAULTACTION;
-
-    // METHODS
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accSelect"))
-        rgdispid[0] = DISPID_ACC_SELECT;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accLocation"))
-        rgdispid[0] = DISPID_ACC_LOCATION;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accNavigate"))
-        rgdispid[0] = DISPID_ACC_NAVIGATE;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accHitTest"))
-        rgdispid[0] = DISPID_ACC_HITTEST;
-    else if (_bstr_t(rgszNames[0]) == _bstr_t(L"accDoDefaultAction"))
-        rgdispid[0] = DISPID_ACC_DODEFAULTACTION;
-    else
-        return DISP_E_UNKNOWNINTERFACE;
-
-    return S_OK;
-#else
-    Q_UNUSED(rgszNames);
-    Q_UNUSED(rgdispid);
-
-    return DISP_E_MEMBERNOTFOUND;
-#endif
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::Invoke(long dispIdMember, const _GUID &, unsigned long, unsigned short wFlags, tagDISPPARAMS *pDispParams, tagVARIANT *pVarResult, tagEXCEPINFO *, unsigned int *)
-{
-    HRESULT hr = DISP_E_MEMBERNOTFOUND;
-
-    switch (dispIdMember)
-    {
-        case DISPID_ACC_PARENT:
-            if (wFlags == DISPATCH_PROPERTYGET) {
-                if (!pVarResult)
-                    return E_INVALIDARG;
-                hr = get_accParent(&pVarResult->pdispVal);
-            } else {
-                hr = DISP_E_MEMBERNOTFOUND;
-            }
-            break;
-
-        case DISPID_ACC_CHILDCOUNT:
-            if (wFlags == DISPATCH_PROPERTYGET) {
-                if (!pVarResult)
-                    return E_INVALIDARG;
-                hr = get_accChildCount(&pVarResult->lVal);
-            } else {
-                hr = DISP_E_MEMBERNOTFOUND;
-            }
-            break;
-
-        case DISPID_ACC_CHILD:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accChild(pDispParams->rgvarg[0], &pVarResult->pdispVal);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_NAME:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accName(pDispParams->rgvarg[0], &pVarResult->bstrVal);
-            else if (wFlags == DISPATCH_PROPERTYPUT)
-                hr = put_accName(pDispParams->rgvarg[0], pVarResult->bstrVal);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_VALUE:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accValue(pDispParams->rgvarg[0], &pVarResult->bstrVal);
-            else if (wFlags == DISPATCH_PROPERTYPUT)
-                hr = put_accValue(pDispParams->rgvarg[0], pVarResult->bstrVal);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_DESCRIPTION:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accDescription(pDispParams->rgvarg[0], &pVarResult->bstrVal);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_ROLE:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accRole(pDispParams->rgvarg[0], pVarResult);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_STATE:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accState(pDispParams->rgvarg[0], pVarResult);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_HELP:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accHelp(pDispParams->rgvarg[0], &pVarResult->bstrVal);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_HELPTOPIC:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accHelpTopic(&pDispParams->rgvarg[2].bstrVal, pDispParams->rgvarg[1], &pDispParams->rgvarg[0].lVal);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_KEYBOARDSHORTCUT:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accKeyboardShortcut(pDispParams->rgvarg[0], &pVarResult->bstrVal);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_FOCUS:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accFocus(pVarResult);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_SELECTION:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accSelection(pVarResult);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_DEFAULTACTION:
-            if (wFlags == DISPATCH_PROPERTYGET)
-                hr = get_accDefaultAction(pDispParams->rgvarg[0], &pVarResult->bstrVal);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_SELECT:
-            if (wFlags == DISPATCH_METHOD)
-                hr = accSelect(pDispParams->rgvarg[1].lVal, pDispParams->rgvarg[0]);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_LOCATION:
-            if (wFlags == DISPATCH_METHOD)
-                hr = accLocation(&pDispParams->rgvarg[4].lVal, &pDispParams->rgvarg[3].lVal, &pDispParams->rgvarg[2].lVal, &pDispParams->rgvarg[1].lVal, pDispParams->rgvarg[0]);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_NAVIGATE:
-            if (wFlags == DISPATCH_METHOD)
-                hr = accNavigate(pDispParams->rgvarg[1].lVal, pDispParams->rgvarg[0], pVarResult);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_HITTEST:
-            if (wFlags == DISPATCH_METHOD)
-                hr = accHitTest(pDispParams->rgvarg[1].lVal, pDispParams->rgvarg[0].lVal, pVarResult);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        case DISPID_ACC_DODEFAULTACTION:
-            if (wFlags == DISPATCH_METHOD)
-                hr = accDoDefaultAction(pDispParams->rgvarg[0]);
-            else
-                hr = DISP_E_MEMBERNOTFOUND;
-            break;
-
-        default:
-            hr = DISP_E_MEMBERNOTFOUND;
-            break;
-    }
-
-    if (!SUCCEEDED(hr)) {
-        return hr;
-    }
-    return hr;
-}
-
-/*
-  IAccessible
-
-IAccessible::accHitTest documents the value returned in pvarID like this:
-
-| *Point location*                                       | *vt member* | *Value member*          |
-+========================================================+=============+=========================+
-| Outside of the object's boundaries, and either inside  | VT_EMPTY    | None.                   |
-| or outside of the object's bounding rectangle.         |             |                         |
-+--------------------------------------------------------+-------------+-------------------------+
-|  Within the object but not within a child element or a | VT_I4       | lVal is CHILDID_SELF    |
-|  child object.                                         |             |                         |
-+--------------------------------------------------------+-------------+-------------------------+
-| Within a child element.                                | VT_I4       | lVal contains           |
-|                                                        |             | the child ID.           |
-+--------------------------------------------------------+-------------+-------------------------+
-| Within a child object.                                 | VT_DISPATCH | pdispVal is set to the  |
-|                                                        |             | child object's IDispatch|
-|                                                        |             | interface pointer       |
-+--------------------------------------------------------+-------------+-------------------------+
-*/
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::accHitTest(long xLeft, long yTop, VARIANT *pvarID)
-{
-
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    QAccessibleInterface *child = accessible->childAt(xLeft, yTop);
-    if (child == 0) {
-        // no child found, return this item if it contains the coordinates
-        if (accessible->rect().contains(xLeft, yTop)) {
-            (*pvarID).vt = VT_I4;
-            (*pvarID).lVal = CHILDID_SELF;
-            return S_OK;
-        }
-    } else {
-        QWindowsAccessible* wacc = new QWindowsAccessible(child);
-        IDispatch *iface = 0;
-        wacc->QueryInterface(IID_IDispatch, (void**)&iface);
-        if (iface) {
-            (*pvarID).vt = VT_DISPATCH;
-            (*pvarID).pdispVal = iface;
-            return S_OK;
-        }
-    }
-
-    // Did not find anything
-    (*pvarID).vt = VT_EMPTY;
-    return S_FALSE;
-}
-
-/*
- It is recommended to read
-    "Implementing a Microsoft Active Accessibility (MSAA) Server.
-    Practical Tips for Developers and How Mozilla Does It"
-    (https://developer.mozilla.org/En/Accessibility/Implementing_an_MSAA_Server)
-
- to get an overview of what's important to implement and what parts of MSAA
- can be ignored. All stuff prefixed with "moz" are information from that page.
-*/
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varID)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    QRect rect;
-    if (varID.lVal) {
-        QAIPointer child = QAIPointer(accessible->child(varID.lVal - 1));
-        if (child->isValid())
-            rect = child->rect();
-    } else {
-        rect = accessible->rect();
-    }
-
-    *pxLeft = rect.x();
-    *pyTop = rect.y();
-    *pcxWidth = rect.width();
-    *pcyHeight = rect.height();
-
-    return S_OK;
-}
-
-// moz: [important, but no need to implement up/down/left/right]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEnd)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    QAccessibleInterface *acc = 0;
-    switch (navDir) {
-    case NAVDIR_FIRSTCHILD:
-        acc = accessible->child(0);
-        break;
-    case NAVDIR_LASTCHILD:
-        acc = accessible->child(accessible->childCount() - 1);
-        break;
-    case NAVDIR_NEXT:
-    case NAVDIR_PREVIOUS:
-        if (!varStart.lVal){
-            QAccessibleInterface *parent = accessible->parent();
-            if (parent) {
-                int index = parent->indexOfChild(accessible);
-                index += (navDir == NAVDIR_NEXT) ? 1 : -1;
-                if (index >= 0 && index < parent->childCount())
-                    acc = parent->child(index);
-                delete parent;
-            }
-        } else {
-            int index = varStart.lVal;
-            index += (navDir == NAVDIR_NEXT) ? 1 : -1;
-            if (index > 0 && index <= accessible->childCount())
-                acc = accessible->child(index - 1);
-        }
-        break;
-
-    // Geometrical
-    case NAVDIR_UP:
-    case NAVDIR_DOWN:
-    case NAVDIR_LEFT:
-    case NAVDIR_RIGHT:
-        if (QAccessibleInterface *pIface = accessible->parent()) {
-            const int indexOfOurself = pIface->indexOfChild(accessible);
-            QRect startg = accessible->rect();
-            QPoint startc = startg.center();
-            QAccessibleInterface *candidate = 0;
-            unsigned mindist = UINT_MAX;    // will work on screen sizes at least up to 46340x46340
-            const int sibCount = pIface->childCount();
-            for (int i = 0; i < sibCount; ++i) {
-                QAccessibleInterface *sibling = 0;
-                sibling = pIface->child(i);
-                Q_ASSERT(sibling);
-                if (i == indexOfOurself || sibling->state().invisible) {
-                    //ignore ourself and invisible siblings
-                    delete sibling;
-                    continue;
-                }
-
-                QRect sibg = sibling->rect();
-                QPoint sibc = sibg.center();
-                QPoint sibp;
-                QPoint startp;
-                QPoint distp;
-                switch (navDir) {
-                case NAVDIR_LEFT:
-                    startp = QPoint(startg.left(), startg.top() + startg.height() / 2);
-                    sibp = QPoint(sibg.right(), sibg.top() + sibg.height() / 2);
-                    if (QPoint(sibc - startc).x() >= 0) {
-                        delete sibling;
-                        continue;
-                    }
-                    distp = sibp - startp;
-                    break;
-                case NAVDIR_RIGHT:
-                    startp = QPoint(startg.right(), startg.top() + startg.height() / 2);
-                    sibp = QPoint(sibg.left(), sibg.top() + sibg.height() / 2);
-                    if (QPoint(sibc - startc).x() <= 0) {
-                        delete sibling;
-                        continue;
-                    }
-                    distp = sibp - startp;
-                    break;
-                case NAVDIR_UP:
-                    startp = QPoint(startg.left() + startg.width() / 2, startg.top());
-                    sibp = QPoint(sibg.left() + sibg.width() / 2, sibg.bottom());
-                    if (QPoint(sibc - startc).y() >= 0) {
-                        delete sibling;
-                        continue;
-                    }
-                    distp = sibp - startp;
-                    break;
-                case NAVDIR_DOWN:
-                    startp = QPoint(startg.left() + startg.width() / 2, startg.bottom());
-                    sibp = QPoint(sibg.left() + sibg.width() / 2, sibg.top());
-                    if (QPoint(sibc - startc).y() <= 0) {
-                        delete sibling;
-                        continue;
-                    }
-                    distp = sibp - startp;
-                    break;
-                default:
-                    break;
-                }
-
-                // Since we're *comparing* (and not measuring) distances, we can compare the
-                // squared distance, (thus, no need to take the sqrt()).
-                unsigned dist = distp.x() * distp.x() + distp.y() * distp.y();
-                if (dist < mindist) {
-                    delete candidate;
-                    candidate = sibling;
-                    mindist = dist;
-                } else {
-                    delete sibling;
-                }
-            }
-            delete pIface;
-            acc = candidate;
-        }
-        break;
-    default:
-        break;
-    }
-    if (!acc) {
-        (*pvarEnd).vt = VT_EMPTY;
-        return S_FALSE;
-    }
-    QWindowsAccessible* wacc = new QWindowsAccessible(acc);
-
-    IDispatch *iface = 0;
-    wacc->QueryInterface(IID_IDispatch, (void**)&iface);
-    if (iface) {
-        (*pvarEnd).vt = VT_DISPATCH;
-        (*pvarEnd).pdispVal = iface;
-        return S_OK;
-    } else {
-        delete wacc;
-    }
-
-    (*pvarEnd).vt = VT_EMPTY;
-    return S_FALSE;
-}
-
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accChild(VARIANT varChildID, IDispatch** ppdispChild)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    if (varChildID.vt == VT_EMPTY)
-        return E_INVALIDARG;
-
-
-    int childIndex = varChildID.lVal;
-    QAccessibleInterface *acc = 0;
-
-    if (childIndex < 0) {
-        const int entry = childIndex;
-        QPair<QObject*, int> ref = qAccessibleRecentSentEvents()->value(entry);
-        if (ref.first) {
-            acc = QAccessible::queryAccessibleInterface(ref.first);
-            if (acc && ref.second >= 0) {
-                QAccessibleInterface *res = acc->child(ref.second);
-                delete acc;
-                if (!res)
-                    return E_INVALIDARG;
-                acc = res;
-            }
-        }
-    } else {
-        if (childIndex) {
-            acc = accessible->child(childIndex - 1);
-        } else {
-            // Yes, some AT clients (Active Accessibility Object Inspector)
-            // actually ask for the same object. As a consequence, we need to clone ourselves:
-            if (QAccessibleInterface *par = accessible->parent()) {
-                const int indexOf = par->indexOfChild(accessible);
-                QAccessibleInterface *clone = par->child(indexOf);
-                delete par;
-                acc = clone;
-            }
-        }
-    }
-
-    if (acc) {
-        QWindowsAccessible* wacc = new QWindowsAccessible(acc);
-        wacc->QueryInterface(IID_IDispatch, (void**)ppdispChild);
-        return S_OK;
-    }
-
-    *ppdispChild = 0;
-    return S_FALSE;
-}
-
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accChildCount(long* pcountChildren)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    *pcountChildren = accessible->childCount();
-    return S_OK;
-}
-
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accParent(IDispatch** ppdispParent)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    QAccessibleInterface *acc = accessible->parent();
-    if (acc) {
-        QWindowsAccessible* wacc = new QWindowsAccessible(acc);
-        wacc->QueryInterface(IID_IDispatch, (void**)ppdispParent);
-
-        if (*ppdispParent)
-            return S_OK;
-    }
-
-    *ppdispParent = 0;
-    return S_FALSE;
-}
-
-/*
-  Properties and methods
-*/
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::accDoDefaultAction(VARIANT varID)
-{
-    Q_UNUSED(varID);
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    if (QAccessibleActionInterface *actionIface = accessible->actionInterface()) {
-        const QString def = actionIface->actionNames().value(0);
-        if (!def.isEmpty()) {
-            actionIface->doAction(def);
-            return S_OK;
-        }
-    }
-    return S_FALSE;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accDefaultAction(VARIANT varID, BSTR* pszDefaultAction)
-{
-    Q_UNUSED(varID);
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    *pszDefaultAction = 0;
-    if (QAccessibleActionInterface *actionIface = accessible->actionInterface()) {
-        const QString def = actionIface->actionNames().value(0);
-        if (!def.isEmpty())
-            *pszDefaultAction = QStringToBSTR(def);
-    }
-    return *pszDefaultAction ? S_OK : S_FALSE;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accDescription(VARIANT varID, BSTR* pszDescription)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-
-    QString descr;
-    if (varID.lVal) {
-        QAIPointer child = childPointer(varID);
-        if (!child)
-            return E_FAIL;
-        descr = child->text(QAccessible::Description);
-    } else {
-        descr = accessible->text(QAccessible::Description);
-    }
-    if (descr.size()) {
-        *pszDescription = QStringToBSTR(descr);
-        return S_OK;
-    }
-
-    *pszDescription = 0;
-    return S_FALSE;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accHelp(VARIANT varID, BSTR *pszHelp)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    QString help;
-    if (varID.lVal) {
-        QAIPointer child = childPointer(varID);
-        if (!child)
-            return E_FAIL;
-        help = child->text(QAccessible::Help);
-    } else {
-        help = accessible->text(QAccessible::Help);
-    }
-    if (help.size()) {
-        *pszHelp = QStringToBSTR(help);
-        return S_OK;
-    }
-
-    *pszHelp = 0;
-    return S_FALSE;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accHelpTopic(BSTR *, VARIANT, long *)
-{
-    return DISP_E_MEMBERNOTFOUND;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accKeyboardShortcut(VARIANT varID, BSTR *pszKeyboardShortcut)
-{
-    Q_UNUSED(varID);
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    *pszKeyboardShortcut = 0;
-    if (QAccessibleActionInterface *actionIface = accessible->actionInterface()) {
-        const QString def = actionIface->actionNames().value(0);
-        if (!def.isEmpty()) {
-            const QString keyBoardShortCut = actionIface->keyBindingsForAction(def).value(0);
-            if (!keyBoardShortCut.isEmpty())
-                *pszKeyboardShortcut = QStringToBSTR(keyBoardShortCut);
-        }
-    }
-    return *pszKeyboardShortcut ? S_OK : S_FALSE;
-}
-
-static QAccessibleInterface *relatedInterface(QAccessibleInterface *iface, QAccessible::RelationFlag flag)
-{
-    typedef QPair<QAccessibleInterface *, QAccessible::Relation> RelationPair;
-    QVector<RelationPair> rels = iface->relations(flag);
-
-    for (int i = 1; i < rels.count(); ++i)
-        delete rels.at(i).first;
-
-    return rels.value(0).first;
-}
-
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accName(VARIANT varID, BSTR* pszName)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    QString name;
-    if (varID.lVal) {
-        QAIPointer child = childPointer(varID);
-        if (!child)
-            return E_FAIL;
-        name = child->text(QAccessible::Name);
-        if (name.isEmpty()) {
-            if (QAccessibleInterface *labelInterface = relatedInterface(child.data(), QAccessible::Label)) {
-                name = labelInterface->text(QAccessible::Name);
-                delete labelInterface;
-            }
-        }
-    } else {
-        name = accessible->text(QAccessible::Name);
-        if (name.isEmpty()) {
-            if (QAccessibleInterface *labelInterface = relatedInterface(accessible, QAccessible::Label)) {
-                name = labelInterface->text(QAccessible::Name);
-                delete labelInterface;
-            }
-        }
-    }
-    if (name.size()) {
-        *pszName = QStringToBSTR(name);
-        return S_OK;
-    }
-
-    *pszName = 0;
-    return S_FALSE;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::put_accName(VARIANT, BSTR)
-{
-    accessibleDebugClientCalls(accessible);
-    return DISP_E_MEMBERNOTFOUND;
-}
-
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accRole(VARIANT varID, VARIANT *pvarRole)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    QAccessible::Role role;
-    if (varID.lVal) {
-        QAIPointer child = childPointer(varID);
-        if (!child)
-            return E_FAIL;
-        role = child->role();
-    } else {
-        role = accessible->role();
-    }
-
-    if (role != QAccessible::NoRole) {
-        if (role == QAccessible::LayeredPane)
-            role = QAccessible::Pane;
-        (*pvarRole).vt = VT_I4;
-        (*pvarRole).lVal = role;
-    } else {
-        (*pvarRole).vt = VT_EMPTY;
-    }
-    return S_OK;
-}
-
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accState(VARIANT varID, VARIANT *pvarState)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    QAccessible::State state;
-    if (varID.lVal) {
-        QAIPointer child = childPointer(varID);
-        if (!child.data())
-            return E_FAIL;
-        state = child->state();
-    } else {
-        state = accessible->state();
-    }
-
-    LONG st = 0;
-    if (state.animated)
-        st |= STATE_SYSTEM_ANIMATED;
-    if (state.busy)
-        st |= STATE_SYSTEM_BUSY;
-    if (state.checked)
-        st |= STATE_SYSTEM_CHECKED;
-    if (state.collapsed)
-        st |= STATE_SYSTEM_COLLAPSED;
-    if (state.defaultButton)
-        st |= STATE_SYSTEM_DEFAULT;
-    if (state.expanded)
-        st |= STATE_SYSTEM_EXPANDED;
-    if (state.extSelectable)
-        st |= STATE_SYSTEM_EXTSELECTABLE;
-    if (state.focusable)
-        st |= STATE_SYSTEM_FOCUSABLE;
-    if (state.focused)
-        st |= STATE_SYSTEM_FOCUSED;
-    if (state.hasPopup)
-        st |= STATE_SYSTEM_HASPOPUP;
-    if (state.hotTracked)
-        st |= STATE_SYSTEM_HOTTRACKED;
-    if (state.invisible)
-        st |= STATE_SYSTEM_INVISIBLE;
-    if (state.linked)
-        st |= STATE_SYSTEM_LINKED;
-    if (state.marqueed)
-        st |= STATE_SYSTEM_MARQUEED;
-    if (state.checkStateMixed)
-        st |= STATE_SYSTEM_MIXED;
-    if (state.movable)
-        st |= STATE_SYSTEM_MOVEABLE;
-    if (state.multiSelectable)
-        st |= STATE_SYSTEM_MULTISELECTABLE;
-    if (state.offscreen)
-        st |= STATE_SYSTEM_OFFSCREEN;
-    if (state.pressed)
-        st |= STATE_SYSTEM_PRESSED;
-    if (state.passwordEdit)
-        st |= STATE_SYSTEM_PROTECTED;
-    if (state.readOnly)
-        st |= STATE_SYSTEM_READONLY;
-    if (state.selectable)
-        st |= STATE_SYSTEM_SELECTABLE;
-    if (state.selected)
-        st |= STATE_SYSTEM_SELECTED;
-    if (state.selfVoicing)
-        st |= STATE_SYSTEM_SELFVOICING;
-    if (state.sizeable)
-        st |= STATE_SYSTEM_SIZEABLE;
-    if (state.traversed)
-        st |= STATE_SYSTEM_TRAVERSED;
-
-    (*pvarState).vt = VT_I4;
-    (*pvarState).lVal = st;
-    return S_OK;
-}
-
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accValue(VARIANT varID, BSTR* pszValue)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid() || varID.lVal)
-        return E_FAIL;
-
-    QString value;
-    if (accessible->valueInterface()) {
-        value = QString::number(accessible->valueInterface()->currentValue().toDouble());
-    } else {
-        value = accessible->text(QAccessible::Value);
-    }
-    if (!value.isNull()) {
-        *pszValue = QStringToBSTR(value);
-        return S_OK;
-    }
-
-    *pszValue = 0;
-    return S_FALSE;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::put_accValue(VARIANT, BSTR)
-{
-    accessibleDebugClientCalls(accessible);
-    return DISP_E_MEMBERNOTFOUND;
-}
-
-// moz: [important]
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::accSelect(long flagsSelect, VARIANT varID)
-{
-    Q_UNUSED(flagsSelect);
-    Q_UNUSED(varID);
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    bool res = false;
-
-/*
-  ### Check for accessibleTableInterface() or accessibleTextInterface()
-
-  ### and if there are no ia2 interfaces we should do nothing??
-    if (flagsSelect & SELFLAG_TAKEFOCUS)
-        res = accessible->doAction(SetFocus, varID.lVal, QVariantList());
-    if (flagsSelect & SELFLAG_TAKESELECTION) {
-        accessible->doAction(ClearSelection, 0, QVariantList());
-        res = accessible->doAction(AddToSelection, varID.lVal, QVariantList());
-    }
-    if (flagsSelect & SELFLAG_EXTENDSELECTION)
-        res = accessible->doAction(ExtendSelection, varID.lVal, QVariantList());
-    if (flagsSelect & SELFLAG_ADDSELECTION)
-        res = accessible->doAction(AddToSelection, varID.lVal, QVariantList());
-    if (flagsSelect & SELFLAG_REMOVESELECTION)
-        res = accessible->doAction(RemoveSelection, varID.lVal, QVariantList());
-*/
-    return res ? S_OK : S_FALSE;
-}
-
-/*!
-    \internal
-    Can return:
-
-  +-------------+------------------------------------------------------------------------------+
-  | VT_EMPTY    | None. Neither this object nor any of its children has the keyboard focus.    |
-  +-------------+------------------------------------------------------------------------------+
-  | VT_I4       | lVal is CHILDID_SELF. The object itself has the keyboard focus.              |
-  +-------------+------------------------------------------------------------------------------+
-  | VT_I4       | lVal contains the child ID of the child element that has the keyboard focus. |
-  +-------------+------------------------------------------------------------------------------+
-  | VT_DISPATCH | pdispVal member is the address of the IDispatch interface for the child      |
-  |             | object that has the keyboard focus.                                          |
-  +-------------+------------------------------------------------------------------------------+
-    moz: [important]
-*/
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accFocus(VARIANT *pvarID)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    if (QAccessibleInterface *acc = accessible->focusChild()) {
-        if (compareAccessible(acc, accessible)) {
-            (*pvarID).vt = VT_I4;
-            (*pvarID).lVal = CHILDID_SELF;
-            delete acc;
-            return S_OK;
-        } else {
-            QWindowsAccessible* wacc = new QWindowsAccessible(acc);
-            IDispatch *iface = 0;
-            wacc->QueryInterface(IID_IDispatch, (void**)&iface);
-            (*pvarID).vt = VT_DISPATCH;
-            (*pvarID).pdispVal = iface;
-            return S_OK;
-        }
-        delete acc;
-    }
-    (*pvarID).vt = VT_EMPTY;
-    return S_FALSE;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accSelection(VARIANT *pvarChildren)
-{
-    accessibleDebugClientCalls(accessible);
-    if (!accessible->isValid())
-        return E_FAIL;
-
-    int cc = accessible->childCount();
-    QVector<int> sel(cc);
-    int selIndex = 0;
-    for (int i = 0; i < cc; ++i) {
-        bool isSelected = false;
-        QAccessibleInterface *child = accessible->child(i);
-        if (child) {
-            isSelected = child->state().selected;
-            delete child;
-        }
-        if (isSelected)
-            sel[selIndex++] = i+1;
-    }
-    sel.resize(selIndex);
-    if (sel.isEmpty()) {
-        (*pvarChildren).vt = VT_EMPTY;
-        return S_FALSE;
-    }
-    if (sel.size() == 1) {
-        (*pvarChildren).vt = VT_I4;
-        (*pvarChildren).lVal = sel[0];
-        return S_OK;
-    }
-    IEnumVARIANT *iface = new QWindowsEnumerate(sel);
-    IUnknown *uiface;
-    iface->QueryInterface(IID_IUnknown, (void**)&uiface);
-    (*pvarChildren).vt = VT_UNKNOWN;
-    (*pvarChildren).punkVal = uiface;
-
-    return S_OK;
-}
-
-static QWindow *window_helper(const QAccessibleInterface *iface)
-{
-    QWindow *window = iface->window();
-    if (!window) {
-        QAccessibleInterface *acc = iface->parent();
-        while (acc && !window) {
-            window = acc->window();
-            QAccessibleInterface *par = acc->parent();
-            delete acc;
-            acc = par;
-        }
-    }
-    return window;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::GetWindow(HWND *phwnd)
-{
-    *phwnd = 0;
-    if (!accessible->isValid())
-        return E_UNEXPECTED;
-
-    QWindow *window = window_helper(accessible);
-    if (!window)
-        return E_FAIL;
-
-    QPlatformNativeInterface *platform = QGuiApplication::platformNativeInterface();
-    Q_ASSERT(platform);
-    *phwnd = (HWND)platform->nativeResourceForWindow("handle", window);
-    return S_OK;
-}
-
-HRESULT STDMETHODCALLTYPE QWindowsAccessible::ContextSensitiveHelp(BOOL)
-{
-    return S_OK;
-}
-
-
-QWindowsAccessibility::QWindowsAccessibility()
-{
-}
-
-
-void QWindowsAccessibility::notifyAccessibilityUpdate(const QAccessibleEvent &event)
-{
-    QString soundName;
-    switch (event.type()) {
-    case QAccessible::PopupMenuStart:
-        soundName = QLatin1String("MenuPopup");
-        break;
-
-    case QAccessible::MenuCommand:
-        soundName = QLatin1String("MenuCommand");
-        break;
-
-    case QAccessible::Alert:
-        {
-        /*      ### FIXME
-#ifndef QT_NO_MESSAGEBOX
-            QMessageBox *mb = qobject_cast<QMessageBox*>(o);
-            if (mb) {
-                switch (mb->icon()) {
-                case QMessageBox::Warning:
-                    soundName = QLatin1String("SystemExclamation");
-                    break;
-                case QMessageBox::Critical:
-                    soundName = QLatin1String("SystemHand");
-                    break;
-                case QMessageBox::Information:
-                    soundName = QLatin1String("SystemAsterisk");
-                    break;
-                default:
-                    break;
-                }
-            } else
-#endif // QT_NO_MESSAGEBOX
-*/
-            {
-                soundName = QLatin1String("SystemAsterisk");
-            }
-
-        }
-        break;
-    default:
-        break;
-    }
-
-    if (!soundName.isEmpty()) {
-#ifndef QT_NO_SETTINGS
-        QSettings settings(QLatin1String("HKEY_CURRENT_USER\\AppEvents\\Schemes\\Apps\\.Default\\") + soundName,
-                           QSettings::NativeFormat);
-        QString file = settings.value(QLatin1String(".Current/.")).toString();
-#else
-        QString file;
-#endif
-        if (!file.isEmpty()) {
-            PlaySound(reinterpret_cast<const wchar_t *>(soundName.utf16()), 0, SND_ALIAS | SND_ASYNC | SND_NODEFAULT | SND_NOWAIT);
-        }
-    }
-
-    typedef void (WINAPI *PtrNotifyWinEvent)(DWORD, HWND, LONG, LONG);
-
-#if defined(Q_OS_WINCE) // ### TODO: check for NotifyWinEvent in CE 6.0
-    // There is no user32.lib nor NotifyWinEvent for CE
-    return;
-#else
-    static PtrNotifyWinEvent ptrNotifyWinEvent = 0;
-    static bool resolvedNWE = false;
-    if (!resolvedNWE) {
-        resolvedNWE = true;
-        ptrNotifyWinEvent = (PtrNotifyWinEvent)QSystemLibrary::resolve(QLatin1String("user32"), "NotifyWinEvent");
-    }
-    if (!ptrNotifyWinEvent)
-        return;
-
-    // An event has to be associated with a window,
-    // so find the first parent that is a widget and that has a WId
-    QAccessibleInterface *iface = event.accessibleInterface();
-    QWindow *window = iface ? window_helper(iface) : 0;
-    delete iface;
-
-    if (!window) {
-        window = QGuiApplication::activeWindow();
-        if (!window)
-            return;
-    }
-
-    QPlatformNativeInterface *platform = QGuiApplication::platformNativeInterface();
-    HWND hWnd = (HWND)platform->nativeResourceForWindow("handle", window);
-
-    if (event.type() != QAccessible::MenuCommand) { // MenuCommand is faked
-        // See comment "SENDING EVENTS TO OBJECTS WITH NO WINDOW HANDLE"
-        eventNum %= 50;              //[0..49]
-        int eventId = - eventNum - 1;
-
-        qAccessibleRecentSentEvents()->insert(eventId, qMakePair(event.object(), event.child()));
-        ptrNotifyWinEvent(event.type(), hWnd, OBJID_CLIENT, eventId );
-
-        ++eventNum;
-    }
-#endif // Q_OS_WINCE
-}
-
-/*
-void QWindowsAccessibility::setRootObject(QObject *o)
-{
-
-}
-
-void QWindowsAccessibility::initialize()
-{
-
-}
-
-void QWindowsAccessibility::cleanup()
-{
-
-}
-
-*/
-
-bool QWindowsAccessibility::handleAccessibleObjectFromWindowRequest(HWND hwnd, WPARAM wParam, LPARAM lParam, LRESULT *lResult)
-{
-    if (static_cast<long>(lParam) == static_cast<long>(UiaRootObjectId)) {
-        /* For UI Automation
-      */
-    } else if ((DWORD)lParam == OBJID_CLIENT) {
-#if 1
-        // Ignoring all requests while starting up
-        // ### Maybe QPA takes care of this???
-        if (QApplication::startingUp() || QApplication::closingDown())
-            return false;
-#endif
-
-        typedef LRESULT (WINAPI *PtrLresultFromObject)(REFIID, WPARAM, LPUNKNOWN);
-        static PtrLresultFromObject ptrLresultFromObject = 0;
-        static bool oleaccChecked = false;
-
-        if (!oleaccChecked) {
-            oleaccChecked = true;
-#if !defined(Q_OS_WINCE)
-            ptrLresultFromObject = (PtrLresultFromObject)QSystemLibrary::resolve(QLatin1String("oleacc"), "LresultFromObject");
-#endif
-        }
-
-        if (ptrLresultFromObject) {
-            QWindow *window = QWindowsContext::instance()->findWindow(hwnd);
-            if (window) {
-                QAccessibleInterface *acc = window->accessibleRoot();
-                if (acc) {
-                    QWindowsAccessible *winacc = new QWindowsAccessible(acc);
-                    IAccessible *iface;
-                    HRESULT hr = winacc->QueryInterface(IID_IAccessible, (void**)&iface);
-                    if (SUCCEEDED(hr)) {
-                        *lResult = ptrLresultFromObject(IID_IAccessible, wParam, iface);  // ref == 2
-                        if (*lResult) {
-                            iface->Release(); // the client will release the object again, and then it will destroy itself
-                        }
-                        return true;
-                    }
-                }
-            }
-        }
-    }
-    return false;
-}
-
-QT_END_NAMESPACE
-
-#endif //QT_NO_ACCESSIBILITY
diff --git a/src/plugins/platforms/windows/qwindowsaccessibility.h b/src/plugins/platforms/windows/qwindowsaccessibility.h
deleted file mode 100644
index 9294f23..0000000
--- a/src/plugins/platforms/windows/qwindowsaccessibility.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QWINDOWSACCESSIBILITY_H
-#define QWINDOWSACCESSIBILITY_H
-
-#include "qtwindowsglobal.h"
-#include <QtGui/QPlatformAccessibility>
-
-QT_BEGIN_HEADER
-QT_BEGIN_NAMESPACE
-
-class QWindowsAccessibility : public QPlatformAccessibility
-{
-public:
-    QWindowsAccessibility();
-    static bool handleAccessibleObjectFromWindowRequest(HWND hwnd, WPARAM wParam, LPARAM lParam, LRESULT *lResult);
-    virtual void notifyAccessibilityUpdate(const QAccessibleEvent &event);
-    /*
-    virtual void setRootObject(QObject *o);
-    virtual void initialize();
-    virtual void cleanup();
-    */
-};
-
-QT_END_NAMESPACE
-QT_END_HEADER
-
-#endif // QWINDOWSACCESSIBILITY_H
diff --git a/src/plugins/platforms/windows/qwindowscontext.cpp b/src/plugins/platforms/windows/qwindowscontext.cpp
index 2706e02..e8050d5 100644
--- a/src/plugins/platforms/windows/qwindowscontext.cpp
+++ b/src/plugins/platforms/windows/qwindowscontext.cpp
@@ -47,7 +47,7 @@
 #include "qtwindowsglobal.h"
 #include "qwindowsmime.h"
 #include "qwindowsinputcontext.h"
-#include "qwindowsaccessibility.h"
+#include "accessible/qwindowsaccessibility.h"
 #include "qwindowsscreen.h"
 #include "qwindowstheme.h"
 
diff --git a/src/plugins/platforms/windows/qwindowsintegration.cpp b/src/plugins/platforms/windows/qwindowsintegration.cpp
index 3c2ece5..7510cde 100644
--- a/src/plugins/platforms/windows/qwindowsintegration.cpp
+++ b/src/plugins/platforms/windows/qwindowsintegration.cpp
@@ -55,8 +55,8 @@
 #include "qwindowsclipboard.h"
 #include "qwindowsdrag.h"
 #include "qwindowsinputcontext.h"
-#include "qwindowsaccessibility.h"
 #include "qwindowskeymapper.h"
+#include "accessible/qwindowsaccessibility.h"
 
 #include <QtGui/QPlatformNativeInterface>
 #include <QtGui/QWindowSystemInterface>
diff --git a/src/plugins/platforms/windows/windows.pro b/src/plugins/platforms/windows/windows.pro
index bb41fe8..87bc724 100644
--- a/src/plugins/platforms/windows/windows.pro
+++ b/src/plugins/platforms/windows/windows.pro
@@ -45,7 +45,6 @@ SOURCES += \
     qwindowsdrag.cpp \
     qwindowscursor.cpp \
     qwindowsinputcontext.cpp \
-    qwindowsaccessibility.cpp \
     qwindowstheme.cpp \
     qwindowsdialoghelpers.cpp \
     qwindowsservices.cpp
@@ -73,7 +72,6 @@ HEADERS += \
     qwindowscursor.h \
     array.h \
     qwindowsinputcontext.h \
-    qwindowsaccessibility.h \
     qwindowstheme.h \
     qwindowsdialoghelpers.h \
     qwindowsservices.h
@@ -151,5 +149,6 @@ contains(QT_CONFIG, freetype) {
 
 OTHER_FILES += windows.json
 
+include(accessible/accessible.pri)
 target.path += $$[QT_INSTALL_PLUGINS]/platforms
 INSTALLS += target