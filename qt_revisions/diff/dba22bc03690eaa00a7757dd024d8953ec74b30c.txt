diff --git a/src/gui/gui.pro b/src/gui/gui.pro
index ab4e555..277000a 100644
--- a/src/gui/gui.pro
+++ b/src/gui/gui.pro
@@ -28,6 +28,7 @@ include(util/util.pri)
 include(math3d/math3d.pri)
 include(opengl/opengl.pri)
 include(animation/animation.pri)
+include(itemmodels/itemmodels.pri)
 
 QMAKE_LIBS += $$QMAKE_LIBS_GUI
 
diff --git a/src/gui/itemmodels/itemmodels.pri b/src/gui/itemmodels/itemmodels.pri
new file mode 100644
index 0000000..65bcd7c
--- /dev/null
+++ b/src/gui/itemmodels/itemmodels.pri
@@ -0,0 +1,6 @@
+HEADERS += \
+    itemmodels/qstandarditemmodel.h \
+    itemmodels/qstandarditemmodel_p.h \
+
+SOURCES += \
+    itemmodels/qstandarditemmodel.cpp \
diff --git a/src/gui/itemmodels/qstandarditemmodel.cpp b/src/gui/itemmodels/qstandarditemmodel.cpp
new file mode 100644
index 0000000..2d296a0
--- /dev/null
+++ b/src/gui/itemmodels/qstandarditemmodel.cpp
@@ -0,0 +1,3129 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qstandarditemmodel.h"
+
+#ifndef QT_NO_STANDARDITEMMODEL
+
+#include <QtCore/qdatetime.h>
+#include <QtCore/qlist.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qpair.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qvector.h>
+#include <QtCore/qstringlist.h>
+#include <QtCore/qbitarray.h>
+#include <QtCore/qmimedata.h>
+
+#include <private/qstandarditemmodel_p.h>
+#include <qdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+class QStandardItemModelLessThan
+{
+public:
+    inline QStandardItemModelLessThan()
+        { }
+
+    inline bool operator()(const QPair<QStandardItem*, int> &l,
+                           const QPair<QStandardItem*, int> &r) const
+    {
+        return *(l.first) < *(r.first);
+    }
+};
+
+class QStandardItemModelGreaterThan
+{
+public:
+    inline QStandardItemModelGreaterThan()
+        { }
+
+    inline bool operator()(const QPair<QStandardItem*, int> &l,
+                           const QPair<QStandardItem*, int> &r) const
+    {
+        return *(r.first) < *(l.first);
+    }
+};
+
+/*!
+  \internal
+*/
+QStandardItemPrivate::~QStandardItemPrivate()
+{
+    QVector<QStandardItem*>::const_iterator it;
+    for (it = children.constBegin(); it != children.constEnd(); ++it) {
+        QStandardItem *child = *it;
+        if (child)
+            child->d_func()->setModel(0);
+        delete child;
+    }
+    children.clear();
+    if (parent && model)
+        parent->d_func()->childDeleted(q_func());
+}
+
+/*!
+  \internal
+*/
+QPair<int, int> QStandardItemPrivate::position() const
+{
+    if (QStandardItem *par = parent) {
+        int idx = par->d_func()->childIndex(q_func());
+        if (idx == -1)
+            return QPair<int, int>(-1, -1);
+        return QPair<int, int>(idx / par->columnCount(), idx % par->columnCount());
+    }
+    // ### support header items?
+    return QPair<int, int>(-1, -1);
+}
+
+/*!
+  \internal
+*/
+void QStandardItemPrivate::setChild(int row, int column, QStandardItem *item,
+                                    bool emitChanged)
+{
+    Q_Q(QStandardItem);
+    if (item == q) {
+        qWarning("QStandardItem::setChild: Can't make an item a child of itself %p",
+                 item);
+        return;
+    }
+    if ((row < 0) || (column < 0))
+        return;
+    if (rows <= row)
+        q->setRowCount(row + 1);
+    if (columns <= column)
+        q->setColumnCount(column + 1);
+    int index = childIndex(row, column);
+    Q_ASSERT(index != -1);
+    QStandardItem *oldItem = children.at(index);
+    if (item == oldItem)
+        return;
+    if (item) {
+        if (item->d_func()->parent == 0) {
+            item->d_func()->setParentAndModel(q, model);
+        } else {
+            qWarning("QStandardItem::setChild: Ignoring duplicate insertion of item %p",
+                     item);
+            return;
+        }
+    }
+    if (oldItem)
+        oldItem->d_func()->setModel(0);
+    delete oldItem;
+    children.replace(index, item);
+    if (emitChanged && model)
+        model->d_func()->itemChanged(item);
+}
+
+
+/*!
+  \internal
+*/
+void QStandardItemPrivate::changeFlags(bool enable, Qt::ItemFlags f)
+{
+    Q_Q(QStandardItem);
+    Qt::ItemFlags flags = q->flags();
+    if (enable)
+        flags |= f;
+    else
+        flags &= ~f;
+    q->setFlags(flags);
+}
+
+/*!
+  \internal
+*/
+void QStandardItemPrivate::childDeleted(QStandardItem *child)
+{
+    int index = childIndex(child);
+    Q_ASSERT(index != -1);
+    children.replace(index, 0);
+}
+
+/*!
+  \internal
+*/
+void QStandardItemPrivate::setItemData(const QMap<int, QVariant> &roles)
+{
+    Q_Q(QStandardItem);
+
+    //let's build the vector of new values
+    QVector<QStandardItemData> newValues;
+    QMap<int, QVariant>::const_iterator it;
+    for (it = roles.begin(); it != roles.end(); ++it) {
+        QVariant value = it.value();
+        if (value.isValid()) {
+            int role = it.key();
+            role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
+            QStandardItemData wid(role,it.value());
+            newValues.append(wid);
+        }
+    }
+
+    if (values!=newValues) {
+        values=newValues;
+        if (model)
+            model->d_func()->itemChanged(q);
+    }
+}
+
+/*!
+  \internal
+*/
+const QMap<int, QVariant> QStandardItemPrivate::itemData() const
+{
+    QMap<int, QVariant> result;
+    QVector<QStandardItemData>::const_iterator it;
+    for (it = values.begin(); it != values.end(); ++it)
+        result.insert((*it).role, (*it).value);
+    return result;
+}
+
+/*!
+  \internal
+*/
+void QStandardItemPrivate::sortChildren(int column, Qt::SortOrder order)
+{
+    Q_Q(QStandardItem);
+    if (column >= columnCount())
+        return;
+
+    QVector<QPair<QStandardItem*, int> > sortable;
+    QVector<int> unsortable;
+
+    sortable.reserve(rowCount());
+    unsortable.reserve(rowCount());
+
+    for (int row = 0; row < rowCount(); ++row) {
+        QStandardItem *itm = q->child(row, column);
+        if (itm)
+            sortable.append(QPair<QStandardItem*,int>(itm, row));
+        else
+            unsortable.append(row);
+    }
+
+    if (order == Qt::AscendingOrder) {
+        QStandardItemModelLessThan lt;
+        qStableSort(sortable.begin(), sortable.end(), lt);
+    } else {
+        QStandardItemModelGreaterThan gt;
+        qStableSort(sortable.begin(), sortable.end(), gt);
+    }
+
+    QModelIndexList changedPersistentIndexesFrom, changedPersistentIndexesTo;
+    QVector<QStandardItem*> sorted_children(children.count());
+    for (int i = 0; i < rowCount(); ++i) {
+        int r = (i < sortable.count()
+                 ? sortable.at(i).second
+                 : unsortable.at(i - sortable.count()));
+        for (int c = 0; c < columnCount(); ++c) {
+            QStandardItem *itm = q->child(r, c);
+            sorted_children[childIndex(i, c)] = itm;
+            if (model) {
+                QModelIndex from = model->createIndex(r, c, q);
+                if (model->d_func()->persistent.indexes.contains(from)) {
+                    QModelIndex to = model->createIndex(i, c, q);
+                    changedPersistentIndexesFrom.append(from);
+                    changedPersistentIndexesTo.append(to);
+                }
+            }
+        }
+    }
+
+    children = sorted_children;
+
+    if (model) {
+        model->changePersistentIndexList(changedPersistentIndexesFrom, changedPersistentIndexesTo);
+    }
+
+    QVector<QStandardItem*>::iterator it;
+    for (it = children.begin(); it != children.end(); ++it) {
+        if (*it)
+            (*it)->d_func()->sortChildren(column, order);
+    }
+}
+
+/*!
+  \internal
+  set the model of this item and all its children
+  */
+void QStandardItemPrivate::setModel(QStandardItemModel *mod)
+{
+    if (children.isEmpty()) {
+        if (model)
+            model->d_func()->invalidatePersistentIndex(model->indexFromItem(q_ptr));
+        model = mod;
+    } else {
+        QStack<QStandardItem*> stack;
+        stack.push(q_ptr);
+        while (!stack.isEmpty()) {
+            QStandardItem *itm = stack.pop();
+            if (itm->d_func()->model) {
+                itm->d_func()->model->d_func()->invalidatePersistentIndex(itm->d_func()->model->indexFromItem(itm));
+            }
+            itm->d_func()->model = mod;
+            const QVector<QStandardItem*> &childList = itm->d_func()->children;
+            for (int i = 0; i < childList.count(); ++i) {
+                QStandardItem *chi = childList.at(i);
+                if (chi)
+                    stack.push(chi);
+            }
+        }
+    }
+}
+
+/*!
+  \internal
+*/
+QStandardItemModelPrivate::QStandardItemModelPrivate()
+    : root(new QStandardItem),
+      itemPrototype(0),
+      sortRole(Qt::DisplayRole)
+{
+    root->setFlags(Qt::ItemIsDropEnabled);
+}
+
+/*!
+  \internal
+*/
+QStandardItemModelPrivate::~QStandardItemModelPrivate()
+{
+    delete itemPrototype;
+    qDeleteAll(columnHeaderItems);
+    qDeleteAll(rowHeaderItems);
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::init()
+{
+    Q_Q(QStandardItemModel);
+    QObject::connect(q, SIGNAL(dataChanged(QModelIndex,QModelIndex)),
+                     q, SLOT(_q_emitItemChanged(QModelIndex,QModelIndex)));
+}
+
+/*!
+    \internal
+*/
+void QStandardItemModelPrivate::_q_emitItemChanged(const QModelIndex &topLeft,
+                                                   const QModelIndex &bottomRight)
+{
+    Q_Q(QStandardItemModel);
+    QModelIndex parent = topLeft.parent();
+    for (int row = topLeft.row(); row <= bottomRight.row(); ++row) {
+        for (int column = topLeft.column(); column <= bottomRight.column(); ++column) {
+            QModelIndex index = q->index(row, column, parent);
+            if (QStandardItem *item = itemFromIndex(index))
+                emit q->itemChanged(item);
+        }
+    }
+}
+
+/*!
+    \internal
+*/
+bool QStandardItemPrivate::insertRows(int row, const QList<QStandardItem*> &items)
+{
+    Q_Q(QStandardItem);
+    if ((row < 0) || (row > rowCount()))
+        return false;
+    int count = items.count();
+    if (model)
+        model->d_func()->rowsAboutToBeInserted(q, row, row + count - 1);
+    if (rowCount() == 0) {
+        if (columnCount() == 0)
+            q->setColumnCount(1);
+        children.resize(columnCount() * count);
+        rows = count;
+    } else {
+        rows += count;
+        int index = childIndex(row, 0);
+        if (index != -1)
+            children.insert(index, columnCount() * count, 0);
+    }
+    for (int i = 0; i < items.count(); ++i) {
+        QStandardItem *item = items.at(i);
+        item->d_func()->model = model;
+        item->d_func()->parent = q;
+        int index = childIndex(i + row, 0);
+        children.replace(index, item);
+    }
+    if (model)
+        model->d_func()->rowsInserted(q, row, count);
+    return true;
+}
+
+bool QStandardItemPrivate::insertRows(int row, int count, const QList<QStandardItem*> &items)
+{
+    Q_Q(QStandardItem);
+    if ((count < 1) || (row < 0) || (row > rowCount()))
+        return false;
+    if (model)
+        model->d_func()->rowsAboutToBeInserted(q, row, row + count - 1);
+    if (rowCount() == 0) {
+        children.resize(columnCount() * count);
+        rows = count;
+    } else {
+        rows += count;
+        int index = childIndex(row, 0);
+        if (index != -1)
+            children.insert(index, columnCount() * count, 0);
+    }
+    if (!items.isEmpty()) {
+        int index = childIndex(row, 0);
+        int limit = qMin(items.count(), columnCount() * count);
+        for (int i = 0; i < limit; ++i) {
+            QStandardItem *item = items.at(i);
+            if (item) {
+                if (item->d_func()->parent == 0) {
+                    item->d_func()->setParentAndModel(q, model);
+                } else {
+                    qWarning("QStandardItem::insertRows: Ignoring duplicate insertion of item %p",
+                             item);
+                    item = 0;
+                }
+            }
+            children.replace(index, item);
+            ++index;
+        }
+    }
+    if (model)
+        model->d_func()->rowsInserted(q, row, count);
+    return true;
+}
+
+/*!
+    \internal
+*/
+bool QStandardItemPrivate::insertColumns(int column, int count, const QList<QStandardItem*> &items)
+{
+    Q_Q(QStandardItem);
+    if ((count < 1) || (column < 0) || (column > columnCount()))
+        return false;
+    if (model)
+        model->d_func()->columnsAboutToBeInserted(q, column, column + count - 1);
+    if (columnCount() == 0) {
+        children.resize(rowCount() * count);
+        columns = count;
+    } else {
+        columns += count;
+        int index = childIndex(0, column);
+        for (int row = 0; row < rowCount(); ++row) {
+            children.insert(index, count, 0);
+            index += columnCount();
+        }
+    }
+    if (!items.isEmpty()) {
+        int limit = qMin(items.count(), rowCount() * count);
+        for (int i = 0; i < limit; ++i) {
+            QStandardItem *item = items.at(i);
+            if (item) {
+                if (item->d_func()->parent == 0) {
+                    item->d_func()->setParentAndModel(q, model);
+                } else {
+                    qWarning("QStandardItem::insertColumns: Ignoring duplicate insertion of item %p",
+                             item);
+                    item = 0;
+                }
+            }
+            int r = i / count;
+            int c = column + (i % count);
+            int index = childIndex(r, c);
+            children.replace(index, item);
+        }
+    }
+    if (model)
+        model->d_func()->columnsInserted(q, column, count);
+    return true;
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::itemChanged(QStandardItem *item)
+{
+    Q_Q(QStandardItemModel);
+    if (item->d_func()->parent == 0) {
+        // Header item
+        int idx = columnHeaderItems.indexOf(item);
+        if (idx != -1) {
+            emit q->headerDataChanged(Qt::Horizontal, idx, idx);
+        } else {
+            idx = rowHeaderItems.indexOf(item);
+            if (idx != -1)
+                emit q->headerDataChanged(Qt::Vertical, idx, idx);
+        }
+    } else {
+        // Normal item
+        QModelIndex index = q->indexFromItem(item);
+        emit q->dataChanged(index, index);
+    }
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::rowsAboutToBeInserted(QStandardItem *parent,
+                                                      int start, int end)
+{
+    Q_Q(QStandardItemModel);
+    QModelIndex index = q->indexFromItem(parent);
+    q->beginInsertRows(index, start, end);
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::columnsAboutToBeInserted(QStandardItem *parent,
+                                                         int start, int end)
+{
+    Q_Q(QStandardItemModel);
+    QModelIndex index = q->indexFromItem(parent);
+    q->beginInsertColumns(index, start, end);
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::rowsAboutToBeRemoved(QStandardItem *parent,
+                                                     int start, int end)
+{
+    Q_Q(QStandardItemModel);
+    QModelIndex index = q->indexFromItem(parent);
+    q->beginRemoveRows(index, start, end);
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::columnsAboutToBeRemoved(QStandardItem *parent,
+                                                        int start, int end)
+{
+    Q_Q(QStandardItemModel);
+    QModelIndex index = q->indexFromItem(parent);
+    q->beginRemoveColumns(index, start, end);
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::rowsInserted(QStandardItem *parent,
+                                             int row, int count)
+{
+    Q_Q(QStandardItemModel);
+    if (parent == root.data())
+        rowHeaderItems.insert(row, count, 0);
+    q->endInsertRows();
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::columnsInserted(QStandardItem *parent,
+                                                int column, int count)
+{
+    Q_Q(QStandardItemModel);
+    if (parent == root.data())
+        columnHeaderItems.insert(column, count, 0);
+    q->endInsertColumns();
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::rowsRemoved(QStandardItem *parent,
+                                            int row, int count)
+{
+    Q_Q(QStandardItemModel);
+    if (parent == root.data()) {
+        for (int i = row; i < row + count; ++i) {
+            QStandardItem *oldItem = rowHeaderItems.at(i);
+            if (oldItem)
+                oldItem->d_func()->setModel(0);
+            delete oldItem;
+        }
+        rowHeaderItems.remove(row, count);
+    }
+    q->endRemoveRows();
+}
+
+/*!
+  \internal
+*/
+void QStandardItemModelPrivate::columnsRemoved(QStandardItem *parent,
+                                               int column, int count)
+{
+    Q_Q(QStandardItemModel);
+    if (parent == root.data()) {
+        for (int i = column; i < column + count; ++i) {
+            QStandardItem *oldItem = columnHeaderItems.at(i);
+            if (oldItem)
+                oldItem->d_func()->setModel(0);
+            delete oldItem;
+        }
+        columnHeaderItems.remove(column, count);
+    }
+    q->endRemoveColumns();
+}
+
+/*!
+    \class QStandardItem
+    \brief The QStandardItem class provides an item for use with the
+    QStandardItemModel class.
+    \since 4.2
+    \ingroup model-view
+    \inmodule QtGui
+
+    Items usually contain text, icons, or checkboxes.
+
+    Each item can have its own background brush which is set with the
+    setBackground() function. The current background brush can be found with
+    background().  The text label for each item can be rendered with its own
+    font and brush. These are specified with the setFont() and setForeground()
+    functions, and read with font() and foreground().
+
+    By default, items are enabled, editable, selectable, checkable, and can be
+    used both as the source of a drag and drop operation and as a drop target.
+    Each item's flags can be changed by calling setFlags(). Checkable items
+    can be checked and unchecked with the setCheckState() function. The
+    corresponding checkState() function indicates whether the item is
+    currently checked.
+
+    You can store application-specific data in an item by calling setData().
+
+    Each item can have a two-dimensional table of child items. This makes it
+    possible to build hierarchies of items. The typical hierarchy is the tree,
+    in which case the child table is a table with a single column (a list).
+
+    The dimensions of the child table can be set with setRowCount() and
+    setColumnCount(). Items can be positioned in the child table with
+    setChild(). Get a pointer to a child item with child(). New rows and
+    columns of children can also be inserted with insertRow() and
+    insertColumn(), or appended with appendRow() and appendColumn(). When
+    using the append and insert functions, the dimensions of the child table
+    will grow as needed.
+
+    An existing row of children can be removed with removeRow() or takeRow();
+    correspondingly, a column can be removed with removeColumn() or
+    takeColumn().
+
+    An item's children can be sorted by calling sortChildren().
+
+    \section1 Subclassing
+
+    When subclassing QStandardItem to provide custom items, it is possible to
+    define new types for them so that they can be distinguished from the base
+    class. The type() function should be reimplemented to return a new type
+    value equal to or greater than \l UserType.
+
+    Reimplement data() and setData() if you want to perform custom handling of
+    data queries and/or control how an item's data is represented.
+
+    Reimplement clone() if you want QStandardItemModel to be able to create
+    instances of your custom item class on demand (see
+    QStandardItemModel::setItemPrototype()).
+
+    Reimplement read() and write() if you want to control how items are
+    represented in their serialized form.
+
+    Reimplement \l{operator<()} if you want to control the semantics of item
+    comparison. \l{operator<()} determines the sorted order when sorting items
+    with sortChildren() or with QStandardItemModel::sort().
+
+    \sa QStandardItemModel, {Item View Convenience Classes}, {Model/View Programming}
+*/
+
+/*!
+    \enum QStandardItem::ItemType
+
+    This enum describes the types that are used to describe standard items.
+
+    \value Type     The default type for standard items.
+    \value UserType The minimum value for custom types. Values below UserType are
+                    reserved by Qt.
+
+    You can define new user types in QStandardItem subclasses to ensure that
+    custom items are treated specially; for example, when items are sorted.
+
+    \sa type()
+*/
+
+/*!
+    Constructs an item.
+*/
+QStandardItem::QStandardItem()
+    : d_ptr(new QStandardItemPrivate)
+{
+    Q_D(QStandardItem);
+    d->q_ptr = this;
+}
+
+/*!
+    Constructs an item with the given \a text.
+*/
+QStandardItem::QStandardItem(const QString &text)
+    : d_ptr(new QStandardItemPrivate)
+{
+    Q_D(QStandardItem);
+    d->q_ptr = this;
+    setText(text);
+}
+
+/*!
+    Constructs an item with the given \a icon and \a text.
+*/
+QStandardItem::QStandardItem(const QIcon &icon, const QString &text)
+    : d_ptr(new QStandardItemPrivate)
+{
+    Q_D(QStandardItem);
+    d->q_ptr = this;
+    setIcon(icon);
+    setText(text);
+}
+
+/*!
+   Constructs an item with \a rows rows and \a columns columns of child items.
+*/
+QStandardItem::QStandardItem(int rows, int columns)
+    : d_ptr(new QStandardItemPrivate)
+{
+    Q_D(QStandardItem);
+    d->q_ptr = this;
+    setRowCount(rows);
+    setColumnCount(columns);
+}
+
+/*!
+  \internal
+*/
+QStandardItem::QStandardItem(QStandardItemPrivate &dd)
+    : d_ptr(&dd)
+{
+    Q_D(QStandardItem);
+    d->q_ptr = this;
+}
+
+/*!
+  Constructs a copy of \a other. Note that model() is
+  not copied.
+
+  This function is useful when reimplementing clone().
+*/
+QStandardItem::QStandardItem(const QStandardItem &other)
+    : d_ptr(new QStandardItemPrivate)
+{
+    Q_D(QStandardItem);
+    d->q_ptr = this;
+    operator=(other);
+}
+
+/*!
+  Assigns \a other's data and flags to this item. Note that
+  type() and model() are not copied.
+
+  This function is useful when reimplementing clone().
+*/
+QStandardItem &QStandardItem::operator=(const QStandardItem &other)
+{
+    Q_D(QStandardItem);
+    d->values = other.d_func()->values;
+    return *this;
+}
+
+/*!
+  Destructs the item.
+  This causes the item's children to be destructed as well.
+*/
+QStandardItem::~QStandardItem()
+{
+}
+
+/*!
+  Returns the item's parent item, or 0 if the item has no parent.
+  \note For toplevel items parent() returns 0. To receive toplevel
+  item's parent use QStandardItemModel::invisibleRootItem() instead.
+
+  \sa child(), QStandardItemModel::invisibleRootItem()
+*/
+QStandardItem *QStandardItem::parent() const
+{
+    Q_D(const QStandardItem);
+    if (!d->model || (d->model->d_func()->root.data() != d->parent))
+        return d->parent;
+    return 0;
+}
+
+/*!
+    Sets the item's data for the given \a role to the specified \a value.
+
+    If you subclass QStandardItem and reimplement this function, your
+    reimplementation should call emitDataChanged() if you do not call
+    the base implementation of setData(). This will ensure that e.g.
+    views using the model are notified of the changes.
+
+    \note The default implementation treats Qt::EditRole and Qt::DisplayRole
+    as referring to the same data.
+
+    \sa Qt::ItemDataRole, data(), setFlags()
+*/
+void QStandardItem::setData(const QVariant &value, int role)
+{
+    Q_D(QStandardItem);
+    role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
+    QVector<QStandardItemData>::iterator it;
+    for (it = d->values.begin(); it != d->values.end(); ++it) {
+        if ((*it).role == role) {
+            if (value.isValid()) {
+                if ((*it).value.type() == value.type() && (*it).value == value)
+                    return;
+                (*it).value = value;
+            } else {
+                d->values.erase(it);
+            }
+            if (d->model)
+                d->model->d_func()->itemChanged(this);
+            return;
+        }
+    }
+    d->values.append(QStandardItemData(role, value));
+    if (d->model)
+        d->model->d_func()->itemChanged(this);
+}
+
+/*!
+    Returns the item's data for the given \a role, or an invalid
+    QVariant if there is no data for the role.
+
+    \note The default implementation treats Qt::EditRole and Qt::DisplayRole
+    as referring to the same data.
+*/
+QVariant QStandardItem::data(int role) const
+{
+    Q_D(const QStandardItem);
+    role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
+    QVector<QStandardItemData>::const_iterator it;
+    for (it = d->values.begin(); it != d->values.end(); ++it) {
+        if ((*it).role == role)
+            return (*it).value;
+    }
+    return QVariant();
+}
+
+/*!
+  \since 4.4
+
+  Causes the model associated with this item to emit a
+  \l{QAbstractItemModel::dataChanged()}{dataChanged}() signal for this
+  item.
+
+  You normally only need to call this function if you have subclassed
+  QStandardItem and reimplemented data() and/or setData().
+
+  \sa setData()
+*/
+void QStandardItem::emitDataChanged()
+{
+    Q_D(QStandardItem);
+    if (d->model)
+        d->model->d_func()->itemChanged(this);
+}
+
+/*!
+  Sets the item flags for the item to \a flags.
+
+  The item flags determine how the user can interact with the item.
+  This is often used to disable an item.
+
+  \sa flags(), setData()
+*/
+void QStandardItem::setFlags(Qt::ItemFlags flags)
+{
+    setData((int)flags, Qt::UserRole - 1);
+}
+
+/*!
+  Returns the item flags for the item.
+
+  The item flags determine how the user can interact with the item.
+
+  By default, items are enabled, editable, selectable, checkable, and can be
+  used both as the source of a drag and drop operation and as a drop target.
+
+  \sa setFlags()
+*/
+Qt::ItemFlags QStandardItem::flags() const
+{
+    QVariant v = data(Qt::UserRole - 1);
+    if (!v.isValid())
+        return (Qt::ItemIsSelectable|Qt::ItemIsEnabled|Qt::ItemIsEditable
+                |Qt::ItemIsDragEnabled|Qt::ItemIsDropEnabled);
+    return Qt::ItemFlags(v.toInt());
+}
+
+/*!
+    \fn QString QStandardItem::text() const
+
+    Returns the item's text. This is the text that's presented to the user
+    in a view.
+
+    \sa setText()
+*/
+
+/*!
+    \fn void QStandardItem::setText(const QString &text)
+
+    Sets the item's text to the \a text specified.
+
+    \sa text(), setFont(), setForeground()
+*/
+
+/*!
+    \fn QIcon QStandardItem::icon() const
+
+    Returns the item's icon.
+
+    \sa setIcon(), {QAbstractItemView::iconSize}{iconSize}
+*/
+
+/*!
+    \fn void QStandardItem::setIcon(const QIcon &icon)
+
+    Sets the item's icon to the \a icon specified.
+*/
+
+/*!
+    \fn QString QStandardItem::statusTip() const
+
+    Returns the item's status tip.
+
+    \sa setStatusTip(), toolTip(), whatsThis()
+*/
+
+/*!
+    \fn void QStandardItem::setStatusTip(const QString &statusTip)
+
+    Sets the item's status tip to the string specified by \a statusTip.
+
+    \sa statusTip(), setToolTip(), setWhatsThis()
+*/
+
+/*!
+    \fn QString QStandardItem::toolTip() const
+
+    Returns the item's tooltip.
+
+    \sa setToolTip(), statusTip(), whatsThis()
+*/
+
+/*!
+    \fn void QStandardItem::setToolTip(const QString &toolTip)
+
+    Sets the item's tooltip to the string specified by \a toolTip.
+
+    \sa toolTip(), setStatusTip(), setWhatsThis()
+*/
+
+/*!
+    \fn QString QStandardItem::whatsThis() const
+
+    Returns the item's "What's This?" help.
+
+    \sa setWhatsThis(), toolTip(), statusTip()
+*/
+
+/*!
+    \fn void QStandardItem::setWhatsThis(const QString &whatsThis)
+
+    Sets the item's "What's This?" help to the string specified by \a whatsThis.
+
+    \sa whatsThis(), setStatusTip(), setToolTip()
+*/
+
+/*!
+    \fn QFont QStandardItem::font() const
+
+    Returns the font used to render the item's text.
+
+    \sa setFont()
+*/
+
+/*!
+    \fn void QStandardItem::setFont(const QFont &font)
+
+    Sets the font used to display the item's text to the given \a font.
+
+    \sa font(), setText(), setForeground()
+*/
+
+/*!
+    \fn QBrush QStandardItem::background() const
+
+    Returns the brush used to render the item's background.
+
+    \sa foreground(), setBackground()
+*/
+
+/*!
+    \fn void QStandardItem::setBackground(const QBrush &brush)
+
+    Sets the item's background brush to the specified \a brush.
+
+    \sa background(), setForeground()
+*/
+
+/*!
+    \fn QBrush QStandardItem::foreground() const
+
+    Returns the brush used to render the item's foreground (e.g. text).
+
+    \sa setForeground(), background()
+*/
+
+/*!
+    \fn void QStandardItem::setForeground(const QBrush &brush)
+
+    Sets the brush used to display the item's foreground (e.g. text) to the
+    given \a brush.
+
+    \sa foreground(), setBackground(), setFont()
+*/
+
+/*!
+    \fn int QStandardItem::textAlignment() const
+
+    Returns the text alignment for the item's text.
+*/
+
+/*!
+    \fn void QStandardItem::setTextAlignment(Qt::Alignment alignment)
+
+    Sets the text alignment for the item's text to the \a alignment
+    specified.
+
+    \sa textAlignment()
+*/
+
+/*!
+    \fn QSize QStandardItem::sizeHint() const
+
+    Returns the size hint set for the item, or an invalid QSize if no
+    size hint has been set.
+
+    If no size hint has been set, the item delegate will compute the
+    size hint based on the item data.
+
+    \sa setSizeHint()
+*/
+
+/*!
+    \fn void QStandardItem::setSizeHint(const QSize &size)
+
+    Sets the size hint for the item to be \a size.
+    If no size hint is set, the item delegate will compute the
+    size hint based on the item data.
+
+    \sa sizeHint()
+*/
+
+/*!
+    \fn Qt::CheckState QStandardItem::checkState() const
+
+    Returns the checked state of the item.
+
+    \sa setCheckState(), isCheckable()
+*/
+
+/*!
+    \fn void QStandardItem::setCheckState(Qt::CheckState state)
+
+    Sets the check state of the item to be \a state.
+
+    \sa checkState(), setCheckable()
+*/
+
+/*!
+    \fn QString QStandardItem::accessibleText() const
+
+    Returns the item's accessible text.
+
+    The accessible text is used by assistive technologies (i.e. for users who
+    cannot use conventional means of interaction).
+
+    \sa setAccessibleText(), accessibleDescription()
+*/
+
+/*!
+    \fn void QStandardItem::setAccessibleText(const QString &accessibleText)
+
+    Sets the item's accessible text to the string specified by \a accessibleText.
+
+    The accessible text is used by assistive technologies (i.e. for users who
+    cannot use conventional means of interaction).
+
+    \sa accessibleText(), setAccessibleDescription()
+*/
+
+/*!
+    \fn QString QStandardItem::accessibleDescription() const
+
+    Returns the item's accessible description.
+
+    The accessible description is used by assistive technologies (i.e. for
+    users who cannot use conventional means of interaction).
+
+    \sa setAccessibleDescription(), accessibleText()
+*/
+
+/*!
+    \fn void QStandardItem::setAccessibleDescription(const QString &accessibleDescription)
+
+    Sets the item's accessible description to the string specified by \a
+    accessibleDescription.
+
+    The accessible description is used by assistive technologies (i.e. for
+    users who cannot use conventional means of interaction).
+
+    \sa accessibleDescription(), setAccessibleText()
+*/
+
+/*!
+  Sets whether the item is enabled. If \a enabled is true, the item is enabled,
+  meaning that the user can interact with the item; if \a enabled is false, the
+  user cannot interact with the item.
+
+  This flag takes precedence over the other item flags; e.g. if an item is not
+  enabled, it cannot be selected by the user, even if the Qt::ItemIsSelectable
+  flag has been set.
+
+  \sa isEnabled(), Qt::ItemIsEnabled, setFlags()
+*/
+void QStandardItem::setEnabled(bool enabled)
+{
+    Q_D(QStandardItem);
+    d->changeFlags(enabled, Qt::ItemIsEnabled);
+}
+
+/*!
+  \fn bool QStandardItem::isEnabled() const
+
+  Returns whether the item is enabled.
+
+  When an item is enabled, the user can interact with it. The possible
+  types of interaction are specified by the other item flags, such as
+  isEditable() and isSelectable().
+
+  The default value is true.
+
+  \sa setEnabled(), flags()
+*/
+
+/*!
+  Sets whether the item is editable. If \a editable is true, the item can be
+  edited by the user; otherwise, the user cannot edit the item.
+
+  How the user can edit items in a view is determined by the view's edit
+  triggers; see QAbstractItemView::editTriggers.
+
+  \sa isEditable(), setFlags()
+*/
+void QStandardItem::setEditable(bool editable)
+{
+    Q_D(QStandardItem);
+    d->changeFlags(editable, Qt::ItemIsEditable);
+}
+
+/*!
+  \fn bool QStandardItem::isEditable() const
+
+  Returns whether the item can be edited by the user.
+
+  When an item is editable (and enabled), the user can edit the item by
+  invoking one of the view's edit triggers; see
+  QAbstractItemView::editTriggers.
+
+  The default value is true.
+
+  \sa setEditable(), flags()
+*/
+
+/*!
+  Sets whether the item is selectable. If \a selectable is true, the item
+  can be selected by the user; otherwise, the user cannot select the item.
+
+  You can control the selection behavior and mode by manipulating their
+  view properties; see QAbstractItemView::selectionMode and
+  QAbstractItemView::selectionBehavior.
+
+  \sa isSelectable(), setFlags()
+*/
+void QStandardItem::setSelectable(bool selectable)
+{
+    Q_D(QStandardItem);
+    d->changeFlags(selectable, Qt::ItemIsSelectable);
+}
+
+/*!
+  \fn bool QStandardItem::isSelectable() const
+
+  Returns whether the item is selectable by the user.
+
+  The default value is true.
+
+  \sa setSelectable(), flags()
+*/
+
+/*!
+  Sets whether the item is user-checkable. If \a checkable is true, the
+  item can be checked by the user; otherwise, the user cannot check
+  the item.
+
+  The item delegate will render a checkable item with a check box next to the
+  item's text.
+
+  \sa isCheckable(), setCheckState(), setTristate()
+*/
+void QStandardItem::setCheckable(bool checkable)
+{
+    Q_D(QStandardItem);
+    if (checkable && !isCheckable()) {
+        // make sure there's data for the checkstate role
+        if (!data(Qt::CheckStateRole).isValid())
+            setData(Qt::Unchecked, Qt::CheckStateRole);
+    }
+    d->changeFlags(checkable, Qt::ItemIsUserCheckable);
+}
+
+/*!
+  \fn bool QStandardItem::isCheckable() const
+
+  Returns whether the item is user-checkable.
+
+  The default value is false.
+
+  \sa setCheckable(), checkState(), isTristate()
+*/
+
+/*!
+  Sets whether the item is tristate. If \a tristate is true, the
+  item is checkable with three separate states; otherwise, the item
+  is checkable with two states. (Note that this also requires that
+  the item is checkable; see isCheckable().)
+
+  \sa isTristate(), setCheckable(), setCheckState()
+*/
+void QStandardItem::setTristate(bool tristate)
+{
+    Q_D(QStandardItem);
+    d->changeFlags(tristate, Qt::ItemIsTristate);
+}
+
+/*!
+  \fn bool QStandardItem::isTristate() const
+
+  Returns whether the item is tristate; that is, if it's checkable with three
+  separate states.
+
+  The default value is false.
+
+  \sa setTristate(), isCheckable(), checkState()
+*/
+
+#ifndef QT_NO_DRAGANDDROP
+
+/*!
+  Sets whether the item is drag enabled. If \a dragEnabled is true, the item
+  can be dragged by the user; otherwise, the user cannot drag the item.
+
+  Note that you also need to ensure that item dragging is enabled in the view;
+  see QAbstractItemView::dragEnabled.
+
+  \sa isDragEnabled(), setDropEnabled(), setFlags()
+*/
+void QStandardItem::setDragEnabled(bool dragEnabled)
+{
+    Q_D(QStandardItem);
+    d->changeFlags(dragEnabled, Qt::ItemIsDragEnabled);
+}
+
+/*!
+  \fn bool QStandardItem::isDragEnabled() const
+
+  Returns whether the item is drag enabled. An item that is drag enabled can
+  be dragged by the user.
+
+  The default value is true.
+
+  Note that item dragging must be enabled in the view for dragging to work;
+  see QAbstractItemView::dragEnabled.
+
+  \sa setDragEnabled(), isDropEnabled(), flags()
+*/
+
+/*!
+  Sets whether the item is drop enabled. If \a dropEnabled is true, the item
+  can be used as a drop target; otherwise, it cannot.
+
+  Note that you also need to ensure that drops are enabled in the view; see
+  QWidget::acceptDrops(); and that the model supports the desired drop actions;
+  see QAbstractItemModel::supportedDropActions().
+
+  \sa isDropEnabled(), setDragEnabled(), setFlags()
+*/
+void QStandardItem::setDropEnabled(bool dropEnabled)
+{
+    Q_D(QStandardItem);
+    d->changeFlags(dropEnabled, Qt::ItemIsDropEnabled);
+}
+
+/*!
+  \fn bool QStandardItem::isDropEnabled() const
+
+  Returns whether the item is drop enabled. When an item is drop enabled, it
+  can be used as a drop target.
+
+  The default value is true.
+
+  \sa setDropEnabled(), isDragEnabled(), flags()
+*/
+
+#endif // QT_NO_DRAGANDDROP
+
+/*!
+  Returns the row where the item is located in its parent's child table, or
+  -1 if the item has no parent.
+
+  \sa column(), parent()
+*/
+int QStandardItem::row() const
+{
+    Q_D(const QStandardItem);
+    QPair<int, int> pos = d->position();
+    return pos.first;
+}
+
+/*!
+  Returns the column where the item is located in its parent's child table,
+  or -1 if the item has no parent.
+
+  \sa row(), parent()
+*/
+int QStandardItem::column() const
+{
+    Q_D(const QStandardItem);
+    QPair<int, int> pos = d->position();
+    return pos.second;
+}
+
+/*!
+  Returns the QModelIndex associated with this item.
+
+  When you need to invoke item functionality in a QModelIndex-based API (e.g.
+  QAbstractItemView), you can call this function to obtain an index that
+  corresponds to the item's location in the model.
+
+  If the item is not associated with a model, an invalid QModelIndex is
+  returned.
+
+  \sa model(), QStandardItemModel::itemFromIndex()
+*/
+QModelIndex QStandardItem::index() const
+{
+    Q_D(const QStandardItem);
+    return d->model ? d->model->indexFromItem(this) : QModelIndex();
+}
+
+/*!
+  Returns the QStandardItemModel that this item belongs to.
+
+  If the item is not a child of another item that belongs to the model, this
+  function returns 0.
+
+  \sa index()
+*/
+QStandardItemModel *QStandardItem::model() const
+{
+    Q_D(const QStandardItem);
+    return d->model;
+}
+
+/*!
+    Sets the number of child item rows to \a rows. If this is less than
+    rowCount(), the data in the unwanted rows is discarded.
+
+    \sa rowCount(), setColumnCount()
+*/
+void QStandardItem::setRowCount(int rows)
+{
+    int rc = rowCount();
+    if (rc == rows)
+        return;
+    if (rc < rows)
+        insertRows(qMax(rc, 0), rows - rc);
+    else
+        removeRows(qMax(rows, 0), rc - rows);
+}
+
+/*!
+    Returns the number of child item rows that the item has.
+
+    \sa setRowCount(), columnCount()
+*/
+int QStandardItem::rowCount() const
+{
+    Q_D(const QStandardItem);
+    return d->rowCount();
+}
+
+/*!
+    Sets the number of child item columns to \a columns. If this is less than
+    columnCount(), the data in the unwanted columns is discarded.
+
+    \sa columnCount(), setRowCount()
+*/
+void QStandardItem::setColumnCount(int columns)
+{
+    int cc = columnCount();
+    if (cc == columns)
+        return;
+    if (cc < columns)
+        insertColumns(qMax(cc, 0), columns - cc);
+    else
+        removeColumns(qMax(columns, 0), cc - columns);
+}
+
+/*!
+    Returns the number of child item columns that the item has.
+
+    \sa setColumnCount(), rowCount()
+*/
+int QStandardItem::columnCount() const
+{
+    Q_D(const QStandardItem);
+    return d->columnCount();
+}
+
+/*!
+    Inserts a row at \a row containing \a items. If necessary, the column
+    count is increased to the size of \a items.
+
+    \sa insertRows(), insertColumn()
+*/
+void QStandardItem::insertRow(int row, const QList<QStandardItem*> &items)
+{
+    Q_D(QStandardItem);
+    if (row < 0)
+        return;
+    if (columnCount() < items.count())
+        setColumnCount(items.count());
+    d->insertRows(row, 1, items);
+}
+
+/*!
+    Inserts \a items at \a row. The column count wont be changed.
+
+    \sa insertRow(), insertColumn()
+*/
+void QStandardItem::insertRows(int row, const QList<QStandardItem*> &items)
+{
+    Q_D(QStandardItem);
+    if (row < 0)
+        return;
+    d->insertRows(row, items);
+}
+
+/*!
+    Inserts a column at \a column containing \a items. If necessary,
+    the row count is increased to the size of \a items.
+
+    \sa insertColumns(), insertRow()
+*/
+void QStandardItem::insertColumn(int column, const QList<QStandardItem*> &items)
+{
+    Q_D(QStandardItem);
+    if (column < 0)
+        return;
+    if (rowCount() < items.count())
+        setRowCount(items.count());
+    d->insertColumns(column, 1, items);
+}
+
+/*!
+    Inserts \a count rows of child items at row \a row.
+
+    \sa insertRow(), insertColumns()
+*/
+void QStandardItem::insertRows(int row, int count)
+{
+    Q_D(QStandardItem);
+    if (rowCount() < row) {
+        count += row - rowCount();
+        row = rowCount();
+    }
+    d->insertRows(row, count, QList<QStandardItem*>());
+}
+
+/*!
+    Inserts \a count columns of child items at column \a column.
+
+    \sa insertColumn(), insertRows()
+*/
+void QStandardItem::insertColumns(int column, int count)
+{
+    Q_D(QStandardItem);
+    if (columnCount() < column) {
+        count += column - columnCount();
+        column = columnCount();
+    }
+    d->insertColumns(column, count, QList<QStandardItem*>());
+}
+
+/*!
+    \fn void QStandardItem::appendRow(const QList<QStandardItem*> &items)
+
+    Appends a row containing \a items. If necessary, the column count is
+    increased to the size of \a items.
+
+    \sa insertRow()
+*/
+
+/*!
+    \fn void QStandardItem::appendRows(const QList<QStandardItem*> &items)
+
+    Appends rows containing \a items.  The column count will not change.
+
+    \sa insertRow()
+*/
+
+/*!
+    \fn void QStandardItem::appendColumn(const QList<QStandardItem*> &items)
+
+    Appends a column containing \a items. If necessary, the row count is
+    increased to the size of \a items.
+
+    \sa insertColumn()
+*/
+
+/*!
+    \fn bool QStandardItemModel::insertRow(int row, const QModelIndex &parent)
+
+    Inserts a single row before the given \a row in the child items of the
+    \a parent specified. Returns true if the row is inserted; otherwise
+    returns false.
+
+    \sa insertRows(), insertColumn(), removeRow()
+*/
+
+/*!
+    \fn bool QStandardItemModel::insertColumn(int column, const QModelIndex &parent)
+
+    Inserts a single column before the given \a column in the child items of
+    the \a parent specified. Returns true if the column is inserted; otherwise
+    returns false.
+
+    \sa insertColumns(), insertRow(), removeColumn()
+*/
+
+/*!
+    \fn QStandardItem::insertRow(int row, QStandardItem *item)
+    \overload
+
+    Inserts a row at \a row containing \a item.
+
+    When building a list or a tree that has only one column, this function
+    provides a convenient way to insert a single new item.
+*/
+
+/*!
+    \fn QStandardItem::appendRow(QStandardItem *item)
+    \overload
+
+    Appends a row containing \a item.
+
+    When building a list or a tree that has only one column, this function
+    provides a convenient way to append a single new item.
+*/
+
+/*!
+    Removes the given \a row. The items that were in the row are deleted.
+
+    \sa takeRow(), removeRows(), removeColumn()
+*/
+void QStandardItem::removeRow(int row)
+{
+    removeRows(row, 1);
+}
+
+/*!
+    Removes the given \a column. The items that were in the
+    column are deleted.
+
+    \sa takeColumn(), removeColumns(), removeRow()
+*/
+void QStandardItem::removeColumn(int column)
+{
+    removeColumns(column, 1);
+}
+
+/*!
+    Removes \a count rows at row \a row. The items that were in those rows are
+    deleted.
+
+    \sa removeRow(), removeColumn()
+*/
+void QStandardItem::removeRows(int row, int count)
+{
+    Q_D(QStandardItem);
+    if ((count < 1) || (row < 0) || ((row + count) > rowCount()))
+        return;
+    if (d->model)
+        d->model->d_func()->rowsAboutToBeRemoved(this, row, row + count - 1);
+    int i = d->childIndex(row, 0);
+    int n = count * d->columnCount();
+    for (int j = i; j < n+i; ++j) {
+        QStandardItem *oldItem = d->children.at(j);
+        if (oldItem)
+            oldItem->d_func()->setModel(0);
+        delete oldItem;
+    }
+    d->children.remove(qMax(i, 0), n);
+    d->rows -= count;
+    if (d->model)
+        d->model->d_func()->rowsRemoved(this, row, count);
+}
+
+/*!
+    Removes \a count columns at column \a column. The items that were in those
+    columns are deleted.
+
+    \sa removeColumn(), removeRows()
+*/
+void QStandardItem::removeColumns(int column, int count)
+{
+    Q_D(QStandardItem);
+    if ((count < 1) || (column < 0) || ((column + count) > columnCount()))
+        return;
+    if (d->model)
+        d->model->d_func()->columnsAboutToBeRemoved(this, column, column + count - 1);
+    for (int row = d->rowCount() - 1; row >= 0; --row) {
+        int i = d->childIndex(row, column);
+        for (int j=i; j<i+count; ++j) {
+            QStandardItem *oldItem = d->children.at(j);
+            if (oldItem)
+                oldItem->d_func()->setModel(0);
+            delete oldItem;
+        }
+        d->children.remove(i, count);
+    }
+    d->columns -= count;
+    if (d->model)
+        d->model->d_func()->columnsRemoved(this, column, count);
+}
+
+/*!
+    Returns true if this item has any children; otherwise returns false.
+
+    \sa rowCount(), columnCount(), child()
+*/
+bool QStandardItem::hasChildren() const
+{
+    return (rowCount() > 0) && (columnCount() > 0);
+}
+
+/*!
+    Sets the child item at (\a row, \a column) to \a item. This item (the parent
+    item) takes ownership of \a item. If necessary, the row count and column
+    count are increased to fit the item.
+
+    \sa child()
+*/
+void QStandardItem::setChild(int row, int column, QStandardItem *item)
+{
+    Q_D(QStandardItem);
+    d->setChild(row, column, item, true);
+}
+
+/*!
+    \fn QStandardItem::setChild(int row, QStandardItem *item)
+    \overload
+
+    Sets the child at \a row to \a item.
+*/
+
+/*!
+    Returns the child item at (\a row, \a column) if one has been set; otherwise
+    returns 0.
+
+    \sa setChild(), takeChild(), parent()
+*/
+QStandardItem *QStandardItem::child(int row, int column) const
+{
+    Q_D(const QStandardItem);
+    int index = d->childIndex(row, column);
+    if (index == -1)
+        return 0;
+    return d->children.at(index);
+}
+
+/*!
+    Removes the child item at (\a row, \a column) without deleting it, and returns
+    a pointer to the item. If there was no child at the given location, then
+    this function returns 0.
+
+    Note that this function, unlike takeRow() and takeColumn(), does not affect
+    the dimensions of the child table.
+
+    \sa child(), takeRow(), takeColumn()
+*/
+QStandardItem *QStandardItem::takeChild(int row, int column)
+{
+    Q_D(QStandardItem);
+    QStandardItem *item = 0;
+    int index = d->childIndex(row, column);
+    if (index != -1) {
+        item = d->children.at(index);
+        if (item)
+            item->d_func()->setParentAndModel(0, 0);
+        d->children.replace(index, 0);
+    }
+    return item;
+}
+
+/*!
+    Removes \a row without deleting the row items, and returns a list of
+    pointers to the removed items. For items in the row that have not been
+    set, the corresponding pointers in the list will be 0.
+
+    \sa removeRow(), insertRow(), takeColumn()
+*/
+QList<QStandardItem*> QStandardItem::takeRow(int row)
+{
+    Q_D(QStandardItem);
+    if ((row < 0) || (row >= rowCount()))
+        return QList<QStandardItem*>();
+    if (d->model)
+        d->model->d_func()->rowsAboutToBeRemoved(this, row, row);
+    QList<QStandardItem*> items;
+    int index = d->childIndex(row, 0);  // Will return -1 if there are no columns
+    if (index != -1) {
+        int col_count = d->columnCount();
+        for (int column = 0; column < col_count; ++column) {
+            QStandardItem *ch = d->children.at(index + column);
+            if (ch)
+                ch->d_func()->setParentAndModel(0, 0);
+            items.append(ch);
+        }
+        d->children.remove(index, col_count);
+    }
+    d->rows--;
+    if (d->model)
+        d->model->d_func()->rowsRemoved(this, row, 1);
+    return items;
+}
+
+/*!
+    Removes \a column without deleting the column items, and returns a list of
+    pointers to the removed items. For items in the column that have not been
+    set, the corresponding pointers in the list will be 0.
+
+    \sa removeColumn(), insertColumn(), takeRow()
+*/
+QList<QStandardItem*> QStandardItem::takeColumn(int column)
+{
+    Q_D(QStandardItem);
+    if ((column < 0) || (column >= columnCount()))
+        return QList<QStandardItem*>();
+    if (d->model)
+        d->model->d_func()->columnsAboutToBeRemoved(this, column, column);
+    QList<QStandardItem*> items;
+
+    for (int row = d->rowCount() - 1; row >= 0; --row) {
+        int index = d->childIndex(row, column);
+        QStandardItem *ch = d->children.at(index);
+        if (ch)
+            ch->d_func()->setParentAndModel(0, 0);
+        d->children.remove(index);
+        items.prepend(ch);
+    }
+    d->columns--;
+    if (d->model)
+        d->model->d_func()->columnsRemoved(this, column, 1);
+    return items;
+}
+
+/*!
+    Returns true if this item is less than \a other; otherwise returns false.
+
+    The default implementation uses the data for the item's sort role (see
+    QStandardItemModel::sortRole) to perform the comparison if the item
+    belongs to a model; otherwise, the data for the item's Qt::DisplayRole
+    (text()) is used to perform the comparison.
+
+    sortChildren() and QStandardItemModel::sort() use this function when
+    sorting items. If you want custom sorting, you can subclass QStandardItem
+    and reimplement this function.
+*/
+bool QStandardItem::operator<(const QStandardItem &other) const
+{
+    const int role = model() ? model()->sortRole() : Qt::DisplayRole;
+    const QVariant l = data(role), r = other.data(role);
+    // this code is copied from QSortFilterProxyModel::lessThan()
+    switch (l.userType()) {
+    case QVariant::Invalid:
+        return (r.type() == QVariant::Invalid);
+    case QVariant::Int:
+        return l.toInt() < r.toInt();
+    case QVariant::UInt:
+        return l.toUInt() < r.toUInt();
+    case QVariant::LongLong:
+        return l.toLongLong() < r.toLongLong();
+    case QVariant::ULongLong:
+        return l.toULongLong() < r.toULongLong();
+    case QMetaType::Float:
+        return l.toFloat() < r.toFloat();
+    case QVariant::Double:
+        return l.toDouble() < r.toDouble();
+    case QVariant::Char:
+        return l.toChar() < r.toChar();
+    case QVariant::Date:
+        return l.toDate() < r.toDate();
+    case QVariant::Time:
+        return l.toTime() < r.toTime();
+    case QVariant::DateTime:
+        return l.toDateTime() < r.toDateTime();
+    case QVariant::String:
+    default:
+        return l.toString().compare(r.toString()) < 0;
+    }
+}
+
+/*!
+    Sorts the children of the item using the given \a order, by the values in
+    the given \a column.
+
+    \note This function is recursive, therefore it sorts the children of the
+    item, its grandchildren, etc.
+
+    \sa {operator<()}
+*/
+void QStandardItem::sortChildren(int column, Qt::SortOrder order)
+{
+    Q_D(QStandardItem);
+    if ((column < 0) || (rowCount() == 0))
+        return;
+    if (d->model)
+        emit d->model->layoutAboutToBeChanged();
+    d->sortChildren(column, order);
+    if (d->model)
+        emit d->model->layoutChanged();
+}
+
+/*!
+    Returns a copy of this item. The item's children are not copied.
+
+    When subclassing QStandardItem, you can reimplement this function
+    to provide QStandardItemModel with a factory that it can use to
+    create new items on demand.
+
+    \sa QStandardItemModel::setItemPrototype(), operator=()
+*/
+QStandardItem *QStandardItem::clone() const
+{
+    return new QStandardItem(*this);
+}
+
+/*!
+    Returns the type of this item. The type is used to distinguish custom
+    items from the base class. When subclassing QStandardItem, you should
+    reimplement this function and return a new value greater than or equal
+    to \l UserType.
+
+    \sa QStandardItem::Type
+*/
+int QStandardItem::type() const
+{
+    return Type;
+}
+
+#ifndef QT_NO_DATASTREAM
+
+/*!
+    Reads the item from stream \a in. Only the data and flags of the item are
+    read, not the child items.
+
+    \sa write()
+*/
+void QStandardItem::read(QDataStream &in)
+{
+    Q_D(QStandardItem);
+    in >> d->values;
+    qint32 flags;
+    in >> flags;
+    setFlags(Qt::ItemFlags(flags));
+}
+
+/*!
+    Writes the item to stream \a out. Only the data and flags of the item
+    are written, not the child items.
+
+    \sa read()
+*/
+void QStandardItem::write(QDataStream &out) const
+{
+    Q_D(const QStandardItem);
+    out << d->values;
+    out << flags();
+}
+
+/*!
+    \relates QStandardItem
+    \since 4.2
+
+    Reads a QStandardItem from stream \a in into \a item.
+
+    This operator uses QStandardItem::read().
+
+    \sa {Serializing Qt Data Types}
+*/
+QDataStream &operator>>(QDataStream &in, QStandardItem &item)
+{
+    item.read(in);
+    return in;
+}
+
+/*!
+    \relates QStandardItem
+    \since 4.2
+
+    Writes the QStandardItem \a item to stream \a out.
+
+    This operator uses QStandardItem::write().
+
+    \sa {Serializing Qt Data Types}
+*/
+QDataStream &operator<<(QDataStream &out, const QStandardItem &item)
+{
+    item.write(out);
+    return out;
+}
+
+#endif // QT_NO_DATASTREAM
+
+/*!
+    \class QStandardItemModel
+    \brief The QStandardItemModel class provides a generic model for storing custom data.
+    \ingroup model-view
+    \inmodule QtGui
+
+    QStandardItemModel can be used as a repository for standard Qt
+    data types. It is one of the \l {Model/View Classes} and is part
+    of Qt's \l {Model/View Programming}{model/view} framework.
+
+    QStandardItemModel provides a classic item-based approach to working with
+    the model.  The items in a QStandardItemModel are provided by
+    QStandardItem.
+
+    QStandardItemModel implements the QAbstractItemModel interface, which
+    means that the model can be used to provide data in any view that supports
+    that interface (such as QListView, QTableView and QTreeView, and your own
+    custom views). For performance and flexibility, you may want to subclass
+    QAbstractItemModel to provide support for different kinds of data
+    repositories. For example, the QDirModel provides a model interface to the
+    underlying file system.
+
+    When you want a list or tree, you typically create an empty
+    QStandardItemModel and use appendRow() to add items to the model, and
+    item() to access an item.  If your model represents a table, you typically
+    pass the dimensions of the table to the QStandardItemModel constructor and
+    use setItem() to position items into the table. You can also use setRowCount()
+    and setColumnCount() to alter the dimensions of the model. To insert items,
+    use insertRow() or insertColumn(), and to remove items, use removeRow() or
+    removeColumn().
+
+    You can set the header labels of your model with setHorizontalHeaderLabels()
+    and setVerticalHeaderLabels().
+
+    You can search for items in the model with findItems(), and sort the model by
+    calling sort().
+
+    Call clear() to remove all items from the model.
+
+    An example usage of QStandardItemModel to create a table:
+
+    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 0
+
+    An example usage of QStandardItemModel to create a tree:
+
+    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 1
+
+    After setting the model on a view, you typically want to react to user
+    actions, such as an item being clicked. Since a QAbstractItemView provides
+    QModelIndex-based signals and functions, you need a way to obtain the
+    QStandardItem that corresponds to a given QModelIndex, and vice
+    versa. itemFromIndex() and indexFromItem() provide this mapping. Typical
+    usage of itemFromIndex() includes obtaining the item at the current index
+    in a view, and obtaining the item that corresponds to an index carried by
+    a QAbstractItemView signal, such as QAbstractItemView::clicked(). First
+    you connect the view's signal to a slot in your class:
+
+    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 2
+
+    When you receive the signal, you call itemFromIndex() on the given model
+    index to get a pointer to the item:
+
+    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 3
+
+    Conversely, you must obtain the QModelIndex of an item when you want to
+    invoke a model/view function that takes an index as argument. You can
+    obtain the index either by using the model's indexFromItem() function, or,
+    equivalently, by calling QStandardItem::index():
+
+    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 4
+
+    You are, of course, not required to use the item-based approach; you could
+    instead rely entirely on the QAbstractItemModel interface when working with
+    the model, or use a combination of the two as appropriate.
+
+    \sa QStandardItem, {Model/View Programming}, QAbstractItemModel,
+    {itemviews/simpletreemodel}{Simple Tree Model example},
+    {Item View Convenience Classes}
+*/
+
+/*!
+    \fn void QStandardItemModel::itemChanged(QStandardItem *item)
+    \since 4.2
+
+    This signal is emitted whenever the data of \a item has changed.
+*/
+
+/*!
+    Constructs a new item model with the given \a parent.
+*/
+QStandardItemModel::QStandardItemModel(QObject *parent)
+    : QAbstractItemModel(*new QStandardItemModelPrivate, parent)
+{
+    Q_D(QStandardItemModel);
+    d->init();
+    d->root->d_func()->setModel(this);
+}
+
+/*!
+    Constructs a new item model that initially has \a rows rows and \a columns
+    columns, and that has the given \a parent.
+*/
+QStandardItemModel::QStandardItemModel(int rows, int columns, QObject *parent)
+    : QAbstractItemModel(*new QStandardItemModelPrivate, parent)
+{
+    Q_D(QStandardItemModel);
+    d->init();
+    d->root->insertColumns(0, columns);
+    d->columnHeaderItems.insert(0, columns, 0);
+    d->root->insertRows(0, rows);
+    d->rowHeaderItems.insert(0, rows, 0);
+    d->root->d_func()->setModel(this);
+}
+
+/*!
+  \internal
+*/
+QStandardItemModel::QStandardItemModel(QStandardItemModelPrivate &dd, QObject *parent)
+    : QAbstractItemModel(dd, parent)
+{
+    Q_D(QStandardItemModel);
+    d->init();
+}
+
+/*!
+    Destructs the model. The model destroys all its items.
+*/
+QStandardItemModel::~QStandardItemModel()
+{
+}
+
+/*!
+    Sets the item role names to \a roleNames.
+*/
+void QStandardItemModel::setItemRoleNames(const QHash<int,QByteArray> &roleNames)
+{
+    Q_D(QStandardItemModel);
+    d->roleNames = roleNames;
+}
+
+/*!
+    Removes all items (including header items) from the model and sets the
+    number of rows and columns to zero.
+
+    \sa removeColumns(), removeRows()
+*/
+void QStandardItemModel::clear()
+{
+    Q_D(QStandardItemModel);
+    beginResetModel();
+    d->root.reset(new QStandardItem);
+    d->root->d_func()->setModel(this);
+    qDeleteAll(d->columnHeaderItems);
+    d->columnHeaderItems.clear();
+    qDeleteAll(d->rowHeaderItems);
+    d->rowHeaderItems.clear();
+    endResetModel();
+}
+
+/*!
+    \since 4.2
+
+    Returns a pointer to the QStandardItem associated with the given \a index.
+
+    Calling this function is typically the initial step when processing
+    QModelIndex-based signals from a view, such as
+    QAbstractItemView::activated(). In your slot, you call itemFromIndex(),
+    with the QModelIndex carried by the signal as argument, to obtain a
+    pointer to the corresponding QStandardItem.
+
+    Note that this function will lazily create an item for the index (using
+    itemPrototype()), and set it in the parent item's child table, if no item
+    already exists at that index.
+
+    If \a index is an invalid index, this function returns 0.
+
+    \sa indexFromItem()
+*/
+QStandardItem *QStandardItemModel::itemFromIndex(const QModelIndex &index) const
+{
+    Q_D(const QStandardItemModel);
+    if ((index.row() < 0) || (index.column() < 0) || (index.model() != this))
+        return 0;
+    QStandardItem *parent = static_cast<QStandardItem*>(index.internalPointer());
+    if (parent == 0)
+        return 0;
+    QStandardItem *item = parent->child(index.row(), index.column());
+    // lazy part
+    if (item == 0) {
+        item = d->createItem();
+        parent->d_func()->setChild(index.row(), index.column(), item);
+    }
+    return item;
+}
+
+/*!
+    \since 4.2
+
+    Returns the QModelIndex associated with the given \a item.
+
+    Use this function when you want to perform an operation that requires the
+    QModelIndex of the item, such as
+    QAbstractItemView::scrollTo(). QStandardItem::index() is provided as
+    convenience; it is equivalent to calling this function.
+
+    \sa itemFromIndex(), QStandardItem::index()
+*/
+QModelIndex QStandardItemModel::indexFromItem(const QStandardItem *item) const
+{
+    if (item && item->d_func()->parent) {
+        QPair<int, int> pos = item->d_func()->position();
+        return createIndex(pos.first, pos.second, item->d_func()->parent);
+    }
+    return QModelIndex();
+}
+
+/*!
+    \since 4.2
+
+    Sets the number of rows in this model to \a rows. If
+    this is less than rowCount(), the data in the unwanted rows
+    is discarded.
+
+    \sa setColumnCount()
+*/
+void QStandardItemModel::setRowCount(int rows)
+{
+    Q_D(QStandardItemModel);
+    d->root->setRowCount(rows);
+}
+
+/*!
+    \since 4.2
+
+    Sets the number of columns in this model to \a columns. If
+    this is less than columnCount(), the data in the unwanted columns
+    is discarded.
+
+    \sa setRowCount()
+*/
+void QStandardItemModel::setColumnCount(int columns)
+{
+    Q_D(QStandardItemModel);
+    d->root->setColumnCount(columns);
+}
+
+/*!
+    \since 4.2
+
+    Sets the item for the given \a row and \a column to \a item. The model
+    takes ownership of the item. If necessary, the row count and column count
+    are increased to fit the item. The previous item at the given location (if
+    there was one) is deleted.
+
+    \sa item()
+*/
+void QStandardItemModel::setItem(int row, int column, QStandardItem *item)
+{
+    Q_D(QStandardItemModel);
+    d->root->d_func()->setChild(row, column, item, true);
+}
+
+/*!
+  \fn QStandardItemModel::setItem(int row, QStandardItem *item)
+  \overload
+*/
+
+/*!
+    \since 4.2
+
+    Returns the item for the given \a row and \a column if one has been set;
+    otherwise returns 0.
+
+    \sa setItem(), takeItem(), itemFromIndex()
+*/
+QStandardItem *QStandardItemModel::item(int row, int column) const
+{
+    Q_D(const QStandardItemModel);
+    return d->root->child(row, column);
+}
+
+/*!
+    \since 4.2
+
+    Returns the model's invisible root item.
+
+    The invisible root item provides access to the model's top-level items
+    through the QStandardItem API, making it possible to write functions that
+    can treat top-level items and their children in a uniform way; for
+    example, recursive functions involving a tree model.
+
+    \note Calling \l{QAbstractItemModel::index()}{index()} on the QStandardItem object
+    retrieved from this function is not valid.
+*/
+QStandardItem *QStandardItemModel::invisibleRootItem() const
+{
+    Q_D(const QStandardItemModel);
+    return d->root.data();
+}
+
+/*!
+    \since 4.2
+
+    Sets the horizontal header item for \a column to \a item.  The model takes
+    ownership of the item. If necessary, the column count is increased to fit
+    the item. The previous header item (if there was one) is deleted.
+
+    \sa horizontalHeaderItem(), setHorizontalHeaderLabels(),
+    setVerticalHeaderItem()
+*/
+void QStandardItemModel::setHorizontalHeaderItem(int column, QStandardItem *item)
+{
+    Q_D(QStandardItemModel);
+    if (column < 0)
+        return;
+    if (columnCount() <= column)
+        setColumnCount(column + 1);
+
+    QStandardItem *oldItem = d->columnHeaderItems.at(column);
+    if (item == oldItem)
+        return;
+
+    if (item) {
+        if (item->model() == 0) {
+            item->d_func()->setModel(this);
+        } else {
+            qWarning("QStandardItem::setHorizontalHeaderItem: Ignoring duplicate insertion of item %p",
+                     item);
+            return;
+        }
+    }
+
+    if (oldItem)
+        oldItem->d_func()->setModel(0);
+    delete oldItem;
+
+    d->columnHeaderItems.replace(column, item);
+    emit headerDataChanged(Qt::Horizontal, column, column);
+}
+
+/*!
+    \since 4.2
+
+    Returns the horizontal header item for \a column if one has been set;
+    otherwise returns 0.
+
+    \sa setHorizontalHeaderItem(), verticalHeaderItem()
+*/
+QStandardItem *QStandardItemModel::horizontalHeaderItem(int column) const
+{
+    Q_D(const QStandardItemModel);
+    if ((column < 0) || (column >= columnCount()))
+        return 0;
+    return d->columnHeaderItems.at(column);
+}
+
+/*!
+    \since 4.2
+
+    Sets the vertical header item for \a row to \a item.  The model takes
+    ownership of the item. If necessary, the row count is increased to fit the
+    item. The previous header item (if there was one) is deleted.
+
+    \sa verticalHeaderItem(), setVerticalHeaderLabels(),
+    setHorizontalHeaderItem()
+*/
+void QStandardItemModel::setVerticalHeaderItem(int row, QStandardItem *item)
+{
+    Q_D(QStandardItemModel);
+    if (row < 0)
+        return;
+    if (rowCount() <= row)
+        setRowCount(row + 1);
+
+    QStandardItem *oldItem = d->rowHeaderItems.at(row);
+    if (item == oldItem)
+        return;
+
+    if (item) {
+        if (item->model() == 0) {
+            item->d_func()->setModel(this);
+        } else {
+            qWarning("QStandardItem::setVerticalHeaderItem: Ignoring duplicate insertion of item %p",
+                     item);
+            return;
+        }
+    }
+
+    if (oldItem)
+        oldItem->d_func()->setModel(0);
+    delete oldItem;
+
+    d->rowHeaderItems.replace(row, item);
+    emit headerDataChanged(Qt::Vertical, row, row);
+}
+
+/*!
+    \since 4.2
+
+    Returns the vertical header item for row \a row if one has been set;
+    otherwise returns 0.
+
+    \sa setVerticalHeaderItem(), horizontalHeaderItem()
+*/
+QStandardItem *QStandardItemModel::verticalHeaderItem(int row) const
+{
+    Q_D(const QStandardItemModel);
+    if ((row < 0) || (row >= rowCount()))
+        return 0;
+    return d->rowHeaderItems.at(row);
+}
+
+/*!
+    \since 4.2
+
+    Sets the horizontal header labels using \a labels. If necessary, the
+    column count is increased to the size of \a labels.
+
+    \sa setHorizontalHeaderItem()
+*/
+void QStandardItemModel::setHorizontalHeaderLabels(const QStringList &labels)
+{
+    Q_D(QStandardItemModel);
+    if (columnCount() < labels.count())
+        setColumnCount(labels.count());
+    for (int i = 0; i < labels.count(); ++i) {
+        QStandardItem *item = horizontalHeaderItem(i);
+        if (!item) {
+            item = d->createItem();
+            setHorizontalHeaderItem(i, item);
+        }
+        item->setText(labels.at(i));
+    }
+}
+
+/*!
+    \since 4.2
+
+    Sets the vertical header labels using \a labels. If necessary, the row
+    count is increased to the size of \a labels.
+
+    \sa setVerticalHeaderItem()
+*/
+void QStandardItemModel::setVerticalHeaderLabels(const QStringList &labels)
+{
+    Q_D(QStandardItemModel);
+    if (rowCount() < labels.count())
+        setRowCount(labels.count());
+    for (int i = 0; i < labels.count(); ++i) {
+        QStandardItem *item = verticalHeaderItem(i);
+        if (!item) {
+            item = d->createItem();
+            setVerticalHeaderItem(i, item);
+        }
+        item->setText(labels.at(i));
+    }
+}
+
+/*!
+    \since 4.2
+
+    Sets the item prototype for the model to the specified \a item. The model
+    takes ownership of the prototype.
+
+    The item prototype acts as a QStandardItem factory, by relying on the
+    QStandardItem::clone() function.  To provide your own prototype, subclass
+    QStandardItem, reimplement QStandardItem::clone() and set the prototype to
+    be an instance of your custom class. Whenever QStandardItemModel needs to
+    create an item on demand (for instance, when a view or item delegate calls
+    setData())), the new items will be instances of your custom class.
+
+    \sa itemPrototype(), QStandardItem::clone()
+*/
+void QStandardItemModel::setItemPrototype(const QStandardItem *item)
+{
+    Q_D(QStandardItemModel);
+    if (d->itemPrototype != item) {
+        delete d->itemPrototype;
+        d->itemPrototype = item;
+    }
+}
+
+/*!
+    \since 4.2
+
+    Returns the item prototype used by the model. The model uses the item
+    prototype as an item factory when it needs to construct new items on
+    demand (for instance, when a view or item delegate calls setData()).
+
+    \sa setItemPrototype()
+*/
+const QStandardItem *QStandardItemModel::itemPrototype() const
+{
+    Q_D(const QStandardItemModel);
+    return d->itemPrototype;
+}
+
+/*!
+    \since 4.2
+
+    Returns a list of items that match the given \a text, using the given \a
+    flags, in the given \a column.
+*/
+QList<QStandardItem*> QStandardItemModel::findItems(const QString &text,
+                                                    Qt::MatchFlags flags, int column) const
+{
+    QModelIndexList indexes = match(index(0, column, QModelIndex()),
+                                    Qt::DisplayRole, text, -1, flags);
+    QList<QStandardItem*> items;
+    for (int i = 0; i < indexes.size(); ++i)
+        items.append(itemFromIndex(indexes.at(i)));
+    return items;
+}
+
+/*!
+    \since 4.2
+
+    Appends a row containing \a items. If necessary, the column count is
+    increased to the size of \a items.
+
+    \sa insertRow(), appendColumn()
+*/
+void QStandardItemModel::appendRow(const QList<QStandardItem*> &items)
+{
+    invisibleRootItem()->appendRow(items);
+}
+
+/*!
+    \since 4.2
+
+    Appends a column containing \a items. If necessary, the row count is
+    increased to the size of \a items.
+
+    \sa insertColumn(), appendRow()
+*/
+void QStandardItemModel::appendColumn(const QList<QStandardItem*> &items)
+{
+    invisibleRootItem()->appendColumn(items);
+}
+
+/*!
+    \since 4.2
+    \fn QStandardItemModel::appendRow(QStandardItem *item)
+    \overload
+
+    When building a list or a tree that has only one column, this function
+    provides a convenient way to append a single new \a item.
+*/
+
+/*!
+    \since 4.2
+
+    Inserts a row at \a row containing \a items. If necessary, the column
+    count is increased to the size of \a items.
+
+    \sa takeRow(), appendRow(), insertColumn()
+*/
+void QStandardItemModel::insertRow(int row, const QList<QStandardItem*> &items)
+{
+    invisibleRootItem()->insertRow(row, items);
+}
+
+/*!
+    \since 4.2
+
+    \fn void QStandardItemModel::insertRow(int row, QStandardItem *item)
+    \overload
+
+    Inserts a row at \a row containing \a item.
+
+    When building a list or a tree that has only one column, this function
+    provides a convenient way to append a single new item.
+*/
+
+/*!
+    \since 4.2
+
+    Inserts a column at \a column containing \a items. If necessary, the row
+    count is increased to the size of \a items.
+
+    \sa takeColumn(), appendColumn(), insertRow()
+*/
+void QStandardItemModel::insertColumn(int column, const QList<QStandardItem*> &items)
+{
+    invisibleRootItem()->insertColumn(column, items);
+}
+
+/*!
+    \since 4.2
+
+    Removes the item at (\a row, \a column) without deleting it. The model
+    releases ownership of the item.
+
+    \sa item(), takeRow(), takeColumn()
+*/
+QStandardItem *QStandardItemModel::takeItem(int row, int column)
+{
+    Q_D(QStandardItemModel);
+    return d->root->takeChild(row, column);
+}
+
+/*!
+    \since 4.2
+
+    Removes the given \a row without deleting the row items, and returns a
+    list of pointers to the removed items. The model releases ownership of the
+    items. For items in the row that have not been set, the corresponding
+    pointers in the list will be 0.
+
+    \sa takeColumn()
+*/
+QList<QStandardItem*> QStandardItemModel::takeRow(int row)
+{
+    Q_D(QStandardItemModel);
+    return d->root->takeRow(row);
+}
+
+/*!
+    \since 4.2
+
+    Removes the given \a column without deleting the column items, and returns
+    a list of pointers to the removed items. The model releases ownership of
+    the items. For items in the column that have not been set, the
+    corresponding pointers in the list will be 0.
+
+    \sa takeRow()
+*/
+QList<QStandardItem*> QStandardItemModel::takeColumn(int column)
+{
+    Q_D(QStandardItemModel);
+    return d->root->takeColumn(column);
+}
+
+/*!
+    \since 4.2
+
+    Removes the horizontal header item at \a column from the header without
+    deleting it, and returns a pointer to the item. The model releases
+    ownership of the item.
+
+    \sa horizontalHeaderItem(), takeVerticalHeaderItem()
+*/
+QStandardItem *QStandardItemModel::takeHorizontalHeaderItem(int column)
+{
+    Q_D(QStandardItemModel);
+    if ((column < 0) || (column >= columnCount()))
+        return 0;
+    QStandardItem *headerItem = d->columnHeaderItems.at(column);
+    if (headerItem) {
+        headerItem->d_func()->setParentAndModel(0, 0);
+        d->columnHeaderItems.replace(column, 0);
+    }
+    return headerItem;
+}
+
+/*!
+    \since 4.2
+
+    Removes the vertical header item at \a row from the header without
+    deleting it, and returns a pointer to the item. The model releases
+    ownership of the item.
+
+    \sa verticalHeaderItem(), takeHorizontalHeaderItem()
+*/
+QStandardItem *QStandardItemModel::takeVerticalHeaderItem(int row)
+{
+    Q_D(QStandardItemModel);
+    if ((row < 0) || (row >= rowCount()))
+        return 0;
+    QStandardItem *headerItem = d->rowHeaderItems.at(row);
+    if (headerItem) {
+        headerItem->d_func()->setParentAndModel(0, 0);
+        d->rowHeaderItems.replace(row, 0);
+    }
+    return headerItem;
+}
+
+/*!
+    \since 4.2
+    \property QStandardItemModel::sortRole
+    \brief the item role that is used to query the model's data when sorting items
+
+    The default value is Qt::DisplayRole.
+
+    \sa sort(), QStandardItem::sortChildren()
+*/
+int QStandardItemModel::sortRole() const
+{
+    Q_D(const QStandardItemModel);
+    return d->sortRole;
+}
+
+void QStandardItemModel::setSortRole(int role)
+{
+    Q_D(QStandardItemModel);
+    d->sortRole = role;
+}
+
+/*!
+  \reimp
+*/
+int QStandardItemModel::columnCount(const QModelIndex &parent) const
+{
+    Q_D(const QStandardItemModel);
+    QStandardItem *item = d->itemFromIndex(parent);
+    return item ? item->columnCount() : 0;
+}
+
+/*!
+  \reimp
+*/
+QVariant QStandardItemModel::data(const QModelIndex &index, int role) const
+{
+    Q_D(const QStandardItemModel);
+    QStandardItem *item = d->itemFromIndex(index);
+    return item ? item->data(role) : QVariant();
+}
+
+/*!
+  \reimp
+*/
+Qt::ItemFlags QStandardItemModel::flags(const QModelIndex &index) const
+{
+    Q_D(const QStandardItemModel);
+    if (!d->indexValid(index))
+        return d->root->flags();
+    QStandardItem *item = d->itemFromIndex(index);
+    if (item)
+        return item->flags();
+    return Qt::ItemIsSelectable
+        |Qt::ItemIsEnabled
+        |Qt::ItemIsEditable
+        |Qt::ItemIsDragEnabled
+        |Qt::ItemIsDropEnabled;
+}
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::hasChildren(const QModelIndex &parent) const
+{
+    Q_D(const QStandardItemModel);
+    QStandardItem *item = d->itemFromIndex(parent);
+    return item ? item->hasChildren() : false;
+}
+
+/*!
+  \reimp
+*/
+QVariant QStandardItemModel::headerData(int section, Qt::Orientation orientation, int role) const
+{
+    Q_D(const QStandardItemModel);
+    if ((section < 0)
+        || ((orientation == Qt::Horizontal) && (section >= columnCount()))
+        || ((orientation == Qt::Vertical) && (section >= rowCount()))) {
+        return QVariant();
+    }
+    QStandardItem *headerItem = 0;
+    if (orientation == Qt::Horizontal)
+        headerItem = d->columnHeaderItems.at(section);
+    else if (orientation == Qt::Vertical)
+        headerItem = d->rowHeaderItems.at(section);
+    return headerItem ? headerItem->data(role)
+        : QAbstractItemModel::headerData(section, orientation, role);
+}
+
+/*!
+    \reimp
+
+    QStandardItemModel supports both copy and move.
+*/
+Qt::DropActions QStandardItemModel::supportedDropActions () const
+{
+    return Qt::CopyAction | Qt::MoveAction;
+}
+
+/*!
+  \reimp
+*/
+QModelIndex QStandardItemModel::index(int row, int column, const QModelIndex &parent) const
+{
+    Q_D(const QStandardItemModel);
+    QStandardItem *parentItem = d->itemFromIndex(parent);
+    if ((parentItem == 0)
+        || (row < 0)
+        || (column < 0)
+        || (row >= parentItem->rowCount())
+        || (column >= parentItem->columnCount())) {
+        return QModelIndex();
+    }
+    return createIndex(row, column, parentItem);
+}
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::insertColumns(int column, int count, const QModelIndex &parent)
+{
+    Q_D(QStandardItemModel);
+    QStandardItem *item = parent.isValid() ? itemFromIndex(parent) : d->root.data();
+    if (item == 0)
+        return false;
+    return item->d_func()->insertColumns(column, count, QList<QStandardItem*>());
+}
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::insertRows(int row, int count, const QModelIndex &parent)
+{
+    Q_D(QStandardItemModel);
+    QStandardItem *item = parent.isValid() ? itemFromIndex(parent) : d->root.data();
+    if (item == 0)
+        return false;
+    return item->d_func()->insertRows(row, count, QList<QStandardItem*>());
+}
+
+/*!
+  \reimp
+*/
+QMap<int, QVariant> QStandardItemModel::itemData(const QModelIndex &index) const
+{
+    Q_D(const QStandardItemModel);
+    QStandardItem *item = d->itemFromIndex(index);
+    return item ? item->d_func()->itemData() : QMap<int, QVariant>();
+}
+
+/*!
+  \reimp
+*/
+QModelIndex QStandardItemModel::parent(const QModelIndex &child) const
+{
+    Q_D(const QStandardItemModel);
+    if (!d->indexValid(child))
+        return QModelIndex();
+    QStandardItem *parentItem = static_cast<QStandardItem*>(child.internalPointer());
+    return indexFromItem(parentItem);
+}
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::removeColumns(int column, int count, const QModelIndex &parent)
+{
+    Q_D(QStandardItemModel);
+    QStandardItem *item = d->itemFromIndex(parent);
+    if ((item == 0) || (count < 1) || (column < 0) || ((column + count) > item->columnCount()))
+        return false;
+    item->removeColumns(column, count);
+    return true;
+}
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::removeRows(int row, int count, const QModelIndex &parent)
+{
+    Q_D(QStandardItemModel);
+    QStandardItem *item = d->itemFromIndex(parent);
+    if ((item == 0) || (count < 1) || (row < 0) || ((row + count) > item->rowCount()))
+        return false;
+    item->removeRows(row, count);
+    return true;
+}
+
+/*!
+  \reimp
+*/
+int QStandardItemModel::rowCount(const QModelIndex &parent) const
+{
+    Q_D(const QStandardItemModel);
+    QStandardItem *item = d->itemFromIndex(parent);
+    return item ? item->rowCount() : 0;
+}
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::setData(const QModelIndex &index, const QVariant &value, int role)
+{
+    if (!index.isValid())
+        return false;
+    QStandardItem *item = itemFromIndex(index);
+    if (item == 0)
+        return false;
+    item->setData(value, role);
+    return true;
+}
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
+{
+    Q_D(QStandardItemModel);
+    if ((section < 0)
+        || ((orientation == Qt::Horizontal) && (section >= columnCount()))
+        || ((orientation == Qt::Vertical) && (section >= rowCount()))) {
+        return false;
+    }
+    QStandardItem *headerItem = 0;
+    if (orientation == Qt::Horizontal) {
+        headerItem = d->columnHeaderItems.at(section);
+        if (headerItem == 0) {
+            headerItem = d->createItem();
+            headerItem->d_func()->setModel(this);
+            d->columnHeaderItems.replace(section, headerItem);
+        }
+    } else if (orientation == Qt::Vertical) {
+        headerItem = d->rowHeaderItems.at(section);
+        if (headerItem == 0) {
+            headerItem = d->createItem();
+            headerItem->d_func()->setModel(this);
+            d->rowHeaderItems.replace(section, headerItem);
+        }
+    }
+    if (headerItem) {
+        headerItem->setData(value, role);
+        return true;
+    }
+    return false;
+}
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles)
+{
+    QStandardItem *item = itemFromIndex(index);
+    if (item == 0)
+        return false;
+    item->d_func()->setItemData(roles);
+    return true;
+}
+
+/*!
+  \reimp
+*/
+void QStandardItemModel::sort(int column, Qt::SortOrder order)
+{
+    Q_D(QStandardItemModel);
+    d->root->sortChildren(column, order);
+}
+
+/*!
+  \fn QObject *QStandardItemModel::parent() const
+  \internal
+*/
+
+
+/*!
+  \reimp
+*/
+QStringList QStandardItemModel::mimeTypes() const
+{
+    return QAbstractItemModel::mimeTypes() <<  QLatin1String("application/x-qstandarditemmodeldatalist");
+}
+
+/*!
+  \reimp
+*/
+QMimeData *QStandardItemModel::mimeData(const QModelIndexList &indexes) const
+{
+    QMimeData *data = QAbstractItemModel::mimeData(indexes);
+    if(!data)
+        return 0;
+
+    QString format = QLatin1String("application/x-qstandarditemmodeldatalist");
+    if (!mimeTypes().contains(format))
+        return data;
+    QByteArray encoded;
+    QDataStream stream(&encoded, QIODevice::WriteOnly);
+    
+    QSet<QStandardItem*> itemsSet;
+    QStack<QStandardItem*> stack;
+    itemsSet.reserve(indexes.count());
+    stack.reserve(indexes.count());
+    for (int i = 0; i < indexes.count(); ++i) {
+        QStandardItem *item = itemFromIndex(indexes.at(i));
+        itemsSet << item;
+        stack.push(item);
+    }
+    
+    //remove duplicates childrens
+    {
+        QSet<QStandardItem *> seen;
+        while (!stack.isEmpty()) {
+            QStandardItem *itm = stack.pop();
+            if (seen.contains(itm))
+                continue;
+            seen.insert(itm);
+            
+            const QVector<QStandardItem*> &childList = itm->d_func()->children;
+            for (int i = 0; i < childList.count(); ++i) {
+                QStandardItem *chi = childList.at(i);
+                if (chi) {
+                    QSet<QStandardItem *>::iterator it = itemsSet.find(chi);
+                    if (it != itemsSet.end()) {
+                        itemsSet.erase(it);
+                    }
+                    stack.push(chi);
+                }
+            }
+        }
+    }
+    
+    stack.reserve(itemsSet.count());
+    foreach (QStandardItem *item, itemsSet) {
+        stack.push(item);
+    }
+    
+    //stream everything recursively
+    while (!stack.isEmpty()) {
+        QStandardItem *item = stack.pop();
+        if(itemsSet.contains(item)) { //if the item is selection 'top-level', strem its position
+            stream << item->row() << item->column(); 
+        }
+        if(item) {
+            stream << *item << item->columnCount() << item->d_ptr->children.count();
+            stack += item->d_ptr->children;
+        } else {
+            QStandardItem dummy;
+            stream << dummy << 0 << 0;
+        }
+    }
+
+    data->setData(format, encoded);
+    return data;
+}
+
+
+/* \internal
+    Used by QStandardItemModel::dropMimeData
+    stream out an item and his children 
+ */
+void QStandardItemModelPrivate::decodeDataRecursive(QDataStream &stream, QStandardItem *item)
+{
+    int colCount, childCount;
+    stream >> *item;
+    stream >> colCount >> childCount;
+    item->setColumnCount(colCount);
+    
+    int childPos = childCount;
+    
+    while(childPos > 0) {
+        childPos--;
+        QStandardItem *child = createItem();
+        decodeDataRecursive(stream, child);
+        item->setChild( childPos / colCount, childPos % colCount, child);
+    }
+}
+
+
+/*!
+  \reimp
+*/
+bool QStandardItemModel::dropMimeData(const QMimeData *data, Qt::DropAction action,
+                                      int row, int column, const QModelIndex &parent)
+{
+    Q_D(QStandardItemModel);
+    // check if the action is supported
+    if (!data || !(action == Qt::CopyAction || action == Qt::MoveAction))
+        return false;
+    // check if the format is supported
+    QString format = QLatin1String("application/x-qstandarditemmodeldatalist");
+    if (!data->hasFormat(format))
+        return QAbstractItemModel::dropMimeData(data, action, row, column, parent);
+
+    if (row > rowCount(parent))
+        row = rowCount(parent);
+    if (row == -1)
+        row = rowCount(parent);
+    if (column == -1)
+        column = 0;
+
+    // decode and insert
+    QByteArray encoded = data->data(format);
+    QDataStream stream(&encoded, QIODevice::ReadOnly);
+
+
+    //code based on QAbstractItemModel::decodeData
+    // adapted to work with QStandardItem
+    int top = INT_MAX;
+    int left = INT_MAX;
+    int bottom = 0;
+    int right = 0;
+    QVector<int> rows, columns;
+    QVector<QStandardItem *> items;
+
+    while (!stream.atEnd()) {
+        int r, c;
+        QStandardItem *item = d->createItem();
+        stream >> r >> c;
+        d->decodeDataRecursive(stream, item);
+
+        rows.append(r);
+        columns.append(c);
+        items.append(item);
+        top = qMin(r, top);
+        left = qMin(c, left);
+        bottom = qMax(r, bottom);
+        right = qMax(c, right);
+    }
+
+    // insert the dragged items into the table, use a bit array to avoid overwriting items,
+    // since items from different tables can have the same row and column
+    int dragRowCount = 0;
+    int dragColumnCount = right - left + 1;
+
+    // Compute the number of continuous rows upon insertion and modify the rows to match
+    QVector<int> rowsToInsert(bottom + 1);
+    for (int i = 0; i < rows.count(); ++i)
+        rowsToInsert[rows.at(i)] = 1;
+    for (int i = 0; i < rowsToInsert.count(); ++i) {
+        if (rowsToInsert[i] == 1){
+            rowsToInsert[i] = dragRowCount;
+            ++dragRowCount;
+        }
+    }
+    for (int i = 0; i < rows.count(); ++i)
+        rows[i] = top + rowsToInsert[rows[i]];
+
+    QBitArray isWrittenTo(dragRowCount * dragColumnCount);
+
+    // make space in the table for the dropped data
+    int colCount = columnCount(parent);
+    if (colCount < dragColumnCount + column) {
+        insertColumns(colCount, dragColumnCount + column - colCount, parent);
+        colCount = columnCount(parent);
+    }
+    insertRows(row, dragRowCount, parent);
+
+    row = qMax(0, row);
+    column = qMax(0, column);
+
+    QStandardItem *parentItem = itemFromIndex (parent);
+    if (!parentItem)
+        parentItem = invisibleRootItem();
+
+    QVector<QPersistentModelIndex> newIndexes(items.size());
+    // set the data in the table
+    for (int j = 0; j < items.size(); ++j) {
+        int relativeRow = rows.at(j) - top;
+        int relativeColumn = columns.at(j) - left;
+        int destinationRow = relativeRow + row;
+        int destinationColumn = relativeColumn + column;
+        int flat = (relativeRow * dragColumnCount) + relativeColumn;
+        // if the item was already written to, or we just can't fit it in the table, create a new row
+        if (destinationColumn >= colCount || isWrittenTo.testBit(flat)) {
+            destinationColumn = qBound(column, destinationColumn, colCount - 1);
+            destinationRow = row + dragRowCount;
+            insertRows(row + dragRowCount, 1, parent);
+            flat = (dragRowCount * dragColumnCount) + relativeColumn;
+            isWrittenTo.resize(++dragRowCount * dragColumnCount);
+        }
+        if (!isWrittenTo.testBit(flat)) {
+            newIndexes[j] = index(destinationRow, destinationColumn, parentItem->index());
+            isWrittenTo.setBit(flat);
+        }
+    }
+
+    for(int k = 0; k < newIndexes.size(); k++) {
+        if (newIndexes.at(k).isValid()) {
+            parentItem->setChild(newIndexes.at(k).row(), newIndexes.at(k).column(), items.at(k));
+        } else {
+            delete items.at(k);
+        }
+    }
+
+    return true;
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qstandarditemmodel.cpp"
+
+#endif // QT_NO_STANDARDITEMMODEL
diff --git a/src/gui/itemmodels/qstandarditemmodel.h b/src/gui/itemmodels/qstandarditemmodel.h
new file mode 100644
index 0000000..8b3bc1c
--- /dev/null
+++ b/src/gui/itemmodels/qstandarditemmodel.h
@@ -0,0 +1,457 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSTANDARDITEMMODEL_H
+#define QSTANDARDITEMMODEL_H
+
+#include <QtCore/qabstractitemmodel.h>
+#include <QtGui/qbrush.h>
+#include <QtGui/qfont.h>
+#include <QtGui/qicon.h>
+#ifndef QT_NO_DATASTREAM
+#include <QtCore/qdatastream.h>
+#endif
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+
+#ifndef QT_NO_STANDARDITEMMODEL
+
+template <class T> class QList;
+
+class QStandardItemModel;
+
+class QStandardItemPrivate;
+class Q_GUI_EXPORT QStandardItem
+{
+public:
+    QStandardItem();
+    explicit QStandardItem(const QString &text);
+    QStandardItem(const QIcon &icon, const QString &text);
+    explicit QStandardItem(int rows, int columns = 1);
+    virtual ~QStandardItem();
+
+    virtual QVariant data(int role = Qt::UserRole + 1) const;
+    virtual void setData(const QVariant &value, int role = Qt::UserRole + 1);
+
+    inline QString text() const {
+        return qvariant_cast<QString>(data(Qt::DisplayRole));
+    }
+    inline void setText(const QString &text);
+
+    inline QIcon icon() const {
+        return qvariant_cast<QIcon>(data(Qt::DecorationRole));
+    }
+    inline void setIcon(const QIcon &icon);
+
+#ifndef QT_NO_TOOLTIP
+    inline QString toolTip() const {
+        return qvariant_cast<QString>(data(Qt::ToolTipRole));
+    }
+    inline void setToolTip(const QString &toolTip);
+#endif
+
+#ifndef QT_NO_STATUSTIP
+    inline QString statusTip() const {
+        return qvariant_cast<QString>(data(Qt::StatusTipRole));
+    }
+    inline void setStatusTip(const QString &statusTip);
+#endif
+
+#ifndef QT_NO_WHATSTHIS
+    inline QString whatsThis() const {
+        return qvariant_cast<QString>(data(Qt::WhatsThisRole));
+    }
+    inline void setWhatsThis(const QString &whatsThis);
+#endif
+
+    inline QSize sizeHint() const {
+        return qvariant_cast<QSize>(data(Qt::SizeHintRole));
+    }
+    inline void setSizeHint(const QSize &sizeHint);
+
+    inline QFont font() const {
+        return qvariant_cast<QFont>(data(Qt::FontRole));
+    }
+    inline void setFont(const QFont &font);
+
+    inline Qt::Alignment textAlignment() const {
+        return Qt::Alignment(qvariant_cast<int>(data(Qt::TextAlignmentRole)));
+    }
+    inline void setTextAlignment(Qt::Alignment textAlignment);
+
+    inline QBrush background() const {
+        return qvariant_cast<QBrush>(data(Qt::BackgroundRole));
+    }
+    inline void setBackground(const QBrush &brush);
+
+    inline QBrush foreground() const {
+        return qvariant_cast<QBrush>(data(Qt::ForegroundRole));
+    }
+    inline void setForeground(const QBrush &brush);
+
+    inline Qt::CheckState checkState() const {
+        return Qt::CheckState(qvariant_cast<int>(data(Qt::CheckStateRole)));
+    }
+    inline void setCheckState(Qt::CheckState checkState);
+
+    inline QString accessibleText() const {
+        return qvariant_cast<QString>(data(Qt::AccessibleTextRole));
+    }
+    inline void setAccessibleText(const QString &accessibleText);
+
+    inline QString accessibleDescription() const {
+        return qvariant_cast<QString>(data(Qt::AccessibleDescriptionRole));
+    }
+    inline void setAccessibleDescription(const QString &accessibleDescription);
+
+    Qt::ItemFlags flags() const;
+    void setFlags(Qt::ItemFlags flags);
+
+    inline bool isEnabled() const {
+        return (flags() & Qt::ItemIsEnabled) != 0;
+    }
+    void setEnabled(bool enabled);
+
+    inline bool isEditable() const {
+        return (flags() & Qt::ItemIsEditable) != 0;
+    }
+    void setEditable(bool editable);
+
+    inline bool isSelectable() const {
+        return (flags() & Qt::ItemIsSelectable) != 0;
+    }
+    void setSelectable(bool selectable);
+
+    inline bool isCheckable() const {
+        return (flags() & Qt::ItemIsUserCheckable) != 0;
+    }
+    void setCheckable(bool checkable);
+
+    inline bool isTristate() const {
+        return (flags() & Qt::ItemIsTristate) != 0;
+    }
+    void setTristate(bool tristate);
+
+#ifndef QT_NO_DRAGANDDROP
+    inline bool isDragEnabled() const {
+        return (flags() & Qt::ItemIsDragEnabled) != 0;
+    }
+    void setDragEnabled(bool dragEnabled);
+
+    inline bool isDropEnabled() const {
+        return (flags() & Qt::ItemIsDropEnabled) != 0;
+    }
+    void setDropEnabled(bool dropEnabled);
+#endif // QT_NO_DRAGANDDROP
+
+    QStandardItem *parent() const;
+    int row() const;
+    int column() const;
+    QModelIndex index() const;
+    QStandardItemModel *model() const;
+
+    int rowCount() const;
+    void setRowCount(int rows);
+    int columnCount() const;
+    void setColumnCount(int columns);
+
+    bool hasChildren() const;
+    QStandardItem *child(int row, int column = 0) const;
+    void setChild(int row, int column, QStandardItem *item);
+    inline void setChild(int row, QStandardItem *item);
+
+    void insertRow(int row, const QList<QStandardItem*> &items);
+    void insertColumn(int column, const QList<QStandardItem*> &items);
+    void insertRows(int row, const QList<QStandardItem*> &items);
+    void insertRows(int row, int count);
+    void insertColumns(int column, int count);
+
+    void removeRow(int row);
+    void removeColumn(int column);
+    void removeRows(int row, int count);
+    void removeColumns(int column, int count);
+
+    inline void appendRow(const QList<QStandardItem*> &items);
+    inline void appendRows(const QList<QStandardItem*> &items);
+    inline void appendColumn(const QList<QStandardItem*> &items);
+    inline void insertRow(int row, QStandardItem *item);
+    inline void appendRow(QStandardItem *item);
+
+    QStandardItem *takeChild(int row, int column = 0);
+    QList<QStandardItem*> takeRow(int row);
+    QList<QStandardItem*> takeColumn(int column);
+
+    void sortChildren(int column, Qt::SortOrder order = Qt::AscendingOrder);
+
+    virtual QStandardItem *clone() const;
+
+    enum ItemType { Type = 0, UserType = 1000 };
+    virtual int type() const;
+
+#ifndef QT_NO_DATASTREAM
+    virtual void read(QDataStream &in);
+    virtual void write(QDataStream &out) const;
+#endif
+    virtual bool operator<(const QStandardItem &other) const;
+
+protected:
+    QStandardItem(const QStandardItem &other);
+    QStandardItem(QStandardItemPrivate &dd);
+    QStandardItem &operator=(const QStandardItem &other);
+    QScopedPointer<QStandardItemPrivate> d_ptr;
+
+    void emitDataChanged();
+
+private:
+    Q_DECLARE_PRIVATE(QStandardItem)
+    friend class QStandardItemModelPrivate;
+    friend class QStandardItemModel;
+};
+
+inline void QStandardItem::setText(const QString &atext)
+{ setData(atext, Qt::DisplayRole); }
+
+inline void QStandardItem::setIcon(const QIcon &aicon)
+{ setData(aicon, Qt::DecorationRole); }
+
+#ifndef QT_NO_TOOLTIP
+inline void QStandardItem::setToolTip(const QString &atoolTip)
+{ setData(atoolTip, Qt::ToolTipRole); }
+#endif
+
+#ifndef QT_NO_STATUSTIP
+inline void QStandardItem::setStatusTip(const QString &astatusTip)
+{ setData(astatusTip, Qt::StatusTipRole); }
+#endif
+
+#ifndef QT_NO_WHATSTHIS
+inline void QStandardItem::setWhatsThis(const QString &awhatsThis)
+{ setData(awhatsThis, Qt::WhatsThisRole); }
+#endif
+
+inline void QStandardItem::setSizeHint(const QSize &asizeHint)
+{ setData(asizeHint, Qt::SizeHintRole); }
+
+inline void QStandardItem::setFont(const QFont &afont)
+{ setData(afont, Qt::FontRole); }
+
+inline void QStandardItem::setTextAlignment(Qt::Alignment atextAlignment)
+{ setData(int(atextAlignment), Qt::TextAlignmentRole); }
+
+inline void QStandardItem::setBackground(const QBrush &abrush)
+{ setData(abrush, Qt::BackgroundRole); }
+
+inline void QStandardItem::setForeground(const QBrush &abrush)
+{ setData(abrush, Qt::ForegroundRole); }
+
+inline void QStandardItem::setCheckState(Qt::CheckState acheckState)
+{ setData(acheckState, Qt::CheckStateRole); }
+
+inline void QStandardItem::setAccessibleText(const QString &aaccessibleText)
+{ setData(aaccessibleText, Qt::AccessibleTextRole); }
+
+inline void QStandardItem::setAccessibleDescription(const QString &aaccessibleDescription)
+{ setData(aaccessibleDescription, Qt::AccessibleDescriptionRole); }
+
+inline void QStandardItem::setChild(int arow, QStandardItem *aitem)
+{ setChild(arow, 0, aitem); }
+
+inline void QStandardItem::appendRow(const QList<QStandardItem*> &aitems)
+{ insertRow(rowCount(), aitems); }
+
+inline void QStandardItem::appendRows(const QList<QStandardItem*> &aitems)
+{ insertRows(rowCount(), aitems); }
+
+inline void QStandardItem::appendColumn(const QList<QStandardItem*> &aitems)
+{ insertColumn(columnCount(), aitems); }
+
+inline void QStandardItem::insertRow(int arow, QStandardItem *aitem)
+{ insertRow(arow, QList<QStandardItem*>() << aitem); }
+
+inline void QStandardItem::appendRow(QStandardItem *aitem)
+{ insertRow(rowCount(), aitem); }
+
+class QStandardItemModelPrivate;
+
+class Q_GUI_EXPORT QStandardItemModel : public QAbstractItemModel
+{
+    Q_OBJECT
+    Q_PROPERTY(int sortRole READ sortRole WRITE setSortRole)
+
+public:
+    explicit QStandardItemModel(QObject *parent = 0);
+    QStandardItemModel(int rows, int columns, QObject *parent = 0);
+    ~QStandardItemModel();
+
+    void setItemRoleNames(const QHash<int,QByteArray> &roleNames);
+
+    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
+    QModelIndex parent(const QModelIndex &child) const;
+
+    int rowCount(const QModelIndex &parent = QModelIndex()) const;
+    int columnCount(const QModelIndex &parent = QModelIndex()) const;
+    bool hasChildren(const QModelIndex &parent = QModelIndex()) const;
+
+    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
+    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);
+
+    QVariant headerData(int section, Qt::Orientation orientation,
+                        int role = Qt::DisplayRole) const;
+    bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
+                       int role = Qt::EditRole);
+
+    bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
+    bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
+    bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
+    bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());
+
+    Qt::ItemFlags flags(const QModelIndex &index) const;
+    Qt::DropActions supportedDropActions() const;
+
+    QMap<int, QVariant> itemData(const QModelIndex &index) const;
+    bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);
+
+    void clear();
+
+#ifdef Q_NO_USING_KEYWORD
+    inline QObject *parent() const { return QObject::parent(); }
+#else
+    using QObject::parent;
+#endif
+
+    void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);
+
+    QStandardItem *itemFromIndex(const QModelIndex &index) const;
+    QModelIndex indexFromItem(const QStandardItem *item) const;
+
+    QStandardItem *item(int row, int column = 0) const;
+    void setItem(int row, int column, QStandardItem *item);
+    inline void setItem(int row, QStandardItem *item);
+    QStandardItem *invisibleRootItem() const;
+
+    QStandardItem *horizontalHeaderItem(int column) const;
+    void setHorizontalHeaderItem(int column, QStandardItem *item);
+    QStandardItem *verticalHeaderItem(int row) const;
+    void setVerticalHeaderItem(int row, QStandardItem *item);
+
+    void setHorizontalHeaderLabels(const QStringList &labels);
+    void setVerticalHeaderLabels(const QStringList &labels);
+
+    void setRowCount(int rows);
+    void setColumnCount(int columns);
+
+    void appendRow(const QList<QStandardItem*> &items);
+    void appendColumn(const QList<QStandardItem*> &items);
+    inline void appendRow(QStandardItem *item);
+
+    void insertRow(int row, const QList<QStandardItem*> &items);
+    void insertColumn(int column, const QList<QStandardItem*> &items);
+    inline void insertRow(int row, QStandardItem *item);
+
+    inline bool insertRow(int row, const QModelIndex &parent = QModelIndex());
+    inline bool insertColumn(int column, const QModelIndex &parent = QModelIndex());
+
+    QStandardItem *takeItem(int row, int column = 0);
+    QList<QStandardItem*> takeRow(int row);
+    QList<QStandardItem*> takeColumn(int column);
+
+    QStandardItem *takeHorizontalHeaderItem(int column);
+    QStandardItem *takeVerticalHeaderItem(int row);
+
+    const QStandardItem *itemPrototype() const;
+    void setItemPrototype(const QStandardItem *item);
+
+    QList<QStandardItem*> findItems(const QString &text,
+                                    Qt::MatchFlags flags = Qt::MatchExactly,
+                                    int column = 0) const;
+
+    int sortRole() const;
+    void setSortRole(int role);
+
+    QStringList mimeTypes() const;
+    QMimeData *mimeData(const QModelIndexList &indexes) const;
+    bool dropMimeData (const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &parent);
+
+Q_SIGNALS:
+    void itemChanged(QStandardItem *item);
+
+protected:
+    QStandardItemModel(QStandardItemModelPrivate &dd, QObject *parent = 0);
+
+private:
+    friend class QStandardItemPrivate;
+    friend class QStandardItem;
+    Q_DISABLE_COPY(QStandardItemModel)
+    Q_DECLARE_PRIVATE(QStandardItemModel)
+
+    Q_PRIVATE_SLOT(d_func(), void _q_emitItemChanged(const QModelIndex &topLeft,
+                                                     const QModelIndex &bottomRight))
+};
+
+inline void QStandardItemModel::setItem(int arow, QStandardItem *aitem)
+{ setItem(arow, 0, aitem); }
+
+inline void QStandardItemModel::appendRow(QStandardItem *aitem)
+{ appendRow(QList<QStandardItem*>() << aitem); }
+
+inline void QStandardItemModel::insertRow(int arow, QStandardItem *aitem)
+{ insertRow(arow, QList<QStandardItem*>() << aitem); }
+
+inline bool QStandardItemModel::insertRow(int arow, const QModelIndex &aparent)
+{ return QAbstractItemModel::insertRow(arow, aparent); }
+inline bool QStandardItemModel::insertColumn(int acolumn, const QModelIndex &aparent)
+{ return QAbstractItemModel::insertColumn(acolumn, aparent); }
+
+#ifndef QT_NO_DATASTREAM
+Q_GUI_EXPORT QDataStream &operator>>(QDataStream &in, QStandardItem &item);
+Q_GUI_EXPORT QDataStream &operator<<(QDataStream &out, const QStandardItem &item);
+#endif
+
+#endif // QT_NO_STANDARDITEMMODEL
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif //QSTANDARDITEMMODEL_H
diff --git a/src/gui/itemmodels/qstandarditemmodel_p.h b/src/gui/itemmodels/qstandarditemmodel_p.h
new file mode 100644
index 0000000..ba43bbd
--- /dev/null
+++ b/src/gui/itemmodels/qstandarditemmodel_p.h
@@ -0,0 +1,219 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSTANDARDITEMMODEL_P_H
+#define QSTANDARDITEMMODEL_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of other Qt classes.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "private/qabstractitemmodel_p.h"
+
+#ifndef QT_NO_STANDARDITEMMODEL
+
+#include <QtCore/qlist.h>
+#include <QtCore/qpair.h>
+#include <QtCore/qstack.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qvector.h>
+
+QT_BEGIN_NAMESPACE
+
+class QStandardItemData
+{
+public:
+    inline QStandardItemData() : role(-1) {}
+    inline QStandardItemData(int r, QVariant v) : role(r), value(v) {}
+    int role;
+    QVariant value;
+    inline bool operator==(const QStandardItemData &other) const { return role == other.role && value == other.value; }
+};
+
+#ifndef QT_NO_DATASTREAM
+
+inline QDataStream &operator>>(QDataStream &in, QStandardItemData &data)
+{
+    in >> data.role;
+    in >> data.value;
+    return in;
+}
+
+inline QDataStream &operator<<(QDataStream &out, const QStandardItemData &data)
+{
+    out << data.role;
+    out << data.value;
+    return out;
+}
+
+#endif // QT_NO_DATASTREAM
+
+class QStandardItemPrivate
+{
+    Q_DECLARE_PUBLIC(QStandardItem)
+public:
+    inline QStandardItemPrivate()
+        : model(0),
+          parent(0),
+          rows(0),
+          columns(0),
+          q_ptr(0),
+          lastIndexOf(2)
+        { }
+    virtual ~QStandardItemPrivate();
+
+    inline int childIndex(int row, int column) const {
+        if ((row < 0) || (column < 0)
+            || (row >= rowCount()) || (column >= columnCount())) {
+            return -1;
+        }
+        return (row * columnCount()) + column;
+    }
+    inline int childIndex(const QStandardItem *child) {
+        int start = qMax(0, lastIndexOf -2);
+        lastIndexOf = children.indexOf(const_cast<QStandardItem*>(child), start);
+        if (lastIndexOf == -1 && start != 0)
+            lastIndexOf = children.lastIndexOf(const_cast<QStandardItem*>(child), start);
+        return lastIndexOf;
+    }
+    QPair<int, int> position() const;
+    void setChild(int row, int column, QStandardItem *item,
+                  bool emitChanged = false);
+    inline int rowCount() const {
+        return rows;
+    }
+    inline int columnCount() const {
+        return columns;
+    }
+    void childDeleted(QStandardItem *child);
+
+    void setModel(QStandardItemModel *mod);
+
+    inline void setParentAndModel(
+        QStandardItem *par,
+        QStandardItemModel *mod) {
+        setModel(mod);
+        parent = par;
+    }
+
+    void changeFlags(bool enable, Qt::ItemFlags f);
+    void setItemData(const QMap<int, QVariant> &roles);
+    const QMap<int, QVariant> itemData() const;
+
+    bool insertRows(int row, int count, const QList<QStandardItem*> &items);
+    bool insertRows(int row, const QList<QStandardItem*> &items);
+    bool insertColumns(int column, int count, const QList<QStandardItem*> &items);
+
+    void sortChildren(int column, Qt::SortOrder order);
+
+    QStandardItemModel *model;
+    QStandardItem *parent;
+    QVector<QStandardItemData> values;
+    QVector<QStandardItem*> children;
+    int rows;
+    int columns;
+
+    QStandardItem *q_ptr;
+
+    int lastIndexOf;
+};
+
+class QStandardItemModelPrivate : public QAbstractItemModelPrivate
+{
+    Q_DECLARE_PUBLIC(QStandardItemModel)
+
+public:
+    QStandardItemModelPrivate();
+    virtual ~QStandardItemModelPrivate();
+
+    void init();
+
+    inline QStandardItem *createItem() const {
+        return itemPrototype ? itemPrototype->clone() : new QStandardItem;
+    }
+
+    inline QStandardItem *itemFromIndex(const QModelIndex &index) const {
+        Q_Q(const QStandardItemModel);
+        if (!index.isValid())
+            return root.data();
+        if (index.model() != q)
+            return 0;
+        QStandardItem *parent = static_cast<QStandardItem*>(index.internalPointer());
+        if (parent == 0)
+            return 0;
+        return parent->child(index.row(), index.column());
+    }
+
+    void sort(QStandardItem *parent, int column, Qt::SortOrder order);
+    void itemChanged(QStandardItem *item);
+    void rowsAboutToBeInserted(QStandardItem *parent, int start, int end);
+    void columnsAboutToBeInserted(QStandardItem *parent, int start, int end);
+    void rowsAboutToBeRemoved(QStandardItem *parent, int start, int end);
+    void columnsAboutToBeRemoved(QStandardItem *parent, int start, int end);
+    void rowsInserted(QStandardItem *parent, int row, int count);
+    void columnsInserted(QStandardItem *parent, int column, int count);
+    void rowsRemoved(QStandardItem *parent, int row, int count);
+    void columnsRemoved(QStandardItem *parent, int column, int count);
+
+    void _q_emitItemChanged(const QModelIndex &topLeft,
+                            const QModelIndex &bottomRight);
+
+    void decodeDataRecursive(QDataStream &stream, QStandardItem *item);
+
+    QVector<QStandardItem*> columnHeaderItems;
+    QVector<QStandardItem*> rowHeaderItems;
+    QScopedPointer<QStandardItem> root;
+    const QStandardItem *itemPrototype;
+    int sortRole;
+};
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_STANDARDITEMMODEL
+
+#endif // QSTANDARDITEMMODEL_P_H
diff --git a/src/widgets/itemviews/itemviews.pri b/src/widgets/itemviews/itemviews.pri
index d5a5012..fa44b0b 100644
--- a/src/widgets/itemviews/itemviews.pri
+++ b/src/widgets/itemviews/itemviews.pri
@@ -25,8 +25,6 @@ HEADERS += \
 	itemviews/qproxymodel_p.h \
 	itemviews/qitemeditorfactory.h \
 	itemviews/qitemeditorfactory_p.h \
-	itemviews/qstandarditemmodel.h \
-	itemviews/qstandarditemmodel_p.h \
 	itemviews/qtreewidgetitemiterator.h \
     itemviews/qdatawidgetmapper.h \
     itemviews/qfileiconprovider.h \
@@ -50,7 +48,6 @@ SOURCES += \
 	itemviews/qtreewidget.cpp \
 	itemviews/qproxymodel.cpp \
 	itemviews/qitemeditorfactory.cpp \
-	itemviews/qstandarditemmodel.cpp \
 	itemviews/qtreewidgetitemiterator.cpp \
     itemviews/qdatawidgetmapper.cpp \
     itemviews/qfileiconprovider.cpp \
diff --git a/src/widgets/itemviews/qstandarditemmodel.cpp b/src/widgets/itemviews/qstandarditemmodel.cpp
deleted file mode 100644
index 45ffa24..0000000
--- a/src/widgets/itemviews/qstandarditemmodel.cpp
+++ /dev/null
@@ -1,3129 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qstandarditemmodel.h"
-
-#ifndef QT_NO_STANDARDITEMMODEL
-
-#include <QtCore/qdatetime.h>
-#include <QtCore/qlist.h>
-#include <QtCore/qmap.h>
-#include <QtCore/qpair.h>
-#include <QtCore/qvariant.h>
-#include <QtCore/qvector.h>
-#include <QtCore/qstringlist.h>
-#include <QtCore/qbitarray.h>
-#include <QtCore/qmimedata.h>
-
-#include <private/qstandarditemmodel_p.h>
-#include <qdebug.h>
-
-QT_BEGIN_NAMESPACE
-
-class QStandardItemModelLessThan
-{
-public:
-    inline QStandardItemModelLessThan()
-        { }
-
-    inline bool operator()(const QPair<QStandardItem*, int> &l,
-                           const QPair<QStandardItem*, int> &r) const
-    {
-        return *(l.first) < *(r.first);
-    }
-};
-
-class QStandardItemModelGreaterThan
-{
-public:
-    inline QStandardItemModelGreaterThan()
-        { }
-
-    inline bool operator()(const QPair<QStandardItem*, int> &l,
-                           const QPair<QStandardItem*, int> &r) const
-    {
-        return *(r.first) < *(l.first);
-    }
-};
-
-/*!
-  \internal
-*/
-QStandardItemPrivate::~QStandardItemPrivate()
-{
-    QVector<QStandardItem*>::const_iterator it;
-    for (it = children.constBegin(); it != children.constEnd(); ++it) {
-        QStandardItem *child = *it;
-        if (child)
-            child->d_func()->setModel(0);
-        delete child;
-    }
-    children.clear();
-    if (parent && model)
-        parent->d_func()->childDeleted(q_func());
-}
-
-/*!
-  \internal
-*/
-QPair<int, int> QStandardItemPrivate::position() const
-{
-    if (QStandardItem *par = parent) {
-        int idx = par->d_func()->childIndex(q_func());
-        if (idx == -1)
-            return QPair<int, int>(-1, -1);
-        return QPair<int, int>(idx / par->columnCount(), idx % par->columnCount());
-    }
-    // ### support header items?
-    return QPair<int, int>(-1, -1);
-}
-
-/*!
-  \internal
-*/
-void QStandardItemPrivate::setChild(int row, int column, QStandardItem *item,
-                                    bool emitChanged)
-{
-    Q_Q(QStandardItem);
-    if (item == q) {
-        qWarning("QStandardItem::setChild: Can't make an item a child of itself %p",
-                 item);
-        return;
-    }
-    if ((row < 0) || (column < 0))
-        return;
-    if (rows <= row)
-        q->setRowCount(row + 1);
-    if (columns <= column)
-        q->setColumnCount(column + 1);
-    int index = childIndex(row, column);
-    Q_ASSERT(index != -1);
-    QStandardItem *oldItem = children.at(index);
-    if (item == oldItem)
-        return;
-    if (item) {
-        if (item->d_func()->parent == 0) {
-            item->d_func()->setParentAndModel(q, model);
-        } else {
-            qWarning("QStandardItem::setChild: Ignoring duplicate insertion of item %p",
-                     item);
-            return;
-        }
-    }
-    if (oldItem)
-        oldItem->d_func()->setModel(0);
-    delete oldItem;
-    children.replace(index, item);
-    if (emitChanged && model)
-        model->d_func()->itemChanged(item);
-}
-
-
-/*!
-  \internal
-*/
-void QStandardItemPrivate::changeFlags(bool enable, Qt::ItemFlags f)
-{
-    Q_Q(QStandardItem);
-    Qt::ItemFlags flags = q->flags();
-    if (enable)
-        flags |= f;
-    else
-        flags &= ~f;
-    q->setFlags(flags);
-}
-
-/*!
-  \internal
-*/
-void QStandardItemPrivate::childDeleted(QStandardItem *child)
-{
-    int index = childIndex(child);
-    Q_ASSERT(index != -1);
-    children.replace(index, 0);
-}
-
-/*!
-  \internal
-*/
-void QStandardItemPrivate::setItemData(const QMap<int, QVariant> &roles)
-{
-    Q_Q(QStandardItem);
-
-    //let's build the vector of new values
-    QVector<QWidgetItemData> newValues;
-    QMap<int, QVariant>::const_iterator it;
-    for (it = roles.begin(); it != roles.end(); ++it) {
-        QVariant value = it.value();
-        if (value.isValid()) {
-            int role = it.key();
-            role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
-            QWidgetItemData wid(role,it.value());
-            newValues.append(wid);
-        }
-    }
-
-    if (values!=newValues) {
-        values=newValues;
-        if (model)
-            model->d_func()->itemChanged(q);
-    }
-}
-
-/*!
-  \internal
-*/
-const QMap<int, QVariant> QStandardItemPrivate::itemData() const
-{
-    QMap<int, QVariant> result;
-    QVector<QWidgetItemData>::const_iterator it;
-    for (it = values.begin(); it != values.end(); ++it)
-        result.insert((*it).role, (*it).value);
-    return result;
-}
-
-/*!
-  \internal
-*/
-void QStandardItemPrivate::sortChildren(int column, Qt::SortOrder order)
-{
-    Q_Q(QStandardItem);
-    if (column >= columnCount())
-        return;
-
-    QVector<QPair<QStandardItem*, int> > sortable;
-    QVector<int> unsortable;
-
-    sortable.reserve(rowCount());
-    unsortable.reserve(rowCount());
-
-    for (int row = 0; row < rowCount(); ++row) {
-        QStandardItem *itm = q->child(row, column);
-        if (itm)
-            sortable.append(QPair<QStandardItem*,int>(itm, row));
-        else
-            unsortable.append(row);
-    }
-
-    if (order == Qt::AscendingOrder) {
-        QStandardItemModelLessThan lt;
-        qStableSort(sortable.begin(), sortable.end(), lt);
-    } else {
-        QStandardItemModelGreaterThan gt;
-        qStableSort(sortable.begin(), sortable.end(), gt);
-    }
-
-    QModelIndexList changedPersistentIndexesFrom, changedPersistentIndexesTo;
-    QVector<QStandardItem*> sorted_children(children.count());
-    for (int i = 0; i < rowCount(); ++i) {
-        int r = (i < sortable.count()
-                 ? sortable.at(i).second
-                 : unsortable.at(i - sortable.count()));
-        for (int c = 0; c < columnCount(); ++c) {
-            QStandardItem *itm = q->child(r, c);
-            sorted_children[childIndex(i, c)] = itm;
-            if (model) {
-                QModelIndex from = model->createIndex(r, c, q);
-                if (model->d_func()->persistent.indexes.contains(from)) {
-                    QModelIndex to = model->createIndex(i, c, q);
-                    changedPersistentIndexesFrom.append(from);
-                    changedPersistentIndexesTo.append(to);
-                }
-            }
-        }
-    }
-
-    children = sorted_children;
-
-    if (model) {
-        model->changePersistentIndexList(changedPersistentIndexesFrom, changedPersistentIndexesTo);
-    }
-
-    QVector<QStandardItem*>::iterator it;
-    for (it = children.begin(); it != children.end(); ++it) {
-        if (*it)
-            (*it)->d_func()->sortChildren(column, order);
-    }
-}
-
-/*!
-  \internal
-  set the model of this item and all its children
-  */
-void QStandardItemPrivate::setModel(QStandardItemModel *mod)
-{
-    if (children.isEmpty()) {
-        if (model)
-            model->d_func()->invalidatePersistentIndex(model->indexFromItem(q_ptr));
-        model = mod;
-    } else {
-        QStack<QStandardItem*> stack;
-        stack.push(q_ptr);
-        while (!stack.isEmpty()) {
-            QStandardItem *itm = stack.pop();
-            if (itm->d_func()->model) {
-                itm->d_func()->model->d_func()->invalidatePersistentIndex(itm->d_func()->model->indexFromItem(itm));
-            }
-            itm->d_func()->model = mod;
-            const QVector<QStandardItem*> &childList = itm->d_func()->children;
-            for (int i = 0; i < childList.count(); ++i) {
-                QStandardItem *chi = childList.at(i);
-                if (chi)
-                    stack.push(chi);
-            }
-        }
-    }
-}
-
-/*!
-  \internal
-*/
-QStandardItemModelPrivate::QStandardItemModelPrivate()
-    : root(new QStandardItem),
-      itemPrototype(0),
-      sortRole(Qt::DisplayRole)
-{
-    root->setFlags(Qt::ItemIsDropEnabled);
-}
-
-/*!
-  \internal
-*/
-QStandardItemModelPrivate::~QStandardItemModelPrivate()
-{
-    delete itemPrototype;
-    qDeleteAll(columnHeaderItems);
-    qDeleteAll(rowHeaderItems);
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::init()
-{
-    Q_Q(QStandardItemModel);
-    QObject::connect(q, SIGNAL(dataChanged(QModelIndex,QModelIndex)),
-                     q, SLOT(_q_emitItemChanged(QModelIndex,QModelIndex)));
-}
-
-/*!
-    \internal
-*/
-void QStandardItemModelPrivate::_q_emitItemChanged(const QModelIndex &topLeft,
-                                                   const QModelIndex &bottomRight)
-{
-    Q_Q(QStandardItemModel);
-    QModelIndex parent = topLeft.parent();
-    for (int row = topLeft.row(); row <= bottomRight.row(); ++row) {
-        for (int column = topLeft.column(); column <= bottomRight.column(); ++column) {
-            QModelIndex index = q->index(row, column, parent);
-            if (QStandardItem *item = itemFromIndex(index))
-                emit q->itemChanged(item);
-        }
-    }
-}
-
-/*!
-    \internal
-*/
-bool QStandardItemPrivate::insertRows(int row, const QList<QStandardItem*> &items)
-{
-    Q_Q(QStandardItem);
-    if ((row < 0) || (row > rowCount()))
-        return false;
-    int count = items.count();
-    if (model)
-        model->d_func()->rowsAboutToBeInserted(q, row, row + count - 1);
-    if (rowCount() == 0) {
-        if (columnCount() == 0)
-            q->setColumnCount(1);
-        children.resize(columnCount() * count);
-        rows = count;
-    } else {
-        rows += count;
-        int index = childIndex(row, 0);
-        if (index != -1)
-            children.insert(index, columnCount() * count, 0);
-    }
-    for (int i = 0; i < items.count(); ++i) {
-        QStandardItem *item = items.at(i);
-        item->d_func()->model = model;
-        item->d_func()->parent = q;
-        int index = childIndex(i + row, 0);
-        children.replace(index, item);
-    }
-    if (model)
-        model->d_func()->rowsInserted(q, row, count);
-    return true;
-}
-
-bool QStandardItemPrivate::insertRows(int row, int count, const QList<QStandardItem*> &items)
-{
-    Q_Q(QStandardItem);
-    if ((count < 1) || (row < 0) || (row > rowCount()))
-        return false;
-    if (model)
-        model->d_func()->rowsAboutToBeInserted(q, row, row + count - 1);
-    if (rowCount() == 0) {
-        children.resize(columnCount() * count);
-        rows = count;
-    } else {
-        rows += count;
-        int index = childIndex(row, 0);
-        if (index != -1)
-            children.insert(index, columnCount() * count, 0);
-    }
-    if (!items.isEmpty()) {
-        int index = childIndex(row, 0);
-        int limit = qMin(items.count(), columnCount() * count);
-        for (int i = 0; i < limit; ++i) {
-            QStandardItem *item = items.at(i);
-            if (item) {
-                if (item->d_func()->parent == 0) {
-                    item->d_func()->setParentAndModel(q, model);
-                } else {
-                    qWarning("QStandardItem::insertRows: Ignoring duplicate insertion of item %p",
-                             item);
-                    item = 0;
-                }
-            }
-            children.replace(index, item);
-            ++index;
-        }
-    }
-    if (model)
-        model->d_func()->rowsInserted(q, row, count);
-    return true;
-}
-
-/*!
-    \internal
-*/
-bool QStandardItemPrivate::insertColumns(int column, int count, const QList<QStandardItem*> &items)
-{
-    Q_Q(QStandardItem);
-    if ((count < 1) || (column < 0) || (column > columnCount()))
-        return false;
-    if (model)
-        model->d_func()->columnsAboutToBeInserted(q, column, column + count - 1);
-    if (columnCount() == 0) {
-        children.resize(rowCount() * count);
-        columns = count;
-    } else {
-        columns += count;
-        int index = childIndex(0, column);
-        for (int row = 0; row < rowCount(); ++row) {
-            children.insert(index, count, 0);
-            index += columnCount();
-        }
-    }
-    if (!items.isEmpty()) {
-        int limit = qMin(items.count(), rowCount() * count);
-        for (int i = 0; i < limit; ++i) {
-            QStandardItem *item = items.at(i);
-            if (item) {
-                if (item->d_func()->parent == 0) {
-                    item->d_func()->setParentAndModel(q, model);
-                } else {
-                    qWarning("QStandardItem::insertColumns: Ignoring duplicate insertion of item %p",
-                             item);
-                    item = 0;
-                }
-            }
-            int r = i / count;
-            int c = column + (i % count);
-            int index = childIndex(r, c);
-            children.replace(index, item);
-        }
-    }
-    if (model)
-        model->d_func()->columnsInserted(q, column, count);
-    return true;
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::itemChanged(QStandardItem *item)
-{
-    Q_Q(QStandardItemModel);
-    if (item->d_func()->parent == 0) {
-        // Header item
-        int idx = columnHeaderItems.indexOf(item);
-        if (idx != -1) {
-            emit q->headerDataChanged(Qt::Horizontal, idx, idx);
-        } else {
-            idx = rowHeaderItems.indexOf(item);
-            if (idx != -1)
-                emit q->headerDataChanged(Qt::Vertical, idx, idx);
-        }
-    } else {
-        // Normal item
-        QModelIndex index = q->indexFromItem(item);
-        emit q->dataChanged(index, index);
-    }
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::rowsAboutToBeInserted(QStandardItem *parent,
-                                                      int start, int end)
-{
-    Q_Q(QStandardItemModel);
-    QModelIndex index = q->indexFromItem(parent);
-    q->beginInsertRows(index, start, end);
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::columnsAboutToBeInserted(QStandardItem *parent,
-                                                         int start, int end)
-{
-    Q_Q(QStandardItemModel);
-    QModelIndex index = q->indexFromItem(parent);
-    q->beginInsertColumns(index, start, end);
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::rowsAboutToBeRemoved(QStandardItem *parent,
-                                                     int start, int end)
-{
-    Q_Q(QStandardItemModel);
-    QModelIndex index = q->indexFromItem(parent);
-    q->beginRemoveRows(index, start, end);
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::columnsAboutToBeRemoved(QStandardItem *parent,
-                                                        int start, int end)
-{
-    Q_Q(QStandardItemModel);
-    QModelIndex index = q->indexFromItem(parent);
-    q->beginRemoveColumns(index, start, end);
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::rowsInserted(QStandardItem *parent,
-                                             int row, int count)
-{
-    Q_Q(QStandardItemModel);
-    if (parent == root.data())
-        rowHeaderItems.insert(row, count, 0);
-    q->endInsertRows();
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::columnsInserted(QStandardItem *parent,
-                                                int column, int count)
-{
-    Q_Q(QStandardItemModel);
-    if (parent == root.data())
-        columnHeaderItems.insert(column, count, 0);
-    q->endInsertColumns();
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::rowsRemoved(QStandardItem *parent,
-                                            int row, int count)
-{
-    Q_Q(QStandardItemModel);
-    if (parent == root.data()) {
-        for (int i = row; i < row + count; ++i) {
-            QStandardItem *oldItem = rowHeaderItems.at(i);
-            if (oldItem)
-                oldItem->d_func()->setModel(0);
-            delete oldItem;
-        }
-        rowHeaderItems.remove(row, count);
-    }
-    q->endRemoveRows();
-}
-
-/*!
-  \internal
-*/
-void QStandardItemModelPrivate::columnsRemoved(QStandardItem *parent,
-                                               int column, int count)
-{
-    Q_Q(QStandardItemModel);
-    if (parent == root.data()) {
-        for (int i = column; i < column + count; ++i) {
-            QStandardItem *oldItem = columnHeaderItems.at(i);
-            if (oldItem)
-                oldItem->d_func()->setModel(0);
-            delete oldItem;
-        }
-        columnHeaderItems.remove(column, count);
-    }
-    q->endRemoveColumns();
-}
-
-/*!
-    \class QStandardItem
-    \brief The QStandardItem class provides an item for use with the
-    QStandardItemModel class.
-    \since 4.2
-    \ingroup model-view
-    \inmodule QtWidgets
-
-    Items usually contain text, icons, or checkboxes.
-
-    Each item can have its own background brush which is set with the
-    setBackground() function. The current background brush can be found with
-    background().  The text label for each item can be rendered with its own
-    font and brush. These are specified with the setFont() and setForeground()
-    functions, and read with font() and foreground().
-
-    By default, items are enabled, editable, selectable, checkable, and can be
-    used both as the source of a drag and drop operation and as a drop target.
-    Each item's flags can be changed by calling setFlags(). Checkable items
-    can be checked and unchecked with the setCheckState() function. The
-    corresponding checkState() function indicates whether the item is
-    currently checked.
-
-    You can store application-specific data in an item by calling setData().
-
-    Each item can have a two-dimensional table of child items. This makes it
-    possible to build hierarchies of items. The typical hierarchy is the tree,
-    in which case the child table is a table with a single column (a list).
-
-    The dimensions of the child table can be set with setRowCount() and
-    setColumnCount(). Items can be positioned in the child table with
-    setChild(). Get a pointer to a child item with child(). New rows and
-    columns of children can also be inserted with insertRow() and
-    insertColumn(), or appended with appendRow() and appendColumn(). When
-    using the append and insert functions, the dimensions of the child table
-    will grow as needed.
-
-    An existing row of children can be removed with removeRow() or takeRow();
-    correspondingly, a column can be removed with removeColumn() or
-    takeColumn().
-
-    An item's children can be sorted by calling sortChildren().
-
-    \section1 Subclassing
-
-    When subclassing QStandardItem to provide custom items, it is possible to
-    define new types for them so that they can be distinguished from the base
-    class. The type() function should be reimplemented to return a new type
-    value equal to or greater than \l UserType.
-
-    Reimplement data() and setData() if you want to perform custom handling of
-    data queries and/or control how an item's data is represented.
-
-    Reimplement clone() if you want QStandardItemModel to be able to create
-    instances of your custom item class on demand (see
-    QStandardItemModel::setItemPrototype()).
-
-    Reimplement read() and write() if you want to control how items are
-    represented in their serialized form.
-
-    Reimplement \l{operator<()} if you want to control the semantics of item
-    comparison. \l{operator<()} determines the sorted order when sorting items
-    with sortChildren() or with QStandardItemModel::sort().
-
-    \sa QStandardItemModel, {Item View Convenience Classes}, {Model/View Programming}
-*/
-
-/*!
-    \enum QStandardItem::ItemType
-
-    This enum describes the types that are used to describe standard items.
-
-    \value Type     The default type for standard items.
-    \value UserType The minimum value for custom types. Values below UserType are
-                    reserved by Qt.
-
-    You can define new user types in QStandardItem subclasses to ensure that
-    custom items are treated specially; for example, when items are sorted.
-
-    \sa type()
-*/
-
-/*!
-    Constructs an item.
-*/
-QStandardItem::QStandardItem()
-    : d_ptr(new QStandardItemPrivate)
-{
-    Q_D(QStandardItem);
-    d->q_ptr = this;
-}
-
-/*!
-    Constructs an item with the given \a text.
-*/
-QStandardItem::QStandardItem(const QString &text)
-    : d_ptr(new QStandardItemPrivate)
-{
-    Q_D(QStandardItem);
-    d->q_ptr = this;
-    setText(text);
-}
-
-/*!
-    Constructs an item with the given \a icon and \a text.
-*/
-QStandardItem::QStandardItem(const QIcon &icon, const QString &text)
-    : d_ptr(new QStandardItemPrivate)
-{
-    Q_D(QStandardItem);
-    d->q_ptr = this;
-    setIcon(icon);
-    setText(text);
-}
-
-/*!
-   Constructs an item with \a rows rows and \a columns columns of child items.
-*/
-QStandardItem::QStandardItem(int rows, int columns)
-    : d_ptr(new QStandardItemPrivate)
-{
-    Q_D(QStandardItem);
-    d->q_ptr = this;
-    setRowCount(rows);
-    setColumnCount(columns);
-}
-
-/*!
-  \internal
-*/
-QStandardItem::QStandardItem(QStandardItemPrivate &dd)
-    : d_ptr(&dd)
-{
-    Q_D(QStandardItem);
-    d->q_ptr = this;
-}
-
-/*!
-  Constructs a copy of \a other. Note that model() is
-  not copied.
-
-  This function is useful when reimplementing clone().
-*/
-QStandardItem::QStandardItem(const QStandardItem &other)
-    : d_ptr(new QStandardItemPrivate)
-{
-    Q_D(QStandardItem);
-    d->q_ptr = this;
-    operator=(other);
-}
-
-/*!
-  Assigns \a other's data and flags to this item. Note that
-  type() and model() are not copied.
-
-  This function is useful when reimplementing clone().
-*/
-QStandardItem &QStandardItem::operator=(const QStandardItem &other)
-{
-    Q_D(QStandardItem);
-    d->values = other.d_func()->values;
-    return *this;
-}
-
-/*!
-  Destructs the item.
-  This causes the item's children to be destructed as well.
-*/
-QStandardItem::~QStandardItem()
-{
-}
-
-/*!
-  Returns the item's parent item, or 0 if the item has no parent.
-  \note For toplevel items parent() returns 0. To receive toplevel
-  item's parent use QStandardItemModel::invisibleRootItem() instead.
-
-  \sa child(), QStandardItemModel::invisibleRootItem()
-*/
-QStandardItem *QStandardItem::parent() const
-{
-    Q_D(const QStandardItem);
-    if (!d->model || (d->model->d_func()->root.data() != d->parent))
-        return d->parent;
-    return 0;
-}
-
-/*!
-    Sets the item's data for the given \a role to the specified \a value.
-
-    If you subclass QStandardItem and reimplement this function, your
-    reimplementation should call emitDataChanged() if you do not call
-    the base implementation of setData(). This will ensure that e.g.
-    views using the model are notified of the changes.
-
-    \note The default implementation treats Qt::EditRole and Qt::DisplayRole
-    as referring to the same data.
-
-    \sa Qt::ItemDataRole, data(), setFlags()
-*/
-void QStandardItem::setData(const QVariant &value, int role)
-{
-    Q_D(QStandardItem);
-    role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
-    QVector<QWidgetItemData>::iterator it;
-    for (it = d->values.begin(); it != d->values.end(); ++it) {
-        if ((*it).role == role) {
-            if (value.isValid()) {
-                if ((*it).value.type() == value.type() && (*it).value == value)
-                    return;
-                (*it).value = value;
-            } else {
-                d->values.erase(it);
-            }
-            if (d->model)
-                d->model->d_func()->itemChanged(this);
-            return;
-        }
-    }
-    d->values.append(QWidgetItemData(role, value));
-    if (d->model)
-        d->model->d_func()->itemChanged(this);
-}
-
-/*!
-    Returns the item's data for the given \a role, or an invalid
-    QVariant if there is no data for the role.
-
-    \note The default implementation treats Qt::EditRole and Qt::DisplayRole
-    as referring to the same data.
-*/
-QVariant QStandardItem::data(int role) const
-{
-    Q_D(const QStandardItem);
-    role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
-    QVector<QWidgetItemData>::const_iterator it;
-    for (it = d->values.begin(); it != d->values.end(); ++it) {
-        if ((*it).role == role)
-            return (*it).value;
-    }
-    return QVariant();
-}
-
-/*!
-  \since 4.4
-
-  Causes the model associated with this item to emit a
-  \l{QAbstractItemModel::dataChanged()}{dataChanged}() signal for this
-  item.
-
-  You normally only need to call this function if you have subclassed
-  QStandardItem and reimplemented data() and/or setData().
-
-  \sa setData()
-*/
-void QStandardItem::emitDataChanged()
-{
-    Q_D(QStandardItem);
-    if (d->model)
-        d->model->d_func()->itemChanged(this);
-}
-
-/*!
-  Sets the item flags for the item to \a flags.
-
-  The item flags determine how the user can interact with the item.
-  This is often used to disable an item.
-
-  \sa flags(), setData()
-*/
-void QStandardItem::setFlags(Qt::ItemFlags flags)
-{
-    setData((int)flags, Qt::UserRole - 1);
-}
-
-/*!
-  Returns the item flags for the item.
-
-  The item flags determine how the user can interact with the item.
-
-  By default, items are enabled, editable, selectable, checkable, and can be
-  used both as the source of a drag and drop operation and as a drop target.
-
-  \sa setFlags()
-*/
-Qt::ItemFlags QStandardItem::flags() const
-{
-    QVariant v = data(Qt::UserRole - 1);
-    if (!v.isValid())
-        return (Qt::ItemIsSelectable|Qt::ItemIsEnabled|Qt::ItemIsEditable
-                |Qt::ItemIsDragEnabled|Qt::ItemIsDropEnabled);
-    return Qt::ItemFlags(v.toInt());
-}
-
-/*!
-    \fn QString QStandardItem::text() const
-
-    Returns the item's text. This is the text that's presented to the user
-    in a view.
-
-    \sa setText()
-*/
-
-/*!
-    \fn void QStandardItem::setText(const QString &text)
-
-    Sets the item's text to the \a text specified.
-
-    \sa text(), setFont(), setForeground()
-*/
-
-/*!
-    \fn QIcon QStandardItem::icon() const
-
-    Returns the item's icon.
-
-    \sa setIcon(), {QAbstractItemView::iconSize}{iconSize}
-*/
-
-/*!
-    \fn void QStandardItem::setIcon(const QIcon &icon)
-
-    Sets the item's icon to the \a icon specified.
-*/
-
-/*!
-    \fn QString QStandardItem::statusTip() const
-
-    Returns the item's status tip.
-
-    \sa setStatusTip(), toolTip(), whatsThis()
-*/
-
-/*!
-    \fn void QStandardItem::setStatusTip(const QString &statusTip)
-
-    Sets the item's status tip to the string specified by \a statusTip.
-
-    \sa statusTip(), setToolTip(), setWhatsThis()
-*/
-
-/*!
-    \fn QString QStandardItem::toolTip() const
-
-    Returns the item's tooltip.
-
-    \sa setToolTip(), statusTip(), whatsThis()
-*/
-
-/*!
-    \fn void QStandardItem::setToolTip(const QString &toolTip)
-
-    Sets the item's tooltip to the string specified by \a toolTip.
-
-    \sa toolTip(), setStatusTip(), setWhatsThis()
-*/
-
-/*!
-    \fn QString QStandardItem::whatsThis() const
-
-    Returns the item's "What's This?" help.
-
-    \sa setWhatsThis(), toolTip(), statusTip()
-*/
-
-/*!
-    \fn void QStandardItem::setWhatsThis(const QString &whatsThis)
-
-    Sets the item's "What's This?" help to the string specified by \a whatsThis.
-
-    \sa whatsThis(), setStatusTip(), setToolTip()
-*/
-
-/*!
-    \fn QFont QStandardItem::font() const
-
-    Returns the font used to render the item's text.
-
-    \sa setFont()
-*/
-
-/*!
-    \fn void QStandardItem::setFont(const QFont &font)
-
-    Sets the font used to display the item's text to the given \a font.
-
-    \sa font(), setText(), setForeground()
-*/
-
-/*!
-    \fn QBrush QStandardItem::background() const
-
-    Returns the brush used to render the item's background.
-
-    \sa foreground(), setBackground()
-*/
-
-/*!
-    \fn void QStandardItem::setBackground(const QBrush &brush)
-
-    Sets the item's background brush to the specified \a brush.
-
-    \sa background(), setForeground()
-*/
-
-/*!
-    \fn QBrush QStandardItem::foreground() const
-
-    Returns the brush used to render the item's foreground (e.g. text).
-
-    \sa setForeground(), background()
-*/
-
-/*!
-    \fn void QStandardItem::setForeground(const QBrush &brush)
-
-    Sets the brush used to display the item's foreground (e.g. text) to the
-    given \a brush.
-
-    \sa foreground(), setBackground(), setFont()
-*/
-
-/*!
-    \fn int QStandardItem::textAlignment() const
-
-    Returns the text alignment for the item's text.
-*/
-
-/*!
-    \fn void QStandardItem::setTextAlignment(Qt::Alignment alignment)
-
-    Sets the text alignment for the item's text to the \a alignment
-    specified.
-
-    \sa textAlignment()
-*/
-
-/*!
-    \fn QSize QStandardItem::sizeHint() const
-
-    Returns the size hint set for the item, or an invalid QSize if no
-    size hint has been set.
-
-    If no size hint has been set, the item delegate will compute the
-    size hint based on the item data.
-
-    \sa setSizeHint()
-*/
-
-/*!
-    \fn void QStandardItem::setSizeHint(const QSize &size)
-
-    Sets the size hint for the item to be \a size.
-    If no size hint is set, the item delegate will compute the
-    size hint based on the item data.
-
-    \sa sizeHint()
-*/
-
-/*!
-    \fn Qt::CheckState QStandardItem::checkState() const
-
-    Returns the checked state of the item.
-
-    \sa setCheckState(), isCheckable()
-*/
-
-/*!
-    \fn void QStandardItem::setCheckState(Qt::CheckState state)
-
-    Sets the check state of the item to be \a state.
-
-    \sa checkState(), setCheckable()
-*/
-
-/*!
-    \fn QString QStandardItem::accessibleText() const
-
-    Returns the item's accessible text.
-
-    The accessible text is used by assistive technologies (i.e. for users who
-    cannot use conventional means of interaction).
-
-    \sa setAccessibleText(), accessibleDescription()
-*/
-
-/*!
-    \fn void QStandardItem::setAccessibleText(const QString &accessibleText)
-
-    Sets the item's accessible text to the string specified by \a accessibleText.
-
-    The accessible text is used by assistive technologies (i.e. for users who
-    cannot use conventional means of interaction).
-
-    \sa accessibleText(), setAccessibleDescription()
-*/
-
-/*!
-    \fn QString QStandardItem::accessibleDescription() const
-
-    Returns the item's accessible description.
-
-    The accessible description is used by assistive technologies (i.e. for
-    users who cannot use conventional means of interaction).
-
-    \sa setAccessibleDescription(), accessibleText()
-*/
-
-/*!
-    \fn void QStandardItem::setAccessibleDescription(const QString &accessibleDescription)
-
-    Sets the item's accessible description to the string specified by \a
-    accessibleDescription.
-
-    The accessible description is used by assistive technologies (i.e. for
-    users who cannot use conventional means of interaction).
-
-    \sa accessibleDescription(), setAccessibleText()
-*/
-
-/*!
-  Sets whether the item is enabled. If \a enabled is true, the item is enabled,
-  meaning that the user can interact with the item; if \a enabled is false, the
-  user cannot interact with the item.
-
-  This flag takes precedence over the other item flags; e.g. if an item is not
-  enabled, it cannot be selected by the user, even if the Qt::ItemIsSelectable
-  flag has been set.
-
-  \sa isEnabled(), Qt::ItemIsEnabled, setFlags()
-*/
-void QStandardItem::setEnabled(bool enabled)
-{
-    Q_D(QStandardItem);
-    d->changeFlags(enabled, Qt::ItemIsEnabled);
-}
-
-/*!
-  \fn bool QStandardItem::isEnabled() const
-
-  Returns whether the item is enabled.
-
-  When an item is enabled, the user can interact with it. The possible
-  types of interaction are specified by the other item flags, such as
-  isEditable() and isSelectable().
-
-  The default value is true.
-
-  \sa setEnabled(), flags()
-*/
-
-/*!
-  Sets whether the item is editable. If \a editable is true, the item can be
-  edited by the user; otherwise, the user cannot edit the item.
-
-  How the user can edit items in a view is determined by the view's edit
-  triggers; see QAbstractItemView::editTriggers.
-
-  \sa isEditable(), setFlags()
-*/
-void QStandardItem::setEditable(bool editable)
-{
-    Q_D(QStandardItem);
-    d->changeFlags(editable, Qt::ItemIsEditable);
-}
-
-/*!
-  \fn bool QStandardItem::isEditable() const
-
-  Returns whether the item can be edited by the user.
-
-  When an item is editable (and enabled), the user can edit the item by
-  invoking one of the view's edit triggers; see
-  QAbstractItemView::editTriggers.
-
-  The default value is true.
-
-  \sa setEditable(), flags()
-*/
-
-/*!
-  Sets whether the item is selectable. If \a selectable is true, the item
-  can be selected by the user; otherwise, the user cannot select the item.
-
-  You can control the selection behavior and mode by manipulating their
-  view properties; see QAbstractItemView::selectionMode and
-  QAbstractItemView::selectionBehavior.
-
-  \sa isSelectable(), setFlags()
-*/
-void QStandardItem::setSelectable(bool selectable)
-{
-    Q_D(QStandardItem);
-    d->changeFlags(selectable, Qt::ItemIsSelectable);
-}
-
-/*!
-  \fn bool QStandardItem::isSelectable() const
-
-  Returns whether the item is selectable by the user.
-
-  The default value is true.
-
-  \sa setSelectable(), flags()
-*/
-
-/*!
-  Sets whether the item is user-checkable. If \a checkable is true, the
-  item can be checked by the user; otherwise, the user cannot check
-  the item.
-
-  The item delegate will render a checkable item with a check box next to the
-  item's text.
-
-  \sa isCheckable(), setCheckState(), setTristate()
-*/
-void QStandardItem::setCheckable(bool checkable)
-{
-    Q_D(QStandardItem);
-    if (checkable && !isCheckable()) {
-        // make sure there's data for the checkstate role
-        if (!data(Qt::CheckStateRole).isValid())
-            setData(Qt::Unchecked, Qt::CheckStateRole);
-    }
-    d->changeFlags(checkable, Qt::ItemIsUserCheckable);
-}
-
-/*!
-  \fn bool QStandardItem::isCheckable() const
-
-  Returns whether the item is user-checkable.
-
-  The default value is false.
-
-  \sa setCheckable(), checkState(), isTristate()
-*/
-
-/*!
-  Sets whether the item is tristate. If \a tristate is true, the
-  item is checkable with three separate states; otherwise, the item
-  is checkable with two states. (Note that this also requires that
-  the item is checkable; see isCheckable().)
-
-  \sa isTristate(), setCheckable(), setCheckState()
-*/
-void QStandardItem::setTristate(bool tristate)
-{
-    Q_D(QStandardItem);
-    d->changeFlags(tristate, Qt::ItemIsTristate);
-}
-
-/*!
-  \fn bool QStandardItem::isTristate() const
-
-  Returns whether the item is tristate; that is, if it's checkable with three
-  separate states.
-
-  The default value is false.
-
-  \sa setTristate(), isCheckable(), checkState()
-*/
-
-#ifndef QT_NO_DRAGANDDROP
-
-/*!
-  Sets whether the item is drag enabled. If \a dragEnabled is true, the item
-  can be dragged by the user; otherwise, the user cannot drag the item.
-
-  Note that you also need to ensure that item dragging is enabled in the view;
-  see QAbstractItemView::dragEnabled.
-
-  \sa isDragEnabled(), setDropEnabled(), setFlags()
-*/
-void QStandardItem::setDragEnabled(bool dragEnabled)
-{
-    Q_D(QStandardItem);
-    d->changeFlags(dragEnabled, Qt::ItemIsDragEnabled);
-}
-
-/*!
-  \fn bool QStandardItem::isDragEnabled() const
-
-  Returns whether the item is drag enabled. An item that is drag enabled can
-  be dragged by the user.
-
-  The default value is true.
-
-  Note that item dragging must be enabled in the view for dragging to work;
-  see QAbstractItemView::dragEnabled.
-
-  \sa setDragEnabled(), isDropEnabled(), flags()
-*/
-
-/*!
-  Sets whether the item is drop enabled. If \a dropEnabled is true, the item
-  can be used as a drop target; otherwise, it cannot.
-
-  Note that you also need to ensure that drops are enabled in the view; see
-  QWidget::acceptDrops(); and that the model supports the desired drop actions;
-  see QAbstractItemModel::supportedDropActions().
-
-  \sa isDropEnabled(), setDragEnabled(), setFlags()
-*/
-void QStandardItem::setDropEnabled(bool dropEnabled)
-{
-    Q_D(QStandardItem);
-    d->changeFlags(dropEnabled, Qt::ItemIsDropEnabled);
-}
-
-/*!
-  \fn bool QStandardItem::isDropEnabled() const
-
-  Returns whether the item is drop enabled. When an item is drop enabled, it
-  can be used as a drop target.
-
-  The default value is true.
-
-  \sa setDropEnabled(), isDragEnabled(), flags()
-*/
-
-#endif // QT_NO_DRAGANDDROP
-
-/*!
-  Returns the row where the item is located in its parent's child table, or
-  -1 if the item has no parent.
-
-  \sa column(), parent()
-*/
-int QStandardItem::row() const
-{
-    Q_D(const QStandardItem);
-    QPair<int, int> pos = d->position();
-    return pos.first;
-}
-
-/*!
-  Returns the column where the item is located in its parent's child table,
-  or -1 if the item has no parent.
-
-  \sa row(), parent()
-*/
-int QStandardItem::column() const
-{
-    Q_D(const QStandardItem);
-    QPair<int, int> pos = d->position();
-    return pos.second;
-}
-
-/*!
-  Returns the QModelIndex associated with this item.
-
-  When you need to invoke item functionality in a QModelIndex-based API (e.g.
-  QAbstractItemView), you can call this function to obtain an index that
-  corresponds to the item's location in the model.
-
-  If the item is not associated with a model, an invalid QModelIndex is
-  returned.
-
-  \sa model(), QStandardItemModel::itemFromIndex()
-*/
-QModelIndex QStandardItem::index() const
-{
-    Q_D(const QStandardItem);
-    return d->model ? d->model->indexFromItem(this) : QModelIndex();
-}
-
-/*!
-  Returns the QStandardItemModel that this item belongs to.
-
-  If the item is not a child of another item that belongs to the model, this
-  function returns 0.
-
-  \sa index()
-*/
-QStandardItemModel *QStandardItem::model() const
-{
-    Q_D(const QStandardItem);
-    return d->model;
-}
-
-/*!
-    Sets the number of child item rows to \a rows. If this is less than
-    rowCount(), the data in the unwanted rows is discarded.
-
-    \sa rowCount(), setColumnCount()
-*/
-void QStandardItem::setRowCount(int rows)
-{
-    int rc = rowCount();
-    if (rc == rows)
-        return;
-    if (rc < rows)
-        insertRows(qMax(rc, 0), rows - rc);
-    else
-        removeRows(qMax(rows, 0), rc - rows);
-}
-
-/*!
-    Returns the number of child item rows that the item has.
-
-    \sa setRowCount(), columnCount()
-*/
-int QStandardItem::rowCount() const
-{
-    Q_D(const QStandardItem);
-    return d->rowCount();
-}
-
-/*!
-    Sets the number of child item columns to \a columns. If this is less than
-    columnCount(), the data in the unwanted columns is discarded.
-
-    \sa columnCount(), setRowCount()
-*/
-void QStandardItem::setColumnCount(int columns)
-{
-    int cc = columnCount();
-    if (cc == columns)
-        return;
-    if (cc < columns)
-        insertColumns(qMax(cc, 0), columns - cc);
-    else
-        removeColumns(qMax(columns, 0), cc - columns);
-}
-
-/*!
-    Returns the number of child item columns that the item has.
-
-    \sa setColumnCount(), rowCount()
-*/
-int QStandardItem::columnCount() const
-{
-    Q_D(const QStandardItem);
-    return d->columnCount();
-}
-
-/*!
-    Inserts a row at \a row containing \a items. If necessary, the column
-    count is increased to the size of \a items.
-
-    \sa insertRows(), insertColumn()
-*/
-void QStandardItem::insertRow(int row, const QList<QStandardItem*> &items)
-{
-    Q_D(QStandardItem);
-    if (row < 0)
-        return;
-    if (columnCount() < items.count())
-        setColumnCount(items.count());
-    d->insertRows(row, 1, items);
-}
-
-/*!
-    Inserts \a items at \a row. The column count wont be changed.
-
-    \sa insertRow(), insertColumn()
-*/
-void QStandardItem::insertRows(int row, const QList<QStandardItem*> &items)
-{
-    Q_D(QStandardItem);
-    if (row < 0)
-        return;
-    d->insertRows(row, items);
-}
-
-/*!
-    Inserts a column at \a column containing \a items. If necessary,
-    the row count is increased to the size of \a items.
-
-    \sa insertColumns(), insertRow()
-*/
-void QStandardItem::insertColumn(int column, const QList<QStandardItem*> &items)
-{
-    Q_D(QStandardItem);
-    if (column < 0)
-        return;
-    if (rowCount() < items.count())
-        setRowCount(items.count());
-    d->insertColumns(column, 1, items);
-}
-
-/*!
-    Inserts \a count rows of child items at row \a row.
-
-    \sa insertRow(), insertColumns()
-*/
-void QStandardItem::insertRows(int row, int count)
-{
-    Q_D(QStandardItem);
-    if (rowCount() < row) {
-        count += row - rowCount();
-        row = rowCount();
-    }
-    d->insertRows(row, count, QList<QStandardItem*>());
-}
-
-/*!
-    Inserts \a count columns of child items at column \a column.
-
-    \sa insertColumn(), insertRows()
-*/
-void QStandardItem::insertColumns(int column, int count)
-{
-    Q_D(QStandardItem);
-    if (columnCount() < column) {
-        count += column - columnCount();
-        column = columnCount();
-    }
-    d->insertColumns(column, count, QList<QStandardItem*>());
-}
-
-/*!
-    \fn void QStandardItem::appendRow(const QList<QStandardItem*> &items)
-
-    Appends a row containing \a items. If necessary, the column count is
-    increased to the size of \a items.
-
-    \sa insertRow()
-*/
-
-/*!
-    \fn void QStandardItem::appendRows(const QList<QStandardItem*> &items)
-
-    Appends rows containing \a items.  The column count will not change.
-
-    \sa insertRow()
-*/
-
-/*!
-    \fn void QStandardItem::appendColumn(const QList<QStandardItem*> &items)
-
-    Appends a column containing \a items. If necessary, the row count is
-    increased to the size of \a items.
-
-    \sa insertColumn()
-*/
-
-/*!
-    \fn bool QStandardItemModel::insertRow(int row, const QModelIndex &parent)
-
-    Inserts a single row before the given \a row in the child items of the
-    \a parent specified. Returns true if the row is inserted; otherwise
-    returns false.
-
-    \sa insertRows(), insertColumn(), removeRow()
-*/
-
-/*!
-    \fn bool QStandardItemModel::insertColumn(int column, const QModelIndex &parent)
-
-    Inserts a single column before the given \a column in the child items of
-    the \a parent specified. Returns true if the column is inserted; otherwise
-    returns false.
-
-    \sa insertColumns(), insertRow(), removeColumn()
-*/
-
-/*!
-    \fn QStandardItem::insertRow(int row, QStandardItem *item)
-    \overload
-
-    Inserts a row at \a row containing \a item.
-
-    When building a list or a tree that has only one column, this function
-    provides a convenient way to insert a single new item.
-*/
-
-/*!
-    \fn QStandardItem::appendRow(QStandardItem *item)
-    \overload
-
-    Appends a row containing \a item.
-
-    When building a list or a tree that has only one column, this function
-    provides a convenient way to append a single new item.
-*/
-
-/*!
-    Removes the given \a row. The items that were in the row are deleted.
-
-    \sa takeRow(), removeRows(), removeColumn()
-*/
-void QStandardItem::removeRow(int row)
-{
-    removeRows(row, 1);
-}
-
-/*!
-    Removes the given \a column. The items that were in the
-    column are deleted.
-
-    \sa takeColumn(), removeColumns(), removeRow()
-*/
-void QStandardItem::removeColumn(int column)
-{
-    removeColumns(column, 1);
-}
-
-/*!
-    Removes \a count rows at row \a row. The items that were in those rows are
-    deleted.
-
-    \sa removeRow(), removeColumn()
-*/
-void QStandardItem::removeRows(int row, int count)
-{
-    Q_D(QStandardItem);
-    if ((count < 1) || (row < 0) || ((row + count) > rowCount()))
-        return;
-    if (d->model)
-        d->model->d_func()->rowsAboutToBeRemoved(this, row, row + count - 1);
-    int i = d->childIndex(row, 0);
-    int n = count * d->columnCount();
-    for (int j = i; j < n+i; ++j) {
-        QStandardItem *oldItem = d->children.at(j);
-        if (oldItem)
-            oldItem->d_func()->setModel(0);
-        delete oldItem;
-    }
-    d->children.remove(qMax(i, 0), n);
-    d->rows -= count;
-    if (d->model)
-        d->model->d_func()->rowsRemoved(this, row, count);
-}
-
-/*!
-    Removes \a count columns at column \a column. The items that were in those
-    columns are deleted.
-
-    \sa removeColumn(), removeRows()
-*/
-void QStandardItem::removeColumns(int column, int count)
-{
-    Q_D(QStandardItem);
-    if ((count < 1) || (column < 0) || ((column + count) > columnCount()))
-        return;
-    if (d->model)
-        d->model->d_func()->columnsAboutToBeRemoved(this, column, column + count - 1);
-    for (int row = d->rowCount() - 1; row >= 0; --row) {
-        int i = d->childIndex(row, column);
-        for (int j=i; j<i+count; ++j) {
-            QStandardItem *oldItem = d->children.at(j);
-            if (oldItem)
-                oldItem->d_func()->setModel(0);
-            delete oldItem;
-        }
-        d->children.remove(i, count);
-    }
-    d->columns -= count;
-    if (d->model)
-        d->model->d_func()->columnsRemoved(this, column, count);
-}
-
-/*!
-    Returns true if this item has any children; otherwise returns false.
-
-    \sa rowCount(), columnCount(), child()
-*/
-bool QStandardItem::hasChildren() const
-{
-    return (rowCount() > 0) && (columnCount() > 0);
-}
-
-/*!
-    Sets the child item at (\a row, \a column) to \a item. This item (the parent
-    item) takes ownership of \a item. If necessary, the row count and column
-    count are increased to fit the item.
-
-    \sa child()
-*/
-void QStandardItem::setChild(int row, int column, QStandardItem *item)
-{
-    Q_D(QStandardItem);
-    d->setChild(row, column, item, true);
-}
-
-/*!
-    \fn QStandardItem::setChild(int row, QStandardItem *item)
-    \overload
-
-    Sets the child at \a row to \a item.
-*/
-
-/*!
-    Returns the child item at (\a row, \a column) if one has been set; otherwise
-    returns 0.
-
-    \sa setChild(), takeChild(), parent()
-*/
-QStandardItem *QStandardItem::child(int row, int column) const
-{
-    Q_D(const QStandardItem);
-    int index = d->childIndex(row, column);
-    if (index == -1)
-        return 0;
-    return d->children.at(index);
-}
-
-/*!
-    Removes the child item at (\a row, \a column) without deleting it, and returns
-    a pointer to the item. If there was no child at the given location, then
-    this function returns 0.
-
-    Note that this function, unlike takeRow() and takeColumn(), does not affect
-    the dimensions of the child table.
-
-    \sa child(), takeRow(), takeColumn()
-*/
-QStandardItem *QStandardItem::takeChild(int row, int column)
-{
-    Q_D(QStandardItem);
-    QStandardItem *item = 0;
-    int index = d->childIndex(row, column);
-    if (index != -1) {
-        item = d->children.at(index);
-        if (item)
-            item->d_func()->setParentAndModel(0, 0);
-        d->children.replace(index, 0);
-    }
-    return item;
-}
-
-/*!
-    Removes \a row without deleting the row items, and returns a list of
-    pointers to the removed items. For items in the row that have not been
-    set, the corresponding pointers in the list will be 0.
-
-    \sa removeRow(), insertRow(), takeColumn()
-*/
-QList<QStandardItem*> QStandardItem::takeRow(int row)
-{
-    Q_D(QStandardItem);
-    if ((row < 0) || (row >= rowCount()))
-        return QList<QStandardItem*>();
-    if (d->model)
-        d->model->d_func()->rowsAboutToBeRemoved(this, row, row);
-    QList<QStandardItem*> items;
-    int index = d->childIndex(row, 0);  // Will return -1 if there are no columns
-    if (index != -1) {
-        int col_count = d->columnCount();
-        for (int column = 0; column < col_count; ++column) {
-            QStandardItem *ch = d->children.at(index + column);
-            if (ch)
-                ch->d_func()->setParentAndModel(0, 0);
-            items.append(ch);
-        }
-        d->children.remove(index, col_count);
-    }
-    d->rows--;
-    if (d->model)
-        d->model->d_func()->rowsRemoved(this, row, 1);
-    return items;
-}
-
-/*!
-    Removes \a column without deleting the column items, and returns a list of
-    pointers to the removed items. For items in the column that have not been
-    set, the corresponding pointers in the list will be 0.
-
-    \sa removeColumn(), insertColumn(), takeRow()
-*/
-QList<QStandardItem*> QStandardItem::takeColumn(int column)
-{
-    Q_D(QStandardItem);
-    if ((column < 0) || (column >= columnCount()))
-        return QList<QStandardItem*>();
-    if (d->model)
-        d->model->d_func()->columnsAboutToBeRemoved(this, column, column);
-    QList<QStandardItem*> items;
-
-    for (int row = d->rowCount() - 1; row >= 0; --row) {
-        int index = d->childIndex(row, column);
-        QStandardItem *ch = d->children.at(index);
-        if (ch)
-            ch->d_func()->setParentAndModel(0, 0);
-        d->children.remove(index);
-        items.prepend(ch);
-    }
-    d->columns--;
-    if (d->model)
-        d->model->d_func()->columnsRemoved(this, column, 1);
-    return items;
-}
-
-/*!
-    Returns true if this item is less than \a other; otherwise returns false.
-
-    The default implementation uses the data for the item's sort role (see
-    QStandardItemModel::sortRole) to perform the comparison if the item
-    belongs to a model; otherwise, the data for the item's Qt::DisplayRole
-    (text()) is used to perform the comparison.
-
-    sortChildren() and QStandardItemModel::sort() use this function when
-    sorting items. If you want custom sorting, you can subclass QStandardItem
-    and reimplement this function.
-*/
-bool QStandardItem::operator<(const QStandardItem &other) const
-{
-    const int role = model() ? model()->sortRole() : Qt::DisplayRole;
-    const QVariant l = data(role), r = other.data(role);
-    // this code is copied from QSortFilterProxyModel::lessThan()
-    switch (l.userType()) {
-    case QVariant::Invalid:
-        return (r.type() == QVariant::Invalid);
-    case QVariant::Int:
-        return l.toInt() < r.toInt();
-    case QVariant::UInt:
-        return l.toUInt() < r.toUInt();
-    case QVariant::LongLong:
-        return l.toLongLong() < r.toLongLong();
-    case QVariant::ULongLong:
-        return l.toULongLong() < r.toULongLong();
-    case QMetaType::Float:
-        return l.toFloat() < r.toFloat();
-    case QVariant::Double:
-        return l.toDouble() < r.toDouble();
-    case QVariant::Char:
-        return l.toChar() < r.toChar();
-    case QVariant::Date:
-        return l.toDate() < r.toDate();
-    case QVariant::Time:
-        return l.toTime() < r.toTime();
-    case QVariant::DateTime:
-        return l.toDateTime() < r.toDateTime();
-    case QVariant::String:
-    default:
-        return l.toString().compare(r.toString()) < 0;
-    }
-}
-
-/*!
-    Sorts the children of the item using the given \a order, by the values in
-    the given \a column.
-
-    \note This function is recursive, therefore it sorts the children of the
-    item, its grandchildren, etc.
-
-    \sa {operator<()}
-*/
-void QStandardItem::sortChildren(int column, Qt::SortOrder order)
-{
-    Q_D(QStandardItem);
-    if ((column < 0) || (rowCount() == 0))
-        return;
-    if (d->model)
-        emit d->model->layoutAboutToBeChanged();
-    d->sortChildren(column, order);
-    if (d->model)
-        emit d->model->layoutChanged();
-}
-
-/*!
-    Returns a copy of this item. The item's children are not copied.
-
-    When subclassing QStandardItem, you can reimplement this function
-    to provide QStandardItemModel with a factory that it can use to
-    create new items on demand.
-
-    \sa QStandardItemModel::setItemPrototype(), operator=()
-*/
-QStandardItem *QStandardItem::clone() const
-{
-    return new QStandardItem(*this);
-}
-
-/*!
-    Returns the type of this item. The type is used to distinguish custom
-    items from the base class. When subclassing QStandardItem, you should
-    reimplement this function and return a new value greater than or equal
-    to \l UserType.
-
-    \sa QStandardItem::Type
-*/
-int QStandardItem::type() const
-{
-    return Type;
-}
-
-#ifndef QT_NO_DATASTREAM
-
-/*!
-    Reads the item from stream \a in. Only the data and flags of the item are
-    read, not the child items.
-
-    \sa write()
-*/
-void QStandardItem::read(QDataStream &in)
-{
-    Q_D(QStandardItem);
-    in >> d->values;
-    qint32 flags;
-    in >> flags;
-    setFlags(Qt::ItemFlags(flags));
-}
-
-/*!
-    Writes the item to stream \a out. Only the data and flags of the item
-    are written, not the child items.
-
-    \sa read()
-*/
-void QStandardItem::write(QDataStream &out) const
-{
-    Q_D(const QStandardItem);
-    out << d->values;
-    out << flags();
-}
-
-/*!
-    \relates QStandardItem
-    \since 4.2
-
-    Reads a QStandardItem from stream \a in into \a item.
-
-    This operator uses QStandardItem::read().
-
-    \sa {Serializing Qt Data Types}
-*/
-QDataStream &operator>>(QDataStream &in, QStandardItem &item)
-{
-    item.read(in);
-    return in;
-}
-
-/*!
-    \relates QStandardItem
-    \since 4.2
-
-    Writes the QStandardItem \a item to stream \a out.
-
-    This operator uses QStandardItem::write().
-
-    \sa {Serializing Qt Data Types}
-*/
-QDataStream &operator<<(QDataStream &out, const QStandardItem &item)
-{
-    item.write(out);
-    return out;
-}
-
-#endif // QT_NO_DATASTREAM
-
-/*!
-    \class QStandardItemModel
-    \brief The QStandardItemModel class provides a generic model for storing custom data.
-    \ingroup model-view
-    \inmodule QtWidgets
-
-    QStandardItemModel can be used as a repository for standard Qt
-    data types. It is one of the \l {Model/View Classes} and is part
-    of Qt's \l {Model/View Programming}{model/view} framework.
-
-    QStandardItemModel provides a classic item-based approach to working with
-    the model.  The items in a QStandardItemModel are provided by
-    QStandardItem.
-
-    QStandardItemModel implements the QAbstractItemModel interface, which
-    means that the model can be used to provide data in any view that supports
-    that interface (such as QListView, QTableView and QTreeView, and your own
-    custom views). For performance and flexibility, you may want to subclass
-    QAbstractItemModel to provide support for different kinds of data
-    repositories. For example, the QDirModel provides a model interface to the
-    underlying file system.
-
-    When you want a list or tree, you typically create an empty
-    QStandardItemModel and use appendRow() to add items to the model, and
-    item() to access an item.  If your model represents a table, you typically
-    pass the dimensions of the table to the QStandardItemModel constructor and
-    use setItem() to position items into the table. You can also use setRowCount()
-    and setColumnCount() to alter the dimensions of the model. To insert items,
-    use insertRow() or insertColumn(), and to remove items, use removeRow() or
-    removeColumn().
-
-    You can set the header labels of your model with setHorizontalHeaderLabels()
-    and setVerticalHeaderLabels().
-
-    You can search for items in the model with findItems(), and sort the model by
-    calling sort().
-
-    Call clear() to remove all items from the model.
-
-    An example usage of QStandardItemModel to create a table:
-
-    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 0
-
-    An example usage of QStandardItemModel to create a tree:
-
-    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 1
-
-    After setting the model on a view, you typically want to react to user
-    actions, such as an item being clicked. Since a QAbstractItemView provides
-    QModelIndex-based signals and functions, you need a way to obtain the
-    QStandardItem that corresponds to a given QModelIndex, and vice
-    versa. itemFromIndex() and indexFromItem() provide this mapping. Typical
-    usage of itemFromIndex() includes obtaining the item at the current index
-    in a view, and obtaining the item that corresponds to an index carried by
-    a QAbstractItemView signal, such as QAbstractItemView::clicked(). First
-    you connect the view's signal to a slot in your class:
-
-    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 2
-
-    When you receive the signal, you call itemFromIndex() on the given model
-    index to get a pointer to the item:
-
-    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 3
-
-    Conversely, you must obtain the QModelIndex of an item when you want to
-    invoke a model/view function that takes an index as argument. You can
-    obtain the index either by using the model's indexFromItem() function, or,
-    equivalently, by calling QStandardItem::index():
-
-    \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 4
-
-    You are, of course, not required to use the item-based approach; you could
-    instead rely entirely on the QAbstractItemModel interface when working with
-    the model, or use a combination of the two as appropriate.
-
-    \sa QStandardItem, {Model/View Programming}, QAbstractItemModel,
-    {itemviews/simpletreemodel}{Simple Tree Model example},
-    {Item View Convenience Classes}
-*/
-
-/*!
-    \fn void QStandardItemModel::itemChanged(QStandardItem *item)
-    \since 4.2
-
-    This signal is emitted whenever the data of \a item has changed.
-*/
-
-/*!
-    Constructs a new item model with the given \a parent.
-*/
-QStandardItemModel::QStandardItemModel(QObject *parent)
-    : QAbstractItemModel(*new QStandardItemModelPrivate, parent)
-{
-    Q_D(QStandardItemModel);
-    d->init();
-    d->root->d_func()->setModel(this);
-}
-
-/*!
-    Constructs a new item model that initially has \a rows rows and \a columns
-    columns, and that has the given \a parent.
-*/
-QStandardItemModel::QStandardItemModel(int rows, int columns, QObject *parent)
-    : QAbstractItemModel(*new QStandardItemModelPrivate, parent)
-{
-    Q_D(QStandardItemModel);
-    d->init();
-    d->root->insertColumns(0, columns);
-    d->columnHeaderItems.insert(0, columns, 0);
-    d->root->insertRows(0, rows);
-    d->rowHeaderItems.insert(0, rows, 0);
-    d->root->d_func()->setModel(this);
-}
-
-/*!
-  \internal
-*/
-QStandardItemModel::QStandardItemModel(QStandardItemModelPrivate &dd, QObject *parent)
-    : QAbstractItemModel(dd, parent)
-{
-    Q_D(QStandardItemModel);
-    d->init();
-}
-
-/*!
-    Destructs the model. The model destroys all its items.
-*/
-QStandardItemModel::~QStandardItemModel()
-{
-}
-
-/*!
-    Sets the item role names to \a roleNames.
-*/
-void QStandardItemModel::setItemRoleNames(const QHash<int,QByteArray> &roleNames)
-{
-    Q_D(QStandardItemModel);
-    d->roleNames = roleNames;
-}
-
-/*!
-    Removes all items (including header items) from the model and sets the
-    number of rows and columns to zero.
-
-    \sa removeColumns(), removeRows()
-*/
-void QStandardItemModel::clear()
-{
-    Q_D(QStandardItemModel);
-    beginResetModel();
-    d->root.reset(new QStandardItem);
-    d->root->d_func()->setModel(this);
-    qDeleteAll(d->columnHeaderItems);
-    d->columnHeaderItems.clear();
-    qDeleteAll(d->rowHeaderItems);
-    d->rowHeaderItems.clear();
-    endResetModel();
-}
-
-/*!
-    \since 4.2
-
-    Returns a pointer to the QStandardItem associated with the given \a index.
-
-    Calling this function is typically the initial step when processing
-    QModelIndex-based signals from a view, such as
-    QAbstractItemView::activated(). In your slot, you call itemFromIndex(),
-    with the QModelIndex carried by the signal as argument, to obtain a
-    pointer to the corresponding QStandardItem.
-
-    Note that this function will lazily create an item for the index (using
-    itemPrototype()), and set it in the parent item's child table, if no item
-    already exists at that index.
-
-    If \a index is an invalid index, this function returns 0.
-
-    \sa indexFromItem()
-*/
-QStandardItem *QStandardItemModel::itemFromIndex(const QModelIndex &index) const
-{
-    Q_D(const QStandardItemModel);
-    if ((index.row() < 0) || (index.column() < 0) || (index.model() != this))
-        return 0;
-    QStandardItem *parent = static_cast<QStandardItem*>(index.internalPointer());
-    if (parent == 0)
-        return 0;
-    QStandardItem *item = parent->child(index.row(), index.column());
-    // lazy part
-    if (item == 0) {
-        item = d->createItem();
-        parent->d_func()->setChild(index.row(), index.column(), item);
-    }
-    return item;
-}
-
-/*!
-    \since 4.2
-
-    Returns the QModelIndex associated with the given \a item.
-
-    Use this function when you want to perform an operation that requires the
-    QModelIndex of the item, such as
-    QAbstractItemView::scrollTo(). QStandardItem::index() is provided as
-    convenience; it is equivalent to calling this function.
-
-    \sa itemFromIndex(), QStandardItem::index()
-*/
-QModelIndex QStandardItemModel::indexFromItem(const QStandardItem *item) const
-{
-    if (item && item->d_func()->parent) {
-        QPair<int, int> pos = item->d_func()->position();
-        return createIndex(pos.first, pos.second, item->d_func()->parent);
-    }
-    return QModelIndex();
-}
-
-/*!
-    \since 4.2
-
-    Sets the number of rows in this model to \a rows. If
-    this is less than rowCount(), the data in the unwanted rows
-    is discarded.
-
-    \sa setColumnCount()
-*/
-void QStandardItemModel::setRowCount(int rows)
-{
-    Q_D(QStandardItemModel);
-    d->root->setRowCount(rows);
-}
-
-/*!
-    \since 4.2
-
-    Sets the number of columns in this model to \a columns. If
-    this is less than columnCount(), the data in the unwanted columns
-    is discarded.
-
-    \sa setRowCount()
-*/
-void QStandardItemModel::setColumnCount(int columns)
-{
-    Q_D(QStandardItemModel);
-    d->root->setColumnCount(columns);
-}
-
-/*!
-    \since 4.2
-
-    Sets the item for the given \a row and \a column to \a item. The model
-    takes ownership of the item. If necessary, the row count and column count
-    are increased to fit the item. The previous item at the given location (if
-    there was one) is deleted.
-
-    \sa item()
-*/
-void QStandardItemModel::setItem(int row, int column, QStandardItem *item)
-{
-    Q_D(QStandardItemModel);
-    d->root->d_func()->setChild(row, column, item, true);
-}
-
-/*!
-  \fn QStandardItemModel::setItem(int row, QStandardItem *item)
-  \overload
-*/
-
-/*!
-    \since 4.2
-
-    Returns the item for the given \a row and \a column if one has been set;
-    otherwise returns 0.
-
-    \sa setItem(), takeItem(), itemFromIndex()
-*/
-QStandardItem *QStandardItemModel::item(int row, int column) const
-{
-    Q_D(const QStandardItemModel);
-    return d->root->child(row, column);
-}
-
-/*!
-    \since 4.2
-
-    Returns the model's invisible root item.
-
-    The invisible root item provides access to the model's top-level items
-    through the QStandardItem API, making it possible to write functions that
-    can treat top-level items and their children in a uniform way; for
-    example, recursive functions involving a tree model.
-
-    \note Calling \l{QAbstractItemModel::index()}{index()} on the QStandardItem object
-    retrieved from this function is not valid.
-*/
-QStandardItem *QStandardItemModel::invisibleRootItem() const
-{
-    Q_D(const QStandardItemModel);
-    return d->root.data();
-}
-
-/*!
-    \since 4.2
-
-    Sets the horizontal header item for \a column to \a item.  The model takes
-    ownership of the item. If necessary, the column count is increased to fit
-    the item. The previous header item (if there was one) is deleted.
-
-    \sa horizontalHeaderItem(), setHorizontalHeaderLabels(),
-    setVerticalHeaderItem()
-*/
-void QStandardItemModel::setHorizontalHeaderItem(int column, QStandardItem *item)
-{
-    Q_D(QStandardItemModel);
-    if (column < 0)
-        return;
-    if (columnCount() <= column)
-        setColumnCount(column + 1);
-
-    QStandardItem *oldItem = d->columnHeaderItems.at(column);
-    if (item == oldItem)
-        return;
-
-    if (item) {
-        if (item->model() == 0) {
-            item->d_func()->setModel(this);
-        } else {
-            qWarning("QStandardItem::setHorizontalHeaderItem: Ignoring duplicate insertion of item %p",
-                     item);
-            return;
-        }
-    }
-
-    if (oldItem)
-        oldItem->d_func()->setModel(0);
-    delete oldItem;
-
-    d->columnHeaderItems.replace(column, item);
-    emit headerDataChanged(Qt::Horizontal, column, column);
-}
-
-/*!
-    \since 4.2
-
-    Returns the horizontal header item for \a column if one has been set;
-    otherwise returns 0.
-
-    \sa setHorizontalHeaderItem(), verticalHeaderItem()
-*/
-QStandardItem *QStandardItemModel::horizontalHeaderItem(int column) const
-{
-    Q_D(const QStandardItemModel);
-    if ((column < 0) || (column >= columnCount()))
-        return 0;
-    return d->columnHeaderItems.at(column);
-}
-
-/*!
-    \since 4.2
-
-    Sets the vertical header item for \a row to \a item.  The model takes
-    ownership of the item. If necessary, the row count is increased to fit the
-    item. The previous header item (if there was one) is deleted.
-
-    \sa verticalHeaderItem(), setVerticalHeaderLabels(),
-    setHorizontalHeaderItem()
-*/
-void QStandardItemModel::setVerticalHeaderItem(int row, QStandardItem *item)
-{
-    Q_D(QStandardItemModel);
-    if (row < 0)
-        return;
-    if (rowCount() <= row)
-        setRowCount(row + 1);
-
-    QStandardItem *oldItem = d->rowHeaderItems.at(row);
-    if (item == oldItem)
-        return;
-
-    if (item) {
-        if (item->model() == 0) {
-            item->d_func()->setModel(this);
-        } else {
-            qWarning("QStandardItem::setVerticalHeaderItem: Ignoring duplicate insertion of item %p",
-                     item);
-            return;
-        }
-    }
-
-    if (oldItem)
-        oldItem->d_func()->setModel(0);
-    delete oldItem;
-
-    d->rowHeaderItems.replace(row, item);
-    emit headerDataChanged(Qt::Vertical, row, row);
-}
-
-/*!
-    \since 4.2
-
-    Returns the vertical header item for row \a row if one has been set;
-    otherwise returns 0.
-
-    \sa setVerticalHeaderItem(), horizontalHeaderItem()
-*/
-QStandardItem *QStandardItemModel::verticalHeaderItem(int row) const
-{
-    Q_D(const QStandardItemModel);
-    if ((row < 0) || (row >= rowCount()))
-        return 0;
-    return d->rowHeaderItems.at(row);
-}
-
-/*!
-    \since 4.2
-
-    Sets the horizontal header labels using \a labels. If necessary, the
-    column count is increased to the size of \a labels.
-
-    \sa setHorizontalHeaderItem()
-*/
-void QStandardItemModel::setHorizontalHeaderLabels(const QStringList &labels)
-{
-    Q_D(QStandardItemModel);
-    if (columnCount() < labels.count())
-        setColumnCount(labels.count());
-    for (int i = 0; i < labels.count(); ++i) {
-        QStandardItem *item = horizontalHeaderItem(i);
-        if (!item) {
-            item = d->createItem();
-            setHorizontalHeaderItem(i, item);
-        }
-        item->setText(labels.at(i));
-    }
-}
-
-/*!
-    \since 4.2
-
-    Sets the vertical header labels using \a labels. If necessary, the row
-    count is increased to the size of \a labels.
-
-    \sa setVerticalHeaderItem()
-*/
-void QStandardItemModel::setVerticalHeaderLabels(const QStringList &labels)
-{
-    Q_D(QStandardItemModel);
-    if (rowCount() < labels.count())
-        setRowCount(labels.count());
-    for (int i = 0; i < labels.count(); ++i) {
-        QStandardItem *item = verticalHeaderItem(i);
-        if (!item) {
-            item = d->createItem();
-            setVerticalHeaderItem(i, item);
-        }
-        item->setText(labels.at(i));
-    }
-}
-
-/*!
-    \since 4.2
-
-    Sets the item prototype for the model to the specified \a item. The model
-    takes ownership of the prototype.
-
-    The item prototype acts as a QStandardItem factory, by relying on the
-    QStandardItem::clone() function.  To provide your own prototype, subclass
-    QStandardItem, reimplement QStandardItem::clone() and set the prototype to
-    be an instance of your custom class. Whenever QStandardItemModel needs to
-    create an item on demand (for instance, when a view or item delegate calls
-    setData())), the new items will be instances of your custom class.
-
-    \sa itemPrototype(), QStandardItem::clone()
-*/
-void QStandardItemModel::setItemPrototype(const QStandardItem *item)
-{
-    Q_D(QStandardItemModel);
-    if (d->itemPrototype != item) {
-        delete d->itemPrototype;
-        d->itemPrototype = item;
-    }
-}
-
-/*!
-    \since 4.2
-
-    Returns the item prototype used by the model. The model uses the item
-    prototype as an item factory when it needs to construct new items on
-    demand (for instance, when a view or item delegate calls setData()).
-
-    \sa setItemPrototype()
-*/
-const QStandardItem *QStandardItemModel::itemPrototype() const
-{
-    Q_D(const QStandardItemModel);
-    return d->itemPrototype;
-}
-
-/*!
-    \since 4.2
-
-    Returns a list of items that match the given \a text, using the given \a
-    flags, in the given \a column.
-*/
-QList<QStandardItem*> QStandardItemModel::findItems(const QString &text,
-                                                    Qt::MatchFlags flags, int column) const
-{
-    QModelIndexList indexes = match(index(0, column, QModelIndex()),
-                                    Qt::DisplayRole, text, -1, flags);
-    QList<QStandardItem*> items;
-    for (int i = 0; i < indexes.size(); ++i)
-        items.append(itemFromIndex(indexes.at(i)));
-    return items;
-}
-
-/*!
-    \since 4.2
-
-    Appends a row containing \a items. If necessary, the column count is
-    increased to the size of \a items.
-
-    \sa insertRow(), appendColumn()
-*/
-void QStandardItemModel::appendRow(const QList<QStandardItem*> &items)
-{
-    invisibleRootItem()->appendRow(items);
-}
-
-/*!
-    \since 4.2
-
-    Appends a column containing \a items. If necessary, the row count is
-    increased to the size of \a items.
-
-    \sa insertColumn(), appendRow()
-*/
-void QStandardItemModel::appendColumn(const QList<QStandardItem*> &items)
-{
-    invisibleRootItem()->appendColumn(items);
-}
-
-/*!
-    \since 4.2
-    \fn QStandardItemModel::appendRow(QStandardItem *item)
-    \overload
-
-    When building a list or a tree that has only one column, this function
-    provides a convenient way to append a single new \a item.
-*/
-
-/*!
-    \since 4.2
-
-    Inserts a row at \a row containing \a items. If necessary, the column
-    count is increased to the size of \a items.
-
-    \sa takeRow(), appendRow(), insertColumn()
-*/
-void QStandardItemModel::insertRow(int row, const QList<QStandardItem*> &items)
-{
-    invisibleRootItem()->insertRow(row, items);
-}
-
-/*!
-    \since 4.2
-
-    \fn void QStandardItemModel::insertRow(int row, QStandardItem *item)
-    \overload
-
-    Inserts a row at \a row containing \a item.
-
-    When building a list or a tree that has only one column, this function
-    provides a convenient way to append a single new item.
-*/
-
-/*!
-    \since 4.2
-
-    Inserts a column at \a column containing \a items. If necessary, the row
-    count is increased to the size of \a items.
-
-    \sa takeColumn(), appendColumn(), insertRow()
-*/
-void QStandardItemModel::insertColumn(int column, const QList<QStandardItem*> &items)
-{
-    invisibleRootItem()->insertColumn(column, items);
-}
-
-/*!
-    \since 4.2
-
-    Removes the item at (\a row, \a column) without deleting it. The model
-    releases ownership of the item.
-
-    \sa item(), takeRow(), takeColumn()
-*/
-QStandardItem *QStandardItemModel::takeItem(int row, int column)
-{
-    Q_D(QStandardItemModel);
-    return d->root->takeChild(row, column);
-}
-
-/*!
-    \since 4.2
-
-    Removes the given \a row without deleting the row items, and returns a
-    list of pointers to the removed items. The model releases ownership of the
-    items. For items in the row that have not been set, the corresponding
-    pointers in the list will be 0.
-
-    \sa takeColumn()
-*/
-QList<QStandardItem*> QStandardItemModel::takeRow(int row)
-{
-    Q_D(QStandardItemModel);
-    return d->root->takeRow(row);
-}
-
-/*!
-    \since 4.2
-
-    Removes the given \a column without deleting the column items, and returns
-    a list of pointers to the removed items. The model releases ownership of
-    the items. For items in the column that have not been set, the
-    corresponding pointers in the list will be 0.
-
-    \sa takeRow()
-*/
-QList<QStandardItem*> QStandardItemModel::takeColumn(int column)
-{
-    Q_D(QStandardItemModel);
-    return d->root->takeColumn(column);
-}
-
-/*!
-    \since 4.2
-
-    Removes the horizontal header item at \a column from the header without
-    deleting it, and returns a pointer to the item. The model releases
-    ownership of the item.
-
-    \sa horizontalHeaderItem(), takeVerticalHeaderItem()
-*/
-QStandardItem *QStandardItemModel::takeHorizontalHeaderItem(int column)
-{
-    Q_D(QStandardItemModel);
-    if ((column < 0) || (column >= columnCount()))
-        return 0;
-    QStandardItem *headerItem = d->columnHeaderItems.at(column);
-    if (headerItem) {
-        headerItem->d_func()->setParentAndModel(0, 0);
-        d->columnHeaderItems.replace(column, 0);
-    }
-    return headerItem;
-}
-
-/*!
-    \since 4.2
-
-    Removes the vertical header item at \a row from the header without
-    deleting it, and returns a pointer to the item. The model releases
-    ownership of the item.
-
-    \sa verticalHeaderItem(), takeHorizontalHeaderItem()
-*/
-QStandardItem *QStandardItemModel::takeVerticalHeaderItem(int row)
-{
-    Q_D(QStandardItemModel);
-    if ((row < 0) || (row >= rowCount()))
-        return 0;
-    QStandardItem *headerItem = d->rowHeaderItems.at(row);
-    if (headerItem) {
-        headerItem->d_func()->setParentAndModel(0, 0);
-        d->rowHeaderItems.replace(row, 0);
-    }
-    return headerItem;
-}
-
-/*!
-    \since 4.2
-    \property QStandardItemModel::sortRole
-    \brief the item role that is used to query the model's data when sorting items
-
-    The default value is Qt::DisplayRole.
-
-    \sa sort(), QStandardItem::sortChildren()
-*/
-int QStandardItemModel::sortRole() const
-{
-    Q_D(const QStandardItemModel);
-    return d->sortRole;
-}
-
-void QStandardItemModel::setSortRole(int role)
-{
-    Q_D(QStandardItemModel);
-    d->sortRole = role;
-}
-
-/*!
-  \reimp
-*/
-int QStandardItemModel::columnCount(const QModelIndex &parent) const
-{
-    Q_D(const QStandardItemModel);
-    QStandardItem *item = d->itemFromIndex(parent);
-    return item ? item->columnCount() : 0;
-}
-
-/*!
-  \reimp
-*/
-QVariant QStandardItemModel::data(const QModelIndex &index, int role) const
-{
-    Q_D(const QStandardItemModel);
-    QStandardItem *item = d->itemFromIndex(index);
-    return item ? item->data(role) : QVariant();
-}
-
-/*!
-  \reimp
-*/
-Qt::ItemFlags QStandardItemModel::flags(const QModelIndex &index) const
-{
-    Q_D(const QStandardItemModel);
-    if (!d->indexValid(index))
-        return d->root->flags();
-    QStandardItem *item = d->itemFromIndex(index);
-    if (item)
-        return item->flags();
-    return Qt::ItemIsSelectable
-        |Qt::ItemIsEnabled
-        |Qt::ItemIsEditable
-        |Qt::ItemIsDragEnabled
-        |Qt::ItemIsDropEnabled;
-}
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::hasChildren(const QModelIndex &parent) const
-{
-    Q_D(const QStandardItemModel);
-    QStandardItem *item = d->itemFromIndex(parent);
-    return item ? item->hasChildren() : false;
-}
-
-/*!
-  \reimp
-*/
-QVariant QStandardItemModel::headerData(int section, Qt::Orientation orientation, int role) const
-{
-    Q_D(const QStandardItemModel);
-    if ((section < 0)
-        || ((orientation == Qt::Horizontal) && (section >= columnCount()))
-        || ((orientation == Qt::Vertical) && (section >= rowCount()))) {
-        return QVariant();
-    }
-    QStandardItem *headerItem = 0;
-    if (orientation == Qt::Horizontal)
-        headerItem = d->columnHeaderItems.at(section);
-    else if (orientation == Qt::Vertical)
-        headerItem = d->rowHeaderItems.at(section);
-    return headerItem ? headerItem->data(role)
-        : QAbstractItemModel::headerData(section, orientation, role);
-}
-
-/*!
-    \reimp
-
-    QStandardItemModel supports both copy and move.
-*/
-Qt::DropActions QStandardItemModel::supportedDropActions () const
-{
-    return Qt::CopyAction | Qt::MoveAction;
-}
-
-/*!
-  \reimp
-*/
-QModelIndex QStandardItemModel::index(int row, int column, const QModelIndex &parent) const
-{
-    Q_D(const QStandardItemModel);
-    QStandardItem *parentItem = d->itemFromIndex(parent);
-    if ((parentItem == 0)
-        || (row < 0)
-        || (column < 0)
-        || (row >= parentItem->rowCount())
-        || (column >= parentItem->columnCount())) {
-        return QModelIndex();
-    }
-    return createIndex(row, column, parentItem);
-}
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::insertColumns(int column, int count, const QModelIndex &parent)
-{
-    Q_D(QStandardItemModel);
-    QStandardItem *item = parent.isValid() ? itemFromIndex(parent) : d->root.data();
-    if (item == 0)
-        return false;
-    return item->d_func()->insertColumns(column, count, QList<QStandardItem*>());
-}
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::insertRows(int row, int count, const QModelIndex &parent)
-{
-    Q_D(QStandardItemModel);
-    QStandardItem *item = parent.isValid() ? itemFromIndex(parent) : d->root.data();
-    if (item == 0)
-        return false;
-    return item->d_func()->insertRows(row, count, QList<QStandardItem*>());
-}
-
-/*!
-  \reimp
-*/
-QMap<int, QVariant> QStandardItemModel::itemData(const QModelIndex &index) const
-{
-    Q_D(const QStandardItemModel);
-    QStandardItem *item = d->itemFromIndex(index);
-    return item ? item->d_func()->itemData() : QMap<int, QVariant>();
-}
-
-/*!
-  \reimp
-*/
-QModelIndex QStandardItemModel::parent(const QModelIndex &child) const
-{
-    Q_D(const QStandardItemModel);
-    if (!d->indexValid(child))
-        return QModelIndex();
-    QStandardItem *parentItem = static_cast<QStandardItem*>(child.internalPointer());
-    return indexFromItem(parentItem);
-}
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::removeColumns(int column, int count, const QModelIndex &parent)
-{
-    Q_D(QStandardItemModel);
-    QStandardItem *item = d->itemFromIndex(parent);
-    if ((item == 0) || (count < 1) || (column < 0) || ((column + count) > item->columnCount()))
-        return false;
-    item->removeColumns(column, count);
-    return true;
-}
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::removeRows(int row, int count, const QModelIndex &parent)
-{
-    Q_D(QStandardItemModel);
-    QStandardItem *item = d->itemFromIndex(parent);
-    if ((item == 0) || (count < 1) || (row < 0) || ((row + count) > item->rowCount()))
-        return false;
-    item->removeRows(row, count);
-    return true;
-}
-
-/*!
-  \reimp
-*/
-int QStandardItemModel::rowCount(const QModelIndex &parent) const
-{
-    Q_D(const QStandardItemModel);
-    QStandardItem *item = d->itemFromIndex(parent);
-    return item ? item->rowCount() : 0;
-}
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::setData(const QModelIndex &index, const QVariant &value, int role)
-{
-    if (!index.isValid())
-        return false;
-    QStandardItem *item = itemFromIndex(index);
-    if (item == 0)
-        return false;
-    item->setData(value, role);
-    return true;
-}
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
-{
-    Q_D(QStandardItemModel);
-    if ((section < 0)
-        || ((orientation == Qt::Horizontal) && (section >= columnCount()))
-        || ((orientation == Qt::Vertical) && (section >= rowCount()))) {
-        return false;
-    }
-    QStandardItem *headerItem = 0;
-    if (orientation == Qt::Horizontal) {
-        headerItem = d->columnHeaderItems.at(section);
-        if (headerItem == 0) {
-            headerItem = d->createItem();
-            headerItem->d_func()->setModel(this);
-            d->columnHeaderItems.replace(section, headerItem);
-        }
-    } else if (orientation == Qt::Vertical) {
-        headerItem = d->rowHeaderItems.at(section);
-        if (headerItem == 0) {
-            headerItem = d->createItem();
-            headerItem->d_func()->setModel(this);
-            d->rowHeaderItems.replace(section, headerItem);
-        }
-    }
-    if (headerItem) {
-        headerItem->setData(value, role);
-        return true;
-    }
-    return false;
-}
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles)
-{
-    QStandardItem *item = itemFromIndex(index);
-    if (item == 0)
-        return false;
-    item->d_func()->setItemData(roles);
-    return true;
-}
-
-/*!
-  \reimp
-*/
-void QStandardItemModel::sort(int column, Qt::SortOrder order)
-{
-    Q_D(QStandardItemModel);
-    d->root->sortChildren(column, order);
-}
-
-/*!
-  \fn QObject *QStandardItemModel::parent() const
-  \internal
-*/
-
-
-/*!
-  \reimp
-*/
-QStringList QStandardItemModel::mimeTypes() const
-{
-    return QAbstractItemModel::mimeTypes() <<  QLatin1String("application/x-qstandarditemmodeldatalist");
-}
-
-/*!
-  \reimp
-*/
-QMimeData *QStandardItemModel::mimeData(const QModelIndexList &indexes) const
-{
-    QMimeData *data = QAbstractItemModel::mimeData(indexes);
-    if(!data)
-        return 0;
-
-    QString format = QLatin1String("application/x-qstandarditemmodeldatalist");
-    if (!mimeTypes().contains(format))
-        return data;
-    QByteArray encoded;
-    QDataStream stream(&encoded, QIODevice::WriteOnly);
-    
-    QSet<QStandardItem*> itemsSet;
-    QStack<QStandardItem*> stack;
-    itemsSet.reserve(indexes.count());
-    stack.reserve(indexes.count());
-    for (int i = 0; i < indexes.count(); ++i) {
-        QStandardItem *item = itemFromIndex(indexes.at(i));
-        itemsSet << item;
-        stack.push(item);
-    }
-    
-    //remove duplicates childrens
-    {
-        QSet<QStandardItem *> seen;
-        while (!stack.isEmpty()) {
-            QStandardItem *itm = stack.pop();
-            if (seen.contains(itm))
-                continue;
-            seen.insert(itm);
-            
-            const QVector<QStandardItem*> &childList = itm->d_func()->children;
-            for (int i = 0; i < childList.count(); ++i) {
-                QStandardItem *chi = childList.at(i);
-                if (chi) {
-                    QSet<QStandardItem *>::iterator it = itemsSet.find(chi);
-                    if (it != itemsSet.end()) {
-                        itemsSet.erase(it);
-                    }
-                    stack.push(chi);
-                }
-            }
-        }
-    }
-    
-    stack.reserve(itemsSet.count());
-    foreach (QStandardItem *item, itemsSet) {
-        stack.push(item);
-    }
-    
-    //stream everything recursively
-    while (!stack.isEmpty()) {
-        QStandardItem *item = stack.pop();
-        if(itemsSet.contains(item)) { //if the item is selection 'top-level', strem its position
-            stream << item->row() << item->column(); 
-        }
-        if(item) {
-            stream << *item << item->columnCount() << item->d_ptr->children.count();
-            stack += item->d_ptr->children;
-        } else {
-            QStandardItem dummy;
-            stream << dummy << 0 << 0;
-        }
-    }
-
-    data->setData(format, encoded);
-    return data;
-}
-
-
-/* \internal
-    Used by QStandardItemModel::dropMimeData
-    stream out an item and his children 
- */
-void QStandardItemModelPrivate::decodeDataRecursive(QDataStream &stream, QStandardItem *item)
-{
-    int colCount, childCount;
-    stream >> *item;
-    stream >> colCount >> childCount;
-    item->setColumnCount(colCount);
-    
-    int childPos = childCount;
-    
-    while(childPos > 0) {
-        childPos--;
-        QStandardItem *child = createItem();
-        decodeDataRecursive(stream, child);
-        item->setChild( childPos / colCount, childPos % colCount, child);
-    }
-}
-
-
-/*!
-  \reimp
-*/
-bool QStandardItemModel::dropMimeData(const QMimeData *data, Qt::DropAction action,
-                                      int row, int column, const QModelIndex &parent)
-{
-    Q_D(QStandardItemModel);
-    // check if the action is supported
-    if (!data || !(action == Qt::CopyAction || action == Qt::MoveAction))
-        return false;
-    // check if the format is supported
-    QString format = QLatin1String("application/x-qstandarditemmodeldatalist");
-    if (!data->hasFormat(format))
-        return QAbstractItemModel::dropMimeData(data, action, row, column, parent);
-
-    if (row > rowCount(parent))
-        row = rowCount(parent);
-    if (row == -1)
-        row = rowCount(parent);
-    if (column == -1)
-        column = 0;
-
-    // decode and insert
-    QByteArray encoded = data->data(format);
-    QDataStream stream(&encoded, QIODevice::ReadOnly);
-
-
-    //code based on QAbstractItemModel::decodeData
-    // adapted to work with QStandardItem
-    int top = INT_MAX;
-    int left = INT_MAX;
-    int bottom = 0;
-    int right = 0;
-    QVector<int> rows, columns;
-    QVector<QStandardItem *> items;
-
-    while (!stream.atEnd()) {
-        int r, c;
-        QStandardItem *item = d->createItem();
-        stream >> r >> c;
-        d->decodeDataRecursive(stream, item);
-
-        rows.append(r);
-        columns.append(c);
-        items.append(item);
-        top = qMin(r, top);
-        left = qMin(c, left);
-        bottom = qMax(r, bottom);
-        right = qMax(c, right);
-    }
-
-    // insert the dragged items into the table, use a bit array to avoid overwriting items,
-    // since items from different tables can have the same row and column
-    int dragRowCount = 0;
-    int dragColumnCount = right - left + 1;
-
-    // Compute the number of continuous rows upon insertion and modify the rows to match
-    QVector<int> rowsToInsert(bottom + 1);
-    for (int i = 0; i < rows.count(); ++i)
-        rowsToInsert[rows.at(i)] = 1;
-    for (int i = 0; i < rowsToInsert.count(); ++i) {
-        if (rowsToInsert[i] == 1){
-            rowsToInsert[i] = dragRowCount;
-            ++dragRowCount;
-        }
-    }
-    for (int i = 0; i < rows.count(); ++i)
-        rows[i] = top + rowsToInsert[rows[i]];
-
-    QBitArray isWrittenTo(dragRowCount * dragColumnCount);
-
-    // make space in the table for the dropped data
-    int colCount = columnCount(parent);
-    if (colCount < dragColumnCount + column) {
-        insertColumns(colCount, dragColumnCount + column - colCount, parent);
-        colCount = columnCount(parent);
-    }
-    insertRows(row, dragRowCount, parent);
-
-    row = qMax(0, row);
-    column = qMax(0, column);
-
-    QStandardItem *parentItem = itemFromIndex (parent);
-    if (!parentItem)
-        parentItem = invisibleRootItem();
-
-    QVector<QPersistentModelIndex> newIndexes(items.size());
-    // set the data in the table
-    for (int j = 0; j < items.size(); ++j) {
-        int relativeRow = rows.at(j) - top;
-        int relativeColumn = columns.at(j) - left;
-        int destinationRow = relativeRow + row;
-        int destinationColumn = relativeColumn + column;
-        int flat = (relativeRow * dragColumnCount) + relativeColumn;
-        // if the item was already written to, or we just can't fit it in the table, create a new row
-        if (destinationColumn >= colCount || isWrittenTo.testBit(flat)) {
-            destinationColumn = qBound(column, destinationColumn, colCount - 1);
-            destinationRow = row + dragRowCount;
-            insertRows(row + dragRowCount, 1, parent);
-            flat = (dragRowCount * dragColumnCount) + relativeColumn;
-            isWrittenTo.resize(++dragRowCount * dragColumnCount);
-        }
-        if (!isWrittenTo.testBit(flat)) {
-            newIndexes[j] = index(destinationRow, destinationColumn, parentItem->index());
-            isWrittenTo.setBit(flat);
-        }
-    }
-
-    for(int k = 0; k < newIndexes.size(); k++) {
-        if (newIndexes.at(k).isValid()) {
-            parentItem->setChild(newIndexes.at(k).row(), newIndexes.at(k).column(), items.at(k));
-        } else {
-            delete items.at(k);
-        }
-    }
-
-    return true;
-}
-
-QT_END_NAMESPACE
-
-#include "moc_qstandarditemmodel.cpp"
-
-#endif // QT_NO_STANDARDITEMMODEL
diff --git a/src/widgets/itemviews/qstandarditemmodel.h b/src/widgets/itemviews/qstandarditemmodel.h
deleted file mode 100644
index 2f449ab..0000000
--- a/src/widgets/itemviews/qstandarditemmodel.h
+++ /dev/null
@@ -1,457 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QSTANDARDITEMMODEL_H
-#define QSTANDARDITEMMODEL_H
-
-#include <QtCore/qabstractitemmodel.h>
-#include <QtGui/qbrush.h>
-#include <QtGui/qfont.h>
-#include <QtGui/qicon.h>
-#ifndef QT_NO_DATASTREAM
-#include <QtCore/qdatastream.h>
-#endif
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-#ifndef QT_NO_STANDARDITEMMODEL
-
-template <class T> class QList;
-
-class QStandardItemModel;
-
-class QStandardItemPrivate;
-class Q_WIDGETS_EXPORT QStandardItem
-{
-public:
-    QStandardItem();
-    explicit QStandardItem(const QString &text);
-    QStandardItem(const QIcon &icon, const QString &text);
-    explicit QStandardItem(int rows, int columns = 1);
-    virtual ~QStandardItem();
-
-    virtual QVariant data(int role = Qt::UserRole + 1) const;
-    virtual void setData(const QVariant &value, int role = Qt::UserRole + 1);
-
-    inline QString text() const {
-        return qvariant_cast<QString>(data(Qt::DisplayRole));
-    }
-    inline void setText(const QString &text);
-
-    inline QIcon icon() const {
-        return qvariant_cast<QIcon>(data(Qt::DecorationRole));
-    }
-    inline void setIcon(const QIcon &icon);
-
-#ifndef QT_NO_TOOLTIP
-    inline QString toolTip() const {
-        return qvariant_cast<QString>(data(Qt::ToolTipRole));
-    }
-    inline void setToolTip(const QString &toolTip);
-#endif
-
-#ifndef QT_NO_STATUSTIP
-    inline QString statusTip() const {
-        return qvariant_cast<QString>(data(Qt::StatusTipRole));
-    }
-    inline void setStatusTip(const QString &statusTip);
-#endif
-
-#ifndef QT_NO_WHATSTHIS
-    inline QString whatsThis() const {
-        return qvariant_cast<QString>(data(Qt::WhatsThisRole));
-    }
-    inline void setWhatsThis(const QString &whatsThis);
-#endif
-
-    inline QSize sizeHint() const {
-        return qvariant_cast<QSize>(data(Qt::SizeHintRole));
-    }
-    inline void setSizeHint(const QSize &sizeHint);
-
-    inline QFont font() const {
-        return qvariant_cast<QFont>(data(Qt::FontRole));
-    }
-    inline void setFont(const QFont &font);
-
-    inline Qt::Alignment textAlignment() const {
-        return Qt::Alignment(qvariant_cast<int>(data(Qt::TextAlignmentRole)));
-    }
-    inline void setTextAlignment(Qt::Alignment textAlignment);
-
-    inline QBrush background() const {
-        return qvariant_cast<QBrush>(data(Qt::BackgroundRole));
-    }
-    inline void setBackground(const QBrush &brush);
-
-    inline QBrush foreground() const {
-        return qvariant_cast<QBrush>(data(Qt::ForegroundRole));
-    }
-    inline void setForeground(const QBrush &brush);
-
-    inline Qt::CheckState checkState() const {
-        return Qt::CheckState(qvariant_cast<int>(data(Qt::CheckStateRole)));
-    }
-    inline void setCheckState(Qt::CheckState checkState);
-
-    inline QString accessibleText() const {
-        return qvariant_cast<QString>(data(Qt::AccessibleTextRole));
-    }
-    inline void setAccessibleText(const QString &accessibleText);
-
-    inline QString accessibleDescription() const {
-        return qvariant_cast<QString>(data(Qt::AccessibleDescriptionRole));
-    }
-    inline void setAccessibleDescription(const QString &accessibleDescription);
-
-    Qt::ItemFlags flags() const;
-    void setFlags(Qt::ItemFlags flags);
-
-    inline bool isEnabled() const {
-        return (flags() & Qt::ItemIsEnabled) != 0;
-    }
-    void setEnabled(bool enabled);
-
-    inline bool isEditable() const {
-        return (flags() & Qt::ItemIsEditable) != 0;
-    }
-    void setEditable(bool editable);
-
-    inline bool isSelectable() const {
-        return (flags() & Qt::ItemIsSelectable) != 0;
-    }
-    void setSelectable(bool selectable);
-
-    inline bool isCheckable() const {
-        return (flags() & Qt::ItemIsUserCheckable) != 0;
-    }
-    void setCheckable(bool checkable);
-
-    inline bool isTristate() const {
-        return (flags() & Qt::ItemIsTristate) != 0;
-    }
-    void setTristate(bool tristate);
-
-#ifndef QT_NO_DRAGANDDROP
-    inline bool isDragEnabled() const {
-        return (flags() & Qt::ItemIsDragEnabled) != 0;
-    }
-    void setDragEnabled(bool dragEnabled);
-
-    inline bool isDropEnabled() const {
-        return (flags() & Qt::ItemIsDropEnabled) != 0;
-    }
-    void setDropEnabled(bool dropEnabled);
-#endif // QT_NO_DRAGANDDROP
-
-    QStandardItem *parent() const;
-    int row() const;
-    int column() const;
-    QModelIndex index() const;
-    QStandardItemModel *model() const;
-
-    int rowCount() const;
-    void setRowCount(int rows);
-    int columnCount() const;
-    void setColumnCount(int columns);
-
-    bool hasChildren() const;
-    QStandardItem *child(int row, int column = 0) const;
-    void setChild(int row, int column, QStandardItem *item);
-    inline void setChild(int row, QStandardItem *item);
-
-    void insertRow(int row, const QList<QStandardItem*> &items);
-    void insertColumn(int column, const QList<QStandardItem*> &items);
-    void insertRows(int row, const QList<QStandardItem*> &items);
-    void insertRows(int row, int count);
-    void insertColumns(int column, int count);
-
-    void removeRow(int row);
-    void removeColumn(int column);
-    void removeRows(int row, int count);
-    void removeColumns(int column, int count);
-
-    inline void appendRow(const QList<QStandardItem*> &items);
-    inline void appendRows(const QList<QStandardItem*> &items);
-    inline void appendColumn(const QList<QStandardItem*> &items);
-    inline void insertRow(int row, QStandardItem *item);
-    inline void appendRow(QStandardItem *item);
-
-    QStandardItem *takeChild(int row, int column = 0);
-    QList<QStandardItem*> takeRow(int row);
-    QList<QStandardItem*> takeColumn(int column);
-
-    void sortChildren(int column, Qt::SortOrder order = Qt::AscendingOrder);
-
-    virtual QStandardItem *clone() const;
-
-    enum ItemType { Type = 0, UserType = 1000 };
-    virtual int type() const;
-
-#ifndef QT_NO_DATASTREAM
-    virtual void read(QDataStream &in);
-    virtual void write(QDataStream &out) const;
-#endif
-    virtual bool operator<(const QStandardItem &other) const;
-
-protected:
-    QStandardItem(const QStandardItem &other);
-    QStandardItem(QStandardItemPrivate &dd);
-    QStandardItem &operator=(const QStandardItem &other);
-    QScopedPointer<QStandardItemPrivate> d_ptr;
-
-    void emitDataChanged();
-
-private:
-    Q_DECLARE_PRIVATE(QStandardItem)
-    friend class QStandardItemModelPrivate;
-    friend class QStandardItemModel;
-};
-
-inline void QStandardItem::setText(const QString &atext)
-{ setData(atext, Qt::DisplayRole); }
-
-inline void QStandardItem::setIcon(const QIcon &aicon)
-{ setData(aicon, Qt::DecorationRole); }
-
-#ifndef QT_NO_TOOLTIP
-inline void QStandardItem::setToolTip(const QString &atoolTip)
-{ setData(atoolTip, Qt::ToolTipRole); }
-#endif
-
-#ifndef QT_NO_STATUSTIP
-inline void QStandardItem::setStatusTip(const QString &astatusTip)
-{ setData(astatusTip, Qt::StatusTipRole); }
-#endif
-
-#ifndef QT_NO_WHATSTHIS
-inline void QStandardItem::setWhatsThis(const QString &awhatsThis)
-{ setData(awhatsThis, Qt::WhatsThisRole); }
-#endif
-
-inline void QStandardItem::setSizeHint(const QSize &asizeHint)
-{ setData(asizeHint, Qt::SizeHintRole); }
-
-inline void QStandardItem::setFont(const QFont &afont)
-{ setData(afont, Qt::FontRole); }
-
-inline void QStandardItem::setTextAlignment(Qt::Alignment atextAlignment)
-{ setData(int(atextAlignment), Qt::TextAlignmentRole); }
-
-inline void QStandardItem::setBackground(const QBrush &abrush)
-{ setData(abrush, Qt::BackgroundRole); }
-
-inline void QStandardItem::setForeground(const QBrush &abrush)
-{ setData(abrush, Qt::ForegroundRole); }
-
-inline void QStandardItem::setCheckState(Qt::CheckState acheckState)
-{ setData(acheckState, Qt::CheckStateRole); }
-
-inline void QStandardItem::setAccessibleText(const QString &aaccessibleText)
-{ setData(aaccessibleText, Qt::AccessibleTextRole); }
-
-inline void QStandardItem::setAccessibleDescription(const QString &aaccessibleDescription)
-{ setData(aaccessibleDescription, Qt::AccessibleDescriptionRole); }
-
-inline void QStandardItem::setChild(int arow, QStandardItem *aitem)
-{ setChild(arow, 0, aitem); }
-
-inline void QStandardItem::appendRow(const QList<QStandardItem*> &aitems)
-{ insertRow(rowCount(), aitems); }
-
-inline void QStandardItem::appendRows(const QList<QStandardItem*> &aitems)
-{ insertRows(rowCount(), aitems); }
-
-inline void QStandardItem::appendColumn(const QList<QStandardItem*> &aitems)
-{ insertColumn(columnCount(), aitems); }
-
-inline void QStandardItem::insertRow(int arow, QStandardItem *aitem)
-{ insertRow(arow, QList<QStandardItem*>() << aitem); }
-
-inline void QStandardItem::appendRow(QStandardItem *aitem)
-{ insertRow(rowCount(), aitem); }
-
-class QStandardItemModelPrivate;
-
-class Q_WIDGETS_EXPORT QStandardItemModel : public QAbstractItemModel
-{
-    Q_OBJECT
-    Q_PROPERTY(int sortRole READ sortRole WRITE setSortRole)
-
-public:
-    explicit QStandardItemModel(QObject *parent = 0);
-    QStandardItemModel(int rows, int columns, QObject *parent = 0);
-    ~QStandardItemModel();
-
-    void setItemRoleNames(const QHash<int,QByteArray> &roleNames);
-
-    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
-    QModelIndex parent(const QModelIndex &child) const;
-
-    int rowCount(const QModelIndex &parent = QModelIndex()) const;
-    int columnCount(const QModelIndex &parent = QModelIndex()) const;
-    bool hasChildren(const QModelIndex &parent = QModelIndex()) const;
-
-    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
-    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);
-
-    QVariant headerData(int section, Qt::Orientation orientation,
-                        int role = Qt::DisplayRole) const;
-    bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
-                       int role = Qt::EditRole);
-
-    bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
-    bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
-    bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
-    bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());
-
-    Qt::ItemFlags flags(const QModelIndex &index) const;
-    Qt::DropActions supportedDropActions() const;
-
-    QMap<int, QVariant> itemData(const QModelIndex &index) const;
-    bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);
-
-    void clear();
-
-#ifdef Q_NO_USING_KEYWORD
-    inline QObject *parent() const { return QObject::parent(); }
-#else
-    using QObject::parent;
-#endif
-
-    void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);
-
-    QStandardItem *itemFromIndex(const QModelIndex &index) const;
-    QModelIndex indexFromItem(const QStandardItem *item) const;
-
-    QStandardItem *item(int row, int column = 0) const;
-    void setItem(int row, int column, QStandardItem *item);
-    inline void setItem(int row, QStandardItem *item);
-    QStandardItem *invisibleRootItem() const;
-
-    QStandardItem *horizontalHeaderItem(int column) const;
-    void setHorizontalHeaderItem(int column, QStandardItem *item);
-    QStandardItem *verticalHeaderItem(int row) const;
-    void setVerticalHeaderItem(int row, QStandardItem *item);
-
-    void setHorizontalHeaderLabels(const QStringList &labels);
-    void setVerticalHeaderLabels(const QStringList &labels);
-
-    void setRowCount(int rows);
-    void setColumnCount(int columns);
-
-    void appendRow(const QList<QStandardItem*> &items);
-    void appendColumn(const QList<QStandardItem*> &items);
-    inline void appendRow(QStandardItem *item);
-
-    void insertRow(int row, const QList<QStandardItem*> &items);
-    void insertColumn(int column, const QList<QStandardItem*> &items);
-    inline void insertRow(int row, QStandardItem *item);
-
-    inline bool insertRow(int row, const QModelIndex &parent = QModelIndex());
-    inline bool insertColumn(int column, const QModelIndex &parent = QModelIndex());
-
-    QStandardItem *takeItem(int row, int column = 0);
-    QList<QStandardItem*> takeRow(int row);
-    QList<QStandardItem*> takeColumn(int column);
-
-    QStandardItem *takeHorizontalHeaderItem(int column);
-    QStandardItem *takeVerticalHeaderItem(int row);
-
-    const QStandardItem *itemPrototype() const;
-    void setItemPrototype(const QStandardItem *item);
-
-    QList<QStandardItem*> findItems(const QString &text,
-                                    Qt::MatchFlags flags = Qt::MatchExactly,
-                                    int column = 0) const;
-
-    int sortRole() const;
-    void setSortRole(int role);
-
-    QStringList mimeTypes() const;
-    QMimeData *mimeData(const QModelIndexList &indexes) const;
-    bool dropMimeData (const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &parent);
-
-Q_SIGNALS:
-    void itemChanged(QStandardItem *item);
-
-protected:
-    QStandardItemModel(QStandardItemModelPrivate &dd, QObject *parent = 0);
-
-private:
-    friend class QStandardItemPrivate;
-    friend class QStandardItem;
-    Q_DISABLE_COPY(QStandardItemModel)
-    Q_DECLARE_PRIVATE(QStandardItemModel)
-
-    Q_PRIVATE_SLOT(d_func(), void _q_emitItemChanged(const QModelIndex &topLeft,
-                                                     const QModelIndex &bottomRight))
-};
-
-inline void QStandardItemModel::setItem(int arow, QStandardItem *aitem)
-{ setItem(arow, 0, aitem); }
-
-inline void QStandardItemModel::appendRow(QStandardItem *aitem)
-{ appendRow(QList<QStandardItem*>() << aitem); }
-
-inline void QStandardItemModel::insertRow(int arow, QStandardItem *aitem)
-{ insertRow(arow, QList<QStandardItem*>() << aitem); }
-
-inline bool QStandardItemModel::insertRow(int arow, const QModelIndex &aparent)
-{ return QAbstractItemModel::insertRow(arow, aparent); }
-inline bool QStandardItemModel::insertColumn(int acolumn, const QModelIndex &aparent)
-{ return QAbstractItemModel::insertColumn(acolumn, aparent); }
-
-#ifndef QT_NO_DATASTREAM
-Q_WIDGETS_EXPORT QDataStream &operator>>(QDataStream &in, QStandardItem &item);
-Q_WIDGETS_EXPORT QDataStream &operator<<(QDataStream &out, const QStandardItem &item);
-#endif
-
-#endif // QT_NO_STANDARDITEMMODEL
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif //QSTANDARDITEMMODEL_H
diff --git a/src/widgets/itemviews/qstandarditemmodel_p.h b/src/widgets/itemviews/qstandarditemmodel_p.h
deleted file mode 100644
index 8278bd1..0000000
--- a/src/widgets/itemviews/qstandarditemmodel_p.h
+++ /dev/null
@@ -1,192 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QSTANDARDITEMMODEL_P_H
-#define QSTANDARDITEMMODEL_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience
-// of other Qt classes.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "private/qabstractitemmodel_p.h"
-
-#ifndef QT_NO_STANDARDITEMMODEL
-
-#include <private/qwidgetitemdata_p.h>
-#include <QtCore/qlist.h>
-#include <QtCore/qpair.h>
-#include <QtCore/qstack.h>
-#include <QtCore/qvariant.h>
-#include <QtCore/qvector.h>
-
-QT_BEGIN_NAMESPACE
-
-class QStandardItemPrivate
-{
-    Q_DECLARE_PUBLIC(QStandardItem)
-public:
-    inline QStandardItemPrivate()
-        : model(0),
-          parent(0),
-          rows(0),
-          columns(0),
-          q_ptr(0),
-          lastIndexOf(2)
-        { }
-    virtual ~QStandardItemPrivate();
-
-    inline int childIndex(int row, int column) const {
-        if ((row < 0) || (column < 0)
-            || (row >= rowCount()) || (column >= columnCount())) {
-            return -1;
-        }
-        return (row * columnCount()) + column;
-    }
-    inline int childIndex(const QStandardItem *child) {
-        int start = qMax(0, lastIndexOf -2);
-        lastIndexOf = children.indexOf(const_cast<QStandardItem*>(child), start);
-        if (lastIndexOf == -1 && start != 0)
-            lastIndexOf = children.lastIndexOf(const_cast<QStandardItem*>(child), start);
-        return lastIndexOf;
-    }
-    QPair<int, int> position() const;
-    void setChild(int row, int column, QStandardItem *item,
-                  bool emitChanged = false);
-    inline int rowCount() const {
-        return rows;
-    }
-    inline int columnCount() const {
-        return columns;
-    }
-    void childDeleted(QStandardItem *child);
-
-    void setModel(QStandardItemModel *mod);
-
-    inline void setParentAndModel(
-        QStandardItem *par,
-        QStandardItemModel *mod) {
-        setModel(mod);
-        parent = par;
-    }
-
-    void changeFlags(bool enable, Qt::ItemFlags f);
-    void setItemData(const QMap<int, QVariant> &roles);
-    const QMap<int, QVariant> itemData() const;
-
-    bool insertRows(int row, int count, const QList<QStandardItem*> &items);
-    bool insertRows(int row, const QList<QStandardItem*> &items);
-    bool insertColumns(int column, int count, const QList<QStandardItem*> &items);
-
-    void sortChildren(int column, Qt::SortOrder order);
-
-    QStandardItemModel *model;
-    QStandardItem *parent;
-    QVector<QWidgetItemData> values;
-    QVector<QStandardItem*> children;
-    int rows;
-    int columns;
-
-    QStandardItem *q_ptr;
-
-    int lastIndexOf;
-};
-
-class QStandardItemModelPrivate : public QAbstractItemModelPrivate
-{
-    Q_DECLARE_PUBLIC(QStandardItemModel)
-
-public:
-    QStandardItemModelPrivate();
-    virtual ~QStandardItemModelPrivate();
-
-    void init();
-
-    inline QStandardItem *createItem() const {
-        return itemPrototype ? itemPrototype->clone() : new QStandardItem;
-    }
-
-    inline QStandardItem *itemFromIndex(const QModelIndex &index) const {
-        Q_Q(const QStandardItemModel);
-        if (!index.isValid())
-            return root.data();
-        if (index.model() != q)
-            return 0;
-        QStandardItem *parent = static_cast<QStandardItem*>(index.internalPointer());
-        if (parent == 0)
-            return 0;
-        return parent->child(index.row(), index.column());
-    }
-
-    void sort(QStandardItem *parent, int column, Qt::SortOrder order);
-    void itemChanged(QStandardItem *item);
-    void rowsAboutToBeInserted(QStandardItem *parent, int start, int end);
-    void columnsAboutToBeInserted(QStandardItem *parent, int start, int end);
-    void rowsAboutToBeRemoved(QStandardItem *parent, int start, int end);
-    void columnsAboutToBeRemoved(QStandardItem *parent, int start, int end);
-    void rowsInserted(QStandardItem *parent, int row, int count);
-    void columnsInserted(QStandardItem *parent, int column, int count);
-    void rowsRemoved(QStandardItem *parent, int row, int count);
-    void columnsRemoved(QStandardItem *parent, int column, int count);
-
-    void _q_emitItemChanged(const QModelIndex &topLeft,
-                            const QModelIndex &bottomRight);
-
-    void decodeDataRecursive(QDataStream &stream, QStandardItem *item);
-
-    QVector<QStandardItem*> columnHeaderItems;
-    QVector<QStandardItem*> rowHeaderItems;
-    QScopedPointer<QStandardItem> root;
-    const QStandardItem *itemPrototype;
-    int sortRole;
-};
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_STANDARDITEMMODEL
-
-#endif // QSTANDARDITEMMODEL_P_H
diff --git a/src/widgets/widgets/qcombobox_p.h b/src/widgets/widgets/qcombobox_p.h
index 68b52ae..dbb2397 100644
--- a/src/widgets/widgets/qcombobox_p.h
+++ b/src/widgets/widgets/qcombobox_p.h
@@ -59,7 +59,7 @@
 #include "QtWidgets/qabstractslider.h"
 #include "QtWidgets/qapplication.h"
 #include "QtWidgets/qitemdelegate.h"
-#include "QtWidgets/qstandarditemmodel.h"
+#include "QtGui/qstandarditemmodel.h"
 #include "QtWidgets/qlineedit.h"
 #include "QtWidgets/qlistview.h"
 #include "QtGui/qpainter.h"
diff --git a/sync.profile b/sync.profile
index e6c8116..460e708 100644
--- a/sync.profile
+++ b/sync.profile
@@ -93,7 +93,11 @@
         "qplatformmenu_qpa.h" => "qpa/qplatformmenu.h",
         "QPlatformMenu" => "qpa/qplatformmenu.h",
         "QPlatformMenuAction" => "qpa/qplatformmenu.h",
-        "QPlatformMenuBar" => "qpa/qplatformmenu.h"
+        "QPlatformMenuBar" => "qpa/qplatformmenu.h",
+        "QStandardItem" => "QtGui/QStandardItem",
+        "QStandardItemModel" => "QtGui/QStandardItemModel",
+        "qstandarditem.h" => "QtGui/qstandarditem.h",
+        "qstandarditemmodel.h" => "QtGui/qstandarditemmodel.h"
     },
     "QtPrintSupport" => {
         "qplatformprintersupport_qpa.h" => "qpa/qplatformprintersupport.h",
diff --git a/tests/auto/corelib/itemmodels/qidentityproxymodel/qidentityproxymodel.pro b/tests/auto/corelib/itemmodels/qidentityproxymodel/qidentityproxymodel.pro
index c56498a..6de1ffa 100644
--- a/tests/auto/corelib/itemmodels/qidentityproxymodel/qidentityproxymodel.pro
+++ b/tests/auto/corelib/itemmodels/qidentityproxymodel/qidentityproxymodel.pro
@@ -4,6 +4,6 @@ TARGET = tst_qidentityproxymodel
 
 mtdir = ../../../other/modeltest
 INCLUDEPATH += $$PWD/$${mtdir}
-QT += widgets testlib
+QT += testlib
 SOURCES         += tst_qidentityproxymodel.cpp $${mtdir}/dynamictreemodel.cpp $${mtdir}/modeltest.cpp
 HEADERS         += $${mtdir}/dynamictreemodel.h $${mtdir}/modeltest.h
diff --git a/tests/auto/corelib/itemmodels/qidentityproxymodel/tst_qidentityproxymodel.cpp b/tests/auto/corelib/itemmodels/qidentityproxymodel/tst_qidentityproxymodel.cpp
index 567bb58..0102464 100644
--- a/tests/auto/corelib/itemmodels/qidentityproxymodel/tst_qidentityproxymodel.cpp
+++ b/tests/auto/corelib/itemmodels/qidentityproxymodel/tst_qidentityproxymodel.cpp
@@ -41,7 +41,7 @@
 
 #include <QtTest/QtTest>
 #include <QtCore/QCoreApplication>
-#include <QtWidgets/QStandardItemModel>
+#include <QtGui/QStandardItemModel>
 
 #include "dynamictreemodel.h"
 #include "qidentityproxymodel.h"
diff --git a/tests/auto/corelib/itemmodels/qsortfilterproxymodel/tst_qsortfilterproxymodel.cpp b/tests/auto/corelib/itemmodels/qsortfilterproxymodel/tst_qsortfilterproxymodel.cpp
index b31b64d..bb3132b 100644
--- a/tests/auto/corelib/itemmodels/qsortfilterproxymodel/tst_qsortfilterproxymodel.cpp
+++ b/tests/auto/corelib/itemmodels/qsortfilterproxymodel/tst_qsortfilterproxymodel.cpp
@@ -44,7 +44,7 @@
 #include "modeltest.h"
 
 #include <QtCore/QCoreApplication>
-#include <QtWidgets/QStandardItem>
+#include <QtGui/QStandardItem>
 #include <QtWidgets/QTreeView>
 #include <QtWidgets/QTableView>
 
diff --git a/tests/auto/gui/gui.pro b/tests/auto/gui/gui.pro
index 48fa277..87aea70 100644
--- a/tests/auto/gui/gui.pro
+++ b/tests/auto/gui/gui.pro
@@ -7,3 +7,4 @@ SUBDIRS=\
     qopengl \
     text \
     util \
+    itemmodels \
diff --git a/tests/auto/gui/itemmodels/itemmodels.pro b/tests/auto/gui/itemmodels/itemmodels.pro
new file mode 100644
index 0000000..2e7fabf
--- /dev/null
+++ b/tests/auto/gui/itemmodels/itemmodels.pro
@@ -0,0 +1,4 @@
+TEMPLATE=subdirs
+SUBDIRS= \
+    qstandarditem \
+    qstandarditemmodel \
diff --git a/tests/auto/gui/itemmodels/qstandarditem/.gitignore b/tests/auto/gui/itemmodels/qstandarditem/.gitignore
new file mode 100644
index 0000000..6da85cc
--- /dev/null
+++ b/tests/auto/gui/itemmodels/qstandarditem/.gitignore
@@ -0,0 +1 @@
+tst_qstandarditem
diff --git a/tests/auto/gui/itemmodels/qstandarditem/qstandarditem.pro b/tests/auto/gui/itemmodels/qstandarditem/qstandarditem.pro
new file mode 100644
index 0000000..282737e
--- /dev/null
+++ b/tests/auto/gui/itemmodels/qstandarditem/qstandarditem.pro
@@ -0,0 +1,7 @@
+CONFIG += testcase
+CONFIG += parallel_test
+TARGET = tst_qstandarditem
+QT += gui testlib
+SOURCES  += tst_qstandarditem.cpp
+
+
diff --git a/tests/auto/gui/itemmodels/qstandarditem/tst_qstandarditem.cpp b/tests/auto/gui/itemmodels/qstandarditem/tst_qstandarditem.cpp
new file mode 100644
index 0000000..8ababf0
--- /dev/null
+++ b/tests/auto/gui/itemmodels/qstandarditem/tst_qstandarditem.cpp
@@ -0,0 +1,1107 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#include <QtTest/QtTest>
+
+#include <qstandarditemmodel.h>
+
+class tst_QStandardItem : public QObject
+{
+    Q_OBJECT
+
+public:
+    tst_QStandardItem();
+    virtual ~tst_QStandardItem();
+
+public slots:
+    void init();
+    void cleanup();
+
+private slots:
+    void ctor();
+    void textCtor();
+    void iconTextCtor();
+    void rowsColumnsCtor();
+    void getSetData();
+    void getSetFlags();
+    void getSetRowAndColumnCount();
+    void getSetChild_data();
+    void getSetChild();
+    void parent();
+    void insertColumn_data();
+    void insertColumn();
+    void insertColumns_data();
+    void insertColumns();
+    void insertRow_data();
+    void insertRow();
+    void insertRows_data();
+    void insertRows();
+    void appendColumn_data();
+    void appendColumn();
+    void appendRow_data();
+    void appendRow();
+    void takeChild();
+    void takeColumn_data();
+    void takeColumn();
+    void takeRow_data();
+    void takeRow();
+    void streamItem();
+    void deleteItem();
+    void clone();
+    void sortChildren();
+    void subclassing();
+};
+
+tst_QStandardItem::tst_QStandardItem()
+{
+}
+
+tst_QStandardItem::~tst_QStandardItem()
+{
+}
+
+void tst_QStandardItem::init()
+{
+}
+
+void tst_QStandardItem::cleanup()
+{
+}
+
+void tst_QStandardItem::ctor()
+{
+    QStandardItem item;
+    QVERIFY(!item.hasChildren());
+}
+
+void tst_QStandardItem::textCtor()
+{
+    QLatin1String text("text");
+    QStandardItem item(text);
+    QCOMPARE(item.text(), text);
+    QVERIFY(!item.hasChildren());
+}
+
+void tst_QStandardItem::iconTextCtor()
+{
+    QPixmap pixmap(32, 32);
+    pixmap.fill(Qt::red);
+    QIcon icon(pixmap);
+    QLatin1String text("text");
+    QStandardItem item(icon, text);
+    QCOMPARE(item.icon(), icon);
+    QCOMPARE(item.text(), text);
+    QVERIFY(!item.hasChildren());
+}
+
+void tst_QStandardItem::rowsColumnsCtor()
+{
+    const int rows = 5;
+    const int columns = 12;
+    QStandardItem item(rows, columns);
+    QCOMPARE(item.rowCount(), rows);
+    QCOMPARE(item.columnCount(), columns);
+}
+
+void tst_QStandardItem::getSetData()
+{
+    QStandardItem item;
+    for (int x = 0; x < 2; ++x) {
+        for (int i = 1; i <= 2; ++i) {
+            QString text = QString("text %0").arg(i);
+            item.setText(text);
+            QCOMPARE(item.text(), text);
+            
+            QPixmap pixmap(32, 32);
+            pixmap.fill((i == 1) ? Qt::red : Qt::green);
+            QIcon icon(pixmap);
+            item.setIcon(icon);
+            QCOMPARE(item.icon(), icon);
+            
+            QString toolTip = QString("toolTip %0").arg(i);
+            item.setToolTip(toolTip);
+            QCOMPARE(item.toolTip(), toolTip);
+            
+            QString statusTip = QString("statusTip %0").arg(i);
+            item.setStatusTip(statusTip);
+            QCOMPARE(item.statusTip(), statusTip);
+        
+            QString whatsThis = QString("whatsThis %0").arg(i);
+            item.setWhatsThis(whatsThis);
+            QCOMPARE(item.whatsThis(), whatsThis);
+            
+            QSize sizeHint(64*i, 48*i);
+            item.setSizeHint(sizeHint);
+            QCOMPARE(item.sizeHint(), sizeHint);
+            
+            QFont font;
+            item.setFont(font);
+            QCOMPARE(item.font(), font);
+        
+            Qt::Alignment textAlignment((i == 1)
+                                        ? Qt::AlignLeft|Qt::AlignVCenter
+                                        : Qt::AlignRight);
+            item.setTextAlignment(textAlignment);
+            QCOMPARE(item.textAlignment(), textAlignment);
+            
+            QColor backgroundColor((i == 1) ? Qt::blue : Qt::yellow);
+            item.setBackground(backgroundColor);
+            QCOMPARE(item.background().color(), backgroundColor);
+            
+            QColor textColor((i == i) ? Qt::green : Qt::cyan);
+            item.setForeground(textColor);
+            QCOMPARE(item.foreground().color(), textColor);
+            
+            Qt::CheckState checkState((i == 1) ? Qt::PartiallyChecked : Qt::Checked);
+            item.setCheckState(checkState);
+            QCOMPARE(item.checkState(), checkState);
+            
+            QString accessibleText = QString("accessibleText %0").arg(i);
+            item.setAccessibleText(accessibleText);
+            QCOMPARE(item.accessibleText(), accessibleText);
+            
+            QString accessibleDescription = QString("accessibleDescription %0").arg(i);
+            item.setAccessibleDescription(accessibleDescription);
+            QCOMPARE(item.accessibleDescription(), accessibleDescription);
+            
+            QCOMPARE(item.text(), text);
+            QCOMPARE(item.icon(), icon);
+            QCOMPARE(item.toolTip(), toolTip);
+            QCOMPARE(item.statusTip(), statusTip);
+            QCOMPARE(item.whatsThis(), whatsThis);
+            QCOMPARE(item.sizeHint(), sizeHint);
+            QCOMPARE(item.font(), font);
+            QCOMPARE(item.textAlignment(), textAlignment);
+            QCOMPARE(item.background().color(), backgroundColor);
+            QCOMPARE(item.foreground().color(), textColor);
+            QCOMPARE(item.checkState(), checkState);
+            QCOMPARE(item.accessibleText(), accessibleText);
+            QCOMPARE(item.accessibleDescription(), accessibleDescription);
+            
+            QCOMPARE(qvariant_cast<QString>(item.data(Qt::DisplayRole)), text);
+            QCOMPARE(qvariant_cast<QIcon>(item.data(Qt::DecorationRole)), icon);
+            QCOMPARE(qvariant_cast<QString>(item.data(Qt::ToolTipRole)), toolTip);
+            QCOMPARE(qvariant_cast<QString>(item.data(Qt::StatusTipRole)), statusTip);
+            QCOMPARE(qvariant_cast<QString>(item.data(Qt::WhatsThisRole)), whatsThis);
+            QCOMPARE(qvariant_cast<QSize>(item.data(Qt::SizeHintRole)), sizeHint);
+            QCOMPARE(qvariant_cast<QFont>(item.data(Qt::FontRole)), font);
+            QCOMPARE(qvariant_cast<int>(item.data(Qt::TextAlignmentRole)), int(textAlignment));
+            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::BackgroundColorRole)), QBrush(backgroundColor));
+            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::BackgroundRole)), QBrush(backgroundColor));
+            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::TextColorRole)), QBrush(textColor));
+            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::ForegroundRole)), QBrush(textColor));
+            QCOMPARE(qvariant_cast<int>(item.data(Qt::CheckStateRole)), int(checkState));
+            QCOMPARE(qvariant_cast<QString>(item.data(Qt::AccessibleTextRole)), accessibleText);
+            QCOMPARE(qvariant_cast<QString>(item.data(Qt::AccessibleDescriptionRole)), accessibleDescription);
+
+            item.setBackground(pixmap);
+            QCOMPARE(item.background().texture(), pixmap);
+            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::BackgroundRole)).texture(), pixmap);
+        }
+        item.setData(QVariant(), Qt::DisplayRole);
+        item.setData(QVariant(), Qt::DecorationRole);
+        item.setData(QVariant(), Qt::ToolTipRole);
+        item.setData(QVariant(), Qt::StatusTipRole);
+        item.setData(QVariant(), Qt::WhatsThisRole);
+        item.setData(QVariant(), Qt::SizeHintRole);
+        item.setData(QVariant(), Qt::FontRole);
+        item.setData(QVariant(), Qt::TextAlignmentRole);
+        item.setData(QVariant(), Qt::BackgroundRole);
+        item.setData(QVariant(), Qt::ForegroundRole);
+        item.setData(QVariant(), Qt::CheckStateRole);
+        item.setData(QVariant(), Qt::AccessibleTextRole);
+        item.setData(QVariant(), Qt::AccessibleDescriptionRole);
+        
+        QCOMPARE(item.data(Qt::DisplayRole), QVariant());
+        QCOMPARE(item.data(Qt::DecorationRole), QVariant());
+        QCOMPARE(item.data(Qt::ToolTipRole), QVariant());
+        QCOMPARE(item.data(Qt::StatusTipRole), QVariant());
+        QCOMPARE(item.data(Qt::WhatsThisRole), QVariant());
+        QCOMPARE(item.data(Qt::SizeHintRole), QVariant());
+        QCOMPARE(item.data(Qt::FontRole), QVariant());
+        QCOMPARE(item.data(Qt::TextAlignmentRole), QVariant());
+        QCOMPARE(item.data(Qt::BackgroundColorRole), QVariant());
+        QCOMPARE(item.data(Qt::BackgroundRole), QVariant());
+        QCOMPARE(item.data(Qt::TextColorRole), QVariant());
+        QCOMPARE(item.data(Qt::ForegroundRole), QVariant());
+        QCOMPARE(item.data(Qt::CheckStateRole), QVariant());
+        QCOMPARE(item.data(Qt::AccessibleTextRole), QVariant());
+        QCOMPARE(item.data(Qt::AccessibleDescriptionRole), QVariant());
+    }
+}
+
+void tst_QStandardItem::getSetFlags()
+{
+    QStandardItem item;
+    item.setEnabled(true);
+    QVERIFY(item.isEnabled());
+    QVERIFY(item.flags() & Qt::ItemIsEnabled);
+    item.setEditable(true);
+    QVERIFY(item.isEditable());
+    QVERIFY(item.flags() & Qt::ItemIsEditable);
+    item.setSelectable(true);
+    QVERIFY(item.isSelectable());
+    QVERIFY(item.flags() & Qt::ItemIsSelectable);
+    item.setCheckable(true);
+    QVERIFY(item.isCheckable());
+    QCOMPARE(item.checkState(), Qt::Unchecked);
+    QVERIFY(item.flags() & Qt::ItemIsUserCheckable);
+    item.setTristate(true);
+    QVERIFY(item.isTristate());
+    QVERIFY(item.flags() & Qt::ItemIsTristate);
+#ifndef QT_NO_DRAGANDDROP
+    item.setDragEnabled(true);
+    QVERIFY(item.isDragEnabled());
+    QVERIFY(item.flags() & Qt::ItemIsDragEnabled);
+    item.setDropEnabled(true);
+    QVERIFY(item.isDropEnabled());
+    QVERIFY(item.flags() & Qt::ItemIsDropEnabled);
+#endif
+    
+    QVERIFY(item.isEnabled());
+    item.setEnabled(false);
+    QVERIFY(!item.isEnabled());
+    QVERIFY(!(item.flags() & Qt::ItemIsEnabled));
+    QVERIFY(item.isEditable());
+    item.setEditable(false);
+    QVERIFY(!item.isEditable());
+    QVERIFY(!(item.flags() & Qt::ItemIsEditable));
+    QVERIFY(item.isSelectable());
+    item.setSelectable(false);
+    QVERIFY(!item.isSelectable());
+    QVERIFY(!(item.flags() & Qt::ItemIsSelectable));
+    QVERIFY(item.isCheckable());
+    item.setCheckable(false);
+    QVERIFY(!item.isCheckable());
+    QVERIFY(!(item.flags() & Qt::ItemIsUserCheckable));
+    QVERIFY(item.isTristate());
+    item.setTristate(false);
+    QVERIFY(!item.isTristate());
+    QVERIFY(!(item.flags() & Qt::ItemIsTristate));
+#ifndef QT_NO_DRAGANDDROP
+    QVERIFY(item.isDragEnabled());
+    item.setDragEnabled(false);
+    QVERIFY(!item.isDragEnabled());
+    QVERIFY(!(item.flags() & Qt::ItemIsDragEnabled));
+    QVERIFY(item.isDropEnabled());
+    item.setDropEnabled(false);
+    QVERIFY(!item.isDropEnabled());
+    QVERIFY(!(item.flags() & Qt::ItemIsDropEnabled));
+#endif
+
+    item.setCheckable(false);
+    item.setCheckState(Qt::Checked);
+    item.setCheckable(true);
+    QCOMPARE(item.checkState(), Qt::Checked);
+}    
+
+void tst_QStandardItem::getSetRowAndColumnCount()
+{
+    QStandardItem item;
+
+    item.setRowCount(-1);
+    QCOMPARE(item.rowCount(), 0);
+
+    item.setColumnCount(-1);
+    QCOMPARE(item.columnCount(), 0);
+
+    item.setRowCount(1);
+    QCOMPARE(item.rowCount(), 1);
+    QCOMPARE(item.columnCount(), 0);
+
+    item.setColumnCount(1);
+    QCOMPARE(item.columnCount(), 1);
+    QCOMPARE(item.rowCount(), 1);
+
+    item.setColumnCount(10);
+    QCOMPARE(item.columnCount(), 10);
+    QCOMPARE(item.rowCount(), 1);
+
+    item.setRowCount(20);
+    QCOMPARE(item.rowCount(), 20);
+    QCOMPARE(item.columnCount(), 10);
+
+    item.setRowCount(-1);
+    QCOMPARE(item.rowCount(), 20);
+
+    item.setColumnCount(-1);
+    QCOMPARE(item.columnCount(), 10);
+
+    item.setColumnCount(0);
+    QCOMPARE(item.columnCount(), 0);
+    QCOMPARE(item.rowCount(), 20);
+
+    item.setRowCount(0);
+    QCOMPARE(item.rowCount(), 0);
+}
+
+void tst_QStandardItem::getSetChild_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("row");
+    QTest::addColumn<int>("column");
+
+    QTest::newRow("0x0 children, child at (-1,-1)") << 0 << 0 << -1 << -1;
+    QTest::newRow("0x0 children, child at (0,0)") << 0 << 0 << 0 << 0;
+}
+
+void tst_QStandardItem::getSetChild()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, row);
+    QFETCH(int, column);
+
+    QStandardItem item(rows, columns);
+    bool shouldHaveChildren = (rows > 0) && (columns > 0);
+    QCOMPARE(item.hasChildren(), shouldHaveChildren);
+    QCOMPARE(item.child(row, column), static_cast<QStandardItem*>(0));
+
+    QStandardItem *child = new QStandardItem;
+    item.setChild(row, column, child);
+    if ((row >= 0) && (column >= 0)) {
+        QCOMPARE(item.rowCount(), qMax(rows, row + 1));
+        QCOMPARE(item.columnCount(), qMax(columns, column + 1));
+
+        QCOMPARE(item.child(row, column), child);
+        QCOMPARE(child->row(), row);
+        QCOMPARE(child->column(), column);
+
+        QStandardItem *anotherChild = new QStandardItem;
+        item.setChild(row, column, anotherChild);
+        QCOMPARE(item.child(row, column), anotherChild);
+        QCOMPARE(anotherChild->row(), row);
+        QCOMPARE(anotherChild->column(), column);
+        item.setChild(row, column, 0);
+    } else {
+        delete child;
+    }
+    QCOMPARE(item.child(row, column), static_cast<QStandardItem*>(0));
+}
+
+void tst_QStandardItem::parent()
+{
+    {
+        QStandardItem item;
+        QStandardItem *child = new QStandardItem;
+        QCOMPARE(child->parent(), static_cast<QStandardItem*>(0));
+        item.setChild(0, 0, child);
+        QCOMPARE(child->parent(), &item);
+        
+        QStandardItem *childOfChild = new QStandardItem;
+        child->setChild(0, 0, childOfChild);
+        QCOMPARE(childOfChild->parent(), child);
+    }
+
+    {
+        QStandardItemModel model;
+        QStandardItem *item = new QStandardItem;
+        model.appendRow(item);
+        // parent of a top-level item should be 0
+        QCOMPARE(item->parent(), static_cast<QStandardItem*>(0));
+    }
+}
+
+void tst_QStandardItem::insertColumn_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("column");
+    QTest::addColumn<int>("count");
+
+    QTest::newRow("insert 0 at -1 in 0x0") << 0 << 0 << -1 << 0;
+    QTest::newRow("insert 0 at 0 in 0x0") << 0 << 0 << 0 << 0;
+    QTest::newRow("insert 0 at 0 in 1x0") << 1 << 0 << 0 << 0;
+    QTest::newRow("insert 0 at 0 in 0x1") << 0 << 1 << 0 << 0;
+    QTest::newRow("insert 0 at 0 in 1x1") << 1 << 1 << 0 << 0;
+    QTest::newRow("insert 1 at -1 in 0x0") << 0 << 0 << -1 << 1;
+    QTest::newRow("insert 1 at 0 in 0x0") << 0 << 0 << 0 << 1;
+    QTest::newRow("insert 1 at 0 in 1x0") << 1 << 0 << 0 << 1;
+    QTest::newRow("insert 1 at 0 in 0x1") << 0 << 1 << 0 << 1;
+    QTest::newRow("insert 1 at 0 in 1x1") << 1 << 1 << 0 << 1;
+    QTest::newRow("insert 1 at 1 in 1x1") << 1 << 1 << 1 << 1;
+    QTest::newRow("insert 1 at 0 in 2x1") << 2 << 1 << 0 << 1;
+    QTest::newRow("insert 1 at 1 in 2x1") << 2 << 1 << 1 << 1;
+    QTest::newRow("insert 1 at 0 in 1x2") << 1 << 2 << 0 << 1;
+    QTest::newRow("insert 1 at 1 in 1x2") << 1 << 2 << 1 << 1;
+    QTest::newRow("insert 1 at 0 in 8x4") << 8 << 4 << 0 << 1;
+    QTest::newRow("insert 1 at 1 in 8x4") << 8 << 4 << 1 << 1;
+    QTest::newRow("insert 1 at 2 in 8x4") << 8 << 4 << 2 << 1;
+    QTest::newRow("insert 1 at 3 in 8x4") << 8 << 4 << 3 << 1;
+    QTest::newRow("insert 1 at 4 in 8x4") << 8 << 4 << 4 << 1;
+    QTest::newRow("insert 4 at 0 in 8x4") << 8 << 4 << 0 << 4;
+    QTest::newRow("insert 4 at 4 in 8x4") << 8 << 4 << 4 << 4;
+    QTest::newRow("insert 6 at 0 in 8x4") << 8 << 4 << 0 << 6;
+    QTest::newRow("insert 6 at 4 in 8x4") << 8 << 4 << 4 << 6;
+}
+
+void tst_QStandardItem::insertColumn()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, column);
+    QFETCH(int, count);
+
+    QStandardItem item(rows, columns);
+
+    // make items for a new column
+    QList<QStandardItem*> columnItems;
+    for (int i = 0; i < count; ++i)
+        columnItems.append(new QStandardItem);
+
+    item.insertColumn(column, columnItems);
+
+    if (column >= 0) {
+        QCOMPARE(item.columnCount(), columns + 1);
+        QCOMPARE(item.rowCount(), qMax(rows, count));
+        // check to make sure items were inserted in correct place
+        for (int i = 0; i < count; ++i)
+            QCOMPARE(item.child(i, column), columnItems.at(i));
+        for (int i = count; i < item.rowCount(); ++i)
+            QCOMPARE(item.child(i, column), static_cast<QStandardItem*>(0));
+    } else {
+        QCOMPARE(item.columnCount(), columns);
+        QCOMPARE(item.rowCount(), rows);
+        qDeleteAll(columnItems);
+    }
+}
+
+void tst_QStandardItem::insertColumns_data()
+{
+}
+
+void tst_QStandardItem::insertColumns()
+{
+}
+
+void tst_QStandardItem::insertRow_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("row");
+    QTest::addColumn<int>("count");
+
+    QTest::newRow("insert 0 at -1 in 0x0") << 0 << 0 << -1 << 0;
+    QTest::newRow("insert 0 at 0 in 0x0") << 0 << 0 << 0 << 0;
+    QTest::newRow("insert 0 at 0 in 1x0") << 1 << 0 << 0 << 0;
+    QTest::newRow("insert 0 at 0 in 0x1") << 0 << 1 << 0 << 0;
+    QTest::newRow("insert 0 at 0 in 1x1") << 1 << 1 << 0 << 0;
+    QTest::newRow("insert 1 at -1 in 0x0") << 0 << 0 << -1 << 1;
+    QTest::newRow("insert 1 at 0 in 0x0") << 0 << 0 << 0 << 1;
+    QTest::newRow("insert 1 at 0 in 1x0") << 1 << 0 << 0 << 1;
+    QTest::newRow("insert 1 at 0 in 0x1") << 0 << 1 << 0 << 1;
+    QTest::newRow("insert 1 at 0 in 1x1") << 1 << 1 << 0 << 1;
+    QTest::newRow("insert 1 at 1 in 1x1") << 1 << 1 << 1 << 1;
+    QTest::newRow("insert 1 at 0 in 2x1") << 2 << 1 << 0 << 1;
+    QTest::newRow("insert 1 at 1 in 2x1") << 2 << 1 << 1 << 1;
+    QTest::newRow("insert 1 at 0 in 1x2") << 1 << 2 << 0 << 1;
+    QTest::newRow("insert 1 at 1 in 1x2") << 1 << 2 << 1 << 1;
+    QTest::newRow("insert 1 at 0 in 4x8") << 4 << 8 << 0 << 1;
+    QTest::newRow("insert 1 at 1 in 4x8") << 4 << 8 << 1 << 1;
+    QTest::newRow("insert 1 at 2 in 4x8") << 4 << 8 << 2 << 1;
+    QTest::newRow("insert 1 at 3 in 4x8") << 4 << 8 << 3 << 1;
+    QTest::newRow("insert 1 at 4 in 4x8") << 4 << 8 << 4 << 1;
+    QTest::newRow("insert 4 at 0 in 4x8") << 4 << 8 << 0 << 4;
+    QTest::newRow("insert 4 at 4 in 4x8") << 4 << 8 << 4 << 4;
+    QTest::newRow("insert 6 at 0 in 4x8") << 4 << 8 << 0 << 6;
+    QTest::newRow("insert 6 at 4 in 4x8") << 4 << 8 << 4 << 6;
+}
+
+void tst_QStandardItem::insertRow()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, row);
+    QFETCH(int, count);
+
+    QStandardItem item(rows, columns);
+
+    // make items for a new column
+    QList<QStandardItem*> rowItems;
+    for (int i = 0; i < count; ++i)
+        rowItems.append(new QStandardItem);
+
+    item.insertRow(row, rowItems);
+
+    if (row >= 0) {
+        QCOMPARE(item.columnCount(), qMax(columns, count));
+        QCOMPARE(item.rowCount(), rows + 1);
+        // check to make sure items were inserted in correct place
+        for (int i = 0; i < count; ++i)
+            QCOMPARE(item.child(row, i), rowItems.at(i));
+        for (int i = count; i < item.columnCount(); ++i)
+            QCOMPARE(item.child(row, i), static_cast<QStandardItem*>(0));
+    } else {
+        QCOMPARE(item.columnCount(), columns);
+        QCOMPARE(item.rowCount(), rows);
+        qDeleteAll(rowItems);
+    }
+}
+
+void tst_QStandardItem::insertRows_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("insertAt");
+    QTest::addColumn<int>("insertCount");
+
+    QTest::newRow("insert {0,1} at 0 in 0x0") << 0 << 0 << 0 << 2;
+}
+
+void tst_QStandardItem::insertRows()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, insertAt);
+    QFETCH(int, insertCount);
+
+    QStandardItem item(rows, columns);
+
+    QList<QStandardItem*> items;
+    for (int i = 0; i < insertCount; ++i) {
+        items.append(new QStandardItem());
+    }
+    item.insertRows(insertAt, items);
+
+    QCOMPARE(item.rowCount(), rows + insertCount);
+}
+
+void tst_QStandardItem::appendColumn_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("count");
+
+    QTest::newRow("append 0 to 0x0") << 0 << 0 << 0;
+    QTest::newRow("append 1 to 0x0") << 0 << 0 << 1;
+    QTest::newRow("append 1 to 1x0") << 1 << 0 << 1;
+    QTest::newRow("append 1 to 0x1") << 0 << 1 << 1;
+    QTest::newRow("append 1 to 1x1") << 1 << 1 << 1;
+    QTest::newRow("append 1 to 2x0") << 2 << 0 << 1;
+    QTest::newRow("append 1 to 0x2") << 0 << 2 << 1;
+    QTest::newRow("append 1 to 2x1") << 2 << 1 << 1;
+    QTest::newRow("append 1 to 1x2") << 1 << 2 << 1;
+    QTest::newRow("append 1 to 2x2") << 2 << 2 << 1;
+    QTest::newRow("append 2 to 0x0") << 0 << 0 << 2;
+    QTest::newRow("append 2 to 1x0") << 1 << 0 << 2;
+    QTest::newRow("append 2 to 0x1") << 0 << 1 << 2;
+    QTest::newRow("append 2 to 1x1") << 1 << 1 << 2;
+    QTest::newRow("append 2 to 2x0") << 2 << 0 << 2;
+    QTest::newRow("append 2 to 0x2") << 0 << 2 << 2;
+    QTest::newRow("append 2 to 2x1") << 2 << 1 << 2;
+    QTest::newRow("append 2 to 1x2") << 1 << 2 << 2;
+    QTest::newRow("append 2 to 2x2") << 2 << 2 << 2;
+    QTest::newRow("append 3 to 2x1") << 2 << 1 << 3;
+    QTest::newRow("append 3 to 1x2") << 1 << 2 << 3;
+    QTest::newRow("append 3 to 2x2") << 2 << 2 << 3;
+    QTest::newRow("append 3 to 4x2") << 4 << 2 << 3;
+    QTest::newRow("append 3 to 2x4") << 2 << 4 << 3;
+    QTest::newRow("append 3 to 4x4") << 4 << 4 << 3;
+    QTest::newRow("append 7 to 4x2") << 4 << 2 << 7;
+    QTest::newRow("append 7 to 2x4") << 2 << 4 << 7;
+    QTest::newRow("append 7 to 4x4") << 4 << 4 << 7;
+}
+
+void tst_QStandardItem::appendColumn()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, count);
+
+    QStandardItem item(rows, columns);
+    QList<QStandardItem*> originalChildren;
+    // initialize children
+    for (int i = 0; i < rows; ++i) {
+        for (int j = 0; j < columns; ++j) {
+            QStandardItem *child = new QStandardItem;
+            originalChildren.append(child);
+            item.setChild(i, j, child);
+        }
+    }
+
+    // make items for a new column
+    QList<QStandardItem*> columnItems;
+    for (int i = 0; i < count; ++i)
+        columnItems.append(new QStandardItem);
+
+    item.appendColumn(columnItems);
+
+    QCOMPARE(item.columnCount(), columns + 1);
+    QCOMPARE(item.rowCount(), qMax(rows, count));
+    // check to make sure items were inserted in correct place
+    for (int i = 0; i < count; ++i)
+        QCOMPARE(item.child(i, columns), columnItems.at(i));
+    for (int i = count; i < item.rowCount(); ++i)
+        QCOMPARE(item.child(i, columns), static_cast<QStandardItem*>(0));
+
+    // make sure original children remained unchanged
+    for (int i = 0; i < rows; ++i) {
+        for (int j = 0; j < columns; ++j)
+            QCOMPARE(item.child(i, j), originalChildren.at(i*columns+j));
+    }
+}
+
+void tst_QStandardItem::appendRow_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("count");
+
+    QTest::newRow("append 0 to 0x0") << 0 << 0 << 0;
+    QTest::newRow("append 1 to 0x0") << 0 << 0 << 1;
+    QTest::newRow("append 1 to 1x0") << 1 << 0 << 1;
+    QTest::newRow("append 1 to 0x1") << 0 << 1 << 1;
+    QTest::newRow("append 1 to 1x1") << 1 << 1 << 1;
+    QTest::newRow("append 1 to 2x0") << 2 << 0 << 1;
+    QTest::newRow("append 1 to 0x2") << 0 << 2 << 1;
+    QTest::newRow("append 1 to 2x1") << 2 << 1 << 1;
+    QTest::newRow("append 1 to 1x2") << 1 << 2 << 1;
+    QTest::newRow("append 1 to 2x2") << 2 << 2 << 1;
+    QTest::newRow("append 2 to 0x0") << 0 << 0 << 2;
+    QTest::newRow("append 2 to 1x0") << 1 << 0 << 2;
+    QTest::newRow("append 2 to 0x1") << 0 << 1 << 2;
+    QTest::newRow("append 2 to 1x1") << 1 << 1 << 2;
+    QTest::newRow("append 2 to 2x0") << 2 << 0 << 2;
+    QTest::newRow("append 2 to 0x2") << 0 << 2 << 2;
+    QTest::newRow("append 2 to 2x1") << 2 << 1 << 2;
+    QTest::newRow("append 2 to 1x2") << 1 << 2 << 2;
+    QTest::newRow("append 2 to 2x2") << 2 << 2 << 2;
+    QTest::newRow("append 3 to 2x1") << 2 << 1 << 3;
+    QTest::newRow("append 3 to 1x2") << 1 << 2 << 3;
+    QTest::newRow("append 3 to 2x2") << 2 << 2 << 3;
+    QTest::newRow("append 3 to 4x2") << 4 << 2 << 3;
+    QTest::newRow("append 3 to 2x4") << 2 << 4 << 3;
+    QTest::newRow("append 3 to 4x4") << 4 << 4 << 3;
+    QTest::newRow("append 7 to 4x2") << 4 << 2 << 7;
+    QTest::newRow("append 7 to 2x4") << 2 << 4 << 7;
+    QTest::newRow("append 7 to 4x4") << 4 << 4 << 7;
+}
+
+void tst_QStandardItem::appendRow()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, count);
+
+    QStandardItem item(rows, columns);
+    QList<QStandardItem*> originalChildren;
+    // initialize children
+    for (int i = 0; i < rows; ++i) {
+        for (int j = 0; j < columns; ++j) {
+            QStandardItem *child = new QStandardItem;
+            originalChildren.append(child);
+            item.setChild(i, j, child);
+        }
+    }
+
+    // make items for a new row
+    QList<QStandardItem*> rowItems;
+    for (int i = 0; i < count; ++i)
+        rowItems.append(new QStandardItem);
+
+    item.appendRow(rowItems);
+
+    QCOMPARE(item.rowCount(), rows + 1);
+    QCOMPARE(item.columnCount(), qMax(columns, count));
+    // check to make sure items were inserted in correct place
+    for (int i = 0; i < count; ++i)
+        QCOMPARE(item.child(rows, i), rowItems.at(i));
+    for (int i = count; i < item.columnCount(); ++i)
+        QCOMPARE(item.child(rows, i), static_cast<QStandardItem*>(0));
+
+    // make sure original children remained unchanged
+    for (int i = 0; i < rows; ++i) {
+        for (int j = 0; j < columns; ++j)
+            QCOMPARE(item.child(i, j), originalChildren.at(i*columns+j));
+    }
+}
+
+void tst_QStandardItem::takeChild()
+{
+    QList<QStandardItem*> itemList;
+    for (int i = 0; i < 10; ++i)
+        itemList.append(new QStandardItem);
+    QStandardItem item;
+    item.appendColumn(itemList);
+
+    for (int i = 0; i < item.rowCount(); ++i) {
+        QCOMPARE(item.takeChild(i), itemList.at(i));
+        QCOMPARE(item.takeChild(0, 0), static_cast<QStandardItem*>(0));
+        for (int j = i + 1; j < item.rowCount(); ++j)
+            QCOMPARE(item.child(j), itemList.at(j));
+    }
+    qDeleteAll(itemList);
+}
+
+void tst_QStandardItem::takeColumn_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("column");
+    QTest::addColumn<bool>("expectSuccess");
+
+    QTest::newRow("take -1 from 0x0") << 0 << 0 << -1 << false;
+    QTest::newRow("take 0 from 0x0") << 0 << 0 << 0 << false;
+    QTest::newRow("take 0 from 1x0") << 1 << 0 << 0 << false;
+    QTest::newRow("take 0 from 0x1") << 0 << 1 << 0 << true;
+    QTest::newRow("take 1 from 0x1") << 0 << 1 << 1 << false;
+    QTest::newRow("take 0 from 1x1") << 1 << 1 << 0 << true;
+    QTest::newRow("take 1 from 1x1") << 0 << 1 << 1 << false;
+    QTest::newRow("take 0 from 4x1") << 4 << 1 << 0 << true;
+    QTest::newRow("take 1 from 4x1") << 4 << 1 << 1 << false;
+    QTest::newRow("take 0 from 4x8") << 4 << 8 << 0 << true;
+    QTest::newRow("take 7 from 4x8") << 4 << 8 << 7 << true;
+    QTest::newRow("take 8 from 4x8") << 4 << 8 << 8 << false;
+}
+
+void tst_QStandardItem::takeColumn()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, column);
+    QFETCH(bool, expectSuccess);
+
+    QStandardItem item(rows, columns);
+    QList<QStandardItem*> originalChildren;
+    // initialize children
+    for (int i = 0; i < rows; ++i) {
+        for (int j = 0; j < columns; ++j) {
+            QStandardItem *child = new QStandardItem;
+            originalChildren.append(child);
+            item.setChild(i, j, child);
+        }
+    }
+
+    QList<QStandardItem *> taken = item.takeColumn(column);
+    if (expectSuccess) {
+        QCOMPARE(taken.count(), item.rowCount());
+        QCOMPARE(item.columnCount(), columns - 1);
+        int index = column;
+        for (int i = 0; i < taken.count(); ++i) {
+            QCOMPARE(taken.at(i), originalChildren.takeAt(index));
+            index += item.columnCount();
+        }
+        index = 0;
+        for (int i = 0; i < item.rowCount(); ++i) {
+            for (int j = 0; j < item.columnCount(); ++j) {
+                QCOMPARE(item.child(i, j), originalChildren.at(index));
+                ++index;
+            }
+        }
+    } else {
+        QVERIFY(taken.isEmpty());
+    }
+    qDeleteAll(taken);
+}
+
+void tst_QStandardItem::takeRow_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("row");
+    QTest::addColumn<bool>("expectSuccess");
+
+    QTest::newRow("take -1 from 0x0") << 0 << 0 << -1 << false;
+    QTest::newRow("take 0 from 0x0") << 0 << 0 << 0 << false;
+    QTest::newRow("take 0 from 1x0") << 1 << 0 << 0 << true;
+    QTest::newRow("take 0 from 0x1") << 0 << 1 << 0 << false;
+    QTest::newRow("take 1 from 0x1") << 0 << 1 << 1 << false;
+    QTest::newRow("take 0 from 1x1") << 1 << 1 << 0 << true;
+    QTest::newRow("take 1 from 1x1") << 0 << 1 << 1 << false;
+    QTest::newRow("take 0 from 1x4") << 1 << 4 << 0 << true;
+    QTest::newRow("take 1 from 1x4") << 1 << 4 << 1 << false;
+    QTest::newRow("take 0 from 8x4") << 8 << 4 << 0 << true;
+    QTest::newRow("take 7 from 8x4") << 8 << 4 << 7 << true;
+    QTest::newRow("take 8 from 8x4") << 8 << 4 << 8 << false;
+}
+
+void tst_QStandardItem::takeRow()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, row);
+    QFETCH(bool, expectSuccess);
+
+    QStandardItem item(rows, columns);
+    QList<QStandardItem*> originalChildren;
+    // initialize children
+    for (int i = 0; i < rows; ++i) {
+        for (int j = 0; j < columns; ++j) {
+            QStandardItem *child = new QStandardItem;
+            originalChildren.append(child);
+            item.setChild(i, j, child);
+        }
+    }
+
+    QList<QStandardItem *> taken = item.takeRow(row);
+    if (expectSuccess) {
+        QCOMPARE(taken.count(), item.columnCount());
+        QCOMPARE(item.rowCount(), rows - 1);
+        int index = row * columns;
+        for (int i = 0; i < taken.count(); ++i) {
+            QCOMPARE(taken.at(i), originalChildren.takeAt(index));
+        }
+        index = 0;
+        for (int i = 0; i < item.rowCount(); ++i) {
+            for (int j = 0; j < item.columnCount(); ++j) {
+                QCOMPARE(item.child(i, j), originalChildren.at(index));
+                ++index;
+            }
+        }
+    } else {
+        QVERIFY(taken.isEmpty());
+    }
+    qDeleteAll(taken);
+}
+
+void tst_QStandardItem::streamItem()
+{
+    QStandardItem item;
+    
+    item.setText(QLatin1String("text"));
+    item.setToolTip(QLatin1String("toolTip"));
+    item.setStatusTip(QLatin1String("statusTip"));
+    item.setWhatsThis(QLatin1String("whatsThis"));
+    item.setSizeHint(QSize(64, 48));
+    item.setFont(QFont());
+    item.setTextAlignment(Qt::AlignLeft|Qt::AlignVCenter);
+    item.setBackground(QColor(Qt::blue));
+    item.setForeground(QColor(Qt::green));
+    item.setCheckState(Qt::PartiallyChecked);
+    item.setAccessibleText(QLatin1String("accessibleText"));
+    item.setAccessibleDescription(QLatin1String("accessibleDescription"));
+
+    QByteArray ba;
+    {
+        QDataStream ds(&ba, QIODevice::WriteOnly);
+        ds << item;
+    }
+    {
+        QStandardItem streamedItem;
+        QDataStream ds(&ba, QIODevice::ReadOnly);
+        ds >> streamedItem;
+        QCOMPARE(streamedItem.text(), item.text());
+        QCOMPARE(streamedItem.toolTip(), item.toolTip());
+        QCOMPARE(streamedItem.statusTip(), item.statusTip());
+        QCOMPARE(streamedItem.whatsThis(), item.whatsThis());
+        QCOMPARE(streamedItem.sizeHint(), item.sizeHint());
+        QCOMPARE(streamedItem.font(), item.font());
+        QCOMPARE(streamedItem.textAlignment(), item.textAlignment());
+        QCOMPARE(streamedItem.background(), item.background());
+        QCOMPARE(streamedItem.foreground(), item.foreground());
+        QCOMPARE(streamedItem.checkState(), item.checkState());
+        QCOMPARE(streamedItem.accessibleText(), item.accessibleText());
+        QCOMPARE(streamedItem.accessibleDescription(), item.accessibleDescription());
+        QCOMPARE(streamedItem.flags(), item.flags());
+    }
+}
+
+void tst_QStandardItem::deleteItem()
+{
+    QStandardItemModel model(4, 6);
+    // initialize items
+    for (int i = 0; i < model.rowCount(); ++i) {
+        for (int j = 0; j < model.columnCount(); ++j) {
+            QStandardItem *item = new QStandardItem();
+            model.setItem(i, j, item);
+        }
+    }
+    // delete items
+    for (int i = 0; i < model.rowCount(); ++i) {
+        for (int j = 0; j < model.columnCount(); ++j) {
+            QStandardItem *item = model.item(i, j);
+            delete item;
+            QCOMPARE(model.item(i, j), static_cast<QStandardItem*>(0));
+        }
+    }
+}
+
+void tst_QStandardItem::clone()
+{
+    QStandardItem item;
+    item.setText(QLatin1String("text"));
+    item.setToolTip(QLatin1String("toolTip"));
+    item.setStatusTip(QLatin1String("statusTip"));
+    item.setWhatsThis(QLatin1String("whatsThis"));
+    item.setSizeHint(QSize(64, 48));
+    item.setFont(QFont());
+    item.setTextAlignment(Qt::AlignLeft|Qt::AlignVCenter);
+    item.setBackground(QColor(Qt::blue));
+    item.setForeground(QColor(Qt::green));
+    item.setCheckState(Qt::PartiallyChecked);
+    item.setAccessibleText(QLatin1String("accessibleText"));
+    item.setAccessibleDescription(QLatin1String("accessibleDescription"));
+    item.setFlags(Qt::ItemIsEnabled | Qt::ItemIsDropEnabled);
+
+    QStandardItem *clone = item.clone();
+    QCOMPARE(clone->text(), item.text());
+    QCOMPARE(clone->toolTip(), item.toolTip());
+    QCOMPARE(clone->statusTip(), item.statusTip());
+    QCOMPARE(clone->whatsThis(), item.whatsThis());
+    QCOMPARE(clone->sizeHint(), item.sizeHint());
+    QCOMPARE(clone->font(), item.font());
+    QCOMPARE(clone->textAlignment(), item.textAlignment());
+    QCOMPARE(clone->background(), item.background());
+    QCOMPARE(clone->foreground(), item.foreground());
+    QCOMPARE(clone->checkState(), item.checkState());
+    QCOMPARE(clone->accessibleText(), item.accessibleText());
+    QCOMPARE(clone->accessibleDescription(), item.accessibleDescription());
+    QCOMPARE(clone->flags(), item.flags());
+    QVERIFY(!(*clone < item));
+    delete clone;
+}
+
+void tst_QStandardItem::sortChildren()
+{
+    for (int x = 0; x < 2; ++x) {
+        QStandardItemModel *model = new QStandardItemModel;
+        QStandardItem *item = (x == 0) ? new QStandardItem : model->invisibleRootItem();
+        QStandardItem *one = new QStandardItem;
+        one->appendRow(new QStandardItem(QLatin1String("a")));
+        one->appendRow(new QStandardItem(QLatin1String("b")));
+        one->appendRow(new QStandardItem(QLatin1String("c")));
+        QStandardItem *two = new QStandardItem;
+        two->appendRow(new QStandardItem(QLatin1String("f")));
+        two->appendRow(new QStandardItem(QLatin1String("d")));
+        two->appendRow(new QStandardItem(QLatin1String("e")));
+        item->appendRow(one);
+        item->appendRow(two);
+        
+        QSignalSpy layoutAboutToBeChangedSpy(
+            model, SIGNAL(layoutAboutToBeChanged()));
+        QSignalSpy layoutChangedSpy(
+            model, SIGNAL(layoutChanged()));
+
+        one->sortChildren(0, Qt::DescendingOrder);
+        // verify sorted
+        QCOMPARE(one->child(0)->text(), QLatin1String("c"));
+        QCOMPARE(one->child(1)->text(), QLatin1String("b"));
+        QCOMPARE(one->child(2)->text(), QLatin1String("a"));
+        // verify siblings unaffected
+        QCOMPARE(two->child(0)->text(), QLatin1String("f"));
+        QCOMPARE(two->child(1)->text(), QLatin1String("d"));
+        QCOMPARE(two->child(2)->text(), QLatin1String("e"));
+        
+        two->sortChildren(0, Qt::AscendingOrder);
+        // verify sorted
+        QCOMPARE(two->child(0)->text(), QLatin1String("d"));
+        QCOMPARE(two->child(1)->text(), QLatin1String("e"));
+        QCOMPARE(two->child(2)->text(), QLatin1String("f"));
+        // verify siblings unaffected
+        QCOMPARE(one->child(0)->text(), QLatin1String("c"));
+        QCOMPARE(one->child(1)->text(), QLatin1String("b"));
+        QCOMPARE(one->child(2)->text(), QLatin1String("a"));
+        
+        item->sortChildren(0, Qt::AscendingOrder);
+        // verify everything sorted
+        QCOMPARE(one->child(0)->text(), QLatin1String("a"));
+        QCOMPARE(one->child(1)->text(), QLatin1String("b"));
+        QCOMPARE(one->child(2)->text(), QLatin1String("c"));
+        QCOMPARE(two->child(0)->text(), QLatin1String("d"));
+        QCOMPARE(two->child(1)->text(), QLatin1String("e"));
+        QCOMPARE(two->child(2)->text(), QLatin1String("f"));
+
+        QCOMPARE(layoutAboutToBeChangedSpy.count(), (x == 0) ? 0 : 3);
+        QCOMPARE(layoutChangedSpy.count(), (x == 0) ? 0 : 3);
+
+        if (x == 0)
+            delete item;
+        delete model;
+    }
+}
+
+class CustomItem : public QStandardItem
+{
+public:
+    CustomItem(const QString &text) : QStandardItem(text) { }
+    CustomItem() { }
+    virtual ~CustomItem() { }
+
+    virtual int type() const { return QStandardItem::UserType + 1; }
+
+    virtual QStandardItem *clone() const { return QStandardItem::clone(); }
+
+    void emitDataChanged() { QStandardItem::emitDataChanged(); }
+
+    virtual bool operator<(const QStandardItem &other) const {
+        return text().length() < other.text().length();
+    }
+};
+
+Q_DECLARE_METATYPE(QStandardItem*)
+
+void tst_QStandardItem::subclassing()
+{
+    qMetaTypeId<QStandardItem*>();
+
+    CustomItem *item = new CustomItem;
+    QCOMPARE(item->type(), int(QStandardItem::UserType + 1));
+
+    item->setText(QString::fromLatin1("foo"));
+    QCOMPARE(item->text(), QString::fromLatin1("foo"));
+
+    item->emitDataChanged(); // does nothing
+
+    QStandardItemModel model;
+    model.appendRow(item);
+
+    QSignalSpy itemChangedSpy(&model, SIGNAL(itemChanged(QStandardItem*)));
+    item->emitDataChanged();
+    QCOMPARE(itemChangedSpy.count(), 1);
+    QCOMPARE(itemChangedSpy.at(0).count(), 1);
+    QCOMPARE(qvariant_cast<QStandardItem*>(itemChangedSpy.at(0).at(0)), (QStandardItem*)item);
+
+    CustomItem *child0 = new CustomItem("cc");
+    CustomItem *child1 = new CustomItem("bbb");
+    CustomItem *child2 = new CustomItem("a");
+    item->appendRow(child0);
+    item->appendRow(child1);
+    item->appendRow(child2);
+    item->sortChildren(0);
+    QCOMPARE(item->child(0), (QStandardItem*)child2);
+    QCOMPARE(item->child(1), (QStandardItem*)child0);
+    QCOMPARE(item->child(2), (QStandardItem*)child1);
+}
+
+QTEST_MAIN(tst_QStandardItem)
+#include "tst_qstandarditem.moc"
diff --git a/tests/auto/gui/itemmodels/qstandarditemmodel/.gitignore b/tests/auto/gui/itemmodels/qstandarditemmodel/.gitignore
new file mode 100644
index 0000000..c218efc
--- /dev/null
+++ b/tests/auto/gui/itemmodels/qstandarditemmodel/.gitignore
@@ -0,0 +1 @@
+tst_qstandarditemmodel
diff --git a/tests/auto/gui/itemmodels/qstandarditemmodel/qstandarditemmodel.pro b/tests/auto/gui/itemmodels/qstandarditemmodel/qstandarditemmodel.pro
new file mode 100644
index 0000000..71ef4ac
--- /dev/null
+++ b/tests/auto/gui/itemmodels/qstandarditemmodel/qstandarditemmodel.pro
@@ -0,0 +1,10 @@
+CONFIG += testcase
+CONFIG += parallel_test
+TARGET = tst_qstandarditemmodel
+
+QT += widgets widgets-private testlib
+QT += core-private gui-private
+
+SOURCES  += tst_qstandarditemmodel.cpp
+
+
diff --git a/tests/auto/gui/itemmodels/qstandarditemmodel/tst_qstandarditemmodel.cpp b/tests/auto/gui/itemmodels/qstandarditemmodel/tst_qstandarditemmodel.cpp
new file mode 100644
index 0000000..1c661f9
--- /dev/null
+++ b/tests/auto/gui/itemmodels/qstandarditemmodel/tst_qstandarditemmodel.cpp
@@ -0,0 +1,1683 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#include <QtTest/QtTest>
+
+#include <qstandarditemmodel.h>
+#include <QTreeView>
+#include <private/qtreeview_p.h>
+
+class tst_QStandardItemModel : public QObject
+{
+    Q_OBJECT
+
+public:
+    tst_QStandardItemModel();
+    virtual ~tst_QStandardItemModel();
+
+    enum ModelChanged {
+        RowsAboutToBeInserted,
+        RowsInserted,
+        RowsAboutToBeRemoved,
+        RowsRemoved,
+        ColumnsAboutToBeInserted,
+        ColumnsInserted,
+        ColumnsAboutToBeRemoved,
+        ColumnsRemoved
+    };
+
+public slots:
+    void init();
+    void cleanup();
+
+protected slots:
+    void checkAboutToBeRemoved();
+    void checkRemoved();
+    void updateRowAboutToBeRemoved();
+
+    void rowsAboutToBeInserted(const QModelIndex &parent, int first, int last)
+        { modelChanged(RowsAboutToBeInserted, parent, first, last); }
+    void rowsInserted(const QModelIndex &parent, int first, int last)
+        { modelChanged(RowsInserted, parent, first, last); }
+    void rowsAboutToBeRemoved(const QModelIndex &parent, int first, int last)
+        { modelChanged(RowsAboutToBeRemoved, parent, first, last); }
+    void rowsRemoved(const QModelIndex &parent, int first, int last)
+        { modelChanged(RowsRemoved, parent, first, last); }
+    void columnsAboutToBeInserted(const QModelIndex &parent, int first, int last)
+        { modelChanged(ColumnsAboutToBeInserted, parent, first, last); }
+    void columnsInserted(const QModelIndex &parent, int first, int last)
+        { modelChanged(ColumnsInserted, parent, first, last); }
+    void columnsAboutToBeRemoved(const QModelIndex &parent, int first, int last)
+        { modelChanged(ColumnsAboutToBeRemoved, parent, first, last); }
+    void columnsRemoved(const QModelIndex &parent, int first, int last)
+        { modelChanged(ColumnsRemoved, parent, first, last); }
+
+    void modelChanged(ModelChanged change, const QModelIndex &parent, int first, int last);
+
+private slots:
+    void insertRow_data();
+    void insertRow();
+    void insertRows();
+    void insertRowsItems();
+    void insertRowInHierarcy();
+    void insertColumn_data();
+    void insertColumn();
+    void insertColumns();
+    void removeRows();
+    void removeColumns();
+    void setHeaderData();
+    void persistentIndexes();
+    void removingPersistentIndexes();
+    void updatingPersistentIndexes();
+
+    void checkChildren();
+    void data();
+    void clear();
+    void sort_data();
+    void sort();
+    void sortRole_data();
+    void sortRole();
+    void findItems();
+    void getSetHeaderItem();
+    void indexFromItem();
+    void itemFromIndex();
+    void getSetItemPrototype();
+    void getSetItemData();
+    void setHeaderLabels_data();
+    void setHeaderLabels();
+    void itemDataChanged();
+    void takeHeaderItem();
+    void useCase1();
+    void useCase2();
+    void useCase3();
+
+    void rootItemFlags();
+    void treeDragAndDrop();
+    void removeRowsAndColumns();
+
+    void itemRoleNames();
+
+private:
+    QAbstractItemModel *m_model;
+    QPersistentModelIndex persistent;
+    QVector<QModelIndex> rcParent;
+    QVector<int> rcFirst;
+    QVector<int> rcLast;
+
+    //return true if models have the same structure, and all child have the same text
+    bool compareModels(QStandardItemModel *model1, QStandardItemModel *model2);
+    //return true if models have the same structure, and all child have the same text
+    bool compareItems(QStandardItem *item1, QStandardItem *item2);
+};
+
+static const int defaultSize = 3;
+
+Q_DECLARE_METATYPE(QModelIndex)
+Q_DECLARE_METATYPE(QStandardItem*)
+Q_DECLARE_METATYPE(Qt::Orientation)
+Q_DECLARE_METATYPE(QVariantList)
+
+tst_QStandardItemModel::tst_QStandardItemModel() : m_model(0), rcParent(8), rcFirst(8,0), rcLast(8,0)
+{
+}
+
+tst_QStandardItemModel::~tst_QStandardItemModel()
+{
+}
+
+/*
+  This test usually uses a model with a 3x3 table
+  ---------------------------
+  |  0,0  |  0,1    |  0,2  |
+  ---------------------------
+  |  1,0  |  1,1    |  1,2  |
+  ---------------------------
+  |  2,0  |  2,1    |  2,2  |
+  ---------------------------
+*/
+void tst_QStandardItemModel::init()
+{
+    qRegisterMetaType<QModelIndex>("QModelIndex");
+    qRegisterMetaType<QStandardItem*>("QStandardItem*");
+    qRegisterMetaType<Qt::Orientation>("Qt::Orientation");
+
+    m_model = new QStandardItemModel(defaultSize, defaultSize);
+    connect(m_model, SIGNAL(rowsAboutToBeInserted(QModelIndex, int, int)),
+            this, SLOT(rowsAboutToBeInserted(QModelIndex, int, int)));
+    connect(m_model, SIGNAL(rowsInserted(QModelIndex, int, int)),
+            this, SLOT(rowsInserted(QModelIndex, int, int)));
+    connect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex, int, int)),
+            this, SLOT(rowsAboutToBeRemoved(QModelIndex, int, int)));
+    connect(m_model, SIGNAL(rowsRemoved(QModelIndex, int, int)),
+            this, SLOT(rowsRemoved(QModelIndex, int, int)));
+
+    connect(m_model, SIGNAL(columnsAboutToBeInserted(QModelIndex, int, int)),
+            this, SLOT(columnsAboutToBeInserted(QModelIndex, int, int)));
+    connect(m_model, SIGNAL(columnsInserted(QModelIndex, int, int)),
+            this, SLOT(columnsInserted(QModelIndex, int, int)));
+    connect(m_model, SIGNAL(columnsAboutToBeRemoved(QModelIndex, int, int)),
+            this, SLOT(columnsAboutToBeRemoved(QModelIndex, int, int)));
+    connect(m_model, SIGNAL(columnsRemoved(QModelIndex, int, int)),
+            this, SLOT(columnsRemoved(QModelIndex, int, int)));
+
+    rcFirst.fill(-1);
+    rcLast.fill(-1);
+}
+
+void tst_QStandardItemModel::cleanup()
+{
+    disconnect(m_model, SIGNAL(rowsAboutToBeInserted(QModelIndex, int, int)),
+               this, SLOT(rowsAboutToBeInserted(QModelIndex, int, int)));
+    disconnect(m_model, SIGNAL(rowsInserted(QModelIndex, int, int)),
+               this, SLOT(rowsInserted(QModelIndex, int, int)));
+    disconnect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex, int, int)),
+               this, SLOT(rowsAboutToBeRemoved(QModelIndex, int, int)));
+    disconnect(m_model, SIGNAL(rowsRemoved(QModelIndex, int, int)),
+               this, SLOT(rowsRemoved(QModelIndex, int, int)));
+
+    disconnect(m_model, SIGNAL(columnsAboutToBeInserted(QModelIndex, int, int)),
+               this, SLOT(columnsAboutToBeInserted(QModelIndex, int, int)));
+    disconnect(m_model, SIGNAL(columnsInserted(QModelIndex, int, int)),
+               this, SLOT(columnsInserted(QModelIndex, int, int)));
+    disconnect(m_model, SIGNAL(columnsAboutToBeRemoved(QModelIndex, int, int)),
+               this, SLOT(columnsAboutToBeRemoved(QModelIndex, int, int)));
+    disconnect(m_model, SIGNAL(columnsRemoved(QModelIndex, int, int)),
+               this, SLOT(columnsRemoved(QModelIndex, int, int)));
+    delete m_model;
+    m_model = 0;
+}
+
+void tst_QStandardItemModel::insertRow_data()
+{
+    QTest::addColumn<int>("insertRow");
+    QTest::addColumn<int>("expectedRow");
+
+    QTest::newRow("Insert less then 0") << -1 << 0;
+    QTest::newRow("Insert at 0")  << 0 << 0;
+    QTest::newRow("Insert beyond count")  << defaultSize+1 << defaultSize;
+    QTest::newRow("Insert at count") << defaultSize << defaultSize;
+    QTest::newRow("Insert in the middle") << 1 << 1;
+}
+
+void tst_QStandardItemModel::insertRow()
+{
+    QFETCH(int, insertRow);
+    QFETCH(int, expectedRow);
+
+    QIcon icon;
+    // default all initial items to DisplayRole: "initalitem"
+    for (int r=0; r < m_model->rowCount(); ++r) {
+        for (int c=0; c < m_model->columnCount(); ++c) {
+            m_model->setData(m_model->index(r,c), "initialitem", Qt::DisplayRole);
+        }
+    }
+
+    // check that inserts changes rowCount
+    QCOMPARE(m_model->rowCount(), defaultSize);
+    m_model->insertRow(insertRow);
+    if (insertRow >= 0 && insertRow <= defaultSize) {
+        QCOMPARE(m_model->rowCount(), defaultSize + 1);
+
+        // check that signals were emitted with correct info
+        QCOMPARE(rcFirst[RowsAboutToBeInserted], expectedRow);
+        QCOMPARE(rcLast[RowsAboutToBeInserted], expectedRow);
+        QCOMPARE(rcFirst[RowsInserted], expectedRow);
+        QCOMPARE(rcLast[RowsInserted], expectedRow);
+
+        //check that the inserted item has different DisplayRole than initial items
+        QVERIFY(m_model->data(m_model->index(expectedRow, 0), Qt::DisplayRole).toString() != "initialitem");
+    } else {
+        // We inserted something outside the bounds, do nothing
+        QCOMPARE(m_model->rowCount(), defaultSize);
+        QCOMPARE(rcFirst[RowsAboutToBeInserted], -1);
+        QCOMPARE(rcLast[RowsAboutToBeInserted], -1);
+        QCOMPARE(rcFirst[RowsInserted], -1);
+        QCOMPARE(rcLast[RowsInserted], -1);
+    }
+}
+
+void tst_QStandardItemModel::insertRows()
+{
+    int rowCount = m_model->rowCount();
+    QCOMPARE(rowCount, defaultSize);
+
+    // insert custom header label
+    QString headerLabel = "custom";
+    m_model->setHeaderData(0, Qt::Vertical, headerLabel);
+
+    // insert one row
+    m_model->insertRows(0, 1);
+    QCOMPARE(m_model->rowCount(), rowCount + 1);
+    rowCount = m_model->rowCount();
+
+    // check header data has moved
+    QCOMPARE(m_model->headerData(1, Qt::Vertical).toString(), headerLabel);
+
+    // insert two rows
+    m_model->insertRows(0, 2);
+    QCOMPARE(m_model->rowCount(), rowCount + 2);
+
+    // check header data has moved
+    QCOMPARE(m_model->headerData(3, Qt::Vertical).toString(), headerLabel);
+}
+
+void tst_QStandardItemModel::insertRowsItems()
+{
+    int rowCount = m_model->rowCount();
+
+    QList<QStandardItem *> items;
+    QStandardItemModel *m = qobject_cast<QStandardItemModel*>(m_model);
+    QStandardItem *hiddenRoot = m->invisibleRootItem();
+    for (int i = 0; i < 3; ++i)
+        items.append(new QStandardItem(QString("%1").arg(i + 10)));
+    hiddenRoot->appendRows(items);
+    QCOMPARE(m_model->rowCount(), rowCount + 3);
+    QCOMPARE(m_model->index(rowCount + 0, 0).data().toInt(), 10);
+    QCOMPARE(m_model->index(rowCount + 1, 0).data().toInt(), 11);
+    QCOMPARE(m_model->index(rowCount + 2, 0).data().toInt(), 12);
+    for (int i = rowCount; i < rowCount + 3; ++i) {
+        QVERIFY(m->item(i));
+        QCOMPARE(static_cast<QAbstractItemModel *>(m->item(i)->model()), m_model);
+    }
+}
+
+void tst_QStandardItemModel::insertRowInHierarcy()
+{
+    QVERIFY(m_model->insertRows(0, 1, QModelIndex()));
+    QVERIFY(m_model->insertColumns(0, 1, QModelIndex()));
+    QVERIFY(m_model->hasIndex(0, 0, QModelIndex()));
+
+    QModelIndex parent = m_model->index(0, 0, QModelIndex());
+    QVERIFY(parent.isValid());
+
+    QVERIFY(m_model->insertRows(0, 1, parent));
+    QVERIFY(m_model->insertColumns(0, 1, parent));
+    QVERIFY(m_model->hasIndex(0, 0, parent));
+
+    QModelIndex child = m_model->index(0, 0, parent);
+    QVERIFY(child.isValid());
+}
+
+void tst_QStandardItemModel::insertColumn_data()
+{
+    QTest::addColumn<int>("insertColumn");
+    QTest::addColumn<int>("expectedColumn");
+
+    QTest::newRow("Insert less then 0") << -1 << 0;
+    QTest::newRow("Insert at 0")  << 0 << 0;
+    QTest::newRow("Insert beyond count")  << defaultSize+1 << defaultSize;
+    QTest::newRow("Insert at count") << defaultSize << defaultSize;
+    QTest::newRow("Insert in the middle") << 1 << 1;
+}
+
+void tst_QStandardItemModel::insertColumn()
+{
+    QFETCH(int, insertColumn);
+    QFETCH(int, expectedColumn);
+
+    // default all initial items to DisplayRole: "initalitem"
+    for (int r=0; r < m_model->rowCount(); ++r) {
+        for (int c=0; c < m_model->columnCount(); ++c) {
+            m_model->setData(m_model->index(r,c), "initialitem", Qt::DisplayRole);
+        }
+    }
+
+    // check that inserts changes columnCount
+    QCOMPARE(m_model->columnCount(), defaultSize);
+    m_model->insertColumn(insertColumn);
+    if (insertColumn >= 0 && insertColumn <= defaultSize) {
+        QCOMPARE(m_model->columnCount(), defaultSize +  1);
+        // check that signals were emitted with correct info
+        QCOMPARE(rcFirst[ColumnsAboutToBeInserted], expectedColumn);
+        QCOMPARE(rcLast[ColumnsAboutToBeInserted], expectedColumn);
+        QCOMPARE(rcFirst[ColumnsInserted], expectedColumn);
+        QCOMPARE(rcLast[ColumnsInserted], expectedColumn);
+
+        //check that the inserted item has different DisplayRole than initial items
+        QVERIFY(m_model->data(m_model->index(0, expectedColumn), Qt::DisplayRole).toString() != "initialitem");
+    } else {
+        // We inserted something outside the bounds, do nothing
+        QCOMPARE(m_model->columnCount(), defaultSize);
+        QCOMPARE(rcFirst[ColumnsAboutToBeInserted], -1);
+        QCOMPARE(rcLast[ColumnsAboutToBeInserted], -1);
+        QCOMPARE(rcFirst[ColumnsInserted], -1);
+        QCOMPARE(rcLast[ColumnsInserted], -1);
+    }
+
+}
+
+void tst_QStandardItemModel::insertColumns()
+{
+    int columnCount = m_model->columnCount();
+    QCOMPARE(columnCount, defaultSize);
+
+    // insert custom header label
+    QString headerLabel = "custom";
+    m_model->setHeaderData(0, Qt::Horizontal, headerLabel);
+
+    // insert one column
+    m_model->insertColumns(0, 1);
+    QCOMPARE(m_model->columnCount(), columnCount + 1);
+    columnCount = m_model->columnCount();
+
+    // check header data has moved
+    QCOMPARE(m_model->headerData(1, Qt::Horizontal).toString(), headerLabel);
+
+    // insert two columns
+    m_model->insertColumns(0, 2);
+    QCOMPARE(m_model->columnCount(), columnCount + 2);
+
+    // check header data has moved
+    QCOMPARE(m_model->headerData(3, Qt::Horizontal).toString(), headerLabel);
+}
+
+void tst_QStandardItemModel::removeRows()
+{
+    int rowCount = m_model->rowCount();
+    QCOMPARE(rowCount, defaultSize);
+
+    // insert custom header label
+    QString headerLabel = "custom";
+    m_model->setHeaderData(rowCount - 1, Qt::Vertical, headerLabel);
+
+    // remove one row
+    m_model->removeRows(0, 1);
+    QCOMPARE(m_model->rowCount(), rowCount - 1);
+    rowCount = m_model->rowCount();
+
+    // check header data has moved
+    QCOMPARE(m_model->headerData(rowCount - 1, Qt::Vertical).toString(), headerLabel);
+
+    // remove two rows
+    m_model->removeRows(0, 2);
+    QCOMPARE(m_model->rowCount(), rowCount - 2);
+}
+
+void tst_QStandardItemModel::removeColumns()
+{
+    int columnCount = m_model->columnCount();
+    QCOMPARE(columnCount, defaultSize);
+
+    // insert custom header label
+    QString headerLabel = "custom";
+    m_model->setHeaderData(columnCount - 1, Qt::Horizontal, headerLabel);
+
+    // remove one column
+    m_model->removeColumns(0, 1);
+    QCOMPARE(m_model->columnCount(), columnCount - 1);
+    columnCount = m_model->columnCount();
+
+    // check header data has moved
+    QCOMPARE(m_model->headerData(columnCount - 1, Qt::Horizontal).toString(), headerLabel);
+
+    // remove two columns
+    m_model->removeColumns(0, 2);
+    QCOMPARE(m_model->columnCount(), columnCount - 2);
+}
+
+
+void tst_QStandardItemModel::setHeaderData()
+{
+    for (int x = 0; x < 2; ++x) {
+        bool vertical = (x == 0);
+        int count = vertical ? m_model->rowCount() : m_model->columnCount();
+        QCOMPARE(count, defaultSize);
+        Qt::Orientation orient = vertical ? Qt::Vertical : Qt::Horizontal;
+
+        // check default values are ok
+        for (int i = 0; i < count; ++i)
+            QCOMPARE(m_model->headerData(i, orient).toString(), QString::number(i + 1));
+
+        QSignalSpy headerDataChangedSpy(
+            m_model, SIGNAL(headerDataChanged(Qt::Orientation, int, int)));
+        QSignalSpy dataChangedSpy(
+            m_model, SIGNAL(dataChanged(QModelIndex, QModelIndex)));
+        // insert custom values and check
+        for (int i = 0; i < count; ++i) {
+            QString customString = QString("custom") + QString::number(i);
+            QCOMPARE(m_model->setHeaderData(i, orient, customString), true);
+            QCOMPARE(headerDataChangedSpy.count(), 1);
+            QCOMPARE(dataChangedSpy.count(), 0);
+            QVariantList args = headerDataChangedSpy.takeFirst();
+            QCOMPARE(qvariant_cast<Qt::Orientation>(args.at(0)), orient);
+            QCOMPARE(args.at(1).toInt(), i);
+            QCOMPARE(args.at(2).toInt(), i);
+            QCOMPARE(m_model->headerData(i, orient).toString(), customString);
+            QCOMPARE(m_model->setHeaderData(i, orient, customString), true);
+            QCOMPARE(headerDataChangedSpy.count(), 0);
+            QCOMPARE(dataChangedSpy.count(), 0);
+        }
+
+        //check read from invalid sections
+        QVERIFY(!m_model->headerData(count, orient).isValid());
+        QVERIFY(!m_model->headerData(-1, orient).isValid());
+        //check write to invalid section
+        QCOMPARE(m_model->setHeaderData(count, orient, "foo"), false);
+        QCOMPARE(m_model->setHeaderData(-1, orient, "foo"), false);
+        QVERIFY(!m_model->headerData(count, orient).isValid());
+        QVERIFY(!m_model->headerData(-1, orient).isValid());
+    }
+}
+
+void tst_QStandardItemModel::persistentIndexes()
+{
+    QCOMPARE(m_model->rowCount(), defaultSize);
+    QCOMPARE(m_model->columnCount(), defaultSize);
+
+    // create a persisten index at 0,0
+    QPersistentModelIndex persistentIndex(m_model->index(0, 0));
+
+    // verify it is ok and at the correct spot
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 0);
+    QCOMPARE(persistentIndex.column(), 0);
+
+    // insert row and check that the persisten index has moved
+    QVERIFY(m_model->insertRow(0));
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 1);
+    QCOMPARE(persistentIndex.column(), 0);
+
+    // insert row after the persisten index and see that it stays the same
+    QVERIFY(m_model->insertRow(m_model->rowCount()));
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 1);
+    QCOMPARE(persistentIndex.column(), 0);
+
+    // insert column and check that the persisten index has moved
+    QVERIFY(m_model->insertColumn(0));
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 1);
+    QCOMPARE(persistentIndex.column(), 1);
+
+    // insert column after the persisten index and see that it stays the same
+    QVERIFY(m_model->insertColumn(m_model->columnCount()));
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 1);
+    QCOMPARE(persistentIndex.column(), 1);
+
+    // removes a row beyond the persistent index and see it stays the same
+    QVERIFY(m_model->removeRow(m_model->rowCount() - 1));
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 1);
+    QCOMPARE(persistentIndex.column(), 1);
+
+    // removes a column beyond the persistent index and see it stays the same
+    QVERIFY(m_model->removeColumn(m_model->columnCount() - 1));
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 1);
+    QCOMPARE(persistentIndex.column(), 1);
+
+    // removes a row before the persistent index and see it moves the same
+    QVERIFY(m_model->removeRow(0));
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 0);
+    QCOMPARE(persistentIndex.column(), 1);
+
+    // removes a column before the persistent index and see it moves the same
+    QVERIFY(m_model->removeColumn(0));
+    QVERIFY(persistentIndex.isValid());
+    QCOMPARE(persistentIndex.row(), 0);
+    QCOMPARE(persistentIndex.column(), 0);
+
+    // remove the row where the persistent index is, and see that it becomes invalid
+    QVERIFY(m_model->removeRow(0));
+    QVERIFY(!persistentIndex.isValid());
+
+    // remove the row where the persistent index is, and see that it becomes invalid
+    persistentIndex = m_model->index(0, 0);
+    QVERIFY(persistentIndex.isValid());
+    QVERIFY(m_model->removeColumn(0));
+    QVERIFY(!persistentIndex.isValid());
+}
+
+void tst_QStandardItemModel::checkAboutToBeRemoved()
+{
+    QVERIFY(persistent.isValid());
+}
+
+void tst_QStandardItemModel::checkRemoved()
+{
+    QVERIFY(!persistent.isValid());
+}
+
+void tst_QStandardItemModel::removingPersistentIndexes()
+{
+    // add 10 rows and columns to model to make it big enough
+    QVERIFY(m_model->insertRows(0, 10));
+    QVERIFY(m_model->insertColumns(0, 10));
+
+    QObject::connect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
+                     this, SLOT(checkAboutToBeRemoved()));
+    QObject::connect(m_model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
+                     this, SLOT(checkRemoved()));
+    QObject::connect(m_model, SIGNAL(columnsAboutToBeRemoved(QModelIndex,int,int)),
+                     this, SLOT(checkAboutToBeRemoved()));
+    QObject::connect(m_model, SIGNAL(columnsRemoved(QModelIndex,int,int)),
+                     this, SLOT(checkRemoved()));
+
+
+    // test removeRow
+    // add child table 3x3 to parent index(0, 0)
+    QVERIFY(m_model->insertRows(0, 3, m_model->index(0, 0)));
+    QVERIFY(m_model->insertColumns(0, 3, m_model->index(0, 0)));
+
+    // set child to persistent and delete parent row
+    persistent = m_model->index(0, 0, m_model->index(0, 0));
+    QVERIFY(persistent.isValid());
+    QVERIFY(m_model->removeRow(0));
+
+    // set persistent to index(0, 0) and remove that row
+    persistent = m_model->index(0, 0);
+    QVERIFY(persistent.isValid());
+    QVERIFY(m_model->removeRow(0));
+
+
+    // test removeColumn
+    // add child table 3x3 to parent index (0, 0)
+    QVERIFY(m_model->insertRows(0, 3, m_model->index(0, 0)));
+    QVERIFY(m_model->insertColumns(0, 3, m_model->index(0, 0)));
+
+    // set child to persistent and delete parent column
+    persistent = m_model->index(0, 0, m_model->index(0, 0));
+    QVERIFY(persistent.isValid());
+    QVERIFY(m_model->removeColumn(0));
+
+    // set persistent to index(0, 0) and remove that column
+    persistent = m_model->index(0, 0);
+    QVERIFY(persistent.isValid());
+    QVERIFY(m_model->removeColumn(0));
+
+
+    QObject::disconnect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
+                        this, SLOT(checkAboutToBeRemoved()));
+    QObject::disconnect(m_model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
+                        this, SLOT(checkRemoved()));
+    QObject::disconnect(m_model, SIGNAL(columnsAboutToBeRemoved(QModelIndex,int,int)),
+                        this, SLOT(checkAboutToBeRemoved()));
+    QObject::disconnect(m_model, SIGNAL(columnsRemoved(QModelIndex,int,int)),
+                        this, SLOT(checkRemoved()));
+}
+
+void tst_QStandardItemModel::updateRowAboutToBeRemoved()
+{
+    QModelIndex idx = m_model->index(0, 0);
+    QVERIFY(idx.isValid());
+    persistent = idx;
+}
+
+void tst_QStandardItemModel::updatingPersistentIndexes()
+{
+    QObject::connect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
+                     this, SLOT(updateRowAboutToBeRemoved()));
+
+    persistent = m_model->index(1, 0);
+    QVERIFY(persistent.isValid());
+    QVERIFY(m_model->removeRow(1));
+    QVERIFY(persistent.isValid());
+    QPersistentModelIndex tmp = m_model->index(0, 0);
+    QCOMPARE(persistent, tmp);
+
+    QObject::disconnect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
+                        this, SLOT(updateRowAboutToBeRemoved()));
+}
+
+void tst_QStandardItemModel::modelChanged(ModelChanged change, const QModelIndex &parent,
+                                          int first, int last)
+{
+    rcParent[change] = parent;
+    rcFirst[change] = first;
+    rcLast[change] = last;
+}
+
+
+void tst_QStandardItemModel::checkChildren()
+{
+    QStandardItemModel model(0, 0);
+    QCOMPARE(model.rowCount(), 0);
+    QCOMPARE(model.columnCount(), 0);
+    QVERIFY(!model.hasChildren());
+
+    QVERIFY(model.insertRows(0, 1));
+    QVERIFY(!model.hasChildren());
+    QCOMPARE(model.rowCount(), 1);
+    QCOMPARE(model.columnCount(), 0);
+
+    QVERIFY(model.insertColumns(0, 1));
+    QVERIFY(model.hasChildren());
+    QCOMPARE(model.rowCount(), 1);
+    QCOMPARE(model.columnCount(), 1);
+
+    QModelIndex idx = model.index(0, 0);
+    QVERIFY(!model.hasChildren(idx));
+    QCOMPARE(model.rowCount(idx), 0);
+    QCOMPARE(model.columnCount(idx), 0);
+
+    QVERIFY(model.insertRows(0, 1, idx));
+    QVERIFY(!model.hasChildren(idx));
+    QCOMPARE(model.rowCount(idx), 1);
+    QCOMPARE(model.columnCount(idx), 0);
+
+    QVERIFY(model.insertColumns(0, 1, idx));
+    QVERIFY(model.hasChildren(idx));
+    QCOMPARE(model.rowCount(idx), 1);
+    QCOMPARE(model.columnCount(idx), 1);
+
+    QModelIndex idx2 = model.index(0, 0, idx);
+    QVERIFY(!model.hasChildren(idx2));
+    QCOMPARE(model.rowCount(idx2), 0);
+    QCOMPARE(model.columnCount(idx2), 0);
+
+    QVERIFY(model.removeRows(0, 1, idx));
+    QVERIFY(model.hasChildren());
+    QCOMPARE(model.rowCount(), 1);
+    QCOMPARE(model.columnCount(), 1);
+    QVERIFY(!model.hasChildren(idx));
+    QCOMPARE(model.rowCount(idx), 0);
+    QCOMPARE(model.columnCount(idx), 1);
+
+    QVERIFY(model.removeRows(0, 1));
+    QVERIFY(!model.hasChildren());
+    QCOMPARE(model.rowCount(), 0);
+    QCOMPARE(model.columnCount(), 1);
+}
+
+void tst_QStandardItemModel::data()
+{
+    // bad args
+    m_model->setData(QModelIndex(), "bla", Qt::DisplayRole);
+
+    QIcon icon;
+    for (int r=0; r < m_model->rowCount(); ++r) {
+        for (int c=0; c < m_model->columnCount(); ++c) {
+            m_model->setData(m_model->index(r,c), "initialitem", Qt::DisplayRole);
+            m_model->setData(m_model->index(r,c), "tooltip", Qt::ToolTipRole);
+            m_model->setData(m_model->index(r,c), icon, Qt::DecorationRole);
+        }
+    }
+
+    QVERIFY(m_model->data(m_model->index(0, 0), Qt::DisplayRole).toString() == "initialitem");
+    QVERIFY(m_model->data(m_model->index(0, 0), Qt::ToolTipRole).toString() == "tooltip");
+
+}
+
+void tst_QStandardItemModel::clear()
+{
+    QStandardItemModel model;
+    model.insertColumns(0, 10);
+    model.insertRows(0, 10);
+    QCOMPARE(model.columnCount(), 10);
+    QCOMPARE(model.rowCount(), 10);
+
+    QSignalSpy modelResetSpy(&model, SIGNAL(modelReset()));
+    QSignalSpy layoutChangedSpy(&model, SIGNAL(layoutChanged()));
+    QSignalSpy rowsRemovedSpy(&model, SIGNAL(rowsRemoved(QModelIndex, int, int)));
+    model.clear();
+
+    QCOMPARE(modelResetSpy.count(), 1);
+    QCOMPARE(layoutChangedSpy.count(), 0);
+    QCOMPARE(rowsRemovedSpy.count(), 0);
+    QCOMPARE(model.index(0, 0), QModelIndex());
+    QCOMPARE(model.columnCount(), 0);
+    QCOMPARE(model.rowCount(), 0);
+    QCOMPARE(model.hasChildren(), false);
+}
+
+void tst_QStandardItemModel::sort_data()
+{
+    QTest::addColumn<int>("sortOrder");
+    QTest::addColumn<QStringList>("initial");
+    QTest::addColumn<QStringList>("expected");
+
+    QTest::newRow("flat descending") << static_cast<int>(Qt::DescendingOrder)
+                                  << (QStringList()
+                                      << "delta"
+                                      << "yankee"
+                                      << "bravo"
+                                      << "lima"
+                                      << "charlie"
+                                      << "juliet"
+                                      << "tango"
+                                      << "hotel"
+                                      << "uniform"
+                                      << "alpha"
+                                      << "echo"
+                                      << "golf"
+                                      << "quebec"
+                                      << "foxtrot"
+                                      << "india"
+                                      << "romeo"
+                                      << "november"
+                                      << "oskar"
+                                      << "zulu"
+                                      << "kilo"
+                                      << "whiskey"
+                                      << "mike"
+                                      << "papa"
+                                      << "sierra"
+                                      << "xray"
+                                      << "viktor")
+                                  << (QStringList()
+                                      << "zulu"
+                                      << "yankee"
+                                      << "xray"
+                                      << "whiskey"
+                                      << "viktor"
+                                      << "uniform"
+                                      << "tango"
+                                      << "sierra"
+                                      << "romeo"
+                                      << "quebec"
+                                      << "papa"
+                                      << "oskar"
+                                      << "november"
+                                      << "mike"
+                                      << "lima"
+                                      << "kilo"
+                                      << "juliet"
+                                      << "india"
+                                      << "hotel"
+                                      << "golf"
+                                      << "foxtrot"
+                                      << "echo"
+                                      << "delta"
+                                      << "charlie"
+                                      << "bravo"
+                                      << "alpha");
+    QTest::newRow("flat ascending") <<  static_cast<int>(Qt::AscendingOrder)
+                                 << (QStringList()
+                                     << "delta"
+                                     << "yankee"
+                                     << "bravo"
+                                     << "lima"
+                                     << "charlie"
+                                     << "juliet"
+                                     << "tango"
+                                     << "hotel"
+                                     << "uniform"
+                                     << "alpha"
+                                     << "echo"
+                                     << "golf"
+                                     << "quebec"
+                                     << "foxtrot"
+                                     << "india"
+                                     << "romeo"
+                                     << "november"
+                                     << "oskar"
+                                     << "zulu"
+                                     << "kilo"
+                                     << "whiskey"
+                                     << "mike"
+                                     << "papa"
+                                     << "sierra"
+                                     << "xray"
+                                     << "viktor")
+                                 << (QStringList()
+                                     << "alpha"
+                                     << "bravo"
+                                     << "charlie"
+                                     << "delta"
+                                     << "echo"
+                                     << "foxtrot"
+                                     << "golf"
+                                     << "hotel"
+                                     << "india"
+                                     << "juliet"
+                                     << "kilo"
+                                     << "lima"
+                                     << "mike"
+                                     << "november"
+                                     << "oskar"
+                                     << "papa"
+                                     << "quebec"
+                                     << "romeo"
+                                     << "sierra"
+                                     << "tango"
+                                     << "uniform"
+                                     << "viktor"
+                                     << "whiskey"
+                                     << "xray"
+                                     << "yankee"
+                                     << "zulu");
+    QStringList list;
+    for (int i=1000; i < 2000; ++i)
+        list.append(QString("Number: %1").arg(i));
+    QTest::newRow("large set ascending") <<  static_cast<int>(Qt::AscendingOrder) << list << list;
+}
+
+void tst_QStandardItemModel::sort()
+{
+    QFETCH(int, sortOrder);
+    QFETCH(QStringList, initial);
+    QFETCH(QStringList, expected);
+    // prepare model
+    QStandardItemModel model;
+    QVERIFY(model.insertRows(0, initial.count(), QModelIndex()));
+    QCOMPARE(model.rowCount(QModelIndex()), initial.count());
+    model.insertColumns(0, 1, QModelIndex());
+    QCOMPARE(model.columnCount(QModelIndex()), 1);
+    for (int row = 0; row < model.rowCount(QModelIndex()); ++row) {
+        QModelIndex index = model.index(row, 0, QModelIndex());
+        model.setData(index, initial.at(row), Qt::DisplayRole);
+    }
+
+    QSignalSpy layoutAboutToBeChangedSpy(
+        &model, SIGNAL(layoutAboutToBeChanged()));
+    QSignalSpy layoutChangedSpy(
+        &model, SIGNAL(layoutChanged()));
+
+    // sort
+    model.sort(0, static_cast<Qt::SortOrder>(sortOrder));
+
+    QCOMPARE(layoutAboutToBeChangedSpy.count(), 1);
+    QCOMPARE(layoutChangedSpy.count(), 1);
+
+    // make sure the model is sorted
+    for (int row = 0; row < model.rowCount(QModelIndex()); ++row) {
+        QModelIndex index = model.index(row, 0, QModelIndex());
+        QCOMPARE(model.data(index, Qt::DisplayRole).toString(), expected.at(row));
+    }
+}
+
+void tst_QStandardItemModel::sortRole_data()
+{
+    QTest::addColumn<QStringList>("initialText");
+    QTest::addColumn<QVariantList>("initialData");
+    QTest::addColumn<int>("sortRole");
+    QTest::addColumn<int>("sortOrder");
+    QTest::addColumn<QStringList>("expectedText");
+    QTest::addColumn<QVariantList>("expectedData");
+
+    QTest::newRow("sort ascending with Qt::DisplayRole")
+        << (QStringList() << "b" << "a" << "c")
+        << (QVariantList() << 2 << 3 << 1)
+        << static_cast<int>(Qt::DisplayRole)
+        << static_cast<int>(Qt::AscendingOrder)
+        << (QStringList() << "a" << "b" << "c")
+        << (QVariantList() << 3 << 2 << 1);
+    QTest::newRow("sort ascending with Qt::UserRole")
+        << (QStringList() << "a" << "b" << "c")
+        << (QVariantList() << 3 << 2 << 1)
+        << static_cast<int>(Qt::UserRole)
+        << static_cast<int>(Qt::AscendingOrder)
+        << (QStringList() << "c" << "b" << "a")
+        << (QVariantList() << 1 << 2 << 3);
+}
+
+void tst_QStandardItemModel::sortRole()
+{
+    QFETCH(QStringList, initialText);
+    QFETCH(QVariantList, initialData);
+    QFETCH(int, sortRole);
+    QFETCH(int, sortOrder);
+    QFETCH(QStringList, expectedText);
+    QFETCH(QVariantList, expectedData);
+
+    QStandardItemModel model;
+    for (int i = 0; i < initialText.count(); ++i) {
+        QStandardItem *item = new QStandardItem;
+        item->setText(initialText.at(i));
+        item->setData(initialData.at(i), Qt::UserRole);
+        model.appendRow(item);
+    }
+    model.setSortRole(sortRole);
+    model.sort(0, static_cast<Qt::SortOrder>(sortOrder));
+    for (int i = 0; i < expectedText.count(); ++i) {
+        QStandardItem *item = model.item(i);
+        QCOMPARE(item->text(), expectedText.at(i));
+        QCOMPARE(item->data(Qt::UserRole), expectedData.at(i));
+    }
+}
+
+void tst_QStandardItemModel::findItems()
+{
+    QStandardItemModel model;
+    model.appendRow(new QStandardItem(QLatin1String("foo")));
+    model.appendRow(new QStandardItem(QLatin1String("bar")));
+    model.item(1)->appendRow(new QStandardItem(QLatin1String("foo")));
+    QList<QStandardItem*> matches;
+    matches = model.findItems(QLatin1String("foo"), Qt::MatchExactly|Qt::MatchRecursive, 0);
+    QCOMPARE(matches.count(), 2);
+    matches = model.findItems(QLatin1String("foo"), Qt::MatchExactly, 0);
+    QCOMPARE(matches.count(), 1);
+    matches = model.findItems(QLatin1String("food"), Qt::MatchExactly|Qt::MatchRecursive, 0);
+    QCOMPARE(matches.count(), 0);
+    matches = model.findItems(QLatin1String("foo"), Qt::MatchExactly|Qt::MatchRecursive, -1);
+    QCOMPARE(matches.count(), 0);
+    matches = model.findItems(QLatin1String("foo"), Qt::MatchExactly|Qt::MatchRecursive, 1);
+    QCOMPARE(matches.count(), 0);
+}
+
+void tst_QStandardItemModel::getSetHeaderItem()
+{
+    QStandardItemModel model;
+
+    QCOMPARE(model.horizontalHeaderItem(0), static_cast<QStandardItem*>(0));
+    QStandardItem *hheader = new QStandardItem();
+    model.setHorizontalHeaderItem(0, hheader);
+    QCOMPARE(model.columnCount(), 1);
+    QCOMPARE(model.horizontalHeaderItem(0), hheader);
+    QCOMPARE(hheader->model(), &model);
+    model.setHorizontalHeaderItem(0, 0);
+    QCOMPARE(model.horizontalHeaderItem(0), static_cast<QStandardItem*>(0));
+
+    QCOMPARE(model.verticalHeaderItem(0), static_cast<QStandardItem*>(0));
+    QStandardItem *vheader = new QStandardItem();
+    model.setVerticalHeaderItem(0, vheader);
+    QCOMPARE(model.rowCount(), 1);
+    QCOMPARE(model.verticalHeaderItem(0), vheader);
+    QCOMPARE(vheader->model(), &model);
+    model.setVerticalHeaderItem(0, 0);
+    QCOMPARE(model.verticalHeaderItem(0), static_cast<QStandardItem*>(0));
+}
+
+void tst_QStandardItemModel::indexFromItem()
+{
+    QStandardItemModel model;
+
+    QCOMPARE(model.indexFromItem(model.invisibleRootItem()), QModelIndex());
+
+    QStandardItem *item = new QStandardItem;
+    model.setItem(10, 20, item);
+    QCOMPARE(item->model(), &model);
+    QModelIndex itemIndex = model.indexFromItem(item);
+    QVERIFY(itemIndex.isValid());
+    QCOMPARE(itemIndex.row(), 10);
+    QCOMPARE(itemIndex.column(), 20);
+    QCOMPARE(itemIndex.parent(), QModelIndex());
+    QCOMPARE(itemIndex.model(), (const QAbstractItemModel*)(&model));
+
+    QStandardItem *child = new QStandardItem;
+    item->setChild(4, 2, child);
+    QModelIndex childIndex = model.indexFromItem(child);
+    QVERIFY(childIndex.isValid());
+    QCOMPARE(childIndex.row(), 4);
+    QCOMPARE(childIndex.column(), 2);
+    QCOMPARE(childIndex.parent(), itemIndex);
+
+    QStandardItem *dummy = new QStandardItem;
+    QModelIndex noSuchIndex = model.indexFromItem(dummy);
+    QVERIFY(!noSuchIndex.isValid());
+    delete dummy;
+
+    noSuchIndex = model.indexFromItem(0);
+    QVERIFY(!noSuchIndex.isValid());
+}
+
+void tst_QStandardItemModel::itemFromIndex()
+{
+    QStandardItemModel model;
+
+    QCOMPARE(model.itemFromIndex(QModelIndex()), (QStandardItem*)0);
+
+    QStandardItem *item = new QStandardItem;
+    model.setItem(10, 20, item);
+    QModelIndex itemIndex = model.index(10, 20, QModelIndex());
+    QVERIFY(itemIndex.isValid());
+    QCOMPARE(model.itemFromIndex(itemIndex), item);
+
+    QStandardItem *child = new QStandardItem;
+    item->setChild(4, 2, child);
+    QModelIndex childIndex = model.index(4, 2, itemIndex);
+    QVERIFY(childIndex.isValid());
+    QCOMPARE(model.itemFromIndex(childIndex), child);
+
+    QModelIndex noSuchIndex = model.index(99, 99, itemIndex);
+    QVERIFY(!noSuchIndex.isValid());
+}
+
+class CustomItem : public QStandardItem
+{
+public:
+    CustomItem() : QStandardItem() { }
+    ~CustomItem() { }
+    int type() const {
+        return UserType;
+    }
+    QStandardItem *clone() const {
+        return new CustomItem;
+    }
+};
+
+void tst_QStandardItemModel::getSetItemPrototype()
+{
+    QStandardItemModel model;
+    QCOMPARE(model.itemPrototype(), static_cast<const QStandardItem*>(0));
+
+    const CustomItem *proto = new CustomItem;
+    model.setItemPrototype(proto);
+    QCOMPARE(model.itemPrototype(), (const QStandardItem*)proto);
+
+    model.setRowCount(1);
+    model.setColumnCount(1);
+    QModelIndex index = model.index(0, 0, QModelIndex());
+    model.setData(index, "foo");
+    QStandardItem *item = model.itemFromIndex(index);
+    QVERIFY(item != 0);
+    QCOMPARE(item->type(), static_cast<int>(QStandardItem::UserType));
+
+    model.setItemPrototype(0);
+    QCOMPARE(model.itemPrototype(), static_cast<const QStandardItem*>(0));
+}
+
+void tst_QStandardItemModel::getSetItemData()
+{
+    QMap<int, QVariant> roles;
+    QLatin1String text("text");
+    roles.insert(Qt::DisplayRole, text);
+    QLatin1String statusTip("statusTip");
+    roles.insert(Qt::StatusTipRole, statusTip);
+    QLatin1String toolTip("toolTip");
+    roles.insert(Qt::ToolTipRole, toolTip);
+    QLatin1String whatsThis("whatsThis");
+    roles.insert(Qt::WhatsThisRole, whatsThis);
+    QSize sizeHint(64, 48);
+    roles.insert(Qt::SizeHintRole, sizeHint);
+    QFont font;
+    roles.insert(Qt::FontRole, font);
+    Qt::Alignment textAlignment(Qt::AlignLeft|Qt::AlignVCenter);
+    roles.insert(Qt::TextAlignmentRole, int(textAlignment));
+    QColor backgroundColor(Qt::blue);
+    roles.insert(Qt::BackgroundRole, backgroundColor);
+    QColor textColor(Qt::green);
+    roles.insert(Qt::TextColorRole, textColor);
+    Qt::CheckState checkState(Qt::PartiallyChecked);
+    roles.insert(Qt::CheckStateRole, int(checkState));
+    QLatin1String accessibleText("accessibleText");
+    roles.insert(Qt::AccessibleTextRole, accessibleText);
+    QLatin1String accessibleDescription("accessibleDescription");
+    roles.insert(Qt::AccessibleDescriptionRole, accessibleDescription);
+
+    QStandardItemModel model;
+    model.insertRows(0, 1);
+    model.insertColumns(0, 1);
+    QModelIndex idx = model.index(0, 0, QModelIndex());
+
+    QSignalSpy modelDataChangedSpy(
+         &model, SIGNAL(dataChanged(const QModelIndex&, const QModelIndex&)));
+    QVERIFY(model.setItemData(idx, roles));
+    QCOMPARE(modelDataChangedSpy.count(), 1);
+    QVERIFY(model.setItemData(idx, roles));
+    QCOMPARE(modelDataChangedSpy.count(), 1); //it was already changed once
+    QCOMPARE(model.itemData(idx), roles);
+}
+
+void tst_QStandardItemModel::setHeaderLabels_data()
+{
+    QTest::addColumn<int>("rows");
+    QTest::addColumn<int>("columns");
+    QTest::addColumn<int>("orientation");
+    QTest::addColumn<QStringList>("labels");
+    QTest::addColumn<QStringList>("expectedLabels");
+
+    QTest::newRow("horizontal labels")
+        << 1
+        << 4
+        << int(Qt::Horizontal)
+        << (QStringList() << "a" << "b" << "c" << "d")
+        << (QStringList() << "a" << "b" << "c" << "d");
+    QTest::newRow("vertical labels")
+        << 4
+        << 1
+        << int(Qt::Vertical)
+        << (QStringList() << "a" << "b" << "c" << "d")
+        << (QStringList() << "a" << "b" << "c" << "d");
+    QTest::newRow("too few (horizontal)")
+        << 1
+        << 4
+        << int(Qt::Horizontal)
+        << (QStringList() << "a" << "b")
+        << (QStringList() << "a" << "b" << "3" << "4");
+    QTest::newRow("too few (vertical)")
+        << 4
+        << 1
+        << int(Qt::Vertical)
+        << (QStringList() << "a" << "b")
+        << (QStringList() << "a" << "b" << "3" << "4");
+    QTest::newRow("too many (horizontal)")
+        << 1
+        << 2
+        << int(Qt::Horizontal)
+        << (QStringList() << "a" << "b" << "c" << "d")
+        << (QStringList() << "a" << "b" << "c" << "d");
+    QTest::newRow("too many (vertical)")
+        << 2
+        << 1
+        << int(Qt::Vertical)
+        << (QStringList() << "a" << "b" << "c" << "d")
+        << (QStringList() << "a" << "b" << "c" << "d");
+}
+
+void tst_QStandardItemModel::setHeaderLabels()
+{
+    QFETCH(int, rows);
+    QFETCH(int, columns);
+    QFETCH(int, orientation);
+    QFETCH(QStringList, labels);
+    QFETCH(QStringList, expectedLabels);
+    QStandardItemModel model(rows, columns);
+    QSignalSpy columnsInsertedSpy(
+        &model, SIGNAL(columnsInserted(QModelIndex,int,int)));
+    QSignalSpy rowsInsertedSpy(
+        &model, SIGNAL(rowsInserted(QModelIndex,int,int)));
+    if (orientation == Qt::Horizontal)
+        model.setHorizontalHeaderLabels(labels);
+    else
+        model.setVerticalHeaderLabels(labels);
+    for (int i = 0; i < expectedLabels.count(); ++i)
+        QCOMPARE(model.headerData(i, Qt::Orientation(orientation)).toString(), expectedLabels.at(i));
+    QCOMPARE(columnsInsertedSpy.count(),
+             (orientation == Qt::Vertical) ? 0 : labels.count() > columns);
+    QCOMPARE(rowsInsertedSpy.count(),
+             (orientation == Qt::Horizontal) ? 0 : labels.count() > rows);
+}
+
+void tst_QStandardItemModel::itemDataChanged()
+{
+    QStandardItemModel model(6, 4);
+    QStandardItem item;
+    QSignalSpy dataChangedSpy(
+        &model, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)));
+    QSignalSpy itemChangedSpy(
+        &model, SIGNAL(itemChanged(QStandardItem *)));
+
+    model.setItem(0, &item);
+    QCOMPARE(dataChangedSpy.count(), 1);
+    QCOMPARE(itemChangedSpy.count(), 1);
+    QModelIndex index = model.indexFromItem(&item);
+    QList<QVariant> args;
+    args = dataChangedSpy.takeFirst();
+    QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), index);
+    QCOMPARE(qvariant_cast<QModelIndex>(args.at(1)), index);
+    args = itemChangedSpy.takeFirst();
+    QCOMPARE(qvariant_cast<QStandardItem*>(args.at(0)), &item);
+
+    item.setData(QLatin1String("foo"), Qt::DisplayRole);
+    QCOMPARE(dataChangedSpy.count(), 1);
+    QCOMPARE(itemChangedSpy.count(), 1);
+    args = dataChangedSpy.takeFirst();
+    QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), index);
+    QCOMPARE(qvariant_cast<QModelIndex>(args.at(1)), index);
+    args = itemChangedSpy.takeFirst();
+    QCOMPARE(qvariant_cast<QStandardItem*>(args.at(0)), &item);
+
+    item.setData(item.data(Qt::DisplayRole), Qt::DisplayRole);
+    QCOMPARE(dataChangedSpy.count(), 0);
+    QCOMPARE(itemChangedSpy.count(), 0);
+
+    item.setFlags(Qt::ItemIsEnabled);
+    QCOMPARE(dataChangedSpy.count(), 1);
+    QCOMPARE(itemChangedSpy.count(), 1);
+    args = dataChangedSpy.takeFirst();
+    QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), index);
+    QCOMPARE(qvariant_cast<QModelIndex>(args.at(1)), index);
+    args = itemChangedSpy.takeFirst();
+    QCOMPARE(qvariant_cast<QStandardItem*>(args.at(0)), &item);
+
+    item.setFlags(item.flags());
+    QCOMPARE(dataChangedSpy.count(), 0);
+    QCOMPARE(itemChangedSpy.count(), 0);
+}
+
+void tst_QStandardItemModel::takeHeaderItem()
+{
+    QStandardItemModel model;
+    // set header items
+    QStandardItem *hheader = new QStandardItem();
+    model.setHorizontalHeaderItem(0, hheader);
+    QStandardItem *vheader = new QStandardItem();
+    model.setVerticalHeaderItem(0, vheader);
+    // take header items
+    QCOMPARE(model.takeHorizontalHeaderItem(0), hheader);
+    QCOMPARE(model.takeVerticalHeaderItem(0), vheader);
+    QCOMPARE(hheader->model(), static_cast<QStandardItemModel*>(0));
+    QCOMPARE(vheader->model(), static_cast<QStandardItemModel*>(0));
+    QCOMPARE(model.takeHorizontalHeaderItem(0), static_cast<QStandardItem*>(0));
+    QCOMPARE(model.takeVerticalHeaderItem(0), static_cast<QStandardItem*>(0));
+    delete hheader;
+    delete vheader;
+}
+
+void tst_QStandardItemModel::useCase1()
+{
+    const int rows = 5;
+    const int columns = 8;
+    QStandardItemModel model(rows, columns);
+    for (int i = 0; i < model.rowCount(); ++i) {
+        for (int j = 0; j < model.columnCount(); ++j) {
+            QCOMPARE(model.item(i, j), static_cast<QStandardItem*>(0));
+
+            QStandardItem *item = new QStandardItem();
+            model.setItem(i, j, item);
+            QCOMPARE(item->row(), i);
+            QCOMPARE(item->column(), j);
+            QCOMPARE(item->model(), &model);
+
+            QModelIndex index = model.indexFromItem(item);
+            QCOMPARE(index, model.index(i, j, QModelIndex()));
+            QStandardItem *sameItem = model.itemFromIndex(index);
+            QCOMPARE(sameItem, item);
+        }
+    }
+}
+
+static void createChildren(QStandardItemModel *model, QStandardItem *parent, int level)
+{
+    if (level > 4)
+        return;
+    for (int i = 0; i < 4; ++i) {
+        QCOMPARE(parent->rowCount(), i);
+        parent->appendRow(QList<QStandardItem*>());
+        for (int j = 0; j < parent->columnCount(); ++j) {
+            QStandardItem *item = new QStandardItem();
+            parent->setChild(i, j, item);
+            QCOMPARE(item->row(), i);
+            QCOMPARE(item->column(), j);
+
+            QModelIndex parentIndex = model->indexFromItem(parent);
+            QModelIndex index = model->indexFromItem(item);
+            QCOMPARE(index, model->index(i, j, parentIndex));
+            QStandardItem *theItem = model->itemFromIndex(index);
+            QCOMPARE(theItem, item);
+            QStandardItem *theParent = model->itemFromIndex(parentIndex);
+            QCOMPARE(theParent, (level == 0) ? (QStandardItem*)0 : parent);
+        }
+
+        {
+            QStandardItem *item = parent->child(i);
+            item->setColumnCount(parent->columnCount());
+            createChildren(model, item, level + 1);
+        }
+    }
+}
+
+void tst_QStandardItemModel::useCase2()
+{
+    QStandardItemModel model;
+    model.setColumnCount(2);
+    createChildren(&model, model.invisibleRootItem(), 0);
+}
+
+void tst_QStandardItemModel::useCase3()
+{
+    // create the tree structure first
+    QStandardItem *childItem = 0;
+    for (int i = 0; i < 100; ++i) {
+        QStandardItem *item = new QStandardItem(QString("item %0").arg(i));
+        if (childItem)
+            item->appendRow(childItem);
+        childItem = item;
+    }
+
+    // add to model as last step
+    QStandardItemModel model;
+    model.appendRow(childItem);
+
+    // make sure each item has the correct model and parent
+    QStandardItem *parentItem = 0;
+    while (childItem) {
+        QCOMPARE(childItem->model(), &model);
+        QCOMPARE(childItem->parent(), parentItem);
+        parentItem = childItem;
+        childItem = childItem->child(0);
+    }
+
+    // take the item, make sure model is set to 0, but that parents are the same
+    childItem = model.takeItem(0);
+    {
+        parentItem = 0;
+        QStandardItem *item = childItem;
+        while (item) {
+            QCOMPARE(item->model(), static_cast<QStandardItemModel*>(0));
+            QCOMPARE(item->parent(), parentItem);
+            parentItem = item;
+            item = item->child(0);
+        }
+    }
+    delete childItem;
+}
+
+void tst_QStandardItemModel::rootItemFlags()
+{
+    QStandardItemModel model(6, 4);
+    QCOMPARE(model.invisibleRootItem()->flags() , model.flags(QModelIndex()));
+    QCOMPARE(model.invisibleRootItem()->flags() , Qt::ItemIsDropEnabled);
+
+    Qt::ItemFlags f = Qt::ItemIsDropEnabled | Qt::ItemIsEnabled;
+    model.invisibleRootItem()->setFlags(f);
+    QCOMPARE(model.invisibleRootItem()->flags() , f);
+    QCOMPARE(model.invisibleRootItem()->flags() , model.flags(QModelIndex()));
+
+#ifndef QT_NO_DRAGANDDROP
+    model.invisibleRootItem()->setDropEnabled(false);
+#endif
+    QCOMPARE(model.invisibleRootItem()->flags() , Qt::ItemIsEnabled);
+    QCOMPARE(model.invisibleRootItem()->flags() , model.flags(QModelIndex()));
+}
+
+bool tst_QStandardItemModel::compareModels(QStandardItemModel *model1, QStandardItemModel *model2)
+{
+    return compareItems(model1->invisibleRootItem(), model2->invisibleRootItem());
+}
+
+bool tst_QStandardItemModel::compareItems(QStandardItem *item1, QStandardItem *item2)
+{
+    if (!item1 && !item2)
+        return true;
+    if (!item1 || !item2)
+        return false;
+    if (item1->text() != item2->text()){
+        qDebug() << item1->text() << item2->text();
+        return false;
+    }
+    if (item1->rowCount() != item2->rowCount()) {
+  //      qDebug() << "RowCount" << item1->text() << item1->rowCount() << item2->rowCount();
+        return false;
+    }
+    if (item1->columnCount() != item2->columnCount()) {
+  //     qDebug() << "ColumnCount" << item1->text() << item1->columnCount() << item2->columnCount();
+        return false;
+    }
+    for (int row = 0; row < item1->columnCount(); row++)
+        for (int col = 0; col < item1->columnCount(); col++) {
+
+        if (!compareItems(item1->child(row, col), item2->child(row, col)))
+            return false;
+    }
+    return true;
+}
+
+static QStandardItem *itemFromText(QStandardItem *parent, const QString &text)
+{
+    QStandardItem *item = 0;
+    for(int i = 0; i < parent->columnCount(); i++)
+        for(int j = 0; j < parent->rowCount(); j++) {
+
+        QStandardItem *child = parent->child(j, i);
+
+        if(!child)
+            continue;
+
+        if (child->text() == text) {
+            if (item) {
+                return 0;
+            }
+            item = child;
+        }
+
+        QStandardItem *candidate = itemFromText(child, text);
+        if(candidate) {
+            if (item) {
+                return 0;
+            }
+            item = candidate;
+        }
+    }
+    return item;
+}
+
+#ifdef QT_BUILD_INTERNAL
+static QModelIndex indexFromText(QStandardItemModel *model, const QString &text)
+{
+    QStandardItem *item = itemFromText(model->invisibleRootItem(), text);
+    /*QVERIFY(item);*/
+    return model->indexFromItem(item);
+}
+
+
+struct FriendlyTreeView : public QTreeView
+{
+    friend class tst_QStandardItemModel;
+	Q_DECLARE_PRIVATE(QTreeView)
+};
+#endif
+
+void tst_QStandardItemModel::treeDragAndDrop()
+{
+#ifdef QT_BUILD_INTERNAL
+    const int nRow = 5;
+    const int nCol = 3;
+
+    QStandardItemModel model;
+    QStandardItemModel checkModel;
+
+    for (int i = 0; i < nRow; ++i) {
+        QList<QStandardItem *> colItems1;
+        for (int c = 0 ; c < nCol; c ++)
+            colItems1 << new QStandardItem(QString("item %1 - %0").arg(c).arg(i));
+        model.appendRow(colItems1);
+
+        for (int j = 0; j < nRow; ++j) {
+            QList<QStandardItem *> colItems2;
+            for (int c = 0 ; c < nCol; c ++)
+                colItems2 << new QStandardItem(QString("item %1/%2 - %0").arg(c).arg(i).arg(j));
+            colItems1.at(0)->appendRow(colItems2);
+
+            for (int k = 0; k < nRow; ++k) {
+                QList<QStandardItem *> colItems3;
+                for (int c = 0 ; c < nCol; c ++)
+                    colItems3 << new QStandardItem(QString("item %1/%2/%3 - %0").arg(c).arg(i).arg(j).arg(k));
+                colItems2.at(0)->appendRow(colItems3);
+            }
+        }
+    }
+
+    for (int i = 0; i < nRow; ++i) {
+        QList<QStandardItem *> colItems1;
+        for (int c = 0 ; c < nCol; c ++)
+            colItems1 << new QStandardItem(QString("item %1 - %0").arg(c).arg(i));
+        checkModel.appendRow(colItems1);
+
+        for (int j = 0; j < nRow; ++j) {
+            QList<QStandardItem *> colItems2;
+            for (int c = 0 ; c < nCol; c ++)
+                colItems2 << new QStandardItem(QString("item %1/%2 - %0").arg(c).arg(i).arg(j));
+            colItems1.at(0)->appendRow(colItems2);
+
+            for (int k = 0; k < nRow; ++k) {
+                QList<QStandardItem *> colItems3;
+                for (int c = 0 ; c < nCol; c ++)
+                    colItems3 << new QStandardItem(QString("item %1/%2/%3 - %0").arg(c).arg(i).arg(j).arg(k));
+                colItems2.at(0)->appendRow(colItems3);
+            }
+        }
+    }
+
+    QVERIFY(compareModels(&model, &checkModel));
+
+    FriendlyTreeView  view;
+    view.setModel(&model);
+    view.expandAll();
+    view.show();
+#ifndef QT_NO_DRAGANDDROP
+    view.setDragDropMode(QAbstractItemView::InternalMove);
+#endif
+    view.setSelectionMode(QAbstractItemView::ExtendedSelection);
+
+    QItemSelectionModel *selection = view.selectionModel();
+
+    //
+    // step1  drag  "item 1" and "item 2"   into "item 4"
+    //
+    {
+        selection->clear();
+        selection->select(QItemSelection(indexFromText(&model, QString("item 1 - 0")),
+                                        indexFromText(&model, QString("item 1 - %0").arg(nCol-1))), QItemSelectionModel::Select);
+
+        selection->select(QItemSelection(indexFromText(&model, QString("item 2 - 0")),
+                                        indexFromText(&model, QString("item 2 - %0").arg(nCol-1))), QItemSelectionModel::Select);
+
+        //code based from QAbstractItemView::startDrag and QAbstractItemView::dropEvent
+        QModelIndexList indexes = view.selectedIndexes();
+        QMimeData *data = model.mimeData(indexes);
+        if(model.dropMimeData(data, Qt::MoveAction, 0, 0, indexFromText(&model, "item 4 - 0")))
+            view.d_func()->clearOrRemove();
+        delete data;
+
+        QVERIFY(!compareModels(&model, &checkModel)); //the model must be different at this point
+        QStandardItem *item4 = itemFromText(checkModel.invisibleRootItem(), "item 4 - 0");
+        item4->insertRow(0, checkModel.takeRow(1));
+        item4->insertRow(1, checkModel.takeRow(1));
+        QVERIFY(compareModels(&model, &checkModel));
+    }
+
+    //
+    // step2  drag  "item 3" and "item 3/0"   into "item 4"
+    //
+    {
+        selection->clear();
+        selection->select(QItemSelection(indexFromText(&model, QString("item 3 - 0")),
+                                          indexFromText(&model, QString("item 3 - %0").arg(nCol-1))), QItemSelectionModel::Select);
+
+        selection->select(QItemSelection(indexFromText(&model, QString("item 3/0 - 0")),
+                                        indexFromText(&model, QString("item 3/0 - %0").arg(nCol-1))), QItemSelectionModel::Select);
+
+        //code based from QAbstractItemView::startDrag and QAbstractItemView::dropEvent
+        QModelIndexList indexes = view.selectedIndexes();
+        QMimeData *data = model.mimeData(indexes);
+        if(model.dropMimeData(data, Qt::MoveAction, 0, 0, indexFromText(&model, "item 4 - 0")))
+        view.d_func()->clearOrRemove();
+        delete data;
+
+        QVERIFY(!compareModels(&model, &checkModel)); //the model must be different at this point
+        QStandardItem *item4 = itemFromText(checkModel.invisibleRootItem(), "item 4 - 0");
+        item4->insertRow(0, checkModel.takeRow(1));
+
+        QVERIFY(compareModels(&model, &checkModel));
+    }
+
+    //
+    // step2  drag  "item 3" and "item 3/0/2"   into "item 0/2"
+    // ( remember "item 3" is now the first child of "item 4")
+    //
+    {
+        selection->clear();
+        selection->select(QItemSelection(indexFromText(&model, QString("item 3 - 0")),
+                                         indexFromText(&model, QString("item 3 - %0").arg(nCol-1))), QItemSelectionModel::Select);
+
+        selection->select(QItemSelection(indexFromText(&model, QString("item 3/0/2 - 0")),
+                                        indexFromText(&model, QString("item 3/0/2 - %0").arg(nCol-1))), QItemSelectionModel::Select);
+
+        //code based from QAbstractItemView::startDrag and QAbstractItemView::dropEvent
+        QModelIndexList indexes = view.selectedIndexes();
+        QMimeData *data = model.mimeData(indexes);
+        if(model.dropMimeData(data, Qt::MoveAction, 0, 0, indexFromText(&model, "item 0/2 - 0")))
+        view.d_func()->clearOrRemove();
+        delete data;
+
+        QVERIFY(!compareModels(&model, &checkModel)); //the model must be different at this point
+        QStandardItem *item02 = itemFromText(checkModel.invisibleRootItem(), "item 0/2 - 0");
+        QStandardItem *item4 = itemFromText(checkModel.invisibleRootItem(), "item 4 - 0");
+        item02->insertRow(0, item4->takeRow(0));
+
+        QVERIFY(compareModels(&model, &checkModel));
+    }
+#endif
+}
+
+void tst_QStandardItemModel::removeRowsAndColumns()
+{
+#define VERIFY_MODEL \
+    for (int c = 0; c < col_list.count(); c++) \
+        for (int r = 0; r < row_list.count(); r++) \
+            QCOMPARE(model.item(r,c)->text() , row_list[r] + "x" + col_list[c]);
+
+    QVector<QString> row_list = QString("1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20").split(',').toVector();
+    QVector<QString> col_list = row_list;
+    QStandardItemModel model;
+    for (int c = 0; c < col_list.count(); c++)
+        for (int r = 0; r < row_list.count(); r++)
+            model.setItem(r, c, new QStandardItem(row_list[r] + "x" + col_list[c]));
+    VERIFY_MODEL
+
+    row_list.remove(3);
+    model.removeRow(3);
+    VERIFY_MODEL
+
+    col_list.remove(5);
+    model.removeColumn(5);
+    VERIFY_MODEL
+
+    row_list.remove(2, 5);
+    model.removeRows(2, 5);
+    VERIFY_MODEL
+
+    col_list.remove(1, 6);
+    model.removeColumns(1, 6);
+    VERIFY_MODEL
+
+    QList<QStandardItem *> row_taken = model.takeRow(6);
+    QCOMPARE(row_taken.count(), col_list.count());
+    for (int c = 0; c < col_list.count(); c++)
+        QCOMPARE(row_taken[c]->text() , row_list[6] + "x" + col_list[c]);
+    row_list.remove(6);
+    VERIFY_MODEL
+
+    QList<QStandardItem *> col_taken = model.takeColumn(10);
+    QCOMPARE(col_taken.count(), row_list.count());
+    for (int r = 0; r < row_list.count(); r++)
+        QCOMPARE(col_taken[r]->text() , row_list[r] + "x" + col_list[10]);
+    col_list.remove(10);
+    VERIFY_MODEL
+}
+
+void tst_QStandardItemModel::itemRoleNames()
+{
+    QVector<QString> row_list = QString("1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20").split(',').toVector();
+    QVector<QString> col_list = row_list;
+    QStandardItemModel model;
+    for (int c = 0; c < col_list.count(); c++)
+        for (int r = 0; r < row_list.count(); r++)
+            model.setItem(r, c, new QStandardItem(row_list[r] + "x" + col_list[c]));
+    VERIFY_MODEL
+
+    QHash<int, QByteArray> newRoleNames;
+    newRoleNames.insert(Qt::DisplayRole, "Name");
+    newRoleNames.insert(Qt::DecorationRole, "Avatar");
+    model.setItemRoleNames(newRoleNames);
+    QCOMPARE(model.roleNames(), newRoleNames);
+    VERIFY_MODEL
+}
+
+
+QTEST_MAIN(tst_QStandardItemModel)
+#include "tst_qstandarditemmodel.moc"
diff --git a/tests/auto/widgets/itemviews/itemviews.pro b/tests/auto/widgets/itemviews/itemviews.pro
index e13a5a8..2bd8ec4 100644
--- a/tests/auto/widgets/itemviews/itemviews.pro
+++ b/tests/auto/widgets/itemviews/itemviews.pro
@@ -11,8 +11,6 @@ SUBDIRS=\
    qitemview \
    qlistview \
    qlistwidget \
-   qstandarditem \
-   qstandarditemmodel \
    qtableview \
    qtablewidget \
    qtreeview \
diff --git a/tests/auto/widgets/itemviews/qstandarditem/.gitignore b/tests/auto/widgets/itemviews/qstandarditem/.gitignore
deleted file mode 100644
index 6da85cc..0000000
--- a/tests/auto/widgets/itemviews/qstandarditem/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qstandarditem
diff --git a/tests/auto/widgets/itemviews/qstandarditem/qstandarditem.pro b/tests/auto/widgets/itemviews/qstandarditem/qstandarditem.pro
deleted file mode 100644
index 1fef72e..0000000
--- a/tests/auto/widgets/itemviews/qstandarditem/qstandarditem.pro
+++ /dev/null
@@ -1,7 +0,0 @@
-CONFIG += testcase
-CONFIG += parallel_test
-TARGET = tst_qstandarditem
-QT += widgets testlib
-SOURCES  += tst_qstandarditem.cpp
-
-
diff --git a/tests/auto/widgets/itemviews/qstandarditem/tst_qstandarditem.cpp b/tests/auto/widgets/itemviews/qstandarditem/tst_qstandarditem.cpp
deleted file mode 100644
index 8ababf0..0000000
--- a/tests/auto/widgets/itemviews/qstandarditem/tst_qstandarditem.cpp
+++ /dev/null
@@ -1,1107 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include <QtTest/QtTest>
-
-#include <qstandarditemmodel.h>
-
-class tst_QStandardItem : public QObject
-{
-    Q_OBJECT
-
-public:
-    tst_QStandardItem();
-    virtual ~tst_QStandardItem();
-
-public slots:
-    void init();
-    void cleanup();
-
-private slots:
-    void ctor();
-    void textCtor();
-    void iconTextCtor();
-    void rowsColumnsCtor();
-    void getSetData();
-    void getSetFlags();
-    void getSetRowAndColumnCount();
-    void getSetChild_data();
-    void getSetChild();
-    void parent();
-    void insertColumn_data();
-    void insertColumn();
-    void insertColumns_data();
-    void insertColumns();
-    void insertRow_data();
-    void insertRow();
-    void insertRows_data();
-    void insertRows();
-    void appendColumn_data();
-    void appendColumn();
-    void appendRow_data();
-    void appendRow();
-    void takeChild();
-    void takeColumn_data();
-    void takeColumn();
-    void takeRow_data();
-    void takeRow();
-    void streamItem();
-    void deleteItem();
-    void clone();
-    void sortChildren();
-    void subclassing();
-};
-
-tst_QStandardItem::tst_QStandardItem()
-{
-}
-
-tst_QStandardItem::~tst_QStandardItem()
-{
-}
-
-void tst_QStandardItem::init()
-{
-}
-
-void tst_QStandardItem::cleanup()
-{
-}
-
-void tst_QStandardItem::ctor()
-{
-    QStandardItem item;
-    QVERIFY(!item.hasChildren());
-}
-
-void tst_QStandardItem::textCtor()
-{
-    QLatin1String text("text");
-    QStandardItem item(text);
-    QCOMPARE(item.text(), text);
-    QVERIFY(!item.hasChildren());
-}
-
-void tst_QStandardItem::iconTextCtor()
-{
-    QPixmap pixmap(32, 32);
-    pixmap.fill(Qt::red);
-    QIcon icon(pixmap);
-    QLatin1String text("text");
-    QStandardItem item(icon, text);
-    QCOMPARE(item.icon(), icon);
-    QCOMPARE(item.text(), text);
-    QVERIFY(!item.hasChildren());
-}
-
-void tst_QStandardItem::rowsColumnsCtor()
-{
-    const int rows = 5;
-    const int columns = 12;
-    QStandardItem item(rows, columns);
-    QCOMPARE(item.rowCount(), rows);
-    QCOMPARE(item.columnCount(), columns);
-}
-
-void tst_QStandardItem::getSetData()
-{
-    QStandardItem item;
-    for (int x = 0; x < 2; ++x) {
-        for (int i = 1; i <= 2; ++i) {
-            QString text = QString("text %0").arg(i);
-            item.setText(text);
-            QCOMPARE(item.text(), text);
-            
-            QPixmap pixmap(32, 32);
-            pixmap.fill((i == 1) ? Qt::red : Qt::green);
-            QIcon icon(pixmap);
-            item.setIcon(icon);
-            QCOMPARE(item.icon(), icon);
-            
-            QString toolTip = QString("toolTip %0").arg(i);
-            item.setToolTip(toolTip);
-            QCOMPARE(item.toolTip(), toolTip);
-            
-            QString statusTip = QString("statusTip %0").arg(i);
-            item.setStatusTip(statusTip);
-            QCOMPARE(item.statusTip(), statusTip);
-        
-            QString whatsThis = QString("whatsThis %0").arg(i);
-            item.setWhatsThis(whatsThis);
-            QCOMPARE(item.whatsThis(), whatsThis);
-            
-            QSize sizeHint(64*i, 48*i);
-            item.setSizeHint(sizeHint);
-            QCOMPARE(item.sizeHint(), sizeHint);
-            
-            QFont font;
-            item.setFont(font);
-            QCOMPARE(item.font(), font);
-        
-            Qt::Alignment textAlignment((i == 1)
-                                        ? Qt::AlignLeft|Qt::AlignVCenter
-                                        : Qt::AlignRight);
-            item.setTextAlignment(textAlignment);
-            QCOMPARE(item.textAlignment(), textAlignment);
-            
-            QColor backgroundColor((i == 1) ? Qt::blue : Qt::yellow);
-            item.setBackground(backgroundColor);
-            QCOMPARE(item.background().color(), backgroundColor);
-            
-            QColor textColor((i == i) ? Qt::green : Qt::cyan);
-            item.setForeground(textColor);
-            QCOMPARE(item.foreground().color(), textColor);
-            
-            Qt::CheckState checkState((i == 1) ? Qt::PartiallyChecked : Qt::Checked);
-            item.setCheckState(checkState);
-            QCOMPARE(item.checkState(), checkState);
-            
-            QString accessibleText = QString("accessibleText %0").arg(i);
-            item.setAccessibleText(accessibleText);
-            QCOMPARE(item.accessibleText(), accessibleText);
-            
-            QString accessibleDescription = QString("accessibleDescription %0").arg(i);
-            item.setAccessibleDescription(accessibleDescription);
-            QCOMPARE(item.accessibleDescription(), accessibleDescription);
-            
-            QCOMPARE(item.text(), text);
-            QCOMPARE(item.icon(), icon);
-            QCOMPARE(item.toolTip(), toolTip);
-            QCOMPARE(item.statusTip(), statusTip);
-            QCOMPARE(item.whatsThis(), whatsThis);
-            QCOMPARE(item.sizeHint(), sizeHint);
-            QCOMPARE(item.font(), font);
-            QCOMPARE(item.textAlignment(), textAlignment);
-            QCOMPARE(item.background().color(), backgroundColor);
-            QCOMPARE(item.foreground().color(), textColor);
-            QCOMPARE(item.checkState(), checkState);
-            QCOMPARE(item.accessibleText(), accessibleText);
-            QCOMPARE(item.accessibleDescription(), accessibleDescription);
-            
-            QCOMPARE(qvariant_cast<QString>(item.data(Qt::DisplayRole)), text);
-            QCOMPARE(qvariant_cast<QIcon>(item.data(Qt::DecorationRole)), icon);
-            QCOMPARE(qvariant_cast<QString>(item.data(Qt::ToolTipRole)), toolTip);
-            QCOMPARE(qvariant_cast<QString>(item.data(Qt::StatusTipRole)), statusTip);
-            QCOMPARE(qvariant_cast<QString>(item.data(Qt::WhatsThisRole)), whatsThis);
-            QCOMPARE(qvariant_cast<QSize>(item.data(Qt::SizeHintRole)), sizeHint);
-            QCOMPARE(qvariant_cast<QFont>(item.data(Qt::FontRole)), font);
-            QCOMPARE(qvariant_cast<int>(item.data(Qt::TextAlignmentRole)), int(textAlignment));
-            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::BackgroundColorRole)), QBrush(backgroundColor));
-            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::BackgroundRole)), QBrush(backgroundColor));
-            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::TextColorRole)), QBrush(textColor));
-            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::ForegroundRole)), QBrush(textColor));
-            QCOMPARE(qvariant_cast<int>(item.data(Qt::CheckStateRole)), int(checkState));
-            QCOMPARE(qvariant_cast<QString>(item.data(Qt::AccessibleTextRole)), accessibleText);
-            QCOMPARE(qvariant_cast<QString>(item.data(Qt::AccessibleDescriptionRole)), accessibleDescription);
-
-            item.setBackground(pixmap);
-            QCOMPARE(item.background().texture(), pixmap);
-            QCOMPARE(qvariant_cast<QBrush>(item.data(Qt::BackgroundRole)).texture(), pixmap);
-        }
-        item.setData(QVariant(), Qt::DisplayRole);
-        item.setData(QVariant(), Qt::DecorationRole);
-        item.setData(QVariant(), Qt::ToolTipRole);
-        item.setData(QVariant(), Qt::StatusTipRole);
-        item.setData(QVariant(), Qt::WhatsThisRole);
-        item.setData(QVariant(), Qt::SizeHintRole);
-        item.setData(QVariant(), Qt::FontRole);
-        item.setData(QVariant(), Qt::TextAlignmentRole);
-        item.setData(QVariant(), Qt::BackgroundRole);
-        item.setData(QVariant(), Qt::ForegroundRole);
-        item.setData(QVariant(), Qt::CheckStateRole);
-        item.setData(QVariant(), Qt::AccessibleTextRole);
-        item.setData(QVariant(), Qt::AccessibleDescriptionRole);
-        
-        QCOMPARE(item.data(Qt::DisplayRole), QVariant());
-        QCOMPARE(item.data(Qt::DecorationRole), QVariant());
-        QCOMPARE(item.data(Qt::ToolTipRole), QVariant());
-        QCOMPARE(item.data(Qt::StatusTipRole), QVariant());
-        QCOMPARE(item.data(Qt::WhatsThisRole), QVariant());
-        QCOMPARE(item.data(Qt::SizeHintRole), QVariant());
-        QCOMPARE(item.data(Qt::FontRole), QVariant());
-        QCOMPARE(item.data(Qt::TextAlignmentRole), QVariant());
-        QCOMPARE(item.data(Qt::BackgroundColorRole), QVariant());
-        QCOMPARE(item.data(Qt::BackgroundRole), QVariant());
-        QCOMPARE(item.data(Qt::TextColorRole), QVariant());
-        QCOMPARE(item.data(Qt::ForegroundRole), QVariant());
-        QCOMPARE(item.data(Qt::CheckStateRole), QVariant());
-        QCOMPARE(item.data(Qt::AccessibleTextRole), QVariant());
-        QCOMPARE(item.data(Qt::AccessibleDescriptionRole), QVariant());
-    }
-}
-
-void tst_QStandardItem::getSetFlags()
-{
-    QStandardItem item;
-    item.setEnabled(true);
-    QVERIFY(item.isEnabled());
-    QVERIFY(item.flags() & Qt::ItemIsEnabled);
-    item.setEditable(true);
-    QVERIFY(item.isEditable());
-    QVERIFY(item.flags() & Qt::ItemIsEditable);
-    item.setSelectable(true);
-    QVERIFY(item.isSelectable());
-    QVERIFY(item.flags() & Qt::ItemIsSelectable);
-    item.setCheckable(true);
-    QVERIFY(item.isCheckable());
-    QCOMPARE(item.checkState(), Qt::Unchecked);
-    QVERIFY(item.flags() & Qt::ItemIsUserCheckable);
-    item.setTristate(true);
-    QVERIFY(item.isTristate());
-    QVERIFY(item.flags() & Qt::ItemIsTristate);
-#ifndef QT_NO_DRAGANDDROP
-    item.setDragEnabled(true);
-    QVERIFY(item.isDragEnabled());
-    QVERIFY(item.flags() & Qt::ItemIsDragEnabled);
-    item.setDropEnabled(true);
-    QVERIFY(item.isDropEnabled());
-    QVERIFY(item.flags() & Qt::ItemIsDropEnabled);
-#endif
-    
-    QVERIFY(item.isEnabled());
-    item.setEnabled(false);
-    QVERIFY(!item.isEnabled());
-    QVERIFY(!(item.flags() & Qt::ItemIsEnabled));
-    QVERIFY(item.isEditable());
-    item.setEditable(false);
-    QVERIFY(!item.isEditable());
-    QVERIFY(!(item.flags() & Qt::ItemIsEditable));
-    QVERIFY(item.isSelectable());
-    item.setSelectable(false);
-    QVERIFY(!item.isSelectable());
-    QVERIFY(!(item.flags() & Qt::ItemIsSelectable));
-    QVERIFY(item.isCheckable());
-    item.setCheckable(false);
-    QVERIFY(!item.isCheckable());
-    QVERIFY(!(item.flags() & Qt::ItemIsUserCheckable));
-    QVERIFY(item.isTristate());
-    item.setTristate(false);
-    QVERIFY(!item.isTristate());
-    QVERIFY(!(item.flags() & Qt::ItemIsTristate));
-#ifndef QT_NO_DRAGANDDROP
-    QVERIFY(item.isDragEnabled());
-    item.setDragEnabled(false);
-    QVERIFY(!item.isDragEnabled());
-    QVERIFY(!(item.flags() & Qt::ItemIsDragEnabled));
-    QVERIFY(item.isDropEnabled());
-    item.setDropEnabled(false);
-    QVERIFY(!item.isDropEnabled());
-    QVERIFY(!(item.flags() & Qt::ItemIsDropEnabled));
-#endif
-
-    item.setCheckable(false);
-    item.setCheckState(Qt::Checked);
-    item.setCheckable(true);
-    QCOMPARE(item.checkState(), Qt::Checked);
-}    
-
-void tst_QStandardItem::getSetRowAndColumnCount()
-{
-    QStandardItem item;
-
-    item.setRowCount(-1);
-    QCOMPARE(item.rowCount(), 0);
-
-    item.setColumnCount(-1);
-    QCOMPARE(item.columnCount(), 0);
-
-    item.setRowCount(1);
-    QCOMPARE(item.rowCount(), 1);
-    QCOMPARE(item.columnCount(), 0);
-
-    item.setColumnCount(1);
-    QCOMPARE(item.columnCount(), 1);
-    QCOMPARE(item.rowCount(), 1);
-
-    item.setColumnCount(10);
-    QCOMPARE(item.columnCount(), 10);
-    QCOMPARE(item.rowCount(), 1);
-
-    item.setRowCount(20);
-    QCOMPARE(item.rowCount(), 20);
-    QCOMPARE(item.columnCount(), 10);
-
-    item.setRowCount(-1);
-    QCOMPARE(item.rowCount(), 20);
-
-    item.setColumnCount(-1);
-    QCOMPARE(item.columnCount(), 10);
-
-    item.setColumnCount(0);
-    QCOMPARE(item.columnCount(), 0);
-    QCOMPARE(item.rowCount(), 20);
-
-    item.setRowCount(0);
-    QCOMPARE(item.rowCount(), 0);
-}
-
-void tst_QStandardItem::getSetChild_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("row");
-    QTest::addColumn<int>("column");
-
-    QTest::newRow("0x0 children, child at (-1,-1)") << 0 << 0 << -1 << -1;
-    QTest::newRow("0x0 children, child at (0,0)") << 0 << 0 << 0 << 0;
-}
-
-void tst_QStandardItem::getSetChild()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, row);
-    QFETCH(int, column);
-
-    QStandardItem item(rows, columns);
-    bool shouldHaveChildren = (rows > 0) && (columns > 0);
-    QCOMPARE(item.hasChildren(), shouldHaveChildren);
-    QCOMPARE(item.child(row, column), static_cast<QStandardItem*>(0));
-
-    QStandardItem *child = new QStandardItem;
-    item.setChild(row, column, child);
-    if ((row >= 0) && (column >= 0)) {
-        QCOMPARE(item.rowCount(), qMax(rows, row + 1));
-        QCOMPARE(item.columnCount(), qMax(columns, column + 1));
-
-        QCOMPARE(item.child(row, column), child);
-        QCOMPARE(child->row(), row);
-        QCOMPARE(child->column(), column);
-
-        QStandardItem *anotherChild = new QStandardItem;
-        item.setChild(row, column, anotherChild);
-        QCOMPARE(item.child(row, column), anotherChild);
-        QCOMPARE(anotherChild->row(), row);
-        QCOMPARE(anotherChild->column(), column);
-        item.setChild(row, column, 0);
-    } else {
-        delete child;
-    }
-    QCOMPARE(item.child(row, column), static_cast<QStandardItem*>(0));
-}
-
-void tst_QStandardItem::parent()
-{
-    {
-        QStandardItem item;
-        QStandardItem *child = new QStandardItem;
-        QCOMPARE(child->parent(), static_cast<QStandardItem*>(0));
-        item.setChild(0, 0, child);
-        QCOMPARE(child->parent(), &item);
-        
-        QStandardItem *childOfChild = new QStandardItem;
-        child->setChild(0, 0, childOfChild);
-        QCOMPARE(childOfChild->parent(), child);
-    }
-
-    {
-        QStandardItemModel model;
-        QStandardItem *item = new QStandardItem;
-        model.appendRow(item);
-        // parent of a top-level item should be 0
-        QCOMPARE(item->parent(), static_cast<QStandardItem*>(0));
-    }
-}
-
-void tst_QStandardItem::insertColumn_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("column");
-    QTest::addColumn<int>("count");
-
-    QTest::newRow("insert 0 at -1 in 0x0") << 0 << 0 << -1 << 0;
-    QTest::newRow("insert 0 at 0 in 0x0") << 0 << 0 << 0 << 0;
-    QTest::newRow("insert 0 at 0 in 1x0") << 1 << 0 << 0 << 0;
-    QTest::newRow("insert 0 at 0 in 0x1") << 0 << 1 << 0 << 0;
-    QTest::newRow("insert 0 at 0 in 1x1") << 1 << 1 << 0 << 0;
-    QTest::newRow("insert 1 at -1 in 0x0") << 0 << 0 << -1 << 1;
-    QTest::newRow("insert 1 at 0 in 0x0") << 0 << 0 << 0 << 1;
-    QTest::newRow("insert 1 at 0 in 1x0") << 1 << 0 << 0 << 1;
-    QTest::newRow("insert 1 at 0 in 0x1") << 0 << 1 << 0 << 1;
-    QTest::newRow("insert 1 at 0 in 1x1") << 1 << 1 << 0 << 1;
-    QTest::newRow("insert 1 at 1 in 1x1") << 1 << 1 << 1 << 1;
-    QTest::newRow("insert 1 at 0 in 2x1") << 2 << 1 << 0 << 1;
-    QTest::newRow("insert 1 at 1 in 2x1") << 2 << 1 << 1 << 1;
-    QTest::newRow("insert 1 at 0 in 1x2") << 1 << 2 << 0 << 1;
-    QTest::newRow("insert 1 at 1 in 1x2") << 1 << 2 << 1 << 1;
-    QTest::newRow("insert 1 at 0 in 8x4") << 8 << 4 << 0 << 1;
-    QTest::newRow("insert 1 at 1 in 8x4") << 8 << 4 << 1 << 1;
-    QTest::newRow("insert 1 at 2 in 8x4") << 8 << 4 << 2 << 1;
-    QTest::newRow("insert 1 at 3 in 8x4") << 8 << 4 << 3 << 1;
-    QTest::newRow("insert 1 at 4 in 8x4") << 8 << 4 << 4 << 1;
-    QTest::newRow("insert 4 at 0 in 8x4") << 8 << 4 << 0 << 4;
-    QTest::newRow("insert 4 at 4 in 8x4") << 8 << 4 << 4 << 4;
-    QTest::newRow("insert 6 at 0 in 8x4") << 8 << 4 << 0 << 6;
-    QTest::newRow("insert 6 at 4 in 8x4") << 8 << 4 << 4 << 6;
-}
-
-void tst_QStandardItem::insertColumn()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, column);
-    QFETCH(int, count);
-
-    QStandardItem item(rows, columns);
-
-    // make items for a new column
-    QList<QStandardItem*> columnItems;
-    for (int i = 0; i < count; ++i)
-        columnItems.append(new QStandardItem);
-
-    item.insertColumn(column, columnItems);
-
-    if (column >= 0) {
-        QCOMPARE(item.columnCount(), columns + 1);
-        QCOMPARE(item.rowCount(), qMax(rows, count));
-        // check to make sure items were inserted in correct place
-        for (int i = 0; i < count; ++i)
-            QCOMPARE(item.child(i, column), columnItems.at(i));
-        for (int i = count; i < item.rowCount(); ++i)
-            QCOMPARE(item.child(i, column), static_cast<QStandardItem*>(0));
-    } else {
-        QCOMPARE(item.columnCount(), columns);
-        QCOMPARE(item.rowCount(), rows);
-        qDeleteAll(columnItems);
-    }
-}
-
-void tst_QStandardItem::insertColumns_data()
-{
-}
-
-void tst_QStandardItem::insertColumns()
-{
-}
-
-void tst_QStandardItem::insertRow_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("row");
-    QTest::addColumn<int>("count");
-
-    QTest::newRow("insert 0 at -1 in 0x0") << 0 << 0 << -1 << 0;
-    QTest::newRow("insert 0 at 0 in 0x0") << 0 << 0 << 0 << 0;
-    QTest::newRow("insert 0 at 0 in 1x0") << 1 << 0 << 0 << 0;
-    QTest::newRow("insert 0 at 0 in 0x1") << 0 << 1 << 0 << 0;
-    QTest::newRow("insert 0 at 0 in 1x1") << 1 << 1 << 0 << 0;
-    QTest::newRow("insert 1 at -1 in 0x0") << 0 << 0 << -1 << 1;
-    QTest::newRow("insert 1 at 0 in 0x0") << 0 << 0 << 0 << 1;
-    QTest::newRow("insert 1 at 0 in 1x0") << 1 << 0 << 0 << 1;
-    QTest::newRow("insert 1 at 0 in 0x1") << 0 << 1 << 0 << 1;
-    QTest::newRow("insert 1 at 0 in 1x1") << 1 << 1 << 0 << 1;
-    QTest::newRow("insert 1 at 1 in 1x1") << 1 << 1 << 1 << 1;
-    QTest::newRow("insert 1 at 0 in 2x1") << 2 << 1 << 0 << 1;
-    QTest::newRow("insert 1 at 1 in 2x1") << 2 << 1 << 1 << 1;
-    QTest::newRow("insert 1 at 0 in 1x2") << 1 << 2 << 0 << 1;
-    QTest::newRow("insert 1 at 1 in 1x2") << 1 << 2 << 1 << 1;
-    QTest::newRow("insert 1 at 0 in 4x8") << 4 << 8 << 0 << 1;
-    QTest::newRow("insert 1 at 1 in 4x8") << 4 << 8 << 1 << 1;
-    QTest::newRow("insert 1 at 2 in 4x8") << 4 << 8 << 2 << 1;
-    QTest::newRow("insert 1 at 3 in 4x8") << 4 << 8 << 3 << 1;
-    QTest::newRow("insert 1 at 4 in 4x8") << 4 << 8 << 4 << 1;
-    QTest::newRow("insert 4 at 0 in 4x8") << 4 << 8 << 0 << 4;
-    QTest::newRow("insert 4 at 4 in 4x8") << 4 << 8 << 4 << 4;
-    QTest::newRow("insert 6 at 0 in 4x8") << 4 << 8 << 0 << 6;
-    QTest::newRow("insert 6 at 4 in 4x8") << 4 << 8 << 4 << 6;
-}
-
-void tst_QStandardItem::insertRow()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, row);
-    QFETCH(int, count);
-
-    QStandardItem item(rows, columns);
-
-    // make items for a new column
-    QList<QStandardItem*> rowItems;
-    for (int i = 0; i < count; ++i)
-        rowItems.append(new QStandardItem);
-
-    item.insertRow(row, rowItems);
-
-    if (row >= 0) {
-        QCOMPARE(item.columnCount(), qMax(columns, count));
-        QCOMPARE(item.rowCount(), rows + 1);
-        // check to make sure items were inserted in correct place
-        for (int i = 0; i < count; ++i)
-            QCOMPARE(item.child(row, i), rowItems.at(i));
-        for (int i = count; i < item.columnCount(); ++i)
-            QCOMPARE(item.child(row, i), static_cast<QStandardItem*>(0));
-    } else {
-        QCOMPARE(item.columnCount(), columns);
-        QCOMPARE(item.rowCount(), rows);
-        qDeleteAll(rowItems);
-    }
-}
-
-void tst_QStandardItem::insertRows_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("insertAt");
-    QTest::addColumn<int>("insertCount");
-
-    QTest::newRow("insert {0,1} at 0 in 0x0") << 0 << 0 << 0 << 2;
-}
-
-void tst_QStandardItem::insertRows()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, insertAt);
-    QFETCH(int, insertCount);
-
-    QStandardItem item(rows, columns);
-
-    QList<QStandardItem*> items;
-    for (int i = 0; i < insertCount; ++i) {
-        items.append(new QStandardItem());
-    }
-    item.insertRows(insertAt, items);
-
-    QCOMPARE(item.rowCount(), rows + insertCount);
-}
-
-void tst_QStandardItem::appendColumn_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("count");
-
-    QTest::newRow("append 0 to 0x0") << 0 << 0 << 0;
-    QTest::newRow("append 1 to 0x0") << 0 << 0 << 1;
-    QTest::newRow("append 1 to 1x0") << 1 << 0 << 1;
-    QTest::newRow("append 1 to 0x1") << 0 << 1 << 1;
-    QTest::newRow("append 1 to 1x1") << 1 << 1 << 1;
-    QTest::newRow("append 1 to 2x0") << 2 << 0 << 1;
-    QTest::newRow("append 1 to 0x2") << 0 << 2 << 1;
-    QTest::newRow("append 1 to 2x1") << 2 << 1 << 1;
-    QTest::newRow("append 1 to 1x2") << 1 << 2 << 1;
-    QTest::newRow("append 1 to 2x2") << 2 << 2 << 1;
-    QTest::newRow("append 2 to 0x0") << 0 << 0 << 2;
-    QTest::newRow("append 2 to 1x0") << 1 << 0 << 2;
-    QTest::newRow("append 2 to 0x1") << 0 << 1 << 2;
-    QTest::newRow("append 2 to 1x1") << 1 << 1 << 2;
-    QTest::newRow("append 2 to 2x0") << 2 << 0 << 2;
-    QTest::newRow("append 2 to 0x2") << 0 << 2 << 2;
-    QTest::newRow("append 2 to 2x1") << 2 << 1 << 2;
-    QTest::newRow("append 2 to 1x2") << 1 << 2 << 2;
-    QTest::newRow("append 2 to 2x2") << 2 << 2 << 2;
-    QTest::newRow("append 3 to 2x1") << 2 << 1 << 3;
-    QTest::newRow("append 3 to 1x2") << 1 << 2 << 3;
-    QTest::newRow("append 3 to 2x2") << 2 << 2 << 3;
-    QTest::newRow("append 3 to 4x2") << 4 << 2 << 3;
-    QTest::newRow("append 3 to 2x4") << 2 << 4 << 3;
-    QTest::newRow("append 3 to 4x4") << 4 << 4 << 3;
-    QTest::newRow("append 7 to 4x2") << 4 << 2 << 7;
-    QTest::newRow("append 7 to 2x4") << 2 << 4 << 7;
-    QTest::newRow("append 7 to 4x4") << 4 << 4 << 7;
-}
-
-void tst_QStandardItem::appendColumn()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, count);
-
-    QStandardItem item(rows, columns);
-    QList<QStandardItem*> originalChildren;
-    // initialize children
-    for (int i = 0; i < rows; ++i) {
-        for (int j = 0; j < columns; ++j) {
-            QStandardItem *child = new QStandardItem;
-            originalChildren.append(child);
-            item.setChild(i, j, child);
-        }
-    }
-
-    // make items for a new column
-    QList<QStandardItem*> columnItems;
-    for (int i = 0; i < count; ++i)
-        columnItems.append(new QStandardItem);
-
-    item.appendColumn(columnItems);
-
-    QCOMPARE(item.columnCount(), columns + 1);
-    QCOMPARE(item.rowCount(), qMax(rows, count));
-    // check to make sure items were inserted in correct place
-    for (int i = 0; i < count; ++i)
-        QCOMPARE(item.child(i, columns), columnItems.at(i));
-    for (int i = count; i < item.rowCount(); ++i)
-        QCOMPARE(item.child(i, columns), static_cast<QStandardItem*>(0));
-
-    // make sure original children remained unchanged
-    for (int i = 0; i < rows; ++i) {
-        for (int j = 0; j < columns; ++j)
-            QCOMPARE(item.child(i, j), originalChildren.at(i*columns+j));
-    }
-}
-
-void tst_QStandardItem::appendRow_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("count");
-
-    QTest::newRow("append 0 to 0x0") << 0 << 0 << 0;
-    QTest::newRow("append 1 to 0x0") << 0 << 0 << 1;
-    QTest::newRow("append 1 to 1x0") << 1 << 0 << 1;
-    QTest::newRow("append 1 to 0x1") << 0 << 1 << 1;
-    QTest::newRow("append 1 to 1x1") << 1 << 1 << 1;
-    QTest::newRow("append 1 to 2x0") << 2 << 0 << 1;
-    QTest::newRow("append 1 to 0x2") << 0 << 2 << 1;
-    QTest::newRow("append 1 to 2x1") << 2 << 1 << 1;
-    QTest::newRow("append 1 to 1x2") << 1 << 2 << 1;
-    QTest::newRow("append 1 to 2x2") << 2 << 2 << 1;
-    QTest::newRow("append 2 to 0x0") << 0 << 0 << 2;
-    QTest::newRow("append 2 to 1x0") << 1 << 0 << 2;
-    QTest::newRow("append 2 to 0x1") << 0 << 1 << 2;
-    QTest::newRow("append 2 to 1x1") << 1 << 1 << 2;
-    QTest::newRow("append 2 to 2x0") << 2 << 0 << 2;
-    QTest::newRow("append 2 to 0x2") << 0 << 2 << 2;
-    QTest::newRow("append 2 to 2x1") << 2 << 1 << 2;
-    QTest::newRow("append 2 to 1x2") << 1 << 2 << 2;
-    QTest::newRow("append 2 to 2x2") << 2 << 2 << 2;
-    QTest::newRow("append 3 to 2x1") << 2 << 1 << 3;
-    QTest::newRow("append 3 to 1x2") << 1 << 2 << 3;
-    QTest::newRow("append 3 to 2x2") << 2 << 2 << 3;
-    QTest::newRow("append 3 to 4x2") << 4 << 2 << 3;
-    QTest::newRow("append 3 to 2x4") << 2 << 4 << 3;
-    QTest::newRow("append 3 to 4x4") << 4 << 4 << 3;
-    QTest::newRow("append 7 to 4x2") << 4 << 2 << 7;
-    QTest::newRow("append 7 to 2x4") << 2 << 4 << 7;
-    QTest::newRow("append 7 to 4x4") << 4 << 4 << 7;
-}
-
-void tst_QStandardItem::appendRow()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, count);
-
-    QStandardItem item(rows, columns);
-    QList<QStandardItem*> originalChildren;
-    // initialize children
-    for (int i = 0; i < rows; ++i) {
-        for (int j = 0; j < columns; ++j) {
-            QStandardItem *child = new QStandardItem;
-            originalChildren.append(child);
-            item.setChild(i, j, child);
-        }
-    }
-
-    // make items for a new row
-    QList<QStandardItem*> rowItems;
-    for (int i = 0; i < count; ++i)
-        rowItems.append(new QStandardItem);
-
-    item.appendRow(rowItems);
-
-    QCOMPARE(item.rowCount(), rows + 1);
-    QCOMPARE(item.columnCount(), qMax(columns, count));
-    // check to make sure items were inserted in correct place
-    for (int i = 0; i < count; ++i)
-        QCOMPARE(item.child(rows, i), rowItems.at(i));
-    for (int i = count; i < item.columnCount(); ++i)
-        QCOMPARE(item.child(rows, i), static_cast<QStandardItem*>(0));
-
-    // make sure original children remained unchanged
-    for (int i = 0; i < rows; ++i) {
-        for (int j = 0; j < columns; ++j)
-            QCOMPARE(item.child(i, j), originalChildren.at(i*columns+j));
-    }
-}
-
-void tst_QStandardItem::takeChild()
-{
-    QList<QStandardItem*> itemList;
-    for (int i = 0; i < 10; ++i)
-        itemList.append(new QStandardItem);
-    QStandardItem item;
-    item.appendColumn(itemList);
-
-    for (int i = 0; i < item.rowCount(); ++i) {
-        QCOMPARE(item.takeChild(i), itemList.at(i));
-        QCOMPARE(item.takeChild(0, 0), static_cast<QStandardItem*>(0));
-        for (int j = i + 1; j < item.rowCount(); ++j)
-            QCOMPARE(item.child(j), itemList.at(j));
-    }
-    qDeleteAll(itemList);
-}
-
-void tst_QStandardItem::takeColumn_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("column");
-    QTest::addColumn<bool>("expectSuccess");
-
-    QTest::newRow("take -1 from 0x0") << 0 << 0 << -1 << false;
-    QTest::newRow("take 0 from 0x0") << 0 << 0 << 0 << false;
-    QTest::newRow("take 0 from 1x0") << 1 << 0 << 0 << false;
-    QTest::newRow("take 0 from 0x1") << 0 << 1 << 0 << true;
-    QTest::newRow("take 1 from 0x1") << 0 << 1 << 1 << false;
-    QTest::newRow("take 0 from 1x1") << 1 << 1 << 0 << true;
-    QTest::newRow("take 1 from 1x1") << 0 << 1 << 1 << false;
-    QTest::newRow("take 0 from 4x1") << 4 << 1 << 0 << true;
-    QTest::newRow("take 1 from 4x1") << 4 << 1 << 1 << false;
-    QTest::newRow("take 0 from 4x8") << 4 << 8 << 0 << true;
-    QTest::newRow("take 7 from 4x8") << 4 << 8 << 7 << true;
-    QTest::newRow("take 8 from 4x8") << 4 << 8 << 8 << false;
-}
-
-void tst_QStandardItem::takeColumn()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, column);
-    QFETCH(bool, expectSuccess);
-
-    QStandardItem item(rows, columns);
-    QList<QStandardItem*> originalChildren;
-    // initialize children
-    for (int i = 0; i < rows; ++i) {
-        for (int j = 0; j < columns; ++j) {
-            QStandardItem *child = new QStandardItem;
-            originalChildren.append(child);
-            item.setChild(i, j, child);
-        }
-    }
-
-    QList<QStandardItem *> taken = item.takeColumn(column);
-    if (expectSuccess) {
-        QCOMPARE(taken.count(), item.rowCount());
-        QCOMPARE(item.columnCount(), columns - 1);
-        int index = column;
-        for (int i = 0; i < taken.count(); ++i) {
-            QCOMPARE(taken.at(i), originalChildren.takeAt(index));
-            index += item.columnCount();
-        }
-        index = 0;
-        for (int i = 0; i < item.rowCount(); ++i) {
-            for (int j = 0; j < item.columnCount(); ++j) {
-                QCOMPARE(item.child(i, j), originalChildren.at(index));
-                ++index;
-            }
-        }
-    } else {
-        QVERIFY(taken.isEmpty());
-    }
-    qDeleteAll(taken);
-}
-
-void tst_QStandardItem::takeRow_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("row");
-    QTest::addColumn<bool>("expectSuccess");
-
-    QTest::newRow("take -1 from 0x0") << 0 << 0 << -1 << false;
-    QTest::newRow("take 0 from 0x0") << 0 << 0 << 0 << false;
-    QTest::newRow("take 0 from 1x0") << 1 << 0 << 0 << true;
-    QTest::newRow("take 0 from 0x1") << 0 << 1 << 0 << false;
-    QTest::newRow("take 1 from 0x1") << 0 << 1 << 1 << false;
-    QTest::newRow("take 0 from 1x1") << 1 << 1 << 0 << true;
-    QTest::newRow("take 1 from 1x1") << 0 << 1 << 1 << false;
-    QTest::newRow("take 0 from 1x4") << 1 << 4 << 0 << true;
-    QTest::newRow("take 1 from 1x4") << 1 << 4 << 1 << false;
-    QTest::newRow("take 0 from 8x4") << 8 << 4 << 0 << true;
-    QTest::newRow("take 7 from 8x4") << 8 << 4 << 7 << true;
-    QTest::newRow("take 8 from 8x4") << 8 << 4 << 8 << false;
-}
-
-void tst_QStandardItem::takeRow()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, row);
-    QFETCH(bool, expectSuccess);
-
-    QStandardItem item(rows, columns);
-    QList<QStandardItem*> originalChildren;
-    // initialize children
-    for (int i = 0; i < rows; ++i) {
-        for (int j = 0; j < columns; ++j) {
-            QStandardItem *child = new QStandardItem;
-            originalChildren.append(child);
-            item.setChild(i, j, child);
-        }
-    }
-
-    QList<QStandardItem *> taken = item.takeRow(row);
-    if (expectSuccess) {
-        QCOMPARE(taken.count(), item.columnCount());
-        QCOMPARE(item.rowCount(), rows - 1);
-        int index = row * columns;
-        for (int i = 0; i < taken.count(); ++i) {
-            QCOMPARE(taken.at(i), originalChildren.takeAt(index));
-        }
-        index = 0;
-        for (int i = 0; i < item.rowCount(); ++i) {
-            for (int j = 0; j < item.columnCount(); ++j) {
-                QCOMPARE(item.child(i, j), originalChildren.at(index));
-                ++index;
-            }
-        }
-    } else {
-        QVERIFY(taken.isEmpty());
-    }
-    qDeleteAll(taken);
-}
-
-void tst_QStandardItem::streamItem()
-{
-    QStandardItem item;
-    
-    item.setText(QLatin1String("text"));
-    item.setToolTip(QLatin1String("toolTip"));
-    item.setStatusTip(QLatin1String("statusTip"));
-    item.setWhatsThis(QLatin1String("whatsThis"));
-    item.setSizeHint(QSize(64, 48));
-    item.setFont(QFont());
-    item.setTextAlignment(Qt::AlignLeft|Qt::AlignVCenter);
-    item.setBackground(QColor(Qt::blue));
-    item.setForeground(QColor(Qt::green));
-    item.setCheckState(Qt::PartiallyChecked);
-    item.setAccessibleText(QLatin1String("accessibleText"));
-    item.setAccessibleDescription(QLatin1String("accessibleDescription"));
-
-    QByteArray ba;
-    {
-        QDataStream ds(&ba, QIODevice::WriteOnly);
-        ds << item;
-    }
-    {
-        QStandardItem streamedItem;
-        QDataStream ds(&ba, QIODevice::ReadOnly);
-        ds >> streamedItem;
-        QCOMPARE(streamedItem.text(), item.text());
-        QCOMPARE(streamedItem.toolTip(), item.toolTip());
-        QCOMPARE(streamedItem.statusTip(), item.statusTip());
-        QCOMPARE(streamedItem.whatsThis(), item.whatsThis());
-        QCOMPARE(streamedItem.sizeHint(), item.sizeHint());
-        QCOMPARE(streamedItem.font(), item.font());
-        QCOMPARE(streamedItem.textAlignment(), item.textAlignment());
-        QCOMPARE(streamedItem.background(), item.background());
-        QCOMPARE(streamedItem.foreground(), item.foreground());
-        QCOMPARE(streamedItem.checkState(), item.checkState());
-        QCOMPARE(streamedItem.accessibleText(), item.accessibleText());
-        QCOMPARE(streamedItem.accessibleDescription(), item.accessibleDescription());
-        QCOMPARE(streamedItem.flags(), item.flags());
-    }
-}
-
-void tst_QStandardItem::deleteItem()
-{
-    QStandardItemModel model(4, 6);
-    // initialize items
-    for (int i = 0; i < model.rowCount(); ++i) {
-        for (int j = 0; j < model.columnCount(); ++j) {
-            QStandardItem *item = new QStandardItem();
-            model.setItem(i, j, item);
-        }
-    }
-    // delete items
-    for (int i = 0; i < model.rowCount(); ++i) {
-        for (int j = 0; j < model.columnCount(); ++j) {
-            QStandardItem *item = model.item(i, j);
-            delete item;
-            QCOMPARE(model.item(i, j), static_cast<QStandardItem*>(0));
-        }
-    }
-}
-
-void tst_QStandardItem::clone()
-{
-    QStandardItem item;
-    item.setText(QLatin1String("text"));
-    item.setToolTip(QLatin1String("toolTip"));
-    item.setStatusTip(QLatin1String("statusTip"));
-    item.setWhatsThis(QLatin1String("whatsThis"));
-    item.setSizeHint(QSize(64, 48));
-    item.setFont(QFont());
-    item.setTextAlignment(Qt::AlignLeft|Qt::AlignVCenter);
-    item.setBackground(QColor(Qt::blue));
-    item.setForeground(QColor(Qt::green));
-    item.setCheckState(Qt::PartiallyChecked);
-    item.setAccessibleText(QLatin1String("accessibleText"));
-    item.setAccessibleDescription(QLatin1String("accessibleDescription"));
-    item.setFlags(Qt::ItemIsEnabled | Qt::ItemIsDropEnabled);
-
-    QStandardItem *clone = item.clone();
-    QCOMPARE(clone->text(), item.text());
-    QCOMPARE(clone->toolTip(), item.toolTip());
-    QCOMPARE(clone->statusTip(), item.statusTip());
-    QCOMPARE(clone->whatsThis(), item.whatsThis());
-    QCOMPARE(clone->sizeHint(), item.sizeHint());
-    QCOMPARE(clone->font(), item.font());
-    QCOMPARE(clone->textAlignment(), item.textAlignment());
-    QCOMPARE(clone->background(), item.background());
-    QCOMPARE(clone->foreground(), item.foreground());
-    QCOMPARE(clone->checkState(), item.checkState());
-    QCOMPARE(clone->accessibleText(), item.accessibleText());
-    QCOMPARE(clone->accessibleDescription(), item.accessibleDescription());
-    QCOMPARE(clone->flags(), item.flags());
-    QVERIFY(!(*clone < item));
-    delete clone;
-}
-
-void tst_QStandardItem::sortChildren()
-{
-    for (int x = 0; x < 2; ++x) {
-        QStandardItemModel *model = new QStandardItemModel;
-        QStandardItem *item = (x == 0) ? new QStandardItem : model->invisibleRootItem();
-        QStandardItem *one = new QStandardItem;
-        one->appendRow(new QStandardItem(QLatin1String("a")));
-        one->appendRow(new QStandardItem(QLatin1String("b")));
-        one->appendRow(new QStandardItem(QLatin1String("c")));
-        QStandardItem *two = new QStandardItem;
-        two->appendRow(new QStandardItem(QLatin1String("f")));
-        two->appendRow(new QStandardItem(QLatin1String("d")));
-        two->appendRow(new QStandardItem(QLatin1String("e")));
-        item->appendRow(one);
-        item->appendRow(two);
-        
-        QSignalSpy layoutAboutToBeChangedSpy(
-            model, SIGNAL(layoutAboutToBeChanged()));
-        QSignalSpy layoutChangedSpy(
-            model, SIGNAL(layoutChanged()));
-
-        one->sortChildren(0, Qt::DescendingOrder);
-        // verify sorted
-        QCOMPARE(one->child(0)->text(), QLatin1String("c"));
-        QCOMPARE(one->child(1)->text(), QLatin1String("b"));
-        QCOMPARE(one->child(2)->text(), QLatin1String("a"));
-        // verify siblings unaffected
-        QCOMPARE(two->child(0)->text(), QLatin1String("f"));
-        QCOMPARE(two->child(1)->text(), QLatin1String("d"));
-        QCOMPARE(two->child(2)->text(), QLatin1String("e"));
-        
-        two->sortChildren(0, Qt::AscendingOrder);
-        // verify sorted
-        QCOMPARE(two->child(0)->text(), QLatin1String("d"));
-        QCOMPARE(two->child(1)->text(), QLatin1String("e"));
-        QCOMPARE(two->child(2)->text(), QLatin1String("f"));
-        // verify siblings unaffected
-        QCOMPARE(one->child(0)->text(), QLatin1String("c"));
-        QCOMPARE(one->child(1)->text(), QLatin1String("b"));
-        QCOMPARE(one->child(2)->text(), QLatin1String("a"));
-        
-        item->sortChildren(0, Qt::AscendingOrder);
-        // verify everything sorted
-        QCOMPARE(one->child(0)->text(), QLatin1String("a"));
-        QCOMPARE(one->child(1)->text(), QLatin1String("b"));
-        QCOMPARE(one->child(2)->text(), QLatin1String("c"));
-        QCOMPARE(two->child(0)->text(), QLatin1String("d"));
-        QCOMPARE(two->child(1)->text(), QLatin1String("e"));
-        QCOMPARE(two->child(2)->text(), QLatin1String("f"));
-
-        QCOMPARE(layoutAboutToBeChangedSpy.count(), (x == 0) ? 0 : 3);
-        QCOMPARE(layoutChangedSpy.count(), (x == 0) ? 0 : 3);
-
-        if (x == 0)
-            delete item;
-        delete model;
-    }
-}
-
-class CustomItem : public QStandardItem
-{
-public:
-    CustomItem(const QString &text) : QStandardItem(text) { }
-    CustomItem() { }
-    virtual ~CustomItem() { }
-
-    virtual int type() const { return QStandardItem::UserType + 1; }
-
-    virtual QStandardItem *clone() const { return QStandardItem::clone(); }
-
-    void emitDataChanged() { QStandardItem::emitDataChanged(); }
-
-    virtual bool operator<(const QStandardItem &other) const {
-        return text().length() < other.text().length();
-    }
-};
-
-Q_DECLARE_METATYPE(QStandardItem*)
-
-void tst_QStandardItem::subclassing()
-{
-    qMetaTypeId<QStandardItem*>();
-
-    CustomItem *item = new CustomItem;
-    QCOMPARE(item->type(), int(QStandardItem::UserType + 1));
-
-    item->setText(QString::fromLatin1("foo"));
-    QCOMPARE(item->text(), QString::fromLatin1("foo"));
-
-    item->emitDataChanged(); // does nothing
-
-    QStandardItemModel model;
-    model.appendRow(item);
-
-    QSignalSpy itemChangedSpy(&model, SIGNAL(itemChanged(QStandardItem*)));
-    item->emitDataChanged();
-    QCOMPARE(itemChangedSpy.count(), 1);
-    QCOMPARE(itemChangedSpy.at(0).count(), 1);
-    QCOMPARE(qvariant_cast<QStandardItem*>(itemChangedSpy.at(0).at(0)), (QStandardItem*)item);
-
-    CustomItem *child0 = new CustomItem("cc");
-    CustomItem *child1 = new CustomItem("bbb");
-    CustomItem *child2 = new CustomItem("a");
-    item->appendRow(child0);
-    item->appendRow(child1);
-    item->appendRow(child2);
-    item->sortChildren(0);
-    QCOMPARE(item->child(0), (QStandardItem*)child2);
-    QCOMPARE(item->child(1), (QStandardItem*)child0);
-    QCOMPARE(item->child(2), (QStandardItem*)child1);
-}
-
-QTEST_MAIN(tst_QStandardItem)
-#include "tst_qstandarditem.moc"
diff --git a/tests/auto/widgets/itemviews/qstandarditemmodel/.gitignore b/tests/auto/widgets/itemviews/qstandarditemmodel/.gitignore
deleted file mode 100644
index c218efc..0000000
--- a/tests/auto/widgets/itemviews/qstandarditemmodel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-tst_qstandarditemmodel
diff --git a/tests/auto/widgets/itemviews/qstandarditemmodel/qstandarditemmodel.pro b/tests/auto/widgets/itemviews/qstandarditemmodel/qstandarditemmodel.pro
deleted file mode 100644
index 71ef4ac..0000000
--- a/tests/auto/widgets/itemviews/qstandarditemmodel/qstandarditemmodel.pro
+++ /dev/null
@@ -1,10 +0,0 @@
-CONFIG += testcase
-CONFIG += parallel_test
-TARGET = tst_qstandarditemmodel
-
-QT += widgets widgets-private testlib
-QT += core-private gui-private
-
-SOURCES  += tst_qstandarditemmodel.cpp
-
-
diff --git a/tests/auto/widgets/itemviews/qstandarditemmodel/tst_qstandarditemmodel.cpp b/tests/auto/widgets/itemviews/qstandarditemmodel/tst_qstandarditemmodel.cpp
deleted file mode 100644
index 1c661f9..0000000
--- a/tests/auto/widgets/itemviews/qstandarditemmodel/tst_qstandarditemmodel.cpp
+++ /dev/null
@@ -1,1683 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include <QtTest/QtTest>
-
-#include <qstandarditemmodel.h>
-#include <QTreeView>
-#include <private/qtreeview_p.h>
-
-class tst_QStandardItemModel : public QObject
-{
-    Q_OBJECT
-
-public:
-    tst_QStandardItemModel();
-    virtual ~tst_QStandardItemModel();
-
-    enum ModelChanged {
-        RowsAboutToBeInserted,
-        RowsInserted,
-        RowsAboutToBeRemoved,
-        RowsRemoved,
-        ColumnsAboutToBeInserted,
-        ColumnsInserted,
-        ColumnsAboutToBeRemoved,
-        ColumnsRemoved
-    };
-
-public slots:
-    void init();
-    void cleanup();
-
-protected slots:
-    void checkAboutToBeRemoved();
-    void checkRemoved();
-    void updateRowAboutToBeRemoved();
-
-    void rowsAboutToBeInserted(const QModelIndex &parent, int first, int last)
-        { modelChanged(RowsAboutToBeInserted, parent, first, last); }
-    void rowsInserted(const QModelIndex &parent, int first, int last)
-        { modelChanged(RowsInserted, parent, first, last); }
-    void rowsAboutToBeRemoved(const QModelIndex &parent, int first, int last)
-        { modelChanged(RowsAboutToBeRemoved, parent, first, last); }
-    void rowsRemoved(const QModelIndex &parent, int first, int last)
-        { modelChanged(RowsRemoved, parent, first, last); }
-    void columnsAboutToBeInserted(const QModelIndex &parent, int first, int last)
-        { modelChanged(ColumnsAboutToBeInserted, parent, first, last); }
-    void columnsInserted(const QModelIndex &parent, int first, int last)
-        { modelChanged(ColumnsInserted, parent, first, last); }
-    void columnsAboutToBeRemoved(const QModelIndex &parent, int first, int last)
-        { modelChanged(ColumnsAboutToBeRemoved, parent, first, last); }
-    void columnsRemoved(const QModelIndex &parent, int first, int last)
-        { modelChanged(ColumnsRemoved, parent, first, last); }
-
-    void modelChanged(ModelChanged change, const QModelIndex &parent, int first, int last);
-
-private slots:
-    void insertRow_data();
-    void insertRow();
-    void insertRows();
-    void insertRowsItems();
-    void insertRowInHierarcy();
-    void insertColumn_data();
-    void insertColumn();
-    void insertColumns();
-    void removeRows();
-    void removeColumns();
-    void setHeaderData();
-    void persistentIndexes();
-    void removingPersistentIndexes();
-    void updatingPersistentIndexes();
-
-    void checkChildren();
-    void data();
-    void clear();
-    void sort_data();
-    void sort();
-    void sortRole_data();
-    void sortRole();
-    void findItems();
-    void getSetHeaderItem();
-    void indexFromItem();
-    void itemFromIndex();
-    void getSetItemPrototype();
-    void getSetItemData();
-    void setHeaderLabels_data();
-    void setHeaderLabels();
-    void itemDataChanged();
-    void takeHeaderItem();
-    void useCase1();
-    void useCase2();
-    void useCase3();
-
-    void rootItemFlags();
-    void treeDragAndDrop();
-    void removeRowsAndColumns();
-
-    void itemRoleNames();
-
-private:
-    QAbstractItemModel *m_model;
-    QPersistentModelIndex persistent;
-    QVector<QModelIndex> rcParent;
-    QVector<int> rcFirst;
-    QVector<int> rcLast;
-
-    //return true if models have the same structure, and all child have the same text
-    bool compareModels(QStandardItemModel *model1, QStandardItemModel *model2);
-    //return true if models have the same structure, and all child have the same text
-    bool compareItems(QStandardItem *item1, QStandardItem *item2);
-};
-
-static const int defaultSize = 3;
-
-Q_DECLARE_METATYPE(QModelIndex)
-Q_DECLARE_METATYPE(QStandardItem*)
-Q_DECLARE_METATYPE(Qt::Orientation)
-Q_DECLARE_METATYPE(QVariantList)
-
-tst_QStandardItemModel::tst_QStandardItemModel() : m_model(0), rcParent(8), rcFirst(8,0), rcLast(8,0)
-{
-}
-
-tst_QStandardItemModel::~tst_QStandardItemModel()
-{
-}
-
-/*
-  This test usually uses a model with a 3x3 table
-  ---------------------------
-  |  0,0  |  0,1    |  0,2  |
-  ---------------------------
-  |  1,0  |  1,1    |  1,2  |
-  ---------------------------
-  |  2,0  |  2,1    |  2,2  |
-  ---------------------------
-*/
-void tst_QStandardItemModel::init()
-{
-    qRegisterMetaType<QModelIndex>("QModelIndex");
-    qRegisterMetaType<QStandardItem*>("QStandardItem*");
-    qRegisterMetaType<Qt::Orientation>("Qt::Orientation");
-
-    m_model = new QStandardItemModel(defaultSize, defaultSize);
-    connect(m_model, SIGNAL(rowsAboutToBeInserted(QModelIndex, int, int)),
-            this, SLOT(rowsAboutToBeInserted(QModelIndex, int, int)));
-    connect(m_model, SIGNAL(rowsInserted(QModelIndex, int, int)),
-            this, SLOT(rowsInserted(QModelIndex, int, int)));
-    connect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex, int, int)),
-            this, SLOT(rowsAboutToBeRemoved(QModelIndex, int, int)));
-    connect(m_model, SIGNAL(rowsRemoved(QModelIndex, int, int)),
-            this, SLOT(rowsRemoved(QModelIndex, int, int)));
-
-    connect(m_model, SIGNAL(columnsAboutToBeInserted(QModelIndex, int, int)),
-            this, SLOT(columnsAboutToBeInserted(QModelIndex, int, int)));
-    connect(m_model, SIGNAL(columnsInserted(QModelIndex, int, int)),
-            this, SLOT(columnsInserted(QModelIndex, int, int)));
-    connect(m_model, SIGNAL(columnsAboutToBeRemoved(QModelIndex, int, int)),
-            this, SLOT(columnsAboutToBeRemoved(QModelIndex, int, int)));
-    connect(m_model, SIGNAL(columnsRemoved(QModelIndex, int, int)),
-            this, SLOT(columnsRemoved(QModelIndex, int, int)));
-
-    rcFirst.fill(-1);
-    rcLast.fill(-1);
-}
-
-void tst_QStandardItemModel::cleanup()
-{
-    disconnect(m_model, SIGNAL(rowsAboutToBeInserted(QModelIndex, int, int)),
-               this, SLOT(rowsAboutToBeInserted(QModelIndex, int, int)));
-    disconnect(m_model, SIGNAL(rowsInserted(QModelIndex, int, int)),
-               this, SLOT(rowsInserted(QModelIndex, int, int)));
-    disconnect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex, int, int)),
-               this, SLOT(rowsAboutToBeRemoved(QModelIndex, int, int)));
-    disconnect(m_model, SIGNAL(rowsRemoved(QModelIndex, int, int)),
-               this, SLOT(rowsRemoved(QModelIndex, int, int)));
-
-    disconnect(m_model, SIGNAL(columnsAboutToBeInserted(QModelIndex, int, int)),
-               this, SLOT(columnsAboutToBeInserted(QModelIndex, int, int)));
-    disconnect(m_model, SIGNAL(columnsInserted(QModelIndex, int, int)),
-               this, SLOT(columnsInserted(QModelIndex, int, int)));
-    disconnect(m_model, SIGNAL(columnsAboutToBeRemoved(QModelIndex, int, int)),
-               this, SLOT(columnsAboutToBeRemoved(QModelIndex, int, int)));
-    disconnect(m_model, SIGNAL(columnsRemoved(QModelIndex, int, int)),
-               this, SLOT(columnsRemoved(QModelIndex, int, int)));
-    delete m_model;
-    m_model = 0;
-}
-
-void tst_QStandardItemModel::insertRow_data()
-{
-    QTest::addColumn<int>("insertRow");
-    QTest::addColumn<int>("expectedRow");
-
-    QTest::newRow("Insert less then 0") << -1 << 0;
-    QTest::newRow("Insert at 0")  << 0 << 0;
-    QTest::newRow("Insert beyond count")  << defaultSize+1 << defaultSize;
-    QTest::newRow("Insert at count") << defaultSize << defaultSize;
-    QTest::newRow("Insert in the middle") << 1 << 1;
-}
-
-void tst_QStandardItemModel::insertRow()
-{
-    QFETCH(int, insertRow);
-    QFETCH(int, expectedRow);
-
-    QIcon icon;
-    // default all initial items to DisplayRole: "initalitem"
-    for (int r=0; r < m_model->rowCount(); ++r) {
-        for (int c=0; c < m_model->columnCount(); ++c) {
-            m_model->setData(m_model->index(r,c), "initialitem", Qt::DisplayRole);
-        }
-    }
-
-    // check that inserts changes rowCount
-    QCOMPARE(m_model->rowCount(), defaultSize);
-    m_model->insertRow(insertRow);
-    if (insertRow >= 0 && insertRow <= defaultSize) {
-        QCOMPARE(m_model->rowCount(), defaultSize + 1);
-
-        // check that signals were emitted with correct info
-        QCOMPARE(rcFirst[RowsAboutToBeInserted], expectedRow);
-        QCOMPARE(rcLast[RowsAboutToBeInserted], expectedRow);
-        QCOMPARE(rcFirst[RowsInserted], expectedRow);
-        QCOMPARE(rcLast[RowsInserted], expectedRow);
-
-        //check that the inserted item has different DisplayRole than initial items
-        QVERIFY(m_model->data(m_model->index(expectedRow, 0), Qt::DisplayRole).toString() != "initialitem");
-    } else {
-        // We inserted something outside the bounds, do nothing
-        QCOMPARE(m_model->rowCount(), defaultSize);
-        QCOMPARE(rcFirst[RowsAboutToBeInserted], -1);
-        QCOMPARE(rcLast[RowsAboutToBeInserted], -1);
-        QCOMPARE(rcFirst[RowsInserted], -1);
-        QCOMPARE(rcLast[RowsInserted], -1);
-    }
-}
-
-void tst_QStandardItemModel::insertRows()
-{
-    int rowCount = m_model->rowCount();
-    QCOMPARE(rowCount, defaultSize);
-
-    // insert custom header label
-    QString headerLabel = "custom";
-    m_model->setHeaderData(0, Qt::Vertical, headerLabel);
-
-    // insert one row
-    m_model->insertRows(0, 1);
-    QCOMPARE(m_model->rowCount(), rowCount + 1);
-    rowCount = m_model->rowCount();
-
-    // check header data has moved
-    QCOMPARE(m_model->headerData(1, Qt::Vertical).toString(), headerLabel);
-
-    // insert two rows
-    m_model->insertRows(0, 2);
-    QCOMPARE(m_model->rowCount(), rowCount + 2);
-
-    // check header data has moved
-    QCOMPARE(m_model->headerData(3, Qt::Vertical).toString(), headerLabel);
-}
-
-void tst_QStandardItemModel::insertRowsItems()
-{
-    int rowCount = m_model->rowCount();
-
-    QList<QStandardItem *> items;
-    QStandardItemModel *m = qobject_cast<QStandardItemModel*>(m_model);
-    QStandardItem *hiddenRoot = m->invisibleRootItem();
-    for (int i = 0; i < 3; ++i)
-        items.append(new QStandardItem(QString("%1").arg(i + 10)));
-    hiddenRoot->appendRows(items);
-    QCOMPARE(m_model->rowCount(), rowCount + 3);
-    QCOMPARE(m_model->index(rowCount + 0, 0).data().toInt(), 10);
-    QCOMPARE(m_model->index(rowCount + 1, 0).data().toInt(), 11);
-    QCOMPARE(m_model->index(rowCount + 2, 0).data().toInt(), 12);
-    for (int i = rowCount; i < rowCount + 3; ++i) {
-        QVERIFY(m->item(i));
-        QCOMPARE(static_cast<QAbstractItemModel *>(m->item(i)->model()), m_model);
-    }
-}
-
-void tst_QStandardItemModel::insertRowInHierarcy()
-{
-    QVERIFY(m_model->insertRows(0, 1, QModelIndex()));
-    QVERIFY(m_model->insertColumns(0, 1, QModelIndex()));
-    QVERIFY(m_model->hasIndex(0, 0, QModelIndex()));
-
-    QModelIndex parent = m_model->index(0, 0, QModelIndex());
-    QVERIFY(parent.isValid());
-
-    QVERIFY(m_model->insertRows(0, 1, parent));
-    QVERIFY(m_model->insertColumns(0, 1, parent));
-    QVERIFY(m_model->hasIndex(0, 0, parent));
-
-    QModelIndex child = m_model->index(0, 0, parent);
-    QVERIFY(child.isValid());
-}
-
-void tst_QStandardItemModel::insertColumn_data()
-{
-    QTest::addColumn<int>("insertColumn");
-    QTest::addColumn<int>("expectedColumn");
-
-    QTest::newRow("Insert less then 0") << -1 << 0;
-    QTest::newRow("Insert at 0")  << 0 << 0;
-    QTest::newRow("Insert beyond count")  << defaultSize+1 << defaultSize;
-    QTest::newRow("Insert at count") << defaultSize << defaultSize;
-    QTest::newRow("Insert in the middle") << 1 << 1;
-}
-
-void tst_QStandardItemModel::insertColumn()
-{
-    QFETCH(int, insertColumn);
-    QFETCH(int, expectedColumn);
-
-    // default all initial items to DisplayRole: "initalitem"
-    for (int r=0; r < m_model->rowCount(); ++r) {
-        for (int c=0; c < m_model->columnCount(); ++c) {
-            m_model->setData(m_model->index(r,c), "initialitem", Qt::DisplayRole);
-        }
-    }
-
-    // check that inserts changes columnCount
-    QCOMPARE(m_model->columnCount(), defaultSize);
-    m_model->insertColumn(insertColumn);
-    if (insertColumn >= 0 && insertColumn <= defaultSize) {
-        QCOMPARE(m_model->columnCount(), defaultSize +  1);
-        // check that signals were emitted with correct info
-        QCOMPARE(rcFirst[ColumnsAboutToBeInserted], expectedColumn);
-        QCOMPARE(rcLast[ColumnsAboutToBeInserted], expectedColumn);
-        QCOMPARE(rcFirst[ColumnsInserted], expectedColumn);
-        QCOMPARE(rcLast[ColumnsInserted], expectedColumn);
-
-        //check that the inserted item has different DisplayRole than initial items
-        QVERIFY(m_model->data(m_model->index(0, expectedColumn), Qt::DisplayRole).toString() != "initialitem");
-    } else {
-        // We inserted something outside the bounds, do nothing
-        QCOMPARE(m_model->columnCount(), defaultSize);
-        QCOMPARE(rcFirst[ColumnsAboutToBeInserted], -1);
-        QCOMPARE(rcLast[ColumnsAboutToBeInserted], -1);
-        QCOMPARE(rcFirst[ColumnsInserted], -1);
-        QCOMPARE(rcLast[ColumnsInserted], -1);
-    }
-
-}
-
-void tst_QStandardItemModel::insertColumns()
-{
-    int columnCount = m_model->columnCount();
-    QCOMPARE(columnCount, defaultSize);
-
-    // insert custom header label
-    QString headerLabel = "custom";
-    m_model->setHeaderData(0, Qt::Horizontal, headerLabel);
-
-    // insert one column
-    m_model->insertColumns(0, 1);
-    QCOMPARE(m_model->columnCount(), columnCount + 1);
-    columnCount = m_model->columnCount();
-
-    // check header data has moved
-    QCOMPARE(m_model->headerData(1, Qt::Horizontal).toString(), headerLabel);
-
-    // insert two columns
-    m_model->insertColumns(0, 2);
-    QCOMPARE(m_model->columnCount(), columnCount + 2);
-
-    // check header data has moved
-    QCOMPARE(m_model->headerData(3, Qt::Horizontal).toString(), headerLabel);
-}
-
-void tst_QStandardItemModel::removeRows()
-{
-    int rowCount = m_model->rowCount();
-    QCOMPARE(rowCount, defaultSize);
-
-    // insert custom header label
-    QString headerLabel = "custom";
-    m_model->setHeaderData(rowCount - 1, Qt::Vertical, headerLabel);
-
-    // remove one row
-    m_model->removeRows(0, 1);
-    QCOMPARE(m_model->rowCount(), rowCount - 1);
-    rowCount = m_model->rowCount();
-
-    // check header data has moved
-    QCOMPARE(m_model->headerData(rowCount - 1, Qt::Vertical).toString(), headerLabel);
-
-    // remove two rows
-    m_model->removeRows(0, 2);
-    QCOMPARE(m_model->rowCount(), rowCount - 2);
-}
-
-void tst_QStandardItemModel::removeColumns()
-{
-    int columnCount = m_model->columnCount();
-    QCOMPARE(columnCount, defaultSize);
-
-    // insert custom header label
-    QString headerLabel = "custom";
-    m_model->setHeaderData(columnCount - 1, Qt::Horizontal, headerLabel);
-
-    // remove one column
-    m_model->removeColumns(0, 1);
-    QCOMPARE(m_model->columnCount(), columnCount - 1);
-    columnCount = m_model->columnCount();
-
-    // check header data has moved
-    QCOMPARE(m_model->headerData(columnCount - 1, Qt::Horizontal).toString(), headerLabel);
-
-    // remove two columns
-    m_model->removeColumns(0, 2);
-    QCOMPARE(m_model->columnCount(), columnCount - 2);
-}
-
-
-void tst_QStandardItemModel::setHeaderData()
-{
-    for (int x = 0; x < 2; ++x) {
-        bool vertical = (x == 0);
-        int count = vertical ? m_model->rowCount() : m_model->columnCount();
-        QCOMPARE(count, defaultSize);
-        Qt::Orientation orient = vertical ? Qt::Vertical : Qt::Horizontal;
-
-        // check default values are ok
-        for (int i = 0; i < count; ++i)
-            QCOMPARE(m_model->headerData(i, orient).toString(), QString::number(i + 1));
-
-        QSignalSpy headerDataChangedSpy(
-            m_model, SIGNAL(headerDataChanged(Qt::Orientation, int, int)));
-        QSignalSpy dataChangedSpy(
-            m_model, SIGNAL(dataChanged(QModelIndex, QModelIndex)));
-        // insert custom values and check
-        for (int i = 0; i < count; ++i) {
-            QString customString = QString("custom") + QString::number(i);
-            QCOMPARE(m_model->setHeaderData(i, orient, customString), true);
-            QCOMPARE(headerDataChangedSpy.count(), 1);
-            QCOMPARE(dataChangedSpy.count(), 0);
-            QVariantList args = headerDataChangedSpy.takeFirst();
-            QCOMPARE(qvariant_cast<Qt::Orientation>(args.at(0)), orient);
-            QCOMPARE(args.at(1).toInt(), i);
-            QCOMPARE(args.at(2).toInt(), i);
-            QCOMPARE(m_model->headerData(i, orient).toString(), customString);
-            QCOMPARE(m_model->setHeaderData(i, orient, customString), true);
-            QCOMPARE(headerDataChangedSpy.count(), 0);
-            QCOMPARE(dataChangedSpy.count(), 0);
-        }
-
-        //check read from invalid sections
-        QVERIFY(!m_model->headerData(count, orient).isValid());
-        QVERIFY(!m_model->headerData(-1, orient).isValid());
-        //check write to invalid section
-        QCOMPARE(m_model->setHeaderData(count, orient, "foo"), false);
-        QCOMPARE(m_model->setHeaderData(-1, orient, "foo"), false);
-        QVERIFY(!m_model->headerData(count, orient).isValid());
-        QVERIFY(!m_model->headerData(-1, orient).isValid());
-    }
-}
-
-void tst_QStandardItemModel::persistentIndexes()
-{
-    QCOMPARE(m_model->rowCount(), defaultSize);
-    QCOMPARE(m_model->columnCount(), defaultSize);
-
-    // create a persisten index at 0,0
-    QPersistentModelIndex persistentIndex(m_model->index(0, 0));
-
-    // verify it is ok and at the correct spot
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 0);
-    QCOMPARE(persistentIndex.column(), 0);
-
-    // insert row and check that the persisten index has moved
-    QVERIFY(m_model->insertRow(0));
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 1);
-    QCOMPARE(persistentIndex.column(), 0);
-
-    // insert row after the persisten index and see that it stays the same
-    QVERIFY(m_model->insertRow(m_model->rowCount()));
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 1);
-    QCOMPARE(persistentIndex.column(), 0);
-
-    // insert column and check that the persisten index has moved
-    QVERIFY(m_model->insertColumn(0));
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 1);
-    QCOMPARE(persistentIndex.column(), 1);
-
-    // insert column after the persisten index and see that it stays the same
-    QVERIFY(m_model->insertColumn(m_model->columnCount()));
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 1);
-    QCOMPARE(persistentIndex.column(), 1);
-
-    // removes a row beyond the persistent index and see it stays the same
-    QVERIFY(m_model->removeRow(m_model->rowCount() - 1));
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 1);
-    QCOMPARE(persistentIndex.column(), 1);
-
-    // removes a column beyond the persistent index and see it stays the same
-    QVERIFY(m_model->removeColumn(m_model->columnCount() - 1));
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 1);
-    QCOMPARE(persistentIndex.column(), 1);
-
-    // removes a row before the persistent index and see it moves the same
-    QVERIFY(m_model->removeRow(0));
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 0);
-    QCOMPARE(persistentIndex.column(), 1);
-
-    // removes a column before the persistent index and see it moves the same
-    QVERIFY(m_model->removeColumn(0));
-    QVERIFY(persistentIndex.isValid());
-    QCOMPARE(persistentIndex.row(), 0);
-    QCOMPARE(persistentIndex.column(), 0);
-
-    // remove the row where the persistent index is, and see that it becomes invalid
-    QVERIFY(m_model->removeRow(0));
-    QVERIFY(!persistentIndex.isValid());
-
-    // remove the row where the persistent index is, and see that it becomes invalid
-    persistentIndex = m_model->index(0, 0);
-    QVERIFY(persistentIndex.isValid());
-    QVERIFY(m_model->removeColumn(0));
-    QVERIFY(!persistentIndex.isValid());
-}
-
-void tst_QStandardItemModel::checkAboutToBeRemoved()
-{
-    QVERIFY(persistent.isValid());
-}
-
-void tst_QStandardItemModel::checkRemoved()
-{
-    QVERIFY(!persistent.isValid());
-}
-
-void tst_QStandardItemModel::removingPersistentIndexes()
-{
-    // add 10 rows and columns to model to make it big enough
-    QVERIFY(m_model->insertRows(0, 10));
-    QVERIFY(m_model->insertColumns(0, 10));
-
-    QObject::connect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
-                     this, SLOT(checkAboutToBeRemoved()));
-    QObject::connect(m_model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
-                     this, SLOT(checkRemoved()));
-    QObject::connect(m_model, SIGNAL(columnsAboutToBeRemoved(QModelIndex,int,int)),
-                     this, SLOT(checkAboutToBeRemoved()));
-    QObject::connect(m_model, SIGNAL(columnsRemoved(QModelIndex,int,int)),
-                     this, SLOT(checkRemoved()));
-
-
-    // test removeRow
-    // add child table 3x3 to parent index(0, 0)
-    QVERIFY(m_model->insertRows(0, 3, m_model->index(0, 0)));
-    QVERIFY(m_model->insertColumns(0, 3, m_model->index(0, 0)));
-
-    // set child to persistent and delete parent row
-    persistent = m_model->index(0, 0, m_model->index(0, 0));
-    QVERIFY(persistent.isValid());
-    QVERIFY(m_model->removeRow(0));
-
-    // set persistent to index(0, 0) and remove that row
-    persistent = m_model->index(0, 0);
-    QVERIFY(persistent.isValid());
-    QVERIFY(m_model->removeRow(0));
-
-
-    // test removeColumn
-    // add child table 3x3 to parent index (0, 0)
-    QVERIFY(m_model->insertRows(0, 3, m_model->index(0, 0)));
-    QVERIFY(m_model->insertColumns(0, 3, m_model->index(0, 0)));
-
-    // set child to persistent and delete parent column
-    persistent = m_model->index(0, 0, m_model->index(0, 0));
-    QVERIFY(persistent.isValid());
-    QVERIFY(m_model->removeColumn(0));
-
-    // set persistent to index(0, 0) and remove that column
-    persistent = m_model->index(0, 0);
-    QVERIFY(persistent.isValid());
-    QVERIFY(m_model->removeColumn(0));
-
-
-    QObject::disconnect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
-                        this, SLOT(checkAboutToBeRemoved()));
-    QObject::disconnect(m_model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
-                        this, SLOT(checkRemoved()));
-    QObject::disconnect(m_model, SIGNAL(columnsAboutToBeRemoved(QModelIndex,int,int)),
-                        this, SLOT(checkAboutToBeRemoved()));
-    QObject::disconnect(m_model, SIGNAL(columnsRemoved(QModelIndex,int,int)),
-                        this, SLOT(checkRemoved()));
-}
-
-void tst_QStandardItemModel::updateRowAboutToBeRemoved()
-{
-    QModelIndex idx = m_model->index(0, 0);
-    QVERIFY(idx.isValid());
-    persistent = idx;
-}
-
-void tst_QStandardItemModel::updatingPersistentIndexes()
-{
-    QObject::connect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
-                     this, SLOT(updateRowAboutToBeRemoved()));
-
-    persistent = m_model->index(1, 0);
-    QVERIFY(persistent.isValid());
-    QVERIFY(m_model->removeRow(1));
-    QVERIFY(persistent.isValid());
-    QPersistentModelIndex tmp = m_model->index(0, 0);
-    QCOMPARE(persistent, tmp);
-
-    QObject::disconnect(m_model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
-                        this, SLOT(updateRowAboutToBeRemoved()));
-}
-
-void tst_QStandardItemModel::modelChanged(ModelChanged change, const QModelIndex &parent,
-                                          int first, int last)
-{
-    rcParent[change] = parent;
-    rcFirst[change] = first;
-    rcLast[change] = last;
-}
-
-
-void tst_QStandardItemModel::checkChildren()
-{
-    QStandardItemModel model(0, 0);
-    QCOMPARE(model.rowCount(), 0);
-    QCOMPARE(model.columnCount(), 0);
-    QVERIFY(!model.hasChildren());
-
-    QVERIFY(model.insertRows(0, 1));
-    QVERIFY(!model.hasChildren());
-    QCOMPARE(model.rowCount(), 1);
-    QCOMPARE(model.columnCount(), 0);
-
-    QVERIFY(model.insertColumns(0, 1));
-    QVERIFY(model.hasChildren());
-    QCOMPARE(model.rowCount(), 1);
-    QCOMPARE(model.columnCount(), 1);
-
-    QModelIndex idx = model.index(0, 0);
-    QVERIFY(!model.hasChildren(idx));
-    QCOMPARE(model.rowCount(idx), 0);
-    QCOMPARE(model.columnCount(idx), 0);
-
-    QVERIFY(model.insertRows(0, 1, idx));
-    QVERIFY(!model.hasChildren(idx));
-    QCOMPARE(model.rowCount(idx), 1);
-    QCOMPARE(model.columnCount(idx), 0);
-
-    QVERIFY(model.insertColumns(0, 1, idx));
-    QVERIFY(model.hasChildren(idx));
-    QCOMPARE(model.rowCount(idx), 1);
-    QCOMPARE(model.columnCount(idx), 1);
-
-    QModelIndex idx2 = model.index(0, 0, idx);
-    QVERIFY(!model.hasChildren(idx2));
-    QCOMPARE(model.rowCount(idx2), 0);
-    QCOMPARE(model.columnCount(idx2), 0);
-
-    QVERIFY(model.removeRows(0, 1, idx));
-    QVERIFY(model.hasChildren());
-    QCOMPARE(model.rowCount(), 1);
-    QCOMPARE(model.columnCount(), 1);
-    QVERIFY(!model.hasChildren(idx));
-    QCOMPARE(model.rowCount(idx), 0);
-    QCOMPARE(model.columnCount(idx), 1);
-
-    QVERIFY(model.removeRows(0, 1));
-    QVERIFY(!model.hasChildren());
-    QCOMPARE(model.rowCount(), 0);
-    QCOMPARE(model.columnCount(), 1);
-}
-
-void tst_QStandardItemModel::data()
-{
-    // bad args
-    m_model->setData(QModelIndex(), "bla", Qt::DisplayRole);
-
-    QIcon icon;
-    for (int r=0; r < m_model->rowCount(); ++r) {
-        for (int c=0; c < m_model->columnCount(); ++c) {
-            m_model->setData(m_model->index(r,c), "initialitem", Qt::DisplayRole);
-            m_model->setData(m_model->index(r,c), "tooltip", Qt::ToolTipRole);
-            m_model->setData(m_model->index(r,c), icon, Qt::DecorationRole);
-        }
-    }
-
-    QVERIFY(m_model->data(m_model->index(0, 0), Qt::DisplayRole).toString() == "initialitem");
-    QVERIFY(m_model->data(m_model->index(0, 0), Qt::ToolTipRole).toString() == "tooltip");
-
-}
-
-void tst_QStandardItemModel::clear()
-{
-    QStandardItemModel model;
-    model.insertColumns(0, 10);
-    model.insertRows(0, 10);
-    QCOMPARE(model.columnCount(), 10);
-    QCOMPARE(model.rowCount(), 10);
-
-    QSignalSpy modelResetSpy(&model, SIGNAL(modelReset()));
-    QSignalSpy layoutChangedSpy(&model, SIGNAL(layoutChanged()));
-    QSignalSpy rowsRemovedSpy(&model, SIGNAL(rowsRemoved(QModelIndex, int, int)));
-    model.clear();
-
-    QCOMPARE(modelResetSpy.count(), 1);
-    QCOMPARE(layoutChangedSpy.count(), 0);
-    QCOMPARE(rowsRemovedSpy.count(), 0);
-    QCOMPARE(model.index(0, 0), QModelIndex());
-    QCOMPARE(model.columnCount(), 0);
-    QCOMPARE(model.rowCount(), 0);
-    QCOMPARE(model.hasChildren(), false);
-}
-
-void tst_QStandardItemModel::sort_data()
-{
-    QTest::addColumn<int>("sortOrder");
-    QTest::addColumn<QStringList>("initial");
-    QTest::addColumn<QStringList>("expected");
-
-    QTest::newRow("flat descending") << static_cast<int>(Qt::DescendingOrder)
-                                  << (QStringList()
-                                      << "delta"
-                                      << "yankee"
-                                      << "bravo"
-                                      << "lima"
-                                      << "charlie"
-                                      << "juliet"
-                                      << "tango"
-                                      << "hotel"
-                                      << "uniform"
-                                      << "alpha"
-                                      << "echo"
-                                      << "golf"
-                                      << "quebec"
-                                      << "foxtrot"
-                                      << "india"
-                                      << "romeo"
-                                      << "november"
-                                      << "oskar"
-                                      << "zulu"
-                                      << "kilo"
-                                      << "whiskey"
-                                      << "mike"
-                                      << "papa"
-                                      << "sierra"
-                                      << "xray"
-                                      << "viktor")
-                                  << (QStringList()
-                                      << "zulu"
-                                      << "yankee"
-                                      << "xray"
-                                      << "whiskey"
-                                      << "viktor"
-                                      << "uniform"
-                                      << "tango"
-                                      << "sierra"
-                                      << "romeo"
-                                      << "quebec"
-                                      << "papa"
-                                      << "oskar"
-                                      << "november"
-                                      << "mike"
-                                      << "lima"
-                                      << "kilo"
-                                      << "juliet"
-                                      << "india"
-                                      << "hotel"
-                                      << "golf"
-                                      << "foxtrot"
-                                      << "echo"
-                                      << "delta"
-                                      << "charlie"
-                                      << "bravo"
-                                      << "alpha");
-    QTest::newRow("flat ascending") <<  static_cast<int>(Qt::AscendingOrder)
-                                 << (QStringList()
-                                     << "delta"
-                                     << "yankee"
-                                     << "bravo"
-                                     << "lima"
-                                     << "charlie"
-                                     << "juliet"
-                                     << "tango"
-                                     << "hotel"
-                                     << "uniform"
-                                     << "alpha"
-                                     << "echo"
-                                     << "golf"
-                                     << "quebec"
-                                     << "foxtrot"
-                                     << "india"
-                                     << "romeo"
-                                     << "november"
-                                     << "oskar"
-                                     << "zulu"
-                                     << "kilo"
-                                     << "whiskey"
-                                     << "mike"
-                                     << "papa"
-                                     << "sierra"
-                                     << "xray"
-                                     << "viktor")
-                                 << (QStringList()
-                                     << "alpha"
-                                     << "bravo"
-                                     << "charlie"
-                                     << "delta"
-                                     << "echo"
-                                     << "foxtrot"
-                                     << "golf"
-                                     << "hotel"
-                                     << "india"
-                                     << "juliet"
-                                     << "kilo"
-                                     << "lima"
-                                     << "mike"
-                                     << "november"
-                                     << "oskar"
-                                     << "papa"
-                                     << "quebec"
-                                     << "romeo"
-                                     << "sierra"
-                                     << "tango"
-                                     << "uniform"
-                                     << "viktor"
-                                     << "whiskey"
-                                     << "xray"
-                                     << "yankee"
-                                     << "zulu");
-    QStringList list;
-    for (int i=1000; i < 2000; ++i)
-        list.append(QString("Number: %1").arg(i));
-    QTest::newRow("large set ascending") <<  static_cast<int>(Qt::AscendingOrder) << list << list;
-}
-
-void tst_QStandardItemModel::sort()
-{
-    QFETCH(int, sortOrder);
-    QFETCH(QStringList, initial);
-    QFETCH(QStringList, expected);
-    // prepare model
-    QStandardItemModel model;
-    QVERIFY(model.insertRows(0, initial.count(), QModelIndex()));
-    QCOMPARE(model.rowCount(QModelIndex()), initial.count());
-    model.insertColumns(0, 1, QModelIndex());
-    QCOMPARE(model.columnCount(QModelIndex()), 1);
-    for (int row = 0; row < model.rowCount(QModelIndex()); ++row) {
-        QModelIndex index = model.index(row, 0, QModelIndex());
-        model.setData(index, initial.at(row), Qt::DisplayRole);
-    }
-
-    QSignalSpy layoutAboutToBeChangedSpy(
-        &model, SIGNAL(layoutAboutToBeChanged()));
-    QSignalSpy layoutChangedSpy(
-        &model, SIGNAL(layoutChanged()));
-
-    // sort
-    model.sort(0, static_cast<Qt::SortOrder>(sortOrder));
-
-    QCOMPARE(layoutAboutToBeChangedSpy.count(), 1);
-    QCOMPARE(layoutChangedSpy.count(), 1);
-
-    // make sure the model is sorted
-    for (int row = 0; row < model.rowCount(QModelIndex()); ++row) {
-        QModelIndex index = model.index(row, 0, QModelIndex());
-        QCOMPARE(model.data(index, Qt::DisplayRole).toString(), expected.at(row));
-    }
-}
-
-void tst_QStandardItemModel::sortRole_data()
-{
-    QTest::addColumn<QStringList>("initialText");
-    QTest::addColumn<QVariantList>("initialData");
-    QTest::addColumn<int>("sortRole");
-    QTest::addColumn<int>("sortOrder");
-    QTest::addColumn<QStringList>("expectedText");
-    QTest::addColumn<QVariantList>("expectedData");
-
-    QTest::newRow("sort ascending with Qt::DisplayRole")
-        << (QStringList() << "b" << "a" << "c")
-        << (QVariantList() << 2 << 3 << 1)
-        << static_cast<int>(Qt::DisplayRole)
-        << static_cast<int>(Qt::AscendingOrder)
-        << (QStringList() << "a" << "b" << "c")
-        << (QVariantList() << 3 << 2 << 1);
-    QTest::newRow("sort ascending with Qt::UserRole")
-        << (QStringList() << "a" << "b" << "c")
-        << (QVariantList() << 3 << 2 << 1)
-        << static_cast<int>(Qt::UserRole)
-        << static_cast<int>(Qt::AscendingOrder)
-        << (QStringList() << "c" << "b" << "a")
-        << (QVariantList() << 1 << 2 << 3);
-}
-
-void tst_QStandardItemModel::sortRole()
-{
-    QFETCH(QStringList, initialText);
-    QFETCH(QVariantList, initialData);
-    QFETCH(int, sortRole);
-    QFETCH(int, sortOrder);
-    QFETCH(QStringList, expectedText);
-    QFETCH(QVariantList, expectedData);
-
-    QStandardItemModel model;
-    for (int i = 0; i < initialText.count(); ++i) {
-        QStandardItem *item = new QStandardItem;
-        item->setText(initialText.at(i));
-        item->setData(initialData.at(i), Qt::UserRole);
-        model.appendRow(item);
-    }
-    model.setSortRole(sortRole);
-    model.sort(0, static_cast<Qt::SortOrder>(sortOrder));
-    for (int i = 0; i < expectedText.count(); ++i) {
-        QStandardItem *item = model.item(i);
-        QCOMPARE(item->text(), expectedText.at(i));
-        QCOMPARE(item->data(Qt::UserRole), expectedData.at(i));
-    }
-}
-
-void tst_QStandardItemModel::findItems()
-{
-    QStandardItemModel model;
-    model.appendRow(new QStandardItem(QLatin1String("foo")));
-    model.appendRow(new QStandardItem(QLatin1String("bar")));
-    model.item(1)->appendRow(new QStandardItem(QLatin1String("foo")));
-    QList<QStandardItem*> matches;
-    matches = model.findItems(QLatin1String("foo"), Qt::MatchExactly|Qt::MatchRecursive, 0);
-    QCOMPARE(matches.count(), 2);
-    matches = model.findItems(QLatin1String("foo"), Qt::MatchExactly, 0);
-    QCOMPARE(matches.count(), 1);
-    matches = model.findItems(QLatin1String("food"), Qt::MatchExactly|Qt::MatchRecursive, 0);
-    QCOMPARE(matches.count(), 0);
-    matches = model.findItems(QLatin1String("foo"), Qt::MatchExactly|Qt::MatchRecursive, -1);
-    QCOMPARE(matches.count(), 0);
-    matches = model.findItems(QLatin1String("foo"), Qt::MatchExactly|Qt::MatchRecursive, 1);
-    QCOMPARE(matches.count(), 0);
-}
-
-void tst_QStandardItemModel::getSetHeaderItem()
-{
-    QStandardItemModel model;
-
-    QCOMPARE(model.horizontalHeaderItem(0), static_cast<QStandardItem*>(0));
-    QStandardItem *hheader = new QStandardItem();
-    model.setHorizontalHeaderItem(0, hheader);
-    QCOMPARE(model.columnCount(), 1);
-    QCOMPARE(model.horizontalHeaderItem(0), hheader);
-    QCOMPARE(hheader->model(), &model);
-    model.setHorizontalHeaderItem(0, 0);
-    QCOMPARE(model.horizontalHeaderItem(0), static_cast<QStandardItem*>(0));
-
-    QCOMPARE(model.verticalHeaderItem(0), static_cast<QStandardItem*>(0));
-    QStandardItem *vheader = new QStandardItem();
-    model.setVerticalHeaderItem(0, vheader);
-    QCOMPARE(model.rowCount(), 1);
-    QCOMPARE(model.verticalHeaderItem(0), vheader);
-    QCOMPARE(vheader->model(), &model);
-    model.setVerticalHeaderItem(0, 0);
-    QCOMPARE(model.verticalHeaderItem(0), static_cast<QStandardItem*>(0));
-}
-
-void tst_QStandardItemModel::indexFromItem()
-{
-    QStandardItemModel model;
-
-    QCOMPARE(model.indexFromItem(model.invisibleRootItem()), QModelIndex());
-
-    QStandardItem *item = new QStandardItem;
-    model.setItem(10, 20, item);
-    QCOMPARE(item->model(), &model);
-    QModelIndex itemIndex = model.indexFromItem(item);
-    QVERIFY(itemIndex.isValid());
-    QCOMPARE(itemIndex.row(), 10);
-    QCOMPARE(itemIndex.column(), 20);
-    QCOMPARE(itemIndex.parent(), QModelIndex());
-    QCOMPARE(itemIndex.model(), (const QAbstractItemModel*)(&model));
-
-    QStandardItem *child = new QStandardItem;
-    item->setChild(4, 2, child);
-    QModelIndex childIndex = model.indexFromItem(child);
-    QVERIFY(childIndex.isValid());
-    QCOMPARE(childIndex.row(), 4);
-    QCOMPARE(childIndex.column(), 2);
-    QCOMPARE(childIndex.parent(), itemIndex);
-
-    QStandardItem *dummy = new QStandardItem;
-    QModelIndex noSuchIndex = model.indexFromItem(dummy);
-    QVERIFY(!noSuchIndex.isValid());
-    delete dummy;
-
-    noSuchIndex = model.indexFromItem(0);
-    QVERIFY(!noSuchIndex.isValid());
-}
-
-void tst_QStandardItemModel::itemFromIndex()
-{
-    QStandardItemModel model;
-
-    QCOMPARE(model.itemFromIndex(QModelIndex()), (QStandardItem*)0);
-
-    QStandardItem *item = new QStandardItem;
-    model.setItem(10, 20, item);
-    QModelIndex itemIndex = model.index(10, 20, QModelIndex());
-    QVERIFY(itemIndex.isValid());
-    QCOMPARE(model.itemFromIndex(itemIndex), item);
-
-    QStandardItem *child = new QStandardItem;
-    item->setChild(4, 2, child);
-    QModelIndex childIndex = model.index(4, 2, itemIndex);
-    QVERIFY(childIndex.isValid());
-    QCOMPARE(model.itemFromIndex(childIndex), child);
-
-    QModelIndex noSuchIndex = model.index(99, 99, itemIndex);
-    QVERIFY(!noSuchIndex.isValid());
-}
-
-class CustomItem : public QStandardItem
-{
-public:
-    CustomItem() : QStandardItem() { }
-    ~CustomItem() { }
-    int type() const {
-        return UserType;
-    }
-    QStandardItem *clone() const {
-        return new CustomItem;
-    }
-};
-
-void tst_QStandardItemModel::getSetItemPrototype()
-{
-    QStandardItemModel model;
-    QCOMPARE(model.itemPrototype(), static_cast<const QStandardItem*>(0));
-
-    const CustomItem *proto = new CustomItem;
-    model.setItemPrototype(proto);
-    QCOMPARE(model.itemPrototype(), (const QStandardItem*)proto);
-
-    model.setRowCount(1);
-    model.setColumnCount(1);
-    QModelIndex index = model.index(0, 0, QModelIndex());
-    model.setData(index, "foo");
-    QStandardItem *item = model.itemFromIndex(index);
-    QVERIFY(item != 0);
-    QCOMPARE(item->type(), static_cast<int>(QStandardItem::UserType));
-
-    model.setItemPrototype(0);
-    QCOMPARE(model.itemPrototype(), static_cast<const QStandardItem*>(0));
-}
-
-void tst_QStandardItemModel::getSetItemData()
-{
-    QMap<int, QVariant> roles;
-    QLatin1String text("text");
-    roles.insert(Qt::DisplayRole, text);
-    QLatin1String statusTip("statusTip");
-    roles.insert(Qt::StatusTipRole, statusTip);
-    QLatin1String toolTip("toolTip");
-    roles.insert(Qt::ToolTipRole, toolTip);
-    QLatin1String whatsThis("whatsThis");
-    roles.insert(Qt::WhatsThisRole, whatsThis);
-    QSize sizeHint(64, 48);
-    roles.insert(Qt::SizeHintRole, sizeHint);
-    QFont font;
-    roles.insert(Qt::FontRole, font);
-    Qt::Alignment textAlignment(Qt::AlignLeft|Qt::AlignVCenter);
-    roles.insert(Qt::TextAlignmentRole, int(textAlignment));
-    QColor backgroundColor(Qt::blue);
-    roles.insert(Qt::BackgroundRole, backgroundColor);
-    QColor textColor(Qt::green);
-    roles.insert(Qt::TextColorRole, textColor);
-    Qt::CheckState checkState(Qt::PartiallyChecked);
-    roles.insert(Qt::CheckStateRole, int(checkState));
-    QLatin1String accessibleText("accessibleText");
-    roles.insert(Qt::AccessibleTextRole, accessibleText);
-    QLatin1String accessibleDescription("accessibleDescription");
-    roles.insert(Qt::AccessibleDescriptionRole, accessibleDescription);
-
-    QStandardItemModel model;
-    model.insertRows(0, 1);
-    model.insertColumns(0, 1);
-    QModelIndex idx = model.index(0, 0, QModelIndex());
-
-    QSignalSpy modelDataChangedSpy(
-         &model, SIGNAL(dataChanged(const QModelIndex&, const QModelIndex&)));
-    QVERIFY(model.setItemData(idx, roles));
-    QCOMPARE(modelDataChangedSpy.count(), 1);
-    QVERIFY(model.setItemData(idx, roles));
-    QCOMPARE(modelDataChangedSpy.count(), 1); //it was already changed once
-    QCOMPARE(model.itemData(idx), roles);
-}
-
-void tst_QStandardItemModel::setHeaderLabels_data()
-{
-    QTest::addColumn<int>("rows");
-    QTest::addColumn<int>("columns");
-    QTest::addColumn<int>("orientation");
-    QTest::addColumn<QStringList>("labels");
-    QTest::addColumn<QStringList>("expectedLabels");
-
-    QTest::newRow("horizontal labels")
-        << 1
-        << 4
-        << int(Qt::Horizontal)
-        << (QStringList() << "a" << "b" << "c" << "d")
-        << (QStringList() << "a" << "b" << "c" << "d");
-    QTest::newRow("vertical labels")
-        << 4
-        << 1
-        << int(Qt::Vertical)
-        << (QStringList() << "a" << "b" << "c" << "d")
-        << (QStringList() << "a" << "b" << "c" << "d");
-    QTest::newRow("too few (horizontal)")
-        << 1
-        << 4
-        << int(Qt::Horizontal)
-        << (QStringList() << "a" << "b")
-        << (QStringList() << "a" << "b" << "3" << "4");
-    QTest::newRow("too few (vertical)")
-        << 4
-        << 1
-        << int(Qt::Vertical)
-        << (QStringList() << "a" << "b")
-        << (QStringList() << "a" << "b" << "3" << "4");
-    QTest::newRow("too many (horizontal)")
-        << 1
-        << 2
-        << int(Qt::Horizontal)
-        << (QStringList() << "a" << "b" << "c" << "d")
-        << (QStringList() << "a" << "b" << "c" << "d");
-    QTest::newRow("too many (vertical)")
-        << 2
-        << 1
-        << int(Qt::Vertical)
-        << (QStringList() << "a" << "b" << "c" << "d")
-        << (QStringList() << "a" << "b" << "c" << "d");
-}
-
-void tst_QStandardItemModel::setHeaderLabels()
-{
-    QFETCH(int, rows);
-    QFETCH(int, columns);
-    QFETCH(int, orientation);
-    QFETCH(QStringList, labels);
-    QFETCH(QStringList, expectedLabels);
-    QStandardItemModel model(rows, columns);
-    QSignalSpy columnsInsertedSpy(
-        &model, SIGNAL(columnsInserted(QModelIndex,int,int)));
-    QSignalSpy rowsInsertedSpy(
-        &model, SIGNAL(rowsInserted(QModelIndex,int,int)));
-    if (orientation == Qt::Horizontal)
-        model.setHorizontalHeaderLabels(labels);
-    else
-        model.setVerticalHeaderLabels(labels);
-    for (int i = 0; i < expectedLabels.count(); ++i)
-        QCOMPARE(model.headerData(i, Qt::Orientation(orientation)).toString(), expectedLabels.at(i));
-    QCOMPARE(columnsInsertedSpy.count(),
-             (orientation == Qt::Vertical) ? 0 : labels.count() > columns);
-    QCOMPARE(rowsInsertedSpy.count(),
-             (orientation == Qt::Horizontal) ? 0 : labels.count() > rows);
-}
-
-void tst_QStandardItemModel::itemDataChanged()
-{
-    QStandardItemModel model(6, 4);
-    QStandardItem item;
-    QSignalSpy dataChangedSpy(
-        &model, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)));
-    QSignalSpy itemChangedSpy(
-        &model, SIGNAL(itemChanged(QStandardItem *)));
-
-    model.setItem(0, &item);
-    QCOMPARE(dataChangedSpy.count(), 1);
-    QCOMPARE(itemChangedSpy.count(), 1);
-    QModelIndex index = model.indexFromItem(&item);
-    QList<QVariant> args;
-    args = dataChangedSpy.takeFirst();
-    QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), index);
-    QCOMPARE(qvariant_cast<QModelIndex>(args.at(1)), index);
-    args = itemChangedSpy.takeFirst();
-    QCOMPARE(qvariant_cast<QStandardItem*>(args.at(0)), &item);
-
-    item.setData(QLatin1String("foo"), Qt::DisplayRole);
-    QCOMPARE(dataChangedSpy.count(), 1);
-    QCOMPARE(itemChangedSpy.count(), 1);
-    args = dataChangedSpy.takeFirst();
-    QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), index);
-    QCOMPARE(qvariant_cast<QModelIndex>(args.at(1)), index);
-    args = itemChangedSpy.takeFirst();
-    QCOMPARE(qvariant_cast<QStandardItem*>(args.at(0)), &item);
-
-    item.setData(item.data(Qt::DisplayRole), Qt::DisplayRole);
-    QCOMPARE(dataChangedSpy.count(), 0);
-    QCOMPARE(itemChangedSpy.count(), 0);
-
-    item.setFlags(Qt::ItemIsEnabled);
-    QCOMPARE(dataChangedSpy.count(), 1);
-    QCOMPARE(itemChangedSpy.count(), 1);
-    args = dataChangedSpy.takeFirst();
-    QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), index);
-    QCOMPARE(qvariant_cast<QModelIndex>(args.at(1)), index);
-    args = itemChangedSpy.takeFirst();
-    QCOMPARE(qvariant_cast<QStandardItem*>(args.at(0)), &item);
-
-    item.setFlags(item.flags());
-    QCOMPARE(dataChangedSpy.count(), 0);
-    QCOMPARE(itemChangedSpy.count(), 0);
-}
-
-void tst_QStandardItemModel::takeHeaderItem()
-{
-    QStandardItemModel model;
-    // set header items
-    QStandardItem *hheader = new QStandardItem();
-    model.setHorizontalHeaderItem(0, hheader);
-    QStandardItem *vheader = new QStandardItem();
-    model.setVerticalHeaderItem(0, vheader);
-    // take header items
-    QCOMPARE(model.takeHorizontalHeaderItem(0), hheader);
-    QCOMPARE(model.takeVerticalHeaderItem(0), vheader);
-    QCOMPARE(hheader->model(), static_cast<QStandardItemModel*>(0));
-    QCOMPARE(vheader->model(), static_cast<QStandardItemModel*>(0));
-    QCOMPARE(model.takeHorizontalHeaderItem(0), static_cast<QStandardItem*>(0));
-    QCOMPARE(model.takeVerticalHeaderItem(0), static_cast<QStandardItem*>(0));
-    delete hheader;
-    delete vheader;
-}
-
-void tst_QStandardItemModel::useCase1()
-{
-    const int rows = 5;
-    const int columns = 8;
-    QStandardItemModel model(rows, columns);
-    for (int i = 0; i < model.rowCount(); ++i) {
-        for (int j = 0; j < model.columnCount(); ++j) {
-            QCOMPARE(model.item(i, j), static_cast<QStandardItem*>(0));
-
-            QStandardItem *item = new QStandardItem();
-            model.setItem(i, j, item);
-            QCOMPARE(item->row(), i);
-            QCOMPARE(item->column(), j);
-            QCOMPARE(item->model(), &model);
-
-            QModelIndex index = model.indexFromItem(item);
-            QCOMPARE(index, model.index(i, j, QModelIndex()));
-            QStandardItem *sameItem = model.itemFromIndex(index);
-            QCOMPARE(sameItem, item);
-        }
-    }
-}
-
-static void createChildren(QStandardItemModel *model, QStandardItem *parent, int level)
-{
-    if (level > 4)
-        return;
-    for (int i = 0; i < 4; ++i) {
-        QCOMPARE(parent->rowCount(), i);
-        parent->appendRow(QList<QStandardItem*>());
-        for (int j = 0; j < parent->columnCount(); ++j) {
-            QStandardItem *item = new QStandardItem();
-            parent->setChild(i, j, item);
-            QCOMPARE(item->row(), i);
-            QCOMPARE(item->column(), j);
-
-            QModelIndex parentIndex = model->indexFromItem(parent);
-            QModelIndex index = model->indexFromItem(item);
-            QCOMPARE(index, model->index(i, j, parentIndex));
-            QStandardItem *theItem = model->itemFromIndex(index);
-            QCOMPARE(theItem, item);
-            QStandardItem *theParent = model->itemFromIndex(parentIndex);
-            QCOMPARE(theParent, (level == 0) ? (QStandardItem*)0 : parent);
-        }
-
-        {
-            QStandardItem *item = parent->child(i);
-            item->setColumnCount(parent->columnCount());
-            createChildren(model, item, level + 1);
-        }
-    }
-}
-
-void tst_QStandardItemModel::useCase2()
-{
-    QStandardItemModel model;
-    model.setColumnCount(2);
-    createChildren(&model, model.invisibleRootItem(), 0);
-}
-
-void tst_QStandardItemModel::useCase3()
-{
-    // create the tree structure first
-    QStandardItem *childItem = 0;
-    for (int i = 0; i < 100; ++i) {
-        QStandardItem *item = new QStandardItem(QString("item %0").arg(i));
-        if (childItem)
-            item->appendRow(childItem);
-        childItem = item;
-    }
-
-    // add to model as last step
-    QStandardItemModel model;
-    model.appendRow(childItem);
-
-    // make sure each item has the correct model and parent
-    QStandardItem *parentItem = 0;
-    while (childItem) {
-        QCOMPARE(childItem->model(), &model);
-        QCOMPARE(childItem->parent(), parentItem);
-        parentItem = childItem;
-        childItem = childItem->child(0);
-    }
-
-    // take the item, make sure model is set to 0, but that parents are the same
-    childItem = model.takeItem(0);
-    {
-        parentItem = 0;
-        QStandardItem *item = childItem;
-        while (item) {
-            QCOMPARE(item->model(), static_cast<QStandardItemModel*>(0));
-            QCOMPARE(item->parent(), parentItem);
-            parentItem = item;
-            item = item->child(0);
-        }
-    }
-    delete childItem;
-}
-
-void tst_QStandardItemModel::rootItemFlags()
-{
-    QStandardItemModel model(6, 4);
-    QCOMPARE(model.invisibleRootItem()->flags() , model.flags(QModelIndex()));
-    QCOMPARE(model.invisibleRootItem()->flags() , Qt::ItemIsDropEnabled);
-
-    Qt::ItemFlags f = Qt::ItemIsDropEnabled | Qt::ItemIsEnabled;
-    model.invisibleRootItem()->setFlags(f);
-    QCOMPARE(model.invisibleRootItem()->flags() , f);
-    QCOMPARE(model.invisibleRootItem()->flags() , model.flags(QModelIndex()));
-
-#ifndef QT_NO_DRAGANDDROP
-    model.invisibleRootItem()->setDropEnabled(false);
-#endif
-    QCOMPARE(model.invisibleRootItem()->flags() , Qt::ItemIsEnabled);
-    QCOMPARE(model.invisibleRootItem()->flags() , model.flags(QModelIndex()));
-}
-
-bool tst_QStandardItemModel::compareModels(QStandardItemModel *model1, QStandardItemModel *model2)
-{
-    return compareItems(model1->invisibleRootItem(), model2->invisibleRootItem());
-}
-
-bool tst_QStandardItemModel::compareItems(QStandardItem *item1, QStandardItem *item2)
-{
-    if (!item1 && !item2)
-        return true;
-    if (!item1 || !item2)
-        return false;
-    if (item1->text() != item2->text()){
-        qDebug() << item1->text() << item2->text();
-        return false;
-    }
-    if (item1->rowCount() != item2->rowCount()) {
-  //      qDebug() << "RowCount" << item1->text() << item1->rowCount() << item2->rowCount();
-        return false;
-    }
-    if (item1->columnCount() != item2->columnCount()) {
-  //     qDebug() << "ColumnCount" << item1->text() << item1->columnCount() << item2->columnCount();
-        return false;
-    }
-    for (int row = 0; row < item1->columnCount(); row++)
-        for (int col = 0; col < item1->columnCount(); col++) {
-
-        if (!compareItems(item1->child(row, col), item2->child(row, col)))
-            return false;
-    }
-    return true;
-}
-
-static QStandardItem *itemFromText(QStandardItem *parent, const QString &text)
-{
-    QStandardItem *item = 0;
-    for(int i = 0; i < parent->columnCount(); i++)
-        for(int j = 0; j < parent->rowCount(); j++) {
-
-        QStandardItem *child = parent->child(j, i);
-
-        if(!child)
-            continue;
-
-        if (child->text() == text) {
-            if (item) {
-                return 0;
-            }
-            item = child;
-        }
-
-        QStandardItem *candidate = itemFromText(child, text);
-        if(candidate) {
-            if (item) {
-                return 0;
-            }
-            item = candidate;
-        }
-    }
-    return item;
-}
-
-#ifdef QT_BUILD_INTERNAL
-static QModelIndex indexFromText(QStandardItemModel *model, const QString &text)
-{
-    QStandardItem *item = itemFromText(model->invisibleRootItem(), text);
-    /*QVERIFY(item);*/
-    return model->indexFromItem(item);
-}
-
-
-struct FriendlyTreeView : public QTreeView
-{
-    friend class tst_QStandardItemModel;
-	Q_DECLARE_PRIVATE(QTreeView)
-};
-#endif
-
-void tst_QStandardItemModel::treeDragAndDrop()
-{
-#ifdef QT_BUILD_INTERNAL
-    const int nRow = 5;
-    const int nCol = 3;
-
-    QStandardItemModel model;
-    QStandardItemModel checkModel;
-
-    for (int i = 0; i < nRow; ++i) {
-        QList<QStandardItem *> colItems1;
-        for (int c = 0 ; c < nCol; c ++)
-            colItems1 << new QStandardItem(QString("item %1 - %0").arg(c).arg(i));
-        model.appendRow(colItems1);
-
-        for (int j = 0; j < nRow; ++j) {
-            QList<QStandardItem *> colItems2;
-            for (int c = 0 ; c < nCol; c ++)
-                colItems2 << new QStandardItem(QString("item %1/%2 - %0").arg(c).arg(i).arg(j));
-            colItems1.at(0)->appendRow(colItems2);
-
-            for (int k = 0; k < nRow; ++k) {
-                QList<QStandardItem *> colItems3;
-                for (int c = 0 ; c < nCol; c ++)
-                    colItems3 << new QStandardItem(QString("item %1/%2/%3 - %0").arg(c).arg(i).arg(j).arg(k));
-                colItems2.at(0)->appendRow(colItems3);
-            }
-        }
-    }
-
-    for (int i = 0; i < nRow; ++i) {
-        QList<QStandardItem *> colItems1;
-        for (int c = 0 ; c < nCol; c ++)
-            colItems1 << new QStandardItem(QString("item %1 - %0").arg(c).arg(i));
-        checkModel.appendRow(colItems1);
-
-        for (int j = 0; j < nRow; ++j) {
-            QList<QStandardItem *> colItems2;
-            for (int c = 0 ; c < nCol; c ++)
-                colItems2 << new QStandardItem(QString("item %1/%2 - %0").arg(c).arg(i).arg(j));
-            colItems1.at(0)->appendRow(colItems2);
-
-            for (int k = 0; k < nRow; ++k) {
-                QList<QStandardItem *> colItems3;
-                for (int c = 0 ; c < nCol; c ++)
-                    colItems3 << new QStandardItem(QString("item %1/%2/%3 - %0").arg(c).arg(i).arg(j).arg(k));
-                colItems2.at(0)->appendRow(colItems3);
-            }
-        }
-    }
-
-    QVERIFY(compareModels(&model, &checkModel));
-
-    FriendlyTreeView  view;
-    view.setModel(&model);
-    view.expandAll();
-    view.show();
-#ifndef QT_NO_DRAGANDDROP
-    view.setDragDropMode(QAbstractItemView::InternalMove);
-#endif
-    view.setSelectionMode(QAbstractItemView::ExtendedSelection);
-
-    QItemSelectionModel *selection = view.selectionModel();
-
-    //
-    // step1  drag  "item 1" and "item 2"   into "item 4"
-    //
-    {
-        selection->clear();
-        selection->select(QItemSelection(indexFromText(&model, QString("item 1 - 0")),
-                                        indexFromText(&model, QString("item 1 - %0").arg(nCol-1))), QItemSelectionModel::Select);
-
-        selection->select(QItemSelection(indexFromText(&model, QString("item 2 - 0")),
-                                        indexFromText(&model, QString("item 2 - %0").arg(nCol-1))), QItemSelectionModel::Select);
-
-        //code based from QAbstractItemView::startDrag and QAbstractItemView::dropEvent
-        QModelIndexList indexes = view.selectedIndexes();
-        QMimeData *data = model.mimeData(indexes);
-        if(model.dropMimeData(data, Qt::MoveAction, 0, 0, indexFromText(&model, "item 4 - 0")))
-            view.d_func()->clearOrRemove();
-        delete data;
-
-        QVERIFY(!compareModels(&model, &checkModel)); //the model must be different at this point
-        QStandardItem *item4 = itemFromText(checkModel.invisibleRootItem(), "item 4 - 0");
-        item4->insertRow(0, checkModel.takeRow(1));
-        item4->insertRow(1, checkModel.takeRow(1));
-        QVERIFY(compareModels(&model, &checkModel));
-    }
-
-    //
-    // step2  drag  "item 3" and "item 3/0"   into "item 4"
-    //
-    {
-        selection->clear();
-        selection->select(QItemSelection(indexFromText(&model, QString("item 3 - 0")),
-                                          indexFromText(&model, QString("item 3 - %0").arg(nCol-1))), QItemSelectionModel::Select);
-
-        selection->select(QItemSelection(indexFromText(&model, QString("item 3/0 - 0")),
-                                        indexFromText(&model, QString("item 3/0 - %0").arg(nCol-1))), QItemSelectionModel::Select);
-
-        //code based from QAbstractItemView::startDrag and QAbstractItemView::dropEvent
-        QModelIndexList indexes = view.selectedIndexes();
-        QMimeData *data = model.mimeData(indexes);
-        if(model.dropMimeData(data, Qt::MoveAction, 0, 0, indexFromText(&model, "item 4 - 0")))
-        view.d_func()->clearOrRemove();
-        delete data;
-
-        QVERIFY(!compareModels(&model, &checkModel)); //the model must be different at this point
-        QStandardItem *item4 = itemFromText(checkModel.invisibleRootItem(), "item 4 - 0");
-        item4->insertRow(0, checkModel.takeRow(1));
-
-        QVERIFY(compareModels(&model, &checkModel));
-    }
-
-    //
-    // step2  drag  "item 3" and "item 3/0/2"   into "item 0/2"
-    // ( remember "item 3" is now the first child of "item 4")
-    //
-    {
-        selection->clear();
-        selection->select(QItemSelection(indexFromText(&model, QString("item 3 - 0")),
-                                         indexFromText(&model, QString("item 3 - %0").arg(nCol-1))), QItemSelectionModel::Select);
-
-        selection->select(QItemSelection(indexFromText(&model, QString("item 3/0/2 - 0")),
-                                        indexFromText(&model, QString("item 3/0/2 - %0").arg(nCol-1))), QItemSelectionModel::Select);
-
-        //code based from QAbstractItemView::startDrag and QAbstractItemView::dropEvent
-        QModelIndexList indexes = view.selectedIndexes();
-        QMimeData *data = model.mimeData(indexes);
-        if(model.dropMimeData(data, Qt::MoveAction, 0, 0, indexFromText(&model, "item 0/2 - 0")))
-        view.d_func()->clearOrRemove();
-        delete data;
-
-        QVERIFY(!compareModels(&model, &checkModel)); //the model must be different at this point
-        QStandardItem *item02 = itemFromText(checkModel.invisibleRootItem(), "item 0/2 - 0");
-        QStandardItem *item4 = itemFromText(checkModel.invisibleRootItem(), "item 4 - 0");
-        item02->insertRow(0, item4->takeRow(0));
-
-        QVERIFY(compareModels(&model, &checkModel));
-    }
-#endif
-}
-
-void tst_QStandardItemModel::removeRowsAndColumns()
-{
-#define VERIFY_MODEL \
-    for (int c = 0; c < col_list.count(); c++) \
-        for (int r = 0; r < row_list.count(); r++) \
-            QCOMPARE(model.item(r,c)->text() , row_list[r] + "x" + col_list[c]);
-
-    QVector<QString> row_list = QString("1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20").split(',').toVector();
-    QVector<QString> col_list = row_list;
-    QStandardItemModel model;
-    for (int c = 0; c < col_list.count(); c++)
-        for (int r = 0; r < row_list.count(); r++)
-            model.setItem(r, c, new QStandardItem(row_list[r] + "x" + col_list[c]));
-    VERIFY_MODEL
-
-    row_list.remove(3);
-    model.removeRow(3);
-    VERIFY_MODEL
-
-    col_list.remove(5);
-    model.removeColumn(5);
-    VERIFY_MODEL
-
-    row_list.remove(2, 5);
-    model.removeRows(2, 5);
-    VERIFY_MODEL
-
-    col_list.remove(1, 6);
-    model.removeColumns(1, 6);
-    VERIFY_MODEL
-
-    QList<QStandardItem *> row_taken = model.takeRow(6);
-    QCOMPARE(row_taken.count(), col_list.count());
-    for (int c = 0; c < col_list.count(); c++)
-        QCOMPARE(row_taken[c]->text() , row_list[6] + "x" + col_list[c]);
-    row_list.remove(6);
-    VERIFY_MODEL
-
-    QList<QStandardItem *> col_taken = model.takeColumn(10);
-    QCOMPARE(col_taken.count(), row_list.count());
-    for (int r = 0; r < row_list.count(); r++)
-        QCOMPARE(col_taken[r]->text() , row_list[r] + "x" + col_list[10]);
-    col_list.remove(10);
-    VERIFY_MODEL
-}
-
-void tst_QStandardItemModel::itemRoleNames()
-{
-    QVector<QString> row_list = QString("1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20").split(',').toVector();
-    QVector<QString> col_list = row_list;
-    QStandardItemModel model;
-    for (int c = 0; c < col_list.count(); c++)
-        for (int r = 0; r < row_list.count(); r++)
-            model.setItem(r, c, new QStandardItem(row_list[r] + "x" + col_list[c]));
-    VERIFY_MODEL
-
-    QHash<int, QByteArray> newRoleNames;
-    newRoleNames.insert(Qt::DisplayRole, "Name");
-    newRoleNames.insert(Qt::DecorationRole, "Avatar");
-    model.setItemRoleNames(newRoleNames);
-    QCOMPARE(model.roleNames(), newRoleNames);
-    VERIFY_MODEL
-}
-
-
-QTEST_MAIN(tst_QStandardItemModel)
-#include "tst_qstandarditemmodel.moc"