diff --git a/examples/opengl/pbuffers/cube.cpp b/examples/opengl/pbuffers/cube.cpp
index e384078..91024fc 100644
--- a/examples/opengl/pbuffers/cube.cpp
+++ b/examples/opengl/pbuffers/cube.cpp
@@ -121,24 +121,6 @@ void Tile::setColors(GLfloat colorArray[4][4])
     geom->setColors(start, colorArray);
 }
 
-static inline void qMultMatrix(const QMatrix4x4 &mat)
-{
-    if (sizeof(qreal) == sizeof(GLfloat))
-        glMultMatrixf((GLfloat*)mat.constData());
-#ifndef QT_OPENGL_ES
-    else if (sizeof(qreal) == sizeof(GLdouble))
-        glMultMatrixd((GLdouble*)mat.constData());
-#endif
-    else
-    {
-        GLfloat fmat[16];
-        qreal const *r = mat.constData();
-        for (int i = 0; i < 16; ++i)
-            fmat[i] = r[i];
-        glMultMatrixf(fmat);
-    }
-}
-
 void Tile::draw() const
 {
     QMatrix4x4 mat;
@@ -146,7 +128,7 @@ void Tile::draw() const
     mat.rotate(orientation);
     glMatrixMode(GL_MODELVIEW);
     glPushMatrix();
-    qMultMatrix(mat);
+    glMultMatrixf(mat.constData());
     glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, faceColor);
     glDrawElements(GL_TRIANGLES, count, GL_UNSIGNED_SHORT, geom->indices() + start);
     glPopMatrix();
diff --git a/examples/opengl/shared/qtlogo.cpp b/examples/opengl/shared/qtlogo.cpp
index 1a3b94e..d3ccb7a 100644
--- a/examples/opengl/shared/qtlogo.cpp
+++ b/examples/opengl/shared/qtlogo.cpp
@@ -173,29 +173,11 @@ void Patch::translate(const QVector3D &t)
     mat.translate(t);
 }
 
-static inline void qMultMatrix(const QMatrix4x4 &mat)
-{
-    if (sizeof(qreal) == sizeof(GLfloat))
-        glMultMatrixf((GLfloat*)mat.constData());
-#ifndef QT_OPENGL_ES
-    else if (sizeof(qreal) == sizeof(GLdouble))
-        glMultMatrixd((GLdouble*)mat.constData());
-#endif
-    else
-    {
-        GLfloat fmat[16];
-        qreal const *r = mat.constData();
-        for (int i = 0; i < 16; ++i)
-            fmat[i] = r[i];
-        glMultMatrixf(fmat);
-    }
-}
-
 //! [2]
 void Patch::draw() const
 {
     glPushMatrix();
-    qMultMatrix(mat);
+    glMultMatrixf(mat.constData());
     glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, faceColor);
 
     const GLushort *indices = geom->faces.constData();
diff --git a/examples/widgets/graphicsview/boxes/scene.cpp b/examples/widgets/graphicsview/boxes/scene.cpp
index 5fb43d8..cf0b021 100644
--- a/examples/widgets/graphicsview/boxes/scene.cpp
+++ b/examples/widgets/graphicsview/boxes/scene.cpp
@@ -655,22 +655,12 @@ static void loadMatrix(const QMatrix4x4& m)
 {
     // static to prevent glLoadMatrixf to fail on certain drivers
     static GLfloat mat[16];
-    const qreal *data = m.constData();
+    const float *data = m.constData();
     for (int index = 0; index < 16; ++index)
         mat[index] = data[index];
     glLoadMatrixf(mat);
 }
 
-static void multMatrix(const QMatrix4x4& m)
-{
-    // static to prevent glMultMatrixf to fail on certain drivers
-    static GLfloat mat[16];
-    const qreal *data = m.constData();
-    for (int index = 0; index < 16; ++index)
-        mat[index] = data[index];
-    glMultMatrixf(mat);
-}
-
 // If one of the boxes should not be rendered, set excludeBox to its index.
 // If the main box should not be rendered, set excludeBox to -1.
 void Scene::renderBoxes(const QMatrix4x4 &view, int excludeBox)
@@ -722,7 +712,7 @@ void Scene::renderBoxes(const QMatrix4x4 &view, int excludeBox)
         glPushMatrix();
         QMatrix4x4 m;
         m.rotate(m_trackBalls[1].rotation());
-        multMatrix(m);
+        glMultMatrixf(m.constData());
 
         glRotatef(360.0f * i / m_programs.size(), 0.0f, 0.0f, 1.0f);
         glTranslatef(2.0f, 0.0f, 0.0f);
@@ -755,7 +745,7 @@ void Scene::renderBoxes(const QMatrix4x4 &view, int excludeBox)
     if (-1 != excludeBox) {
         QMatrix4x4 m;
         m.rotate(m_trackBalls[0].rotation());
-        multMatrix(m);
+        glMultMatrixf(m.constData());
 
         if (glActiveTexture) {
             if (m_dynamicCubemap)
diff --git a/src/gui/math3d/qgenericmatrix.cpp b/src/gui/math3d/qgenericmatrix.cpp
index a05a47f..e0ae71d 100644
--- a/src/gui/math3d/qgenericmatrix.cpp
+++ b/src/gui/math3d/qgenericmatrix.cpp
@@ -273,7 +273,7 @@ QT_BEGIN_NAMESPACE
     \relates QGenericMatrix
 
     The QMatrix2x2 type defines a convenient instantiation of the
-    QGenericMatrix template for 2 columns, 2 rows, and qreal as
+    QGenericMatrix template for 2 columns, 2 rows, and float as
     the element type.
 */
 
@@ -282,7 +282,7 @@ QT_BEGIN_NAMESPACE
     \relates QGenericMatrix
 
     The QMatrix2x3 type defines a convenient instantiation of the
-    QGenericMatrix template for 2 columns, 3 rows, and qreal as
+    QGenericMatrix template for 2 columns, 3 rows, and float as
     the element type.
 */
 
@@ -291,7 +291,7 @@ QT_BEGIN_NAMESPACE
     \relates QGenericMatrix
 
     The QMatrix2x4 type defines a convenient instantiation of the
-    QGenericMatrix template for 2 columns, 4 rows, and qreal as
+    QGenericMatrix template for 2 columns, 4 rows, and float as
     the element type.
 */
 
@@ -300,7 +300,7 @@ QT_BEGIN_NAMESPACE
     \relates QGenericMatrix
 
     The QMatrix3x2 type defines a convenient instantiation of the
-    QGenericMatrix template for 3 columns, 2 rows, and qreal as
+    QGenericMatrix template for 3 columns, 2 rows, and float as
     the element type.
 */
 
@@ -309,7 +309,7 @@ QT_BEGIN_NAMESPACE
     \relates QGenericMatrix
 
     The QMatrix3x3 type defines a convenient instantiation of the
-    QGenericMatrix template for 3 columns, 3 rows, and qreal as
+    QGenericMatrix template for 3 columns, 3 rows, and float as
     the element type.
 */
 
@@ -318,7 +318,7 @@ QT_BEGIN_NAMESPACE
     \relates QGenericMatrix
 
     The QMatrix3x4 type defines a convenient instantiation of the
-    QGenericMatrix template for 3 columns, 4 rows, and qreal as
+    QGenericMatrix template for 3 columns, 4 rows, and float as
     the element type.
 */
 
@@ -327,7 +327,7 @@ QT_BEGIN_NAMESPACE
     \relates QGenericMatrix
 
     The QMatrix4x2 type defines a convenient instantiation of the
-    QGenericMatrix template for 4 columns, 2 rows, and qreal as
+    QGenericMatrix template for 4 columns, 2 rows, and float as
     the element type.
 */
 
@@ -336,7 +336,7 @@ QT_BEGIN_NAMESPACE
     \relates QGenericMatrix
 
     The QMatrix4x3 type defines a convenient instantiation of the
-    QGenericMatrix template for 4 columns, 3 rows, and qreal as
+    QGenericMatrix template for 4 columns, 3 rows, and float as
     the element type.
 */
 
diff --git a/src/gui/math3d/qgenericmatrix.h b/src/gui/math3d/qgenericmatrix.h
index b987ab2..cd98f09 100644
--- a/src/gui/math3d/qgenericmatrix.h
+++ b/src/gui/math3d/qgenericmatrix.h
@@ -336,14 +336,14 @@ Q_OUTOFLINE_TEMPLATE void QGenericMatrix<N, M, T>::copyDataTo(T *values) const
 }
 
 // Define aliases for the useful variants of QGenericMatrix.
-typedef QGenericMatrix<2, 2, qreal> QMatrix2x2;
-typedef QGenericMatrix<2, 3, qreal> QMatrix2x3;
-typedef QGenericMatrix<2, 4, qreal> QMatrix2x4;
-typedef QGenericMatrix<3, 2, qreal> QMatrix3x2;
-typedef QGenericMatrix<3, 3, qreal> QMatrix3x3;
-typedef QGenericMatrix<3, 4, qreal> QMatrix3x4;
-typedef QGenericMatrix<4, 2, qreal> QMatrix4x2;
-typedef QGenericMatrix<4, 3, qreal> QMatrix4x3;
+typedef QGenericMatrix<2, 2, float> QMatrix2x2;
+typedef QGenericMatrix<2, 3, float> QMatrix2x3;
+typedef QGenericMatrix<2, 4, float> QMatrix2x4;
+typedef QGenericMatrix<3, 2, float> QMatrix3x2;
+typedef QGenericMatrix<3, 3, float> QMatrix3x3;
+typedef QGenericMatrix<3, 4, float> QMatrix3x4;
+typedef QGenericMatrix<4, 2, float> QMatrix4x2;
+typedef QGenericMatrix<4, 3, float> QMatrix4x3;
 
 #ifndef QT_NO_DEBUG_STREAM
 
diff --git a/src/gui/math3d/qmatrix4x4.cpp b/src/gui/math3d/qmatrix4x4.cpp
index 76135f0..899939c 100644
--- a/src/gui/math3d/qmatrix4x4.cpp
+++ b/src/gui/math3d/qmatrix4x4.cpp
@@ -73,7 +73,7 @@ QT_BEGIN_NAMESPACE
     \sa QVector3D, QGenericMatrix
 */
 
-static const qreal inv_dist_to_plane = 1. / 1024.;
+static const float inv_dist_to_plane = 1.0f / 1024.0f;
 
 /*!
     \fn QMatrix4x4::QMatrix4x4()
@@ -93,7 +93,7 @@ static const qreal inv_dist_to_plane = 1. / 1024.;
 
     \sa copyDataTo(), optimize()
 */
-QMatrix4x4::QMatrix4x4(const qreal *values)
+QMatrix4x4::QMatrix4x4(const float *values)
 {
     for (int row = 0; row < 4; ++row)
         for (int col = 0; col < 4; ++col)
@@ -101,8 +101,17 @@ QMatrix4x4::QMatrix4x4(const qreal *values)
     flagBits = General;
 }
 
+// ###TODO This is temporary to get through the CI's revdep qtdeclarative tests. Remove it!
+QMatrix4x4::QMatrix4x4(const double *values)
+{
+    for (int row = 0; row < 4; ++row)
+        for (int col = 0; col < 4; ++col)
+            m[col][row] = float(values[row * 4 + col]);
+    flagBits = General;
+}
+
 /*!
-    \fn QMatrix4x4::QMatrix4x4(qreal m11, qreal m12, qreal m13, qreal m14, qreal m21, qreal m22, qreal m23, qreal m24, qreal m31, qreal m32, qreal m33, qreal m34, qreal m41, qreal m42, qreal m43, qreal m44)
+    \fn QMatrix4x4::QMatrix4x4(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44)
 
     Constructs a matrix from the 16 elements \a m11, \a m12, \a m13, \a m14,
     \a m21, \a m22, \a m23, \a m24, \a m31, \a m32, \a m33, \a m34,
@@ -118,7 +127,7 @@ QMatrix4x4::QMatrix4x4(const qreal *values)
 */
 
 /*!
-    \fn QMatrix4x4::QMatrix4x4(const QGenericMatrix<N, M, qreal>& matrix)
+    \fn QMatrix4x4::QMatrix4x4(const QGenericMatrix<N, M, float>& matrix)
 
     Constructs a 4x4 matrix from the left-most 4 columns and top-most
     4 rows of \a matrix.  If \a matrix has less than 4 columns or rows,
@@ -129,7 +138,7 @@ QMatrix4x4::QMatrix4x4(const qreal *values)
 */
 
 /*!
-    \fn QGenericMatrix<N, M, qreal> QMatrix4x4::toGenericMatrix() const
+    \fn QGenericMatrix<N, M, float> QMatrix4x4::toGenericMatrix() const
 
     Constructs a NxM generic matrix from the left-most N columns and
     top-most M rows of this 4x4 matrix.  If N or M is greater than 4,
@@ -138,7 +147,7 @@ QMatrix4x4::QMatrix4x4(const qreal *values)
 */
 
 /*!
-    \fn QMatrix4x4 qGenericMatrixToMatrix4x4(const QGenericMatrix<N, M, qreal>& matrix)
+    \fn QMatrix4x4 qGenericMatrixToMatrix4x4(const QGenericMatrix<N, M, float>& matrix)
     \relates QMatrix4x4
     \obsolete
 
@@ -151,7 +160,7 @@ QMatrix4x4::QMatrix4x4(const qreal *values)
 */
 
 /*!
-    \fn QGenericMatrix<N, M, qreal> qGenericMatrixFromMatrix4x4(const QMatrix4x4& matrix)
+    \fn QGenericMatrix<N, M, float> qGenericMatrixFromMatrix4x4(const QMatrix4x4& matrix)
     \relates QMatrix4x4
     \obsolete
 
@@ -166,7 +175,7 @@ QMatrix4x4::QMatrix4x4(const qreal *values)
 /*!
     \internal
 */
-QMatrix4x4::QMatrix4x4(const qreal *values, int cols, int rows)
+QMatrix4x4::QMatrix4x4(const float *values, int cols, int rows)
 {
     for (int col = 0; col < 4; ++col) {
         for (int row = 0; row < 4; ++row) {
@@ -246,7 +255,7 @@ QMatrix4x4::QMatrix4x4(const QTransform& transform)
 }
 
 /*!
-    \fn const qreal& QMatrix4x4::operator()(int row, int column) const
+    \fn const float& QMatrix4x4::operator()(int row, int column) const
 
     Returns a constant reference to the element at position
     (\a row, \a column) in this matrix.
@@ -255,7 +264,7 @@ QMatrix4x4::QMatrix4x4(const QTransform& transform)
 */
 
 /*!
-    \fn qreal& QMatrix4x4::operator()(int row, int column)
+    \fn float& QMatrix4x4::operator()(int row, int column)
 
     Returns a reference to the element at position (\a row, \a column)
     in this matrix so that the element can be assigned to.
@@ -312,12 +321,12 @@ QMatrix4x4::QMatrix4x4(const QTransform& transform)
 */
 
 /*!
-    \fn void QMatrix4x4::fill(qreal value)
+    \fn void QMatrix4x4::fill(float value)
 
     Fills all elements of this matrx with \a value.
 */
 
-static inline qreal matrixDet2(const qreal m[4][4], int col0, int col1, int row0, int row1)
+static inline double matrixDet2(const double m[4][4], int col0, int col1, int row0, int row1)
 {
     return m[col0][row0] * m[col1][row1] - m[col0][row1] * m[col1][row0];
 }
@@ -332,8 +341,8 @@ static inline qreal matrixDet2(const qreal m[4][4], int col0, int col1, int row0
 //     | A B C |
 // M = | D E F |   det(M) = A * (EI - HF) - B * (DI - GF) + C * (DH - GE)
 //     | G H I |
-static inline qreal matrixDet3
-    (const qreal m[4][4], int col0, int col1, int col2,
+static inline double matrixDet3
+    (const double m[4][4], int col0, int col1, int col2,
      int row0, int row1, int row2)
 {
     return m[col0][row0] * matrixDet2(m, col1, col2, row1, row2)
@@ -342,9 +351,9 @@ static inline qreal matrixDet3
 }
 
 // Calculate the determinant of a 4x4 matrix.
-static inline qreal matrixDet4(const qreal m[4][4])
+static inline double matrixDet4(const double m[4][4])
 {
-    qreal det;
+    double det;
     det  = m[0][0] * matrixDet3(m, 1, 2, 3, 1, 2, 3);
     det -= m[1][0] * matrixDet3(m, 0, 2, 3, 1, 2, 3);
     det += m[2][0] * matrixDet3(m, 0, 1, 3, 1, 2, 3);
@@ -352,18 +361,28 @@ static inline qreal matrixDet4(const qreal m[4][4])
     return det;
 }
 
+static inline void copyToDoubles(const float m[4][4], double mm[4][4])
+{
+    for (int i = 0; i < 4; ++i)
+        for (int j = 0; j < 4; ++j)
+            mm[i][j] = double(m[i][j]);
+}
+
 /*!
     Returns the determinant of this matrix.
 */
-qreal QMatrix4x4::determinant() const
+double QMatrix4x4::determinant() const
 {
     if ((flagBits & ~(Translation | Rotation2D | Rotation)) == Identity)
-        return 1;
+        return 1.0;
+
+    double mm[4][4];
+    copyToDoubles(m, mm);
     if (flagBits < Rotation2D)
-        return m[0][0] * m[1][1] * m[2][2]; // Translation | Scale
+        return mm[0][0] * mm[1][1] * mm[2][2]; // Translation | Scale
     if (flagBits < Perspective)
-        return matrixDet3(m, 0, 1, 2, 0, 1, 2);
-    return matrixDet4(m);
+        return matrixDet3(mm, 0, 1, 2, 0, 1, 2);
+    return matrixDet4(mm);
 }
 
 /*!
@@ -420,7 +439,10 @@ QMatrix4x4 QMatrix4x4::inverted(bool *invertible) const
     } else if (flagBits < Perspective) {
         QMatrix4x4 inv(1); // The "1" says to not load the identity.
 
-        qreal det = matrixDet3(m, 0, 1, 2, 0, 1, 2);
+        double mm[4][4];
+        copyToDoubles(m, mm);
+
+        double det = matrixDet3(mm, 0, 1, 2, 0, 1, 2);
         if (det == 0.0f) {
             if (invertible)
                 *invertible = false;
@@ -428,17 +450,17 @@ QMatrix4x4 QMatrix4x4::inverted(bool *invertible) const
         }
         det = 1.0f / det;
 
-        inv.m[0][0] =  matrixDet2(m, 1, 2, 1, 2) * det;
-        inv.m[0][1] = -matrixDet2(m, 0, 2, 1, 2) * det;
-        inv.m[0][2] =  matrixDet2(m, 0, 1, 1, 2) * det;
+        inv.m[0][0] =  matrixDet2(mm, 1, 2, 1, 2) * det;
+        inv.m[0][1] = -matrixDet2(mm, 0, 2, 1, 2) * det;
+        inv.m[0][2] =  matrixDet2(mm, 0, 1, 1, 2) * det;
         inv.m[0][3] = 0;
-        inv.m[1][0] = -matrixDet2(m, 1, 2, 0, 2) * det;
-        inv.m[1][1] =  matrixDet2(m, 0, 2, 0, 2) * det;
-        inv.m[1][2] = -matrixDet2(m, 0, 1, 0, 2) * det;
+        inv.m[1][0] = -matrixDet2(mm, 1, 2, 0, 2) * det;
+        inv.m[1][1] =  matrixDet2(mm, 0, 2, 0, 2) * det;
+        inv.m[1][2] = -matrixDet2(mm, 0, 1, 0, 2) * det;
         inv.m[1][3] = 0;
-        inv.m[2][0] =  matrixDet2(m, 1, 2, 0, 1) * det;
-        inv.m[2][1] = -matrixDet2(m, 0, 2, 0, 1) * det;
-        inv.m[2][2] =  matrixDet2(m, 0, 1, 0, 1) * det;
+        inv.m[2][0] =  matrixDet2(mm, 1, 2, 0, 1) * det;
+        inv.m[2][1] = -matrixDet2(mm, 0, 2, 0, 1) * det;
+        inv.m[2][2] =  matrixDet2(mm, 0, 1, 0, 1) * det;
         inv.m[2][3] = 0;
         inv.m[3][0] = -inv.m[0][0] * m[3][0] - inv.m[1][0] * m[3][1] - inv.m[2][0] * m[3][2];
         inv.m[3][1] = -inv.m[0][1] * m[3][0] - inv.m[1][1] * m[3][1] - inv.m[2][1] * m[3][2];
@@ -453,7 +475,10 @@ QMatrix4x4 QMatrix4x4::inverted(bool *invertible) const
 
     QMatrix4x4 inv(1); // The "1" says to not load the identity.
 
-    qreal det = matrixDet4(m);
+    double mm[4][4];
+    copyToDoubles(m, mm);
+
+    double det = matrixDet4(mm);
     if (det == 0.0f) {
         if (invertible)
             *invertible = false;
@@ -461,22 +486,22 @@ QMatrix4x4 QMatrix4x4::inverted(bool *invertible) const
     }
     det = 1.0f / det;
 
-    inv.m[0][0] =  matrixDet3(m, 1, 2, 3, 1, 2, 3) * det;
-    inv.m[0][1] = -matrixDet3(m, 0, 2, 3, 1, 2, 3) * det;
-    inv.m[0][2] =  matrixDet3(m, 0, 1, 3, 1, 2, 3) * det;
-    inv.m[0][3] = -matrixDet3(m, 0, 1, 2, 1, 2, 3) * det;
-    inv.m[1][0] = -matrixDet3(m, 1, 2, 3, 0, 2, 3) * det;
-    inv.m[1][1] =  matrixDet3(m, 0, 2, 3, 0, 2, 3) * det;
-    inv.m[1][2] = -matrixDet3(m, 0, 1, 3, 0, 2, 3) * det;
-    inv.m[1][3] =  matrixDet3(m, 0, 1, 2, 0, 2, 3) * det;
-    inv.m[2][0] =  matrixDet3(m, 1, 2, 3, 0, 1, 3) * det;
-    inv.m[2][1] = -matrixDet3(m, 0, 2, 3, 0, 1, 3) * det;
-    inv.m[2][2] =  matrixDet3(m, 0, 1, 3, 0, 1, 3) * det;
-    inv.m[2][3] = -matrixDet3(m, 0, 1, 2, 0, 1, 3) * det;
-    inv.m[3][0] = -matrixDet3(m, 1, 2, 3, 0, 1, 2) * det;
-    inv.m[3][1] =  matrixDet3(m, 0, 2, 3, 0, 1, 2) * det;
-    inv.m[3][2] = -matrixDet3(m, 0, 1, 3, 0, 1, 2) * det;
-    inv.m[3][3] =  matrixDet3(m, 0, 1, 2, 0, 1, 2) * det;
+    inv.m[0][0] =  matrixDet3(mm, 1, 2, 3, 1, 2, 3) * det;
+    inv.m[0][1] = -matrixDet3(mm, 0, 2, 3, 1, 2, 3) * det;
+    inv.m[0][2] =  matrixDet3(mm, 0, 1, 3, 1, 2, 3) * det;
+    inv.m[0][3] = -matrixDet3(mm, 0, 1, 2, 1, 2, 3) * det;
+    inv.m[1][0] = -matrixDet3(mm, 1, 2, 3, 0, 2, 3) * det;
+    inv.m[1][1] =  matrixDet3(mm, 0, 2, 3, 0, 2, 3) * det;
+    inv.m[1][2] = -matrixDet3(mm, 0, 1, 3, 0, 2, 3) * det;
+    inv.m[1][3] =  matrixDet3(mm, 0, 1, 2, 0, 2, 3) * det;
+    inv.m[2][0] =  matrixDet3(mm, 1, 2, 3, 0, 1, 3) * det;
+    inv.m[2][1] = -matrixDet3(mm, 0, 2, 3, 0, 1, 3) * det;
+    inv.m[2][2] =  matrixDet3(mm, 0, 1, 3, 0, 1, 3) * det;
+    inv.m[2][3] = -matrixDet3(mm, 0, 1, 2, 0, 1, 3) * det;
+    inv.m[3][0] = -matrixDet3(mm, 1, 2, 3, 0, 1, 2) * det;
+    inv.m[3][1] =  matrixDet3(mm, 0, 2, 3, 0, 1, 2) * det;
+    inv.m[3][2] = -matrixDet3(mm, 0, 1, 3, 0, 1, 2) * det;
+    inv.m[3][3] =  matrixDet3(mm, 0, 1, 2, 0, 1, 2) * det;
     inv.flagBits = flagBits;
 
     if (invertible)
@@ -509,7 +534,7 @@ QMatrix3x3 QMatrix4x4::normalMatrix() const
         inv.data()[8] = 1.0f / m[2][2];
         return inv;
     } else if ((flagBits & ~(Translation | Rotation2D | Rotation)) == Identity) {
-        qreal *invm = inv.data();
+        float *invm = inv.data();
         invm[0 + 0 * 3] = m[0][0];
         invm[1 + 0 * 3] = m[0][1];
         invm[2 + 0 * 3] = m[0][2];
@@ -522,23 +547,25 @@ QMatrix3x3 QMatrix4x4::normalMatrix() const
         return inv;
     }
 
-    qreal det = matrixDet3(m, 0, 1, 2, 0, 1, 2);
+    double mm[4][4];
+    copyToDoubles(m, mm);
+    double det = matrixDet3(mm, 0, 1, 2, 0, 1, 2);
     if (det == 0.0f)
         return inv;
     det = 1.0f / det;
 
-    qreal *invm = inv.data();
+    float *invm = inv.data();
 
     // Invert and transpose in a single step.
-    invm[0 + 0 * 3] =  (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * det;
-    invm[1 + 0 * 3] = -(m[1][0] * m[2][2] - m[1][2] * m[2][0]) * det;
-    invm[2 + 0 * 3] =  (m[1][0] * m[2][1] - m[1][1] * m[2][0]) * det;
-    invm[0 + 1 * 3] = -(m[0][1] * m[2][2] - m[2][1] * m[0][2]) * det;
-    invm[1 + 1 * 3] =  (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * det;
-    invm[2 + 1 * 3] = -(m[0][0] * m[2][1] - m[0][1] * m[2][0]) * det;
-    invm[0 + 2 * 3] =  (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * det;
-    invm[1 + 2 * 3] = -(m[0][0] * m[1][2] - m[0][2] * m[1][0]) * det;
-    invm[2 + 2 * 3] =  (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * det;
+    invm[0 + 0 * 3] =  (mm[1][1] * mm[2][2] - mm[2][1] * mm[1][2]) * det;
+    invm[1 + 0 * 3] = -(mm[1][0] * mm[2][2] - mm[1][2] * mm[2][0]) * det;
+    invm[2 + 0 * 3] =  (mm[1][0] * mm[2][1] - mm[1][1] * mm[2][0]) * det;
+    invm[0 + 1 * 3] = -(mm[0][1] * mm[2][2] - mm[2][1] * mm[0][2]) * det;
+    invm[1 + 1 * 3] =  (mm[0][0] * mm[2][2] - mm[0][2] * mm[2][0]) * det;
+    invm[2 + 1 * 3] = -(mm[0][0] * mm[2][1] - mm[0][1] * mm[2][0]) * det;
+    invm[0 + 2 * 3] =  (mm[0][1] * mm[1][2] - mm[0][2] * mm[1][1]) * det;
+    invm[1 + 2 * 3] = -(mm[0][0] * mm[1][2] - mm[0][2] * mm[1][0]) * det;
+    invm[2 + 2 * 3] =  (mm[0][0] * mm[1][1] - mm[1][0] * mm[0][1]) * det;
 
     return inv;
 }
@@ -578,7 +605,7 @@ QMatrix4x4 QMatrix4x4::transposed() const
 */
 
 /*!
-    \fn QMatrix4x4& QMatrix4x4::operator*=(qreal factor)
+    \fn QMatrix4x4& QMatrix4x4::operator*=(float factor)
     \overload
 
     Multiplies all elements of this matrix by \a factor.
@@ -589,7 +616,7 @@ QMatrix4x4 QMatrix4x4::transposed() const
 
     Divides all elements of this matrix by \a divisor.
 */
-QMatrix4x4& QMatrix4x4::operator/=(qreal divisor)
+QMatrix4x4& QMatrix4x4::operator/=(float divisor)
 {
     m[0][0] /= divisor;
     m[0][1] /= divisor;
@@ -727,14 +754,14 @@ QMatrix4x4& QMatrix4x4::operator/=(qreal divisor)
 */
 
 /*!
-    \fn QMatrix4x4 operator*(qreal factor, const QMatrix4x4& matrix)
+    \fn QMatrix4x4 operator*(float factor, const QMatrix4x4& matrix)
     \relates QMatrix4x4
 
     Returns the result of multiplying all elements of \a matrix by \a factor.
 */
 
 /*!
-    \fn QMatrix4x4 operator*(const QMatrix4x4& matrix, qreal factor)
+    \fn QMatrix4x4 operator*(const QMatrix4x4& matrix, float factor)
     \relates QMatrix4x4
 
     Returns the result of multiplying all elements of \a matrix by \a factor.
@@ -745,7 +772,7 @@ QMatrix4x4& QMatrix4x4::operator/=(qreal divisor)
 
     Returns the result of dividing all elements of \a matrix by \a divisor.
 */
-QMatrix4x4 operator/(const QMatrix4x4& matrix, qreal divisor)
+QMatrix4x4 operator/(const QMatrix4x4& matrix, float divisor)
 {
     QMatrix4x4 m(1); // The "1" says to not load the identity.
     m.m[0][0] = matrix.m[0][0] / divisor;
@@ -786,9 +813,9 @@ QMatrix4x4 operator/(const QMatrix4x4& matrix, qreal divisor)
 */
 void QMatrix4x4::scale(const QVector3D& vector)
 {
-    qreal vx = vector.x();
-    qreal vy = vector.y();
-    qreal vz = vector.z();
+    float vx = vector.x();
+    float vy = vector.y();
+    float vz = vector.z();
     if (flagBits < Scale) {
         m[0][0] = vx;
         m[1][1] = vy;
@@ -830,7 +857,7 @@ void QMatrix4x4::scale(const QVector3D& vector)
 
     \sa translate(), rotate()
 */
-void QMatrix4x4::scale(qreal x, qreal y)
+void QMatrix4x4::scale(float x, float y)
 {
     if (flagBits < Scale) {
         m[0][0] = x;
@@ -864,7 +891,7 @@ void QMatrix4x4::scale(qreal x, qreal y)
 
     \sa translate(), rotate()
 */
-void QMatrix4x4::scale(qreal x, qreal y, qreal z)
+void QMatrix4x4::scale(float x, float y, float z)
 {
     if (flagBits < Scale) {
         m[0][0] = x;
@@ -905,7 +932,7 @@ void QMatrix4x4::scale(qreal x, qreal y, qreal z)
 
     \sa translate(), rotate()
 */
-void QMatrix4x4::scale(qreal factor)
+void QMatrix4x4::scale(float factor)
 {
     if (flagBits < Scale) {
         m[0][0] = factor;
@@ -948,9 +975,9 @@ void QMatrix4x4::scale(qreal factor)
 
 void QMatrix4x4::translate(const QVector3D& vector)
 {
-    qreal vx = vector.x();
-    qreal vy = vector.y();
-    qreal vz = vector.z();
+    float vx = vector.x();
+    float vy = vector.y();
+    float vz = vector.z();
     if (flagBits == Identity) {
         m[3][0] = vx;
         m[3][1] = vy;
@@ -989,7 +1016,7 @@ void QMatrix4x4::translate(const QVector3D& vector)
 
     \sa scale(), rotate()
 */
-void QMatrix4x4::translate(qreal x, qreal y)
+void QMatrix4x4::translate(float x, float y)
 {
     if (flagBits == Identity) {
         m[3][0] = x;
@@ -1023,7 +1050,7 @@ void QMatrix4x4::translate(qreal x, qreal y)
 
     \sa scale(), rotate()
 */
-void QMatrix4x4::translate(qreal x, qreal y, qreal z)
+void QMatrix4x4::translate(float x, float y, float z)
 {
     if (flagBits == Identity) {
         m[3][0] = x;
@@ -1062,7 +1089,7 @@ void QMatrix4x4::translate(qreal x, qreal y, qreal z)
     \sa scale(), translate()
 */
 
-void QMatrix4x4::rotate(qreal angle, const QVector3D& vector)
+void QMatrix4x4::rotate(float angle, const QVector3D& vector)
 {
     rotate(angle, vector.x(), vector.y(), vector.z());
 }
@@ -1077,11 +1104,11 @@ void QMatrix4x4::rotate(qreal angle, const QVector3D& vector)
 
     \sa scale(), translate()
 */
-void QMatrix4x4::rotate(qreal angle, qreal x, qreal y, qreal z)
+void QMatrix4x4::rotate(float angle, float x, float y, float z)
 {
     if (angle == 0.0f)
         return;
-    qreal c, s;
+    float c, s;
     if (angle == 90.0f || angle == -270.0f) {
         s = 1.0f;
         c = 0.0f;
@@ -1092,9 +1119,9 @@ void QMatrix4x4::rotate(qreal angle, qreal x, qreal y, qreal z)
         s = 0.0f;
         c = -1.0f;
     } else {
-        qreal a = angle * M_PI / 180.0f;
-        c = qCos(a);
-        s = qSin(a);
+        float a = angle * M_PI / 180.0f;
+        c = cosf(a);
+        s = sinf(a);
     }
     if (x == 0.0f) {
         if (y == 0.0f) {
@@ -1102,7 +1129,7 @@ void QMatrix4x4::rotate(qreal angle, qreal x, qreal y, qreal z)
                 // Rotate around the Z axis.
                 if (z < 0)
                     s = -s;
-                qreal tmp;
+                float tmp;
                 m[0][0] = (tmp = m[0][0]) * c + m[1][0] * s;
                 m[1][0] = m[1][0] * c - tmp * s;
                 m[0][1] = (tmp = m[0][1]) * c + m[1][1] * s;
@@ -1119,7 +1146,7 @@ void QMatrix4x4::rotate(qreal angle, qreal x, qreal y, qreal z)
             // Rotate around the Y axis.
             if (y < 0)
                 s = -s;
-            qreal tmp;
+            float tmp;
             m[2][0] = (tmp = m[2][0]) * c + m[0][0] * s;
             m[0][0] = m[0][0] * c - tmp * s;
             m[2][1] = (tmp = m[2][1]) * c + m[0][1] * s;
@@ -1136,7 +1163,7 @@ void QMatrix4x4::rotate(qreal angle, qreal x, qreal y, qreal z)
         // Rotate around the X axis.
         if (x < 0)
             s = -s;
-        qreal tmp;
+        float tmp;
         m[1][0] = (tmp = m[1][0]) * c + m[2][0] * s;
         m[2][0] = m[2][0] * c - tmp * s;
         m[1][1] = (tmp = m[1][1]) * c + m[2][1] * s;
@@ -1150,14 +1177,16 @@ void QMatrix4x4::rotate(qreal angle, qreal x, qreal y, qreal z)
         return;
     }
 
-    qreal len = x * x + y * y + z * z;
-    if (!qFuzzyCompare(len, qreal(1)) && !qFuzzyIsNull(len)) {
-        len = qSqrt(len);
-        x /= len;
-        y /= len;
-        z /= len;
+    double len = double(x) * double(x) +
+                 double(y) * double(y) +
+                 double(z) * double(z);
+    if (!qFuzzyCompare(len, 1.0) && !qFuzzyIsNull(len)) {
+        len = sqrt(len);
+        x = float(double(x) / len);
+        y = float(double(y) / len);
+        z = float(double(z) / len);
     }
-    qreal ic = 1.0f - c;
+    float ic = 1.0f - c;
     QMatrix4x4 rot(1); // The "1" says to not load the identity.
     rot.m[0][0] = x * x * ic + c;
     rot.m[1][0] = x * y * ic - z * s;
@@ -1182,13 +1211,13 @@ void QMatrix4x4::rotate(qreal angle, qreal x, qreal y, qreal z)
 /*!
     \internal
 */
-void QMatrix4x4::projectedRotate(qreal angle, qreal x, qreal y, qreal z)
+void QMatrix4x4::projectedRotate(float angle, float x, float y, float z)
 {
     // Used by QGraphicsRotation::applyTo() to perform a rotation
     // and projection back to 2D in a single step.
     if (angle == 0.0f)
         return;
-    qreal c, s;
+    float c, s;
     if (angle == 90.0f || angle == -270.0f) {
         s = 1.0f;
         c = 0.0f;
@@ -1199,9 +1228,9 @@ void QMatrix4x4::projectedRotate(qreal angle, qreal x, qreal y, qreal z)
         s = 0.0f;
         c = -1.0f;
     } else {
-        qreal a = angle * M_PI / 180.0f;
-        c = qCos(a);
-        s = qSin(a);
+        float a = angle * M_PI / 180.0f;
+        c = cosf(a);
+        s = sinf(a);
     }
     if (x == 0.0f) {
         if (y == 0.0f) {
@@ -1209,7 +1238,7 @@ void QMatrix4x4::projectedRotate(qreal angle, qreal x, qreal y, qreal z)
                 // Rotate around the Z axis.
                 if (z < 0)
                     s = -s;
-                qreal tmp;
+                float tmp;
                 m[0][0] = (tmp = m[0][0]) * c + m[1][0] * s;
                 m[1][0] = m[1][0] * c - tmp * s;
                 m[0][1] = (tmp = m[0][1]) * c + m[1][1] * s;
@@ -1244,14 +1273,16 @@ void QMatrix4x4::projectedRotate(qreal angle, qreal x, qreal y, qreal z)
         flagBits = General;
         return;
     }
-    qreal len = x * x + y * y + z * z;
-    if (!qFuzzyIsNull(len - 1.0f) && !qFuzzyIsNull(len)) {
-        len = qSqrt(len);
-        x /= len;
-        y /= len;
-        z /= len;
+    double len = double(x) * double(x) +
+                 double(y) * double(y) +
+                 double(z) * double(z);
+    if (!qFuzzyCompare(len, 1.0) && !qFuzzyIsNull(len)) {
+        len = sqrt(len);
+        x = float(double(x) / len);
+        y = float(double(y) / len);
+        z = float(double(z) / len);
     }
-    qreal ic = 1.0f - c;
+    float ic = 1.0f - c;
     QMatrix4x4 rot(1); // The "1" says to not load the identity.
     rot.m[0][0] = x * x * ic + c;
     rot.m[1][0] = x * y * ic - z * s;
@@ -1287,15 +1318,15 @@ void QMatrix4x4::rotate(const QQuaternion& quaternion)
     // Algorithm from:
     // http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q54
     QMatrix4x4 m(1);
-    qreal xx = quaternion.x() * quaternion.x();
-    qreal xy = quaternion.x() * quaternion.y();
-    qreal xz = quaternion.x() * quaternion.z();
-    qreal xw = quaternion.x() * quaternion.scalar();
-    qreal yy = quaternion.y() * quaternion.y();
-    qreal yz = quaternion.y() * quaternion.z();
-    qreal yw = quaternion.y() * quaternion.scalar();
-    qreal zz = quaternion.z() * quaternion.z();
-    qreal zw = quaternion.z() * quaternion.scalar();
+    float xx = quaternion.x() * quaternion.x();
+    float xy = quaternion.x() * quaternion.y();
+    float xz = quaternion.x() * quaternion.z();
+    float xw = quaternion.x() * quaternion.scalar();
+    float yy = quaternion.y() * quaternion.y();
+    float yz = quaternion.y() * quaternion.z();
+    float yw = quaternion.y() * quaternion.scalar();
+    float zz = quaternion.z() * quaternion.z();
+    float zw = quaternion.z() * quaternion.scalar();
     m.m[0][0] = 1.0f - 2 * (yy + zz);
     m.m[1][0] =        2 * (xy - zw);
     m.m[2][0] =        2 * (xz + yw);
@@ -1358,16 +1389,16 @@ void QMatrix4x4::ortho(const QRectF& rect)
 
     \sa frustum(), perspective()
 */
-void QMatrix4x4::ortho(qreal left, qreal right, qreal bottom, qreal top, qreal nearPlane, qreal farPlane)
+void QMatrix4x4::ortho(float left, float right, float bottom, float top, float nearPlane, float farPlane)
 {
     // Bail out if the projection volume is zero-sized.
     if (left == right || bottom == top || nearPlane == farPlane)
         return;
 
     // Construct the projection.
-    qreal width = right - left;
-    qreal invheight = top - bottom;
-    qreal clip = farPlane - nearPlane;
+    float width = right - left;
+    float invheight = top - bottom;
+    float clip = farPlane - nearPlane;
     QMatrix4x4 m(1);
     m.m[0][0] = 2.0f / width;
     m.m[1][0] = 0.0f;
@@ -1399,7 +1430,7 @@ void QMatrix4x4::ortho(qreal left, qreal right, qreal bottom, qreal top, qreal n
 
     \sa ortho(), perspective()
 */
-void QMatrix4x4::frustum(qreal left, qreal right, qreal bottom, qreal top, qreal nearPlane, qreal farPlane)
+void QMatrix4x4::frustum(float left, float right, float bottom, float top, float nearPlane, float farPlane)
 {
     // Bail out if the projection volume is zero-sized.
     if (left == right || bottom == top || nearPlane == farPlane)
@@ -1407,9 +1438,9 @@ void QMatrix4x4::frustum(qreal left, qreal right, qreal bottom, qreal top, qreal
 
     // Construct the projection.
     QMatrix4x4 m(1);
-    qreal width = right - left;
-    qreal invheight = top - bottom;
-    qreal clip = farPlane - nearPlane;
+    float width = right - left;
+    float invheight = top - bottom;
+    float clip = farPlane - nearPlane;
     m.m[0][0] = 2.0f * nearPlane / width;
     m.m[1][0] = 0.0f;
     m.m[2][0] = (left + right) / width;
@@ -1440,7 +1471,7 @@ void QMatrix4x4::frustum(qreal left, qreal right, qreal bottom, qreal top, qreal
 
     \sa ortho(), frustum()
 */
-void QMatrix4x4::perspective(qreal angle, qreal aspect, qreal nearPlane, qreal farPlane)
+void QMatrix4x4::perspective(float angle, float aspect, float nearPlane, float farPlane)
 {
     // Bail out if the projection volume is zero-sized.
     if (nearPlane == farPlane || aspect == 0.0f)
@@ -1448,12 +1479,12 @@ void QMatrix4x4::perspective(qreal angle, qreal aspect, qreal nearPlane, qreal f
 
     // Construct the projection.
     QMatrix4x4 m(1);
-    qreal radians = (angle / 2.0f) * M_PI / 180.0f;
-    qreal sine = qSin(radians);
+    float radians = (angle / 2.0f) * M_PI / 180.0f;
+    float sine = sinf(radians);
     if (sine == 0.0f)
         return;
-    qreal cotan = qCos(radians) / sine;
-    qreal clip = farPlane - nearPlane;
+    float cotan = cosf(radians) / sine;
+    float clip = farPlane - nearPlane;
     m.m[0][0] = cotan / aspect;
     m.m[1][0] = 0.0f;
     m.m[2][0] = 0.0f;
@@ -1551,11 +1582,11 @@ void QMatrix4x4::flipCoordinates()
     Retrieves the 16 items in this matrix and copies them to \a values
     in row-major order.
 */
-void QMatrix4x4::copyDataTo(qreal *values) const
+void QMatrix4x4::copyDataTo(float *values) const
 {
     for (int row = 0; row < 4; ++row)
         for (int col = 0; col < 4; ++col)
-            values[row * 4 + col] = qreal(m[col][row]);
+            values[row * 4 + col] = float(m[col][row]);
 }
 
 /*!
@@ -1607,7 +1638,7 @@ QTransform QMatrix4x4::toTransform() const
 
     \sa toAffine()
 */
-QTransform QMatrix4x4::toTransform(qreal distanceToPlane) const
+QTransform QMatrix4x4::toTransform(float distanceToPlane) const
 {
     if (distanceToPlane == 1024.0f) {
         // Optimize the common case with constants.
@@ -1622,7 +1653,7 @@ QTransform QMatrix4x4::toTransform(qreal distanceToPlane) const
         //      | 0 0 d 1 |
         // where d = -1 / distanceToPlane.  After projection, row 3 and
         // column 3 are dropped to form the final QTransform.
-        qreal d = 1.0f / distanceToPlane;
+        float d = 1.0f / distanceToPlane;
         return QTransform(m[0][0], m[0][1], m[0][3] - m[0][2] * d,
                           m[1][0], m[1][1], m[1][3] - m[1][2] * d,
                           m[3][0], m[3][1], m[3][3] - m[3][2] * d);
@@ -1701,10 +1732,10 @@ QRect QMatrix4x4::mapRect(const QRect& rect) const
                      rect.width(), rect.height());
     } else if (flagBits < Rotation2D) {
         // Translation | Scale
-        qreal x = rect.x() * m[0][0] + m[3][0];
-        qreal y = rect.y() * m[1][1] + m[3][1];
-        qreal w = rect.width() * m[0][0];
-        qreal h = rect.height() * m[1][1];
+        float x = rect.x() * m[0][0] + m[3][0];
+        float y = rect.y() * m[1][1] + m[3][1];
+        float w = rect.width() * m[0][0];
+        float h = rect.height() * m[1][1];
         if (w < 0) {
             w = -w;
             x -= w;
@@ -1745,10 +1776,10 @@ QRectF QMatrix4x4::mapRect(const QRectF& rect) const
         return rect.translated(m[3][0], m[3][1]);
     } else if (flagBits < Rotation2D) {
         // Translation | Scale
-        qreal x = rect.x() * m[0][0] + m[3][0];
-        qreal y = rect.y() * m[1][1] + m[3][1];
-        qreal w = rect.width() * m[0][0];
-        qreal h = rect.height() * m[1][1];
+        float x = rect.x() * m[0][0] + m[3][0];
+        float y = rect.y() * m[1][1] + m[3][1];
+        float w = rect.width() * m[0][0];
+        float h = rect.height() * m[1][1];
         if (w < 0) {
             w = -w;
             x -= w;
@@ -1763,16 +1794,16 @@ QRectF QMatrix4x4::mapRect(const QRectF& rect) const
     QPointF tl = map(rect.topLeft()); QPointF tr = map(rect.topRight());
     QPointF bl = map(rect.bottomLeft()); QPointF br = map(rect.bottomRight());
 
-    qreal xmin = qMin(qMin(tl.x(), tr.x()), qMin(bl.x(), br.x()));
-    qreal xmax = qMax(qMax(tl.x(), tr.x()), qMax(bl.x(), br.x()));
-    qreal ymin = qMin(qMin(tl.y(), tr.y()), qMin(bl.y(), br.y()));
-    qreal ymax = qMax(qMax(tl.y(), tr.y()), qMax(bl.y(), br.y()));
+    float xmin = qMin(qMin(tl.x(), tr.x()), qMin(bl.x(), br.x()));
+    float xmax = qMax(qMax(tl.x(), tr.x()), qMax(bl.x(), br.x()));
+    float ymin = qMin(qMin(tl.y(), tr.y()), qMin(bl.y(), br.y()));
+    float ymax = qMax(qMax(tl.y(), tr.y()), qMax(bl.y(), br.y()));
 
     return QRectF(QPointF(xmin, ymin), QPointF(xmax, ymax));
 }
 
 /*!
-    \fn qreal *QMatrix4x4::data()
+    \fn float *QMatrix4x4::data()
 
     Returns a pointer to the raw data of this matrix.
 
@@ -1780,7 +1811,7 @@ QRectF QMatrix4x4::mapRect(const QRectF& rect) const
 */
 
 /*!
-    \fn const qreal *QMatrix4x4::data() const
+    \fn const float *QMatrix4x4::data() const
 
     Returns a constant pointer to the raw data of this matrix.
     This raw data is stored in column-major format.
@@ -1789,7 +1820,7 @@ QRectF QMatrix4x4::mapRect(const QRectF& rect) const
 */
 
 /*!
-    \fn const qreal *QMatrix4x4::constData() const
+    \fn const float *QMatrix4x4::constData() const
 
     Returns a constant pointer to the raw data of this matrix.
     This raw data is stored in column-major format.
@@ -1873,24 +1904,28 @@ void QMatrix4x4::optimize()
                 flagBits &= ~Scale;
         } else {
             // If the columns are orthonormal and form a right-handed system, then there is no scale.
-            qreal det = matrixDet2(m, 0, 1, 0, 1);
-            qreal lenX = m[0][0] * m[0][0] + m[0][1] * m[0][1];
-            qreal lenY = m[1][0] * m[1][0] + m[1][1] * m[1][1];
-            qreal lenZ = m[2][2];
-            if (qFuzzyCompare(det, qreal(1)) && qFuzzyCompare(lenX, qreal(1))
-                    && qFuzzyCompare(lenY, qreal(1)) && qFuzzyCompare(lenZ, qreal(1)))
+            double mm[4][4];
+            copyToDoubles(m, mm);
+            double det = matrixDet2(mm, 0, 1, 0, 1);
+            double lenX = mm[0][0] * mm[0][0] + mm[0][1] * mm[0][1];
+            double lenY = mm[1][0] * mm[1][0] + mm[1][1] * mm[1][1];
+            double lenZ = mm[2][2];
+            if (qFuzzyCompare(det, 1.0) && qFuzzyCompare(lenX, 1.0)
+                    && qFuzzyCompare(lenY, 1.0) && qFuzzyCompare(lenZ, 1.0))
             {
                 flagBits &= ~Scale;
             }
         }
     } else {
         // If the columns are orthonormal and form a right-handed system, then there is no scale.
-        qreal det = matrixDet3(m, 0, 1, 2, 0, 1, 2);
-        qreal lenX = m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2];
-        qreal lenY = m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2];
-        qreal lenZ = m[2][0] * m[2][0] + m[2][1] * m[2][1] + m[2][2] * m[2][2];
-        if (qFuzzyCompare(det, qreal(1)) && qFuzzyCompare(lenX, qreal(1))
-                && qFuzzyCompare(lenY, qreal(1)) && qFuzzyCompare(lenZ, qreal(1)))
+        double mm[4][4];
+        copyToDoubles(m, mm);
+        double det = matrixDet3(mm, 0, 1, 2, 0, 1, 2);
+        double lenX = mm[0][0] * mm[0][0] + mm[0][1] * mm[0][1] + mm[0][2] * mm[0][2];
+        double lenY = mm[1][0] * mm[1][0] + mm[1][1] * mm[1][1] + mm[1][2] * mm[1][2];
+        double lenZ = mm[2][0] * mm[2][0] + mm[2][1] * mm[2][1] + mm[2][2] * mm[2][2];
+        if (qFuzzyCompare(det, 1.0) && qFuzzyCompare(lenX, 1.0)
+                && qFuzzyCompare(lenY, 1.0) && qFuzzyCompare(lenZ, 1.0))
         {
             flagBits &= ~Scale;
         }
@@ -1959,7 +1994,7 @@ QDataStream &operator<<(QDataStream &stream, const QMatrix4x4 &matrix)
 {
     for (int row = 0; row < 4; ++row)
         for (int col = 0; col < 4; ++col)
-            stream << double(matrix(row, col));
+            stream << matrix(row, col);
     return stream;
 }
 
@@ -1975,11 +2010,11 @@ QDataStream &operator<<(QDataStream &stream, const QMatrix4x4 &matrix)
 
 QDataStream &operator>>(QDataStream &stream, QMatrix4x4 &matrix)
 {
-    double x;
+    float x;
     for (int row = 0; row < 4; ++row) {
         for (int col = 0; col < 4; ++col) {
             stream >> x;
-            matrix(row, col) = qreal(x);
+            matrix(row, col) = x;
         }
     }
     matrix.optimize();
diff --git a/src/gui/math3d/qmatrix4x4.h b/src/gui/math3d/qmatrix4x4.h
index 8353adf..34230ac 100644
--- a/src/gui/math3d/qmatrix4x4.h
+++ b/src/gui/math3d/qmatrix4x4.h
@@ -63,21 +63,24 @@ class Q_GUI_EXPORT QMatrix4x4
 {
 public:
     inline QMatrix4x4() { setToIdentity(); }
-    explicit QMatrix4x4(const qreal *values);
-    inline QMatrix4x4(qreal m11, qreal m12, qreal m13, qreal m14,
-                      qreal m21, qreal m22, qreal m23, qreal m24,
-                      qreal m31, qreal m32, qreal m33, qreal m34,
-                      qreal m41, qreal m42, qreal m43, qreal m44);
+    explicit QMatrix4x4(const float *values);
+
+    // ###TODO This is temporary to get through the CI's revdep qtdeclarative tests. Remove it!
+    explicit QMatrix4x4(const double *values);
+    inline QMatrix4x4(float m11, float m12, float m13, float m14,
+                      float m21, float m22, float m23, float m24,
+                      float m31, float m32, float m33, float m34,
+                      float m41, float m42, float m43, float m44);
 
     template <int N, int M>
-    explicit QMatrix4x4(const QGenericMatrix<N, M, qreal>& matrix);
+    explicit QMatrix4x4(const QGenericMatrix<N, M, float>& matrix);
 
-    QMatrix4x4(const qreal *values, int cols, int rows);
+    QMatrix4x4(const float *values, int cols, int rows);
     QMatrix4x4(const QTransform& transform);
     QMatrix4x4(const QMatrix& matrix);
 
-    inline const qreal& operator()(int row, int column) const;
-    inline qreal& operator()(int row, int column);
+    inline const float& operator()(int row, int column) const;
+    inline float& operator()(int row, int column);
 
 #ifndef QT_NO_VECTOR4D
     inline QVector4D column(int index) const;
@@ -90,9 +93,9 @@ public:
     inline bool isIdentity() const;
     inline void setToIdentity();
 
-    inline void fill(qreal value);
+    inline void fill(float value);
 
-    qreal determinant() const;
+    double determinant() const;
     QMatrix4x4 inverted(bool *invertible = 0) const;
     QMatrix4x4 transposed() const;
     QMatrix3x3 normalMatrix() const;
@@ -100,8 +103,8 @@ public:
     inline QMatrix4x4& operator+=(const QMatrix4x4& other);
     inline QMatrix4x4& operator-=(const QMatrix4x4& other);
     inline QMatrix4x4& operator*=(const QMatrix4x4& other);
-    inline QMatrix4x4& operator*=(qreal factor);
-    QMatrix4x4& operator/=(qreal divisor);
+    inline QMatrix4x4& operator*=(float factor);
+    QMatrix4x4& operator/=(float divisor);
     inline bool operator==(const QMatrix4x4& other) const;
     inline bool operator!=(const QMatrix4x4& other) const;
 
@@ -121,42 +124,42 @@ public:
     friend QMatrix4x4 operator-(const QMatrix4x4& matrix);
     friend QPoint operator*(const QMatrix4x4& matrix, const QPoint& point);
     friend QPointF operator*(const QMatrix4x4& matrix, const QPointF& point);
-    friend QMatrix4x4 operator*(qreal factor, const QMatrix4x4& matrix);
-    friend QMatrix4x4 operator*(const QMatrix4x4& matrix, qreal factor);
-    friend Q_GUI_EXPORT QMatrix4x4 operator/(const QMatrix4x4& matrix, qreal divisor);
+    friend QMatrix4x4 operator*(float factor, const QMatrix4x4& matrix);
+    friend QMatrix4x4 operator*(const QMatrix4x4& matrix, float factor);
+    friend Q_GUI_EXPORT QMatrix4x4 operator/(const QMatrix4x4& matrix, float divisor);
 
     friend inline bool qFuzzyCompare(const QMatrix4x4& m1, const QMatrix4x4& m2);
 
 #ifndef QT_NO_VECTOR3D
     void scale(const QVector3D& vector);
     void translate(const QVector3D& vector);
-    void rotate(qreal angle, const QVector3D& vector);
+    void rotate(float angle, const QVector3D& vector);
 #endif
-    void scale(qreal x, qreal y);
-    void scale(qreal x, qreal y, qreal z);
-    void scale(qreal factor);
-    void translate(qreal x, qreal y);
-    void translate(qreal x, qreal y, qreal z);
-    void rotate(qreal angle, qreal x, qreal y, qreal z = 0.0f);
+    void scale(float x, float y);
+    void scale(float x, float y, float z);
+    void scale(float factor);
+    void translate(float x, float y);
+    void translate(float x, float y, float z);
+    void rotate(float angle, float x, float y, float z = 0.0f);
 #ifndef QT_NO_QUATERNION
     void rotate(const QQuaternion& quaternion);
 #endif
 
     void ortho(const QRect& rect);
     void ortho(const QRectF& rect);
-    void ortho(qreal left, qreal right, qreal bottom, qreal top, qreal nearPlane, qreal farPlane);
-    void frustum(qreal left, qreal right, qreal bottom, qreal top, qreal nearPlane, qreal farPlane);
-    void perspective(qreal angle, qreal aspect, qreal nearPlane, qreal farPlane);
+    void ortho(float left, float right, float bottom, float top, float nearPlane, float farPlane);
+    void frustum(float left, float right, float bottom, float top, float nearPlane, float farPlane);
+    void perspective(float angle, float aspect, float nearPlane, float farPlane);
 #ifndef QT_NO_VECTOR3D
     void lookAt(const QVector3D& eye, const QVector3D& center, const QVector3D& up);
 #endif
     void flipCoordinates();
 
-    void copyDataTo(qreal *values) const;
+    void copyDataTo(float *values) const;
 
     QMatrix toAffine() const;
     QTransform toTransform() const;
-    QTransform toTransform(qreal distanceToPlane) const;
+    QTransform toTransform(float distanceToPlane) const;
 
     QPoint map(const QPoint& point) const;
     QPointF map(const QPointF& point) const;
@@ -171,11 +174,11 @@ public:
     QRectF mapRect(const QRectF& rect) const;
 
     template <int N, int M>
-    QGenericMatrix<N, M, qreal> toGenericMatrix() const;
+    QGenericMatrix<N, M, float> toGenericMatrix() const;
 
-    inline qreal *data();
-    inline const qreal *data() const { return *m; }
-    inline const qreal *constData() const { return *m; }
+    inline float *data();
+    inline const float *data() const { return *m; }
+    inline const float *constData() const { return *m; }
 
     void optimize();
 
@@ -186,7 +189,7 @@ public:
 #endif
 
 private:
-    qreal m[4][4];          // Column-major order to match OpenGL.
+    float m[4][4];          // Column-major order to match OpenGL.
     int flagBits;           // Flag bits from the enum below.
 
     // When matrices are multiplied, the flag bits are or-ed together.
@@ -205,7 +208,7 @@ private:
 
     QMatrix4x4 orthonormalInverse() const;
 
-    void projectedRotate(qreal angle, qreal x, qreal y, qreal z);
+    void projectedRotate(float angle, float x, float y, float z);
 
     friend class QGraphicsRotation;
 };
@@ -213,10 +216,10 @@ private:
 Q_DECLARE_TYPEINFO(QMatrix4x4, Q_MOVABLE_TYPE);
 
 inline QMatrix4x4::QMatrix4x4
-        (qreal m11, qreal m12, qreal m13, qreal m14,
-         qreal m21, qreal m22, qreal m23, qreal m24,
-         qreal m31, qreal m32, qreal m33, qreal m34,
-         qreal m41, qreal m42, qreal m43, qreal m44)
+        (float m11, float m12, float m13, float m14,
+         float m21, float m22, float m23, float m24,
+         float m31, float m32, float m33, float m34,
+         float m41, float m42, float m43, float m44)
 {
     m[0][0] = m11; m[0][1] = m21; m[0][2] = m31; m[0][3] = m41;
     m[1][0] = m12; m[1][1] = m22; m[1][2] = m32; m[1][3] = m42;
@@ -227,9 +230,9 @@ inline QMatrix4x4::QMatrix4x4
 
 template <int N, int M>
 Q_INLINE_TEMPLATE QMatrix4x4::QMatrix4x4
-    (const QGenericMatrix<N, M, qreal>& matrix)
+    (const QGenericMatrix<N, M, float>& matrix)
 {
-    const qreal *values = matrix.constData();
+    const float *values = matrix.constData();
     for (int matrixCol = 0; matrixCol < 4; ++matrixCol) {
         for (int matrixRow = 0; matrixRow < 4; ++matrixRow) {
             if (matrixCol < N && matrixRow < M)
@@ -244,10 +247,10 @@ Q_INLINE_TEMPLATE QMatrix4x4::QMatrix4x4
 }
 
 template <int N, int M>
-QGenericMatrix<N, M, qreal> QMatrix4x4::toGenericMatrix() const
+QGenericMatrix<N, M, float> QMatrix4x4::toGenericMatrix() const
 {
-    QGenericMatrix<N, M, qreal> result;
-    qreal *values = result.data();
+    QGenericMatrix<N, M, float> result;
+    float *values = result.data();
     for (int matrixCol = 0; matrixCol < N; ++matrixCol) {
         for (int matrixRow = 0; matrixRow < M; ++matrixRow) {
             if (matrixCol < 4 && matrixRow < 4)
@@ -261,13 +264,13 @@ QGenericMatrix<N, M, qreal> QMatrix4x4::toGenericMatrix() const
     return result;
 }
 
-inline const qreal& QMatrix4x4::operator()(int aRow, int aColumn) const
+inline const float& QMatrix4x4::operator()(int aRow, int aColumn) const
 {
     Q_ASSERT(aRow >= 0 && aRow < 4 && aColumn >= 0 && aColumn < 4);
     return m[aColumn][aRow];
 }
 
-inline qreal& QMatrix4x4::operator()(int aRow, int aColumn)
+inline float& QMatrix4x4::operator()(int aRow, int aColumn)
 {
     Q_ASSERT(aRow >= 0 && aRow < 4 && aColumn >= 0 && aColumn < 4);
     flagBits = General;
@@ -308,7 +311,7 @@ inline void QMatrix4x4::setRow(int index, const QVector4D& value)
 }
 #endif
 
-Q_GUI_EXPORT QMatrix4x4 operator/(const QMatrix4x4& matrix, qreal divisor);
+Q_GUI_EXPORT QMatrix4x4 operator/(const QMatrix4x4& matrix, float divisor);
 
 inline bool QMatrix4x4::isIdentity() const
 {
@@ -348,7 +351,7 @@ inline void QMatrix4x4::setToIdentity()
     flagBits = Identity;
 }
 
-inline void QMatrix4x4::fill(qreal value)
+inline void QMatrix4x4::fill(float value)
 {
     m[0][0] = value;
     m[0][1] = value;
@@ -428,7 +431,7 @@ inline QMatrix4x4& QMatrix4x4::operator*=(const QMatrix4x4& other)
         return *this;
     }
 
-    qreal m0, m1, m2;
+    float m0, m1, m2;
     m0 = m[0][0] * other.m[0][0]
             + m[1][0] * other.m[0][1]
             + m[2][0] * other.m[0][2]
@@ -511,7 +514,7 @@ inline QMatrix4x4& QMatrix4x4::operator*=(const QMatrix4x4& other)
     return *this;
 }
 
-inline QMatrix4x4& QMatrix4x4::operator*=(qreal factor)
+inline QMatrix4x4& QMatrix4x4::operator*=(float factor)
 {
     m[0][0] *= factor;
     m[0][1] *= factor;
@@ -711,7 +714,7 @@ inline QMatrix4x4 operator*(const QMatrix4x4& m1, const QMatrix4x4& m2)
 
 inline QVector3D operator*(const QVector3D& vector, const QMatrix4x4& matrix)
 {
-    qreal x, y, z, w;
+    float x, y, z, w;
     x = vector.x() * matrix.m[0][0] +
         vector.y() * matrix.m[0][1] +
         vector.z() * matrix.m[0][2] +
@@ -736,7 +739,7 @@ inline QVector3D operator*(const QVector3D& vector, const QMatrix4x4& matrix)
 
 inline QVector3D operator*(const QMatrix4x4& matrix, const QVector3D& vector)
 {
-    qreal x, y, z, w;
+    float x, y, z, w;
     if (matrix.flagBits == QMatrix4x4::Identity) {
         return vector;
     } else if (matrix.flagBits < QMatrix4x4::Rotation2D) {
@@ -779,7 +782,7 @@ inline QVector3D operator*(const QMatrix4x4& matrix, const QVector3D& vector)
 
 inline QVector4D operator*(const QVector4D& vector, const QMatrix4x4& matrix)
 {
-    qreal x, y, z, w;
+    float x, y, z, w;
     x = vector.x() * matrix.m[0][0] +
         vector.y() * matrix.m[0][1] +
         vector.z() * matrix.m[0][2] +
@@ -801,7 +804,7 @@ inline QVector4D operator*(const QVector4D& vector, const QMatrix4x4& matrix)
 
 inline QVector4D operator*(const QMatrix4x4& matrix, const QVector4D& vector)
 {
-    qreal x, y, z, w;
+    float x, y, z, w;
     x = vector.x() * matrix.m[0][0] +
         vector.y() * matrix.m[1][0] +
         vector.z() * matrix.m[2][0] +
@@ -825,8 +828,8 @@ inline QVector4D operator*(const QMatrix4x4& matrix, const QVector4D& vector)
 
 inline QPoint operator*(const QPoint& point, const QMatrix4x4& matrix)
 {
-    qreal xin, yin;
-    qreal x, y, w;
+    float xin, yin;
+    float x, y, w;
     xin = point.x();
     yin = point.y();
     x = xin * matrix.m[0][0] +
@@ -846,8 +849,8 @@ inline QPoint operator*(const QPoint& point, const QMatrix4x4& matrix)
 
 inline QPointF operator*(const QPointF& point, const QMatrix4x4& matrix)
 {
-    qreal xin, yin;
-    qreal x, y, w;
+    float xin, yin;
+    float x, y, w;
     xin = point.x();
     yin = point.y();
     x = xin * matrix.m[0][0] +
@@ -860,16 +863,16 @@ inline QPointF operator*(const QPointF& point, const QMatrix4x4& matrix)
         yin * matrix.m[3][1] +
         matrix.m[3][3];
     if (w == 1.0f) {
-        return QPointF(qreal(x), qreal(y));
+        return QPointF(float(x), float(y));
     } else {
-        return QPointF(qreal(x / w), qreal(y / w));
+        return QPointF(float(x / w), float(y / w));
     }
 }
 
 inline QPoint operator*(const QMatrix4x4& matrix, const QPoint& point)
 {
-    qreal xin, yin;
-    qreal x, y, w;
+    float xin, yin;
+    float x, y, w;
     xin = point.x();
     yin = point.y();
     if (matrix.flagBits == QMatrix4x4::Identity) {
@@ -900,8 +903,8 @@ inline QPoint operator*(const QMatrix4x4& matrix, const QPoint& point)
 
 inline QPointF operator*(const QMatrix4x4& matrix, const QPointF& point)
 {
-    qreal xin, yin;
-    qreal x, y, w;
+    float xin, yin;
+    float x, y, w;
     xin = point.x();
     yin = point.y();
     if (matrix.flagBits == QMatrix4x4::Identity) {
@@ -924,9 +927,9 @@ inline QPointF operator*(const QMatrix4x4& matrix, const QPointF& point)
             yin * matrix.m[1][3] +
             matrix.m[3][3];
         if (w == 1.0f) {
-            return QPointF(qreal(x), qreal(y));
+            return QPointF(float(x), float(y));
         } else {
-            return QPointF(qreal(x / w), qreal(y / w));
+            return QPointF(float(x / w), float(y / w));
         }
     }
 }
@@ -954,7 +957,7 @@ inline QMatrix4x4 operator-(const QMatrix4x4& matrix)
     return m;
 }
 
-inline QMatrix4x4 operator*(qreal factor, const QMatrix4x4& matrix)
+inline QMatrix4x4 operator*(float factor, const QMatrix4x4& matrix)
 {
     QMatrix4x4 m(1);
     m.m[0][0] = matrix.m[0][0] * factor;
@@ -977,7 +980,7 @@ inline QMatrix4x4 operator*(qreal factor, const QMatrix4x4& matrix)
     return m;
 }
 
-inline QMatrix4x4 operator*(const QMatrix4x4& matrix, qreal factor)
+inline QMatrix4x4 operator*(const QMatrix4x4& matrix, float factor)
 {
     QMatrix4x4 m(1);
     m.m[0][0] = matrix.m[0][0] * factor;
@@ -1071,7 +1074,7 @@ inline QVector4D QMatrix4x4::map(const QVector4D& point) const
 
 #endif
 
-inline qreal *QMatrix4x4::data()
+inline float *QMatrix4x4::data()
 {
     // We have to assume that the caller will modify the matrix elements,
     // so we flip it over to "General" mode.
@@ -1090,17 +1093,17 @@ Q_GUI_EXPORT QDataStream &operator>>(QDataStream &, QMatrix4x4 &);
 
 #if QT_DEPRECATED_SINCE(5, 0)
 template <int N, int M>
-QT_DEPRECATED QMatrix4x4 qGenericMatrixToMatrix4x4(const QGenericMatrix<N, M, qreal>& matrix)
+QT_DEPRECATED QMatrix4x4 qGenericMatrixToMatrix4x4(const QGenericMatrix<N, M, float>& matrix)
 {
     return QMatrix4x4(matrix.constData(), N, M);
 }
 
 template <int N, int M>
-QT_DEPRECATED QGenericMatrix<N, M, qreal> qGenericMatrixFromMatrix4x4(const QMatrix4x4& matrix)
+QT_DEPRECATED QGenericMatrix<N, M, float> qGenericMatrixFromMatrix4x4(const QMatrix4x4& matrix)
 {
-    QGenericMatrix<N, M, qreal> result;
-    const qreal *m = matrix.constData();
-    qreal *values = result.data();
+    QGenericMatrix<N, M, float> result;
+    const float *m = matrix.constData();
+    float *values = result.data();
     for (int col = 0; col < N; ++col) {
         for (int row = 0; row < M; ++row) {
             if (col < 4 && row < 4)
diff --git a/src/gui/math3d/qquaternion.cpp b/src/gui/math3d/qquaternion.cpp
index 79cdb36..b013388 100644
--- a/src/gui/math3d/qquaternion.cpp
+++ b/src/gui/math3d/qquaternion.cpp
@@ -68,7 +68,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn QQuaternion::QQuaternion(qreal scalar, qreal xpos, qreal ypos, qreal zpos)
+    \fn QQuaternion::QQuaternion(float scalar, float xpos, float ypos, float zpos)
 
     Constructs a quaternion with the vector (\a xpos, \a ypos, \a zpos)
     and \a scalar.
@@ -77,7 +77,7 @@ QT_BEGIN_NAMESPACE
 #ifndef QT_NO_VECTOR3D
 
 /*!
-    \fn QQuaternion::QQuaternion(qreal scalar, const QVector3D& vector)
+    \fn QQuaternion::QQuaternion(float scalar, const QVector3D& vector)
 
     Constructs a quaternion vector from the specified \a vector and
     \a scalar.
@@ -104,7 +104,7 @@ QT_BEGIN_NAMESPACE
 #endif
 
 /*!
-    \fn void QQuaternion::setVector(qreal x, qreal y, qreal z)
+    \fn void QQuaternion::setVector(float x, float y, float z)
 
     Sets the vector component of this quaternion to (\a x, \a y, \a z).
 
@@ -143,7 +143,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn qreal QQuaternion::x() const
+    \fn float QQuaternion::x() const
 
     Returns the x coordinate of this quaternion's vector.
 
@@ -151,7 +151,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn qreal QQuaternion::y() const
+    \fn float QQuaternion::y() const
 
     Returns the y coordinate of this quaternion's vector.
 
@@ -159,7 +159,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn qreal QQuaternion::z() const
+    \fn float QQuaternion::z() const
 
     Returns the z coordinate of this quaternion's vector.
 
@@ -167,7 +167,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn qreal QQuaternion::scalar() const
+    \fn float QQuaternion::scalar() const
 
     Returns the scalar component of this quaternion.
 
@@ -175,7 +175,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn void QQuaternion::setX(qreal x)
+    \fn void QQuaternion::setX(float x)
 
     Sets the x coordinate of this quaternion's vector to the given
     \a x coordinate.
@@ -184,7 +184,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn void QQuaternion::setY(qreal y)
+    \fn void QQuaternion::setY(float y)
 
     Sets the y coordinate of this quaternion's vector to the given
     \a y coordinate.
@@ -193,7 +193,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn void QQuaternion::setZ(qreal z)
+    \fn void QQuaternion::setZ(float z)
 
     Sets the z coordinate of this quaternion's vector to the given
     \a z coordinate.
@@ -202,7 +202,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn void QQuaternion::setScalar(qreal scalar)
+    \fn void QQuaternion::setScalar(float scalar)
 
     Sets the scalar component of this quaternion to \a scalar.
 
@@ -214,7 +214,7 @@ QT_BEGIN_NAMESPACE
 
     \sa lengthSquared(), normalized()
 */
-qreal QQuaternion::length() const
+float QQuaternion::length() const
 {
     return qSqrt(xp * xp + yp * yp + zp * zp + wp * wp);
 }
@@ -224,7 +224,7 @@ qreal QQuaternion::length() const
 
     \sa length()
 */
-qreal QQuaternion::lengthSquared() const
+float QQuaternion::lengthSquared() const
 {
     return xp * xp + yp * yp + zp * zp + wp * wp;
 }
@@ -323,7 +323,7 @@ QVector3D QQuaternion::rotatedVector(const QVector3D& vector) const
 */
 
 /*!
-    \fn QQuaternion &QQuaternion::operator*=(qreal factor)
+    \fn QQuaternion &QQuaternion::operator*=(float factor)
 
     Multiplies this quaternion's components by the given \a factor, and
     returns a reference to this quaternion.
@@ -339,7 +339,7 @@ QVector3D QQuaternion::rotatedVector(const QVector3D& vector) const
 */
 
 /*!
-    \fn QQuaternion &QQuaternion::operator/=(qreal divisor)
+    \fn QQuaternion &QQuaternion::operator/=(float divisor)
 
     Divides this quaternion's components by the given \a divisor, and
     returns a reference to this quaternion.
@@ -353,15 +353,15 @@ QVector3D QQuaternion::rotatedVector(const QVector3D& vector) const
     Creates a normalized quaternion that corresponds to rotating through
     \a angle degrees about the specified 3D \a axis.
 */
-QQuaternion QQuaternion::fromAxisAndAngle(const QVector3D& axis, qreal angle)
+QQuaternion QQuaternion::fromAxisAndAngle(const QVector3D& axis, float angle)
 {
     // Algorithm from:
     // http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q56
     // We normalize the result just in case the values are close
     // to zero, as suggested in the above FAQ.
-    qreal a = (angle / 2.0f) * M_PI / 180.0f;
-    qreal s = qSin(a);
-    qreal c = qCos(a);
+    float a = (angle / 2.0f) * M_PI / 180.0f;
+    float s = sinf(a);
+    float c = cosf(a);
     QVector3D ax = axis.normalized();
     return QQuaternion(c, ax.x() * s, ax.y() * s, ax.z() * s).normalized();
 }
@@ -373,17 +373,17 @@ QQuaternion QQuaternion::fromAxisAndAngle(const QVector3D& axis, qreal angle)
     \a angle degrees about the 3D axis (\a x, \a y, \a z).
 */
 QQuaternion QQuaternion::fromAxisAndAngle
-        (qreal x, qreal y, qreal z, qreal angle)
+        (float x, float y, float z, float angle)
 {
-    qreal length = qSqrt(x * x + y * y + z * z);
+    float length = qSqrt(x * x + y * y + z * z);
     if (!qFuzzyIsNull(length - 1.0f) && !qFuzzyIsNull(length)) {
         x /= length;
         y /= length;
         z /= length;
     }
-    qreal a = (angle / 2.0f) * M_PI / 180.0f;
-    qreal s = qSin(a);
-    qreal c = qCos(a);
+    float a = (angle / 2.0f) * M_PI / 180.0f;
+    float s = qSin(a);
+    float c = qCos(a);
     return QQuaternion(c, x * s, y * s, z * s).normalized();
 }
 
@@ -424,7 +424,7 @@ QQuaternion QQuaternion::fromAxisAndAngle
 */
 
 /*!
-    \fn const QQuaternion operator*(qreal factor, const QQuaternion &quaternion)
+    \fn const QQuaternion operator*(float factor, const QQuaternion &quaternion)
     \relates QQuaternion
 
     Returns a copy of the given \a quaternion,  multiplied by the
@@ -434,7 +434,7 @@ QQuaternion QQuaternion::fromAxisAndAngle
 */
 
 /*!
-    \fn const QQuaternion operator*(const QQuaternion &quaternion, qreal factor)
+    \fn const QQuaternion operator*(const QQuaternion &quaternion, float factor)
     \relates QQuaternion
 
     Returns a copy of the given \a quaternion,  multiplied by the
@@ -466,7 +466,7 @@ QQuaternion QQuaternion::fromAxisAndAngle
 */
 
 /*!
-    \fn const QQuaternion operator/(const QQuaternion &quaternion, qreal divisor)
+    \fn const QQuaternion operator/(const QQuaternion &quaternion, float divisor)
     \relates QQuaternion
 
     Returns the QQuaternion object formed by dividing all components of
@@ -495,7 +495,7 @@ QQuaternion QQuaternion::fromAxisAndAngle
     \sa nlerp()
 */
 QQuaternion QQuaternion::slerp
-    (const QQuaternion& q1, const QQuaternion& q2, qreal t)
+    (const QQuaternion& q1, const QQuaternion& q2, float t)
 {
     // Handle the easy cases first.
     if (t <= 0.0f)
@@ -505,7 +505,7 @@ QQuaternion QQuaternion::slerp
 
     // Determine the angle between the two quaternions.
     QQuaternion q2b;
-    qreal dot;
+    float dot;
     dot = q1.xp * q2.xp + q1.yp * q2.yp + q1.zp * q2.zp + q1.wp * q2.wp;
     if (dot >= 0.0f) {
         q2b = q2;
@@ -516,14 +516,14 @@ QQuaternion QQuaternion::slerp
 
     // Get the scale factors.  If they are too small,
     // then revert to simple linear interpolation.
-    qreal factor1 = 1.0f - t;
-    qreal factor2 = t;
+    float factor1 = 1.0f - t;
+    float factor2 = t;
     if ((1.0f - dot) > 0.0000001) {
-        qreal angle = qreal(qAcos(dot));
-        qreal sinOfAngle = qreal(qSin(angle));
+        float angle = float(qAcos(dot));
+        float sinOfAngle = float(qSin(angle));
         if (sinOfAngle > 0.0000001) {
-            factor1 = qreal(qSin((1.0f - t) * angle)) / sinOfAngle;
-            factor2 = qreal(qSin(t * angle)) / sinOfAngle;
+            factor1 = float(qSin((1.0f - t) * angle)) / sinOfAngle;
+            factor2 = float(qSin(t * angle)) / sinOfAngle;
         }
     }
 
@@ -547,7 +547,7 @@ QQuaternion QQuaternion::slerp
     \sa slerp()
 */
 QQuaternion QQuaternion::nlerp
-    (const QQuaternion& q1, const QQuaternion& q2, qreal t)
+    (const QQuaternion& q1, const QQuaternion& q2, float t)
 {
     // Handle the easy cases first.
     if (t <= 0.0f)
@@ -557,7 +557,7 @@ QQuaternion QQuaternion::nlerp
 
     // Determine the angle between the two quaternions.
     QQuaternion q2b;
-    qreal dot;
+    float dot;
     dot = q1.xp * q2.xp + q1.yp * q2.yp + q1.zp * q2.zp + q1.wp * q2.wp;
     if (dot >= 0.0f)
         q2b = q2;
@@ -602,8 +602,8 @@ QDebug operator<<(QDebug dbg, const QQuaternion &q)
 
 QDataStream &operator<<(QDataStream &stream, const QQuaternion &quaternion)
 {
-    stream << double(quaternion.scalar()) << double(quaternion.x())
-           << double(quaternion.y()) << double(quaternion.z());
+    stream << quaternion.scalar() << quaternion.x()
+           << quaternion.y() << quaternion.z();
     return stream;
 }
 
@@ -619,15 +619,15 @@ QDataStream &operator<<(QDataStream &stream, const QQuaternion &quaternion)
 
 QDataStream &operator>>(QDataStream &stream, QQuaternion &quaternion)
 {
-    double scalar, x, y, z;
+    float scalar, x, y, z;
     stream >> scalar;
     stream >> x;
     stream >> y;
     stream >> z;
-    quaternion.setScalar(qreal(scalar));
-    quaternion.setX(qreal(x));
-    quaternion.setY(qreal(y));
-    quaternion.setZ(qreal(z));
+    quaternion.setScalar(scalar);
+    quaternion.setX(x);
+    quaternion.setY(y);
+    quaternion.setZ(z);
     return stream;
 }
 
diff --git a/src/gui/math3d/qquaternion.h b/src/gui/math3d/qquaternion.h
index 0a1552f..2188a08 100644
--- a/src/gui/math3d/qquaternion.h
+++ b/src/gui/math3d/qquaternion.h
@@ -59,9 +59,9 @@ class Q_GUI_EXPORT QQuaternion
 {
 public:
     QQuaternion();
-    QQuaternion(qreal scalar, qreal xpos, qreal ypos, qreal zpos);
+    QQuaternion(float scalar, float xpos, float ypos, float zpos);
 #ifndef QT_NO_VECTOR3D
-    QQuaternion(qreal scalar, const QVector3D& vector);
+    QQuaternion(float scalar, const QVector3D& vector);
 #endif
 #ifndef QT_NO_VECTOR4D
     explicit QQuaternion(const QVector4D& vector);
@@ -74,20 +74,20 @@ public:
     QVector3D vector() const;
     void setVector(const QVector3D& vector);
 #endif
-    void setVector(qreal x, qreal y, qreal z);
+    void setVector(float x, float y, float z);
 
-    qreal x() const;
-    qreal y() const;
-    qreal z() const;
-    qreal scalar() const;
+    float x() const;
+    float y() const;
+    float z() const;
+    float scalar() const;
 
-    void setX(qreal x);
-    void setY(qreal y);
-    void setZ(qreal z);
-    void setScalar(qreal scalar);
+    void setX(float x);
+    void setY(float y);
+    void setZ(float z);
+    void setScalar(float scalar);
 
-    qreal length() const;
-    qreal lengthSquared() const;
+    float length() const;
+    float lengthSquared() const;
 
     QQuaternion normalized() const;
     void normalize();
@@ -98,19 +98,19 @@ public:
 
     QQuaternion &operator+=(const QQuaternion &quaternion);
     QQuaternion &operator-=(const QQuaternion &quaternion);
-    QQuaternion &operator*=(qreal factor);
+    QQuaternion &operator*=(float factor);
     QQuaternion &operator*=(const QQuaternion &quaternion);
-    QQuaternion &operator/=(qreal divisor);
+    QQuaternion &operator/=(float divisor);
 
     friend inline bool operator==(const QQuaternion &q1, const QQuaternion &q2);
     friend inline bool operator!=(const QQuaternion &q1, const QQuaternion &q2);
     friend inline const QQuaternion operator+(const QQuaternion &q1, const QQuaternion &q2);
     friend inline const QQuaternion operator-(const QQuaternion &q1, const QQuaternion &q2);
-    friend inline const QQuaternion operator*(qreal factor, const QQuaternion &quaternion);
-    friend inline const QQuaternion operator*(const QQuaternion &quaternion, qreal factor);
+    friend inline const QQuaternion operator*(float factor, const QQuaternion &quaternion);
+    friend inline const QQuaternion operator*(const QQuaternion &quaternion, float factor);
     friend inline const QQuaternion operator*(const QQuaternion &q1, const QQuaternion& q2);
     friend inline const QQuaternion operator-(const QQuaternion &quaternion);
-    friend inline const QQuaternion operator/(const QQuaternion &quaternion, qreal divisor);
+    friend inline const QQuaternion operator/(const QQuaternion &quaternion, float divisor);
 
     friend inline bool qFuzzyCompare(const QQuaternion& q1, const QQuaternion& q2);
 
@@ -121,25 +121,25 @@ public:
     operator QVariant() const;
 
 #ifndef QT_NO_VECTOR3D
-    static QQuaternion fromAxisAndAngle(const QVector3D& axis, qreal angle);
+    static QQuaternion fromAxisAndAngle(const QVector3D& axis, float angle);
 #endif
     static QQuaternion fromAxisAndAngle
-            (qreal x, qreal y, qreal z, qreal angle);
+            (float x, float y, float z, float angle);
 
     static QQuaternion slerp
-        (const QQuaternion& q1, const QQuaternion& q2, qreal t);
+        (const QQuaternion& q1, const QQuaternion& q2, float t);
     static QQuaternion nlerp
-        (const QQuaternion& q1, const QQuaternion& q2, qreal t);
+        (const QQuaternion& q1, const QQuaternion& q2, float t);
 
 private:
-    qreal wp, xp, yp, zp;
+    float wp, xp, yp, zp;
 };
 
 Q_DECLARE_TYPEINFO(QQuaternion, Q_MOVABLE_TYPE);
 
 inline QQuaternion::QQuaternion() : wp(1.0f), xp(0.0f), yp(0.0f), zp(0.0f) {}
 
-inline QQuaternion::QQuaternion(qreal aScalar, qreal xpos, qreal ypos, qreal zpos) : wp(aScalar), xp(xpos), yp(ypos), zp(zpos) {}
+inline QQuaternion::QQuaternion(float aScalar, float xpos, float ypos, float zpos) : wp(aScalar), xp(xpos), yp(ypos), zp(zpos) {}
 
 
 inline bool QQuaternion::isNull() const
@@ -152,15 +152,15 @@ inline bool QQuaternion::isIdentity() const
     return qIsNull(xp) && qIsNull(yp) && qIsNull(zp) && wp == 1.0f;
 }
 
-inline qreal QQuaternion::x() const { return qreal(xp); }
-inline qreal QQuaternion::y() const { return qreal(yp); }
-inline qreal QQuaternion::z() const { return qreal(zp); }
-inline qreal QQuaternion::scalar() const { return qreal(wp); }
+inline float QQuaternion::x() const { return xp; }
+inline float QQuaternion::y() const { return yp; }
+inline float QQuaternion::z() const { return zp; }
+inline float QQuaternion::scalar() const { return wp; }
 
-inline void QQuaternion::setX(qreal aX) { xp = aX; }
-inline void QQuaternion::setY(qreal aY) { yp = aY; }
-inline void QQuaternion::setZ(qreal aZ) { zp = aZ; }
-inline void QQuaternion::setScalar(qreal aScalar) { wp = aScalar; }
+inline void QQuaternion::setX(float aX) { xp = aX; }
+inline void QQuaternion::setY(float aY) { yp = aY; }
+inline void QQuaternion::setZ(float aZ) { zp = aZ; }
+inline void QQuaternion::setScalar(float aScalar) { wp = aScalar; }
 
 inline QQuaternion QQuaternion::conjugate() const
 {
@@ -185,7 +185,7 @@ inline QQuaternion &QQuaternion::operator-=(const QQuaternion &quaternion)
     return *this;
 }
 
-inline QQuaternion &QQuaternion::operator*=(qreal factor)
+inline QQuaternion &QQuaternion::operator*=(float factor)
 {
     xp *= factor;
     yp *= factor;
@@ -196,16 +196,16 @@ inline QQuaternion &QQuaternion::operator*=(qreal factor)
 
 inline const QQuaternion operator*(const QQuaternion &q1, const QQuaternion& q2)
 {
-    qreal ww = (q1.zp + q1.xp) * (q2.xp + q2.yp);
-    qreal yy = (q1.wp - q1.yp) * (q2.wp + q2.zp);
-    qreal zz = (q1.wp + q1.yp) * (q2.wp - q2.zp);
-    qreal xx = ww + yy + zz;
-    qreal qq = 0.5 * (xx + (q1.zp - q1.xp) * (q2.xp - q2.yp));
+    float ww = (q1.zp + q1.xp) * (q2.xp + q2.yp);
+    float yy = (q1.wp - q1.yp) * (q2.wp + q2.zp);
+    float zz = (q1.wp + q1.yp) * (q2.wp - q2.zp);
+    float xx = ww + yy + zz;
+    float qq = 0.5 * (xx + (q1.zp - q1.xp) * (q2.xp - q2.yp));
 
-    qreal w = qq - ww + (q1.zp - q1.yp) * (q2.yp - q2.zp);
-    qreal x = qq - xx + (q1.xp + q1.wp) * (q2.xp + q2.wp);
-    qreal y = qq - yy + (q1.wp - q1.xp) * (q2.yp + q2.zp);
-    qreal z = qq - zz + (q1.zp + q1.yp) * (q2.wp - q2.xp);
+    float w = qq - ww + (q1.zp - q1.yp) * (q2.yp - q2.zp);
+    float x = qq - xx + (q1.xp + q1.wp) * (q2.xp + q2.wp);
+    float y = qq - yy + (q1.wp - q1.xp) * (q2.yp + q2.zp);
+    float z = qq - zz + (q1.zp + q1.yp) * (q2.wp - q2.xp);
 
     return QQuaternion(w, x, y, z);
 }
@@ -216,7 +216,7 @@ inline QQuaternion &QQuaternion::operator*=(const QQuaternion &quaternion)
     return *this;
 }
 
-inline QQuaternion &QQuaternion::operator/=(qreal divisor)
+inline QQuaternion &QQuaternion::operator/=(float divisor)
 {
     xp /= divisor;
     yp /= divisor;
@@ -245,12 +245,12 @@ inline const QQuaternion operator-(const QQuaternion &q1, const QQuaternion &q2)
     return QQuaternion(q1.wp - q2.wp, q1.xp - q2.xp, q1.yp - q2.yp, q1.zp - q2.zp);
 }
 
-inline const QQuaternion operator*(qreal factor, const QQuaternion &quaternion)
+inline const QQuaternion operator*(float factor, const QQuaternion &quaternion)
 {
     return QQuaternion(quaternion.wp * factor, quaternion.xp * factor, quaternion.yp * factor, quaternion.zp * factor);
 }
 
-inline const QQuaternion operator*(const QQuaternion &quaternion, qreal factor)
+inline const QQuaternion operator*(const QQuaternion &quaternion, float factor)
 {
     return QQuaternion(quaternion.wp * factor, quaternion.xp * factor, quaternion.yp * factor, quaternion.zp * factor);
 }
@@ -260,7 +260,7 @@ inline const QQuaternion operator-(const QQuaternion &quaternion)
     return QQuaternion(-quaternion.wp, -quaternion.xp, -quaternion.yp, -quaternion.zp);
 }
 
-inline const QQuaternion operator/(const QQuaternion &quaternion, qreal divisor)
+inline const QQuaternion operator/(const QQuaternion &quaternion, float divisor)
 {
     return QQuaternion(quaternion.wp / divisor, quaternion.xp / divisor, quaternion.yp / divisor, quaternion.zp / divisor);
 }
@@ -275,7 +275,7 @@ inline bool qFuzzyCompare(const QQuaternion& q1, const QQuaternion& q2)
 
 #ifndef QT_NO_VECTOR3D
 
-inline QQuaternion::QQuaternion(qreal aScalar, const QVector3D& aVector)
+inline QQuaternion::QQuaternion(float aScalar, const QVector3D& aVector)
     : wp(aScalar), xp(aVector.x()), yp(aVector.y()), zp(aVector.z()) {}
 
 inline void QQuaternion::setVector(const QVector3D& aVector)
@@ -292,7 +292,7 @@ inline QVector3D QQuaternion::vector() const
 
 #endif
 
-inline void QQuaternion::setVector(qreal aX, qreal aY, qreal aZ)
+inline void QQuaternion::setVector(float aX, float aY, float aZ)
 {
     xp = aX;
     yp = aY;
diff --git a/src/gui/math3d/qvector2d.cpp b/src/gui/math3d/qvector2d.cpp
index 672e2e4..5d542c6 100644
--- a/src/gui/math3d/qvector2d.cpp
+++ b/src/gui/math3d/qvector2d.cpp
@@ -62,11 +62,6 @@ QT_BEGIN_NAMESPACE
     The QVector2D class can also be used to represent vertices in 2D space.
     We therefore do not need to provide a separate vertex class.
 
-    \b{Note:} By design values in the QVector2D instance are stored as \c float.
-    This means that on platforms where the \c qreal arguments to QVector2D
-    functions are represented by \c double values, it is possible to
-    lose precision.
-
     \sa QVector3D, QVector4D, QQuaternion
 */
 
@@ -77,7 +72,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn QVector2D::QVector2D(qreal xpos, qreal ypos)
+    \fn QVector2D::QVector2D(float xpos, float ypos)
 
     Constructs a vector with coordinates (\a xpos, \a ypos).
 */
@@ -134,7 +129,7 @@ QVector2D::QVector2D(const QVector4D& vector)
 */
 
 /*!
-    \fn qreal QVector2D::x() const
+    \fn float QVector2D::x() const
 
     Returns the x coordinate of this point.
 
@@ -142,7 +137,7 @@ QVector2D::QVector2D(const QVector4D& vector)
 */
 
 /*!
-    \fn qreal QVector2D::y() const
+    \fn float QVector2D::y() const
 
     Returns the y coordinate of this point.
 
@@ -150,7 +145,7 @@ QVector2D::QVector2D(const QVector4D& vector)
 */
 
 /*!
-    \fn void QVector2D::setX(qreal x)
+    \fn void QVector2D::setX(float x)
 
     Sets the x coordinate of this point to the given \a x coordinate.
 
@@ -158,7 +153,7 @@ QVector2D::QVector2D(const QVector4D& vector)
 */
 
 /*!
-    \fn void QVector2D::setY(qreal y)
+    \fn void QVector2D::setY(float y)
 
     Sets the y coordinate of this point to the given \a y coordinate.
 
@@ -170,9 +165,12 @@ QVector2D::QVector2D(const QVector4D& vector)
 
     \sa lengthSquared(), normalized()
 */
-qreal QVector2D::length() const
+float QVector2D::length() const
 {
-    return qSqrt(xp * xp + yp * yp);
+    // Need some extra precision if the length is very small.
+    double len = double(xp) * double(xp) +
+                 double(yp) * double(yp);
+    return float(sqrt(len));
 }
 
 /*!
@@ -181,7 +179,7 @@ qreal QVector2D::length() const
 
     \sa length(), dotProduct()
 */
-qreal QVector2D::lengthSquared() const
+float QVector2D::lengthSquared() const
 {
     return xp * xp + yp * yp;
 }
@@ -200,12 +198,14 @@ QVector2D QVector2D::normalized() const
     // Need some extra precision if the length is very small.
     double len = double(xp) * double(xp) +
                  double(yp) * double(yp);
-    if (qFuzzyIsNull(len - 1.0f))
+    if (qFuzzyIsNull(len - 1.0f)) {
         return *this;
-    else if (!qFuzzyIsNull(len))
-        return *this / qSqrt(len);
-    else
+    } else if (!qFuzzyIsNull(len)) {
+        double sqrtLen = sqrt(len);
+        return QVector2D(float(double(xp) / sqrtLen), float(double(yp) / sqrtLen));
+    } else {
         return QVector2D();
+    }
 }
 
 /*!
@@ -222,10 +222,10 @@ void QVector2D::normalize()
     if (qFuzzyIsNull(len - 1.0f) || qFuzzyIsNull(len))
         return;
 
-    len = qSqrt(len);
+    len = sqrt(len);
 
-    xp /= len;
-    yp /= len;
+    xp = float(double(xp) / len);
+    yp = float(double(yp) / len);
 }
 
 /*!
@@ -247,7 +247,7 @@ void QVector2D::normalize()
 */
 
 /*!
-    \fn QVector2D &QVector2D::operator*=(qreal factor)
+    \fn QVector2D &QVector2D::operator*=(float factor)
 
     Multiplies this vector's coordinates by the given \a factor, and
     returns a reference to this vector.
@@ -263,7 +263,7 @@ void QVector2D::normalize()
 */
 
 /*!
-    \fn QVector2D &QVector2D::operator/=(qreal divisor)
+    \fn QVector2D &QVector2D::operator/=(float divisor)
 
     Divides this vector's coordinates by the given \a divisor, and
     returns a reference to this vector.
@@ -274,7 +274,7 @@ void QVector2D::normalize()
 /*!
     Returns the dot product of \a v1 and \a v2.
 */
-qreal QVector2D::dotProduct(const QVector2D& v1, const QVector2D& v2)
+float QVector2D::dotProduct(const QVector2D& v1, const QVector2D& v2)
 {
     return v1.xp * v2.xp + v1.yp * v2.yp;
 }
@@ -316,7 +316,7 @@ qreal QVector2D::dotProduct(const QVector2D& v1, const QVector2D& v2)
 */
 
 /*!
-    \fn const QVector2D operator*(qreal factor, const QVector2D &vector)
+    \fn const QVector2D operator*(float factor, const QVector2D &vector)
     \relates QVector2D
 
     Returns a copy of the given \a vector,  multiplied by the given \a factor.
@@ -325,7 +325,7 @@ qreal QVector2D::dotProduct(const QVector2D& v1, const QVector2D& v2)
 */
 
 /*!
-    \fn const QVector2D operator*(const QVector2D &vector, qreal factor)
+    \fn const QVector2D operator*(const QVector2D &vector, float factor)
     \relates QVector2D
 
     Returns a copy of the given \a vector,  multiplied by the given \a factor.
@@ -353,7 +353,7 @@ qreal QVector2D::dotProduct(const QVector2D& v1, const QVector2D& v2)
 */
 
 /*!
-    \fn const QVector2D operator/(const QVector2D &vector, qreal divisor)
+    \fn const QVector2D operator/(const QVector2D &vector, float divisor)
     \relates QVector2D
 
     Returns the QVector2D object formed by dividing all three components of
@@ -379,7 +379,7 @@ qreal QVector2D::dotProduct(const QVector2D& v1, const QVector2D& v2)
 */
 QVector3D QVector2D::toVector3D() const
 {
-    return QVector3D(xp, yp, 0.0f, 1);
+    return QVector3D(xp, yp, 0.0f);
 }
 
 #endif
@@ -393,7 +393,7 @@ QVector3D QVector2D::toVector3D() const
 */
 QVector4D QVector2D::toVector4D() const
 {
-    return QVector4D(xp, yp, 0.0f, 0.0f, 1);
+    return QVector4D(xp, yp, 0.0f, 0.0f);
 }
 
 #endif
@@ -446,7 +446,7 @@ QDebug operator<<(QDebug dbg, const QVector2D &vector)
 
 QDataStream &operator<<(QDataStream &stream, const QVector2D &vector)
 {
-    stream << double(vector.x()) << double(vector.y());
+    stream << vector.x() << vector.y();
     return stream;
 }
 
@@ -462,11 +462,11 @@ QDataStream &operator<<(QDataStream &stream, const QVector2D &vector)
 
 QDataStream &operator>>(QDataStream &stream, QVector2D &vector)
 {
-    double x, y;
+    float x, y;
     stream >> x;
     stream >> y;
-    vector.setX(qreal(x));
-    vector.setY(qreal(y));
+    vector.setX(x);
+    vector.setY(y);
     return stream;
 }
 
diff --git a/src/gui/math3d/qvector2d.h b/src/gui/math3d/qvector2d.h
index 882845d..34893c2 100644
--- a/src/gui/math3d/qvector2d.h
+++ b/src/gui/math3d/qvector2d.h
@@ -60,7 +60,7 @@ class Q_GUI_EXPORT QVector2D
 {
 public:
     QVector2D();
-    QVector2D(qreal xpos, qreal ypos);
+    QVector2D(float xpos, float ypos);
     explicit QVector2D(const QPoint& point);
     explicit QVector2D(const QPointF& point);
 #ifndef QT_NO_VECTOR3D
@@ -72,35 +72,35 @@ public:
 
     bool isNull() const;
 
-    qreal x() const;
-    qreal y() const;
+    float x() const;
+    float y() const;
 
-    void setX(qreal x);
-    void setY(qreal y);
+    void setX(float x);
+    void setY(float y);
 
-    qreal length() const;
-    qreal lengthSquared() const;
+    float length() const;
+    float lengthSquared() const;
 
     QVector2D normalized() const;
     void normalize();
 
     QVector2D &operator+=(const QVector2D &vector);
     QVector2D &operator-=(const QVector2D &vector);
-    QVector2D &operator*=(qreal factor);
+    QVector2D &operator*=(float factor);
     QVector2D &operator*=(const QVector2D &vector);
-    QVector2D &operator/=(qreal divisor);
+    QVector2D &operator/=(float divisor);
 
-    static qreal dotProduct(const QVector2D& v1, const QVector2D& v2);
+    static float dotProduct(const QVector2D& v1, const QVector2D& v2);
 
     friend inline bool operator==(const QVector2D &v1, const QVector2D &v2);
     friend inline bool operator!=(const QVector2D &v1, const QVector2D &v2);
     friend inline const QVector2D operator+(const QVector2D &v1, const QVector2D &v2);
     friend inline const QVector2D operator-(const QVector2D &v1, const QVector2D &v2);
-    friend inline const QVector2D operator*(qreal factor, const QVector2D &vector);
-    friend inline const QVector2D operator*(const QVector2D &vector, qreal factor);
+    friend inline const QVector2D operator*(float factor, const QVector2D &vector);
+    friend inline const QVector2D operator*(const QVector2D &vector, float factor);
     friend inline const QVector2D operator*(const QVector2D &v1, const QVector2D &v2);
     friend inline const QVector2D operator-(const QVector2D &vector);
-    friend inline const QVector2D operator/(const QVector2D &vector, qreal divisor);
+    friend inline const QVector2D operator/(const QVector2D &vector, float divisor);
 
     friend inline bool qFuzzyCompare(const QVector2D& v1, const QVector2D& v2);
 
@@ -119,8 +119,6 @@ public:
 private:
     float xp, yp;
 
-    QVector2D(float xpos, float ypos, int dummy);
-
     friend class QVector3D;
     friend class QVector4D;
 };
@@ -129,9 +127,7 @@ Q_DECLARE_TYPEINFO(QVector2D, Q_MOVABLE_TYPE);
 
 inline QVector2D::QVector2D() : xp(0.0f), yp(0.0f) {}
 
-inline QVector2D::QVector2D(float xpos, float ypos, int) : xp(xpos), yp(ypos) {}
-
-inline QVector2D::QVector2D(qreal xpos, qreal ypos) : xp(xpos), yp(ypos) {}
+inline QVector2D::QVector2D(float xpos, float ypos) : xp(xpos), yp(ypos) {}
 
 inline QVector2D::QVector2D(const QPoint& point) : xp(point.x()), yp(point.y()) {}
 
@@ -142,11 +138,11 @@ inline bool QVector2D::isNull() const
     return qIsNull(xp) && qIsNull(yp);
 }
 
-inline qreal QVector2D::x() const { return qreal(xp); }
-inline qreal QVector2D::y() const { return qreal(yp); }
+inline float QVector2D::x() const { return xp; }
+inline float QVector2D::y() const { return yp; }
 
-inline void QVector2D::setX(qreal aX) { xp = aX; }
-inline void QVector2D::setY(qreal aY) { yp = aY; }
+inline void QVector2D::setX(float aX) { xp = aX; }
+inline void QVector2D::setY(float aY) { yp = aY; }
 
 inline QVector2D &QVector2D::operator+=(const QVector2D &vector)
 {
@@ -162,7 +158,7 @@ inline QVector2D &QVector2D::operator-=(const QVector2D &vector)
     return *this;
 }
 
-inline QVector2D &QVector2D::operator*=(qreal factor)
+inline QVector2D &QVector2D::operator*=(float factor)
 {
     xp *= factor;
     yp *= factor;
@@ -176,7 +172,7 @@ inline QVector2D &QVector2D::operator*=(const QVector2D &vector)
     return *this;
 }
 
-inline QVector2D &QVector2D::operator/=(qreal divisor)
+inline QVector2D &QVector2D::operator/=(float divisor)
 {
     xp /= divisor;
     yp /= divisor;
@@ -195,37 +191,37 @@ inline bool operator!=(const QVector2D &v1, const QVector2D &v2)
 
 inline const QVector2D operator+(const QVector2D &v1, const QVector2D &v2)
 {
-    return QVector2D(v1.xp + v2.xp, v1.yp + v2.yp, 1);
+    return QVector2D(v1.xp + v2.xp, v1.yp + v2.yp);
 }
 
 inline const QVector2D operator-(const QVector2D &v1, const QVector2D &v2)
 {
-    return QVector2D(v1.xp - v2.xp, v1.yp - v2.yp, 1);
+    return QVector2D(v1.xp - v2.xp, v1.yp - v2.yp);
 }
 
-inline const QVector2D operator*(qreal factor, const QVector2D &vector)
+inline const QVector2D operator*(float factor, const QVector2D &vector)
 {
-    return QVector2D(vector.xp * factor, vector.yp * factor, 1);
+    return QVector2D(vector.xp * factor, vector.yp * factor);
 }
 
-inline const QVector2D operator*(const QVector2D &vector, qreal factor)
+inline const QVector2D operator*(const QVector2D &vector, float factor)
 {
-    return QVector2D(vector.xp * factor, vector.yp * factor, 1);
+    return QVector2D(vector.xp * factor, vector.yp * factor);
 }
 
 inline const QVector2D operator*(const QVector2D &v1, const QVector2D &v2)
 {
-    return QVector2D(v1.xp * v2.xp, v1.yp * v2.yp, 1);
+    return QVector2D(v1.xp * v2.xp, v1.yp * v2.yp);
 }
 
 inline const QVector2D operator-(const QVector2D &vector)
 {
-    return QVector2D(-vector.xp, -vector.yp, 1);
+    return QVector2D(-vector.xp, -vector.yp);
 }
 
-inline const QVector2D operator/(const QVector2D &vector, qreal divisor)
+inline const QVector2D operator/(const QVector2D &vector, float divisor)
 {
-    return QVector2D(vector.xp / divisor, vector.yp / divisor, 1);
+    return QVector2D(vector.xp / divisor, vector.yp / divisor);
 }
 
 inline bool qFuzzyCompare(const QVector2D& v1, const QVector2D& v2)
diff --git a/src/gui/math3d/qvector3d.cpp b/src/gui/math3d/qvector3d.cpp
index 076f5c9..8002ef9 100644
--- a/src/gui/math3d/qvector3d.cpp
+++ b/src/gui/math3d/qvector3d.cpp
@@ -65,11 +65,6 @@ QT_BEGIN_NAMESPACE
     The QVector3D class can also be used to represent vertices in 3D space.
     We therefore do not need to provide a separate vertex class.
 
-    \b{Note:} By design values in the QVector3D instance are stored as \c float.
-    This means that on platforms where the \c qreal arguments to QVector3D
-    functions are represented by \c double values, it is possible to
-    lose precision.
-
     \sa QVector2D, QVector4D, QQuaternion
 */
 
@@ -80,7 +75,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn QVector3D::QVector3D(qreal xpos, qreal ypos, qreal zpos)
+    \fn QVector3D::QVector3D(float xpos, float ypos, float zpos)
 
     Constructs a vector with coordinates (\a xpos, \a ypos, \a zpos).
 */
@@ -120,7 +115,7 @@ QVector3D::QVector3D(const QVector2D& vector)
 
     \sa toVector2D()
 */
-QVector3D::QVector3D(const QVector2D& vector, qreal zpos)
+QVector3D::QVector3D(const QVector2D& vector, float zpos)
 {
     xp = vector.xp;
     yp = vector.yp;
@@ -154,7 +149,7 @@ QVector3D::QVector3D(const QVector4D& vector)
 */
 
 /*!
-    \fn qreal QVector3D::x() const
+    \fn float QVector3D::x() const
 
     Returns the x coordinate of this point.
 
@@ -162,7 +157,7 @@ QVector3D::QVector3D(const QVector4D& vector)
 */
 
 /*!
-    \fn qreal QVector3D::y() const
+    \fn float QVector3D::y() const
 
     Returns the y coordinate of this point.
 
@@ -170,7 +165,7 @@ QVector3D::QVector3D(const QVector4D& vector)
 */
 
 /*!
-    \fn qreal QVector3D::z() const
+    \fn float QVector3D::z() const
 
     Returns the z coordinate of this point.
 
@@ -178,7 +173,7 @@ QVector3D::QVector3D(const QVector4D& vector)
 */
 
 /*!
-    \fn void QVector3D::setX(qreal x)
+    \fn void QVector3D::setX(float x)
 
     Sets the x coordinate of this point to the given \a x coordinate.
 
@@ -186,7 +181,7 @@ QVector3D::QVector3D(const QVector4D& vector)
 */
 
 /*!
-    \fn void QVector3D::setY(qreal y)
+    \fn void QVector3D::setY(float y)
 
     Sets the y coordinate of this point to the given \a y coordinate.
 
@@ -194,7 +189,7 @@ QVector3D::QVector3D(const QVector4D& vector)
 */
 
 /*!
-    \fn void QVector3D::setZ(qreal z)
+    \fn void QVector3D::setZ(float z)
 
     Sets the z coordinate of this point to the given \a z coordinate.
 
@@ -216,12 +211,16 @@ QVector3D QVector3D::normalized() const
     double len = double(xp) * double(xp) +
                  double(yp) * double(yp) +
                  double(zp) * double(zp);
-    if (qFuzzyIsNull(len - 1.0f))
+    if (qFuzzyIsNull(len - 1.0f)) {
         return *this;
-    else if (!qFuzzyIsNull(len))
-        return *this / qSqrt(len);
-    else
+    } else if (!qFuzzyIsNull(len)) {
+        double sqrtLen = sqrt(len);
+        return QVector3D(float(double(xp) / sqrtLen),
+                         float(double(yp) / sqrtLen),
+                         float(double(zp) / sqrtLen));
+    } else {
         return QVector3D();
+    }
 }
 
 /*!
@@ -239,11 +238,11 @@ void QVector3D::normalize()
     if (qFuzzyIsNull(len - 1.0f) || qFuzzyIsNull(len))
         return;
 
-    len = qSqrt(len);
+    len = sqrt(len);
 
-    xp /= len;
-    yp /= len;
-    zp /= len;
+    xp = float(double(xp) / len);
+    yp = float(double(yp) / len);
+    zp = float(double(zp) / len);
 }
 
 /*!
@@ -265,7 +264,7 @@ void QVector3D::normalize()
 */
 
 /*!
-    \fn QVector3D &QVector3D::operator*=(qreal factor)
+    \fn QVector3D &QVector3D::operator*=(float factor)
 
     Multiplies this vector's coordinates by the given \a factor, and
     returns a reference to this vector.
@@ -287,7 +286,7 @@ void QVector3D::normalize()
 */
 
 /*!
-    \fn QVector3D &QVector3D::operator/=(qreal divisor)
+    \fn QVector3D &QVector3D::operator/=(float divisor)
 
     Divides this vector's coordinates by the given \a divisor, and
     returns a reference to this vector.
@@ -298,7 +297,7 @@ void QVector3D::normalize()
 /*!
     Returns the dot product of \a v1 and \a v2.
 */
-qreal QVector3D::dotProduct(const QVector3D& v1, const QVector3D& v2)
+float QVector3D::dotProduct(const QVector3D& v1, const QVector3D& v2)
 {
     return v1.xp * v2.xp + v1.yp * v2.yp + v1.zp * v2.zp;
 }
@@ -312,8 +311,8 @@ qreal QVector3D::dotProduct(const QVector3D& v1, const QVector3D& v2)
 QVector3D QVector3D::crossProduct(const QVector3D& v1, const QVector3D& v2)
 {
     return QVector3D(v1.yp * v2.zp - v1.zp * v2.yp,
-                    v1.zp * v2.xp - v1.xp * v2.zp,
-                    v1.xp * v2.yp - v1.yp * v2.xp, 1);
+                     v1.zp * v2.xp - v1.xp * v2.zp,
+                     v1.xp * v2.yp - v1.yp * v2.xp);
 }
 
 /*!
@@ -358,7 +357,7 @@ QVector3D QVector3D::normal
 
     \sa normal(), distanceToLine()
 */
-qreal QVector3D::distanceToPlane
+float QVector3D::distanceToPlane
         (const QVector3D& plane, const QVector3D& normal) const
 {
     return dotProduct(*this - plane, normal);
@@ -378,7 +377,7 @@ qreal QVector3D::distanceToPlane
 
     \sa normal(), distanceToLine()
 */
-qreal QVector3D::distanceToPlane
+float QVector3D::distanceToPlane
     (const QVector3D& plane1, const QVector3D& plane2, const QVector3D& plane3) const
 {
     QVector3D n = normal(plane2 - plane1, plane3 - plane1);
@@ -394,7 +393,7 @@ qreal QVector3D::distanceToPlane
 
     \sa distanceToPlane()
 */
-qreal QVector3D::distanceToLine
+float QVector3D::distanceToLine
         (const QVector3D& point, const QVector3D& direction) const
 {
     if (direction.isNull())
@@ -440,7 +439,7 @@ qreal QVector3D::distanceToLine
 */
 
 /*!
-    \fn const QVector3D operator*(qreal factor, const QVector3D &vector)
+    \fn const QVector3D operator*(float factor, const QVector3D &vector)
     \relates QVector3D
 
     Returns a copy of the given \a vector,  multiplied by the given \a factor.
@@ -449,7 +448,7 @@ qreal QVector3D::distanceToLine
 */
 
 /*!
-    \fn const QVector3D operator*(const QVector3D &vector, qreal factor)
+    \fn const QVector3D operator*(const QVector3D &vector, float factor)
     \relates QVector3D
 
     Returns a copy of the given \a vector,  multiplied by the given \a factor.
@@ -480,7 +479,7 @@ qreal QVector3D::distanceToLine
 */
 
 /*!
-    \fn const QVector3D operator/(const QVector3D &vector, qreal divisor)
+    \fn const QVector3D operator/(const QVector3D &vector, float divisor)
     \relates QVector3D
 
     Returns the QVector3D object formed by dividing all three components of
@@ -506,7 +505,7 @@ qreal QVector3D::distanceToLine
 */
 QVector2D QVector3D::toVector2D() const
 {
-    return QVector2D(xp, yp, 1);
+    return QVector2D(xp, yp);
 }
 
 #endif
@@ -520,7 +519,7 @@ QVector2D QVector3D::toVector2D() const
 */
 QVector4D QVector3D::toVector4D() const
 {
-    return QVector4D(xp, yp, zp, 0.0f, 1);
+    return QVector4D(xp, yp, zp, 0.0f);
 }
 
 #endif
@@ -556,9 +555,13 @@ QVector3D::operator QVariant() const
 
     \sa lengthSquared(), normalized()
 */
-qreal QVector3D::length() const
+float QVector3D::length() const
 {
-    return qSqrt(xp * xp + yp * yp + zp * zp);
+    // Need some extra precision if the length is very small.
+    double len = double(xp) * double(xp) +
+                 double(yp) * double(yp) +
+                 double(zp) * double(zp);
+    return float(sqrt(len));
 }
 
 /*!
@@ -567,7 +570,7 @@ qreal QVector3D::length() const
 
     \sa length(), dotProduct()
 */
-qreal QVector3D::lengthSquared() const
+float QVector3D::lengthSquared() const
 {
     return xp * xp + yp * yp + zp * zp;
 }
@@ -597,8 +600,7 @@ QDebug operator<<(QDebug dbg, const QVector3D &vector)
 
 QDataStream &operator<<(QDataStream &stream, const QVector3D &vector)
 {
-    stream << double(vector.x()) << double(vector.y())
-           << double(vector.z());
+    stream << vector.x() << vector.y() << vector.z();
     return stream;
 }
 
@@ -614,13 +616,13 @@ QDataStream &operator<<(QDataStream &stream, const QVector3D &vector)
 
 QDataStream &operator>>(QDataStream &stream, QVector3D &vector)
 {
-    double x, y, z;
+    float x, y, z;
     stream >> x;
     stream >> y;
     stream >> z;
-    vector.setX(qreal(x));
-    vector.setY(qreal(y));
-    vector.setZ(qreal(z));
+    vector.setX(x);
+    vector.setY(y);
+    vector.setZ(z);
     return stream;
 }
 
diff --git a/src/gui/math3d/qvector3d.h b/src/gui/math3d/qvector3d.h
index d02fa7d..d6a8901 100644
--- a/src/gui/math3d/qvector3d.h
+++ b/src/gui/math3d/qvector3d.h
@@ -60,12 +60,12 @@ class Q_GUI_EXPORT QVector3D
 {
 public:
     QVector3D();
-    QVector3D(qreal xpos, qreal ypos, qreal zpos);
+    QVector3D(float xpos, float ypos, float zpos);
     explicit QVector3D(const QPoint& point);
     explicit QVector3D(const QPointF& point);
 #ifndef QT_NO_VECTOR2D
     QVector3D(const QVector2D& vector);
-    QVector3D(const QVector2D& vector, qreal zpos);
+    QVector3D(const QVector2D& vector, float zpos);
 #endif
 #ifndef QT_NO_VECTOR4D
     explicit QVector3D(const QVector4D& vector);
@@ -73,45 +73,45 @@ public:
 
     bool isNull() const;
 
-    qreal x() const;
-    qreal y() const;
-    qreal z() const;
+    float x() const;
+    float y() const;
+    float z() const;
 
-    void setX(qreal x);
-    void setY(qreal y);
-    void setZ(qreal z);
+    void setX(float x);
+    void setY(float y);
+    void setZ(float z);
 
-    qreal length() const;
-    qreal lengthSquared() const;
+    float length() const;
+    float lengthSquared() const;
 
     QVector3D normalized() const;
     void normalize();
 
     QVector3D &operator+=(const QVector3D &vector);
     QVector3D &operator-=(const QVector3D &vector);
-    QVector3D &operator*=(qreal factor);
+    QVector3D &operator*=(float factor);
     QVector3D &operator*=(const QVector3D& vector);
-    QVector3D &operator/=(qreal divisor);
+    QVector3D &operator/=(float divisor);
 
-    static qreal dotProduct(const QVector3D& v1, const QVector3D& v2);
+    static float dotProduct(const QVector3D& v1, const QVector3D& v2);
     static QVector3D crossProduct(const QVector3D& v1, const QVector3D& v2);
     static QVector3D normal(const QVector3D& v1, const QVector3D& v2);
     static QVector3D normal
         (const QVector3D& v1, const QVector3D& v2, const QVector3D& v3);
 
-    qreal distanceToPlane(const QVector3D& plane, const QVector3D& normal) const;
-    qreal distanceToPlane(const QVector3D& plane1, const QVector3D& plane2, const QVector3D& plane3) const;
-    qreal distanceToLine(const QVector3D& point, const QVector3D& direction) const;
+    float distanceToPlane(const QVector3D& plane, const QVector3D& normal) const;
+    float distanceToPlane(const QVector3D& plane1, const QVector3D& plane2, const QVector3D& plane3) const;
+    float distanceToLine(const QVector3D& point, const QVector3D& direction) const;
 
     friend inline bool operator==(const QVector3D &v1, const QVector3D &v2);
     friend inline bool operator!=(const QVector3D &v1, const QVector3D &v2);
     friend inline const QVector3D operator+(const QVector3D &v1, const QVector3D &v2);
     friend inline const QVector3D operator-(const QVector3D &v1, const QVector3D &v2);
-    friend inline const QVector3D operator*(qreal factor, const QVector3D &vector);
-    friend inline const QVector3D operator*(const QVector3D &vector, qreal factor);
+    friend inline const QVector3D operator*(float factor, const QVector3D &vector);
+    friend inline const QVector3D operator*(const QVector3D &vector, float factor);
     friend const QVector3D operator*(const QVector3D &v1, const QVector3D& v2);
     friend inline const QVector3D operator-(const QVector3D &vector);
-    friend inline const QVector3D operator/(const QVector3D &vector, qreal divisor);
+    friend inline const QVector3D operator/(const QVector3D &vector, float divisor);
 
     friend inline bool qFuzzyCompare(const QVector3D& v1, const QVector3D& v2);
 
@@ -130,8 +130,6 @@ public:
 private:
     float xp, yp, zp;
 
-    QVector3D(float xpos, float ypos, float zpos, int dummy);
-
     friend class QVector2D;
     friend class QVector4D;
 #ifndef QT_NO_MATRIX4X4
@@ -144,9 +142,7 @@ Q_DECLARE_TYPEINFO(QVector3D, Q_MOVABLE_TYPE);
 
 inline QVector3D::QVector3D() : xp(0.0f), yp(0.0f), zp(0.0f) {}
 
-inline QVector3D::QVector3D(qreal xpos, qreal ypos, qreal zpos) : xp(xpos), yp(ypos), zp(zpos) {}
-
-inline QVector3D::QVector3D(float xpos, float ypos, float zpos, int) : xp(xpos), yp(ypos), zp(zpos) {}
+inline QVector3D::QVector3D(float xpos, float ypos, float zpos) : xp(xpos), yp(ypos), zp(zpos) {}
 
 inline QVector3D::QVector3D(const QPoint& point) : xp(point.x()), yp(point.y()), zp(0.0f) {}
 
@@ -157,13 +153,13 @@ inline bool QVector3D::isNull() const
     return qIsNull(xp) && qIsNull(yp) && qIsNull(zp);
 }
 
-inline qreal QVector3D::x() const { return qreal(xp); }
-inline qreal QVector3D::y() const { return qreal(yp); }
-inline qreal QVector3D::z() const { return qreal(zp); }
+inline float QVector3D::x() const { return xp; }
+inline float QVector3D::y() const { return yp; }
+inline float QVector3D::z() const { return zp; }
 
-inline void QVector3D::setX(qreal aX) { xp = aX; }
-inline void QVector3D::setY(qreal aY) { yp = aY; }
-inline void QVector3D::setZ(qreal aZ) { zp = aZ; }
+inline void QVector3D::setX(float aX) { xp = aX; }
+inline void QVector3D::setY(float aY) { yp = aY; }
+inline void QVector3D::setZ(float aZ) { zp = aZ; }
 
 inline QVector3D &QVector3D::operator+=(const QVector3D &vector)
 {
@@ -181,7 +177,7 @@ inline QVector3D &QVector3D::operator-=(const QVector3D &vector)
     return *this;
 }
 
-inline QVector3D &QVector3D::operator*=(qreal factor)
+inline QVector3D &QVector3D::operator*=(float factor)
 {
     xp *= factor;
     yp *= factor;
@@ -197,7 +193,7 @@ inline QVector3D &QVector3D::operator*=(const QVector3D& vector)
     return *this;
 }
 
-inline QVector3D &QVector3D::operator/=(qreal divisor)
+inline QVector3D &QVector3D::operator/=(float divisor)
 {
     xp /= divisor;
     yp /= divisor;
@@ -217,37 +213,37 @@ inline bool operator!=(const QVector3D &v1, const QVector3D &v2)
 
 inline const QVector3D operator+(const QVector3D &v1, const QVector3D &v2)
 {
-    return QVector3D(v1.xp + v2.xp, v1.yp + v2.yp, v1.zp + v2.zp, 1);
+    return QVector3D(v1.xp + v2.xp, v1.yp + v2.yp, v1.zp + v2.zp);
 }
 
 inline const QVector3D operator-(const QVector3D &v1, const QVector3D &v2)
 {
-    return QVector3D(v1.xp - v2.xp, v1.yp - v2.yp, v1.zp - v2.zp, 1);
+    return QVector3D(v1.xp - v2.xp, v1.yp - v2.yp, v1.zp - v2.zp);
 }
 
-inline const QVector3D operator*(qreal factor, const QVector3D &vector)
+inline const QVector3D operator*(float factor, const QVector3D &vector)
 {
-    return QVector3D(vector.xp * factor, vector.yp * factor, vector.zp * factor, 1);
+    return QVector3D(vector.xp * factor, vector.yp * factor, vector.zp * factor);
 }
 
-inline const QVector3D operator*(const QVector3D &vector, qreal factor)
+inline const QVector3D operator*(const QVector3D &vector, float factor)
 {
-    return QVector3D(vector.xp * factor, vector.yp * factor, vector.zp * factor, 1);
+    return QVector3D(vector.xp * factor, vector.yp * factor, vector.zp * factor);
 }
 
 inline const QVector3D operator*(const QVector3D &v1, const QVector3D& v2)
 {
-    return QVector3D(v1.xp * v2.xp, v1.yp * v2.yp, v1.zp * v2.zp, 1);
+    return QVector3D(v1.xp * v2.xp, v1.yp * v2.yp, v1.zp * v2.zp);
 }
 
 inline const QVector3D operator-(const QVector3D &vector)
 {
-    return QVector3D(-vector.xp, -vector.yp, -vector.zp, 1);
+    return QVector3D(-vector.xp, -vector.yp, -vector.zp);
 }
 
-inline const QVector3D operator/(const QVector3D &vector, qreal divisor)
+inline const QVector3D operator/(const QVector3D &vector, float divisor)
 {
-    return QVector3D(vector.xp / divisor, vector.yp / divisor, vector.zp / divisor, 1);
+    return QVector3D(vector.xp / divisor, vector.yp / divisor, vector.zp / divisor);
 }
 
 inline bool qFuzzyCompare(const QVector3D& v1, const QVector3D& v2)
diff --git a/src/gui/math3d/qvector4d.cpp b/src/gui/math3d/qvector4d.cpp
index a188333..81eedae 100644
--- a/src/gui/math3d/qvector4d.cpp
+++ b/src/gui/math3d/qvector4d.cpp
@@ -61,11 +61,6 @@ QT_BEGIN_NAMESPACE
     The QVector4D class can also be used to represent vertices in 4D space.
     We therefore do not need to provide a separate vertex class.
 
-    \b{Note:} By design values in the QVector4D instance are stored as \c float.
-    This means that on platforms where the \c qreal arguments to QVector4D
-    functions are represented by \c double values, it is possible to
-    lose precision.
-
     \sa QQuaternion, QVector2D, QVector3D
 */
 
@@ -76,7 +71,7 @@ QT_BEGIN_NAMESPACE
 */
 
 /*!
-    \fn QVector4D::QVector4D(qreal xpos, qreal ypos, qreal zpos, qreal wpos)
+    \fn QVector4D::QVector4D(float xpos, float ypos, float zpos, float wpos)
 
     Constructs a vector with coordinates (\a xpos, \a ypos, \a zpos, \a wpos).
 */
@@ -117,7 +112,7 @@ QVector4D::QVector4D(const QVector2D& vector)
 
     \sa toVector2D()
 */
-QVector4D::QVector4D(const QVector2D& vector, qreal zpos, qreal wpos)
+QVector4D::QVector4D(const QVector2D& vector, float zpos, float wpos)
 {
     xp = vector.xp;
     yp = vector.yp;
@@ -149,7 +144,7 @@ QVector4D::QVector4D(const QVector3D& vector)
 
     \sa toVector3D()
 */
-QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
+QVector4D::QVector4D(const QVector3D& vector, float wpos)
 {
     xp = vector.xp;
     yp = vector.yp;
@@ -167,7 +162,7 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 */
 
 /*!
-    \fn qreal QVector4D::x() const
+    \fn float QVector4D::x() const
 
     Returns the x coordinate of this point.
 
@@ -175,7 +170,7 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 */
 
 /*!
-    \fn qreal QVector4D::y() const
+    \fn float QVector4D::y() const
 
     Returns the y coordinate of this point.
 
@@ -183,7 +178,7 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 */
 
 /*!
-    \fn qreal QVector4D::z() const
+    \fn float QVector4D::z() const
 
     Returns the z coordinate of this point.
 
@@ -191,7 +186,7 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 */
 
 /*!
-    \fn qreal QVector4D::w() const
+    \fn float QVector4D::w() const
 
     Returns the w coordinate of this point.
 
@@ -199,7 +194,7 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 */
 
 /*!
-    \fn void QVector4D::setX(qreal x)
+    \fn void QVector4D::setX(float x)
 
     Sets the x coordinate of this point to the given \a x coordinate.
 
@@ -207,7 +202,7 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 */
 
 /*!
-    \fn void QVector4D::setY(qreal y)
+    \fn void QVector4D::setY(float y)
 
     Sets the y coordinate of this point to the given \a y coordinate.
 
@@ -215,7 +210,7 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 */
 
 /*!
-    \fn void QVector4D::setZ(qreal z)
+    \fn void QVector4D::setZ(float z)
 
     Sets the z coordinate of this point to the given \a z coordinate.
 
@@ -223,7 +218,7 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 */
 
 /*!
-    \fn void QVector4D::setW(qreal w)
+    \fn void QVector4D::setW(float w)
 
     Sets the w coordinate of this point to the given \a w coordinate.
 
@@ -235,9 +230,14 @@ QVector4D::QVector4D(const QVector3D& vector, qreal wpos)
 
     \sa lengthSquared(), normalized()
 */
-qreal QVector4D::length() const
+float QVector4D::length() const
 {
-    return qSqrt(xp * xp + yp * yp + zp * zp + wp * wp);
+    // Need some extra precision if the length is very small.
+    double len = double(xp) * double(xp) +
+                 double(yp) * double(yp) +
+                 double(zp) * double(zp) +
+                 double(wp) * double(wp);
+    return float(sqrt(len));
 }
 
 /*!
@@ -246,7 +246,7 @@ qreal QVector4D::length() const
 
     \sa length(), dotProduct()
 */
-qreal QVector4D::lengthSquared() const
+float QVector4D::lengthSquared() const
 {
     return xp * xp + yp * yp + zp * zp + wp * wp;
 }
@@ -267,12 +267,17 @@ QVector4D QVector4D::normalized() const
                  double(yp) * double(yp) +
                  double(zp) * double(zp) +
                  double(wp) * double(wp);
-    if (qFuzzyIsNull(len - 1.0f))
+    if (qFuzzyIsNull(len - 1.0f)) {
         return *this;
-    else if (!qFuzzyIsNull(len))
-        return *this / qSqrt(len);
-    else
+    } else if (!qFuzzyIsNull(len)) {
+        double sqrtLen = sqrt(len);
+        return QVector4D(float(double(xp) / sqrtLen),
+                         float(double(yp) / sqrtLen),
+                         float(double(zp) / sqrtLen),
+                         float(double(wp) / sqrtLen));
+    } else {
         return QVector4D();
+    }
 }
 
 /*!
@@ -291,12 +296,12 @@ void QVector4D::normalize()
     if (qFuzzyIsNull(len - 1.0f) || qFuzzyIsNull(len))
         return;
 
-    len = qSqrt(len);
+    len = sqrt(len);
 
-    xp /= len;
-    yp /= len;
-    zp /= len;
-    wp /= len;
+    xp = float(double(xp) / len);
+    yp = float(double(yp) / len);
+    zp = float(double(zp) / len);
+    wp = float(double(wp) / len);
 }
 
 /*!
@@ -318,7 +323,7 @@ void QVector4D::normalize()
 */
 
 /*!
-    \fn QVector4D &QVector4D::operator*=(qreal factor)
+    \fn QVector4D &QVector4D::operator*=(float factor)
 
     Multiplies this vector's coordinates by the given \a factor, and
     returns a reference to this vector.
@@ -334,7 +339,7 @@ void QVector4D::normalize()
 */
 
 /*!
-    \fn QVector4D &QVector4D::operator/=(qreal divisor)
+    \fn QVector4D &QVector4D::operator/=(float divisor)
 
     Divides this vector's coordinates by the given \a divisor, and
     returns a reference to this vector.
@@ -345,7 +350,7 @@ void QVector4D::normalize()
 /*!
     Returns the dot product of \a v1 and \a v2.
 */
-qreal QVector4D::dotProduct(const QVector4D& v1, const QVector4D& v2)
+float QVector4D::dotProduct(const QVector4D& v1, const QVector4D& v2)
 {
     return v1.xp * v2.xp + v1.yp * v2.yp + v1.zp * v2.zp + v1.wp * v2.wp;
 }
@@ -387,7 +392,7 @@ qreal QVector4D::dotProduct(const QVector4D& v1, const QVector4D& v2)
 */
 
 /*!
-    \fn const QVector4D operator*(qreal factor, const QVector4D &vector)
+    \fn const QVector4D operator*(float factor, const QVector4D &vector)
     \relates QVector4D
 
     Returns a copy of the given \a vector,  multiplied by the given \a factor.
@@ -396,7 +401,7 @@ qreal QVector4D::dotProduct(const QVector4D& v1, const QVector4D& v2)
 */
 
 /*!
-    \fn const QVector4D operator*(const QVector4D &vector, qreal factor)
+    \fn const QVector4D operator*(const QVector4D &vector, float factor)
     \relates QVector4D
 
     Returns a copy of the given \a vector,  multiplied by the given \a factor.
@@ -426,7 +431,7 @@ qreal QVector4D::dotProduct(const QVector4D& v1, const QVector4D& v2)
 */
 
 /*!
-    \fn const QVector4D operator/(const QVector4D &vector, qreal divisor)
+    \fn const QVector4D operator/(const QVector4D &vector, float divisor)
     \relates QVector4D
 
     Returns the QVector4D object formed by dividing all four components of
@@ -452,7 +457,7 @@ qreal QVector4D::dotProduct(const QVector4D& v1, const QVector4D& v2)
 */
 QVector2D QVector4D::toVector2D() const
 {
-    return QVector2D(xp, yp, 1);
+    return QVector2D(xp, yp);
 }
 
 /*!
@@ -466,7 +471,7 @@ QVector2D QVector4D::toVector2DAffine() const
 {
     if (qIsNull(wp))
         return QVector2D();
-    return QVector2D(xp / wp, yp / wp, 1);
+    return QVector2D(xp / wp, yp / wp);
 }
 
 #endif
@@ -480,7 +485,7 @@ QVector2D QVector4D::toVector2DAffine() const
 */
 QVector3D QVector4D::toVector3D() const
 {
-    return QVector3D(xp, yp, zp, 1);
+    return QVector3D(xp, yp, zp);
 }
 
 /*!
@@ -493,7 +498,7 @@ QVector3D QVector4D::toVector3DAffine() const
 {
     if (qIsNull(wp))
         return QVector3D();
-    return QVector3D(xp / wp, yp / wp, zp / wp, 1);
+    return QVector3D(xp / wp, yp / wp, zp / wp);
 }
 
 #endif
@@ -550,8 +555,8 @@ QDebug operator<<(QDebug dbg, const QVector4D &vector)
 
 QDataStream &operator<<(QDataStream &stream, const QVector4D &vector)
 {
-    stream << double(vector.x()) << double(vector.y())
-           << double(vector.z()) << double(vector.w());
+    stream << vector.x() << vector.y()
+           << vector.z() << vector.w();
     return stream;
 }
 
@@ -567,15 +572,15 @@ QDataStream &operator<<(QDataStream &stream, const QVector4D &vector)
 
 QDataStream &operator>>(QDataStream &stream, QVector4D &vector)
 {
-    double x, y, z, w;
+    float x, y, z, w;
     stream >> x;
     stream >> y;
     stream >> z;
     stream >> w;
-    vector.setX(qreal(x));
-    vector.setY(qreal(y));
-    vector.setZ(qreal(z));
-    vector.setW(qreal(w));
+    vector.setX(x);
+    vector.setY(y);
+    vector.setZ(z);
+    vector.setW(w);
     return stream;
 }
 
diff --git a/src/gui/math3d/qvector4d.h b/src/gui/math3d/qvector4d.h
index 384dd6a..c793c4e 100644
--- a/src/gui/math3d/qvector4d.h
+++ b/src/gui/math3d/qvector4d.h
@@ -60,53 +60,53 @@ class Q_GUI_EXPORT QVector4D
 {
 public:
     QVector4D();
-    QVector4D(qreal xpos, qreal ypos, qreal zpos, qreal wpos);
+    QVector4D(float xpos, float ypos, float zpos, float wpos);
     explicit QVector4D(const QPoint& point);
     explicit QVector4D(const QPointF& point);
 #ifndef QT_NO_VECTOR2D
     QVector4D(const QVector2D& vector);
-    QVector4D(const QVector2D& vector, qreal zpos, qreal wpos);
+    QVector4D(const QVector2D& vector, float zpos, float wpos);
 #endif
 #ifndef QT_NO_VECTOR3D
     QVector4D(const QVector3D& vector);
-    QVector4D(const QVector3D& vector, qreal wpos);
+    QVector4D(const QVector3D& vector, float wpos);
 #endif
 
     bool isNull() const;
 
-    qreal x() const;
-    qreal y() const;
-    qreal z() const;
-    qreal w() const;
+    float x() const;
+    float y() const;
+    float z() const;
+    float w() const;
 
-    void setX(qreal x);
-    void setY(qreal y);
-    void setZ(qreal z);
-    void setW(qreal w);
+    void setX(float x);
+    void setY(float y);
+    void setZ(float z);
+    void setW(float w);
 
-    qreal length() const;
-    qreal lengthSquared() const;
+    float length() const;
+    float lengthSquared() const;
 
     QVector4D normalized() const;
     void normalize();
 
     QVector4D &operator+=(const QVector4D &vector);
     QVector4D &operator-=(const QVector4D &vector);
-    QVector4D &operator*=(qreal factor);
+    QVector4D &operator*=(float factor);
     QVector4D &operator*=(const QVector4D &vector);
-    QVector4D &operator/=(qreal divisor);
+    QVector4D &operator/=(float divisor);
 
-    static qreal dotProduct(const QVector4D& v1, const QVector4D& v2);
+    static float dotProduct(const QVector4D& v1, const QVector4D& v2);
 
     friend inline bool operator==(const QVector4D &v1, const QVector4D &v2);
     friend inline bool operator!=(const QVector4D &v1, const QVector4D &v2);
     friend inline const QVector4D operator+(const QVector4D &v1, const QVector4D &v2);
     friend inline const QVector4D operator-(const QVector4D &v1, const QVector4D &v2);
-    friend inline const QVector4D operator*(qreal factor, const QVector4D &vector);
-    friend inline const QVector4D operator*(const QVector4D &vector, qreal factor);
+    friend inline const QVector4D operator*(float factor, const QVector4D &vector);
+    friend inline const QVector4D operator*(const QVector4D &vector, float factor);
     friend inline const QVector4D operator*(const QVector4D &v1, const QVector4D& v2);
     friend inline const QVector4D operator-(const QVector4D &vector);
-    friend inline const QVector4D operator/(const QVector4D &vector, qreal divisor);
+    friend inline const QVector4D operator/(const QVector4D &vector, float divisor);
 
     friend inline bool qFuzzyCompare(const QVector4D& v1, const QVector4D& v2);
 
@@ -127,8 +127,6 @@ public:
 private:
     float xp, yp, zp, wp;
 
-    QVector4D(float xpos, float ypos, float zpos, float wpos, int dummy);
-
     friend class QVector2D;
     friend class QVector3D;
 #ifndef QT_NO_MATRIX4X4
@@ -141,9 +139,7 @@ Q_DECLARE_TYPEINFO(QVector4D, Q_MOVABLE_TYPE);
 
 inline QVector4D::QVector4D() : xp(0.0f), yp(0.0f), zp(0.0f), wp(0.0f) {}
 
-inline QVector4D::QVector4D(qreal xpos, qreal ypos, qreal zpos, qreal wpos) : xp(xpos), yp(ypos), zp(zpos), wp(wpos) {}
-
-inline QVector4D::QVector4D(float xpos, float ypos, float zpos, float wpos, int) : xp(xpos), yp(ypos), zp(zpos), wp(wpos) {}
+inline QVector4D::QVector4D(float xpos, float ypos, float zpos, float wpos) : xp(xpos), yp(ypos), zp(zpos), wp(wpos) {}
 
 inline QVector4D::QVector4D(const QPoint& point) : xp(point.x()), yp(point.y()), zp(0.0f), wp(0.0f) {}
 
@@ -154,15 +150,15 @@ inline bool QVector4D::isNull() const
     return qIsNull(xp) && qIsNull(yp) && qIsNull(zp) && qIsNull(wp);
 }
 
-inline qreal QVector4D::x() const { return qreal(xp); }
-inline qreal QVector4D::y() const { return qreal(yp); }
-inline qreal QVector4D::z() const { return qreal(zp); }
-inline qreal QVector4D::w() const { return qreal(wp); }
+inline float QVector4D::x() const { return xp; }
+inline float QVector4D::y() const { return yp; }
+inline float QVector4D::z() const { return zp; }
+inline float QVector4D::w() const { return wp; }
 
-inline void QVector4D::setX(qreal aX) { xp = aX; }
-inline void QVector4D::setY(qreal aY) { yp = aY; }
-inline void QVector4D::setZ(qreal aZ) { zp = aZ; }
-inline void QVector4D::setW(qreal aW) { wp = aW; }
+inline void QVector4D::setX(float aX) { xp = aX; }
+inline void QVector4D::setY(float aY) { yp = aY; }
+inline void QVector4D::setZ(float aZ) { zp = aZ; }
+inline void QVector4D::setW(float aW) { wp = aW; }
 
 inline QVector4D &QVector4D::operator+=(const QVector4D &vector)
 {
@@ -182,7 +178,7 @@ inline QVector4D &QVector4D::operator-=(const QVector4D &vector)
     return *this;
 }
 
-inline QVector4D &QVector4D::operator*=(qreal factor)
+inline QVector4D &QVector4D::operator*=(float factor)
 {
     xp *= factor;
     yp *= factor;
@@ -200,7 +196,7 @@ inline QVector4D &QVector4D::operator*=(const QVector4D &vector)
     return *this;
 }
 
-inline QVector4D &QVector4D::operator/=(qreal divisor)
+inline QVector4D &QVector4D::operator/=(float divisor)
 {
     xp /= divisor;
     yp /= divisor;
@@ -221,37 +217,37 @@ inline bool operator!=(const QVector4D &v1, const QVector4D &v2)
 
 inline const QVector4D operator+(const QVector4D &v1, const QVector4D &v2)
 {
-    return QVector4D(v1.xp + v2.xp, v1.yp + v2.yp, v1.zp + v2.zp, v1.wp + v2.wp, 1);
+    return QVector4D(v1.xp + v2.xp, v1.yp + v2.yp, v1.zp + v2.zp, v1.wp + v2.wp);
 }
 
 inline const QVector4D operator-(const QVector4D &v1, const QVector4D &v2)
 {
-    return QVector4D(v1.xp - v2.xp, v1.yp - v2.yp, v1.zp - v2.zp, v1.wp - v2.wp, 1);
+    return QVector4D(v1.xp - v2.xp, v1.yp - v2.yp, v1.zp - v2.zp, v1.wp - v2.wp);
 }
 
-inline const QVector4D operator*(qreal factor, const QVector4D &vector)
+inline const QVector4D operator*(float factor, const QVector4D &vector)
 {
-    return QVector4D(vector.xp * factor, vector.yp * factor, vector.zp * factor, vector.wp * factor, 1);
+    return QVector4D(vector.xp * factor, vector.yp * factor, vector.zp * factor, vector.wp * factor);
 }
 
-inline const QVector4D operator*(const QVector4D &vector, qreal factor)
+inline const QVector4D operator*(const QVector4D &vector, float factor)
 {
-    return QVector4D(vector.xp * factor, vector.yp * factor, vector.zp * factor, vector.wp * factor, 1);
+    return QVector4D(vector.xp * factor, vector.yp * factor, vector.zp * factor, vector.wp * factor);
 }
 
 inline const QVector4D operator*(const QVector4D &v1, const QVector4D& v2)
 {
-    return QVector4D(v1.xp * v2.xp, v1.yp * v2.yp, v1.zp * v2.zp, v1.wp * v2.wp, 1);
+    return QVector4D(v1.xp * v2.xp, v1.yp * v2.yp, v1.zp * v2.zp, v1.wp * v2.wp);
 }
 
 inline const QVector4D operator-(const QVector4D &vector)
 {
-    return QVector4D(-vector.xp, -vector.yp, -vector.zp, -vector.wp, 1);
+    return QVector4D(-vector.xp, -vector.yp, -vector.zp, -vector.wp);
 }
 
-inline const QVector4D operator/(const QVector4D &vector, qreal divisor)
+inline const QVector4D operator/(const QVector4D &vector, float divisor)
 {
-    return QVector4D(vector.xp / divisor, vector.yp / divisor, vector.zp / divisor, vector.wp / divisor, 1);
+    return QVector4D(vector.xp / divisor, vector.yp / divisor, vector.zp / divisor, vector.wp / divisor);
 }
 
 inline bool qFuzzyCompare(const QVector4D& v1, const QVector4D& v2)
diff --git a/src/gui/opengl/qopenglshaderprogram.cpp b/src/gui/opengl/qopenglshaderprogram.cpp
index 100fc0b..e74d495 100644
--- a/src/gui/opengl/qopenglshaderprogram.cpp
+++ b/src/gui/opengl/qopenglshaderprogram.cpp
@@ -2131,35 +2131,6 @@ void QOpenGLShaderProgram::setUniformValue(const char *name, const QSizeF& size)
     setUniformValue(uniformLocation(name), size);
 }
 
-// We have to repack matrices from qreal to GLfloat.
-#define setUniformMatrix(func,location,value,cols,rows) \
-    if (location == -1) \
-        return; \
-    if (sizeof(qreal) == sizeof(GLfloat)) { \
-        func(location, 1, GL_FALSE, \
-             reinterpret_cast<const GLfloat *>(value.constData())); \
-    } else { \
-        GLfloat mat[cols * rows]; \
-        const qreal *data = value.constData(); \
-        for (int i = 0; i < cols * rows; ++i) \
-            mat[i] = data[i]; \
-        func(location, 1, GL_FALSE, mat); \
-    }
-#define setUniformGenericMatrix(colfunc,location,value,cols,rows) \
-    if (location == -1) \
-        return; \
-    if (sizeof(qreal) == sizeof(GLfloat)) { \
-        const GLfloat *data = reinterpret_cast<const GLfloat *> \
-            (value.constData());  \
-        colfunc(location, cols, data); \
-    } else { \
-        GLfloat mat[cols * rows]; \
-        const qreal *data = value.constData(); \
-        for (int i = 0; i < cols * rows; ++i) \
-            mat[i] = data[i]; \
-        colfunc(location, cols, mat); \
-    }
-
 /*!
     Sets the uniform variable at \a location in the current context
     to a 2x2 matrix \a value.
@@ -2170,7 +2141,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix2x2& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformMatrix(d->glfuncs->glUniformMatrix2fv, location, value, 2, 2);
+    d->glfuncs->glUniformMatrix2fv(location, 1, GL_FALSE, value.constData());
 }
 
 /*!
@@ -2196,8 +2167,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix2x3& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (d->glfuncs->glUniform3fv, location, value, 2, 3);
+    d->glfuncs->glUniform3fv(location, 2, value.constData());
 }
 
 /*!
@@ -2223,8 +2193,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix2x4& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (d->glfuncs->glUniform4fv, location, value, 2, 4);
+    d->glfuncs->glUniform4fv(location, 2, value.constData());
 }
 
 /*!
@@ -2250,8 +2219,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix3x2& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (d->glfuncs->glUniform2fv, location, value, 3, 2);
+    d->glfuncs->glUniform2fv(location, 3, value.constData());
 }
 
 /*!
@@ -2277,7 +2245,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix3x3& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformMatrix(d->glfuncs->glUniformMatrix3fv, location, value, 3, 3);
+    d->glfuncs->glUniformMatrix3fv(location, 1, GL_FALSE, value.constData());
 }
 
 /*!
@@ -2303,8 +2271,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix3x4& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (d->glfuncs->glUniform4fv, location, value, 3, 4);
+    d->glfuncs->glUniform4fv(location, 3, value.constData());
 }
 
 /*!
@@ -2330,8 +2297,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix4x2& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (d->glfuncs->glUniform2fv, location, value, 4, 2);
+    d->glfuncs->glUniform2fv(location, 4, value.constData());
 }
 
 /*!
@@ -2357,8 +2323,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix4x3& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (d->glfuncs->glUniform3fv, location, value, 4, 3);
+    d->glfuncs->glUniform3fv(location, 4, value.constData());
 }
 
 /*!
@@ -2384,7 +2349,7 @@ void QOpenGLShaderProgram::setUniformValue(int location, const QMatrix4x4& value
 {
     Q_D(QOpenGLShaderProgram);
     Q_UNUSED(d);
-    setUniformMatrix(d->glfuncs->glUniformMatrix4fv, location, value, 4, 4);
+    d->glfuncs->glUniformMatrix4fv(location, 1, GL_FALSE, value.constData());
 }
 
 /*!
diff --git a/src/opengl/qglshaderprogram.cpp b/src/opengl/qglshaderprogram.cpp
index 4680131..1062669 100644
--- a/src/opengl/qglshaderprogram.cpp
+++ b/src/opengl/qglshaderprogram.cpp
@@ -2191,58 +2191,6 @@ void QGLShaderProgram::setUniformValue(const char *name, const QSizeF& size)
     setUniformValue(uniformLocation(name), size);
 }
 
-// We have to repack matrices from qreal to GLfloat.
-#define setUniformMatrix(func,location,value,cols,rows) \
-    if (location == -1) \
-        return; \
-    if (sizeof(qreal) == sizeof(GLfloat)) { \
-        func(location, 1, GL_FALSE, \
-             reinterpret_cast<const GLfloat *>(value.constData())); \
-    } else { \
-        GLfloat mat[cols * rows]; \
-        const qreal *data = value.constData(); \
-        for (int i = 0; i < cols * rows; ++i) \
-            mat[i] = data[i]; \
-        func(location, 1, GL_FALSE, mat); \
-    }
-#if !defined(QT_OPENGL_ES_2)
-#define setUniformGenericMatrix(func,colfunc,location,value,cols,rows) \
-    if (location == -1) \
-        return; \
-    if (sizeof(qreal) == sizeof(GLfloat)) { \
-        const GLfloat *data = reinterpret_cast<const GLfloat *> \
-            (value.constData());  \
-        if (func) \
-            func(location, 1, GL_FALSE, data); \
-        else \
-            colfunc(location, cols, data); \
-    } else { \
-        GLfloat mat[cols * rows]; \
-        const qreal *data = value.constData(); \
-        for (int i = 0; i < cols * rows; ++i) \
-            mat[i] = data[i]; \
-        if (func) \
-            func(location, 1, GL_FALSE, mat); \
-        else \
-            colfunc(location, cols, mat); \
-    }
-#else
-#define setUniformGenericMatrix(func,colfunc,location,value,cols,rows) \
-    if (location == -1) \
-        return; \
-    if (sizeof(qreal) == sizeof(GLfloat)) { \
-        const GLfloat *data = reinterpret_cast<const GLfloat *> \
-            (value.constData());  \
-        colfunc(location, cols, data); \
-    } else { \
-        GLfloat mat[cols * rows]; \
-        const qreal *data = value.constData(); \
-        for (int i = 0; i < cols * rows; ++i) \
-            mat[i] = data[i]; \
-        colfunc(location, cols, mat); \
-    }
-#endif
-
 /*!
     Sets the uniform variable at \a location in the current context
     to a 2x2 matrix \a value.
@@ -2253,7 +2201,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix2x2& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformMatrix(glUniformMatrix2fv, location, value, 2, 2);
+    glUniformMatrix2fv(location, 1, GL_FALSE, value.constData());
 }
 
 /*!
@@ -2279,8 +2227,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix2x3& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (glUniformMatrix2x3fv, glUniform3fv, location, value, 2, 3);
+    glUniform3fv(location, 2, value.constData());
 }
 
 /*!
@@ -2306,8 +2253,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix2x4& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (glUniformMatrix2x4fv, glUniform4fv, location, value, 2, 4);
+    glUniform4fv(location, 2, value.constData());
 }
 
 /*!
@@ -2333,8 +2279,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix3x2& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (glUniformMatrix3x2fv, glUniform2fv, location, value, 3, 2);
+    glUniform2fv(location, 3, value.constData());
 }
 
 /*!
@@ -2360,7 +2305,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix3x3& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformMatrix(glUniformMatrix3fv, location, value, 3, 3);
+    glUniformMatrix3fv(location, 1, GL_FALSE, value.constData());
 }
 
 /*!
@@ -2386,8 +2331,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix3x4& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (glUniformMatrix3x4fv, glUniform4fv, location, value, 3, 4);
+    glUniform4fv(location, 3, value.constData());
 }
 
 /*!
@@ -2413,8 +2357,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix4x2& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (glUniformMatrix4x2fv, glUniform2fv, location, value, 4, 2);
+    glUniform2fv(location, 4, value.constData());
 }
 
 /*!
@@ -2440,8 +2383,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix4x3& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformGenericMatrix
-        (glUniformMatrix4x3fv, glUniform3fv, location, value, 4, 3);
+    glUniform3fv(location, 4, value.constData());
 }
 
 /*!
@@ -2467,7 +2409,7 @@ void QGLShaderProgram::setUniformValue(int location, const QMatrix4x4& value)
 {
     Q_D(QGLShaderProgram);
     Q_UNUSED(d);
-    setUniformMatrix(glUniformMatrix4fv, location, value, 4, 4);
+    glUniformMatrix4fv(location, 1, GL_FALSE, value.constData());
 }
 
 /*!
diff --git a/tests/auto/gui/math3d/qmatrixnxn/tst_qmatrixnxn.cpp b/tests/auto/gui/math3d/qmatrixnxn/tst_qmatrixnxn.cpp
index c89d10a..c72955e 100644
--- a/tests/auto/gui/math3d/qmatrixnxn/tst_qmatrixnxn.cpp
+++ b/tests/auto/gui/math3d/qmatrixnxn/tst_qmatrixnxn.cpp
@@ -171,149 +171,161 @@ private slots:
     void metaTypes();
 
 private:
-    static void setMatrix(QMatrix2x2& m, const qreal *values);
-    static void setMatrixDirect(QMatrix2x2& m, const qreal *values);
-    static bool isSame(const QMatrix2x2& m, const qreal *values);
+    static void setMatrix(QMatrix2x2& m, const float *values);
+    static void setMatrixDirect(QMatrix2x2& m, const float *values);
+    static bool isSame(const QMatrix2x2& m, const float *values);
     static bool isIdentity(const QMatrix2x2& m);
 
-    static void setMatrix(QMatrix3x3& m, const qreal *values);
-    static void setMatrixDirect(QMatrix3x3& m, const qreal *values);
-    static bool isSame(const QMatrix3x3& m, const qreal *values);
+    static void setMatrix(QMatrix3x3& m, const float *values);
+    static void setMatrixDirect(QMatrix3x3& m, const float *values);
+    static bool isSame(const QMatrix3x3& m, const float *values);
     static bool isIdentity(const QMatrix3x3& m);
 
-    static void setMatrix(QMatrix4x4& m, const qreal *values);
-    static void setMatrixDirect(QMatrix4x4& m, const qreal *values);
-    static bool isSame(const QMatrix4x4& m, const qreal *values);
+    static void setMatrix(QMatrix4x4& m, const float *values);
+    static void setMatrixDirect(QMatrix4x4& m, const float *values);
+    static bool isSame(const QMatrix4x4& m, const float *values);
     static bool isIdentity(const QMatrix4x4& m);
 
-    static void setMatrix(QMatrix4x3& m, const qreal *values);
-    static void setMatrixDirect(QMatrix4x3& m, const qreal *values);
-    static bool isSame(const QMatrix4x3& m, const qreal *values);
+    static void setMatrix(QMatrix4x3& m, const float *values);
+    static void setMatrixDirect(QMatrix4x3& m, const float *values);
+    static bool isSame(const QMatrix4x3& m, const float *values);
     static bool isIdentity(const QMatrix4x3& m);
 };
 
-static const qreal nullValues2[] =
+static const float nullValues2[] =
     {0.0f, 0.0f,
      0.0f, 0.0f};
 
-static qreal const identityValues2[16] =
+static float const identityValues2[16] =
     {1.0f, 0.0f,
      0.0f, 1.0f};
 
-static const qreal doubleIdentity2[] =
+static const float doubleIdentity2[] =
     {2.0f, 0.0f,
      0.0f, 2.0f};
 
-static qreal const uniqueValues2[16] =
+static float const uniqueValues2[16] =
     {1.0f, 2.0f,
      5.0f, 6.0f};
 
-static qreal const transposedValues2[16] =
+static float const transposedValues2[16] =
     {1.0f, 5.0f,
      2.0f, 6.0f};
 
-static const qreal nullValues3[] =
+static const float nullValues3[] =
     {0.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 0.0f};
 
-static qreal const identityValues3[16] =
+static float const identityValues3[16] =
     {1.0f, 0.0f, 0.0f,
      0.0f, 1.0f, 0.0f,
      0.0f, 0.0f, 1.0f};
 
-static const qreal doubleIdentity3[] =
+static const float doubleIdentity3[] =
     {2.0f, 0.0f, 0.0f,
      0.0f, 2.0f, 0.0f,
      0.0f, 0.0f, 2.0f};
 
-static qreal const uniqueValues3[16] =
+static float const uniqueValues3[16] =
     {1.0f, 2.0f, 3.0f,
      5.0f, 6.0f, 7.0f,
      9.0f, 10.0f, 11.0f};
 
-static qreal const transposedValues3[16] =
+static float const transposedValues3[16] =
     {1.0f, 5.0f, 9.0f,
      2.0f, 6.0f, 10.0f,
      3.0f, 7.0f, 11.0f};
 
-static const qreal nullValues4[] =
+static const float nullValues4[] =
     {0.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 0.0f, 0.0f};
 
-static qreal const identityValues4[16] =
+static float const identityValues4[16] =
     {1.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 1.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 1.0f, 0.0f,
      0.0f, 0.0f, 0.0f, 1.0f};
 
-static const qreal doubleIdentity4[] =
+static const float doubleIdentity4[] =
     {2.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 2.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 2.0f, 0.0f,
      0.0f, 0.0f, 0.0f, 2.0f};
 
-static qreal const uniqueValues4[16] =
+static float const uniqueValues4[16] =
     {1.0f, 2.0f, 3.0f, 4.0f,
      5.0f, 6.0f, 7.0f, 8.0f,
      9.0f, 10.0f, 11.0f, 12.0f,
      13.0f, 14.0f, 15.0f, 16.0f};
 
-static qreal const transposedValues4[16] =
+static float const transposedValues4[16] =
     {1.0f, 5.0f, 9.0f, 13.0f,
      2.0f, 6.0f, 10.0f, 14.0f,
      3.0f, 7.0f, 11.0f, 15.0f,
      4.0f, 8.0f, 12.0f, 16.0f};
 
-static const qreal nullValues4x3[] =
+static const float nullValues4x3[] =
     {0.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 0.0f, 0.0f};
 
-static qreal const identityValues4x3[12] =
+static float const identityValues4x3[12] =
     {1.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 1.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 1.0f, 0.0f};
 
-static qreal const doubleIdentity4x3[12] =
+static float const doubleIdentity4x3[12] =
     {2.0f, 0.0f, 0.0f, 0.0f,
      0.0f, 2.0f, 0.0f, 0.0f,
      0.0f, 0.0f, 2.0f, 0.0f};
 
-static qreal const uniqueValues4x3[12] =
+static float const uniqueValues4x3[12] =
     {1.0f, 2.0f, 3.0f, 4.0f,
      5.0f, 6.0f, 7.0f, 8.0f,
      9.0f, 10.0f, 11.0f, 12.0f};
 
-static qreal const transposedValues3x4[12] =
+static float const transposedValues3x4[12] =
     {1.0f, 5.0f, 9.0f,
      2.0f, 6.0f, 10.0f,
      3.0f, 7.0f, 11.0f,
      4.0f, 8.0f, 12.0f};
 
+// We use a slightly better implementation of qFuzzyCompare here that
+// handles the case where one of the values is exactly 0
+static inline bool fuzzyCompare(float p1, float p2)
+{
+    if (qFuzzyIsNull(p1))
+        return qFuzzyIsNull(p2);
+    else if (qFuzzyIsNull(p2))
+        return false;
+    else
+        return qFuzzyCompare(p1, p2);
+}
+
 // Set a matrix to a specified array of values, which are assumed
 // to be in row-major order.  This sets the values using floating-point.
-void tst_QMatrixNxN::setMatrix(QMatrix2x2& m, const qreal *values)
+void tst_QMatrixNxN::setMatrix(QMatrix2x2& m, const float *values)
 {
     for (int row = 0; row < 2; ++row)
         for (int col = 0; col < 2; ++col)
             m(row, col) = values[row * 2 + col];
 }
-void tst_QMatrixNxN::setMatrix(QMatrix3x3& m, const qreal *values)
+void tst_QMatrixNxN::setMatrix(QMatrix3x3& m, const float *values)
 {
     for (int row = 0; row < 3; ++row)
         for (int col = 0; col < 3; ++col)
             m(row, col) = values[row * 3 + col];
 }
-void tst_QMatrixNxN::setMatrix(QMatrix4x4& m, const qreal *values)
+void tst_QMatrixNxN::setMatrix(QMatrix4x4& m, const float *values)
 {
     for (int row = 0; row < 4; ++row)
         for (int col = 0; col < 4; ++col)
             m(row, col) = values[row * 4 + col];
 }
-void tst_QMatrixNxN::setMatrix(QMatrix4x3& m, const qreal *values)
+void tst_QMatrixNxN::setMatrix(QMatrix4x3& m, const float *values)
 {
     for (int row = 0; row < 3; ++row)
         for (int col = 0; col < 4; ++col)
@@ -323,36 +335,36 @@ void tst_QMatrixNxN::setMatrix(QMatrix4x3& m, const qreal *values)
 // Set a matrix to a specified array of values, which are assumed
 // to be in row-major order.  This sets the values directly into
 // the internal data() array.
-void tst_QMatrixNxN::setMatrixDirect(QMatrix2x2& m, const qreal *values)
+void tst_QMatrixNxN::setMatrixDirect(QMatrix2x2& m, const float *values)
 {
-    qreal *data = m.data();
+    float *data = m.data();
     for (int row = 0; row < 2; ++row) {
         for (int col = 0; col < 2; ++col) {
             data[row + col * 2] = values[row * 2 + col];
         }
     }
 }
-void tst_QMatrixNxN::setMatrixDirect(QMatrix3x3& m, const qreal *values)
+void tst_QMatrixNxN::setMatrixDirect(QMatrix3x3& m, const float *values)
 {
-    qreal *data = m.data();
+    float *data = m.data();
     for (int row = 0; row < 3; ++row) {
         for (int col = 0; col < 3; ++col) {
             data[row + col * 3] = values[row * 3 + col];
         }
     }
 }
-void tst_QMatrixNxN::setMatrixDirect(QMatrix4x4& m, const qreal *values)
+void tst_QMatrixNxN::setMatrixDirect(QMatrix4x4& m, const float *values)
 {
-    qreal *data = m.data();
+    float *data = m.data();
     for (int row = 0; row < 4; ++row) {
         for (int col = 0; col < 4; ++col) {
             data[row + col * 4] = values[row * 4 + col];
         }
     }
 }
-void tst_QMatrixNxN::setMatrixDirect(QMatrix4x3& m, const qreal *values)
+void tst_QMatrixNxN::setMatrixDirect(QMatrix4x3& m, const float *values)
 {
-    qreal *data = m.data();
+    float *data = m.data();
     for (int row = 0; row < 3; ++row) {
         for (int col = 0; col < 4; ++col) {
             data[row + col * 3] = values[row * 4 + col];
@@ -360,31 +372,11 @@ void tst_QMatrixNxN::setMatrixDirect(QMatrix4x3& m, const qreal *values)
     }
 }
 
-// QVector2/3/4D use float internally, which can sometimes lead
-// to precision issues when converting to and from qreal during
-// operations involving QMatrix4x4.  This fuzzy compare is slightly
-// "fuzzier" than the default qFuzzyCompare for qreal to compensate.
-static bool fuzzyCompare(qreal x, qreal y)
-{
-    return qFuzzyIsNull((float)(x - y));
-}
-
-static bool fuzzyCompare(const QVector3D &v1, const QVector3D &v2)
-{
-    if (!fuzzyCompare(v1.x(), v2.x()))
-        return false;
-    if (!fuzzyCompare(v1.y(), v2.y()))
-        return false;
-    if (!fuzzyCompare(v1.z(), v2.z()))
-        return false;
-    return true;
-}
-
 // Determine if a matrix is the same as a specified array of values.
 // The values are assumed to be specified in row-major order.
-bool tst_QMatrixNxN::isSame(const QMatrix2x2& m, const qreal *values)
+bool tst_QMatrixNxN::isSame(const QMatrix2x2& m, const float *values)
 {
-    const qreal *mv = m.constData();
+    const float *mv = m.constData();
     for (int row = 0; row < 2; ++row) {
         for (int col = 0; col < 2; ++col) {
             // Check the values using the operator() function.
@@ -403,9 +395,9 @@ bool tst_QMatrixNxN::isSame(const QMatrix2x2& m, const qreal *values)
     }
     return true;
 }
-bool tst_QMatrixNxN::isSame(const QMatrix3x3& m, const qreal *values)
+bool tst_QMatrixNxN::isSame(const QMatrix3x3& m, const float *values)
 {
-    const qreal *mv = m.constData();
+    const float *mv = m.constData();
     for (int row = 0; row < 3; ++row) {
         for (int col = 0; col < 3; ++col) {
             // Check the values using the operator() access function.
@@ -424,9 +416,9 @@ bool tst_QMatrixNxN::isSame(const QMatrix3x3& m, const qreal *values)
     }
     return true;
 }
-bool tst_QMatrixNxN::isSame(const QMatrix4x4& m, const qreal *values)
+bool tst_QMatrixNxN::isSame(const QMatrix4x4& m, const float *values)
 {
-    const qreal *mv = m.constData();
+    const float *mv = m.constData();
     for (int row = 0; row < 4; ++row) {
         for (int col = 0; col < 4; ++col) {
             // Check the values using the operator() access function.
@@ -445,9 +437,9 @@ bool tst_QMatrixNxN::isSame(const QMatrix4x4& m, const qreal *values)
     }
     return true;
 }
-bool tst_QMatrixNxN::isSame(const QMatrix4x3& m, const qreal *values)
+bool tst_QMatrixNxN::isSame(const QMatrix4x3& m, const float *values)
 {
-    const qreal *mv = m.constData();
+    const float *mv = m.constData();
     for (int row = 0; row < 3; ++row) {
         for (int col = 0; col < 4; ++col) {
             // Check the values using the operator() access function.
@@ -514,7 +506,7 @@ void tst_QMatrixNxN::create2x2()
 
     QMatrix2x2 m6(uniqueValues2);
     QVERIFY(isSame(m6, uniqueValues2));
-    qreal vals[4];
+    float vals[4];
     m6.copyDataTo(vals);
     for (int index = 0; index < 4; ++index)
         QCOMPARE(vals[index], uniqueValues2[index]);
@@ -549,7 +541,7 @@ void tst_QMatrixNxN::create3x3()
 
     QMatrix3x3 m6(uniqueValues3);
     QVERIFY(isSame(m6, uniqueValues3));
-    qreal vals[9];
+    float vals[9];
     m6.copyDataTo(vals);
     for (int index = 0; index < 9; ++index)
         QCOMPARE(vals[index], uniqueValues3[index]);
@@ -584,7 +576,7 @@ void tst_QMatrixNxN::create4x4()
 
     QMatrix4x4 m6(uniqueValues4);
     QVERIFY(isSame(m6, uniqueValues4));
-    qreal vals[16];
+    float vals[16];
     m6.copyDataTo(vals);
     for (int index = 0; index < 16; ++index)
         QCOMPARE(vals[index], uniqueValues4[index]);
@@ -626,7 +618,7 @@ void tst_QMatrixNxN::create4x3()
 
     QMatrix4x3 m6(uniqueValues4x3);
     QVERIFY(isSame(m6, uniqueValues4x3));
-    qreal vals[12];
+    float vals[12];
     m6.copyDataTo(vals);
     for (int index = 0; index < 12; ++index)
         QCOMPARE(vals[index], uniqueValues4x3[index]);
@@ -795,7 +787,7 @@ void tst_QMatrixNxN::transposed4x3()
 {
     QMatrix4x3 m3(uniqueValues4x3);
     QMatrix3x4 m4 = m3.transposed();
-    qreal values[12];
+    float values[12];
     m4.copyDataTo(values);
     for (int index = 0; index < 12; ++index)
         QCOMPARE(values[index], transposedValues3x4[index]);
@@ -817,7 +809,7 @@ void tst_QMatrixNxN::add2x2_data()
     QTest::newRow("identity/identity")
         << (void *)identityValues2 << (void *)identityValues2 << (void *)doubleIdentity2;
 
-    static qreal const sumValues[16] =
+    static float const sumValues[16] =
         {2.0f, 7.0f,
          7.0f, 12.0f};
     QTest::newRow("unique")
@@ -829,16 +821,16 @@ void tst_QMatrixNxN::add2x2()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix2x2 m1((const qreal *)m1Values);
-    QMatrix2x2 m2((const qreal *)m2Values);
+    QMatrix2x2 m1((const float *)m1Values);
+    QMatrix2x2 m2((const float *)m2Values);
 
     QMatrix2x2 m4(m1);
     m4 += m2;
-    QVERIFY(isSame(m4, (const qreal *)m3Values));
+    QVERIFY(isSame(m4, (const float *)m3Values));
 
     QMatrix2x2 m5;
     m5 = m1 + m2;
-    QVERIFY(isSame(m5, (const qreal *)m3Values));
+    QVERIFY(isSame(m5, (const float *)m3Values));
 }
 
 // Test matrix addition for 3x3 matrices.
@@ -857,7 +849,7 @@ void tst_QMatrixNxN::add3x3_data()
     QTest::newRow("identity/identity")
         << (void *)identityValues3 << (void *)identityValues3 << (void *)doubleIdentity3;
 
-    static qreal const sumValues[16] =
+    static float const sumValues[16] =
         {2.0f, 7.0f, 12.0f,
          7.0f, 12.0f, 17.0f,
          12.0f, 17.0f, 22.0f};
@@ -870,16 +862,16 @@ void tst_QMatrixNxN::add3x3()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix3x3 m1((const qreal *)m1Values);
-    QMatrix3x3 m2((const qreal *)m2Values);
+    QMatrix3x3 m1((const float *)m1Values);
+    QMatrix3x3 m2((const float *)m2Values);
 
     QMatrix3x3 m4(m1);
     m4 += m2;
-    QVERIFY(isSame(m4, (const qreal *)m3Values));
+    QVERIFY(isSame(m4, (const float *)m3Values));
 
     QMatrix3x3 m5;
     m5 = m1 + m2;
-    QVERIFY(isSame(m5, (const qreal *)m3Values));
+    QVERIFY(isSame(m5, (const float *)m3Values));
 }
 
 // Test matrix addition for 4x4 matrices.
@@ -898,7 +890,7 @@ void tst_QMatrixNxN::add4x4_data()
     QTest::newRow("identity/identity")
         << (void *)identityValues4 << (void *)identityValues4 << (void *)doubleIdentity4;
 
-    static qreal const sumValues[16] =
+    static float const sumValues[16] =
         {2.0f, 7.0f, 12.0f, 17.0f,
          7.0f, 12.0f, 17.0f, 22.0f,
          12.0f, 17.0f, 22.0f, 27.0f,
@@ -912,16 +904,16 @@ void tst_QMatrixNxN::add4x4()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix4x4 m1((const qreal *)m1Values);
-    QMatrix4x4 m2((const qreal *)m2Values);
+    QMatrix4x4 m1((const float *)m1Values);
+    QMatrix4x4 m2((const float *)m2Values);
 
     QMatrix4x4 m4(m1);
     m4 += m2;
-    QVERIFY(isSame(m4, (const qreal *)m3Values));
+    QVERIFY(isSame(m4, (const float *)m3Values));
 
     QMatrix4x4 m5;
     m5 = m1 + m2;
-    QVERIFY(isSame(m5, (const qreal *)m3Values));
+    QVERIFY(isSame(m5, (const float *)m3Values));
 }
 
 // Test matrix addition for 4x3 matrices.
@@ -940,7 +932,7 @@ void tst_QMatrixNxN::add4x3_data()
     QTest::newRow("identity/identity")
         << (void *)identityValues4x3 << (void *)identityValues4x3 << (void *)doubleIdentity4x3;
 
-    static qreal const sumValues[16] =
+    static float const sumValues[16] =
         {2.0f, 7.0f, 12.0f, 6.0f,
          11.0f, 16.0f, 10.0f, 15.0f,
          20.0f, 14.0f, 19.0f, 24.0f};
@@ -953,16 +945,16 @@ void tst_QMatrixNxN::add4x3()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix4x3 m1((const qreal *)m1Values);
-    QMatrix4x3 m2((const qreal *)m2Values);
+    QMatrix4x3 m1((const float *)m1Values);
+    QMatrix4x3 m2((const float *)m2Values);
 
     QMatrix4x3 m4(m1);
     m4 += m2;
-    QVERIFY(isSame(m4, (const qreal *)m3Values));
+    QVERIFY(isSame(m4, (const float *)m3Values));
 
     QMatrix4x3 m5;
     m5 = m1 + m2;
-    QVERIFY(isSame(m5, (const qreal *)m3Values));
+    QVERIFY(isSame(m5, (const float *)m3Values));
 }
 
 // Test matrix subtraction for 2x2 matrices.
@@ -977,25 +969,25 @@ void tst_QMatrixNxN::subtract2x2()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix2x2 m1((const qreal *)m1Values);
-    QMatrix2x2 m2((const qreal *)m2Values);
-    QMatrix2x2 m3((const qreal *)m3Values);
+    QMatrix2x2 m1((const float *)m1Values);
+    QMatrix2x2 m2((const float *)m2Values);
+    QMatrix2x2 m3((const float *)m3Values);
 
     QMatrix2x2 m4(m3);
     m4 -= m1;
-    QVERIFY(isSame(m4, (const qreal *)m2Values));
+    QVERIFY(isSame(m4, (const float *)m2Values));
 
     QMatrix2x2 m5;
     m5 = m3 - m1;
-    QVERIFY(isSame(m5, (const qreal *)m2Values));
+    QVERIFY(isSame(m5, (const float *)m2Values));
 
     QMatrix2x2 m6(m3);
     m6 -= m2;
-    QVERIFY(isSame(m6, (const qreal *)m1Values));
+    QVERIFY(isSame(m6, (const float *)m1Values));
 
     QMatrix2x2 m7;
     m7 = m3 - m2;
-    QVERIFY(isSame(m7, (const qreal *)m1Values));
+    QVERIFY(isSame(m7, (const float *)m1Values));
 }
 
 // Test matrix subtraction for 3x3 matrices.
@@ -1010,25 +1002,25 @@ void tst_QMatrixNxN::subtract3x3()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix3x3 m1((const qreal *)m1Values);
-    QMatrix3x3 m2((const qreal *)m2Values);
-    QMatrix3x3 m3((const qreal *)m3Values);
+    QMatrix3x3 m1((const float *)m1Values);
+    QMatrix3x3 m2((const float *)m2Values);
+    QMatrix3x3 m3((const float *)m3Values);
 
     QMatrix3x3 m4(m3);
     m4 -= m1;
-    QVERIFY(isSame(m4, (const qreal *)m2Values));
+    QVERIFY(isSame(m4, (const float *)m2Values));
 
     QMatrix3x3 m5;
     m5 = m3 - m1;
-    QVERIFY(isSame(m5, (const qreal *)m2Values));
+    QVERIFY(isSame(m5, (const float *)m2Values));
 
     QMatrix3x3 m6(m3);
     m6 -= m2;
-    QVERIFY(isSame(m6, (const qreal *)m1Values));
+    QVERIFY(isSame(m6, (const float *)m1Values));
 
     QMatrix3x3 m7;
     m7 = m3 - m2;
-    QVERIFY(isSame(m7, (const qreal *)m1Values));
+    QVERIFY(isSame(m7, (const float *)m1Values));
 }
 
 // Test matrix subtraction for 4x4 matrices.
@@ -1043,25 +1035,25 @@ void tst_QMatrixNxN::subtract4x4()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix4x4 m1((const qreal *)m1Values);
-    QMatrix4x4 m2((const qreal *)m2Values);
-    QMatrix4x4 m3((const qreal *)m3Values);
+    QMatrix4x4 m1((const float *)m1Values);
+    QMatrix4x4 m2((const float *)m2Values);
+    QMatrix4x4 m3((const float *)m3Values);
 
     QMatrix4x4 m4(m3);
     m4 -= m1;
-    QVERIFY(isSame(m4, (const qreal *)m2Values));
+    QVERIFY(isSame(m4, (const float *)m2Values));
 
     QMatrix4x4 m5;
     m5 = m3 - m1;
-    QVERIFY(isSame(m5, (const qreal *)m2Values));
+    QVERIFY(isSame(m5, (const float *)m2Values));
 
     QMatrix4x4 m6(m3);
     m6 -= m2;
-    QVERIFY(isSame(m6, (const qreal *)m1Values));
+    QVERIFY(isSame(m6, (const float *)m1Values));
 
     QMatrix4x4 m7;
     m7 = m3 - m2;
-    QVERIFY(isSame(m7, (const qreal *)m1Values));
+    QVERIFY(isSame(m7, (const float *)m1Values));
 }
 
 // Test matrix subtraction for 4x3 matrices.
@@ -1076,25 +1068,25 @@ void tst_QMatrixNxN::subtract4x3()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix4x3 m1((const qreal *)m1Values);
-    QMatrix4x3 m2((const qreal *)m2Values);
-    QMatrix4x3 m3((const qreal *)m3Values);
+    QMatrix4x3 m1((const float *)m1Values);
+    QMatrix4x3 m2((const float *)m2Values);
+    QMatrix4x3 m3((const float *)m3Values);
 
     QMatrix4x3 m4(m3);
     m4 -= m1;
-    QVERIFY(isSame(m4, (const qreal *)m2Values));
+    QVERIFY(isSame(m4, (const float *)m2Values));
 
     QMatrix4x3 m5;
     m5 = m3 - m1;
-    QVERIFY(isSame(m5, (const qreal *)m2Values));
+    QVERIFY(isSame(m5, (const float *)m2Values));
 
     QMatrix4x3 m6(m3);
     m6 -= m2;
-    QVERIFY(isSame(m6, (const qreal *)m1Values));
+    QVERIFY(isSame(m6, (const float *)m1Values));
 
     QMatrix4x3 m7;
     m7 = m3 - m2;
-    QVERIFY(isSame(m7, (const qreal *)m1Values));
+    QVERIFY(isSame(m7, (const float *)m1Values));
 }
 
 // Test matrix multiplication for 2x2 matrices.
@@ -1119,10 +1111,10 @@ void tst_QMatrixNxN::multiply2x2_data()
     QTest::newRow("identity/unique")
         << (void *)identityValues2 << (void *)uniqueValues2 << (void *)uniqueValues2;
 
-    static qreal uniqueResult[4];
+    static float uniqueResult[4];
     for (int row = 0; row < 2; ++row) {
         for (int col = 0; col < 2; ++col) {
-            qreal sum = 0.0f;
+            float sum = 0.0f;
             for (int j = 0; j < 2; ++j)
                 sum += uniqueValues2[row * 2 + j] * transposedValues2[j * 2 + col];
             uniqueResult[row * 2 + col] = sum;
@@ -1138,12 +1130,12 @@ void tst_QMatrixNxN::multiply2x2()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix2x2 m1((const qreal *)m1Values);
-    QMatrix2x2 m2((const qreal *)m2Values);
+    QMatrix2x2 m1((const float *)m1Values);
+    QMatrix2x2 m2((const float *)m2Values);
 
     QMatrix2x2 m5;
     m5 = m1 * m2;
-    QVERIFY(isSame(m5, (const qreal *)m3Values));
+    QVERIFY(isSame(m5, (const float *)m3Values));
 }
 
 // Test matrix multiplication for 3x3 matrices.
@@ -1168,10 +1160,10 @@ void tst_QMatrixNxN::multiply3x3_data()
     QTest::newRow("identity/unique")
         << (void *)identityValues3 << (void *)uniqueValues3 << (void *)uniqueValues3;
 
-    static qreal uniqueResult[9];
+    static float uniqueResult[9];
     for (int row = 0; row < 3; ++row) {
         for (int col = 0; col < 3; ++col) {
-            qreal sum = 0.0f;
+            float sum = 0.0f;
             for (int j = 0; j < 3; ++j)
                 sum += uniqueValues3[row * 3 + j] * transposedValues3[j * 3 + col];
             uniqueResult[row * 3 + col] = sum;
@@ -1187,12 +1179,12 @@ void tst_QMatrixNxN::multiply3x3()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix3x3 m1((const qreal *)m1Values);
-    QMatrix3x3 m2((const qreal *)m2Values);
+    QMatrix3x3 m1((const float *)m1Values);
+    QMatrix3x3 m2((const float *)m2Values);
 
     QMatrix3x3 m5;
     m5 = m1 * m2;
-    QVERIFY(isSame(m5, (const qreal *)m3Values));
+    QVERIFY(isSame(m5, (const float *)m3Values));
 }
 
 // Test matrix multiplication for 4x4 matrices.
@@ -1217,10 +1209,10 @@ void tst_QMatrixNxN::multiply4x4_data()
     QTest::newRow("identity/unique")
         << (void *)identityValues4 << (void *)uniqueValues4 << (void *)uniqueValues4;
 
-    static qreal uniqueResult[16];
+    static float uniqueResult[16];
     for (int row = 0; row < 4; ++row) {
         for (int col = 0; col < 4; ++col) {
-            qreal sum = 0.0f;
+            float sum = 0.0f;
             for (int j = 0; j < 4; ++j)
                 sum += uniqueValues4[row * 4 + j] * transposedValues4[j * 4 + col];
             uniqueResult[row * 4 + col] = sum;
@@ -1236,17 +1228,17 @@ void tst_QMatrixNxN::multiply4x4()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix4x4 m1((const qreal *)m1Values);
-    QMatrix4x4 m2((const qreal *)m2Values);
+    QMatrix4x4 m1((const float *)m1Values);
+    QMatrix4x4 m2((const float *)m2Values);
 
     QMatrix4x4 m4;
     m4 = m1;
     m4 *= m2;
-    QVERIFY(isSame(m4, (const qreal *)m3Values));
+    QVERIFY(isSame(m4, (const float *)m3Values));
 
     QMatrix4x4 m5;
     m5 = m1 * m2;
-    QVERIFY(isSame(m5, (const qreal *)m3Values));
+    QVERIFY(isSame(m5, (const float *)m3Values));
 }
 
 // Test matrix multiplication for 4x3 matrices.
@@ -1265,10 +1257,10 @@ void tst_QMatrixNxN::multiply4x3_data()
     QTest::newRow("unique/null")
         << (void *)uniqueValues4x3 << (void *)nullValues4x3 << (void *)nullValues3;
 
-    static qreal uniqueResult[9];
+    static float uniqueResult[9];
     for (int row = 0; row < 3; ++row) {
         for (int col = 0; col < 3; ++col) {
-            qreal sum = 0.0f;
+            float sum = 0.0f;
             for (int j = 0; j < 4; ++j)
                 sum += uniqueValues4x3[row * 4 + j] * transposedValues3x4[j * 3 + col];
             uniqueResult[row * 3 + col] = sum;
@@ -1284,243 +1276,243 @@ void tst_QMatrixNxN::multiply4x3()
     QFETCH(void *, m2Values);
     QFETCH(void *, m3Values);
 
-    QMatrix4x3 m1((const qreal *)m1Values);
-    QMatrix3x4 m2((const qreal *)m2Values);
+    QMatrix4x3 m1((const float *)m1Values);
+    QMatrix3x4 m2((const float *)m2Values);
 
-    QGenericMatrix<3, 3, qreal> m4;
+    QGenericMatrix<3, 3, float> m4;
     m4 = m1 * m2;
-    qreal values[9];
+    float values[9];
     m4.copyDataTo(values);
     for (int index = 0; index < 9; ++index)
-        QCOMPARE(values[index], ((const qreal *)m3Values)[index]);
+        QCOMPARE(values[index], ((const float *)m3Values)[index]);
 }
 
 // Test matrix multiplication by a factor for 2x2 matrices.
 void tst_QMatrixNxN::multiplyFactor2x2_data()
 {
     QTest::addColumn<void *>("m1Values");
-    QTest::addColumn<qreal>("factor");
+    QTest::addColumn<float>("factor");
     QTest::addColumn<void *>("m2Values");
 
     QTest::newRow("null")
-        << (void *)nullValues2 << (qreal)1.0f << (void *)nullValues2;
+        << (void *)nullValues2 << (float)1.0f << (void *)nullValues2;
 
     QTest::newRow("double identity")
-        << (void *)identityValues2 << (qreal)2.0f << (void *)doubleIdentity2;
+        << (void *)identityValues2 << (float)2.0f << (void *)doubleIdentity2;
 
-    static qreal const values[16] =
+    static float const values[16] =
         {1.0f, 2.0f,
          5.0f, 6.0f};
-    static qreal const doubleValues[16] =
+    static float const doubleValues[16] =
         {2.0f, 4.0f,
          10.0f, 12.0f};
-    static qreal const negDoubleValues[16] =
+    static float const negDoubleValues[16] =
         {-2.0f, -4.0f,
          -10.0f, -12.0f};
 
     QTest::newRow("unique")
-        << (void *)values << (qreal)2.0f << (void *)doubleValues;
+        << (void *)values << (float)2.0f << (void *)doubleValues;
 
     QTest::newRow("neg")
-        << (void *)values << (qreal)-2.0f << (void *)negDoubleValues;
+        << (void *)values << (float)-2.0f << (void *)negDoubleValues;
 
     QTest::newRow("zero")
-        << (void *)values << (qreal)0.0f << (void *)nullValues4;
+        << (void *)values << (float)0.0f << (void *)nullValues4;
 }
 void tst_QMatrixNxN::multiplyFactor2x2()
 {
     QFETCH(void *, m1Values);
-    QFETCH(qreal, factor);
+    QFETCH(float, factor);
     QFETCH(void *, m2Values);
 
-    QMatrix2x2 m1((const qreal *)m1Values);
+    QMatrix2x2 m1((const float *)m1Values);
 
     QMatrix2x2 m3;
     m3 = m1;
     m3 *= factor;
-    QVERIFY(isSame(m3, (const qreal *)m2Values));
+    QVERIFY(isSame(m3, (const float *)m2Values));
 
     QMatrix2x2 m4;
     m4 = m1 * factor;
-    QVERIFY(isSame(m4, (const qreal *)m2Values));
+    QVERIFY(isSame(m4, (const float *)m2Values));
 
     QMatrix2x2 m5;
     m5 = factor * m1;
-    QVERIFY(isSame(m5, (const qreal *)m2Values));
+    QVERIFY(isSame(m5, (const float *)m2Values));
 }
 
 // Test matrix multiplication by a factor for 3x3 matrices.
 void tst_QMatrixNxN::multiplyFactor3x3_data()
 {
     QTest::addColumn<void *>("m1Values");
-    QTest::addColumn<qreal>("factor");
+    QTest::addColumn<float>("factor");
     QTest::addColumn<void *>("m2Values");
 
     QTest::newRow("null")
-        << (void *)nullValues3 << (qreal)1.0f << (void *)nullValues3;
+        << (void *)nullValues3 << (float)1.0f << (void *)nullValues3;
 
     QTest::newRow("double identity")
-        << (void *)identityValues3 << (qreal)2.0f << (void *)doubleIdentity3;
+        << (void *)identityValues3 << (float)2.0f << (void *)doubleIdentity3;
 
-    static qreal const values[16] =
+    static float const values[16] =
         {1.0f, 2.0f, 3.0f,
          5.0f, 6.0f, 7.0f,
          9.0f, 10.0f, 11.0f};
-    static qreal const doubleValues[16] =
+    static float const doubleValues[16] =
         {2.0f, 4.0f, 6.0f,
          10.0f, 12.0f, 14.0f,
          18.0f, 20.0f, 22.0f};
-    static qreal const negDoubleValues[16] =
+    static float const negDoubleValues[16] =
         {-2.0f, -4.0f, -6.0f,
          -10.0f, -12.0f, -14.0f,
          -18.0f, -20.0f, -22.0f};
 
     QTest::newRow("unique")
-        << (void *)values << (qreal)2.0f << (void *)doubleValues;
+        << (void *)values << (float)2.0f << (void *)doubleValues;
 
     QTest::newRow("neg")
-        << (void *)values << (qreal)-2.0f << (void *)negDoubleValues;
+        << (void *)values << (float)-2.0f << (void *)negDoubleValues;
 
     QTest::newRow("zero")
-        << (void *)values << (qreal)0.0f << (void *)nullValues4;
+        << (void *)values << (float)0.0f << (void *)nullValues4;
 }
 void tst_QMatrixNxN::multiplyFactor3x3()
 {
     QFETCH(void *, m1Values);
-    QFETCH(qreal, factor);
+    QFETCH(float, factor);
     QFETCH(void *, m2Values);
 
-    QMatrix3x3 m1((const qreal *)m1Values);
+    QMatrix3x3 m1((const float *)m1Values);
 
     QMatrix3x3 m3;
     m3 = m1;
     m3 *= factor;
-    QVERIFY(isSame(m3, (const qreal *)m2Values));
+    QVERIFY(isSame(m3, (const float *)m2Values));
 
     QMatrix3x3 m4;
     m4 = m1 * factor;
-    QVERIFY(isSame(m4, (const qreal *)m2Values));
+    QVERIFY(isSame(m4, (const float *)m2Values));
 
     QMatrix3x3 m5;
     m5 = factor * m1;
-    QVERIFY(isSame(m5, (const qreal *)m2Values));
+    QVERIFY(isSame(m5, (const float *)m2Values));
 }
 
 // Test matrix multiplication by a factor for 4x4 matrices.
 void tst_QMatrixNxN::multiplyFactor4x4_data()
 {
     QTest::addColumn<void *>("m1Values");
-    QTest::addColumn<qreal>("factor");
+    QTest::addColumn<float>("factor");
     QTest::addColumn<void *>("m2Values");
 
     QTest::newRow("null")
-        << (void *)nullValues4 << (qreal)1.0f << (void *)nullValues4;
+        << (void *)nullValues4 << (float)1.0f << (void *)nullValues4;
 
     QTest::newRow("double identity")
-        << (void *)identityValues4 << (qreal)2.0f << (void *)doubleIdentity4;
+        << (void *)identityValues4 << (float)2.0f << (void *)doubleIdentity4;
 
-    static qreal const values[16] =
+    static float const values[16] =
         {1.0f, 2.0f, 3.0f, 4.0f,
          5.0f, 6.0f, 7.0f, 8.0f,
          9.0f, 10.0f, 11.0f, 12.0f,
          13.0f, 14.0f, 15.0f, 16.0f};
-    static qreal const doubleValues[16] =
+    static float const doubleValues[16] =
         {2.0f, 4.0f, 6.0f, 8.0f,
          10.0f, 12.0f, 14.0f, 16.0f,
          18.0f, 20.0f, 22.0f, 24.0f,
          26.0f, 28.0f, 30.0f, 32.0f};
-    static qreal const negDoubleValues[16] =
+    static float const negDoubleValues[16] =
         {-2.0f, -4.0f, -6.0f, -8.0f,
          -10.0f, -12.0f, -14.0f, -16.0f,
          -18.0f, -20.0f, -22.0f, -24.0f,
          -26.0f, -28.0f, -30.0f, -32.0f};
 
     QTest::newRow("unique")
-        << (void *)values << (qreal)2.0f << (void *)doubleValues;
+        << (void *)values << (float)2.0f << (void *)doubleValues;
 
     QTest::newRow("neg")
-        << (void *)values << (qreal)-2.0f << (void *)negDoubleValues;
+        << (void *)values << (float)-2.0f << (void *)negDoubleValues;
 
     QTest::newRow("zero")
-        << (void *)values << (qreal)0.0f << (void *)nullValues4;
+        << (void *)values << (float)0.0f << (void *)nullValues4;
 }
 void tst_QMatrixNxN::multiplyFactor4x4()
 {
     QFETCH(void *, m1Values);
-    QFETCH(qreal, factor);
+    QFETCH(float, factor);
     QFETCH(void *, m2Values);
 
-    QMatrix4x4 m1((const qreal *)m1Values);
+    QMatrix4x4 m1((const float *)m1Values);
 
     QMatrix4x4 m3;
     m3 = m1;
     m3 *= factor;
-    QVERIFY(isSame(m3, (const qreal *)m2Values));
+    QVERIFY(isSame(m3, (const float *)m2Values));
 
     QMatrix4x4 m4;
     m4 = m1 * factor;
-    QVERIFY(isSame(m4, (const qreal *)m2Values));
+    QVERIFY(isSame(m4, (const float *)m2Values));
 
     QMatrix4x4 m5;
     m5 = factor * m1;
-    QVERIFY(isSame(m5, (const qreal *)m2Values));
+    QVERIFY(isSame(m5, (const float *)m2Values));
 }
 
 // Test matrix multiplication by a factor for 4x3 matrices.
 void tst_QMatrixNxN::multiplyFactor4x3_data()
 {
     QTest::addColumn<void *>("m1Values");
-    QTest::addColumn<qreal>("factor");
+    QTest::addColumn<float>("factor");
     QTest::addColumn<void *>("m2Values");
 
     QTest::newRow("null")
-        << (void *)nullValues4x3 << (qreal)1.0f << (void *)nullValues4x3;
+        << (void *)nullValues4x3 << (float)1.0f << (void *)nullValues4x3;
 
     QTest::newRow("double identity")
-        << (void *)identityValues4x3 << (qreal)2.0f << (void *)doubleIdentity4x3;
+        << (void *)identityValues4x3 << (float)2.0f << (void *)doubleIdentity4x3;
 
-    static qreal const values[12] =
+    static float const values[12] =
         {1.0f, 2.0f, 3.0f, 4.0f,
          5.0f, 6.0f, 7.0f, 8.0f,
          9.0f, 10.0f, 11.0f, 12.0f};
-    static qreal const doubleValues[12] =
+    static float const doubleValues[12] =
         {2.0f, 4.0f, 6.0f, 8.0f,
          10.0f, 12.0f, 14.0f, 16.0f,
          18.0f, 20.0f, 22.0f, 24.0f};
-    static qreal const negDoubleValues[12] =
+    static float const negDoubleValues[12] =
         {-2.0f, -4.0f, -6.0f, -8.0f,
          -10.0f, -12.0f, -14.0f, -16.0f,
          -18.0f, -20.0f, -22.0f, -24.0f};
 
     QTest::newRow("unique")
-        << (void *)values << (qreal)2.0f << (void *)doubleValues;
+        << (void *)values << (float)2.0f << (void *)doubleValues;
 
     QTest::newRow("neg")
-        << (void *)values << (qreal)-2.0f << (void *)negDoubleValues;
+        << (void *)values << (float)-2.0f << (void *)negDoubleValues;
 
     QTest::newRow("zero")
-        << (void *)values << (qreal)0.0f << (void *)nullValues4x3;
+        << (void *)values << (float)0.0f << (void *)nullValues4x3;
 }
 void tst_QMatrixNxN::multiplyFactor4x3()
 {
     QFETCH(void *, m1Values);
-    QFETCH(qreal, factor);
+    QFETCH(float, factor);
     QFETCH(void *, m2Values);
 
-    QMatrix4x3 m1((const qreal *)m1Values);
+    QMatrix4x3 m1((const float *)m1Values);
 
     QMatrix4x3 m3;
     m3 = m1;
     m3 *= factor;
-    QVERIFY(isSame(m3, (const qreal *)m2Values));
+    QVERIFY(isSame(m3, (const float *)m2Values));
 
     QMatrix4x3 m4;
     m4 = m1 * factor;
-    QVERIFY(isSame(m4, (const qreal *)m2Values));
+    QVERIFY(isSame(m4, (const float *)m2Values));
 
     QMatrix4x3 m5;
     m5 = factor * m1;
-    QVERIFY(isSame(m5, (const qreal *)m2Values));
+    QVERIFY(isSame(m5, (const float *)m2Values));
 }
 
 // Test matrix division by a factor for 2x2 matrices.
@@ -1532,22 +1524,22 @@ void tst_QMatrixNxN::divideFactor2x2_data()
 void tst_QMatrixNxN::divideFactor2x2()
 {
     QFETCH(void *, m1Values);
-    QFETCH(qreal, factor);
+    QFETCH(float, factor);
     QFETCH(void *, m2Values);
 
     if (factor == 0.0f)
         return;
 
-    QMatrix2x2 m2((const qreal *)m2Values);
+    QMatrix2x2 m2((const float *)m2Values);
 
     QMatrix2x2 m3;
     m3 = m2;
     m3 /= factor;
-    QVERIFY(isSame(m3, (const qreal *)m1Values));
+    QVERIFY(isSame(m3, (const float *)m1Values));
 
     QMatrix2x2 m4;
     m4 = m2 / factor;
-    QVERIFY(isSame(m4, (const qreal *)m1Values));
+    QVERIFY(isSame(m4, (const float *)m1Values));
 }
 
 // Test matrix division by a factor for 3x3 matrices.
@@ -1559,22 +1551,22 @@ void tst_QMatrixNxN::divideFactor3x3_data()
 void tst_QMatrixNxN::divideFactor3x3()
 {
     QFETCH(void *, m1Values);
-    QFETCH(qreal, factor);
+    QFETCH(float, factor);
     QFETCH(void *, m2Values);
 
     if (factor == 0.0f)
         return;
 
-    QMatrix3x3 m2((const qreal *)m2Values);
+    QMatrix3x3 m2((const float *)m2Values);
 
     QMatrix3x3 m3;
     m3 = m2;
     m3 /= factor;
-    QVERIFY(isSame(m3, (const qreal *)m1Values));
+    QVERIFY(isSame(m3, (const float *)m1Values));
 
     QMatrix3x3 m4;
     m4 = m2 / factor;
-    QVERIFY(isSame(m4, (const qreal *)m1Values));
+    QVERIFY(isSame(m4, (const float *)m1Values));
 }
 
 // Test matrix division by a factor for 4x4 matrices.
@@ -1586,22 +1578,22 @@ void tst_QMatrixNxN::divideFactor4x4_data()
 void tst_QMatrixNxN::divideFactor4x4()
 {
     QFETCH(void *, m1Values);
-    QFETCH(qreal, factor);
+    QFETCH(float, factor);
     QFETCH(void *, m2Values);
 
     if (factor == 0.0f)
         return;
 
-    QMatrix4x4 m2((const qreal *)m2Values);
+    QMatrix4x4 m2((const float *)m2Values);
 
     QMatrix4x4 m3;
     m3 = m2;
     m3 /= factor;
-    QVERIFY(isSame(m3, (const qreal *)m1Values));
+    QVERIFY(isSame(m3, (const float *)m1Values));
 
     QMatrix4x4 m4;
     m4 = m2 / factor;
-    QVERIFY(isSame(m4, (const qreal *)m1Values));
+    QVERIFY(isSame(m4, (const float *)m1Values));
 }
 
 // Test matrix division by a factor for 4x3 matrices.
@@ -1613,22 +1605,22 @@ void tst_QMatrixNxN::divideFactor4x3_data()
 void tst_QMatrixNxN::divideFactor4x3()
 {
     QFETCH(void *, m1Values);
-    QFETCH(qreal, factor);
+    QFETCH(float, factor);
     QFETCH(void *, m2Values);
 
     if (factor == 0.0f)
         return;
 
-    QMatrix4x3 m2((const qreal *)m2Values);
+    QMatrix4x3 m2((const float *)m2Values);
 
     QMatrix4x3 m3;
     m3 = m2;
     m3 /= factor;
-    QVERIFY(isSame(m3, (const qreal *)m1Values));
+    QVERIFY(isSame(m3, (const float *)m1Values));
 
     QMatrix4x3 m4;
     m4 = m2 / factor;
-    QVERIFY(isSame(m4, (const qreal *)m1Values));
+    QVERIFY(isSame(m4, (const float *)m1Values));
 }
 
 // Test matrix negation for 2x2 matrices.
@@ -1641,11 +1633,11 @@ void tst_QMatrixNxN::negate2x2()
 {
     QFETCH(void *, m1Values);
 
-    const qreal *values = (const qreal *)m1Values;
+    const float *values = (const float *)m1Values;
 
     QMatrix2x2 m1(values);
 
-    qreal negated[4];
+    float negated[4];
     for (int index = 0; index < 4; ++index)
         negated[index] = -values[index];
 
@@ -1664,11 +1656,11 @@ void tst_QMatrixNxN::negate3x3()
 {
     QFETCH(void *, m1Values);
 
-    const qreal *values = (const qreal *)m1Values;
+    const float *values = (const float *)m1Values;
 
     QMatrix3x3 m1(values);
 
-    qreal negated[9];
+    float negated[9];
     for (int index = 0; index < 9; ++index)
         negated[index] = -values[index];
 
@@ -1687,11 +1679,11 @@ void tst_QMatrixNxN::negate4x4()
 {
     QFETCH(void *, m1Values);
 
-    const qreal *values = (const qreal *)m1Values;
+    const float *values = (const float *)m1Values;
 
     QMatrix4x4 m1(values);
 
-    qreal negated[16];
+    float negated[16];
     for (int index = 0; index < 16; ++index)
         negated[index] = -values[index];
 
@@ -1710,11 +1702,11 @@ void tst_QMatrixNxN::negate4x3()
 {
     QFETCH(void *, m1Values);
 
-    const qreal *values = (const qreal *)m1Values;
+    const float *values = (const float *)m1Values;
 
     QMatrix4x3 m1(values);
 
-    qreal negated[12];
+    float negated[12];
     for (int index = 0; index < 12; ++index)
         negated[index] = -values[index];
 
@@ -1730,14 +1722,14 @@ void tst_QMatrixNxN::negate4x3()
 
 struct Matrix3
 {
-    qreal v[9];
+    float v[9];
 };
 struct Matrix4
 {
-    qreal v[16];
+    float v[16];
 };
 
-static qreal m3Determinant(const Matrix3& m)
+static float m3Determinant(const Matrix3& m)
 {
     return m.v[0] * (m.v[4] * m.v[8] - m.v[7] * m.v[5]) -
            m.v[1] * (m.v[3] * m.v[8] - m.v[6] * m.v[5]) +
@@ -1746,7 +1738,7 @@ static qreal m3Determinant(const Matrix3& m)
 
 static bool m3Inverse(const Matrix3& min, Matrix3& mout)
 {
-    qreal det = m3Determinant(min);
+    float det = m3Determinant(min);
     if (det == 0.0f)
         return false;
     mout.v[0] =  (min.v[4] * min.v[8] - min.v[5] * min.v[7]) / det;
@@ -1779,11 +1771,11 @@ static void m4Submatrix(const Matrix4& min, Matrix3& mout, int i, int j)
     }
 }
 
-static qreal m4Determinant(const Matrix4& m)
+static float m4Determinant(const Matrix4& m)
 {
-    qreal det;
-    qreal result = 0.0f;
-    qreal i = 1.0f;
+    float det;
+    float result = 0.0f;
+    float i = 1.0f;
     Matrix3 msub;
     for (int n = 0; n < 4; ++n, i *= -1.0f) {
         m4Submatrix(m, msub, 0, n);
@@ -1795,11 +1787,11 @@ static qreal m4Determinant(const Matrix4& m)
 
 static void m4Inverse(const Matrix4& min, Matrix4& mout)
 {
-    qreal det = m4Determinant(min);
+    float det = m4Determinant(min);
     Matrix3 msub;
     for (int i = 0; i < 4; ++i) {
         for (int j = 0; j < 4; ++j) {
-            qreal sign = 1.0f - ((i + j) % 2) * 2.0f;
+            float sign = 1.0f - ((i + j) % 2) * 2.0f;
             m4Submatrix(min, msub, i, j);
             mout.v[i + j * 4] = (m3Determinant(msub) * sign) / det;
         }
@@ -1868,7 +1860,7 @@ void tst_QMatrixNxN::inverted4x4()
     QFETCH(void *, m2Values);
     QFETCH(bool, invertible);
 
-    QMatrix4x4 m1((const qreal *)m1Values);
+    QMatrix4x4 m1((const float *)m1Values);
 
     if (invertible)
         QVERIFY(m1.determinant() != 0.0f);
@@ -1876,14 +1868,14 @@ void tst_QMatrixNxN::inverted4x4()
         QVERIFY(m1.determinant() == 0.0f);
 
     Matrix4 m1alt;
-    memcpy(m1alt.v, (const qreal *)m1Values, sizeof(m1alt.v));
+    memcpy(m1alt.v, (const float *)m1Values, sizeof(m1alt.v));
 
     QCOMPARE(m1.determinant(), m4Determinant(m1alt));
 
     QMatrix4x4 m2;
     bool inv;
     m2 = m1.inverted(&inv);
-    QVERIFY(isSame(m2, (const qreal *)m2Values));
+    QVERIFY(isSame(m2, (const float *)m2Values));
 
     if (invertible) {
         QVERIFY(inv);
@@ -1906,7 +1898,7 @@ void tst_QMatrixNxN::inverted4x4()
     // Test again, after inferring the special matrix type.
     m1.optimize();
     m2 = m1.inverted(&inv);
-    QVERIFY(isSame(m2, (const qreal *)m2Values));
+    QVERIFY(isSame(m2, (const float *)m2Values));
     QCOMPARE(inv, invertible);
 }
 
@@ -1947,62 +1939,62 @@ void tst_QMatrixNxN::orthonormalInverse4x4()
 // Test the generation and use of 4x4 scale matrices.
 void tst_QMatrixNxN::scale4x4_data()
 {
-    QTest::addColumn<qreal>("x");
-    QTest::addColumn<qreal>("y");
-    QTest::addColumn<qreal>("z");
+    QTest::addColumn<float>("x");
+    QTest::addColumn<float>("y");
+    QTest::addColumn<float>("z");
     QTest::addColumn<void *>("resultValues");
 
-    static const qreal nullScale[] =
+    static const float nullScale[] =
         {0.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (void *)nullScale;
+        << (float)0.0f << (float)0.0f << (float)0.0f << (void *)nullScale;
 
     QTest::newRow("identity")
-        << (qreal)1.0f << (qreal)1.0f << (qreal)1.0f << (void *)identityValues4;
+        << (float)1.0f << (float)1.0f << (float)1.0f << (void *)identityValues4;
 
-    static const qreal doubleScale[] =
+    static const float doubleScale[] =
         {2.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 2.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 2.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("double")
-        << (qreal)2.0f << (qreal)2.0f << (qreal)2.0f << (void *)doubleScale;
+        << (float)2.0f << (float)2.0f << (float)2.0f << (void *)doubleScale;
 
-    static const qreal complexScale[] =
+    static const float complexScale[] =
         {2.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 11.0f, 0.0f, 0.0f,
          0.0f, 0.0f, -6.5f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("complex")
-        << (qreal)2.0f << (qreal)11.0f << (qreal)-6.5f << (void *)complexScale;
+        << (float)2.0f << (float)11.0f << (float)-6.5f << (void *)complexScale;
 
-    static const qreal complexScale2D[] =
+    static const float complexScale2D[] =
         {2.0f, 0.0f, 0.0f, 0.0f,
          0.0f, -11.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("complex2D")
-        << (qreal)2.0f << (qreal)-11.0f << (qreal)1.0f << (void *)complexScale2D;
+        << (float)2.0f << (float)-11.0f << (float)1.0f << (void *)complexScale2D;
 }
 void tst_QMatrixNxN::scale4x4()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
     QFETCH(void *, resultValues);
 
-    QMatrix4x4 result((const qreal *)resultValues);
+    QMatrix4x4 result((const float *)resultValues);
 
     QMatrix4x4 m1;
     m1.scale(QVector3D(x, y, z));
-    QVERIFY(isSame(m1, (const qreal *)resultValues));
+    QVERIFY(isSame(m1, (const float *)resultValues));
 
     QMatrix4x4 m2;
     m2.scale(x, y, z);
-    QVERIFY(isSame(m2, (const qreal *)resultValues));
+    QVERIFY(isSame(m2, (const float *)resultValues));
 
     if (z == 1.0f) {
         QMatrix4x4 m2b;
@@ -2012,27 +2004,27 @@ void tst_QMatrixNxN::scale4x4()
 
     QVector3D v1(2.0f, 3.0f, -4.0f);
     QVector3D v2 = m1 * v1;
-    QCOMPARE(v2.x(), (qreal)(2.0f * x));
-    QCOMPARE(v2.y(), (qreal)(3.0f * y));
-    QCOMPARE(v2.z(), (qreal)(-4.0f * z));
+    QCOMPARE(v2.x(), (float)(2.0f * x));
+    QCOMPARE(v2.y(), (float)(3.0f * y));
+    QCOMPARE(v2.z(), (float)(-4.0f * z));
 
     v2 = v1 * m1;
-    QCOMPARE(v2.x(), (qreal)(2.0f * x));
-    QCOMPARE(v2.y(), (qreal)(3.0f * y));
-    QCOMPARE(v2.z(), (qreal)(-4.0f * z));
+    QCOMPARE(v2.x(), (float)(2.0f * x));
+    QCOMPARE(v2.y(), (float)(3.0f * y));
+    QCOMPARE(v2.z(), (float)(-4.0f * z));
 
     QVector4D v3(2.0f, 3.0f, -4.0f, 34.0f);
     QVector4D v4 = m1 * v3;
-    QCOMPARE(v4.x(), (qreal)(2.0f * x));
-    QCOMPARE(v4.y(), (qreal)(3.0f * y));
-    QCOMPARE(v4.z(), (qreal)(-4.0f * z));
-    QCOMPARE(v4.w(), (qreal)34.0f);
+    QCOMPARE(v4.x(), (float)(2.0f * x));
+    QCOMPARE(v4.y(), (float)(3.0f * y));
+    QCOMPARE(v4.z(), (float)(-4.0f * z));
+    QCOMPARE(v4.w(), (float)34.0f);
 
     v4 = v3 * m1;
-    QCOMPARE(v4.x(), (qreal)(2.0f * x));
-    QCOMPARE(v4.y(), (qreal)(3.0f * y));
-    QCOMPARE(v4.z(), (qreal)(-4.0f * z));
-    QCOMPARE(v4.w(), (qreal)34.0f);
+    QCOMPARE(v4.x(), (float)(2.0f * x));
+    QCOMPARE(v4.y(), (float)(3.0f * y));
+    QCOMPARE(v4.z(), (float)(-4.0f * z));
+    QCOMPARE(v4.w(), (float)34.0f);
 
     QPoint p1(2, 3);
     QPoint p2 = m1 * p1;
@@ -2045,12 +2037,12 @@ void tst_QMatrixNxN::scale4x4()
 
     QPointF p3(2.0f, 3.0f);
     QPointF p4 = m1 * p3;
-    QCOMPARE(p4.x(), (qreal)(2.0f * x));
-    QCOMPARE(p4.y(), (qreal)(3.0f * y));
+    QCOMPARE(p4.x(), (float)(2.0f * x));
+    QCOMPARE(p4.y(), (float)(3.0f * y));
 
     p4 = p3 * m1;
-    QCOMPARE(p4.x(), (qreal)(2.0f * x));
-    QCOMPARE(p4.y(), (qreal)(3.0f * y));
+    QCOMPARE(p4.x(), (float)(2.0f * x));
+    QCOMPARE(p4.y(), (float)(3.0f * y));
 
     QMatrix4x4 m3(uniqueValues4);
     QMatrix4x4 m4(m3);
@@ -2060,7 +2052,7 @@ void tst_QMatrixNxN::scale4x4()
     if (x == y && y == z) {
         QMatrix4x4 m5;
         m5.scale(x);
-        QVERIFY(isSame(m5, (const qreal *)resultValues));
+        QVERIFY(isSame(m5, (const float *)resultValues));
     }
 
     if (z == 1.0f) {
@@ -2074,81 +2066,81 @@ void tst_QMatrixNxN::scale4x4()
     QMatrix4x4 m6;
     m6(0, 0) = 1.0f;
     m6.scale(QVector3D(x, y, z));
-    QVERIFY(isSame(m6, (const qreal *)resultValues));
+    QVERIFY(isSame(m6, (const float *)resultValues));
 
     QMatrix4x4 m7;
     m7(0, 0) = 1.0f;
     m7.scale(x, y, z);
-    QVERIFY(isSame(m7, (const qreal *)resultValues));
+    QVERIFY(isSame(m7, (const float *)resultValues));
 
     if (x == y && y == z) {
         QMatrix4x4 m8;
         m8(0, 0) = 1.0f;
         m8.scale(x);
-        QVERIFY(isSame(m8, (const qreal *)resultValues));
+        QVERIFY(isSame(m8, (const float *)resultValues));
 
         m8.optimize();
         m8.scale(1.0f);
-        QVERIFY(isSame(m8, (const qreal *)resultValues));
+        QVERIFY(isSame(m8, (const float *)resultValues));
 
         QMatrix4x4 m9;
         m9.translate(0.0f, 0.0f, 0.0f);
         m9.scale(x);
-        QVERIFY(isSame(m9, (const qreal *)resultValues));
+        QVERIFY(isSame(m9, (const float *)resultValues));
     }
 }
 
 // Test the generation and use of 4x4 translation matrices.
 void tst_QMatrixNxN::translate4x4_data()
 {
-    QTest::addColumn<qreal>("x");
-    QTest::addColumn<qreal>("y");
-    QTest::addColumn<qreal>("z");
+    QTest::addColumn<float>("x");
+    QTest::addColumn<float>("y");
+    QTest::addColumn<float>("z");
     QTest::addColumn<void *>("resultValues");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (void *)identityValues4;
+        << (float)0.0f << (float)0.0f << (float)0.0f << (void *)identityValues4;
 
-    static const qreal identityTranslate[] =
+    static const float identityTranslate[] =
         {1.0f, 0.0f, 0.0f, 1.0f,
          0.0f, 1.0f, 0.0f, 1.0f,
          0.0f, 0.0f, 1.0f, 1.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("identity")
-        << (qreal)1.0f << (qreal)1.0f << (qreal)1.0f << (void *)identityTranslate;
+        << (float)1.0f << (float)1.0f << (float)1.0f << (void *)identityTranslate;
 
-    static const qreal complexTranslate[] =
+    static const float complexTranslate[] =
         {1.0f, 0.0f, 0.0f, 2.0f,
          0.0f, 1.0f, 0.0f, 11.0f,
          0.0f, 0.0f, 1.0f, -6.5f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("complex")
-        << (qreal)2.0f << (qreal)11.0f << (qreal)-6.5f << (void *)complexTranslate;
+        << (float)2.0f << (float)11.0f << (float)-6.5f << (void *)complexTranslate;
 
-    static const qreal complexTranslate2D[] =
+    static const float complexTranslate2D[] =
         {1.0f, 0.0f, 0.0f, 2.0f,
          0.0f, 1.0f, 0.0f, -11.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("complex2D")
-        << (qreal)2.0f << (qreal)-11.0f << (qreal)0.0f << (void *)complexTranslate2D;
+        << (float)2.0f << (float)-11.0f << (float)0.0f << (void *)complexTranslate2D;
 }
 void tst_QMatrixNxN::translate4x4()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
     QFETCH(void *, resultValues);
 
-    QMatrix4x4 result((const qreal *)resultValues);
+    QMatrix4x4 result((const float *)resultValues);
 
     QMatrix4x4 m1;
     m1.translate(QVector3D(x, y, z));
-    QVERIFY(isSame(m1, (const qreal *)resultValues));
+    QVERIFY(isSame(m1, (const float *)resultValues));
 
     QMatrix4x4 m2;
     m2.translate(x, y, z);
-    QVERIFY(isSame(m2, (const qreal *)resultValues));
+    QVERIFY(isSame(m2, (const float *)resultValues));
 
     if (z == 0.0f) {
         QMatrix4x4 m2b;
@@ -2158,23 +2150,23 @@ void tst_QMatrixNxN::translate4x4()
 
     QVector3D v1(2.0f, 3.0f, -4.0f);
     QVector3D v2 = m1 * v1;
-    QCOMPARE(v2.x(), (qreal)(2.0f + x));
-    QCOMPARE(v2.y(), (qreal)(3.0f + y));
-    QCOMPARE(v2.z(), (qreal)(-4.0f + z));
+    QCOMPARE(v2.x(), (float)(2.0f + x));
+    QCOMPARE(v2.y(), (float)(3.0f + y));
+    QCOMPARE(v2.z(), (float)(-4.0f + z));
 
     QVector4D v3(2.0f, 3.0f, -4.0f, 1.0f);
     QVector4D v4 = m1 * v3;
-    QCOMPARE(v4.x(), (qreal)(2.0f + x));
-    QCOMPARE(v4.y(), (qreal)(3.0f + y));
-    QCOMPARE(v4.z(), (qreal)(-4.0f + z));
-    QCOMPARE(v4.w(), (qreal)1.0f);
+    QCOMPARE(v4.x(), (float)(2.0f + x));
+    QCOMPARE(v4.y(), (float)(3.0f + y));
+    QCOMPARE(v4.z(), (float)(-4.0f + z));
+    QCOMPARE(v4.w(), (float)1.0f);
 
     QVector4D v5(2.0f, 3.0f, -4.0f, 34.0f);
     QVector4D v6 = m1 * v5;
-    QCOMPARE(v6.x(), (qreal)(2.0f + x * 34.0f));
-    QCOMPARE(v6.y(), (qreal)(3.0f + y * 34.0f));
-    QCOMPARE(v6.z(), (qreal)(-4.0f + z * 34.0f));
-    QCOMPARE(v6.w(), (qreal)34.0f);
+    QCOMPARE(v6.x(), (float)(2.0f + x * 34.0f));
+    QCOMPARE(v6.y(), (float)(3.0f + y * 34.0f));
+    QCOMPARE(v6.z(), (float)(-4.0f + z * 34.0f));
+    QCOMPARE(v6.w(), (float)34.0f);
 
     QPoint p1(2, 3);
     QPoint p2 = m1 * p1;
@@ -2183,8 +2175,8 @@ void tst_QMatrixNxN::translate4x4()
 
     QPointF p3(2.0f, 3.0f);
     QPointF p4 = m1 * p3;
-    QCOMPARE(p4.x(), (qreal)(2.0f + x));
-    QCOMPARE(p4.y(), (qreal)(3.0f + y));
+    QCOMPARE(p4.x(), (float)(2.0f + x));
+    QCOMPARE(p4.y(), (float)(3.0f + y));
 
     QMatrix4x4 m3(uniqueValues4);
     QMatrix4x4 m4(m3);
@@ -2201,116 +2193,116 @@ void tst_QMatrixNxN::translate4x4()
 // Test the generation and use of 4x4 rotation matrices.
 void tst_QMatrixNxN::rotate4x4_data()
 {
-    QTest::addColumn<qreal>("angle");
-    QTest::addColumn<qreal>("x");
-    QTest::addColumn<qreal>("y");
-    QTest::addColumn<qreal>("z");
+    QTest::addColumn<float>("angle");
+    QTest::addColumn<float>("x");
+    QTest::addColumn<float>("y");
+    QTest::addColumn<float>("z");
     QTest::addColumn<void *>("resultValues");
 
-    static const qreal nullRotate[] =
+    static const float nullRotate[] =
         {0.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("null")
-        << (qreal)90.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
+        << (float)90.0f
+        << (float)0.0f << (float)0.0f << (float)0.0f
         << (void *)nullRotate;
 
-    static const qreal noRotate[] =
+    static const float noRotate[] =
         {1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("zerodegrees")
-        << (qreal)0.0f
-        << (qreal)2.0f << (qreal)3.0f << (qreal)-4.0f
+        << (float)0.0f
+        << (float)2.0f << (float)3.0f << (float)-4.0f
         << (void *)noRotate;
 
-    static const qreal xRotate[] =
+    static const float xRotate[] =
         {1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, -1.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("xrotate")
-        << (qreal)90.0f
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
+        << (float)90.0f
+        << (float)1.0f << (float)0.0f << (float)0.0f
         << (void *)xRotate;
 
-    static const qreal xRotateNeg[] =
+    static const float xRotateNeg[] =
         {1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, -1.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("-xrotate")
-        << (qreal)90.0f
-        << (qreal)-1.0f << (qreal)0.0f << (qreal)0.0f
+        << (float)90.0f
+        << (float)-1.0f << (float)0.0f << (float)0.0f
         << (void *)xRotateNeg;
 
-    static const qreal yRotate[] =
+    static const float yRotate[] =
         {0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          -1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("yrotate")
-        << (qreal)90.0f
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
+        << (float)90.0f
+        << (float)0.0f << (float)1.0f << (float)0.0f
         << (void *)yRotate;
 
-    static const qreal yRotateNeg[] =
+    static const float yRotateNeg[] =
         {0.0f, 0.0f, -1.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("-yrotate")
-        << (qreal)90.0f
-        << (qreal)0.0f << (qreal)-1.0f << (qreal)0.0f
+        << (float)90.0f
+        << (float)0.0f << (float)-1.0f << (float)0.0f
         << (void *)yRotateNeg;
 
-    static const qreal zRotate[] =
+    static const float zRotate[] =
         {0.0f, -1.0f, 0.0f, 0.0f,
          1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("zrotate")
-        << (qreal)90.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
+        << (float)90.0f
+        << (float)0.0f << (float)0.0f << (float)1.0f
         << (void *)zRotate;
 
-    static const qreal zRotateNeg[] =
+    static const float zRotateNeg[] =
         {0.0f, 1.0f, 0.0f, 0.0f,
          -1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
     QTest::newRow("-zrotate")
-        << (qreal)90.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)-1.0f
+        << (float)90.0f
+        << (float)0.0f << (float)0.0f << (float)-1.0f
         << (void *)zRotateNeg;
 
     // Algorithm from http://en.wikipedia.org/wiki/Rotation_matrix.
     // Deliberately different from the one in the code for cross-checking.
-    static qreal complexRotate[16];
-    qreal x = 1.0f;
-    qreal y = 2.0f;
-    qreal z = -6.0f;
-    qreal angle = -45.0f;
-    qreal c = qCos(angle * M_PI / 180.0f);
-    qreal s = qSin(angle * M_PI / 180.0f);
-    qreal len = qSqrt(x * x + y * y + z * z);
-    qreal xu = x / len;
-    qreal yu = y / len;
-    qreal zu = z / len;
-    complexRotate[0] = (qreal)((1 - xu * xu) * c + xu * xu);
-    complexRotate[1] = (qreal)(-zu * s - xu * yu * c + xu * yu);
-    complexRotate[2] = (qreal)(yu * s - xu * zu * c + xu * zu);
+    static float complexRotate[16];
+    float x = 1.0f;
+    float y = 2.0f;
+    float z = -6.0f;
+    float angle = -45.0f;
+    float c = qCos(angle * M_PI / 180.0f);
+    float s = qSin(angle * M_PI / 180.0f);
+    float len = sqrtf(x * x + y * y + z * z);
+    float xu = x / len;
+    float yu = y / len;
+    float zu = z / len;
+    complexRotate[0] = (float)((1 - xu * xu) * c + xu * xu);
+    complexRotate[1] = (float)(-zu * s - xu * yu * c + xu * yu);
+    complexRotate[2] = (float)(yu * s - xu * zu * c + xu * zu);
     complexRotate[3] = 0;
-    complexRotate[4] = (qreal)(zu * s - xu * yu * c + xu * yu);
-    complexRotate[5] = (qreal)((1 - yu * yu) * c + yu * yu);
-    complexRotate[6] = (qreal)(-xu * s - yu * zu * c + yu * zu);
+    complexRotate[4] = (float)(zu * s - xu * yu * c + xu * yu);
+    complexRotate[5] = (float)((1 - yu * yu) * c + yu * yu);
+    complexRotate[6] = (float)(-xu * s - yu * zu * c + yu * zu);
     complexRotate[7] = 0;
-    complexRotate[8] = (qreal)(-yu * s - xu * zu * c + xu * zu);
-    complexRotate[9] = (qreal)(xu * s - yu * zu * c + yu * zu);
-    complexRotate[10] = (qreal)((1 - zu * zu) * c + zu * zu);
+    complexRotate[8] = (float)(-yu * s - xu * zu * c + xu * zu);
+    complexRotate[9] = (float)(xu * s - yu * zu * c + yu * zu);
+    complexRotate[10] = (float)((1 - zu * zu) * c + zu * zu);
     complexRotate[11] = 0;
     complexRotate[12] = 0;
     complexRotate[13] = 0;
@@ -2318,25 +2310,25 @@ void tst_QMatrixNxN::rotate4x4_data()
     complexRotate[15] = 1;
 
     QTest::newRow("complex")
-        << (qreal)angle
-        << (qreal)x << (qreal)y << (qreal)z
+        << (float)angle
+        << (float)x << (float)y << (float)z
         << (void *)complexRotate;
 }
 void tst_QMatrixNxN::rotate4x4()
 {
-    QFETCH(qreal, angle);
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
+    QFETCH(float, angle);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
     QFETCH(void *, resultValues);
 
     QMatrix4x4 m1;
     m1.rotate(angle, QVector3D(x, y, z));
-    QVERIFY(isSame(m1, (const qreal *)resultValues));
+    QVERIFY(isSame(m1, (const float *)resultValues));
 
     QMatrix4x4 m2;
     m2.rotate(angle, x, y, z);
-    QVERIFY(isSame(m2, (const qreal *)resultValues));
+    QVERIFY(isSame(m2, (const float *)resultValues));
 
     QMatrix4x4 m3(uniqueValues4);
     QMatrix4x4 m4(m3);
@@ -2347,40 +2339,40 @@ void tst_QMatrixNxN::rotate4x4()
     if (x != 0 || y != 0 || z != 0) {
         QMatrix4x4 m5;
         m5.rotate(QQuaternion::fromAxisAndAngle(QVector3D(x, y, z), angle));
-        QVERIFY(isSame(m5, (const qreal *)resultValues));
+        QVERIFY(isSame(m5, (const float *)resultValues));
     }
 
 #define ROTATE4(xin,yin,zin,win,xout,yout,zout,wout) \
     do { \
-        xout = ((const qreal *)resultValues)[0] * xin + \
-               ((const qreal *)resultValues)[1] * yin + \
-               ((const qreal *)resultValues)[2] * zin + \
-               ((const qreal *)resultValues)[3] * win; \
-        yout = ((const qreal *)resultValues)[4] * xin + \
-               ((const qreal *)resultValues)[5] * yin + \
-               ((const qreal *)resultValues)[6] * zin + \
-               ((const qreal *)resultValues)[7] * win; \
-        zout = ((const qreal *)resultValues)[8] * xin + \
-               ((const qreal *)resultValues)[9] * yin + \
-               ((const qreal *)resultValues)[10] * zin + \
-               ((const qreal *)resultValues)[11] * win; \
-        wout = ((const qreal *)resultValues)[12] * xin + \
-               ((const qreal *)resultValues)[13] * yin + \
-               ((const qreal *)resultValues)[14] * zin + \
-               ((const qreal *)resultValues)[15] * win; \
+        xout = ((const float *)resultValues)[0] * xin + \
+               ((const float *)resultValues)[1] * yin + \
+               ((const float *)resultValues)[2] * zin + \
+               ((const float *)resultValues)[3] * win; \
+        yout = ((const float *)resultValues)[4] * xin + \
+               ((const float *)resultValues)[5] * yin + \
+               ((const float *)resultValues)[6] * zin + \
+               ((const float *)resultValues)[7] * win; \
+        zout = ((const float *)resultValues)[8] * xin + \
+               ((const float *)resultValues)[9] * yin + \
+               ((const float *)resultValues)[10] * zin + \
+               ((const float *)resultValues)[11] * win; \
+        wout = ((const float *)resultValues)[12] * xin + \
+               ((const float *)resultValues)[13] * yin + \
+               ((const float *)resultValues)[14] * zin + \
+               ((const float *)resultValues)[15] * win; \
     } while (0)
 
     // Rotate various test vectors using the straight-forward approach.
-    qreal v1x, v1y, v1z, v1w;
+    float v1x, v1y, v1z, v1w;
     ROTATE4(2.0f, 3.0f, -4.0f, 1.0f, v1x, v1y, v1z, v1w);
     v1x /= v1w;
     v1y /= v1w;
     v1z /= v1w;
-    qreal v3x, v3y, v3z, v3w;
+    float v3x, v3y, v3z, v3w;
     ROTATE4(2.0f, 3.0f, -4.0f, 1.0f, v3x, v3y, v3z, v3w);
-    qreal v5x, v5y, v5z, v5w;
+    float v5x, v5y, v5z, v5w;
     ROTATE4(2.0f, 3.0f, -4.0f, 34.0f, v5x, v5y, v5z, v5w);
-    qreal p1x, p1y, p1z, p1w;
+    float p1x, p1y, p1z, p1w;
     ROTATE4(2.0f, 3.0f, 0.0f, 1.0f, p1x, p1y, p1z, p1w);
     p1x /= p1w;
     p1y /= p1w;
@@ -2388,23 +2380,23 @@ void tst_QMatrixNxN::rotate4x4()
 
     QVector3D v1(2.0f, 3.0f, -4.0f);
     QVector3D v2 = m1 * v1;
-    QVERIFY(fuzzyCompare(v2.x(), v1x));
-    QVERIFY(fuzzyCompare(v2.y(), v1y));
-    QVERIFY(fuzzyCompare(v2.z(), v1z));
+    QVERIFY(qFuzzyCompare(v2.x(), v1x));
+    QVERIFY(qFuzzyCompare(v2.y(), v1y));
+    QVERIFY(qFuzzyCompare(v2.z(), v1z));
 
     QVector4D v3(2.0f, 3.0f, -4.0f, 1.0f);
     QVector4D v4 = m1 * v3;
-    QVERIFY(fuzzyCompare(v4.x(), v3x));
-    QVERIFY(fuzzyCompare(v4.y(), v3y));
-    QVERIFY(fuzzyCompare(v4.z(), v3z));
-    QVERIFY(fuzzyCompare(v4.w(), v3w));
+    QVERIFY(qFuzzyCompare(v4.x(), v3x));
+    QVERIFY(qFuzzyCompare(v4.y(), v3y));
+    QVERIFY(qFuzzyCompare(v4.z(), v3z));
+    QVERIFY(qFuzzyCompare(v4.w(), v3w));
 
     QVector4D v5(2.0f, 3.0f, -4.0f, 34.0f);
     QVector4D v6 = m1 * v5;
-    QVERIFY(fuzzyCompare(v6.x(), v5x));
-    QVERIFY(fuzzyCompare(v6.y(), v5y));
-    QVERIFY(fuzzyCompare(v6.z(), v5z));
-    QVERIFY(fuzzyCompare(v6.w(), v5w));
+    QVERIFY(qFuzzyCompare(v6.x(), v5x));
+    QVERIFY(qFuzzyCompare(v6.y(), v5y));
+    QVERIFY(qFuzzyCompare(v6.z(), v5z));
+    QVERIFY(qFuzzyCompare(v6.w(), v5w));
 
     QPoint p1(2, 3);
     QPoint p2 = m1 * p1;
@@ -2413,15 +2405,15 @@ void tst_QMatrixNxN::rotate4x4()
 
     QPointF p3(2.0f, 3.0f);
     QPointF p4 = m1 * p3;
-    QVERIFY(fuzzyCompare(p4.x(), p1x));
-    QVERIFY(fuzzyCompare(p4.y(), p1y));
+    QVERIFY(qFuzzyCompare(float(p4.x()), p1x));
+    QVERIFY(qFuzzyCompare(float(p4.y()), p1y));
 
     if (x != 0 || y != 0 || z != 0) {
         QQuaternion q = QQuaternion::fromAxisAndAngle(QVector3D(x, y, z), angle);
         QVector3D vq = q.rotatedVector(v1);
-        QVERIFY(fuzzyCompare(vq.x(), v1x));
-        QVERIFY(fuzzyCompare(vq.y(), v1y));
-        QVERIFY(fuzzyCompare(vq.z(), v1z));
+        QVERIFY(qFuzzyCompare(vq.x(), v1x));
+        QVERIFY(qFuzzyCompare(vq.y(), v1y));
+        QVERIFY(qFuzzyCompare(vq.z(), v1z));
     }
 }
 
@@ -2429,7 +2421,7 @@ static bool isSame(const QMatrix3x3& m1, const Matrix3& m2)
 {
     for (int row = 0; row < 3; ++row) {
         for (int col = 0; col < 3; ++col) {
-            if (!fuzzyCompare(m1(row, col), m2.v[row * 3 + col]))
+            if (!qFuzzyCompare(m1(row, col), m2.v[row * 3 + col]))
                 return false;
         }
     }
@@ -2446,37 +2438,37 @@ void tst_QMatrixNxN::normalMatrix_data()
     QTest::newRow("unique")
         << (void *)uniqueValues4;   // Not invertible because determinant == 0.
 
-    static qreal const translateValues[16] =
+    static float const translateValues[16] =
         {1.0f, 0.0f, 0.0f, 4.0f,
          0.0f, 1.0f, 0.0f, 5.0f,
          0.0f, 0.0f, 1.0f, -3.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const scaleValues[16] =
+    static float const scaleValues[16] =
         {2.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 7.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 9.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const bothValues[16] =
+    static float const bothValues[16] =
         {2.0f, 0.0f, 0.0f, 4.0f,
          0.0f, 7.0f, 0.0f, 5.0f,
          0.0f, 0.0f, 9.0f, -3.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const rotateValues[16] =
+    static float const rotateValues[16] =
         {0.0f, 0.0f, 1.0f, 0.0f,
          1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const nullScaleValues1[16] =
+    static float const nullScaleValues1[16] =
         {0.0f, 0.0f, 0.0f, 4.0f,
          0.0f, 7.0f, 0.0f, 5.0f,
          0.0f, 0.0f, 9.0f, -3.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const nullScaleValues2[16] =
+    static float const nullScaleValues2[16] =
         {2.0f, 0.0f, 0.0f, 4.0f,
          0.0f, 0.0f, 0.0f, 5.0f,
          0.0f, 0.0f, 9.0f, -3.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const nullScaleValues3[16] =
+    static float const nullScaleValues3[16] =
         {2.0f, 0.0f, 0.0f, 4.0f,
          0.0f, 7.0f, 0.0f, 5.0f,
          0.0f, 0.0f, 0.0f, -3.0f,
@@ -2493,7 +2485,7 @@ void tst_QMatrixNxN::normalMatrix_data()
 void tst_QMatrixNxN::normalMatrix()
 {
     QFETCH(void *, mValues);
-    const qreal *values = (const qreal *)mValues;
+    const float *values = (const float *)mValues;
 
     // Compute the expected answer the long way.
     Matrix3 min;
@@ -2533,42 +2525,42 @@ void tst_QMatrixNxN::normalMatrix()
 // Test optimized transformations on 4x4 matrices.
 void tst_QMatrixNxN::optimizedTransforms()
 {
-    static qreal const translateValues[16] =
+    static float const translateValues[16] =
         {1.0f, 0.0f, 0.0f, 4.0f,
          0.0f, 1.0f, 0.0f, 5.0f,
          0.0f, 0.0f, 1.0f, -3.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const translateDoubleValues[16] =
+    static float const translateDoubleValues[16] =
         {1.0f, 0.0f, 0.0f, 8.0f,
          0.0f, 1.0f, 0.0f, 10.0f,
          0.0f, 0.0f, 1.0f, -6.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const scaleValues[16] =
+    static float const scaleValues[16] =
         {2.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 7.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 9.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const scaleDoubleValues[16] =
+    static float const scaleDoubleValues[16] =
         {4.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 49.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 81.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const bothValues[16] =
+    static float const bothValues[16] =
         {2.0f, 0.0f, 0.0f, 4.0f,
          0.0f, 7.0f, 0.0f, 5.0f,
          0.0f, 0.0f, 9.0f, -3.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const bothReverseValues[16] =
+    static float const bothReverseValues[16] =
         {2.0f, 0.0f, 0.0f, 4.0f * 2.0f,
          0.0f, 7.0f, 0.0f, 5.0f * 7.0f,
          0.0f, 0.0f, 9.0f, -3.0f * 9.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const bothThenTranslateValues[16] =
+    static float const bothThenTranslateValues[16] =
         {2.0f, 0.0f, 0.0f, 4.0f + 2.0f * 4.0f,
          0.0f, 7.0f, 0.0f, 5.0f + 7.0f * 5.0f,
          0.0f, 0.0f, 9.0f, -3.0f + 9.0f * -3.0f,
          0.0f, 0.0f, 0.0f, 1.0f};
-    static qreal const bothThenScaleValues[16] =
+    static float const bothThenScaleValues[16] =
         {4.0f, 0.0f, 0.0f, 4.0f,
          0.0f, 49.0f, 0.0f, 5.0f,
          0.0f, 0.0f, 81.0f, -3.0f,
@@ -2651,17 +2643,17 @@ void tst_QMatrixNxN::ortho()
     QPointF p3 = m1 * QPointF(0, 150);
     QPointF p4 = m1 * QPointF(300, 150);
     QVector3D p5 = m1 * QVector3D(300, 150, 1);
-    QVERIFY(fuzzyCompare(p1.x(), -1.0));
-    QVERIFY(fuzzyCompare(p1.y(), 1.0));
-    QVERIFY(fuzzyCompare(p2.x(), 1.0));
-    QVERIFY(fuzzyCompare(p2.y(), 1.0));
-    QVERIFY(fuzzyCompare(p3.x(), -1.0));
-    QVERIFY(fuzzyCompare(p3.y(), -1.0));
-    QVERIFY(fuzzyCompare(p4.x(), 1.0));
-    QVERIFY(fuzzyCompare(p4.y(), -1.0));
-    QVERIFY(fuzzyCompare(p5.x(), (qreal)1.0));
-    QVERIFY(fuzzyCompare(p5.y(), (qreal)-1.0));
-    QVERIFY(fuzzyCompare(p5.z(), (qreal)-1.0));
+    QVERIFY(qFuzzyCompare(float(p1.x()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p1.y()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p2.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p2.y()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p3.x()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p3.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p4.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p4.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.z()), -1.0f));
 
     QMatrix4x4 m2;
     m2.ortho(QRectF(0, 0, 300, 150));
@@ -2670,17 +2662,17 @@ void tst_QMatrixNxN::ortho()
     p3 = m2 * QPointF(0, 150);
     p4 = m2 * QPointF(300, 150);
     p5 = m2 * QVector3D(300, 150, 1);
-    QVERIFY(fuzzyCompare(p1.x(), -1.0));
-    QVERIFY(fuzzyCompare(p1.y(), 1.0));
-    QVERIFY(fuzzyCompare(p2.x(), 1.0));
-    QVERIFY(fuzzyCompare(p2.y(), 1.0));
-    QVERIFY(fuzzyCompare(p3.x(), -1.0));
-    QVERIFY(fuzzyCompare(p3.y(), -1.0));
-    QVERIFY(fuzzyCompare(p4.x(), 1.0));
-    QVERIFY(fuzzyCompare(p4.y(), -1.0));
-    QVERIFY(fuzzyCompare(p5.x(), (qreal)1.0));
-    QVERIFY(fuzzyCompare(p5.y(), (qreal)-1.0));
-    QVERIFY(fuzzyCompare(p5.z(), (qreal)-1.0));
+    QVERIFY(qFuzzyCompare(float(p1.x()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p1.y()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p2.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p2.y()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p3.x()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p3.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p4.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p4.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.z()), -1.0f));
 
     QMatrix4x4 m3;
     m3.ortho(0, 300, 150, 0, -1, 1);
@@ -2689,17 +2681,17 @@ void tst_QMatrixNxN::ortho()
     p3 = m3 * QPointF(0, 150);
     p4 = m3 * QPointF(300, 150);
     p5 = m3 * QVector3D(300, 150, 1);
-    QVERIFY(fuzzyCompare(p1.x(), -1.0));
-    QVERIFY(fuzzyCompare(p1.y(), 1.0));
-    QVERIFY(fuzzyCompare(p2.x(), 1.0));
-    QVERIFY(fuzzyCompare(p2.y(), 1.0));
-    QVERIFY(fuzzyCompare(p3.x(), -1.0));
-    QVERIFY(fuzzyCompare(p3.y(), -1.0));
-    QVERIFY(fuzzyCompare(p4.x(), 1.0));
-    QVERIFY(fuzzyCompare(p4.y(), -1.0));
-    QVERIFY(fuzzyCompare(p5.x(), (qreal)1.0));
-    QVERIFY(fuzzyCompare(p5.y(), (qreal)-1.0));
-    QVERIFY(fuzzyCompare(p5.z(), (qreal)-1.0));
+    QVERIFY(qFuzzyCompare(float(p1.x()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p1.y()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p2.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p2.y()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p3.x()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p3.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p4.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p4.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.z()), -1.0f));
 
     QMatrix4x4 m4;
     m4.ortho(0, 300, 150, 0, -2, 3);
@@ -2708,17 +2700,17 @@ void tst_QMatrixNxN::ortho()
     p3 = m4 * QPointF(0, 150);
     p4 = m4 * QPointF(300, 150);
     p5 = m4 * QVector3D(300, 150, 1);
-    QVERIFY(fuzzyCompare(p1.x(), -1.0));
-    QVERIFY(fuzzyCompare(p1.y(), 1.0));
-    QVERIFY(fuzzyCompare(p2.x(), 1.0));
-    QVERIFY(fuzzyCompare(p2.y(), 1.0));
-    QVERIFY(fuzzyCompare(p3.x(), -1.0));
-    QVERIFY(fuzzyCompare(p3.y(), -1.0));
-    QVERIFY(fuzzyCompare(p4.x(), 1.0));
-    QVERIFY(fuzzyCompare(p4.y(), -1.0));
-    QVERIFY(fuzzyCompare(p5.x(), (qreal)1.0));
-    QVERIFY(fuzzyCompare(p5.y(), (qreal)-1.0));
-    QVERIFY(fuzzyCompare(p5.z(), (qreal)-0.6));
+    QVERIFY(qFuzzyCompare(float(p1.x()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p1.y()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p2.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p2.y()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p3.x()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p3.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p4.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p4.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.x()), 1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.y()), -1.0f));
+    QVERIFY(qFuzzyCompare(float(p5.z()), -0.6f));
 
     // An empty view volume should leave the matrix alone.
     QMatrix4x4 m5;
@@ -2740,21 +2732,21 @@ void tst_QMatrixNxN::frustum()
     QVector3D p3 = m1 * QVector3D(-1.0f, 1.0f, 1.0f);
     QVector3D p4 = m1 * QVector3D(1.0f, 1.0f, 1.0f);
     QVector3D p5 = m1 * QVector3D(0.0f, 0.0f, 2.0f);
-    QVERIFY(fuzzyCompare(p1.x(), -1.0f));
-    QVERIFY(fuzzyCompare(p1.y(), -1.0f));
-    QVERIFY(fuzzyCompare(p1.z(), -1.0f));
-    QVERIFY(fuzzyCompare(p2.x(), 1.0f));
-    QVERIFY(fuzzyCompare(p2.y(), -1.0f));
-    QVERIFY(fuzzyCompare(p2.z(), -1.0f));
-    QVERIFY(fuzzyCompare(p3.x(), -1.0f));
-    QVERIFY(fuzzyCompare(p3.y(), 1.0f));
-    QVERIFY(fuzzyCompare(p3.z(), -1.0f));
-    QVERIFY(fuzzyCompare(p4.x(), 1.0f));
-    QVERIFY(fuzzyCompare(p4.y(), 1.0f));
-    QVERIFY(fuzzyCompare(p4.z(), -1.0f));
-    QVERIFY(fuzzyCompare(p5.x(), 0.0f));
-    QVERIFY(fuzzyCompare(p5.y(), 0.0f));
-    QVERIFY(fuzzyCompare(p5.z(), -0.5f));
+    QVERIFY(qFuzzyCompare(p1.x(), -1.0f));
+    QVERIFY(qFuzzyCompare(p1.y(), -1.0f));
+    QVERIFY(qFuzzyCompare(p1.z(), -1.0f));
+    QVERIFY(qFuzzyCompare(p2.x(), 1.0f));
+    QVERIFY(qFuzzyCompare(p2.y(), -1.0f));
+    QVERIFY(qFuzzyCompare(p2.z(), -1.0f));
+    QVERIFY(qFuzzyCompare(p3.x(), -1.0f));
+    QVERIFY(qFuzzyCompare(p3.y(), 1.0f));
+    QVERIFY(qFuzzyCompare(p3.z(), -1.0f));
+    QVERIFY(qFuzzyCompare(p4.x(), 1.0f));
+    QVERIFY(qFuzzyCompare(p4.y(), 1.0f));
+    QVERIFY(qFuzzyCompare(p4.z(), -1.0f));
+    QVERIFY(qFuzzyCompare(p5.x(), 0.0f));
+    QVERIFY(qFuzzyCompare(p5.y(), 0.0f));
+    QVERIFY(qFuzzyCompare(p5.z(), -0.5f));
 
     // An empty view volume should leave the matrix alone.
     QMatrix4x4 m5;
@@ -2776,21 +2768,21 @@ void tst_QMatrixNxN::perspective()
     QVector3D p3 = m1 * QVector3D(-1.0f, 1.0f, 1.0f);
     QVector3D p4 = m1 * QVector3D(1.0f, 1.0f, 1.0f);
     QVector3D p5 = m1 * QVector3D(0.0f, 0.0f, 2.0f);
-    QVERIFY(fuzzyCompare(p1.x(), 2.41421));
-    QVERIFY(fuzzyCompare(p1.y(), 2.41421));
-    QVERIFY(fuzzyCompare(p1.z(), -1));
-    QVERIFY(fuzzyCompare(p2.x(), -2.41421));
-    QVERIFY(fuzzyCompare(p2.y(), 2.41421));
-    QVERIFY(fuzzyCompare(p2.z(), -1.0f));
-    QVERIFY(fuzzyCompare(p3.x(), 2.41421));
-    QVERIFY(fuzzyCompare(p3.y(), -2.41421));
-    QVERIFY(fuzzyCompare(p3.z(), -1.0f));
-    QVERIFY(fuzzyCompare(p4.x(), -2.41421));
-    QVERIFY(fuzzyCompare(p4.y(), -2.41421));
-    QVERIFY(fuzzyCompare(p4.z(), -1.0f));
-    QVERIFY(fuzzyCompare(p5.x(), 0.0f));
-    QVERIFY(fuzzyCompare(p5.y(), 0.0f));
-    QVERIFY(fuzzyCompare(p5.z(), -0.5f));
+    QVERIFY(qFuzzyCompare(p1.x(), 2.41421f));
+    QVERIFY(qFuzzyCompare(p1.y(), 2.41421f));
+    QVERIFY(qFuzzyCompare(p1.z(), -1.0f));
+    QVERIFY(qFuzzyCompare(p2.x(), -2.41421f));
+    QVERIFY(qFuzzyCompare(p2.y(), 2.41421f));
+    QVERIFY(qFuzzyCompare(p2.z(), -1.0f));
+    QVERIFY(qFuzzyCompare(p3.x(), 2.41421f));
+    QVERIFY(qFuzzyCompare(p3.y(), -2.41421f));
+    QVERIFY(qFuzzyCompare(p3.z(), -1.0f));
+    QVERIFY(qFuzzyCompare(p4.x(), -2.41421f));
+    QVERIFY(qFuzzyCompare(p4.y(), -2.41421f));
+    QVERIFY(qFuzzyCompare(p4.z(), -1.0f));
+    QVERIFY(qFuzzyCompare(p5.x(), 0.0f));
+    QVERIFY(qFuzzyCompare(p5.y(), 0.0f));
+    QVERIFY(qFuzzyCompare(p5.z(), -0.5f));
 
     // An empty view volume should leave the matrix alone.
     QMatrix4x4 m5;
@@ -2834,7 +2826,7 @@ void tst_QMatrixNxN::convertGeneric()
 {
     QMatrix4x3 m1(uniqueValues4x3);
 
-    static qreal const unique4x4[16] = {
+    static float const unique4x4[16] = {
         1.0f, 2.0f, 3.0f, 4.0f,
         5.0f, 6.0f, 7.0f, 8.0f,
         9.0f, 10.0f, 11.0f, 12.0f,
@@ -2846,7 +2838,7 @@ void tst_QMatrixNxN::convertGeneric()
     QMatrix4x4 m5 = qGenericMatrixToMatrix4x4(m1);
     QVERIFY(isSame(m5, unique4x4));
 
-    static qreal const conv4x4[12] = {
+    static float const conv4x4[12] = {
         1.0f, 2.0f, 3.0f, 4.0f,
         5.0f, 6.0f, 7.0f, 8.0f,
         9.0f, 10.0f, 11.0f, 12.0f
@@ -2874,7 +2866,7 @@ enum {
 // Structure that allows direct access to "flagBits" for testing.
 struct Matrix4x4
 {
-    qreal m[4][4];
+    float m[4][4];
     int flagBits;
 };
 
@@ -2891,7 +2883,7 @@ void tst_QMatrixNxN::optimize_data()
     QTest::newRow("unique")
         << (void *)uniqueValues4 << (int)General;
 
-    static qreal scaleValues[16] = {
+    static float scaleValues[16] = {
         2.0f, 0.0f, 0.0f, 0.0f,
         0.0f, 3.0f, 0.0f, 0.0f,
         0.0f, 0.0f, 4.0f, 0.0f,
@@ -2900,7 +2892,7 @@ void tst_QMatrixNxN::optimize_data()
     QTest::newRow("scale")
         << (void *)scaleValues << (int)Scale;
 
-    static qreal translateValues[16] = {
+    static float translateValues[16] = {
         1.0f, 0.0f, 0.0f, 2.0f,
         0.0f, 1.0f, 0.0f, 3.0f,
         0.0f, 0.0f, 1.0f, 4.0f,
@@ -2909,7 +2901,7 @@ void tst_QMatrixNxN::optimize_data()
     QTest::newRow("translate")
         << (void *)translateValues << (int)Translation;
 
-    static qreal scaleTranslateValues[16] = {
+    static float scaleTranslateValues[16] = {
         1.0f, 0.0f, 0.0f, 2.0f,
         0.0f, 2.0f, 0.0f, 0.0f,
         0.0f, 0.0f, 1.0f, 4.0f,
@@ -2918,7 +2910,7 @@ void tst_QMatrixNxN::optimize_data()
     QTest::newRow("scaleTranslate")
         << (void *)scaleTranslateValues << (int)(Scale | Translation);
 
-    static qreal rotateValues[16] = {
+    static float rotateValues[16] = {
         0.0f, 1.0f, 0.0f, 0.0f,
         -1.0f, 0.0f, 0.0f, 0.0f,
         0.0f, 0.0f, 1.0f, 0.0f,
@@ -2928,7 +2920,7 @@ void tst_QMatrixNxN::optimize_data()
         << (void *)rotateValues << (int)Rotation2D;
 
     // Left-handed system, not a simple rotation.
-    static qreal scaleRotateValues[16] = {
+    static float scaleRotateValues[16] = {
         0.0f, 1.0f, 0.0f, 0.0f,
         1.0f, 0.0f, 0.0f, 0.0f,
         0.0f, 0.0f, 1.0f, 0.0f,
@@ -2937,7 +2929,7 @@ void tst_QMatrixNxN::optimize_data()
     QTest::newRow("scaleRotate")
         << (void *)scaleRotateValues << (int)(Scale | Rotation2D);
 
-    static qreal matrix2x2Values[16] = {
+    static float matrix2x2Values[16] = {
         1.0f, 2.0f, 0.0f, 0.0f,
         8.0f, 3.0f, 0.0f, 0.0f,
         0.0f, 0.0f, 9.0f, 0.0f,
@@ -2946,7 +2938,7 @@ void tst_QMatrixNxN::optimize_data()
     QTest::newRow("matrix2x2")
         << (void *)matrix2x2Values << (int)(Scale | Rotation2D);
 
-    static qreal matrix3x3Values[16] = {
+    static float matrix3x3Values[16] = {
         1.0f, 2.0f, 4.0f, 0.0f,
         8.0f, 3.0f, 5.0f, 0.0f,
         6.0f, 7.0f, 9.0f, 0.0f,
@@ -2955,7 +2947,7 @@ void tst_QMatrixNxN::optimize_data()
     QTest::newRow("matrix3x3")
         << (void *)matrix3x3Values << (int)(Scale | Rotation2D | Rotation);
 
-    static qreal rotateTranslateValues[16] = {
+    static float rotateTranslateValues[16] = {
         0.0f, 1.0f, 0.0f, 1.0f,
         -1.0f, 0.0f, 0.0f, 2.0f,
         0.0f, 0.0f, 1.0f, 3.0f,
@@ -2965,7 +2957,7 @@ void tst_QMatrixNxN::optimize_data()
         << (void *)rotateTranslateValues << (int)(Translation | Rotation2D);
 
     // Left-handed system, not a simple rotation.
-    static qreal scaleRotateTranslateValues[16] = {
+    static float scaleRotateTranslateValues[16] = {
         0.0f, 1.0f, 0.0f, 1.0f,
         1.0f, 0.0f, 0.0f, 2.0f,
         0.0f, 0.0f, 1.0f, 3.0f,
@@ -2974,7 +2966,7 @@ void tst_QMatrixNxN::optimize_data()
     QTest::newRow("scaleRotateTranslate")
         << (void *)scaleRotateTranslateValues << (int)(Translation | Scale | Rotation2D);
 
-    static qreal belowValues[16] = {
+    static float belowValues[16] = {
         1.0f, 0.0f, 0.0f, 0.0f,
         0.0f, 1.0f, 0.0f, 0.0f,
         0.0f, 0.0f, 1.0f, 0.0f,
@@ -2988,7 +2980,7 @@ void tst_QMatrixNxN::optimize()
     QFETCH(void *, mValues);
     QFETCH(int, flagBits);
 
-    QMatrix4x4 m((const qreal *)mValues);
+    QMatrix4x4 m((const float *)mValues);
     m.optimize();
 
     QCOMPARE(reinterpret_cast<Matrix4x4 *>(&m)->flagBits, flagBits);
@@ -3074,16 +3066,16 @@ void tst_QMatrixNxN::convertQMatrix()
 
     QMatrix4x4 m6(m5);
     QPointF p6 = m6 * QPointF(100.0, 150.0);
-    QVERIFY(fuzzyCompare(p5.x(), p6.x()));
-    QVERIFY(fuzzyCompare(p5.y(), p6.y()));
+    QVERIFY(qFuzzyCompare(float(p5.x()), float(p6.x())));
+    QVERIFY(qFuzzyCompare(float(p5.y()), float(p6.y())));
 
     QMatrix m7 = m6.toAffine();
-    QVERIFY(fuzzyCompare(m5.m11(), m7.m11()));
-    QVERIFY(fuzzyCompare(m5.m12(), m7.m12()));
-    QVERIFY(fuzzyCompare(m5.m21(), m7.m21()));
-    QVERIFY(fuzzyCompare(m5.m22(), m7.m22()));
-    QVERIFY(fuzzyCompare(m5.dx(), m7.dx()));
-    QVERIFY(fuzzyCompare(m5.dy(), m7.dy()));
+    QVERIFY(qFuzzyCompare(float(m5.m11()), float(m7.m11())));
+    QVERIFY(qFuzzyCompare(float(m5.m12()), float(m7.m12())));
+    QVERIFY(qFuzzyCompare(float(m5.m21()), float(m7.m21())));
+    QVERIFY(qFuzzyCompare(float(m5.m22()), float(m7.m22())));
+    QVERIFY(qFuzzyCompare(float(m5.dx()), float(m7.dx())));
+    QVERIFY(qFuzzyCompare(float(m5.dy()), float(m7.dy())));
 }
 
 // Test converting QTransform objects into QMatrix4x4 and then
@@ -3121,19 +3113,19 @@ void tst_QMatrixNxN::convertQTransform()
 
     QMatrix4x4 m6(m5);
     QPointF p6 = m6 * QPointF(100.0, 150.0);
-    QVERIFY(fuzzyCompare(p5.x(), p6.x()));
-    QVERIFY(fuzzyCompare(p5.y(), p6.y()));
+    QVERIFY(qFuzzyCompare(float(p5.x()), float(p6.x())));
+    QVERIFY(qFuzzyCompare(float(p5.y()), float(p6.y())));
 
     QTransform m7 = m6.toTransform();
-    QVERIFY(fuzzyCompare(m5.m11(), m7.m11()));
-    QVERIFY(fuzzyCompare(m5.m12(), m7.m12()));
-    QVERIFY(fuzzyCompare(m5.m21(), m7.m21()));
-    QVERIFY(fuzzyCompare(m5.m22(), m7.m22()));
-    QVERIFY(fuzzyCompare(m5.dx(), m7.dx()));
-    QVERIFY(fuzzyCompare(m5.dy(), m7.dy()));
-    QVERIFY(fuzzyCompare(m5.m13(), m7.m13()));
-    QVERIFY(fuzzyCompare(m5.m23(), m7.m23()));
-    QVERIFY(fuzzyCompare(m5.m33(), m7.m33()));
+    QVERIFY(qFuzzyCompare(float(m5.m11()), float(m7.m11())));
+    QVERIFY(qFuzzyCompare(float(m5.m12()), float(m7.m12())));
+    QVERIFY(qFuzzyCompare(float(m5.m21()), float(m7.m21())));
+    QVERIFY(qFuzzyCompare(float(m5.m22()), float(m7.m22())));
+    QVERIFY(qFuzzyCompare(float(m5.dx()), float(m7.dx())));
+    QVERIFY(qFuzzyCompare(float(m5.dy()), float(m7.dy())));
+    QVERIFY(qFuzzyCompare(float(m5.m13()), float(m7.m13())));
+    QVERIFY(qFuzzyCompare(float(m5.m23()), float(m7.m23())));
+    QVERIFY(qFuzzyCompare(float(m5.m33()), float(m7.m33())));
 }
 
 // Test filling matrices with specific values.
@@ -3143,7 +3135,7 @@ void tst_QMatrixNxN::fill()
     m1.fill(0.0f);
     QVERIFY(isSame(m1, nullValues4));
 
-    static const qreal fillValues4[] =
+    static const float fillValues4[] =
         {2.5f, 2.5f, 2.5f, 2.5f,
          2.5f, 2.5f, 2.5f, 2.5f,
          2.5f, 2.5f, 2.5f, 2.5f,
@@ -3155,7 +3147,7 @@ void tst_QMatrixNxN::fill()
     m2.fill(0.0f);
     QVERIFY(isSame(m2, nullValues4x3));
 
-    static const qreal fillValues4x3[] =
+    static const float fillValues4x3[] =
         {2.5f, 2.5f, 2.5f, 2.5f,
          2.5f, 2.5f, 2.5f, 2.5f,
          2.5f, 2.5f, 2.5f, 2.5f};
@@ -3166,22 +3158,22 @@ void tst_QMatrixNxN::fill()
 // Test the mapRect() function for QRect and QRectF.
 void tst_QMatrixNxN::mapRect_data()
 {
-    QTest::addColumn<qreal>("x");
-    QTest::addColumn<qreal>("y");
-    QTest::addColumn<qreal>("width");
-    QTest::addColumn<qreal>("height");
+    QTest::addColumn<float>("x");
+    QTest::addColumn<float>("y");
+    QTest::addColumn<float>("width");
+    QTest::addColumn<float>("height");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << (float)0.0f << (float)0.0f << (float)0.0f << (float)0.0f;
     QTest::newRow("rect")
-        << (qreal)1.0f << (qreal)-20.5f << (qreal)100.0f << (qreal)63.75f;
+        << (float)1.0f << (float)-20.5f << (float)100.0f << (float)63.75f;
 }
 void tst_QMatrixNxN::mapRect()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, width);
-    QFETCH(qreal, height);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, width);
+    QFETCH(float, height);
 
     QRectF rect(x, y, width, height);
     QRect recti(qRound(x), qRound(y), qRound(width), qRound(height));
@@ -3200,10 +3192,10 @@ void tst_QMatrixNxN::mapRect()
 
     QMatrix4x4 m3;
     m3.scale(-100.5f, 64.0f);
-    qreal scalex = x * -100.5f;
-    qreal scaley = y * 64.0f;
-    qreal scalewid = width * -100.5f;
-    qreal scaleht = height * 64.0f;
+    float scalex = x * -100.5f;
+    float scaley = y * 64.0f;
+    float scalewid = width * -100.5f;
+    float scaleht = height * 64.0f;
     if (scalewid < 0.0f) {
         scalewid = -scalewid;
         scalex -= scalewid;
@@ -3233,10 +3225,10 @@ void tst_QMatrixNxN::mapRect()
     QMatrix4x4 m4;
     m4.translate(-100.5f, 64.0f);
     m4.scale(-2.5f, 4.0f);
-    qreal transx1 = x * -2.5f - 100.5f;
-    qreal transy1 = y * 4.0f + 64.0f;
-    qreal transx2 = (x + width) * -2.5f - 100.5f;
-    qreal transy2 = (y + height) * 4.0f + 64.0f;
+    float transx1 = x * -2.5f - 100.5f;
+    float transy1 = y * 4.0f + 64.0f;
+    float transx2 = (x + width) * -2.5f - 100.5f;
+    float transy2 = (y + height) * 4.0f + 64.0f;
     if (transx1 > transx2)
         qSwap(transx1, transx2);
     if (transy1 > transy2)
@@ -3264,10 +3256,10 @@ void tst_QMatrixNxN::mapRect()
     t4.rotate(45.0f);
     QRectF mr = m4.mapRect(rect);
     QRectF tr = t4.mapRect(rect);
-    QVERIFY(fuzzyCompare(mr.x(), tr.x()));
-    QVERIFY(fuzzyCompare(mr.y(), tr.y()));
-    QVERIFY(fuzzyCompare(mr.width(), tr.width()));
-    QVERIFY(fuzzyCompare(mr.height(), tr.height()));
+    QVERIFY(qFuzzyCompare(float(mr.x()), float(tr.x())));
+    QVERIFY(qFuzzyCompare(float(mr.y()), float(tr.y())));
+    QVERIFY(qFuzzyCompare(float(mr.width()), float(tr.width())));
+    QVERIFY(qFuzzyCompare(float(mr.height()), float(tr.height())));
 
     QRect mri = m4.mapRect(recti);
     QRect tri = t4.mapRect(recti);
@@ -3287,7 +3279,7 @@ void tst_QMatrixNxN::mapVector_data()
     QTest::newRow("unique")
         << (void *)uniqueValues4;
 
-    static const qreal scale[] =
+    static const float scale[] =
         {2.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 11.0f, 0.0f, 0.0f,
          0.0f, 0.0f, -6.5f, 0.0f,
@@ -3295,7 +3287,7 @@ void tst_QMatrixNxN::mapVector_data()
     QTest::newRow("scale")
         << (void *)scale;
 
-    static const qreal scaleTranslate[] =
+    static const float scaleTranslate[] =
         {2.0f, 0.0f, 0.0f, 1.0f,
          0.0f, 11.0f, 0.0f, 2.0f,
          0.0f, 0.0f, -6.5f, 3.0f,
@@ -3303,7 +3295,7 @@ void tst_QMatrixNxN::mapVector_data()
     QTest::newRow("scaleTranslate")
         << (void *)scaleTranslate;
 
-    static const qreal translate[] =
+    static const float translate[] =
         {1.0f, 0.0f, 0.0f, 1.0f,
          0.0f, 1.0f, 0.0f, 2.0f,
          0.0f, 0.0f, 1.0f, 3.0f,
@@ -3315,7 +3307,7 @@ void tst_QMatrixNxN::mapVector()
 {
     QFETCH(void *, mValues);
 
-    QMatrix4x4 m1((const qreal *)mValues);
+    QMatrix4x4 m1((const float *)mValues);
 
     QVector3D v(3.5f, -1.0f, 2.5f);
 
@@ -3328,12 +3320,12 @@ void tst_QMatrixNxN::mapVector()
     m1.optimize();
     QVector3D actual2 = m1.mapVector(v);
 
-    QVERIFY(fuzzyCompare(actual.x(), expected.x()));
-    QVERIFY(fuzzyCompare(actual.y(), expected.y()));
-    QVERIFY(fuzzyCompare(actual.z(), expected.z()));
-    QVERIFY(fuzzyCompare(actual2.x(), expected.x()));
-    QVERIFY(fuzzyCompare(actual2.y(), expected.y()));
-    QVERIFY(fuzzyCompare(actual2.z(), expected.z()));
+    QVERIFY(qFuzzyCompare(actual.x(), expected.x()));
+    QVERIFY(qFuzzyCompare(actual.y(), expected.y()));
+    QVERIFY(qFuzzyCompare(actual.z(), expected.z()));
+    QVERIFY(qFuzzyCompare(actual2.x(), expected.x()));
+    QVERIFY(qFuzzyCompare(actual2.y(), expected.y()));
+    QVERIFY(qFuzzyCompare(actual2.z(), expected.z()));
 }
 
 class tst_QMatrixNxN4x4Properties : public QObject
diff --git a/tests/auto/gui/math3d/qquaternion/tst_qquaternion.cpp b/tests/auto/gui/math3d/qquaternion/tst_qquaternion.cpp
index f42cc30..3557651 100644
--- a/tests/auto/gui/math3d/qquaternion/tst_qquaternion.cpp
+++ b/tests/auto/gui/math3d/qquaternion/tst_qquaternion.cpp
@@ -98,113 +98,106 @@ private slots:
     void metaTypes();
 };
 
-// QVector3D uses float internally, which can lead to some precision
-// issues when using it with the qreal-based QQuaternion.
-static bool fuzzyCompare(qreal x, qreal y)
-{
-    return qFuzzyIsNull(float(x - y));
-}
-
 // Test the creation of QQuaternion objects in various ways:
 // construct, copy, and modify.
 void tst_QQuaternion::create()
 {
     QQuaternion identity;
-    QCOMPARE(identity.x(), (qreal)0.0f);
-    QCOMPARE(identity.y(), (qreal)0.0f);
-    QCOMPARE(identity.z(), (qreal)0.0f);
-    QCOMPARE(identity.scalar(), (qreal)1.0f);
+    QCOMPARE(identity.x(), 0.0f);
+    QCOMPARE(identity.y(), 0.0f);
+    QCOMPARE(identity.z(), 0.0f);
+    QCOMPARE(identity.scalar(), 1.0f);
     QVERIFY(identity.isIdentity());
 
-    QQuaternion negativeZeroIdentity(qreal(1.0), qreal(-0.0), qreal(-0.0), qreal(-0.0));
-    QCOMPARE(negativeZeroIdentity.x(), qreal(-0.0));
-    QCOMPARE(negativeZeroIdentity.y(), qreal(-0.0));
-    QCOMPARE(negativeZeroIdentity.z(), qreal(-0.0));
-    QCOMPARE(negativeZeroIdentity.scalar(), qreal(1.0));
+    QQuaternion negativeZeroIdentity(1.0f, -0.0f, -0.0f, -0.0f);
+    QCOMPARE(negativeZeroIdentity.x(), -0.0f);
+    QCOMPARE(negativeZeroIdentity.y(), -0.0f);
+    QCOMPARE(negativeZeroIdentity.z(), -0.0f);
+    QCOMPARE(negativeZeroIdentity.scalar(), 1.0f);
     QVERIFY(negativeZeroIdentity.isIdentity());
 
     QQuaternion v1(34.0f, 1.0f, 2.5f, -89.25f);
-    QCOMPARE(v1.x(), (qreal)1.0f);
-    QCOMPARE(v1.y(), (qreal)2.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
-    QCOMPARE(v1.scalar(), (qreal)34.0f);
+    QCOMPARE(v1.x(), 1.0f);
+    QCOMPARE(v1.y(), 2.5f);
+    QCOMPARE(v1.z(), -89.25f);
+    QCOMPARE(v1.scalar(), 34.0f);
     QVERIFY(!v1.isNull());
 
     QQuaternion v1i(34, 1, 2, -89);
-    QCOMPARE(v1i.x(), (qreal)1.0f);
-    QCOMPARE(v1i.y(), (qreal)2.0f);
-    QCOMPARE(v1i.z(), (qreal)-89.0f);
-    QCOMPARE(v1i.scalar(), (qreal)34.0f);
+    QCOMPARE(v1i.x(), 1.0f);
+    QCOMPARE(v1i.y(), 2.0f);
+    QCOMPARE(v1i.z(), -89.0f);
+    QCOMPARE(v1i.scalar(), 34.0f);
     QVERIFY(!v1i.isNull());
 
     QQuaternion v2(v1);
-    QCOMPARE(v2.x(), (qreal)1.0f);
-    QCOMPARE(v2.y(), (qreal)2.5f);
-    QCOMPARE(v2.z(), (qreal)-89.25f);
-    QCOMPARE(v2.scalar(), (qreal)34.0f);
+    QCOMPARE(v2.x(), 1.0f);
+    QCOMPARE(v2.y(), 2.5f);
+    QCOMPARE(v2.z(), -89.25f);
+    QCOMPARE(v2.scalar(), 34.0f);
     QVERIFY(!v2.isNull());
 
     QQuaternion v4;
-    QCOMPARE(v4.x(), (qreal)0.0f);
-    QCOMPARE(v4.y(), (qreal)0.0f);
-    QCOMPARE(v4.z(), (qreal)0.0f);
-    QCOMPARE(v4.scalar(), (qreal)1.0f);
+    QCOMPARE(v4.x(), 0.0f);
+    QCOMPARE(v4.y(), 0.0f);
+    QCOMPARE(v4.z(), 0.0f);
+    QCOMPARE(v4.scalar(), 1.0f);
     QVERIFY(v4.isIdentity());
     v4 = v1;
-    QCOMPARE(v4.x(), (qreal)1.0f);
-    QCOMPARE(v4.y(), (qreal)2.5f);
-    QCOMPARE(v4.z(), (qreal)-89.25f);
-    QCOMPARE(v4.scalar(), (qreal)34.0f);
+    QCOMPARE(v4.x(), 1.0f);
+    QCOMPARE(v4.y(), 2.5f);
+    QCOMPARE(v4.z(), -89.25f);
+    QCOMPARE(v4.scalar(), 34.0f);
     QVERIFY(!v4.isNull());
 
     QQuaternion v9(34, QVector3D(1.0f, 2.5f, -89.25f));
-    QCOMPARE(v9.x(), (qreal)1.0f);
-    QCOMPARE(v9.y(), (qreal)2.5f);
-    QCOMPARE(v9.z(), (qreal)-89.25f);
-    QCOMPARE(v9.scalar(), (qreal)34.0f);
+    QCOMPARE(v9.x(), 1.0f);
+    QCOMPARE(v9.y(), 2.5f);
+    QCOMPARE(v9.z(), -89.25f);
+    QCOMPARE(v9.scalar(), 34.0f);
     QVERIFY(!v9.isNull());
 
     v1.setX(3.0f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)2.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
-    QCOMPARE(v1.scalar(), (qreal)34.0f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 2.5f);
+    QCOMPARE(v1.z(), -89.25f);
+    QCOMPARE(v1.scalar(), 34.0f);
     QVERIFY(!v1.isNull());
 
     v1.setY(10.5f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
-    QCOMPARE(v1.scalar(), (qreal)34.0f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
+    QCOMPARE(v1.z(), -89.25f);
+    QCOMPARE(v1.scalar(), 34.0f);
     QVERIFY(!v1.isNull());
 
     v1.setZ(15.5f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
-    QCOMPARE(v1.z(), (qreal)15.5f);
-    QCOMPARE(v1.scalar(), (qreal)34.0f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
+    QCOMPARE(v1.z(), 15.5f);
+    QCOMPARE(v1.scalar(), 34.0f);
     QVERIFY(!v1.isNull());
 
     v1.setScalar(6.0f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
-    QCOMPARE(v1.z(), (qreal)15.5f);
-    QCOMPARE(v1.scalar(), (qreal)6.0f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
+    QCOMPARE(v1.z(), 15.5f);
+    QCOMPARE(v1.scalar(), 6.0f);
     QVERIFY(!v1.isNull());
 
     v1.setVector(2.0f, 6.5f, -1.25f);
-    QCOMPARE(v1.x(), (qreal)2.0f);
-    QCOMPARE(v1.y(), (qreal)6.5f);
-    QCOMPARE(v1.z(), (qreal)-1.25f);
-    QCOMPARE(v1.scalar(), (qreal)6.0f);
+    QCOMPARE(v1.x(), 2.0f);
+    QCOMPARE(v1.y(), 6.5f);
+    QCOMPARE(v1.z(), -1.25f);
+    QCOMPARE(v1.scalar(), 6.0f);
     QVERIFY(!v1.isNull());
     QVERIFY(v1.vector() == QVector3D(2.0f, 6.5f, -1.25f));
 
     v1.setVector(QVector3D(-2.0f, -6.5f, 1.25f));
-    QCOMPARE(v1.x(), (qreal)-2.0f);
-    QCOMPARE(v1.y(), (qreal)-6.5f);
-    QCOMPARE(v1.z(), (qreal)1.25f);
-    QCOMPARE(v1.scalar(), (qreal)6.0f);
+    QCOMPARE(v1.x(), -2.0f);
+    QCOMPARE(v1.y(), -6.5f);
+    QCOMPARE(v1.z(), 1.25f);
+    QCOMPARE(v1.scalar(), 6.0f);
     QVERIFY(!v1.isNull());
     QVERIFY(v1.vector() == QVector3D(-2.0f, -6.5f, 1.25f));
 
@@ -212,46 +205,46 @@ void tst_QQuaternion::create()
     v1.setY(0.0f);
     v1.setZ(0.0f);
     v1.setScalar(0.0f);
-    QCOMPARE(v1.x(), (qreal)0.0f);
-    QCOMPARE(v1.y(), (qreal)0.0f);
-    QCOMPARE(v1.z(), (qreal)0.0f);
-    QCOMPARE(v1.scalar(), (qreal)0.0f);
+    QCOMPARE(v1.x(), 0.0f);
+    QCOMPARE(v1.y(), 0.0f);
+    QCOMPARE(v1.z(), 0.0f);
+    QCOMPARE(v1.scalar(), 0.0f);
     QVERIFY(v1.isNull());
 
     QVector4D v10 = v9.toVector4D();
-    QCOMPARE(v10.x(), (qreal)1.0f);
-    QCOMPARE(v10.y(), (qreal)2.5f);
-    QCOMPARE(v10.z(), (qreal)-89.25f);
-    QCOMPARE(v10.w(), (qreal)34.0f);
+    QCOMPARE(v10.x(), 1.0f);
+    QCOMPARE(v10.y(), 2.5f);
+    QCOMPARE(v10.z(), -89.25f);
+    QCOMPARE(v10.w(), 34.0f);
 }
 
 // Test length computation for quaternions.
 void tst_QQuaternion::length_data()
 {
-    QTest::addColumn<qreal>("x");
-    QTest::addColumn<qreal>("y");
-    QTest::addColumn<qreal>("z");
-    QTest::addColumn<qreal>("w");
-    QTest::addColumn<qreal>("len");
-
-    QTest::newRow("null") << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
-    QTest::newRow("1x") << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1y") << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1z") << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1w") << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)1.0f;
-    QTest::newRow("-1x") << (qreal)-1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1y") << (qreal)0.0f << (qreal)-1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1z") << (qreal)0.0f << (qreal)0.0f << (qreal)-1.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1w") << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)-1.0f << (qreal)1.0f;
-    QTest::newRow("two") << (qreal)2.0f << (qreal)-2.0f << (qreal)2.0f << (qreal)2.0f << (qreal)qSqrt(16.0f);
+    QTest::addColumn<float>("x");
+    QTest::addColumn<float>("y");
+    QTest::addColumn<float>("z");
+    QTest::addColumn<float>("w");
+    QTest::addColumn<float>("len");
+
+    QTest::newRow("null") << 0.0f << 0.0f << 0.0f << 0.0f << 0.0f;
+    QTest::newRow("1x") << 1.0f << 0.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("1y") << 0.0f << 1.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("1z") << 0.0f << 0.0f << 1.0f << 0.0f << 1.0f;
+    QTest::newRow("1w") << 0.0f << 0.0f << 0.0f << 1.0f << 1.0f;
+    QTest::newRow("-1x") << -1.0f << 0.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("-1y") << 0.0f << -1.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("-1z") << 0.0f << 0.0f << -1.0f << 0.0f << 1.0f;
+    QTest::newRow("-1w") << 0.0f << 0.0f << 0.0f << -1.0f << 1.0f;
+    QTest::newRow("two") << 2.0f << -2.0f << 2.0f << 2.0f << sqrtf(16.0f);
 }
 void tst_QQuaternion::length()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
-    QFETCH(qreal, w);
-    QFETCH(qreal, len);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
+    QFETCH(float, w);
+    QFETCH(float, len);
 
     QQuaternion v(w, x, y, z);
     QCOMPARE(v.length(), len);
@@ -266,18 +259,18 @@ void tst_QQuaternion::normalized_data()
 }
 void tst_QQuaternion::normalized()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
-    QFETCH(qreal, w);
-    QFETCH(qreal, len);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
+    QFETCH(float, w);
+    QFETCH(float, len);
 
     QQuaternion v(w, x, y, z);
     QQuaternion u = v.normalized();
     if (v.isNull())
         QVERIFY(u.isNull());
     else
-        QCOMPARE(u.length(), qreal(1.0f));
+        QCOMPARE(u.length(), 1.0f);
     QCOMPARE(u.x() * len, v.x());
     QCOMPARE(u.y() * len, v.y());
     QCOMPARE(u.z() * len, v.z());
@@ -292,10 +285,10 @@ void tst_QQuaternion::normalize_data()
 }
 void tst_QQuaternion::normalize()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
-    QFETCH(qreal, w);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
+    QFETCH(float, w);
 
     QQuaternion v(w, x, y, z);
     bool isNull = v.isNull();
@@ -303,7 +296,7 @@ void tst_QQuaternion::normalize()
     if (isNull)
         QVERIFY(v.isNull());
     else
-        QCOMPARE(v.length(), qreal(1.0f));
+        QCOMPARE(v.length(), 1.0f);
 }
 
 // Test the comparison operators for quaternions.
@@ -326,63 +319,63 @@ void tst_QQuaternion::compare()
 // Test addition for quaternions.
 void tst_QQuaternion::add_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("w1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("w2");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
-    QTest::addColumn<qreal>("w3");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("w1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("w2");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
+    QTest::addColumn<float>("w3");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)3.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f << 0.0f
+        << 2.0f << 0.0f << 0.0f << 0.0f
+        << 3.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)3.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 1.0f << 0.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f << 0.0f
+        << 0.0f << 3.0f << 0.0f << 0.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)3.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 1.0f << 0.0f
+        << 0.0f << 0.0f << 2.0f << 0.0f
+        << 0.0f << 0.0f << 3.0f << 0.0f;
 
     QTest::newRow("wonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)3.0f;
+        << 0.0f << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 0.0f << 2.0f
+        << 0.0f << 0.0f << 0.0f << 3.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f << (qreal)8.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)-6.0f << (qreal)9.0f
-        << (qreal)5.0f << (qreal)7.0f << (qreal)-3.0f << (qreal)17.0f;
+        << 1.0f << 2.0f << 3.0f << 8.0f
+        << 4.0f << 5.0f << -6.0f << 9.0f
+        << 5.0f << 7.0f << -3.0f << 17.0f;
 }
 void tst_QQuaternion::add()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, w3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, w3);
 
     QQuaternion v1(w1, x1, y1, z1);
     QQuaternion v2(w2, x2, y2, z2);
@@ -408,18 +401,18 @@ void tst_QQuaternion::subtract_data()
 }
 void tst_QQuaternion::subtract()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, w3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, w3);
 
     QQuaternion v1(w1, x1, y1, z1);
     QQuaternion v2(w2, x2, y2, z2);
@@ -450,31 +443,31 @@ void tst_QQuaternion::subtract()
 // Test quaternion multiplication.
 void tst_QQuaternion::multiply_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("w1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("w2");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("w1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("w2");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("unitvec")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)1.0f;
+        << 1.0f << 0.0f << 0.0f << 1.0f
+        << 0.0f << 1.0f << 0.0f << 1.0f;
 
     QTest::newRow("complex")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f << (qreal)7.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)6.0f << (qreal)8.0f;
+        << 1.0f << 2.0f << 3.0f << 7.0f
+        << 4.0f << 5.0f << 6.0f << 8.0f;
 
-    for (qreal w = -1.0f; w <= 1.0f; w += 0.5f)
-        for (qreal x = -1.0f; x <= 1.0f; x += 0.5f)
-            for (qreal y = -1.0f; y <= 1.0f; y += 0.5f)
-                for (qreal z = -1.0f; z <= 1.0f; z += 0.5f) {
+    for (float w = -1.0f; w <= 1.0f; w += 0.5f)
+        for (float x = -1.0f; x <= 1.0f; x += 0.5f)
+            for (float y = -1.0f; y <= 1.0f; y += 0.5f)
+                for (float z = -1.0f; z <= 1.0f; z += 0.5f) {
                     QTest::newRow("exhaustive")
                         << x << y << z << w
                         << z << w << y << x;
@@ -482,14 +475,14 @@ void tst_QQuaternion::multiply_data()
 }
 void tst_QQuaternion::multiply()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
 
     QQuaternion q1(w1, x1, y1, z1);
     QQuaternion q2(w2, x2, y2, z2);
@@ -499,7 +492,7 @@ void tst_QQuaternion::multiply()
     // to calculate the answer we expect to get.
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
-    qreal scalar = w1 * w2 - QVector3D::dotProduct(v1, v2);
+    float scalar = w1 * w2 - QVector3D::dotProduct(v1, v2);
     QVector3D vector = w1 * v2 + w2 * v1 + QVector3D::crossProduct(v1, v2);
     QQuaternion result(scalar, vector);
 
@@ -509,62 +502,62 @@ void tst_QQuaternion::multiply()
 // Test multiplication by a factor for quaternions.
 void tst_QQuaternion::multiplyFactor_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("w1");
-    QTest::addColumn<qreal>("factor");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("w2");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("w1");
+    QTest::addColumn<float>("factor");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("w2");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)100.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 100.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f << 0.0f
+        << 2.0f
+        << 2.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 1.0f << 0.0f << 0.0f
+        << 2.0f
+        << 0.0f << 2.0f << 0.0f << 0.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 1.0f << 0.0f
+        << 2.0f
+        << 0.0f << 0.0f << 2.0f << 0.0f;
 
     QTest::newRow("wonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f;
+        << 0.0f << 0.0f << 0.0f << 1.0f
+        << 2.0f
+        << 0.0f << 0.0f << 0.0f << 2.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)4.0f
-        << (qreal)2.0f
-        << (qreal)2.0f << (qreal)4.0f << (qreal)-6.0f << (qreal)8.0f;
+        << 1.0f << 2.0f << -3.0f << 4.0f
+        << 2.0f
+        << 2.0f << 4.0f << -6.0f << 8.0f;
 
     QTest::newRow("allzero")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)4.0f
-        << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 2.0f << -3.0f << 4.0f
+        << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 }
 void tst_QQuaternion::multiplyFactor()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, factor);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, factor);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
 
     QQuaternion v1(w1, x1, y1, z1);
     QQuaternion v2(w2, x2, y2, z2);
@@ -590,20 +583,20 @@ void tst_QQuaternion::divide_data()
 }
 void tst_QQuaternion::divide()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, factor);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, factor);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
 
     QQuaternion v1(w1, x1, y1, z1);
     QQuaternion v2(w2, x2, y2, z2);
 
-    if (factor == (qreal)0.0f)
+    if (factor == 0.0f)
         return;
 
     QVERIFY((v2 / factor) == v1);
@@ -626,10 +619,10 @@ void tst_QQuaternion::negate_data()
 }
 void tst_QQuaternion::negate()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
 
     QQuaternion v1(w1, x1, y1, z1);
     QQuaternion v2(-w1, -x1, -y1, -z1);
@@ -645,10 +638,10 @@ void tst_QQuaternion::conjugate_data()
 }
 void tst_QQuaternion::conjugate()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
 
     QQuaternion v1(w1, x1, y1, z1);
     QQuaternion v2(w1, -x1, -y1, -z1);
@@ -659,121 +652,121 @@ void tst_QQuaternion::conjugate()
 // Test quaternion creation from an axis and an angle.
 void tst_QQuaternion::fromAxisAndAngle_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("angle");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("angle");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)90.0f;
+        << 1.0f << 0.0f << 0.0f << 90.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)180.0f;
+        << 0.0f << 1.0f << 0.0f << 180.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)270.0f;
+        << 0.0f << 0.0f << 1.0f << 270.0f;
 
     QTest::newRow("complex")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)45.0f;
+        << 1.0f << 2.0f << -3.0f << 45.0f;
 }
 void tst_QQuaternion::fromAxisAndAngle()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, angle);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, angle);
 
     // Use a straight-forward implementation of the algorithm at:
     // http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q56
     // to calculate the answer we expect to get.
     QVector3D vector = QVector3D(x1, y1, z1).normalized();
-    qreal sin_a = qSin((angle * M_PI / 180.0) / 2.0);
-    qreal cos_a = qCos((angle * M_PI / 180.0) / 2.0);
-    QQuaternion result((qreal)cos_a,
-                       (qreal)(vector.x() * sin_a),
-                       (qreal)(vector.y() * sin_a),
-                       (qreal)(vector.z() * sin_a));
+    float sin_a = sinf((angle * M_PI / 180.0) / 2.0);
+    float cos_a = cosf((angle * M_PI / 180.0) / 2.0);
+    QQuaternion result(cos_a,
+                       (vector.x() * sin_a),
+                       (vector.y() * sin_a),
+                       (vector.z() * sin_a));
     result = result.normalized();
 
     QQuaternion answer = QQuaternion::fromAxisAndAngle(QVector3D(x1, y1, z1), angle);
-    QVERIFY(fuzzyCompare(answer.x(), result.x()));
-    QVERIFY(fuzzyCompare(answer.y(), result.y()));
-    QVERIFY(fuzzyCompare(answer.z(), result.z()));
-    QVERIFY(fuzzyCompare(answer.scalar(), result.scalar()));
+    QVERIFY(qFuzzyCompare(answer.x(), result.x()));
+    QVERIFY(qFuzzyCompare(answer.y(), result.y()));
+    QVERIFY(qFuzzyCompare(answer.z(), result.z()));
+    QVERIFY(qFuzzyCompare(answer.scalar(), result.scalar()));
 
     answer = QQuaternion::fromAxisAndAngle(x1, y1, z1, angle);
-    QVERIFY(fuzzyCompare(answer.x(), result.x()));
-    QVERIFY(fuzzyCompare(answer.y(), result.y()));
-    QVERIFY(fuzzyCompare(answer.z(), result.z()));
-    QVERIFY(fuzzyCompare(answer.scalar(), result.scalar()));
+    QVERIFY(qFuzzyCompare(answer.x(), result.x()));
+    QVERIFY(qFuzzyCompare(answer.y(), result.y()));
+    QVERIFY(qFuzzyCompare(answer.z(), result.z()));
+    QVERIFY(qFuzzyCompare(answer.scalar(), result.scalar()));
 }
 
 // Test spherical interpolation of quaternions.
 void tst_QQuaternion::slerp_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("angle1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("angle2");
-    QTest::addColumn<qreal>("t");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
-    QTest::addColumn<qreal>("angle3");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("angle1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("angle2");
+    QTest::addColumn<float>("t");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
+    QTest::addColumn<float>("angle3");
 
     QTest::newRow("first")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)90.0f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)180.0f
-        << (qreal)0.0f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)90.0f;
+        << 1.0f << 2.0f << -3.0f << 90.0f
+        << 1.0f << 2.0f << -3.0f << 180.0f
+        << 0.0f
+        << 1.0f << 2.0f << -3.0f << 90.0f;
     QTest::newRow("first2")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)90.0f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)180.0f
-        << (qreal)-0.5f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)90.0f;
+        << 1.0f << 2.0f << -3.0f << 90.0f
+        << 1.0f << 2.0f << -3.0f << 180.0f
+        << -0.5f
+        << 1.0f << 2.0f << -3.0f << 90.0f;
     QTest::newRow("second")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)90.0f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)180.0f
-        << (qreal)1.0f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)180.0f;
+        << 1.0f << 2.0f << -3.0f << 90.0f
+        << 1.0f << 2.0f << -3.0f << 180.0f
+        << 1.0f
+        << 1.0f << 2.0f << -3.0f << 180.0f;
     QTest::newRow("second2")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)90.0f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)180.0f
-        << (qreal)1.5f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)180.0f;
+        << 1.0f << 2.0f << -3.0f << 90.0f
+        << 1.0f << 2.0f << -3.0f << 180.0f
+        << 1.5f
+        << 1.0f << 2.0f << -3.0f << 180.0f;
     QTest::newRow("middle")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)90.0f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)180.0f
-        << (qreal)0.5f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)135.0f;
+        << 1.0f << 2.0f << -3.0f << 90.0f
+        << 1.0f << 2.0f << -3.0f << 180.0f
+        << 0.5f
+        << 1.0f << 2.0f << -3.0f << 135.0f;
     QTest::newRow("wide angle")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)0.0f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)270.0f
-        << (qreal)0.5f
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)-45.0f;
+        << 1.0f << 2.0f << -3.0f << 0.0f
+        << 1.0f << 2.0f << -3.0f << 270.0f
+        << 0.5f
+        << 1.0f << 2.0f << -3.0f << -45.0f;
 }
 void tst_QQuaternion::slerp()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, angle1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, angle2);
-    QFETCH(qreal, t);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, angle3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, angle1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, angle2);
+    QFETCH(float, t);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, angle3);
 
     QQuaternion q1 = QQuaternion::fromAxisAndAngle(x1, y1, z1, angle1);
     QQuaternion q2 = QQuaternion::fromAxisAndAngle(x2, y2, z2, angle2);
@@ -781,10 +774,10 @@ void tst_QQuaternion::slerp()
 
     QQuaternion result = QQuaternion::slerp(q1, q2, t);
 
-    QVERIFY(fuzzyCompare(result.x(), q3.x()));
-    QVERIFY(fuzzyCompare(result.y(), q3.y()));
-    QVERIFY(fuzzyCompare(result.z(), q3.z()));
-    QVERIFY(fuzzyCompare(result.scalar(), q3.scalar()));
+    QVERIFY(qFuzzyCompare(result.x(), q3.x()));
+    QVERIFY(qFuzzyCompare(result.y(), q3.y()));
+    QVERIFY(qFuzzyCompare(result.z(), q3.z()));
+    QVERIFY(qFuzzyCompare(result.scalar(), q3.scalar()));
 }
 
 // Test normalized linear interpolation of quaternions.
@@ -794,22 +787,22 @@ void tst_QQuaternion::nlerp_data()
 }
 void tst_QQuaternion::nlerp()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, angle1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, angle2);
-    QFETCH(qreal, t);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, angle1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, angle2);
+    QFETCH(float, t);
 
     QQuaternion q1 = QQuaternion::fromAxisAndAngle(x1, y1, z1, angle1);
     QQuaternion q2 = QQuaternion::fromAxisAndAngle(x2, y2, z2, angle2);
 
     QQuaternion result = QQuaternion::nlerp(q1, q2, t);
 
-    qreal resultx, resulty, resultz, resultscalar;
+    float resultx, resulty, resultz, resultscalar;
     if (t <= 0.0f) {
         resultx = q1.x();
         resulty = q1.y();
@@ -835,10 +828,10 @@ void tst_QQuaternion::nlerp()
 
     QQuaternion q3 = QQuaternion(resultscalar, resultx, resulty, resultz).normalized();
 
-    QVERIFY(fuzzyCompare(result.x(), q3.x()));
-    QVERIFY(fuzzyCompare(result.y(), q3.y()));
-    QVERIFY(fuzzyCompare(result.z(), q3.z()));
-    QVERIFY(fuzzyCompare(result.scalar(), q3.scalar()));
+    QVERIFY(qFuzzyCompare(result.x(), q3.x()));
+    QVERIFY(qFuzzyCompare(result.y(), q3.y()));
+    QVERIFY(qFuzzyCompare(result.z(), q3.z()));
+    QVERIFY(qFuzzyCompare(result.scalar(), q3.scalar()));
 }
 
 class tst_QQuaternionProperties : public QObject
@@ -863,19 +856,19 @@ void tst_QQuaternion::properties()
     obj.setQuaternion(QQuaternion(6.0f, 7.0f, 8.0f, 9.0f));
 
     QQuaternion q = qvariant_cast<QQuaternion>(obj.property("quaternion"));
-    QCOMPARE(q.scalar(), (qreal)6.0f);
-    QCOMPARE(q.x(), (qreal)7.0f);
-    QCOMPARE(q.y(), (qreal)8.0f);
-    QCOMPARE(q.z(), (qreal)9.0f);
+    QCOMPARE(q.scalar(), 6.0f);
+    QCOMPARE(q.x(), 7.0f);
+    QCOMPARE(q.y(), 8.0f);
+    QCOMPARE(q.z(), 9.0f);
 
     obj.setProperty("quaternion",
                     QVariant::fromValue(QQuaternion(-6.0f, -7.0f, -8.0f, -9.0f)));
 
     q = qvariant_cast<QQuaternion>(obj.property("quaternion"));
-    QCOMPARE(q.scalar(), (qreal)-6.0f);
-    QCOMPARE(q.x(), (qreal)-7.0f);
-    QCOMPARE(q.y(), (qreal)-8.0f);
-    QCOMPARE(q.z(), (qreal)-9.0f);
+    QCOMPARE(q.scalar(), -6.0f);
+    QCOMPARE(q.x(), -7.0f);
+    QCOMPARE(q.y(), -8.0f);
+    QCOMPARE(q.z(), -9.0f);
 }
 
 void tst_QQuaternion::metaTypes()
diff --git a/tests/auto/gui/math3d/qvectornd/tst_qvectornd.cpp b/tests/auto/gui/math3d/qvectornd/tst_qvectornd.cpp
index 4b6d983..2ab896f 100644
--- a/tests/auto/gui/math3d/qvectornd/tst_qvectornd.cpp
+++ b/tests/auto/gui/math3d/qvectornd/tst_qvectornd.cpp
@@ -144,87 +144,78 @@ private slots:
     void metaTypes();
 };
 
-// QVector2/3/4D use float internally, which can sometimes lead
-// to precision issues when converting to and from qreal.
-// This fuzzy compare is slightly "fuzzier" than the default
-// qFuzzyCompare for qreal to compensate.
-static bool fuzzyCompare(qreal x, qreal y)
-{
-    return qFuzzyIsNull((float)(x - y));
-}
-
 // Test the creation of QVector2D objects in various ways:
 // construct, copy, and modify.
 void tst_QVectorND::create2()
 {
     QVector2D null;
-    QCOMPARE(null.x(), (qreal)0.0f);
-    QCOMPARE(null.y(), (qreal)0.0f);
+    QCOMPARE(null.x(), 0.0f);
+    QCOMPARE(null.y(), 0.0f);
     QVERIFY(null.isNull());
 
-    QVector2D nullNegativeZero(qreal(-0.0), qreal(-0.0));
-    QCOMPARE(nullNegativeZero.x(), (qreal)-0.0f);
-    QCOMPARE(nullNegativeZero.y(), (qreal)-0.0f);
+    QVector2D nullNegativeZero(-0.0f, -0.0f);
+    QCOMPARE(nullNegativeZero.x(), -0.0f);
+    QCOMPARE(nullNegativeZero.y(), -0.0f);
     QVERIFY(nullNegativeZero.isNull());
 
     QVector2D v1(1.0f, 2.5f);
-    QCOMPARE(v1.x(), (qreal)1.0f);
-    QCOMPARE(v1.y(), (qreal)2.5f);
+    QCOMPARE(v1.x(), 1.0f);
+    QCOMPARE(v1.y(), 2.5f);
     QVERIFY(!v1.isNull());
 
     QVector2D v1i(1, 2);
-    QCOMPARE(v1i.x(), (qreal)1.0f);
-    QCOMPARE(v1i.y(), (qreal)2.0f);
+    QCOMPARE(v1i.x(), 1.0f);
+    QCOMPARE(v1i.y(), 2.0f);
     QVERIFY(!v1i.isNull());
 
     QVector2D v2(v1);
-    QCOMPARE(v2.x(), (qreal)1.0f);
-    QCOMPARE(v2.y(), (qreal)2.5f);
+    QCOMPARE(v2.x(), 1.0f);
+    QCOMPARE(v2.y(), 2.5f);
     QVERIFY(!v2.isNull());
 
     QVector2D v4;
-    QCOMPARE(v4.x(), (qreal)0.0f);
-    QCOMPARE(v4.y(), (qreal)0.0f);
+    QCOMPARE(v4.x(), 0.0f);
+    QCOMPARE(v4.y(), 0.0f);
     QVERIFY(v4.isNull());
     v4 = v1;
-    QCOMPARE(v4.x(), (qreal)1.0f);
-    QCOMPARE(v4.y(), (qreal)2.5f);
+    QCOMPARE(v4.x(), 1.0f);
+    QCOMPARE(v4.y(), 2.5f);
     QVERIFY(!v4.isNull());
 
     QVector2D v5(QPoint(1, 2));
-    QCOMPARE(v5.x(), (qreal)1.0f);
-    QCOMPARE(v5.y(), (qreal)2.0f);
+    QCOMPARE(v5.x(), 1.0f);
+    QCOMPARE(v5.y(), 2.0f);
     QVERIFY(!v5.isNull());
 
     QVector2D v6(QPointF(1, 2.5));
-    QCOMPARE(v6.x(), (qreal)1.0f);
-    QCOMPARE(v6.y(), (qreal)2.5f);
+    QCOMPARE(v6.x(), 1.0f);
+    QCOMPARE(v6.y(), 2.5f);
     QVERIFY(!v6.isNull());
 
     QVector2D v7(QVector3D(1.0f, 2.5f, 54.25f));
-    QCOMPARE(v7.x(), (qreal)1.0f);
-    QCOMPARE(v7.y(), (qreal)2.5f);
+    QCOMPARE(v7.x(), 1.0f);
+    QCOMPARE(v7.y(), 2.5f);
     QVERIFY(!v6.isNull());
 
     QVector2D v8(QVector4D(1.0f, 2.5f, 54.25f, 34.0f));
-    QCOMPARE(v8.x(), (qreal)1.0f);
-    QCOMPARE(v8.y(), (qreal)2.5f);
+    QCOMPARE(v8.x(), 1.0f);
+    QCOMPARE(v8.y(), 2.5f);
     QVERIFY(!v6.isNull());
 
     v1.setX(3.0f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)2.5f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 2.5f);
     QVERIFY(!v1.isNull());
 
     v1.setY(10.5f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
     QVERIFY(!v1.isNull());
 
     v1.setX(0.0f);
     v1.setY(0.0f);
-    QCOMPARE(v1.x(), (qreal)0.0f);
-    QCOMPARE(v1.y(), (qreal)0.0f);
+    QCOMPARE(v1.x(), 0.0f);
+    QCOMPARE(v1.y(), 0.0f);
     QVERIFY(v1.isNull());
 
     QPoint p1 = v8.toPoint();
@@ -232,19 +223,19 @@ void tst_QVectorND::create2()
     QCOMPARE(p1.y(), 3);
 
     QPointF p2 = v8.toPointF();
-    QCOMPARE((qreal)p2.x(), (qreal)1.0f);
-    QCOMPARE((qreal)p2.y(), (qreal)2.5f);
+    QCOMPARE(p2.x(), 1.0f);
+    QCOMPARE(p2.y(), 2.5f);
 
     QVector3D v9 = v8.toVector3D();
-    QCOMPARE(v9.x(), (qreal)1.0f);
-    QCOMPARE(v9.y(), (qreal)2.5f);
-    QCOMPARE(v9.z(), (qreal)0.0f);
+    QCOMPARE(v9.x(), 1.0f);
+    QCOMPARE(v9.y(), 2.5f);
+    QCOMPARE(v9.z(), 0.0f);
 
     QVector4D v10 = v8.toVector4D();
-    QCOMPARE(v10.x(), (qreal)1.0f);
-    QCOMPARE(v10.y(), (qreal)2.5f);
-    QCOMPARE(v10.z(), (qreal)0.0f);
-    QCOMPARE(v10.w(), (qreal)0.0f);
+    QCOMPARE(v10.x(), 1.0f);
+    QCOMPARE(v10.y(), 2.5f);
+    QCOMPARE(v10.z(), 0.0f);
+    QCOMPARE(v10.w(), 0.0f);
 }
 
 // Test the creation of QVector3D objects in various ways:
@@ -252,112 +243,112 @@ void tst_QVectorND::create2()
 void tst_QVectorND::create3()
 {
     QVector3D null;
-    QCOMPARE(null.x(), (qreal)0.0f);
-    QCOMPARE(null.y(), (qreal)0.0f);
-    QCOMPARE(null.z(), (qreal)0.0f);
+    QCOMPARE(null.x(), 0.0f);
+    QCOMPARE(null.y(), 0.0f);
+    QCOMPARE(null.z(), 0.0f);
     QVERIFY(null.isNull());
 
-    QVector3D nullNegativeZero(qreal(-0.0), qreal(-0.0), qreal(-0.0));
-    QCOMPARE(nullNegativeZero.x(), (qreal)-0.0f);
-    QCOMPARE(nullNegativeZero.y(), (qreal)-0.0f);
-    QCOMPARE(nullNegativeZero.z(), (qreal)-0.0f);
+    QVector3D nullNegativeZero(-0.0f, -0.0f, -0.0f);
+    QCOMPARE(nullNegativeZero.x(), -0.0f);
+    QCOMPARE(nullNegativeZero.y(), -0.0f);
+    QCOMPARE(nullNegativeZero.z(), -0.0f);
     QVERIFY(nullNegativeZero.isNull());
 
     QVector3D v1(1.0f, 2.5f, -89.25f);
-    QCOMPARE(v1.x(), (qreal)1.0f);
-    QCOMPARE(v1.y(), (qreal)2.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
+    QCOMPARE(v1.x(), 1.0f);
+    QCOMPARE(v1.y(), 2.5f);
+    QCOMPARE(v1.z(), -89.25f);
     QVERIFY(!v1.isNull());
 
     QVector3D v1i(1, 2, -89);
-    QCOMPARE(v1i.x(), (qreal)1.0f);
-    QCOMPARE(v1i.y(), (qreal)2.0f);
-    QCOMPARE(v1i.z(), (qreal)-89.0f);
+    QCOMPARE(v1i.x(), 1.0f);
+    QCOMPARE(v1i.y(), 2.0f);
+    QCOMPARE(v1i.z(), -89.0f);
     QVERIFY(!v1i.isNull());
 
     QVector3D v2(v1);
-    QCOMPARE(v2.x(), (qreal)1.0f);
-    QCOMPARE(v2.y(), (qreal)2.5f);
-    QCOMPARE(v2.z(), (qreal)-89.25f);
+    QCOMPARE(v2.x(), 1.0f);
+    QCOMPARE(v2.y(), 2.5f);
+    QCOMPARE(v2.z(), -89.25f);
     QVERIFY(!v2.isNull());
 
     QVector3D v3(1.0f, 2.5f, 0.0f);
-    QCOMPARE(v3.x(), (qreal)1.0f);
-    QCOMPARE(v3.y(), (qreal)2.5f);
-    QCOMPARE(v3.z(), (qreal)0.0f);
+    QCOMPARE(v3.x(), 1.0f);
+    QCOMPARE(v3.y(), 2.5f);
+    QCOMPARE(v3.z(), 0.0f);
     QVERIFY(!v3.isNull());
 
     QVector3D v3i(1, 2, 0);
-    QCOMPARE(v3i.x(), (qreal)1.0f);
-    QCOMPARE(v3i.y(), (qreal)2.0f);
-    QCOMPARE(v3i.z(), (qreal)0.0f);
+    QCOMPARE(v3i.x(), 1.0f);
+    QCOMPARE(v3i.y(), 2.0f);
+    QCOMPARE(v3i.z(), 0.0f);
     QVERIFY(!v3i.isNull());
 
     QVector3D v4;
-    QCOMPARE(v4.x(), (qreal)0.0f);
-    QCOMPARE(v4.y(), (qreal)0.0f);
-    QCOMPARE(v4.z(), (qreal)0.0f);
+    QCOMPARE(v4.x(), 0.0f);
+    QCOMPARE(v4.y(), 0.0f);
+    QCOMPARE(v4.z(), 0.0f);
     QVERIFY(v4.isNull());
     v4 = v1;
-    QCOMPARE(v4.x(), (qreal)1.0f);
-    QCOMPARE(v4.y(), (qreal)2.5f);
-    QCOMPARE(v4.z(), (qreal)-89.25f);
+    QCOMPARE(v4.x(), 1.0f);
+    QCOMPARE(v4.y(), 2.5f);
+    QCOMPARE(v4.z(), -89.25f);
     QVERIFY(!v4.isNull());
 
     QVector3D v5(QPoint(1, 2));
-    QCOMPARE(v5.x(), (qreal)1.0f);
-    QCOMPARE(v5.y(), (qreal)2.0f);
-    QCOMPARE(v5.z(), (qreal)0.0f);
+    QCOMPARE(v5.x(), 1.0f);
+    QCOMPARE(v5.y(), 2.0f);
+    QCOMPARE(v5.z(), 0.0f);
     QVERIFY(!v5.isNull());
 
     QVector3D v6(QPointF(1, 2.5));
-    QCOMPARE(v6.x(), (qreal)1.0f);
-    QCOMPARE(v6.y(), (qreal)2.5f);
-    QCOMPARE(v6.z(), (qreal)0.0f);
+    QCOMPARE(v6.x(), 1.0f);
+    QCOMPARE(v6.y(), 2.5f);
+    QCOMPARE(v6.z(), 0.0f);
     QVERIFY(!v6.isNull());
 
     QVector3D v7(QVector2D(1.0f, 2.5f));
-    QCOMPARE(v7.x(), (qreal)1.0f);
-    QCOMPARE(v7.y(), (qreal)2.5f);
-    QCOMPARE(v7.z(), (qreal)0.0f);
+    QCOMPARE(v7.x(), 1.0f);
+    QCOMPARE(v7.y(), 2.5f);
+    QCOMPARE(v7.z(), 0.0f);
     QVERIFY(!v7.isNull());
 
     QVector3D v8(QVector2D(1.0f, 2.5f), 54.25f);
-    QCOMPARE(v8.x(), (qreal)1.0f);
-    QCOMPARE(v8.y(), (qreal)2.5f);
-    QCOMPARE(v8.z(), (qreal)54.25f);
+    QCOMPARE(v8.x(), 1.0f);
+    QCOMPARE(v8.y(), 2.5f);
+    QCOMPARE(v8.z(), 54.25f);
     QVERIFY(!v8.isNull());
 
     QVector3D v9(QVector4D(1.0f, 2.5f, 54.25f, 34.0f));
-    QCOMPARE(v9.x(), (qreal)1.0f);
-    QCOMPARE(v9.y(), (qreal)2.5f);
-    QCOMPARE(v9.z(), (qreal)54.25f);
+    QCOMPARE(v9.x(), 1.0f);
+    QCOMPARE(v9.y(), 2.5f);
+    QCOMPARE(v9.z(), 54.25f);
     QVERIFY(!v9.isNull());
 
     v1.setX(3.0f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)2.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 2.5f);
+    QCOMPARE(v1.z(), -89.25f);
     QVERIFY(!v1.isNull());
 
     v1.setY(10.5f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
+    QCOMPARE(v1.z(), -89.25f);
     QVERIFY(!v1.isNull());
 
     v1.setZ(15.5f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
-    QCOMPARE(v1.z(), (qreal)15.5f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
+    QCOMPARE(v1.z(), 15.5f);
     QVERIFY(!v1.isNull());
 
     v1.setX(0.0f);
     v1.setY(0.0f);
     v1.setZ(0.0f);
-    QCOMPARE(v1.x(), (qreal)0.0f);
-    QCOMPARE(v1.y(), (qreal)0.0f);
-    QCOMPARE(v1.z(), (qreal)0.0f);
+    QCOMPARE(v1.x(), 0.0f);
+    QCOMPARE(v1.y(), 0.0f);
+    QCOMPARE(v1.z(), 0.0f);
     QVERIFY(v1.isNull());
 
     QPoint p1 = v8.toPoint();
@@ -365,18 +356,18 @@ void tst_QVectorND::create3()
     QCOMPARE(p1.y(), 3);
 
     QPointF p2 = v8.toPointF();
-    QCOMPARE((qreal)p2.x(), (qreal)1.0f);
-    QCOMPARE((qreal)p2.y(), (qreal)2.5f);
+    QCOMPARE(p2.x(), 1.0f);
+    QCOMPARE(p2.y(), 2.5f);
 
     QVector2D v10 = v8.toVector2D();
-    QCOMPARE(v10.x(), (qreal)1.0f);
-    QCOMPARE(v10.y(), (qreal)2.5f);
+    QCOMPARE(v10.x(), 1.0f);
+    QCOMPARE(v10.y(), 2.5f);
 
     QVector4D v11 = v8.toVector4D();
-    QCOMPARE(v11.x(), (qreal)1.0f);
-    QCOMPARE(v11.y(), (qreal)2.5f);
-    QCOMPARE(v11.z(), (qreal)54.25f);
-    QCOMPARE(v11.w(), (qreal)0.0f);
+    QCOMPARE(v11.x(), 1.0f);
+    QCOMPARE(v11.y(), 2.5f);
+    QCOMPARE(v11.z(), 54.25f);
+    QCOMPARE(v11.w(), 0.0f);
 }
 
 // Test the creation of QVector4D objects in various ways:
@@ -384,159 +375,159 @@ void tst_QVectorND::create3()
 void tst_QVectorND::create4()
 {
     QVector4D null;
-    QCOMPARE(null.x(), (qreal)0.0f);
-    QCOMPARE(null.y(), (qreal)0.0f);
-    QCOMPARE(null.z(), (qreal)0.0f);
-    QCOMPARE(null.w(), (qreal)0.0f);
+    QCOMPARE(null.x(), 0.0f);
+    QCOMPARE(null.y(), 0.0f);
+    QCOMPARE(null.z(), 0.0f);
+    QCOMPARE(null.w(), 0.0f);
     QVERIFY(null.isNull());
 
-    QVector4D nullNegativeZero(qreal(-0.0), qreal(-0.0), qreal(-0.0), qreal(-0.0));
-    QCOMPARE(nullNegativeZero.x(), (qreal)-0.0f);
-    QCOMPARE(nullNegativeZero.y(), (qreal)-0.0f);
-    QCOMPARE(nullNegativeZero.z(), (qreal)-0.0f);
-    QCOMPARE(nullNegativeZero.w(), (qreal)-0.0f);
+    QVector4D nullNegativeZero(-0.0f, -0.0f, -0.0f, -0.0f);
+    QCOMPARE(nullNegativeZero.x(), -0.0f);
+    QCOMPARE(nullNegativeZero.y(), -0.0f);
+    QCOMPARE(nullNegativeZero.z(), -0.0f);
+    QCOMPARE(nullNegativeZero.w(), -0.0f);
     QVERIFY(nullNegativeZero.isNull());
 
     QVector4D v1(1.0f, 2.5f, -89.25f, 34.0f);
-    QCOMPARE(v1.x(), (qreal)1.0f);
-    QCOMPARE(v1.y(), (qreal)2.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
-    QCOMPARE(v1.w(), (qreal)34.0f);
+    QCOMPARE(v1.x(), 1.0f);
+    QCOMPARE(v1.y(), 2.5f);
+    QCOMPARE(v1.z(), -89.25f);
+    QCOMPARE(v1.w(), 34.0f);
     QVERIFY(!v1.isNull());
 
     QVector4D v1i(1, 2, -89, 34);
-    QCOMPARE(v1i.x(), (qreal)1.0f);
-    QCOMPARE(v1i.y(), (qreal)2.0f);
-    QCOMPARE(v1i.z(), (qreal)-89.0f);
-    QCOMPARE(v1i.w(), (qreal)34.0f);
+    QCOMPARE(v1i.x(), 1.0f);
+    QCOMPARE(v1i.y(), 2.0f);
+    QCOMPARE(v1i.z(), -89.0f);
+    QCOMPARE(v1i.w(), 34.0f);
     QVERIFY(!v1i.isNull());
 
     QVector4D v2(v1);
-    QCOMPARE(v2.x(), (qreal)1.0f);
-    QCOMPARE(v2.y(), (qreal)2.5f);
-    QCOMPARE(v2.z(), (qreal)-89.25f);
-    QCOMPARE(v2.w(), (qreal)34.0f);
+    QCOMPARE(v2.x(), 1.0f);
+    QCOMPARE(v2.y(), 2.5f);
+    QCOMPARE(v2.z(), -89.25f);
+    QCOMPARE(v2.w(), 34.0f);
     QVERIFY(!v2.isNull());
 
     QVector4D v3(1.0f, 2.5f, 0.0f, 0.0f);
-    QCOMPARE(v3.x(), (qreal)1.0f);
-    QCOMPARE(v3.y(), (qreal)2.5f);
-    QCOMPARE(v3.z(), (qreal)0.0f);
-    QCOMPARE(v3.w(), (qreal)0.0f);
+    QCOMPARE(v3.x(), 1.0f);
+    QCOMPARE(v3.y(), 2.5f);
+    QCOMPARE(v3.z(), 0.0f);
+    QCOMPARE(v3.w(), 0.0f);
     QVERIFY(!v3.isNull());
 
     QVector4D v3i(1, 2, 0, 0);
-    QCOMPARE(v3i.x(), (qreal)1.0f);
-    QCOMPARE(v3i.y(), (qreal)2.0f);
-    QCOMPARE(v3i.z(), (qreal)0.0f);
-    QCOMPARE(v3i.w(), (qreal)0.0f);
+    QCOMPARE(v3i.x(), 1.0f);
+    QCOMPARE(v3i.y(), 2.0f);
+    QCOMPARE(v3i.z(), 0.0f);
+    QCOMPARE(v3i.w(), 0.0f);
     QVERIFY(!v3i.isNull());
 
     QVector4D v3b(1.0f, 2.5f, -89.25f, 0.0f);
-    QCOMPARE(v3b.x(), (qreal)1.0f);
-    QCOMPARE(v3b.y(), (qreal)2.5f);
-    QCOMPARE(v3b.z(), (qreal)-89.25f);
-    QCOMPARE(v3b.w(), (qreal)0.0f);
+    QCOMPARE(v3b.x(), 1.0f);
+    QCOMPARE(v3b.y(), 2.5f);
+    QCOMPARE(v3b.z(), -89.25f);
+    QCOMPARE(v3b.w(), 0.0f);
     QVERIFY(!v3b.isNull());
 
     QVector4D v3bi(1, 2, -89, 0);
-    QCOMPARE(v3bi.x(), (qreal)1.0f);
-    QCOMPARE(v3bi.y(), (qreal)2.0f);
-    QCOMPARE(v3bi.z(), (qreal)-89.0f);
-    QCOMPARE(v3bi.w(), (qreal)0.0f);
+    QCOMPARE(v3bi.x(), 1.0f);
+    QCOMPARE(v3bi.y(), 2.0f);
+    QCOMPARE(v3bi.z(), -89.0f);
+    QCOMPARE(v3bi.w(), 0.0f);
     QVERIFY(!v3bi.isNull());
 
     QVector4D v4;
-    QCOMPARE(v4.x(), (qreal)0.0f);
-    QCOMPARE(v4.y(), (qreal)0.0f);
-    QCOMPARE(v4.z(), (qreal)0.0f);
-    QCOMPARE(v4.w(), (qreal)0.0f);
+    QCOMPARE(v4.x(), 0.0f);
+    QCOMPARE(v4.y(), 0.0f);
+    QCOMPARE(v4.z(), 0.0f);
+    QCOMPARE(v4.w(), 0.0f);
     QVERIFY(v4.isNull());
     v4 = v1;
-    QCOMPARE(v4.x(), (qreal)1.0f);
-    QCOMPARE(v4.y(), (qreal)2.5f);
-    QCOMPARE(v4.z(), (qreal)-89.25f);
-    QCOMPARE(v4.w(), (qreal)34.0f);
+    QCOMPARE(v4.x(), 1.0f);
+    QCOMPARE(v4.y(), 2.5f);
+    QCOMPARE(v4.z(), -89.25f);
+    QCOMPARE(v4.w(), 34.0f);
     QVERIFY(!v4.isNull());
 
     QVector4D v5(QPoint(1, 2));
-    QCOMPARE(v5.x(), (qreal)1.0f);
-    QCOMPARE(v5.y(), (qreal)2.0f);
-    QCOMPARE(v5.z(), (qreal)0.0f);
-    QCOMPARE(v5.w(), (qreal)0.0f);
+    QCOMPARE(v5.x(), 1.0f);
+    QCOMPARE(v5.y(), 2.0f);
+    QCOMPARE(v5.z(), 0.0f);
+    QCOMPARE(v5.w(), 0.0f);
     QVERIFY(!v5.isNull());
 
     QVector4D v6(QPointF(1, 2.5));
-    QCOMPARE(v6.x(), (qreal)1.0f);
-    QCOMPARE(v6.y(), (qreal)2.5f);
-    QCOMPARE(v6.z(), (qreal)0.0f);
-    QCOMPARE(v6.w(), (qreal)0.0f);
+    QCOMPARE(v6.x(), 1.0f);
+    QCOMPARE(v6.y(), 2.5f);
+    QCOMPARE(v6.z(), 0.0f);
+    QCOMPARE(v6.w(), 0.0f);
     QVERIFY(!v6.isNull());
 
     QVector4D v7(QVector2D(1.0f, 2.5f));
-    QCOMPARE(v7.x(), (qreal)1.0f);
-    QCOMPARE(v7.y(), (qreal)2.5f);
-    QCOMPARE(v7.z(), (qreal)0.0f);
-    QCOMPARE(v7.w(), (qreal)0.0f);
+    QCOMPARE(v7.x(), 1.0f);
+    QCOMPARE(v7.y(), 2.5f);
+    QCOMPARE(v7.z(), 0.0f);
+    QCOMPARE(v7.w(), 0.0f);
     QVERIFY(!v7.isNull());
 
     QVector4D v8(QVector3D(1.0f, 2.5f, -89.25f));
-    QCOMPARE(v8.x(), (qreal)1.0f);
-    QCOMPARE(v8.y(), (qreal)2.5f);
-    QCOMPARE(v8.z(), (qreal)-89.25f);
-    QCOMPARE(v8.w(), (qreal)0.0f);
+    QCOMPARE(v8.x(), 1.0f);
+    QCOMPARE(v8.y(), 2.5f);
+    QCOMPARE(v8.z(), -89.25f);
+    QCOMPARE(v8.w(), 0.0f);
     QVERIFY(!v8.isNull());
 
     QVector4D v9(QVector3D(1.0f, 2.5f, -89.25f), 34);
-    QCOMPARE(v9.x(), (qreal)1.0f);
-    QCOMPARE(v9.y(), (qreal)2.5f);
-    QCOMPARE(v9.z(), (qreal)-89.25f);
-    QCOMPARE(v9.w(), (qreal)34.0f);
+    QCOMPARE(v9.x(), 1.0f);
+    QCOMPARE(v9.y(), 2.5f);
+    QCOMPARE(v9.z(), -89.25f);
+    QCOMPARE(v9.w(), 34.0f);
     QVERIFY(!v9.isNull());
 
     QVector4D v10(QVector2D(1.0f, 2.5f), 23.5f, -8);
-    QCOMPARE(v10.x(), (qreal)1.0f);
-    QCOMPARE(v10.y(), (qreal)2.5f);
-    QCOMPARE(v10.z(), (qreal)23.5f);
-    QCOMPARE(v10.w(), (qreal)-8.0f);
+    QCOMPARE(v10.x(), 1.0f);
+    QCOMPARE(v10.y(), 2.5f);
+    QCOMPARE(v10.z(), 23.5f);
+    QCOMPARE(v10.w(), -8.0f);
     QVERIFY(!v10.isNull());
 
     v1.setX(3.0f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)2.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
-    QCOMPARE(v1.w(), (qreal)34.0f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 2.5f);
+    QCOMPARE(v1.z(), -89.25f);
+    QCOMPARE(v1.w(), 34.0f);
     QVERIFY(!v1.isNull());
 
     v1.setY(10.5f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
-    QCOMPARE(v1.z(), (qreal)-89.25f);
-    QCOMPARE(v1.w(), (qreal)34.0f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
+    QCOMPARE(v1.z(), -89.25f);
+    QCOMPARE(v1.w(), 34.0f);
     QVERIFY(!v1.isNull());
 
     v1.setZ(15.5f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
-    QCOMPARE(v1.z(), (qreal)15.5f);
-    QCOMPARE(v1.w(), (qreal)34.0f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
+    QCOMPARE(v1.z(), 15.5f);
+    QCOMPARE(v1.w(), 34.0f);
     QVERIFY(!v1.isNull());
 
     v1.setW(6.0f);
-    QCOMPARE(v1.x(), (qreal)3.0f);
-    QCOMPARE(v1.y(), (qreal)10.5f);
-    QCOMPARE(v1.z(), (qreal)15.5f);
-    QCOMPARE(v1.w(), (qreal)6.0f);
+    QCOMPARE(v1.x(), 3.0f);
+    QCOMPARE(v1.y(), 10.5f);
+    QCOMPARE(v1.z(), 15.5f);
+    QCOMPARE(v1.w(), 6.0f);
     QVERIFY(!v1.isNull());
 
     v1.setX(0.0f);
     v1.setY(0.0f);
     v1.setZ(0.0f);
     v1.setW(0.0f);
-    QCOMPARE(v1.x(), (qreal)0.0f);
-    QCOMPARE(v1.y(), (qreal)0.0f);
-    QCOMPARE(v1.z(), (qreal)0.0f);
-    QCOMPARE(v1.w(), (qreal)0.0f);
+    QCOMPARE(v1.x(), 0.0f);
+    QCOMPARE(v1.y(), 0.0f);
+    QCOMPARE(v1.z(), 0.0f);
+    QCOMPARE(v1.w(), 0.0f);
     QVERIFY(v1.isNull());
 
     QPoint p1 = v8.toPoint();
@@ -544,30 +535,30 @@ void tst_QVectorND::create4()
     QCOMPARE(p1.y(), 3);
 
     QPointF p2 = v8.toPointF();
-    QCOMPARE((qreal)p2.x(), (qreal)1.0f);
-    QCOMPARE((qreal)p2.y(), (qreal)2.5f);
+    QCOMPARE(p2.x(), 1.0f);
+    QCOMPARE(p2.y(), 2.5f);
 
     QVector2D v11 = v8.toVector2D();
-    QCOMPARE(v11.x(), (qreal)1.0f);
-    QCOMPARE(v11.y(), (qreal)2.5f);
+    QCOMPARE(v11.x(), 1.0f);
+    QCOMPARE(v11.y(), 2.5f);
 
     QVector3D v12 = v8.toVector3D();
-    QCOMPARE(v12.x(), (qreal)1.0f);
-    QCOMPARE(v12.y(), (qreal)2.5f);
-    QCOMPARE(v12.z(), (qreal)-89.25f);
+    QCOMPARE(v12.x(), 1.0f);
+    QCOMPARE(v12.y(), 2.5f);
+    QCOMPARE(v12.z(), -89.25f);
 
     QVector2D v13 = v9.toVector2DAffine();
-    QVERIFY(fuzzyCompare(v13.x(), (qreal)(1.0f / 34.0f)));
-    QVERIFY(fuzzyCompare(v13.y(), (qreal)(2.5f / 34.0f)));
+    QVERIFY(qFuzzyCompare(v13.x(), (1.0f / 34.0f)));
+    QVERIFY(qFuzzyCompare(v13.y(), (2.5f / 34.0f)));
 
     QVector4D zerow(1.0f, 2.0f, 3.0f, 0.0f);
     v13 = zerow.toVector2DAffine();
     QVERIFY(v13.isNull());
 
     QVector3D v14 = v9.toVector3DAffine();
-    QVERIFY(fuzzyCompare(v14.x(), (qreal)(1.0f / 34.0f)));
-    QVERIFY(fuzzyCompare(v14.y(), (qreal)(2.5f / 34.0f)));
-    QVERIFY(fuzzyCompare(v14.z(), (qreal)(-89.25f / 34.0f)));
+    QVERIFY(qFuzzyCompare(v14.x(), (1.0f / 34.0f)));
+    QVERIFY(qFuzzyCompare(v14.y(), (2.5f / 34.0f)));
+    QVERIFY(qFuzzyCompare(v14.z(), (-89.25f / 34.0f)));
 
     v14 = zerow.toVector3DAffine();
     QVERIFY(v14.isNull());
@@ -576,22 +567,22 @@ void tst_QVectorND::create4()
 // Test vector length computation for 2D vectors.
 void tst_QVectorND::length2_data()
 {
-    QTest::addColumn<qreal>("x");
-    QTest::addColumn<qreal>("y");
-    QTest::addColumn<qreal>("len");
+    QTest::addColumn<float>("x");
+    QTest::addColumn<float>("y");
+    QTest::addColumn<float>("len");
 
-    QTest::newRow("null") << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
-    QTest::newRow("1x") << (qreal)1.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1y") << (qreal)0.0f << (qreal)1.0f << (qreal)1.0f;
-    QTest::newRow("-1x") << (qreal)-1.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1y") << (qreal)0.0f << (qreal)-1.0f << (qreal)1.0f;
-    QTest::newRow("two") << (qreal)2.0f << (qreal)-2.0f << (qreal)qSqrt(8.0f);
+    QTest::newRow("null") <<  0.0f <<  0.0f << 0.0f;
+    QTest::newRow("1x")   <<  1.0f <<  0.0f << 1.0f;
+    QTest::newRow("1y")   <<  0.0f <<  1.0f << 1.0f;
+    QTest::newRow("-1x")  << -1.0f <<  0.0f << 1.0f;
+    QTest::newRow("-1y")  <<  0.0f << -1.0f << 1.0f;
+    QTest::newRow("two")  <<  2.0f << -2.0f << sqrtf(8.0f);
 }
 void tst_QVectorND::length2()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, len);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, len);
 
     QVector2D v(x, y);
     QCOMPARE(v.length(), len);
@@ -601,26 +592,26 @@ void tst_QVectorND::length2()
 // Test vector length computation for 3D vectors.
 void tst_QVectorND::length3_data()
 {
-    QTest::addColumn<qreal>("x");
-    QTest::addColumn<qreal>("y");
-    QTest::addColumn<qreal>("z");
-    QTest::addColumn<qreal>("len");
+    QTest::addColumn<float>("x");
+    QTest::addColumn<float>("y");
+    QTest::addColumn<float>("z");
+    QTest::addColumn<float>("len");
 
-    QTest::newRow("null") << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
-    QTest::newRow("1x") << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1y") << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1z") << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)1.0f;
-    QTest::newRow("-1x") << (qreal)-1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1y") << (qreal)0.0f << (qreal)-1.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1z") << (qreal)0.0f << (qreal)0.0f << (qreal)-1.0f << (qreal)1.0f;
-    QTest::newRow("two") << (qreal)2.0f << (qreal)-2.0f << (qreal)2.0f << (qreal)qSqrt(12.0f);
+    QTest::newRow("null") << 0.0f << 0.0f << 0.0f << 0.0f;
+    QTest::newRow("1x") << 1.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("1y") << 0.0f << 1.0f << 0.0f << 1.0f;
+    QTest::newRow("1z") << 0.0f << 0.0f << 1.0f << 1.0f;
+    QTest::newRow("-1x") << -1.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("-1y") << 0.0f << -1.0f << 0.0f << 1.0f;
+    QTest::newRow("-1z") << 0.0f << 0.0f << -1.0f << 1.0f;
+    QTest::newRow("two") << 2.0f << -2.0f << 2.0f << sqrtf(12.0f);
 }
 void tst_QVectorND::length3()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
-    QFETCH(qreal, len);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
+    QFETCH(float, len);
 
     QVector3D v(x, y, z);
     QCOMPARE(v.length(), len);
@@ -630,30 +621,30 @@ void tst_QVectorND::length3()
 // Test vector length computation for 4D vectors.
 void tst_QVectorND::length4_data()
 {
-    QTest::addColumn<qreal>("x");
-    QTest::addColumn<qreal>("y");
-    QTest::addColumn<qreal>("z");
-    QTest::addColumn<qreal>("w");
-    QTest::addColumn<qreal>("len");
-
-    QTest::newRow("null") << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
-    QTest::newRow("1x") << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1y") << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1z") << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("1w") << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)1.0f;
-    QTest::newRow("-1x") << (qreal)-1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1y") << (qreal)0.0f << (qreal)-1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1z") << (qreal)0.0f << (qreal)0.0f << (qreal)-1.0f << (qreal)0.0f << (qreal)1.0f;
-    QTest::newRow("-1w") << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)-1.0f << (qreal)1.0f;
-    QTest::newRow("two") << (qreal)2.0f << (qreal)-2.0f << (qreal)2.0f << (qreal)2.0f << (qreal)qSqrt(16.0f);
+    QTest::addColumn<float>("x");
+    QTest::addColumn<float>("y");
+    QTest::addColumn<float>("z");
+    QTest::addColumn<float>("w");
+    QTest::addColumn<float>("len");
+
+    QTest::newRow("null") << 0.0f << 0.0f << 0.0f << 0.0f << 0.0f;
+    QTest::newRow("1x") << 1.0f << 0.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("1y") << 0.0f << 1.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("1z") << 0.0f << 0.0f << 1.0f << 0.0f << 1.0f;
+    QTest::newRow("1w") << 0.0f << 0.0f << 0.0f << 1.0f << 1.0f;
+    QTest::newRow("-1x") << -1.0f << 0.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("-1y") << 0.0f << -1.0f << 0.0f << 0.0f << 1.0f;
+    QTest::newRow("-1z") << 0.0f << 0.0f << -1.0f << 0.0f << 1.0f;
+    QTest::newRow("-1w") << 0.0f << 0.0f << 0.0f << -1.0f << 1.0f;
+    QTest::newRow("two") << 2.0f << -2.0f << 2.0f << 2.0f << sqrtf(16.0f);
 }
 void tst_QVectorND::length4()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
-    QFETCH(qreal, w);
-    QFETCH(qreal, len);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
+    QFETCH(float, w);
+    QFETCH(float, len);
 
     QVector4D v(x, y, z, w);
     QCOMPARE(v.length(), len);
@@ -668,18 +659,18 @@ void tst_QVectorND::normalized2_data()
 }
 void tst_QVectorND::normalized2()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, len);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, len);
 
     QVector2D v(x, y);
     QVector2D u = v.normalized();
     if (v.isNull())
         QVERIFY(u.isNull());
     else
-        QVERIFY(fuzzyCompare(u.length(), qreal(1.0f)));
-    QVERIFY(fuzzyCompare(u.x() * len, v.x()));
-    QVERIFY(fuzzyCompare(u.y() * len, v.y()));
+        QVERIFY(qFuzzyCompare(u.length(), 1.0f));
+    QVERIFY(qFuzzyCompare(u.x() * len, v.x()));
+    QVERIFY(qFuzzyCompare(u.y() * len, v.y()));
 }
 
 // Test the unit vector conversion for 3D vectors.
@@ -690,20 +681,20 @@ void tst_QVectorND::normalized3_data()
 }
 void tst_QVectorND::normalized3()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
-    QFETCH(qreal, len);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
+    QFETCH(float, len);
 
     QVector3D v(x, y, z);
     QVector3D u = v.normalized();
     if (v.isNull())
         QVERIFY(u.isNull());
     else
-        QVERIFY(fuzzyCompare(u.length(), qreal(1.0f)));
-    QVERIFY(fuzzyCompare(u.x() * len, v.x()));
-    QVERIFY(fuzzyCompare(u.y() * len, v.y()));
-    QVERIFY(fuzzyCompare(u.z() * len, v.z()));
+        QVERIFY(qFuzzyCompare(u.length(), 1.0f));
+    QVERIFY(qFuzzyCompare(u.x() * len, v.x()));
+    QVERIFY(qFuzzyCompare(u.y() * len, v.y()));
+    QVERIFY(qFuzzyCompare(u.z() * len, v.z()));
 }
 
 // Test the unit vector conversion for 4D vectors.
@@ -714,22 +705,22 @@ void tst_QVectorND::normalized4_data()
 }
 void tst_QVectorND::normalized4()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
-    QFETCH(qreal, w);
-    QFETCH(qreal, len);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
+    QFETCH(float, w);
+    QFETCH(float, len);
 
     QVector4D v(x, y, z, w);
     QVector4D u = v.normalized();
     if (v.isNull())
         QVERIFY(u.isNull());
     else
-        QVERIFY(fuzzyCompare(u.length(), qreal(1.0f)));
-    QVERIFY(fuzzyCompare(u.x() * len, v.x()));
-    QVERIFY(fuzzyCompare(u.y() * len, v.y()));
-    QVERIFY(fuzzyCompare(u.z() * len, v.z()));
-    QVERIFY(fuzzyCompare(u.w() * len, v.w()));
+        QVERIFY(qFuzzyCompare(u.length(), 1.0f));
+    QVERIFY(qFuzzyCompare(u.x() * len, v.x()));
+    QVERIFY(qFuzzyCompare(u.y() * len, v.y()));
+    QVERIFY(qFuzzyCompare(u.z() * len, v.z()));
+    QVERIFY(qFuzzyCompare(u.w() * len, v.w()));
 }
 
 // Test the unit vector conversion for 2D vectors.
@@ -740,8 +731,8 @@ void tst_QVectorND::normalize2_data()
 }
 void tst_QVectorND::normalize2()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
+    QFETCH(float, x);
+    QFETCH(float, y);
 
     QVector2D v(x, y);
     bool isNull = v.isNull();
@@ -749,7 +740,7 @@ void tst_QVectorND::normalize2()
     if (isNull)
         QVERIFY(v.isNull());
     else
-        QVERIFY(fuzzyCompare(v.length(), qreal(1.0f)));
+        QVERIFY(qFuzzyCompare(v.length(), 1.0f));
 }
 
 // Test the unit vector conversion for 3D vectors.
@@ -760,9 +751,9 @@ void tst_QVectorND::normalize3_data()
 }
 void tst_QVectorND::normalize3()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
 
     QVector3D v(x, y, z);
     bool isNull = v.isNull();
@@ -770,7 +761,7 @@ void tst_QVectorND::normalize3()
     if (isNull)
         QVERIFY(v.isNull());
     else
-        QVERIFY(fuzzyCompare(v.length(), qreal(1.0f)));
+        QVERIFY(qFuzzyCompare(v.length(), 1.0f));
 }
 
 // Test the unit vector conversion for 4D vectors.
@@ -781,10 +772,10 @@ void tst_QVectorND::normalize4_data()
 }
 void tst_QVectorND::normalize4()
 {
-    QFETCH(qreal, x);
-    QFETCH(qreal, y);
-    QFETCH(qreal, z);
-    QFETCH(qreal, w);
+    QFETCH(float, x);
+    QFETCH(float, y);
+    QFETCH(float, z);
+    QFETCH(float, w);
 
     QVector4D v(x, y, z, w);
     bool isNull = v.isNull();
@@ -792,7 +783,7 @@ void tst_QVectorND::normalize4()
     if (isNull)
         QVERIFY(v.isNull());
     else
-        QVERIFY(fuzzyCompare(v.length(), qreal(1.0f)));
+        QVERIFY(qFuzzyCompare(v.length(), 1.0f));
 }
 
 // Test the comparison operators for 2D vectors.
@@ -843,41 +834,41 @@ void tst_QVectorND::compare4()
 // Test vector addition for 2D vectors.
 void tst_QVectorND::add2_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f
+        << 0.0f << 0.0f
+        << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f
-        << (qreal)3.0f << (qreal)0.0f;
+        << 1.0f << 0.0f
+        << 2.0f << 0.0f
+        << 3.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)2.0f
-        << (qreal)0.0f << (qreal)3.0f;
+        << 0.0f << 1.0f
+        << 0.0f << 2.0f
+        << 0.0f << 3.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f
-        << (qreal)4.0f << (qreal)5.0f
-        << (qreal)5.0f << (qreal)7.0f;
+        << 1.0f << 2.0f
+        << 4.0f << 5.0f
+        << 5.0f << 7.0f;
 }
 void tst_QVectorND::add2()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
 
     QVector2D v1(x1, y1);
     QVector2D v2(x2, y2);
@@ -896,52 +887,52 @@ void tst_QVectorND::add2()
 // Test vector addition for 3D vectors.
 void tst_QVectorND::add3_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)3.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f
+        << 2.0f << 0.0f << 0.0f
+        << 3.0f << 0.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)3.0f << (qreal)0.0f;
+        << 0.0f << 1.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f
+        << 0.0f << 3.0f << 0.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)3.0f;
+        << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 2.0f
+        << 0.0f << 0.0f << 3.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)-6.0f
-        << (qreal)5.0f << (qreal)7.0f << (qreal)-3.0f;
+        << 1.0f << 2.0f << 3.0f
+        << 4.0f << 5.0f << -6.0f
+        << 5.0f << 7.0f << -3.0f;
 }
 void tst_QVectorND::add3()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
@@ -961,63 +952,63 @@ void tst_QVectorND::add3()
 // Test vector addition for 4D vectors.
 void tst_QVectorND::add4_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("w1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("w2");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
-    QTest::addColumn<qreal>("w3");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("w1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("w2");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
+    QTest::addColumn<float>("w3");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)3.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f << 0.0f
+        << 2.0f << 0.0f << 0.0f << 0.0f
+        << 3.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)3.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 1.0f << 0.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f << 0.0f
+        << 0.0f << 3.0f << 0.0f << 0.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)3.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 1.0f << 0.0f
+        << 0.0f << 0.0f << 2.0f << 0.0f
+        << 0.0f << 0.0f << 3.0f << 0.0f;
 
     QTest::newRow("wonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)3.0f;
+        << 0.0f << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 0.0f << 2.0f
+        << 0.0f << 0.0f << 0.0f << 3.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f << (qreal)8.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)-6.0f << (qreal)9.0f
-        << (qreal)5.0f << (qreal)7.0f << (qreal)-3.0f << (qreal)17.0f;
+        << 1.0f << 2.0f << 3.0f << 8.0f
+        << 4.0f << 5.0f << -6.0f << 9.0f
+        << 5.0f << 7.0f << -3.0f << 17.0f;
 }
 void tst_QVectorND::add4()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, w3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, w3);
 
     QVector4D v1(x1, y1, z1, w1);
     QVector4D v2(x2, y2, z2, w2);
@@ -1043,12 +1034,12 @@ void tst_QVectorND::subtract2_data()
 }
 void tst_QVectorND::subtract2()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
 
     QVector2D v1(x1, y1);
     QVector2D v2(x2, y2);
@@ -1080,15 +1071,15 @@ void tst_QVectorND::subtract3_data()
 }
 void tst_QVectorND::subtract3()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
@@ -1122,18 +1113,18 @@ void tst_QVectorND::subtract4_data()
 }
 void tst_QVectorND::subtract4()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, w3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, w3);
 
     QVector4D v1(x1, y1, z1, w1);
     QVector4D v2(x2, y2, z2, w2);
@@ -1164,41 +1155,41 @@ void tst_QVectorND::subtract4()
 // Test component-wise vector multiplication for 2D vectors.
 void tst_QVectorND::multiply2_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f
+        << 0.0f << 0.0f
+        << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f;
+        << 1.0f << 0.0f
+        << 2.0f << 0.0f
+        << 2.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)2.0f
-        << (qreal)0.0f << (qreal)2.0f;
+        << 0.0f << 1.0f
+        << 0.0f << 2.0f
+        << 0.0f << 2.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f
-        << (qreal)4.0f << (qreal)5.0f
-        << (qreal)4.0f << (qreal)10.0f;
+        << 1.0f << 2.0f
+        << 4.0f << 5.0f
+        << 4.0f << 10.0f;
 }
 void tst_QVectorND::multiply2()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
 
     QVector2D v1(x1, y1);
     QVector2D v2(x2, y2);
@@ -1217,52 +1208,52 @@ void tst_QVectorND::multiply2()
 // Test component-wise vector multiplication for 3D vectors.
 void tst_QVectorND::multiply3_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f
+        << 2.0f << 0.0f << 0.0f
+        << 2.0f << 0.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f;
+        << 0.0f << 1.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f;
+        << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 2.0f
+        << 0.0f << 0.0f << 2.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)-6.0f
-        << (qreal)4.0f << (qreal)10.0f << (qreal)-18.0f;
+        << 1.0f << 2.0f << 3.0f
+        << 4.0f << 5.0f << -6.0f
+        << 4.0f << 10.0f << -18.0f;
 }
 void tst_QVectorND::multiply3()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
@@ -1282,63 +1273,63 @@ void tst_QVectorND::multiply3()
 // Test component-wise vector multiplication for 4D vectors.
 void tst_QVectorND::multiply4_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("w1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("w2");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
-    QTest::addColumn<qreal>("w3");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("w1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("w2");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
+    QTest::addColumn<float>("w3");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f << 0.0f
+        << 2.0f << 0.0f << 0.0f << 0.0f
+        << 2.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 1.0f << 0.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f << 0.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 1.0f << 0.0f
+        << 0.0f << 0.0f << 2.0f << 0.0f
+        << 0.0f << 0.0f << 2.0f << 0.0f;
 
     QTest::newRow("wonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f;
+        << 0.0f << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 0.0f << 2.0f
+        << 0.0f << 0.0f << 0.0f << 2.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f << (qreal)8.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)-6.0f << (qreal)9.0f
-        << (qreal)4.0f << (qreal)10.0f << (qreal)-18.0f << (qreal)72.0f;
+        << 1.0f << 2.0f << 3.0f << 8.0f
+        << 4.0f << 5.0f << -6.0f << 9.0f
+        << 4.0f << 10.0f << -18.0f << 72.0f;
 }
 void tst_QVectorND::multiply4()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, w3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, w3);
 
     QVector4D v1(x1, y1, z1, w1);
     QVector4D v2(x2, y2, z2, w2);
@@ -1359,44 +1350,44 @@ void tst_QVectorND::multiply4()
 // Test vector multiplication by a factor for 2D vectors.
 void tst_QVectorND::multiplyFactor2_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("factor");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("factor");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f
-        << (qreal)100.0f
-        << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f
+        << 100.0f
+        << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)2.0f << (qreal)0.0f;
+        << 1.0f << 0.0f
+        << 2.0f
+        << 2.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)2.0f;
+        << 0.0f << 1.0f
+        << 2.0f
+        << 0.0f << 2.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f
-        << (qreal)2.0f
-        << (qreal)2.0f << (qreal)4.0f;
+        << 1.0f << 2.0f
+        << 2.0f
+        << 2.0f << 4.0f;
 
     QTest::newRow("allzero")
-        << (qreal)1.0f << (qreal)2.0f
-        << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 2.0f
+        << 0.0f
+        << 0.0f << 0.0f;
 }
 void tst_QVectorND::multiplyFactor2()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, factor);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, factor);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
 
     QVector2D v1(x1, y1);
     QVector2D v2(x2, y2);
@@ -1415,53 +1406,53 @@ void tst_QVectorND::multiplyFactor2()
 // Test vector multiplication by a factor for 3D vectors.
 void tst_QVectorND::multiplyFactor3_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("factor");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("factor");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)100.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 100.0f
+        << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f
+        << 2.0f
+        << 2.0f << 0.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f;
+        << 0.0f << 1.0f << 0.0f
+        << 2.0f
+        << 0.0f << 2.0f << 0.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f;
+        << 0.0f << 0.0f << 1.0f
+        << 2.0f
+        << 0.0f << 0.0f << 2.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f
-        << (qreal)2.0f
-        << (qreal)2.0f << (qreal)4.0f << (qreal)-6.0f;
+        << 1.0f << 2.0f << -3.0f
+        << 2.0f
+        << 2.0f << 4.0f << -6.0f;
 
     QTest::newRow("allzero")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f
-        << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 2.0f << -3.0f
+        << 0.0f
+        << 0.0f << 0.0f << 0.0f;
 }
 void tst_QVectorND::multiplyFactor3()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, factor);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, factor);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
@@ -1481,62 +1472,62 @@ void tst_QVectorND::multiplyFactor3()
 // Test vector multiplication by a factor for 4D vectors.
 void tst_QVectorND::multiplyFactor4_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("w1");
-    QTest::addColumn<qreal>("factor");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("w2");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("w1");
+    QTest::addColumn<float>("factor");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("w2");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)100.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 100.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("xonly")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f << 0.0f
+        << 2.0f
+        << 2.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("yonly")
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 1.0f << 0.0f << 0.0f
+        << 2.0f
+        << 0.0f << 2.0f << 0.0f << 0.0f;
 
     QTest::newRow("zonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 1.0f << 0.0f
+        << 2.0f
+        << 0.0f << 0.0f << 2.0f << 0.0f;
 
     QTest::newRow("wonly")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)2.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f;
+        << 0.0f << 0.0f << 0.0f << 1.0f
+        << 2.0f
+        << 0.0f << 0.0f << 0.0f << 2.0f;
 
     QTest::newRow("all")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)4.0f
-        << (qreal)2.0f
-        << (qreal)2.0f << (qreal)4.0f << (qreal)-6.0f << (qreal)8.0f;
+        << 1.0f << 2.0f << -3.0f << 4.0f
+        << 2.0f
+        << 2.0f << 4.0f << -6.0f << 8.0f;
 
     QTest::newRow("allzero")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)-3.0f << (qreal)4.0f
-        << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 1.0f << 2.0f << -3.0f << 4.0f
+        << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 }
 void tst_QVectorND::multiplyFactor4()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, factor);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, factor);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
 
     QVector4D v1(x1, y1, z1, w1);
     QVector4D v2(x2, y2, z2, w2);
@@ -1562,16 +1553,16 @@ void tst_QVectorND::divide2_data()
 }
 void tst_QVectorND::divide2()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, factor);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, factor);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
 
     QVector2D v1(x1, y1);
     QVector2D v2(x2, y2);
 
-    if (factor == (qreal)0.0f)
+    if (factor == 0.0f)
         return;
 
     QVERIFY((v2 / factor) == v1);
@@ -1592,18 +1583,18 @@ void tst_QVectorND::divide3_data()
 }
 void tst_QVectorND::divide3()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, factor);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, factor);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
 
-    if (factor == (qreal)0.0f)
+    if (factor == 0.0f)
         return;
 
     QVERIFY((v2 / factor) == v1);
@@ -1625,20 +1616,20 @@ void tst_QVectorND::divide4_data()
 }
 void tst_QVectorND::divide4()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, factor);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, factor);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
 
     QVector4D v1(x1, y1, z1, w1);
     QVector4D v2(x2, y2, z2, w2);
 
-    if (factor == (qreal)0.0f)
+    if (factor == 0.0f)
         return;
 
     QVERIFY((v2 / factor) == v1);
@@ -1661,8 +1652,8 @@ void tst_QVectorND::negate2_data()
 }
 void tst_QVectorND::negate2()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
 
     QVector2D v1(x1, y1);
     QVector2D v2(-x1, -y1);
@@ -1678,9 +1669,9 @@ void tst_QVectorND::negate3_data()
 }
 void tst_QVectorND::negate3()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(-x1, -y1, -z1);
@@ -1696,10 +1687,10 @@ void tst_QVectorND::negate4_data()
 }
 void tst_QVectorND::negate4()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
 
     QVector4D v1(x1, y1, z1, w1);
     QVector4D v2(-x1, -y1, -z1, -w1);
@@ -1710,46 +1701,46 @@ void tst_QVectorND::negate4()
 // Test the computation of vector cross-products.
 void tst_QVectorND::crossProduct_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("x3");
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
-    QTest::addColumn<qreal>("dot");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("x3");
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
+    QTest::addColumn<float>("dot");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f;
 
     QTest::newRow("unitvec")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f
+        << 0.0f << 1.0f << 0.0f
+        << 0.0f << 0.0f << 1.0f
+        << 0.0f;
 
     QTest::newRow("complex")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)6.0f
-        << (qreal)-3.0f << (qreal)6.0f << (qreal)-3.0f
-        << (qreal)32.0f;
+        << 1.0f << 2.0f << 3.0f
+        << 4.0f << 5.0f << 6.0f
+        << -3.0f << 6.0f << -3.0f
+        << 32.0f;
 }
 void tst_QVectorND::crossProduct()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
@@ -1759,9 +1750,9 @@ void tst_QVectorND::crossProduct()
     QVERIFY(v4 == v3);
 
     // Compute the cross-product long-hand and check again.
-    qreal xres = y1 * z2 - z1 * y2;
-    qreal yres = z1 * x2 - x1 * z2;
-    qreal zres = x1 * y2 - y1 * x2;
+    float xres = y1 * z2 - z1 * y2;
+    float yres = z1 * x2 - x1 * z2;
+    float zres = x1 * y2 - y1 * x2;
 
     QCOMPARE(v4.x(), xres);
     QCOMPARE(v4.y(), yres);
@@ -1776,15 +1767,15 @@ void tst_QVectorND::normal_data()
 }
 void tst_QVectorND::normal()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
@@ -1800,65 +1791,65 @@ void tst_QVectorND::normal()
 // Test distance to plane calculations.
 void tst_QVectorND::distanceToPlane_data()
 {
-    QTest::addColumn<qreal>("x1");  // Point on plane
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("x2");  // Normal to plane
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("x3");  // Point to test for distance
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
-    QTest::addColumn<qreal>("x4");  // Second point on plane
-    QTest::addColumn<qreal>("y4");
-    QTest::addColumn<qreal>("z4");
-    QTest::addColumn<qreal>("x5");  // Third point on plane
-    QTest::addColumn<qreal>("y5");
-    QTest::addColumn<qreal>("z5");
-    QTest::addColumn<qreal>("distance");
+    QTest::addColumn<float>("x1");  // Point on plane
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("x2");  // Normal to plane
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("x3");  // Point to test for distance
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
+    QTest::addColumn<float>("x4");  // Second point on plane
+    QTest::addColumn<float>("y4");
+    QTest::addColumn<float>("z4");
+    QTest::addColumn<float>("x5");  // Third point on plane
+    QTest::addColumn<float>("y5");
+    QTest::addColumn<float>("z5");
+    QTest::addColumn<float>("distance");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f
-        << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 0.0f
+        << 1.0f << 0.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f
+        << 0.0f;
 
     QTest::newRow("above")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)2.0f
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f
-        << (qreal)2.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 2.0f
+        << 1.0f << 0.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f
+        << 2.0f;
 
     QTest::newRow("below")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)-1.0f << (qreal)1.0f << (qreal)-2.0f
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)2.0f << (qreal)0.0f
-        << (qreal)-2.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 1.0f
+        << -1.0f << 1.0f << -2.0f
+        << 1.0f << 0.0f << 0.0f
+        << 0.0f << 2.0f << 0.0f
+        << -2.0f;
 }
 void tst_QVectorND::distanceToPlane()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, x4);
-    QFETCH(qreal, y4);
-    QFETCH(qreal, z4);
-    QFETCH(qreal, x5);
-    QFETCH(qreal, y5);
-    QFETCH(qreal, z5);
-    QFETCH(qreal, distance);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, x4);
+    QFETCH(float, y4);
+    QFETCH(float, z4);
+    QFETCH(float, x5);
+    QFETCH(float, y5);
+    QFETCH(float, z5);
+    QFETCH(float, distance);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
@@ -1873,59 +1864,59 @@ void tst_QVectorND::distanceToPlane()
 // Test distance to line calculations.
 void tst_QVectorND::distanceToLine_data()
 {
-    QTest::addColumn<qreal>("x1");  // Point on line
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("x2");  // Direction of the line
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("x3");  // Point to test for distance
-    QTest::addColumn<qreal>("y3");
-    QTest::addColumn<qreal>("z3");
-    QTest::addColumn<qreal>("distance");
+    QTest::addColumn<float>("x1");  // Point on line
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("x2");  // Direction of the line
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("x3");  // Point to test for distance
+    QTest::addColumn<float>("y3");
+    QTest::addColumn<float>("z3");
+    QTest::addColumn<float>("distance");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f;
 
     QTest::newRow("on line")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)5.0f
-        << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 1.0f
+        << 0.0f << 0.0f << 5.0f
+        << 0.0f;
 
     QTest::newRow("off line")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)1.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 1.0f
+        << 1.0f << 0.0f << 0.0f
+        << 1.0f;
 
     QTest::newRow("off line 2")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)-2.0f << (qreal)0.0f
-        << (qreal)2.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 1.0f
+        << 0.0f << -2.0f << 0.0f
+        << 2.0f;
 
     QTest::newRow("points")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)5.0f << (qreal)0.0f
-        << (qreal)5.0f;
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f
+        << 0.0f << 5.0f << 0.0f
+        << 5.0f;
 }
 void tst_QVectorND::distanceToLine()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, distance);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, distance);
 
     QVector3D v1(x1, y1, z1);
     QVector3D v2(x2, y2, z2);
@@ -1937,34 +1928,34 @@ void tst_QVectorND::distanceToLine()
 // Test the computation of dot products for 2D vectors.
 void tst_QVectorND::dotProduct2_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("dot");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("dot");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f;
+        << 0.0f << 0.0f
+        << 0.0f << 0.0f
+        << 0.0f;
 
     QTest::newRow("unitvec")
-        << (qreal)1.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f;
+        << 1.0f << 0.0f
+        << 0.0f << 1.0f
+        << 0.0f;
 
     QTest::newRow("complex")
-        << (qreal)1.0f << (qreal)2.0f
-        << (qreal)4.0f << (qreal)5.0f
-        << (qreal)14.0f;
+        << 1.0f << 2.0f
+        << 4.0f << 5.0f
+        << 14.0f;
 }
 void tst_QVectorND::dotProduct2()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, dot);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, dot);
 
     QVector2D v1(x1, y1);
     QVector2D v2(x2, y2);
@@ -1972,7 +1963,7 @@ void tst_QVectorND::dotProduct2()
     QVERIFY(QVector2D::dotProduct(v1, v2) == dot);
 
     // Compute the dot-product long-hand and check again.
-    qreal d = x1 * x2 + y1 * y2;
+    float d = x1 * x2 + y1 * y2;
 
     QCOMPARE(QVector2D::dotProduct(v1, v2), d);
 }
@@ -1985,16 +1976,16 @@ void tst_QVectorND::dotProduct3_data()
 }
 void tst_QVectorND::dotProduct3()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, x3);
-    QFETCH(qreal, y3);
-    QFETCH(qreal, z3);
-    QFETCH(qreal, dot);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, x3);
+    QFETCH(float, y3);
+    QFETCH(float, z3);
+    QFETCH(float, dot);
 
     Q_UNUSED(x3);
     Q_UNUSED(y3);
@@ -2006,7 +1997,7 @@ void tst_QVectorND::dotProduct3()
     QVERIFY(QVector3D::dotProduct(v1, v2) == dot);
 
     // Compute the dot-product long-hand and check again.
-    qreal d = x1 * x2 + y1 * y2 + z1 * z2;
+    float d = x1 * x2 + y1 * y2 + z1 * z2;
 
     QCOMPARE(QVector3D::dotProduct(v1, v2), d);
 }
@@ -2014,42 +2005,42 @@ void tst_QVectorND::dotProduct3()
 // Test the computation of dot products for 4D vectors.
 void tst_QVectorND::dotProduct4_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("w1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("w2");
-    QTest::addColumn<qreal>("dot");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("w1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("w2");
+    QTest::addColumn<float>("dot");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f;
 
     QTest::newRow("unitvec")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f;
+        << 1.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 1.0f << 0.0f << 0.0f
+        << 0.0f;
 
     QTest::newRow("complex")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f << (qreal)4.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)6.0f << (qreal)7.0f
-        << (qreal)60.0f;
+        << 1.0f << 2.0f << 3.0f << 4.0f
+        << 4.0f << 5.0f << 6.0f << 7.0f
+        << 60.0f;
 }
 void tst_QVectorND::dotProduct4()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
-    QFETCH(qreal, dot);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
+    QFETCH(float, dot);
 
     QVector4D v1(x1, y1, z1, w1);
     QVector4D v2(x2, y2, z2, w2);
@@ -2057,7 +2048,7 @@ void tst_QVectorND::dotProduct4()
     QVERIFY(QVector4D::dotProduct(v1, v2) == dot);
 
     // Compute the dot-product long-hand and check again.
-    qreal d = x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2;
+    float d = x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2;
 
     QCOMPARE(QVector4D::dotProduct(v1, v2), d);
 }
@@ -2096,19 +2087,19 @@ void tst_QVectorND::properties()
     obj.setVector4D(QVector4D(6.0f, 7.0f, 8.0f, 9.0f));
 
     QVector2D v2 = qvariant_cast<QVector2D>(obj.property("vector2D"));
-    QCOMPARE(v2.x(), (qreal)1.0f);
-    QCOMPARE(v2.y(), (qreal)2.0f);
+    QCOMPARE(v2.x(), 1.0f);
+    QCOMPARE(v2.y(), 2.0f);
 
     QVector3D v3 = qvariant_cast<QVector3D>(obj.property("vector3D"));
-    QCOMPARE(v3.x(), (qreal)3.0f);
-    QCOMPARE(v3.y(), (qreal)4.0f);
-    QCOMPARE(v3.z(), (qreal)5.0f);
+    QCOMPARE(v3.x(), 3.0f);
+    QCOMPARE(v3.y(), 4.0f);
+    QCOMPARE(v3.z(), 5.0f);
 
     QVector4D v4 = qvariant_cast<QVector4D>(obj.property("vector4D"));
-    QCOMPARE(v4.x(), (qreal)6.0f);
-    QCOMPARE(v4.y(), (qreal)7.0f);
-    QCOMPARE(v4.z(), (qreal)8.0f);
-    QCOMPARE(v4.w(), (qreal)9.0f);
+    QCOMPARE(v4.x(), 6.0f);
+    QCOMPARE(v4.y(), 7.0f);
+    QCOMPARE(v4.z(), 8.0f);
+    QCOMPARE(v4.w(), 9.0f);
 
     obj.setProperty("vector2D",
                     QVariant::fromValue(QVector2D(-1.0f, -2.0f)));
@@ -2118,19 +2109,19 @@ void tst_QVectorND::properties()
                     QVariant::fromValue(QVector4D(-6.0f, -7.0f, -8.0f, -9.0f)));
 
     v2 = qvariant_cast<QVector2D>(obj.property("vector2D"));
-    QCOMPARE(v2.x(), (qreal)-1.0f);
-    QCOMPARE(v2.y(), (qreal)-2.0f);
+    QCOMPARE(v2.x(), -1.0f);
+    QCOMPARE(v2.y(), -2.0f);
 
     v3 = qvariant_cast<QVector3D>(obj.property("vector3D"));
-    QCOMPARE(v3.x(), (qreal)-3.0f);
-    QCOMPARE(v3.y(), (qreal)-4.0f);
-    QCOMPARE(v3.z(), (qreal)-5.0f);
+    QCOMPARE(v3.x(), -3.0f);
+    QCOMPARE(v3.y(), -4.0f);
+    QCOMPARE(v3.z(), -5.0f);
 
     v4 = qvariant_cast<QVector4D>(obj.property("vector4D"));
-    QCOMPARE(v4.x(), (qreal)-6.0f);
-    QCOMPARE(v4.y(), (qreal)-7.0f);
-    QCOMPARE(v4.z(), (qreal)-8.0f);
-    QCOMPARE(v4.w(), (qreal)-9.0f);
+    QCOMPARE(v4.x(), -6.0f);
+    QCOMPARE(v4.y(), -7.0f);
+    QCOMPARE(v4.z(), -8.0f);
+    QCOMPARE(v4.w(), -9.0f);
 }
 
 void tst_QVectorND::metaTypes()
diff --git a/tests/auto/widgets/graphicsview/qgraphicstransform/qgraphicstransform.pro b/tests/auto/widgets/graphicsview/qgraphicstransform/qgraphicstransform.pro
index 18931f6..c11ca1a 100644
--- a/tests/auto/widgets/graphicsview/qgraphicstransform/qgraphicstransform.pro
+++ b/tests/auto/widgets/graphicsview/qgraphicstransform/qgraphicstransform.pro
@@ -4,5 +4,4 @@ QT += widgets testlib
 SOURCES  += tst_qgraphicstransform.cpp
 CONFIG += parallel_test
 
-linux-*:contains(QT_CONFIG,release):DEFINES+=MAY_HIT_QTBUG_20661
 DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0
diff --git a/tests/auto/widgets/graphicsview/qgraphicstransform/tst_qgraphicstransform.cpp b/tests/auto/widgets/graphicsview/qgraphicstransform/tst_qgraphicstransform.cpp
index 5820598..b0e3d6f 100644
--- a/tests/auto/widgets/graphicsview/qgraphicstransform/tst_qgraphicstransform.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicstransform/tst_qgraphicstransform.cpp
@@ -156,31 +156,39 @@ void tst_QGraphicsTransform::scale()
     QCOMPARE(t3.map(QPointF(4, 5)), QPointF(31 / t3.m33(), 8 / t3.m33()));
 }
 
-// QMatrix4x4 uses float internally, whereas QTransform uses qreal.
-// This can lead to issues with qFuzzyCompare() where it uses double
-// precision to compare values that have no more than float precision
-// after conversion from QMatrix4x4 to QTransform.  The following
-// definitions correct for the difference.
-static inline bool fuzzyCompare(qreal p1, qreal p2)
+// fuzzyCompareNonZero is a very slightly looser version of qFuzzyCompare
+// for use with values that are not very close to zero
+Q_DECL_CONSTEXPR static inline bool fuzzyCompareNonZero(float p1, float p2)
 {
-    // increase delta on small machines using float instead of double
-    if (sizeof(qreal) == sizeof(float))
-        return (qAbs(p1 - p2) <= 0.00003f * qMin(qAbs(p1), qAbs(p2)));
+    return (qAbs(p1 - p2) <= 0.00003f * qMin(qAbs(p1), qAbs(p2)));
+}
+
+// This is a more tolerant version of qFuzzyCompare that also handles the case
+// where one or more of the values being compare are close to zero
+static inline bool fuzzyCompare(float p1, float p2)
+{
+    if (qFuzzyIsNull(p1))
+        return qFuzzyIsNull(p2);
+    else if (qFuzzyIsNull(p2))
+        return false;
     else
-        return (qAbs(p1 - p2) <= 0.00001f * qMin(qAbs(p1), qAbs(p2)));
+        return fuzzyCompareNonZero(p1, p2);
 }
 
-static bool fuzzyCompare(const QTransform& t1, const QTransform& t2)
+// This compares two QTransforms by casting the elements to float. This is
+// necessary here because in this test one of the transforms is created from
+// a QMatrix4x4 which uses float storage.
+static bool fuzzyCompareAsFloat(const QTransform& t1, const QTransform& t2)
 {
-    return fuzzyCompare(t1.m11(), t2.m11()) &&
-           fuzzyCompare(t1.m12(), t2.m12()) &&
-           fuzzyCompare(t1.m13(), t2.m13()) &&
-           fuzzyCompare(t1.m21(), t2.m21()) &&
-           fuzzyCompare(t1.m22(), t2.m22()) &&
-           fuzzyCompare(t1.m23(), t2.m23()) &&
-           fuzzyCompare(t1.m31(), t2.m31()) &&
-           fuzzyCompare(t1.m32(), t2.m32()) &&
-           fuzzyCompare(t1.m33(), t2.m33());
+    return fuzzyCompare(float(t1.m11()), float(t2.m11())) &&
+           fuzzyCompare(float(t1.m12()), float(t2.m12())) &&
+           fuzzyCompare(float(t1.m13()), float(t2.m13())) &&
+           fuzzyCompare(float(t1.m21()), float(t2.m21())) &&
+           fuzzyCompare(float(t1.m22()), float(t2.m22())) &&
+           fuzzyCompare(float(t1.m23()), float(t2.m23())) &&
+           fuzzyCompare(float(t1.m31()), float(t2.m31())) &&
+           fuzzyCompare(float(t1.m32()), float(t2.m32())) &&
+           fuzzyCompare(float(t1.m33()), float(t2.m33()));
 }
 
 static inline bool fuzzyCompare(const QMatrix4x4& m1, const QMatrix4x4& m2)
@@ -221,7 +229,7 @@ void tst_QGraphicsTransform::rotation()
     QTransform res;
     res.rotate(40);
 
-    QVERIFY(fuzzyCompare(transform2D(rotation), res));
+    QVERIFY(fuzzyCompareAsFloat(transform2D(rotation), res));
 
     rotation.setOrigin(QVector3D(10, 10, 0));
     rotation.setAngle(90);
@@ -271,20 +279,14 @@ void tst_QGraphicsTransform::rotation3d()
     else
         expected.rotate(angle, axis);
 
-    QVERIFY(fuzzyCompare(transform2D(rotation), expected));
+    QVERIFY(fuzzyCompareAsFloat(transform2D(rotation), expected));
 
     // Check that "rotation" produces the 4x4 form of the 3x3 matrix.
     // i.e. third row and column are 0 0 1 0.
     t.setToIdentity();
     rotation.applyTo(&t);
     QMatrix4x4 r(expected);
-    if (sizeof(qreal) == sizeof(float) && angle == 268) {
-        // This test fails, on only this angle, when qreal == float
-        // because the deg2rad value in QTransform is not accurate
-        // enough to match what QMatrix4x4 is doing.
-    } else {
-        QVERIFY(fuzzyCompare(t, r));
-    }
+    QVERIFY(fuzzyCompare(t, r));
 
     //now let's check that a null vector will not change the transform
     rotation.setAxis(QVector3D(0, 0, 0));
@@ -358,21 +360,8 @@ void tst_QGraphicsTransform::rotation3dArbitraryAxis()
     exp.rotate(angle, axis);
     QTransform expected = exp.toTransform(1024.0f);
 
-#if defined(MAY_HIT_QTBUG_20661)
-    // These failures possibly relate to the float vs qreal issue mentioned
-    // in the comment above fuzzyCompare().
-    if (sizeof(qreal) == sizeof(double)) {
-        QEXPECT_FAIL("rotation of 120 on (1, 1, 1)",                "QTBUG-20661", Abort);
-        QEXPECT_FAIL("rotation of 240 on (1, 1, 1)",                "QTBUG-20661", Abort);
-        QEXPECT_FAIL("rotation of 120 on (0.01, 0.01, 0.01)",       "QTBUG-20661", Abort);
-        QEXPECT_FAIL("rotation of 240 on (0.01, 0.01, 0.01)",       "QTBUG-20661", Abort);
-        QEXPECT_FAIL("rotation of 120 on (0.0001, 0.0001, 0.0001)", "QTBUG-20661", Abort);
-        QEXPECT_FAIL("rotation of 240 on (0.0001, 0.0001, 0.0001)", "QTBUG-20661", Abort);
-    }
-#endif
-
     QTransform actual = transform2D(rotation);
-    QVERIFY2(fuzzyCompare(actual, expected), qPrintable(
+    QVERIFY2(fuzzyCompareAsFloat(actual, expected), qPrintable(
         QString("\nactual:   %1\n"
                   "expected: %2")
         .arg(toString(actual))
@@ -384,7 +373,13 @@ void tst_QGraphicsTransform::rotation3dArbitraryAxis()
     t.setToIdentity();
     rotation.applyTo(&t);
     QMatrix4x4 r(expected);
-    QVERIFY(qFuzzyCompare(t, r));
+    for (int row = 0; row < 4; ++row) {
+        for (int col = 0; col < 4; ++col) {
+            float a = t(row, col);
+            float b = r(row, col);
+            QVERIFY2(fuzzyCompare(a, b), QString("%1 is not equal to %2").arg(a).arg(b).toLatin1());
+        }
+    }
 }
 
 QString tst_QGraphicsTransform::toString(QTransform const& t)
diff --git a/tests/benchmarks/gui/math3d/qmatrix4x4/tst_qmatrix4x4.cpp b/tests/benchmarks/gui/math3d/qmatrix4x4/tst_qmatrix4x4.cpp
index 9d12d1b..0e97b98 100644
--- a/tests/benchmarks/gui/math3d/qmatrix4x4/tst_qmatrix4x4.cpp
+++ b/tests/benchmarks/gui/math3d/qmatrix4x4/tst_qmatrix4x4.cpp
@@ -96,7 +96,7 @@ private slots:
     void compareRotateAfterScale();
 };
 
-static qreal const generalValues[16] =
+static float const generalValues[16] =
     {1.0f, 2.0f, 3.0f, 4.0f,
      5.0f, 6.0f, 7.0f, 8.0f,
      9.0f, 10.0f, 11.0f, 12.0f,
@@ -171,9 +171,9 @@ void tst_QMatrix4x4::multiplyDirect()
 
     QMatrix4x4 m3;
 
-    const qreal *m1data = m1.constData();
-    const qreal *m2data = m2.constData();
-    qreal *m3data = m3.data();
+    const float *m1data = m1.constData();
+    const float *m2data = m2.constData();
+    float *m3data = m3.data();
 
     QBENCHMARK {
         for (int row = 0; row < 4; ++row) {
@@ -266,9 +266,9 @@ void tst_QMatrix4x4::mapVectorDirect()
 {
     QFETCH(QMatrix4x4, m1);
 
-    const qreal *m1data = m1.constData();
-    qreal v[4] = {10.5f, -2.0f, 3.0f, 1.0f};
-    qreal result[4];
+    const float *m1data = m1.constData();
+    float v[4] = {10.5f, -2.0f, 3.0f, 1.0f};
+    float result[4];
 
     QBENCHMARK {
         for (int row = 0; row < 4; ++row) {
@@ -310,9 +310,9 @@ void tst_QMatrix4x4::compareTranslate()
     QFETCH(bool, useQTransform);
     QFETCH(QVector3D, translation);
 
-    qreal x = translation.x();
-    qreal y = translation.y();
-    qreal z = translation.z();
+    float x = translation.x();
+    float y = translation.y();
+    float z = translation.z();
 
     if (useQTransform) {
         QTransform t;
@@ -343,9 +343,9 @@ void tst_QMatrix4x4::compareTranslateAfterScale()
     QFETCH(bool, useQTransform);
     QFETCH(QVector3D, translation);
 
-    qreal x = translation.x();
-    qreal y = translation.y();
-    qreal z = translation.z();
+    float x = translation.x();
+    float y = translation.y();
+    float z = translation.z();
 
     if (useQTransform) {
         QTransform t;
@@ -379,9 +379,9 @@ void tst_QMatrix4x4::compareTranslateAfterRotate()
     QFETCH(bool, useQTransform);
     QFETCH(QVector3D, translation);
 
-    qreal x = translation.x();
-    qreal y = translation.y();
-    qreal z = translation.z();
+    float x = translation.x();
+    float y = translation.y();
+    float z = translation.z();
 
     if (useQTransform) {
         QTransform t;
@@ -431,9 +431,9 @@ void tst_QMatrix4x4::compareScale()
     QFETCH(bool, useQTransform);
     QFETCH(QVector3D, scale);
 
-    qreal x = scale.x();
-    qreal y = scale.y();
-    qreal z = scale.z();
+    float x = scale.x();
+    float y = scale.y();
+    float z = scale.z();
 
     if (useQTransform) {
         QTransform t;
@@ -464,9 +464,9 @@ void tst_QMatrix4x4::compareScaleAfterTranslate()
     QFETCH(bool, useQTransform);
     QFETCH(QVector3D, scale);
 
-    qreal x = scale.x();
-    qreal y = scale.y();
-    qreal z = scale.z();
+    float x = scale.x();
+    float y = scale.y();
+    float z = scale.z();
 
     if (useQTransform) {
         QTransform t;
@@ -500,9 +500,9 @@ void tst_QMatrix4x4::compareScaleAfterRotate()
     QFETCH(bool, useQTransform);
     QFETCH(QVector3D, scale);
 
-    qreal x = scale.x();
-    qreal y = scale.y();
-    qreal z = scale.z();
+    float x = scale.x();
+    float y = scale.y();
+    float z = scale.z();
 
     if (useQTransform) {
         QTransform t;
@@ -530,65 +530,65 @@ void tst_QMatrix4x4::compareScaleAfterRotate()
 void tst_QMatrix4x4::compareRotate_data()
 {
     QTest::addColumn<bool>("useQTransform");
-    QTest::addColumn<qreal>("angle");
+    QTest::addColumn<float>("angle");
     QTest::addColumn<QVector3D>("rotation");
     QTest::addColumn<int>("axis");
 
     QTest::newRow("QTransform::rotate(0, ZAxis)")
-        << true << qreal(0.0f) << QVector3D(0, 0, 1) << int(Qt::ZAxis);
+        << true << 0.0f << QVector3D(0, 0, 1) << int(Qt::ZAxis);
     QTest::newRow("QMatrix4x4::rotate(0, ZAxis)")
-        << false << qreal(0.0f) << QVector3D(0, 0, 1) << int(Qt::ZAxis);
+        << false << 0.0f << QVector3D(0, 0, 1) << int(Qt::ZAxis);
 
     QTest::newRow("QTransform::rotate(45, ZAxis)")
-        << true << qreal(45.0f) << QVector3D(0, 0, 1) << int(Qt::ZAxis);
+        << true << 45.0f << QVector3D(0, 0, 1) << int(Qt::ZAxis);
     QTest::newRow("QMatrix4x4::rotate(45, ZAxis)")
-        << false << qreal(45.0f) << QVector3D(0, 0, 1) << int(Qt::ZAxis);
+        << false << 45.0f << QVector3D(0, 0, 1) << int(Qt::ZAxis);
 
     QTest::newRow("QTransform::rotate(90, ZAxis)")
-        << true << qreal(90.0f) << QVector3D(0, 0, 1) << int(Qt::ZAxis);
+        << true << 90.0f << QVector3D(0, 0, 1) << int(Qt::ZAxis);
     QTest::newRow("QMatrix4x4::rotate(90, ZAxis)")
-        << false << qreal(90.0f) << QVector3D(0, 0, 1) << int(Qt::ZAxis);
+        << false << 90.0f << QVector3D(0, 0, 1) << int(Qt::ZAxis);
 
     QTest::newRow("QTransform::rotate(0, YAxis)")
-        << true << qreal(0.0f) << QVector3D(0, 1, 0) << int(Qt::YAxis);
+        << true << 0.0f << QVector3D(0, 1, 0) << int(Qt::YAxis);
     QTest::newRow("QMatrix4x4::rotate(0, YAxis)")
-        << false << qreal(0.0f) << QVector3D(0, 1, 0) << int(Qt::YAxis);
+        << false << 0.0f << QVector3D(0, 1, 0) << int(Qt::YAxis);
 
     QTest::newRow("QTransform::rotate(45, YAxis)")
-        << true << qreal(45.0f) << QVector3D(0, 1, 0) << int(Qt::YAxis);
+        << true << 45.0f << QVector3D(0, 1, 0) << int(Qt::YAxis);
     QTest::newRow("QMatrix4x4::rotate(45, YAxis)")
-        << false << qreal(45.0f) << QVector3D(0, 1, 0) << int(Qt::YAxis);
+        << false << 45.0f << QVector3D(0, 1, 0) << int(Qt::YAxis);
 
     QTest::newRow("QTransform::rotate(90, YAxis)")
-        << true << qreal(90.0f) << QVector3D(0, 1, 0) << int(Qt::YAxis);
+        << true << 90.0f << QVector3D(0, 1, 0) << int(Qt::YAxis);
     QTest::newRow("QMatrix4x4::rotate(90, YAxis)")
-        << false << qreal(90.0f) << QVector3D(0, 1, 0) << int(Qt::YAxis);
+        << false << 90.0f << QVector3D(0, 1, 0) << int(Qt::YAxis);
 
     QTest::newRow("QTransform::rotate(0, XAxis)")
-        << true << qreal(0.0f) << QVector3D(0, 1, 0) << int(Qt::XAxis);
+        << true << 0.0f << QVector3D(0, 1, 0) << int(Qt::XAxis);
     QTest::newRow("QMatrix4x4::rotate(0, XAxis)")
-        << false << qreal(0.0f) << QVector3D(0, 1, 0) << int(Qt::XAxis);
+        << false << 0.0f << QVector3D(0, 1, 0) << int(Qt::XAxis);
 
     QTest::newRow("QTransform::rotate(45, XAxis)")
-        << true << qreal(45.0f) << QVector3D(1, 0, 0) << int(Qt::XAxis);
+        << true << 45.0f << QVector3D(1, 0, 0) << int(Qt::XAxis);
     QTest::newRow("QMatrix4x4::rotate(45, XAxis)")
-        << false << qreal(45.0f) << QVector3D(1, 0, 0) << int(Qt::XAxis);
+        << false << 45.0f << QVector3D(1, 0, 0) << int(Qt::XAxis);
 
     QTest::newRow("QTransform::rotate(90, XAxis)")
-        << true << qreal(90.0f) << QVector3D(1, 0, 0) << int(Qt::XAxis);
+        << true << 90.0f << QVector3D(1, 0, 0) << int(Qt::XAxis);
     QTest::newRow("QMatrix4x4::rotate(90, XAxis)")
-        << false << qreal(90.0f) << QVector3D(1, 0, 0) << int(Qt::XAxis);
+        << false << 90.0f << QVector3D(1, 0, 0) << int(Qt::XAxis);
 }
 void tst_QMatrix4x4::compareRotate()
 {
     QFETCH(bool, useQTransform);
-    QFETCH(qreal, angle);
+    QFETCH(float, angle);
     QFETCH(QVector3D, rotation);
     QFETCH(int, axis);
 
-    qreal x = rotation.x();
-    qreal y = rotation.y();
-    qreal z = rotation.z();
+    float x = rotation.x();
+    float y = rotation.y();
+    float z = rotation.z();
 
     if (useQTransform) {
         QTransform t;
@@ -612,13 +612,13 @@ void tst_QMatrix4x4::compareRotateAfterTranslate_data()
 void tst_QMatrix4x4::compareRotateAfterTranslate()
 {
     QFETCH(bool, useQTransform);
-    QFETCH(qreal, angle);
+    QFETCH(float, angle);
     QFETCH(QVector3D, rotation);
     QFETCH(int, axis);
 
-    qreal x = rotation.x();
-    qreal y = rotation.y();
-    qreal z = rotation.z();
+    float x = rotation.x();
+    float y = rotation.y();
+    float z = rotation.z();
 
     if (useQTransform) {
         QTransform t;
@@ -644,13 +644,13 @@ void tst_QMatrix4x4::compareRotateAfterScale_data()
 void tst_QMatrix4x4::compareRotateAfterScale()
 {
     QFETCH(bool, useQTransform);
-    QFETCH(qreal, angle);
+    QFETCH(float, angle);
     QFETCH(QVector3D, rotation);
     QFETCH(int, axis);
 
-    qreal x = rotation.x();
-    qreal y = rotation.y();
-    qreal z = rotation.z();
+    float x = rotation.x();
+    float y = rotation.y();
+    float z = rotation.z();
 
     if (useQTransform) {
         QTransform t;
diff --git a/tests/benchmarks/gui/math3d/qquaternion/tst_qquaternion.cpp b/tests/benchmarks/gui/math3d/qquaternion/tst_qquaternion.cpp
index 6ab473e..e47fdcc 100644
--- a/tests/benchmarks/gui/math3d/qquaternion/tst_qquaternion.cpp
+++ b/tests/benchmarks/gui/math3d/qquaternion/tst_qquaternion.cpp
@@ -77,38 +77,38 @@ void tst_QQuaternion::cleanup()
 
 void tst_QQuaternion::multiply_data()
 {
-    QTest::addColumn<qreal>("x1");
-    QTest::addColumn<qreal>("y1");
-    QTest::addColumn<qreal>("z1");
-    QTest::addColumn<qreal>("w1");
-    QTest::addColumn<qreal>("x2");
-    QTest::addColumn<qreal>("y2");
-    QTest::addColumn<qreal>("z2");
-    QTest::addColumn<qreal>("w2");
+    QTest::addColumn<float>("x1");
+    QTest::addColumn<float>("y1");
+    QTest::addColumn<float>("z1");
+    QTest::addColumn<float>("w1");
+    QTest::addColumn<float>("x2");
+    QTest::addColumn<float>("y2");
+    QTest::addColumn<float>("z2");
+    QTest::addColumn<float>("w2");
 
     QTest::newRow("null")
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f
-        << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f << (qreal)0.0f;
+        << 0.0f << 0.0f << 0.0f << 0.0f
+        << 0.0f << 0.0f << 0.0f << 0.0f;
 
     QTest::newRow("unitvec")
-        << (qreal)1.0f << (qreal)0.0f << (qreal)0.0f << (qreal)1.0f
-        << (qreal)0.0f << (qreal)1.0f << (qreal)0.0f << (qreal)1.0f;
+        << 1.0f << 0.0f << 0.0f << 1.0f
+        << 0.0f << 1.0f << 0.0f << 1.0f;
 
     QTest::newRow("complex")
-        << (qreal)1.0f << (qreal)2.0f << (qreal)3.0f << (qreal)7.0f
-        << (qreal)4.0f << (qreal)5.0f << (qreal)6.0f << (qreal)8.0f;
+        << 1.0f << 2.0f << 3.0f << 7.0f
+        << 4.0f << 5.0f << 6.0f << 8.0f;
 }
 
 void tst_QQuaternion::multiply()
 {
-    QFETCH(qreal, x1);
-    QFETCH(qreal, y1);
-    QFETCH(qreal, z1);
-    QFETCH(qreal, w1);
-    QFETCH(qreal, x2);
-    QFETCH(qreal, y2);
-    QFETCH(qreal, z2);
-    QFETCH(qreal, w2);
+    QFETCH(float, x1);
+    QFETCH(float, y1);
+    QFETCH(float, z1);
+    QFETCH(float, w1);
+    QFETCH(float, x2);
+    QFETCH(float, y2);
+    QFETCH(float, z2);
+    QFETCH(float, w2);
 
     QQuaternion q1(w1, x1, y1, z1);
     QQuaternion q2(w2, x2, y2, z2);